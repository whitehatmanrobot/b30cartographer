Impersonating ,
			t_OldContext ,
			t_OldSecurity ,
			t_IsProxy ,
			t_Interface ,
			t_Revert ,
			t_Proxy
		) ;

		if ( SUCCEEDED ( t_Result ) )
		{
			t_Result = t_Interface->CreateClassEnumAsync (

				a_Superclass, 
				a_Flags, 
				a_Context,
				a_Sink
			) ;

			End_IWbemServices (

				t_Impersonating ,
				t_OldContext ,
				t_OldSecurity ,
				t_IsProxy ,
				t_Interface ,
				t_Revert ,
				t_Proxy
			) ;
		}
	}

	InterlockedDecrement ( & m_InProgress ) ;

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_IWbemServices_RestrictingInterceptor :: PutInstance (

    IWbemClassObject *a_Instance,
    long a_Flags,
    IWbemContext *a_Context,
	IWbemCallResult **a_CallResult
) 
{
	HRESULT t_Result = S_OK ;

	InterlockedIncrement ( & m_InProgress ) ;

	if ( m_GateClosed == 1 )
	{
		t_Result = WBEM_E_SHUTTING_DOWN ;
	}
	else
	{
		BOOL t_Impersonating ;
		IUnknown *t_OldContext ;
		IServerSecurity *t_OldSecurity ;
		BOOL t_IsProxy ;
		IWbemServices *t_Interface ;
		BOOL t_Revert ;
		IUnknown *t_Proxy ;

		t_Result = Begin_IWbemServices (

			t_Impersonating ,
			t_OldContext ,
			t_OldSecurity ,
			t_IsProxy ,
			t_Interface ,
			t_Revert ,
			t_Proxy
		) ;

		if ( SUCCEEDED ( t_Result ) )
		{
			t_Result = t_Interface->PutInstance (

				a_Instance,
				a_Flags,
				a_Context,
				a_CallResult
			) ;

			End_IWbemServices (

				t_Impersonating ,
				t_OldContext ,
				t_OldSecurity ,
				t_IsProxy ,
				t_Interface ,
				t_Revert ,
				t_Proxy
			) ;
		}
	}

	InterlockedDecrement ( & m_InProgress ) ;

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_IWbemServices_RestrictingInterceptor :: PutInstanceAsync ( 
		
	IWbemClassObject *a_Instance, 
	long a_Flags, 
    IWbemContext *a_Context,
	IWbemObjectSink *a_Sink
) 
{
	HRESULT t_Result = S_OK ;

	InterlockedIncrement ( & m_InProgress ) ;

	if ( m_GateClosed == 1 )
	{
		t_Result = WBEM_E_SHUTTING_DOWN ;
	}
	else
	{
		BOOL t_Impersonating ;
		IUnknown *t_OldContext ;
		IServerSecurity *t_OldSecurity ;
		BOOL t_IsProxy ;
		IWbemServices *t_Interface ;
		BOOL t_Revert ;
		IUnknown *t_Proxy ;

		t_Result = Begin_IWbemServices (

			t_Impersonating ,
			t_OldContext ,
			t_OldSecurity ,
			t_IsProxy ,
			t_Interface ,
			t_Revert ,
			t_Proxy
		) ;

		if ( SUCCEEDED ( t_Result ) )
		{
			t_Result = t_Interface->PutInstanceAsync (

				a_Instance, 
				a_Flags, 
				a_Context,
				a_Sink
			) ;

			End_IWbemServices (

				t_Impersonating ,
				t_OldContext ,
				t_OldSecurity ,
				t_IsProxy ,
				t_Interface ,
				t_Revert ,
				t_Proxy
			) ;
		}
	}

	InterlockedDecrement ( & m_InProgress ) ;

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_IWbemServices_RestrictingInterceptor :: DeleteInstance ( 

	const BSTR a_ObjectPath,
    long a_Flags,
    IWbemContext *a_Context,
    IWbemCallResult **a_CallResult
)
{
	HRESULT t_Result = S_OK ;

	InterlockedIncrement ( & m_InProgress ) ;

	if ( m_GateClosed == 1 )
	{
		t_Result = WBEM_E_SHUTTING_DOWN ;
	}
	else
	{
		BOOL t_Impersonating ;
		IUnknown *t_OldContext ;
		IServerSecurity *t_OldSecurity ;
		BOOL t_IsProxy ;
		IWbemServices *t_Interface ;
		BOOL t_Revert ;
		IUnknown *t_Proxy ;

		t_Result = Begin_IWbemServices (

			t_Impersonating ,
			t_OldContext ,
			t_OldSecurity ,
			t_IsProxy ,
			t_Interface ,
			t_Revert ,
			t_Proxy
		) ;

		if ( SUCCEEDED ( t_Result ) )
		{
			t_Result = t_Interface->DeleteInstance (

				a_ObjectPath,
				a_Flags,
				a_Context,
				a_CallResult
			) ;

			End_IWbemServices (

				t_Impersonating ,
				t_OldContext ,
				t_OldSecurity ,
				t_IsProxy ,
				t_Interface ,
				t_Revert ,
				t_Proxy
			) ;
		}
	}

	InterlockedDecrement ( & m_InProgress ) ;

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/
        
HRESULT CInterceptor_IWbemServices_RestrictingInterceptor :: DeleteInstanceAsync (
 
	const BSTR a_ObjectPath,
    long a_Flags,
    IWbemContext *a_Context,
    IWbemObjectSink *a_Sink	
)
{
	HRESULT t_Result = S_OK ;

	InterlockedIncrement ( & m_InProgress ) ;

	if ( m_GateClosed == 1 )
	{
		t_Result = WBEM_E_SHUTTING_DOWN ;
	}
	else
	{
		BOOL t_Impersonating ;
		IUnknown *t_OldContext ;
		IServerSecurity *t_OldSecurity ;
		BOOL t_IsProxy ;
		IWbemServices *t_Interface ;
		BOOL t_Revert ;
		IUnknown *t_Proxy ;

		t_Result = Begin_IWbemServices (

			t_Impersonating ,
			t_OldContext ,
			t_OldSecurity ,
			t_IsProxy ,
			t_Interface ,
			t_Revert ,
			t_Proxy
		) ;

		if ( SUCCEEDED ( t_Result ) )
		{
			t_Result = t_Interface->DeleteInstanceAsync (

				a_ObjectPath,
				a_Flags,
				a_Context,
				a_Sink
			) ;

			End_IWbemServices (

				t_Impersonating ,
				t_OldContext ,
				t_OldSecurity ,
				t_IsProxy ,
				t_Interface ,
				t_Revert ,
				t_Proxy
			) ;
		}
	}

	InterlockedDecrement ( & m_InProgress ) ;

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_IWbemServices_RestrictingInterceptor :: CreateInstanceEnum ( 

	const BSTR a_Class, 
	long a_Flags, 
	IWbemContext *a_Context, 
	IEnumWbemClassObject **a_Enum
)
{
	HRESULT t_Result = S_OK ;

	InterlockedIncrement ( & m_InProgress ) ;

	if ( m_GateClosed == 1 )
	{
		t_Result = WBEM_E_SHUTTING_DOWN ;
	}
	else
	{
		BOOL t_Impersonating ;
		IUnknown *t_OldContext ;
		IServerSecurity *t_OldSecurity ;
		BOOL t_IsProxy ;
		IWbemServices *t_Interface ;
		BOOL t_Revert ;
		IUnknown *t_Proxy ;

		t_Result = Begin_IWbemServices (

			t_Impersonating ,
			t_OldContext ,
			t_OldSecurity ,
			t_IsProxy ,
			t_Interface ,
			t_Revert ,
			t_Proxy
		) ;

		if ( SUCCEEDED ( t_Result ) )
		{
			t_Result = t_Interface->CreateInstanceEnum (

				a_Class, 
				a_Flags, 
				a_Context, 
				a_Enum
			) ;

			End_IWbemServices (

				t_Impersonating ,
				t_OldContext ,
				t_OldSecurity ,
				t_IsProxy ,
				t_Interface ,
				t_Revert ,
				t_Proxy
			) ;
		}
	}

	InterlockedDecrement ( & m_InProgress ) ;

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_IWbemServices_RestrictingInterceptor :: CreateInstanceEnumAsync (

 	const BSTR a_Class, 
	long a_Flags, 
	IWbemContext *a_Context,
	IWbemObjectSink *a_Sink

) 
{
	HRESULT t_Result = S_OK ;

	InterlockedIncrement ( & m_InProgress ) ;

	if ( m_GateClosed == 1 )
	{
		t_Result = WBEM_E_SHUTTING_DOWN ;
	}
	else
	{
		BOOL t_Impersonating ;
		IUnknown *t_OldContext ;
		IServerSecurity *t_OldSecurity ;
		BOOL t_IsProxy ;
		IWbemServices *t_Interface ;
		BOOL t_Revert ;
		IUnknown *t_Proxy ;

		t_Result = Begin_IWbemServices (

			t_Impersonating ,
			t_OldContext ,
			t_OldSecurity ,
			t_IsProxy ,
			t_Interface ,
			t_Revert ,
			t_Proxy
		) ;

		if ( SUCCEEDED ( t_Result ) )
		{
			t_Result = t_Interface->CreateInstanceEnumAsync (

 				a_Class, 
				a_Flags, 
				a_Context,
				a_Sink
			) ;

			End_IWbemServices (

				t_Impersonating ,
				t_OldContext ,
				t_OldSecurity ,
				t_IsProxy ,
				t_Interface ,
				t_Revert ,
				t_Proxy
			) ;
		}
	}

	InterlockedDecrement ( & m_InProgress ) ;

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_IWbemServices_RestrictingInterceptor :: ExecQuery ( 

	const BSTR a_QueryLanguage, 
	const BSTR a_Query, 
	long a_Flags, 
	IWbemContext *a_Context,
	IEnumWbemClassObject **a_Enum
)
{
	HRESULT t_Result = S_OK ;

	InterlockedIncrement ( & m_InProgress ) ;

	if ( m_GateClosed == 1 )
	{
		t_Result = WBEM_E_SHUTTING_DOWN ;
	}
	else
	{
		BOOL t_Impersonating ;
		IUnknown *t_OldContext ;
		IServerSecurity *t_OldSecurity ;
		BOOL t_IsProxy ;
		IWbemServices *t_Interface ;
		BOOL t_Revert ;
		IUnknown *t_Proxy ;

		t_Result = Begin_IWbemServices (

			t_Impersonating ,
			t_OldContext ,
			t_OldSecurity ,
			t_IsProxy ,
			t_Interface ,
			t_Revert ,
			t_Proxy
		) ;

		if ( SUCCEEDED ( t_Result ) )
		{
			t_Result = t_Interface->ExecQuery (

				a_QueryLanguage, 
				a_Query, 
				a_Flags, 
				a_Context,
				a_Enum
			) ;

			End_IWbemServices (

				t_Impersonating ,
				t_OldContext ,
				t_OldSecurity ,
				t_IsProxy ,
				t_Interface ,
				t_Revert ,
				t_Proxy
			) ;
		}
	}

	InterlockedDecrement ( & m_InProgress ) ;

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_IWbemServices_RestrictingInterceptor :: ExecQueryAsync ( 
		
	const BSTR a_QueryLanguage, 
	const BSTR a_Query, 
	long a_Flags, 
	IWbemContext *a_Context ,
	IWbemObjectSink *a_Sink
) 
{
	HRESULT t_Result = S_OK ;

	InterlockedIncrement ( & m_InProgress ) ;

	if ( m_GateClosed == 1 )
	{
		t_Result = WBEM_E_SHUTTING_DOWN ;
	}
	else
	{
		BOOL t_Impersonating ;
		IUnknown *t_OldContext ;
		IServerSecurity *t_OldSecurity ;
		BOOL t_IsProxy ;
		IWbemServices *t_Interface ;
		BOOL t_Revert ;
		IUnknown *t_Proxy ;

		t_Result = Begin_IWbemServices (

			t_Impersonating ,
			t_OldContext ,
			t_OldSecurity ,
			t_IsProxy ,
			t_Interface ,
			t_Revert ,
			t_Proxy
		) ;

		if ( SUCCEEDED ( t_Result ) )
		{
			t_Result = t_Interface->ExecQueryAsync (

				a_QueryLanguage, 
				a_Query, 
				a_Flags, 
				a_Context,
				a_Sink
			) ;

			End_IWbemServices (

				t_Impersonating ,
				t_OldContext ,
				t_OldSecurity ,
				t_IsProxy ,
				t_Interface ,
				t_Revert ,
				t_Proxy
			) ;
		}
	}

	InterlockedDecrement ( & m_InProgress ) ;

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_IWbemServices_RestrictingInterceptor :: ExecNotificationQuery ( 

	const BSTR a_QueryLanguage,
    const BSTR a_Query,
    long a_Flags,
    IWbemContext *a_Context,
    IEnumWbemClassObject **a_Enum
)
{
	HRESULT t_Result = S_OK ;

	InterlockedIncrement ( & m_InProgress ) ;

	if ( m_GateClosed == 1 )
	{
		t_Result = WBEM_E_SHUTTING_DOWN ;
	}
	else
	{
		BOOL t_Impersonating ;
		IUnknown *t_OldContext ;
		IServerSecurity *t_OldSecurity ;
		BOOL t_IsProxy ;
		IWbemServices *t_Interface ;
		BOOL t_Revert ;
		IUnknown *t_Proxy ;

		t_Result = Begin_IWbemServices (

			t_Impersonating ,
			t_OldContext ,
			t_OldSecurity ,
			t_IsProxy ,
			t_Interface ,
			t_Revert ,
			t_Proxy
		) ;

		if ( SUCCEEDED ( t_Result ) )
		{
			t_Result = t_Interface->ExecNotificationQuery (

				a_QueryLanguage,
				a_Query,
				a_Flags,
				a_Context,
				a_Enum
			) ;

			End_IWbemServices (

				t_Impersonating ,
				t_OldContext ,
				t_OldSecurity ,
				t_IsProxy ,
				t_Interface ,
				t_Revert ,
				t_Proxy
			) ;
		}
	}

	InterlockedDecrement ( & m_InProgress ) ;

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/
        
HRESULT CInterceptor_IWbemServices_RestrictingInterceptor :: ExecNotificationQueryAsync ( 
            
	const BSTR a_QueryLanguage,
    const BSTR a_Query,
    long a_Flags,
    IWbemContext *a_Context,
    IWbemObjectSink *a_Sink
)
{
	HRESULT t_Result = S_OK ;

	InterlockedIncrement ( & m_InProgress ) ;

	if ( m_GateClosed == 1 )
	{
		t_Result = WBEM_E_SHUTTING_DOWN ;
	}
	else
	{
		BOOL t_Impersonating ;
		IUnknown *t_OldContext ;
		IServerSecurity *t_OldSecurity ;
		BOOL t_IsProxy ;
		IWbemServices *t_Interface ;
		BOOL t_Revert ;
		IUnknown *t_Proxy ;

		t_Result = Begin_IWbemServices (

			t_Impersonating ,
			t_OldContext ,
			t_OldSecurity ,
			t_IsProxy ,
			t_Interface ,
			t_Revert ,
			t_Proxy
		) ;

		if ( SUCCEEDED ( t_Result ) )
		{
			t_Result = t_Interface->ExecNotificationQueryAsync (

				a_QueryLanguage,
				a_Query,
				a_Flags,
				a_Context,
				a_Sink
			) ;

			End_IWbemServices (

				t_Impersonating ,
				t_OldContext ,
				t_OldSecurity ,
				t_IsProxy ,
				t_Interface ,
				t_Revert ,
				t_Proxy
			) ;
		}
	}

	InterlockedDecrement ( & m_InProgress ) ;

	return t_Result ;
}       

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT STDMETHODCALLTYPE CInterceptor_IWbemServices_RestrictingInterceptor :: ExecMethod ( 

	const BSTR a_ObjectPath,
    const BSTR a_MethodName,
    long a_Flags,
    IWbemContext *a_Context,
    IWbemClassObject *a_InParams,
    IWbemClassObject **a_OutParams,
    IWbemCallResult **a_CallResult
)
{
	HRESULT t_Result = S_OK ;

	InterlockedIncrement ( & m_InProgress ) ;

	if ( m_GateClosed == 1 )
	{
		t_Result = WBEM_E_SHUTTING_DOWN ;
	}
	else
	{
		BOOL t_Impersonating ;
		IUnknown *t_OldContext ;
		IServerSecurity *t_OldSecurity ;
		BOOL t_IsProxy ;
		IWbemServices *t_Interface ;
		BOOL t_Revert ;
		IUnknown *t_Proxy ;

		t_Result = Begin_IWbemServices (

			t_Impersonating ,
			t_OldContext ,
			t_OldSecurity ,
			t_IsProxy ,
			t_Interface ,
			t_Revert ,
			t_Proxy
		) ;

		if ( SUCCEEDED ( t_Result ) )
		{
			t_Result = t_Interface->ExecMethod (

				a_ObjectPath,
				a_MethodName,
				a_Flags,
				a_Context,
				a_InParams,
				a_OutParams,
				a_CallResult
			) ;

			End_IWbemServices (

				t_Impersonating ,
				t_OldContext ,
				t_OldSecurity ,
				t_IsProxy ,
				t_Interface ,
				t_Revert ,
				t_Proxy
			) ;
		}
	}

	InterlockedDecrement ( & m_InProgress ) ;

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT STDMETHODCALLTYPE CInterceptor_IWbemServices_RestrictingInterceptor :: ExecMethodAsync ( 

    const BSTR a_ObjectPath,
    const BSTR a_MethodName,
    long a_Flags,
    IWbemContext *a_Context,
    IWbemClassObject *a_InParams,
	IWbemObjectSink *a_Sink
) 
{
	HRESULT t_Result = S_OK ;

	InterlockedIncrement ( & m_InProgress ) ;

	if ( m_GateClosed == 1 )
	{
		t_Result = WBEM_E_SHUTTING_DOWN ;
	}
	else
	{
		BOOL t_Impersonating ;
		IUnknown *t_OldContext ;
		IServerSecurity *t_OldSecurity ;
		BOOL t_IsProxy ;
		IWbemServices *t_Interface ;
		BOOL t_Revert ;
		IUnknown *t_Proxy ;

		t_Result = Begin_IWbemServices (

			t_Impersonating ,
			t_OldContext ,
			t_OldSecurity ,
			t_IsProxy ,
			t_Interface ,
			t_Revert ,
			t_Proxy
		) ;

		if ( SUCCEEDED ( t_Result ) )
		{
			t_Result = t_Interface->ExecMethodAsync (

				a_ObjectPath,
				a_MethodName,
				a_Flags,
				a_Context,
				a_InParams,
				a_Sink
			) ;

			End_IWbemServices (

				t_Impersonating ,
				t_OldContext ,
				t_OldSecurity ,
				t_IsProxy ,
				t_Interface ,
				t_Revert ,
				t_Proxy
			) ;
		}
	}

	InterlockedDecrement ( & m_InProgress ) ;

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_IWbemServices_RestrictingInterceptor :: ServiceInitialize ()
{
	WmiStatusCode t_StatusCode = m_ProxyContainer.Initialize () ;
	if ( t_StatusCode == e_StatusCode_Success )
	{
		return S_OK ;
	}
	else
	{
		return WBEM_E_OUT_OF_MEMORY ;
	}
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_IWbemServices_RestrictingInterceptor :: Shutdown (

	LONG a_Flags ,
	ULONG a_MaxMilliSeconds ,
	IWbemContext *a_Context
)
{
	HRESULT t_Result = S_OK ;

	InterlockedIncrement ( & m_GateClosed ) ;

	bool t_Acquired = false ;
	while ( ! t_Acquired )
	{
		if ( m_InProgress == 0 )
		{
			t_Acquired = true ;
			break ;
		}

		if ( SwitchToThread () == FALSE ) 
		{
		}
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_IWbemServices_RestrictingInterceptor :: AddObjectToRefresher (

	WBEM_REFRESHER_ID *a_RefresherId ,
	LPCWSTR a_Path,
	long a_Flags ,
	IWbemContext *a_Context,
	DWORD a_ClientRefresherVersion ,
	WBEM_REFRESH_INFO *a_Information ,
	DWORD *a_ServerRefresherVersion
)
{
	HRESULT t_Result = S_OK ;

	InterlockedIncrement ( & m_InProgress ) ;

	if ( m_GateClosed == 1 )
	{
		t_Result = WBEM_E_SHUTTING_DOWN ;
	}
	else
	{
		if ( m_Core_IWbemRefreshingServices )
		{
			BOOL t_Impersonating ;
			IUnknown *t_OldContext ;
			IServerSecurity *t_OldSecurity ;
			BOOL t_IsProxy ;
			IWbemRefreshingServices *t_Interface ;
			BOOL t_Revert ;
			IUnknown *t_Proxy ;

			t_Result = Begin_IWbemRefreshingServices (

				t_Impersonating ,
				t_OldContext ,
				t_OldSecurity ,
				t_IsProxy ,
				t_Interface ,
				t_Revert ,
				t_Proxy
			) ;

			if ( SUCCEEDED ( t_Result ) )
			{
				t_Result = t_Interface->AddObjectToRefresher (

					a_RefresherId ,
					a_Path,
					a_Flags ,
					a_Context,
					a_ClientRefresherVersion ,
					a_Information ,
					a_ServerRefresherVersion
				) ;

				End_IWbemRefreshingServices (

					t_Impersonating ,
					t_OldContext ,
					t_OldSecurity ,
					t_IsProxy ,
					t_Interface ,
					t_Revert ,
					t_Proxy
				) ;
			}
		}
		else
		{
			t_Result = WBEM_E_NOT_AVAILABLE ;
		}
	}

	InterlockedDecrement ( & m_InProgress ) ;

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_IWbemServices_RestrictingInterceptor :: AddObjectToRefresherByTemplate (

	WBEM_REFRESHER_ID *a_RefresherId ,
	IWbemClassObject *a_Template ,
	long a_Flags ,
	IWbemContext *a_Context ,
	DWORD a_ClientRefresherVersion ,
	WBEM_REFRESH_INFO *a_Information ,
	DWORD *a_ServerRefresherVersion
)
{
	HRESULT t_Result = S_OK ;

	InterlockedIncrement ( & m_InProgress ) ;

	if ( m_GateClosed == 1 )
	{
		t_Result = WBEM_E_SHUTTING_DOWN ;
	}
	else
	{
		if ( m_Core_IWbemRefreshingServices )
		{
			BOOL t_Impersonating ;
			IUnknown *t_OldContext ;
			IServerSecurity *t_OldSecurity ;
			BOOL t_IsProxy ;
			IWbemRefreshingServices *t_Interface ;
			BOOL t_Revert ;
			IUnknown *t_Proxy ;

			t_Result = Begin_IWbemRefreshingServices (

				t_Impersonating ,
				t_OldContext ,
				t_OldSecurity ,
				t_IsProxy ,
				t_Interface ,
				t_Revert ,
				t_Proxy
			) ;

			if ( SUCCEEDED ( t_Result ) )
			{
				t_Result = t_Interface->AddObjectToRefresherByTemplate (

					a_RefresherId ,
					a_Template ,
					a_Flags ,
					a_Context ,
					a_ClientRefresherVersion ,
					a_Information ,
					a_ServerRefresherVersion
				) ;

				End_IWbemRefreshingServices (

					t_Impersonating ,
					t_OldContext ,
					t_OldSecurity ,
					t_IsProxy ,
					t_Interface ,
					t_Revert ,
					t_Proxy
				) ;
			}
			else
			{
				t_Result = WBEM_E_NOT_AVAILABLE ;
			}
		}
	}

	InterlockedDecrement ( & m_InProgress ) ;

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_IWbemServices_RestrictingInterceptor :: AddEnumToRefresher (

	WBEM_REFRESHER_ID *a_RefresherId ,
	LPCWSTR a_Class ,
	long a_Flags ,
	IWbemContext *a_Context,
	DWORD a_ClientRefresherVersion ,
	WBEM_REFRESH_INFO *a_Information ,
	DWORD *a_ServerRefresherVersion
)
{
	HRESULT t_Result = S_OK ;

	InterlockedIncrement ( & m_InProgress ) ;

	if ( m_GateClosed == 1 )
	{
		t_Result = WBEM_E_SHUTTING_DOWN ;
	}
	else
	{
		if ( m_Core_IWbemRefreshingServices )
		{
			BOOL t_Impersonating ;
			IUnknown *t_OldContext ;
			IServerSecurity *t_OldSecurity ;
			BOOL t_IsProxy ;
			IWbemRefreshingServices *t_Interface ;
			BOOL t_Revert ;
			IUnknown *t_Proxy ;

			t_Result = Begin_IWbemRefreshingServices (

				t_Impersonating ,
				t_OldContext ,
				t_OldSecurity ,
				t_IsProxy ,
				t_Interface ,
				t_Revert ,
				t_Proxy
			) ;

			if ( SUCCEEDED ( t_Result ) )
			{
				t_Result = t_Interface->AddEnumToRefresher (

					a_RefresherId ,
					a_Class ,
					a_Flags ,
					a_Context,
					a_ClientRefresherVersion ,
					a_Information ,
					a_ServerRefresherVersion
				) ;

				End_IWbemRefreshingServices (

					t_Impersonating ,
					t_OldContext ,
					t_OldSecurity ,
					t_IsProxy ,
					t_Interface ,
					t_Revert ,
					t_Proxy
				) ;
			}
		}
		else
		{
			t_Result = WBEM_E_NOT_AVAILABLE ;
		}
	}

	InterlockedDecrement ( & m_InProgress ) ;

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_IWbemServices_RestrictingInterceptor :: RemoveObjectFromRefresher (

	WBEM_REFRESHER_ID *a_RefresherId ,
	long a_Id ,
	long a_Flags ,
	DWORD a_ClientRefresherVersion ,
	DWORD *a_ServerRefresherVersion
)
{
	HRESULT t_Result = S_OK ;

	InterlockedIncrement ( & m_InProgress ) ;

	if ( m_GateClosed == 1 )
	{
		t_Result = WBEM_E_SHUTTING_DOWN ;
	}
	else
	{
		if ( m_Core_IWbemRefreshingServices )
		{
			BOOL t_Impersonating ;
			IUnknown *t_OldContext ;
			IServerSecurity *t_OldSecurity ;
			BOOL t_IsProxy ;
			IWbemRefreshingServices *t_Interface ;
			BOOL t_Revert ;
			IUnknown *t_Proxy ;

			t_Result = Begin_IWbemRefreshingServices (

				t_Impersonating ,
				t_OldContext ,
				t_OldSecurity ,
				t_IsProxy ,
				t_Interface ,
				t_Revert ,
				t_Proxy
			) ;

			if ( SUCCEEDED ( t_Result ) )
			{
				t_Result = t_Interface->RemoveObjectFromRefresher (

					a_RefresherId ,
					a_Id ,
					a_Flags ,
					a_ClientRefresherVersion ,
					a_ServerRefresherVersion
				) ;

				End_IWbemRefreshingServices (

					t_Impersonating ,
					t_OldContext ,
					t_OldSecurity ,
					t_IsProxy ,
					t_Interface ,
					t_Revert ,
					t_Proxy
				) ;
			}
		}
		else
		{
			t_Result = WBEM_E_NOT_AVAILABLE ;
		}
	}

	InterlockedDecrement ( & m_InProgress ) ;

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_IWbemServices_RestrictingInterceptor :: GetRemoteRefresher (

	WBEM_REFRESHER_ID *a_RefresherId ,
	long a_Flags ,
	DWORD a_ClientRefresherVersion ,
	IWbemRemoteRefresher **a_RemoteRefresher ,
	GUID *a_Guid ,
	DWORD *a_ServerRefresherVersion
)
{
	HRESULT t_Result = S_OK ;

	InterlockedIncrement ( & m_InProgress ) ;

	if ( m_GateClosed == 1 )
	{
		t_Result = WBEM_E_SHUTTING_DOWN ;
	}
	else
	{
		if ( m_Core_IWbemRefreshingServices )
		{
			BOOL t_Impersonating ;
			IUnknown *t_OldContext ;
			IServerSecurity *t_OldSecurity ;
			BOOL t_IsProxy ;
			IWbemRefreshingServices *t_Interface ;
			BOOL t_Revert ;
			IUnknown *t_Proxy ;

			t_Result = Begin_IWbemRefreshingServices (

				t_Impersonating ,
				t_OldContext ,
				t_OldSecurity ,
				t_IsProxy ,
				t_Interface ,
				t_Revert ,
				t_Proxy
			) ;

			if ( SUCCEEDED ( t_Result ) )
			{
				t_Result = t_Interface->GetRemoteRefresher (

					a_RefresherId ,
					a_Flags ,
					a_ClientRefresherVersion ,
					a_RemoteRefresher ,
					a_Guid ,
					a_ServerRefresherVersion
				) ;

				End_IWbemRefreshingServices (

					t_Impersonating ,
					t_OldContext ,
					t_OldSecurity ,
					t_IsProxy ,
					t_Interface ,
					t_Revert ,
					t_Proxy
				) ;
			}
		}
		else
		{
			t_Result = WBEM_E_NOT_AVAILABLE ;
		}
	}

	InterlockedDecrement ( & m_InProgress ) ;

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_IWbemServices_RestrictingInterceptor :: ReconnectRemoteRefresher (

	WBEM_REFRESHER_ID *a_RefresherId,
	long a_Flags,
	long a_NumberOfObjects,
	DWORD a_ClientRefresherVersion ,
	WBEM_RECONNECT_INFO *a_ReconnectInformation ,
	WBEM_RECONNECT_RESULTS *a_ReconnectResults ,
	DWORD *a_ServerRefresherVersion
)
{
	HRESULT t_Result = S_OK ;

	InterlockedIncrement ( & m_InProgress ) ;

	if ( m_GateClosed == 1 )
	{
		t_Result = WBEM_E_SHUTTING_DOWN ;
	}
	else
	{
		if ( m_Core_IWbemRefreshingServices )
		{
			BOOL t_Impersonating ;
			IUnknown *t_OldContext ;
			IServerSecurity *t_OldSecurity ;
			BOOL t_IsProxy ;
			IWbemRefreshingServices *t_Interface ;
			BOOL t_Revert ;
			IUnknown *t_Proxy ;

			t_Result = Begin_IWbemRefreshingServices (

				t_Impersonating ,
				t_OldContext ,
				t_OldSecurity ,
				t_IsProxy ,
				t_Interface ,
				t_Revert ,
				t_Proxy
			) ;

			if ( SUCCEEDED ( t_Result ) )
			{
				t_Result = t_Interface->ReconnectRemoteRefresher (

					a_RefresherId,
					a_Flags,
					a_NumberOfObjects,
					a_ClientRefresherVersion ,
					a_ReconnectInformation ,
					a_ReconnectResults ,
					a_ServerRefresherVersion
				) ;

				End_IWbemRefreshingServices (

					t_Impersonating ,
					t_OldContext ,
					t_OldSecurity ,
					t_IsProxy ,
					t_Interface ,
					t_Revert ,
					t_Proxy
				) ;
			}
		}
		else
		{
			t_Result = WBEM_E_NOT_AVAILABLE ;
		}
	}

	InterlockedDecrement ( & m_InProgress ) ;

	return t_Result ;
}

#ifdef INTERNAL_IDENTIFY

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

#pragma warning( disable : 4355 )

CInterceptor_IEnumWbemClassObject_Stub :: CInterceptor_IEnumWbemClassObject_Stub (

	CWbemGlobal_VoidPointerController *a_Controller ,
	WmiAllocator &a_Allocator ,
	IEnumWbemClassObject *a_InterceptedEnum

)	:	CWbemGlobal_VoidPointerController ( a_Allocator ) ,
		VoidPointerContainerElement ( 

			a_Controller ,
			this
		) ,
		m_Allocator ( a_Allocator ) ,
		m_InterceptedEnum ( a_InterceptedEnum ) ,
		m_GateClosed ( FALSE ) ,
		m_InProgress ( 0 )
{
	InterlockedIncrement ( & ProviderSubSystem_Globals :: s_CInterceptor_IEnumWbemClassObject_Stub_ObjectsInProgress ) ;

	ProviderSubSystem_Globals :: Increment_Global_Object_Count () ;

	if ( m_InterceptedEnum )
	{
		m_InterceptedEnum->AddRef () ;
	}
}

#pragma warning( default : 4355 )

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

CInterceptor_IEnumWbemClassObject_Stub :: ~CInterceptor_IEnumWbemClassObject_Stub ()
{
	CWbemGlobal_VoidPointerController :: UnInitialize () ;

	InterlockedDecrement ( & ProviderSubSystem_Globals :: s_CInterceptor_IEnumWbemClassObject_Stub_ObjectsInProgress ) ;

	ProviderSubSystem_Globals :: Decrement_Global_Object_Count () ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

STDMETHODIMP CInterceptor_IEnumWbemClassObject_Stub :: QueryInterface (

	REFIID iid , 
	LPVOID FAR *iplpv 
) 
{
	*iplpv = NULL ;

	if ( iid == IID_IUnknown )
	{
		*iplpv = ( LPVOID ) this ;
	}
	else if ( iid == IID_IEnumWbemClassObject )
	{
		*iplpv = ( LPVOID ) ( IEnumWbemClassObject * ) this ;		
	}
	else if ( iid == IID_Internal_IEnumWbemClassObject )
	{
		*iplpv = ( LPVOID ) ( Internal_IEnumWbemClassObject * ) this ;		
	}	
	else if ( iid == IID_IWbemShutdown )
	{
		*iplpv = ( LPVOID ) ( IWbemShutdown * ) this ;		
	}	

	if ( *iplpv )
	{
		( ( LPUNKNOWN ) *iplpv )->AddRef () ;

		return ResultFromScode ( S_OK ) ;
	}
	else
	{
		return ResultFromScode ( E_NOINTERFACE ) ;
	}
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

STDMETHODIMP_(ULONG) CInterceptor_IEnumWbemClassObject_Stub :: AddRef ( void )
{
	return VoidPointerContainerElement :: AddRef () ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

STDMETHODIMP_(ULONG) CInterceptor_IEnumWbemClassObject_Stub :: Release ( void )
{
	return VoidPointerContainerElement :: Release () ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_IEnumWbemClassObject_Stub :: EnumInitialize ()
{
	HRESULT t_Result = S_OK ;

	if ( SUCCEEDED ( t_Result ) )
	{
		WmiStatusCode t_StatusCode = CWbemGlobal_VoidPointerController :: Initialize () ;
		if ( t_StatusCode != e_StatusCode_Success ) 
		{
			t_Result = WBEM_E_OUT_OF_MEMORY ;
		}
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_IEnumWbemClassObject_Stub :: Enqueue_IEnumWbemClassObject (

	IEnumWbemClassObject *a_Enum ,
	IEnumWbemClassObject *&a_Stub
)
{
	HRESULT t_Result = S_OK ;

	CInterceptor_IEnumWbemClassObject_Stub *t_Stub = new CInterceptor_IEnumWbemClassObject_Stub ( 

		this , 
		m_Allocator , 
		a_Enum
	) ;

	if ( t_Stub )
	{
		t_Stub->AddRef () ;

		t_Result = t_Stub->EnumInitialize () ;
		if ( SUCCEEDED ( t_Result ) ) 
		{
			CWbemGlobal_VoidPointerController_Container_Iterator t_Iterator ;


			Lock () ;

			WmiStatusCode t_StatusCode = Insert ( 

				*t_Stub ,
				t_Iterator
			) ;

			if ( t_StatusCode == e_StatusCode_Success ) 
			{
				a_Stub = t_Stub ;
			}
			else
			{
				t_Result = WBEM_E_OUT_OF_MEMORY ;
			}

			UnLock () ;
		}
		else
		{
			t_Stub->Release () ;
		}
	}
	else
	{
		t_Result = WBEM_E_OUT_OF_MEMORY ;
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_IEnumWbemClassObject_Stub :: Reset ()
{
	HRESULT t_Result = S_OK ;

	InterlockedIncrement ( & m_InProgress ) ;

	if ( m_GateClosed == 1 )
	{
		t_Result = WBEM_E_SHUTTING_DOWN ;
	}
	else
	{
		t_Result = m_InterceptedEnum->Reset () ;
	}

	InterlockedDecrement ( & m_InProgress ) ;

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_IEnumWbemClassObject_Stub :: Next (

	long a_Timeout ,
	ULONG a_Count ,
	IWbemClassObject **a_Objects ,
	ULONG *a_Returned
)
{
	HRESULT t_Result = S_OK ;

	InterlockedIncrement ( & m_InProgress ) ;

	if ( m_GateClosed == 1 )
	{
		t_Result = WBEM_E_SHUTTING_DOWN ;
	}
	else
	{
		t_Result = m_InterceptedEnum->Next ( 

			a_Timeout ,
			a_Count ,
			a_Objects ,
			a_Returned
		) ;
	}

	InterlockedDecrement ( & m_InProgress ) ;

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_IEnumWbemClassObject_Stub :: NextAsync (

	ULONG a_Count,
	IWbemObjectSink *a_Sink
)
{
	HRESULT t_Result = S_OK ;

	InterlockedIncrement ( & m_InProgress ) ;

	if ( m_GateClosed == 1 )
	{
		t_Result = WBEM_E_SHUTTING_DOWN ;
	}
	else
	{
		t_Result = m_InterceptedEnum->NextAsync ( 

			a_Count,
			a_Sink
		) ;
	}

	InterlockedDecrement ( & m_InProgress ) ;

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_IEnumWbemClassObject_Stub :: Clone (

	IEnumWbemClassObject **a_Enum
)
{
	HRESULT t_Result = S_OK ;

	try
	{
		*a_Enum = NULL ;
	}
	catch ( ... ) 
	{
		t_Result = WBEM_E_CRITICAL_ERROR ;
	}

	if ( SUCCEEDED ( t_Result ) )
	{
		InterlockedIncrement ( & m_InProgress ) ;

		if ( m_GateClosed == 1 )
		{
			t_Result = WBEM_E_SHUTTING_DOWN ;
		}
		else
		{
			IEnumWbemClassObject *t_Enum = NULL ;

			t_Result = m_InterceptedEnum->Clone ( 

				& t_Enum
			) ;

			if ( SUCCEEDED ( t_Result ) )
			{
				HRESULT t_TempResult = Enqueue_IEnumWbemClassObject ( 

					t_Enum ,
					*a_Enum
				) ;

				if ( FAILED ( t_TempResult ) )
				{
					t_Result = t_TempResult ;
				}

				t_Enum->Release () ;
			}
		}

		InterlockedDecrement ( & m_InProgress ) ;
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_IEnumWbemClassObject_Stub :: Skip (

    long a_Timeout,
    ULONG a_Count
)
{
	HRESULT t_Result = S_OK ;

	InterlockedIncrement ( & m_InProgress ) ;

	if ( m_GateClosed == 1 )
	{
		t_Result = WBEM_E_SHUTTING_DOWN ;
	}
	else
	{
		IEnumWbemClassObject *t_Enum = NULL ;

		t_Result = m_InterceptedEnum->Skip ( 

			a_Timeout,
			a_Count
		) ;
	}

	InterlockedDecrement ( & m_InProgress ) ;

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_IEnumWbemClassObject_Stub :: Internal_Reset (

	WmiInternalContext a_InternalContext
)
{
	BOOL t_Impersonating = FALSE ;
	IUnknown *t_OldContext = NULL ;
	IServerSecurity *t_OldSecurity = NULL ;

	HRESULT t_Result = ProviderSubSystem_Globals :: Begin_IdentifyCall_SvcHost (

		a_InternalContext ,
		t_Impersonating ,
		t_OldContext ,
		t_OldSecurity
	) ;

	if ( SUCCEEDED ( t_Result ) )
	{
		t_Result = Reset () ;

		ProviderSubSystem_Globals :: End_IdentifyCall_SvcHost ( a_InternalContext , t_OldContext , t_OldSecurity , t_Impersonating ) ;
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_IEnumWbemClassObject_Stub :: Internal_Next (

	WmiInternalContext a_InternalContext ,
	long a_Timeout ,
	ULONG a_Count ,
	IWbemClassObject **a_Objects ,
	ULONG *a_Returned
)
{
	BOOL t_Impersonating = FALSE ;
	IUnknown *t_OldContext = NULL ;
	IServerSecurity *t_OldSecurity = NULL ;

	HRESULT t_Result = ProviderSubSystem_Globals :: Begin_IdentifyCall_SvcHost (

		a_InternalContext ,
		t_Impersonating ,
		t_OldContext ,
		t_OldSecurity
	) ;

	if ( SUCCEEDED ( t_Result ) )
	{
		t_Result = Next (

			a_Timeout ,
			a_Count ,
			a_Objects ,
			a_Returned
		) ;

		ProviderSubSystem_Globals :: End_IdentifyCall_SvcHost ( a_InternalContext , t_OldContext , t_OldSecurity , t_Impersonating ) ;
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_IEnumWbemClassObject_Stub :: Internal_NextAsync (

	WmiInternalContext a_InternalContext ,
	ULONG a_Count,
	IWbemObjectSink *a_Sink
)
{
	BOOL t_Impersonating = FALSE ;
	IUnknown *t_OldContext = NULL ;
	IServerSecurity *t_OldSecurity = NULL ;

	HRESULT t_Result = ProviderSubSystem_Globals :: Begin_IdentifyCall_SvcHost (

		a_InternalContext ,
		t_Impersonating ,
		t_OldContext ,
		t_OldSecurity
	) ;

	if ( SUCCEEDED ( t_Result ) )
	{
		t_Result = NextAsync (

			a_Count,
			a_Sink
		) ;

		ProviderSubSystem_Globals :: End_IdentifyCall_SvcHost ( a_InternalContext , t_OldContext , t_OldSecurity , t_Impersonating ) ;
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_IEnumWbemClassObject_Stub :: Internal_Clone (

	WmiInternalContext a_InternalContext ,
	IEnumWbemClassObject **a_Enum
)
{
	BOOL t_Impersonating = FALSE ;
	IUnknown *t_OldContext = NULL ;
	IServerSecurity *t_OldSecurity = NULL ;

	HRESULT t_Result = ProviderSubSystem_Globals :: Begin_IdentifyCall_SvcHost (

		a_InternalContext ,
		t_Impersonating ,
		t_OldContext ,
		t_OldSecurity
	) ;

	if ( SUCCEEDED ( t_Result ) )
	{
		t_Result = Clone (

			a_Enum
		) ;

		ProviderSubSystem_Globals :: End_IdentifyCall_SvcHost ( a_InternalContext , t_OldContext , t_OldSecurity , t_Impersonating ) ;
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_IEnumWbemClassObject_Stub :: Internal_Skip (

	WmiInternalContext a_InternalContext ,
    long a_Timeout,
    ULONG a_Count
)
{
	BOOL t_Impersonating = FALSE ;
	IUnknown *t_OldContext = NULL ;
	IServerSecurity *t_OldSecurity = NULL ;

	HRESULT t_Result = ProviderSubSystem_Globals :: Begin_IdentifyCall_SvcHost (

		a_InternalContext ,
		t_Impersonating ,
		t_OldContext ,
		t_OldSecurity
	) ;

	if ( SUCCEEDED ( t_Result ) )
	{
		t_Result = Skip (

			a_Timeout,
			a_Count
		) ;

		ProviderSubSystem_Globals :: End_IdentifyCall_SvcHost ( a_InternalContext , t_OldContext , t_OldSecurity , t_Impersonating ) ;
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_IEnumWbemClassObject_Stub :: Shutdown (

	LONG a_Flags ,
	ULONG a_MaxMilliSeconds ,
	IWbemContext *a_Context
)
{
	HRESULT t_Result = S_OK ;

	InterlockedIncrement ( & m_GateClosed ) ;

	bool t_Acquired = false ;
	while ( ! t_Acquired )
	{
		if ( m_InProgress == 0 )
		{
			t_Acquired = true ;
		}

		if ( SwitchToThread () == FALSE ) 
		{
		}
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

#pragma warning( disable : 4355 )

CInterceptor_IEnumWbemClassObject_Proxy :: CInterceptor_IEnumWbemClassObject_Proxy (

	CWbemGlobal_VoidPointerController *a_Controller ,
	WmiAllocator &a_Allocator ,
	IEnumWbemClassObject *a_InterceptedEnum

)	:	CWbemGlobal_VoidPointerController ( a_Allocator ) ,
		VoidPointerContainerElement ( 

			a_Controller ,
			this
		) ,
		m_Allocator ( a_Allocator ) ,
		m_ProxyContainer ( a_Allocator , ProxyIndex_EnumProxy_Size , MAX_PROXIES ) ,
		m_InterceptedEnum ( a_InterceptedEnum ) ,
		m_Internal_InterceptedEnum ( NULL ) ,
		m_GateClosed ( FALSE ) ,
		m_InProgress ( 0 )
{
	InterlockedIncrement ( & ProviderSubSystem_Globals :: s_CInterceptor_IEnumWbemClassObject_Proxy_ObjectsInProgress ) ;

	ProviderSubSystem_Globals :: Increment_Global_Object_Count () ;

	if ( m_InterceptedEnum )
	{
		m_InterceptedEnum->AddRef () ;

		HRESULT t_Result = m_InterceptedEnum->QueryInterface ( IID_Internal_IEnumWbemClassObject , ( void ** ) & m_Internal_InterceptedEnum ) ;
	}
}

#pragma warning( default : 4355 )

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

CInterceptor_IEnumWbemClassObject_Proxy :: ~CInterceptor_IEnumWbemClassObject_Proxy ()
{
	CWbemGlobal_VoidPointerController :: UnInitialize () ;

	WmiStatusCode t_StatusCode = m_ProxyContainer.UnInitialize () ;

	InterlockedDecrement ( & ProviderSubSystem_Globals :: s_CInterceptor_IEnumWbemClassObject_Proxy_ObjectsInProgress ) ;

	ProviderSubSystem_Globals :: Decrement_Global_Object_Count () ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

STDMETHODIMP CInterceptor_IEnumWbemClassObject_Proxy :: QueryInterface (

	REFIID iid , 
	LPVOID FAR *iplpv 
) 
{
	*iplpv = NULL ;

	if ( iid == IID_IUnknown )
	{
		*iplpv = ( LPVOID ) this ;
	}
	else if ( iid == IID_IEnumWbemClassObject )
	{
		*iplpv = ( LPVOID ) ( IEnumWbemClassObject * ) this ;		
	}
	else if ( iid == IID_Internal_IEnumWbemClassObject )
	{
		*iplpv = ( LPVOID ) ( Internal_IEnumWbemClassObject * ) this ;		
	}	
	else if ( iid == IID_IWbemShutdown )
	{
		*iplpv = ( LPVOID ) ( IWbemShutdown * ) this ;		
	}	

	if ( *iplpv )
	{
		( ( LPUNKNOWN ) *iplpv )->AddRef () ;

		return ResultFromScode ( S_OK ) ;
	}
	else
	{
		return ResultFromScode ( E_NOINTERFACE ) ;
	}
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

STDMETHODIMP_(ULONG) CInterceptor_IEnumWbemClassObject_Proxy :: AddRef ( void )
{
	return VoidPointerContainerElement :: AddRef () ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

STDMETHODIMP_(ULONG) CInterceptor_IEnumWbemClassObject_Proxy :: Release ( void )
{
	return VoidPointerContainerElement :: Release () ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_IEnumWbemClassObject_Proxy :: EnumInitialize ()
{
	HRESULT t_Result = S_OK ;

	WmiStatusCode t_StatusCode = m_ProxyContainer.Initialize () ;
	if ( t_StatusCode != e_StatusCode_Success ) 
	{
		t_Result = WBEM_E_OUT_OF_MEMORY ;
	}

	if ( SUCCEEDED ( t_Result ) )
	{
		WmiStatusCode t_StatusCode = CWbemGlobal_VoidPointerController :: Initialize () ;
		if ( t_StatusCode != e_StatusCode_Success ) 
		{
			t_Result = WBEM_E_OUT_OF_MEMORY ;
		}
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_IEnumWbemClassObject_Proxy :: Begin_IEnumWbemClassObject (

	DWORD a_ProcessIdentifier ,
	HANDLE &a_IdentifyToken ,
	BOOL &a_Impersonating ,
	IUnknown *&a_OldContext ,
	IServerSecurity *&a_OldSecurity ,
	BOOL &a_IsProxy ,
	IUnknown *&a_Interface ,
	BOOL &a_Revert ,
	IUnknown *&a_Proxy
)
{
	HRESULT t_Result = S_OK ;

	a_IdentifyToken = NULL ;
	a_Revert = FALSE ;
	a_Proxy = NULL ;
	a_Impersonating = FALSE ;
	a_OldContext = NULL ;
	a_OldSecurity = NULL ;

	t_Result = ProviderSubSystem_Common_Globals :: BeginCallbackImpersonation ( a_OldContext , a_OldSecurity , a_Impersonating ) ;
	if ( SUCCEEDED ( t_Result ) ) 
	{
		if ( a_ProcessIdentifier )
		{
			t_Result = CoImpersonateClient () ;
			if ( SUCCEEDED ( t_Result ) )
			{
				DWORD t_ImpersonationLevel = ProviderSubSystem_Common_Globals :: GetCurrentImpersonationLevel () ;

				CoRevertToSelf () ;

				if ( t_ImpersonationLevel == RPC_C_IMP_LEVEL_IMPERSONATE || t_ImpersonationLevel == RPC_C_IMP_LEVEL_DELEGATE )
				{
					t_Result = ProviderSubSystem_Common_Globals :: SetProxyState ( 
					
						m_ProxyContainer , 
						ProxyIndex_EnumProxy_IEnumWbemClassObject , 
						IID_IEnumWbemClassObject , 
						m_InterceptedEnum , 
						a_Proxy , 
						a_Revert
					) ;
				}
				else
				{
					t_Result = ProviderSubSystem_Common_Globals :: SetProxyState_PrvHost ( 
					
						m_ProxyContainer , 
						ProxyIndex_EnumProxy_Internal_IEnumWbemClassObject , 
						IID_Internal_IEnumWbemClassObject , 
						m_Internal_InterceptedEnum , 
						a_Proxy , 
						a_Revert ,
						a_ProcessIdentifier ,
						a_IdentifyToken 
					) ;
				}
			}
		}
		else
		{
			t_Result = ProviderSubSystem_Common_Globals :: SetProxyState ( 
			
				m_ProxyContainer , 
				ProxyIndex_EnumProxy_IEnumWbemClassObject , 
				IID_IEnumWbemClassObject , 
				m_InterceptedEnum , 
				a_Proxy , 
				a_Revert
			) ;
		}

		if ( t_Result == WBEM_E_NOT_FOUND )
		{
			a_Interface = m_InterceptedEnum ;
			a_IsProxy = FALSE ;
			t_Result = S_OK ;
		}
		else
		{
			if ( SUCCEEDED ( t_Result ) )
			{
				a_IsProxy = TRUE ;

				a_Interface = ( IUnknown * ) a_Proxy ;

				// Set cloaking on the proxy
				// =========================

				DWORD t_ImpersonationLevel = ProviderSubSystem_Common_Globals :: GetCurrentImpersonationLevel () ;

				t_Result = ProviderSubSystem_Common_Globals :: SetCloaking (

					a_Interface ,
					RPC_C_AUTHN_LEVEL_DEFAULT , 
					t_ImpersonationLevel
				) ;

				if ( FAILED ( t_Result ) )
				{
					if ( a_IdentifyToken )
					{
						HRESULT t_TempResult = ProviderSubSystem_Common_Globals :: RevertProxyState_PrvHost ( 

							m_ProxyContainer , 
							ProxyIndex_EnumProxy_Internal_IEnumWbemClassObject , 
							a_Proxy , 
							a_Revert ,
							a_ProcessIdentifier , 
							a_IdentifyToken 
						) ;
					}
					else
					{
						HRESULT t_TempResult = ProviderSubSystem_Common_Globals :: RevertProxyState ( 

							m_ProxyContainer , 
							ProxyIndex_EnumProxy_IEnumWbemClassObject , 
							a_Proxy , 
							a_Revert
						) ;
					}
				}
			}
		}

		if ( FAILED ( t_Result ) )
		{
			ProviderSubSystem_Common_Globals :: EndImpersonation ( a_OldContext , a_OldSecurity , a_Impersonating ) ;
		}
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_IEnumWbemClassObject_Proxy :: End_IEnumWbemClassObject (

	DWORD a_ProcessIdentifier ,
	HANDLE a_IdentifyToken ,
	BOOL a_Impersonating ,
	IUnknown *a_OldContext ,
	IServerSecurity *a_OldSecurity ,
	BOOL a_IsProxy ,
	IUnknown *a_Interface ,
	BOOL a_Revert ,
	IUnknown *a_Proxy
)
{
	CoRevertToSelf () ;

	if ( a_Proxy )
	{
		if ( a_IdentifyToken )
		{
			HRESULT t_TempResult = ProviderSubSystem_Common_Globals :: RevertProxyState_PrvHost ( 

				m_ProxyContainer , 
				ProxyIndex_EnumProxy_Internal_IEnumWbemClassObject , 
				a_Proxy , 
				a_Revert ,
				a_ProcessIdentifier , 
				a_IdentifyToken 
			) ;
		}
		else
		{
			HRESULT t_TempResult = ProviderSubSystem_Common_Globals :: RevertProxyState ( 

				m_ProxyContainer , 
				ProxyIndex_EnumProxy_IEnumWbemClassObject , 
				a_Proxy , 
				a_Revert
			) ;
		}
	}

	ProviderSubSystem_Common_Globals :: EndImpersonation ( a_OldContext , a_OldSecurity , a_Impersonating ) ;
	
	return S_OK ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_IEnumWbemClassObject_Proxy :: Enqueue_IEnumWbemClassObject (

	IEnumWbemClassObject *a_Enum ,
	IEnumWbemClassObject *&a_Proxy
)
{
	HRESULT t_Result = S_OK ;

	CInterceptor_IEnumWbemClassObject_Proxy *t_Proxy = new CInterceptor_IEnumWbemClassObject_Proxy ( 

		this , 
		m_Allocator , 
		a_Enum
	) ;

	if ( t_Proxy )
	{
		t_Proxy->AddRef () ;

		t_Result = t_Proxy->EnumInitialize () ;
		if ( SUCCEEDED ( t_Result ) ) 
		{
			CWbemGlobal_VoidPointerController_Container_Iterator t_Iterator ;


			Lock () ;

			WmiStatusCode t_StatusCode = Insert ( 

				*t_Proxy ,
				t_Iterator
			) ;

			if ( t_StatusCode == e_StatusCode_Success ) 
			{
				a_Proxy = t_Proxy ;
			}
			else
			{
				t_Result = WBEM_E_OUT_OF_MEMORY ;
			}

			UnLock () ;
		}
		else
		{
			t_Proxy->Release () ;
		}
	}
	else
	{
		t_Result = WBEM_E_OUT_OF_MEMORY ;
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_IEnumWbemClassObject_Proxy :: Reset ()
{
	try
	{
		BOOL t_Impersonating ;
		IUnknown *t_OldContext ;
		IServerSecurity *t_OldSecurity ;
		BOOL t_IsProxy ;
		IUnknown *t_Interface ;
		BOOL t_Revert ;
		IUnknown *t_Proxy ;
		DWORD t_ProcessIdentifier = GetCurrentProcessId () ;
		HANDLE t_IdentifyToken = NULL ;

		HRESULT t_Result = Begin_IEnumWbemClassObject (

			t_ProcessIdentifier ,
			t_IdentifyToken ,
			t_Impersonating ,
			t_OldContext ,
			t_OldSecurity ,
			t_IsProxy ,
			t_Interface ,
			t_Revert ,
			t_Proxy 
		) ;

		if ( SUCCEEDED ( t_Result ) )
		{
			if ( t_IdentifyToken )
			{
				WmiInternalContext t_InternalContext ;
				t_InternalContext.m_IdentifyHandle = ( unsigned __int64 ) t_IdentifyToken ;
				t_InternalContext.m_ProcessIdentifier = t_ProcessIdentifier ;

				t_Result = ( ( Internal_IEnumWbemClassObject * ) t_Interface )->Internal_Reset (

					t_InternalContext
				) ;
			}
			else
			{
				t_Result = ( ( IEnumWbemClassObject * ) t_Interface )->Reset () ;
			}

			End_IEnumWbemClassObject (

				t_ProcessIdentifier ,
				t_IdentifyToken ,
				t_Impersonating ,
				t_OldContext ,
				t_OldSecurity ,
				t_IsProxy ,
				t_Interface ,
				t_Revert ,
				t_Proxy
			) ;
		}

		return t_Result ;
	}
	catch ( ... )
	{
		return WBEM_E_CRITICAL_ERROR ;
	}
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_IEnumWbemClassObject_Proxy :: Next (

	long a_Timeout ,
	ULONG a_Count ,
	IWbemClassObject **a_Objects ,
	ULONG *a_Returned
)
{
	try
	{
		BOOL t_Impersonating ;
		IUnknown *t_OldContext ;
		IServerSecurity *t_OldSecurity ;
		BOOL t_IsProxy ;
		IUnknown *t_Interface ;
		BOOL t_Revert ;
		IUnknown *t_Proxy ;
		DWORD t_ProcessIdentifier = GetCurrentProcessId () ;
		HANDLE t_IdentifyToken = NULL ;

		HRESULT t_Result = Begin_IEnumWbemClassObject (

			t_ProcessIdentifier ,
			t_IdentifyToken ,
			t_Impersonating ,
			t_OldContext ,
			t_OldSecurity ,
			t_IsProxy ,
			t_Interface ,
			t_Revert ,
			t_Proxy 
		) ;

		if ( SUCCEEDED ( t_Result ) )
		{
			if ( t_IdentifyToken )
			{
				WmiInternalContext t_InternalContext ;
				t_InternalContext.m_IdentifyHandle = ( unsigned __int64 ) t_IdentifyToken ;
				t_InternalContext.m_ProcessIdentifier = t_ProcessIdentifier ;

				t_Result = ( ( Internal_IEnumWbemClassObject * ) t_Interface )->Internal_Next (

					t_InternalContext ,
					a_Timeout ,
					a_Count ,
					a_Objects ,
					a_Returned
				) ;
			}
			else
			{
				t_Result = ( ( IEnumWbemClassObject * ) t_Interface )->Next (
				
					a_Timeout ,
					a_Count ,
					a_Objects ,
					a_Returned
				) ;
			}

			End_IEnumWbemClassObject (

				t_ProcessIdentifier ,
				t_IdentifyToken ,
				t_Impersonating ,
				t_OldContext ,
				t_OldSecurity ,
				t_IsProxy ,
				t_Interface ,
				t_Revert ,
				t_Proxy
			) ;
		}

		return t_Result ;
	}
	catch ( ... )
	{
		return WBEM_E_CRITICAL_ERROR ;
	}
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_IEnumWbemClassObject_Proxy :: NextAsync (

	ULONG a_Count,
	IWbemObjectSink *a_Sink
)
{
	try
	{
		BOOL t_Impersonating ;
		IUnknown *t_OldContext ;
		IServerSecurity *t_OldSecurity ;
		BOOL t_IsProxy ;
		IUnknown *t_Interface ;
		BOOL t_Revert ;
		IUnknown *t_Proxy ;
		DWORD t_ProcessIdentifier = GetCurrentProcessId () ;
		HANDLE t_IdentifyToken = NULL ;

		HRESULT t_Result = Begin_IEnumWbemClassObject (

			t_ProcessIdentifier ,
			t_IdentifyToken ,
			t_Impersonating ,
			t_OldContext ,
			t_OldSecurity ,
			t_IsProxy ,
			t_Interface ,
			t_Revert ,
			t_Proxy 
		) ;

		if ( SUCCEEDED ( t_Result ) )
		{
			if ( t_IdentifyToken )
			{
				WmiInternalContext t_InternalContext ;
				t_InternalContext.m_IdentifyHandle = ( unsigned __int64 ) t_IdentifyToken ;
				t_InternalContext.m_ProcessIdentifier = t_ProcessIdentifier ;

				t_Result = ( ( Internal_IEnumWbemClassObject * ) t_Interface )->Internal_NextAsync (

					t_InternalContext ,
					a_Count,
					a_Sink
				) ;
			}
			else
			{
				t_Result = ( ( IEnumWbemClassObject * ) t_Interface )->NextAsync (
				
					a_Count,
					a_Sink
				) ;
			}

			End_IEnumWbemClassObject (

				t_ProcessIdentifier ,
				t_IdentifyToken ,
				t_Impersonating ,
				t_OldContext ,
				t_OldSecurity ,
				t_IsProxy ,
				t_Interface ,
				t_Revert ,
				t_Proxy
			) ;
		}

		return t_Result ;
	}
	catch ( ... )
	{
		return WBEM_E_CRITICAL_ERROR ;
	}
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_IEnumWbemClassObject_Proxy :: Clone (

	IEnumWbemClassObject **a_Enum
)
{
	try
	{
		BOOL t_Impersonating ;
		IUnknown *t_OldContext ;
		IServerSecurity *t_OldSecurity ;
		BOOL t_IsProxy ;
		IUnknown *t_Interface ;
		BOOL t_Revert ;
		IUnknown *t_Proxy ;
		DWORD t_ProcessIdentifier = GetCurrentProcessId () ;
		HANDLE t_IdentifyToken = NULL ;

		HRESULT t_Result = Begin_IEnumWbemClassObject (

			t_ProcessIdentifier ,
			t_IdentifyToken ,
			t_Impersonating ,
			t_OldContext ,
			t_OldSecurity ,
			t_IsProxy ,
			t_Interface ,
			t_Revert ,
			t_Proxy 
		) ;

		if ( SUCCEEDED ( t_Result ) )
		{
			if ( t_IdentifyToken )
			{
				WmiInternalContext t_InternalContext ;
				t_InternalContext.m_IdentifyHandle = ( unsigned __int64 ) t_IdentifyToken ;
				t_InternalContext.m_ProcessIdentifier = t_ProcessIdentifier ;

				t_Result = ( ( Internal_IEnumWbemClassObject * ) t_Interface )->Internal_Clone (

					t_InternalContext ,
					a_Enum
				) ;
			}
			else
			{
				t_Result = ( ( IEnumWbemClassObject * ) t_Interface )->Clone (
				
					a_Enum
				) ;
			}

			End_IEnumWbemClassObject (

				t_ProcessIdentifier ,
				t_IdentifyToken ,
				t_Impersonating ,
				t_OldContext ,
				t_OldSecurity ,
				t_IsProxy ,
				t_Interface ,
				t_Revert ,
				t_Proxy
			) ;
		}

		return t_Result ;
	}
	catch ( ... )
	{
		return WBEM_E_CRITICAL_ERROR ;
	}
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_IEnumWbemClassObject_Proxy :: Skip (

    long a_Timeout,
    ULONG a_Count
)
{
	try
	{
		BOOL t_Impersonating ;
		IUnknown *t_OldContext ;
		IServerSecurity *t_OldSecurity ;
		BOOL t_IsProxy ;
		IUnknown *t_Interface ;
		BOOL t_Revert ;
		IUnknown *t_Proxy ;
		DWORD t_ProcessIdentifier = GetCurrentProcessId () ;
		HANDLE t_IdentifyToken = NULL ;

		HRESULT t_Result = Begin_IEnumWbemClassObject (

			t_ProcessIdentifier ,
			t_IdentifyToken ,
			t_Impersonating ,
			t_OldContext ,
			t_OldSecurity ,
			t_IsProxy ,
			t_Interface ,
			t_Revert ,
			t_Proxy 
		) ;

		if ( SUCCEEDED ( t_Result ) )
		{
			if ( t_IdentifyToken )
			{
				WmiInternalContext t_InternalContext ;
				t_InternalContext.m_IdentifyHandle = ( unsigned __int64 ) t_IdentifyToken ;
				t_InternalContext.m_ProcessIdentifier = t_ProcessIdentifier ;

				t_Result = ( ( Internal_IEnumWbemClassObject * ) t_Interface )->Internal_Skip (

					t_InternalContext ,
					a_Timeout,
					a_Count
				) ;
			}
			else
			{
				t_Result = ( ( IEnumWbemClassObject * ) t_Interface )->Skip (
				
					a_Timeout,
					a_Count
				) ;
			}

			End_IEnumWbemClassObject (

				t_ProcessIdentifier ,
				t_IdentifyToken ,
				t_Impersonating ,
				t_OldContext ,
				t_OldSecurity ,
				t_IsProxy ,
				t_Interface ,
				t_Revert ,
				t_Proxy
			) ;
		}

		return t_Result ;
	}
	catch ( ... )
	{
		return WBEM_E_CRITICAL_ERROR ;
	}
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

#pragma warning( disable : 4355 )

CInterceptor_IWbemServices_Stub :: CInterceptor_IWbemServices_Stub (

	CWbemGlobal_VoidPointerController *a_Controller ,
	WmiAllocator &a_Allocator ,
	IWbemServices *a_Service

) : CWbemGlobal_IWmiObjectSinkController ( a_Allocator ) ,
	VoidPointerContainerElement ( 

		a_Controller ,
		this
	) ,
	m_Core_IWbemServices ( a_Service ) ,
	m_Core_IWbemRefreshingServices ( NULL ) ,
	m_GateClosed ( FALSE ) ,
	m_InProgress ( 0 ) ,
	m_Allocator ( a_Allocator )
{
	InterlockedIncrement ( & ProviderSubSystem_Globals :: s_CInterceptor_IWbemServices_Stub_ObjectsInProgress ) ;

	ProviderSubSystem_Globals :: Increment_Global_Object_Count () ;

	HRESULT t_Result = m_Core_IWbemServices->QueryInterface ( IID_IWbemRefreshingServices , ( void ** ) & m_Core_IWbemRefreshingServices ) ;

	m_Core_IWbemServices->AddRef () ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

CInterceptor_IWbemServices_Stub :: ~CInterceptor_IWbemServices_Stub ()
{
	CWbemGlobal_VoidPointerController :: UnInitialize () ;

	if ( m_Core_IWbemServices )
	{
		m_Core_IWbemServices->Release () ; 
	}

	if ( m_Core_IWbemRefreshingServices )
	{
		m_Core_IWbemRefreshingServices->Release () ;
	}

	InterlockedDecrement ( & ProviderSubSystem_Globals :: s_CInterceptor_IWbemServices_Stub_ObjectsInProgress ) ;

	ProviderSubSystem_Globals :: Decrement_Global_Object_Count () ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

STDMETHODIMP_(ULONG) CInterceptor_IWbemServices_Stub :: AddRef ( void )
{
	return VoidPointerContainerElement :: AddRef () ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

STDMETHODIMP_(ULONG) CInterceptor_IWbemServices_Stub :: Release ( void )
{
	return VoidPointerContainerElement :: Release () ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

STDMETHODIMP CInterceptor_IWbemServices_Stub :: QueryInterface (

	REFIID iid , 
	LPVOID FAR *iplpv 
) 
{
	*iplpv = NULL ;

	if ( iid == IID_IUnknown )
	{
		*iplpv = ( LPVOID ) this ;
	}
	else if ( iid == IID_IWbemServices )
	{
		*iplpv = ( LPVOID ) ( IWbemServices * ) this ;		
	}
	else if ( iid == IID_IWbemRefreshingServices )
	{
		*iplpv = ( LPVOID ) ( IWbemRefreshingServices * ) this ;		
	}
	else if ( iid == IID_IWbemShutdown )
	{
		*iplpv = ( LPVOID ) ( IWbemShutdown * ) this ;		
	}	
	else if ( iid == IID_Internal_IWbemServices )
	{
		*iplpv = ( LPVOID ) ( Internal_IWbemServices * ) this ;		
	}

	if ( *iplpv )
	{
		( ( LPUNKNOWN ) *iplpv )->AddRef () ;

		return ResultFromScode ( S_OK ) ;
	}
	else
	{
		return ResultFromScode ( E_NOINTERFACE ) ;
	}
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_IWbemServices_Stub :: Enqueue_IWbemServices (

	IWbemServices *a_Service ,
	IWbemServices *&a_Stub
)
{
	HRESULT t_Result = S_OK ;

	CInterceptor_IWbemServices_Stub *t_Stub = new CInterceptor_IWbemServices_Stub ( 

		this , 
		m_Allocator , 
		a_Service
	) ;

	if ( t_Stub )
	{
		t_Stub->AddRef () ;

		t_Result = t_Stub->ServiceInitialize () ;
		if ( SUCCEEDED ( t_Result ) ) 
		{
			CWbemGlobal_VoidPointerController_Container_Iterator t_Iterator ;

			Lock () ;

			WmiStatusCode t_StatusCode = Insert ( 

				*t_Stub ,
				t_Iterator
			) ;

			if ( t_StatusCode == e_StatusCode_Success ) 
			{
				a_Stub = t_Stub ;
			}
			else
			{
				t_Result = WBEM_E_OUT_OF_MEMORY ;
			}

			UnLock () ;
		}
		else
		{
			t_Stub->Release () ;
		}
	}
	else
	{
		t_Result = WBEM_E_OUT_OF_MEMORY ;
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_IWbemServices_Stub :: Enqueue_IEnumWbemClassObject (

	IEnumWbemClassObject *a_Enum ,
	IEnumWbemClassObject *&a_Stub
)
{
	HRESULT t_Result = S_OK ;

	CInterceptor_IEnumWbemClassObject_Stub *t_Stub = new CInterceptor_IEnumWbemClassObject_Stub ( 

		this , 
		m_Allocator , 
		a_Enum
	) ;

	if ( t_Stub )
	{
		t_Stub->AddRef () ;

		t_Result = t_Stub->EnumInitialize () ;
		if ( SUCCEEDED ( t_Result ) ) 
		{
			CWbemGlobal_VoidPointerController_Container_Iterator t_Iterator ;


			Lock () ;

			WmiStatusCode t_StatusCode = Insert ( 

				*t_Stub ,
				t_Iterator
			) ;

			if ( t_StatusCode == e_StatusCode_Success ) 
			{
				a_Stub = t_Stub ;
			}
			else
			{
				t_Result = WBEM_E_OUT_OF_MEMORY ;
			}

			UnLock () ;
		}
		else
		{
			t_Stub->Release () ;
		}
	}
	else
	{
		t_Result = WBEM_E_OUT_OF_MEMORY ;
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_IWbemServices_Stub::OpenNamespace ( 

	const BSTR a_ObjectPath ,
	long a_Flags ,
	IWbemContext *a_Context ,
	IWbemServices **a_NamespaceService ,
	IWbemCallResult **a_CallResult
)
{
	HRESULT t_Result = S_OK ;

	InterlockedIncrement ( & m_InProgress ) ;

	if ( m_GateClosed == 1 )
	{
		t_Result = WBEM_E_SHUTTING_DOWN ;
	}
	else
	{
		t_Result = m_Core_IWbemServices->OpenNamespace (

			a_ObjectPath, 
			a_Flags, 
			a_Context ,
			a_NamespaceService, 
			a_CallResult
		) ;
	}

	InterlockedDecrement ( & m_InProgress ) ;

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_IWbemServices_Stub :: CancelAsyncCall ( 
		
	IWbemObjectSink *a_Sink
)
{
	HRESULT t_Result = S_OK ;

	InterlockedIncrement ( & m_InProgress ) ;

	if ( m_GateClosed == 1 )
	{
		t_Result = WBEM_E_SHUTTING_DOWN ;
	}
	else
	{
		t_Result = m_Core_IWbemServices->CancelAsyncCall (

			a_Sink
		) ;
	}

	InterlockedDecrement ( & m_InProgress ) ;

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_IWbemServices_Stub :: QueryObjectSink ( 

	long a_Flags ,
	IWbemObjectSink **a_Sink
) 
{
	HRESULT t_Result = S_OK ;

	InterlockedIncrement ( & m_InProgress ) ;

	if ( m_GateClosed == 1 )
	{
		t_Result = WBEM_E_SHUTTING_DOWN ;
	}
	else
	{
		t_Result = m_Core_IWbemServices->QueryObjectSink (

			a_Flags,
			a_Sink
		) ;
	}

	InterlockedDecrement ( & m_InProgress ) ;

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_IWbemServices_Stub :: GetObject ( 
		
	const BSTR a_ObjectPath ,
    long a_Flags ,
    IWbemContext *a_Context ,
    IWbemClassObject **a_Object ,
    IWbemCallResult **a_CallResult
)
{
	HRESULT t_Result = S_OK ;

	InterlockedIncrement ( & m_InProgress ) ;

	if ( m_GateClosed == 1 )
	{
		t_Result = WBEM_E_SHUTTING_DOWN ;
	}
	else
	{
		t_Result = m_Core_IWbemServices->GetObject (

			a_ObjectPath,
			a_Flags,
			a_Context ,
			a_Object,
			a_CallResult
		) ;
	}

	InterlockedDecrement ( & m_InProgress ) ;

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_IWbemServices_Stub :: GetObjectAsync ( 
		
	const BSTR a_ObjectPath ,
	long a_Flags , 
	IWbemContext *a_Context ,
	IWbemObjectSink *a_Sink
) 
{
	HRESULT t_Result = S_OK ;

	InterlockedIncrement ( & m_InProgress ) ;

	if ( m_GateClosed == 1 )
	{
		t_Result = WBEM_E_SHUTTING_DOWN ;
	}
	else
	{
		t_Result = m_Core_IWbemServices->GetObjectAsync (

			a_ObjectPath, 
			a_Flags, 
			a_Context ,
			a_Sink
		) ;
	}

	InterlockedDecrement ( & m_InProgress ) ;

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_IWbemServices_Stub :: PutClass ( 
		
	IWbemClassObject *a_Object ,
	long a_Flags , 
	IWbemContext *a_Context ,
	IWbemCallResult **a_CallResult
) 
{
	HRESULT t_Result = S_OK ;

	InterlockedIncrement ( & m_InProgress ) ;

	if ( m_GateClosed == 1 )
	{
		t_Result = WBEM_E_SHUTTING_DOWN ;
	}
	else
	{
		t_Result = m_Core_IWbemServices->PutClass (

			a_Object, 
			a_Flags, 
			a_Context,
			a_CallResult
		) ;
	}

	InterlockedDecrement ( & m_InProgress ) ;

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_IWbemServices_Stub :: PutClassAsync ( 
		
	IWbemClassObject *a_Object , 
	long a_Flags ,
	IWbemContext FAR *a_Context ,
	IWbemObjectSink *a_Sink
) 
{
	HRESULT t_Result = S_OK ;

	InterlockedIncrement ( & m_InProgress ) ;

	if ( m_GateClosed == 1 )
	{
		t_Result = WBEM_E_SHUTTING_DOWN ;
	}
	else
	{
		t_Result = m_Core_IWbemServices->PutClassAsync (

			a_Object, 
			a_Flags, 
			a_Context ,
			a_Sink
		) ;
	}

	InterlockedDecrement ( & m_InProgress ) ;

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_IWbemServices_Stub :: DeleteClass ( 
		
	const BSTR a_Class , 
	long a_Flags , 
	IWbemContext *a_Context ,
	IWbemCallResult **a_CallResult
) 
{
	HRESULT t_Result = S_OK ;

	InterlockedIncrement ( & m_InProgress ) ;

	if ( m_GateClosed == 1 )
	{
		t_Result = WBEM_E_SHUTTING_DOWN ;
	}
	else
	{
		t_Result = m_Core_IWbemServices->DeleteClass (

			a_Class, 
			a_Flags, 
			a_Context,
			a_CallResult
		) ;
	}

	InterlockedDecrement ( & m_InProgress ) ;

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_IWbemServices_Stub :: DeleteClassAsync ( 
		
	const BSTR a_Class ,
	long a_Flags,
	IWbemContext *a_Context ,
	IWbemObjectSink *a_Sink
) 
{
	HRESULT t_Result = S_OK ;

	InterlockedIncrement ( & m_InProgress ) ;

	if ( m_GateClosed == 1 )
	{
		t_Result = WBEM_E_SHUTTING_DOWN ;
	}
	else
	{
		t_Result = m_Core_IWbemServices->DeleteClassAsync (

			a_Class , 
			a_Flags , 
			a_Context ,
			a_Sink
		) ;
	}

	InterlockedDecrement ( & m_InProgress ) ;

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_IWbemServices_Stub :: CreateClassEnum ( 

	const BSTR a_Superclass ,
	long a_Flags, 
	IWbemContext *a_Context ,
	IEnumWbemClassObject **a_Enum
) 
{
	HRESULT t_Result = S_OK ;

	InterlockedIncrement ( & m_InProgress ) ;

	if ( m_GateClosed == 1 )
	{
		t_Result = WBEM_E_SHUTTING_DOWN ;
	}
	else
	{
		IEnumWbemClassObject *t_Enum = NULL ;

		t_Result = m_Core_IWbemServices->CreateClassEnum (

			a_Superclass, 
			a_Flags, 
			a_Context,
			& t_Enum
		) ;

		if ( SUCCEEDED ( t_Result ) )
		{
			HRESULT t_TempResult = Enqueue_IEnumWbemClassObject ( 

				t_Enum ,
				*a_Enum
			) ;

			if ( FAILED ( t_TempResult ) )
			{
				t_Result = t_TempResult ;
			}

			t_Enum->Release () ;
		}
	}

	InterlockedDecrement ( & m_InProgress ) ;

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_IWbemServices_Stub :: CreateClassEnumAsync (

	const BSTR a_Superclass ,
	long a_Flags ,
	IWbemContext *a_Context ,
	IWbemObjectSink *a_Sink
) 
{
	HRESULT t_Result = S_OK ;

	InterlockedIncrement ( & m_InProgress ) ;

	if ( m_GateClosed == 1 )
	{
		t_Result = WBEM_E_SHUTTING_DOWN ;
	}
	else
	{
		t_Result = m_Core_IWbemServices->CreateClassEnumAsync (

			a_Superclass, 
			a_Flags, 
			a_Context,
			a_Sink
		) ;
	}

	InterlockedDecrement ( & m_InProgress ) ;

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_IWbemServices_Stub :: PutInstance (

    IWbemClassObject *a_Instance,
    long a_Flags,
    IWbemContext *a_Context,
	IWbemCallResult **a_CallResult
) 
{
	HRESULT t_Result = S_OK ;

	InterlockedIncrement ( & m_InProgress ) ;

	if ( m_GateClosed == 1 )
	{
		t_Result = WBEM_E_SHUTTING_DOWN ;
	}
	else
	{
		t_Result = m_Core_IWbemServices->PutInstance (

			a_Instance,
			a_Flags,
			a_Context,
			a_CallResult
		) ;
	}

	InterlockedDecrement ( & m_InProgress ) ;

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_IWbemServices_Stub :: PutInstanceAsync ( 
		
	IWbemClassObject *a_Instance, 
	long a_Flags, 
    IWbemContext *a_Context,
	IWbemObjectSink *a_Sink
) 
{
	HRESULT t_Result = S_OK ;

	InterlockedIncrement ( & m_InProgress ) ;

	if ( m_GateClosed == 1 )
	{
		t_Result = WBEM_E_SHUTTING_DOWN ;
	}
	else
	{
		t_Result = m_Core_IWbemServices->PutInstanceAsync (

			a_Instance, 
			a_Flags, 
			a_Context,
			a_Sink
		) ;
	}

	InterlockedDecrement ( & m_InProgress ) ;

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_IWbemServices_Stub :: DeleteInstance ( 

	const BSTR a_ObjectPath,
    long a_Flags,
    IWbemContext *a_Context,
    IWbemCallResult **a_CallResult
)
{
	HRESULT t_Result = S_OK ;

	InterlockedIncrement ( & m_InProgress ) ;

	if ( m_GateClosed == 1 )
	{
		t_Result = WBEM_E_SHUTTING_DOWN ;
	}
	else
	{
		t_Result = m_Core_IWbemServices->DeleteInstance (

			a_ObjectPath,
			a_Flags,
			a_Context,
			a_CallResult
		) ;
	}

	InterlockedDecrement ( & m_InProgress ) ;

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/
        
HRESULT CInterceptor_IWbemServices_Stub :: DeleteInstanceAsync (
 
	const BSTR a_ObjectPath,
    long a_Flags,
    IWbemContext *a_Context,
    IWbemObjectSink *a_Sink	
)
{
	HRESULT t_Result = S_OK ;

	InterlockedIncrement ( & m_InProgress ) ;

	if ( m_GateClosed == 1 )
	{
		t_Result = WBEM_E_SHUTTING_DOWN ;
	}
	else
	{
		t_Result = m_Core_IWbemServices->DeleteInstanceAsync (

			a_ObjectPath,
			a_Flags,
			a_Context,
			a_Sink
		) ;
	}

	InterlockedDecrement ( & m_InProgress ) ;

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_IWbemServices_Stub :: CreateInstanceEnum ( 

	const BSTR a_Class, 
	long a_Flags, 
	IWbemContext *a_Context, 
	IEnumWbemClassObject **a_Enum
)
{
	HRESULT t_Result = S_OK ;

	InterlockedIncrement ( & m_InProgress ) ;

	if ( m_GateClosed == 1 )
	{
		t_Result = WBEM_E_SHUTTING_DOWN ;
	}
	else
	{
		IEnumWbemClassObject *t_Enum = NULL ;

		t_Result = m_Core_IWbemServices->CreateInstanceEnum (

			a_Class, 
			a_Flags, 
			a_Context, 
			& t_Enum
		) ;

		if ( SUCCEEDED ( t_Result ) )
		{
			HRESULT t_TempResult = Enqueue_IEnumWbemClassObject ( 

				t_Enum ,
				*a_Enum
			) ;

			if ( FAILED ( t_TempResult ) )
			{
				t_Result = t_TempResult ;
			}

			t_Enum->Release () ;
		}
	}

	InterlockedDecrement ( & m_InProgress ) ;

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_IWbemServices_Stub :: CreateInstanceEnumAsync (

 	const BSTR a_Class, 
	long a_Flags, 
	IWbemContext *a_Context,
	IWbemObjectSink *a_Sink

) 
{
	HRESULT t_Result = S_OK ;

	InterlockedIncrement ( & m_InProgress ) ;

	if ( m_GateClosed == 1 )
	{
		t_Result = WBEM_E_SHUTTING_DOWN ;
	}
	else
	{
		t_Result = m_Core_IWbemServices->CreateInstanceEnumAsync (

 			a_Class, 
			a_Flags, 
			a_Context,
			a_Sink
		) ;
	}

	InterlockedDecrement ( & m_InProgress ) ;

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_IWbemServices_Stub :: ExecQuery ( 

	const BSTR a_QueryLanguage, 
	const BSTR a_Query, 
	long a_Flags, 
	IWbemContext *a_Context,
	IEnumWbemClassObject **a_Enum
)
{
	HRESULT t_Result = S_OK ;

	InterlockedIncrement ( & m_InProgress ) ;

	if ( m_GateClosed == 1 )
	{
		t_Result = WBEM_E_SHUTTING_DOWN ;
	}
	else
	{
		IEnumWbemClassObject *t_Enum = NULL ;

		t_Result = m_Core_IWbemServices->ExecQuery (

			a_QueryLanguage, 
			a_Query, 
			a_Flags, 
			a_Context,
			& t_Enum
		) ;

		if ( SUCCEEDED ( t_Result ) )
		{
			HRESULT t_TempResult = Enqueue_IEnumWbemClassObject ( 

				t_Enum ,
				*a_Enum
			) ;

			if ( FAILED ( t_TempResult ) )
			{
				t_Result = t_TempResult ;
			}

			t_Enum->Release () ;
		}
	}

	InterlockedDecrement ( & m_InProgress ) ;

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_IWbemServices_Stub :: ExecQueryAsync ( 
		
	const BSTR a_QueryLanguage, 
	const BSTR a_Query, 
	long a_Flags, 
	IWbemContext *a_Context ,
	IWbemObjectSink *a_Sink
) 
{
	HRESULT t_Result = S_OK ;

	InterlockedIncrement ( & m_InProgress ) ;

	if ( m_GateClosed == 1 )
	{
		t_Result = WBEM_E_SHUTTING_DOWN ;
	}
	else
	{
		t_Result = m_Core_IWbemServices->ExecQueryAsync (

			a_QueryLanguage, 
			a_Query, 
			a_Flags, 
			a_Context,
			a_Sink
		) ;
	}

	InterlockedDecrement ( & m_InProgress ) ;

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_IWbemServices_Stub :: ExecNotificationQuery ( 

	const BSTR a_QueryLanguage,
    const BSTR a_Query,
    long a_Flags,
    IWbemContext *a_Context,
    IEnumWbemClassObject **a_Enum
)
{
	HRESULT t_Result = S_OK ;

	InterlockedIncrement ( & m_InProgress ) ;

	if ( m_GateClosed == 1 )
	{
		t_Result = WBEM_E_SHUTTING_DOWN ;
	}
	else
	{
		t_Result = m_Core_IWbemServices->ExecNotificationQuery (

			a_QueryLanguage,
			a_Query,
			a_Flags,
			a_Context,
			a_Enum
		) ;
	}

	InterlockedDecrement ( & m_InProgress ) ;

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/
        
HRESULT CInterceptor_IWbemServices_Stub :: ExecNotificationQueryAsync ( 
            
	const BSTR a_QueryLanguage,
    const BSTR a_Query,
    long a_Flags,
    IWbemContext *a_Context,
    IWbemObjectSink *a_Sink
)
{
	HRESULT t_Result = S_OK ;

	InterlockedIncrement ( & m_InProgress ) ;

	if ( m_GateClosed == 1 )
	{
		t_Result = WBEM_E_SHUTTING_DOWN ;
	}
	else
	{
		t_Result = m_Core_IWbemServices->ExecNotificationQueryAsync (

			a_QueryLanguage,
			a_Query,
			a_Flags,
			a_Context,
			a_Sink
		) ;
	}

	InterlockedDecrement ( & m_InProgress ) ;

	return t_Result ;
}       

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_IWbemServices_Stub :: ExecMethod ( 

	const BSTR a_ObjectPath,
    const BSTR a_MethodName,
    long a_Flags,
    IWbemContext *a_Context,
    IWbemClassObject *a_InParams,
    IWbemClassObject **a_OutParams,
    IWbemCallResult **a_CallResult
)
{
	HRESULT t_Result = S_OK ;

	InterlockedIncrement ( & m_InProgress ) ;

	if ( m_GateClosed == 1 )
	{
		t_Result = WBEM_E_SHUTTING_DOWN ;
	}
	else
	{
		t_Result = m_Core_IWbemServices->ExecMethod (

			a_ObjectPath,
			a_MethodName,
			a_Flags,
			a_Context,
			a_InParams,
			a_OutParams,
			a_CallResult
		) ;
	}

	InterlockedDecrement ( & m_InProgress ) ;

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_IWbemServices_Stub :: ExecMethodAsync ( 

    const BSTR a_ObjectPath,
    const BSTR a_MethodName,
    long a_Flags,
    IWbemContext *a_Context,
    IWbemClassObject *a_InParams,
	IWbemObjectSink *a_Sink
) 
{
	HRESULT t_Result = S_OK ;

	InterlockedIncrement ( & m_InProgress ) ;

	if ( m_GateClosed == 1 )
	{
		t_Result = WBEM_E_SHUTTING_DOWN ;
	}
	else
	{
		t_Result = m_Core_IWbemServices->ExecMethodAsync (

			a_ObjectPath,
			a_MethodName,
			a_Flags,
			a_Context,
			a_InParams,
			a_Sink
		) ;
	}

	InterlockedDecrement ( & m_InProgress ) ;

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_IWbemServices_Stub :: ServiceInitialize ()
{
	HRESULT t_Result = S_OK ;

	if ( SUCCEEDED ( t_Result ) )
	{
		WmiStatusCode t_StatusCode = CWbemGlobal_VoidPointerController :: Initialize () ;
		if ( t_StatusCode != e_StatusCode_Success ) 
		{
			t_Result = WBEM_E_OUT_OF_MEMORY ;
		}
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_IWbemServices_Stub :: Shutdown (

	LONG a_Flags ,
	ULONG a_MaxMilliSeconds ,
	IWbemContext *a_Context
)
{
	HRESULT t_Result = S_OK ;

	InterlockedIncrement ( & m_GateClosed ) ;

	bool t_Acquired = false ;
	while ( ! t_Acquired )
	{
		if ( m_InProgress == 0 )
		{
			t_Acquired = true ;
			break ;
		}

		if ( SwitchToThread () == FALSE ) 
		{
		}
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_IWbemServices_Stub :: AddObjectToRefresher (

	WBEM_REFRESHER_ID *a_RefresherId ,
	LPCWSTR a_Path,
	long a_Flags ,
	IWbemContext *a_Context,
	DWORD a_ClientRefresherVersion ,
	WBEM_REFRESH_INFO *a_Information ,
	DWORD *a_ServerRefresherVersion
)
{
	HRESULT t_Result = S_OK ;

	InterlockedIncrement ( & m_InProgress ) ;

	if ( m_GateClosed == 1 )
	{
		t_Result = WBEM_E_SHUTTING_DOWN ;
	}
	else
	{
		if ( m_Core_IWbemRefreshingServices )
		{
			t_Result = m_Core_IWbemRefreshingServices->AddObjectToRefresher (

				a_RefresherId ,
				a_Path,
				a_Flags ,
				a_Context,
				a_ClientRefresherVersion ,
				a_Information ,
				a_ServerRefresherVersion
			) ;
		}
		else
		{
			t_Result = WBEM_E_NOT_AVAILABLE ;
		}
	}

	InterlockedDecrement ( & m_InProgress ) ;

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_IWbemServices_Stub :: AddObjectToRefresherByTemplate (

	WBEM_REFRESHER_ID *a_RefresherId ,
	IWbemClassObject *a_Template ,
	long a_Flags ,
	IWbemContext *a_Context ,
	DWORD a_ClientRefresherVersion ,
	WBEM_REFRESH_INFO *a_Information ,
	DWORD *a_ServerRefresherVersion
)
{
	HRESULT t_Result = S_OK ;

	InterlockedIncrement ( & m_InProgress ) ;

	if ( m_GateClosed == 1 )
	{
		t_Result = WBEM_E_SHUTTING_DOWN ;
	}
	else
	{
		if ( m_Core_IWbemRefreshingServices )
		{
			t_Result = m_Core_IWbemRefreshingServices->AddObjectToRefresherByTemplate (

				a_RefresherId ,
				a_Template ,
				a_Flags ,
				a_Context ,
				a_ClientRefresherVersion ,
				a_Information ,
				a_ServerRefresherVersion
			) ;
		}
		else
		{
			t_Result = WBEM_E_NOT_AVAILABLE ;
		}
	}

	InterlockedDecrement ( & m_InProgress ) ;

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_IWbemServices_Stub :: AddEnumToRefresher (

	WBEM_REFRESHER_ID *a_RefresherId ,
	LPCWSTR a_Class ,
	long a_Flags ,
	IWbemContext *a_Context,
	DWORD a_ClientRefresherVersion ,
	WBEM_REFRESH_INFO *a_Information ,
	DWORD *a_ServerRefresherVersion
)
{
	HRESULT t_Result = S_OK ;

	InterlockedIncrement ( & m_InProgress ) ;

	if ( m_GateClosed == 1 )
	{
		t_Result = WBEM_E_SHUTTING_DOWN ;
	}
	else
	{
		if ( m_Core_IWbemRefreshingServices )
		{
			t_Result = m_Core_IWbemRefreshingServices->AddEnumToRefresher (

				a_RefresherId ,
				a_Class ,
				a_Flags ,
				a_Context,
				a_ClientRefresherVersion ,
				a_Information ,
				a_ServerRefresherVersion
			) ;
		}
		else
		{
			t_Result = WBEM_E_NOT_AVAILABLE ;
		}
	}

	InterlockedDecrement ( & m_InProgress ) ;

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_IWbemServices_Stub :: RemoveObjectFromRefresher (

	WBEM_REFRESHER_ID *a_RefresherId ,
	long a_Id ,
	long a_Flags ,
	DWORD a_ClientRefresherVersion ,
	DWORD *a_ServerRefresherVersion
)
{
	HRESULT t_Result = S_OK ;

	InterlockedIncrement ( & m_InProgress ) ;

	if ( m_GateClosed == 1 )
	{
		t_Result = WBEM_E_SHUTTING_DOWN ;
	}
	else
	{
		if ( m_Core_IWbemRefreshingServices )
		{
			t_Result = m_Core_IWbemRefreshingServices->RemoveObjectFromRefresher (

				a_RefresherId ,
				a_Id ,
				a_Flags ,
				a_ClientRefresherVersion ,
				a_ServerRefresherVersion
			) ;
		}
		else
		{
			t_Result = WBEM_E_NOT_AVAILABLE ;
		}
	}

	InterlockedDecrement ( & m_InProgress ) ;

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_IWbemServices_Stub :: GetRemoteRefresher (

	WBEM_REFRESHER_ID *a_RefresherId ,
	long a_Flags ,
	DWORD a_ClientRefresherVersion ,
	IWbemRemoteRefresher **a_RemoteRefresher ,
	GUID *a_Guid ,
	DWORD *a_ServerRefresherVersion
)
{
	HRESULT t_Result = S_OK ;

	InterlockedIncrement ( & m_InProgress ) ;

	if ( m_GateClosed == 1 )
	{
		t_Result = WBEM_E_SHUTTING_DOWN ;
	}
	else
	{
		if ( m_Core_IWbemRefreshingServices )
		{
			t_Result = m_Core_IWbemRefreshingServices->GetRemoteRefresher (

				a_RefresherId ,
				a_Flags ,
				a_ClientRefresherVersion ,
				a_RemoteRefresher ,
				a_Guid ,
				a_ServerRefresherVersion
			) ;
		}
		else
		{
			t_Result = WBEM_E_NOT_AVAILABLE ;
		}
	}

	InterlockedDecrement ( & m_InProgress ) ;

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_IWbemServices_Stub :: ReconnectRemoteRefresher (

	WBEM_REFRESHER_ID *a_RefresherId,
	long a_Flags,
	long a_NumberOfObjects,
	DWORD a_ClientRefresherVersion ,
	WBEM_RECONNECT_INFO *a_ReconnectInformation ,
	WBEM_RECONNECT_RESULTS *a_ReconnectResults ,
	DWORD *a_ServerRefresherVersion
)
{
	HRESULT t_Result = S_OK ;

	InterlockedIncrement ( & m_InProgress ) ;

	if ( m_GateClosed == 1 )
	{
		t_Result = WBEM_E_SHUTTING_DOWN ;
	}
	else
	{
		if ( m_Core_IWbemRefreshingServices )
		{
			t_Result = m_Core_IWbemRefreshingServices->ReconnectRemoteRefresher (

				a_RefresherId,
				a_Flags,
				a_NumberOfObjects,
				a_ClientRefresherVersion ,
				a_ReconnectInformation ,
				a_ReconnectResults ,
				a_ServerRefresherVersion
			) ;
		}
		else
		{
			t_Result = WBEM_E_NOT_AVAILABLE ;
		}
	}

	InterlockedDecrement ( & m_InProgress ) ;

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_IWbemServices_Stub :: Internal_OpenNamespace ( 

	WmiInternalContext a_InternalContext ,
	const BSTR a_ObjectPath ,
	long a_Flags ,
	IWbemContext *a_Context ,
	IWbemServices **a_NamespaceService ,
	IWbemCallResult **a_CallResult
)
{
	BOOL t_Impersonating = FALSE ;
	IUnknown *t_OldContext = NULL ;
	IServerSecurity *t_OldSecurity = NULL ;

	HRESULT t_Result = ProviderSubSystem_Globals :: Begin_IdentifyCall_SvcHost (

		a_InternalContext ,
		t_Impersonating ,
		t_OldContext ,
		t_OldSecurity
	) ;

	if ( SUCCEEDED ( t_Result ) )
	{
		t_Result = OpenNamespace (

			a_ObjectPath ,
			a_Flags ,
			a_Context ,
			a_NamespaceService ,
			a_CallResult
		) ;

		ProviderSubSystem_Globals :: End_IdentifyCall_SvcHost ( a_InternalContext , t_OldContext , t_OldSecurity , t_Impersonating ) ;
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_IWbemServices_Stub :: Internal_CancelAsyncCall ( 
	
	WmiInternalContext a_InternalContext ,		
	IWbemObjectSink *a_Sink
)
{
	BOOL t_Impersonating = FALSE ;
	IUnknown *t_OldContext = NULL ;
	IServerSecurity *t_OldSecurity = NULL ;

	HRESULT t_Result = ProviderSubSystem_Globals :: Begin_IdentifyCall_SvcHost (

		a_InternalContext ,
		t_Impersonating ,
		t_OldContext ,
		t_OldSecurity
	) ;

	if ( SUCCEEDED ( t_Result ) )
	{
		t_Result = CancelAsyncCall (
		
			a_Sink
		) ;

		ProviderSubSystem_Globals :: End_IdentifyCall_SvcHost ( a_InternalContext , t_OldContext , t_OldSecurity , t_Impersonating ) ;
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_IWbemServices_Stub :: Internal_QueryObjectSink ( 

	WmiInternalContext a_InternalContext ,
	long a_Flags ,
	IWbemObjectSink **a_Sink
) 
{
	BOOL t_Impersonating = FALSE ;
	IUnknown *t_OldContext = NULL ;
	IServerSecurity *t_OldSecurity = NULL ;

	HRESULT t_Result = ProviderSubSystem_Globals :: Begin_IdentifyCall_SvcHost (

		a_InternalContext ,
		t_Impersonating ,
		t_OldContext ,
		t_OldSecurity
	) ;

	if ( SUCCEEDED ( t_Result ) )
	{
		t_Result = QueryObjectSink (

			a_Flags ,	
			a_Sink
		) ;

		ProviderSubSystem_Globals :: End_IdentifyCall_SvcHost ( a_InternalContext , t_OldContext , t_OldSecurity , t_Impersonating ) ;
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_IWbemServices_Stub :: Internal_GetObject ( 
		
	WmiInternalContext a_InternalContext ,
	const BSTR a_ObjectPath ,
    long a_Flags ,
    IWbemContext *a_Context ,
    IWbemClassObject **a_Object ,
    IWbemCallResult **a_CallResult
)
{
	BOOL t_Impersonating = FALSE ;
	IUnknown *t_OldContext = NULL ;
	IServerSecurity *t_OldSecurity = NULL ;

	HRESULT t_Result = ProviderSubSystem_Globals :: Begin_IdentifyCall_SvcHost (

		a_InternalContext ,
		t_Impersonating ,
		t_OldContext ,
		t_OldSecurity
	) ;

	if ( SUCCEEDED ( t_Result ) )
	{
		t_Result = GetObject (

			a_ObjectPath ,
			a_Flags ,
			a_Context ,
			a_Object ,
			a_CallResult
		) ;

		ProviderSubSystem_Globals :: End_IdentifyCall_SvcHost ( a_InternalContext , t_OldContext , t_OldSecurity , t_Impersonating ) ;
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_IWbemServices_Stub :: Internal_GetObjectAsync ( 
		
	WmiInternalContext a_InternalContext ,
	const BSTR a_ObjectPath ,
	long a_Flags , 
	IWbemContext *a_Context ,
	IWbemObjectSink *a_Sink
) 
{
	BOOL t_Impersonating = FALSE ;
	IUnknown *t_OldContext = NULL ;
	IServerSecurity *t_OldSecurity = NULL ;

	HRESULT t_Result = ProviderSubSystem_Globals :: Begin_IdentifyCall_SvcHost (

		a_InternalContext ,
		t_Impersonating ,
		t_OldContext ,
		t_OldSecurity
	) ;

	if ( SUCCEEDED ( t_Result ) )
	{
		t_Result = GetObjectAsync (

			a_ObjectPath ,
			a_Flags , 
			a_Context ,
			a_Sink
		) ;

		ProviderSubSystem_Globals :: End_IdentifyCall_SvcHost ( a_InternalContext , t_OldContext , t_OldSecurity , t_Impersonating ) ;
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_IWbemServices_Stub :: Internal_PutClass ( 

	WmiInternalContext a_InternalContext ,		
	IWbemClassObject *a_Object ,
	long a_Flags , 
	IWbemContext *a_Context ,
	IWbemCallResult **a_CallResult
) 
{
	BOOL t_Impersonating = FALSE ;
	IUnknown *t_OldContext = NULL ;
	IServerSecurity *t_OldSecurity = NULL ;

	HRESULT t_Result = ProviderSubSystem_Globals :: Begin_IdentifyCall_SvcHost (

		a_InternalContext ,
		t_Impersonating ,
		t_OldContext ,
		t_OldSecurity
	) ;

	if ( SUCCEEDED ( t_Result ) )
	{
		t_Result = PutClass (

			a_Object ,
			a_Flags , 
			a_Context ,
			a_CallResult
		) ;

		ProviderSubSystem_Globals :: End_IdentifyCall_SvcHost ( a_InternalContext , t_OldContext , t_OldSecurity , t_Impersonating ) ;
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_IWbemServices_Stub :: Internal_PutClassAsync ( 
		
	WmiInternalContext a_InternalContext ,
	IWbemClassObject *a_Object , 
	long a_Flags , 
	IWbemContext *a_Context ,
	IWbemObjectSink *a_Sink
) 
{
	BOOL t_Impersonating = FALSE ;
	IUnknown *t_OldContext = NULL ;
	IServerSecurity *t_OldSecurity = NULL ;

	HRESULT t_Result = ProviderSubSystem_Globals :: Begin_IdentifyCall_SvcHost (

		a_InternalContext ,
		t_Impersonating ,
		t_OldContext ,
		t_OldSecurity
	) ;

	if ( SUCCEEDED ( t_Result ) )
	{
		t_Result = PutClassAsync (

			a_Object , 
			a_Flags , 
			a_Context ,
			a_Sink
		) ;

		ProviderSubSystem_Globals :: End_IdentifyCall_SvcHost ( a_InternalContext , t_OldContext , t_OldSecurity , t_Impersonating ) ;
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_IWbemServices_Stub :: Internal_DeleteClass ( 
		
	WmiInternalContext a_InternalContext ,
	const BSTR a_Class , 
	long a_Flags , 
	IWbemContext *a_Context ,
	IWbemCallResult **a_CallResult
) 
{
	BOOL t_Impersonating = FALSE ;
	IUnknown *t_OldContext = NULL ;
	IServerSecurity *t_OldSecurity = NULL ;

	HRESULT t_Result = ProviderSubSystem_Globals :: Begin_IdentifyCall_SvcHost (

		a_InternalContext ,
		t_Impersonating ,
		t_OldContext ,
		t_OldSecurity
	) ;

	if ( SUCCEEDED ( t_Result ) )
	{
		t_Result = DeleteClass (

			a_Class , 
			a_Flags , 
			a_Context ,
			a_CallResult
		) ;

		ProviderSubSystem_Globals :: End_IdentifyCall_SvcHost ( a_InternalContext , t_OldContext , t_OldSecurity , t_Impersonating ) ;
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_IWbemServices_Stub :: Internal_DeleteClassAsync ( 
		
	WmiInternalContext a_InternalContext ,
	const BSTR a_Class , 
	long a_Flags , 
	IWbemContext *a_Context ,
	IWbemObjectSink *a_Sink
) 
{
	BOOL t_Impersonating = FALSE ;
	IUnknown *t_OldContext = NULL ;
	IServerSecurity *t_OldSecurity = NULL ;

	HRESULT t_Result = ProviderSubSystem_Globals :: Begin_IdentifyCall_SvcHost (

		a_InternalContext ,
		t_Impersonating ,
		t_OldContext ,
		t_OldSecurity
	) ;

	if ( SUCCEEDED ( t_Result ) )
	{
		t_Result = DeleteClassAsync (

			a_Class , 
			a_Flags , 
			a_Context ,
			a_Sink
		) ;

		ProviderSubSystem_Globals :: End_IdentifyCall_SvcHost ( a_InternalContext , t_OldContext , t_OldSecurity , t_Impersonating ) ;
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_IWbemServices_Stub :: Internal_CreateClassEnum ( 

	WmiInternalContext a_InternalContext ,
	const BSTR a_SuperClass ,
	long a_Flags, 
	IWbemContext *a_Context ,
	IEnumWbemClassObject **a_Enum
) 
{
	BOOL t_Impersonating = FALSE ;
	IUnknown *t_OldContext = NULL ;
	IServerSecurity *t_OldSecurity = NULL ;

	HRESULT t_Result = ProviderSubSystem_Globals :: Begin_IdentifyCall_SvcHost (

		a_InternalContext ,
		t_Impersonating ,
		t_OldContext ,
		t_OldSecurity
	) ;

	if ( SUCCEEDED ( t_Result ) )
	{
		t_Result = CreateClassEnum (

			a_SuperClass ,
			a_Flags, 
			a_Context ,
			a_Enum
		) ;

		ProviderSubSystem_Globals :: End_IdentifyCall_SvcHost ( a_InternalContext , t_OldContext , t_OldSecurity , t_Impersonating ) ;
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_IWbemServices_Stub :: Internal_CreateClassEnumAsync ( 
		
	WmiInternalContext a_InternalContext ,
	const BSTR a_SuperClass , 
	long a_Flags , 
	IWbemContext *a_Context ,
	IWbemObjectSink *a_Sink
) 
{
	BOOL t_Impersonating = FALSE ;
	IUnknown *t_OldContext = NULL ;
	IServerSecurity *t_OldSecurity = NULL ;

	HRESULT t_Result = ProviderSubSystem_Globals :: Begin_IdentifyCall_SvcHost (

		a_InternalContext ,
		t_Impersonating ,
		t_OldContext ,
		t_OldSecurity
	) ;

	if ( SUCCEEDED ( t_Result ) )
	{
		t_Result = CreateClassEnumAsync (

			a_SuperClass ,
			a_Flags, 
			a_Context ,
			a_Sink
		) ;

		ProviderSubSystem_Globals :: End_IdentifyCall_SvcHost ( a_InternalContext , t_OldContext , t_OldSecurity , t_Impersonating ) ;
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_IWbemServices_Stub :: Internal_PutInstance (

	WmiInternalContext a_InternalContext ,
    IWbemClassObject *a_Instance ,
    long a_Flags ,
    IWbemContext *a_Context ,
	IWbemCallResult **a_CallResult
) 
{
	BOOL t_Impersonating = FALSE ;
	IUnknown *t_OldContext = NULL ;
	IServerSecurity *t_OldSecurity = NULL ;

	HRESULT t_Result = ProviderSubSystem_Globals :: Begin_IdentifyCall_SvcHost (

		a_InternalContext ,
		t_Impersonating ,
		t_OldContext ,
		t_OldSecurity
	) ;

	if ( SUCCEEDED ( t_Result ) )
	{
		t_Result = PutInstance (

			a_Instance ,
			a_Flags ,
			a_Context ,
			a_CallResult
		) ;

		ProviderSubSystem_Globals :: End_IdentifyCall_SvcHost ( a_InternalContext , t_OldContext , t_OldSecurity , t_Impersonating ) ;
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_IWbemServices_Stub :: Internal_PutInstanceAsync ( 

	WmiInternalContext a_InternalContext ,		
	IWbemClassObject *a_Instance , 
	long a_Flags , 
	IWbemContext *a_Context ,
	IWbemObjectSink *a_Sink
) 
{
	BOOL t_Impersonating = FALSE ;
	IUnknown *t_OldContext = NULL ;
	IServerSecurity *t_OldSecurity = NULL ;

	HRESULT t_Result = ProviderSubSystem_Globals :: Begin_IdentifyCall_SvcHost (

		a_InternalContext ,
		t_Impersonating ,
		t_OldContext ,
		t_OldSecurity
	) ;

	if ( SUCCEEDED ( t_Result ) )
	{
		t_Result = PutInstanceAsync (

			a_Instance , 
			a_Flags , 
			a_Context ,
			a_Sink
		) ;

		ProviderSubSystem_Globals :: End_IdentifyCall_SvcHost ( a_InternalContext , t_OldContext , t_OldSecurity , t_Impersonating ) ;
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_IWbemServices_Stub :: Internal_DeleteInstance ( 

	WmiInternalContext a_InternalContext ,
	const BSTR a_ObjectPath ,
    long a_Flags ,
    IWbemContext *a_Context ,
    IWbemCallResult **a_CallResult
)
{
	BOOL t_Impersonating = FALSE ;
	IUnknown *t_OldContext = NULL ;
	IServerSecurity *t_OldSecurity = NULL ;

	HRESULT t_Result = ProviderSubSystem_Globals :: Begin_IdentifyCall_SvcHost (

		a_InternalContext ,
		t_Impersonating ,
		t_OldContext ,
		t_OldSecurity
	) ;

	if ( SUCCEEDED ( t_Result ) )
	{
		t_Result = DeleteInstance (

			a_ObjectPath ,
			a_Flags ,
			a_Context ,
			a_CallResult
		) ;

		ProviderSubSystem_Globals :: End_IdentifyCall_SvcHost ( a_InternalContext , t_OldContext , t_OldSecurity , t_Impersonating ) ;
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_IWbemServices_Stub :: Internal_DeleteInstanceAsync ( 
		
	WmiInternalContext a_InternalContext ,
	const BSTR a_ObjectPath ,
	long a_Flags , 
	IWbemContext *a_Context ,
	IWbemObjectSink *a_Sink
) 
{
	BOOL t_Impersonating = FALSE ;
	IUnknown *t_OldContext = NULL ;
	IServerSecurity *t_OldSecurity = NULL ;

	HRESULT t_Result = ProviderSubSystem_Globals :: Begin_IdentifyCall_SvcHost (

		a_InternalContext ,
		t_Impersonating ,
		t_OldContext ,
		t_OldSecurity
	) ;

	if ( SUCCEEDED ( t_Result ) )
	{
		t_Result = DeleteInstanceAsync (

			a_ObjectPath ,
			a_Flags , 
			a_Context ,
			a_Sink
		) ;

		ProviderSubSystem_Globals :: End_IdentifyCall_SvcHost ( a_InternalContext , t_OldContext , t_OldSecurity , t_Impersonating ) ;
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_IWbemServices_Stub :: Internal_CreateInstanceEnum ( 

	WmiInternalContext a_InternalContext ,
	const BSTR a_Class ,
	long a_Flags , 
	IWbemContext *a_Context , 
	IEnumWbemClassObject **a_Enum
)
{
	BOOL t_Impersonating = FALSE ;
	IUnknown *t_OldContext = NULL ;
	IServerSecurity *t_OldSecurity = NULL ;

	HRESULT t_Result = ProviderSubSystem_Globals :: Begin_IdentifyCall_SvcHost (

		a_InternalContext ,
		t_Impersonating ,
		t_OldContext ,
		t_OldSecurity
	) ;

	if ( SUCCEEDED ( t_Result ) )
	{
		t_Result = CreateInstanceEnum (

			a_Class ,
			a_Flags , 
			a_Context , 
			a_Enum
		) ;

		ProviderSubSystem_Globals :: End_IdentifyCall_SvcHost ( a_InternalContext , t_OldContext , t_OldSecurity , t_Impersonating ) ;
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_IWbemServices_Stub :: Internal_CreateInstanceEnumAsync (

	WmiInternalContext a_InternalContext ,
 	const BSTR a_Class ,
	long a_Flags ,
	IWbemContext *a_Context ,
	IWbemObjectSink *a_Sink 
) 
{
	BOOL t_Impersonating = FALSE ;
	IUnknown *t_OldContext = NULL ;
	IServerSecurity *t_OldSecurity = NULL ;

	HRESULT t_Result = ProviderSubSystem_Globals :: Begin_IdentifyCall_SvcHost (

		a_InternalContext ,
		t_Impersonating ,
		t_OldContext ,
		t_OldSecurity
	) ;

	if ( SUCCEEDED ( t_Result ) )
	{
		t_Result = CreateInstanceEnumAsync (

			a_Class ,
			a_Flags ,
			a_Context ,
			a_Sink 
		) ;

		ProviderSubSystem_Globals :: End_IdentifyCall_SvcHost ( a_InternalContext , t_OldContext , t_OldSecurity , t_Impersonating ) ;
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_IWbemServices_Stub :: Internal_ExecQuery ( 

	WmiInternalContext a_InternalContext ,
	const BSTR a_QueryLanguage ,
	const BSTR a_Query ,
	long a_Flags ,
	IWbemContext *a_Context ,
	IEnumWbemClassObject **a_Enum
)
{
	BOOL t_Impersonating = FALSE ;
	IUnknown *t_OldContext = NULL ;
	IServerSecurity *t_OldSecurity = NULL ;

	HRESULT t_Result = ProviderSubSystem_Globals :: Begin_IdentifyCall_SvcHost (

		a_InternalContext ,
		t_Impersonating ,
		t_OldContext ,
		t_OldSecurity
	) ;

	if ( SUCCEEDED ( t_Result ) )
	{
		t_Result = ExecQuery (

			a_QueryLanguage ,
			a_Query ,
			a_Flags ,
			a_Context ,
			a_Enum
		) ;

		ProviderSubSystem_Globals :: End_IdentifyCall_SvcHost ( a_InternalContext , t_OldContext , t_OldSecurity , t_Impersonating ) ;
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_IWbemServices_Stub :: Internal_ExecQueryAsync ( 

	WmiInternalContext a_InternalContext ,		
	const BSTR a_QueryLanguage ,
	const BSTR a_Query, 
	long a_Flags , 
	IWbemContext *a_Context ,
	IWbemObjectSink *a_Sink
) 
{
	BOOL t_Impersonating = FALSE ;
	IUnknown *t_OldContext = NULL ;
	IServerSecurity *t_OldSecurity = NULL ;

	HRESULT t_Result = ProviderSubSystem_Globals :: Begin_IdentifyCall_SvcHost (

		a_InternalContext ,
		t_Impersonating ,
		t_OldContext ,
		t_OldSecurity
	) ;

	if ( SUCCEEDED ( t_Result ) )
	{
		t_Result = ExecQueryAsync (

			a_QueryLanguage ,
			a_Query, 
			a_Flags , 
			a_Context ,
			a_Sink
		) ;

		ProviderSubSystem_Globals :: End_IdentifyCall_SvcHost ( a_InternalContext , t_OldContext , t_OldSecurity , t_Impersonating ) ;
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_IWbemServices_Stub :: Internal_ExecNotificationQuery ( 

	WmiInternalContext a_InternalContext ,
	const BSTR a_QueryLanguage ,
    const BSTR a_Query ,
    long a_Flags ,
    IWbemContext *a_Context ,
    IEnumWbemClassObject **a_Enum
)
{
	BOOL t_Impersonating = FALSE ;
	IUnknown *t_OldContext = NULL ;
	IServerSecurity *t_OldSecurity = NULL ;

	HRESULT t_Result = ProviderSubSystem_Globals :: Begin_IdentifyCall_SvcHost (

		a_InternalContext ,
		t_Impersonating ,
		t_OldContext ,
		t_OldSecurity
	) ;

	if ( SUCCEEDED ( t_Result ) )
	{
		t_Result = ExecNotificationQuery (

			a_QueryLanguage ,
			a_Query ,
			a_Flags ,
			a_Context ,
			a_Enum
		) ;

		ProviderSubSystem_Globals :: End_IdentifyCall_SvcHost ( a_InternalContext , t_OldContext , t_OldSecurity , t_Impersonating ) ;
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/
        
HRESULT CInterceptor_IWbemServices_Stub :: Internal_ExecNotificationQueryAsync ( 

	WmiInternalContext a_InternalContext ,            
	const BSTR a_QueryLanguage ,
    const BSTR a_Query ,
    long a_Flags ,
    IWbemContext *a_Context ,
    IWbemObjectSink *a_Sink 
)
{
	BOOL t_Impersonating = FALSE ;
	IUnknown *t_OldContext = NULL ;
	IServerSecurity *t_OldSecurity = NULL ;

	HRESULT t_Result = ProviderSubSystem_Globals :: Begin_IdentifyCall_SvcHost (

		a_InternalContext ,
		t_Impersonating ,
		t_OldContext ,
		t_OldSecurity
	) ;

	if ( SUCCEEDED ( t_Result ) )
	{
		t_Result = ExecNotificationQueryAsync (

			a_QueryLanguage ,
			a_Query ,
			a_Flags ,
			a_Context ,
			a_Sink 
		) ;

		ProviderSubSystem_Globals :: End_IdentifyCall_SvcHost ( a_InternalContext , t_OldContext , t_OldSecurity , t_Impersonating ) ;
	}

	return t_Result ;
}       

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_IWbemServices_Stub :: Internal_ExecMethod (

	WmiInternalContext a_InternalContext ,
	const BSTR a_ObjectPath ,
    const BSTR a_MethodName ,
    long a_Flags ,
    IWbemContext *a_Context ,
    IWbemClassObject *a_InParams ,
    IWbemClassObject **a_OutParams ,
    IWbemCallResult **a_CallResult
)
{
	BOOL t_Impersonating = FALSE ;
	IUnknown *t_OldContext = NULL ;
	IServerSecurity *t_OldSecurity = NULL ;

	HRESULT t_Result = ProviderSubSystem_Globals :: Begin_IdentifyCall_SvcHost (

		a_InternalContext ,
		t_Impersonating ,
		t_OldContext ,
		t_OldSecurity
	) ;

	if ( SUCCEEDED ( t_Result ) )
	{
		t_Result = ExecMethod (

			a_ObjectPath ,
			a_MethodName ,
			a_Flags ,
			a_Context ,
			a_InParams ,
			a_OutParams ,
			a_CallResult
		) ;

		ProviderSubSystem_Globals :: End_IdentifyCall_SvcHost ( a_InternalContext , t_OldContext , t_OldSecurity , t_Impersonating ) ;
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_IWbemServices_Stub :: Internal_ExecMethodAsync ( 

	WmiInternalContext a_InternalContext ,		
    const BSTR a_ObjectPath ,
    const BSTR a_MethodName ,
    long a_Flags ,
    IWbemContext *a_Context ,
    IWbemClassObject *a_InParams ,
	IWbemObjectSink *a_Sink
) 
{
	BOOL t_Impersonating = FALSE ;
	IUnknown *t_OldContext = NULL ;
	IServerSecurity *t_OldSecurity = NULL ;

	HRESULT t_Result = ProviderSubSystem_Globals :: Begin_IdentifyCall_SvcHost (

		a_InternalContext ,
		t_Impersonating ,
		t_OldContext ,
		t_OldSecurity
	) ;

	if ( SUCCEEDED ( t_Result ) )
	{
		t_Result = ExecMethodAsync (

			a_ObjectPath ,
			a_MethodName ,
			a_Flags ,
			a_Context ,
			a_InParams ,
			a_Sink
		) ;

		ProviderSubSystem_Globals :: End_IdentifyCall_SvcHost ( a_InternalContext , t_OldContext , t_OldSecurity , t_Impersonating ) ;
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

#pragma warning( disable : 4355 )

CInterceptor_IWbemServices_Proxy :: CInterceptor_IWbemServices_Proxy (

	CWbemGlobal_VoidPointerController *a_Controller ,
	WmiAllocator &a_Allocator ,
	IWbemServices *a_Service ,
	CServerObject_ProviderRegistrationV1 &a_Registration

) : CWbemGlobal_IWmiObjectSinkController ( a_Allocator ) ,
	VoidPointerContainerElement ( 

		a_Controller ,
		this
	) ,
	m_Core_IWbemServices ( a_Service ) ,
	m_Core_IWbemRefreshingServices ( NULL ) ,
	m_Core_Internal_IWbemServices ( NULL ) ,
	m_GateClosed ( FALSE ) ,
	m_InProgress ( 0 ) ,
	m_Allocator ( a_Allocator ) ,
	m_Registration ( a_Registration ) , 
	m_ProxyContainer ( a_Allocator , ProxyIndex_Proxy_Size , MAX_PROXIES )
{
	InterlockedIncrement ( & ProviderSubSystem_Globals :: s_CInterceptor_IWbemServices_Proxy_ObjectsInProgress ) ;

	ProviderSubSystem_Globals :: Increment_Global_Object_Count () ;

	HRESULT t_Result = m_Core_IWbemServices->QueryInterface ( IID_IWbemRefreshingServices , ( void ** ) & m_Core_IWbemRefreshingServices ) ;
	t_Result = m_Core_IWbemServices->QueryInterface ( IID_Internal_IWbemServices , ( void ** ) & m_Core_Internal_IWbemServices ) ;

	m_Core_IWbemServices->AddRef () ;

	m_Registration.AddRef () ;
}

#pragma warning( default : 4355 )

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

CInterceptor_IWbemServices_Proxy :: ~CInterceptor_IWbemServices_Proxy ()
{
	CWbemGlobal_VoidPointerController :: UnInitialize () ;

	m_Registration.Release () ;

	WmiStatusCode t_StatusCode = m_ProxyContainer.UnInitialize () ;

	if ( m_Core_IWbemServices )
	{
		m_Core_IWbemServices->Release () ; 
	}

	if ( m_Core_Internal_IWbemServices )
	{
		m_Core_Internal_IWbemServices->Release () ; 
	}

	if ( m_Core_IWbemRefreshingServices )
	{
		m_Core_IWbemRefreshingServices->Release () ;
	}

	InterlockedDecrement ( & ProviderSubSystem_Globals :: s_CInterceptor_IWbemServices_Proxy_ObjectsInProgress ) ;

	ProviderSubSystem_Globals :: Decrement_Global_Object_Count () ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

STDMETHODIMP_(ULONG) CInterceptor_IWbemServices_Proxy :: AddRef ( void )
{
	return VoidPointerContainerElement :: AddRef () ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

STDMETHODIMP_(ULONG) CInterceptor_IWbemServices_Proxy :: Release ( void )
{
	return VoidPointerContainerElement :: Release () ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

STDMETHODIMP CInterceptor_IWbemServices_Proxy :: QueryInterface (

	REFIID iid , 
	LPVOID FAR *iplpv 
) 
{
	*iplpv = NULL ;

	if ( iid == IID_IUnknown )
	{
		*iplpv = ( LPVOID ) this ;
	}
	else if ( iid == IID_IWbemServices )
	{
		*iplpv = ( LPVOID ) ( IWbemServices * ) this ;		
	}
	else if ( iid == IID_IWbemRefreshingServices )
	{
		*iplpv = ( LPVOID ) ( IWbemRefreshingServices * ) this ;		
	}
	else if ( iid == IID_IWbemShutdown )
	{
		*iplpv = ( LPVOID ) ( IWbemShutdown * ) this ;		
	}	

	if ( *iplpv )
	{
		( ( LPUNKNOWN ) *iplpv )->AddRef () ;

		return ResultFromScode ( S_OK ) ;
	}
	else
	{
		return ResultFromScode ( E_NOINTERFACE ) ;
	}
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_IWbemServices_Proxy :: Begin_IWbemServices (

	DWORD a_ProcessIdentifier ,
	HANDLE &a_IdentifyToken ,
	BOOL &a_Impersonating ,
	IUnknown *&a_OldContext ,
	IServerSecurity *&a_OldSecurity ,
	BOOL &a_IsProxy ,
	IUnknown *&a_Interface ,
	BOOL &a_Revert ,
	IUnknown *&a_Proxy
)
{
	HRESULT t_Result = S_OK ;

	a_IdentifyToken = NULL ;
	a_Revert = FALSE ;
	a_Proxy = NULL ;
	a_Impersonating = FALSE ;
	a_OldContext = NULL ;
	a_OldSecurity = NULL ;

	t_Result = ProviderSubSystem_Common_Globals :: BeginCallbackImpersonation ( a_OldContext , a_OldSecurity , a_Impersonating ) ;
	if ( SUCCEEDED ( t_Result ) ) 
	{
		if ( a_ProcessIdentifier )
		{
			t_Result = CoImpersonateClient () ;
			if ( SUCCEEDED ( t_Result ) )
			{
				DWORD t_ImpersonationLevel = ProviderSubSystem_Common_Globals :: GetCurrentImpersonationLevel () ;

				CoRevertToSelf () ;

				if ( t_ImpersonationLevel == RPC_C_IMP_LEVEL_IMPERSONATE || t_ImpersonationLevel == RPC_C_IMP_LEVEL_DELEGATE )
				{
					t_Result = ProviderSubSystem_Common_Globals :: SetProxyState ( 
					
						m_ProxyContainer , 
						ProxyIndex_Proxy_IWbemServices , 
						IID_IWbemServices , 
						m_Core_IWbemServices , 
						a_Proxy , 
						a_Revert
					) ;
				}
				else
				{
					t_Result = ProviderSubSystem_Common_Globals :: SetProxyState_PrvHost ( 
					
						m_ProxyContainer , 
						ProxyIndex_Proxy_Internal_IWbemServices , 
						IID_Internal_IWbemServices , 
						m_Core_Internal_IWbemServices , 
						a_Proxy , 
						a_Revert ,
						a_ProcessIdentifier ,
						a_IdentifyToken 
					) ;
				}
			}
		}
		else
		{
			t_Result = ProviderSubSystem_Common_Globals :: SetProxyState ( 
			
				m_ProxyContainer , 
				ProxyIndex_Proxy_IWbemServices , 
				IID_IWbemServices , 
				m_Core_IWbemServices , 
				a_Proxy , 
				a_Revert
			) ;
		}

		if ( t_Result == WBEM_E_NOT_FOUND )
		{
			a_Interface = m_Core_IWbemServices ;
			a_IsProxy = FALSE ;
			t_Result = S_OK ;
		}
		else
		{
			if ( SUCCEEDED ( t_Result ) )
			{
				a_IsProxy = TRUE ;

				a_Interface = ( IUnknown * ) a_Proxy ;

				// Set cloaking on the proxy
				// =========================

				DWORD t_ImpersonationLevel = ProviderSubSystem_Common_Globals :: GetCurrentImpersonationLevel () ;

				t_Result = ProviderSubSystem_Common_Globals :: SetCloaking (

					a_Interface ,
					RPC_C_AUTHN_LEVEL_DEFAULT , 
					t_ImpersonationLevel
				) ;

				if ( FAILED ( t_Result ) )
				{
					if ( a_IdentifyToken )
					{
						HRESULT t_TempResult = ProviderSubSystem_Common_Globals :: RevertProxyState_PrvHost ( 

							m_ProxyContainer , 
							ProxyIndex_Proxy_Internal_IWbemServices , 
							a_Proxy , 
							a_Revert ,
							a_ProcessIdentifier , 
							a_IdentifyToken 
						) ;
					}
					else
					{
						HRESULT t_TempResult = ProviderSubSystem_Common_Globals :: RevertProxyState ( 

							m_ProxyContainer , 
							ProxyIndex_Proxy_IWbemServices , 
							a_Proxy , 
							a_Revert
						) ;
					}
				}
			}
		}

		if ( FAILED ( t_Result ) )
		{
			ProviderSubSystem_Common_Globals :: EndImpersonation ( a_OldContext , a_OldSecurity , a_Impersonating ) ;
		}
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_IWbemServices_Proxy :: End_IWbemServices (

	DWORD a_ProcessIdentifier ,
	HANDLE a_IdentifyToken ,
	BOOL a_Impersonating ,
	IUnknown *a_OldContext ,
	IServerSecurity *a_OldSecurity ,
	BOOL a_IsProxy ,
	IUnknown *a_Interface ,
	BOOL a_Revert ,
	IUnknown *a_Proxy
)
{
	CoRevertToSelf () ;

	if ( a_Proxy )
	{
		if ( a_IdentifyToken )
		{
			HRESULT t_TempResult = ProviderSubSystem_Common_Globals :: RevertProxyState_PrvHost ( 

				m_ProxyContainer , 
				ProxyIndex_Proxy_Internal_IWbemServices , 
				a_Proxy , 
				a_Revert ,
				a_ProcessIdentifier , 
				a_IdentifyToken 
			) ;
		}
		else
		{
			HRESULT t_TempResult = ProviderSubSystem_Common_Globals :: RevertProxyState ( 

				m_ProxyContainer , 
				ProxyIndex_Proxy_IWbemServices , 
				a_Proxy , 
				a_Revert
			) ;
		}
	}

	ProviderSubSystem_Common_Globals :: EndImpersonation ( a_OldContext , a_OldSecurity , a_Impersonating ) ;
	
	return S_OK ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_IWbemServices_Proxy :: Begin_IWbemRefreshingServices (

	BOOL &a_Impersonating ,
	IUnknown *&a_OldContext ,
	IServerSecurity *&a_OldSecurity ,
	BOOL &a_IsProxy ,
	IWbemRefreshingServices *&a_Interface ,
	BOOL &a_Revert ,
	IUnknown *&a_Proxy ,
	IWbemContext *a_Context 
)
{
	HRESULT t_Result = S_OK ;

	a_Revert = FALSE ;
	a_Proxy = NULL ;
	a_Impersonating = FALSE ;
	a_OldContext = NULL ;
	a_OldSecurity = NULL ;

	t_Result = ProviderSubSystem_Common_Globals :: BeginCallbackImpersonation ( a_OldContext , a_OldSecurity , a_Impersonating ) ;
	if ( SUCCEEDED ( t_Result ) ) 
	{
		t_Result = ProviderSubSystem_Common_Globals :: SetProxyState ( 

			m_ProxyContainer , 
			ProxyIndex_Proxy_IWbemRefreshingServices , 
			IID_IWbemRefreshingServices , 
			m_Core_IWbemRefreshingServices , 
			a_Proxy , 
			a_Revert
		) ;

		if ( t_Result == WBEM_E_NOT_FOUND )
		{
			a_Interface = m_Core_IWbemRefreshingServices ;
			a_IsProxy = FALSE ;
			t_Result = S_OK ;
		}
		else
		{
			if ( SUCCEEDED ( t_Result ) )
			{
				a_IsProxy = TRUE ;

				a_Interface = ( IWbemRefreshingServices * ) a_Proxy ;

				// Set cloaking on the proxy
				// =========================

				DWORD t_ImpersonationLevel = ProviderSubSystem_Common_Globals :: GetCurrentImpersonationLevel () ;

				t_Result = ProviderSubSystem_Common_Globals :: SetCloaking (

					a_Interface ,
					RPC_C_AUTHN_LEVEL_DEFAULT , 
					t_ImpersonationLevel
				) ;

				if ( FAILED ( t_Result ) )
				{
					HRESULT t_TempResult = ProviderSubSystem_Common_Globals :: RevertProxyState ( 

						m_ProxyContainer , 
						ProxyIndex_Proxy_IWbemRefreshingServices , 
						a_Proxy , 
						a_Revert
					) ;
				}
			}
		}

		if ( FAILED ( t_Result ) )
		{
			ProviderSubSystem_Common_Globals :: EndImpersonation ( a_OldContext , a_OldSecurity , a_Impersonating ) ;
		}
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_IWbemServices_Proxy :: End_IWbemRefreshingServices (

	BOOL a_Impersonating ,
	IUnknown *a_OldContext ,
	IServerSecurity *a_OldSecurity ,
	BOOL a_IsProxy ,
	IWbemRefreshingServices *a_Interface ,
	BOOL a_Revert ,
	IUnknown *a_Proxy
)
{
	CoRevertToSelf () ;

	if ( a_Proxy )
	{
		HRESULT t_TempResult = ProviderSubSystem_Common_Globals :: RevertProxyState ( 

			m_ProxyContainer , 
			ProxyIndex_Proxy_IWbemRefreshingServices , 
			a_Proxy , 
			a_Revert
		) ;
	}

	ProviderSubSystem_Common_Globals :: EndImpersonation ( a_OldContext , a_OldSecurity , a_Impersonating ) ;
	
	return S_OK ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_IWbemServices_Proxy :: Enqueue_IWbemServices (

	IWbemServices *a_Service ,
	IWbemServices *&a_Proxy
)
{
	HRESULT t_Result = S_OK ;

	CInterceptor_IWbemServices_Proxy *t_Proxy = new CInterceptor_IWbemServices_Proxy ( 

		this , 
		m_Allocator , 
		a_Service ,
		m_Registration
	) ;

	if ( t_Proxy )
	{
		t_Proxy->AddRef () ;

		t_Result = t_Proxy->ServiceInitialize () ;
		if ( SUCCEEDED ( t_Result ) ) 
		{
			CWbemGlobal_VoidPointerController_Container_Iterator t_Iterator ;


			Lock () ;

			WmiStatusCode t_StatusCode = Insert ( 

				*t_Proxy ,
				t_Iterator
			) ;

			if ( t_StatusCode == e_StatusCode_Success ) 
			{
				a_Proxy = t_Proxy ;
			}
			else
			{
				t_Result = WBEM_E_OUT_OF_MEMORY ;
			}

			UnLock () ;
		}
		else
		{
			t_Proxy->Release () ;
		}
	}
	else
	{
		t_Result = WBEM_E_OUT_OF_MEMORY ;
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_IWbemServices_Proxy :: Enqueue_IEnumWbemClassObject (

	IEnumWbemClassObject *a_Enum ,
	IEnumWbemClassObject *&a_Proxy
)
{
	HRESULT t_Result = S_OK ;

	CInterceptor_IEnumWbemClassObject_Proxy *t_Proxy = new CInterceptor_IEnumWbemClassObject_Proxy ( 

		this , 
		m_Allocator , 
		a_Enum
	) ;

	if ( t_Proxy )
	{
		t_Proxy->AddRef () ;

		t_Result = t_Proxy->EnumInitialize () ;
		if ( SUCCEEDED ( t_Result ) ) 
		{
			CWbemGlobal_VoidPointerController_Container_Iterator t_Iterator ;


			Lock () ;

			WmiStatusCode t_StatusCode = Insert ( 

				*t_Proxy ,
				t_Iterator
			) ;

			if ( t_StatusCode == e_StatusCode_Success ) 
			{
				a_Proxy = t_Proxy ;
			}
			else
			{
				t_Result = WBEM_E_OUT_OF_MEMORY ;
			}

			UnLock () ;
		}
		else
		{
			t_Proxy->Release () ;
		}
	}
	else
	{
		t_Result = WBEM_E_OUT_OF_MEMORY ;
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_IWbemServices_Proxy::OpenNamespace ( 

	const BSTR a_ObjectPath ,
	long a_Flags ,
	IWbemContext *a_Context ,
	IWbemServices **a_NamespaceService ,
	IWbemCallResult **a_CallResult
)
{
	HRESULT t_Result = S_OK ;

	try
	{
		*a_NamespaceService = NULL ;
	}
	catch ( ... ) 
	{
		t_Result = WBEM_E_CRITICAL_ERROR ;
	}

	if ( SUCCEEDED ( t_Result ) )
	{
		InterlockedIncrement ( & m_InProgress ) ;

		if ( m_GateClosed == 1 )
		{
			t_Result = WBEM_E_SHUTTING_DOWN ;
		}
		else
		{
			BOOL t_Impersonating ;
			IUnknown *t_OldContext ;
			IServerSecurity *t_OldSecurity ;
			BOOL t_IsProxy ;
			IUnknown *t_Interface ;
			BOOL t_Revert ;
			IUnknown *t_Proxy ;
			DWORD t_ProcessIdentifier = GetCurrentProcessId () ;
			HANDLE t_IdentifyToken = NULL ;

			t_Result = Begin_IWbemServices (

				t_ProcessIdentifier ,
				t_IdentifyToken ,
				t_Impersonating ,
				t_OldContext ,
				t_OldSecurity ,
				t_IsProxy ,
				t_Interface ,
				t_Revert ,
				t_Proxy
			) ;

			if ( SUCCEEDED ( t_Result ) )
			{
				if ( t_IdentifyToken )
				{
					WmiInternalContext t_InternalContext ;
					t_InternalContext.m_IdentifyHandle = ( unsigned __int64 ) t_IdentifyToken ;
					t_InternalContext.m_ProcessIdentifier = t_ProcessIdentifier ;

					BSTR t_ObjectPath = SysAllocString ( a_ObjectPath ) ;
					if ( t_ObjectPath )
					{
						IWbemServices *t_Service = NULL ;

						t_Result = ( ( Internal_IWbemServices * ) t_Interface )->Internal_OpenNamespace (

							t_InternalContext ,
							t_ObjectPath, 
							a_Flags, 
							a_Context ,
							& t_Service , 
							a_CallResult
						) ;

						if ( SUCCEEDED ( t_Result ) )
						{
							t_Result = Enqueue_IWbemServices ( 

								t_Service ,
								*a_NamespaceService
							) ;
						}

						SysFreeString ( t_ObjectPath ) ;
					}
					else
					{
						t_Result = WBEM_E_OUT_OF_MEMORY ;
					}
				}
				else
				{
					IWbemServices *t_Service = NULL ;

					t_Result = ( ( IWbemServices * ) t_Interface )->OpenNamespace (

						a_ObjectPath, 
						a_Flags, 
						a_Context ,
						& t_Service , 
						a_CallResult
					) ;

					if ( SUCCEEDED ( t_Result ) )
					{
						t_Result = Enqueue_IWbemServices ( 

							t_Service ,
							*a_NamespaceService
						) ;
					}
				}

				End_IWbemServices (

					t_ProcessIdentifier ,
					t_IdentifyToken ,
					t_Impersonating ,
					t_OldContext ,
					t_OldSecurity ,
					t_IsProxy ,
					t_Interface ,
					t_Revert ,
					t_Proxy
				) ;
			}
		}

		InterlockedDecrement ( & m_InProgress ) ;
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_IWbemServices_Proxy :: CancelAsyncCall ( 
		
	IWbemObjectSink *a_Sink
)
{
	HRESULT t_Result = S_OK ;

	InterlockedIncrement ( & m_InProgress ) ;

	if ( m_GateClosed == 1 )
	{
		t_Result = WBEM_E_SHUTTING_DOWN ;
	}
	else
	{
		BOOL t_Impersonating ;
		IUnknown *t_OldContext ;
		IServerSecurity *t_OldSecurity ;
		BOOL t_IsProxy ;
		IUnknown *t_Interface ;
		BOOL t_Revert ;
		IUnknown *t_Proxy ;
		DWORD t_ProcessIdentifier = GetCurrentProcessId () ;
		HANDLE t_IdentifyToken = NULL ;

		t_Result = Begin_IWbemServices (

			t_ProcessIdentifier ,
			t_IdentifyToken ,
			t_Impersonating ,
			t_OldContext ,
			t_OldSecurity ,
			t_IsProxy ,
			t_Interface ,
			t_Revert ,
			t_Proxy
		) ;

		if ( SUCCEEDED ( t_Result ) )
		{
			if ( t_IdentifyToken )
			{
				WmiInternalContext t_InternalContext ;
				t_InternalContext.m_IdentifyHandle = ( unsigned __int64 ) t_IdentifyToken ;
				t_InternalContext.m_ProcessIdentifier = t_ProcessIdentifier ;

				t_Result = ( ( Internal_IWbemServices * ) t_Interface )->Internal_CancelAsyncCall (

					t_InternalContext ,
					a_Sink
				) ;
			}
			else
			{
				t_Result = ( ( IWbemServices * ) t_Interface )->CancelAsyncCall (

					a_Sink
				) ;
			}

			End_IWbemServices (

				t_ProcessIdentifier ,
				t_IdentifyToken ,
				t_Impersonating ,
				t_OldContext ,
				t_OldSecurity ,
				t_IsProxy ,
				t_Interface ,
				t_Revert ,
				t_Proxy
			) ;
		}
	}

	InterlockedDecrement ( & m_InProgress ) ;

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_IWbemServices_Proxy :: QueryObjectSink ( 

	long a_Flags ,
	IWbemObjectSink **a_Sink
) 
{
	HRESULT t_Result = S_OK ;

	InterlockedIncrement ( & m_InProgress ) ;

	if ( m_GateClosed == 1 )
	{
		t_Result = WBEM_E_SHUTTING_DOWN ;
	}
	else
	{
		BOOL t_Impersonating ;
		IUnknown *t_OldContext ;
		IServerSecurity *t_OldSecurity ;
		BOOL t_IsProxy ;
		IUnknown *t_Interface ;
		BOOL t_Revert ;
		IUnknown *t_Proxy ;
		DWORD t_ProcessIdentifier = GetCurrentProcessId () ;
		HANDLE t_IdentifyToken = NULL ;

		t_Result = Begin_IWbemServices (

			t_ProcessIdentifier ,
			t_IdentifyToken ,
			t_Impersonating ,
			t_OldContext ,
			t_OldSecurity ,
			t_IsProxy ,
			t_Interface ,
			t_Revert ,
			t_Proxy
		) ;

		if ( SUCCEEDED ( t_Result ) )
		{
			if ( t_IdentifyToken )
			{
				WmiInternalContext t_InternalContext ;
				t_InternalContext.m_IdentifyHandle = ( unsigned __int64 ) t_IdentifyToken ;
				t_InternalContext.m_ProcessIdentifier = t_ProcessIdentifier ;

				t_Result = ( ( Internal_IWbemServices * ) t_Interface )->Internal_QueryObjectSink (

					t_InternalContext ,
					a_Flags ,
					a_Sink
				) ;
			}
			else
			{
				t_Result = ( ( IWbemServices * ) t_Interface )->QueryObjectSink (

					a_Flags ,
					a_Sink
				) ;
			}

			End_IWbemServices (

				t_ProcessIdentifier ,
				t_IdentifyToken ,
				t_Impersonating ,
				t_OldContext ,
				t_OldSecurity ,
				t_IsProxy ,
				t_Interface ,
				t_Revert ,
				t_Proxy
			) ;
		}
	}

	InterlockedDecrement ( & m_InProgress ) ;

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_IWbemServices_Proxy :: GetObject ( 
		
	const BSTR a_ObjectPath ,
    long a_Flags ,
    IWbemContext *a_Context ,
    IWbemClassObject **a_Object ,
    IWbemCallResult **a_CallResult
)
{
	HRESULT t_Result = S_OK ;

	InterlockedIncrement ( & m_InProgress ) ;

	if ( m_GateClosed == 1 )
	{
		t_Result = WBEM_E_SHUTTING_DOWN ;
	}
	else
	{
		BOOL t_Impersonating ;
		IUnknown *t_OldContext ;
		IServerSecurity *t_OldSecurity ;
		BOOL t_IsProxy ;
		IUnknown *t_Interface ;
		BOOL t_Revert ;
		IUnknown *t_Proxy ;
		DWORD t_ProcessIdentifier = GetCurrentProcessId () ;
		HANDLE t_IdentifyToken = NULL ;

		t_Result = Begin_IWbemServices (

			t_ProcessIdentifier ,
			t_IdentifyToken ,
			t_Impersonating ,
			t_OldContext ,
			t_OldSecurity ,
			t_IsProxy ,
			t_Interface ,
			t_Revert ,
			t_Proxy
		) ;

		if ( SUCCEEDED ( t_Result ) )
		{
			if ( t_IdentifyToken )
			{
				WmiInternalContext t_InternalContext ;
				t_InternalContext.m_IdentifyHandle = ( unsigned __int64 ) t_IdentifyToken ;
				t_InternalContext.m_ProcessIdentifier = t_ProcessIdentifier ;

				BSTR t_ObjectPath = SysAllocString ( a_ObjectPath ) ;
				if ( t_ObjectPath )
				{
					t_Result = ( ( Internal_IWbemServices * ) t_Interface )->Internal_GetObject (

						t_InternalContext ,
						t_ObjectPath,
						a_Flags,
						a_Context ,
						a_Object,
						a_CallResult
					) ;

					SysFreeString ( t_ObjectPath ) ;
				}
				else
				{
					t_Result = WBEM_E_OUT_OF_MEMORY ;
				}

			}
			else
			{
				t_Result = ( ( IWbemServices * ) t_Interface )->GetObject (

					a_ObjectPath,
					a_Flags,
					a_Context ,
					a_Object,
					a_CallResult
				) ;
			}

			End_IWbemServices (

				t_ProcessIdentifier ,
				t_IdentifyToken ,
				t_Impersonating ,
				t_OldContext ,
				t_OldSecurity ,
				t_IsProxy ,
				t_Interface ,
				t_Revert ,
				t_Proxy
			) ;
		}
	}

	InterlockedDecrement ( & m_InProgress ) ;

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_IWbemServices_Proxy :: GetObjectAsync ( 
		
	const BSTR a_ObjectPath ,
	long a_Flags , 
	IWbemContext *a_Context ,
	IWbemObjectSink *a_Sink
) 
{
	HRESULT t_Result = S_OK ;

	InterlockedIncrement ( & m_InProgress ) ;

	if ( m_GateClosed == 1 )
	{
		t_Result = WBEM_E_SHUTTING_DOWN ;
	}
	else
	{
		BOOL t_Impersonating ;
		IUnknown *t_OldContext ;
		IServerSecurity *t_OldSecurity ;
		BOOL t_IsProxy ;
		IUnknown *t_Interface ;
		BOOL t_Revert ;
		IUnknown *t_Proxy ;
		DWORD t_ProcessIdentifier = GetCurrentProcessId () ;
		HANDLE t_IdentifyToken = NULL ;

		t_Result = Begin_IWbemServices (

			t_ProcessIdentifier ,
			t_IdentifyToken ,
			t_Impersonating ,
			t_OldContext ,
			t_OldSecurity ,
			t_IsProxy ,
			t_Interface ,
			t_Revert ,
			t_Proxy
		) ;

		if ( SUCCEEDED ( t_Result ) )
		{
			if ( t_IdentifyToken )
			{
				WmiInternalContext t_InternalContext ;
				t_InternalContext.m_IdentifyHandle = ( unsigned __int64 ) t_IdentifyToken ;
				t_InternalContext.m_ProcessIdentifier = t_ProcessIdentifier ;

				BSTR t_ObjectPath = SysAllocString ( a_ObjectPath ) ;
				if ( t_ObjectPath )
				{
					t_Result = ( ( Internal_IWbemServices * ) t_Interface )->Internal_GetObjectAsync (

						t_InternalContext ,
						t_ObjectPath, 
						a_Flags, 
						a_Context ,
						a_Sink
					) ;

					SysFreeString ( t_ObjectPath ) ;
				}
				else
				{
					t_Result = WBEM_E_OUT_OF_MEMORY ;
				}
			}
			else
			{
				t_Result = ( ( IWbemServices * ) t_Interface )->GetObjectAsync (

					a_ObjectPath, 
					a_Flags, 
					a_Context ,
					a_Sink
				) ;
			}

			End_IWbemServices (

				t_ProcessIdentifier ,
				t_IdentifyToken ,
				t_Impersonating ,
				t_OldContext ,
				t_OldSecurity ,
				t_IsProxy ,
				t_Interface ,
				t_Revert ,
				t_Proxy
			) ;
		}
	}

	InterlockedDecrement ( & m_InProgress ) ;

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_IWbemServices_Proxy :: PutClass ( 
		
	IWbemClassObject *a_Object ,
	long a_Flags , 
	IWbemContext *a_Context ,
	IWbemCallResult **a_CallResult
) 
{
	HRESULT t_Result = S_OK ;

	InterlockedIncrement ( & m_InProgress ) ;

	if ( m_GateClosed == 1 )
	{
		t_Result = WBEM_E_SHUTTING_DOWN ;
	}
	else
	{
		BOOL t_Impersonating ;
		IUnknown *t_OldContext ;
		IServerSecurity *t_OldSecurity ;
		BOOL t_IsProxy ;
		IUnknown *t_Interface ;
		BOOL t_Revert ;
		IUnknown *t_Proxy ;
		DWORD t_ProcessIdentifier = GetCurrentProcessId () ;
		HANDLE t_IdentifyToken = NULL ;

		t_Result = Begin_IWbemServices (

			t_ProcessIdentifier ,
			t_IdentifyToken ,
			t_Impersonating ,
			t_OldContext ,
			t_OldSecurity ,
			t_IsProxy ,
			t_Interface ,
			t_Revert ,
			t_Proxy
		) ;

		if ( SUCCEEDED ( t_Result ) )
		{
			if ( t_IdentifyToken )
			{
				WmiInternalContext t_InternalContext ;
				t_InternalContext.m_IdentifyHandle = ( unsigned __int64 ) t_IdentifyToken ;
				t_InternalContext.m_ProcessIdentifier = t_ProcessIdentifier ;

				t_Result = ( ( Internal_IWbemServices * ) t_Interface )->Internal_PutClass (

					t_InternalContext ,
					a_Object, 
					a_Flags, 
					a_Context,
					a_CallResult
				) ;
			}
			else
			{
				t_Result = ( ( IWbemServices * ) t_Interface )->PutClass (

					a_Object, 
					a_Flags, 
					a_Context,
					a_CallResult
				) ;
			}

			End_IWbemServices (

				t_ProcessIdentifier ,
				t_IdentifyToken ,
				t_Impersonating ,
				t_OldContext ,
				t_OldSecurity ,
				t_IsProxy ,
				t_Interface ,
				t_Revert ,
				t_Proxy
			) ;
		}
	}

	InterlockedDecrement ( & m_InProgress ) ;

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_IWbemServices_Proxy :: PutClassAsync ( 
		
	IWbemClassObject *a_Object , 
	long a_Flags ,
	IWbemContext FAR *a_Context ,
	IWbemObjectSink *a_Sink
) 
{
	HRESULT t_Result = S_OK ;

	InterlockedIncrement ( & m_InProgress ) ;

	if ( m_GateClosed == 1 )
	{
		t_Result = WBEM_E_SHUTTING_DOWN ;
	}
	else
	{
		BOOL t_Impersonating ;
		IUnknown *t_OldContext ;
		IServerSecurity *t_OldSecurity ;
		BOOL t_IsProxy ;
		IUnknown *t_Interface ;
		BOOL t_Revert ;
		IUnknown *t_Proxy ;
		DWORD t_ProcessIdentifier = GetCurrentProcessId () ;
		HANDLE t_IdentifyToken = NULL ;

		t_Result = Begin_IWbemServices (

			t_ProcessIdentifier ,
			t_IdentifyToken ,
			t_Impersonating ,
			t_OldContext ,
			t_OldSecurity ,
			t_IsProxy ,
			t_Interface ,
			t_Revert ,
			t_Proxy
		) ;

		if ( SUCCEEDED ( t_Result ) )
		{
			if ( t_IdentifyToken )
			{
				WmiInternalContext t_InternalContext ;
				t_InternalContext.m_IdentifyHandle = ( unsigned __int64 ) t_IdentifyToken ;
				t_InternalContext.m_ProcessIdentifier = t_ProcessIdentifier ;

				t_Result = ( ( Internal_IWbemServices * ) t_Interface )->Internal_PutClassAsync (

					t_InternalContext ,
					a_Object, 
					a_Flags, 
					a_Context ,
					a_Sink
				) ;
			}
			else
			{
				t_Result = ( ( IWbemServices * ) t_Interface )->PutClassAsync (

					a_Object, 
					a_Flags, 
					a_Context ,
					a_Sink
				) ;
			}

			End_IWbemServices (

				t_ProcessIdentifier ,
				t_IdentifyToken ,
				t_Impersonating ,
				t_OldContext ,
				t_OldSecurity ,
				t_IsProxy ,
				t_Interface ,
				t_Revert ,
				t_Proxy
			) ;
		}
	}

	InterlockedDecrement ( & m_InProgress ) ;

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_IWbemServices_Proxy :: DeleteClass ( 
		
	const BSTR a_Class , 
	long a_Flags , 
	IWbemContext *a_Context ,
	IWbemCallResult **a_CallResult
) 
{
	HRESULT t_Result = S_OK ;

	InterlockedIncrement ( & m_InProgress ) ;

	if ( m_GateClosed == 1 )
	{
		t_Result = WBEM_E_SHUTTING_DOWN ;
	}
	else
	{
		BOOL t_Impersonating ;
		IUnknown *t_OldContext ;
		IServerSecurity *t_OldSecurity ;
		BOOL t_IsProxy ;
		IUnknown *t_Interface ;
		BOOL t_Revert ;
		IUnknown *t_Proxy ;
		DWORD t_ProcessIdentifier = GetCurrentProcessId () ;
		HANDLE t_IdentifyToken = NULL ;

		t_Result = Begin_IWbemServices (

			t_ProcessIdentifier ,
			t_IdentifyToken ,
			t_Impersonating ,
			t_OldContext ,
			t_OldSecurity ,
			t_IsProxy ,
			t_Interface ,
			t_Revert ,
			t_Proxy
		) ;

		if ( SUCCEEDED ( t_Result ) )
		{
			if ( t_IdentifyToken )
			{
				WmiInternalContext t_InternalContext ;
				t_InternalContext.m_IdentifyHandle = ( unsigned __int64 ) t_IdentifyToken ;
				t_InternalContext.m_ProcessIdentifier = t_ProcessIdentifier ;

				BSTR t_Class = SysAllocString ( a_Class ) ;
				if ( t_Class )
				{
					t_Result = ( ( Internal_IWbemServices * ) t_Interface )->Internal_DeleteClass (

						t_InternalContext ,
						t_Class, 
						a_Flags, 
						a_Context,
						a_CallResult
					) ;

					SysFreeString ( t_Class ) ;
				}
				else
				{
					t_Result = WBEM_E_OUT_OF_MEMORY ;
				}
			}
			else
			{
				t_Result = ( ( IWbemServices * ) t_Interface )->DeleteClass (

					a_Class, 
					a_Flags, 
					a_Context,
					a_CallResult
				) ;
			}

			End_IWbemServices (

				t_ProcessIdentifier ,
				t_IdentifyToken ,
				t_Impersonating ,
				t_OldContext ,
				t_OldSecurity ,
				t_IsProxy ,
				t_Interface ,
				t_Revert ,
				t_Proxy
			) ;
		}
	}

	InterlockedDecrement ( & m_InProgress ) ;

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_IWbemServices_Proxy :: DeleteClassAsync ( 
		
	const BSTR a_Class ,
	long a_Flags,
	IWbemContext *a_Context ,
	IWbemObjectSink *a_Sink
) 
{
	HRESULT t_Result = S_OK ;

	InterlockedIncrement ( & m_InProgress ) ;

	if ( m_GateClosed == 1 )
	{
		t_Result = WBEM_E_SHUTTING_DOWN ;
	}
	else
	{
		BOOL t_Impersonating ;
		IUnknown *t_OldContext ;
		IServerSecurity *t_OldSecurity ;
		BOOL t_IsProxy ;
		IUnknown *t_Interface ;
		BOOL t_Revert ;
		IUnknown *t_Proxy ;
		DWORD t_ProcessIdentifier = GetCurrentProcessId () ;
		HANDLE t_IdentifyToken = NULL ;

		t_Result = Begin_IWbemServices (

			t_ProcessIdentifier ,
			t_IdentifyToken ,
			t_Impersonating ,
			t_OldContext ,
			t_OldSecurity ,
			t_IsProxy ,
			t_Interface ,
			t_Revert ,
			t_Proxy
		) ;

		if ( SUCCEEDED ( t_Result ) )
		{
			if ( t_IdentifyToken )
			{
				WmiInternalContext t_InternalContext ;
				t_InternalContext.m_IdentifyHandle = ( unsigned __int64 ) t_IdentifyToken ;
				t_InternalContext.m_ProcessIdentifier = t_ProcessIdentifier ;

				BSTR t_Class = SysAllocString ( a_Class ) ;
				if ( t_Class )
				{
					t_Result = ( ( Internal_IWbemServices * ) t_Interface )->Internal_DeleteClassAsync (

						t_InternalContext ,
						t_Class , 
						a_Flags , 
						a_Context ,
						a_Sink
					) ;

					SysFreeString ( t_Class ) ;
				}
				else
				{
					t_Result = WBEM_E_OUT_OF_MEMORY ;
				}
			}
			else
			{
				t_Result = ( ( IWbemServices * ) t_Interface )->DeleteClassAsync (

					a_Class , 
					a_Flags , 
					a_Context ,
					a_Sink
				) ;
			}

			End_IWbemServices (

				t_ProcessIdentifier ,
				t_IdentifyToken ,
				t_Impersonating ,
				t_OldContext ,
				t_OldSecurity ,
				t_IsProxy ,
				t_Interface ,
				t_Revert ,
				t_Proxy
			) ;
		}
	}

	InterlockedDecrement ( & m_InProgress ) ;

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_IWbemServices_Proxy :: CreateClassEnum ( 

	const BSTR a_SuperClass ,
	long a_Flags, 
	IWbemContext *a_Context ,
	IEnumWbemClassObject **a_Enum
) 
{
	HRESULT t_Result = S_OK ;

	try
	{
		*a_Enum = NULL ;
	}
	catch ( ... ) 
	{
		t_Result = WBEM_E_CRITICAL_ERROR ;
	}

	if ( SUCCEEDED ( t_Result ) )
	{
		InterlockedIncrement ( & m_InProgress ) ;

		if ( m_GateClosed == 1 )
		{
			t_Result = WBEM_E_SHUTTING_DOWN ;
		}
		else
		{
			BOOL t_Impersonating ;
			IUnknown *t_OldContext ;
			IServerSecurity *t_OldSecurity ;
			BOOL t_IsProxy ;
			IUnknown *t_Interface ;
			BOOL t_Revert ;
			IUnknown *t_Proxy ;
			DWORD t_ProcessIdentifier = GetCurrentProcessId () ;
			HANDLE t_IdentifyToken = NULL ;

			t_Result = Begin_IWbemServices (

				t_ProcessIdentifier ,
				t_IdentifyToken ,
				t_Impersonating ,
				t_OldContext ,
				t_OldSecurity ,
				t_IsProxy ,
				t_Interface ,
				t_Revert ,
				t_Proxy
			) ;

			if ( SUCCEEDED ( t_Result ) )
			{
				if ( t_IdentifyToken )
				{
					WmiInternalContext t_InternalContext ;
					t_InternalContext.m_IdentifyHandle = ( unsigned __int64 ) t_IdentifyToken ;
					t_InternalContext.m_ProcessIdentifier = t_ProcessIdentifier ;

					BSTR t_SuperClass = SysAllocString ( a_SuperClass ) ;
					if ( t_SuperClass )
					{
						IEnumWbemClassObject *t_Enum = NULL ;

						t_Result = ( ( Internal_IWbemServices * ) t_Interface )->Internal_CreateClassEnum (

							t_InternalContext ,
							t_SuperClass, 
							a_Flags, 
							a_Context,
							& t_Enum
						) ;

						if ( SUCCEEDED ( t_Result ) )
						{
							HRESULT t_TempResult = Enqueue_IEnumWbemClassObject ( 

								t_Enum ,
								*a_Enum
							) ;

							if ( FAILED ( t_TempResult ) )
							{
								t_Result = t_TempResult ;
							}

							t_Enum->Release () ;
						}
			
						SysFreeString ( t_SuperClass ) ;
					}
					else
					{
						t_Result = WBEM_E_OUT_OF_MEMORY ;
					}
				}
				else
				{
					IEnumWbemClassObject *t_Enum = NULL ;

					t_Result = ( ( IWbemServices * ) t_Interface )->CreateClassEnum (

						a_SuperClass, 
						a_Flags, 
						a_Context,
						& t_Enum
					) ;

					if ( SUCCEEDED ( t_Result ) )
					{
						HRESULT t_TempResult = Enqueue_IEnumWbemClassObject ( 

							t_Enum ,
							*a_Enum
						) ;

						if ( FAILED ( t_TempResult ) )
						{
							t_Result = t_TempResult ;
						}

						t_Enum->Release () ;
					}
				}

				End_IWbemServices (

					t_ProcessIdentifier ,
					t_IdentifyToken ,
					t_Impersonating ,
					t_OldContext ,
					t_OldSecurity ,
					t_IsProxy ,
					t_Interface ,
					t_Revert ,
					t_Proxy
				) ;
			}
		}

		InterlockedDecrement ( & m_InProgress ) ;
	}
	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

SCODE CInterceptor_IWbemServices_Proxy :: CreateClassEnumAsync (

	const BSTR a_SuperClass ,
	long a_Flags ,
	IWbemContext *a_Context ,
	IWbemObjectSink *a_Sink
) 
{
	HRESULT t_Result = S_OK ;

	InterlockedIncrement ( & m_InProgress ) ;

	if ( m_GateClosed == 1 )
	{
		t_Result = WBEM_E_SHUTTING_DOWN ;
	}
	else
	{
		BOOL t_Impersonating ;
		IUnknown *t_OldContext ;
		IServerSecurity *t_OldSecurity ;
		BOOL t_IsProxy ;
		IUnknown *t_Interface ;
		BOOL t_Revert ;
		IUnknown *t_Proxy ;
		DWORD t_ProcessIdentifier = GetCurrentProcessId () ;
		HANDLE t_IdentifyToken = NULL ;

		t_Result = Begin_IWbemServices (

			t_ProcessIdentifier ,
			t_IdentifyToken ,
			t_Impersonating ,
			t_OldContext ,
			t_OldSecurity ,
			t_IsProxy ,
			t_Interface ,
			t_Revert ,
			t_Proxy
		) ;

		if ( SUCCEEDED ( t_Result ) )
		{
			if ( t_IdentifyToken )
			{
				WmiInternalContext t_InternalContext ;
				t_InternalContext.m_IdentifyHandle = ( unsigned __int64 ) t_IdentifyToken ;
				t_InternalContext.m_ProcessIdentifier = t_ProcessIdentifier ;

				BSTR t_SuperClass = SysAllocString ( a_SuperClass ) ;
				if ( t_SuperClass )
				{
					t_Result = ( ( Internal_IWbemServices * ) t_Interface )->Internal_CreateClassEnumAsync (

						t_InternalContext ,
						t_SuperClass, 
						a_Flags, 
						a_Context,
						a_Sink
					) ;

					SysFreeString ( t_SuperClass ) ;
				}
				else
				{
					t_Result = WBEM_E_OUT_OF_MEMORY ;
				}
			}
			else
			{
				t_Result = ( ( IWbemServices * ) t_Interface )->CreateClassEnumAsync (

					a_SuperClass, 
					a_Flags, 
					a_Context,
					a_Sink
				) ;
			}

			End_IWbemServices (

				t_ProcessIdentifier ,
				t_IdentifyToken ,
				t_Impersonating ,
				t_OldContext ,
				t_OldSecurity ,
				t_IsProxy ,
				t_Interface ,
				t_Revert ,
				t_Proxy
			) ;
		}
	}

	InterlockedDecrement ( & m_InProgress ) ;

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_IWbemServices_Proxy :: PutInstance (

    IWbemClassObject *a_Instance,
    long a_Flags,
    IWbemContext *a_Context,
	IWbemCallResult **a_CallResult
) 
{
	HRESULT t_Result = S_OK ;

	InterlockedIncrement ( & m_InProgress ) ;

	if ( m_GateClosed == 1 )
	{
		t_Result = WBEM_E_SHUTTING_DOWN ;
	}
	else
	{
		BOOL t_Impersonating ;
		IUnknown *t_OldContext ;
		IServerSecurity *t_OldSecurity ;
		BOOL t_IsProxy ;
		IUnknown *t_Interface ;
		BOOL t_Revert ;
		IUnknown *t_Proxy ;
		DWORD t_ProcessIdentifier = GetCurrentProcessId () ;
		HANDLE t_IdentifyToken = NULL ;

		t_Result = Begin_IWbemServices (

			t_ProcessIdentifier ,
			t_IdentifyToken ,
			t_Impersonating ,
			t_OldContext ,
			t_OldSecurity ,
			t_IsProxy ,
			t_Interface ,
			t_Revert ,
			t_Proxy
		) ;

		if ( SUCCEEDED ( t_Result ) )
		{
			if ( t_IdentifyToken )
			{
				WmiInternalContext t_InternalContext ;
				t_InternalContext.m_IdentifyHandle = ( unsigned __int64 ) t_IdentifyToken ;
				t_InternalContext.m_ProcessIdentifier = t_ProcessIdentifier ;

				t_Result = ( ( Internal_IWbemServices * ) t_Interface )->Internal_PutInstance (

					t_InternalContext ,
					a_Instance,
					a_Flags,
					a_Context,
					a_CallResult
				) ;
			}
			else
			{
				t_Result = ( ( IWbemServices * ) t_Interface )->PutInstance (

					a_Instance,
					a_Flags,
					a_Context,
					a_CallResult
				) ;
			}

			End_IWbemServices (

				t_ProcessIdentifier ,
				t_IdentifyToken ,
				t_Impersonating ,
				t_OldContext ,
				t_OldSecurity ,
				t_IsProxy ,
				t_Interface ,
				t_Revert ,
				t_Proxy
			) ;
		}
	}

	InterlockedDecrement ( & m_InProgress ) ;

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_IWbemServices_Proxy :: PutInstanceAsync ( 
		
	IWbemClassObject *a_Instance, 
	long a_Flags, 
    IWbemContext *a_Context,
	IWbemObjectSink *a_Sink
) 
{
	HRESULT t_Result = S_OK ;

	InterlockedIncrement ( & m_InProgress ) ;

	if ( m_GateClosed == 1 )
	{
		t_Result = WBEM_E_SHUTTING_DOWN ;
	}
	else
	{
		BOOL t_Impersonating ;
		IUnknown *t_OldContext ;
		IServerSecurity *t_OldSecurity ;
		BOOL t_IsProxy ;
		IUnknown *t_Interface ;
		BOOL t_Revert ;
		IUnknown *t_Proxy ;
		DWORD t_ProcessIdentifier = GetCurrentProcessId () ;
		HANDLE t_IdentifyToken = NULL ;

		t_Result = Begin_IWbemServices (

			t_ProcessIdentifier ,
			t_IdentifyToken ,
			t_Impersonating ,
			t_OldContext ,
			t_OldSecurity ,
			t_IsProxy ,
			t_Interface ,
			t_Revert ,
			t_Proxy
		) ;

		if ( SUCCEEDED ( t_Result ) )
		{
			if ( t_IdentifyToken )
			{
				WmiInternalContext t_InternalContext ;
				t_InternalContext.m_IdentifyHandle = ( unsigned __int64 ) t_IdentifyToken ;
				t_InternalContext.m_ProcessIdentifier = t_ProcessIdentifier ;

				t_Result = ( ( Internal_IWbemServices * ) t_Interface )->Internal_PutInstanceAsync (

					t_InternalContext ,
					a_Instance, 
					a_Flags, 
					a_Context,
					a_Sink
				) ;
			}
			else
			{
				t_Result = ( ( IWbemServices * ) t_Interface )->PutInstanceAsync (

					a_Instance, 
					a_Flags, 
					a_Context,
					a_Sink
				) ;
			}

			End_IWbemServices (

				t_ProcessIdentifier ,
				t_IdentifyToken ,
				t_Impersonating ,
				t_OldContext ,
				t_OldSecurity ,
				t_IsProxy ,
				t_Interface ,
				t_Revert ,
				t_Proxy
			) ;
		}
	}

	InterlockedDecrement ( & m_InProgress ) ;

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_IWbemServices_Proxy :: DeleteInstance ( 

	const BSTR a_ObjectPath,
    long a_Flags,
    IWbemContext *a_Context,
    IWbemCallResult **a_CallResult
)
{
	HRESULT t_Result = S_OK ;

	InterlockedIncrement ( & m_InProgress ) ;

	if ( m_GateClosed == 1 )
	{
		t_Result = WBEM_E_SHUTTING_DOWN ;
	}
	else
	{
		BOOL t_Impersonating ;
		IUnknown *t_OldContext ;
		IServerSecurity *t_OldSecurity ;
		BOOL t_IsProxy ;
		IUnknown *t_Interface ;
		BOOL t_Revert ;
		IUnknown *t_Proxy ;
		DWORD t_ProcessIdentifier = GetCurrentProcessId () ;
		HANDLE t_IdentifyToken = NULL ;

		t_Result = Begin_IWbemServices (

			t_ProcessIdentifier ,
			t_IdentifyToken ,
			t_Impersonating ,
			t_OldContext ,
			t_OldSecurity ,
			t_IsProxy ,
			t_Interface ,
			t_Revert ,
			t_Proxy
		) ;

		if ( SUCCEEDED ( t_Result ) )
		{
			if ( t_IdentifyToken )
			{
				WmiInternalContext t_InternalContext ;
				t_InternalContext.m_IdentifyHandle = ( unsigned __int64 ) t_IdentifyToken ;
				t_InternalContext.m_ProcessIdentifier = t_ProcessIdentifier ;

				BSTR t_ObjectPath = SysAllocString ( a_ObjectPath ) ;
				if ( t_ObjectPath )
				{
					t_Result = ( ( Internal_IWbemServices * ) t_Interface )->Internal_DeleteInstance (

						t_InternalContext ,
						t_ObjectPath,
						a_Flags,
						a_Context,
						a_CallResult
					) ;

					SysFreeString ( t_ObjectPath ) ;
				}
				else
				{
					t_Result = WBEM_E_OUT_OF_MEMORY ;
				}
			}
			else
			{
				t_Result = ( ( IWbemServices * ) t_Interface )->DeleteInstance (

					a_ObjectPath,
					a_Flags,
					a_Context,
					a_CallResult
				) ;
			}

			End_IWbemServices (

				t_ProcessIdentifier ,
				t_IdentifyToken ,
				t_Impersonating ,
				t_OldContext ,
				t_OldSecurity ,
				t_IsProxy ,
				t_Interface ,
				t_Revert ,
				t_Proxy
			) ;
		}
	}

	InterlockedDecrement ( & m_InProgress ) ;

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/
        
HRESULT CInterceptor_IWbemServices_Proxy :: DeleteInstanceAsync (
 
	const BSTR a_ObjectPath,
    long a_Flags,
    IWbemContext *a_Context,
    IWbemObjectSink *a_Sink	
)
{
	HRESULT t_Result = S_OK ;

	InterlockedIncrement ( & m_InProgress ) ;

	if ( m_GateClosed == 1 )
	{
		t_Result = WBEM_E_SHUTTING_DOWN ;
	}
	else
	{
		BOOL t_Impersonating ;
		IUnknown *t_OldContext ;
		IServerSecurity *t_OldSecurity ;
		BOOL t_IsProxy ;
		IUnknown *t_Interface ;
		BOOL t_Revert ;
		IUnknown *t_Proxy ;
		DWORD t_ProcessIdentifier = GetCurrentProcessId () ;
		HANDLE t_IdentifyToken = NULL ;

		t_Result = Begin_IWbemServices (

			t_ProcessIdentifier ,
			t_IdentifyToken ,
			t_Impersonating ,
			t_OldContext ,
			t_OldSecurity ,
			t_IsProxy ,
			t_Interface ,
			t_Revert ,
			t_Proxy
		) ;

		if ( SUCCEEDED ( t_Result ) )
		{
			if ( t_IdentifyToken )
			{
				WmiInternalContext t_InternalContext ;
				t_InternalContext.m_IdentifyHandle = ( unsigned __int64 ) t_IdentifyToken ;
				t_InternalContext.m_ProcessIdentifier = t_ProcessIdentifier ;

				BSTR t_ObjectPath = SysAllocString ( a_ObjectPath ) ;
				if ( t_ObjectPath )
				{
					t_Result = ( ( Internal_IWbemServices * ) t_Interface )->Internal_DeleteInstanceAsync (

						t_InternalContext ,
						t_ObjectPath,
						a_Flags,
						a_Context,
						a_Sink
					) ;

					SysFreeString ( t_ObjectPath ) ;
				}
				else
				{
					t_Result = WBEM_E_OUT_OF_MEMORY ;
				}
			}
			else
			{
				t_Result = ( ( IWbemServices * ) t_Interface )->DeleteInstanceAsync (

					a_ObjectPath,
					a_Flags,
					a_Context,
					a_Sink
				) ;
			}

			End_IWbemServices (

				t_ProcessIdentifier ,
				t_IdentifyToken ,
				t_Impersonating ,
				t_OldContext ,
				t_OldSecurity ,
				t_IsProxy ,
				t_Interface ,
				t_Revert ,
				t_Proxy
			) ;
		}
	}

	InterlockedDecrement ( & m_InProgress ) ;

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_IWbemServices_Proxy :: CreateInstanceEnum ( 

	const BSTR a_Class, 
	long a_Flags, 
	IWbemContext *a_Context, 
	IEnumWbemClassObject **a_Enum
)
{
	HRESULT t_Result = S_OK ;

	try
	{
		*a_Enum = NULL ;
	}
	catch ( ... ) 
	{
		t_Result = WBEM_E_CRITICAL_ERROR ;
	}

	if ( SUCCEEDED ( t_Result ) )
	{
		InterlockedIncrement ( & m_InProgress ) ;

		if ( m_GateClosed == 1 )
		{
			t_Result = WBEM_E_SHUTTING_DOWN ;
		}
		else
		{
			BOOL t_Impersonating ;
			IUnknown *t_OldContext ;
			IServerSecurity *t_OldSecurity ;
			BOOL t_IsProxy ;
			IUnknown *t_Interface ;
			BOOL t_Revert ;
			IUnknown *t_Proxy ;
			DWORD t_ProcessIdentifier = GetCurrentProcessId () ;
			HANDLE t_IdentifyToken = NULL ;

			t_Result = Begin_IWbemServices (

				t_ProcessIdentifier ,
				t_IdentifyToken ,
				t_Impersonating ,
				t_OldContext ,
				t_OldSecurity ,
				t_IsProxy ,
				t_Interface ,
				t_Revert ,
				t_Proxy
			) ;

			if ( SUCCEEDED ( t_Result ) )
			{
				if ( t_IdentifyToken )
				{
					WmiInternalContext t_InternalContext ;
					t_InternalContext.m_IdentifyHandle = ( unsigned __int64 ) t_IdentifyToken ;
					t_InternalContext.m_ProcessIdentifier = t_ProcessIdentifier ;

					BSTR t_Class = SysAllocString ( a_Class ) ;
					if ( t_Class )
					{
						IEnumWbemClassObject *t_Enum = NULL ;

						t_Result = ( ( Internal_IWbemServices * ) t_Interface )->Internal_CreateInstanceEnum (

							t_InternalContext ,
							t_Class, 
							a_Flags, 
							a_Context, 
							& t_Enum
						) ;

						if ( SUCCEEDED ( t_Result ) )
						{
							HRESULT t_TempResult = Enqueue_IEnumWbemClassObject ( 

								t_Enum ,
								*a_Enum
							) ;

							if ( FAILED ( t_TempResult ) )
							{
								t_Result = t_TempResult ;
							}

							t_Enum->Release () ;
						}
		
						SysFreeString ( t_Class ) ;
					}
					else
					{
						t_Result = WBEM_E_OUT_OF_MEMORY ;
					}
				}
				else
				{
					IEnumWbemClassObject *t_Enum = NULL ;

					t_Result = ( ( IWbemServices * ) t_Interface )->CreateInstanceEnum (

						a_Class, 
						a_Flags, 
						a_Context, 
						& t_Enum
					) ;

					if ( SUCCEEDED ( t_Result ) )
					{
						HRESULT t_TempResult = Enqueue_IEnumWbemClassObject ( 

							t_Enum ,
							*a_Enum
						) ;

						if ( FAILED ( t_TempResult ) )
						{
							t_Result = t_TempResult ;
						}

						t_Enum->Release () ;
					}
				}

				End_IWbemServices (

					t_ProcessIdentifier ,
					t_IdentifyToken ,
					t_Impersonating ,
					t_OldContext ,
					t_OldSecurity ,
					t_IsProxy ,
					t_Interface ,
					t_Revert ,
					t_Proxy
				) ;
			}
		}

		InterlockedDecrement ( & m_InProgress ) ;
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_IWbemServices_Proxy :: CreateInstanceEnumAsync (

 	const BSTR a_Class, 
	long a_Flags, 
	IWbemContext *a_Context,
	IWbemObjectSink *a_Sink

) 
{
	HRESULT t_Result = S_OK ;

	InterlockedIncrement ( & m_InProgress ) ;

	if ( m_GateClosed == 1 )
	{
		t_Result = WBEM_E_SHUTTING_DOWN ;
	}
	else
	{
		BOOL t_Impersonating ;
		IUnknown *t_OldContext ;
		IServerSecurity *t_OldSecurity ;
		BOOL t_IsProxy ;
		IUnknown *t_Interface ;
		BOOL t_Revert ;
		IUnknown *t_Proxy ;
		DWORD t_ProcessIdentifier = GetCurrentProcessId () ;
		HANDLE t_IdentifyToken = NULL ;

		t_Result = Begin_IWbemServices (

			t_ProcessIdentifier ,
			t_IdentifyToken ,
			t_Impersonating ,
			t_OldContext ,
			t_OldSecurity ,
			t_IsProxy ,
			t_Interface ,
			t_Revert ,
			t_Proxy
		) ;

		if ( SUCCEEDED ( t_Result ) )
		{
			if ( t_IdentifyToken )
			{
				WmiInternalContext t_InternalContext ;
				t_InternalContext.m_IdentifyHandle = ( unsigned __int64 ) t_IdentifyToken ;
				t_InternalContext.m_ProcessIdentifier = t_ProcessIdentifier ;

				BSTR t_Class = SysAllocString ( a_Class ) ;
				if ( t_Class )
				{
					t_Result = ( ( Internal_IWbemServices * ) t_Interface )->Internal_CreateInstanceEnumAsync (

						t_InternalContext ,
 						t_Class, 
						a_Flags, 
						a_Context,
						a_Sink
					) ;

					SysFreeString ( t_Class ) ;
				}
				else
				{
					t_Result = WBEM_E_OUT_OF_MEMORY ;
				}
			}
			else
			{
				t_Result = ( ( IWbemServices * ) t_Interface )->CreateInstanceEnumAsync (

					a_Class, 
					a_Flags, 
					a_Context,
					a_Sink
				) ;
			}

			End_IWbemServices (

				t_ProcessIdentifier ,
				t_IdentifyToken ,
				t_Impersonating ,
				t_OldContext ,
				t_OldSecurity ,
				t_IsProxy ,
				t_Interface ,
				t_Revert ,
				t_Proxy
			) ;
		}
	}

	InterlockedDecrement ( & m_InProgress ) ;

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_IWbemServices_Proxy :: ExecQuery ( 

	const BSTR a_QueryLanguage, 
	const BSTR a_Query, 
	long a_Flags, 
	IWbemContext *a_Context,
	IEnumWbemClassObject **a_Enum
)
{
	HRESULT t_Result = S_OK ;

	try
	{
		*a_Enum = NULL ;
	}
	catch ( ... ) 
	{
		t_Result = WBEM_E_CRITICAL_ERROR ;
	}

	if ( SUCCEEDED ( t_Result ) )
	{
		InterlockedIncrement ( & m_InProgress ) ;

		if ( m_GateClosed == 1 )
		{
			t_Result = WBEM_E_SHUTTING_DOWN ;
		}
		else
		{
			BOOL t_Impersonating ;
			IUnknown *t_OldContext ;
			IServerSecurity *t_OldSecurity ;
			BOOL t_IsProxy ;
			IUnknown *t_Interface ;
			BOOL t_Revert ;
			IUnknown *t_Proxy ;
			DWORD t_ProcessIdentifier = GetCurrentProcessId () ;
			HANDLE t_IdentifyToken = NULL ;

			t_Result = Begin_IWbemServices (

				t_ProcessIdentifier ,
				t_IdentifyToken ,
				t_Impersonating ,
				t_OldContext ,
				t_OldSecurity ,
				t_IsProxy ,
				t_Interface ,
				t_Revert ,
				t_Proxy
			) ;

			if ( SUCCEEDED ( t_Result ) )
			{
				if ( t_IdentifyToken )
				{
					WmiInternalContext t_InternalContext ;
					t_InternalContext.m_IdentifyHandle = ( unsigned __int64 ) t_IdentifyToken ;
					t_InternalContext.m_ProcessIdentifier = t_ProcessIdentifier ;

					BSTR t_QueryLanguage = SysAllocString ( a_QueryLanguage ) ;
					BSTR t_Query = SysAllocString ( a_Query ) ;

					if ( t_QueryLanguage && t_Query )
					{
						IEnumWbemClassObject *t_Enum = NULL ;

						t_Result = ( ( Internal_IWbemServices * ) t_Interface )->Internal_ExecQuery (

							t_InternalContext ,
							t_QueryLanguage, 
							t_Query, 
							a_Flags, 
							a_Context,
							& t_Enum
						) ;

						if ( SUCCEEDED ( t_Result ) )
						{
							HRESULT t_TempResult = Enqueue_IEnumWbemClassObject ( 

								t_Enum ,
								*a_Enum
							) ;

							if ( FAILED ( t_TempResult ) )
							{
								t_Result = t_TempResult ;
							}

							t_Enum->Release () ;
						}
					}
					else
					{
						t_Result = WBEM_E_OUT_OF_MEMORY ;
					}

					SysFreeString ( t_QueryLanguage ) ;
					SysFreeString ( t_Query ) ;
				}
				else
				{
					IEnumWbemClassObject *t_Enum = NULL ;

					t_Result = ( ( IWbemServices * ) t_Interface )->ExecQuery (

						a_QueryLanguage, 
						a_Query, 
						a_Flags, 
						a_Context,
						& t_Enum
					) ;

					if ( SUCCEEDED ( t_Result ) )
					{
						HRESULT t_TempResult = Enqueue_IEnumWbemClassObject ( 

							t_Enum ,
							*a_Enum
						) ;

						if ( FAILED ( t_TempResult ) )
						{
							t_Result = t_TempResult ;
						}

						t_Enum->Release () ;
					}

				}

				End_IWbemServices (

					t_ProcessIdentifier ,
					t_IdentifyToken ,
					t_Impersonating ,
					t_OldContext ,
					t_OldSecurity ,
					t_IsProxy ,
					t_Interface ,
					t_Revert ,
					t_Proxy
				) ;
			}
		}

		InterlockedDecrement ( & m_InProgress ) ;
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_IWbemServices_Proxy :: ExecQueryAsync ( 
		
	const BSTR a_QueryLanguage, 
	const BSTR a_Query, 
	long a_Flags, 
	IWbemContext *a_Context ,
	IWbemObjectSink *a_Sink
) 
{
	HRESULT t_Result = S_OK ;

	InterlockedIncrement ( & m_InProgress ) ;

	if ( m_GateClosed == 1 )
	{
		t_Result = WBEM_E_SHUTTING_DOWN ;
	}
	else
	{
		BOOL t_Impersonating ;
		IUnknown *t_OldContext ;
		IServerSecurity *t_OldSecurity ;
		BOOL t_IsProxy ;
		IUnknown *t_Interface ;
		BOOL t_Revert ;
		IUnknown *t_Proxy ;
		DWORD t_ProcessIdentifier = GetCurrentProcessId () ;
		HANDLE t_IdentifyToken = NULL ;

		t_Result = Begin_IWbemServices (

			t_ProcessIdentifier ,
			t_IdentifyToken ,
			t_Impersonating ,
			t_OldContext ,
			t_OldSecurity ,
			t_IsProxy ,
			t_Interface ,
			t_Revert ,
			t_Proxy
		) ;

		if ( SUCCEEDED ( t_Result ) )
		{
			if ( t_IdentifyToken )
			{
				WmiInternalContext t_InternalContext ;
				t_InternalContext.m_IdentifyHandle = ( unsigned __int64 ) t_IdentifyToken ;
				t_InternalContext.m_ProcessIdentifier = t_ProcessIdentifier ;

				BSTR t_QueryLanguage = SysAllocString ( a_QueryLanguage ) ;
				BSTR t_Query = SysAllocString ( a_Query ) ;

				if ( t_QueryLanguage && t_Query )
				{
					t_Result = ( ( Internal_IWbemServices * ) t_Interface )->Internal_ExecQueryAsync (

						t_InternalContext ,
						t_QueryLanguage, 
						t_Query, 
						a_Flags, 
						a_Context,
						a_Sink
					) ;
				}
				else
				{
					t_Result = WBEM_E_OUT_OF_MEMORY ;
				}

				SysFreeString ( t_QueryLanguage ) ;
				SysFreeString ( t_Query ) ;
			}
			else
			{
				t_Result = ( ( IWbemServices * ) t_Interface )->ExecQueryAsync (

					a_QueryLanguage, 
					a_Query, 
					a_Flags, 
					a_Context,
					a_Sink
				) ;
			}

			End_IWbemServices (

				t_ProcessIdentifier ,
				t_IdentifyToken ,
				t_Impersonating ,
				t_OldContext ,
				t_OldSecurity ,
				t_IsProxy ,
				t_Interface ,
				t_Revert ,
				t_Proxy
			) ;
		}
	}

	InterlockedDecrement ( & m_InProgress ) ;

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_IWbemServices_Proxy :: ExecNotificationQuery ( 

	const BSTR a_QueryLanguage,
    const BSTR a_Query,
    long a_Flags,
    IWbemContext *a_Context,
    IEnumWbemClassObject **a_Enum
)
{
	HRESULT t_Result = S_OK ;

	InterlockedIncrement ( & m_InProgress ) ;

	if ( m_GateClosed == 1 )
	{
		t_Result = WBEM_E_SHUTTING_DOWN ;
	}
	else
	{
		BOOL t_Impersonating ;
		IUnknown *t_OldContext ;
		IServerSecurity *t_OldSecurity ;
		BOOL t_IsProxy ;
		IUnknown *t_Interface ;
		BOOL t_Revert ;
		IUnknown *t_Proxy ;
		DWORD t_ProcessIdentifier = GetCurrentProcessId () ;
		HANDLE t_IdentifyToken = NULL ;

		t_Result = Begin_IWbemServices (

			t_ProcessIdentifier ,
			t_IdentifyToken ,
			t_Impersonating ,
			t_OldContext ,
			t_OldSecurity ,
			t_IsProxy ,
			t_Interface ,
			t_Revert ,
			t_Proxy
		) ;

		if ( SUCCEEDED ( t_Result ) )
		{
			if ( t_IdentifyToken )
			{
				WmiInternalContext t_InternalContext ;
				t_InternalContext.m_IdentifyHandle = ( unsigned __int64 ) t_IdentifyToken ;
				t_InternalContext.m_ProcessIdentifier = t_ProcessIdentifier ;

				BSTR t_QueryLanguage = SysAllocString ( a_QueryLanguage ) ;
				BSTR t_Query = SysAllocString ( a_Query ) ;

				if ( t_QueryLanguage && t_Query )
				{
					t_Result = ( ( Internal_IWbemServices * ) t_Interface )->Internal_ExecNotificationQuery (

						t_InternalContext ,
						t_QueryLanguage,
						t_Query,
						a_Flags,
						a_Context,
						a_Enum
					) ;
				}
				else
				{
					t_Result = WBEM_E_OUT_OF_MEMORY ;
				}

				SysFreeString ( t_QueryLanguage ) ;
				SysFreeString ( t_Query ) ;
			}
			else
			{
				t_Result = ( ( IWbemServices * ) t_Interface )->ExecNotificationQuery (

					a_QueryLanguage,
					a_Query,
					a_Flags,
					a_Context,
					a_Enum
				) ;
			}

			End_IWbemServices (

				t_ProcessIdentifier ,
				t_IdentifyToken ,
				t_Impersonating ,
				t_OldContext ,
				t_OldSecurity ,
				t_IsProxy ,
				t_Interface ,
				t_Revert ,
				t_Proxy
			) ;
		}
	}

	InterlockedDecrement ( & m_InProgress ) ;

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/
        
HRESULT CInterceptor_IWbemServices_Proxy :: ExecNotificationQueryAsync ( 
            
	const BSTR a_QueryLanguage,
    const BSTR a_Query,
    long a_Flags,
    IWbemContext *a_Context,
    IWbemObjectSink *a_Sink
)
{
	HRESULT t_Result = S_OK ;

	InterlockedIncrement ( & m_InProgress ) ;

	if ( m_GateClosed == 1 )
	{
		t_Result = WBEM_E_SHUTTING_DOWN ;
	}
	else
	{
		BOOL t_Impersonating ;
		IUnknown *t_OldContext ;
		IServerSecurity *t_OldSecurity ;
		BOOL t_IsProxy ;
		IUnknown *t_Interface ;
		BOOL t_Revert ;
		IUnknown *t_Proxy ;
		DWORD t_ProcessIdentifier = GetCurrentProcessId () ;
		HANDLE t_IdentifyToken = NULL ;

		t_Result = Begin_IWbemServices (

			t_ProcessIdentifier ,
			t_IdentifyToken ,
			t_Impersonating ,
			t_OldContext ,
			t_OldSecurity ,
			t_IsProxy ,
			t_Interface ,
			t_Revert ,
			t_Proxy
		) ;

		if ( SUCCEEDED ( t_Result ) )
		{
			if ( t_IdentifyToken )
			{
				WmiInternalContext t_InternalContext ;
				t_InternalContext.m_IdentifyHandle = ( unsigned __int64 ) t_IdentifyToken ;
				t_InternalContext.m_ProcessIdentifier = t_ProcessIdentifier ;

				BSTR t_QueryLanguage = SysAllocString ( a_QueryLanguage ) ;
				BSTR t_Query = SysAllocString ( a_Query ) ;

				if ( t_QueryLanguage && t_Query )
				{
					t_Result = ( ( Internal_IWbemServices * ) t_Interface )->Internal_ExecNotificationQueryAsync (

						t_InternalContext ,
						a_QueryLanguage,
						a_Query,
						a_Flags,
						a_Context,
						a_Sink
					) ;
				}
				else
				{
					t_Result = WBEM_E_OUT_OF_MEMORY ;
				}

				SysFreeString ( t_QueryLanguage ) ;
				SysFreeString ( t_Query ) ;
			}
			else
			{
				t_Result = ( ( IWbemServices * ) t_Interface )->ExecNotificationQueryAsync (

					a_QueryLanguage,
					a_Query,
					a_Flags,
					a_Context,
					a_Sink
				) ;
			}

			End_IWbemServices (

				t_ProcessIdentifier ,
				t_IdentifyToken ,
				t_Impersonating ,
				t_OldContext ,
				t_OldSecurity ,
				t_IsProxy ,
				t_Interface ,
				t_Revert ,
				t_Proxy
			) ;
		}
	}

	InterlockedDecrement ( & m_InProgress ) ;

	return t_Result ;
}       

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT STDMETHODCALLTYPE CInterceptor_IWbemServices_Proxy :: ExecMethod ( 

	const BSTR a_ObjectPath,
    const BSTR a_MethodName,
    long a_Flags,
    IWbemContext *a_Context,
    IWbemClassObject *a_InParams,
    IWbemClassObject **a_OutParams,
    IWbemCallResult **a_CallResult
)
{
	HRESULT t_Result = S_OK ;

	InterlockedIncrement ( & m_InProgress ) ;

	if ( m_GateClosed == 1 )
	{
		t_Result = WBEM_E_SHUTTING_DOWN ;
	}
	else
	{
		BOOL t_Impersonating ;
		IUnknown *t_OldContext ;
		IServerSecurity *t_OldSecurity ;
		BOOL t_IsProxy ;
		IUnknown *t_Interface ;
		BOOL t_Revert ;
		IUnknown *t_Proxy ;
		DWORD t_ProcessIdentifier = GetCurrentProcessId () ;
		HANDLE t_IdentifyToken = NULL ;

		t_Result = Begin_IWbemServices (

			t_ProcessIdentifier ,
			t_IdentifyToken ,
			t_Impersonating ,
			t_OldContext ,
			t_OldSecurity ,
			t_IsProxy ,
			t_Interface ,
			t_Revert ,
			t_Proxy
		) ;

		if ( SUCCEEDED ( t_Result ) )
		{
			if ( t_IdentifyToken )
			{
				WmiInternalContext t_InternalContext ;
				t_InternalContext.m_IdentifyHandle = ( unsigned __int64 ) t_IdentifyToken ;
				t_InternalContext.m_ProcessIdentifier = t_ProcessIdentifier ;

				BSTR t_ObjectPath = SysAllocString ( a_ObjectPath ) ;
				BSTR t_MethodName = SysAllocString ( a_MethodName ) ;

				if ( t_ObjectPath && t_MethodName )
				{
					t_Result = ( ( Internal_IWbemServices * ) t_Interface )->Internal_ExecMethod (

						t_InternalContext ,
						t_ObjectPath,
						t_MethodName,
						a_Flags,
						a_Context,
						a_InParams,
						a_OutParams,
						a_CallResult
					) ;
				}
				else
				{
					t_Result = WBEM_E_OUT_OF_MEMORY ;
				}

				SysFreeString ( t_ObjectPath ) ;
				SysFreeString ( t_MethodName ) ;

			}
			else
			{
				t_Result = ( ( IWbemServices * ) t_Interface )->ExecMethod (

					a_ObjectPath,
					a_MethodName,
					a_Flags,
					a_Context,
					a_InParams,
					a_OutParams,
					a_CallResult
				) ;
			}

			End_IWbemServices (

				t_ProcessIdentifier ,
				t_IdentifyToken ,
				t_Impersonating ,
				t_OldContext ,
				t_OldSecurity ,
				t_IsProxy ,
				t_Interface ,
				t_Revert ,
				t_Proxy
			) ;
		}
	}

	InterlockedDecrement ( & m_InProgress ) ;

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT STDMETHODCALLTYPE CInterceptor_IWbemServices_Proxy :: ExecMethodAsync ( 

    const BSTR a_ObjectPath,
    const BSTR a_MethodName,
    long a_Flags,
    IWbemContext *a_Context,
    IWbemClassObject *a_InParams,
	IWbemObjectSink *a_Sink
) 
{
	HRESULT t_Result = S_OK ;

	InterlockedIncrement ( & m_InProgress ) ;

	if ( m_GateClosed == 1 )
	{
		t_Result = WBEM_E_SHUTTING_DOWN ;
	}
	else
	{
		BOOL t_Impersonating ;
		IUnknown *t_OldContext ;
		IServerSecurity *t_OldSecurity ;
		BOOL t_IsProxy ;
		IUnknown *t_Interface ;
		BOOL t_Revert ;
		IUnknown *t_Proxy ;
		DWORD t_ProcessIdentifier = GetCurrentProcessId () ;
		HANDLE t_IdentifyToken = NULL ;

		t_Result = Begin_IWbemServices (

			t_ProcessIdentifier ,
			t_IdentifyToken ,
			t_Impersonating ,
			t_OldContext ,
			t_OldSecurity ,
			t_IsProxy ,
			t_Interface ,
			t_Revert ,
			t_Proxy
		) ;

		if ( SUCCEEDED ( t_Result ) )
		{
			if ( t_IdentifyToken )
			{
				WmiInternalContext t_InternalContext ;
				t_InternalContext.m_IdentifyHandle = ( unsigned __int64 ) t_IdentifyToken ;
				t_InternalContext.m_ProcessIdentifier = t_ProcessIdentifier ;

				BSTR t_ObjectPath = SysAllocString ( a_ObjectPath ) ;
				BSTR t_MethodName = SysAllocString ( a_MethodName ) ;

				if ( t_ObjectPath && t_MethodName )
				{
					t_Result = ( ( Internal_IWbemServices * ) t_Interface )->Internal_ExecMethodAsync (

						t_InternalContext ,
						t_ObjectPath,
						t_MethodName,
						a_Flags,
						a_Context,
						a_InParams,
						a_Sink
					) ;
				}
				else
				{
					t_Result = WBEM_E_OUT_OF_MEMORY ;
				}

				SysFreeString ( t_ObjectPath ) ;
				SysFreeString ( t_MethodName ) ;
			}
			else
			{
				t_Result = ( ( IWbemServices * ) t_Interface )->ExecMethodAsync (

					a_ObjectPath,
					a_MethodName,
					a_Flags,
					a_Context,
					a_InParams,
					a_Sink

				) ;
			}

			End_IWbemServices (

				t_ProcessIdentifier ,
				t_IdentifyToken ,
				t_Impersonating ,
				t_OldContext ,
				t_OldSecurity ,
				t_IsProxy ,
				t_Interface ,
				t_Revert ,
				t_Proxy
			) ;
		}
	}

	InterlockedDecrement ( & m_InProgress ) ;

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_IWbemServices_Proxy :: ServiceInitialize ()
{
	HRESULT t_Result = S_OK ;

	WmiStatusCode t_StatusCode = m_ProxyContainer.Initialize () ;
	if ( t_StatusCode != e_StatusCode_Success )
	{
	}

	if ( SUCCEEDED ( t_Result ) )
	{
		t_StatusCode = CWbemGlobal_VoidPointerController :: Initialize () ;
		if ( t_StatusCode != e_StatusCode_Success ) 
		{
			t_Result = WBEM_E_OUT_OF_MEMORY ;
		}
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_IWbemServices_Proxy :: Shutdown (

	LONG a_Flags ,
	ULONG a_MaxMilliSeconds ,
	IWbemContext *a_Context
)
{
	HRESULT t_Result = S_OK ;

	InterlockedIncrement ( & m_GateClosed ) ;

	bool t_Acquired = false ;
	while ( ! t_Acquired )
	{
		if ( m_InProgress == 0 )
		{
			t_Acquired = true ;
			break ;
		}

		if ( SwitchToThread () == FALSE ) 
		{
		}
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_IWbemServices_Proxy :: AddObjectToRefresher (

	WBEM_REFRESHER_ID *a_RefresherId ,
	LPCWSTR a_Path,
	long a_Flags ,
	IWbemContext *a_Context,
	DWORD a_ClientRefresherVersion ,
	WBEM_REFRESH_INFO *a_Information ,
	DWORD *a_ServerRefresherVersion
)
{
	HRESULT t_Result = S_OK ;

	InterlockedIncrement ( & m_InProgress ) ;

	if ( m_GateClosed == 1 )
	{
		t_Result = WBEM_E_SHUTTING_DOWN ;
	}
	else
	{
		if ( m_Core_IWbemRefreshingServices )
		{
			BOOL t_Impersonating ;
			IUnknown *t_OldContext ;
			IServerSecurity *t_OldSecurity ;
			BOOL t_IsProxy ;
			IWbemRefreshingServices *t_Interface ;
			BOOL t_Revert ;
			IUnknown *t_Proxy ;

			t_Result = Begin_IWbemRefreshingServices (

				t_Impersonating ,
				t_OldContext ,
				t_OldSecurity ,
				t_IsProxy ,
				t_Interface ,
				t_Revert ,
				t_Proxy
			) ;

			if ( SUCCEEDED ( t_Result ) )
			{
				t_Result = t_Interface->AddObjectToRefresher (

					a_RefresherId ,
					a_Path,
					a_Flags ,
					a_Context,
					a_ClientRefresherVersion ,
					a_Information ,
					a_ServerRefresherVersion
				) ;

				End_IWbemRefreshingServices (

					t_Impersonating ,
					t_OldContext ,
					t_OldSecurity ,
					t_IsProxy ,
					t_Interface ,
					t_Revert ,
					t_Proxy
				) ;
			}
		}
		else
		{
			t_Result = WBEM_E_NOT_AVAILABLE ;
		}
	}

	InterlockedDecrement ( & m_InProgress ) ;

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_IWbemServices_Proxy :: AddObjectToRefresherByTemplate (

	WBEM_REFRESHER_ID *a_RefresherId ,
	IWbemClassObject *a_Template ,
	long a_Flags ,
	IWbemContext *a_Context ,
	DWORD a_ClientRefresherVersion ,
	WBEM_REFRESH_INFO *a_Information ,
	DWORD *a_ServerRefresherVersion
)
{
	HRESULT t_Result = S_OK ;

	InterlockedIncrement ( & m_InProgress ) ;

	if ( m_GateClosed == 1 )
	{
		t_Result = WBEM_E_SHUTTING_DOWN ;
	}
	else
	{
		if ( m_Core_IWbemRefreshingServices )
		{
			BOOL t_Impersonating ;
			IUnknown *t_OldContext ;
			IServerSecurity *t_OldSecurity ;
			BOOL t_IsProxy ;
			IWbemRefreshingServices *t_Interface ;
			BOOL t_Revert ;
			IUnknown *t_Proxy ;

			t_Result = Begin_IWbemRefreshingServices (

				t_Impersonating ,
				t_OldContext ,
				t_OldSecurity ,
				t_IsProxy ,
				t_Interface ,
				t_Revert ,
				t_Proxy
			) ;

			if ( SUCCEEDED ( t_Result ) )
			{
				t_Result = t_Interface->AddObjectToRefresherByTemplate (

					a_RefresherId ,
					a_Template ,
					a_Flags ,
					a_Context ,
					a_ClientRefresherVersion ,
					a_Information ,
					a_ServerRefresherVersion
				) ;

				End_IWbemRefreshingServices (

					t_Impersonating ,
					t_OldContext ,
					t_OldSecurity ,
					t_IsProxy ,
					t_Interface ,
					t_Revert ,
					t_Proxy
				) ;
			}
			else
			{
				t_Result = WBEM_E_NOT_AVAILABLE ;
			}
		}
	}

	InterlockedDecrement ( & m_InProgress ) ;

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_IWbemServices_Proxy :: AddEnumToRefresher (

	WBEM_REFRESHER_ID *a_RefresherId ,
	LPCWSTR a_Class ,
	long a_Flags ,
	IWbemContext *a_Context,
	DWORD a_ClientRefresherVersion ,
	WBEM_REFRESH_INFO *a_Information ,
	DWORD *a_ServerRefresherVersion
)
{
	HRESULT t_Result = S_OK ;

	InterlockedIncrement ( & m_InProgress ) ;

	if ( m_GateClosed == 1 )
	{
		t_Result = WBEM_E_SHUTTING_DOWN ;
	}
	else
	{
		if ( m_Core_IWbemRefreshingServices )
		{
			BOOL t_Impersonating ;
			IUnknown *t_OldContext ;
			IServerSecurity *t_OldSecurity ;
			BOOL t_IsProxy ;
			IWbemRefreshingServices *t_Interface ;
			BOOL t_Revert ;
			IUnknown *t_Proxy ;

			t_Result = Begin_IWbemRefreshingServices (

				t_Impersonating ,
				t_OldContext ,
				t_OldSecurity ,
				t_IsProxy ,
				t_Interface ,
				t_Revert ,
				t_Proxy
			) ;

			if ( SUCCEEDED ( t_Result ) )
			{
				t_Result = t_Interface->AddEnumToRefresher (

					a_RefresherId ,
					a_Class ,
					a_Flags ,
					a_Context,
					a_ClientRefresherVersion ,
					a_Information ,
					a_ServerRefresherVersion
				) ;

				End_IWbemRefreshingServices (

					t_Impersonating ,
					t_OldContext ,
					t_OldSecurity ,
					t_IsProxy ,
					t_Interface ,
					t_Revert ,
					t_Proxy
				) ;
			}
		}
		else
		{
			t_Result = WBEM_E_NOT_AVAILABLE ;
		}
	}

	InterlockedDecrement ( & m_InProgress ) ;

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_IWbemServices_Proxy :: RemoveObjectFromRefresher (

	WBEM_REFRESHER_ID *a_RefresherId ,
	long a_Id ,
	long a_Flags ,
	DWORD a_ClientRefresherVersion ,
	DWORD *a_ServerRefresherVersion
)
{
	HRESULT t_Result = S_OK ;

	InterlockedIncrement ( & m_InProgress ) ;

	if ( m_GateClosed == 1 )
	{
		t_Result = WBEM_E_SHUTTING_DOWN ;
	}
	else
	{
		if ( m_Core_IWbemRefreshingServices )
		{
			BOOL t_Impersonating ;
			IUnknown *t_OldContext ;
			IServerSecurity *t_OldSecurity ;
			BOOL t_IsProxy ;
			IWbemRefreshingServices *t_Interface ;
			BOOL t_Revert ;
			IUnknown *t_Proxy ;

			t_Result = Begin_IWbemRefreshingServices (

				t_Impersonating ,
				t_OldContext ,
				t_OldSecurity ,
				t_IsProxy ,
				t_Interface ,
				t_Revert ,
				t_Proxy
			) ;

			if ( SUCCEEDED ( t_Result ) )
			{
				t_Result = t_Interface->RemoveObjectFromRefresher (

					a_RefresherId ,
					a_Id ,
					a_Flags ,
					a_ClientRefresherVersion ,
					a_ServerRefresherVersion
				) ;

				End_IWbemRefreshingServices (

					t_Impersonating ,
					t_OldContext ,
					t_OldSecurity ,
					t_IsProxy ,
					t_Interface ,
					t_Revert ,
					t_Proxy
				) ;
			}
		}
		else
		{
			t_Result = WBEM_E_NOT_AVAILABLE ;
		}
	}

	InterlockedDecrement ( & m_InProgress ) ;

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_IWbemServices_Proxy :: GetRemoteRefresher (

	WBEM_REFRESHER_ID *a_RefresherId ,
	long a_Flags ,
	DWORD a_ClientRefresherVersion ,
	IWbemRemoteRefresher **a_RemoteRefresher ,
	GUID *a_Guid ,
	DWORD *a_ServerRefresherVersion
)
{
	HRESULT t_Result = S_OK ;

	InterlockedIncrement ( & m_InProgress ) ;

	if ( m_GateClosed == 1 )
	{
		t_Result = WBEM_E_SHUTTING_DOWN ;
	}
	else
	{
		if ( m_Core_IWbemRefreshingServices )
		{
			BOOL t_Impersonating ;
			IUnknown *t_OldContext ;
			IServerSecurity *t_OldSecurity ;
			BOOL t_IsProxy ;
			IWbemRefreshingServices *t_Interface ;
			BOOL t_Revert ;
			IUnknown *t_Proxy ;

			t_Result = Begin_IWbemRefreshingServices (

				t_Impersonating ,
				t_OldContext ,
				t_OldSecurity ,
				t_IsProxy ,
				t_Interface ,
				t_Revert ,
				t_Proxy
			) ;

			if ( SUCCEEDED ( t_Result ) )
			{
				t_Result = t_Interface->GetRemoteRefresher (

					a_RefresherId ,
					a_Flags ,
					a_ClientRefresherVersion ,
					a_RemoteRefresher ,
					a_Guid ,
					a_ServerRefresherVersion
				) ;

				End_IWbemRefreshingServices (

					t_Impersonating ,
					t_OldContext ,
					t_OldSecurity ,
					t_IsProxy ,
					t_Interface ,
					t_Revert ,
					t_Proxy
				) ;
			}
		}
		else
		{
			t_Result = WBEM_E_NOT_AVAILABLE ;
		}
	}

	InterlockedDecrement ( & m_InProgress ) ;

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_IWbemServices_Proxy :: ReconnectRemoteRefresher (

	WBEM_REFRESHER_ID *a_RefresherId,
	long a_Flags,
	long a_NumberOfObjects,
	DWORD a_ClientRefresherVersion ,
	WBEM_RECONNECT_INFO *a_ReconnectInformation ,
	WBEM_RECONNECT_RESULTS *a_ReconnectResults ,
	DWORD *a_ServerRefresherVersion
)
{
	HRESULT t_Result = S_OK ;

	InterlockedIncrement ( & m_InProgress ) ;

	if ( m_GateClosed == 1 )
	{
		t_Result = WBEM_E_SHUTTING_DOWN ;
	}
	else
	{
		if ( m_Core_IWbemRefreshingServices )
		{
			BOOL t_Impersonating ;
			IUnknown *t_OldContext ;
			IServerSecurity *t_OldSecurity ;
			BOOL t_IsProxy ;
			IWbemRefreshingServices *t_Interface ;
			BOOL t_Revert ;
			IUnknown *t_Proxy ;

			t_Result = Begin_IWbemRefreshingServices (

				t_Impersonating ,
				t_OldContext ,
				t_OldSecurity ,
				t_IsProxy ,
				t_Interface ,
				t_Revert ,
				t_Proxy
			) ;

			if ( SUCCEEDED ( t_Result ) )
			{
				t_Result = t_Interface->ReconnectRemoteRefresher (

					a_RefresherId,
					a_Flags,
					a_NumberOfObjects,
					a_ClientRefresherVersion ,
					a_ReconnectInformation ,
					a_ReconnectResults ,
					a_ServerRefresherVersion
				) ;

				End_IWbemRefreshingServices (

					t_Impersonating ,
					t_OldContext ,
					t_OldSecurity ,
					t_IsProxy ,
					t_Interface ,
					t_Revert ,
					t_Proxy
				) ;
			}
		}
		else
		{
			t_Result = WBEM_E_NOT_AVAILABLE ;
		}
	}

	InterlockedDecrement ( & m_InProgress ) ;

	return t_Result ;
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\winmgmt\provsubsys\server\provwsv.cpp ===
/*++

Copyright (C) 1996-2001 Microsoft Corporation

Module Name:

	XXXX

Abstract:


History:

--*/

#include "PreComp.h"

#include <wbemint.h>
#include <stdio.h>
#include <NCObjApi.h>

#include "Globals.h"
#include "CGlobals.h"
#include "ProvSubs.h"
#include "ProvFact.h"
#include "ProvObSk.h"
#include "ProvInSk.h"
#include "ProvWsv.h"
#include "ProvCache.h"

#include "arrtempl.h"

#include "Guids.h"

#include <helper.h>


/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

#pragma warning( disable : 4355 )

CInterceptor_IWbemUnboundObjectSink :: CInterceptor_IWbemUnboundObjectSink (

	WmiAllocator &a_Allocator ,
	IUnknown *a_ServerSideProvider , 
	CWbemGlobal_IWmiObjectSinkController *a_Controller ,
	CServerObject_ProviderRegistrationV1 &a_Registration

) :	VoidPointerContainerElement (

		a_Controller ,
		this 
	) ,
	m_Allocator ( a_Allocator ) ,
	m_Controller ( NULL ) ,
	m_Unknown ( NULL ) ,
	m_Provider_IWbemUnboundObjectSink ( NULL ) ,
	m_Provider_Internal_IWbemUnboundObjectSink ( NULL ) ,
	m_Registration ( & a_Registration ) ,
	m_ProxyContainer ( a_Allocator , ProxyIndex_UnBound_Size , MAX_PROXIES ) ,
	m_InitializeResult ( S_OK ) ,
	m_ProcessIdentifier ( 0 ) 
{
	InterlockedIncrement ( & ProviderSubSystem_Globals :: s_CInterceptor_IWbemUnboundObjectSink_ObjectsInProgress ) ;

	ProviderSubSystem_Globals :: Increment_Global_Object_Count () ;
	
	if ( m_Registration )
	{
		m_Registration->AddRef () ;
	}

	m_InitializeResult = a_Controller->QueryInterface ( IID__IWmiProviderAbnormalShutdown , ( void ** ) & m_Controller ) ;
	if ( SUCCEEDED ( m_InitializeResult ) )
	{
		if ( a_ServerSideProvider ) 
		{
			m_Unknown = a_ServerSideProvider ;
			m_Unknown->AddRef () ;

			m_InitializeResult = a_ServerSideProvider->QueryInterface ( IID_IWbemUnboundObjectSink , ( void ** ) & m_Provider_IWbemUnboundObjectSink ) ;
			if ( SUCCEEDED ( m_InitializeResult ) )
			{
				m_InitializeResult  = a_ServerSideProvider->QueryInterface ( IID_Internal_IWbemUnboundObjectSink , ( void ** ) & m_Provider_Internal_IWbemUnboundObjectSink ) ;
			}
		}
	}
}

#pragma warning( default : 4355 )

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

CInterceptor_IWbemUnboundObjectSink :: ~CInterceptor_IWbemUnboundObjectSink ()
{
	if ( m_Controller )
	{
		m_Controller->Release () ;
	}

	if ( m_Unknown )
	{
		m_Unknown->Release () ;
	}

	if ( m_Provider_IWbemUnboundObjectSink )
	{
		m_Provider_IWbemUnboundObjectSink->Release () ;
	}

	if ( m_Provider_Internal_IWbemUnboundObjectSink )
	{
		m_Provider_Internal_IWbemUnboundObjectSink->Release () ;
	}

	if ( m_Registration )
	{
		m_Registration->Release () ;
	}

	InterlockedDecrement ( & ProviderSubSystem_Globals :: s_CInterceptor_IWbemUnboundObjectSink_ObjectsInProgress ) ;

	ProviderSubSystem_Globals :: Decrement_Global_Object_Count () ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_IWbemUnboundObjectSink :: Initialize ()
{
	if ( SUCCEEDED ( m_InitializeResult ) )
	{
		WmiStatusCode t_StatusCode = m_ProxyContainer.Initialize () ;
		if ( t_StatusCode != e_StatusCode_Success ) 
		{
			m_InitializeResult = WBEM_E_OUT_OF_MEMORY ;
		}
	}

	if ( SUCCEEDED ( m_InitializeResult ) )
	{
		_IWmiProviderSite *t_Site = NULL ;
		m_InitializeResult = m_Unknown->QueryInterface ( IID__IWmiProviderSite , ( void ** ) & t_Site ) ;
		if ( SUCCEEDED ( m_InitializeResult ) )
		{
			m_InitializeResult = t_Site->GetSite ( & m_ProcessIdentifier ) ;
			t_Site->Release () ;
		}
	}

	return m_InitializeResult ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

STDMETHODIMP_( ULONG ) CInterceptor_IWbemUnboundObjectSink :: AddRef ()
{
	return VoidPointerContainerElement :: AddRef () ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

STDMETHODIMP_(ULONG) CInterceptor_IWbemUnboundObjectSink :: Release ()
{
	return VoidPointerContainerElement :: Release () ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

STDMETHODIMP CInterceptor_IWbemUnboundObjectSink :: QueryInterface (

	REFIID iid , 
	LPVOID FAR *iplpv 
) 
{
	*iplpv = NULL ;

	if ( iid == IID_IUnknown )
	{
		*iplpv = ( LPVOID ) this ;
	}
	else if ( iid == IID_IWbemUnboundObjectSink )
	{
		if ( m_Provider_IWbemUnboundObjectSink )
		{
			*iplpv = ( LPVOID ) ( IWbemUnboundObjectSink * ) this ;
		}
	}
	else if ( iid == IID_IWbemShutdown )
	{
		*iplpv = ( LPVOID ) ( IWbemShutdown * ) this ;		
	}

	if ( *iplpv )
	{
		( ( LPUNKNOWN ) *iplpv )->AddRef () ;

		return ResultFromScode ( S_OK ) ;
	}
	else
	{
		return ResultFromScode ( E_NOINTERFACE ) ;
	}
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_IWbemUnboundObjectSink :: Begin_Interface (

	IUnknown *a_ServerInterface ,
	REFIID a_InterfaceIdentifier ,
	DWORD a_ProxyIndex ,
	IUnknown *a_InternalServerInterface ,
	REFIID a_InternalInterfaceIdentifier ,
	DWORD a_InternalProxyIndex ,
	DWORD a_ProcessIdentifier ,
	HANDLE &a_IdentifyToken ,
	BOOL &a_Impersonating ,
	IUnknown *&a_OldContext ,
	IServerSecurity *&a_OldSecurity ,
	BOOL &a_IsProxy ,
	IUnknown *&a_Interface ,
	BOOL &a_Revert ,
	IUnknown *&a_Proxy ,
	IWbemContext *a_Context
)
{
	HRESULT t_Result = S_OK ;

	a_IdentifyToken = NULL ;
	a_Revert = FALSE ;
	a_Proxy = NULL ;
	a_Impersonating = FALSE ;
	a_OldContext = NULL ;
	a_OldSecurity = NULL ;

	switch ( m_Registration->GetHosting () )
	{
		case e_Hosting_WmiCore:
		case e_Hosting_WmiCoreOrSelfHost:
		case e_Hosting_SelfHost:
		{
			a_Interface = a_ServerInterface ;
			a_IsProxy = FALSE ;
		}
		break ;

		default:
		{
			DWORD t_AuthenticationLevel = RPC_C_AUTHN_LEVEL_DEFAULT ;

			IUnknown *t_CallContext ;
			t_Result = CoGetCallContext ( IID_IUnknown , ( void ** ) & t_CallContext ) ;
			if ( SUCCEEDED ( t_Result ) )
			{
				t_Result = ProviderSubSystem_Common_Globals :: BeginImpersonation ( a_OldContext , a_OldSecurity , a_Impersonating , & t_AuthenticationLevel ) ;
				if ( SUCCEEDED ( t_Result ) ) 
				{
					if ( a_ProcessIdentifier )
					{
						t_Result = CoImpersonateClient () ;
						if ( SUCCEEDED ( t_Result ) )
						{
							DWORD t_ImpersonationLevel = ProviderSubSystem_Common_Globals :: GetCurrentImpersonationLevel () ;

							CoRevertToSelf () ;

							if ( t_ImpersonationLevel == RPC_C_IMP_LEVEL_IMPERSONATE || t_ImpersonationLevel == RPC_C_IMP_LEVEL_DELEGATE )
							{
								t_Result = ProviderSubSystem_Common_Globals :: SetProxyState ( 
								
									m_ProxyContainer , 
									a_ProxyIndex , 
									a_InterfaceIdentifier , 
									a_ServerInterface , 
									a_Proxy , 
									a_Revert
								) ;
							}
							else
							{
								switch ( m_Registration->GetHosting () )
								{
									case e_Hosting_SharedLocalSystemHost:
									case e_Hosting_SharedLocalSystemHostOrSelfHost:
									{
										t_Result = ProviderSubSystem_Common_Globals :: SetProxyState_SvcHost ( 
										
											m_ProxyContainer , 
											a_InternalProxyIndex , 
											a_InterfaceIdentifier , 
											a_InternalServerInterface , 
											a_Proxy , 
											a_Revert , 
											a_ProcessIdentifier , 
											a_IdentifyToken ,
											ProviderSubSystem_Common_Globals :: s_Token_All_Access_System_ACE ,
											ProviderSubSystem_Common_Globals :: s_System_ACESize
										) ;
									}
									break ;

									case e_Hosting_SharedLocalServiceHost:
									{
										t_Result = ProviderSubSystem_Common_Globals :: SetProxyState_SvcHost ( 
										
											m_ProxyContainer , 
											a_InternalProxyIndex , 
											a_InterfaceIdentifier , 
											a_InternalServerInterface , 
											a_Proxy , 
											a_Revert , 
											a_ProcessIdentifier , 
											a_IdentifyToken ,
											ProviderSubSystem_Common_Globals :: s_Token_All_Access_LocalService_ACE ,
											ProviderSubSystem_Common_Globals :: s_LocalService_ACESize
										) ;
									}
									break ;

									case e_Hosting_SharedNetworkServiceHost:
									{
										t_Result = ProviderSubSystem_Common_Globals :: SetProxyState_SvcHost ( 
										
											m_ProxyContainer , 
											a_InternalProxyIndex , 
											a_InterfaceIdentifier , 
											a_InternalServerInterface , 
											a_Proxy , 
											a_Revert , 
											a_ProcessIdentifier , 
											a_IdentifyToken ,
											ProviderSubSystem_Common_Globals :: s_Token_All_Access_NetworkService_ACE ,
											ProviderSubSystem_Common_Globals :: s_NetworkService_ACESize
	 									) ;
									}
									break ;

									default:
									{
										t_Result = WBEM_E_UNEXPECTED ;
									}
									break ;
								}
							}
						}
					}
					else
					{
						t_Result = ProviderSubSystem_Common_Globals :: SetProxyState ( 
						
							m_ProxyContainer , 
							a_ProxyIndex , 
							a_InterfaceIdentifier , 
							a_ServerInterface , 
							a_Proxy , 
							a_Revert
						) ;
					}
				}

				if ( FAILED ( t_Result ) && t_Result != WBEM_E_NOT_FOUND )
				{
					ProviderSubSystem_Common_Globals :: EndImpersonation ( a_OldContext , a_OldSecurity , a_Impersonating ) ;
				}

				t_CallContext->Release () ;
			}
			else
			{
				t_Result = ProviderSubSystem_Common_Globals :: SetProxyState_NoImpersonation ( 
				
					m_ProxyContainer , 
					a_ProxyIndex , 
					a_InterfaceIdentifier , 
					a_ServerInterface , 
					a_Proxy , 
					a_Revert
				) ;
			}

			if ( t_Result == WBEM_E_NOT_FOUND )
			{
				a_Interface = a_ServerInterface ;
				a_IsProxy = FALSE ;
				t_Result = S_OK ;
			}
			else
			{
				if ( SUCCEEDED ( t_Result ) )
				{
					a_IsProxy = TRUE ;

					a_Interface = ( IUnknown * ) a_Proxy ;

					// Set cloaking on the proxy
					// =========================

					DWORD t_ImpersonationLevel = ProviderSubSystem_Common_Globals :: GetCurrentImpersonationLevel () ;

					t_Result = ProviderSubSystem_Common_Globals :: SetCloaking (

						a_Interface ,
						RPC_C_AUTHN_LEVEL_DEFAULT , 
						t_ImpersonationLevel
					) ;

					if ( SUCCEEDED ( t_Result ) )
					{
						if ( a_Context )
						{
							VARIANT t_Variant ;
							VariantInit ( & t_Variant ) ;
							t_Variant.lVal = t_AuthenticationLevel ;
							t_Variant.vt = VT_I4 ;

							
							t_Result = a_Context->SetValue ( L"__WBEM_CLIENT_AUTHENTICATION_LEVEL" , 0, & t_Variant ) ;
						}
					}

					if ( FAILED ( t_Result ) )
					{
						if ( a_IdentifyToken )
						{
							HRESULT t_TempResult = ProviderSubSystem_Common_Globals :: RevertProxyState_SvcHost ( 

								m_ProxyContainer , 
								a_InternalProxyIndex , 
								a_Proxy , 
								a_Revert ,
								a_ProcessIdentifier , 
								a_IdentifyToken 
							) ;
						}
						else
						{
							HRESULT t_TempResult = ProviderSubSystem_Common_Globals :: RevertProxyState ( 

								m_ProxyContainer , 
								a_ProxyIndex , 
								a_Proxy , 
								a_Revert
							) ;
						}
					}
				}
			}
		}
		break ;
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_IWbemUnboundObjectSink :: End_Interface (

	IUnknown *a_ServerInterface ,
	REFIID a_InterfaceIdentifier ,
	DWORD a_ProxyIndex ,
	IUnknown *a_InternalServerInterface ,
	REFIID a_InternalInterfaceIdentifier ,
	DWORD a_InternalProxyIndex ,
	DWORD a_ProcessIdentifier ,
	HANDLE a_IdentifyToken ,
	BOOL a_Impersonating ,
	IUnknown *a_OldContext ,
	IServerSecurity *a_OldSecurity ,
	BOOL a_IsProxy ,
	IUnknown *a_Interface ,
	BOOL a_Revert ,
	IUnknown *a_Proxy
)
{
	CoRevertToSelf () ;

	if ( a_Proxy )
	{
		if ( a_IdentifyToken )
		{
			HRESULT t_TempResult = ProviderSubSystem_Common_Globals :: RevertProxyState_SvcHost ( 

				m_ProxyContainer , 
				a_InternalProxyIndex , 
				a_Proxy , 
				a_Revert ,
				a_ProcessIdentifier ,
				a_IdentifyToken 
			) ;
		}
		else
		{
			HRESULT t_TempResult = ProviderSubSystem_Common_Globals :: RevertProxyState ( 

				m_ProxyContainer , 
				a_ProxyIndex , 
				a_Proxy , 
				a_Revert
			) ;
		}
	}

	ProviderSubSystem_Common_Globals :: EndImpersonation ( a_OldContext , a_OldSecurity , a_Impersonating ) ;

	return S_OK ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_IWbemUnboundObjectSink :: IndicateToConsumer (

	IWbemClassObject *a_LogicalConsumer ,
	long a_ObjectCount ,
	IWbemClassObject **a_Objects
)
{
	if ( m_Provider_IWbemUnboundObjectSink )
	{
		IUnknown *t_ServerInterface = m_Provider_IWbemUnboundObjectSink ;
		REFIID t_InterfaceIdentifier = IID_IWbemUnboundObjectSink ;
		DWORD t_ProxyIndex = ProxyIndex_UnBound_IWbemUnboundObjectSink ;
		IUnknown *t_InternalServerInterface = m_Provider_Internal_IWbemUnboundObjectSink ;
		REFIID t_InternalInterfaceIdentifier = IID_Internal_IWbemUnboundObjectSink ;
		DWORD t_InternalProxyIndex = ProxyIndex_UnBound_Internal_IWbemUnboundObjectSink ;
		BOOL t_Impersonating ;
		IUnknown *t_OldContext ;
		IServerSecurity *t_OldSecurity ;
		BOOL t_IsProxy ;
		IUnknown *t_Interface ;
		BOOL t_Revert ;
		IUnknown *t_Proxy ;
		DWORD t_ProcessIdentifier = m_ProcessIdentifier ;
		HANDLE t_IdentifyToken = NULL ;

		HRESULT t_Result = Begin_Interface (

			t_ServerInterface ,
			t_InterfaceIdentifier ,
			t_ProxyIndex ,
			t_InternalServerInterface ,
			t_InternalInterfaceIdentifier ,
			t_InternalProxyIndex ,
			t_ProcessIdentifier ,
			t_IdentifyToken ,
			t_Impersonating ,
			t_OldContext ,
			t_OldSecurity ,
			t_IsProxy ,
			t_Interface ,
			t_Revert ,
			t_Proxy
		) ;

		if ( SUCCEEDED ( t_Result ) )
		{
			if ( t_IdentifyToken )
			{
				WmiInternalContext t_InternalContext ;
				t_InternalContext.m_IdentifyHandle = ( unsigned __int64 ) t_IdentifyToken ;
				t_InternalContext.m_ProcessIdentifier = GetCurrentProcessId () ;

				t_Result = ( ( Internal_IWbemUnboundObjectSink * ) t_Interface )->Internal_IndicateToConsumer (

					t_InternalContext ,
					a_LogicalConsumer ,
					a_ObjectCount ,
					a_Objects
				) ;
			}
			else
			{

				t_Result = ( ( IWbemUnboundObjectSink * ) t_Interface )->IndicateToConsumer (

					a_LogicalConsumer ,
					a_ObjectCount ,
					a_Objects
				) ;
			}

			End_Interface (

				t_ServerInterface ,
				t_InterfaceIdentifier ,
				t_ProxyIndex ,
				t_InternalServerInterface ,
				t_InternalInterfaceIdentifier ,
				t_InternalProxyIndex ,
				t_ProcessIdentifier ,
				t_IdentifyToken ,
				t_Impersonating ,
				t_OldContext ,
				t_OldSecurity ,
				t_IsProxy ,
				t_Interface ,
				t_Revert ,
				t_Proxy
			) ;
		}

		if ( FAILED ( t_Result ) )
		{
			if ( ( HRESULT_ERROR_FUNC(t_Result) == HRESULT_ERROR_SERVER_UNAVAILABLE ) || ( HRESULT_ERROR_FUNC(t_Result) == HRESULT_ERROR_CALL_FAILED_DNE ) || ( t_Result == RPC_E_DISCONNECTED ))
			{
				if ( m_Controller )
				{
					m_Controller->AbnormalShutdown () ;
				}
			}
		}

		return t_Result ;
	}

	return WBEM_E_PROVIDER_NOT_CAPABLE;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_IWbemUnboundObjectSink :: Shutdown (

		LONG a_Flags ,
		ULONG a_MaxMilliSeconds ,
		IWbemContext *a_Context
)
{
	return S_OK ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

InternalQuotaInterface :: InternalQuotaInterface ( CInterceptor_IWbemProvider *a_Owner ) : m_Owner ( NULL ) , m_ReferenceCount ( 0 )
{
	a_Owner->QueryInterface ( IID__IWmiProviderQuota , ( void ** ) & m_Owner ) ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

InternalQuotaInterface :: ~InternalQuotaInterface ()
{
	if ( m_Owner )
	{
		m_Owner->Release () ;
	}
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT InternalQuotaInterface :: Initialize ()
{
	return m_Owner ? S_OK : WBEM_E_CRITICAL_ERROR ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

STDMETHODIMP InternalQuotaInterface :: QueryInterface (

	REFIID iid ,
	LPVOID FAR *iplpv
)
{
	*iplpv = NULL ;

	if ( iid == IID_IUnknown )
	{
		*iplpv = ( LPVOID ) this ;
	}
	else if ( iid == IID__IWmiProviderQuota )
	{
		*iplpv = ( LPVOID ) ( _IWmiProviderQuota * ) this ;		
	}	

	if ( *iplpv )
	{
		( ( LPUNKNOWN ) *iplpv )->AddRef () ;

		return ResultFromScode ( S_OK ) ;
	}
	else
	{
		return ResultFromScode ( E_NOINTERFACE ) ;
	}
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

STDMETHODIMP_(ULONG) InternalQuotaInterface :: AddRef ( void )
{
	return InterlockedIncrement ( & m_ReferenceCount ) ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

STDMETHODIMP_(ULONG) InternalQuotaInterface :: Release ( void )
{
	LONG t_ReferenceCount = InterlockedDecrement ( & m_ReferenceCount ) ;
	if ( t_ReferenceCount == 0 )
	{
		delete this ;
	}

	return t_ReferenceCount ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT InternalQuotaInterface :: Violation (

	long a_Flags ,
	IWbemContext *a_Context ,
	IWbemClassObject *a_Object	
)
{
	return m_Owner->Violation (

		a_Flags ,
		a_Context ,
		a_Object	
	) ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

#pragma warning( disable : 4355 )

CInterceptor_IWbemProvider :: CInterceptor_IWbemProvider (

	WmiAllocator &a_Allocator ,
	CWbemGlobal_IWmiProviderController *a_Controller ,
	const ProviderCacheKey &a_Key ,
	const ULONG &a_Period ,
	IWbemContext *a_InitializationContext ,
	CServerObject_ProviderRegistrationV1 &a_Registration

) : CWbemGlobal_IWmiObjectSinkController ( a_Allocator ) ,
	ServiceCacheElement ( 

		a_Controller ,
		a_Key ,
		a_Period 
	) ,
	m_Allocator ( a_Allocator ) ,
	m_Unknown ( NULL ) ,
	m_Registration ( & a_Registration ) ,
	m_Host ( NULL ) ,
	m_Quota ( NULL ) ,
	m_Internal ( this ) ,
	m_User ( NULL ) ,
	m_Locale ( NULL ) ,
	m_Namespace ( NULL ) ,
	m_Provider_IWbemServices ( NULL ) ,
	m_Provider_IWbemPropertyProvider ( NULL ) ,
	m_Provider_IWbemHiPerfProvider ( NULL ) ,
	m_Provider_IWbemEventProvider ( NULL ) ,
	m_Provider_IWbemEventProviderQuerySink ( NULL ) ,
	m_Provider_IWbemEventProviderSecurity ( NULL ) ,
	m_Provider_IWbemEventConsumerProvider ( NULL ) ,
	m_Provider_IWbemEventConsumerProviderEx ( NULL ) ,
	m_Provider_IWbemUnboundObjectSink ( NULL ) ,
	m_Provider_Internal_IWbemServices ( NULL ) ,
	m_Provider_Internal_IWbemPropertyProvider ( NULL ) ,
	m_Provider_Internal_IWbemEventProvider ( NULL ) ,
	m_Provider_Internal_IWbemEventProviderQuerySink ( NULL ) ,
	m_Provider_Internal_IWbemEventProviderSecurity ( NULL ) ,
	m_Provider_Internal_IWbemEventConsumerProvider ( NULL ) ,
	m_Provider_Internal_IWbemEventConsumerProviderEx ( NULL ) ,
	m_Provider_Internal_IWbemUnboundObjectSink ( NULL ) ,
	m_Provider_Internal_IWmiProviderConfiguration ( NULL ) ,
	m_ProxyContainer ( a_Allocator , ProxyIndex_Provider_Size , MAX_PROXIES ) ,
	m_ProcessIdentifier ( 0 ) ,
	m_Resumed ( 1 ) ,
	m_UnInitialized ( 0 ) ,
	m_Initialized ( 0 ) ,
	m_InitializeResult ( S_OK ) ,
	m_InitializedEvent ( NULL ) , 
	m_InitializationContext ( a_InitializationContext )
{
	InterlockedIncrement ( & ProviderSubSystem_Globals :: s_CInterceptor_IWbemProvider_ObjectsInProgress ) ;

	ProviderSubSystem_Globals :: Increment_Global_Object_Count () ;

	if ( m_InitializationContext )
	{
		m_InitializationContext->AddRef () ;
	}

	if ( m_Registration )
	{
		m_Registration->AddRef () ;
	}
}

#pragma warning( default : 4355 )

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

CInterceptor_IWbemProvider :: ~CInterceptor_IWbemProvider ()
{
	CWbemGlobal_IWmiObjectSinkController :: UnInitialize () ;

	if ( m_InitializationContext )
	{
		m_InitializationContext->Release () ;
	}

	if ( m_InitializedEvent )
	{
		CloseHandle ( m_InitializedEvent ) ;
	}

	if ( m_Registration )
	{
		m_Registration->Release () ;
	}

	if ( m_Namespace ) 
	{
		SysFreeString ( m_Namespace ) ;
	}

	if ( m_Locale ) 
	{
		SysFreeString ( m_Locale ) ;
	}

	if ( m_User ) 
	{
		SysFreeString ( m_User ) ;
	}

	InterlockedDecrement ( & ProviderSubSystem_Globals :: s_CInterceptor_IWbemProvider_ObjectsInProgress ) ;

	ProviderSubSystem_Globals :: Decrement_Global_Object_Count () ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_IWbemProvider :: Initialize (

	LPWSTR a_User,
	LONG a_Flags,
	LPWSTR a_Namespace,
	LPWSTR a_Locale,
	IWbemServices *a_Core ,         // For anybody
	IWbemContext *a_Context ,
	IWbemProviderInitSink *a_Sink     // For init signals
)
{
	HRESULT t_Result = S_OK ;

	WmiStatusCode t_StatusCode = CWbemGlobal_IWmiObjectSinkController :: Initialize () ;
	if ( t_StatusCode != e_StatusCode_Success ) 
	{
		t_Result = WBEM_E_OUT_OF_MEMORY ;
	}
	
	if ( SUCCEEDED ( t_Result ) )
	{
		t_StatusCode = m_ProxyContainer.Initialize () ;
		if ( t_StatusCode != e_StatusCode_Success ) 
		{
			t_Result = WBEM_E_OUT_OF_MEMORY ;
		}
	}

	if ( SUCCEEDED ( t_Result ) )
	{
		m_InitializedEvent = CreateEvent ( NULL , TRUE , FALSE , NULL ) ;
		if ( m_InitializedEvent == NULL )
		{
			t_Result = t_Result = WBEM_E_OUT_OF_MEMORY ;
		}
	}

	if ( SUCCEEDED ( t_Result ) )
	{
		m_Quota = new InternalQuotaInterface ( this ) ;
		if ( m_Quota )
		{
			m_Quota->AddRef () ;
			t_Result = m_Quota->Initialize () ;
		}
		else
		{
			t_Result = WBEM_E_OUT_OF_MEMORY ;
		}

	}

	if ( SUCCEEDED ( t_Result ) ) 
	{
		if ( a_User ) 
		{
			m_User = SysAllocString ( a_User ) ;
			if ( m_User == NULL )
			{
				t_Result = WBEM_E_OUT_OF_MEMORY ;
			}
		}
	}

	if ( SUCCEEDED ( t_Result ) ) 
	{
		if ( a_Locale ) 
		{
			m_Locale = SysAllocString ( a_Locale ) ;
			if ( m_Locale == NULL )
			{
				t_Result = WBEM_E_OUT_OF_MEMORY ;
			}
		}
	}

	if ( SUCCEEDED ( t_Result ) ) 
	{
		if ( a_Namespace ) 
		{
			m_Namespace = SysAllocString ( a_Namespace ) ;
			if ( m_Namespace == NULL )
			{
				t_Result = WBEM_E_OUT_OF_MEMORY ;
			}
		}
	}

	if ( SUCCEEDED ( t_Result ) )
	{
		t_Result = m_InitializeResult ;
	}

	a_Sink->SetStatus ( t_Result , 0 ) ;

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_IWbemProvider :: GetInitializeResult () 
{
	
	return m_InitializeResult ;
}


HRESULT CInterceptor_IWbemProvider :: SetProvider ( _IWmiProviderHost *a_Host , IUnknown *a_Unknown )
{
	if ( a_Host )
	{
		m_Host = a_Host ;
		m_Host->AddRef () ;

		HRESULT t_Result = m_Host->GetProcessIdentifier ( & m_ProcessIdentifier ) ;
		if ( FAILED ( t_Result ) )
		{
			m_InitializeResult = WBEM_E_PROVIDER_LOAD_FAILURE ;
		}
	}
	else
	{
		m_ProcessIdentifier = GetCurrentProcessId ();
	}

	m_Unknown = a_Unknown ;
	m_Unknown->AddRef () ;

	HRESULT t_TempResult = m_Unknown->QueryInterface ( IID_IWbemServices , ( void ** ) & m_Provider_IWbemServices ) ;
	if ( SUCCEEDED ( t_TempResult ) )
	{
		t_TempResult = m_Unknown->QueryInterface ( IID_Internal_IWbemServices , ( void ** ) & m_Provider_Internal_IWbemServices ) ;
		if ( FAILED ( t_TempResult ) )
		{
			m_InitializeResult = WBEM_E_PROVIDER_LOAD_FAILURE ;
		}
	}

	t_TempResult = m_Unknown->QueryInterface ( IID_IWbemPropertyProvider , ( void ** ) & m_Provider_IWbemPropertyProvider ) ;
	if ( SUCCEEDED ( t_TempResult ) )
	{
		t_TempResult = m_Unknown->QueryInterface ( IID_Internal_IWbemPropertyProvider , ( void ** ) & m_Provider_Internal_IWbemPropertyProvider ) ;
		if ( FAILED ( t_TempResult ) )
		{
			m_InitializeResult = WBEM_E_PROVIDER_LOAD_FAILURE ;
		}
	}

	t_TempResult = m_Unknown->QueryInterface ( IID_IWbemHiPerfProvider , ( void ** ) & m_Provider_IWbemHiPerfProvider ) ;

	t_TempResult = m_Unknown->QueryInterface ( IID_IWbemEventProvider , ( void ** ) & m_Provider_IWbemEventProvider ) ;
	if ( SUCCEEDED ( t_TempResult ) )
	{
		t_TempResult = m_Unknown->QueryInterface ( IID_Internal_IWbemEventProvider , ( void ** ) & m_Provider_Internal_IWbemEventProvider ) ;
		if ( FAILED ( t_TempResult ) )
		{
			m_InitializeResult = WBEM_E_PROVIDER_LOAD_FAILURE ;
		}
	}

	t_TempResult = m_Unknown->QueryInterface ( IID_IWbemEventProviderQuerySink , ( void ** ) & m_Provider_IWbemEventProviderQuerySink ) ;
	if ( SUCCEEDED ( t_TempResult ) )
	{
		t_TempResult = m_Unknown->QueryInterface ( IID_Internal_IWbemEventProviderQuerySink , ( void ** ) & m_Provider_Internal_IWbemEventProviderQuerySink ) ;
		if ( FAILED ( t_TempResult ) )
		{
			m_InitializeResult = WBEM_E_PROVIDER_LOAD_FAILURE ;
		}
	}

	t_TempResult = m_Unknown->QueryInterface ( IID_IWbemEventProviderSecurity , ( void ** ) & m_Provider_IWbemEventProviderSecurity ) ;
	if ( SUCCEEDED ( t_TempResult ) )
	{
		t_TempResult = m_Unknown->QueryInterface ( IID_Internal_IWbemEventProviderSecurity , ( void ** ) & m_Provider_Internal_IWbemEventProviderSecurity ) ;
		if ( FAILED ( t_TempResult ) )
		{
			m_InitializeResult = WBEM_E_PROVIDER_LOAD_FAILURE ;
		}
	}

	t_TempResult = m_Unknown->QueryInterface ( IID_IWbemUnboundObjectSink , ( void ** ) & m_Provider_IWbemUnboundObjectSink ) ;
	if ( SUCCEEDED ( t_TempResult ) )
	{
		t_TempResult = m_Unknown->QueryInterface ( IID_Internal_IWbemUnboundObjectSink , ( void ** ) & m_Provider_Internal_IWbemUnboundObjectSink ) ;
		if ( FAILED ( t_TempResult ) )
		{
			m_InitializeResult = WBEM_E_PROVIDER_LOAD_FAILURE ;
		}
	}

	t_TempResult = m_Unknown->QueryInterface ( IID_IWbemEventConsumerProvider , ( void ** ) & m_Provider_IWbemEventConsumerProvider ) ;
	if ( SUCCEEDED ( t_TempResult ) )
	{
		t_TempResult = m_Unknown->QueryInterface ( IID_Internal_IWbemEventConsumerProvider , ( void ** ) & m_Provider_Internal_IWbemEventConsumerProvider ) ;
		if ( FAILED ( t_TempResult ) )
		{
			m_InitializeResult = WBEM_E_PROVIDER_LOAD_FAILURE ;
		}
	}

	t_TempResult = m_Unknown->QueryInterface ( IID_IWbemEventConsumerProviderEx , ( void ** ) & m_Provider_IWbemEventConsumerProviderEx ) ;
	if ( SUCCEEDED ( t_TempResult ) )
	{
		t_TempResult = m_Unknown->QueryInterface ( IID_Internal_IWbemEventConsumerProviderEx , ( void ** ) & m_Provider_Internal_IWbemEventConsumerProviderEx ) ;
		if ( FAILED ( t_TempResult ) )
		{
			m_InitializeResult = WBEM_E_PROVIDER_LOAD_FAILURE ;
		}
	}

	t_TempResult = m_Unknown->QueryInterface ( IID__IWmiProviderConfiguration , ( void ** ) & m_Provider__IWmiProviderConfiguration ) ;
	if ( FAILED ( t_TempResult ) )
	{
		m_InitializeResult = WBEM_E_PROVIDER_LOAD_FAILURE ;
	}

	t_TempResult = m_Unknown->QueryInterface ( IID_Internal_IWmiProviderConfiguration , ( void ** ) & m_Provider_Internal_IWmiProviderConfiguration ) ;
	if ( FAILED ( t_TempResult ) )
	{
		m_InitializeResult = WBEM_E_PROVIDER_LOAD_FAILURE ;
	}

	return m_InitializeResult ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_IWbemProvider :: DownLevel (

	long a_Flags ,
	IWbemContext *a_Context ,
	REFIID a_Riid,
	void **a_Interface
)
{
	return m_Unknown->QueryInterface ( a_Riid , a_Interface ) ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_IWbemProvider :: SetInitialized ( HRESULT a_InitializeResult )
{

	m_InitializeResult = a_InitializeResult ;
	
	InterlockedExchange ( & m_Initialized , 1 ) ;

	if ( m_InitializedEvent )
	{
		SetEvent ( m_InitializedEvent ) ;
	}

	return S_OK ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_IWbemProvider :: IsIndependant ( IWbemContext *a_Context )
{
	BOOL t_DependantCall = FALSE ;
	HRESULT t_Result = ProviderSubSystem_Common_Globals :: IsDependantCall ( m_InitializationContext , a_Context , t_DependantCall ) ;
	if ( SUCCEEDED ( t_Result ) )
	{
		if ( t_DependantCall == FALSE )
		{
		}
		else
		{
			return S_FALSE ;
		}
	}

	return t_Result ;
}


/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_IWbemProvider :: WaitProvider ( IWbemContext *a_Context , ULONG a_Timeout )
{
	HRESULT t_Result = WBEM_E_UNEXPECTED ;

	if ( m_Initialized == 0 )
	{
		BOOL t_DependantCall = FALSE ;
		t_Result = ProviderSubSystem_Common_Globals :: IsDependantCall ( m_InitializationContext , a_Context , t_DependantCall ) ;
		if ( SUCCEEDED ( t_Result ) )
		{
			if ( t_DependantCall == FALSE )
			{
				if ( WaitForSingleObject ( m_InitializedEvent , a_Timeout ) == WAIT_TIMEOUT )
				{
					return WBEM_E_PROVIDER_LOAD_FAILURE ;
				}
			}
			else
			{
				if ( WaitForSingleObject ( m_InitializedEvent , 0 ) == WAIT_TIMEOUT )
				{
					return S_FALSE ;
				}
			}
		}
	}
	else
	{
		t_Result = S_OK ;
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

STDMETHODIMP_(ULONG) CInterceptor_IWbemProvider :: AddRef ( void )
{
	return ServiceCacheElement :: AddRef () ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

STDMETHODIMP_(ULONG) CInterceptor_IWbemProvider :: Release ( void )
{
	return ServiceCacheElement :: Release () ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

void CInterceptor_IWbemProvider :: CallBackInternalRelease ()
{
	if ( InterlockedCompareExchange ( & m_UnInitialized ,  1 , 0 ) == 0 )
	{
		WmiStatusCode t_StatusCode = m_ProxyContainer.UnInitialize () ;

		CWbemGlobal_HostedProviderController *t_Controller = ProviderSubSystem_Globals :: GetHostedProviderController () ;
		CWbemGlobal_HostedProviderController_Container_Iterator t_Iterator ;

		t_Controller->Lock () ;

		t_StatusCode = t_Controller->Find ( m_ProcessIdentifier , t_Iterator ) ;
		if ( t_StatusCode == e_StatusCode_Success )
		{
			ProviderController *t_ProviderController = NULL ;
			HRESULT t_Result = t_Iterator.GetElement ()->QueryInterface ( IID_ProviderController , ( void ** ) & t_ProviderController ) ;
			if ( SUCCEEDED ( t_Result ) ) 
			{
				t_StatusCode = t_ProviderController->Delete ( this ) ;
				if ( t_StatusCode == e_StatusCode_Success )
				{
					NonCyclicRelease () ;
				}

				t_ProviderController->Release () ;
			}
		}

		t_Controller->UnLock () ;

		if ( m_Quota )
		{
			m_Quota->Release () ;
		}

		if ( m_Unknown )
		{
			m_Unknown->Release () ;
		}

		if ( m_Provider_IWbemServices )
		{
			m_Provider_IWbemServices->Release () ; 
		}

		if ( m_Provider_IWbemPropertyProvider )
		{
			m_Provider_IWbemPropertyProvider->Release () ; 
		}

		if ( m_Provider_IWbemHiPerfProvider )
		{
			m_Provider_IWbemHiPerfProvider->Release () ;
		}

		if ( m_Provider_IWbemEventProvider )
		{
			m_Provider_IWbemEventProvider->Release () ;
		}

		if ( m_Provider_IWbemEventProviderQuerySink )
		{
			m_Provider_IWbemEventProviderQuerySink->Release () ;
		}

		if ( m_Provider_IWbemEventProviderSecurity )
		{
			m_Provider_IWbemEventProviderSecurity->Release () ;
		}

		if ( m_Provider_IWbemEventConsumerProviderEx )
		{
			m_Provider_IWbemEventConsumerProviderEx->Release () ;
		}

		if ( m_Provider_IWbemEventConsumerProvider )
		{
			m_Provider_IWbemEventConsumerProvider->Release () ;
		}

		if ( m_Provider__IWmiProviderConfiguration )
		{
			m_Provider__IWmiProviderConfiguration->Release () ;
		}

		if ( m_Provider_IWbemUnboundObjectSink )
		{
			m_Provider_IWbemUnboundObjectSink->Release () ;
		}

		if ( m_Provider_Internal_IWbemServices )
		{
			m_Provider_Internal_IWbemServices->Release () ;
		}

		if ( m_Provider_Internal_IWbemPropertyProvider )
		{
			m_Provider_Internal_IWbemPropertyProvider->Release () ;
		}

		if ( m_Provider_Internal_IWbemEventProvider )
		{
			m_Provider_Internal_IWbemEventProvider->Release () ;
		}

		if ( m_Provider_Internal_IWbemEventProviderQuerySink )
		{
			m_Provider_Internal_IWbemEventProviderQuerySink->Release () ;
		}

		if ( m_Provider_Internal_IWbemEventProviderSecurity )
		{
			m_Provider_Internal_IWbemEventProviderSecurity->Release () ;
		}

		if ( m_Provider_Internal_IWbemEventConsumerProvider )
		{
			m_Provider_Internal_IWbemEventConsumerProvider->Release () ;
		}

		if ( m_Provider_Internal_IWbemEventConsumerProviderEx )
		{
			m_Provider_Internal_IWbemEventConsumerProviderEx->Release () ;
		}

		if ( m_Provider_Internal_IWbemUnboundObjectSink )
		{
			m_Provider_Internal_IWbemUnboundObjectSink->Release () ;
		}

		if ( m_Provider_Internal_IWmiProviderConfiguration )
		{
			m_Provider_Internal_IWmiProviderConfiguration->Release () ;
		}

		if ( m_Host )
		{
			m_Host->Release () ;
		}

		SetEvent ( ProviderSubSystem_Globals :: s_CoFreeUnusedLibrariesEvent ) ;
	}
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

STDMETHODIMP CInterceptor_IWbemProvider :: QueryInterface (

	REFIID iid , 
	LPVOID FAR *iplpv 
) 
{
	*iplpv = NULL ;

	if ( m_Initialized == 0 )
	{
		if ( iid == IID_IUnknown )
		{
			*iplpv = ( LPVOID ) this ;
		}
		else if ( iid == IID_IWbemServices )
		{
			*iplpv = ( LPVOID ) ( IWbemServices * ) this ;
		}	
		else if ( iid == IID_IWbemPropertyProvider )
		{
			*iplpv = ( LPVOID ) ( IWbemPropertyProvider * ) this ;
		}
		else if ( iid == IID_IWbemHiPerfProvider )
		{
			*iplpv = ( LPVOID ) ( IWbemHiPerfProvider * ) this ;
		}
		else if ( iid == IID_IWbemEventProvider )
		{
			*iplpv = ( LPVOID ) ( IWbemEventProvider * ) this ;
		}
		else if ( iid == IID_IWbemEventProviderQuerySink )
		{
			*iplpv = ( LPVOID ) ( IWbemEventProviderQuerySink * ) this ;
		}
		else if ( iid == IID_IWbemEventProviderSecurity )
		{
			*iplpv = ( LPVOID ) ( IWbemEventProviderSecurity * ) this ;
		}
		else if ( iid == IID_IWbemEventConsumerProvider )
		{
			*iplpv = ( LPVOID ) ( IWbemEventConsumerProvider * ) this ;
		}
		else if ( iid == IID_IWbemEventConsumerProviderEx )
		{
			*iplpv = ( LPVOID ) ( IWbemEventConsumerProviderEx  * ) this ;
		}
		else if ( iid == IID_IWbemUnboundObjectSink )
		{
			*iplpv = ( LPVOID ) ( IWbemUnboundObjectSink * ) this ;
		}
		else if ( iid == IID_IWbemProviderInit )
		{
			*iplpv = ( LPVOID ) ( IWbemProviderInit * ) this ;
		}	
		else if ( iid == IID__IWmiProviderInitialize )
		{
			*iplpv = ( LPVOID ) ( _IWmiProviderInitialize * ) this ;		
		}	
		else if ( iid == IID_IWbemShutdown )
		{
			*iplpv = ( LPVOID ) ( IWbemShutdown * ) this ;
		}
		else if ( iid == IID__IWmiProviderLoad )
		{
			*iplpv = ( LPVOID ) ( _IWmiProviderLoad * )this ;		
		}	
		else if ( iid == IID__IWmiProviderConfiguration )
		{
			*iplpv = ( LPVOID ) ( _IWmiProviderConfiguration * ) this ;
		}	
		else if ( iid == IID__IWmiProviderQuota )
		{
			*iplpv = ( LPVOID ) & ( this->m_Internal ) ;
		}	
		else if ( iid == IID__IWmiProviderStack )
		{
			*iplpv = ( LPVOID ) ( _IWmiProviderStack * ) this ;
		}	
		else if ( iid == IID__IWmiProviderCache )
		{
			*iplpv = ( LPVOID ) ( _IWmiProviderCache * ) this ;
		}	
		else if ( iid == IID_CWbemGlobal_IWmiObjectSinkController )
		{
			*iplpv = ( LPVOID ) ( CWbemGlobal_IWmiObjectSinkController * ) this ;
		}	
		else if ( iid == IID_CInterceptor_IWbemProvider )
		{
			*iplpv = ( LPVOID ) ( CInterceptor_IWbemProvider * ) this ;
		}	
	}
	else
	{
		if ( iid == IID_IUnknown )
		{
			*iplpv = ( LPVOID ) this ;
		}
		else if ( iid == IID_IWbemServices )
		{
			if ( m_Provider_IWbemServices )
			{
				*iplpv = ( LPVOID ) ( IWbemServices * ) this ;
			}
		}	
		else if ( iid == IID_IWbemPropertyProvider )
		{
			if ( m_Provider_IWbemPropertyProvider )
			{
				*iplpv = ( LPVOID ) ( IWbemPropertyProvider * ) this ;
			}
		}
		else if ( iid == IID_IWbemHiPerfProvider )
		{
			if ( m_Provider_IWbemHiPerfProvider )
			{
				*iplpv = ( LPVOID ) ( IWbemHiPerfProvider * ) this ;
			}
		}
		else if ( iid == IID_IWbemEventProvider )
		{
			if ( m_Provider_IWbemEventProvider )
			{
				*iplpv = ( LPVOID ) ( IWbemEventProvider * ) this ;
			}
		}
		else if ( iid == IID_IWbemEventProviderQuerySink )
		{
			if ( m_Provider_IWbemEventProviderQuerySink )
			{
				*iplpv = ( LPVOID ) ( IWbemEventProviderQuerySink * ) this ;
			}
		}
		else if ( iid == IID_IWbemEventProviderSecurity )
		{
			if ( m_Provider_IWbemEventProviderSecurity )
			{
				*iplpv = ( LPVOID ) ( IWbemEventProviderSecurity * ) this ;
			}
		}
		else if ( iid == IID_IWbemEventConsumerProvider )
		{
			if ( m_Provider_IWbemEventConsumerProvider )
			{
				*iplpv = ( LPVOID ) ( IWbemEventConsumerProvider * ) this ;
			}
		}
		else if ( iid == IID_IWbemEventConsumerProviderEx )
		{
			if ( m_Provider_IWbemEventConsumerProviderEx )
			{
				*iplpv = ( LPVOID ) ( IWbemEventConsumerProviderEx  * ) this ;
			}
		}
		else if ( iid == IID_IWbemUnboundObjectSink )
		{
			if ( m_Provider_IWbemUnboundObjectSink )
			{
				*iplpv = ( LPVOID ) ( IWbemUnboundObjectSink * ) this ;
			}
		}
		else if ( iid == IID_IWbemProviderInit )
		{
			*iplpv = ( LPVOID ) ( IWbemProviderInit * ) this ;
		}	
		else if ( iid == IID__IWmiProviderInitialize )
		{
			*iplpv = ( LPVOID ) ( _IWmiProviderInitialize * ) this ;		
		}	
		else if ( iid == IID_IWbemShutdown )
		{
			*iplpv = ( LPVOID ) ( IWbemShutdown * ) this ;
		}	
		else if ( iid == IID__IWmiProviderLoad )
		{
			*iplpv = ( LPVOID ) ( _IWmiProviderLoad * )this ;		
		}	
		else if ( iid == IID__IWmiProviderConfiguration )
		{
			*iplpv = ( LPVOID ) ( _IWmiProviderConfiguration * ) this ;
		}	
		else if ( iid == IID__IWmiProviderQuota )
		{
			*iplpv = ( LPVOID ) & ( this->m_Internal ) ;
		}	
		else if ( iid == IID__IWmiProviderStack )
		{
			*iplpv = ( LPVOID ) ( _IWmiProviderStack * ) this ;
		}	
		else if ( iid == IID__IWmiProviderCache )
		{
			*iplpv = ( LPVOID ) ( _IWmiProviderCache * ) this ;
		}	
		else if ( iid == IID__IWmiProviderAbnormalShutdown )
		{
			*iplpv = ( LPVOID ) ( _IWmiProviderAbnormalShutdown * ) this ;
		}	
		else if ( iid == IID_CWbemGlobal_IWmiObjectSinkController )
		{
			*iplpv = ( LPVOID ) ( CWbemGlobal_IWmiObjectSinkController * ) this ;
		}	
		else if ( iid == IID_CInterceptor_IWbemProvider )
		{
			*iplpv = ( LPVOID ) ( CInterceptor_IWbemProvider * ) this ;
		}	
	}

	if ( *iplpv )
	{
		( ( LPUNKNOWN ) *iplpv )->AddRef () ;

		return ResultFromScode ( S_OK ) ;
	}
	else
	{
		return ResultFromScode ( E_NOINTERFACE ) ;
	}
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_IWbemProvider :: Begin_Interface (

	IUnknown *a_ServerInterface ,
	REFIID a_InterfaceIdentifier ,
	DWORD a_ProxyIndex ,
	IUnknown *a_InternalServerInterface ,
	REFIID a_InternalInterfaceIdentifier ,
	DWORD a_InternalProxyIndex ,
	DWORD a_ProcessIdentifier ,
	HANDLE &a_IdentifyToken ,
	BOOL &a_Impersonating ,
	IUnknown *&a_OldContext ,
	IServerSecurity *&a_OldSecurity ,
	BOOL &a_IsProxy ,
	IUnknown *&a_Interface ,
	BOOL &a_Revert ,
	IUnknown *&a_Proxy ,
	IWbemContext *a_Context
)
{
	HRESULT t_Result = S_OK ;
	_DBG_ASSERT(SUCCEEDED(m_InitializeResult));

	a_IdentifyToken = NULL ;
	a_Revert = FALSE ;
	a_Proxy = NULL ;
	a_Impersonating = FALSE ;
	a_OldContext = NULL ;
	a_OldSecurity = NULL ;

	switch ( m_Registration->GetHosting () )
	{
		case e_Hosting_WmiCore:
		case e_Hosting_WmiCoreOrSelfHost:
		case e_Hosting_SelfHost:
		{
			a_Interface = a_ServerInterface ;
			a_IsProxy = FALSE ;
		}
		break ;

		default:
		{
			DWORD t_AuthenticationLevel = 0 ;

			t_Result = ProviderSubSystem_Common_Globals :: BeginImpersonation ( 
				
				a_OldContext , 
				a_OldSecurity , 
				a_Impersonating , 
				& t_AuthenticationLevel 
			) ;

			if ( SUCCEEDED ( t_Result ) ) 
			{
				if ( a_ProcessIdentifier )
				{
					DWORD t_ImpersonationLevel = RPC_C_IMP_LEVEL_IMPERSONATE ;

					IServerSecurity *t_ServerSecurity = NULL ;
					HRESULT t_TempResult = CoGetCallContext ( IID_IUnknown , ( void ** ) & t_ServerSecurity ) ;
					if ( SUCCEEDED ( t_TempResult ) )
					{
						t_Result = CoImpersonateClient () ;
						if ( SUCCEEDED ( t_Result ) )
						{
							t_ImpersonationLevel = ProviderSubSystem_Common_Globals :: GetCurrentImpersonationLevel () ;

							CoRevertToSelf () ;
						}

						t_ServerSecurity->Release () ;
					}

					if ( t_ImpersonationLevel == RPC_C_IMP_LEVEL_IMPERSONATE || t_ImpersonationLevel == RPC_C_IMP_LEVEL_DELEGATE )
					{
						t_Result = ProviderSubSystem_Common_Globals :: SetProxyState ( 
						
							m_ProxyContainer , 
							a_ProxyIndex , 
							a_InterfaceIdentifier , 
							a_ServerInterface , 
							a_Proxy , 
							a_Revert
						) ;
					}
					else
					{
						switch ( m_Registration->GetHosting () )
						{
							case e_Hosting_SharedLocalSystemHost:
							case e_Hosting_SharedLocalSystemHostOrSelfHost:
							{
								t_Result = ProviderSubSystem_Common_Globals :: SetProxyState_SvcHost ( 
								
									m_ProxyContainer , 
									a_InternalProxyIndex , 
									a_InterfaceIdentifier , 
									a_InternalServerInterface , 
									a_Proxy , 
									a_Revert , 
									a_ProcessIdentifier , 
									a_IdentifyToken ,
									ProviderSubSystem_Common_Globals :: s_Token_All_Access_System_ACE ,
									ProviderSubSystem_Common_Globals :: s_System_ACESize
								) ;
							}
							break ;

							case e_Hosting_SharedLocalServiceHost:
							{
								t_Result = ProviderSubSystem_Common_Globals :: SetProxyState_SvcHost ( 
								
									m_ProxyContainer , 
									a_InternalProxyIndex , 
									a_InterfaceIdentifier , 
									a_InternalServerInterface , 
									a_Proxy , 
									a_Revert , 
									a_ProcessIdentifier , 
									a_IdentifyToken ,
									ProviderSubSystem_Common_Globals :: s_Token_All_Access_LocalService_ACE ,
									ProviderSubSystem_Common_Globals :: s_LocalService_ACESize
								) ;
							}
							break ;

							case e_Hosting_SharedNetworkServiceHost:
							{
								t_Result = ProviderSubSystem_Common_Globals :: SetProxyState_SvcHost ( 
								
									m_ProxyContainer , 
									a_InternalProxyIndex , 
									a_InterfaceIdentifier , 
									a_InternalServerInterface , 
									a_Proxy , 
									a_Revert , 
									a_ProcessIdentifier , 
									a_IdentifyToken ,
									ProviderSubSystem_Common_Globals :: s_Token_All_Access_NetworkService_ACE ,
									ProviderSubSystem_Common_Globals :: s_NetworkService_ACESize
	 							) ;
							}
							break ;

							default:
							{
								t_Result = WBEM_E_UNEXPECTED ;
							}
							break ;
						}
					}
				}
				else
				{
					t_Result = ProviderSubSystem_Common_Globals :: SetProxyState ( 
					
						m_ProxyContainer , 
						a_ProxyIndex , 
						a_InterfaceIdentifier , 
						a_ServerInterface , 
						a_Proxy , 
						a_Revert
					) ;
				}

				if ( t_Result == WBEM_E_NOT_FOUND )
				{
					a_Interface = a_ServerInterface ;
					a_IsProxy = FALSE ;
					t_Result = S_OK ;
				}
				else
				{
					if ( SUCCEEDED ( t_Result ) )
					{
						a_IsProxy = TRUE ;

						a_Interface = ( IUnknown * ) a_Proxy ;

						// Set cloaking on the proxy
						// =========================

						DWORD t_ImpersonationLevel = ProviderSubSystem_Common_Globals :: GetCurrentImpersonationLevel () ;

						t_Result = ProviderSubSystem_Common_Globals :: SetCloaking (

							a_Interface ,
							RPC_C_AUTHN_LEVEL_DEFAULT , 
							t_ImpersonationLevel
						) ;

						if ( SUCCEEDED ( t_Result ) )
						{
							if ( a_Context )
							{
								VARIANT t_Variant ;
								VariantInit ( & t_Variant ) ;
								t_Variant.lVal = t_AuthenticationLevel ;
								t_Variant.vt = VT_I4 ;

								
								t_Result = a_Context->SetValue ( L"__WBEM_CLIENT_AUTHENTICATION_LEVEL" , 0, & t_Variant ) ;
							}
						}

						if ( FAILED ( t_Result ) )
						{
							if ( a_IdentifyToken )
							{
								HRESULT t_TempResult = ProviderSubSystem_Common_Globals :: RevertProxyState_SvcHost ( 

									m_ProxyContainer , 
									a_InternalProxyIndex , 
									a_Proxy , 
									a_Revert ,
									a_ProcessIdentifier , 
									a_IdentifyToken 
								) ;
							}
							else
							{
								HRESULT t_TempResult = ProviderSubSystem_Common_Globals :: RevertProxyState ( 

									m_ProxyContainer , 
									a_ProxyIndex , 
									a_Proxy , 
									a_Revert
								) ;
							}
						}
					}
				}

				if ( FAILED ( t_Result ) && t_Result != WBEM_E_NOT_FOUND )
				{
					ProviderSubSystem_Common_Globals :: EndImpersonation ( a_OldContext , a_OldSecurity , a_Impersonating ) ;
				}
			}
		}
		break ;
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_IWbemProvider :: End_Interface (

	IUnknown *a_ServerInterface ,
	REFIID a_InterfaceIdentifier ,
	DWORD a_ProxyIndex ,
	IUnknown *a_InternalServerInterface ,
	REFIID a_InternalInterfaceIdentifier ,
	DWORD a_InternalProxyIndex ,
	DWORD a_ProcessIdentifier ,
	HANDLE a_IdentifyToken ,
	BOOL a_Impersonating ,
	IUnknown *a_OldContext ,
	IServerSecurity *a_OldSecurity ,
	BOOL a_IsProxy ,
	IUnknown *a_Interface ,
	BOOL a_Revert ,
	IUnknown *a_Proxy
)
{
	CoRevertToSelf () ;

	if ( a_Proxy )
	{
		if ( a_IdentifyToken )
		{
			HRESULT t_TempResult = ProviderSubSystem_Common_Globals :: RevertProxyState_SvcHost ( 

				m_ProxyContainer , 
				a_InternalProxyIndex , 
				a_Proxy , 
				a_Revert ,
				a_ProcessIdentifier ,
				a_IdentifyToken 
			) ;
		}
		else
		{
			HRESULT t_TempResult = ProviderSubSystem_Common_Globals :: RevertProxyState ( 

				m_ProxyContainer , 
				a_ProxyIndex , 
				a_Proxy , 
				a_Revert
			) ;
		}
	}

	switch ( m_Registration->GetHosting () )
	{
		case e_Hosting_WmiCore:
		case e_Hosting_WmiCoreOrSelfHost:
		case e_Hosting_SelfHost:
		{
		}
		break ;

		default:
		{
			ProviderSubSystem_Common_Globals :: EndImpersonation ( a_OldContext , a_OldSecurity , a_Impersonating ) ;
		}
		break ;
	}

	return S_OK ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_IWbemProvider :: Begin_Interface_Context (

	IUnknown *a_ServerInterface ,
	REFIID a_InterfaceIdentifier ,
	DWORD a_ProxyIndex ,
	IUnknown *a_InternalServerInterface ,
	REFIID a_InternalInterfaceIdentifier ,
	DWORD a_InternalProxyIndex ,
	DWORD a_ProcessIdentifier ,
	HANDLE &a_IdentifyToken ,
	BOOL &a_Impersonating ,
	IUnknown *&a_OldContext ,
	IServerSecurity *&a_OldSecurity ,
	BOOL &a_IsProxy ,
	IUnknown *&a_Interface ,
	BOOL &a_Revert ,
	IUnknown *&a_Proxy ,
	IWbemContext *a_Context
)
{
	HRESULT t_Result = S_OK ;

	a_IdentifyToken = NULL ;
	a_Revert = FALSE ;
	a_Proxy = NULL ;
	a_Impersonating = FALSE ;
	a_OldContext = NULL ;
	a_OldSecurity = NULL ;

	switch ( m_Registration->GetHosting () )
	{
		case e_Hosting_WmiCore:
		case e_Hosting_WmiCoreOrSelfHost:
		case e_Hosting_SelfHost:
		{
			a_Interface = a_ServerInterface ;
			a_IsProxy = FALSE ;
		}
		break ;

		default:
		{
			DWORD t_AuthenticationLevel = 0 ;

			IServerSecurity *t_Security = NULL ;
			t_Result = CoGetCallContext ( IID_IServerSecurity , ( void ** ) & t_Security ) ;
			if ( SUCCEEDED ( t_Result ) ) 
			{
				t_Result = ProviderSubSystem_Common_Globals :: BeginImpersonation ( 
					
					a_OldContext , 
					a_OldSecurity , 
					a_Impersonating , 
					& t_AuthenticationLevel 
				) ;

				if ( SUCCEEDED ( t_Result ) ) 
				{
					if ( a_ProcessIdentifier )
					{
						DWORD t_ImpersonationLevel = RPC_C_IMP_LEVEL_IMPERSONATE ;

						IServerSecurity *t_ServerSecurity = NULL ;
						HRESULT t_TempResult = CoGetCallContext ( IID_IUnknown , ( void ** ) & t_ServerSecurity ) ;
						if ( SUCCEEDED ( t_TempResult ) )
						{
							t_Result = CoImpersonateClient () ;
							if ( SUCCEEDED ( t_Result ) )
							{
								t_ImpersonationLevel = ProviderSubSystem_Common_Globals :: GetCurrentImpersonationLevel () ;

								CoRevertToSelf () ;
							}

							t_ServerSecurity->Release () ;
						}

						if ( t_ImpersonationLevel == RPC_C_IMP_LEVEL_IMPERSONATE || t_ImpersonationLevel == RPC_C_IMP_LEVEL_DELEGATE )
						{
							t_Result = ProviderSubSystem_Common_Globals :: SetProxyState ( 
							
								m_ProxyContainer , 
								a_ProxyIndex , 
								a_InterfaceIdentifier , 
								a_ServerInterface , 
								a_Proxy , 
								a_Revert
							) ;
						}
						else
						{
							switch ( m_Registration->GetHosting () )
							{
								case e_Hosting_SharedLocalSystemHost:
								case e_Hosting_SharedLocalSystemHostOrSelfHost:
								{
									t_Result = ProviderSubSystem_Common_Globals :: SetProxyState_SvcHost ( 
									
										m_ProxyContainer , 
										a_InternalProxyIndex , 
										a_InterfaceIdentifier , 
										a_InternalServerInterface , 
										a_Proxy , 
										a_Revert , 
										a_ProcessIdentifier , 
										a_IdentifyToken ,
										ProviderSubSystem_Common_Globals :: s_Token_All_Access_System_ACE ,
										ProviderSubSystem_Common_Globals :: s_System_ACESize
									) ;
								}
								break ;

								case e_Hosting_SharedLocalServiceHost:
								{
									t_Result = ProviderSubSystem_Common_Globals :: SetProxyState_SvcHost ( 
									
										m_ProxyContainer , 
										a_InternalProxyIndex , 
										a_InterfaceIdentifier , 
										a_InternalServerInterface , 
										a_Proxy , 
										a_Revert , 
										a_ProcessIdentifier , 
										a_IdentifyToken ,
										ProviderSubSystem_Common_Globals :: s_Token_All_Access_LocalService_ACE ,
										ProviderSubSystem_Common_Globals :: s_LocalService_ACESize
									) ;
								}
								break ;

								case e_Hosting_SharedNetworkServiceHost:
								{
									t_Result = ProviderSubSystem_Common_Globals :: SetProxyState_SvcHost ( 
									
										m_ProxyContainer , 
										a_InternalProxyIndex , 
										a_InterfaceIdentifier , 
										a_InternalServerInterface , 
										a_Proxy , 
										a_Revert , 
										a_ProcessIdentifier , 
										a_IdentifyToken ,
										ProviderSubSystem_Common_Globals :: s_Token_All_Access_NetworkService_ACE ,
										ProviderSubSystem_Common_Globals :: s_NetworkService_ACESize
	 								) ;
								}
								break ;

								default:
								{
									t_Result = WBEM_E_UNEXPECTED ;
								}
								break ;
							}
						}
					}
					else
					{
						t_Result = ProviderSubSystem_Common_Globals :: SetProxyState ( 
						
							m_ProxyContainer , 
							a_ProxyIndex , 
							a_InterfaceIdentifier , 
							a_ServerInterface , 
							a_Proxy , 
							a_Revert
						) ;
					}

					if ( t_Result == WBEM_E_NOT_FOUND )
					{
						a_Interface = a_ServerInterface ;
						a_IsProxy = FALSE ;
						t_Result = S_OK ;
					}
					else
					{
						if ( SUCCEEDED ( t_Result ) )
						{
							a_IsProxy = TRUE ;

							a_Interface = ( IUnknown * ) a_Proxy ;

							// Set cloaking on the proxy
							// =========================

							DWORD t_ImpersonationLevel = ProviderSubSystem_Common_Globals :: GetCurrentImpersonationLevel () ;

							t_Result = ProviderSubSystem_Common_Globals :: SetCloaking (

								a_Interface ,
								RPC_C_AUTHN_LEVEL_DEFAULT , 
								t_ImpersonationLevel
							) ;

							if ( SUCCEEDED ( t_Result ) )
							{
								if ( a_Context )
								{
									VARIANT t_Variant ;
									VariantInit ( & t_Variant ) ;
									t_Variant.lVal = t_AuthenticationLevel ;
									t_Variant.vt = VT_I4 ;

									
									t_Result = a_Context->SetValue ( L"__WBEM_CLIENT_AUTHENTICATION_LEVEL" , 0, & t_Variant ) ;
								}
							}

							if ( FAILED ( t_Result ) )
							{
								if ( a_IdentifyToken )
								{
									HRESULT t_TempResult = ProviderSubSystem_Common_Globals :: RevertProxyState_SvcHost ( 

										m_ProxyContainer , 
										a_InternalProxyIndex , 
										a_Proxy , 
										a_Revert ,
										a_ProcessIdentifier , 
										a_IdentifyToken 
									) ;
								}
								else
								{
									HRESULT t_TempResult = ProviderSubSystem_Common_Globals :: RevertProxyState ( 

										m_ProxyContainer , 
										a_ProxyIndex , 
										a_Proxy , 
										a_Revert
									) ;
								}
							}
						}
					}

					if ( FAILED ( t_Result ) && t_Result != WBEM_E_NOT_FOUND )
					{
						ProviderSubSystem_Common_Globals :: EndImpersonation ( a_OldContext , a_OldSecurity , a_Impersonating ) ;
					}
				}

				t_Security->Release () ;
			}
			else
			{
				t_Result = ProviderSubSystem_Common_Globals :: SetProxyState_NoImpersonation ( 
						
					m_ProxyContainer , 
					a_ProxyIndex , 
					a_InterfaceIdentifier , 
					a_ServerInterface , 
					a_Proxy , 
					a_Revert
				) ;
				
				if ( t_Result == WBEM_E_NOT_FOUND )
				{
					a_Interface = a_ServerInterface ;
					a_IsProxy = FALSE ;
					t_Result = S_OK ;
				}
				else
				{
					a_Interface = a_Proxy ;
					a_IsProxy = TRUE ;
					t_Result = S_OK ;
				}				
			}
		}
		break ;
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_IWbemProvider :: End_Interface_Context (

	IUnknown *a_ServerInterface ,
	REFIID a_InterfaceIdentifier ,
	DWORD a_ProxyIndex ,
	IUnknown *a_InternalServerInterface ,
	REFIID a_InternalInterfaceIdentifier ,
	DWORD a_InternalProxyIndex ,
	DWORD a_ProcessIdentifier ,
	HANDLE a_IdentifyToken ,
	BOOL a_Impersonating ,
	IUnknown *a_OldContext ,
	IServerSecurity *a_OldSecurity ,
	BOOL a_IsProxy ,
	IUnknown *a_Interface ,
	BOOL a_Revert ,
	IUnknown *a_Proxy
)
{
	CoRevertToSelf () ;

	if ( a_Proxy )
	{
		if ( a_IdentifyToken )
		{
			HRESULT t_TempResult = ProviderSubSystem_Common_Globals :: RevertProxyState_SvcHost ( 

				m_ProxyContainer , 
				a_InternalProxyIndex , 
				a_Proxy , 
				a_Revert ,
				a_ProcessIdentifier ,
				a_IdentifyToken 
			) ;
		}
		else
		{
			HRESULT t_TempResult = ProviderSubSystem_Common_Globals :: RevertProxyState ( 

				m_ProxyContainer , 
				a_ProxyIndex , 
				a_Proxy , 
				a_Revert
			) ;
		}
	}

	switch ( m_Registration->GetHosting () )
	{
		case e_Hosting_WmiCore:
		case e_Hosting_WmiCoreOrSelfHost:
		case e_Hosting_SelfHost:
		{
		}
		break ;

		default:
		{
			ProviderSubSystem_Common_Globals :: EndImpersonation ( a_OldContext , a_OldSecurity , a_Impersonating ) ;
		}
		break ;
	}

	return S_OK ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_IWbemProvider::OpenNamespace ( 

	const BSTR a_ObjectPath ,
	long a_Flags ,
	IWbemContext *a_Context ,
	IWbemServices **a_NamespaceService ,
	IWbemCallResult **a_CallResult
)
{
	return WBEM_E_NOT_AVAILABLE ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_IWbemProvider :: CancelAsyncCall ( 
		
	IWbemObjectSink *a_Sink
)
{
	HRESULT t_Result = WBEM_E_PROVIDER_NOT_CAPABLE ;

	if ( GetResumed () )
	{
		if ( m_Provider_IWbemServices )
		{
			CWbemGlobal_IWmiObjectSinkController_Container_Iterator t_Iterator ;

			Lock () ;

			WmiStatusCode t_StatusCode = Find ( 

				a_Sink ,
				t_Iterator
			) ;

			if ( t_StatusCode == e_StatusCode_Success ) 
			{
				ObjectSinkContainerElement *t_Element = t_Iterator.GetElement () ;

				UnLock () ;

				IWbemObjectSink *t_ObjectSink = NULL ;
				t_Result = t_Element->QueryInterface ( IID_IWbemObjectSink , ( void ** ) & t_ObjectSink ) ;
				if ( SUCCEEDED ( t_Result ) )
				{ 
					IUnknown *t_ServerInterface = m_Provider_IWbemServices ;
					REFIID t_InterfaceIdentifier = IID_IWbemServices ;
					DWORD t_ProxyIndex = ProxyIndex_IWbemServices ;
					IUnknown *t_InternalServerInterface = m_Provider_Internal_IWbemServices ;
					REFIID t_InternalInterfaceIdentifier = IID_Internal_IWbemServices ;
					DWORD t_InternalProxyIndex = ProxyIndex_Internal_IWbemServices ;
					BOOL t_Impersonating ;
					IUnknown *t_OldContext ;
					IServerSecurity *t_OldSecurity ;
					BOOL t_IsProxy ;
					IUnknown *t_Interface ;
					BOOL t_Revert ;
					IUnknown *t_Proxy ;
					HANDLE t_IdentifyToken = NULL ;

					t_Result = Begin_Interface (

						t_ServerInterface ,
						t_InterfaceIdentifier ,
						t_ProxyIndex ,
						t_InternalServerInterface ,
						t_InternalInterfaceIdentifier ,
						t_InternalProxyIndex ,
						m_ProcessIdentifier ,
						t_IdentifyToken ,
						t_Impersonating ,
						t_OldContext ,
						t_OldSecurity ,
						t_IsProxy ,
						t_Interface ,
						t_Revert ,
						t_Proxy
					) ;

					if ( SUCCEEDED ( t_Result ) )
					{
						if ( t_IdentifyToken )
						{
							WmiInternalContext t_InternalContext ;
							t_InternalContext.m_IdentifyHandle = ( unsigned __int64 ) t_IdentifyToken ;
							t_InternalContext.m_ProcessIdentifier = GetCurrentProcessId () ;

							t_Result = ( ( Internal_IWbemServices * ) t_Interface )->Internal_CancelAsyncCall (

								t_InternalContext ,
								t_ObjectSink
							) ;
						}
						else
						{
							t_Result = ( ( IWbemServices * ) t_Interface )->CancelAsyncCall (

								t_ObjectSink
							) ;
						}

						End_Interface (

							t_ServerInterface ,
							t_InterfaceIdentifier ,
							t_ProxyIndex ,
							t_InternalServerInterface ,
							t_InternalInterfaceIdentifier ,
							t_InternalProxyIndex ,
							m_ProcessIdentifier ,
							t_IdentifyToken ,
							t_Impersonating ,
							t_OldContext ,
							t_OldSecurity ,
							t_IsProxy ,
							t_Interface ,
							t_Revert ,
							t_Proxy
						) ;
					}

					t_ObjectSink->Release () ;
				}

				IWbemShutdown *t_Shutdown = NULL ;
				HRESULT t_TempResult = t_Element->QueryInterface ( IID_IWbemShutdown , ( void ** ) & t_Shutdown ) ;
				if ( SUCCEEDED ( t_TempResult ) )
				{
					t_TempResult = t_Shutdown->Shutdown ( 

						0 , 
						0 , 
						NULL 
					) ;

					t_Shutdown->Release () ;
				}

				t_Element->Release () ;
			}
			else
			{
				UnLock () ;

				t_Result = WBEM_E_NOT_FOUND ;
			}
		}
	}
	else
	{
		t_Result = WBEM_E_PROVIDER_SUSPENDED ;
	}

	if ( FAILED ( t_Result ) )
	{
		if ( ( HRESULT_ERROR_FUNC(t_Result) == HRESULT_ERROR_SERVER_UNAVAILABLE ) || ( HRESULT_ERROR_FUNC(t_Result) == HRESULT_ERROR_CALL_FAILED_DNE ) || ( t_Result == RPC_E_DISCONNECTED ))
		{
			AbnormalShutdown () ;
		}
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_IWbemProvider :: QueryObjectSink ( 

	long a_Flags ,
	IWbemObjectSink **a_Sink
) 
{
	return WBEM_E_NOT_AVAILABLE ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_IWbemProvider :: GetObject ( 
		
	const BSTR a_ObjectPath ,
    long a_Flags ,
    IWbemContext *a_Context ,
    IWbemClassObject **a_Object ,
    IWbemCallResult **a_CallResult
)
{
	return WBEM_E_NOT_AVAILABLE ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_IWbemProvider :: GetObjectAsync ( 
		
	const BSTR a_ObjectPath ,
	long a_Flags , 
	IWbemContext *a_Context ,
	IWbemObjectSink *a_Sink
) 
{
	if ( m_Initialized == 0 )
	{
		a_Sink->SetStatus ( 0 , WBEM_E_NOT_FOUND , NULL , NULL ) ;

		return WBEM_E_NOT_FOUND ;
	}

	_DBG_ASSERT(SUCCEEDED(m_InitializeResult));
	BOOL t_DependantCall = FALSE ;

	HRESULT t_Result = WBEM_E_PROVIDER_NOT_CAPABLE ;

	if ( GetResumed () )
	{
		if ( m_Provider_IWbemServices )
		{
			CInterceptor_IWbemObjectSink *t_Sink = new CInterceptor_IWbemObjectSink (

				a_Sink , 
				( IWbemServices * ) this , 
				( CWbemGlobal_IWmiObjectSinkController * ) this
			) ;

			if ( t_Sink )
			{
				t_Sink->AddRef () ;

				t_Result = t_Sink->Initialize ( m_Registration->GetComRegistration ().GetSecurityDescriptor () ) ;
				if ( SUCCEEDED ( t_Result ) ) 
				{
					CWbemGlobal_IWmiObjectSinkController_Container_Iterator t_Iterator ;

					Lock () ;

					WmiStatusCode t_StatusCode = Insert ( 

						*t_Sink ,
						t_Iterator
					) ;

					if ( t_StatusCode == e_StatusCode_Success ) 
					{
						UnLock () ;

						IUnknown *t_ServerInterface = m_Provider_IWbemServices ;
						REFIID t_InterfaceIdentifier = IID_IWbemServices ;
						DWORD t_ProxyIndex = ProxyIndex_IWbemServices ;
						IUnknown *t_InternalServerInterface = m_Provider_Internal_IWbemServices ;
						REFIID t_InternalInterfaceIdentifier = IID_Internal_IWbemServices ;
						DWORD t_InternalProxyIndex = ProxyIndex_Internal_IWbemServices ;
						BOOL t_Impersonating ;
						IUnknown *t_OldContext ;
						IServerSecurity *t_OldSecurity ;
						BOOL t_IsProxy ;
						IUnknown *t_Interface ;
						BOOL t_Revert ;
						IUnknown *t_Proxy ;
						HANDLE t_IdentifyToken = NULL ;

						t_Result = Begin_Interface (

							t_ServerInterface ,
							t_InterfaceIdentifier ,
							t_ProxyIndex ,
							t_InternalServerInterface ,
							t_InternalInterfaceIdentifier ,
							t_InternalProxyIndex ,
							m_ProcessIdentifier ,
							t_IdentifyToken ,
							t_Impersonating ,
							t_OldContext ,
							t_OldSecurity ,
							t_IsProxy ,
							t_Interface ,
							t_Revert ,
							t_Proxy
						) ;

						if ( SUCCEEDED ( t_Result ) )
						{
							if ( t_IdentifyToken )
							{
								BSTR t_ObjectPath = SysAllocString ( a_ObjectPath ) ;
								if ( t_ObjectPath )
								{
									WmiInternalContext t_InternalContext ;
									t_InternalContext.m_IdentifyHandle = ( unsigned __int64 ) t_IdentifyToken ;
									t_InternalContext.m_ProcessIdentifier = GetCurrentProcessId () ;

									t_Result = ( ( Internal_IWbemServices * ) t_Interface )->Internal_GetObjectAsync (

										t_InternalContext ,
										t_ObjectPath, 
										a_Flags, 
										a_Context ,
										t_Sink
									) ;

									SysFreeString ( t_ObjectPath ) ;
								}
								else
								{
									t_Result = WBEM_E_OUT_OF_MEMORY ;
								}
							}
							else
							{
								t_Result = ( ( IWbemServices * ) t_Interface )->GetObjectAsync (

									a_ObjectPath, 
									a_Flags, 
									a_Context ,
									t_Sink
								) ;
							}

							End_Interface (

								t_ServerInterface ,
								t_InterfaceIdentifier ,
								t_ProxyIndex ,
								t_InternalServerInterface ,
								t_InternalInterfaceIdentifier ,
								t_InternalProxyIndex ,
								m_ProcessIdentifier ,
								t_IdentifyToken ,
								t_Impersonating ,
								t_OldContext ,
								t_OldSecurity ,
								t_IsProxy ,
								t_Interface ,
								t_Revert ,
								t_Proxy
							) ;
						}
					}
					else
					{
						UnLock () ;

						t_Result = WBEM_E_OUT_OF_MEMORY ;
					}
				}

				if ( FAILED ( t_Result ) )
				{
					t_Sink->SetStatus ( 0 , t_Result , NULL , NULL ) ;
				}

				t_Sink->Release () ;
			}
			else
			{
				t_Result = WBEM_E_OUT_OF_MEMORY ;
				a_Sink->SetStatus ( 0 , t_Result , NULL , NULL ) ;
			}
		}
		else
		{
			a_Sink->SetStatus ( 0 , t_Result , NULL , NULL ) ;
		}
	}
	else
	{
		t_Result = WBEM_E_PROVIDER_SUSPENDED ;
		a_Sink->SetStatus ( 0 , t_Result , NULL , NULL ) ;
	}

	if ( FAILED ( t_Result ) )
	{
		if ( ( HRESULT_ERROR_FUNC(t_Result) == HRESULT_ERROR_SERVER_UNAVAILABLE ) || ( HRESULT_ERROR_FUNC(t_Result) == HRESULT_ERROR_CALL_FAILED_DNE ) || ( t_Result == RPC_E_DISCONNECTED ))
		{
			AbnormalShutdown () ;
		}
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_IWbemProvider :: PutClass ( 
		
	IWbemClassObject *a_Object ,
	long a_Flags , 
	IWbemContext *a_Context ,
	IWbemCallResult **a_CallResult
) 
{
	return WBEM_E_NOT_AVAILABLE ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_IWbemProvider :: PutClassAsync ( 
		
	IWbemClassObject *a_Object , 
	long a_Flags ,
	IWbemContext FAR *a_Context ,
	IWbemObjectSink *a_Sink
) 
{
	if ( m_Initialized == 0 )
	{
		if ( WBEM_FLAG_ADVISORY & a_Flags )
		{
			a_Sink->SetStatus ( 0 , S_OK , NULL , NULL ) ;

			return S_OK ;
		}
		else
		{
			a_Sink->SetStatus ( 0 , WBEM_E_NOT_FOUND , NULL , NULL ) ;

			return WBEM_E_NOT_FOUND ;
		}
	}

	_DBG_ASSERT(SUCCEEDED(m_InitializeResult));
		
	HRESULT t_Result = WBEM_E_PROVIDER_NOT_CAPABLE ;

	if ( GetResumed () )
	{
		if ( m_Provider_IWbemServices )
		{
			CInterceptor_IWbemObjectSink *t_Sink = new CInterceptor_IWbemObjectSink (

				a_Sink , 
				( IWbemServices * ) this , 
				( CWbemGlobal_IWmiObjectSinkController * ) this
			) ;

			if ( t_Sink )
			{
				t_Sink->AddRef () ;

				t_Result = t_Sink->Initialize ( m_Registration->GetComRegistration ().GetSecurityDescriptor () ) ;
				if ( SUCCEEDED ( t_Result ) ) 
				{
					CWbemGlobal_IWmiObjectSinkController_Container_Iterator t_Iterator ;

					Lock () ;

					WmiStatusCode t_StatusCode = Insert ( 

						*t_Sink ,
						t_Iterator
					) ;

					if ( t_StatusCode == e_StatusCode_Success ) 
					{
						UnLock () ;

						IUnknown *t_ServerInterface = m_Provider_IWbemServices ;
						REFIID t_InterfaceIdentifier = IID_IWbemServices ;
						DWORD t_ProxyIndex = ProxyIndex_IWbemServices ;
						IUnknown *t_InternalServerInterface = m_Provider_Internal_IWbemServices ;
						REFIID t_InternalInterfaceIdentifier = IID_Internal_IWbemServices ;
						DWORD t_InternalProxyIndex = ProxyIndex_Internal_IWbemServices ;
						BOOL t_Impersonating ;
						IUnknown *t_OldContext ;
						IServerSecurity *t_OldSecurity ;
						BOOL t_IsProxy ;
						IUnknown *t_Interface ;
						BOOL t_Revert ;
						IUnknown *t_Proxy ;
						HANDLE t_IdentifyToken = NULL ;

						t_Result = Begin_Interface (

							t_ServerInterface ,
							t_InterfaceIdentifier ,
							t_ProxyIndex ,
							t_InternalServerInterface ,
							t_InternalInterfaceIdentifier ,
							t_InternalProxyIndex ,
							m_ProcessIdentifier ,
							t_IdentifyToken ,
							t_Impersonating ,
							t_OldContext ,
							t_OldSecurity ,
							t_IsProxy ,
							t_Interface ,
							t_Revert ,
							t_Proxy
						) ;

						if ( SUCCEEDED ( t_Result ) )
						{
							if ( t_IdentifyToken )
							{
								WmiInternalContext t_InternalContext ;
								t_InternalContext.m_IdentifyHandle = ( unsigned __int64 ) t_IdentifyToken ;
								t_InternalContext.m_ProcessIdentifier = GetCurrentProcessId () ;

								t_Result = ( ( Internal_IWbemServices * ) t_Interface )->Internal_PutClassAsync (

									t_InternalContext ,
									a_Object , 
									a_Flags, 
									a_Context ,
									t_Sink
								) ;
							}
							else
							{
								t_Result = ( ( IWbemServices * ) t_Interface )->PutClassAsync (

									a_Object , 
									a_Flags, 
									a_Context ,
									t_Sink
								) ;
							}

							End_Interface (

								t_ServerInterface ,
								t_InterfaceIdentifier ,
								t_ProxyIndex ,
								t_InternalServerInterface ,
								t_InternalInterfaceIdentifier ,
								t_InternalProxyIndex ,
								m_ProcessIdentifier ,
								t_IdentifyToken ,
								t_Impersonating ,
								t_OldContext ,
								t_OldSecurity ,
								t_IsProxy ,
								t_Interface ,
								t_Revert ,
								t_Proxy
							) ;
						}
					}
					else
					{
						UnLock () ;

						t_Result = WBEM_E_OUT_OF_MEMORY ;
					}
				}

				if ( FAILED ( t_Result ) )
				{
					t_Sink->SetStatus ( 0 , t_Result , NULL , NULL ) ;
				}

				t_Sink->Release () ;
			}
			else
			{
				t_Result = WBEM_E_OUT_OF_MEMORY ;
				a_Sink->SetStatus ( 0 , t_Result , NULL , NULL ) ;
			}
		}
		else
		{
			a_Sink->SetStatus ( 0 , t_Result , NULL , NULL ) ;
		}
	}
	else
	{
		t_Result = WBEM_E_PROVIDER_SUSPENDED ;
		a_Sink->SetStatus ( 0 , t_Result , NULL , NULL ) ;
	}

	if ( FAILED ( t_Result ) )
	{
		if ( ( HRESULT_ERROR_FUNC(t_Result) == HRESULT_ERROR_SERVER_UNAVAILABLE ) || ( HRESULT_ERROR_FUNC(t_Result) == HRESULT_ERROR_CALL_FAILED_DNE ) || ( t_Result == RPC_E_DISCONNECTED ))
		{
			AbnormalShutdown () ;
		}
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_IWbemProvider :: DeleteClass ( 
		
	const BSTR a_Class , 
	long a_Flags , 
	IWbemContext *a_Context ,
	IWbemCallResult **a_CallResult
) 
{
 	 return WBEM_E_NOT_AVAILABLE ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_IWbemProvider :: DeleteClassAsync ( 
		
	const BSTR a_Class ,
	long a_Flags,
	IWbemContext *a_Context ,
	IWbemObjectSink *a_Sink
) 
{
	if ( m_Initialized == 0 )
	{
		if ( WBEM_FLAG_ADVISORY & a_Flags )
		{
			a_Sink->SetStatus ( 0 , S_OK , NULL , NULL ) ;

			return S_OK ;
		}
		else
		{
			a_Sink->SetStatus ( 0 , WBEM_E_NOT_FOUND , NULL , NULL ) ;

			return WBEM_E_NOT_FOUND ;
		}
	}

	_DBG_ASSERT(SUCCEEDED(m_InitializeResult));
	
	HRESULT t_Result = WBEM_E_PROVIDER_NOT_CAPABLE ;

	if ( GetResumed () )
	{
		if ( m_Provider_IWbemServices )
		{
			CInterceptor_IWbemObjectSink *t_Sink = new CInterceptor_IWbemObjectSink (

				a_Sink , 
				( IWbemServices * ) this , 
				( CWbemGlobal_IWmiObjectSinkController * ) this
			) ;

			if ( t_Sink )
			{
				t_Sink->AddRef () ;

				t_Result = t_Sink->Initialize ( m_Registration->GetComRegistration ().GetSecurityDescriptor () ) ;
				if ( SUCCEEDED ( t_Result ) ) 
				{
					CWbemGlobal_IWmiObjectSinkController_Container_Iterator t_Iterator ;

					Lock () ;

					WmiStatusCode t_StatusCode = Insert ( 

						*t_Sink ,
						t_Iterator
					) ;

					if ( t_StatusCode == e_StatusCode_Success ) 
					{
						UnLock () ;

						IUnknown *t_ServerInterface = m_Provider_IWbemServices ;
						REFIID t_InterfaceIdentifier = IID_IWbemServices ;
						DWORD t_ProxyIndex = ProxyIndex_IWbemServices ;
						IUnknown *t_InternalServerInterface = m_Provider_Internal_IWbemServices ;
						REFIID t_InternalInterfaceIdentifier = IID_Internal_IWbemServices ;
						DWORD t_InternalProxyIndex = ProxyIndex_Internal_IWbemServices ;
						BOOL t_Impersonating ;
						IUnknown *t_OldContext ;
						IServerSecurity *t_OldSecurity ;
						BOOL t_IsProxy ;
						IUnknown *t_Interface ;
						BOOL t_Revert ;
						IUnknown *t_Proxy ;
						HANDLE t_IdentifyToken = NULL ;

						t_Result = Begin_Interface (

							t_ServerInterface ,
							t_InterfaceIdentifier ,
							t_ProxyIndex ,
							t_InternalServerInterface ,
							t_InternalInterfaceIdentifier ,
							t_InternalProxyIndex ,
							m_ProcessIdentifier ,
							t_IdentifyToken ,
							t_Impersonating ,
							t_OldContext ,
							t_OldSecurity ,
							t_IsProxy ,
							t_Interface ,
							t_Revert ,
							t_Proxy
						) ;

						if ( SUCCEEDED ( t_Result ) )
						{
							if ( t_IdentifyToken )
							{
								BSTR t_Class = SysAllocString ( a_Class ) ;
								if ( t_Class ) 
								{
									WmiInternalContext t_InternalContext ;
									t_InternalContext.m_IdentifyHandle = ( unsigned __int64 ) t_IdentifyToken ;
									t_InternalContext.m_ProcessIdentifier = GetCurrentProcessId () ;

									t_Result = ( ( Internal_IWbemServices * ) t_Interface )->Internal_DeleteClassAsync (

										t_InternalContext ,
										t_Class , 
										a_Flags, 
										a_Context ,
										t_Sink
									) ;

									SysFreeString ( t_Class ) ;
								}
								else
								{
									t_Result = WBEM_E_OUT_OF_MEMORY ;
								}
							}
							else
							{
								t_Result = ( ( IWbemServices * ) t_Interface )->DeleteClassAsync (

									a_Class , 
									a_Flags, 
									a_Context ,
									t_Sink
								) ;
							}

							End_Interface (

								t_ServerInterface ,
								t_InterfaceIdentifier ,
								t_ProxyIndex ,
								t_InternalServerInterface ,
								t_InternalInterfaceIdentifier ,
								t_InternalProxyIndex ,
								m_ProcessIdentifier ,
								t_IdentifyToken ,
								t_Impersonating ,
								t_OldContext ,
								t_OldSecurity ,
								t_IsProxy ,
								t_Interface ,
								t_Revert ,
								t_Proxy
							) ;
						}
					}
					else
					{
						UnLock () ;

						t_Result = WBEM_E_OUT_OF_MEMORY ;
					}
				}

				if ( FAILED ( t_Result ) )
				{
					t_Sink->SetStatus ( 0 , t_Result , NULL , NULL ) ;
				}

				t_Sink->Release () ;
			}
			else
			{
				t_Result = WBEM_E_OUT_OF_MEMORY ;
				a_Sink->SetStatus ( 0 , t_Result , NULL , NULL ) ;
			}
		}
		else
		{
			a_Sink->SetStatus ( 0 , t_Result , NULL , NULL ) ;
		}
	}
	else
	{
		t_Result = WBEM_E_PROVIDER_SUSPENDED ;
		a_Sink->SetStatus ( 0 , t_Result , NULL , NULL ) ;
	}

	if ( FAILED ( t_Result ) )
	{
		if ( ( HRESULT_ERROR_FUNC(t_Result) == HRESULT_ERROR_SERVER_UNAVAILABLE ) || ( HRESULT_ERROR_FUNC(t_Result) == HRESULT_ERROR_CALL_FAILED_DNE ) || ( t_Result == RPC_E_DISCONNECTED ))
		{
			AbnormalShutdown () ;
		}
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_IWbemProvider :: CreateClassEnum ( 

	const BSTR a_Superclass ,
	long a_Flags, 
	IWbemContext *a_Context ,
	IEnumWbemClassObject **a_Enum
) 
{
	return WBEM_E_NOT_AVAILABLE ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

SCODE CInterceptor_IWbemProvider :: CreateClassEnumAsync (

	const BSTR a_Superclass ,
	long a_Flags ,
	IWbemContext *a_Context ,
	IWbemObjectSink *a_Sink
) 
{
	if ( m_Initialized == 0 )
	{
		a_Sink->SetStatus ( 0 , S_OK , NULL , NULL ) ;

		return S_OK ;
	}
	_DBG_ASSERT(SUCCEEDED(m_InitializeResult));
	HRESULT t_Result = WBEM_E_PROVIDER_NOT_CAPABLE ;

	if ( GetResumed () )
	{
		if ( m_Provider_IWbemServices )
		{
			CInterceptor_IWbemObjectSink *t_Sink = new CInterceptor_IWbemObjectSink (

				a_Sink , 
				( IWbemServices * ) this , 
				( CWbemGlobal_IWmiObjectSinkController * ) this
			) ;

			if ( t_Sink )
			{
				t_Sink->AddRef () ;

				t_Result = t_Sink->Initialize ( m_Registration->GetComRegistration ().GetSecurityDescriptor () ) ;
				if ( SUCCEEDED ( t_Result ) ) 
				{
					CWbemGlobal_IWmiObjectSinkController_Container_Iterator t_Iterator ;

					Lock () ;

					WmiStatusCode t_StatusCode = Insert ( 

						*t_Sink ,
						t_Iterator
					) ;

					if ( t_StatusCode == e_StatusCode_Success ) 
					{
						UnLock () ;

						IUnknown *t_ServerInterface = m_Provider_IWbemServices ;
						REFIID t_InterfaceIdentifier = IID_IWbemServices ;
						DWORD t_ProxyIndex = ProxyIndex_IWbemServices ;
						IUnknown *t_InternalServerInterface = m_Provider_Internal_IWbemServices ;
						REFIID t_InternalInterfaceIdentifier = IID_Internal_IWbemServices ;
						DWORD t_InternalProxyIndex = ProxyIndex_Internal_IWbemServices ;
						BOOL t_Impersonating ;
						IUnknown *t_OldContext ;
						IServerSecurity *t_OldSecurity ;
						BOOL t_IsProxy ;
						IUnknown *t_Interface ;
						BOOL t_Revert ;
						IUnknown *t_Proxy ;
						HANDLE t_IdentifyToken = NULL ;

						t_Result = Begin_Interface (

							t_ServerInterface ,
							t_InterfaceIdentifier ,
							t_ProxyIndex ,
							t_InternalServerInterface ,
							t_InternalInterfaceIdentifier ,
							t_InternalProxyIndex ,
							m_ProcessIdentifier ,
							t_IdentifyToken ,
							t_Impersonating ,
							t_OldContext ,
							t_OldSecurity ,
							t_IsProxy ,
							t_Interface ,
							t_Revert ,
							t_Proxy
						) ;

						if ( SUCCEEDED ( t_Result ) )
						{
							if ( t_IdentifyToken )
							{
								BSTR t_Superclass = SysAllocString ( a_Superclass ) ;
								if ( t_Superclass ) 
								{
									WmiInternalContext t_InternalContext ;
									t_InternalContext.m_IdentifyHandle = ( unsigned __int64 ) t_IdentifyToken ;
									t_InternalContext.m_ProcessIdentifier = GetCurrentProcessId () ;

									t_Result = ( ( Internal_IWbemServices * ) t_Interface )->Internal_CreateClassEnumAsync  (

										t_InternalContext ,
										t_Superclass , 
										a_Flags, 
										a_Context ,
										t_Sink
									) ;

									SysFreeString ( t_Superclass ) ;
								}
								else
								{
									t_Result = WBEM_E_OUT_OF_MEMORY ;
								}
							}
							else
							{
								t_Result = ( ( IWbemServices * ) t_Interface )->CreateClassEnumAsync  (

									a_Superclass , 
									a_Flags, 
									a_Context ,
									t_Sink
								) ;
							}

							End_Interface (

								t_ServerInterface ,
								t_InterfaceIdentifier ,
								t_ProxyIndex ,
								t_InternalServerInterface ,
								t_InternalInterfaceIdentifier ,
								t_InternalProxyIndex ,
								m_ProcessIdentifier ,
								t_IdentifyToken ,
								t_Impersonating ,
								t_OldContext ,
								t_OldSecurity ,
								t_IsProxy ,
								t_Interface ,
								t_Revert ,
								t_Proxy
							) ;
						}
					}
					else
					{
						UnLock () ;

						t_Result = WBEM_E_OUT_OF_MEMORY ;
					}
				}

				if ( FAILED ( t_Result ) )
				{
					t_Sink->SetStatus ( 0 , t_Result , NULL , NULL ) ;
				}

				t_Sink->Release () ;
			}
			else
			{
				t_Result = WBEM_E_OUT_OF_MEMORY ;
				a_Sink->SetStatus ( 0 , t_Result , NULL , NULL ) ;
			}
		}
		else
		{
			a_Sink->SetStatus ( 0 , t_Result , NULL , NULL ) ;
		}
	}
	else
	{
		t_Result = WBEM_E_PROVIDER_SUSPENDED ;
		a_Sink->SetStatus ( 0 , t_Result , NULL , NULL ) ;
	}

	if ( FAILED ( t_Result ) )
	{
		if ( ( HRESULT_ERROR_FUNC(t_Result) == HRESULT_ERROR_SERVER_UNAVAILABLE ) || ( HRESULT_ERROR_FUNC(t_Result) == HRESULT_ERROR_CALL_FAILED_DNE ) || ( t_Result == RPC_E_DISCONNECTED ))
		{
			AbnormalShutdown () ;
		}
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_IWbemProvider :: PutInstance (

    IWbemClassObject *a_Instance ,
    long a_Flags ,
    IWbemContext *a_Context ,
	IWbemCallResult **a_CallResult
) 
{
	return WBEM_E_NOT_AVAILABLE ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_IWbemProvider :: PutInstanceAsync ( 
		
	IWbemClassObject *a_Instance , 
	long a_Flags ,
    IWbemContext *a_Context ,
	IWbemObjectSink *a_Sink
) 
{
	if ( m_Initialized == 0 )
	{
		if ( WBEM_FLAG_ADVISORY & a_Flags )
		{
			a_Sink->SetStatus ( 0 , S_OK , NULL , NULL ) ;

			return S_OK ;
		}
		else
		{
			a_Sink->SetStatus ( 0 , WBEM_E_NOT_FOUND , NULL , NULL ) ;

			return WBEM_E_NOT_FOUND ;
		}
	}
	_DBG_ASSERT(SUCCEEDED(m_InitializeResult));
	HRESULT t_Result = WBEM_E_PROVIDER_NOT_CAPABLE ;

	if ( GetResumed () )
	{
		if ( m_Provider_IWbemServices )
		{
			CInterceptor_IWbemObjectSink *t_Sink = new CInterceptor_IWbemObjectSink (

				a_Sink , 
				( IWbemServices * ) this , 
				( CWbemGlobal_IWmiObjectSinkController * ) this
			) ;

			if ( t_Sink )
			{
				t_Sink->AddRef () ;

				t_Result = t_Sink->Initialize ( m_Registration->GetComRegistration ().GetSecurityDescriptor () ) ;
				if ( SUCCEEDED ( t_Result ) ) 
				{
					CWbemGlobal_IWmiObjectSinkController_Container_Iterator t_Iterator ;

					Lock () ;

					WmiStatusCode t_StatusCode = Insert ( 

						*t_Sink ,
						t_Iterator
					) ;

					if ( t_StatusCode == e_StatusCode_Success ) 
					{
						UnLock () ;

						IUnknown *t_ServerInterface = m_Provider_IWbemServices ;
						REFIID t_InterfaceIdentifier = IID_IWbemServices ;
						DWORD t_ProxyIndex = ProxyIndex_IWbemServices ;
						IUnknown *t_InternalServerInterface = m_Provider_Internal_IWbemServices ;
						REFIID t_InternalInterfaceIdentifier = IID_Internal_IWbemServices ;
						DWORD t_InternalProxyIndex = ProxyIndex_Internal_IWbemServices ;
						BOOL t_Impersonating ;
						IUnknown *t_OldContext ;
						IServerSecurity *t_OldSecurity ;
						BOOL t_IsProxy ;
						IUnknown *t_Interface ;
						BOOL t_Revert ;
						IUnknown *t_Proxy ;
						HANDLE t_IdentifyToken = NULL ;

						t_Result = Begin_Interface (

							t_ServerInterface ,
							t_InterfaceIdentifier ,
							t_ProxyIndex ,
							t_InternalServerInterface ,
							t_InternalInterfaceIdentifier ,
							t_InternalProxyIndex ,
							m_ProcessIdentifier ,
							t_IdentifyToken ,
							t_Impersonating ,
							t_OldContext ,
							t_OldSecurity ,
							t_IsProxy ,
							t_Interface ,
							t_Revert ,
							t_Proxy
						) ;

						if ( SUCCEEDED ( t_Result ) )
						{
							if ( t_IdentifyToken )
							{
								WmiInternalContext t_InternalContext ;
								t_InternalContext.m_IdentifyHandle = ( unsigned __int64 ) t_IdentifyToken ;
								t_InternalContext.m_ProcessIdentifier = GetCurrentProcessId () ;

								t_Result = ( ( Internal_IWbemServices * ) t_Interface )->Internal_PutInstanceAsync (

									t_InternalContext ,
									a_Instance , 
									a_Flags, 
									a_Context ,
									t_Sink
								) ;
							}
							else
							{
								t_Result = ( ( IWbemServices * ) t_Interface )->PutInstanceAsync (

									a_Instance , 
									a_Flags, 
									a_Context ,
									t_Sink
								) ;
							}

							End_Interface (

								t_ServerInterface ,
								t_InterfaceIdentifier ,
								t_ProxyIndex ,
								t_InternalServerInterface ,
								t_InternalInterfaceIdentifier ,
								t_InternalProxyIndex ,
								m_ProcessIdentifier ,
								t_IdentifyToken ,
								t_Impersonating ,
								t_OldContext ,
								t_OldSecurity ,
								t_IsProxy ,
								t_Interface ,
								t_Revert ,
								t_Proxy
							) ;
						}
					}
					else
					{
						UnLock () ;

						t_Result = WBEM_E_OUT_OF_MEMORY ;
					}
				}

				if ( FAILED ( t_Result ) )
				{
					t_Sink->SetStatus ( 0 , t_Result , NULL , NULL ) ;
				}

				t_Sink->Release () ;
			}
			else
			{
				t_Result = WBEM_E_OUT_OF_MEMORY ;
				a_Sink->SetStatus ( 0 , t_Result , NULL , NULL ) ;
			}
		}
		else
		{
			a_Sink->SetStatus ( 0 , t_Result , NULL , NULL ) ;
		}
	}
	else
	{
		t_Result = WBEM_E_PROVIDER_SUSPENDED ;
		a_Sink->SetStatus ( 0 , t_Result , NULL , NULL ) ;
	}

	if ( FAILED ( t_Result ) )
	{
		if ( ( HRESULT_ERROR_FUNC(t_Result) == HRESULT_ERROR_SERVER_UNAVAILABLE ) || ( HRESULT_ERROR_FUNC(t_Result) == HRESULT_ERROR_CALL_FAILED_DNE ) || ( t_Result == RPC_E_DISCONNECTED ))
		{
			AbnormalShutdown () ;
		}
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_IWbemProvider :: DeleteInstance ( 

	const BSTR a_ObjectPath ,
    long a_Flags ,
    IWbemContext *a_Context ,
    IWbemCallResult **a_CallResult
)
{
	return WBEM_E_NOT_AVAILABLE ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/
        
HRESULT CInterceptor_IWbemProvider :: DeleteInstanceAsync (
 
	const BSTR a_ObjectPath ,
    long a_Flags ,
    IWbemContext *a_Context ,
    IWbemObjectSink *a_Sink	
)
{
	if ( m_Initialized == 0 )
	{
		if ( WBEM_FLAG_ADVISORY & a_Flags )
		{
			a_Sink->SetStatus ( 0 , S_OK , NULL , NULL ) ;

			return S_OK ;
		}
		else
		{
			a_Sink->SetStatus ( 0 , WBEM_E_NOT_FOUND , NULL , NULL ) ;

			return WBEM_E_NOT_FOUND ;
		}
	}
	_DBG_ASSERT(SUCCEEDED(m_InitializeResult));
	HRESULT t_Result = WBEM_E_PROVIDER_NOT_CAPABLE ;

	if ( GetResumed () )
	{
		if ( m_Provider_IWbemServices )
		{
			CInterceptor_IWbemObjectSink *t_Sink = new CInterceptor_IWbemObjectSink (

				a_Sink , 
				( IWbemServices * ) this , 
				( CWbemGlobal_IWmiObjectSinkController * ) this
			) ;

			if ( t_Sink )
			{
				t_Sink->AddRef () ;

				t_Result = t_Sink->Initialize ( m_Registration->GetComRegistration ().GetSecurityDescriptor () ) ;
				if ( SUCCEEDED ( t_Result ) ) 
				{
					CWbemGlobal_IWmiObjectSinkController_Container_Iterator t_Iterator ;

					Lock () ;

					WmiStatusCode t_StatusCode = Insert ( 

						*t_Sink ,
						t_Iterator
					) ;

					if ( t_StatusCode == e_StatusCode_Success ) 
					{
						UnLock () ;

						IUnknown *t_ServerInterface = m_Provider_IWbemServices ;
						REFIID t_InterfaceIdentifier = IID_IWbemServices ;
						DWORD t_ProxyIndex = ProxyIndex_IWbemServices ;
						IUnknown *t_InternalServerInterface = m_Provider_Internal_IWbemServices ;
						REFIID t_InternalInterfaceIdentifier = IID_Internal_IWbemServices ;
						DWORD t_InternalProxyIndex = ProxyIndex_Internal_IWbemServices ;
						BOOL t_Impersonating ;
						IUnknown *t_OldContext ;
						IServerSecurity *t_OldSecurity ;
						BOOL t_IsProxy ;
						IUnknown *t_Interface ;
						BOOL t_Revert ;
						IUnknown *t_Proxy ;
						HANDLE t_IdentifyToken = NULL ;

						t_Result = Begin_Interface (

							t_ServerInterface ,
							t_InterfaceIdentifier ,
							t_ProxyIndex ,
							t_InternalServerInterface ,
							t_InternalInterfaceIdentifier ,
							t_InternalProxyIndex ,
							m_ProcessIdentifier ,
							t_IdentifyToken ,
							t_Impersonating ,
							t_OldContext ,
							t_OldSecurity ,
							t_IsProxy ,
							t_Interface ,
							t_Revert ,
							t_Proxy
						) ;

						if ( SUCCEEDED ( t_Result ) )
						{
							if ( t_IdentifyToken )
							{
								BSTR t_ObjectPath = SysAllocString ( a_ObjectPath ) ;
								if ( t_ObjectPath ) 
								{
									WmiInternalContext t_InternalContext ;
									t_InternalContext.m_IdentifyHandle = ( unsigned __int64 ) t_IdentifyToken ;
									t_InternalContext.m_ProcessIdentifier = GetCurrentProcessId () ;

									t_Result = ( ( Internal_IWbemServices * ) t_Interface )->Internal_DeleteInstanceAsync  (

										t_InternalContext ,
										t_ObjectPath ,
										a_Flags ,
										a_Context ,
										t_Sink
									) ;

									SysFreeString ( t_ObjectPath ) ;
								}
								else
								{
									t_Result = WBEM_E_OUT_OF_MEMORY ;
								}
							}
							else
							{
								t_Result = ( ( IWbemServices * ) t_Interface )->DeleteInstanceAsync  (

									a_ObjectPath ,
									a_Flags ,
									a_Context ,
									t_Sink
								) ;
							}

							End_Interface (

								t_ServerInterface ,
								t_InterfaceIdentifier ,
								t_ProxyIndex ,
								t_InternalServerInterface ,
								t_InternalInterfaceIdentifier ,
								t_InternalProxyIndex ,
								m_ProcessIdentifier ,
								t_IdentifyToken ,
								t_Impersonating ,
								t_OldContext ,
								t_OldSecurity ,
								t_IsProxy ,
								t_Interface ,
								t_Revert ,
								t_Proxy
							) ;
						}
					}
					else
					{
						UnLock () ;

						t_Result = WBEM_E_OUT_OF_MEMORY ;
					}
				}

				if ( FAILED ( t_Result ) )
				{
					t_Sink->SetStatus ( 0 , t_Result , NULL , NULL ) ;
				}

				t_Sink->Release () ;
			}
			else
			{
				t_Result = WBEM_E_OUT_OF_MEMORY ;
				a_Sink->SetStatus ( 0 , t_Result , NULL , NULL ) ;
			}
		}
		else
		{
			a_Sink->SetStatus ( 0 , t_Result , NULL , NULL ) ;
		}
	}
	else
	{
		t_Result = WBEM_E_PROVIDER_SUSPENDED ;
		a_Sink->SetStatus ( 0 , t_Result , NULL , NULL ) ;
	}

	if ( FAILED ( t_Result ) )
	{
		if ( ( HRESULT_ERROR_FUNC(t_Result) == HRESULT_ERROR_SERVER_UNAVAILABLE ) || ( HRESULT_ERROR_FUNC(t_Result) == HRESULT_ERROR_CALL_FAILED_DNE ) || ( t_Result == RPC_E_DISCONNECTED ))
		{
			AbnormalShutdown () ;
		}
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_IWbemProvider :: CreateInstanceEnum ( 

	const BSTR a_Class ,
	long a_Flags , 
	IWbemContext *a_Context , 
	IEnumWbemClassObject **a_Enum
)
{
	return WBEM_E_NOT_AVAILABLE ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_IWbemProvider :: CreateInstanceEnumAsync (

 	const BSTR a_Class ,
	long a_Flags ,
	IWbemContext *a_Context ,
	IWbemObjectSink *a_Sink

) 
{
	if ( m_Initialized == 0 )
	{
		a_Sink->SetStatus ( 0 , S_OK , NULL , NULL ) ;

		return S_OK ;
	}
	_DBG_ASSERT(SUCCEEDED(m_InitializeResult));
	HRESULT t_Result = WBEM_E_PROVIDER_NOT_CAPABLE ;

	if ( GetResumed () )
	{
		if ( m_Provider_IWbemServices )
		{
			CInterceptor_IWbemObjectSink *t_Sink = new CInterceptor_IWbemObjectSink (

				a_Sink , 
				( IWbemServices * ) this , 
				( CWbemGlobal_IWmiObjectSinkController * ) this
			) ;

			if ( t_Sink )
			{
				t_Sink->AddRef () ;

				t_Result = t_Sink->Initialize ( m_Registration->GetComRegistration ().GetSecurityDescriptor () ) ;
				if ( SUCCEEDED ( t_Result ) ) 
				{
					CWbemGlobal_IWmiObjectSinkController_Container_Iterator t_Iterator ;

					Lock () ;

					WmiStatusCode t_StatusCode = Insert ( 

						*t_Sink ,
						t_Iterator
					) ;

					if ( t_StatusCode == e_StatusCode_Success ) 
					{
						UnLock () ;

						IUnknown *t_ServerInterface = m_Provider_IWbemServices ;
						REFIID t_InterfaceIdentifier = IID_IWbemServices ;
						DWORD t_ProxyIndex = ProxyIndex_IWbemServices ;
						IUnknown *t_InternalServerInterface = m_Provider_Internal_IWbemServices ;
						REFIID t_InternalInterfaceIdentifier = IID_Internal_IWbemServices ;
						DWORD t_InternalProxyIndex = ProxyIndex_Internal_IWbemServices ;
						BOOL t_Impersonating ;
						IUnknown *t_OldContext ;
						IServerSecurity *t_OldSecurity ;
						BOOL t_IsProxy ;
						IUnknown *t_Interface ;
						BOOL t_Revert ;
						IUnknown *t_Proxy ;
						HANDLE t_IdentifyToken = NULL ;

						t_Result = Begin_Interface (

							t_ServerInterface ,
							t_InterfaceIdentifier ,
							t_ProxyIndex ,
							t_InternalServerInterface ,
							t_InternalInterfaceIdentifier ,
							t_InternalProxyIndex ,
							m_ProcessIdentifier ,
							t_IdentifyToken ,
							t_Impersonating ,
							t_OldContext ,
							t_OldSecurity ,
							t_IsProxy ,
							t_Interface ,
							t_Revert ,
							t_Proxy 
						) ;

						if ( SUCCEEDED ( t_Result ) )
						{
							if ( t_IdentifyToken )
							{
								WmiInternalContext t_InternalContext ;
								t_InternalContext.m_IdentifyHandle = ( unsigned __int64 ) t_IdentifyToken ;
								t_InternalContext.m_ProcessIdentifier = GetCurrentProcessId () ;

								BSTR t_Class = SysAllocString ( a_Class ) ;
								if ( t_Class )
								{
									t_Result = ( ( Internal_IWbemServices * ) t_Interface )->Internal_CreateInstanceEnumAsync (

										t_InternalContext ,
 										t_Class ,
										a_Flags ,
										a_Context ,
										t_Sink 
									) ;

									SysFreeString ( t_Class ) ;
								}
								else
								{
									t_Result = WBEM_E_OUT_OF_MEMORY ;
								}
							}
							else
							{

								t_Result = ( ( IWbemServices * ) t_Interface )->CreateInstanceEnumAsync (

 									a_Class ,
									a_Flags ,
									a_Context ,
									t_Sink 
								) ;
							}

							End_Interface (

								t_ServerInterface ,
								t_InterfaceIdentifier ,
								t_ProxyIndex ,
								t_InternalServerInterface ,
								t_InternalInterfaceIdentifier ,
								t_InternalProxyIndex ,
								m_ProcessIdentifier ,
								t_IdentifyToken ,
								t_Impersonating ,
								t_OldContext ,
								t_OldSecurity ,
								t_IsProxy ,
								t_Interface ,
								t_Revert ,
								t_Proxy
							) ;
						}
					}
					else
					{
						UnLock () ;

						t_Result = WBEM_E_OUT_OF_MEMORY ;
					}
				}

				if ( FAILED ( t_Result ) )
				{
					t_Sink->SetStatus ( 0 , t_Result , NULL , NULL ) ;
				}

				t_Sink->Release () ;
			}
			else
			{
				t_Result = WBEM_E_OUT_OF_MEMORY ;
				a_Sink->SetStatus ( 0 , t_Result , NULL , NULL ) ;
			}
		}
		else
		{
			a_Sink->SetStatus ( 0 , t_Result , NULL , NULL ) ;
		}
	}
	else
	{
		t_Result = WBEM_E_PROVIDER_SUSPENDED ;
		a_Sink->SetStatus ( 0 , t_Result , NULL , NULL ) ;
	}

	if ( FAILED ( t_Result ) )
	{
		if ( ( HRESULT_ERROR_FUNC(t_Result) == HRESULT_ERROR_SERVER_UNAVAILABLE ) || ( HRESULT_ERROR_FUNC(t_Result) == HRESULT_ERROR_CALL_FAILED_DNE ) || ( t_Result == RPC_E_DISCONNECTED ))
		{
			AbnormalShutdown () ;
		}
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_IWbemProvider :: ExecQuery ( 

	const BSTR a_QueryLanguage ,
	const BSTR a_Query ,
	long a_Flags ,
	IWbemContext *a_Context ,
	IEnumWbemClassObject **a_Enum
)
{
	return WBEM_E_NOT_AVAILABLE ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_IWbemProvider :: ExecQueryAsync ( 
		
	const BSTR a_QueryLanguage ,
	const BSTR a_Query, 
	long a_Flags, 
	IWbemContext *a_Context ,
	IWbemObjectSink *a_Sink
) 
{
	if ( m_Initialized == 0 )
	{
		a_Sink->SetStatus ( 0 , S_OK , NULL , NULL ) ;

		return S_OK ;
	}
	_DBG_ASSERT(SUCCEEDED(m_InitializeResult));
	HRESULT t_Result = WBEM_E_PROVIDER_NOT_CAPABLE ;

	if ( GetResumed () )
	{
		if ( m_Provider_IWbemServices )
		{
			CInterceptor_IWbemFilteringObjectSink *t_Sink = new CInterceptor_IWbemFilteringObjectSink (

				a_Sink , 
				( IWbemServices * ) this , 
				( CWbemGlobal_IWmiObjectSinkController * ) this ,
				a_QueryLanguage ,
				a_Query 
			) ;

			if ( t_Sink )
			{
				t_Sink->AddRef () ;

				t_Result = t_Sink->Initialize ( m_Registration->GetComRegistration ().GetSecurityDescriptor () ) ;
				if ( SUCCEEDED ( t_Result ) ) 
				{
					CWbemGlobal_IWmiObjectSinkController_Container_Iterator t_Iterator ;

					Lock () ;

					WmiStatusCode t_StatusCode = Insert ( 

						*t_Sink ,
						t_Iterator
					) ;

					if ( t_StatusCode == e_StatusCode_Success ) 
					{
						UnLock () ;

						IUnknown *t_ServerInterface = m_Provider_IWbemServices ;
						REFIID t_InterfaceIdentifier = IID_IWbemServices ;
						DWORD t_ProxyIndex = ProxyIndex_IWbemServices ;
						IUnknown *t_InternalServerInterface = m_Provider_Internal_IWbemServices ;
						REFIID t_InternalInterfaceIdentifier = IID_Internal_IWbemServices ;
						DWORD t_InternalProxyIndex = ProxyIndex_Internal_IWbemServices ;
						BOOL t_Impersonating ;
						IUnknown *t_OldContext ;
						IServerSecurity *t_OldSecurity ;
						BOOL t_IsProxy ;
						IUnknown *t_Interface ;
						BOOL t_Revert ;
						IUnknown *t_Proxy ;
						HANDLE t_IdentifyToken = NULL ;

						t_Result = Begin_Interface (

							t_ServerInterface ,
							t_InterfaceIdentifier ,
							t_ProxyIndex ,
							t_InternalServerInterface ,
							t_InternalInterfaceIdentifier ,
							t_InternalProxyIndex ,
							m_ProcessIdentifier ,
							t_IdentifyToken ,
							t_Impersonating ,
							t_OldContext ,
							t_OldSecurity ,
							t_IsProxy ,
							t_Interface ,
							t_Revert ,
							t_Proxy
						) ;

						if ( SUCCEEDED ( t_Result ) )
						{
							if ( t_IdentifyToken )
							{
								BSTR t_QueryLanguage = SysAllocString ( a_QueryLanguage ) ;
								BSTR t_Query = SysAllocString ( a_Query ) ;

								if ( t_QueryLanguage && t_Query ) 
								{
									WmiInternalContext t_InternalContext ;
									t_InternalContext.m_IdentifyHandle = ( unsigned __int64 ) t_IdentifyToken ;
									t_InternalContext.m_ProcessIdentifier = GetCurrentProcessId () ;

									t_Result = ( ( Internal_IWbemServices * ) t_Interface )->Internal_ExecQueryAsync  (

										t_InternalContext ,
										t_QueryLanguage , 
										t_Query, 
										a_Flags, 
										a_Context ,
										t_Sink
									) ;
								}
								else
								{
									t_Result = WBEM_E_OUT_OF_MEMORY ;
								}

								SysFreeString ( t_QueryLanguage ) ;
								SysFreeString ( t_Query ) ;
							}
							else
							{
								t_Result = ( ( IWbemServices * ) t_Interface )->ExecQueryAsync  (

									a_QueryLanguage , 
									a_Query, 
									a_Flags, 
									a_Context ,
									t_Sink
								) ;
							}

							End_Interface (

								t_ServerInterface ,
								t_InterfaceIdentifier ,
								t_ProxyIndex ,
								t_InternalServerInterface ,
								t_InternalInterfaceIdentifier ,
								t_InternalProxyIndex ,
								m_ProcessIdentifier ,
								t_IdentifyToken ,
								t_Impersonating ,
								t_OldContext ,
								t_OldSecurity ,
								t_IsProxy ,
								t_Interface ,
								t_Revert ,
								t_Proxy
							) ;
						}
					}
					else
					{
						UnLock () ;

						t_Result = WBEM_E_OUT_OF_MEMORY ;
					}
				}
				
				if ( FAILED ( t_Result ) )
				{
					t_Sink->SetStatus ( 0 , t_Result , NULL , NULL ) ;
				}

				t_Sink->Release () ;
			}
			else
			{
				t_Result = WBEM_E_OUT_OF_MEMORY ;
				a_Sink->SetStatus ( 0 , t_Result , NULL , NULL ) ;
			}
		}
		else
		{
			a_Sink->SetStatus ( 0 , t_Result , NULL , NULL ) ;
		}
	}
	else
	{
		t_Result = WBEM_E_PROVIDER_SUSPENDED ;
		a_Sink->SetStatus ( 0 , t_Result , NULL , NULL ) ;
	}

	if ( FAILED ( t_Result ) )
	{
		if ( ( HRESULT_ERROR_FUNC(t_Result) == HRESULT_ERROR_SERVER_UNAVAILABLE ) || ( HRESULT_ERROR_FUNC(t_Result) == HRESULT_ERROR_CALL_FAILED_DNE ) || ( t_Result == RPC_E_DISCONNECTED ))
		{
			AbnormalShutdown () ;
		}
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_IWbemProvider :: ExecNotificationQuery ( 

	const BSTR a_QueryLanguage ,
    const BSTR a_Query ,
    long a_Flags ,
    IWbemContext *a_Context ,
    IEnumWbemClassObject **a_Enum
)
{
	return WBEM_E_NOT_AVAILABLE ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/
        
HRESULT CInterceptor_IWbemProvider :: ExecNotificationQueryAsync ( 
            
	const BSTR a_QueryLanguage ,
    const BSTR a_Query ,
    long a_Flags ,
    IWbemContext *a_Context ,
    IWbemObjectSink *a_Sink 
)
{
	return WBEM_E_NOT_AVAILABLE ;
}       

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_IWbemProvider :: ExecMethod (

	const BSTR a_ObjectPath ,
    const BSTR a_MethodName ,
    long a_Flags ,
    IWbemContext *a_Context ,
    IWbemClassObject *a_InParams ,
    IWbemClassObject **a_OutParams ,
    IWbemCallResult **a_CallResult
)
{
	return WBEM_E_NOT_AVAILABLE ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_IWbemProvider :: ExecMethodAsync ( 

    const BSTR a_ObjectPath ,
    const BSTR a_MethodName ,
    long a_Flags ,
    IWbemContext *a_Context ,
    IWbemClassObject *a_InParams ,
	IWbemObjectSink *a_Sink
) 
{
	if ( m_Initialized == 0 )
	{
		a_Sink->SetStatus ( 0 , WBEM_E_NOT_FOUND , NULL , NULL ) ;

		return WBEM_E_NOT_FOUND ;
	}
	_DBG_ASSERT(SUCCEEDED(m_InitializeResult));
	HRESULT t_Result = WBEM_E_NOT_AVAILABLE ;

	if ( GetResumed () )
	{
		if ( m_Provider_IWbemServices )
		{
			CInterceptor_IWbemObjectSink *t_Sink = new CInterceptor_IWbemObjectSink (

				a_Sink , 
				( IWbemServices * ) this , 
				( CWbemGlobal_IWmiObjectSinkController * ) this
			) ;

			if ( t_Sink )
			{
				t_Sink->AddRef () ;

				t_Result = t_Sink->Initialize ( m_Registration->GetComRegistration ().GetSecurityDescriptor () ) ;
				if ( SUCCEEDED ( t_Result ) ) 
				{
					CWbemGlobal_IWmiObjectSinkController_Container_Iterator t_Iterator ;

					Lock () ;

					WmiStatusCode t_StatusCode = Insert ( 

						*t_Sink ,
						t_Iterator
					) ;

					if ( t_StatusCode == e_StatusCode_Success ) 
					{
						UnLock () ;

						IUnknown *t_ServerInterface = m_Provider_IWbemServices ;
						REFIID t_InterfaceIdentifier = IID_IWbemServices ;
						DWORD t_ProxyIndex = ProxyIndex_IWbemServices ;
						IUnknown *t_InternalServerInterface = m_Provider_Internal_IWbemServices ;
						REFIID t_InternalInterfaceIdentifier = IID_Internal_IWbemServices ;
						DWORD t_InternalProxyIndex = ProxyIndex_Internal_IWbemServices ;
						BOOL t_Impersonating ;
						IUnknown *t_OldContext ;
						IServerSecurity *t_OldSecurity ;
						BOOL t_IsProxy ;
						IUnknown *t_Interface ;
						BOOL t_Revert ;
						IUnknown *t_Proxy ;
						HANDLE t_IdentifyToken = NULL ;

						t_Result = Begin_Interface (

							t_ServerInterface ,
							t_InterfaceIdentifier ,
							t_ProxyIndex ,
							t_InternalServerInterface ,
							t_InternalInterfaceIdentifier ,
							t_InternalProxyIndex ,
							m_ProcessIdentifier ,
							t_IdentifyToken ,
							t_Impersonating ,
							t_OldContext ,
							t_OldSecurity ,
							t_IsProxy ,
							t_Interface ,
							t_Revert ,
							t_Proxy ,
							a_Context
						) ;

						if ( SUCCEEDED ( t_Result ) )
						{
							if ( t_IdentifyToken )
							{
								BSTR t_ObjectPath = SysAllocString ( a_ObjectPath ) ;
								BSTR t_MethodName = SysAllocString ( a_MethodName ) ;

								if ( t_ObjectPath && t_MethodName ) 
								{
									WmiInternalContext t_InternalContext ;
									t_InternalContext.m_IdentifyHandle = ( unsigned __int64 ) t_IdentifyToken ;
									t_InternalContext.m_ProcessIdentifier = GetCurrentProcessId () ;

									t_Result = ( ( Internal_IWbemServices * ) t_Interface )->Internal_ExecMethodAsync  (

										t_InternalContext ,
										t_ObjectPath ,
										t_MethodName ,
										a_Flags ,
										a_Context ,
										a_InParams ,
										t_Sink
									) ;
								}
								else
								{
									t_Result = WBEM_E_OUT_OF_MEMORY ;
								}

								SysFreeString ( t_ObjectPath ) ;
								SysFreeString ( t_MethodName ) ;
							}
							else
							{
								t_Result = ( ( IWbemServices * ) t_Interface )->ExecMethodAsync  (

									a_ObjectPath ,
									a_MethodName ,
									a_Flags ,
									a_Context ,
									a_InParams ,
									t_Sink
								) ;
							}

							End_Interface (

								t_ServerInterface ,
								t_InterfaceIdentifier ,
								t_ProxyIndex ,
								t_InternalServerInterface ,
								t_InternalInterfaceIdentifier ,
								t_InternalProxyIndex ,
								m_ProcessIdentifier ,
								t_IdentifyToken ,
								t_Impersonating ,
								t_OldContext ,
								t_OldSecurity ,
								t_IsProxy ,
								t_Interface ,
								t_Revert ,
								t_Proxy
							) ;
						}
					}
					else
					{
						UnLock () ;

						t_Result = WBEM_E_OUT_OF_MEMORY ;
					}
				}

				if ( FAILED ( t_Result ) )
				{
					t_Sink->SetStatus ( 0 , t_Result , NULL , NULL ) ;
				}

				t_Sink->Release () ;
			}
			else
			{
				t_Result = WBEM_E_OUT_OF_MEMORY ;
				a_Sink->SetStatus ( 0 , t_Result , NULL , NULL ) ;
			}
		}
		else
		{
			a_Sink->SetStatus ( 0 , t_Result , NULL , NULL ) ;
		}
	}
	else
	{
		t_Result = WBEM_E_PROVIDER_SUSPENDED ;
		a_Sink->SetStatus ( 0 , t_Result , NULL , NULL ) ;
	}

	if ( FAILED ( t_Result ) )
	{
		if ( ( HRESULT_ERROR_FUNC(t_Result) == HRESULT_ERROR_SERVER_UNAVAILABLE ) || ( HRESULT_ERROR_FUNC(t_Result) == HRESULT_ERROR_CALL_FAILED_DNE ) || ( t_Result == RPC_E_DISCONNECTED ))
		{
			AbnormalShutdown () ;
		}
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_IWbemProvider :: GetProperty (

    long a_Flags ,
    const BSTR a_Locale ,
    const BSTR a_ClassMapping ,
    const BSTR a_InstanceMapping ,
    const BSTR a_PropertyMapping ,
    VARIANT *a_Value
)
{
	_DBG_ASSERT(SUCCEEDED(m_InitializeResult));

	if ( GetResumed () )
	{
		if ( m_Provider_IWbemPropertyProvider )
		{
			IUnknown *t_ServerInterface = m_Provider_IWbemPropertyProvider ;
			REFIID t_InterfaceIdentifier = IID_IWbemPropertyProvider ;
			DWORD t_ProxyIndex = ProxyIndex_IWbemPropertyProvider ;
			IUnknown *t_InternalServerInterface = m_Provider_Internal_IWbemPropertyProvider ;
			REFIID t_InternalInterfaceIdentifier = IID_Internal_IWbemPropertyProvider ;
			DWORD t_InternalProxyIndex = ProxyIndex_Internal_IWbemPropertyProvider ;
			BOOL t_Impersonating ;
			IUnknown *t_OldContext ;
			IServerSecurity *t_OldSecurity ;
			BOOL t_IsProxy ;
			IUnknown *t_Interface ;
			BOOL t_Revert ;
			IUnknown *t_Proxy ;
			HANDLE t_IdentifyToken = NULL ;

			HRESULT t_Result = Begin_Interface (

				t_ServerInterface ,
				t_InterfaceIdentifier ,
				t_ProxyIndex ,
				t_InternalServerInterface ,
				t_InternalInterfaceIdentifier ,
				t_InternalProxyIndex ,
				m_ProcessIdentifier ,
				t_IdentifyToken ,
				t_Impersonating ,
				t_OldContext ,
				t_OldSecurity ,
				t_IsProxy ,
				t_Interface ,
				t_Revert ,
				t_Proxy
			) ;

			if ( SUCCEEDED ( t_Result ) )
			{
				if ( t_IdentifyToken )
				{
					BSTR t_ClassMapping = NULL ;
					BSTR t_InstanceMapping = NULL ;
					BSTR t_PropertyMapping = NULL ;

					if ( a_ClassMapping )
					{
						t_ClassMapping = SysAllocString ( a_ClassMapping ) ;
						if ( t_ClassMapping == NULL )
						{
							t_Result = WBEM_E_OUT_OF_MEMORY ;
						}
					}

					if ( a_InstanceMapping )
					{
						t_InstanceMapping = SysAllocString ( a_InstanceMapping ) ;
						if ( t_InstanceMapping == NULL )
						{
							t_Result = WBEM_E_OUT_OF_MEMORY ;
						} 
					}

					if ( a_PropertyMapping )
					{
						t_PropertyMapping = SysAllocString ( a_PropertyMapping ) ;
						if ( t_PropertyMapping == NULL )
						{
							t_Result = WBEM_E_OUT_OF_MEMORY ;
						}
					}

					if ( SUCCEEDED ( t_Result ) )
					{
						WmiInternalContext t_InternalContext ;
						t_InternalContext.m_IdentifyHandle = ( unsigned __int64 ) t_IdentifyToken ;
						t_InternalContext.m_ProcessIdentifier = GetCurrentProcessId () ;

						( ( Internal_IWbemPropertyProvider * ) t_Interface )->Internal_GetProperty ( 

							t_InternalContext ,
							a_Flags ,
							a_Locale ,
							t_ClassMapping ,
							t_InstanceMapping ,
							t_PropertyMapping ,
							a_Value
						) ;
					}
					else
					{
						t_Result = WBEM_E_OUT_OF_MEMORY ;
					}

					SysFreeString ( t_ClassMapping ) ;
					SysFreeString ( t_InstanceMapping ) ;
					SysFreeString ( t_PropertyMapping ) ;
				}
				else
				{
					t_Result = ( ( IWbemPropertyProvider * ) t_Interface )->GetProperty (

						a_Flags ,
						a_Locale ,
						a_ClassMapping ,
						a_InstanceMapping ,
						a_PropertyMapping ,
						a_Value
					) ;
				}

				End_Interface (

					t_ServerInterface ,
					t_InterfaceIdentifier ,
					t_ProxyIndex ,
					t_InternalServerInterface ,
					t_InternalInterfaceIdentifier ,
					t_InternalProxyIndex ,
					m_ProcessIdentifier ,
					t_IdentifyToken ,
					t_Impersonating ,
					t_OldContext ,
					t_OldSecurity ,
					t_IsProxy ,
					t_Interface ,
					t_Revert ,
					t_Proxy
				) ;
			}

			if ( FAILED ( t_Result ) )
			{
				if ( ( HRESULT_ERROR_FUNC(t_Result) == HRESULT_ERROR_SERVER_UNAVAILABLE ) || ( HRESULT_ERROR_FUNC(t_Result) == HRESULT_ERROR_CALL_FAILED_DNE ) || ( t_Result == RPC_E_DISCONNECTED ))
				{
					AbnormalShutdown () ;
				}
			}

			return t_Result ;
		}	
		else
		{
			return WBEM_E_PROVIDER_NOT_CAPABLE;
		}
	}

	return WBEM_E_PROVIDER_SUSPENDED ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_IWbemProvider :: PutProperty (

    long a_Flags ,
    const BSTR a_Locale ,
    const BSTR a_ClassMapping ,
    const BSTR a_InstanceMapping ,
    const BSTR a_PropertyMapping ,
    const VARIANT *a_Value
)
{
	_DBG_ASSERT(SUCCEEDED(m_InitializeResult));
	if ( GetResumed () )
	{
		if ( m_Provider_IWbemPropertyProvider )
		{
			IUnknown *t_ServerInterface = m_Provider_IWbemPropertyProvider ;
			REFIID t_InterfaceIdentifier = IID_IWbemPropertyProvider ;
			DWORD t_ProxyIndex = ProxyIndex_IWbemPropertyProvider ;
			IUnknown *t_InternalServerInterface = m_Provider_Internal_IWbemPropertyProvider ;
			REFIID t_InternalInterfaceIdentifier = IID_Internal_IWbemPropertyProvider ;
			DWORD t_InternalProxyIndex = ProxyIndex_Internal_IWbemPropertyProvider ;
			BOOL t_Impersonating ;
			IUnknown *t_OldContext ;
			IServerSecurity *t_OldSecurity ;
			BOOL t_IsProxy ;
			IUnknown *t_Interface ;
			BOOL t_Revert ;
			IUnknown *t_Proxy ;
			HANDLE t_IdentifyToken = NULL ;

			HRESULT t_Result = Begin_Interface (

				t_ServerInterface ,
				t_InterfaceIdentifier ,
				t_ProxyIndex ,
				t_InternalServerInterface ,
				t_InternalInterfaceIdentifier ,
				t_InternalProxyIndex ,
				m_ProcessIdentifier ,
				t_IdentifyToken ,
				t_Impersonating ,
				t_OldContext ,
				t_OldSecurity ,
				t_IsProxy ,
				t_Interface ,
				t_Revert ,
				t_Proxy
			) ;

			if ( SUCCEEDED ( t_Result ) )
			{
				if ( t_IdentifyToken )
				{
					BSTR t_ClassMapping = NULL ;
					BSTR t_InstanceMapping = NULL ;
					BSTR t_PropertyMapping = NULL ;

					if ( a_ClassMapping )
					{
						t_ClassMapping = SysAllocString ( a_ClassMapping ) ;
						if ( t_ClassMapping == NULL )
						{
							t_Result = WBEM_E_OUT_OF_MEMORY ;
						}
					}

					if ( a_InstanceMapping )
					{
						t_InstanceMapping = SysAllocString ( a_InstanceMapping ) ;
						if ( t_InstanceMapping == NULL )
						{
							t_Result = WBEM_E_OUT_OF_MEMORY ;
						} 
					}

					if ( a_PropertyMapping )
					{
						t_PropertyMapping = SysAllocString ( a_PropertyMapping ) ;
						if ( t_PropertyMapping == NULL )
						{
							t_Result = WBEM_E_OUT_OF_MEMORY ;
						}
					}

					if ( SUCCEEDED ( t_Result ) )
					{
						WmiInternalContext t_InternalContext ;
						t_InternalContext.m_IdentifyHandle = ( unsigned __int64 ) t_IdentifyToken ;
						t_InternalContext.m_ProcessIdentifier = GetCurrentProcessId () ;

						( ( Internal_IWbemPropertyProvider * ) t_Interface )->Internal_PutProperty ( 

							t_InternalContext ,
							a_Flags ,
							a_Locale ,
							t_ClassMapping ,
							t_InstanceMapping ,
							t_PropertyMapping ,
							a_Value
						) ;
					}
					else
					{
						t_Result = WBEM_E_OUT_OF_MEMORY ;
					}

					SysFreeString ( t_ClassMapping ) ;
					SysFreeString ( t_InstanceMapping ) ;
					SysFreeString ( t_PropertyMapping ) ;
				}
				else
				{
					t_Result = ( ( IWbemPropertyProvider * ) t_Interface )->PutProperty (

						a_Flags ,
						a_Locale ,
						a_ClassMapping ,
						a_InstanceMapping ,
						a_PropertyMapping ,
						a_Value
					) ;
				}

				End_Interface (

					t_ServerInterface ,
					t_InterfaceIdentifier ,
					t_ProxyIndex ,
					t_InternalServerInterface ,
					t_InternalInterfaceIdentifier ,
					t_InternalProxyIndex ,
					m_ProcessIdentifier ,
					t_IdentifyToken ,
					t_Impersonating ,
					t_OldContext ,
					t_OldSecurity ,
					t_IsProxy ,
					t_Interface ,
					t_Revert ,
					t_Proxy
				) ;
			}

			if ( FAILED ( t_Result ) )
			{
				if ( ( HRESULT_ERROR_FUNC(t_Result) == HRESULT_ERROR_SERVER_UNAVAILABLE ) || ( HRESULT_ERROR_FUNC(t_Result) == HRESULT_ERROR_CALL_FAILED_DNE ) || ( t_Result == RPC_E_DISCONNECTED ))
				{
					AbnormalShutdown () ;
				}
			}

			return t_Result ;
		}

		return WBEM_E_PROVIDER_NOT_CAPABLE;
	}

	return WBEM_E_PROVIDER_SUSPENDED ;

}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_IWbemProvider ::ProvideEvents (

	IWbemObjectSink *a_Sink ,
	long a_Flags
)
{
	_DBG_ASSERT(SUCCEEDED(m_InitializeResult));

	if ( GetResumed () )
	{
		if ( m_Provider_IWbemEventProvider )
		{
			IUnknown *t_ServerInterface = m_Provider_IWbemEventProvider ;
			REFIID t_InterfaceIdentifier = IID_IWbemEventProvider ;
			DWORD t_ProxyIndex = ProxyIndex_IWbemEventProvider ;
			IUnknown *t_InternalServerInterface = m_Provider_Internal_IWbemEventProvider ;
			REFIID t_InternalInterfaceIdentifier = IID_Internal_IWbemEventProvider ;
			DWORD t_InternalProxyIndex = ProxyIndex_Internal_IWbemEventProvider ;
			BOOL t_Impersonating ;
			IUnknown *t_OldContext ;
			IServerSecurity *t_OldSecurity ;
			BOOL t_IsProxy ;
			IUnknown *t_Interface ;
			BOOL t_Revert ;
			IUnknown *t_Proxy ;
			HANDLE t_IdentifyToken = NULL ;

			HRESULT t_Result = Begin_Interface (

				t_ServerInterface ,
				t_InterfaceIdentifier ,
				t_ProxyIndex ,
				t_InternalServerInterface ,
				t_InternalInterfaceIdentifier ,
				t_InternalProxyIndex ,
				m_ProcessIdentifier ,
				t_IdentifyToken ,
				t_Impersonating ,
				t_OldContext ,
				t_OldSecurity ,
				t_IsProxy ,
				t_Interface ,
				t_Revert ,
				t_Proxy
			) ;

			if ( SUCCEEDED ( t_Result ) )
			{
				if ( t_IdentifyToken )
				{
					WmiInternalContext t_InternalContext ;
					t_InternalContext.m_IdentifyHandle = ( unsigned __int64 ) t_IdentifyToken ;
					t_InternalContext.m_ProcessIdentifier = GetCurrentProcessId () ;

					t_Result = ( ( Internal_IWbemEventProvider * ) t_Interface )->Internal_ProvideEvents (

						t_InternalContext ,
						a_Sink ,
						a_Flags 
					) ;
				}
				else
				{
					t_Result = ( ( IWbemEventProvider * ) t_Interface )->ProvideEvents (

						a_Sink ,
						a_Flags 
					) ;
				}

				End_Interface (

					t_ServerInterface ,
					t_InterfaceIdentifier ,
					t_ProxyIndex ,
					t_InternalServerInterface ,
					t_InternalInterfaceIdentifier ,
					t_InternalProxyIndex ,
					m_ProcessIdentifier ,
					t_IdentifyToken ,
					t_Impersonating ,
					t_OldContext ,
					t_OldSecurity ,
					t_IsProxy ,
					t_Interface ,
					t_Revert ,
					t_Proxy
				) ;
			}

			if ( FAILED ( t_Result ) )
			{
				if ( ( HRESULT_ERROR_FUNC(t_Result) == HRESULT_ERROR_SERVER_UNAVAILABLE ) || ( HRESULT_ERROR_FUNC(t_Result) == HRESULT_ERROR_CALL_FAILED_DNE ) || ( t_Result == RPC_E_DISCONNECTED ))
				{
					AbnormalShutdown () ;
				}
			}

			return t_Result ;
		}

		return WBEM_E_PROVIDER_NOT_CAPABLE;
	}

	return WBEM_E_PROVIDER_SUSPENDED ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_IWbemProvider ::NewQuery (

	unsigned long a_Id ,
	WBEM_WSTR a_QueryLanguage ,
	WBEM_WSTR a_Query
)
{
	_DBG_ASSERT(SUCCEEDED(m_InitializeResult));
	if ( GetResumed () )
	{
		if ( m_Provider_IWbemEventProviderQuerySink )
		{
			IUnknown *t_ServerInterface = m_Provider_IWbemEventProviderQuerySink ;
			REFIID t_InterfaceIdentifier = IID_IWbemEventProviderQuerySink ;
			DWORD t_ProxyIndex = ProxyIndex_IWbemEventProviderQuerySink ;
			IUnknown *t_InternalServerInterface = m_Provider_Internal_IWbemEventProviderQuerySink ;
			REFIID t_InternalInterfaceIdentifier = IID_Internal_IWbemEventProviderQuerySink ;
			DWORD t_InternalProxyIndex = ProxyIndex_Internal_IWbemEventProviderQuerySink ;
			BOOL t_Impersonating ;
			IUnknown *t_OldContext ;
			IServerSecurity *t_OldSecurity ;
			BOOL t_IsProxy ;
			IUnknown *t_Interface ;
			BOOL t_Revert ;
			IUnknown *t_Proxy ;
			HANDLE t_IdentifyToken = NULL ;

			HRESULT t_Result = Begin_Interface (

				t_ServerInterface ,
				t_InterfaceIdentifier ,
				t_ProxyIndex ,
				t_InternalServerInterface ,
				t_InternalInterfaceIdentifier ,
				t_InternalProxyIndex ,
				m_ProcessIdentifier ,
				t_IdentifyToken ,
				t_Impersonating ,
				t_OldContext ,
				t_OldSecurity ,
				t_IsProxy ,
				t_Interface ,
				t_Revert ,
				t_Proxy
			) ;

			if ( SUCCEEDED ( t_Result ) )
			{
				if ( t_IdentifyToken )
				{
					BSTR t_QueryLanguage = SysAllocString ( a_QueryLanguage ) ;
					BSTR t_Query = SysAllocString ( a_Query ) ;

					if ( t_QueryLanguage && t_Query )
					{
						WmiInternalContext t_InternalContext ;
						t_InternalContext.m_IdentifyHandle = ( unsigned __int64 ) t_IdentifyToken ;
						t_InternalContext.m_ProcessIdentifier = GetCurrentProcessId () ;

						t_Result = ( ( Internal_IWbemEventProviderQuerySink * ) t_Interface )->Internal_NewQuery (

							t_InternalContext ,
							a_Id ,
							t_QueryLanguage ,
							t_Query
						) ;
					}
					else
					{
						t_Result = WBEM_E_OUT_OF_MEMORY ;
					}

					SysFreeString ( t_QueryLanguage ) ;
					SysFreeString ( t_Query ) ;
				}
				else
				{
					t_Result = ( ( IWbemEventProviderQuerySink * ) t_Interface )->NewQuery (

						a_Id ,
						a_QueryLanguage ,
						a_Query
					) ;
				}

				End_Interface (

					t_ServerInterface ,
					t_InterfaceIdentifier ,
					t_ProxyIndex ,
					t_InternalServerInterface ,
					t_InternalInterfaceIdentifier ,
					t_InternalProxyIndex ,
					m_ProcessIdentifier ,
					t_IdentifyToken ,
					t_Impersonating ,
					t_OldContext ,
					t_OldSecurity ,
					t_IsProxy ,
					t_Interface ,
					t_Revert ,
					t_Proxy
				) ;
			}

			if ( FAILED ( t_Result ) )
			{
				if ( ( HRESULT_ERROR_FUNC(t_Result) == HRESULT_ERROR_SERVER_UNAVAILABLE ) || ( HRESULT_ERROR_FUNC(t_Result) == HRESULT_ERROR_CALL_FAILED_DNE ) || ( t_Result == RPC_E_DISCONNECTED ))
				{
					AbnormalShutdown () ;
				}
			}

			return t_Result ;
		}

		return WBEM_E_PROVIDER_NOT_CAPABLE;
	}

	return WBEM_E_PROVIDER_SUSPENDED ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_IWbemProvider ::CancelQuery (

	unsigned long a_Id
)
{
	_DBG_ASSERT(SUCCEEDED(m_InitializeResult));
	if ( GetResumed () )
	{
		if ( m_Provider_IWbemEventProviderQuerySink )
		{
			IUnknown *t_ServerInterface = m_Provider_IWbemEventProviderQuerySink ;
			REFIID t_InterfaceIdentifier = IID_IWbemEventProviderQuerySink ;
			DWORD t_ProxyIndex = ProxyIndex_IWbemEventProviderQuerySink ;
			IUnknown *t_InternalServerInterface = m_Provider_Internal_IWbemEventProviderQuerySink ;
			REFIID t_InternalInterfaceIdentifier = IID_Internal_IWbemEventProviderQuerySink ;
			DWORD t_InternalProxyIndex = ProxyIndex_Internal_IWbemEventProviderQuerySink ;
			BOOL t_Impersonating ;
			IUnknown *t_OldContext ;
			IServerSecurity *t_OldSecurity ;
			BOOL t_IsProxy ;
			IUnknown *t_Interface ;
			BOOL t_Revert ;
			IUnknown *t_Proxy ;
			HANDLE t_IdentifyToken = NULL ;

			HRESULT t_Result = Begin_Interface (

				t_ServerInterface ,
				t_InterfaceIdentifier ,
				t_ProxyIndex ,
				t_InternalServerInterface ,
				t_InternalInterfaceIdentifier ,
				t_InternalProxyIndex ,
				m_ProcessIdentifier ,
				t_IdentifyToken ,
				t_Impersonating ,
				t_OldContext ,
				t_OldSecurity ,
				t_IsProxy ,
				t_Interface ,
				t_Revert ,
				t_Proxy
			) ;

			if ( SUCCEEDED ( t_Result ) )
			{
				if ( t_IdentifyToken )
				{
					WmiInternalContext t_InternalContext ;
					t_InternalContext.m_IdentifyHandle = ( unsigned __int64 ) t_IdentifyToken ;
					t_InternalContext.m_ProcessIdentifier = GetCurrentProcessId () ;

					t_Result = ( ( Internal_IWbemEventProviderQuerySink * ) t_Interface )->Internal_CancelQuery (

						t_InternalContext ,
						a_Id
					) ;
				}
				else
				{
					t_Result = ( ( IWbemEventProviderQuerySink * ) t_Interface )->CancelQuery (

						a_Id
					) ;
				}

				End_Interface (

					t_ServerInterface ,
					t_InterfaceIdentifier ,
					t_ProxyIndex ,
					t_InternalServerInterface ,
					t_InternalInterfaceIdentifier ,
					t_InternalProxyIndex ,
					m_ProcessIdentifier ,
					t_IdentifyToken ,
					t_Impersonating ,
					t_OldContext ,
					t_OldSecurity ,
					t_IsProxy ,
					t_Interface ,
					t_Revert ,
					t_Proxy
				) ;
			}

			if ( FAILED ( t_Result ) )
			{
				if ( ( HRESULT_ERROR_FUNC(t_Result) == HRESULT_ERROR_SERVER_UNAVAILABLE ) || ( HRESULT_ERROR_FUNC(t_Result) == HRESULT_ERROR_CALL_FAILED_DNE ) || ( t_Result == RPC_E_DISCONNECTED ))
				{
					AbnormalShutdown () ;
				}
			}

			return t_Result ;
		}

		return WBEM_E_PROVIDER_NOT_CAPABLE;
	}

	return WBEM_E_PROVIDER_SUSPENDED ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_IWbemProvider ::AccessCheck (

	WBEM_CWSTR a_QueryLanguage ,
	WBEM_CWSTR a_Query ,
	long a_SidLength ,
	const BYTE *a_Sid
)
{
	_DBG_ASSERT(SUCCEEDED(m_InitializeResult));
	if ( GetResumed () )
	{
		if ( m_Provider_IWbemEventProviderSecurity )
		{
			IUnknown *t_ServerInterface = m_Provider_IWbemEventProviderSecurity ;
			REFIID t_InterfaceIdentifier = IID_IWbemEventProviderSecurity ;
			DWORD t_ProxyIndex = ProxyIndex_IWbemEventProviderSecurity ;
			IUnknown *t_InternalServerInterface = m_Provider_Internal_IWbemEventProviderSecurity ;
			REFIID t_InternalInterfaceIdentifier = IID_Internal_IWbemEventProviderSecurity ;
			DWORD t_InternalProxyIndex = ProxyIndex_Internal_IWbemEventProviderSecurity;
			BOOL t_Impersonating ;
			IUnknown *t_OldContext ;
			IServerSecurity *t_OldSecurity ;
			BOOL t_IsProxy ;
			IUnknown *t_Interface ;
			BOOL t_Revert ;
			IUnknown *t_Proxy ;
			HANDLE t_IdentifyToken = NULL ;

			HRESULT t_Result ;

			if ( a_Sid )
			{
				t_Result = Begin_Interface (

					t_ServerInterface ,
					t_InterfaceIdentifier ,
					t_ProxyIndex ,
					t_InternalServerInterface ,
					t_InternalInterfaceIdentifier ,
					t_InternalProxyIndex ,
					m_ProcessIdentifier ,
					t_IdentifyToken ,
					t_Impersonating ,
					t_OldContext ,
					t_OldSecurity ,
					t_IsProxy ,
					t_Interface ,
					t_Revert ,
					t_Proxy
				) ;
			}
			else
			{
				t_Result = Begin_Interface (

					t_ServerInterface ,
					t_InterfaceIdentifier ,
					t_ProxyIndex ,
					t_InternalServerInterface ,
					t_InternalInterfaceIdentifier ,
					t_InternalProxyIndex ,
					m_ProcessIdentifier ,
					t_IdentifyToken ,
					t_Impersonating ,
					t_OldContext ,
					t_OldSecurity ,
					t_IsProxy ,
					t_Interface ,
					t_Revert ,
					t_Proxy
				) ;
			}

			if ( SUCCEEDED ( t_Result ) )
			{
				if ( t_IdentifyToken )
				{
					BSTR t_QueryLanguage = SysAllocString ( a_QueryLanguage ) ;
					BSTR t_Query = SysAllocString ( a_Query ) ;

					if ( t_QueryLanguage && t_Query )
					{
						WmiInternalContext t_InternalContext ;
						t_InternalContext.m_IdentifyHandle = ( unsigned __int64 ) t_IdentifyToken ;
						t_InternalContext.m_ProcessIdentifier = GetCurrentProcessId () ;

						t_Result = ( ( Internal_IWbemEventProviderSecurity * ) t_Interface )->Internal_AccessCheck (

							t_InternalContext ,
							t_QueryLanguage ,
							t_Query ,
							a_SidLength ,
							a_Sid
						) ;
					}
					else
					{
						t_Result = WBEM_E_OUT_OF_MEMORY ;
					}

					SysFreeString ( t_QueryLanguage ) ;
					SysFreeString ( t_Query ) ;
				}
				else
				{
					t_Result = ( ( IWbemEventProviderSecurity * ) t_Interface )->AccessCheck (

						a_QueryLanguage ,
						a_Query ,
						a_SidLength ,
						a_Sid
					) ;
				}

				End_Interface (

					t_ServerInterface ,
					t_InterfaceIdentifier ,
					t_ProxyIndex ,
					t_InternalServerInterface ,
					t_InternalInterfaceIdentifier ,
					t_InternalProxyIndex ,
					m_ProcessIdentifier ,
					t_IdentifyToken ,
					t_Impersonating ,
					t_OldContext ,
					t_OldSecurity ,
					t_IsProxy ,
					t_Interface ,
					t_Revert ,
					t_Proxy
				) ;

				if ( FAILED ( t_Result ) )
				{
					if ( ( HRESULT_ERROR_FUNC(t_Result) == HRESULT_ERROR_SERVER_UNAVAILABLE ) || ( HRESULT_ERROR_FUNC(t_Result) == HRESULT_ERROR_CALL_FAILED_DNE ) || ( t_Result == RPC_E_DISCONNECTED ))
					{
						AbnormalShutdown () ;
					}
				}
			}

			return t_Result ;
		}

		return WBEM_E_PROVIDER_NOT_CAPABLE;
	}

	return WBEM_E_PROVIDER_SUSPENDED ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_IWbemProvider ::FindConsumer (

	IWbemClassObject *a_LogicalConsumer ,
	IWbemUnboundObjectSink **a_Consumer
)
{
	_DBG_ASSERT(SUCCEEDED(m_InitializeResult));
	if ( GetResumed () )
	{
		if ( m_Provider_IWbemEventConsumerProvider )
		{
			IWbemUnboundObjectSink *t_Consumer = NULL ;

			IUnknown *t_ServerInterface = m_Provider_IWbemEventConsumerProvider ;
			REFIID t_InterfaceIdentifier = IID_IWbemEventConsumerProvider ;
			DWORD t_ProxyIndex = ProxyIndex_IWbemEventConsumerProvider ;
			IUnknown *t_InternalServerInterface = m_Provider_Internal_IWbemEventConsumerProvider ;
			REFIID t_InternalInterfaceIdentifier = IID_Internal_IWbemEventConsumerProvider ;
			DWORD t_InternalProxyIndex = ProxyIndex_Internal_IWbemEventConsumerProvider ;
			BOOL t_Impersonating ;
			IUnknown *t_OldContext ;
			IServerSecurity *t_OldSecurity ;
			BOOL t_IsProxy ;
			IUnknown *t_Interface ;
			BOOL t_Revert ;
			IUnknown *t_Proxy ;
			HANDLE t_IdentifyToken = NULL ;

			HRESULT t_Result = Begin_Interface (

				t_ServerInterface ,
				t_InterfaceIdentifier ,
				t_ProxyIndex ,
				t_InternalServerInterface ,
				t_InternalInterfaceIdentifier ,
				t_InternalProxyIndex ,
				m_ProcessIdentifier ,
				t_IdentifyToken ,
				t_Impersonating ,
				t_OldContext ,
				t_OldSecurity ,
				t_IsProxy ,
				t_Interface ,
				t_Revert ,
				t_Proxy
			) ;

			if ( SUCCEEDED ( t_Result ) )
			{
				if ( t_IdentifyToken )
				{
					WmiInternalContext t_InternalContext ;
					t_InternalContext.m_IdentifyHandle = ( unsigned __int64 ) t_IdentifyToken ;
					t_InternalContext.m_ProcessIdentifier = GetCurrentProcessId () ;

					t_Result = ( ( Internal_IWbemEventConsumerProvider * ) t_Interface )->Internal_FindConsumer (

						t_InternalContext ,
						a_LogicalConsumer ,
						& t_Consumer
					) ;
				}
				else
				{
					t_Result = ( ( IWbemEventConsumerProvider * ) t_Interface )->FindConsumer (

						a_LogicalConsumer ,
						& t_Consumer
					) ;
				}

				End_Interface (

					t_ServerInterface ,
					t_InterfaceIdentifier ,
					t_ProxyIndex ,
					t_InternalServerInterface ,
					t_InternalInterfaceIdentifier ,
					t_InternalProxyIndex ,
					m_ProcessIdentifier ,
					t_IdentifyToken ,
					t_Impersonating ,
					t_OldContext ,
					t_OldSecurity ,
					t_IsProxy ,
					t_Interface ,
					t_Revert ,
					t_Proxy
				) ;
			}

			if ( SUCCEEDED ( t_Result ) )
			{
				if ( a_Consumer )
				{
					CInterceptor_IWbemUnboundObjectSink *t_UnboundObjectSink = new CInterceptor_IWbemUnboundObjectSink (

							m_Allocator ,
							t_Consumer , 
							this ,
							*m_Registration
					) ;

					if ( t_UnboundObjectSink )
					{
						t_UnboundObjectSink->AddRef () ;

						t_Result = t_UnboundObjectSink->Initialize () ;
						if ( SUCCEEDED ( t_Result ) ) 
						{
							CWbemGlobal_VoidPointerController_Container_Iterator t_Iterator ;

							Lock () ;

							WmiStatusCode t_StatusCode = Insert ( 

								*t_UnboundObjectSink ,
								t_Iterator
							) ;

							if ( t_StatusCode == e_StatusCode_Success ) 
							{
								UnLock () ;

								*a_Consumer = t_UnboundObjectSink ;

								t_UnboundObjectSink->AddRef () ;
							}
							else
							{
								UnLock () ;

								t_Result = WBEM_E_OUT_OF_MEMORY ;
							}
						}

						t_UnboundObjectSink->Release () ;
					}
				}
			}
			else
			{
				if ( ( HRESULT_ERROR_FUNC(t_Result) == HRESULT_ERROR_SERVER_UNAVAILABLE ) || ( HRESULT_ERROR_FUNC(t_Result) == HRESULT_ERROR_CALL_FAILED_DNE ) || ( t_Result == RPC_E_DISCONNECTED ))
				{
					AbnormalShutdown () ;
				}
			}

			if ( t_Consumer )
			{
				t_Consumer->Release () ;
			}

			return t_Result ;
		}

		return WBEM_E_PROVIDER_NOT_CAPABLE;
	}

	return WBEM_E_PROVIDER_SUSPENDED ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_IWbemProvider ::ValidateSubscription (

	IWbemClassObject *a_LogicalConsumer
)
{
	_DBG_ASSERT(SUCCEEDED(m_InitializeResult));
	if ( GetResumed () )
	{
		if ( m_Provider_IWbemEventConsumerProviderEx )
		{
			IUnknown *t_ServerInterface = m_Provider_IWbemEventConsumerProviderEx ;
			REFIID t_InterfaceIdentifier = IID_IWbemEventConsumerProviderEx ;
			DWORD t_ProxyIndex = ProxyIndex_IWbemEventConsumerProviderEx ;
			IUnknown *t_InternalServerInterface = m_Provider_Internal_IWbemEventConsumerProviderEx ;
			REFIID t_InternalInterfaceIdentifier = IID_Internal_IWbemEventConsumerProviderEx ;
			DWORD t_InternalProxyIndex = ProxyIndex_Internal_IWbemEventConsumerProviderEx ;
			BOOL t_Impersonating ;
			IUnknown *t_OldContext ;
			IServerSecurity *t_OldSecurity ;
			BOOL t_IsProxy ;
			IUnknown *t_Interface ;
			BOOL t_Revert ;
			IUnknown *t_Proxy ;
			HANDLE t_IdentifyToken = NULL ;

			HRESULT t_Result = Begin_Interface (

				t_ServerInterface ,
				t_InterfaceIdentifier ,
				t_ProxyIndex ,
				t_InternalServerInterface ,
				t_InternalInterfaceIdentifier ,
				t_InternalProxyIndex ,
				m_ProcessIdentifier ,
				t_IdentifyToken ,
				t_Impersonating ,
				t_OldContext ,
				t_OldSecurity ,
				t_IsProxy ,
				t_Interface ,
				t_Revert ,
				t_Proxy
			) ;

			if ( SUCCEEDED ( t_Result ) )
			{
				if ( t_IdentifyToken )
				{
					WmiInternalContext t_InternalContext ;
					t_InternalContext.m_IdentifyHandle = ( unsigned __int64 ) t_IdentifyToken ;
					t_InternalContext.m_ProcessIdentifier = GetCurrentProcessId () ;

					t_Result = ( ( Internal_IWbemEventConsumerProviderEx * ) t_Interface )->Internal_ValidateSubscription (

						t_InternalContext ,
						a_LogicalConsumer
					) ;
				}
				else
				{

					t_Result = ( ( IWbemEventConsumerProviderEx * ) t_Interface )->ValidateSubscription (

						a_LogicalConsumer
					) ;
				}

				End_Interface (

					t_ServerInterface ,
					t_InterfaceIdentifier ,
					t_ProxyIndex ,
					t_InternalServerInterface ,
					t_InternalInterfaceIdentifier ,
					t_InternalProxyIndex ,
					m_ProcessIdentifier ,
					t_IdentifyToken ,
					t_Impersonating ,
					t_OldContext ,
					t_OldSecurity ,
					t_IsProxy ,
					t_Interface ,
					t_Revert ,
					t_Proxy
				) ;
			}

			if ( FAILED ( t_Result ) )
			{
				if ( ( HRESULT_ERROR_FUNC(t_Result) == HRESULT_ERROR_SERVER_UNAVAILABLE ) || ( HRESULT_ERROR_FUNC(t_Result) == HRESULT_ERROR_CALL_FAILED_DNE ) || ( t_Result == RPC_E_DISCONNECTED ))
				{
					AbnormalShutdown () ;
				}
			}

			return t_Result ;
		}

		return WBEM_E_PROVIDER_NOT_CAPABLE;
	}

	return WBEM_E_PROVIDER_SUSPENDED ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_IWbemProvider :: IndicateToConsumer (

	IWbemClassObject *a_LogicalConsumer ,
	long a_ObjectCount ,
	IWbemClassObject **a_Objects
)
{
	_DBG_ASSERT(SUCCEEDED(m_InitializeResult));
	if ( GetResumed () )
	{
		if ( m_Provider_IWbemUnboundObjectSink )
		{
			IUnknown *t_ServerInterface = m_Provider_IWbemUnboundObjectSink ;
			REFIID t_InterfaceIdentifier = IID_IWbemUnboundObjectSink ;
			DWORD t_ProxyIndex = ProxyIndex_IWbemUnboundObjectSink ;
			IUnknown *t_InternalServerInterface = m_Provider_Internal_IWbemUnboundObjectSink ;
			REFIID t_InternalInterfaceIdentifier = IID_Internal_IWbemUnboundObjectSink ;
			DWORD t_InternalProxyIndex = ProxyIndex_Internal_IWbemUnboundObjectSink ;
			BOOL t_Impersonating ;
			IUnknown *t_OldContext ;
			IServerSecurity *t_OldSecurity ;
			BOOL t_IsProxy ;
			IUnknown *t_Interface ;
			BOOL t_Revert ;
			IUnknown *t_Proxy ;
			HANDLE t_IdentifyToken = NULL ;

			HRESULT t_Result = Begin_Interface (

				t_ServerInterface ,
				t_InterfaceIdentifier ,
				t_ProxyIndex ,
				t_InternalServerInterface ,
				t_InternalInterfaceIdentifier ,
				t_InternalProxyIndex ,
				m_ProcessIdentifier ,
				t_IdentifyToken ,
				t_Impersonating ,
				t_OldContext ,
				t_OldSecurity ,
				t_IsProxy ,
				t_Interface ,
				t_Revert ,
				t_Proxy
			) ;

			if ( SUCCEEDED ( t_Result ) )
			{
				if ( t_IdentifyToken )
				{
					WmiInternalContext t_InternalContext ;
					t_InternalContext.m_IdentifyHandle = ( unsigned __int64 ) t_IdentifyToken ;
					t_InternalContext.m_ProcessIdentifier = GetCurrentProcessId () ;

					t_Result = ( ( Internal_IWbemUnboundObjectSink * ) t_Interface )->Internal_IndicateToConsumer (

						t_InternalContext ,
						a_LogicalConsumer ,
						a_ObjectCount ,
						a_Objects
					) ;
				}
				else
				{

					t_Result = ( ( IWbemUnboundObjectSink * ) t_Interface )->IndicateToConsumer (

						a_LogicalConsumer ,
						a_ObjectCount ,
						a_Objects
					) ;
				}

				End_Interface (

					t_ServerInterface ,
					t_InterfaceIdentifier ,
					t_ProxyIndex ,
					t_InternalServerInterface ,
					t_InternalInterfaceIdentifier ,
					t_InternalProxyIndex ,
					m_ProcessIdentifier ,
					t_IdentifyToken ,
					t_Impersonating ,
					t_OldContext ,
					t_OldSecurity ,
					t_IsProxy ,
					t_Interface ,
					t_Revert ,
					t_Proxy
				) ;
			}

			if ( FAILED ( t_Result ) )
			{
				if ( ( HRESULT_ERROR_FUNC(t_Result) == HRESULT_ERROR_SERVER_UNAVAILABLE ) || ( HRESULT_ERROR_FUNC(t_Result) == HRESULT_ERROR_CALL_FAILED_DNE ) || ( t_Result == RPC_E_DISCONNECTED ))
				{
					AbnormalShutdown () ;
				}
			}

			return t_Result ;
		}

		return WBEM_E_PROVIDER_NOT_CAPABLE;
	}

	return WBEM_E_PROVIDER_SUSPENDED ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_IWbemProvider ::QueryInstances (

	IWbemServices *a_Namespace ,
	WCHAR *a_Class ,
	long a_Flags ,
	IWbemContext *a_Context ,
	IWbemObjectSink *a_Sink
)
{
	return WBEM_E_PROVIDER_NOT_CAPABLE;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_IWbemProvider ::CreateRefresher (

	IWbemServices *a_Namespace ,
	long a_Flags ,
	IWbemRefresher **a_Refresher
)
{
	return WBEM_E_PROVIDER_NOT_CAPABLE;
} 

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_IWbemProvider ::CreateRefreshableObject (

	IWbemServices *a_Namespace ,
	IWbemObjectAccess *a_Template ,
	IWbemRefresher *a_Refresher ,
	long a_Flags ,
	IWbemContext *a_Context ,
	IWbemObjectAccess **a_Refreshable ,
	long *a_Id
)
{
	return WBEM_E_PROVIDER_NOT_CAPABLE;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_IWbemProvider ::StopRefreshing (

	IWbemRefresher *a_Refresher ,
	long a_Id ,
	long a_Flags
)
{
	return WBEM_E_PROVIDER_NOT_CAPABLE;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_IWbemProvider ::CreateRefreshableEnum (

	IWbemServices *a_Namespace ,
	LPCWSTR a_Class ,
	IWbemRefresher *a_Refresher ,
	long a_Flags ,
	IWbemContext *a_Context ,
	IWbemHiPerfEnum *a_HiPerfEnum ,
	long *a_Id
)
{
	return WBEM_E_PROVIDER_NOT_CAPABLE;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_IWbemProvider ::GetObjects (

	IWbemServices *a_Namespace ,
	long a_ObjectCount ,
	IWbemObjectAccess **a_Objects ,
	long a_Flags ,
	IWbemContext *a_Context
)
{
	return WBEM_E_PROVIDER_NOT_CAPABLE;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_IWbemProvider :: Get (

	IWbemServices *a_Service ,
	long a_Flags ,
	IWbemContext *a_Context ,
	LPCWSTR a_Class ,
	LPCWSTR a_Path ,
	IWbemObjectSink *a_Sink
)
{
	_DBG_ASSERT(SUCCEEDED(m_InitializeResult));
	HRESULT t_Result = S_OK ;

	if ( wbem_wcsicmp ( a_Class , L"Msft_Providers" ) == 0 )
	{
		CWaitingObjectSink *t_Sink = new CWaitingObjectSink ( m_Allocator ) ;
		if ( t_Sink )
		{
			t_Sink->AddRef () ;

			t_Result = t_Sink->SinkInitialize () ;
			if ( SUCCEEDED ( t_Result ) )
			{
				try
				{
					ProviderCacheKey t_Key = ServiceCacheElement :: GetKey () ;

					t_Result = m_Provider__IWmiProviderConfiguration->Get ( 

						a_Service ,
						a_Flags ,
						a_Context ,
						a_Class ,
						a_Path ,
						t_Sink 
					) ;

					t_Result = t_Sink->Wait ( INFINITE ) ;

					if ( SUCCEEDED ( t_Result ) )
					{
						t_Result = t_Sink->GetResult () ;
						if ( FAILED ( t_Result ) )
						{
						}
					}

					WmiQueue <IWbemClassObject *,8> &t_Queue = t_Sink->GetQueue () ;

					WmiStatusCode t_StatusCode = e_StatusCode_Success ;

					IWbemClassObject *t_Object = NULL ;
					while ( ( t_StatusCode = t_Queue.Top ( t_Object ) ) == e_StatusCode_Success )
					{
						if ( SUCCEEDED ( t_Result  ) )
						{
							VARIANT t_VariantNamespace ;
							VariantInit ( & t_VariantNamespace ) ;
							t_VariantNamespace.vt = VT_BSTR ;
							t_VariantNamespace.bstrVal = m_Namespace ? SysAllocString ( m_Namespace ) : SysAllocString ( L"" ) ;
							t_Object->Put ( L"Namespace" , 0 , & t_VariantNamespace , 0 ) ;
							VariantClear ( & t_VariantNamespace ) ;

							VARIANT t_VariantUser ;
							VariantInit ( & t_VariantUser ) ;
							t_VariantUser.vt = VT_BSTR ;
							t_VariantUser.bstrVal = t_Key.m_User ? SysAllocString ( t_Key.m_User ) : SysAllocString ( L"" ) ;
							t_Object->Put ( L"User" , 0 , & t_VariantUser , 0 ) ;
							VariantClear ( & t_VariantUser ) ;
				
							VARIANT t_VariantLocale ;
							VariantInit ( & t_VariantLocale ) ; 
							t_VariantLocale.vt = VT_BSTR ;
							t_VariantLocale.bstrVal = t_Key.m_Locale ? SysAllocString ( t_Key.m_Locale ) : SysAllocString ( L"" ) ;
							t_Object->Put ( L"Locale" , 0 , & t_VariantLocale , 0 ) ;
							VariantClear ( & t_VariantLocale ) ;

							VARIANT t_VariantProvider ;
							VariantInit ( & t_VariantProvider ) ; 
							t_VariantProvider.vt = VT_BSTR ;
							t_VariantProvider.bstrVal = t_Key.m_Provider ? SysAllocString ( t_Key.m_Provider ) : SysAllocString ( L"" ) ;
							t_Object->Put ( L"Provider" , 0 , & t_VariantProvider , 0 ) ;
							VariantClear ( & t_VariantProvider ) ;

							VARIANT t_VariantHostingSpecification ;
							VariantInit ( & t_VariantHostingSpecification ) ;
							t_VariantHostingSpecification.vt = VT_I4 ;
							t_VariantHostingSpecification.lVal = t_Key.m_Hosting ;
							t_Object->Put ( L"HostingSpecification" , 0 , & t_VariantHostingSpecification , 0 ) ;
							VariantClear ( & t_VariantHostingSpecification ) ;

							VARIANT t_VariantHostGroup ;
							VariantInit ( & t_VariantHostGroup ) ; 
							t_VariantHostGroup.vt = VT_BSTR ;
							t_VariantHostGroup.bstrVal = t_Key.m_Group ? SysAllocString ( t_Key.m_Group ) : SysAllocString ( L"" ) ;
							t_Object->Put ( L"HostingGroup" , 0 , & t_VariantHostGroup , 0 ) ;
							VariantClear ( & t_VariantHostGroup ) ;

							wchar_t t_TransactionIdentifier [ sizeof ( L"{00000000-0000-0000-0000-000000000000}" ) ] ;
							if ( t_Key.m_TransactionIdentifier )
							{
								StringFromGUID2 ( *t_Key.m_TransactionIdentifier , t_TransactionIdentifier , sizeof ( t_TransactionIdentifier ) / sizeof ( wchar_t ) );
							}

							VARIANT t_VariantTransactionIdentifier ;
							VariantInit ( & t_VariantTransactionIdentifier ) ;
							t_VariantTransactionIdentifier.vt = VT_BSTR ;
							t_VariantTransactionIdentifier.bstrVal = t_Key.m_TransactionIdentifier ? SysAllocString ( t_TransactionIdentifier ) : SysAllocString ( L"" ) ;
							t_Object->Put ( L"TransactionIdentifier" , 0 , & t_VariantTransactionIdentifier , 0 ) ;
							VariantClear ( & t_VariantTransactionIdentifier ) ;

							a_Sink->Indicate ( 1, & t_Object ) ;
						}

						t_Object->Release () ;
						t_StatusCode = t_Queue.DeQueue () ;
					}
				}
				catch ( Wmi_Heap_Exception &a_Exception )
				{
					t_Result = WBEM_E_OUT_OF_MEMORY ;
				}
				catch ( ... )
				{
					t_Result = WBEM_E_CRITICAL_ERROR ;
				}
			}

			t_Sink->Release () ;
		}
		else
		{
			t_Result = WBEM_E_OUT_OF_MEMORY ;
		}	
	}
	else
	{
		t_Result = WBEM_E_INVALID_CLASS ;
	}

	a_Sink->SetStatus ( 0 , t_Result , NULL , NULL ) ;

	if ( FAILED ( t_Result ) )
	{
		if ( ( HRESULT_ERROR_FUNC(t_Result) == HRESULT_ERROR_SERVER_UNAVAILABLE ) || ( HRESULT_ERROR_FUNC(t_Result) == HRESULT_ERROR_CALL_FAILED_DNE ) || ( t_Result == RPC_E_DISCONNECTED ))
		{
			AbnormalShutdown () ;
		}
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_IWbemProvider :: Set (

	IWbemServices *a_Service ,
	long a_Flags ,
	IWbemContext *a_Context ,
	LPCWSTR a_Provider ,
	LPCWSTR a_Class ,
	LPCWSTR a_Path ,
	IWbemClassObject *a_OldObject ,
	IWbemClassObject *a_NewObject  
)
{
	HRESULT t_Result = m_Provider__IWmiProviderConfiguration->Set ( 

		a_Service ,
		a_Flags ,
		a_Context ,
		a_Provider ,
		a_Class ,
		a_Path ,
		a_OldObject ,
		a_NewObject
	) ;

	if ( FAILED ( t_Result ) )
	{
		if ( ( HRESULT_ERROR_FUNC(t_Result) == HRESULT_ERROR_SERVER_UNAVAILABLE ) || ( HRESULT_ERROR_FUNC(t_Result) == HRESULT_ERROR_CALL_FAILED_DNE ) || ( t_Result == RPC_E_DISCONNECTED ))
		{
			AbnormalShutdown () ;
		}
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_IWbemProvider :: Deleted (

	IWbemServices *a_Service ,
	long a_Flags ,
	IWbemContext *a_Context ,
	LPCWSTR a_Provider ,
	LPCWSTR a_Class ,
	LPCWSTR a_Path ,
	IWbemClassObject *a_Object  
)
{
	HRESULT t_Result = m_Provider__IWmiProviderConfiguration->Deleted ( 

		a_Service ,
		a_Flags ,
		a_Context ,
		a_Provider ,
		a_Class ,
		a_Path ,
		a_Object  
	) ;

	if ( FAILED ( t_Result ) )
	{
		if ( ( HRESULT_ERROR_FUNC(t_Result) == HRESULT_ERROR_SERVER_UNAVAILABLE ) || ( HRESULT_ERROR_FUNC(t_Result) == HRESULT_ERROR_CALL_FAILED_DNE ) || ( t_Result == RPC_E_DISCONNECTED ))
		{
			AbnormalShutdown () ;
		}
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_IWbemProvider :: Enumerate (

	IWbemServices *a_Service ,
	long a_Flags ,
	IWbemContext *a_Context ,
	LPCWSTR a_Class ,
	IWbemObjectSink *a_Sink
)
{
	HRESULT t_Result = S_OK ;

	if ( wbem_wcsicmp ( a_Class , L"Msft_Providers" ) == 0 )
	{
		CWaitingObjectSink *t_Sink = new CWaitingObjectSink ( m_Allocator ) ;
		if ( t_Sink )
		{
			t_Sink->AddRef () ;

			t_Result = t_Sink->SinkInitialize () ;
			if ( SUCCEEDED ( t_Result ) )
			{
				try
				{
					ProviderCacheKey t_Key = ServiceCacheElement :: GetKey () ;

					t_Result = m_Provider__IWmiProviderConfiguration->Enumerate ( 

						a_Service ,
						a_Flags ,
						a_Context ,
						a_Class ,
						t_Sink 
					) ;

					if (SUCCEEDED(t_Result))
					{

					t_Result = t_Sink->Wait ( INFINITE ) ;

					if ( SUCCEEDED ( t_Result ) )
					{
						t_Result = t_Sink->GetResult () ;
						if ( FAILED ( t_Result ) )
						{
						}
					}
					}

					WmiQueue <IWbemClassObject *,8> &t_Queue = t_Sink->GetQueue () ;

					WmiStatusCode t_StatusCode = e_StatusCode_Success ;

					IWbemClassObject *t_Object = NULL ;
					while ( ( t_StatusCode = t_Queue.Top ( t_Object ) ) == e_StatusCode_Success )
					{
						if ( SUCCEEDED ( t_Result  ) )
						{
							VARIANT t_VariantNamespace ;
							VariantInit ( & t_VariantNamespace ) ;
							t_VariantNamespace.vt = VT_BSTR ;
							t_VariantNamespace.bstrVal = m_Namespace ? SysAllocString ( m_Namespace ) : SysAllocString ( L"" ) ;
							t_Object->Put ( L"Namespace" , 0 , & t_VariantNamespace , 0 ) ;
							VariantClear ( & t_VariantNamespace ) ;

							VARIANT t_VariantUser ;
							VariantInit ( & t_VariantUser ) ;
							t_VariantUser.vt = VT_BSTR ;
							t_VariantUser.bstrVal = t_Key.m_User ? SysAllocString ( t_Key.m_User ) : SysAllocString ( L"" ) ;
							t_Object->Put ( L"User" , 0 , & t_VariantUser , 0 ) ;
							VariantClear ( & t_VariantUser ) ;

							VARIANT t_VariantLocale ;
							VariantInit ( & t_VariantLocale ) ; 
							t_VariantLocale.vt = VT_BSTR ;
							t_VariantLocale.bstrVal = t_Key.m_Locale ? SysAllocString ( t_Key.m_Locale ) : SysAllocString ( L"" ) ;
							t_Object->Put ( L"Locale" , 0 , & t_VariantLocale , 0 ) ;
							VariantClear ( & t_VariantLocale ) ;

							VARIANT t_VariantProvider ;
							VariantInit ( & t_VariantProvider ) ; 
							t_VariantProvider.vt = VT_BSTR ;
							t_VariantProvider.bstrVal = t_Key.m_Provider ? SysAllocString ( t_Key.m_Provider ) : SysAllocString ( L"" ) ;
							t_Object->Put ( L"Provider" , 0 , & t_VariantProvider , 0 ) ;
							VariantClear ( & t_VariantProvider ) ;

							VARIANT t_VariantHostingSpecification ;
							VariantInit ( & t_VariantHostingSpecification ) ;
							t_VariantHostingSpecification.vt = VT_I4 ;
							t_VariantHostingSpecification.lVal = t_Key.m_Hosting ;
							t_Object->Put ( L"HostingSpecification" , 0 , & t_VariantHostingSpecification , 0 ) ;
							VariantClear ( & t_VariantHostingSpecification ) ;

							VARIANT t_VariantHostGroup ;
							VariantInit ( & t_VariantHostGroup ) ; 
							t_VariantHostGroup.vt = VT_BSTR ;
							t_VariantHostGroup.bstrVal = t_Key.m_Group ? SysAllocString ( t_Key.m_Group ) : SysAllocString ( L"" ) ;
							t_Object->Put ( L"HostingGroup" , 0 , & t_VariantHostGroup , 0 ) ;
							VariantClear ( & t_VariantHostGroup ) ;

							wchar_t t_TransactionIdentifier [ sizeof ( L"{00000000-0000-0000-0000-000000000000}" ) ] ;
							if ( t_Key.m_TransactionIdentifier )
							{
								StringFromGUID2 ( *t_Key.m_TransactionIdentifier , t_TransactionIdentifier , sizeof ( t_TransactionIdentifier ) / sizeof ( wchar_t ) );
							}

							VARIANT t_VariantTransactionIdentifier ;
							VariantInit ( & t_VariantTransactionIdentifier ) ;
							t_VariantTransactionIdentifier.vt = VT_BSTR ;
							t_VariantTransactionIdentifier.bstrVal = t_Key.m_TransactionIdentifier ? SysAllocString ( t_TransactionIdentifier ) : SysAllocString ( L"" ) ;
							t_Object->Put ( L"TransactionIdentifier" , 0 , & t_VariantTransactionIdentifier , 0 ) ;
							VariantClear ( & t_VariantTransactionIdentifier ) ;

							a_Sink->Indicate ( 1, & t_Object ) ;
						}

						t_Object->Release () ;
						t_StatusCode = t_Queue.DeQueue () ;
					}
				}
				catch ( Wmi_Heap_Exception &a_Exception )
				{
					t_Result = WBEM_E_OUT_OF_MEMORY ;
				}
				catch ( ... )
				{
					t_Result = WBEM_E_CRITICAL_ERROR ;
				}
			}

			t_Sink->Release () ;
		}
		else
		{
			t_Result = WBEM_E_OUT_OF_MEMORY ;
		}	
	}
	else
	{
		t_Result = WBEM_E_INVALID_CLASS ;
	}

	a_Sink->SetStatus ( 0 , t_Result , NULL , NULL ) ;

	if ( FAILED ( t_Result ) )
	{
		if ( ( HRESULT_ERROR_FUNC(t_Result) == HRESULT_ERROR_SERVER_UNAVAILABLE ) || ( HRESULT_ERROR_FUNC(t_Result) == HRESULT_ERROR_CALL_FAILED_DNE ) || ( t_Result == RPC_E_DISCONNECTED ))
		{
			AbnormalShutdown () ;
		}
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_IWbemProvider :: Shutdown (

	IWbemServices *a_Service ,
	long a_Flags ,
	IWbemContext *a_Context ,
	LPCWSTR a_Provider ,
	ULONG a_MilliSeconds
)
{
	HRESULT t_Result = m_Provider__IWmiProviderConfiguration->Shutdown ( 

		a_Service ,
		a_Flags ,
		a_Context ,
		a_Provider ,
		a_MilliSeconds
	) ;

	if ( FAILED ( t_Result ) )
	{
		if ( ( HRESULT_ERROR_FUNC(t_Result) == HRESULT_ERROR_SERVER_UNAVAILABLE ) || ( HRESULT_ERROR_FUNC(t_Result) == HRESULT_ERROR_CALL_FAILED_DNE ) || ( t_Result == RPC_E_DISCONNECTED ))
		{
			AbnormalShutdown () ;
		}
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_IWbemProvider :: Call (

	IWbemServices *a_Service ,
	long a_Flags ,
	IWbemContext *a_Context ,
	LPCWSTR a_Class ,
	LPCWSTR a_Path ,
	LPCWSTR a_Method,
	IWbemClassObject *a_InParams,
	IWbemObjectSink *a_Sink
)
{
	HRESULT t_Result = S_OK ;

	if ( wbem_wcsicmp ( a_Class , L"Msft_Providers" ) == 0 )
	{
		if ( wbem_wcsicmp ( a_Method , L"Suspend" ) == 0 )
		{
			SetResumed ( 0 ) ;
		}
		else if ( wbem_wcsicmp ( a_Method , L"Resume" ) == 0 )
		{
			SetResumed ( 1 ) ;
		}
		else
		{
			CWaitingObjectSink *t_Sink = new CWaitingObjectSink ( m_Allocator ) ;
			if ( t_Sink )
			{
				t_Sink->AddRef () ;

				t_Result = t_Sink->SinkInitialize () ;
				if ( SUCCEEDED ( t_Result ) )
				{
					try
					{
						ProviderCacheKey t_Key = ServiceCacheElement :: GetKey () ;

						t_Result = m_Provider__IWmiProviderConfiguration->Call ( 

							a_Service ,
							a_Flags ,
							a_Context ,
							a_Class ,
							a_Path ,
							a_Method,
							a_InParams,
							t_Sink 
						) ;

						t_Result = t_Sink->Wait ( INFINITE ) ;

						if ( SUCCEEDED ( t_Result ) )
						{
							t_Result = t_Sink->GetResult () ;
							if ( FAILED ( t_Result ) )
							{
							}
						}

						WmiQueue <IWbemClassObject *,8> &t_Queue = t_Sink->GetQueue () ;

						WmiStatusCode t_StatusCode = e_StatusCode_Success ;

						IWbemClassObject *t_Object = NULL ;
						while ( ( t_StatusCode = t_Queue.Top ( t_Object ) ) == e_StatusCode_Success )
						{
							a_Sink->Indicate ( 1, & t_Object ) ;
							t_Object->Release () ;
							t_StatusCode = t_Queue.DeQueue () ;
						}
					}
					catch ( Wmi_Heap_Exception &a_Exception )
					{
						t_Result = WBEM_E_OUT_OF_MEMORY ;
					}
					catch ( ... )
					{
						t_Result = WBEM_E_CRITICAL_ERROR ;
					}
				}

				t_Sink->Release () ;
			}
			else
			{
				t_Result = WBEM_E_OUT_OF_MEMORY ;
			}
		}
	}
	else
	{
		t_Result = WBEM_E_INVALID_CLASS ;
	}

	if ( FAILED ( t_Result ) )
	{
		if ( ( HRESULT_ERROR_FUNC(t_Result) == HRESULT_ERROR_SERVER_UNAVAILABLE ) || ( HRESULT_ERROR_FUNC(t_Result) == HRESULT_ERROR_CALL_FAILED_DNE ) || ( t_Result == RPC_E_DISCONNECTED ))
		{
			AbnormalShutdown () ;
		}
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_IWbemProvider :: Query (

	IWbemServices *a_Service ,
	long a_Flags ,
	IWbemContext *a_Context ,
	WBEM_PROVIDER_CONFIGURATION_CLASS_ID a_ClassIdentifier ,
	WBEM_PROVIDER_CONFIGURATION_PROPERTY_ID a_PropertyIdentifier ,
	VARIANT *a_Value 
)
{
	if ( m_Initialized == 0 )
	{
		HRESULT t_Result = WBEM_E_INVALID_PROPERTY ;

		if ( a_ClassIdentifier == WBEM_PROVIDER_CONFIGURATION_CLASS_ID_INSTANCE_PROVIDER_REGISTRATION ) 
		{
			if ( a_PropertyIdentifier == WBEM_PROVIDER_CONFIGURATION_PROPERTY_ID_EXTENDEDQUERY_SUPPORT )
			{
				a_Value->vt = VT_BOOL ;
				a_Value->boolVal = VARIANT_FALSE ;

				t_Result = S_OK ;
			}
		}

		return t_Result ;
	}

	_DBG_ASSERT(SUCCEEDED(m_InitializeResult));
	HRESULT t_Result = m_Provider__IWmiProviderConfiguration->Query (

		a_Service ,
		a_Flags ,
		a_Context ,
		a_ClassIdentifier ,
		a_PropertyIdentifier ,
		a_Value 
	) ;

	if ( FAILED ( t_Result ) )
	{
		if ( ( HRESULT_ERROR_FUNC(t_Result) == HRESULT_ERROR_SERVER_UNAVAILABLE ) || ( HRESULT_ERROR_FUNC(t_Result) == HRESULT_ERROR_CALL_FAILED_DNE ) || ( t_Result == RPC_E_DISCONNECTED ))
		{
			AbnormalShutdown () ;
		}
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_IWbemProvider :: AbnormalShutdown ()
{
	HRESULT t_Result = S_OK ;

	Lock () ;

	BOOL t_Cached = ServiceCacheElement :: GetCached () ;

	CWbemGlobal_IWmiObjectSinkController_Container *t_Container = NULL ;
	GetContainer ( t_Container ) ;

	IWbemShutdown **t_ShutdownElements = new IWbemShutdown * [ t_Container->Size () ] ;
	if ( t_ShutdownElements )
	{
		CWbemGlobal_IWmiObjectSinkController_Container_Iterator t_Iterator = t_Container->Begin ();

		ULONG t_Count = 0 ;
		while ( ! t_Iterator.Null () )
		{
			t_Result = t_Iterator.GetElement ()->QueryInterface ( IID_IWbemShutdown , ( void ** ) & t_ShutdownElements [ t_Count ] ) ;

			t_Iterator.Increment () ;

			t_Count ++ ;
		}

		UnLock () ;

		for ( ULONG t_Index = 0 ; t_Index < t_Count ; t_Index ++ )
		{
			if ( t_ShutdownElements [ t_Index ] ) 
			{
				t_Result = t_ShutdownElements [ t_Index ]->Shutdown ( 

					0 ,
					0 ,
					NULL
				) ;

				t_ShutdownElements [ t_Index ]->Release () ;
			}
		}

		delete [] t_ShutdownElements ;
	}
	else
	{	
		UnLock () ;

		t_Result = WBEM_E_OUT_OF_MEMORY ;
	}

	CWbemGlobal_IWmiObjectSinkController :: Shutdown () ;

	CWbemGlobal_IWmiProviderController *t_Controller = ServiceCacheElement :: GetController () ;
	if ( t_Controller )
	{
		t_Controller->Shutdown ( ServiceCacheElement :: GetKey () ) ;
	}

	if ( t_Cached )
	{
		t_Result = ForceReload () ;
	}


	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_IWbemProvider :: Expel (

	long a_Flags ,
	IWbemContext *a_Context
)
{
	HRESULT t_Result = S_OK ;

	CWbemGlobal_IWmiProviderController *t_Controller = ServiceCacheElement :: GetController () ;
	if ( t_Controller )
	{
		t_Controller->Shutdown ( ServiceCacheElement :: GetKey () ) ;
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_IWbemProvider :: Violation (

	long a_Flags ,
	IWbemContext *a_Context ,
	IWbemClassObject *a_Object	
)
{
	HRESULT t_Result = S_OK ;

	t_Result = AbnormalShutdown () ;

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_IWbemProvider :: Shutdown (

	LONG a_Flags ,
	ULONG a_MaxMilliSeconds ,
	IWbemContext *a_Context
)
{
	HRESULT t_Result = S_OK ;

	IWbemShutdown *t_Shutdown = NULL ;

	if ( m_Unknown )
	{
		t_Result = m_Unknown->QueryInterface ( IID_IWbemShutdown , ( void ** ) & t_Shutdown ) ;
		if ( SUCCEEDED ( t_Result ) ) 
		{
			t_Result = t_Shutdown->Shutdown (

				a_Flags ,
				a_MaxMilliSeconds ,
				a_Context
			) ;

			t_Shutdown->Release () ;
		}
	}

	Lock () ;

	CWbemGlobal_IWmiObjectSinkController_Container *t_Container = NULL ;
	GetContainer ( t_Container ) ;

    LONG t_Size = t_Container->Size ();
	IWbemShutdown **t_ShutdownElements = new IWbemShutdown * [ t_Size ] ;
	if ( t_ShutdownElements )
	{
        //DBG_PRINTFA((pBuff,"WINMGMT:CInterceptor_IWbemProvider %p sinks %d\n",this,t_Size));
	   
		CWbemGlobal_IWmiObjectSinkController_Container_Iterator t_Iterator = t_Container->Begin ();

		ULONG t_Count = 0 ;
		while ( ! t_Iterator.Null () )
		{
			t_Result = t_Iterator.GetElement ()->QueryInterface ( IID_IWbemShutdown , ( void ** ) & t_ShutdownElements [ t_Count ] ) ;

			t_Iterator.Increment () ;

			t_Count ++ ;
		}

		UnLock () ;

		for ( ULONG t_Index = 0 ; t_Index < t_Count ; t_Index ++ )
		{
			if ( t_ShutdownElements [ t_Index ] ) 
			{
			    CoDisconnectObject( t_ShutdownElements [ t_Index ] , 0);
			    
				t_Result = t_ShutdownElements [ t_Index ]->Shutdown ( 

					a_Flags ,
					a_MaxMilliSeconds ,
					a_Context
				) ;

				t_ShutdownElements [ t_Index ]->Release () ;
			}
		}

		delete [] t_ShutdownElements ;
	}
	else
	{	
		UnLock () ;

		t_Result = WBEM_E_OUT_OF_MEMORY ;
	}

	CWbemGlobal_IWmiObjectSinkController :: Shutdown () ;
	
	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_IWbemProvider :: ForceReload ()
{
	HRESULT t_Result = ProviderSubSystem_Globals :: ForwardReload ( 

		_IWMIPROVSSSINK_FLAGS_RELOAD , 
		NULL ,
		m_Namespace ,
		ServiceCacheElement :: GetKey ().m_Provider
	) ;

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_IWbemProvider  :: Unload (

	long a_Flags ,
	IWbemContext *a_Context
)
{
	ProviderSubSystem_Globals :: InsertGuidTag ( m_Registration->GetClsid () ) ;

	HRESULT t_Result = Shutdown (

		0 ,
		0 ,
		a_Context
	) ;

	t_Result = ProviderSubSystem_Globals :: ForwardReload ( 

		_IWMIPROVSSSINK_FLAGS_UNLOAD , 
		NULL ,
		m_Namespace ,
		ServiceCacheElement :: GetKey ().m_Provider
	) ;

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_IWbemProvider  :: Load (

	long a_Flags ,
	IWbemContext *a_Context
)
{
	HRESULT t_Result = ProviderSubSystem_Globals :: ForwardReload ( 

		_IWMIPROVSSSINK_FLAGS_LOAD , 
		NULL ,
		m_Namespace ,
		ServiceCacheElement :: GetKey ().m_Provider
	) ;

	return t_Result ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\winmgmt\provsubsys\server\exe\makefile.inc ===
!INCLUDE $(_NTDRIVE)$(_NTROOT)\WMI\COMMON\makefile.cmn
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\winmgmt\provsubsys\server\sources.inc ===
############################################################################
#
#   Copyright (C) 1999, Microsoft Corporation.
#
#   All rights reserved.
#
############################################################################

WMIUNICODE=1
WMIPRECOMPSHARED=1
!include $(PROJECT_ROOT)\wmi\wbem\common\makefile.cmn
SOURCES_USED=$(PROJECT_ROOT)\wmi\wbem\common\makefile.cmn

TARGETPATH=obj
	
C_DEFINES=$(C_DEFINES) /D_WIN32_DCOM
# /DDEV_BUILD
USE_NATIVE_EH=ASYNC
USE_RTTI=1
USE_MSVCRT=1
USE_VCCOM=1
USE_STL=1

# The TARGETLIBS macro specifies additional libraries to link against your target
# image. Each library path specification should contain an asterisk (*)
# where the machine-specific subdirectory name should go.
TARGETLIBS= \
	$(SDK_LIB_PATH)\ntdll.lib \
	$(WBEMINT_LIB) \
	$(WMIIDL_LIB) \
	$(WBEMCOMN_DLL_LIB) \
	$(COREPROX_LIB) \
	$(STDLIBRARY_LIB) \
	$(NCOBJAPI_LIB) \
	$(SDK_LIB_PATH)\kernel32.lib \
	$(SDK_LIB_PATH)\advapi32.lib \
	$(SDK_LIB_PATH)\user32.lib \
	$(SDK_LIB_PATH)\oleaut32.lib \
	$(SDK_LIB_PATH)\ole32.lib \
	$(SDK_LIB_PATH)\rpcrt4.lib \
	$(SDK_LIB_PATH)\uuid.lib \
	$(SDK_LIB_PATH)\secur32.lib


LINKLIBS= \
	$(WBEMPRV_COMN_LIB)\

# The INCLUDES variable specifies any include paths that are specific to
# this source directory. Separate multiple paths with single
# semicolons. Relative path specifications are okay.
INCLUDES=$(INCLUDES); \
	$(CONTAINER_INC); \
	$(CONTAINER_SRC); \
	$(NC_COMMON); \
	$(WBEMINT_INC);\
	$(WMIREPOSITIDL_INC); \
	$(WBEMCORE_INC); \
	$(MC_INC); \
	$(STDLIBRARY_INC); \
	$(COREPROX_INC); \
	$(WBEMCOMN_INC); \
	$(WBEMPRV_COMN_INC);\
	$(WBEMPSSSERVER_INC); \

SOURCES=$(XSOURCES) \
	..\Globals.cpp \
	..\maindll.cpp \
	..\ProvHost.cpp \
	..\ProvSubS.cpp \
	..\ProvFact.cpp \
	..\ProvCntrs.cpp \
	..\ProvSelf.cpp \
	..\ProvDWsv.cpp \
	..\ProvWsv.cpp \
	..\ProvWsvS.cpp \
	..\ProvsWsv.cpp \
	..\ProvObSk.cpp \
	..\ProvInSk.cpp \
	..\ProvAggr.cpp \
	..\ProvLoad.cpp \
	..\StaThread.cpp \
	..\StaTask.cpp \
	..\ProvResv.cpp \
	..\StrobeThread.cpp \
	..\ProvCache.cpp \
	..\ProvRMgr.cpp \
	..\ProvDcAggr.cpp \
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\winmgmt\provsubsys\server\statask.cpp ===
/*++

Copyright (C) 1996-2001 Microsoft Corporation

Module Name:

	ProvFact.cpp

Abstract:


History:

--*/

#include "PreComp.h"
#include <wbemint.h>
#include <NCObjApi.h>

#include "Globals.h"
#include "CGlobals.h"
#include "ProvLoad.h"
#include "ProvRegInfo.h"
#include "ProvObSk.h"
#include "ProvInSk.h"
#include "StaThread.h"
#include "StaTask.h"

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

StaTask_Create :: StaTask_Create (

	WmiAllocator &a_Allocator ,
	CServerObject_StaThread &a_Thread ,
	LPCWSTR a_Scope ,
	LPCWSTR a_Namespace 

) : WmiTask < ULONG > ( a_Allocator ) ,
	m_Thread ( a_Thread ) ,
	m_Scope ( NULL ) ,
	m_Namespace ( NULL ) ,
	m_ContextStream ( NULL ) ,
	m_RepositoryStream ( NULL ) ,
	m_ProviderStream ( NULL ) 
{
	InterlockedIncrement ( & ProviderSubSystem_Globals :: s_StaTask_Create_ObjectsInProgress ) ;

	ProviderSubSystem_Globals :: Increment_Global_Object_Count () ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

StaTask_Create :: ~StaTask_Create ()
{
	if ( m_Namespace ) 
	{
		delete [] m_Namespace ;
	}

	if ( m_Scope ) 
	{
		delete [] m_Scope ;
	}

	if ( m_ContextStream ) 
	{
		m_ContextStream->Release () ;
	}

	if ( m_RepositoryStream ) 
	{
		m_RepositoryStream->Release () ;
	}

	if ( m_ProviderStream ) 
	{
		m_ProviderStream->Release () ;
	}

	InterlockedDecrement ( & ProviderSubSystem_Globals :: s_StaTask_Create_ObjectsInProgress ) ;

	ProviderSubSystem_Globals :: Decrement_Global_Object_Count () ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT StaTask_Create :: MarshalContext (

	IWbemContext *a_Context ,
	IWbemServices *a_Repository
)
{
	HRESULT t_Result = S_OK ;

/* 
 *	Marshal interfaces here, so that we can pass an STA proxy.
 */

	if ( a_Context )
	{
		t_Result = CoMarshalInterThreadInterfaceInStream ( 

			IID_IWbemContext , 
			a_Context , 
			& m_ContextStream 
		) ;
	}

	if ( SUCCEEDED ( t_Result ) )
	{
		if ( a_Repository ) 
		{
			t_Result = CoMarshalInterThreadInterfaceInStream ( 

				IID_IWbemServices , 
				a_Repository , 
				& m_RepositoryStream
			) ;
		}
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT StaTask_Create :: UnMarshalContext ()
{
	HRESULT t_Result = S_OK ;

	IWbemContext *t_Context = NULL ;
	IWbemServices *t_Repository = NULL ;

	if ( m_ContextStream )
	{
		t_Result = CoGetInterfaceAndReleaseStream ( 

			m_ContextStream , 
			IID_IWbemContext , 
			( void ** ) & t_Context 
		) ;

		m_ContextStream = NULL ;
	}

	if ( SUCCEEDED ( t_Result ) )
	{
		if ( m_RepositoryStream ) 
		{
			t_Result = CoGetInterfaceAndReleaseStream ( 

				m_RepositoryStream , 
				IID_IWbemServices , 
				( void ** ) & t_Repository
			) ;

			m_RepositoryStream = NULL ;
		}
	}

	if ( t_Context ) 
	{
		m_Thread.SetContext ( t_Context ) ;
		t_Context->Release () ;
	}

	if ( t_Repository ) 
	{
		m_Thread.SetRepository ( t_Repository ) ;
		t_Repository->Release () ;
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT StaTask_Create :: MarshalOutgoing (

	IUnknown *a_ProviderService
)
{
	HRESULT t_Result = S_OK ;

/* 
 *	Marshal interfaces here, so that we can pass an STA proxy.
 */

	if ( a_ProviderService )
	{
		t_Result = CoMarshalInterThreadInterfaceInStream ( 

			IID_IUnknown , 
			a_ProviderService , 
			& m_ProviderStream 
		) ;
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT StaTask_Create :: UnMarshalOutgoing ()
{
	HRESULT t_Result = S_OK ;

	IUnknown *t_ProviderService = NULL ;

	if ( m_ProviderStream )
	{
		t_Result = CoGetInterfaceAndReleaseStream ( 

			m_ProviderStream , 
			IID_IUnknown , 
			( void ** ) &t_ProviderService
		) ;

		m_ProviderStream = NULL ;

		if ( SUCCEEDED ( t_Result ) ) 
		{
			m_Thread.SetProviderService ( t_ProviderService ) ;
			t_ProviderService->Release () ;
		}
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

WmiStatusCode StaTask_Create :: Process ( WmiThread <ULONG > &a_Thread )
{
	m_Result = S_OK ;

	wchar_t t_TransactionIdentifier [ sizeof ( L"{00000000-0000-0000-0000-000000000000}" ) ] ;

	if ( m_Thread.Direct_GetTransactionIdentifier () )
	{
		StringFromGUID2 ( *m_Thread.Direct_GetTransactionIdentifier () , t_TransactionIdentifier , sizeof ( t_TransactionIdentifier ) / sizeof ( wchar_t ) );
	}

	IUnknown *t_ProviderInterface = NULL ;

	m_Result = UnMarshalContext () ;
	if ( SUCCEEDED ( m_Result ) )
	{
		wchar_t *t_NamespacePath = NULL ;

		m_Result = ProviderSubSystem_Common_Globals :: GetNamespacePath ( 

			m_Thread.Direct_GetNamespacePath () , 
			t_NamespacePath
		) ;

		if ( SUCCEEDED ( m_Result ) )
		{
			CServerObject_ProviderRegistrationV1 *t_Registration = new CServerObject_ProviderRegistrationV1 ;
			if ( t_Registration )
			{
				t_Registration->AddRef () ;

				m_Result = t_Registration->SetContext ( 

					m_Thread.Direct_GetContext () ,
					m_Thread.Direct_GetNamespacePath () , 
					m_Thread.Direct_GetRepository ()
				) ;
				
				if ( SUCCEEDED ( m_Result ) )
				{
					t_Registration->SetUnloadTimeoutMilliSeconds ( ProviderSubSystem_Globals :: s_ObjectCacheTimeout ) ;

					m_Result = t_Registration->Load ( 

						e_All ,
						NULL , 
						m_Thread.Direct_GetProviderName () 
					) ;

					if ( SUCCEEDED ( m_Result ) )
					{
						m_Result = CServerObject_RawFactory :: CreateServerSide ( 

							*t_Registration ,
							NULL ,
							NULL ,
							NULL ,
							t_NamespacePath ,
							& t_ProviderInterface
						) ;

						if ( SUCCEEDED ( m_Result ) )
						{
							IUnknown *t_ProviderService = NULL ;
							m_Result = t_ProviderInterface->QueryInterface ( IID_IUnknown , ( void ** ) & t_ProviderService ) ;
							if ( SUCCEEDED ( m_Result ) )
							{
								MarshalOutgoing ( t_ProviderService ) ;

								t_ProviderService->Release () ;
							}

							t_ProviderInterface->Release () ;
						}
					}
				}

				t_Registration->Release () ;
			}

			delete [] t_NamespacePath ;
		}
		else
		{
			m_Result = WBEM_E_OUT_OF_MEMORY ;
		}
	}

	Complete () ;
	return e_StatusCode_Success ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\winmgmt\provsubsys\server\strobethread.cpp ===
/*++

Copyright (C) 1996-2001 Microsoft Corporation

Module Name:

	ProvFact.cpp

Abstract:


History:

--*/

#include "PreComp.h"
#include <wbemint.h>

#include "Globals.h"
#include "CGlobals.h"
#include "ProvSubS.h"
#include "Guids.h"
#include "StrobeThread.h"
#include "ProvCache.h"
#include "ProvHost.h"
#include "ProvWsv.h"


StrobeThread :: StrobeThread (WmiAllocator &a_Allocator , DWORD timeout) :
	m_Allocator ( a_Allocator ), timeout_(timeout)
{
	InterlockedIncrement ( & ProviderSubSystem_Globals :: s_StrobeThread_ObjectsInProgress ) ;
}

StrobeThread::~StrobeThread ()
{
	CWbemGlobal_IWmiProvSubSysController *t_ProvSubSysController = ProviderSubSystem_Globals :: GetProvSubSysController () ;
	t_ProvSubSysController->Shutdown () ;

	InterlockedDecrement ( & ProviderSubSystem_Globals :: s_StrobeThread_ObjectsInProgress ) ;
}

int  StrobeThread :: handleTimeout ()
{
	CoInitializeEx ( NULL , COINIT_MULTITHREADED ) ;
	ULONG t_NextStrobeDelta = 0xFFFFFFFF ;
	try 
	{
		CWbemGlobal_IWbemRefresherMgrController *t_RefresherManagerController = ProviderSubSystem_Globals :: GetRefresherManagerController () ;
		t_RefresherManagerController->Strobe ( t_NextStrobeDelta ) ;

		CWbemGlobal_IWmiHostController *t_HostController = ProviderSubSystem_Globals :: GetHostController () ;
		t_HostController->Strobe ( t_NextStrobeDelta ) ;

		CWbemGlobal_IWmiProvSubSysController *t_ProvSubSysController = ProviderSubSystem_Globals :: GetProvSubSysController () ;

		CWbemGlobal_IWmiProvSubSysController_Container *t_Container = NULL ;
		WmiStatusCode t_StatusCode = t_ProvSubSysController->GetContainer ( t_Container ) ;

		t_ProvSubSysController->Lock () ;

		CWbemGlobal_IWmiFactoryController **t_ShutdownElements = new CWbemGlobal_IWmiFactoryController * [ t_Container->Size () ] ;
		if ( t_ShutdownElements )
		{
			CWbemGlobal_IWmiProvSubSysController_Container_Iterator t_Iterator = t_Container->Begin () ;

			ULONG t_Count = 0 ;
			while ( ! t_Iterator.Null () )
			{
				CWbemGlobal_IWmiFactoryController *t_FactoryController = NULL ;
				ProvSubSysContainerElement *t_Element = t_Iterator.GetElement () ;

				HRESULT t_Result = t_Element->QueryInterface ( IID_CWbemGlobal_IWmiFactoryController , ( void ** ) & t_ShutdownElements [ t_Count ] ) ;

				t_Iterator.Increment () ;

				t_Count ++ ;
			}

			t_ProvSubSysController->UnLock () ;

			for ( ULONG t_Index = 0 ; t_Index < t_Count ; t_Index ++ )
			{
				if ( t_ShutdownElements [ t_Index ] ) 
				{
					t_ShutdownElements [ t_Index ]->Strobe ( t_NextStrobeDelta ) ;

					t_ShutdownElements [ t_Index ]->Release () ;
				}
			}

			delete [] t_ShutdownElements ;
		}
		else
		{
			t_ProvSubSysController->UnLock () ;
		}
	}
	catch ( ... )
	{
	}

	Dispatcher::changeTimer(*this, t_NextStrobeDelta);

	CoUninitialize () ;

	return 0 ;
}



Task_ProcessTermination :: Task_ProcessTermination (

	WmiAllocator &a_Allocator ,
	HANDLE a_Process ,
	DWORD a_ProcessIdentifier 

):	m_ProcessIdentifier ( a_ProcessIdentifier ),
	processHandle_(a_Process)
{
	
}

Task_ProcessTermination::~Task_ProcessTermination()	
{
	CloseHandle(processHandle_);
}

HANDLE Task_ProcessTermination::getHandle()	
{
	return processHandle_;
}

int Task_ProcessTermination::handleEvent()	
{
	try
	{

 
//	Discard entities in host.
 

		CWbemGlobal_HostedProviderController *t_Controller = ProviderSubSystem_Globals :: GetHostedProviderController () ;

		t_Controller->Lock () ;

		CWbemGlobal_HostedProviderController_Container_Iterator t_Iterator ;

		WmiStatusCode t_StatusCode = t_Controller->Find ( m_ProcessIdentifier , t_Iterator ) ;
		switch ( t_StatusCode )
		{
			case e_StatusCode_Success:
			{
				HostedProviderContainerElement *t_Element = t_Iterator.GetElement () ;

				t_StatusCode = t_Controller->Delete ( m_ProcessIdentifier ) ;

				t_Controller->UnLock () ;

				ProviderController *t_ProviderController = NULL ;
				HRESULT t_Result = t_Element->QueryInterface ( IID_ProviderController , ( void ** ) & t_ProviderController ) ;
				if ( SUCCEEDED ( t_Result ) ) 
				{
					t_ProviderController->Lock () ;

					ProviderController :: Container *t_Container = NULL ;

					t_StatusCode = t_ProviderController->GetContainer ( t_Container ) ;

					CInterceptor_IWbemProvider **t_InterceptorElements = new CInterceptor_IWbemProvider * [ t_Container->Size () ] ;
					if ( t_InterceptorElements )
					{
						ProviderController :: Container_Iterator t_Iterator = t_Container->Begin () ;
		
						ULONG t_Count = 0 ;
						while ( ! t_Iterator.Null () )
						{
							t_InterceptorElements [ t_Count ] = t_Iterator.GetElement ();
							
							t_ProviderController->Delete ( t_Iterator.GetKey () ) ;

							t_Iterator = t_Container->Begin () ;

							t_Count ++ ;
						}

						t_ProviderController->UnLock () ;

						for ( ULONG t_Index = 0 ; t_Index < t_Count ; t_Index ++ )
						{
							if ( t_InterceptorElements [ t_Index ] ) 
							{
								t_Result = t_InterceptorElements [ t_Index ]->AbnormalShutdown () ;

								t_InterceptorElements [ t_Index ]->NonCyclicRelease () ;
							}
						}

						delete [] t_InterceptorElements ;
					}
					else
					{
						t_ProviderController->UnLock () ;
					}

					t_ProviderController->Release () ;
				}

				t_Element->Release () ;
			}
			break ;
		
			default:
			{
				t_Controller->UnLock () ;
			}
			break ;
		}

 
//	Discard of host.
 

		CWbemGlobal_IWmiHostController_Cache *t_Cache = NULL ;
		ProviderSubSystem_Globals :: GetHostController ()->GetCache ( t_Cache ) ;

		ProviderSubSystem_Globals :: GetHostController ()->Lock () ;

		ULONG t_Count = 0 ;
		CServerObject_HostInterceptor **t_InterceptorElements = new CServerObject_HostInterceptor * [ t_Cache->Size () ] ;
		if ( t_InterceptorElements )
		{
			CWbemGlobal_IWmiHostController_Cache_Iterator t_HostIterator = t_Cache->Begin () ;
			while ( ! t_HostIterator.Null () )
			{
				HostCacheElement *t_Element = t_HostIterator.GetElement () ;

				t_InterceptorElements [ t_Count ] = NULL ;

				HRESULT t_Result = t_Element->QueryInterface (

					IID_CServerObject_HostInterceptor ,
					( void ** ) & t_InterceptorElements [ t_Count ] 
				) ;

				t_HostIterator.Increment () ;

				t_Count ++ ;
			}
		}

		ProviderSubSystem_Globals :: GetHostController ()->UnLock () ;

		if ( t_InterceptorElements )
		{
			for ( ULONG t_Index = 0 ; t_Index < t_Count ; t_Index ++ )
			{
				if ( t_InterceptorElements [ t_Index ] ) 
				{
					if ( t_InterceptorElements [ t_Index ]->GetProcessIdentifier () == m_ProcessIdentifier )
					{
						ProviderSubSystem_Globals :: GetHostController ()->Shutdown ( t_InterceptorElements [ t_Index ]->GetKey () ) ; 
					}

					t_InterceptorElements [ t_Index ]->Release () ;
				}
			}

			delete [] t_InterceptorElements ;
		}
	}
	catch ( ... )
	{
	}

	return -1;	// remove from queue
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\winmgmt\provsubsys\server\stathread.cpp ===
/*++

Copyright (C) 1996-2001 Microsoft Corporation

Module Name:

	ProvFact.cpp

Abstract:


History:

--*/

#include "PreComp.h"
#include <wbemint.h>
#include <NCObjApi.h>

#include "Globals.h"
#include "CGlobals.h"
#include "ProvRegInfo.h"
#include "ProvObSk.h"
#include "ProvInSk.h"
#include "StaThread.h"
#include "StaTask.h"

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

WmiStatusCode CServerObject_StaThread :: Initialize_Callback ()
{
	CoInitializeEx ( NULL , COINIT_APARTMENTTHREADED ) ;

	return e_StatusCode_Success ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

WmiStatusCode CServerObject_StaThread :: UnInitialize_Callback () 
{
	if ( m_User == NULL )
	{
		SysFreeString ( m_User ) ;
	}

	if ( m_Locale == NULL )
	{
		SysFreeString ( m_Locale ) ;
	}

	if ( m_Scope ) 
	{
		delete [] m_Scope ;
	}

	if ( m_Namespace ) 
	{
		delete [] m_Namespace ;
	}

	if ( m_NamespacePath ) 
	{
		m_NamespacePath->Release() ;
	}
		
	if ( m_Context ) 
	{
		m_Context->Release () ;
	}

	if ( m_Repository ) 
	{
		m_Repository->Release () ;
	}

	CWbemGlobal_IWmiObjectSinkController :: UnInitialize () ;

	CoUninitialize () ;

	return e_StatusCode_Success ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

void CServerObject_StaThread :: CallBackRelease ()
{
	if ( m_Provider_IUnknown )
	{
		m_Provider_IUnknown->Release () ;
		m_Provider_IUnknown = NULL ;
	}

	if ( m_Provider_IWbemServices )
	{
		m_Provider_IWbemServices->Release () ; 
		m_Provider_IWbemServices = NULL ;
	}

	if ( m_Provider_IWbemEventConsumerProvider )
	{
		m_Provider_IWbemEventConsumerProvider->Release () ;
		m_Provider_IWbemEventConsumerProvider = NULL ;
	}

	if ( m_Provider_IWbemEventConsumerProviderEx )
	{
		m_Provider_IWbemEventConsumerProviderEx->Release () ;
		m_Provider_IWbemEventConsumerProviderEx= NULL ;
	}

	if ( m_Provider_IWbemUnboundObjectSink )
	{
		m_Provider_IWbemUnboundObjectSink->Release () ;
		m_Provider_IWbemUnboundObjectSink = NULL ;
	}

	if ( m_Provider_IWbemEventProvider )
	{
		m_Provider_IWbemEventProvider->Release () ; 
		m_Provider_IWbemEventProvider = NULL ;
	}

	if ( m_Provider_IWbemEventProviderQuerySink )
	{
		m_Provider_IWbemEventProviderQuerySink->Release () ;
		m_Provider_IWbemEventProviderQuerySink = NULL ;
	}

	if ( m_Provider_IWbemEventProviderSecurity )
	{
		m_Provider_IWbemEventProviderSecurity->Release () ;
		m_Provider_IWbemEventProviderSecurity = NULL ;
	}

	WmiStatusCode t_StatusCode = m_ProxyContainer.UnInitialize () ;
}

#pragma warning( disable : 4355 )

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

CServerObject_StaThread :: CServerObject_StaThread (

	WmiAllocator &a_Allocator,
	CServerObject_ProviderRegistrationV1& a_Registration

) : WmiThread < ULONG > ( a_Allocator ) ,
	CWbemGlobal_IWmiObjectSinkController ( a_Allocator ) ,
	m_Allocator ( a_Allocator ) ,
	m_Flags ( 0 ) ,
	m_Context ( NULL ) ,
	m_TransactionIdentifier ( NULL ) ,
	m_User ( NULL ) ,
	m_Namespace ( NULL ) ,
	m_NamespacePath ( NULL ),	
	m_Repository ( NULL ) ,
	m_Provider_IUnknown ( NULL ) ,
	m_Provider_IWbemServices ( NULL ) ,
	m_Provider_IWbemEventConsumerProvider ( NULL ) ,
	m_Provider_IWbemEventConsumerProviderEx ( NULL ) ,
	m_Provider_IWbemUnboundObjectSink ( NULL ) ,
	m_Provider_IWbemEventProvider ( NULL ) ,
	m_Provider_IWbemEventProviderQuerySink ( NULL ) ,
	m_Provider_IWbemEventProviderSecurity ( NULL ) ,
	m_ProviderName ( NULL ) ,
	m_ProxyContainer ( a_Allocator , ProxyIndex_Sta_Size , MAX_PROXIES ),
	m_Registration(&a_Registration)
	
{
	m_Registration->AddRef();
	SetStackSize ( ProviderSubSystem_Common_Globals :: GetDefaultStackSize () ) ;

	InterlockedIncrement ( & ProviderSubSystem_Globals :: s_CServerObject_StaThread_ObjectsInProgress ) ;

	ProviderSubSystem_Globals :: Increment_Global_Object_Count () ;
}

#pragma warning( default : 4355 )

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

CServerObject_StaThread::~CServerObject_StaThread ()
{
	InterlockedDecrement ( & ProviderSubSystem_Globals :: s_CServerObject_StaThread_ObjectsInProgress ) ;

	ProviderSubSystem_Globals :: Decrement_Global_Object_Count () ;
	m_Registration->Release();
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CServerObject_StaThread :: SetContext ( IWbemContext *a_Context )
{
	HRESULT t_Result = S_OK ;

	if ( a_Context ) 
	{
		m_Context = a_Context ;
		m_Context->AddRef () ;
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CServerObject_StaThread :: SetScope ( LPCWSTR a_Scope )
{
	HRESULT t_Result = S_OK ;

	if ( a_Scope ) 
	{
		m_Scope = DupString( a_Scope ) ;
		if ( m_Scope == 0)
		{
			t_Result = WBEM_E_OUT_OF_MEMORY ;
		}
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CServerObject_StaThread :: SetNamespace ( LPCWSTR a_Namespace )
{
	HRESULT t_Result = S_OK ;

	if ( a_Namespace ) 
	{
		m_Namespace = DupString ( a_Namespace );
		if ( m_Namespace == 0)
		{
			t_Result = WBEM_E_OUT_OF_MEMORY ;
		}
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CServerObject_StaThread :: SetNamespacePath ( IWbemPath *a_NamespacePath )
{
	HRESULT t_Result = S_OK ;

	if ( a_NamespacePath ) 
	{
		m_NamespacePath = a_NamespacePath ;
		m_NamespacePath->AddRef () ;
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CServerObject_StaThread :: SetRepository ( IWbemServices *a_Repository )
{
	HRESULT t_Result = S_OK ;

	if ( a_Repository ) 
	{
		m_Repository = a_Repository ;
		m_Repository->AddRef () ;
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CServerObject_StaThread :: SetProviderService ( IUnknown *a_ProviderService ) 
{
	HRESULT t_Result = S_OK ;

	if ( a_ProviderService ) 
	{
		m_Provider_IUnknown = a_ProviderService ;
		m_Provider_IUnknown->AddRef () ;

		HRESULT t_TempResult = a_ProviderService->QueryInterface ( IID_IWbemServices , ( void ** ) & m_Provider_IWbemServices ) ;
		if ( t_TempResult != E_NOINTERFACE )
		{
			t_Result = t_TempResult ;
		}
	
		if ( SUCCEEDED ( t_Result ) )
		{
			t_TempResult = a_ProviderService->QueryInterface ( IID_IWbemEventConsumerProvider , ( void ** ) & m_Provider_IWbemEventConsumerProvider ) ;
			if ( t_TempResult != E_NOINTERFACE )
			{
				t_Result = t_TempResult ;
			}
		}

		if ( SUCCEEDED ( t_Result ) )
		{
			t_TempResult = a_ProviderService->QueryInterface ( IID_IWbemEventConsumerProviderEx , ( void ** ) & m_Provider_IWbemEventConsumerProviderEx ) ;
			if ( t_TempResult != E_NOINTERFACE )
			{
				t_Result = t_TempResult ;
			}
		}

		if ( SUCCEEDED ( t_Result ) )
		{
			t_TempResult = a_ProviderService->QueryInterface ( IID_IWbemUnboundObjectSink , ( void ** ) & m_Provider_IWbemUnboundObjectSink ) ;
			if ( t_TempResult != E_NOINTERFACE )
			{
				t_Result = t_TempResult ;
			}
		}

		if ( SUCCEEDED ( t_Result ) )
		{
			t_TempResult = a_ProviderService->QueryInterface ( IID_IWbemEventProvider , ( void ** ) & m_Provider_IWbemEventProvider ) ;
			if ( t_TempResult != E_NOINTERFACE )
			{
				t_Result = t_TempResult ;
			}
		}

		if ( SUCCEEDED ( t_Result ) )
		{
			t_TempResult = a_ProviderService->QueryInterface ( IID_IWbemEventProviderQuerySink , ( void ** ) & m_Provider_IWbemEventProviderQuerySink ) ;
			if ( t_TempResult != E_NOINTERFACE )
			{
				t_Result = t_TempResult ;
			}
		}

		if ( SUCCEEDED ( t_Result ) )
		{
			t_TempResult = a_ProviderService->QueryInterface ( IID_IWbemEventProviderSecurity , ( void ** ) & m_Provider_IWbemEventProviderSecurity ) ;
			if ( t_TempResult != E_NOINTERFACE )
			{
				t_Result = t_TempResult ;
			}
		}
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CServerObject_StaThread :: SetProviderName ( wchar_t *a_ProviderName ) 
{
	HRESULT t_Result = S_OK ;

	if ( m_ProviderName ) 
	{
		delete [] m_ProviderName ;
	}

	m_ProviderName = DupString ( a_ProviderName );
	if ( m_ProviderName == 0)
	{
		t_Result = WBEM_E_OUT_OF_MEMORY ;
	}
	
	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CServerObject_StaThread :: InitializeProvider (

	GUID *a_TransactionIdentifier ,
	LPCWSTR a_User ,
	LPCWSTR a_Locale ,
	LPCWSTR a_Namespace ,
	IWbemPath *a_NamespacePath ,
	IWbemServices *a_Repository ,
	LONG a_Flags ,
	IWbemContext *a_Context ,
	LPCWSTR a_Scope ,
	CServerObject_ProviderRegistrationV1 &a_Registration
) 
{
	HRESULT t_Result = S_OK ;

	wchar_t t_TransactionIdentifier [ sizeof ( L"{00000000-0000-0000-0000-000000000000}" ) ] ;

	if ( a_TransactionIdentifier )
	{
		StringFromGUID2 ( *a_TransactionIdentifier , t_TransactionIdentifier , sizeof ( t_TransactionIdentifier ) / sizeof ( wchar_t ) );
	}

	if ( a_Registration.GetEventProviderRegistration ().Supported () )
	{
		IWbemProviderIdentity *t_ProviderIdentity = NULL ;
		HRESULT t_TempResult = m_Provider_IUnknown->QueryInterface ( IID_IWbemProviderIdentity , ( void ** ) & t_ProviderIdentity ) ;
		if ( SUCCEEDED ( t_TempResult ) )
		{
			BOOL t_Impersonating = FALSE ;
			IUnknown *t_OldContext = NULL ;
			IServerSecurity *t_OldSecurity = NULL ;

			t_Result = ProviderSubSystem_Common_Globals :: BeginImpersonation ( t_OldContext , t_OldSecurity , t_Impersonating ) ;
			if ( SUCCEEDED ( t_Result ) )
			{
				BOOL t_Revert = FALSE ;
				IUnknown *t_Proxy = NULL ;

				t_Result = ProviderSubSystem_Common_Globals :: SetProxyState ( IID_IWbemProviderIdentity , t_ProviderIdentity , t_Proxy , t_Revert ) ;
				if ( t_Result == WBEM_E_NOT_FOUND )
				{
					try
					{
						t_Result = t_ProviderIdentity->SetRegistrationObject (

							0 ,
							a_Registration.GetIdentity () 
						) ;
					}
					catch ( ... )
					{
						t_Result = WBEM_E_PROVIDER_FAILURE ;
					}
				}
				else
				{
					if ( SUCCEEDED ( t_Result ) )
					{
						IWbemProviderIdentity *t_ProviderIdentityProxy = ( IWbemProviderIdentity * ) t_Proxy ;

						// Set cloaking on the proxy
						// =========================

						DWORD t_ImpersonationLevel = ProviderSubSystem_Common_Globals :: GetCurrentImpersonationLevel () ;

						t_Result = ProviderSubSystem_Common_Globals :: SetCloaking (

							t_ProviderIdentityProxy ,
							RPC_C_AUTHN_LEVEL_DEFAULT , 
							t_ImpersonationLevel
						) ;

						if ( SUCCEEDED ( t_Result ) )
						{
							t_Result = CoImpersonateClient () ;
							if ( SUCCEEDED ( t_Result ) )
							{
								try
								{
									t_Result = t_ProviderIdentityProxy->SetRegistrationObject (

										0 ,
										a_Registration.GetIdentity () 
									) ;
								}
								catch ( ... )
								{
									t_Result = WBEM_E_PROVIDER_FAILURE ;
								}

								CoRevertToSelf () ;
							}
							else
							{
								t_Result = WBEM_E_ACCESS_DENIED ;
							}
						}	

						HRESULT t_TempResult = ProviderSubSystem_Common_Globals :: RevertProxyState ( t_Proxy , t_Revert ) ;
					}
				}	

				ProviderSubSystem_Common_Globals :: EndImpersonation ( t_OldContext , t_OldSecurity , t_Impersonating ) ;
			}

			t_ProviderIdentity->Release () ;
		}
		else
		{
			if ( t_TempResult != E_NOINTERFACE )
			{
				t_Result = t_TempResult ;
			}
		}
	}

	if ( SUCCEEDED ( t_Result ) )
	{
		IWbemProviderInit *t_ProviderInit = NULL ;
		HRESULT t_TempResult = m_Provider_IUnknown->QueryInterface ( IID_IWbemProviderInit , ( void ** ) & t_ProviderInit ) ;
		if ( SUCCEEDED ( t_TempResult ) )
		{
			if ( a_Registration.GetComRegistration ().PerUserInitialization () && a_Registration.GetComRegistration ().InitializeAsAdminFirst () )
			{
				CServerObject_ProviderInitSink *t_ProviderInitSink = new CServerObject_ProviderInitSink ; 
				if ( t_ProviderInitSink )
				{
					t_ProviderInitSink->AddRef () ;

					t_Result = t_ProviderInitSink->SinkInitialize ( a_Registration.GetComRegistration ().GetSecurityDescriptor () ) ;
					if ( SUCCEEDED ( t_Result ) ) 
					{
						CInterceptor_IWbemProviderInitSink *t_Sink = new CInterceptor_IWbemProviderInitSink ( t_ProviderInitSink ) ;
						if ( t_Sink )
						{
							t_Sink->AddRef () ;

							BOOL t_Impersonating = FALSE ;
							IUnknown *t_OldContext = NULL ;
							IServerSecurity *t_OldSecurity = NULL ;

							t_Result = ProviderSubSystem_Common_Globals :: BeginImpersonation ( t_OldContext , t_OldSecurity , t_Impersonating ) ;
							if ( SUCCEEDED ( t_Result ) )
							{
								BOOL t_Revert = FALSE ;
								IUnknown *t_Proxy = NULL ;

								t_Result = ProviderSubSystem_Common_Globals :: SetProxyState ( IID_IWbemProviderInit , t_ProviderInit , t_Proxy , t_Revert ) ;
								if ( t_Result == WBEM_E_NOT_FOUND )
								{
									try
									{
										t_Result = t_ProviderInit->Initialize (

											NULL ,
											0 ,
											( const BSTR ) a_Namespace ,
											a_Registration.GetComRegistration ().PerLocaleInitialization () ? ( const BSTR ) a_Locale : NULL ,
											a_Repository ,
											a_Context ,
											t_Sink    
										) ;
									}
									catch ( ... )
									{
										t_Result = WBEM_E_PROVIDER_FAILURE ;
									}

									CoRevertToSelf () ;
								}
								else
								{
									if ( SUCCEEDED ( t_Result ) )
									{
										IWbemProviderInit *t_ProviderInitProxy = ( IWbemProviderInit * ) t_Proxy ;

										// Set cloaking on the proxy
										// =========================

										DWORD t_ImpersonationLevel = ProviderSubSystem_Common_Globals :: GetCurrentImpersonationLevel () ;

										t_Result = ProviderSubSystem_Common_Globals :: SetCloaking (

											t_ProviderInitProxy ,
											RPC_C_AUTHN_LEVEL_DEFAULT , 
											t_ImpersonationLevel
										) ;

										if ( SUCCEEDED ( t_Result ) )
										{
											t_Result = CoImpersonateClient () ;
											if ( SUCCEEDED ( t_Result ) )
											{
												try
												{
													t_Result = t_ProviderInitProxy->Initialize (

														NULL ,
														0 ,
														( const BSTR ) a_Namespace ,
														a_Registration.GetComRegistration ().PerLocaleInitialization () ? ( const BSTR ) a_Locale : NULL ,
														a_Repository ,
														a_Context ,
														t_Sink    
													) ;
												}
												catch ( ... )
												{
													t_Result = WBEM_E_PROVIDER_FAILURE ;
												}

												CoRevertToSelf () ;
											}
											else
											{
												t_Result = WBEM_E_ACCESS_DENIED ;
											}
										}	

										HRESULT t_TempResult = ProviderSubSystem_Common_Globals :: RevertProxyState ( t_Proxy , t_Revert ) ;
									}
								}

								if ( SUCCEEDED ( t_Result ) )
								{
									t_ProviderInitSink->Wait ( a_Registration.GetInitializationTimeoutMilliSeconds () ) ;
									t_Result = t_ProviderInitSink->GetResult () ;
								}

								if ( SUCCEEDED ( t_Result ) )
								{
									WmiSetAndCommitObject (

										ProviderSubSystem_Globals :: s_EventClassHandles [ Msft_WmiProvider_InitializationOperationEvent ] , 
										WMI_SENDCOMMIT_SET_NOT_REQUIRED,
										a_Namespace,
										a_Registration.GetComRegistration ().GetClsidServer ().GetProviderName () ,
										a_Registration.GetComRegistration ().PerUserInitialization () ? ( const BSTR ) a_User : NULL ,
										a_Registration.GetComRegistration ().PerLocaleInitialization () ? ( const BSTR ) a_Locale : NULL ,
										a_TransactionIdentifier ? t_TransactionIdentifier : NULL
									) ;
								}
								else
								{
									WmiSetAndCommitObject (

										ProviderSubSystem_Globals :: s_EventClassHandles [ Msft_WmiProvider_InitializationOperationFailureEvent ] , 
										WMI_SENDCOMMIT_SET_NOT_REQUIRED,
										a_Namespace,
										a_Registration.GetComRegistration ().GetClsidServer ().GetProviderName () ,
										a_Registration.GetComRegistration ().PerUserInitialization () ? ( const BSTR ) a_User : NULL ,
										a_Registration.GetComRegistration ().PerLocaleInitialization () ? ( const BSTR ) a_Locale : NULL ,
										a_TransactionIdentifier ? t_TransactionIdentifier : NULL ,
										t_Result 
									) ;

									t_Result = WBEM_E_PROVIDER_LOAD_FAILURE ;
								}

								ProviderSubSystem_Common_Globals :: EndImpersonation ( t_OldContext , t_OldSecurity , t_Impersonating ) ;
							}	

							t_Sink->Release () ;
						}
						else
						{
							t_Result = WBEM_E_OUT_OF_MEMORY ;
						}
					}

					t_ProviderInitSink->Release () ;
				}
				else
				{
					t_Result = WBEM_E_OUT_OF_MEMORY ;
				}
			}
		}
		else
		{
			if ( t_TempResult != E_NOINTERFACE )
			{
				t_Result = t_TempResult ;
			}
		}

		if ( SUCCEEDED ( t_Result ) )	
		{
			CServerObject_ProviderInitSink *t_ProviderInitSink = new CServerObject_ProviderInitSink ; 
			if ( t_ProviderInitSink )
			{
				t_ProviderInitSink->AddRef () ;

				t_Result = t_ProviderInitSink->SinkInitialize ( a_Registration.GetComRegistration ().GetSecurityDescriptor () ) ;
				if ( SUCCEEDED ( t_Result ) ) 
				{
					CInterceptor_IWbemProviderInitSink *t_Sink = new CInterceptor_IWbemProviderInitSink ( t_ProviderInitSink ) ;
					if ( t_Sink )
					{
						t_Sink->AddRef () ;

						BOOL t_Impersonating = FALSE ;
						IUnknown *t_OldContext = NULL ;
						IServerSecurity *t_OldSecurity = NULL ;

						t_Result = ProviderSubSystem_Common_Globals :: BeginImpersonation ( t_OldContext , t_OldSecurity , t_Impersonating ) ;
						if ( SUCCEEDED ( t_Result ) )
						{
							BOOL t_Revert = FALSE ;
							IUnknown *t_Proxy = NULL ;

							t_Result = ProviderSubSystem_Common_Globals :: SetProxyState ( IID_IWbemProviderInit , t_ProviderInit , t_Proxy , t_Revert ) ;
							if ( t_Result == WBEM_E_NOT_FOUND )
							{
								try
								{
									t_Result = t_ProviderInit->Initialize (

										a_Registration.GetComRegistration ().PerUserInitialization () ? ( const BSTR ) a_User : NULL ,
										0 ,
										( const BSTR ) a_Namespace ,
										a_Registration.GetComRegistration ().PerLocaleInitialization () ? ( const BSTR ) a_Locale : NULL ,
										a_Repository ,
										a_Context ,
										t_Sink    
									) ;
								}
								catch ( ... )
								{
									t_Result = WBEM_E_PROVIDER_FAILURE ;
								}

								CoRevertToSelf () ;
							}
							else
							{
								if ( SUCCEEDED ( t_Result ) )
								{
									IWbemProviderInit *t_ProviderInitProxy = ( IWbemProviderInit * ) t_Proxy ;

									// Set cloaking on the proxy
									// =========================

									DWORD t_ImpersonationLevel = ProviderSubSystem_Common_Globals :: GetCurrentImpersonationLevel () ;

									t_Result = ProviderSubSystem_Common_Globals :: SetCloaking (

										t_ProviderInitProxy ,
										RPC_C_AUTHN_LEVEL_DEFAULT , 
										t_ImpersonationLevel
									) ;

									if ( SUCCEEDED ( t_Result ) )
									{
										t_Result = CoImpersonateClient () ;
										if ( SUCCEEDED ( t_Result ) )
										{
											try
											{
												t_Result = t_ProviderInitProxy->Initialize (

													a_Registration.GetComRegistration ().PerUserInitialization () ? ( const BSTR ) a_User : NULL ,
													0 ,
													( const BSTR ) a_Namespace ,
													a_Registration.GetComRegistration ().PerLocaleInitialization () ? ( const BSTR ) a_Locale : NULL ,
													a_Repository ,
													a_Context ,
													t_Sink    
												) ;
											}
											catch ( ... )
											{
												t_Result = WBEM_E_PROVIDER_FAILURE ;
											}

											CoRevertToSelf () ;
										}
										else
										{
											t_Result = WBEM_E_ACCESS_DENIED ;
										}
									}	

									HRESULT t_TempResult = ProviderSubSystem_Common_Globals :: RevertProxyState ( t_Proxy , t_Revert ) ;
								}
							}	

							if ( SUCCEEDED ( t_Result ) )
							{
								t_ProviderInitSink->Wait ( a_Registration.GetInitializationTimeoutMilliSeconds () ) ;
								t_Result = t_ProviderInitSink->GetResult () ;
							}

							if ( SUCCEEDED ( t_Result ) )
							{
								WmiSetAndCommitObject (

									ProviderSubSystem_Globals :: s_EventClassHandles [ Msft_WmiProvider_InitializationOperationEvent ] , 
									WMI_SENDCOMMIT_SET_NOT_REQUIRED,
									a_Namespace,
									a_Registration.GetComRegistration ().GetClsidServer ().GetProviderName () ,
									a_Registration.GetComRegistration ().PerUserInitialization () ? ( const BSTR ) a_User : NULL ,
									a_Registration.GetComRegistration ().PerLocaleInitialization () ? ( const BSTR ) a_Locale : NULL ,
									a_TransactionIdentifier ? t_TransactionIdentifier : NULL
								) ;
							}
							else
							{
								WmiSetAndCommitObject (

									ProviderSubSystem_Globals :: s_EventClassHandles [ Msft_WmiProvider_InitializationOperationFailureEvent ] , 
									WMI_SENDCOMMIT_SET_NOT_REQUIRED,
									a_Namespace,
									a_Registration.GetComRegistration ().GetClsidServer ().GetProviderName () ,
									a_Registration.GetComRegistration ().PerUserInitialization () ? ( const BSTR ) a_User : NULL ,
									a_Registration.GetComRegistration ().PerLocaleInitialization () ? ( const BSTR ) a_Locale : NULL ,
									a_TransactionIdentifier ? t_TransactionIdentifier : NULL ,
									t_Result 
								) ;

								t_Result = WBEM_E_PROVIDER_LOAD_FAILURE ;
							}

							ProviderSubSystem_Common_Globals :: EndImpersonation ( t_OldContext , t_OldSecurity , t_Impersonating ) ;
						}

						t_Sink->Release () ;
					}
					else
					{
						t_Result = WBEM_E_OUT_OF_MEMORY ;
					}
				}

				t_ProviderInitSink->Release () ;
			}
			else
			{
				t_Result = WBEM_E_OUT_OF_MEMORY ;
			}
		}

		t_ProviderInit->Release () ;
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CServerObject_StaThread :: GetApartmentInstanceProvider (

	GUID *a_TransactionIdentifier ,
	LPCWSTR a_User ,
	LPCWSTR a_Locale ,
	LPCWSTR a_Namespace ,
	IWbemPath *a_NamespacePath ,
	IWbemServices *a_Repository ,
	LONG a_Flags ,
	IWbemContext *a_Context ,
	LPCWSTR a_Scope ,
	CServerObject_ProviderRegistrationV1 &a_Registration
) 
{
	HRESULT t_Result = S_OK ;

	m_TransactionIdentifier = a_TransactionIdentifier ;

	if ( a_User )
	{
		m_User = SysAllocString ( ( LPWSTR ) a_User ) ;
		if ( m_User == NULL )
		{
			t_Result = WBEM_E_OUT_OF_MEMORY ;
			return t_Result ;
		}
	}

	if ( SUCCEEDED ( t_Result ) )
	{
		if ( a_Locale )
		{
			m_Locale = SysAllocString ( ( LPWSTR ) a_Locale ) ;
			if ( m_Locale == NULL ) 
			{
				t_Result = WBEM_E_OUT_OF_MEMORY ;
			}
		}
	}

	if ( SUCCEEDED ( t_Result ) )
	{
		t_Result = SetScope ( a_Scope ) ;
	}

	if ( SUCCEEDED ( t_Result ) ) 
	{
		t_Result = SetNamespace ( a_Namespace ) ;
	}

	if ( SUCCEEDED ( t_Result ) )
	{
		t_Result = SetNamespacePath ( a_NamespacePath ) ;
	}

	if ( SUCCEEDED ( t_Result ) )
	{
		m_Flags = a_Flags ;

		StaTask_Create *t_Task = new StaTask_Create ( 

			m_Allocator ,
			*this ,
			a_Scope ,
			a_Namespace
		) ;

		if ( t_Task )
		{
			t_Task->AddRef () ;

			if ( t_Task->Initialize () == e_StatusCode_Success ) 
			{
				t_Result = t_Task->MarshalContext ( 

					a_Context ,
					a_Repository 
				) ;

				if ( SUCCEEDED ( t_Result ) )
				{
					WmiStatusCode t_StatusCode = EnQueue ( 

						0 ,
						*t_Task
					) ;

					if ( t_StatusCode == e_StatusCode_Success )
					{
						t_StatusCode = t_Task->WaitInterruptable ( INFINITE ) ;
						if ( t_StatusCode == e_StatusCode_Success )
						{
							t_Result = t_Task->GetResultCode () ;
							if ( SUCCEEDED ( t_Result ) )
							{
								t_Result = t_Task->UnMarshalOutgoing () ;
								if ( SUCCEEDED ( t_Result ) )
								{
									t_Result = InitializeProvider (

										a_TransactionIdentifier ,
										a_User ,
										a_Locale ,
										a_Namespace ,
										a_NamespacePath ,
										a_Repository ,
										a_Flags ,
										a_Context ,
										a_Scope ,
										a_Registration
									) ;
								}
							}
						}
						else
						{
							t_Result = WBEM_E_OUT_OF_MEMORY ;
						}
					}
					else
					{
						t_Result = WBEM_E_OUT_OF_MEMORY ;
					}
				}
			}
			else
			{
				t_Result = WBEM_E_OUT_OF_MEMORY ;
			}

			t_Task->Release () ;
		}
		else
		{
			t_Result = WBEM_E_OUT_OF_MEMORY ;
		}
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

STDMETHODIMP_(ULONG) CServerObject_StaThread :: AddRef ( void )
{
	return WmiThread <ULONG> :: AddRef () ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

STDMETHODIMP_(ULONG) CServerObject_StaThread :: Release ( void )
{
	return WmiThread <ULONG> :: Release () ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

STDMETHODIMP CServerObject_StaThread :: QueryInterface (

	REFIID iid , 
	LPVOID FAR *iplpv 
) 
{
	*iplpv = NULL ;

	if ( iid == IID_IUnknown )
	{
		*iplpv = ( LPVOID ) this ;
	}
	else if ( iid == IID_IWbemProviderInit )
	{
		*iplpv = ( LPVOID ) ( IWbemProviderInit * ) this ;		
	}	
	else if ( iid == IID_IWbemServices )
	{
		if ( m_Provider_IWbemServices )
		{
			*iplpv = ( LPVOID ) ( IWbemServices * ) this ;
		}
	}
	else if ( iid == IID_IWbemEventProvider )
	{
		if ( m_Provider_IWbemEventProvider )
		{
			*iplpv = ( LPVOID ) ( IWbemEventProvider * ) this ;
		}
	}
	else if ( iid == IID_IWbemEventProviderQuerySink )
	{
		if ( m_Provider_IWbemEventProviderQuerySink )
		{
			*iplpv = ( LPVOID ) ( IWbemEventProviderQuerySink * ) this ;
		}
	}
	else if ( iid == IID_IWbemEventProviderSecurity )
	{
		if ( m_Provider_IWbemEventProviderSecurity )
		{
			*iplpv = ( LPVOID ) ( IWbemEventProviderSecurity * ) this ;
		}
	}
	else if ( iid == IID_IWbemEventConsumerProvider )
	{
		if ( m_Provider_IWbemEventConsumerProvider )
		{
			*iplpv = ( LPVOID ) ( IWbemEventConsumerProvider * ) this ;
		}
	}
	else if ( iid == IID_IWbemEventConsumerProviderEx )
	{
		if ( m_Provider_IWbemEventConsumerProviderEx )
		{
			*iplpv = ( LPVOID ) ( IWbemEventConsumerProviderEx  * ) this ;
		}
	}
	else if ( iid == IID_IWbemUnboundObjectSink )
	{
		if ( m_Provider_IWbemUnboundObjectSink )
		{
			*iplpv = ( LPVOID ) ( IWbemUnboundObjectSink * ) this ;
		}
	}
	else if ( iid == IID_IWbemShutdown )
	{
		*iplpv = ( LPVOID ) ( IWbemShutdown * ) this ;		
	}	

	if ( *iplpv )
	{
		( ( LPUNKNOWN ) *iplpv )->AddRef () ;

		return ResultFromScode ( S_OK ) ;
	}
	else
	{
		return ResultFromScode ( E_NOINTERFACE ) ;
	}
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CServerObject_StaThread::OpenNamespace ( 

	const BSTR a_ObjectPath, 
	long a_Flags, 
	IWbemContext *a_Context,
	IWbemServices **a_NamespaceService, 
	IWbemCallResult **a_CallResult
)
{
	return WBEM_E_NOT_AVAILABLE ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CServerObject_StaThread :: CancelAsyncCall ( 
		
	IWbemObjectSink *a_Sink
)
{
	HRESULT t_Result = WBEM_E_PROVIDER_NOT_CAPABLE ;

	if ( m_Provider_IWbemServices )
	{
		BOOL t_Revert = FALSE ;
		IUnknown *t_Proxy = NULL ;

		t_Result = ProviderSubSystem_Common_Globals :: SetProxyState ( m_ProxyContainer , ProxyIndex_Sta_IWbemServices , IID_IWbemServices , m_Provider_IWbemServices , t_Proxy , t_Revert ) ;
		if ( t_Result == WBEM_E_NOT_FOUND )
		{
			t_Result = WBEM_E_UNEXPECTED ;
		}
		else
		{
			if ( SUCCEEDED ( t_Result ) )
			{
				IWbemServices *t_Provider = ( IWbemServices * ) t_Proxy ;

				// Set cloaking on the proxy
				// =========================

				DWORD t_ImpersonationLevel = ProviderSubSystem_Common_Globals :: GetCurrentImpersonationLevel () ;

				t_Result = ProviderSubSystem_Common_Globals :: SetCloaking (

					t_Provider ,
					RPC_C_AUTHN_LEVEL_DEFAULT , 
					t_ImpersonationLevel
				) ;

				if ( SUCCEEDED ( t_Result ) )
				{
					t_Result = t_Provider->CancelAsyncCall (

						a_Sink
					) ;
				}

				HRESULT t_TempResult = ProviderSubSystem_Common_Globals :: RevertProxyState ( m_ProxyContainer , ProxyIndex_Sta_IWbemServices , t_Proxy , t_Revert ) ;
			}
		}
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CServerObject_StaThread :: QueryObjectSink ( 

	long a_Flags,		
	IWbemObjectSink **a_Sink
) 
{
	return WBEM_E_NOT_AVAILABLE ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CServerObject_StaThread :: GetObject ( 
		
	const BSTR a_ObjectPath,
    long a_Flags,
    IWbemContext *a_Context,
    IWbemClassObject **a_Object,
    IWbemCallResult **a_CallResult
)
{
	return WBEM_E_NOT_AVAILABLE ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CServerObject_StaThread :: GetObjectAsync ( 
		
	const BSTR a_ObjectPath, 
	long a_Flags, 
	IWbemContext *a_Context,
	IWbemObjectSink *a_Sink
) 
{
	HRESULT t_Result = WBEM_E_PROVIDER_NOT_CAPABLE ;

	if ( m_Provider_IWbemServices )
	{
		BOOL t_Revert = FALSE ;
		IUnknown *t_Proxy = NULL ;

		t_Result = ProviderSubSystem_Common_Globals :: SetProxyState ( m_ProxyContainer , ProxyIndex_Sta_IWbemServices , IID_IWbemServices , m_Provider_IWbemServices , t_Proxy , t_Revert ) ;
		if ( t_Result == WBEM_E_NOT_FOUND )
		{
			t_Result = WBEM_E_UNEXPECTED ;
		}
		else
		{
			if ( SUCCEEDED ( t_Result ) )
			{
				IWbemServices *t_Provider = ( IWbemServices * ) t_Proxy ;

				// Set cloaking on the proxy
				// =========================

				DWORD t_ImpersonationLevel = ProviderSubSystem_Common_Globals :: GetCurrentImpersonationLevel () ;

				t_Result = ProviderSubSystem_Common_Globals :: SetCloaking (

					t_Provider ,
					RPC_C_AUTHN_LEVEL_DEFAULT , 
					t_ImpersonationLevel
				) ;

				if ( SUCCEEDED ( t_Result ) )
				{
					t_Result = t_Provider->GetObjectAsync (

						a_ObjectPath, 
						a_Flags, 
						a_Context,
						a_Sink
					) ;
				}

				HRESULT t_TempResult = ProviderSubSystem_Common_Globals :: RevertProxyState ( m_ProxyContainer , ProxyIndex_Sta_IWbemServices , t_Proxy , t_Revert ) ;
			}
		}
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CServerObject_StaThread :: PutClass ( 
		
	IWbemClassObject *a_Object, 
	long a_Flags, 
	IWbemContext *a_Context,
	IWbemCallResult ** a_CallResult
) 
{
	return WBEM_E_NOT_AVAILABLE ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CServerObject_StaThread :: PutClassAsync ( 
		
	IWbemClassObject *a_Object, 
	long a_Flags, 
	IWbemContext *a_Context,
	IWbemObjectSink *a_Sink
) 
{
 	 return WBEM_E_NOT_AVAILABLE ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

 HRESULT CServerObject_StaThread :: DeleteClass ( 
		
	const BSTR a_Class, 
	long a_Flags, 
	IWbemContext *a_Context,
	IWbemCallResult **a_CallResult
) 
{
 	 return WBEM_E_NOT_AVAILABLE ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CServerObject_StaThread :: DeleteClassAsync ( 
		
	const BSTR a_Class, 
	long a_Flags, 
	IWbemContext *a_Context,
	IWbemObjectSink *a_Sink
) 
{
 	 return WBEM_E_NOT_AVAILABLE ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CServerObject_StaThread :: CreateClassEnum ( 

	const BSTR a_Superclass, 
	long a_Flags, 
	IWbemContext *a_Context,
	IEnumWbemClassObject **a_Enum
) 
{
	return WBEM_E_NOT_AVAILABLE ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

SCODE CServerObject_StaThread :: CreateClassEnumAsync (

	const BSTR a_Superclass, 
	long a_Flags, 
	IWbemContext *a_Context,
	IWbemObjectSink *a_Sink
) 
{
	return WBEM_E_NOT_AVAILABLE ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CServerObject_StaThread :: PutInstance (

    IWbemClassObject *a_Instance,
    long a_Flags,
    IWbemContext *a_Context,
	IWbemCallResult **a_CallResult
) 
{
	return WBEM_E_NOT_AVAILABLE ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CServerObject_StaThread :: PutInstanceAsync ( 
		
	IWbemClassObject *a_Instance, 
	long a_Flags, 
    IWbemContext *a_Context,
	IWbemObjectSink *a_Sink
) 
{
	HRESULT t_Result = WBEM_E_PROVIDER_NOT_CAPABLE ;

	if ( m_Provider_IWbemServices )
	{
		BOOL t_Revert = FALSE ;
		IUnknown *t_Proxy = NULL ;

		t_Result = ProviderSubSystem_Common_Globals :: SetProxyState ( m_ProxyContainer , ProxyIndex_Sta_IWbemServices , IID_IWbemServices , m_Provider_IWbemServices , t_Proxy , t_Revert ) ;
		if ( t_Result == WBEM_E_NOT_FOUND )
		{
			t_Result = WBEM_E_UNEXPECTED ;
		}
		else
		{
			if ( SUCCEEDED ( t_Result ) )
			{
				IWbemServices *t_Provider = ( IWbemServices * ) t_Proxy ;

				// Set cloaking on the proxy
				// =========================

				DWORD t_ImpersonationLevel = ProviderSubSystem_Common_Globals :: GetCurrentImpersonationLevel () ;

				t_Result = ProviderSubSystem_Common_Globals :: SetCloaking (

					t_Provider ,
					RPC_C_AUTHN_LEVEL_DEFAULT , 
					t_ImpersonationLevel
				) ;

				if ( SUCCEEDED ( t_Result ) )
				{
					t_Result = t_Provider->PutInstanceAsync (

						a_Instance, 
						a_Flags, 
						a_Context,
						a_Sink
					) ;
				}

				HRESULT t_TempResult = ProviderSubSystem_Common_Globals :: RevertProxyState ( m_ProxyContainer , ProxyIndex_Sta_IWbemServices , t_Proxy , t_Revert ) ;
			}
		}
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CServerObject_StaThread :: DeleteInstance ( 

	const BSTR a_ObjectPath,
    long a_Flags,
    IWbemContext *a_Context,
    IWbemCallResult **a_CallResult
)
{
	return WBEM_E_NOT_AVAILABLE ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/
        
HRESULT CServerObject_StaThread :: DeleteInstanceAsync (
 
	const BSTR a_ObjectPath,
    long a_Flags,
    IWbemContext *a_Context,
    IWbemObjectSink *a_Sink	
)
{
	HRESULT t_Result = WBEM_E_PROVIDER_NOT_CAPABLE ;

	if ( m_Provider_IWbemServices )
	{
		BOOL t_Revert = FALSE ;
		IUnknown *t_Proxy = NULL ;

		t_Result = ProviderSubSystem_Common_Globals :: SetProxyState ( m_ProxyContainer , ProxyIndex_Sta_IWbemServices , IID_IWbemServices , m_Provider_IWbemServices , t_Proxy , t_Revert ) ;
		if ( t_Result == WBEM_E_NOT_FOUND )
		{
			t_Result = WBEM_E_UNEXPECTED ;
		}
		else
		{
			if ( SUCCEEDED ( t_Result ) )
			{
				IWbemServices *t_Provider = ( IWbemServices * ) t_Proxy ;

				// Set cloaking on the proxy
				// =========================

				DWORD t_ImpersonationLevel = ProviderSubSystem_Common_Globals :: GetCurrentImpersonationLevel () ;

				t_Result = ProviderSubSystem_Common_Globals :: SetCloaking (

					t_Provider ,
					RPC_C_AUTHN_LEVEL_DEFAULT , 
					t_ImpersonationLevel
				) ;

				if ( SUCCEEDED ( t_Result ) )
				{
					t_Result = t_Provider->DeleteInstanceAsync (

						a_ObjectPath,
						a_Flags,
						a_Context,
						a_Sink
					) ;
				}

				HRESULT t_TempResult = ProviderSubSystem_Common_Globals :: RevertProxyState ( m_ProxyContainer , ProxyIndex_Sta_IWbemServices , t_Proxy , t_Revert ) ;
			}
		}
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CServerObject_StaThread :: CreateInstanceEnum ( 

	const BSTR a_Class, 
	long a_Flags, 
	IWbemContext *a_Context, 
	IEnumWbemClassObject **a_Enum
)
{
	return WBEM_E_NOT_AVAILABLE ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CServerObject_StaThread :: CreateInstanceEnumAsync (

 	const BSTR a_Class, 
	long a_Flags, 
	IWbemContext *a_Context,
	IWbemObjectSink *a_Sink

) 
{
	HRESULT t_Result = WBEM_E_PROVIDER_NOT_CAPABLE ;

	if ( m_Provider_IWbemServices )
	{
		BOOL t_Revert = FALSE ;
		IUnknown *t_Proxy = NULL ;

		t_Result = ProviderSubSystem_Common_Globals :: SetProxyState ( m_ProxyContainer , ProxyIndex_Sta_IWbemServices , IID_IWbemServices , m_Provider_IWbemServices , t_Proxy , t_Revert ) ;
		if ( t_Result == WBEM_E_NOT_FOUND )
		{
			t_Result = WBEM_E_UNEXPECTED ;
		}
		else
		{
			if ( SUCCEEDED ( t_Result ) )
			{
				IWbemServices *t_Provider = ( IWbemServices * ) t_Proxy ;

				// Set cloaking on the proxy
				// =========================

				DWORD t_ImpersonationLevel = ProviderSubSystem_Common_Globals :: GetCurrentImpersonationLevel () ;

				t_Result = ProviderSubSystem_Common_Globals :: SetCloaking (

					t_Provider ,
					RPC_C_AUTHN_LEVEL_DEFAULT , 
					t_ImpersonationLevel
				) ;

				if ( SUCCEEDED ( t_Result ) )
				{
					t_Result = t_Provider->CreateInstanceEnumAsync ( 

						a_Class ,
						a_Flags , 
						a_Context ,
						a_Sink
					) ;
				}

				HRESULT t_TempResult = ProviderSubSystem_Common_Globals :: RevertProxyState ( m_ProxyContainer , ProxyIndex_Sta_IWbemServices , t_Proxy , t_Revert ) ;
			}
		}
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CServerObject_StaThread :: ExecQuery ( 

	const BSTR a_QueryLanguage, 
	const BSTR a_Query, 
	long a_Flags, 
	IWbemContext *a_Context,
	IEnumWbemClassObject **a_Enum
)
{
	return WBEM_E_NOT_AVAILABLE ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CServerObject_StaThread :: ExecQueryAsync ( 
		
	const BSTR a_QueryLanguage, 
	const BSTR a_Query, 
	long a_Flags, 
	IWbemContext *a_Context,
	IWbemObjectSink *a_Sink
) 
{
	HRESULT t_Result = WBEM_E_PROVIDER_NOT_CAPABLE ;

	if ( m_Provider_IWbemServices )
	{
		BOOL t_Revert = FALSE ;
		IUnknown *t_Proxy = NULL ;

		t_Result = ProviderSubSystem_Common_Globals :: SetProxyState ( m_ProxyContainer , ProxyIndex_Sta_IWbemServices , IID_IWbemServices , m_Provider_IWbemServices , t_Proxy , t_Revert ) ;
		if ( t_Result == WBEM_E_NOT_FOUND )
		{
			t_Result = WBEM_E_UNEXPECTED ;
		}
		else
		{
			if ( SUCCEEDED ( t_Result ) )
			{
				IWbemServices *t_Provider = ( IWbemServices * ) t_Proxy ;

				// Set cloaking on the proxy
				// =========================

				DWORD t_ImpersonationLevel = ProviderSubSystem_Common_Globals :: GetCurrentImpersonationLevel () ;

				t_Result = ProviderSubSystem_Common_Globals :: SetCloaking (

					t_Provider ,
					RPC_C_AUTHN_LEVEL_DEFAULT , 
					t_ImpersonationLevel
				) ;

				if ( SUCCEEDED ( t_Result ) )
				{
					t_Result = t_Provider->ExecQueryAsync (

						a_QueryLanguage, 
						a_Query, 
						a_Flags, 
						a_Context,
						a_Sink
					) ;
				}

				HRESULT t_TempResult = ProviderSubSystem_Common_Globals :: RevertProxyState ( m_ProxyContainer , ProxyIndex_Sta_IWbemServices , t_Proxy , t_Revert ) ;
			}
		}
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CServerObject_StaThread :: ExecNotificationQuery ( 

	const BSTR a_QueryLanguage,
    const BSTR a_Query,
    long a_Flags,
    IWbemContext *a_Context,
    IEnumWbemClassObject **a_Enum
)
{
	return WBEM_E_NOT_AVAILABLE ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/
        
HRESULT CServerObject_StaThread :: ExecNotificationQueryAsync ( 
            
	const BSTR a_QueryLanguage,
    const BSTR a_Query,
    long a_Flags,
    IWbemContext *a_Context,
    IWbemObjectSink *a_Sink
)
{
	return WBEM_E_NOT_AVAILABLE ;
}       

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT STDMETHODCALLTYPE CServerObject_StaThread :: ExecMethod( 

	const BSTR a_ObjectPath,
    const BSTR a_MethodName,
    long a_Flags,
    IWbemContext *a_Context,
    IWbemClassObject *a_InParams,
    IWbemClassObject **a_OutParams,
    IWbemCallResult **a_CallResult
)
{
	return WBEM_E_NOT_AVAILABLE ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT STDMETHODCALLTYPE CServerObject_StaThread :: ExecMethodAsync ( 

    const BSTR a_ObjectPath,
    const BSTR a_MethodName,
    long a_Flags,
    IWbemContext *a_Context,
    IWbemClassObject *a_InParams,
	IWbemObjectSink *a_Sink
) 
{
	HRESULT t_Result = WBEM_E_PROVIDER_NOT_CAPABLE ;

	if ( m_Provider_IWbemServices )
	{
		BOOL t_Revert = FALSE ;
		IUnknown *t_Proxy = NULL ;

		t_Result = ProviderSubSystem_Common_Globals :: SetProxyState ( m_ProxyContainer , ProxyIndex_Sta_IWbemServices , IID_IWbemServices , m_Provider_IWbemServices , t_Proxy , t_Revert ) ;
		if ( t_Result == WBEM_E_NOT_FOUND )
		{
			t_Result = WBEM_E_UNEXPECTED ;
		}
		else
		{
			if ( SUCCEEDED ( t_Result ) )
			{
				IWbemServices *t_Provider = ( IWbemServices * ) t_Proxy ;

				// Set cloaking on the proxy
				// =========================

				DWORD t_ImpersonationLevel = ProviderSubSystem_Common_Globals :: GetCurrentImpersonationLevel () ;

				t_Result = ProviderSubSystem_Common_Globals :: SetCloaking (

					t_Provider ,
					RPC_C_AUTHN_LEVEL_DEFAULT , 
					t_ImpersonationLevel
				) ;

				if ( SUCCEEDED ( t_Result ) )
				{
					t_Result = t_Provider->ExecMethodAsync (

						a_ObjectPath,
						a_MethodName,
						a_Flags,
						a_Context,
						a_InParams,
						a_Sink
					) ;
				}

				HRESULT t_TempResult = ProviderSubSystem_Common_Globals :: RevertProxyState ( m_ProxyContainer , ProxyIndex_Sta_IWbemServices , t_Proxy , t_Revert ) ;
			}
		}
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CServerObject_StaThread :: ProvideEvents ( 
		
	IWbemObjectSink *a_Sink ,
	long a_Flags
) 
{
	HRESULT t_Result = WBEM_E_PROVIDER_NOT_CAPABLE ;

	if ( m_Provider_IWbemEventProvider )
	{
		BOOL t_Revert = FALSE ;
		IUnknown *t_Proxy = NULL ;

		t_Result = ProviderSubSystem_Common_Globals :: SetProxyState ( m_ProxyContainer , ProxyIndex_Sta_IWbemEventProvider , IID_IWbemEventProvider , m_Provider_IWbemEventProvider , t_Proxy , t_Revert ) ;
		if ( t_Result == WBEM_E_NOT_FOUND )
		{
			t_Result = WBEM_E_UNEXPECTED ;
		}
		else
		{
			if ( SUCCEEDED ( t_Result ) )
			{
				IWbemEventProvider *t_Provider = ( IWbemEventProvider * ) t_Proxy ;

				// Set cloaking on the proxy
				// =========================

				DWORD t_ImpersonationLevel = ProviderSubSystem_Common_Globals :: GetCurrentImpersonationLevel () ;

				t_Result = ProviderSubSystem_Common_Globals :: SetCloaking (

					t_Provider ,
					RPC_C_AUTHN_LEVEL_DEFAULT , 
					t_ImpersonationLevel
				) ;

				if ( SUCCEEDED ( t_Result ) )
				{
					t_Result = t_Provider->ProvideEvents (

						a_Sink ,
						a_Flags
					) ;
				}

				HRESULT t_TempResult = ProviderSubSystem_Common_Globals :: RevertProxyState ( m_ProxyContainer , ProxyIndex_Sta_IWbemEventProvider , t_Proxy , t_Revert ) ;
			}
		}
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CServerObject_StaThread :: NewQuery (

	unsigned long a_Id ,
	WBEM_WSTR a_QueryLanguage ,
	WBEM_WSTR a_Query
) 
{
	HRESULT t_Result = WBEM_E_PROVIDER_NOT_CAPABLE ;

	if ( m_Provider_IWbemEventProviderQuerySink )
	{
		BOOL t_Revert = FALSE ;
		IUnknown *t_Proxy = NULL ;

		t_Result = ProviderSubSystem_Common_Globals :: SetProxyState ( m_ProxyContainer , ProxyIndex_Sta_IWbemEventProviderQuerySink , IID_IWbemEventProviderQuerySink , m_Provider_IWbemEventProviderQuerySink , t_Proxy , t_Revert ) ;
		if ( t_Result == WBEM_E_NOT_FOUND )
		{
			t_Result = WBEM_E_UNEXPECTED ;
		}
		else
		{
			if ( SUCCEEDED ( t_Result ) )
			{
				IWbemEventProviderQuerySink *t_Provider = ( IWbemEventProviderQuerySink * ) t_Proxy ;

				// Set cloaking on the proxy
				// =========================

				DWORD t_ImpersonationLevel = ProviderSubSystem_Common_Globals :: GetCurrentImpersonationLevel () ;

				t_Result = ProviderSubSystem_Common_Globals :: SetCloaking (

					t_Provider ,
					RPC_C_AUTHN_LEVEL_DEFAULT , 
					t_ImpersonationLevel
				) ;

				if ( SUCCEEDED ( t_Result ) )
				{
					t_Result = t_Provider->NewQuery (

						a_Id ,
						a_QueryLanguage ,
						a_Query
					) ;
				}

				HRESULT t_TempResult = ProviderSubSystem_Common_Globals :: RevertProxyState ( m_ProxyContainer , ProxyIndex_Sta_IWbemEventProviderQuerySink , t_Proxy , t_Revert ) ;
			}
		}
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CServerObject_StaThread :: CancelQuery (

	unsigned long a_Id
) 
{
	HRESULT t_Result = WBEM_E_PROVIDER_NOT_CAPABLE ;

	if ( m_Provider_IWbemEventProviderQuerySink )
	{
		BOOL t_Revert = FALSE ;
		IUnknown *t_Proxy = NULL ;

		t_Result = ProviderSubSystem_Common_Globals :: SetProxyState ( m_ProxyContainer , ProxyIndex_Sta_IWbemEventProviderQuerySink , IID_IWbemEventProviderQuerySink , m_Provider_IWbemEventProviderQuerySink , t_Proxy , t_Revert ) ;
		if ( t_Result == WBEM_E_NOT_FOUND )
		{
			t_Result = WBEM_E_UNEXPECTED ;
		}
		else
		{
			if ( SUCCEEDED ( t_Result ) )
			{
				IWbemEventProviderQuerySink *t_Provider = ( IWbemEventProviderQuerySink * ) t_Proxy ;

				// Set cloaking on the proxy
				// =========================

				DWORD t_ImpersonationLevel = ProviderSubSystem_Common_Globals :: GetCurrentImpersonationLevel () ;

				t_Result = ProviderSubSystem_Common_Globals :: SetCloaking (

					t_Provider ,
					RPC_C_AUTHN_LEVEL_DEFAULT , 
					t_ImpersonationLevel
				) ;

				if ( SUCCEEDED ( t_Result ) )
				{
					t_Result = t_Provider->CancelQuery (

						a_Id 
					) ;
				}

				HRESULT t_TempResult = ProviderSubSystem_Common_Globals :: RevertProxyState ( m_ProxyContainer , ProxyIndex_Sta_IWbemEventProviderQuerySink , t_Proxy , t_Revert ) ;
			}
		}
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CServerObject_StaThread :: AccessCheck (

	WBEM_CWSTR a_QueryLanguage ,
	WBEM_CWSTR a_Query ,
	long a_SidLength ,
	const BYTE *a_Sid
) 
{
	HRESULT t_Result = WBEM_E_PROVIDER_NOT_CAPABLE ;

	if ( m_Provider_IWbemEventProviderSecurity )
	{
		BOOL t_Revert = FALSE ;
		IUnknown *t_Proxy = NULL ;

		t_Result = ProviderSubSystem_Common_Globals :: SetProxyState ( m_ProxyContainer , ProxyIndex_Sta_IWbemEventProviderSecurity , IID_IWbemEventProviderSecurity , m_Provider_IWbemEventProviderSecurity , t_Proxy , t_Revert ) ;
		if ( t_Result == WBEM_E_NOT_FOUND )
		{
			t_Result = WBEM_E_UNEXPECTED ;
		}
		else
		{
			if ( SUCCEEDED ( t_Result ) )
			{
				IWbemEventProviderSecurity *t_Provider = ( IWbemEventProviderSecurity * ) t_Proxy ;

				// Set cloaking on the proxy
				// =========================

				DWORD t_ImpersonationLevel = ProviderSubSystem_Common_Globals :: GetCurrentImpersonationLevel () ;

				t_Result = ProviderSubSystem_Common_Globals :: SetCloaking (

					t_Provider ,
					RPC_C_AUTHN_LEVEL_DEFAULT , 
					t_ImpersonationLevel
				) ;

				if ( SUCCEEDED ( t_Result ) )
				{
					t_Result = t_Provider->AccessCheck (

						a_QueryLanguage ,
						a_Query ,
						a_SidLength ,
						a_Sid
					) ;
				}

				HRESULT t_TempResult = ProviderSubSystem_Common_Globals :: RevertProxyState ( m_ProxyContainer , ProxyIndex_Sta_IWbemEventProviderSecurity , t_Proxy , t_Revert ) ;
			}
		}
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CServerObject_StaThread ::FindConsumer (

	IWbemClassObject *a_LogicalConsumer ,
	IWbemUnboundObjectSink **a_Consumer
)
{
	if ( m_Provider_IWbemEventConsumerProvider )
	{
		IWbemUnboundObjectSink *t_Consumer = NULL ;

		BOOL t_Impersonating = FALSE ;
		IUnknown *t_OldContext = NULL ;
		IServerSecurity *t_OldSecurity = NULL ;

		HRESULT t_Result = ProviderSubSystem_Common_Globals :: BeginImpersonation ( t_OldContext , t_OldSecurity , t_Impersonating ) ;
		if ( SUCCEEDED ( t_Result ) ) 
		{
			BOOL t_Revert = FALSE ;
			IUnknown *t_Proxy = NULL ;

			t_Result = ProviderSubSystem_Common_Globals :: SetProxyState ( m_ProxyContainer , ProxyIndex_Sta_IWbemEventConsumerProvider , IID_IWbemEventConsumerProvider , m_Provider_IWbemEventConsumerProvider , t_Proxy , t_Revert ) ;
			if ( t_Result == WBEM_E_NOT_FOUND )
			{
				try
				{
					t_Result = m_Provider_IWbemEventConsumerProvider->FindConsumer (

						a_LogicalConsumer ,
						& t_Consumer
					) ;
				}
				catch ( ... )
				{
					t_Result = WBEM_E_PROVIDER_FAILURE ;
				}

				CoRevertToSelf () ;
			}
			else 
			{
				if ( SUCCEEDED ( t_Result ) )
				{
					IWbemEventConsumerProvider *t_Provider = ( IWbemEventConsumerProvider * ) t_Proxy ;

					// Set cloaking on the proxy
					// =========================

					DWORD t_ImpersonationLevel = ProviderSubSystem_Common_Globals :: GetCurrentImpersonationLevel () ;

					t_Result = ProviderSubSystem_Common_Globals :: SetCloaking (

						t_Provider ,
						RPC_C_AUTHN_LEVEL_DEFAULT , 
						t_ImpersonationLevel
					) ;

					if ( SUCCEEDED ( t_Result ) )
					{
						t_Result = CoImpersonateClient () ;
						if ( SUCCEEDED ( t_Result ) )
						{
							try
							{
								t_Result = t_Provider->FindConsumer (

									a_LogicalConsumer ,
									& t_Consumer
								) ;
							}
							catch ( ... )
							{
								t_Result = WBEM_E_PROVIDER_FAILURE ;
							}

							CoRevertToSelf () ;
						}
						else
						{
							t_Result = WBEM_E_ACCESS_DENIED ;
						}
					}

					HRESULT t_TempResult = ProviderSubSystem_Common_Globals :: RevertProxyState ( m_ProxyContainer , ProxyIndex_Sta_IWbemEventConsumerProvider , t_Proxy , t_Revert ) ;
				}
			}

			ProviderSubSystem_Common_Globals :: EndImpersonation ( t_OldContext , t_OldSecurity , t_Impersonating ) ;
		}

		if ( SUCCEEDED ( t_Result ) )
		{
			if ( a_Consumer )
			{
				CInterceptor_IWbemSyncUnboundObjectSink *t_UnboundObjectSink = new CInterceptor_IWbemSyncUnboundObjectSink (

						m_Allocator ,
						t_Consumer , 
						this ,
						*m_Registration
				) ;

				if ( t_UnboundObjectSink )
				{
					t_UnboundObjectSink->AddRef () ;

					t_Result = t_UnboundObjectSink->Initialize () ;
					if ( SUCCEEDED ( t_Result ) )
					{
						CWbemGlobal_VoidPointerController_Container_Iterator t_Iterator ;

						Lock () ;

						WmiStatusCode t_StatusCode = Insert ( 

							*t_UnboundObjectSink ,
							t_Iterator
						) ;

						if ( t_StatusCode == e_StatusCode_Success ) 
						{
							UnLock () ;

							*a_Consumer = t_UnboundObjectSink ;

							t_UnboundObjectSink->AddRef () ;
						}
						else
						{
							UnLock () ;

							t_Result = WBEM_E_OUT_OF_MEMORY ;
						}
					}

					t_UnboundObjectSink->Release () ;
				}
			}
		}

		if ( t_Consumer )
		{
			t_Consumer->Release () ;
		}

		return t_Result ;
	}

	return WBEM_E_PROVIDER_NOT_CAPABLE;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CServerObject_StaThread ::ValidateSubscription (

	IWbemClassObject *a_LogicalConsumer
)
{
	if ( m_Provider_IWbemEventConsumerProviderEx )
	{
		BOOL t_Impersonating = FALSE ;
		IUnknown *t_OldContext = NULL ;
		IServerSecurity *t_OldSecurity = NULL ;

		HRESULT t_Result = ProviderSubSystem_Common_Globals :: BeginImpersonation ( t_OldContext , t_OldSecurity , t_Impersonating ) ;
		if ( SUCCEEDED ( t_Result ) ) 
		{
			BOOL t_Revert = FALSE ;
			IUnknown *t_Proxy = NULL ;

			t_Result = ProviderSubSystem_Common_Globals :: SetProxyState ( m_ProxyContainer , ProxyIndex_Sta_IWbemEventConsumerProviderEx , IID_IWbemEventConsumerProviderEx , m_Provider_IWbemEventConsumerProviderEx , t_Proxy , t_Revert ) ;
			if ( t_Result == WBEM_E_NOT_FOUND )
			{
				try
				{
					t_Result = m_Provider_IWbemEventConsumerProviderEx->ValidateSubscription (

						a_LogicalConsumer
					) ;
				}
				catch ( ... )
				{
					t_Result = WBEM_E_PROVIDER_FAILURE ;
				}

				CoRevertToSelf () ;
			}
			else 
			{
				if ( SUCCEEDED ( t_Result ) )
				{
					IWbemEventConsumerProviderEx *t_Provider = ( IWbemEventConsumerProviderEx * ) t_Proxy ;

					// Set cloaking on the proxy
					// =========================

					DWORD t_ImpersonationLevel = ProviderSubSystem_Common_Globals :: GetCurrentImpersonationLevel () ;

					t_Result = ProviderSubSystem_Common_Globals :: SetCloaking (

						t_Provider ,
						RPC_C_AUTHN_LEVEL_DEFAULT , 
						t_ImpersonationLevel
					) ;

					if ( SUCCEEDED ( t_Result ) )
					{
						t_Result = CoImpersonateClient () ;
						if ( SUCCEEDED ( t_Result ) )
						{
							try
							{
								t_Result = t_Provider->ValidateSubscription (

									a_LogicalConsumer
								) ;
							}
							catch ( ... )
							{
								t_Result = WBEM_E_PROVIDER_FAILURE ;
							}

							CoRevertToSelf () ;
						}
						else
						{
							t_Result = WBEM_E_ACCESS_DENIED ;
						}
					}

					HRESULT t_TempResult = ProviderSubSystem_Common_Globals :: RevertProxyState ( m_ProxyContainer , ProxyIndex_Sta_IWbemEventConsumerProviderEx , t_Proxy , t_Revert ) ;
				}
			}

			ProviderSubSystem_Common_Globals :: EndImpersonation ( t_OldContext , t_OldSecurity , t_Impersonating ) ;
		}

		return t_Result ;
	}

	return WBEM_E_PROVIDER_NOT_CAPABLE;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CServerObject_StaThread :: IndicateToConsumer (

	IWbemClassObject *a_LogicalConsumer ,
	long a_ObjectCount ,
	IWbemClassObject **a_Objects
)
{
	if ( m_Provider_IWbemUnboundObjectSink )
	{
		BOOL t_Impersonating = FALSE ;
		IUnknown *t_OldContext = NULL ;
		IServerSecurity *t_OldSecurity = NULL ;

		HRESULT t_Result = ProviderSubSystem_Common_Globals :: BeginImpersonation ( t_OldContext , t_OldSecurity , t_Impersonating ) ;
		if ( SUCCEEDED ( t_Result ) ) 
		{
			BOOL t_Revert = FALSE ;
			IUnknown *t_Proxy = NULL ;

			t_Result = ProviderSubSystem_Common_Globals :: SetProxyState ( m_ProxyContainer , ProxyIndex_Sta_IWbemUnboundObjectSink , IID_IWbemUnboundObjectSink , m_Provider_IWbemUnboundObjectSink , t_Proxy , t_Revert ) ;
			if ( t_Result == WBEM_E_NOT_FOUND )
			{
				t_Result = m_Provider_IWbemUnboundObjectSink->IndicateToConsumer (


					a_LogicalConsumer ,
					a_ObjectCount ,
					a_Objects
				) ;
			}
			else 
			{
				if ( SUCCEEDED ( t_Result ) )
				{
					IWbemUnboundObjectSink *t_Provider = ( IWbemUnboundObjectSink * ) t_Proxy ;

					// Set cloaking on the proxy
					// =========================

					DWORD t_ImpersonationLevel = ProviderSubSystem_Common_Globals :: GetCurrentImpersonationLevel () ;

					t_Result = ProviderSubSystem_Common_Globals :: SetCloaking (

						t_Provider ,
						RPC_C_AUTHN_LEVEL_DEFAULT , 
						t_ImpersonationLevel
					) ;

					if ( SUCCEEDED ( t_Result ) )
					{
						t_Result = t_Provider->IndicateToConsumer (

							a_LogicalConsumer ,
							a_ObjectCount ,
							a_Objects
						) ;
					}

					HRESULT t_TempResult = ProviderSubSystem_Common_Globals :: RevertProxyState ( m_ProxyContainer , ProxyIndex_Sta_IWbemUnboundObjectSink , t_Proxy , t_Revert ) ;
				}
			}

			ProviderSubSystem_Common_Globals :: EndImpersonation ( t_OldContext , t_OldSecurity , t_Impersonating ) ;
		}

		return t_Result ;
	}

	return WBEM_E_PROVIDER_NOT_CAPABLE;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CServerObject_StaThread :: Initialize (

	LPWSTR a_User,
	LONG a_Flags,
	LPWSTR a_Namespace,
	LPWSTR a_Locale,
	IWbemServices *a_Core,
	IWbemContext *a_Context,
	IWbemProviderInitSink *a_Sink
)
{
	HRESULT t_Result = S_OK ;

	WmiStatusCode t_StatusCode = CWbemGlobal_IWmiObjectSinkController :: Initialize () ;
	if ( t_StatusCode != e_StatusCode_Success ) 
	{
		t_Result = WBEM_E_OUT_OF_MEMORY ;
	}

	if ( SUCCEEDED ( t_Result ) )
	{
		t_StatusCode = m_ProxyContainer.Initialize () ;
		if ( t_StatusCode != e_StatusCode_Success ) 
		{
			t_Result = WBEM_E_OUT_OF_MEMORY ;
		}
	}

	a_Sink->SetStatus ( t_Result , 0 ) ;
	
	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CServerObject_StaThread :: Shutdown (

	LONG a_Flags ,
	ULONG a_MaxMilliSeconds ,
	IWbemContext *a_Context
)
{
	HRESULT t_Result = S_OK ;

	Lock () ;

	CWbemGlobal_IWmiObjectSinkController_Container *t_Container = NULL ;
	GetContainer ( t_Container ) ;

	CWbemGlobal_IWmiObjectSinkController_Container_Iterator t_Iterator = t_Container->Begin ();

	while ( ! t_Iterator.Null () )
	{
		IWbemShutdown *t_Shutdown = NULL ;
		t_Result = t_Iterator.GetElement ()->QueryInterface ( IID_IWbemShutdown , ( void ** ) & t_Shutdown ) ;

		t_Iterator.Increment () ;

		if ( SUCCEEDED ( t_Result ) ) 
		{
			t_Result = t_Shutdown->Shutdown ( 

				a_Flags ,
				a_MaxMilliSeconds ,
				a_Context
			) ;

			t_Shutdown->Release () ;
		}
	}

	CWbemGlobal_IWmiObjectSinkController :: Shutdown () ;

	UnLock () ;

	return t_Result ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\winmgmt\provsubsys\server\include\classfac.h ===
/*++

Copyright (C) 1996-2001 Microsoft Corporation

Module Name:

	ClassFac.h

Abstract:


History:

--*/

#ifndef _ServerClassFactory_H
#define _ServerClassFactory_H

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

template <class Object,class ObjectInterface>
class CServerClassFactory : public IClassFactory
{
private:

    long m_ReferenceCount ;

protected:
public:

    CServerClassFactory () ;
    ~CServerClassFactory () ;

	//IUnknown members

	STDMETHODIMP QueryInterface ( REFIID , LPVOID FAR * ) ;
    STDMETHODIMP_( ULONG ) AddRef () ;
    STDMETHODIMP_( ULONG ) Release () ;

	//IClassFactory members

    STDMETHODIMP CreateInstance ( LPUNKNOWN , REFIID , LPVOID FAR * ) ;
    STDMETHODIMP LockServer ( BOOL ) ;
};

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

class CServerProvSubSysClassFactory : public IClassFactory
{
private:

    long m_ReferenceCount ;

protected:
public:

    CServerProvSubSysClassFactory () ;
    ~CServerProvSubSysClassFactory () ;

	//IUnknown members

	STDMETHODIMP QueryInterface ( REFIID , LPVOID FAR * ) ;
    STDMETHODIMP_( ULONG ) AddRef () ;
    STDMETHODIMP_( ULONG ) Release () ;

	//IClassFactory members

    STDMETHODIMP CreateInstance ( LPUNKNOWN , REFIID , LPVOID FAR * ) ;
    STDMETHODIMP LockServer ( BOOL ) ;
};

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

class CServerProvRefreshManagerClassFactory : public IClassFactory
{
private:

    long m_ReferenceCount ;

protected:
public:

    CServerProvRefreshManagerClassFactory () ;
    ~CServerProvRefreshManagerClassFactory () ;

	//IUnknown members

	STDMETHODIMP QueryInterface ( REFIID , LPVOID FAR * ) ;
    STDMETHODIMP_( ULONG ) AddRef () ;
    STDMETHODIMP_( ULONG ) Release () ;

	//IClassFactory members

    STDMETHODIMP CreateInstance ( LPUNKNOWN , REFIID , LPVOID FAR * ) ;
    STDMETHODIMP LockServer ( BOOL ) ;
};


#include <classfac.cpp>

#endif // _ServerClassFactory_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\winmgmt\provsubsys\server\include\main.h ===
/*++

Copyright (C) 1996-2001 Microsoft Corporation

Module Name:

	Main.h

Abstract:


History:

--*/

#ifndef _Main_H
#define _Main_H

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

class FactoryLifeTimeThread : public WmiThread < ULONG > 
{
private:

	WmiAllocator &m_Allocator ;

protected:

public:	/* Internal */

    FactoryLifeTimeThread ( 

		WmiAllocator & a_Allocator ,
		const ULONG &a_Timeout 
	) ;

    ~FactoryLifeTimeThread () ;

	WmiStatusCode Initialize_Callback () ;

	WmiStatusCode UnInitialize_Callback () ;

	WmiStatusCode TimedOut () ;

	BOOL QuotaCheck () ;
};

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

class Task_ObjectDestruction : public WmiTask < ULONG > 
{
private:
protected:
public:	// Internal 

	Task_ObjectDestruction ( WmiAllocator &a_Allocator ) : WmiTask < ULONG > ( a_Allocator ) 
	{
	}

	WmiStatusCode Process ( WmiThread <ULONG> &a_Thread ) ;
} ;

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

class Task_FreeLibraries : public WmiTask < ULONG > 
{
private:
protected:
public:	// Internal 

	Task_FreeLibraries ( WmiAllocator &a_Allocator ) : WmiTask < ULONG > ( a_Allocator ) 
	{
	}

	WmiStatusCode Process ( WmiThread <ULONG> &a_Thread ) ;
} ;


/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

STDAPI DllRegisterServer () ;
STDAPI DllUnregisterServer () ;

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

void SetObjectDestruction () ;

void SetProviderDestruction();

#endif // _Main_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\winmgmt\provsubsys\server\include\globals.h ===
/*++

Copyright (C) 1996-2001 Microsoft Corporation

Module Name:

	Globals.h

Abstract:


History:

--*/

#ifndef _Globals_H
#define _Globals_H

#include <pssException.h>
#include <Allocator.h>
#include <BasicTree.h>

#include "ProvCntrs.h"
#include "ProvCache.h"
#include "ProvDcAggr.h"
#include "StrobeThread.h"
#include <lockst.h>

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

enum Event_Identifier {

	Msft_WmiProvider_ComServerLoadOperationEvent = 0 ,
	Msft_WmiProvider_ComServerOperationFailureEvent ,
	Msft_WmiProvider_LoadOperationEvent ,
	Msft_WmiProvider_LoadOperationFailureEvent ,
	Msft_WmiProvider_InitializationOperationFailureEvent ,
	Msft_WmiProvider_InitializationOperationEvent ,
	Msft_WmiProvider_UnLoadOperationEvent ,
#if 0
	Msft_WmiProvider_HostLoadOperationEvent ,
	Msft_WmiProvider_HostLoadFailureOperationEvent ,
	Msft_WmiProvider_HostUnLoadOperationEvent ,
#endif
	Msft_WmiProvider_GetObjectAsyncEvent_Pre ,
	Msft_WmiProvider_PutClassAsyncEvent_Pre ,
	Msft_WmiProvider_DeleteClassAsyncEvent_Pre ,
	Msft_WmiProvider_CreateClassEnumAsyncEvent_Pre ,
	Msft_WmiProvider_PutInstanceAsyncEvent_Pre ,
	Msft_WmiProvider_DeleteInstanceAsyncEvent_Pre ,
	Msft_WmiProvider_CreateInstanceEnumAsyncEvent_Pre ,
	Msft_WmiProvider_ExecQueryAsyncEvent_Pre ,
	Msft_WmiProvider_ExecNotificationQueryAsyncEvent_Pre ,
	Msft_WmiProvider_ExecMethodAsyncEvent_Pre ,

	Msft_WmiProvider_ProvideEvents_Pre ,
	Msft_WmiProvider_AccessCheck_Pre ,
	Msft_WmiProvider_CancelQuery_Pre ,
	Msft_WmiProvider_NewQuery_Pre ,

	Msft_WmiProvider_GetObjectAsyncEvent_Post ,
	Msft_WmiProvider_PutClassAsyncEvent_Post ,
	Msft_WmiProvider_DeleteClassAsyncEvent_Post ,
	Msft_WmiProvider_CreateClassEnumAsyncEvent_Post ,
	Msft_WmiProvider_PutInstanceAsyncEvent_Post ,
	Msft_WmiProvider_DeleteInstanceAsyncEvent_Post ,
	Msft_WmiProvider_CreateInstanceEnumAsyncEvent_Post ,
	Msft_WmiProvider_ExecQueryAsyncEvent_Post ,
	Msft_WmiProvider_ExecNotificationQueryAsyncEvent_Post ,
	Msft_WmiProvider_ExecMethodAsyncEvent_Post ,

	Msft_WmiProvider_ProvideEvents_Post ,
	Msft_WmiProvider_AccessCheck_Post ,
	Msft_WmiProvider_CancelQuery_Post ,
	Msft_WmiProvider_NewQuery_Post

} ;

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

class ProviderSubSystem_Globals
{
public:

	static LONG s_Initialized ;

	static WmiAllocator *s_Allocator ;

	static CriticalSection s_DecoupledRegistrySection ;

	static HANDLE s_FileMapping ;
	static CServerObject_ProviderSubsystem_Counters *s_SharedCounters ;

	static CriticalSection s_GuidTagSection ;
	static CWbemGlobal_ComServerTagContainer *s_GuidTag ;

	static HostController *s_HostController ;
	static RefresherManagerController *s_RefresherManagerController ;
	static CWbemGlobal_HostedProviderController *s_HostedProviderController ;
	static CWbemGlobal_IWmiProvSubSysController *s_ProvSubSysController ;
	static CWbemGlobal_IWbemSyncProviderController *s_SyncProviderController ;
	static CDecoupled_ProviderSubsystemRegistrar *s_DecoupledRegistrar ;
	static StrobeThread *s_StrobeThread ;

	static LONG s_LocksInProgress ;
	static LONG s_ObjectsInProgress ;

	static HANDLE s_CoFreeUnusedLibrariesEvent ;

	static LPCWSTR s_HostJobObjectName ;
	static HANDLE s_HostJobObject ;

	static ULONG s_InternalCacheTimeout ;
	static ULONG s_ObjectCacheTimeout ;
	static ULONG s_EventCacheTimeout ;
	static ULONG s_StrobeTimeout ;
	static SIZE_T s_Quota_ProcessMemoryLimitCount ;
	static SIZE_T s_Quota_JobMemoryLimitCount ;
	static SIZE_T s_Quota_PrivatePageCount ;
	static ULONG s_Quota_ProcessLimitCount ;
	static ULONG s_Quota_HandleCount ;
	static ULONG s_Quota_NumberOfThreads ;

    static LONG s_CServerClassFactory_ObjectsInProgress ;
    static LONG s_CAggregator_IWbemProvider_ObjectsInProgress ;
	static LONG s_CInterceptor_IWbemObjectSink_ObjectsInProgress ;
	static LONG s_CInterceptor_IWbemObjectSinkEx_ObjectsInProgress ;
	static LONG s_CInterceptor_IWbemFilteringObjectSink_ObjectsInProgress ;
	static LONG s_CInterceptor_IWbemSyncObjectSink_ObjectsInProgress ;
	static LONG s_CInterceptor_IWbemSyncObjectSinkEx_ObjectsInProgress ;
	static LONG s_CInterceptor_IWbemSyncFilteringObjectSink_ObjectsInProgress ;
	static LONG s_CInterceptor_IWbemCombiningObjectSink_ObjectsInProgress ;
	static LONG s_CInterceptor_IWbemWaitingObjectSink_ObjectsInProgress ;
    static LONG s_CInterceptor_IWbemProviderInitSink_ObjectsInProgress ;
    static LONG s_CInterceptor_IWbemProvider_ObjectsInProgress ;
    static LONG s_CInterceptor_IWbemSyncProvider_ObjectsInProgress ;
    static LONG s_CInterceptor_IWbemServices_Stub_ObjectsInProgress ;
	static LONG s_CInterceptor_IWbemServices_Proxy_ObjectsInProgress ;
	static LONG s_CInterceptor_IWbemServices_Interceptor_ObjectsInProgress ;
	static LONG s_CInterceptor_IWbemServices_RestrictingInterceptor_ObjectsInProgress ;
	static LONG s_CInterceptor_IEnumWbemClassObject_Stub_ObjectsInProgress ;
	static LONG s_CInterceptor_IEnumWbemClassObject_Proxy_ObjectsInProgress ;
	static LONG s_CInterceptor_IWbemUnboundObjectSink_ObjectsInProgress	;
	static LONG s_CInterceptor_IWbemSyncUnboundObjectSink_ObjectsInProgress	;
	static LONG s_CInterceptor_IWbemDecoupledProvider_ObjectsInProgress ;
	static LONG s_CDecoupled_IWbemUnboundObjectSink_ObjectsInProgress ;
	static LONG s_CServerObject_Host_ObjectsInProgress ;
	static LONG s_CServerObject_HostInterceptor_ObjectsInProgress ;
    static LONG s_CServerObject_BindingFactory_ObjectsInProgress ;
    static LONG s_CServerObject_DynamicPropertyProviderResolver_ObjectsInProgress ;
    static LONG s_CServerObject_IWbemServices_ObjectsInProgress ;
    static LONG s_CServerObject_ProviderSubsystem_Counters_ObjectsInProgress ;
    static LONG s_CServerObject_ProviderSubSystem_ObjectsInProgress ;
    static LONG s_CServerObject_RawFactory_ObjectsInProgress ;
    static LONG s_CServerObject_StaThread_ObjectsInProgress ;
    static LONG s_StaTask_Create_ObjectsInProgress ;
    static LONG s_StrobeThread_ObjectsInProgress ;
	static LONG s_CDecoupledAggregator_IWbemProvider_ObjectsInProgress ;
	static LONG s_CDecoupled_ProviderSubsystemRegistrar_ObjectsInProgress ;
	static LONG s_CServerObject_ProviderRefresherManager_ObjectsInProgress ;
	static LONG s_CServerObject_InterceptorProviderRefresherManager_ObjectsInProgress ;
	static LONG s_CServerProvRefreshManagerClassFactory_ObjectsInProgress ;

	static HRESULT Global_Startup () ;
	static HRESULT Global_Shutdown () ;

	static LPCWSTR s_FileMappingName ;

	static LPCWSTR s_QueryPrefix ;
	static ULONG s_QueryPrefixLen ;

	static LPCWSTR s_QueryPostfix ;
	static ULONG s_QueryPostfixLen ;

	static ULONG s_QueryConstantsLen ;

	static LPCWSTR s_Provider ;
	static ULONG s_ProviderLen ;

	static LPCWSTR s_Class ;
	static ULONG s_ClassLen ;

	static LPCWSTR s_Wql ;

	static LPCWSTR s_DynProps ;

	static LPCWSTR s_ClassContext ;
	static LPCWSTR s_InstanceContext ;
	static LPCWSTR s_PropertyContext ;

	static LPCWSTR s_Dynamic ;

	static LPCWSTR s_ProviderSubsystemEventSourceName ;
	static HANDLE s_NtEventLogSource ;

	static HANDLE s_EventSource ;
	static LPWSTR s_EventPropertySources [] ;
	static HANDLE s_EventClassHandles [] ;
	static ULONG s_EventClassHandlesSize ;

	static HRESULT CreateJobObject () ;
	static HRESULT DeleteJobObject () ;
	static HRESULT AssignProcessToJobObject ( HANDLE a_Handle ) ;

	static HRESULT Initialize_Events () ;
	static HRESULT UnInitialize_Events () ;

	static HRESULT Initialize_SharedCounters () ;
	static HRESULT UnInitialize_SharedCounters () ;

	static CWbemGlobal_ComServerTagContainer *GetGuidTag () ;
	static CriticalSection *GetGuidTagCriticalSection () ;

	static CriticalSection *GetDecoupledRegistrySection () ;

	static CWbemGlobal_IWmiProvSubSysController *GetProvSubSysController () ;

	static CWbemGlobal_IWbemSyncProviderController *GetSyncProviderController () ;

	static CWbemGlobal_HostedProviderController *GetHostedProviderController () ;

	static RefresherManagerController *GetRefresherManagerController () ;

	static HostController *GetHostController () ;

	static CServerObject_ProviderSubsystem_Counters *GetSharedCounters () { return s_SharedCounters ; }

	static StrobeThread &GetStrobeThread () { return *s_StrobeThread ; }

	static HANDLE GetNtEventSource () { return s_NtEventLogSource ; }

	static HRESULT ForwardReload (

		long a_Flags ,
		IWbemContext *a_Context ,
		LPCWSTR a_Namespace ,
		LPCWSTR a_Provider
	) ;

	static BOOL CheckGuidTag ( const GUID &a_Guid ) ;
	static void InsertGuidTag ( const GUID &a_Guid ) ;
	static void DeleteGuidTag ( const GUID &a_Guid ) ;
	static void ClearGuidTag ();

	static HRESULT BeginThreadImpersonation (

		IUnknown *&a_OldContext ,
		IServerSecurity *&a_OldSecurity ,
		BOOL &a_Impersonating
	) ;

	static HRESULT EndThreadImpersonation (

		IUnknown *a_OldContext ,
		IServerSecurity *a_OldSecurity ,
		BOOL a_Impersonating 
	) ;

	static HRESULT Begin_IdentifyCall_PrvHost (

		WmiInternalContext a_InternalContext ,
		BOOL &a_Impersonating ,
		IUnknown *&a_OldContext ,
		IServerSecurity *&a_OldSecurity
	) ;

	static HRESULT End_IdentifyCall_PrvHost (

		WmiInternalContext a_InternalContext ,
		IUnknown *&a_OldContext ,
		IServerSecurity *&a_OldSecurity ,
		BOOL &a_Impersonating 
	) ;

	static HRESULT Begin_IdentifyCall_SvcHost (

		WmiInternalContext a_InternalContext ,
		BOOL &a_Impersonating ,
		IUnknown *&a_OldContext ,
		IServerSecurity *&a_OldSecurity
	) ;

	static HRESULT End_IdentifyCall_SvcHost (

		WmiInternalContext a_InternalContext ,
		IUnknown *&a_OldContext ,
		IServerSecurity *&a_OldSecurity ,
		BOOL &a_Impersonating
	) ;

	static LONG Increment_Global_Object_Count () ;
	static LONG Decrement_Global_Object_Count () ;
} ;

#endif // _Globals_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\winmgmt\provsubsys\server\include\provcache.h ===
/*++

Copyright (C) 1996-2001 Microsoft Corporation

Module Name:

	Cache.H

Abstract:


History:

--*/

#ifndef _Server_Cache_H
#define _Server_Cache_H

#include <PssException.h>
#include <Allocator.h>
#include <Algorithms.h>
#include <TPQueue.h>
#include <BasicTree.h>
#include <Cache.h>
#include <CGlobals.h>
#include <lockst.h>
#include "ProvRegInfo.h"

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

class AutoFreeString 
{
private:

	BSTR m_String ;

protected:
public:

	AutoFreeString ( BSTR a_String = NULL ) 
	{
		m_String = a_String ;
	}

	~AutoFreeString ()
	{
		SysFreeString ( m_String ) ;
	}

	const BSTR Get () const
	{
		return m_String ;
	}

	BSTR Take ()
	{
		BSTR t_Str = m_String ;
		m_String = NULL ;
		return t_Str ;
	}

	AutoFreeString &operator= ( BSTR a_String )
	{
		SysFreeString ( m_String ) ;
		m_String = a_String ;

		return *this ;
	}
} ;

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

class HostCacheKey 
{
public:

	enum HostDesignation
	{
		e_HostDesignation_Shared
	};

	enum IdentityDesignation
	{
		e_IdentityDesignation_LocalSystem ,
		e_IdentityDesignation_LocalService ,
		e_IdentityDesignation_NetworkService ,
		e_IdentityDesignation_User
	} ;

	HostDesignation m_HostDesignation ;
	BSTR m_Group ;
	IdentityDesignation m_IdentityDesignation ;
	BSTR m_Identity ;

public:

	HostCacheKey () :

		m_Identity ( NULL ) ,
		m_Group ( NULL ) ,
		m_HostDesignation ( e_HostDesignation_Shared ) ,
		m_IdentityDesignation ( e_IdentityDesignation_LocalSystem ) 
	{
	}

	HostCacheKey ( 

		const HostCacheKey &a_Key 

	) :	m_Identity ( NULL ) ,
		m_Group ( NULL ) ,
		m_HostDesignation ( a_Key.m_HostDesignation ) ,
		m_IdentityDesignation ( a_Key.m_IdentityDesignation )
	{
		AutoFreeString t_Group ;
		AutoFreeString t_Identity ;

		if ( a_Key.m_Group )
		{
			t_Group = SysAllocString ( a_Key.m_Group ) ;
			if ( t_Group.Get () == NULL )
			{
				throw Wmi_Heap_Exception ( Wmi_Heap_Exception :: E_ALLOCATION_ERROR ) ;
			}
		}

		if ( a_Key.m_Identity )
		{
			t_Identity = SysAllocString ( a_Key.m_Identity ) ;
			if ( t_Identity.Get () == NULL )
			{
				throw Wmi_Heap_Exception ( Wmi_Heap_Exception :: E_ALLOCATION_ERROR ) ;
			}
		}

		m_Identity = t_Identity.Take () ;
		m_Group = t_Group.Take () ;
	}

	HostCacheKey ( 

		HostDesignation a_HostDesignation ,
		const wchar_t *a_Group ,
		IdentityDesignation a_IdentityDesignation ,
		const wchar_t *a_Identity

	) :	m_Identity ( NULL ) ,
		m_Group ( NULL ) ,
		m_HostDesignation ( a_HostDesignation ) ,
		m_IdentityDesignation ( a_IdentityDesignation )
	{
		AutoFreeString t_Group ;
		AutoFreeString t_Identity ;

		if ( a_Group )
		{
			t_Group = SysAllocString ( a_Group ) ;
			if ( t_Group.Get () == NULL )
			{
				throw Wmi_Heap_Exception ( Wmi_Heap_Exception :: E_ALLOCATION_ERROR ) ;
			}
		}

		if ( a_Identity )
		{
			t_Identity = SysAllocString ( a_Identity ) ;
			if ( t_Identity.Get () == NULL )
			{
				throw Wmi_Heap_Exception ( Wmi_Heap_Exception :: E_ALLOCATION_ERROR ) ;
			}
		}

		m_Identity = t_Identity.Take () ;
		m_Group = t_Group.Take () ;
	}

	~HostCacheKey ()
	{
		if ( m_Group )
		{
			SysFreeString ( m_Group ) ;
		}

		if ( m_Identity )
		{
			SysFreeString ( m_Identity ) ;
		}
	}

	HostCacheKey &operator= ( const HostCacheKey &a_Key ) 
	{
		m_HostDesignation = a_Key.m_HostDesignation ;
		m_IdentityDesignation = a_Key.m_IdentityDesignation ;

		if ( m_Group )
		{
			SysFreeString ( m_Group ) ;
		}

		if ( a_Key.m_Group )
		{
			m_Group = SysAllocString ( a_Key.m_Group ) ;
			if ( m_Group == NULL )
			{
				throw Wmi_Heap_Exception ( Wmi_Heap_Exception :: E_ALLOCATION_ERROR ) ;
			}
		}
		else
		{
			m_Group = NULL ;
		}

		if ( m_Identity )
		{
			SysFreeString ( m_Identity ) ;
		}

		if ( a_Key.m_Identity )
		{
			m_Identity = SysAllocString ( a_Key.m_Identity ) ;
			if ( m_Identity == NULL )
			{
				throw Wmi_Heap_Exception ( Wmi_Heap_Exception :: E_ALLOCATION_ERROR ) ;
			}
		}
		else
		{
			m_Identity = NULL ;
		}

		return *this ;
	}

	LONG Compare ( const HostCacheKey &a_Key ) const
	{
		if ( m_HostDesignation == a_Key.m_HostDesignation )
		{
			if ( m_HostDesignation == e_HostDesignation_Shared )
			{
				LONG t_Compare = _wcsicmp ( m_Group , a_Key.m_Group ) ;
				if ( t_Compare == 0 )
				{
				}
				else
				{
					return t_Compare ;
				}
			}

			if ( m_IdentityDesignation == a_Key.m_IdentityDesignation )
			{
				if ( m_IdentityDesignation == e_IdentityDesignation_User )
				{
					return _wcsicmp ( m_Identity , a_Key.m_Identity ) ;
				}	
				else
				{
					return 0 ;
				}
			}
			else
			{
				return m_IdentityDesignation == a_Key.m_IdentityDesignation ? 0 : ( m_IdentityDesignation < a_Key.m_IdentityDesignation ) ? -1 : 1 ;
			}
		}
		else
		{
			return m_HostDesignation == a_Key.m_HostDesignation ? 0 : ( m_HostDesignation < a_Key.m_HostDesignation ) ? -1 : 1 ;
		}
	}
} ;

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

extern LONG CompareElement ( const HostCacheKey &a_Arg1 , const HostCacheKey &a_Arg2 ) ;

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

class BindingFactoryCacheKey 
{
public:

	BSTR m_Namespace ;

public:

	BindingFactoryCacheKey () :

		m_Namespace ( NULL )
	{
	}

	BindingFactoryCacheKey ( 

		const BindingFactoryCacheKey &a_Key 

	) :	m_Namespace ( NULL )
	{
		AutoFreeString t_Namespace ;

		if ( a_Key.m_Namespace )
		{
			t_Namespace = SysAllocString ( a_Key.m_Namespace ) ;
			if ( t_Namespace.Get () == NULL )
			{
				throw Wmi_Heap_Exception ( Wmi_Heap_Exception :: E_ALLOCATION_ERROR ) ;
			}
		}

		m_Namespace = t_Namespace.Take () ;
	}

	BindingFactoryCacheKey ( 

		const wchar_t *a_Namespace 

	) :	m_Namespace ( NULL )
	{
		AutoFreeString t_Namespace ;

		if ( a_Namespace )
		{
			t_Namespace = SysAllocString ( a_Namespace ) ;
			if ( t_Namespace.Get () == NULL )
			{
				throw Wmi_Heap_Exception ( Wmi_Heap_Exception :: E_ALLOCATION_ERROR ) ;
			}
		}

		m_Namespace = t_Namespace.Take () ;
	}

	~BindingFactoryCacheKey ()
	{
		if ( m_Namespace )
		{
			SysFreeString ( m_Namespace ) ;
		}
	}


	BindingFactoryCacheKey &operator= ( const BindingFactoryCacheKey &a_Key ) 
	{
		if ( m_Namespace )
		{
			SysFreeString ( m_Namespace ) ;
		}

		if ( a_Key.m_Namespace )
		{
			m_Namespace = SysAllocString ( a_Key.m_Namespace ) ;
			if ( m_Namespace == NULL )
			{
				throw Wmi_Heap_Exception ( Wmi_Heap_Exception :: E_ALLOCATION_ERROR ) ;
			}
		}
		else
		{
			m_Namespace = NULL ;
		}
				
		return *this ;
	}

	LONG CompareNamespace ( const BSTR a_Namespace ) const
	{
		if ( m_Namespace && a_Namespace )
		{
			return _wcsicmp ( m_Namespace , a_Namespace ) ;
		}	
		else
		{
			return m_Namespace == a_Namespace ? 0 : ( m_Namespace < a_Namespace ) ? -1 : 1 ;
		}
	}

	LONG Compare ( const BindingFactoryCacheKey &a_Key ) const
	{
		return CompareNamespace ( a_Key.m_Namespace ) ;
	}
} ;

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

extern LONG CompareElement ( const BindingFactoryCacheKey &a_Arg1 , const BindingFactoryCacheKey &a_Arg2 ) ;

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

extern LONG CompareElement ( const GUID &a_Arg1 , const GUID &a_Arg2 ) ;

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

class ProviderCacheKey 
{
public:

	BSTR m_Provider ;
	ULONG m_Hosting ;
	BSTR m_Group ;
	BSTR m_User ;
	BSTR m_Locale ;
	bool m_Raw ;
	GUID *m_TransactionIdentifier ;	

public:

	ProviderCacheKey () :

		m_User ( NULL ) ,
		m_Locale ( NULL ) ,
		m_Raw ( false ) ,
		m_Provider ( NULL ) ,
		m_Hosting ( 0 ) ,
		m_Group ( NULL ) ,
		m_TransactionIdentifier ( NULL )
	{
	}

	ProviderCacheKey ( 

		const ProviderCacheKey &a_Key

	) : m_User ( NULL ) ,
		m_Locale ( NULL ) ,
		m_TransactionIdentifier ( NULL ) ,
		m_Raw ( a_Key.m_Raw ) ,
		m_Hosting ( a_Key.m_Hosting ) ,
		m_Group ( NULL ) ,
		m_Provider ( NULL )
	{
		AutoFreeString t_User ;
		AutoFreeString t_Locale ;
		AutoFreeString t_Provider ;
		AutoFreeString t_Group ;

		if ( a_Key.m_User )
		{
			t_User = SysAllocString ( a_Key.m_User ) ;
			if ( t_User.Get () == NULL )
			{
				throw Wmi_Heap_Exception ( Wmi_Heap_Exception :: E_ALLOCATION_ERROR ) ;
			}
		}

		if ( a_Key.m_Locale )
		{
			t_Locale = SysAllocString ( a_Key.m_Locale ) ;
			if ( t_Locale.Get () == NULL )
			{
				throw Wmi_Heap_Exception ( Wmi_Heap_Exception :: E_ALLOCATION_ERROR ) ;
			}
		}

		if ( a_Key.m_Provider ) 
		{
			t_Provider = SysAllocString ( a_Key.m_Provider ) ;
			if ( t_Provider.Get () == NULL )
			{
				throw Wmi_Heap_Exception ( Wmi_Heap_Exception :: E_ALLOCATION_ERROR ) ;
			}
		}

		if ( a_Key.m_Group ) 
		{
			t_Group = SysAllocString ( a_Key.m_Group ) ;
			if ( t_Group.Get () == NULL )
			{
				throw Wmi_Heap_Exception ( Wmi_Heap_Exception :: E_ALLOCATION_ERROR ) ;
			}
		}

		if ( a_Key.m_TransactionIdentifier )
		{
			m_TransactionIdentifier = new GUID ;
			if ( m_TransactionIdentifier == NULL )
			{
				throw Wmi_Heap_Exception ( Wmi_Heap_Exception :: E_ALLOCATION_ERROR ) ;
			}

			*m_TransactionIdentifier = *a_Key.m_TransactionIdentifier ;
		}

		m_User = t_User.Take () ;
		m_Locale = t_Locale.Take () ;
		m_Provider = t_Provider.Take () ;
		m_Group = t_Group.Take () ;
	}	
	
	ProviderCacheKey ( 

		const wchar_t *a_Provider ,
		const ULONG a_Hosting ,
		const wchar_t *a_Group ,
		const bool a_Raw ,
		GUID *a_TransactionIdentifier ,
		const wchar_t *a_User ,
		const wchar_t *a_Locale
	) :
		m_Raw ( a_Raw ) ,
		m_Provider ( NULL ) ,
		m_Group ( NULL ) ,
		m_Hosting ( a_Hosting ) ,
		m_TransactionIdentifier ( NULL ) ,
		m_User ( NULL ) ,
		m_Locale ( NULL )
	{
		AutoFreeString t_User ;
		AutoFreeString t_Locale ;
		AutoFreeString t_Provider ;
		AutoFreeString t_Group ;

		if ( a_User )
		{
			t_User = SysAllocString ( a_User ) ;
			if ( t_User.Get () == NULL )
			{
				throw Wmi_Heap_Exception ( Wmi_Heap_Exception :: E_ALLOCATION_ERROR ) ;
			}
		}

		if ( a_Locale )
		{
			t_Locale = SysAllocString ( a_Locale ) ;
			if ( t_Locale.Get () == NULL )
			{
				throw Wmi_Heap_Exception ( Wmi_Heap_Exception :: E_ALLOCATION_ERROR ) ;
			}
		}

		if ( a_Provider ) 
		{
			t_Provider = SysAllocString ( a_Provider ) ;
			if ( t_Provider.Get () == NULL )
			{
				throw Wmi_Heap_Exception ( Wmi_Heap_Exception :: E_ALLOCATION_ERROR ) ;
			}
		}

		if ( a_Group ) 
		{
			t_Group = SysAllocString ( a_Group ) ;
			if ( t_Group.Get () == NULL )
			{
				throw Wmi_Heap_Exception ( Wmi_Heap_Exception :: E_ALLOCATION_ERROR ) ;
			}
		}

		if ( a_TransactionIdentifier )
		{
			m_TransactionIdentifier = new GUID ;
			if ( m_TransactionIdentifier == NULL )
			{
				throw Wmi_Heap_Exception ( Wmi_Heap_Exception :: E_ALLOCATION_ERROR ) ;
			}

			*m_TransactionIdentifier = *a_TransactionIdentifier ;
		}

		m_User = t_User.Take () ;
		m_Locale = t_Locale.Take () ;
		m_Provider = t_Provider.Take () ;
		m_Group = t_Group.Take () ;
	}

	~ProviderCacheKey ()
	{
		if ( m_User )
		{
			SysFreeString ( m_User ) ;
		}

		if ( m_Locale )
		{
			SysFreeString ( m_Locale ) ;
		}

		if ( m_Provider ) 
		{
			SysFreeString ( m_Provider ) ;
		}

		if ( m_Group ) 
		{
			SysFreeString ( m_Group ) ;
		}

		if ( m_TransactionIdentifier )
		{
			delete m_TransactionIdentifier ;
		}
	}

	ProviderCacheKey &operator= ( const ProviderCacheKey &a_Key ) 
	{
		m_Raw = a_Key.m_Raw ;
		m_Hosting = a_Key.m_Hosting ;

		if ( m_User )
		{
			SysFreeString ( m_User ) ;
		}

		if ( a_Key.m_User )
		{
			m_User = SysAllocString ( a_Key.m_User ) ;
			if ( m_User == NULL )
			{
				throw Wmi_Heap_Exception ( Wmi_Heap_Exception :: E_ALLOCATION_ERROR ) ;
			}
		}
		else
		{
			m_User = NULL ;
		}

		if ( m_Locale )
		{
			SysFreeString ( m_Locale ) ;
		}

		if ( a_Key.m_Locale )
		{
			m_Locale = SysAllocString ( a_Key.m_Locale ) ;
			if ( m_Locale == NULL )
			{
				throw Wmi_Heap_Exception ( Wmi_Heap_Exception :: E_ALLOCATION_ERROR ) ;
			}
		}
		else
		{
			m_Locale = NULL ;
		}

		if ( m_Provider ) 
		{
			SysFreeString ( m_Provider ) ;
		}

		if ( a_Key.m_Provider ) 
		{
			m_Provider = SysAllocString ( a_Key.m_Provider ) ;
			if ( m_Provider == NULL )
			{
				throw Wmi_Heap_Exception ( Wmi_Heap_Exception :: E_ALLOCATION_ERROR ) ;
			}
		}
		else
		{
			m_Provider = NULL ;
		}

		if ( m_Group ) 
		{
			SysFreeString ( m_Group ) ;
		}
		
		if ( a_Key.m_Group ) 
		{
			m_Group = SysAllocString ( a_Key.m_Group ) ;
			if ( m_Group == NULL )
			{
				throw Wmi_Heap_Exception ( Wmi_Heap_Exception :: E_ALLOCATION_ERROR ) ;
			}
		}
		else
		{	
			m_Group = NULL ;
		}

		if ( m_TransactionIdentifier )
		{
			delete m_TransactionIdentifier ;
		}

		if ( a_Key.m_TransactionIdentifier )
		{
			m_TransactionIdentifier = new GUID ;
			if ( m_TransactionIdentifier == NULL )
			{
				throw Wmi_Heap_Exception ( Wmi_Heap_Exception :: E_ALLOCATION_ERROR ) ;
			}

			*m_TransactionIdentifier = *a_Key.m_TransactionIdentifier ;
		}
		else
		{
			m_TransactionIdentifier = NULL ;
		}

		return *this ;
	}

	LONG CompareUser ( const BSTR a_User ) const
	{
		if ( m_User && a_User )
		{
			return _wcsicmp ( m_User , a_User ) ;
		}	
		else
		{
			return m_User == a_User ? 0 : ( m_User < a_User ) ? -1 : 1 ;
		}
	}

	LONG CompareLocale ( const BSTR a_Locale ) const
	{
		if ( m_Locale && a_Locale )
		{
			return _wcsicmp ( m_Locale , a_Locale ) ;
		}	
		else
		{
			return m_Locale == a_Locale ? 0 : ( m_Locale < a_Locale ) ? -1 : 1 ;
		}
	}

	LONG CompareProvider ( const BSTR a_Provider ) const
	{
		if ( m_Provider && a_Provider )
		{
			return _wcsicmp ( m_Provider , a_Provider ) ;
		}	
		else
		{
			return m_Provider == a_Provider ? 0 : ( m_Provider < a_Provider ) ? -1 : 1 ;
		}
	}

	LONG CompareGroup ( const BSTR a_Group ) const
	{
		if ( m_Group && a_Group )
		{
			return _wcsicmp ( m_Group , a_Group ) ;
		}	
		else
		{
			return m_Group == a_Group ? 0 : ( m_Group < a_Group ) ? -1 : 1 ;
		}
	}

	LONG CompareHosting ( const DWORD a_Hosting ) const
	{
		return m_Hosting == a_Hosting ? 0 : ( m_Hosting < a_Hosting ) ? -1 : 1 ;
	}

	LONG CompareTransaction ( const GUID *a_TransactionIdentifier ) const 
	{
		if ( m_TransactionIdentifier && a_TransactionIdentifier )
		{
			return CompareElement ( *m_TransactionIdentifier , *a_TransactionIdentifier ) ;
		}	
		else
		{
			return m_TransactionIdentifier == a_TransactionIdentifier ? 0 : ( m_TransactionIdentifier < a_TransactionIdentifier ) ? -1 : 1 ;
		}
	}

	LONG Compare ( const ProviderCacheKey &a_Key ) const
	{
		LONG t_CompareProvider = CompareProvider ( a_Key.m_Provider ) ;
		if ( t_CompareProvider == 0 )
		{
			LONG t_CompareHosting = CompareHosting ( a_Key.m_Hosting ) ;
			if ( t_CompareHosting == 0 )
			{
				LONG t_CompareGroup = CompareGroup ( a_Key.m_Group ) ;
				if ( t_CompareGroup == 0 )
				{
					LONG t_CompareUser = CompareUser ( a_Key.m_User ) ;
					if ( t_CompareUser == 0 )
					{
						LONG t_CompareLocale = CompareLocale ( a_Key.m_Locale ) ;
						if ( t_CompareLocale == 0 )
						{
							if ( m_Raw == a_Key.m_Raw ) 
							{
									return CompareElement ( m_TransactionIdentifier , a_Key.m_TransactionIdentifier ) ;
							}
							else
							{
								return m_Raw - a_Key.m_Raw ;
							}
						}	
						else
						{
							return t_CompareLocale ;
						}
					}	
					else
					{
						return t_CompareUser ;
					}
				}
				else
				{
					return t_CompareGroup ;
				}
			}
			else
			{
				return t_CompareHosting ;
			}
		}
		else
		{
			return t_CompareProvider ;
		}
	}
} ;

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

extern LONG CompareElement ( const ProviderCacheKey &a_Arg1 , const ProviderCacheKey &a_Arg2 ) ;

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

typedef WmiAvlTree	<GUID,GUID>					CWbemGlobal_ComServerTagContainer ;
typedef WmiAvlTree	<GUID,GUID>	:: Iterator		CWbemGlobal_ComServerTagContainer_Iterator ;

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

class CServerObject_HostInterceptor ;

typedef WmiCacheController <HostCacheKey>					CWbemGlobal_IWmiHostController ;
typedef CWbemGlobal_IWmiHostController :: Cache				CWbemGlobal_IWmiHostController_Cache ;
typedef CWbemGlobal_IWmiHostController :: Cache_Iterator	CWbemGlobal_IWmiHostController_Cache_Iterator ;
typedef CWbemGlobal_IWmiHostController :: WmiCacheElement	HostCacheElement ;

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

class CServerObject_InterceptorProviderRefresherManager ;

typedef WmiCacheController <void *>										CWbemGlobal_IWbemRefresherMgrController ;
typedef CWbemGlobal_IWbemRefresherMgrController :: Cache				CWbemGlobal_IWbemRefresherMgrController_Cache ;
typedef CWbemGlobal_IWbemRefresherMgrController :: Cache_Iterator		CWbemGlobal_IWbemRefresherMgrController_Cache_Iterator ;
typedef CWbemGlobal_IWbemRefresherMgrController :: WmiCacheElement		RefresherManagerCacheElement ;

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

class CServerObject_BindingFactory ;

typedef WmiCacheController <BindingFactoryCacheKey>				CWbemGlobal_IWmiFactoryController ;
typedef CWbemGlobal_IWmiFactoryController :: Cache				CWbemGlobal_IWmiFactoryController_Cache ;
typedef CWbemGlobal_IWmiFactoryController :: Cache_Iterator		CWbemGlobal_IWmiFactoryController_Cache_Iterator ;
typedef CWbemGlobal_IWmiFactoryController :: WmiCacheElement	BindingFactoryCacheElement ;

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

class CInterceptor_IWbemProvider ;

typedef WmiCacheController <ProviderCacheKey>					CWbemGlobal_IWmiProviderController ;
typedef CWbemGlobal_IWmiProviderController :: Cache				CWbemGlobal_IWmiProviderController_Cache ;
typedef CWbemGlobal_IWmiProviderController :: Cache_Iterator	CWbemGlobal_IWmiProviderController_Cache_Iterator ;
typedef CWbemGlobal_IWmiProviderController :: WmiCacheElement	ServiceCacheElement ;

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

class CServerObject_ProviderSubSystem ;

typedef WmiContainerController <void *>										CWbemGlobal_IWmiProvSubSysController ;
typedef CWbemGlobal_IWmiProvSubSysController :: Container					CWbemGlobal_IWmiProvSubSysController_Container ;
typedef CWbemGlobal_IWmiProvSubSysController :: Container_Iterator			CWbemGlobal_IWmiProvSubSysController_Container_Iterator ;
typedef CWbemGlobal_IWmiProvSubSysController :: WmiContainerElement			ProvSubSysContainerElement ;

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

class CInterceptor_IWbemSyncProvider ;

typedef WmiContainerController <GUID>										CWbemGlobal_IWbemSyncProviderController ;
typedef CWbemGlobal_IWbemSyncProviderController :: Container				CWbemGlobal_IWbemSyncProvider_Container ;
typedef CWbemGlobal_IWbemSyncProviderController :: Container_Iterator		CWbemGlobal_IWbemSyncProvider_Container_Iterator ;
typedef CWbemGlobal_IWbemSyncProviderController :: WmiContainerElement		SyncProviderContainerElement ;

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

typedef WmiContainerController <DWORD>										CWbemGlobal_HostedProviderController ;
typedef CWbemGlobal_HostedProviderController :: Container					CWbemGlobal_HostedProviderController_Container ;
typedef CWbemGlobal_HostedProviderController :: Container_Iterator			CWbemGlobal_HostedProviderController_Container_Iterator ;
typedef CWbemGlobal_HostedProviderController :: WmiContainerElement			HostedProviderContainerElement ;

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

class HostController : public CWbemGlobal_IWmiHostController
{
private:
protected:
public:

	HostController ( WmiAllocator &a_Allocator ) ;

	WmiStatusCode StrobeBegin ( const ULONG &a_Period ) ;
} ;


/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

class RefresherManagerController : public CWbemGlobal_IWbemRefresherMgrController
{
private:
protected:
public:

	RefresherManagerController ( WmiAllocator &a_Allocator ) ;

	WmiStatusCode StrobeBegin ( const ULONG &a_Period ) ;
} ;


/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

class CInterceptor_IWbemProvider ;

class ProviderController : public HostedProviderContainerElement
{
public:

typedef WmiBasicTree <CInterceptor_IWbemProvider *,CInterceptor_IWbemProvider *> Container ;
typedef Container :: Iterator Container_Iterator ;

private:

	CriticalSection m_CriticalSection ;

	Container m_Container ;

public:

	ProviderController (

		WmiAllocator &a_Allocator , 
		CWbemGlobal_HostedProviderController *a_Controller ,
		DWORD a_ProcessIdentifier
	) ;

	virtual ~ProviderController () ;

	virtual STDMETHODIMP QueryInterface ( REFIID , LPVOID FAR * ) ;

	virtual STDMETHODIMP_( ULONG ) AddRef () ;

	virtual STDMETHODIMP_( ULONG ) Release () ;

	virtual WmiStatusCode Initialize () ;

	virtual WmiStatusCode UnInitialize () ;

	virtual WmiStatusCode Lock () ;

	virtual WmiStatusCode UnLock () ;

	virtual WmiStatusCode Insert (

		CInterceptor_IWbemProvider *a_Element , 
		Container_Iterator &a_Iterator
	) ;

	virtual WmiStatusCode Find ( CInterceptor_IWbemProvider * const &a_Key , Container_Iterator &a_Iterator ) ;

	virtual WmiStatusCode Delete ( CInterceptor_IWbemProvider *const & a_Key ) ;

	virtual WmiStatusCode Shutdown () ;

	WmiStatusCode GetContainer ( Container *&a_Container )
	{
		a_Container = & m_Container ;
		return e_StatusCode_Success ;
	}

} ;

#endif _Server_Cache_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\winmgmt\provsubsys\server\include\guids.h ===
/*++

Copyright (C) 1996-2001 Microsoft Corporation

Module Name:

	Guids.h

Abstract:


History:

--*/

// {4F09F43F-5BD7-49e5-97D1-A9D8D148B76A}
DEFINE_GUID(IID_CWbemProviderSubSystem, 
0x4f09f43f, 0x5bd7, 0x49e5, 0x97, 0xd1, 0xa9, 0xd8, 0xd1, 0x48, 0xb7, 0x6a);

// {61FA9B2B-D06D-4014-8ADA-0054F43F9E8A}
DEFINE_GUID(IID_CWbemGlobal_IWmiProviderController, 
0x61fa9b2b, 0xd06d, 0x4014, 0x8a, 0xda, 0x0, 0x54, 0xf4, 0x3f, 0x9e, 0x8a);

// {45C4123B-827D-4a02-9C0F-DE8384E65F42}
DEFINE_GUID(IID_CWbemGlobal_IWmiFactoryController, 
0x45c4123b, 0x827d, 0x4a02, 0x9c, 0xf, 0xde, 0x83, 0x84, 0xe6, 0x5f, 0x42);

// {F7BF10E6-A310-4530-8B63-B3354C485E2D}
DEFINE_GUID(IID_CWbemGlobal_IWmiObjectSinkController, 
0xf7bf10e6, 0xa310, 0x4530, 0x8b, 0x63, 0xb3, 0x35, 0x4c, 0x48, 0x5e, 0x2d);

// {3FA1662F-1CBF-4e1d-85C3-75D13D3DAAC8}
DEFINE_GUID(IID_CWbemSubSystemHook, 
0x3fa1662f, 0x1cbf, 0x4e1d, 0x85, 0xc3, 0x75, 0xd1, 0x3d, 0x3d, 0xaa, 0xc8);

// {2CBDE6A3-350A-4c37-BAD0-BAC62FE2AB2A}
DEFINE_GUID(IID_ProviderController, 
0x2cbde6a3, 0x350a, 0x4c37, 0xba, 0xd0, 0xba, 0xc6, 0x2f, 0xe2, 0xab, 0x2a);

// {3DCDD390-8853-40f2-99E2-EB77EAE0091F}
DEFINE_GUID(IID_CServerObject_HostInterceptor,
0x3dcdd390, 0x8853, 0x40f2, 0x99, 0xe2, 0xeb, 0x77, 0xea, 0xe0, 0x9, 0x1f);

// {AA5E5035-DF5A-4baf-8B47-DA979398164D}
DEFINE_GUID(IID_CInterceptor_IWbemProvider, 
0xaa5e5035, 0xdf5a, 0x4baf, 0x8b, 0x47, 0xda, 0x97, 0x93, 0x98, 0x16, 0x4d);

// {90A56151-A5C9-44f7-8462-F8F4A8B74B6E}
DEFINE_GUID(IID_CDecoupledAggregator_IWbemProvider, 
0x90a56151, 0xa5c9, 0x44f7, 0x84, 0x62, 0xf8, 0xf4, 0xa8, 0xb7, 0x4b, 0x6e);

// {E3ECA416-FFD4-41bd-9259-B90A2365A891}
DEFINE_GUID(IID_CAggregator_IWbemProvider, 
0xe3eca416, 0xffd4, 0x41bd, 0x92, 0x59, 0xb9, 0xa, 0x23, 0x65, 0xa8, 0x91);

// {7F598975-37E0-4a67-A992-116680F0CEDA}
DEFINE_GUID(CLSID_ProvSubSys_Provider, 
0x7f598975, 0x37e0, 0x4a67, 0xa9, 0x92, 0x11, 0x66, 0x80, 0xf0, 0xce, 0xda);

// {BBAFF296-93CC-459c-9EE6-D3E35276A21C}
DEFINE_GUID(IID_CWbemCombiningObjectSink, 
0xbbaff296, 0x93cc, 0x459c, 0x9e, 0xe6, 0xd3, 0xe3, 0x52, 0x76, 0xa2, 0x1c);

// {8D955AC7-AF43-407a-A838-C26080B6671B}
DEFINE_GUID(IID_CacheElement, 
0x8d955ac7, 0xaf43, 0x407a, 0xa8, 0x38, 0xc2, 0x60, 0x80, 0xb6, 0x67, 0x1b);

// {B052FF1D-4619-4c9b-93C2-FC8F7137F969}
DEFINE_GUID(IID_CServerObject_InterceptorProviderRefresherManager, 
0xb052ff1d, 0x4619, 0x4c9b, 0x93, 0xc2, 0xfc, 0x8f, 0x71, 0x37, 0xf9, 0x69);

// {29F06F0C-FB7F-44A5-83CD-D41705D5C525}
DEFINE_GUID(CLSID_NCProvider,
0x29F06F0C,0xFB7F,0x44A5,0x83,0xCD,0xD4,0x17,0x05,0xD5,0xC5,0x25);

// {48D17DED-BC50-41b6-9821-2191EE6AA18E}
DEFINE_GUID(IID_IObjectSink_CancelOperation, 
0x48d17ded, 0xbc50, 0x41b6, 0x98, 0x21, 0x21, 0x91, 0xee, 0x6a, 0xa1, 0x8e);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\winmgmt\provsubsys\server\include\provaggr.h ===
/*++

Copyright (C) 1996-2001 Microsoft Corporation

Module Name:

	ProvResv.H

Abstract:


History:

--*/

#ifndef _Server_Aggregator_IWbemProvider_H
#define _Server_Aggregator_IWbemProvider_H

#include "ProvDnf.h"
#include "ProvRegInfo.h"

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

class CAggregator_IWbemProvider :	public IWbemServices , 
									public _IWmiProviderInitialize , 
									public IWbemShutdown ,
									public _IWmiProviderCache ,
									public _IWmiProviderAssociatorsHelper,
									public ServiceCacheElement ,
									public CWbemGlobal_IWmiObjectSinkController

{
private:

	LONG m_ReferenceCount ;         //Object reference count
	WmiAllocator &m_Allocator ;

	_IWmiProviderFactory *m_Factory ;

	IWbemServices *m_CoreRepositoryStub ;
	IWbemServices *m_CoreFullStub ;

	BSTR m_User ;
	BSTR m_Locale ;

	ULONG m_ClassProvidersCount ;
	CServerObject_ProviderRegistrationV1 **m_ClassProviders ;

	LONG m_Initialized ;
	HRESULT m_InitializeResult ;
	HANDLE m_InitializedEvent ;
	IWbemContext *m_InitializationContext ;

private:

	QueryPreprocessor :: QuadState IsA (

		IWbemClassObject *a_Left ,
		IWbemClassObject *a_Right ,
		LONG &a_LeftLength ,
		LONG &a_RightLength ,
		BOOL &a_LeftIsA
	) ;

	QueryPreprocessor :: QuadState EnumDeep_RecursiveEvaluate ( 

		IWbemClassObject *a_Class ,
		IWbemContext *a_Context , 
		WmiTreeNode *&a_Node
	) ;

	QueryPreprocessor :: QuadState EnumDeep_Evaluate ( 

		IWbemClassObject *a_Class ,
		IWbemContext *a_Context , 
		WmiTreeNode *&a_Node
	) ;

	QueryPreprocessor :: QuadState EnumShallow_RecursiveEvaluate ( 

		IWbemClassObject *a_Class ,
		IWbemContext *a_Context , 
		WmiTreeNode *&a_Node
	) ;

	QueryPreprocessor :: QuadState EnumShallow_Evaluate ( 

		IWbemClassObject *a_Class ,
		IWbemContext *a_Context , 
		WmiTreeNode *&a_Node
	) ;

	QueryPreprocessor :: QuadState Get_RecursiveEvaluate ( 

		wchar_t *a_Class ,
		IWbemContext *a_Context , 
		WmiTreeNode *&a_Node
	) ;

	QueryPreprocessor :: QuadState Get_Evaluate ( 

		wchar_t *a_Class ,
		IWbemContext *a_Context , 
		WmiTreeNode *&a_Node
	) ;

	HRESULT Enum_ClassProviders (

		IWbemServices *a_Repository ,
		IWbemContext *a_Context 
	) ;

	HRESULT PutClass_Helper_Advisory ( 

		IWbemClassObject *a_ClassObject, 
		long a_Flags, 
		IWbemContext *a_Context,
		IWbemObjectSink *a_Sink
	) ;

	HRESULT PutClass_Helper_Put_CreateOrUpdate ( 

		BSTR a_Class ,
		IWbemClassObject *a_Object, 
		long a_Flags, 
		IWbemContext *a_Context,
		IWbemObjectSink *a_Sink
	) ;

	HRESULT PutClass_Helper_Put ( 
			
		IWbemClassObject *a_Object, 
		long a_Flags, 
		IWbemContext *a_Context,
		IWbemObjectSink *a_Sink
	) ;

	HRESULT DeleteClass_Helper_Advisory ( 

		IWbemClassObject *a_ClassObject ,
		BSTR a_Class, 
		long a_Flags, 
		IWbemContext *a_Context,
		IWbemObjectSink *a_Sink
	) ;

	HRESULT DeleteClass_Helper_Enum ( 

		IWbemClassObject *a_ClassObject ,
		BSTR a_Class, 
		long a_Flags, 
		IWbemContext *a_Context,
		IWbemObjectSink *a_Sink
	) ;

	HRESULT DeleteClass_Helper_Get ( 

		IWbemClassObject *a_ClassObject ,
		BSTR a_Class, 
		long a_Flags, 
		IWbemContext *a_Context,
		IWbemObjectSink *a_Sink
	) ;

public:

	CAggregator_IWbemProvider ( 

		WmiAllocator &m_Allocator ,
		CWbemGlobal_IWmiProviderController *a_Controller , 
		_IWmiProviderFactory *a_Factory ,
		IWbemServices *a_CoreRepositoryStub ,
		IWbemServices *a_CoreFullStub ,
		const ProviderCacheKey &a_Key ,
		const ULONG &a_Period ,
		IWbemContext *a_InitializationContext
	) ;
	
    ~CAggregator_IWbemProvider () ;

	HRESULT SetInitialized ( HRESULT a_Result ) ;

	HRESULT IsIndependant ( IWbemContext *a_Context ) ;

	HRESULT Enum_ClassProviders ( IWbemContext *a_Context ) ;

public:

	//Non-delegating object IUnknown

    STDMETHODIMP QueryInterface ( REFIID , LPVOID FAR * ) ;
    STDMETHODIMP_( ULONG ) AddRef () ;
    STDMETHODIMP_( ULONG ) Release () ;

    /* IWbemServices methods */

    HRESULT STDMETHODCALLTYPE OpenNamespace ( 

        const BSTR a_Namespace ,
        long a_Flags ,
        IWbemContext *a_Context ,
        IWbemServices **a_Service ,
        IWbemCallResult **a_CallResult
	) ;
    
    HRESULT STDMETHODCALLTYPE CancelAsyncCall ( 

        IWbemObjectSink *a_Sink
	) ;
    
    HRESULT STDMETHODCALLTYPE QueryObjectSink ( 

        long a_Flags ,
        IWbemObjectSink **a_Sink
	) ;
    
    HRESULT STDMETHODCALLTYPE GetObject ( 

		const BSTR a_ObjectPath ,
        long a_Flags ,
        IWbemContext *a_Context ,
        IWbemClassObject **ppObject ,
        IWbemCallResult **a_CallResult
	) ;
    
    HRESULT STDMETHODCALLTYPE GetObjectAsync (
        
		const BSTR a_ObjectPath ,
        long a_Flags ,
        IWbemContext *a_Context ,
        IWbemObjectSink *a_Sink
	) ;
    
    HRESULT STDMETHODCALLTYPE PutClass ( 

        IWbemClassObject *a_Object ,
        long a_Flags ,
        IWbemContext *a_Context ,
        IWbemCallResult **a_CallResult
	) ;
    
    HRESULT STDMETHODCALLTYPE PutClassAsync ( 

        IWbemClassObject *a_Object ,
        long a_Flags ,
        IWbemContext *a_Context ,
        IWbemObjectSink *a_Sink
	) ;
    
    HRESULT STDMETHODCALLTYPE DeleteClass ( 

        const BSTR a_Class ,
        long a_Flags ,
        IWbemContext *a_Context ,
        IWbemCallResult **a_CallResult
	) ;
    
    HRESULT STDMETHODCALLTYPE DeleteClassAsync ( 

        const BSTR a_Class ,
        long a_Flags ,
        IWbemContext *a_Context ,
        IWbemObjectSink *a_Sink
	) ;
    
    HRESULT STDMETHODCALLTYPE CreateClassEnum ( 

        const BSTR a_Superclass ,
        long a_Flags ,
        IWbemContext *a_Context ,
        IEnumWbemClassObject **a_Enum
	) ;
    
    HRESULT STDMETHODCALLTYPE CreateClassEnumAsync ( 

		const BSTR a_Superclass ,
		long a_Flags ,
		IWbemContext *a_Context ,
		IWbemObjectSink *a_Sink
	) ;
    
    HRESULT STDMETHODCALLTYPE PutInstance (

		IWbemClassObject *a_Instance ,
		long a_Flags , 
		IWbemContext *a_Context ,
		IWbemCallResult **a_CallResult
	) ;
    
    HRESULT STDMETHODCALLTYPE PutInstanceAsync (

		IWbemClassObject *a_Instance ,
		long a_Flags ,
		IWbemContext *a_Context ,
		IWbemObjectSink *a_Sink 
	) ;
    
    HRESULT STDMETHODCALLTYPE DeleteInstance ( 

		const BSTR a_ObjectPath ,
		long a_Flags ,
		IWbemContext *a_Context ,
		IWbemCallResult **a_CallResult
	) ;
    
    HRESULT STDMETHODCALLTYPE DeleteInstanceAsync ( 

		const BSTR a_ObjectPath,
		long a_Flags,
		IWbemContext *a_Context ,
		IWbemObjectSink *a_Sink
	) ;
    
    HRESULT STDMETHODCALLTYPE CreateInstanceEnum (

		const BSTR a_Class ,
		long a_Flags ,
		IWbemContext *a_Context ,
		IEnumWbemClassObject **a_Enum
	) ;
    
    HRESULT STDMETHODCALLTYPE CreateInstanceEnumAsync (

		const BSTR a_Class ,
		long a_Flags ,
		IWbemContext *a_Context ,
		IWbemObjectSink *a_Sink
	) ;
    
    HRESULT STDMETHODCALLTYPE ExecQuery ( 

		const BSTR a_QueryLanguage,
		const BSTR a_Query,
		long a_Flags ,
		IWbemContext *a_Context ,
		IEnumWbemClassObject **a_Enum
	) ;
    
    HRESULT STDMETHODCALLTYPE ExecQueryAsync (

		const BSTR a_QueryLanguage ,
		const BSTR a_Query ,
		long a_Flags ,
		IWbemContext *a_Context ,
		IWbemObjectSink *a_Sink
	) ;
    
    HRESULT STDMETHODCALLTYPE ExecNotificationQuery (

		const BSTR a_QueryLanguage ,
		const BSTR a_Query ,
		long a_Flags ,
		IWbemContext *a_Context ,
		IEnumWbemClassObject **a_Enum
	) ;
    
    HRESULT STDMETHODCALLTYPE ExecNotificationQueryAsync ( 

        const BSTR a_QueryLanguage ,
        const BSTR a_Query ,
        long a_Flags ,
        IWbemContext *a_Context ,
        IWbemObjectSink *a_Sink
	) ;
    
    HRESULT STDMETHODCALLTYPE ExecMethod (

        const BSTR a_ObjectPath ,
        const BSTR a_MethodName ,
        long a_Flags ,
        IWbemContext *a_Context ,
        IWbemClassObject *a_InParams ,
        IWbemClassObject **a_OutParams ,
        IWbemCallResult **a_CallResult
	) ;
    
    HRESULT STDMETHODCALLTYPE ExecMethodAsync ( 

		const BSTR a_ObjectPath ,
		const BSTR a_MethodName ,
		long a_Flags ,
		IWbemContext *a_Context ,
		IWbemClassObject *a_InParams ,
		IWbemObjectSink *a_Sink
	) ;

	HRESULT STDMETHODCALLTYPE Initialize (

		long a_Flags ,
		IWbemContext *a_Context ,
		GUID *a_TransactionIdentifier,
		LPCWSTR a_User,
        LPCWSTR a_Locale,
		LPCWSTR a_Namespace ,
		IWbemServices *a_Repository ,
		IWbemServices *a_Service ,
		IWbemProviderInitSink *a_Sink

	) ;

	HRESULT STDMETHODCALLTYPE WaitProvider ( IWbemContext *a_Context , ULONG a_Timeout ) ;

	HRESULT STDMETHODCALLTYPE GetInitializeResult () 
	{
		return m_InitializeResult ;
	}

	HRESULT STDMETHODCALLTYPE GetHosting ( ULONG *a_Value )
	{
		if ( a_Value )
		{
			*a_Value = e_Hosting_WmiCore ;
			return S_OK ;
		}
		else
		{
			return WBEM_E_INVALID_PARAMETER ;
		}
	}

	HRESULT STDMETHODCALLTYPE GetHostingGroup ( BSTR *a_Value )
	{
		if ( a_Value )
		{
			*a_Value = NULL ;

			return S_OK ;
		}
		else
		{
			return WBEM_E_INVALID_PARAMETER ;
		}
	}

	HRESULT STDMETHODCALLTYPE IsInternal ( BOOL *a_Value )
	{
		if ( a_Value )
		{
			*a_Value = TRUE ;
			return S_OK ;
		}
		else
		{
			return WBEM_E_INVALID_PARAMETER ;
		}
	}

	HRESULT STDMETHODCALLTYPE IsPerUserInitialization ( BOOL *a_Value )
	{
		if ( a_Value )
		{
			*a_Value = FALSE ;
			return S_OK ;
		}
		else
		{
			return WBEM_E_INVALID_PARAMETER ;
		}
	}

	HRESULT STDMETHODCALLTYPE IsPerLocaleInitialization ( BOOL *a_Value )
	{
		if ( a_Value )
		{
			*a_Value = FALSE ;
			return S_OK ;
		}
		else
		{
			return WBEM_E_INVALID_PARAMETER ;
		}
	}

	/* _IWmiProviderCache */

	HRESULT STDMETHODCALLTYPE Expel (

		long a_Flags ,
		IWbemContext *a_Context
	) ;
	HRESULT STDMETHODCALLTYPE ForceReload () ;

	HRESULT STDMETHODCALLTYPE Shutdown (

		LONG a_Flags ,
		ULONG a_MaxMilliSeconds ,
		IWbemContext *a_Context
	) ; 

	/* _IWmiProviderAssociatorsHelper */

	HRESULT STDMETHODCALLTYPE GetReferencesClasses (
		long a_Flags ,
		IWbemContext *a_Context ,
		IWbemObjectSink *a_Sink
	) ;

} ;


#endif // _Server_Aggregator_IWbemProvider_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\winmgmt\provsubsys\server\include\provdcaggr.h ===
/*++

Copyright (C) 1996-2001 Microsoft Corporation

Module Name:

	ProvResv.H

Abstract:


History:

--*/

#ifndef _Server_DecoupledAggregator_IWbemProvider_H
#define _Server_DecoupledAggregator_IWbemProvider_H

#include "ProvRegDeCoupled.h"
#include "ProvWsv.h"

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

class CDecoupled_ProviderSubsystemRegistrar :	public _IWmiProviderSubsystemRegistrar
{
private:

	LONG m_ReferenceCount ;         //Object reference count
	WmiAllocator &m_Allocator ;
	CServerObject_ProviderSubSystem *m_SubSystem ;

	HRESULT SaveToRegistry (

		long a_Flags ,
		IWbemContext *a_Context ,
		LPCWSTR a_User ,
		LPCWSTR a_Locale ,
		LPCWSTR a_Scope ,
		LPCWSTR a_Registration ,
		DWORD a_ProcessIdentifier ,
		GUID &a_Identity ,
		IUnknown *a_Unknown
	) ;

	HRESULT ValidateClientSecurity (

		IWbemContext *a_Context ,
		LPCWSTR a_Scope ,
		LPCWSTR a_Registration ,
		IWbemServices *a_Service 
	) ;

	HRESULT CacheProvider (

		CServerObject_ProviderSubSystem *a_SubSystem ,
		IWbemContext *a_Context ,
		CServerObject_DecoupledClientRegistration_Element &a_Element ,
		IUnknown *a_Unknown 
	) ;

	HRESULT Load (

		CServerObject_ProviderSubSystem *a_SubSystem ,
		IWbemContext *a_Context ,
		CServerObject_DecoupledClientRegistration_Element &a_Element
	) ;

	HRESULT MarshalRegistration (

		IUnknown *a_Unknown ,
		BYTE *&a_MarshaledProxy ,
		DWORD &a_MarshaledProxyLength
	) ;

	HRESULT SaveToRegistry (

		IUnknown *a_Unknown ,
		BYTE *a_MarshaledProxy ,
		DWORD a_MarshaledProxyLength
	) ;

protected:
public:

	CDecoupled_ProviderSubsystemRegistrar ( WmiAllocator &a_Allocator , CServerObject_ProviderSubSystem *a_SubSystem ) ;
	~CDecoupled_ProviderSubsystemRegistrar () ;

	HRESULT Load (

		CServerObject_ProviderSubSystem *a_SubSystem , 
		IWbemContext *a_Context
	) ;

	HRESULT Save () ;
	HRESULT Delete () ;

public:

	//Non-delegating object IUnknown

    STDMETHODIMP QueryInterface ( REFIID , LPVOID FAR * ) ;
    STDMETHODIMP_( ULONG ) AddRef () ;
    STDMETHODIMP_( ULONG ) Release () ;

	HRESULT STDMETHODCALLTYPE Register (

		long a_Flags ,
		IWbemContext *a_Context ,
		LPCWSTR a_User ,
		LPCWSTR a_Locale ,
		LPCWSTR a_Registration ,
		LPCWSTR a_Scope ,
		DWORD a_ProcessIdentifier ,
		IUnknown *a_Unknown ,
		GUID a_Identity 
	) ;

	HRESULT STDMETHODCALLTYPE UnRegister (

		long a_Flags ,
		IWbemContext *a_Context ,
		LPCWSTR a_User ,
		LPCWSTR a_Locale ,
		LPCWSTR a_Scope ,
		LPCWSTR a_Registration ,
		GUID a_Identity
	) ;
} ;

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

class CDecoupledAggregator_IWbemProvider :	public IWbemServices , 
											public IWbemEventProvider ,
											public IWbemEventProviderQuerySink ,
											public IWbemEventProviderSecurity ,
											public IWbemProviderIdentity ,
											public IWbemEventConsumerProviderEx ,
											public _IWmiProviderSubsystemRegistrar ,
											public _IWmiProviderInitialize ,
											public IWbemShutdown ,
											public _IWmiProviderCache ,
											public ServiceCacheElement ,
											public CWbemGlobal_IWmiObjectSinkController

{
private:

	LONG m_ReferenceCount ;         //Object reference count
	WmiAllocator &m_Allocator ;

	CWbemGlobal_IWbemSyncProviderController *m_Controller ;

	_IWmiProviderFactory *m_Factory ;

	IWbemObjectSink *m_Sink ;
	IWbemServices *m_CoreRepositoryStub ;
	IWbemServices *m_CoreFullStub ;
	IWbemPath *m_NamespacePath ;

	BSTR m_User ;
	BSTR m_Locale ;
	BSTR m_Namespace ;

	IWbemClassObject *m_ExtendedStatusObject ;
	CServerObject_ProviderRegistrationV1 *m_Registration ;

	LONG m_Initialized ;
	HRESULT m_InitializeResult ;
	HANDLE m_InitializedEvent ;
	IWbemContext *m_InitializationContext ;

private:

	HRESULT InitializeProvider ( 

		IUnknown *a_Unknown ,
		IWbemServices *a_Stub ,
		wchar_t *a_NamespacePath ,
		LONG a_Flags ,
		IWbemContext *a_Context ,
		LPCWSTR a_User ,
		LPCWSTR a_Locale ,
		LPCWSTR a_Scope ,
		CServerObject_ProviderRegistrationV1 &a_Registration
	) ;

	HRESULT CreateSyncProvider ( 

		IUnknown *a_ServerSideProvider ,
		IWbemServices *a_Stub ,
		wchar_t *a_NamespacePath ,
		LONG a_Flags ,
		IWbemContext *a_Context ,
		LPCWSTR a_User ,
		LPCWSTR a_Locale ,
		LPCWSTR a_Scope ,
		CServerObject_ProviderRegistrationV1 &a_Registration ,
		GUID a_Identity ,
		CInterceptor_IWbemDecoupledProvider *&a_Interceptor 
	) ;

	HRESULT SetStatus ( 

		LPWSTR a_Operation ,
		LPWSTR a_Parameters ,
		LPWSTR a_Description ,
		HRESULT a_Result ,
		IWbemObjectSink *a_Sink
	) ;

public:

	CDecoupledAggregator_IWbemProvider ( 

		WmiAllocator &m_Allocator ,
		CWbemGlobal_IWmiProviderController *a_Controller , 
		_IWmiProviderFactory *a_Factory ,
		IWbemServices *a_CoreRepositoryStub ,
		IWbemServices *a_CoreFullStub ,
		const ProviderCacheKey &a_Key ,
		const ULONG &a_Period ,
		IWbemContext *a_InitializationContext ,
		CServerObject_ProviderRegistrationV1 &a_Registration
	) ;
	
    ~CDecoupledAggregator_IWbemProvider () ;

	HRESULT SetInitialized ( HRESULT a_InitializeResult ) ;

	HRESULT IsIndependant ( IWbemContext *a_Context ) ;

	HRESULT AbnormalShutdown ( IUnknown *t_Element ) ;

public:

	//Non-delegating object IUnknown

    STDMETHODIMP QueryInterface ( REFIID , LPVOID FAR * ) ;
    STDMETHODIMP_( ULONG ) AddRef () ;
    STDMETHODIMP_( ULONG ) Release () ;

    /* IWbemServices methods */

    HRESULT STDMETHODCALLTYPE OpenNamespace ( 

        const BSTR a_Namespace ,
        long a_Flags ,
        IWbemContext *a_Context ,
        IWbemServices **a_Service ,
        IWbemCallResult **a_CallResult
	) ;
    
    HRESULT STDMETHODCALLTYPE CancelAsyncCall ( 

        IWbemObjectSink *a_Sink
	) ;
    
    HRESULT STDMETHODCALLTYPE QueryObjectSink ( 

        long a_Flags ,
        IWbemObjectSink **a_Sink
	) ;
    
    HRESULT STDMETHODCALLTYPE GetObject ( 

		const BSTR a_ObjectPath ,
        long a_Flags ,
        IWbemContext *a_Context ,
        IWbemClassObject **ppObject ,
        IWbemCallResult **a_CallResult
	) ;
    
    HRESULT STDMETHODCALLTYPE GetObjectAsync (
        
		const BSTR a_ObjectPath ,
        long a_Flags ,
        IWbemContext *a_Context ,
        IWbemObjectSink *a_Sink
	) ;
    
    HRESULT STDMETHODCALLTYPE PutClass ( 

        IWbemClassObject *a_Object ,
        long a_Flags ,
        IWbemContext *a_Context ,
        IWbemCallResult **a_CallResult
	) ;
    
    HRESULT STDMETHODCALLTYPE PutClassAsync ( 

        IWbemClassObject *a_Object ,
        long a_Flags ,
        IWbemContext *a_Context ,
        IWbemObjectSink *a_Sink
	) ;
    
    HRESULT STDMETHODCALLTYPE DeleteClass ( 

        const BSTR a_Class ,
        long a_Flags ,
        IWbemContext *a_Context ,
        IWbemCallResult **a_CallResult
	) ;
    
    HRESULT STDMETHODCALLTYPE DeleteClassAsync ( 

        const BSTR a_Class ,
        long a_Flags ,
        IWbemContext *a_Context ,
        IWbemObjectSink *a_Sink
	) ;
    
    HRESULT STDMETHODCALLTYPE CreateClassEnum ( 

        const BSTR a_Superclass ,
        long a_Flags ,
        IWbemContext *a_Context ,
        IEnumWbemClassObject **a_Enum
	) ;
    
    HRESULT STDMETHODCALLTYPE CreateClassEnumAsync ( 

		const BSTR a_Superclass ,
		long a_Flags ,
		IWbemContext *a_Context ,
		IWbemObjectSink *a_Sink
	) ;
    
    HRESULT STDMETHODCALLTYPE PutInstance (

		IWbemClassObject *a_Instance ,
		long a_Flags , 
		IWbemContext *a_Context ,
		IWbemCallResult **a_CallResult
	) ;
    
    HRESULT STDMETHODCALLTYPE PutInstanceAsync (

		IWbemClassObject *a_Instance ,
		long a_Flags ,
		IWbemContext *a_Context ,
		IWbemObjectSink *a_Sink 
	) ;
    
    HRESULT STDMETHODCALLTYPE DeleteInstance ( 

		const BSTR a_ObjectPath ,
		long a_Flags ,
		IWbemContext *a_Context ,
		IWbemCallResult **a_CallResult
	) ;
    
    HRESULT STDMETHODCALLTYPE DeleteInstanceAsync ( 

		const BSTR a_ObjectPath,
		long a_Flags,
		IWbemContext *a_Context ,
		IWbemObjectSink *a_Sink
	) ;
    
    HRESULT STDMETHODCALLTYPE CreateInstanceEnum (

		const BSTR a_Class ,
		long a_Flags ,
		IWbemContext *a_Context ,
		IEnumWbemClassObject **a_Enum
	) ;
    
    HRESULT STDMETHODCALLTYPE CreateInstanceEnumAsync (

		const BSTR a_Class ,
		long a_Flags ,
		IWbemContext *a_Context ,
		IWbemObjectSink *a_Sink
	) ;
    
    HRESULT STDMETHODCALLTYPE ExecQuery ( 

		const BSTR a_QueryLanguage,
		const BSTR a_Query,
		long a_Flags ,
		IWbemContext *a_Context ,
		IEnumWbemClassObject **a_Enum
	) ;
    
    HRESULT STDMETHODCALLTYPE ExecQueryAsync (

		const BSTR a_QueryLanguage ,
		const BSTR a_Query ,
		long a_Flags ,
		IWbemContext *a_Context ,
		IWbemObjectSink *a_Sink
	) ;
    
    HRESULT STDMETHODCALLTYPE ExecNotificationQuery (

		const BSTR a_QueryLanguage ,
		const BSTR a_Query ,
		long a_Flags ,
		IWbemContext *a_Context ,
		IEnumWbemClassObject **a_Enum
	) ;
    
    HRESULT STDMETHODCALLTYPE ExecNotificationQueryAsync ( 

        const BSTR a_QueryLanguage ,
        const BSTR a_Query ,
        long a_Flags ,
        IWbemContext *a_Context ,
        IWbemObjectSink *a_Sink
	) ;
    
    HRESULT STDMETHODCALLTYPE ExecMethod (

        const BSTR a_ObjectPath ,
        const BSTR a_MethodName ,
        long a_Flags ,
        IWbemContext *a_Context ,
        IWbemClassObject *a_InParams ,
        IWbemClassObject **a_OutParams ,
        IWbemCallResult **a_CallResult
	) ;
    
    HRESULT STDMETHODCALLTYPE ExecMethodAsync ( 

		const BSTR a_ObjectPath ,
		const BSTR a_MethodName ,
		long a_Flags ,
		IWbemContext *a_Context ,
		IWbemClassObject *a_InParams ,
		IWbemObjectSink *a_Sink
	) ;

	/* IWbemEventProvider */

	HRESULT STDMETHODCALLTYPE ProvideEvents (

		IWbemObjectSink *a_Sink ,
		long a_Flags
	) ;

	/* IWbemEventProviderQuerySink */

	HRESULT STDMETHODCALLTYPE NewQuery (

		unsigned long a_Id ,
		WBEM_WSTR a_QueryLanguage ,
		WBEM_WSTR a_Query
	);

	HRESULT STDMETHODCALLTYPE CancelQuery (

		unsigned long a_Id
	) ;

	/* IWbemEventProviderSecurity */

	HRESULT STDMETHODCALLTYPE AccessCheck (

		WBEM_CWSTR a_QueryLanguage ,
		WBEM_CWSTR a_Query ,
		long a_SidLength ,
		const BYTE *a_Sid
	) ;

	/* IWbemProviderIdentity */

	HRESULT STDMETHODCALLTYPE SetRegistrationObject (

		long a_Flags ,
		IWbemClassObject *a_ProviderRegistration
	) ;

	/* IWbemEventConsumerProvider */

	HRESULT STDMETHODCALLTYPE FindConsumer (

		IWbemClassObject *a_LogicalConsumer ,
		IWbemUnboundObjectSink **a_Consumer
	);

	/* IWbemEventConsumerProviderEx */

	HRESULT STDMETHODCALLTYPE ValidateSubscription (

		IWbemClassObject *a_LogicalConsumer
	) ;

	HRESULT STDMETHODCALLTYPE Register (

		long a_Flags ,
		IWbemContext *a_Context ,
		LPCWSTR a_Scope ,
		LPCWSTR a_User ,
		LPCWSTR a_Locale ,
		LPCWSTR a_Registration ,
		DWORD a_ProcessIdentifier ,
		IUnknown *a_Unknown ,
		GUID a_Identity
	) ;

	HRESULT STDMETHODCALLTYPE UnRegister (

		long a_Flags ,
		IWbemContext *a_Context ,
		LPCWSTR a_User ,
		LPCWSTR a_Locale ,
		LPCWSTR a_Scope ,
		LPCWSTR a_Registration ,
		GUID a_Identity
	) ;

	HRESULT STDMETHODCALLTYPE Initialize (

		long a_Flags ,
		IWbemContext *a_Context ,
		GUID *a_TransactionIdentifier,
		LPCWSTR a_User,
        LPCWSTR a_Locale,
		LPCWSTR a_Namespace ,
		IWbemServices *a_Repository ,
		IWbemServices *a_Service ,
		IWbemProviderInitSink *a_Sink

	) ;

	HRESULT STDMETHODCALLTYPE WaitProvider ( IWbemContext *a_Context , ULONG a_Timeout ) ;

	HRESULT STDMETHODCALLTYPE GetInitializeResult () 
	{
		return m_InitializeResult ;
	}

	HRESULT STDMETHODCALLTYPE GetHosting ( ULONG *a_Value )
	{
		if ( a_Value )
		{
			*a_Value = e_Hosting_WmiCore ;
			return S_OK ;
		}
		else
		{
			return WBEM_E_INVALID_PARAMETER ;
		}
	}

	HRESULT STDMETHODCALLTYPE GetHostingGroup ( BSTR *a_Value )
	{
		if ( a_Value )
		{
			*a_Value = NULL ;

			return S_OK ;
		}
		else
		{
			return WBEM_E_INVALID_PARAMETER ;
		}
	}

	HRESULT STDMETHODCALLTYPE IsInternal ( BOOL *a_Value )
	{
		if ( a_Value )
		{
			*a_Value = TRUE ;
			return S_OK ;
		}
		else
		{
			return WBEM_E_INVALID_PARAMETER ;
		}
	}

	HRESULT STDMETHODCALLTYPE IsPerUserInitialization ( BOOL *a_Value )
	{
		if ( a_Value )
		{
			*a_Value = FALSE ;
			return S_OK ;
		}
		else
		{
			return WBEM_E_INVALID_PARAMETER ;
		}
	}

	HRESULT STDMETHODCALLTYPE IsPerLocaleInitialization ( BOOL *a_Value )
	{
		if ( a_Value )
		{
			*a_Value = FALSE ;
			return S_OK ;
		}
		else
		{
			return WBEM_E_INVALID_PARAMETER ;
		}
	}

	/* _IWmiProviderCache */

	HRESULT STDMETHODCALLTYPE Expel (

		long a_Flags ,
		IWbemContext *a_Context
	) ;

	HRESULT STDMETHODCALLTYPE Unload (

		long a_Flags ,
		IWbemContext *a_Context
	) ;

	HRESULT STDMETHODCALLTYPE Load (

		long a_Flags ,
		IWbemContext *a_Context
	) ;

	HRESULT STDMETHODCALLTYPE ForceReload () ;

	HRESULT STDMETHODCALLTYPE Shutdown (

		LONG a_Flags ,
		ULONG a_MaxMilliSeconds ,
		IWbemContext *a_Context
	) ; 
} ;


#endif // _Server_DecoupledAggregator_IWbemProvider_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\winmgmt\provsubsys\server\include\provcntrs.h ===
/*++

Copyright (C) 1996-2001 Microsoft Corporation

Module Name:

	ProvFact.h

Abstract:


History:

--*/

#ifndef _Server_ProviderCounters_H
#define _Server_ProviderCounters_H

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

class CServerObject_ProviderSubsystem_Counters 
{
public:

    UINT64 m_ProviderHost_WmiCore_Loads ;
    UINT64 m_ProviderHost_WmiCore_UnLoads ;

	UINT64 m_ProviderHost_WmiCoreOrSelfHost_Loads ;
	UINT64 m_ProviderHost_WmiCoreOrSelfHost_UnLoads ;

	UINT64 m_ProviderHost_SelfHost_Loads ;
	UINT64 m_ProviderHost_SelfHost_UnLoads ;

	UINT64 m_ProviderHost_ClientHost_Loads ;
	UINT64 m_ProviderHost_ClientHost_UnLoads ;

	UINT64 m_ProviderHost_Decoupled_Loads ;
	UINT64 m_ProviderHost_Decoupled_UnLoads ;

	UINT64 m_ProviderHost_SharedLocalSystemHost_Loads ;
	UINT64 m_ProviderHost_SharedLocalSystemHost_UnLoads ;

	UINT64 m_ProviderHost_SharedNetworkHost_Loads ;
	UINT64 m_ProviderHost_SharedNetworkHost_UnLoads ;

	UINT64 m_ProviderHost_SharedUserHost_Loads ;
	UINT64 m_ProviderHost_SharedUserHost_UnLoads ;

	UINT64 m_ProviderOperation_GetObjectAsync ;
	UINT64 m_ProviderOperation_PutClassAsync ;
	UINT64 m_ProviderOperation_DeleteClassAsync ;
	UINT64 m_ProviderOperation_CreateClassEnumAsync ;
	UINT64 m_ProviderOperation_PutInstanceAsync ;
	UINT64 m_ProviderOperation_DeleteInstanceAsync ;
	UINT64 m_ProviderOperation_CreateInstanceEnumAsync ;
	UINT64 m_ProviderOperation_ExecQueryAsync ;
	UINT64 m_ProviderOperation_ExecNotificationQueryAsync ;
	UINT64 m_ProviderOperation_ExecMethodAsync ;

	UINT64 m_ProviderOperation_QueryInstances ;
	UINT64 m_ProviderOperation_CreateRefresher ;
	UINT64 m_ProviderOperation_CreateRefreshableObject ;
	UINT64 m_ProviderOperation_StopRefreshing ;
	UINT64 m_ProviderOperation_CreateRefreshableEnum ;
	UINT64 m_ProviderOperation_GetObjects ;

	UINT64 m_ProviderOperation_GetProperty ;
	UINT64 m_ProviderOperation_PutProperty ;

	UINT64 m_ProviderOperation_ProvideEvents ;
	UINT64 m_ProviderOperation_NewQuery ;
	UINT64 m_ProviderOperation_CancelQuery ;
	UINT64 m_ProviderOperation_AccessCheck ;
	UINT64 m_ProviderOperation_SetRegistrationObject ;
	UINT64 m_ProviderOperation_FindConsumer ;
	UINT64 m_ProviderOperation_ValidateSubscription ;

protected:

public:	/* Internal */

    CServerObject_ProviderSubsystem_Counters () ;
    ~CServerObject_ProviderSubsystem_Counters () ;

public:	/* External */

    void Increment_ProviderHost_WmiCore_Loads () { m_ProviderHost_WmiCore_Loads ++ ; }
    void Increment_ProviderHost_WmiCore_UnLoads () { m_ProviderHost_WmiCore_UnLoads ++ ; }

	void Increment_ProviderHost_WmiCoreOrSelfHost_Loads () { m_ProviderHost_WmiCoreOrSelfHost_Loads ++ ; }
	void Increment_ProviderHost_WmiCoreOrSelfHost_UnLoads () { m_ProviderHost_WmiCoreOrSelfHost_UnLoads ++ ; }

	void Increment_ProviderHost_SelfHost_Loads () { m_ProviderHost_SelfHost_Loads ++ ; }
	void Increment_ProviderHost_SelfHost_UnLoads () { m_ProviderHost_SelfHost_UnLoads ++ ; }

	void Increment_ProviderHost_ClientHost_Loads () { m_ProviderHost_ClientHost_Loads ++ ; }
	void Increment_ProviderHost_ClientHost_UnLoads () { m_ProviderHost_ClientHost_UnLoads ++ ; }

	void Increment_ProviderHost_Decoupled_Loads () { m_ProviderHost_Decoupled_Loads ++ ; }
	void Increment_ProviderHost_Decoupled_UnLoads () { m_ProviderHost_Decoupled_UnLoads ++ ; }

	void Increment_ProviderHost_SharedLocalSystemHost_Loads () { m_ProviderHost_SharedLocalSystemHost_Loads ++ ; }
	void Increment_ProviderHost_SharedLocalSystemHost_UnLoads () { m_ProviderHost_SharedLocalSystemHost_UnLoads ++ ; }

	void Increment_ProviderHost_SharedNetworkHost_Loads () { m_ProviderHost_SharedNetworkHost_Loads ++ ; }
	void Increment_ProviderHost_SharedNetworkHost_UnLoads () { m_ProviderHost_SharedNetworkHost_UnLoads ++ ; }

	void Increment_ProviderHost_SharedUserHost_Loads () { m_ProviderHost_SharedUserHost_Loads ++ ; }
	void Increment_ProviderHost_SharedUserHost_UnLoads () { m_ProviderHost_SharedUserHost_UnLoads ++ ; }

	void Increment_ProviderOperation_GetObjectAsync () { m_ProviderOperation_GetObjectAsync ++ ; }
 	void Increment_ProviderOperation_PutClassAsync () { m_ProviderOperation_PutClassAsync ++ ; }
	void Increment_ProviderOperation_DeleteClassAsync () { m_ProviderOperation_DeleteClassAsync ++ ; }
	void Increment_ProviderOperation_CreateClassEnumAsync () { m_ProviderOperation_CreateClassEnumAsync ++ ; }
	void Increment_ProviderOperation_PutInstanceAsync () { m_ProviderOperation_PutInstanceAsync ++ ; }
	void Increment_ProviderOperation_DeleteInstanceAsync () { m_ProviderOperation_DeleteInstanceAsync ++ ; }
	void Increment_ProviderOperation_CreateInstanceEnumAsync () { m_ProviderOperation_CreateInstanceEnumAsync ++ ; }
	void Increment_ProviderOperation_ExecQueryAsync () { m_ProviderOperation_ExecQueryAsync ++ ; }
	void Increment_ProviderOperation_ExecNotificationQueryAsync () { m_ProviderOperation_ExecNotificationQueryAsync ++ ; }
	void Increment_ProviderOperation_ExecMethodAsync () { m_ProviderOperation_ExecMethodAsync ++ ; }

	void Increment_ProviderOperation_QueryInstances () { m_ProviderOperation_QueryInstances ++ ; }
	void Increment_ProviderOperation_CreateRefresher () { m_ProviderOperation_CreateRefresher ++ ; }
	void Increment_ProviderOperation_CreateRefreshableObject () { m_ProviderOperation_CreateRefreshableObject ++ ; }
	void Increment_ProviderOperation_StopRefreshing () { m_ProviderOperation_StopRefreshing ++ ; }
	void Increment_ProviderOperation_CreateRefreshableEnum () { m_ProviderOperation_CreateRefreshableEnum ++ ; }
	void Increment_ProviderOperation_GetObjects () { m_ProviderOperation_GetObjects ++ ; }

	void Increment_ProviderOperation_GetProperty () { m_ProviderOperation_GetProperty ++ ; }
	void Increment_ProviderOperation_PutProperty () { m_ProviderOperation_PutProperty ++ ; }

	void Increment_ProviderOperation_ProvideEvents () { m_ProviderOperation_ProvideEvents ++ ; }
	void Increment_ProviderOperation_NewQuery () { m_ProviderOperation_NewQuery ++ ; }
	void Increment_ProviderOperation_CancelQuery () { m_ProviderOperation_CancelQuery ++ ; }
	void Increment_ProviderOperation_AccessCheck () { m_ProviderOperation_AccessCheck ++ ; }
	void Increment_ProviderOperation_SetRegistrationObject () { m_ProviderOperation_SetRegistrationObject ++ ; }
	void Increment_ProviderOperation_FindConsumer () { m_ProviderOperation_FindConsumer ++ ; }
	void Increment_ProviderOperation_ValidateSubscription () { m_ProviderOperation_ValidateSubscription ++ ; }

    UINT64 Get_ProviderHost_WmiCore_Loads () { return m_ProviderHost_WmiCore_Loads ; }
    UINT64 Get_ProviderHost_WmiCore_UnLoads () { return m_ProviderHost_WmiCore_UnLoads ; }

	UINT64 Get_ProviderHost_WmiCoreOrSelfHost_Loads () { return m_ProviderHost_WmiCoreOrSelfHost_Loads ; }
	UINT64 Get_ProviderHost_WmiCoreOrSelfHost_UnLoads () { return m_ProviderHost_WmiCoreOrSelfHost_UnLoads ; }

	UINT64 Get_ProviderHost_SelfHost_Loads () { return m_ProviderHost_SelfHost_Loads ; }
	UINT64 Get_ProviderHost_SelfHost_UnLoads () { return m_ProviderHost_SelfHost_UnLoads ; }

	UINT64 Get_ProviderHost_ClientHost_Loads () { return m_ProviderHost_ClientHost_Loads ; }
	UINT64 Get_ProviderHost_ClientHost_UnLoads () { return m_ProviderHost_ClientHost_UnLoads ; }

	UINT64 Get_ProviderHost_Decoupled_Loads () { return m_ProviderHost_Decoupled_Loads ; }
	UINT64 Get_ProviderHost_Decoupled_UnLoads () { return m_ProviderHost_Decoupled_UnLoads ; }

	UINT64 Get_ProviderHost_SharedLocalSystemHost_Loads () { return m_ProviderHost_SharedLocalSystemHost_Loads ; }
	UINT64 Get_ProviderHost_SharedLocalSystemHost_UnLoads () { return m_ProviderHost_SharedLocalSystemHost_UnLoads ; }

	UINT64 Get_ProviderHost_SharedNetworkHost_Loads () { return m_ProviderHost_SharedNetworkHost_Loads ; }
	UINT64 Get_ProviderHost_SharedNetworkHost_UnLoads () { return m_ProviderHost_SharedNetworkHost_UnLoads ; }

	UINT64 Get_ProviderHost_SharedUserHost_Loads () { return m_ProviderHost_SharedUserHost_Loads ; }
	UINT64 Get_ProviderHost_SharedUserHost_UnLoads () { return m_ProviderHost_SharedUserHost_UnLoads ; }

	UINT64 Get_ProviderOperation_GetObjectAsync () { return m_ProviderOperation_GetObjectAsync ; }
	UINT64 Get_ProviderOperation_PutClassAsync () { return m_ProviderOperation_PutClassAsync ; }
	UINT64 Get_ProviderOperation_DeleteClassAsync () { return m_ProviderOperation_DeleteClassAsync ; }
	UINT64 Get_ProviderOperation_CreateClassEnumAsync () { return m_ProviderOperation_CreateClassEnumAsync ; }
	UINT64 Get_ProviderOperation_PutInstanceAsync () { return m_ProviderOperation_PutInstanceAsync ; }
	UINT64 Get_ProviderOperation_DeleteInstanceAsync () { return m_ProviderOperation_DeleteInstanceAsync ; }
	UINT64 Get_ProviderOperation_CreateInstanceEnumAsync () { return m_ProviderOperation_CreateInstanceEnumAsync ; }
	UINT64 Get_ProviderOperation_ExecQueryAsync () { return m_ProviderOperation_ExecQueryAsync ; }
	UINT64 Get_ProviderOperation_ExecNotificationQueryAsync () { return m_ProviderOperation_ExecNotificationQueryAsync ; }
	UINT64 Get_ProviderOperation_ExecMethodAsync () { return m_ProviderOperation_ExecMethodAsync ; }

	UINT64 Get_ProviderOperation_QueryInstances () { return m_ProviderOperation_QueryInstances ; }
	UINT64 Get_ProviderOperation_CreateRefresher () { return m_ProviderOperation_CreateRefresher ; }
	UINT64 Get_ProviderOperation_CreateRefreshableObject () { return m_ProviderOperation_CreateRefreshableObject ; }
	UINT64 Get_ProviderOperation_StopRefreshing () { return m_ProviderOperation_StopRefreshing ; }
	UINT64 Get_ProviderOperation_CreateRefreshableEnum () { return m_ProviderOperation_CreateRefreshableEnum ; }
	UINT64 Get_ProviderOperation_GetObjects () { return m_ProviderOperation_GetObjects ; }

	UINT64 Get_ProviderOperation_GetProperty () { return m_ProviderOperation_GetProperty ; }
	UINT64 Get_ProviderOperation_PutProperty () { return m_ProviderOperation_PutProperty ; }

	UINT64 Get_ProviderOperation_ProvideEvents () { return m_ProviderOperation_ProvideEvents ; }
	UINT64 Get_ProviderOperation_NewQuery () { return m_ProviderOperation_NewQuery ; }
	UINT64 Get_ProviderOperation_CancelQuery () { return m_ProviderOperation_CancelQuery ; }
	UINT64 Get_ProviderOperation_AccessCheck () { return m_ProviderOperation_AccessCheck ; }
	UINT64 Get_ProviderOperation_SetRegistrationObject () { return m_ProviderOperation_SetRegistrationObject ; }
	UINT64 Get_ProviderOperation_FindConsumer () { return m_ProviderOperation_FindConsumer ; }
	UINT64 Get_ProviderOperation_ValidateSubscription () { return m_ProviderOperation_ValidateSubscription ; }

};

#endif // _Server_ProviderCounters_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\winmgmt\provsubsys\server\include\provfact.h ===
/*++

Copyright (C) 1996-2001 Microsoft Corporation

Module Name:

	ProvFact.h

Abstract:


History:

--*/

#ifndef _Server_ProviderFactory_H
#define _Server_ProviderFactory_H

#include "ProvRegInfo.h"
#include "ProvCache.h"
#include "ProvAggr.h"
#include "Guids.h"

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

#define ProxyIndex__IWmiProviderFactory		0
#define ProxyIndex_Factory_Size				1

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

class CServerObject_StrobeInterface : public IUnknown
{
private:
protected:
public:

	virtual WmiStatusCode Strobe ( ULONG &a_NextStrobeDelta ) = 0 ;

	virtual WmiStatusCode StrobeBegin ( const ULONG &a_Period ) = 0 ;
} ;

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

class CServerObject_BindingFactory :	public _IWmiProviderFactory , 
										public _IWmiProviderFactoryInitialize , 
										public IWbemShutdown , 
										public _IWmiProviderConfiguration ,
										public BindingFactoryCacheElement , 
										public CWbemGlobal_IWmiProviderController 
{
private:

	WmiAllocator &m_Allocator ;

	LONG m_Flags ;
	_IWmiProvSS *m_SubSystem ;
	IWbemContext *m_Context ;
	LPWSTR m_Namespace ;
	IWbemPath *m_NamespacePath ;
	IWbemServices *m_Repository ;

	class InternalInterface : public CServerObject_StrobeInterface
	{
	private:

		CServerObject_BindingFactory *m_This ;

	public:

		InternalInterface ( CServerObject_BindingFactory *a_This ) : m_This ( a_This ) 
		{
		}

		STDMETHODIMP QueryInterface ( 

			REFIID iid , 
			LPVOID FAR *iplpv 
		)
		{
			*iplpv = NULL ;

			if ( iid == IID_IUnknown )
			{
				*iplpv = ( LPVOID ) this ;
			}
			else if ( iid == IID_CWbemGlobal_IWmiProviderController )
			{
				*iplpv = ( LPVOID ) ( CServerObject_StrobeInterface * ) this ;		
			}	

			if ( *iplpv )
			{
				( ( LPUNKNOWN ) *iplpv )->AddRef () ;

				return ResultFromScode ( S_OK ) ;
			}
			else
			{
				return ResultFromScode ( E_NOINTERFACE ) ;
			}
		}

		STDMETHODIMP_( ULONG ) AddRef ()
		{
			return m_This->InternalAddRef () ; 
		}

		STDMETHODIMP_( ULONG ) Release ()
		{
			return m_This->InternalRelease () ;
		}

		WmiStatusCode Strobe ( ULONG &a_NextStrobeDelta )
		{
			return m_This->Strobe ( a_NextStrobeDelta ) ;
		}

		WmiStatusCode StrobeBegin ( const ULONG &a_Period )
		{
			return m_This->StrobeBegin ( a_Period ) ;
		}
	} ;

	InternalInterface m_Internal ;

	WmiQueue <IUnknown *,8> m_SvcWrappersContainer;

protected:

public:	/* Internal */

    CServerObject_BindingFactory ( 

		WmiAllocator &a_Allocator ,
		WmiCacheController<BindingFactoryCacheKey> *a_Controller ,
		const BindingFactoryCacheKey &a_Key ,
		const ULONG &a_Period 
	) ;

    CServerObject_BindingFactory ( 

		WmiAllocator &a_Allocator
	) ;

    ~CServerObject_BindingFactory () ;

	IWbemContext *Direct_GetContext () { return m_Context ; }
	IWbemPath *Direct_GetNamespacePath () { return m_NamespacePath ; }
	LPCWSTR Direct_GetNamespace () { return m_Namespace ; }
	IWbemServices *Direct_GetRepository () { return m_Repository ; }
	_IWmiProvSS *Direct_GetSubSystem () { return m_SubSystem ; }

	HRESULT CacheProvider (

		_IWmiProviderSubsystemRegistrar *a_Registrar ,
		IWbemContext *a_Context ,
		CServerObject_DecoupledClientRegistration_Element &a_Element ,
		IUnknown *a_Unknown 
	) ;

	HRESULT Load (

		_IWmiProviderSubsystemRegistrar *a_Registrar ,
		IWbemContext *a_Context ,
		CServerObject_DecoupledClientRegistration_Element &a_Element
	) ;

	HRESULT Load (

		CDecoupledAggregator_IWbemProvider *a_Aggregator ,
		IWbemContext *a_Context ,
		BSTR a_Provider ,
		BSTR a_User ,
		BSTR a_Locale ,
		BSTR a_Scope
	) ;

	HRESULT GetHosting ( 

		CServerObject_ProviderRegistrationV1 &a_Registration ,
		IWbemContext *a_Context ,
		Enum_Hosting &a_Hosting ,
		LPCWSTR &a_HostingGroup
	) ;

	HRESULT Create ( 

		CServerObject_ProviderRegistrationV1 &a_Registration ,
		Enum_Hosting a_Hosting ,
		LPCWSTR a_HostingGroup ,
		LPCWSTR a_User ,
		_IWmiProviderHost **a_Host ,
		_IWmiProviderFactory **a_Factory ,
		IWbemContext *a_Context
	) ;

	HRESULT InitializeHostedService (

		CInterceptor_IWbemProvider *a_Interceptor ,
		IUnknown *a_Unknown 
	) ;

	HRESULT InternalGetProvider ( 

		IWbemServices *a_RepositoryService ,
		IWbemServices *a_FullService ,
		_IWmiProviderHost *a_Host ,
		_IWmiProviderFactory *a_Factory ,
		CInterceptor_IWbemProvider *a_Interceptor ,
		CServerObject_ProviderRegistrationV1 &a_Registration ,
		ProviderCacheKey &a_Key ,
		LONG a_Flags ,
		IWbemContext *a_Context ,
		GUID *a_TransactionIdentifier,
		LPCWSTR a_User ,
		LPCWSTR a_Locale ,
		LPCWSTR a_Scope ,
		LPCWSTR a_Name ,
		void **a_Unknown ,
		REFIID a_RIID , 
		void **a_Interface 
	) ;

	HRESULT InternalGetProviderViaProxyRoute ( 

		IWbemServices *a_RepositoryService ,
		IWbemServices *a_FullService ,
		CInterceptor_IWbemProvider *a_Interceptor ,
		CServerObject_ProviderRegistrationV1 &a_Registration ,
		Enum_Hosting a_Hosting ,
		LPCWSTR a_HostingGroup ,
		ProviderCacheKey &a_Key ,
		LONG a_Flags ,
		IWbemContext *a_Context ,
		GUID *a_TransactionIdentifier,
		LPCWSTR a_User ,
		LPCWSTR a_Locale ,
		LPCWSTR a_Scope ,
		LPCWSTR a_Name ,
		REFIID a_RIID , 
		void **a_Interface 
	) ;

	HRESULT InternalFindProvider ( 

		IWbemServices *a_RepositoryService ,
		IWbemServices *a_FullService ,
		CServerObject_ProviderRegistrationV1 &a_Registration ,
		Enum_Hosting a_Hosting ,
		LPCWSTR a_HostingGroup ,
		ProviderCacheKey &a_Key ,
		LONG a_Flags ,
		IWbemContext *a_Context ,
		GUID *a_TransactionIdentifier,
		LPCWSTR a_User ,
		LPCWSTR a_Locale ,
		LPCWSTR a_Scope ,
		LPCWSTR a_Name ,
		REFIID a_RIID , 
		void **a_Interface 
	) ;

	HRESULT GetAggregatedClassProviderViaProxyRoute ( 

		ProviderCacheKey &a_Key ,
		LONG a_Flags ,
		IWbemContext *a_Context ,
		LPCWSTR a_User ,
		LPCWSTR a_Locale ,
		LPCWSTR a_Scope,
		IWbemClassObject *a_Class ,
		REFIID a_RIID , 
		void **a_Interface 
	) ;

	HRESULT WaitProvider ( 

		IWbemContext *a_Context ,
		REFIID a_RIID , 
		void **a_Interface ,
		ServiceCacheElement *a_Element ,
		_IWmiProviderInitialize *a_Initializer 
	) ;

	HRESULT SearchSpecificProvider ( 

		IWbemContext *a_Context ,
		ProviderCacheKey &a_Key ,
		REFIID a_RIID , 
		void **a_Interface ,
		LPCWSTR a_User ,
		LPCWSTR a_Locale
	) ;

	HRESULT FindProvider ( 

		IWbemContext *a_Context ,
		ProviderCacheKey &a_Key ,
		BOOL a_SpecificProvider ,
		REFIID a_RIID , 
		void **a_Interface ,
		LPCWSTR a_User ,
		LPCWSTR a_Locale
	) ;

	HRESULT GetAggregatedClassProvider ( 

		IWbemServices *a_RepositoryService ,
		IWbemServices *a_FullService ,
		ProviderCacheKey &a_Key ,
		LONG a_Flags ,
		IWbemContext *a_Context ,
		LPCWSTR a_User ,
		LPCWSTR a_Locale ,
		LPCWSTR a_Scope,
		IWbemClassObject *a_Class ,
		REFIID a_RIID , 
		void **a_Interface 
	) ;

	HRESULT InternalFindAggregatedDecoupledProvider ( 

		IWbemServices *a_RepositoryService ,
		IWbemServices *a_FullService ,
		CServerObject_ProviderRegistrationV1 &a_Registration ,
		ProviderCacheKey &a_Key ,
		LONG a_Flags ,
		IWbemContext *a_Context ,
		LPCWSTR a_User ,
		LPCWSTR a_Locale ,
		LPCWSTR a_Scope ,
		LPCWSTR a_Name ,
		REFIID a_RIID , 
		void **a_Interface 
	) ;

public:	/* External */


	//IUnknown members

	STDMETHODIMP QueryInterface ( REFIID , LPVOID FAR * ) ;
    STDMETHODIMP_( ULONG ) AddRef () ;
    STDMETHODIMP_( ULONG ) Release () ;

	// CServerObject_BindingFactory members

    HRESULT STDMETHODCALLTYPE GetClassProvider (

        LONG a_Flags ,
		IWbemContext *a_Context ,
		LPCWSTR a_User ,
		LPCWSTR a_Locale ,
        LPCWSTR a_Scope,
		IWbemClassObject *a_Class ,
		REFIID a_RIID , 
		void **a_Interface 
	);

	HRESULT STDMETHODCALLTYPE GetDynamicPropertyResolver (

		LONG a_Flags ,
		IWbemContext *a_Context ,
		LPCWSTR a_User ,
		LPCWSTR a_Locale ,
		REFIID a_RIID , 
		void **a_Interface 
	) ;

	HRESULT STDMETHODCALLTYPE GetHostedProvider ( 
	
		LONG a_Flags ,
		IWbemContext *a_Context ,
		GUID *a_TransactionIdentifier,
		LPCWSTR a_User ,
		LPCWSTR a_Locale ,
        LPCWSTR a_Scope,
		LPCWSTR a_Name ,
		ULONG a_Host ,
		LPCWSTR a_HostGroup ,
		REFIID a_RIID , 
		void **a_Interface 
	) ;

	HRESULT STDMETHODCALLTYPE GetProvider ( 

		WmiInternalContext a_InternalContext ,
		LONG a_Flags ,
		IWbemContext *a_Context ,
		GUID *a_TransactionIdentifier,
		LPCWSTR a_User ,
		LPCWSTR a_Locale ,
        LPCWSTR a_Scope,
		LPCWSTR a_Name ,
		REFIID a_RIID , 
		void **a_Interface 
	) ;

    HRESULT STDMETHODCALLTYPE GetDecoupledProvider (

		LONG a_Flags ,
		IWbemContext *a_Context ,
		LPCWSTR a_User ,
		LPCWSTR a_Locale ,
        LPCWSTR a_Scope,
		LPCWSTR a_Name ,
		REFIID a_RIID , 
		void **a_Interface 
    ) ;

	/* _IWmiProviderConfiguration methods */

	HRESULT STDMETHODCALLTYPE Get (

		IWbemServices *a_Service ,
		long a_Flags ,
		IWbemContext *a_Context ,
		LPCWSTR a_Class ,
		LPCWSTR a_Path ,
		IWbemObjectSink *a_Sink
	) ;

	HRESULT STDMETHODCALLTYPE Set (

		IWbemServices *a_Service ,
		long a_Flags ,
		IWbemContext *a_Context ,
		LPCWSTR a_Provider ,
		LPCWSTR a_Class ,
		LPCWSTR a_Path ,
		IWbemClassObject *a_OldObject ,
		IWbemClassObject *a_NewObject  
	) ;

	HRESULT STDMETHODCALLTYPE Deleted (

		IWbemServices *a_Service ,
		long a_Flags ,
		IWbemContext *a_Context ,
		LPCWSTR a_Provider ,
		LPCWSTR a_Class ,
		LPCWSTR a_Path ,
		IWbemClassObject *a_Object  
	) ;

	HRESULT STDMETHODCALLTYPE Enumerate (

		IWbemServices *a_Service ,
		long a_Flags ,
		IWbemContext *a_Context ,
		LPCWSTR a_Class ,
		IWbemObjectSink *a_Sink
	) ;

	HRESULT STDMETHODCALLTYPE Shutdown (

		IWbemServices *a_Service ,
		long a_Flags ,
		IWbemContext *a_Context ,
		LPCWSTR a_Provider ,
		ULONG a_MilliSeconds
	) ;

	HRESULT STDMETHODCALLTYPE Call (

		IWbemServices *a_Service ,
		long a_Flags ,
		IWbemContext *a_Context ,
		LPCWSTR a_Class ,
		LPCWSTR a_Path ,		
		LPCWSTR a_Method,
		IWbemClassObject *a_InParams,
		IWbemObjectSink *a_Sink
	) ;

	HRESULT STDMETHODCALLTYPE Query (

		IWbemServices *a_Service ,
		long a_Flags ,
		IWbemContext *a_Context ,
		WBEM_PROVIDER_CONFIGURATION_CLASS_ID a_ClassIdentifier ,
		WBEM_PROVIDER_CONFIGURATION_PROPERTY_ID a_PropertyIdentifier ,
		VARIANT *a_Value 
	) ;

	HRESULT STDMETHODCALLTYPE Initialize (

		_IWmiProvSS *a_SubSys ,
		_IWmiProviderFactory *a_Factory ,
		LONG a_Flags ,
		IWbemContext *a_Context ,
		LPCWSTR a_Namespace ,
		IWbemServices *a_Repository ,
		IWbemServices *a_Service
	) ;

	HRESULT STDMETHODCALLTYPE Shutdown (

		LONG a_Flags ,
		ULONG a_MaxMilliSeconds ,
		IWbemContext *a_Context
	) ; 

	WmiStatusCode Strobe ( ULONG &a_NextStrobeDelta ) ;

	WmiStatusCode StrobeBegin ( const ULONG &a_Period ) ;
};

#endif // _Server_ProviderFactory_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\winmgmt\provsubsys\server\include\provinsk.h ===
#ifndef _Server_Interceptor_IWbemProviderInitSink_H
#define _Server_Interceptor_IWbemProviderInitSink_H

/*++

Copyright (C) 1996-2001 Microsoft Corporation

Module Name:

	ProvObSk.H

Abstract:


History:

--*/


/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

class CServerObject_ProviderInitSink : public IWbemProviderInitSink 
{
private:

	LONG m_ReferenceCount ;

	BOOL m_StatusCalled ;

	HANDLE m_Event ;

	HRESULT m_Result ;

	SECURITY_DESCRIPTOR *m_SecurityDescriptor ;

protected:

public:

	CServerObject_ProviderInitSink ( SECURITY_DESCRIPTOR *a_SecurityDescriptor = NULL ) ;
	virtual ~CServerObject_ProviderInitSink () ;

	HRESULT SinkInitialize ( SECURITY_DESCRIPTOR *a_SecurityDescriptor = NULL ) ;

	STDMETHODIMP QueryInterface (

		REFIID iid , 
		LPVOID FAR *iplpv 
	) ;

	STDMETHODIMP_( ULONG ) AddRef () ;

	STDMETHODIMP_(ULONG) Release () ;

    HRESULT STDMETHODCALLTYPE SetStatus (

        LONG a_Status,
        LONG a_Flags 
	) ;

	void Wait ( DWORD a_Timeout = 300000 ) 
	{
		if ( WaitForSingleObject ( m_Event , a_Timeout ) == WAIT_TIMEOUT )
		{
			m_Result = WBEM_E_PROVIDER_LOAD_FAILURE ;
		}
	}

	void Reset () 
	{
		ResetEvent ( m_Event ) ;
		m_Result = S_OK ;
	}

	HRESULT GetResult () { return m_Result ; }
} ;

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

class CInterceptor_IWbemProviderInitSink : public IWbemProviderInitSink
{
private:

	LONG m_ReferenceCount ;

	LONG m_GateClosed ;
	LONG m_InProgress ;

	BOOL m_StatusCalled ;

	IWbemProviderInitSink *m_InterceptedSink ;

protected:
public:

	CInterceptor_IWbemProviderInitSink (

		IWbemProviderInitSink *a_InterceptedSink
	) ;

	~CInterceptor_IWbemProviderInitSink () ;

	//Non-delegating object IUnknown

    STDMETHODIMP QueryInterface ( REFIID , LPVOID FAR * ) ;
    STDMETHODIMP_( ULONG ) AddRef () ;
    STDMETHODIMP_( ULONG ) Release () ;

    HRESULT STDMETHODCALLTYPE SetStatus (

        LONG a_Status,
        LONG a_Flags 
	) ;

	HRESULT STDMETHODCALLTYPE Shutdown () ;
} ;

#endif _Server_Interceptor_IWbemProviderInitSink_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\winmgmt\provsubsys\server\include\provhost.h ===
/*++

Copyright (C) 1996-2001 Microsoft Corporation

Module Name:

	ProvSubS.h

Abstract:


History:

--*/

#ifndef _Server_Host_H
#define _Server_Host_H

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

#define ProxyIndex_Host__IWmiProviderHost				0
#define ProxyIndex_Host_IWbemShutdown					1

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

#include "ProvCache.h"

class CServerObject_HostInterceptor :	public _IWmiProviderHost ,
										public IWbemShutdown ,
										public HostCacheElement 
{
private:

	WmiAllocator &m_Allocator ;

	IUnknown *m_Unknown ;
	IWbemShutdown *m_Host_IWbemShutdown ;
	_IWmiProviderHost *m_Host_IWmiProviderHost ;

	ProxyContainer m_ProxyContainer ;

	LONG m_Initialized ;
	LONG m_UnInitialized ;
	HRESULT m_InitializeResult ;
	HANDLE m_InitializedEvent ;
	IWbemContext *m_InitializationContext ;
	DWORD m_ProcessIdentifier ;
	
	void CallBackInternalRelease () ;

public:

	CServerObject_HostInterceptor ( 

		WmiAllocator &a_Allocator ,
		CWbemGlobal_IWmiHostController *a_Controller , 
		const HostCacheKey &a_Key ,
		const ULONG &a_Period ,
		IWbemContext *a_InitializationContext
	) ;

    ~CServerObject_HostInterceptor () ;

	HRESULT Initialize (

		IWbemContext *a_Context ,
		IWbemProviderInitSink *a_Sink     // For init signals
	) ;

	HRESULT SetHost ( IUnknown *a_Unknown ) ;

	HRESULT IsIndependant ( IWbemContext *a_Context ) ;

	HRESULT SetInitialized ( HRESULT a_InitializeResult ) ;

	HRESULT WaitHost ( IWbemContext *a_Context , ULONG a_Timeout ) ;

	HRESULT GetInitializeResult () 
	{
		return m_InitializeResult ;
	}

	DWORD GetProcessIdentifier ()
	{
		return m_ProcessIdentifier ;
	}

	static HRESULT AbnormalShutdown (

		HostCacheKey &a_Key
	) ;

	static HRESULT CreateUsingAccount (

		HostCacheKey &a_Key ,
		LPWSTR a_User ,
		LPWSTR a_Domain ,
		_IWmiProviderHost **a_Host ,
		_IWmiProviderFactory **a_Factory ,
		IWbemContext *a_Context
	) ;

	static HRESULT CreateUsingToken (

		HostCacheKey &a_Key ,
		_IWmiProviderHost **a_Host ,
		_IWmiProviderFactory **a_Factory ,
		IWbemContext *a_Context
	) ;

	static HRESULT CreateUsingToken (

		HostCacheKey &a_Key ,
		_IWmiProviderHost **a_Host ,
		_IWbemRefresherMgr **a_RefresherManager ,
		IWbemContext *a_Context
	) ;

	static HRESULT CreateUsingAccount (

		HostCacheKey &a_Key ,
		LPWSTR a_User ,
		LPWSTR a_Domain ,
		_IWmiProviderHost **a_Host ,
		_IWbemRefresherMgr **a_RefresherManager ,
		IWbemContext *a_Context
	) ;

	static HRESULT FindHost ( 

		IWbemContext *a_Context ,
		HostCacheKey &a_Key ,
		REFIID a_RIID , 
		void **a_Interface 
	) ;

public:

	//Non-delegating object IUnknown

    STDMETHODIMP QueryInterface ( REFIID , LPVOID FAR * ) ;
    STDMETHODIMP_( ULONG ) AddRef () ;
    STDMETHODIMP_( ULONG ) Release () ;

	HRESULT STDMETHODCALLTYPE GetObject (

		REFCLSID a_Clsid ,
		long a_Flags ,
		IWbemContext *a_Context ,
		REFIID a_Riid ,
		void **a_Interface
	) ;

	HRESULT STDMETHODCALLTYPE GetProcessIdentifier ( DWORD *a_ProcessIdentifier ) ;

	// IWmi_UnInitialize members

	HRESULT STDMETHODCALLTYPE Shutdown (

		LONG a_Flags ,
		ULONG a_MaxMilliSeconds ,
		IWbemContext *a_Context
	) ;

} ;

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

class CServerObject_Host :	public _IWmiProviderHost ,
							public IWbemShutdown

{
private:

	LONG m_ReferenceCount ;
	WmiAllocator &m_Allocator ;

protected:
public:

    CServerObject_Host ( WmiAllocator &a_Allocator ) ;
    ~CServerObject_Host ( void ) ;

	//IUnknown members

	STDMETHODIMP QueryInterface ( REFIID , LPVOID FAR * ) ;
    STDMETHODIMP_( ULONG ) AddRef () ;
    STDMETHODIMP_( ULONG ) Release () ;

	//

	HRESULT STDMETHODCALLTYPE GetObject (

		REFCLSID a_Clsid ,
		long a_Flags ,
		IWbemContext *a_Context ,
		REFIID a_Riid ,
		void **a_Interface
	) ;

	HRESULT STDMETHODCALLTYPE GetProcessIdentifier ( DWORD *a_ProcessIdentifier ) ;

	// IWmi_UnInitialize members

	HRESULT STDMETHODCALLTYPE Shutdown (

		LONG a_Flags ,
		ULONG a_MaxMilliSeconds ,
		IWbemContext *a_Context
	) ;

};

#endif // _Server_Host_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\winmgmt\provsubsys\server\include\provload.h ===
/*++

Copyright (C) 1996-2001 Microsoft Corporation

Module Name:

	ProvFact.h

Abstract:


History:

--*/

#ifndef _Server_SimpleFactory_H
#define _Server_SimpleFactory_H

#include "ProvRegInfo.h"

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

class CServerObject_RawFactory :	public _IWmiProviderFactory , 
									public _IWmiProviderFactoryInitialize , 
									public IWbemShutdown
{
private:

	WmiAllocator &m_Allocator ;

    long m_ReferenceCount ;

	LONG m_Flags ;
	IWbemContext *m_Context ;
	LPWSTR m_Namespace ;
	IWbemPath *m_NamespacePath ;
	IWbemServices *m_Repository ;
	IWbemServices *m_Service ;

public:	/* Internal */

    CServerObject_RawFactory (	WmiAllocator & a_Allocator ) ;
    ~CServerObject_RawFactory () ;

	IWbemContext *Direct_GetContext () { return m_Context ; }
	LPCWSTR Direct_GetNamespace () { return m_Namespace ; }
	IWbemPath *Direct_GetNamespacePath () { return m_NamespacePath ; }
	IWbemServices *Direct_GetRepository () { return m_Repository ; }
	IWbemServices *Direct_GetService () { return m_Service ; }

	HRESULT CreateSyncProvider ( 

		IWbemServices *a_Stub ,
		IUnknown *a_ServerSideProvider ,
		wchar_t *a_NamespacePath ,
		LONG a_Flags ,
		IWbemContext *a_Context ,
		GUID *a_TransactionIdentifier ,
		LPCWSTR a_User ,
		LPCWSTR a_Locale ,
		LPCWSTR a_Scope ,
		REFIID a_RIID , 
		void **a_Interface ,
		CServerObject_ProviderRegistrationV1 &a_Registration
	) ;

	HRESULT InitializeServerProvider ( 

		IWbemServices *a_Stub ,
		IUnknown *a_ProviderInterface ,
		wchar_t *a_NamespacePath ,
		LONG a_Flags ,
		IWbemContext *a_Context ,
		GUID *a_TransactionIdentifier ,
		LPCWSTR a_User ,
		LPCWSTR a_Locale ,
		LPCWSTR a_Scope ,
		REFIID a_RIID , 
		void **a_Interface ,
		CServerObject_ProviderRegistrationV1 &a_Registration
	) ;

	HRESULT InitializeNonApartmentProvider ( 

		IWbemServices *a_Stub ,
		IUnknown *a_ServerSideProviderInterface ,
		wchar_t *a_NamespacePath ,
		LONG a_Flags ,
		IWbemContext *a_Context ,
		GUID *a_TransactionIdentifier ,
		LPCWSTR a_User ,
		LPCWSTR a_Locale ,
		LPCWSTR a_Scope ,
		REFIID a_RIID , 
		void **a_Interface ,
		CServerObject_ProviderRegistrationV1 &a_Registration
	) ;

	HRESULT GetApartmentInstanceProvider ( 

		LONG a_Flags ,
		IWbemContext *a_Context ,
		GUID *a_TransactionIdentifier ,
		LPCWSTR a_User ,
		LPCWSTR a_Locale ,
        LPCWSTR a_Scope ,
		REFIID a_RIID , 
		void **a_Interface ,
		CServerObject_ProviderRegistrationV1 &a_Registration
	) ;

	HRESULT GetNonApartmentProvider ( 

		LONG a_Flags ,
		IWbemContext *a_Context ,
		GUID *a_TransactionIdentifier ,
		LPCWSTR a_User ,
		LPCWSTR a_Locale ,
        LPCWSTR a_Scope ,
		REFIID a_RIID , 
		void **a_Interface ,
		CServerObject_ProviderRegistrationV1 &a_Registration
	) ;

	HRESULT CheckInterfaceConformance (

		CServerObject_ProviderRegistrationV1 &a_Registration ,
		IUnknown *a_Unknown
	) ;

public: /* Internal */

	static HRESULT CreateInstance ( 

		CServerObject_ProviderRegistrationV1 &a_Registration ,
		const CLSID &a_ReferenceClsid ,
		LPUNKNOWN a_OuterUnknown ,
		const DWORD &a_ClassContext ,
		const UUID &a_ReferenceInterfaceId ,
		void **a_ObjectInterface
	) ;

	static HRESULT CreateServerSide ( 

		CServerObject_ProviderRegistrationV1 &a_Registration ,
		GUID *a_TransactionIdentifier ,
		LPCWSTR a_User ,
		LPCWSTR a_Locale ,
		wchar_t *a_NamespacePath ,
		IUnknown **a_ProviderInterface
	) ;

public:	/* External */


	//IUnknown members

	STDMETHODIMP QueryInterface ( REFIID , LPVOID FAR * ) ;
    STDMETHODIMP_( ULONG ) AddRef () ;
    STDMETHODIMP_( ULONG ) Release () ;

	// CServerObject_RawFactory members

	HRESULT STDMETHODCALLTYPE GetHostedProvider ( 
	
		LONG a_Flags ,
		IWbemContext *a_Context ,
		GUID *a_TransactionIdentifier,
		LPCWSTR a_User ,
		LPCWSTR a_Locale ,
        LPCWSTR a_Scope ,
		LPCWSTR a_Name ,
		ULONG a_Host ,
		LPCWSTR a_HostGroup ,
		REFIID a_RIID , 
		void **a_Interface 
	) ;

    HRESULT STDMETHODCALLTYPE GetClassProvider (

        LONG a_Flags ,
		IWbemContext *a_Context ,
		LPCWSTR a_User ,
		LPCWSTR a_Locale ,
        LPCWSTR a_Scope ,
		IWbemClassObject *a_SuperClass ,
		REFIID a_RIID , 
		void **a_Interface 
	);

	HRESULT STDMETHODCALLTYPE GetDynamicPropertyResolver (

		LONG a_Flags ,
		IWbemContext *a_Context ,
		LPCWSTR a_User ,
		LPCWSTR a_Locale ,
		REFIID a_RIID , 
		void **a_Interface 
	) ;

	HRESULT STDMETHODCALLTYPE GetProvider ( 

		WmiInternalContext a_InternalContext ,
		LONG a_Flags ,
		IWbemContext *a_Context ,
		GUID *a_TransactionIdentifier,
		LPCWSTR a_User ,
		LPCWSTR a_Locale ,
        LPCWSTR a_Scope ,
		LPCWSTR a_Name ,
		REFIID a_RIID , 
		void **a_Interface 
	) ;

    HRESULT STDMETHODCALLTYPE GetDecoupledProvider (

		LONG a_Flags ,
		IWbemContext *a_Context ,
		LPCWSTR a_User ,
		LPCWSTR a_Locale ,
        LPCWSTR a_Scope,
		LPCWSTR a_Name ,
		REFIID a_RIID , 
		void **a_Interface 
    ) ;

	HRESULT STDMETHODCALLTYPE Initialize (

		_IWmiProvSS *a_SubSys ,
		_IWmiProviderFactory *a_Factory ,
		LONG a_Flags ,
		IWbemContext *a_Context ,
		LPCWSTR a_Namespace ,
		IWbemServices *a_Repository ,
		IWbemServices *a_Service 
	) ;

	HRESULT STDMETHODCALLTYPE Shutdown (

		LONG a_Flags ,
		ULONG a_MaxMilliSeconds ,
		IWbemContext *a_Context
	) ; 
};

#endif // _Server_SimpleFactory_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\winmgmt\provsubsys\server\include\provobsk.h ===
#ifndef _Server_Interceptor_IWbemObjectSink_H
#define _Server_Interceptor_IWbemObjectSink_H

/*++

Copyright (C) 1996-2001 Microsoft Corporation

Module Name:

	ProvObSk.H

Abstract:


History:

--*/

#include <ProvObjectSink.h>
#include "ProvCache.h"
#include "Queue.h"
#include <lockst.h>

#define SYNCPROV_USEBATCH

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

#define ProxyIndex_IWbemObjectSink					0
#define ProxyIndex_Internal_IWbemObjectSink			1
#define ProxyIndex_ObjectSink_Size					2

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

class IObjectSink_CancelOperation : public IUnknown
{
private:
protected:
public:

	virtual HRESULT STDMETHODCALLTYPE Cancel (

		LONG a_Flags

	) = 0 ; 
} ;

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

class CInterceptor_IWbemObjectSink :	public IWbemObjectSink , 
										public IWbemShutdown ,

#ifdef INTERNAL_IDENTIFY
										public Internal_IWbemObjectSink , 
#endif
										public ObjectSinkContainerElement 
{
private:

	LONG m_InProgress ;
	LONG m_StatusCalled ;

	IWbemObjectSink *m_InterceptedSink ;
	IUnknown *m_Unknown ;
	SECURITY_DESCRIPTOR *m_SecurityDescriptor ;

protected:

	LONG m_GateClosed ;

public:

	CInterceptor_IWbemObjectSink (

		IWbemObjectSink *a_InterceptedSink ,
		IUnknown *a_Unknown ,
		CWbemGlobal_IWmiObjectSinkController *a_Controller 
	) ;

	~CInterceptor_IWbemObjectSink () ;

	HRESULT Initialize ( SECURITY_DESCRIPTOR *a_SecurityDescriptor ) ;

	void CallBackInternalRelease () ;

public:

	//Non-delegating object IUnknown

    STDMETHODIMP QueryInterface ( REFIID , LPVOID FAR * ) ;
    STDMETHODIMP_( ULONG ) AddRef () ;
    STDMETHODIMP_( ULONG ) Release () ;

    HRESULT STDMETHODCALLTYPE Indicate (

		long a_ObjectCount ,
		IWbemClassObject **a_ObjectArray
	) ;

    HRESULT STDMETHODCALLTYPE SetStatus (

		long a_Flags ,
		HRESULT a_Result ,
		BSTR a_StringParamater ,
		IWbemClassObject *a_ObjectParameter
	) ;

	HRESULT STDMETHODCALLTYPE Shutdown (

		LONG a_Flags ,
		ULONG a_MaxMilliSeconds ,
		IWbemContext *a_Context
	) ; 

#ifdef INTERNAL_IDENTIFY

    HRESULT STDMETHODCALLTYPE Internal_Indicate (

		WmiInternalContext a_InternalContext ,
		long a_ObjectCount ,
		IWbemClassObject **a_ObjectArray
	) ;

    HRESULT STDMETHODCALLTYPE Internal_SetStatus (

		WmiInternalContext a_InternalContext ,
		long a_Flags ,
		HRESULT a_Result ,
		BSTR a_StringParamater ,
		IWbemClassObject *a_ObjectParameter
	) ;
#endif
} ;

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

class CInterceptor_IWbemSyncObjectSink :	public CCommon_IWbemSyncObjectSink
{
private:
protected:
public:

	CInterceptor_IWbemSyncObjectSink (

		WmiAllocator &a_Allocator ,
		IWbemObjectSink *a_InterceptedSink ,
		IUnknown *a_Unknown ,
		CWbemGlobal_IWmiObjectSinkController *a_Controller ,
		ULONG a_Dependant = FALSE
	) ;

	~CInterceptor_IWbemSyncObjectSink() ;
} ;

/*****************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

class CInterceptor_IWbemSyncObjectSink_GetObjectAsync : public CCommon_IWbemSyncObjectSink
{
private:

	long m_Flags ;
	BSTR m_ObjectPath ;
	CInterceptor_IWbemSyncProvider *m_Interceptor ;

protected:
public:

	CInterceptor_IWbemSyncObjectSink_GetObjectAsync (

		WmiAllocator &a_Allocator ,
		long a_Flags ,
		BSTR a_ObjectPath ,
		CInterceptor_IWbemSyncProvider *a_Interceptor ,
		IWbemObjectSink *a_InterceptedSink ,
		IUnknown *a_Unknown ,
		CWbemGlobal_IWmiObjectSinkController *a_Controller ,
		ULONG a_Dependant = FALSE
	) ;

	~CInterceptor_IWbemSyncObjectSink_GetObjectAsync () ;

    HRESULT STDMETHODCALLTYPE SetStatus (

		long a_Flags ,
		HRESULT a_Result ,
		BSTR a_StringParamater ,
		IWbemClassObject *a_ObjectParameter
	) ;
} ;

/*****************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

class CInterceptor_IWbemSyncObjectSink_DeleteInstanceAsync : public CCommon_IWbemSyncObjectSink
{
private:

	long m_Flags ;
	BSTR m_ObjectPath ;
	CInterceptor_IWbemSyncProvider *m_Interceptor ;

protected:
public:

	CInterceptor_IWbemSyncObjectSink_DeleteInstanceAsync (

		WmiAllocator &a_Allocator ,
		long a_Flags ,
		BSTR a_ObjectPath ,
		CInterceptor_IWbemSyncProvider *a_Interceptor ,
		IWbemObjectSink *a_InterceptedSink ,
		IUnknown *a_Unknown ,
		CWbemGlobal_IWmiObjectSinkController *a_Controller ,
		ULONG a_Dependant = FALSE
	) ;

	~CInterceptor_IWbemSyncObjectSink_DeleteInstanceAsync () ;

    HRESULT STDMETHODCALLTYPE SetStatus (

		long a_Flags ,
		HRESULT a_Result ,
		BSTR a_StringParamater ,
		IWbemClassObject *a_ObjectParameter
	) ;
} ;

/*****************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

class CInterceptor_IWbemSyncObjectSink_DeleteClassAsync : public CCommon_IWbemSyncObjectSink
{
private:

	long m_Flags ;
	BSTR m_Class ;
	CInterceptor_IWbemSyncProvider *m_Interceptor ;

protected:
public:

	CInterceptor_IWbemSyncObjectSink_DeleteClassAsync (

		WmiAllocator &a_Allocator ,
		long a_Flags ,
		BSTR a_Class ,
		CInterceptor_IWbemSyncProvider *a_Interceptor ,
		IWbemObjectSink *a_InterceptedSink ,
		IUnknown *a_Unknown ,
		CWbemGlobal_IWmiObjectSinkController *a_Controller ,
		ULONG a_Dependant = FALSE
	) ;

	~CInterceptor_IWbemSyncObjectSink_DeleteClassAsync () ;

    HRESULT STDMETHODCALLTYPE SetStatus (

		long a_Flags ,
		HRESULT a_Result ,
		BSTR a_StringParamater ,
		IWbemClassObject *a_ObjectParameter
	) ;
} ;

/*****************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

class CInterceptor_IWbemSyncObjectSink_PutInstanceAsync : public CCommon_IWbemSyncObjectSink
{
private:

	long m_Flags ;
	IWbemClassObject *m_Instance ;
	CInterceptor_IWbemSyncProvider *m_Interceptor ;

protected:
public:

	CInterceptor_IWbemSyncObjectSink_PutInstanceAsync (

		WmiAllocator &a_Allocator ,
		long a_Flags ,
		IWbemClassObject *a_Class ,
		CInterceptor_IWbemSyncProvider *a_Interceptor ,
		IWbemObjectSink *a_InterceptedSink ,
		IUnknown *a_Unknown ,
		CWbemGlobal_IWmiObjectSinkController *a_Controller ,
		ULONG a_Dependant = FALSE
	) ;

	~CInterceptor_IWbemSyncObjectSink_PutInstanceAsync () ;

    HRESULT STDMETHODCALLTYPE SetStatus (

		long a_Flags ,
		HRESULT a_Result ,
		BSTR a_StringParamater ,
		IWbemClassObject *a_ObjectParameter
	) ;
} ;

/*****************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

class CInterceptor_IWbemSyncObjectSink_PutClassAsync : public CCommon_IWbemSyncObjectSink
{
private:

	long m_Flags ;
	IWbemClassObject *m_Class ;
	CInterceptor_IWbemSyncProvider *m_Interceptor ;

protected:
public:

	CInterceptor_IWbemSyncObjectSink_PutClassAsync (

		WmiAllocator &a_Allocator ,
		long a_Flags ,
		IWbemClassObject *a_Class ,
		CInterceptor_IWbemSyncProvider *a_Interceptor ,
		IWbemObjectSink *a_InterceptedSink ,
		IUnknown *a_Unknown ,
		CWbemGlobal_IWmiObjectSinkController *a_Controller ,
		ULONG a_Dependant = FALSE
	) ;

	~CInterceptor_IWbemSyncObjectSink_PutClassAsync () ;

    HRESULT STDMETHODCALLTYPE SetStatus (

		long a_Flags ,
		HRESULT a_Result ,
		BSTR a_StringParamater ,
		IWbemClassObject *a_ObjectParameter
	) ;
} ;

/*****************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

class CInterceptor_IWbemSyncObjectSink_CreateInstanceEnumAsync : public CCommon_Batching_IWbemSyncObjectSink
{
private:

	long m_Flags ;
	BSTR m_Class ;
	CInterceptor_IWbemSyncProvider *m_Interceptor ;

protected:
public:

	CInterceptor_IWbemSyncObjectSink_CreateInstanceEnumAsync (

		WmiAllocator &a_Allocator ,
		long a_Flags ,
		BSTR a_Class ,
		CInterceptor_IWbemSyncProvider *a_Interceptor ,
		IWbemObjectSink *a_InterceptedSink ,
		IUnknown *a_Unknown ,
		CWbemGlobal_IWmiObjectSinkController *a_Controller ,
		ULONG a_Dependant = FALSE
	) ;

	~CInterceptor_IWbemSyncObjectSink_CreateInstanceEnumAsync () ;

    HRESULT STDMETHODCALLTYPE SetStatus (

		long a_Flags ,
		HRESULT a_Result ,
		BSTR a_StringParamater ,
		IWbemClassObject *a_ObjectParameter
	) ;
} ;

/*****************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

class CInterceptor_IWbemSyncObjectSink_CreateClassEnumAsync : public CCommon_Batching_IWbemSyncObjectSink
{
private:

	long m_Flags ;
	BSTR m_SuperClass ;
	CInterceptor_IWbemSyncProvider *m_Interceptor ;

protected:
public:

	CInterceptor_IWbemSyncObjectSink_CreateClassEnumAsync (

		WmiAllocator &a_Allocator ,
		long a_Flags ,
		BSTR a_SuperClass ,
		CInterceptor_IWbemSyncProvider *a_Interceptor ,
		IWbemObjectSink *a_InterceptedSink ,
		IUnknown *a_Unknown ,
		CWbemGlobal_IWmiObjectSinkController *a_Controller ,
		ULONG a_Dependant = FALSE
	) ;

	~CInterceptor_IWbemSyncObjectSink_CreateClassEnumAsync () ;

    HRESULT STDMETHODCALLTYPE SetStatus (

		long a_Flags ,
		HRESULT a_Result ,
		BSTR a_StringParamater ,
		IWbemClassObject *a_ObjectParameter
	) ;
} ;

/*****************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

class CInterceptor_IWbemSyncObjectSink_ExecQueryAsync : public CCommon_Batching_IWbemSyncObjectSink
{
private:

	long m_Flags ;
	BSTR m_QueryLanguage ;
	BSTR m_Query ;
	CInterceptor_IWbemSyncProvider *m_Interceptor ;

protected:
public:

	CInterceptor_IWbemSyncObjectSink_ExecQueryAsync (

		WmiAllocator &a_Allocator ,
		long a_Flags ,
		BSTR a_QueryLanguage ,
		BSTR a_Query ,
		CInterceptor_IWbemSyncProvider *a_Interceptor ,
		IWbemObjectSink *a_InterceptedSink ,
		IUnknown *a_Unknown ,
		CWbemGlobal_IWmiObjectSinkController *a_Controller ,
		ULONG a_Dependant = FALSE
	) ;

	~CInterceptor_IWbemSyncObjectSink_ExecQueryAsync () ;

    HRESULT STDMETHODCALLTYPE SetStatus (

		long a_Flags ,
		HRESULT a_Result ,
		BSTR a_StringParamater ,
		IWbemClassObject *a_ObjectParameter
	) ;
} ;

/*****************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

class CInterceptor_IWbemSyncObjectSink_ExecMethodAsync : public CCommon_IWbemSyncObjectSink
{
private:

	long m_Flags ;
	BSTR m_ObjectPath ;
	BSTR m_MethodName ;
	IWbemClassObject *m_InParameters ;
	CInterceptor_IWbemSyncProvider *m_Interceptor ;

protected:
public:

	CInterceptor_IWbemSyncObjectSink_ExecMethodAsync (

		WmiAllocator &a_Allocator ,
		long a_Flags ,
		BSTR a_ObjectPath ,
		BSTR a_MethodName ,
		IWbemClassObject *a_InParameters ,
		CInterceptor_IWbemSyncProvider *a_Interceptor ,
		IWbemObjectSink *a_InterceptedSink ,
		IUnknown *a_Unknown ,
		CWbemGlobal_IWmiObjectSinkController *a_Controller ,
		ULONG a_Dependant = FALSE
	) ;

	~CInterceptor_IWbemSyncObjectSink_ExecMethodAsync () ;

    HRESULT STDMETHODCALLTYPE SetStatus (

		long a_Flags ,
		HRESULT a_Result ,
		BSTR a_StringParamater ,
		IWbemClassObject *a_ObjectParameter
	) ;
} ;

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

class CInterceptor_IWbemFilteringObjectSink :	public CInterceptor_IWbemObjectSink
{
private:

	LONG m_Filtering ;

	BSTR m_QueryLanguage ;
	BSTR m_Query ;

	IWbemQuery *m_QueryFilter ;

protected:
public:

	CInterceptor_IWbemFilteringObjectSink (

		IWbemObjectSink *a_InterceptedSink ,
		IUnknown *a_Unknown ,
		CWbemGlobal_IWmiObjectSinkController *a_Controller ,
		const BSTR a_QueryLanguage ,
		const BSTR a_Query
	) ;

	~CInterceptor_IWbemFilteringObjectSink () ;

public:

    HRESULT STDMETHODCALLTYPE Indicate (

		long a_ObjectCount ,
		IWbemClassObject **a_ObjectArray
	) ;

    HRESULT STDMETHODCALLTYPE SetStatus (

		long a_Flags ,
		HRESULT a_Result ,
		BSTR a_StringParamater ,
		IWbemClassObject *a_ObjectParameter
	) ;
} ;

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

class CInterceptor_IWbemSyncFilteringObjectSink :	public IWbemObjectSink , 
													public IWbemShutdown ,
													public ObjectSinkContainerElement
{
private:

	LONG m_InProgress ;
	LONG m_StatusCalled ;
	LONG m_Filtering ;

	BSTR m_QueryLanguage ;
	BSTR m_Query ;

	ULONG m_Dependant ;

	IWbemObjectSink *m_InterceptedSink ;
	IWbemQuery *m_QueryFilter ;
	IUnknown *m_Unknown ;

protected:

	LONG m_GateClosed ;

public:

	CInterceptor_IWbemSyncFilteringObjectSink (

		IWbemObjectSink *a_InterceptedSink ,
		IUnknown *a_Unknown ,
		CWbemGlobal_IWmiObjectSinkController *a_Controller ,
		const BSTR a_QueryLanguage ,
		const BSTR a_Query ,
		ULONG a_Dependant = FALSE
	) ;

	~CInterceptor_IWbemSyncFilteringObjectSink() ;

	void CallBackInternalRelease () ;

	//Non-delegating object IUnknown

    STDMETHODIMP QueryInterface ( REFIID , LPVOID FAR * ) ;
    STDMETHODIMP_( ULONG ) AddRef () ;
    STDMETHODIMP_( ULONG ) Release () ;

    HRESULT STDMETHODCALLTYPE Indicate (

		long a_ObjectCount ,
		IWbemClassObject **a_ObjectArray
	) ;

    HRESULT STDMETHODCALLTYPE SetStatus (

		long a_Flags ,
		HRESULT a_Result ,
		BSTR a_StringParamater ,
		IWbemClassObject *a_ObjectParameter
	) ;

	HRESULT STDMETHODCALLTYPE Shutdown (

		LONG a_Flags ,
		ULONG a_MaxMilliSeconds ,
		IWbemContext *a_Context
	) ; 
} ;

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

class CInterceptor_DecoupledIWbemObjectSink :	public IWbemObjectSink , 
												public IWbemShutdown ,
												public IObjectSink_CancelOperation ,
												public ObjectSinkContainerElement
{
private:

	LONG m_InProgress ;
	LONG m_StatusCalled ;

	IWbemObjectSink *m_InterceptedSink ;
	IUnknown *m_Unknown ;

	SECURITY_DESCRIPTOR *m_SecurityDescriptor ;

	IWbemServices *m_Provider ;

protected:

	LONG m_GateClosed ;

public:

	CInterceptor_DecoupledIWbemObjectSink (

		IWbemServices *a_Provider ,
		IWbemObjectSink *a_InterceptedSink ,
		IUnknown *a_Unknown ,
		CWbemGlobal_IWmiObjectSinkController *a_Controller 
	) ;

	~CInterceptor_DecoupledIWbemObjectSink () ;

	HRESULT Initialize ( SECURITY_DESCRIPTOR *a_SecurityDescriptor ) ;

	void CallBackInternalRelease () ;

	IWbemServices *GetProvider () { return m_Provider ; }

public:

	//Non-delegating object IUnknown

    STDMETHODIMP QueryInterface ( REFIID , LPVOID FAR * ) ;
    STDMETHODIMP_( ULONG ) AddRef () ;
    STDMETHODIMP_( ULONG ) Release () ;

    HRESULT STDMETHODCALLTYPE Indicate (

		long a_ObjectCount ,
		IWbemClassObject **a_ObjectArray
	) ;

    HRESULT STDMETHODCALLTYPE SetStatus (

		long a_Flags ,
		HRESULT a_Result ,
		BSTR a_StringParamater ,
		IWbemClassObject *a_ObjectParameter
	) ;

	HRESULT STDMETHODCALLTYPE Shutdown (

		LONG a_Flags ,
		ULONG a_MaxMilliSeconds ,
		IWbemContext *a_Context
	) ; 

	HRESULT STDMETHODCALLTYPE Cancel (

		LONG a_Flags
	) ; 
} ;

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

class CInterceptor_DecoupledIWbemCombiningObjectSink :	public IWbemObjectSink , 
														public IWbemShutdown ,
														public IObjectSink_CancelOperation ,
														public ObjectSinkContainerElement ,
														public CWbemGlobal_IWmiObjectSinkController 
{
private:

	LONG m_InProgress ;
	LONG m_StatusCalled ;

	LONG m_SinkCount ;
	HANDLE m_Event ;

	IWbemObjectSink *m_InterceptedSink ;

	void CallBackInternalRelease () ;

protected:

	LONG m_GateClosed ;

public:

	CInterceptor_DecoupledIWbemCombiningObjectSink (

		WmiAllocator &m_Allocator ,
		IWbemObjectSink *a_InterceptedSink ,
		CWbemGlobal_IWmiObjectSinkController *a_Controller
	) ;

	~CInterceptor_DecoupledIWbemCombiningObjectSink () ;

	HRESULT Wait ( ULONG a_Timeout ) ;

	HRESULT EnQueue ( CInterceptor_DecoupledIWbemObjectSink *a_Sink ) ;

	void Suspend () ;

	void Resume () ;

public:

	//Non-delegating object IUnknown

    STDMETHODIMP QueryInterface ( REFIID , LPVOID FAR * ) ;
    STDMETHODIMP_( ULONG ) AddRef () ;
    STDMETHODIMP_( ULONG ) Release () ;

    HRESULT STDMETHODCALLTYPE Indicate (

		long a_ObjectCount ,
		IWbemClassObject **a_ObjectArray
	) ;

    HRESULT STDMETHODCALLTYPE SetStatus (

		long a_Flags ,
		HRESULT a_Result ,
		BSTR a_StringParamater ,
		IWbemClassObject *a_ObjectParameter
	) ;

	HRESULT STDMETHODCALLTYPE Shutdown (

		LONG a_Flags ,
		ULONG a_MaxMilliSeconds ,
		IWbemContext *a_Context
	) ; 

	HRESULT STDMETHODCALLTYPE Cancel (

		LONG a_Flags
	) ; 
} ;

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

class CInterceptor_IWbemWaitingObjectSink :		public IWbemObjectSink , 
												public IWbemShutdown ,
												public IObjectSink_CancelOperation ,
												public ObjectSinkContainerElement ,
												public CWbemGlobal_IWmiObjectSinkController 
{
private:

	LONG m_ReferenceCount ;
	LONG m_InProgress ;
	LONG m_StatusCalled ;

	WmiQueue <IWbemClassObject *,8> m_Queue ;
	CriticalSection m_CriticalSection ;

	HANDLE m_Event ;

	HRESULT m_Result ;

	IWbemServices *m_Provider ;
		
	CServerObject_ProviderRegistrationV1 &m_Registration ;

	SECURITY_DESCRIPTOR *m_SecurityDescriptor ;

protected:

	LONG m_GateClosed ;

public:

	CInterceptor_IWbemWaitingObjectSink (

		WmiAllocator &m_Allocator ,
		IWbemServices *a_Provider ,
		IWbemObjectSink *a_InterceptedSink ,
		CWbemGlobal_IWmiObjectSinkController *a_Controller ,
		CServerObject_ProviderRegistrationV1 &a_Registration 
	) ;

	~CInterceptor_IWbemWaitingObjectSink () ;

	HRESULT Initialize ( SECURITY_DESCRIPTOR *a_SecurityDescriptor ) ;

	void CallBackInternalRelease () ;

	HRESULT Wait ( ULONG a_Timeout = INFINITE ) ;

	WmiQueue <IWbemClassObject *,8> & GetQueue () { return m_Queue ; }
	CriticalSection &GetQueueCriticalSection () { return m_CriticalSection ; }

	HRESULT GetResult () { return m_Result ; }

	IWbemServices *GetProvider () { return m_Provider ; }

public:

	//Non-delegating object IUnknown

    STDMETHODIMP QueryInterface ( REFIID , LPVOID FAR * ) ;
    STDMETHODIMP_( ULONG ) AddRef () ;
    STDMETHODIMP_( ULONG ) Release () ;

    HRESULT STDMETHODCALLTYPE Indicate (

		long a_ObjectCount ,
		IWbemClassObject **a_ObjectArray
	) ;

    HRESULT STDMETHODCALLTYPE SetStatus (

		long a_Flags ,
		HRESULT a_Result ,
		BSTR a_StringParamater ,
		IWbemClassObject *a_ObjectParameter
	) ;

	HRESULT STDMETHODCALLTYPE Shutdown (

		LONG a_Flags ,
		ULONG a_MaxMilliSeconds ,
		IWbemContext *a_Context
	) ; 

	HRESULT STDMETHODCALLTYPE Cancel (

		LONG a_Flags
	) ; 
} ;

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

class CInterceptor_IWbemWaitingObjectSink_GetObjectAsync : public CInterceptor_IWbemWaitingObjectSink
{
private:

	BSTR m_ObjectPath ;
	LONG m_Flags ;
	IWbemContext *m_Context ;

protected:
public:

	CInterceptor_IWbemWaitingObjectSink_GetObjectAsync ( 

		WmiAllocator &m_Allocator ,
		IWbemServices *a_Provider ,
		IWbemObjectSink *a_InterceptedSink ,
		CWbemGlobal_IWmiObjectSinkController *a_Controller ,
		CServerObject_ProviderRegistrationV1 &a_Registration 
	) ;

	~CInterceptor_IWbemWaitingObjectSink_GetObjectAsync () ;

	HRESULT Initialize ( 
	
		SECURITY_DESCRIPTOR *a_SecurityDescriptor , 
		BSTR a_ObjectPath ,
		LONG a_Flags , 
		IWbemContext *a_Context
	) ;
} ;

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

class CInterceptor_IWbemWaitingObjectSink_DeleteClassAsync : public CInterceptor_IWbemWaitingObjectSink
{
private:

	BSTR m_Class ;
	LONG m_Flags ;
	IWbemContext *m_Context ;

protected:
public:

	CInterceptor_IWbemWaitingObjectSink_DeleteClassAsync ( 

		WmiAllocator &m_Allocator ,
		IWbemServices *a_Provider ,
		IWbemObjectSink *a_InterceptedSink ,
		CWbemGlobal_IWmiObjectSinkController *a_Controller ,
		CServerObject_ProviderRegistrationV1 &a_Registration 
	) ;

	~CInterceptor_IWbemWaitingObjectSink_DeleteClassAsync () ;

	HRESULT Initialize ( 
	
		SECURITY_DESCRIPTOR *a_SecurityDescriptor , 
		BSTR a_Class ,
		LONG a_Flags , 
		IWbemContext *a_Context
	) ;
} ;

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

class CInterceptor_IWbemWaitingObjectSink_CreateClassEnumAsync : public CInterceptor_IWbemWaitingObjectSink
{
private:

	BSTR m_SuperClass ;
	LONG m_Flags ;
	IWbemContext *m_Context ;

protected:
public:

	CInterceptor_IWbemWaitingObjectSink_CreateClassEnumAsync ( 

		WmiAllocator &m_Allocator ,
		IWbemServices *a_Provider ,
		IWbemObjectSink *a_InterceptedSink ,
		CWbemGlobal_IWmiObjectSinkController *a_Controller ,
		CServerObject_ProviderRegistrationV1 &a_Registration 
	) ;

	~CInterceptor_IWbemWaitingObjectSink_CreateClassEnumAsync () ;

	HRESULT Initialize ( 
	
		SECURITY_DESCRIPTOR *a_SecurityDescriptor , 
		BSTR a_SuperClass ,
		LONG a_Flags , 
		IWbemContext *a_Context
	) ;
} ;

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

class CInterceptor_IWbemWaitingObjectSink_PutClassAsync : public CInterceptor_IWbemWaitingObjectSink
{
private:

	IWbemClassObject *m_ClassObject ;
	LONG m_Flags ;
	IWbemContext *m_Context ;

protected:
public:

	CInterceptor_IWbemWaitingObjectSink_PutClassAsync ( 

		WmiAllocator &m_Allocator ,
		IWbemServices *a_Provider ,
		IWbemObjectSink *a_InterceptedSink ,
		CWbemGlobal_IWmiObjectSinkController *a_Controller ,
		CServerObject_ProviderRegistrationV1 &a_Registration 
	) ;

	~CInterceptor_IWbemWaitingObjectSink_PutClassAsync () ;

	HRESULT Initialize ( 
	
		SECURITY_DESCRIPTOR *a_SecurityDescriptor , 
		IWbemClassObject *a_ClassObject ,
		LONG a_Flags , 
		IWbemContext *a_Context
	) ;
} ;

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

class CWaitingObjectSink :	public IWbemObjectSink ,
							public IWbemShutdown ,
							public ObjectSinkContainerElement
{
private:

	LONG m_InProgress ;
	LONG m_StatusCalled ;

	HRESULT m_Result ;

	LONG m_ReferenceCount ;

	HANDLE m_Event ;

	WmiQueue <IWbemClassObject *,8> m_Queue ;
	CriticalSection m_CriticalSection ;

protected:

	LONG m_GateClosed ;

public:

	HRESULT SinkInitialize () ;

public:

	CWaitingObjectSink ( WmiAllocator &a_Allocator ) ;

	~CWaitingObjectSink () ;

    STDMETHODIMP QueryInterface ( REFIID , LPVOID FAR * ) ;

	STDMETHODIMP_( ULONG ) AddRef () ;

	STDMETHODIMP_(ULONG) Release () ;

    HRESULT STDMETHODCALLTYPE SetStatus (

        long a_Flags ,
        HRESULT a_Result ,
        BSTR a_StringParameter ,
        IWbemClassObject *a_ObjectParameter
	) ;

    HRESULT STDMETHODCALLTYPE Indicate (

        LONG a_ObjectCount,
        IWbemClassObject **a_ObjectArray
	) ;

	HRESULT Wait ( DWORD a_Timeout = INFINITE ) ;

	HRESULT STDMETHODCALLTYPE Shutdown (

		LONG a_Flags ,
		ULONG a_MaxMilliSeconds ,
		IWbemContext *a_Context
	) ; 

	WmiQueue <IWbemClassObject *,8> & GetQueue () { return m_Queue ; }
	CriticalSection &GetQueueCriticalSection () { return m_CriticalSection ; }

	HRESULT GetResult () { return m_Result ; }
} ;

#endif _Server_Interceptor_IWbemObjectSink_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\winmgmt\provsubsys\server\include\provresv.h ===
/*++

Copyright (C) 1996-2001 Microsoft Corporation

Module Name:

	ProvResv.h

Abstract:


History:

--*/

#ifndef _Server_DynamicPropertyProviderResolver_H
#define _Server_DynamicPropertyProviderResolver_H

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

class CServerObject_DynamicPropertyProviderResolver :	public _IWmiDynamicPropertyResolver , 
														public IWbemProviderInit , 
														public IWbemShutdown
{
private:

    long m_ReferenceCount ;
	WmiAllocator &m_Allocator ;
	_IWmiProviderFactory *m_Factory ;
	IWbemServices *m_CoreStub ;
	BSTR m_User ;
	BSTR m_Locale ;

	HRESULT GetClassAndInstanceContext (

		IWbemClassObject *a_Class ,
		IWbemClassObject *a_Instance ,
		BSTR &a_ClassContext ,
		BSTR &a_InstanceContext ,
		BOOL &a_Dynamic
	) ;

	HRESULT ReadOrWrite (

		IWbemContext *a_Context ,
		IWbemClassObject *a_Instance ,
		BSTR a_ClassContext ,
		BSTR a_InstanceContext ,
		BSTR a_PropertyContext ,
		BSTR a_Provider ,
		BSTR a_Property ,
		BOOL a_Read 
	) ;

	HRESULT STDMETHODCALLTYPE ReadOrWrite (

		IWbemContext *a_Context ,
        IWbemClassObject *a_Class ,
        IWbemClassObject *a_Instance ,
		BOOL a_Read 
	) ;

protected:
public:

    CServerObject_DynamicPropertyProviderResolver (

		WmiAllocator &a_Allocator ,
		_IWmiProviderFactory *a_Factory ,
		IWbemServices *a_CoreStub
	) ;

    ~CServerObject_DynamicPropertyProviderResolver () ;

	//IUnknown members

	STDMETHODIMP QueryInterface ( REFIID , LPVOID FAR * ) ;
    STDMETHODIMP_( ULONG ) AddRef () ;
    STDMETHODIMP_( ULONG ) Release () ;

	// IWmi_DynamicPropertyResolver members

    HRESULT STDMETHODCALLTYPE Read (

		IWbemContext *a_Context ,
		IWbemClassObject *a_Class ,
		IWbemClassObject **a_Instance
	);

	HRESULT STDMETHODCALLTYPE Write (

		IWbemContext *a_Context ,
        IWbemClassObject *a_Class ,
        IWbemClassObject *a_Instance
	) ;

	HRESULT STDMETHODCALLTYPE Initialize (

		LPWSTR a_User ,
		LONG a_Flags ,
		LPWSTR a_Namespace ,
		LPWSTR a_Locale ,
		IWbemServices *a_Core ,
		IWbemContext *a_Context ,
		IWbemProviderInitSink *a_Sink
	) ;

	HRESULT STDMETHODCALLTYPE Shutdown (

		LONG a_Flags ,
		ULONG a_MaxMilliSeconds ,
		IWbemContext *a_Context
	) ;
};

#endif // #define _Server_DynamicPropertyProviderResolver_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\winmgmt\provsubsys\server\include\provrmgr.h ===
/*++

Copyright (C) 1996-2001 Microsoft Corporation

Module Name:

	ProvSubS.h

Abstract:


History:

--*/

#ifndef _Server_ProviderRefresherManager_H
#define _Server_ProviderRefresherManager_H

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

#include "ProvCache.h"

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

#define ProxyIndex_RefresherManager_IWbemRefresherMgr				0
#define ProxyIndex_RefresherManager_IWbemShutdown					1

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

class CServerObject_InterceptorProviderRefresherManager :	public _IWbemRefresherMgr ,
															public IWbemShutdown ,
															public RefresherManagerCacheElement

{
public:
private:

	LONG m_ReferenceCount ;

	WmiAllocator &m_Allocator ;

	ProxyContainer m_ProxyContainer ;

	_IWmiProviderHost *m_Host ;
	_IWbemRefresherMgr *m_Manager ; 
	IWbemShutdown *m_Shutdown ;

	LONG m_Initialized ;
	LONG m_UnInitialized ;
	HRESULT m_InitializeResult ;
	HANDLE m_InitializedEvent ;
	IWbemContext *m_InitializationContext ;

protected:

	HRESULT AbnormalShutdown () ;

public:

	HRESULT Initialize () ;

	HRESULT SetManager ( _IWmiProviderHost *a_Host , _IWbemRefresherMgr *a_Manager ) ;

	HRESULT SetInitialized ( HRESULT a_InitializeResult ) ;

	HRESULT IsIndependant ( IWbemContext *a_Context ) ;

	HRESULT STDMETHODCALLTYPE WaitProvider ( IWbemContext *a_Context , ULONG a_Timeout ) ;

	HRESULT STDMETHODCALLTYPE GetInitializeResult () 
	{
		return m_InitializeResult ;
	}

public:

    CServerObject_InterceptorProviderRefresherManager (

		CWbemGlobal_IWbemRefresherMgrController *a_Controller ,
		const ULONG &a_Period ,
		WmiAllocator &a_Allocator ,
		IWbemContext *a_InitializationContext
	) ;

    ~CServerObject_InterceptorProviderRefresherManager () ;

	//IUnknown members

	STDMETHODIMP QueryInterface ( REFIID , LPVOID FAR * ) ;
    STDMETHODIMP_( ULONG ) AddRef () ;
    STDMETHODIMP_( ULONG ) Release () ;

	// IWmi_ProviderSubSystem members

	// IWmi_Initialize members

	HRESULT STDMETHODCALLTYPE Startup (

		LONG a_Flags ,
		IWbemContext *a_Context ,
		_IWmiProvSS *a_ProvSS
	) ;

	// IWmi_UnInitialize members

	HRESULT STDMETHODCALLTYPE Shutdown (

		LONG a_Flags ,
		ULONG a_MaxMilliSeconds ,
		IWbemContext *a_Context
	) ;

	HRESULT STDMETHODCALLTYPE AddObjectToRefresher (

		IWbemServices *a_Service, 
		LPCWSTR a_ServerName, 
		LPCWSTR a_Namespace, 
		IWbemClassObject* pClassObject,
		WBEM_REFRESHER_ID *a_DestinationRefresherId, 
		IWbemClassObject *a_InstanceTemplate, 
		long a_Flags, 
		IWbemContext *a_Context,
		IUnknown* pLockMgr,
		WBEM_REFRESH_INFO *a_Information
	) ;

	HRESULT STDMETHODCALLTYPE AddEnumToRefresher (

		IWbemServices *a_Service, 
		LPCWSTR a_ServerName, 
		LPCWSTR a_Namespace, 
		IWbemClassObject* pClassObject,
		WBEM_REFRESHER_ID *a_DestinationRefresherId, 
		IWbemClassObject *a_InstanceTemplate, 
		LPCWSTR a_Class,
		long a_Flags, 
		IWbemContext *a_Context, 
		IUnknown* pLockMgr,
		WBEM_REFRESH_INFO *a_Information
	) ;

	HRESULT STDMETHODCALLTYPE GetRemoteRefresher (

		WBEM_REFRESHER_ID *a_RefresherId , 
		long a_Flags, 
		BOOL fAddRefresher,
		IWbemRemoteRefresher **a_RemoteRefresher ,  
		IUnknown* pLockMgr,
		GUID *a_Guid
	) ;

	HRESULT STDMETHODCALLTYPE LoadProvider (

		IWbemServices *a_Service ,
		LPCWSTR a_ProviderName ,
		LPCWSTR a_Namespace ,
		IWbemContext * a_Context,
		IWbemHiPerfProvider **a_Provider,
		_IWmiProviderStack **a_ProvStack
	) ; 
};

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

class CServerObject_ProviderRefresherManager :	public _IWbemRefresherMgr ,
												public IWbemShutdown

{
public:
private:

	LONG m_ReferenceCount ;

	WmiAllocator &m_Allocator ;

	_IWbemRefresherMgr *m_Manager ; 
	IWbemShutdown *m_Shutdown ;

protected:

public:

    CServerObject_ProviderRefresherManager ( WmiAllocator &a_Allocator ) ;
    ~CServerObject_ProviderRefresherManager () ;

	//IUnknown members

	STDMETHODIMP QueryInterface ( REFIID , LPVOID FAR * ) ;
    STDMETHODIMP_( ULONG ) AddRef () ;
    STDMETHODIMP_( ULONG ) Release () ;

	// IWmi_ProviderSubSystem members

	// IWmi_Initialize members

	HRESULT STDMETHODCALLTYPE Startup (

		LONG a_Flags ,
		IWbemContext *a_Context ,
		_IWmiProvSS *a_ProvSS
	) ;

	// IWmi_UnInitialize members

	HRESULT STDMETHODCALLTYPE Shutdown (

		LONG a_Flags ,
		ULONG a_MaxMilliSeconds ,
		IWbemContext *a_Context
	) ;

	HRESULT STDMETHODCALLTYPE AddObjectToRefresher (

		IWbemServices *a_Service, 
		LPCWSTR a_ServerName, 
		LPCWSTR a_Namespace, 
		IWbemClassObject* pClassObject,
		WBEM_REFRESHER_ID *a_DestinationRefresherId, 
		IWbemClassObject *a_InstanceTemplate, 
		long a_Flags, 
		IWbemContext *a_Context,
		IUnknown* pLockMgr,
		WBEM_REFRESH_INFO *a_Information
	) ;

	HRESULT STDMETHODCALLTYPE AddEnumToRefresher (

		IWbemServices *a_Service, 
		LPCWSTR a_ServerName, 
		LPCWSTR a_Namespace, 
		IWbemClassObject* pClassObject,
		WBEM_REFRESHER_ID *a_DestinationRefresherId, 
		IWbemClassObject *a_InstanceTemplate, 
		LPCWSTR a_Class,
		long a_Flags, 
		IWbemContext *a_Context, 
		IUnknown* pLockMgr,
		WBEM_REFRESH_INFO *a_Information
	) ;

	HRESULT STDMETHODCALLTYPE GetRemoteRefresher (

		WBEM_REFRESHER_ID *a_RefresherId , 
		long a_Flags, 
		BOOL fAddRefresher,
		IWbemRemoteRefresher **a_RemoteRefresher ,  
		IUnknown* pLockMgr,
		GUID *a_Guid
	) ;

	HRESULT STDMETHODCALLTYPE LoadProvider (

		IWbemServices *a_Service ,
		LPCWSTR a_ProviderName ,
		LPCWSTR a_Namespace ,
		IWbemContext * a_Context,
		IWbemHiPerfProvider **a_Provider,
		_IWmiProviderStack** a_ProvStack
	) ; 
};

#endif // _Server_ProviderRefresherManager_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\winmgmt\provsubsys\server\include\provsubs.h ===
/*++

Copyright (C) 1996-2001 Microsoft Corporation

Module Name:

	ProvSubS.h

Abstract:


History:

--*/

#ifndef _Server_ProviderSubSystem_H
#define _Server_ProviderSubSystem_H

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

#include "ProvCache.h"

class CInterceptor_IWmiProvSSSink :	public _IWmiProvSSSink , 
									public VoidPointerContainerElement 
{
private:

	_IWmiProvSSSink *m_InterceptedSink ;

protected:
public:

	CInterceptor_IWmiProvSSSink (

		_IWmiProvSSSink *a_InterceptedSink ,
		CWbemGlobal_VoidPointerController *a_Controller 
	) ;

	~CInterceptor_IWmiProvSSSink () ;

public:

	//Non-delegating object IUnknown

    STDMETHODIMP QueryInterface ( REFIID , LPVOID FAR * ) ;
    STDMETHODIMP_( ULONG ) AddRef () ;
    STDMETHODIMP_( ULONG ) Release () ;

    HRESULT STDMETHODCALLTYPE Synchronize (

		long a_Flags ,
		IWbemContext *a_Context ,
		LPCWSTR a_Namespace ,
		LPCWSTR a_Provider
	) ;
} ;

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

class CServerObject_BindingFactory ;
class CServerObject_ProviderSubSystem : public _IWmiProvSS ,
										public _IWmiCoreWriteHook ,
										public _IWmiProviderConfiguration ,
										public IWbemShutdown ,
										public ProvSubSysContainerElement ,
										public CWbemGlobal_IWmiFactoryController

{
public:

	class InternalInterface : public _IWmiCoreWriteHook
	{
	private:

		CServerObject_ProviderSubSystem *m_This ;

	public:

		InternalInterface ( CServerObject_ProviderSubSystem *a_This ) : m_This ( a_This )
		{
		}

		STDMETHODIMP QueryInterface (

			REFIID iid ,
			LPVOID FAR *iplpv
		)
		{
			*iplpv = NULL ;

			if ( iid == IID_IUnknown )
			{
				*iplpv = ( LPVOID ) this ;
			}
			else if ( iid == IID__IWmiCoreWriteHook )
			{
				*iplpv = ( LPVOID ) ( _IWmiCoreWriteHook * ) this ;		
			}	

			if ( *iplpv )
			{
				( ( LPUNKNOWN ) *iplpv )->AddRef () ;

				return ResultFromScode ( S_OK ) ;
			}
			else
			{
				return ResultFromScode ( E_NOINTERFACE ) ;
			}
		}

		STDMETHODIMP_( ULONG ) AddRef ()
		{
			return m_This->ProvSubSysContainerElement :: NonCyclicAddRef () ;
		}

		STDMETHODIMP_( ULONG ) Release ()
		{
			return m_This->ProvSubSysContainerElement :: NonCyclicRelease () ;
		}

		HRESULT STDMETHODCALLTYPE PrePut (

			long a_Flags ,
			long a_UserFlags ,
			IWbemContext *a_Context ,
			IWbemPath *a_Path ,
			LPCWSTR a_Namespace ,
			LPCWSTR a_Class ,
			_IWmiObject *a_Copy
		)
		{
			return m_This->PrePut (

				a_Flags ,
				a_UserFlags ,
				a_Context ,
				a_Path ,
				a_Namespace ,
				a_Class ,
				a_Copy
			) ;
		}

		HRESULT STDMETHODCALLTYPE PostPut (

			long a_Flags ,
            HRESULT hRes,
			IWbemContext *a_Context ,
			IWbemPath *a_Path ,
			LPCWSTR a_Namespace ,
			LPCWSTR a_Class ,
			_IWmiObject *a_New ,
			_IWmiObject *a_Old
		)
		{
			return m_This->PostPut (

				a_Flags ,
                hRes,
				a_Context ,
				a_Path ,
				a_Namespace ,
				a_Class ,
				a_New ,
				a_Old
			) ;
		}

		HRESULT STDMETHODCALLTYPE PreDelete (

			long a_Flags ,
			long a_UserFlags ,
			IWbemContext *a_Context ,
			IWbemPath *a_Path,
			LPCWSTR a_Namespace,
			LPCWSTR a_Class
		)
		{
			return m_This->PreDelete (

				a_Flags ,
				a_UserFlags ,
				a_Context ,
				a_Path,
				a_Namespace,
				a_Class
			) ;
		}

		HRESULT STDMETHODCALLTYPE PostDelete (

			long a_Flags ,
            HRESULT hRes,
			IWbemContext *a_Context ,
			IWbemPath *a_Path,
			LPCWSTR a_Namespace,
			LPCWSTR a_Class,
			_IWmiObject *a_Old
		)
		{
			return m_This->PostDelete (

				a_Flags ,
                hRes,
				a_Context ,
				a_Path,
				a_Namespace,
				a_Class,
				a_Old
			) ;
		}
	} ;

	InternalInterface m_Internal ;

	void CallBackInternalRelease () ;

private:

	_IWmiCoreServices *m_Core ;

	WmiAllocator &m_Allocator ;

	CWbemGlobal_VoidPointerController *m_SinkController ;

	wchar_t *Strip_Slash ( wchar_t *a_String ) ;
	wchar_t *Strip_Server ( wchar_t *a_String , wchar_t *&a_FreeString ) ;

	HRESULT IsChild_Namespace (	wchar_t *a_Left , wchar_t *a_Right ) ;

	HRESULT GetNamespaceServerPath (

		IWbemPath *a_Namespace ,
		wchar_t *&a_ServerNamespacePath
	) ;

	HRESULT Cache (

		LPCWSTR a_Namespace ,
		IWbemPath *a_NamespacePath ,
		CServerObject_BindingFactory *a_Factory ,
		BindingFactoryCacheKey &a_Key ,
		REFIID a_RIID ,
		void **a_Interface
	) ;

	HRESULT CreateAndCache (

		IWbemServices *a_Core ,
		LONG a_Flags ,
		IWbemContext *a_Context ,
		LPCWSTR a_Namespace ,
		IWbemPath *a_NamespacePath ,
		BindingFactoryCacheKey &a_Key ,
		REFIID a_RIID ,
		void **a_Interface
	) ;

	HRESULT GetProvider (

		LPCWSTR a_Class ,
		IWbemPath *a_Path ,
		IWbemClassObject *a_Object ,
		LPWSTR &a_Provider
	) ;

	HRESULT Call_Load (

		long a_Flags ,
		IWbemContext *a_Context ,
		LPCWSTR a_Class ,
		LPCWSTR a_Path ,		
		LPCWSTR a_Method,
		IWbemClassObject *a_InParams,
		IWbemObjectSink *a_Sink
	) ;

	HRESULT GetDeleteInfo (

		IWbemClassObject *a_OldObject ,
		LPCWSTR a_Class ,
		IWbemPath *a_Path ,
		LPWSTR &a_OutClass ,
		LPWSTR &a_OutStringPath ,
		IWbemPath *&a_OutPathObject
	) ;

	HRESULT PostDelete_ProviderRegistration (

		long a_Flags ,
		HRESULT hRes,
		IWbemContext *a_Context ,
		IWbemPath *a_Path,
		LPCWSTR a_PathString ,
		LPCWSTR a_Namespace,
		LPCWSTR a_Class,
		IWbemClassObject *a_Old

	) ;

	HRESULT PostDelete_Namespace (

		long a_Flags ,
		HRESULT hRes,
		IWbemContext *a_Context ,
		IWbemPath *a_Path,
		LPCWSTR a_PathString ,
		LPCWSTR a_Namespace,
		LPCWSTR a_Class,
		IWbemClassObject *a_Old
	) ;

	QueryPreprocessor :: QuadState IsA (

		IWbemClassObject *a_Left ,
		wchar_t *a_Right
	) ;

	HRESULT VerifySecurity ( 

		IWbemContext *a_Context ,
		const BSTR a_Provider ,
		const BSTR a_NamespacePath
	) ;

	HRESULT GetPath (

		IWbemClassObject *a_Object ,
		IWbemPath *&a_Path ,
		LPWSTR &a_PathText
	) ;

	static HRESULT ReportEvent ( 

		CServerObject_ProviderRegistrationV1 &a_Registration ,
		const BSTR a_NamespacePath
	) ;

	HRESULT ClearSinkController () ;

protected:
public:

    CServerObject_ProviderSubSystem ( WmiAllocator &a_Allocator , CWbemGlobal_IWmiProvSubSysController *a_Controller ) ;
    ~CServerObject_ProviderSubSystem ( void ) ;

	HRESULT GetWmiRepositoryService (

		IWbemPath *a_Namespace ,
		const BSTR a_User ,
		const BSTR a_Locale ,
		IWbemServices *&a_Service
	) ;

	HRESULT GetWmiRepositoryService (

		const BSTR a_Namespace ,
		const BSTR a_User ,
		const BSTR a_Locale ,
		IWbemServices *&a_Service
	) ;

	HRESULT GetWmiService (

		IWbemPath *a_Namespace ,
		const BSTR a_User ,
		const BSTR a_Locale ,
		IWbemServices *&a_Service
	) ;

	HRESULT GetWmiService (

		const BSTR a_Namespace ,
		const BSTR a_User ,
		const BSTR a_Locale ,
		IWbemServices *&a_Service
	) ;

	HRESULT ForwardReload (

		long a_Flags ,
		IWbemContext *a_Context ,
		LPCWSTR a_Namespace ,
		LPCWSTR a_Provider
	) ;

	//IUnknown members

	STDMETHODIMP QueryInterface ( REFIID , LPVOID FAR * ) ;
    STDMETHODIMP_( ULONG ) AddRef () ;
    STDMETHODIMP_( ULONG ) Release () ;

	// IWmi_ProviderSubSystem members

	HRESULT STDMETHODCALLTYPE Create (

		IWbemServices *a_Core ,
		LONG a_Flags ,
		IWbemContext *a_Context ,
		LPCWSTR a_Namespace ,
		REFIID a_RIID ,
		void **a_Interface
	) ;

	HRESULT STDMETHODCALLTYPE CreateRefresherManager (

		IWbemServices *a_Core ,
		LONG a_Flags ,
		IWbemContext *a_Context ,
		REFIID a_RIID ,
		void **a_Interface
   	) ;

	HRESULT STDMETHODCALLTYPE RegisterNotificationSink (

		LONG a_Flags ,
		IWbemContext *a_Context ,
		_IWmiProvSSSink *a_Sink
	) ;

	HRESULT STDMETHODCALLTYPE UnRegisterNotificationSink (

		LONG a_Flags ,
		IWbemContext *a_Context ,
		_IWmiProvSSSink *a_Sink
	) ;

	// IWmi_Initialize members

	HRESULT STDMETHODCALLTYPE Initialize (

		LONG a_Flags ,
		IWbemContext *a_Context ,
		_IWmiCoreServices *a_Core
	) ;

	// IWmi_UnInitialize members

	HRESULT STDMETHODCALLTYPE Shutdown (

		LONG a_Flags ,
		ULONG a_MaxMilliSeconds ,
		IWbemContext *a_Context
	) ;

	WmiStatusCode Strobe ( ULONG &a_NextStrobeDelta ) ;

	WmiStatusCode StrobeBegin ( const ULONG &a_Period ) ;

	/* _IWmiProviderConfiguration methods */

	HRESULT STDMETHODCALLTYPE Get (

		IWbemServices *a_Service ,
		long a_Flags ,
		IWbemContext *a_Context ,
		LPCWSTR a_Class ,
		LPCWSTR a_Path ,
		IWbemObjectSink *a_Sink
	) ;

	HRESULT STDMETHODCALLTYPE Set (

		IWbemServices *a_Service ,
		long a_Flags ,
		IWbemContext *a_Context ,
		LPCWSTR a_Provider ,
		LPCWSTR a_Class ,
		LPCWSTR a_Path ,
		IWbemClassObject *a_OldObject ,
		IWbemClassObject *a_NewObject  
	) ;

	HRESULT STDMETHODCALLTYPE Deleted (

		IWbemServices *a_Service ,
		long a_Flags ,
		IWbemContext *a_Context ,
		LPCWSTR a_Provider ,
		LPCWSTR a_Class ,
		LPCWSTR a_Path ,
		IWbemClassObject *a_Object  
	) ;

	HRESULT STDMETHODCALLTYPE Enumerate (

		IWbemServices *a_Service ,
		long a_Flags ,
		IWbemContext *a_Context ,
		LPCWSTR a_Class ,
		IWbemObjectSink *a_Sink
	) ;

	HRESULT STDMETHODCALLTYPE Shutdown (

		IWbemServices *a_Service ,
		long a_Flags ,
		IWbemContext *a_Context ,
		LPCWSTR a_Provider ,
		ULONG a_MilliSeconds
	) ;

	HRESULT STDMETHODCALLTYPE Call (

		IWbemServices *a_Service ,
		long a_Flags ,
		IWbemContext *a_Context ,
		LPCWSTR a_Class ,
		LPCWSTR a_Path ,		
		LPCWSTR a_Method,
		IWbemClassObject *a_InParams,
		IWbemObjectSink *a_Sink
	) ;

	HRESULT STDMETHODCALLTYPE Query (

		IWbemServices *a_Service ,
		long a_Flags ,
		IWbemContext *a_Context ,
		WBEM_PROVIDER_CONFIGURATION_CLASS_ID a_ClassIdentifier ,
		WBEM_PROVIDER_CONFIGURATION_PROPERTY_ID a_PropertyIdentifier ,
		VARIANT *a_Value 
	) ;

    HRESULT STDMETHODCALLTYPE PrePut (

        long a_Flags ,
        long a_UserFlags ,
        IWbemContext *a_Context ,
        IWbemPath *a_Path ,
        LPCWSTR a_Namespace ,
        LPCWSTR a_Class ,
        _IWmiObject *a_Copy
	) ;

    HRESULT STDMETHODCALLTYPE PostPut (

        long a_Flags ,
        HRESULT hRes,
        IWbemContext *a_Context ,
        IWbemPath *a_Path ,
        LPCWSTR a_Namespace ,
        LPCWSTR a_Class ,
        _IWmiObject *a_New ,
        _IWmiObject *a_Old
	) ;

    HRESULT STDMETHODCALLTYPE PreDelete (

        long a_Flags ,
        long a_UserFlags ,
        IWbemContext *a_Context ,
        IWbemPath *a_Path,
        LPCWSTR a_Namespace,
        LPCWSTR a_Class
	) ;

    HRESULT STDMETHODCALLTYPE PostDelete (

        long a_Flags ,
        HRESULT hRes,
        IWbemContext *a_Context ,
        IWbemPath *a_Path,
        LPCWSTR a_Namespace,
        LPCWSTR a_Class,
        _IWmiObject *a_Old
	) ;
};

#endif // _Server_ProviderSubSystem_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\winmgmt\provsubsys\server\include\provself.h ===
/*++

Copyright (C) 1996-2001 Microsoft Corporation

Module Name:

	ProvResv.H

Abstract:


History:

--*/

#ifndef _Server_ProviderSelfInstrumentation_H
#define _Server_ProviderSelfInstrumentation_H

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

class CServerObject_IWbemServices : public IWbemServices , 
                                public IWbemProviderInit,
                                public IWbemShutdown
{
private:

	LONG m_ReferenceCount ;         //Object reference count

	IWbemServices *m_Service ;

	HRESULT Write_Msft_WmiProvider_Counters ( 
		
		IWbemClassObject *a_Object 
	) ;

	HRESULT GetObjectAsync_Msft_WmiProvider_Counters ( 
		
		IWbemPath *a_Path,
		BSTR a_Class ,
		const BSTR a_ObjectPath, 
		long a_Flags, 
		IWbemContext *a_Context,
		IWbemObjectSink *a_Sink
	) ;

	HRESULT GetObjectAsync_Msft_Providers ( 
		
		IWbemPath *a_Path,
		BSTR a_Class ,
		const BSTR a_ObjectPath, 
		long a_Flags, 
		IWbemContext *a_Context,
		IWbemObjectSink *a_Sink
	) ;

	HRESULT CreateInstanceEnumAsync_Msft_WmiProvider_Counters (

 		const BSTR a_Class, 
		long a_Flags, 
		IWbemContext *a_Context,
		IWbemObjectSink *a_Sink 
	) ;

	HRESULT CreateInstanceEnumAsync_Msft_Providers (

 		const BSTR a_Class, 
		long a_Flags, 
		IWbemContext *a_Context,
		IWbemObjectSink *a_Sink 
	) ;

	HRESULT Helper_ExecMethodAsync_Suspend ( 

		IWbemPath *a_Path ,
		const BSTR a_ObjectPath,
		const BSTR a_MethodName,
		long a_Flags,
		IWbemContext *a_Context,
		IWbemClassObject *a_InParams,
		IWbemObjectSink *a_Sink
	) ;

	HRESULT Helper_ExecMethodAsync_Resume ( 

		IWbemPath *a_Path ,
		const BSTR a_ObjectPath,
		const BSTR a_MethodName,
		long a_Flags,
		IWbemContext *a_Context,
		IWbemClassObject *a_InParams,
		IWbemObjectSink *a_Sink
	) ;

	HRESULT Helper_ExecMethodAsync_UnLoad ( 

		IWbemPath *a_Path ,
		const BSTR a_ObjectPath,
		const BSTR a_MethodName,
		long a_Flags,
		IWbemContext *a_Context,
		IWbemClassObject *a_InParams,
		IWbemObjectSink *a_Sink
	) ;

	HRESULT Helper_ExecMethodAsync_Load ( 

		IWbemPath *a_Path ,
		const BSTR a_ObjectPath,
		const BSTR a_MethodName,
		long a_Flags,
		IWbemContext *a_Context,
		IWbemClassObject *a_InParams,
		IWbemObjectSink *a_Sink
	) ;

public:

	CServerObject_IWbemServices (

		WmiAllocator &a_Allocator
	) ;

    ~CServerObject_IWbemServices () ;

public:

	//Non-delegating object IUnknown

    STDMETHODIMP QueryInterface ( REFIID , LPVOID FAR * ) ;
    STDMETHODIMP_( ULONG ) AddRef () ;
    STDMETHODIMP_( ULONG ) Release () ;

    /* IWbemServices methods */

    HRESULT STDMETHODCALLTYPE OpenNamespace ( 

        const BSTR a_Namespace ,
        long a_Flags ,
        IWbemContext *a_Context ,
        IWbemServices **a_Service ,
        IWbemCallResult **a_CallResult
	) ;
    
    HRESULT STDMETHODCALLTYPE CancelAsyncCall ( 

        IWbemObjectSink *a_Sink
	) ;
    
    HRESULT STDMETHODCALLTYPE QueryObjectSink ( 

        long a_Flags ,
        IWbemObjectSink **a_Sink
	) ;
    
    HRESULT STDMETHODCALLTYPE GetObject ( 

		const BSTR a_ObjectPath ,
        long a_Flags ,
        IWbemContext *a_Context ,
        IWbemClassObject **ppObject ,
        IWbemCallResult **a_CallResult
	) ;
    
    HRESULT STDMETHODCALLTYPE GetObjectAsync (
        
		const BSTR a_ObjectPath ,
        long a_Flags ,
        IWbemContext *a_Context ,
        IWbemObjectSink *a_Sink
	) ;

    HRESULT STDMETHODCALLTYPE PutClass ( 

        IWbemClassObject *a_Object ,
        long a_Flags ,
        IWbemContext *a_Context ,
        IWbemCallResult **a_CallResult
	) ;
    
    HRESULT STDMETHODCALLTYPE PutClassAsync ( 

        IWbemClassObject *a_Object ,
        long a_Flags ,
        IWbemContext *a_Context ,
        IWbemObjectSink *a_Sink
	) ;
    
    HRESULT STDMETHODCALLTYPE DeleteClass ( 

        const BSTR a_Class ,
        long a_Flags ,
        IWbemContext *a_Context ,
        IWbemCallResult **a_CallResult
	) ;
    
    HRESULT STDMETHODCALLTYPE DeleteClassAsync ( 

        const BSTR a_Class ,
        long a_Flags ,
        IWbemContext *a_Context ,
        IWbemObjectSink *a_Sink
	) ;
    
    HRESULT STDMETHODCALLTYPE CreateClassEnum ( 

        const BSTR a_Superclass ,
        long a_Flags ,
        IWbemContext *a_Context ,
        IEnumWbemClassObject **a_Enum
	) ;
    
    HRESULT STDMETHODCALLTYPE CreateClassEnumAsync ( 

		const BSTR a_Superclass ,
		long a_Flags ,
		IWbemContext *a_Context ,
		IWbemObjectSink *a_Sink
	) ;
    
    HRESULT STDMETHODCALLTYPE PutInstance (

		IWbemClassObject *a_Instance ,
		long a_Flags , 
		IWbemContext *a_Context ,
		IWbemCallResult **a_CallResult
	) ;
    
    HRESULT STDMETHODCALLTYPE PutInstanceAsync (

		IWbemClassObject *a_Instance ,
		long a_Flags ,
		IWbemContext *a_Context ,
		IWbemObjectSink *a_Sink 
	) ;
    
    HRESULT STDMETHODCALLTYPE DeleteInstance ( 

		const BSTR a_ObjectPath ,
		long a_Flags ,
		IWbemContext *a_Context ,
		IWbemCallResult **a_CallResult
	) ;
    
    HRESULT STDMETHODCALLTYPE DeleteInstanceAsync ( 

		const BSTR a_ObjectPath,
		long a_Flags,
		IWbemContext *a_Context ,
		IWbemObjectSink *a_Sink
	) ;
    
    HRESULT STDMETHODCALLTYPE CreateInstanceEnum (

		const BSTR a_Class ,
		long a_Flags ,
		IWbemContext *a_Context ,
		IEnumWbemClassObject **a_Enum
	) ;
    
    HRESULT STDMETHODCALLTYPE CreateInstanceEnumAsync (

		const BSTR a_Class ,
		long a_Flags ,
		IWbemContext *a_Context ,
		IWbemObjectSink *a_Sink
	) ;
    
    HRESULT STDMETHODCALLTYPE ExecQuery ( 

		const BSTR a_QueryLanguage,
		const BSTR a_Query,
		long a_Flags ,
		IWbemContext *a_Context ,
		IEnumWbemClassObject **a_Enum
	) ;
    
    HRESULT STDMETHODCALLTYPE ExecQueryAsync (

		const BSTR a_QueryLanguage ,
		const BSTR a_Query ,
		long a_Flags ,
		IWbemContext *a_Context ,
		IWbemObjectSink *a_Sink
	) ;
    
    HRESULT STDMETHODCALLTYPE ExecNotificationQuery (

		const BSTR a_QueryLanguage ,
		const BSTR a_Query ,
		long a_Flags ,
		IWbemContext *a_Context ,
		IEnumWbemClassObject **a_Enum
	) ;
    
    HRESULT STDMETHODCALLTYPE ExecNotificationQueryAsync ( 

        const BSTR a_QueryLanguage ,
        const BSTR a_Query ,
        long a_Flags ,
        IWbemContext *a_Context ,
        IWbemObjectSink *a_Sink
	) ;
    
    HRESULT STDMETHODCALLTYPE ExecMethod (

        const BSTR a_ObjectPath ,
        const BSTR a_MethodName ,
        long a_Flags ,
        IWbemContext *a_Context ,
        IWbemClassObject *a_InParams ,
        IWbemClassObject **a_OutParams ,
        IWbemCallResult **a_CallResult
	) ;
    
    HRESULT STDMETHODCALLTYPE ExecMethodAsync ( 

		const BSTR a_ObjectPath ,
		const BSTR a_MethodName ,
		long a_Flags ,
		IWbemContext *a_Context ,
		IWbemClassObject *a_InParams ,
		IWbemObjectSink *a_Sink
	) ;

	/* IWbemProviderInit methods */

	HRESULT STDMETHODCALLTYPE Initialize (

		LPWSTR a_User ,
		LONG a_Flags ,
		LPWSTR a_Namespace ,
		LPWSTR a_Locale ,
		IWbemServices *a_Core ,
		IWbemContext *a_Context ,
		IWbemProviderInitSink *a_Sink
	) ;

	HRESULT STDMETHODCALLTYPE Shutdown (

		LONG a_Flags ,
		ULONG a_MaxMilliSeconds ,
		IWbemContext *a_Context
	) ; 
} ;


#endif // _Server_ProviderSelfInstrumentation_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\winmgmt\provsubsys\server\include\provwsv.h ===
/*++

Copyright (C) 1996-2001 Microsoft Corporation

Module Name:

	ProvWsv.H

Abstract:


History:

--*/

#ifndef _Server_Interceptor_IWbemServices_H
#define _Server_Interceptor_IWbemServices_H

#include <CGlobals.h>
#include "ProvCache.h"
#include "ProvRegInfo.h"

#define ProxyIndex_IWbemServices					0
#define ProxyIndex_IWbemPropertyProvider			1
#define ProxyIndex_IWbemHiPerfProvider				2
#define ProxyIndex_IWbemEventProvider				3
#define ProxyIndex_IWbemEventProviderQuerySink		4
#define ProxyIndex_IWbemEventProviderSecurity		5
#define ProxyIndex_IWbemProviderIdentity			6
#define ProxyIndex_IWbemEventConsumerProvider		7
#define ProxyIndex_IWbemEventConsumerProviderEx		8
#define ProxyIndex_IWbemUnboundObjectSink			9
#define ProxyIndex_IWbemProviderInit				10

#define ProxyIndex_Internal_IWbemServices					11
#define ProxyIndex_Internal_IWbemPropertyProvider			12
#define ProxyIndex_Internal_IWbemEventProvider				13
#define ProxyIndex_Internal_IWbemEventProviderQuerySink		14
#define ProxyIndex_Internal_IWbemEventProviderSecurity		15
#define ProxyIndex_Internal_IWbemEventConsumerProvider		16
#define ProxyIndex_Internal_IWbemEventConsumerProviderEx	17
#define ProxyIndex_Internal_IWbemUnboundObjectSink			18
#define ProxyIndex_Internal_IWbemProviderIdentity			19
#define ProxyIndex_Internal_IWbemProviderInit				20

#define ProxyIndex_IWbemShutdown					21
#define ProxyIndex__IWmiProviderConfiguration		22

#define ProxyIndex_Internal_IWmiProviderConfiguration		23

#define ProxyIndex_Provider_Size					23

#define ProxyIndex_UnBound_IWbemUnboundObjectSink				0
#define ProxyIndex_UnBound_Internal_IWbemUnboundObjectSink		1
#define ProxyIndex_UnBound_Size									2

#define ProxyIndex_UnBoundSync_IWbemUnboundObjectSink			0
#define ProxyIndex_UnBoundSync_Size								1

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

class CInterceptor_IWbemUnboundObjectSink :		public IWbemUnboundObjectSink ,
												public IWbemShutdown , 
												public VoidPointerContainerElement
{
private:

	WmiAllocator &m_Allocator ;
	CServerObject_ProviderRegistrationV1 *m_Registration ;

	_IWmiProviderAbnormalShutdown *m_Controller ;

	IUnknown *m_Unknown ;
	IWbemUnboundObjectSink *m_Provider_IWbemUnboundObjectSink ;
	Internal_IWbemUnboundObjectSink *m_Provider_Internal_IWbemUnboundObjectSink ;

	ProxyContainer m_ProxyContainer ;

	DWORD m_ProcessIdentifier ;

	HRESULT m_InitializeResult ;

protected:

	HRESULT Begin_Interface (

		IUnknown *a_ServerInterface ,
		REFIID a_InterfaceIdentifier ,
		DWORD a_ProxyIndex ,
		IUnknown *a_InternalServerInterface ,
		REFIID a_InternalInterfaceIdentifier ,
		DWORD a_InternalProxyIndex ,
		DWORD a_ProcessIdentifier ,
		HANDLE &a_IdentifyToken ,
		BOOL &a_Impersonating ,
		IUnknown *&a_OldContext ,
		IServerSecurity *&a_OldSecurity ,
		BOOL &a_IsProxy ,
		IUnknown *&a_Interface ,
		BOOL &a_Revert ,
		IUnknown *&a_Proxy ,
		IWbemContext *a_Context = NULL
	) ;

	HRESULT End_Interface (

		IUnknown *a_ServerInterface ,
		REFIID a_InterfaceIdentifier ,
		DWORD a_ProxyIndex ,
		IUnknown *a_InternalServerInterface ,
		REFIID a_InternalInterfaceIdentifier ,
		DWORD a_InternalProxyIndex ,
		DWORD a_ProcessIdentifier ,
		HANDLE a_IdentifyToken ,
		BOOL a_Impersonating ,
		IUnknown *a_OldContext ,
		IServerSecurity *a_OldSecurity ,
		BOOL a_IsProxy ,
		IUnknown *a_Interface ,
		BOOL a_Revert ,
		IUnknown *a_Proxy
	) ;

public:

	CInterceptor_IWbemUnboundObjectSink (

		WmiAllocator &a_Allocator ,
		IUnknown *a_ServerSideProvider , 
		CWbemGlobal_IWmiObjectSinkController *a_Controller , 
		CServerObject_ProviderRegistrationV1 &a_Registration
	) ;

	~CInterceptor_IWbemUnboundObjectSink () ;

	HRESULT Initialize () ;

public:

	STDMETHODIMP QueryInterface ( 

		REFIID iid , 
		LPVOID FAR *iplpv 
	) ;

	STDMETHODIMP_( ULONG ) AddRef () ;

	STDMETHODIMP_( ULONG ) Release () ;

	HRESULT STDMETHODCALLTYPE IndicateToConsumer (

		IWbemClassObject *a_LogicalConsumer ,
		long a_ObjectCount ,
		IWbemClassObject **a_Objects
	) ;

	HRESULT STDMETHODCALLTYPE Shutdown (

		LONG a_Flags ,
		ULONG a_MaxMilliSeconds ,
		IWbemContext *a_Context
	) ; 
} ;

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

class CDecoupled_IWbemUnboundObjectSink :		public IWbemUnboundObjectSink ,
												public IWbemShutdown , 
												public VoidPointerContainerElement
{
private:

	WmiAllocator &m_Allocator ;
	CServerObject_ProviderRegistrationV1 *m_Registration ;

	_IWmiProviderAbnormalShutdown *m_Controller ;

	IUnknown *m_Unknown ;
	IWbemUnboundObjectSink *m_Provider_IWbemUnboundObjectSink ;
	Internal_IWbemUnboundObjectSink *m_Provider_Internal_IWbemUnboundObjectSink ;

	ProxyContainer m_ProxyContainer ;

	DWORD m_ProcessIdentifier ;

	HRESULT m_InitializeResult ;

protected:

	HRESULT Begin_Interface (

		IUnknown *a_ServerInterface ,
		REFIID a_InterfaceIdentifier ,
		DWORD a_ProxyIndex ,
		IUnknown *a_InternalServerInterface ,
		REFIID a_InternalInterfaceIdentifier ,
		DWORD a_InternalProxyIndex ,
		DWORD a_ProcessIdentifier ,
		HANDLE &a_IdentifyToken ,
		BOOL &a_Impersonating ,
		IUnknown *&a_OldContext ,
		IServerSecurity *&a_OldSecurity ,
		BOOL &a_IsProxy ,
		IUnknown *&a_Interface ,
		BOOL &a_Revert ,
		IUnknown *&a_Proxy ,
		IWbemContext *a_Context = NULL
	) ;

	HRESULT End_Interface (

		IUnknown *a_ServerInterface ,
		REFIID a_InterfaceIdentifier ,
		DWORD a_ProxyIndex ,
		IUnknown *a_InternalServerInterface ,
		REFIID a_InternalInterfaceIdentifier ,
		DWORD a_InternalProxyIndex ,
		DWORD a_ProcessIdentifier ,
		HANDLE a_IdentifyToken ,
		BOOL a_Impersonating ,
		IUnknown *a_OldContext ,
		IServerSecurity *a_OldSecurity ,
		BOOL a_IsProxy ,
		IUnknown *a_Interface ,
		BOOL a_Revert ,
		IUnknown *a_Proxy
	) ;

public:

	CDecoupled_IWbemUnboundObjectSink (

		WmiAllocator &a_Allocator ,
		IUnknown *a_ServerSideProvider , 
		CWbemGlobal_IWmiObjectSinkController *a_Controller , 
		CServerObject_ProviderRegistrationV1 &a_Registration
	) ;

	~CDecoupled_IWbemUnboundObjectSink () ;

	HRESULT Initialize () ;

public:

	STDMETHODIMP QueryInterface ( 

		REFIID iid , 
		LPVOID FAR *iplpv 
	) ;

	STDMETHODIMP_( ULONG ) AddRef () ;

	STDMETHODIMP_( ULONG ) Release () ;

	HRESULT STDMETHODCALLTYPE IndicateToConsumer (

		IWbemClassObject *a_LogicalConsumer ,
		long a_ObjectCount ,
		IWbemClassObject **a_Objects
	) ;

	HRESULT STDMETHODCALLTYPE Shutdown (

		LONG a_Flags ,
		ULONG a_MaxMilliSeconds ,
		IWbemContext *a_Context
	) ; 
} ;

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

class CInterceptor_IWbemProvider ;

class InternalQuotaInterface : public _IWmiProviderQuota
{
private:

	LONG m_ReferenceCount ;
	_IWmiProviderQuota *m_Owner ;

public:

	InternalQuotaInterface ( CInterceptor_IWbemProvider *a_Owner ) ;

	~InternalQuotaInterface () ;

	HRESULT Initialize () ;

	STDMETHODIMP QueryInterface ( 

		REFIID iid , 
		LPVOID FAR *iplpv 
	) ;

	STDMETHODIMP_( ULONG ) AddRef () ;

	STDMETHODIMP_( ULONG ) Release () ;

	HRESULT STDMETHODCALLTYPE Violation (

		long a_Flags ,
		IWbemContext *a_Context ,
		IWbemClassObject *a_Object	
	) ;
} ;

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

class CInterceptor_IWbemProvider :		public IWbemServices , 
										public IWbemPropertyProvider ,
										public IWbemEventProvider ,
										public IWbemEventProviderQuerySink ,
										public IWbemEventProviderSecurity ,
										public IWbemEventConsumerProviderEx ,
										public IWbemUnboundObjectSink ,
										public IWbemHiPerfProvider ,
										public IWbemProviderInit , 
										public _IWmiProviderInitialize ,
										public _IWmiProviderLoad , 
										public IWbemShutdown , 
										public _IWmiProviderQuota ,
										public _IWmiProviderConfiguration ,
										public _IWmiProviderStack ,
										public _IWmiProviderCache ,
										public _IWmiProviderAbnormalShutdown ,
										public ServiceCacheElement , 
										public CWbemGlobal_IWmiObjectSinkController 
{
private:

	WmiAllocator &m_Allocator ;
	CServerObject_ProviderRegistrationV1 *m_Registration ;

	_IWmiProviderHost *m_Host ;

	InternalQuotaInterface *m_Quota ;

	IUnknown *m_Unknown ;
	IWbemServices *m_Provider_IWbemServices ;
	IWbemPropertyProvider *m_Provider_IWbemPropertyProvider ;
	IWbemHiPerfProvider *m_Provider_IWbemHiPerfProvider ;
	IWbemEventProvider *m_Provider_IWbemEventProvider ;
	IWbemEventProviderQuerySink *m_Provider_IWbemEventProviderQuerySink ;
	IWbemEventProviderSecurity *m_Provider_IWbemEventProviderSecurity ;
	IWbemEventConsumerProvider *m_Provider_IWbemEventConsumerProvider ;
	IWbemEventConsumerProviderEx *m_Provider_IWbemEventConsumerProviderEx ;
	IWbemUnboundObjectSink *m_Provider_IWbemUnboundObjectSink ;
	_IWmiProviderConfiguration *m_Provider__IWmiProviderConfiguration ;

	Internal_IWbemServices *m_Provider_Internal_IWbemServices ;
	Internal_IWbemPropertyProvider *m_Provider_Internal_IWbemPropertyProvider ;
	Internal_IWbemEventProvider *m_Provider_Internal_IWbemEventProvider ;
	Internal_IWbemEventProviderQuerySink *m_Provider_Internal_IWbemEventProviderQuerySink ;
	Internal_IWbemEventProviderSecurity *m_Provider_Internal_IWbemEventProviderSecurity ;
	Internal_IWbemEventConsumerProvider *m_Provider_Internal_IWbemEventConsumerProvider ;
	Internal_IWbemEventConsumerProviderEx *m_Provider_Internal_IWbemEventConsumerProviderEx ;
	Internal_IWbemUnboundObjectSink *m_Provider_Internal_IWbemUnboundObjectSink ;
	Internal_IWmiProviderConfiguration *m_Provider_Internal_IWmiProviderConfiguration ;

	ProxyContainer m_ProxyContainer ;

	DWORD m_ProcessIdentifier ;

	BSTR m_Locale ;
	BSTR m_User ;
	BSTR m_Namespace ;

	LONG m_Initialized ;
	LONG m_UnInitialized ;
	HRESULT m_InitializeResult ;
	HANDLE m_InitializedEvent ;
	IWbemContext *m_InitializationContext ;

	LONG m_Resumed ;

	class InternalInterface : public _IWmiProviderQuota
	{
	private:

		CInterceptor_IWbemProvider *m_This ;

	public:

		InternalInterface ( CInterceptor_IWbemProvider *a_This ) : m_This ( a_This ) 
		{
		}

		STDMETHODIMP QueryInterface ( 

			REFIID iid , 
			LPVOID FAR *iplpv 
		)
		{
			return m_This->QueryInterface (

				iid , 
				iplpv 
			) ; 
		}

		STDMETHODIMP_( ULONG ) AddRef ()
		{
			return m_This->ServiceCacheElement :: NonCyclicAddRef () ; 
		}

		STDMETHODIMP_( ULONG ) Release ()
		{
			return m_This->ServiceCacheElement :: NonCyclicRelease () ;
		}

		HRESULT STDMETHODCALLTYPE Violation (

			long a_Flags ,
			IWbemContext *a_Context ,
			IWbemClassObject *a_Object	
		)
		{
			return m_This->Violation (

				a_Flags ,
				a_Context ,
				a_Object	
			) ;
		}
	} ;

	InternalInterface m_Internal ;

	void CallBackInternalRelease () ;

	HRESULT Begin_Interface_Context (

		IUnknown *a_ServerInterface ,
		REFIID a_InterfaceIdentifier ,
		DWORD a_ProxyIndex ,
		IUnknown *a_InternalServerInterface ,
		REFIID a_InternalInterfaceIdentifier ,
		DWORD a_InternalProxyIndex ,
		DWORD a_ProcessIdentifier ,
		HANDLE &a_IdentifyToken ,
		BOOL &a_Impersonating ,
		IUnknown *&a_OldContext ,
		IServerSecurity *&a_OldSecurity ,
		BOOL &a_IsProxy ,
		IUnknown *&a_Interface ,
		BOOL &a_Revert ,
		IUnknown *&a_Proxy ,
		IWbemContext *a_Context = NULL
	) ;

	HRESULT End_Interface_Context (

		IUnknown *a_ServerInterface ,
		REFIID a_InterfaceIdentifier ,
		DWORD a_ProxyIndex ,
		IUnknown *a_InternalServerInterface ,
		REFIID a_InternalInterfaceIdentifier ,
		DWORD a_InternalProxyIndex ,
		DWORD a_ProcessIdentifier ,
		HANDLE a_IdentifyToken ,
		BOOL a_Impersonating ,
		IUnknown *a_OldContext ,
		IServerSecurity *a_OldSecurity ,
		BOOL a_IsProxy ,
		IUnknown *a_Interface ,
		BOOL a_Revert ,
		IUnknown *a_Proxy
	) ;

	HRESULT Begin_Interface (

		IUnknown *a_ServerInterface ,
		REFIID a_InterfaceIdentifier ,
		DWORD a_ProxyIndex ,
		IUnknown *a_InternalServerInterface ,
		REFIID a_InternalInterfaceIdentifier ,
		DWORD a_InternalProxyIndex ,
		DWORD a_ProcessIdentifier ,
		HANDLE &a_IdentifyToken ,
		BOOL &a_Impersonating ,
		IUnknown *&a_OldContext ,
		IServerSecurity *&a_OldSecurity ,
		BOOL &a_IsProxy ,
		IUnknown *&a_Interface ,
		BOOL &a_Revert ,
		IUnknown *&a_Proxy ,
		IWbemContext *a_Context = NULL
	) ;

	HRESULT End_Interface (

		IUnknown *a_ServerInterface ,
		REFIID a_InterfaceIdentifier ,
		DWORD a_ProxyIndex ,
		IUnknown *a_InternalServerInterface ,
		REFIID a_InternalInterfaceIdentifier ,
		DWORD a_InternalProxyIndex ,
		DWORD a_ProcessIdentifier ,
		HANDLE a_IdentifyToken ,
		BOOL a_Impersonating ,
		IUnknown *a_OldContext ,
		IServerSecurity *a_OldSecurity ,
		BOOL a_IsProxy ,
		IUnknown *a_Interface ,
		BOOL a_Revert ,
		IUnknown *a_Proxy
	) ;

public:

	CInterceptor_IWbemProvider ( 

		WmiAllocator &a_Allocator ,
		CWbemGlobal_IWmiProviderController *a_Controller , 
		const ProviderCacheKey &a_Key ,
		const ULONG &a_Period ,
		IWbemContext *a_InitializationContext ,
		CServerObject_ProviderRegistrationV1 &a_Registration
	) ;

    ~CInterceptor_IWbemProvider () ;

	InternalQuotaInterface *GetQuota ()
	{
		return m_Quota ;
	}

	void SetResumed ( LONG a_Resumed )
	{
		if ( a_Resumed )
		{
			InterlockedExchange ( & m_Resumed , 1 ) ;
		}
		else
		{
			InterlockedExchange ( & m_Resumed , 0 ) ;
		}
	}

	LONG GetResumed ()
	{
		return m_Resumed ;
	}

	HRESULT SetProvider ( _IWmiProviderHost *a_Host , IUnknown *a_Unknown ) ;

	HRESULT SetInitialized ( HRESULT a_InitializeResult ) ;

	HRESULT IsIndependant ( IWbemContext *a_Context ) ;

public:

	//Non-delegating object IUnknown

    STDMETHODIMP QueryInterface ( REFIID , LPVOID FAR * ) ;
    STDMETHODIMP_( ULONG ) AddRef () ;
    STDMETHODIMP_( ULONG ) Release () ;

    /* IWbemServices methods */

    HRESULT STDMETHODCALLTYPE OpenNamespace ( 

        const BSTR a_Namespace ,
        long a_Flags ,
        IWbemContext *a_Context ,
        IWbemServices **a_Service ,
        IWbemCallResult **a_CallResult
	) ;
    
    HRESULT STDMETHODCALLTYPE CancelAsyncCall ( 

        IWbemObjectSink *a_Sink
	) ;
    
    HRESULT STDMETHODCALLTYPE QueryObjectSink ( 

        long a_Flags ,
        IWbemObjectSink **a_Sink
	) ;
    
    HRESULT STDMETHODCALLTYPE GetObject ( 

		const BSTR a_ObjectPath ,
        long a_Flags ,
        IWbemContext *a_Context ,
        IWbemClassObject **a_Object ,
        IWbemCallResult **a_CallResult
	) ;
    
    HRESULT STDMETHODCALLTYPE GetObjectAsync (
        
		const BSTR a_ObjectPath ,
        long a_Flags ,
        IWbemContext *a_Context ,
        IWbemObjectSink *a_Sink
	) ;

    HRESULT STDMETHODCALLTYPE PutClass ( 

        IWbemClassObject *a_Object ,
        long a_Flags ,
        IWbemContext *a_Context ,
        IWbemCallResult **a_CallResult
	) ;
    
    HRESULT STDMETHODCALLTYPE PutClassAsync ( 

        IWbemClassObject *a_Object ,
        long a_Flags ,
        IWbemContext *a_Context ,
        IWbemObjectSink *a_Sink
	) ;
    
    HRESULT STDMETHODCALLTYPE DeleteClass ( 

        const BSTR a_Class ,
        long a_Flags ,
        IWbemContext *a_Context ,
        IWbemCallResult **a_CallResult
	) ;
    
    HRESULT STDMETHODCALLTYPE DeleteClassAsync ( 

        const BSTR a_Class ,
        long a_Flags ,
        IWbemContext *a_Context ,
        IWbemObjectSink *a_Sink
	) ;
    
    HRESULT STDMETHODCALLTYPE CreateClassEnum ( 

        const BSTR a_Superclass ,
        long a_Flags ,
        IWbemContext *a_Context ,
        IEnumWbemClassObject **a_Enum
	) ;
    
    HRESULT STDMETHODCALLTYPE CreateClassEnumAsync ( 

		const BSTR a_Superclass ,
		long a_Flags ,
		IWbemContext *a_Context ,
		IWbemObjectSink *a_Sink
	) ;
    
    HRESULT STDMETHODCALLTYPE PutInstance (

		IWbemClassObject *a_Instance ,
		long a_Flags , 
		IWbemContext *a_Context ,
		IWbemCallResult **a_CallResult
	) ;
    
    HRESULT STDMETHODCALLTYPE PutInstanceAsync (

		IWbemClassObject *a_Instance ,
		long a_Flags ,
		IWbemContext *a_Context ,
		IWbemObjectSink *a_Sink 
	) ;
    
    HRESULT STDMETHODCALLTYPE DeleteInstance ( 

		const BSTR a_ObjectPath ,
		long a_Flags ,
		IWbemContext *a_Context ,
		IWbemCallResult **a_CallResult
	) ;
    
    HRESULT STDMETHODCALLTYPE DeleteInstanceAsync ( 

		const BSTR a_ObjectPath,
		long a_Flags,
		IWbemContext *a_Context ,
		IWbemObjectSink *a_Sink
	) ;
    
    HRESULT STDMETHODCALLTYPE CreateInstanceEnum (

		const BSTR a_Class ,
		long a_Flags ,
		IWbemContext *a_Context ,
		IEnumWbemClassObject **a_Enum
	) ;
    
    HRESULT STDMETHODCALLTYPE CreateInstanceEnumAsync (

		const BSTR a_Class ,
		long a_Flags ,
		IWbemContext *a_Context ,
		IWbemObjectSink *a_Sink
	) ;
    
    HRESULT STDMETHODCALLTYPE ExecQuery ( 

		const BSTR a_QueryLanguage,
		const BSTR a_Query,
		long a_Flags ,
		IWbemContext *a_Context ,
		IEnumWbemClassObject **a_Enum
	) ;
    
    HRESULT STDMETHODCALLTYPE ExecQueryAsync (

		const BSTR a_QueryLanguage ,
		const BSTR a_Query ,
		long a_Flags ,
		IWbemContext *a_Context ,
		IWbemObjectSink *a_Sink
	) ;
    
    HRESULT STDMETHODCALLTYPE ExecNotificationQuery (

		const BSTR a_QueryLanguage ,
		const BSTR a_Query ,
		long a_Flags ,
		IWbemContext *a_Context ,
		IEnumWbemClassObject **a_Enum
	) ;
    
    HRESULT STDMETHODCALLTYPE ExecNotificationQueryAsync ( 

        const BSTR a_QueryLanguage ,
        const BSTR a_Query ,
        long a_Flags ,
        IWbemContext *a_Context ,
        IWbemObjectSink *a_Sink
	) ;
    
    HRESULT STDMETHODCALLTYPE ExecMethod (

        const BSTR a_ObjectPath ,
        const BSTR a_MethodName ,
        long a_Flags ,
        IWbemContext *a_Context ,
        IWbemClassObject *a_InParams ,
        IWbemClassObject **a_OutParams ,
        IWbemCallResult **a_CallResult
	) ;
    
    HRESULT STDMETHODCALLTYPE ExecMethodAsync ( 

		const BSTR a_ObjectPath ,
		const BSTR a_MethodName ,
		long a_Flags ,
		IWbemContext *a_Context ,
		IWbemClassObject *a_InParams ,
		IWbemObjectSink *a_Sink
	) ;

	/* IWbemPropertyProvider */

    HRESULT STDMETHODCALLTYPE GetProperty (

        long a_Flags ,
        const BSTR a_Locale ,
        const BSTR a_ClassMapping ,
        const BSTR a_InstanceMapping ,
        const BSTR a_PropertyMapping ,
        VARIANT *a_Value
	) ;
        
    HRESULT STDMETHODCALLTYPE PutProperty (

        long a_Flags ,
        const BSTR a_Locale ,
        const BSTR a_ClassMapping ,
        const BSTR a_InstanceMapping ,
        const BSTR a_PropertyMapping ,
        const VARIANT *a_Value
	) ;

	/* IWbemEventProvider */

	HRESULT STDMETHODCALLTYPE ProvideEvents (

		IWbemObjectSink *a_Sink ,
		long a_Flags
	) ;

	/* IWbemEventProviderQuerySink */

	HRESULT STDMETHODCALLTYPE NewQuery (

		unsigned long a_Id ,
		WBEM_WSTR a_QueryLanguage ,
		WBEM_WSTR a_Query
	);

	HRESULT STDMETHODCALLTYPE CancelQuery (

		unsigned long a_Id
	) ;

	/* IWbemEventProviderSecurity */

	HRESULT STDMETHODCALLTYPE AccessCheck (

		WBEM_CWSTR a_QueryLanguage ,
		WBEM_CWSTR a_Query ,
		long a_SidLength ,
		const BYTE *a_Sid
	) ;

	/* IWbemEventConsumerProvider */

	HRESULT STDMETHODCALLTYPE FindConsumer (

		IWbemClassObject *a_LogicalConsumer ,
		IWbemUnboundObjectSink **a_Consumer
	);

	/* IWbemEventConsumerProviderEx */

	HRESULT STDMETHODCALLTYPE ValidateSubscription (

		IWbemClassObject *a_LogicalConsumer
	) ;

	/* IWbemUnboundObjectSink */

	HRESULT STDMETHODCALLTYPE IndicateToConsumer (

		IWbemClassObject *a_LogicalConsumer ,
		long a_ObjectCount ,
		IWbemClassObject **a_Objects
	) ;

	/* IWbemHiPerfProvider */

	HRESULT STDMETHODCALLTYPE QueryInstances (

		IWbemServices *a_Namespace ,
		WCHAR *a_Class ,
		long a_Flags ,
		IWbemContext *a_Context ,
		IWbemObjectSink *a_Sink
	) ;

	HRESULT STDMETHODCALLTYPE CreateRefresher (

		IWbemServices *a_Namespace ,
		long a_Flags ,
		IWbemRefresher **a_Refresher
	) ; 

	HRESULT STDMETHODCALLTYPE CreateRefreshableObject (

		IWbemServices *a_Namespace ,
		IWbemObjectAccess *a_Template ,
		IWbemRefresher *a_Refresher ,
		long a_Flags ,
		IWbemContext *a_Context ,
		IWbemObjectAccess **a_Refreshable ,
		long *a_Id
	) ;

	HRESULT STDMETHODCALLTYPE StopRefreshing (

		IWbemRefresher *a_Refresher ,
		long a_Id ,
		long a_Flags
	) ;

	HRESULT STDMETHODCALLTYPE CreateRefreshableEnum (

		IWbemServices *a_Namespace ,
		LPCWSTR a_Class ,
		IWbemRefresher *a_Refresher ,
		long a_Flags ,
		IWbemContext *a_Context ,
		IWbemHiPerfEnum *a_HiPerfEnum ,
		long *a_Id
	) ;

	HRESULT STDMETHODCALLTYPE GetObjects (

		IWbemServices *a_Namespace ,
		long a_ObjectCount ,
		IWbemObjectAccess **a_Objects ,
		long a_Flags ,
		IWbemContext *a_Context
	) ;

	HRESULT STDMETHODCALLTYPE Call (

		IWbemServices *a_Service ,
		long a_Flags ,
		IWbemContext *a_Context ,
		LPCWSTR a_Class ,
		LPCWSTR a_Path ,		
		const BSTR a_Method,
		IWbemClassObject *a_InParams,
		IWbemObjectSink *a_Sink
	) ;

	/* _IWmiProviderConfiguration methods */

	HRESULT STDMETHODCALLTYPE Get (

		IWbemServices *a_Service ,
		long a_Flags ,
		IWbemContext *a_Context ,
		LPCWSTR a_Class ,
		LPCWSTR a_Path ,
		IWbemObjectSink *a_Sink
	) ;

	HRESULT STDMETHODCALLTYPE Set (

		IWbemServices *a_Service ,
		long a_Flags ,
		IWbemContext *a_Context ,
		LPCWSTR a_Provider ,
		LPCWSTR a_Class ,
		LPCWSTR a_Path ,
		IWbemClassObject *a_OldObject ,
		IWbemClassObject *a_NewObject  
	) ;

	HRESULT STDMETHODCALLTYPE Deleted (

		IWbemServices *a_Service ,
		long a_Flags ,
		IWbemContext *a_Context ,
		LPCWSTR a_Provider ,
		LPCWSTR a_Class ,
		LPCWSTR a_Path ,
		IWbemClassObject *a_Object  
	) ;

	HRESULT STDMETHODCALLTYPE Enumerate (

		IWbemServices *a_Service ,
		long a_Flags ,
		IWbemContext *a_Context ,
		LPCWSTR a_Class ,
		IWbemObjectSink *a_Sink
	) ;

	HRESULT STDMETHODCALLTYPE Shutdown (

		IWbemServices *a_Service ,
		long a_Flags ,
		IWbemContext *a_Context ,
		LPCWSTR a_Provider ,
		ULONG a_MilliSeconds
	) ;

	HRESULT STDMETHODCALLTYPE Call (

		IWbemServices *a_Service ,
		long a_Flags ,
		IWbemContext *a_Context ,
		LPCWSTR a_Class ,
		LPCWSTR a_Path ,		
		LPCWSTR a_Method,
		IWbemClassObject *a_InParams,
		IWbemObjectSink *a_Sink
	) ;

	HRESULT STDMETHODCALLTYPE Query (

		IWbemServices *a_Service ,
		long a_Flags ,
		IWbemContext *a_Context ,
		WBEM_PROVIDER_CONFIGURATION_CLASS_ID a_ClassIdentifier ,
		WBEM_PROVIDER_CONFIGURATION_PROPERTY_ID a_PropertyIdentifier ,
		VARIANT *a_Value 
	) ;

	HRESULT STDMETHODCALLTYPE Unload (

		long a_Flags ,
		IWbemContext *a_Context
	) ;

	HRESULT STDMETHODCALLTYPE Load (

		long a_Flags ,
		IWbemContext *a_Context
	) ;

	HRESULT STDMETHODCALLTYPE ForceReload () ;

	/* _IWmiProviderQuota */

	HRESULT STDMETHODCALLTYPE Violation (

		long a_Flags ,
		IWbemContext *a_Context ,
		IWbemClassObject *a_Object	
	) ;

	/* _IWmiProviderCache */

	HRESULT STDMETHODCALLTYPE Expel (

		long a_Flags ,
		IWbemContext *a_Context
	) ;

	/* IWbemProviderInit methods */

	HRESULT STDMETHODCALLTYPE Initialize (

		LPWSTR a_User ,
		LONG a_Flags ,
		LPWSTR a_Namespace ,
		LPWSTR a_Locale ,
		IWbemServices *a_Core ,
		IWbemContext *a_Context ,
		IWbemProviderInitSink *a_Sink
	) ;

	HRESULT STDMETHODCALLTYPE Initialize (

		LONG a_Flags ,
		IWbemContext *a_Context ,
		GUID *a_TransactionIdentifier,
		LPCWSTR a_User ,
		LPCWSTR a_Locale ,
		LPCWSTR a_Namespace ,
		IWbemServices *a_Repository ,
		IWbemServices *a_Service ,
		IWbemProviderInitSink *a_Sink
	)
	{
		return WBEM_E_NOT_AVAILABLE ;
	}

	HRESULT STDMETHODCALLTYPE WaitProvider ( IWbemContext *a_Context , ULONG a_Timeout ) ;

	HRESULT STDMETHODCALLTYPE GetInitializeResult () ;

	HRESULT STDMETHODCALLTYPE GetHosting ( ULONG *a_Value )
	{
		if ( a_Value )
		{
			*a_Value = m_Registration->GetHosting () ;
			return S_OK ;
		}
		else
		{
			return WBEM_E_INVALID_PARAMETER ;
		}
	}

	HRESULT STDMETHODCALLTYPE GetHostingGroup ( BSTR *a_Value )
	{
		if ( a_Value )
		{
			if ( m_Registration->GetHostingGroup () )
			{
				BSTR t_Value = SysAllocString ( m_Registration->GetHostingGroup () ) ;
				*a_Value = t_Value ;
			}
			else
			{
				*a_Value = NULL ;
			}

			return S_OK ;
		}
		else
		{
			return WBEM_E_INVALID_PARAMETER ;
		}
	}

	HRESULT STDMETHODCALLTYPE IsInternal ( BOOL *a_Value )
	{
		if ( a_Value )
		{
			*a_Value = FALSE ;
			return S_OK ;
		}
		else
		{
			return WBEM_E_INVALID_PARAMETER ;
		}
	}

	HRESULT STDMETHODCALLTYPE IsPerUserInitialization ( BOOL *a_Value )
	{
		if ( a_Value )
		{
			*a_Value = m_Registration->PerUserInitialization () ;
			return S_OK ;
		}
		else
		{
			return WBEM_E_INVALID_PARAMETER ;
		}
	}

	HRESULT STDMETHODCALLTYPE IsPerLocaleInitialization ( BOOL *a_Value )
	{
		if ( a_Value )
		{
			*a_Value = m_Registration->PerLocaleInitialization () ;
			return S_OK ;
		}
		else
		{
			return WBEM_E_INVALID_PARAMETER ;
		}
	}

	// _IWmiProviderStack 

	HRESULT STDMETHODCALLTYPE DownLevel (

		long a_Flags ,
		IWbemContext *a_Context ,
		REFIID a_Riid,
		void **a_Interface
	) ;

	HRESULT STDMETHODCALLTYPE AbnormalShutdown () ;

	// IWmi_UnInitialize members

	HRESULT STDMETHODCALLTYPE Shutdown (

		LONG a_Flags ,
		ULONG a_MaxMilliSeconds ,
		IWbemContext *a_Context
	) ; 
} ;

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

class CInterceptor_IWbemSyncUnboundObjectSink : public IWbemUnboundObjectSink ,
												public Internal_IWbemUnboundObjectSink ,
												public _IWmiProviderSite ,
												public IWbemShutdown , 
												public VoidPointerContainerElement
{
private:

	WmiAllocator &m_Allocator ;
	CServerObject_ProviderRegistrationV1 *m_Registration ;

	IUnknown *m_Unknown ;
	IWbemUnboundObjectSink *m_Provider_IWbemUnboundObjectSink ;

	ProxyContainer m_ProxyContainer ;

protected:

	HRESULT Begin_Interface_Consumer (

		bool a_Identify ,
		IUnknown *a_ServerInterface ,
		REFIID a_InterfaceIdentifier ,
		DWORD a_ProxyIndex ,
		BOOL &a_Impersonating ,
		IUnknown *&a_OldContext ,
		IServerSecurity *&a_OldSecurity ,
		BOOL &a_IsProxy ,
		IUnknown *&a_Interface ,
		BOOL &a_Revert ,
		IUnknown *&a_Proxy
	) ;

	HRESULT End_Interface_Consumer (

		IUnknown *a_ServerInterface ,
		REFIID a_InterfaceIdentifier ,
		DWORD a_ProxyIndex ,
		BOOL a_Impersonating ,
		IUnknown *a_OldContext ,
		IServerSecurity *a_OldSecurity ,
		BOOL a_IsProxy ,
		IUnknown *a_Interface ,
		BOOL a_Revert ,
		IUnknown *a_Proxy
	) ;

	HRESULT InternalEx_IndicateToConsumer (

		bool a_Identify ,
		IWbemClassObject *a_LogicalConsumer ,
		long a_ObjectCount ,
		IWbemClassObject **a_Objects
	) ;

public:

	CInterceptor_IWbemSyncUnboundObjectSink (

		WmiAllocator &a_Allocator ,
		IUnknown *a_ServerSideProvider , 
		CWbemGlobal_IWmiObjectSinkController *a_Controller ,
		CServerObject_ProviderRegistrationV1 &a_Registration
	) ;

	~CInterceptor_IWbemSyncUnboundObjectSink () ;

	HRESULT Initialize () ;

public:

	STDMETHODIMP QueryInterface ( 

		REFIID iid , 
		LPVOID FAR *iplpv 
	) ;

	STDMETHODIMP_( ULONG ) AddRef () ;

	STDMETHODIMP_( ULONG ) Release () ;

	HRESULT STDMETHODCALLTYPE Internal_IndicateToConsumer (

		WmiInternalContext a_InternalContext ,
		IWbemClassObject *a_LogicalConsumer ,
		long a_ObjectCount ,
		IWbemClassObject **a_Objects
	) ;

	HRESULT STDMETHODCALLTYPE IndicateToConsumer (

		IWbemClassObject *a_LogicalConsumer ,
		long a_ObjectCount ,
		IWbemClassObject **a_Objects
	) ;

	/* _IWmiProviderSite */

	HRESULT STDMETHODCALLTYPE GetSite ( DWORD *a_ProcessIdentifier ) ;

	HRESULT STDMETHODCALLTYPE SetContainer ( IUnknown *a_Container ) ;

	HRESULT STDMETHODCALLTYPE Shutdown (

		LONG a_Flags ,
		ULONG a_MaxMilliSeconds ,
		IWbemContext *a_Context
	) ; 
} ;

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

class CInterceptor_IWbemSyncProvider :	public IWbemServices , 
										public IWbemPropertyProvider ,
										public IWbemEventProvider ,
										public IWbemEventProviderQuerySink ,
										public IWbemEventProviderSecurity ,
										public IWbemProviderIdentity ,
										public IWbemEventConsumerProviderEx ,
										public IWbemUnboundObjectSink ,
										public IWbemHiPerfProvider ,

										public Internal_IWbemServices , 
										public Internal_IWbemPropertyProvider ,
										public Internal_IWbemEventProvider ,
										public Internal_IWbemEventProviderQuerySink ,
										public Internal_IWbemEventProviderSecurity ,
										public Internal_IWbemEventConsumerProviderEx ,
										public Internal_IWbemUnboundObjectSink ,


										public _IWmiProviderInitialize , 
										public IWbemShutdown , 
										public _IWmiProviderQuota ,
										public _IWmiProviderSite ,

										public _IWmiProviderConfiguration ,
										public Internal_IWmiProviderConfiguration ,

										public SyncProviderContainerElement ,
										public CWbemGlobal_IWmiObjectSinkController 
{
private:

	IUnknown *m_Unknown ;
	IWbemServices *m_Provider_IWbemServices ;
	IWbemPropertyProvider *m_Provider_IWbemPropertyProvider ;
	IWbemHiPerfProvider *m_Provider_IWbemHiPerfProvider ;
	IWbemEventProvider *m_Provider_IWbemEventProvider ;
	IWbemEventProviderQuerySink *m_Provider_IWbemEventProviderQuerySink ;
	IWbemEventProviderSecurity *m_Provider_IWbemEventProviderSecurity ;
	IWbemProviderIdentity *m_Provider_IWbemProviderIdentity ;
	IWbemEventConsumerProvider *m_Provider_IWbemEventConsumerProvider ;
	IWbemEventConsumerProviderEx *m_Provider_IWbemEventConsumerProviderEx ;
	IWbemUnboundObjectSink *m_Provider_IWbemUnboundObjectSink ;
	_IWmiProviderQuota *m_Quota ;

	IWbemServices *m_CoreStub ;

	IWbemClassObject *m_ExtendedStatusObject ;

	WmiAllocator &m_Allocator ;

	ProxyContainer m_ProxyContainer ;

	LONG m_Initialized ;
	HRESULT m_InitializeResult ;
	HANDLE m_InitializedEvent ;
	IWbemContext *m_InitializationContext ;

public:

	HRESULT SetInitialized ( HRESULT a_InitializeResult ) ;

public:

	CServerObject_ProviderRegistrationV1 *m_Registration ;
	BSTR m_Locale ;
	BSTR m_User ;
	BSTR m_Namespace ;
	BSTR m_TransactionIdentifier ;

	UINT64 m_ProviderOperation_GetObjectAsync ;
	UINT64 m_ProviderOperation_PutClassAsync ;
	UINT64 m_ProviderOperation_DeleteClassAsync ;
	UINT64 m_ProviderOperation_CreateClassEnumAsync ;
	UINT64 m_ProviderOperation_PutInstanceAsync ;
	UINT64 m_ProviderOperation_DeleteInstanceAsync ;
	UINT64 m_ProviderOperation_CreateInstanceEnumAsync ;
	UINT64 m_ProviderOperation_ExecQueryAsync ;
	UINT64 m_ProviderOperation_ExecNotificationQueryAsync ;
	UINT64 m_ProviderOperation_ExecMethodAsync ;

	UINT64 m_ProviderOperation_Begin ;
	UINT64 m_ProviderOperation_Rollback ;
	UINT64 m_ProviderOperation_Commit ;
	UINT64 m_ProviderOperation_QueryState ;

	UINT64 m_ProviderOperation_QueryInstances ;
	UINT64 m_ProviderOperation_CreateRefresher ;
	UINT64 m_ProviderOperation_CreateRefreshableObject ;
	UINT64 m_ProviderOperation_StopRefreshing ;
	UINT64 m_ProviderOperation_CreateRefreshableEnum ;
	UINT64 m_ProviderOperation_GetObjects ;

	UINT64 m_ProviderOperation_GetProperty ;
	UINT64 m_ProviderOperation_PutProperty ;

	UINT64 m_ProviderOperation_ProvideEvents ;
	UINT64 m_ProviderOperation_NewQuery ;
	UINT64 m_ProviderOperation_CancelQuery ;
	UINT64 m_ProviderOperation_AccessCheck ;
	UINT64 m_ProviderOperation_SetRegistrationObject ;
	UINT64 m_ProviderOperation_FindConsumer ;
	UINT64 m_ProviderOperation_ValidateSubscription ;

	void Increment_ProviderOperation_GetObjectAsync () { m_ProviderOperation_GetObjectAsync ++ ; }
 	void Increment_ProviderOperation_PutClassAsync () { m_ProviderOperation_PutClassAsync ++ ; }
	void Increment_ProviderOperation_DeleteClassAsync () { m_ProviderOperation_DeleteClassAsync ++ ; }
	void Increment_ProviderOperation_CreateClassEnumAsync () { m_ProviderOperation_CreateClassEnumAsync ++ ; }
	void Increment_ProviderOperation_PutInstanceAsync () { m_ProviderOperation_PutInstanceAsync ++ ; }
	void Increment_ProviderOperation_DeleteInstanceAsync () { m_ProviderOperation_DeleteInstanceAsync ++ ; }
	void Increment_ProviderOperation_CreateInstanceEnumAsync () { m_ProviderOperation_CreateInstanceEnumAsync ++ ; }
	void Increment_ProviderOperation_ExecQueryAsync () { m_ProviderOperation_ExecQueryAsync ++ ; }
	void Increment_ProviderOperation_ExecNotificationQueryAsync () { m_ProviderOperation_ExecNotificationQueryAsync ++ ; }
	void Increment_ProviderOperation_ExecMethodAsync () { m_ProviderOperation_ExecMethodAsync ++ ; }

	void Increment_ProviderOperation_Begin () { m_ProviderOperation_Begin ++ ; }
	void Increment_ProviderOperation_Rollback () { m_ProviderOperation_Rollback ++ ; }
	void Increment_ProviderOperation_Commit () { m_ProviderOperation_Commit ++ ; }
	void Increment_ProviderOperation_QueryState () { m_ProviderOperation_QueryState ++ ; }

	void Increment_ProviderOperation_QueryInstances () { m_ProviderOperation_QueryInstances ++ ; }
	void Increment_ProviderOperation_CreateRefresher () { m_ProviderOperation_CreateRefresher ++ ; }
	void Increment_ProviderOperation_CreateRefreshableObject () { m_ProviderOperation_CreateRefreshableObject ++ ; }
	void Increment_ProviderOperation_StopRefreshing () { m_ProviderOperation_StopRefreshing ++ ; }
	void Increment_ProviderOperation_CreateRefreshableEnum () { m_ProviderOperation_CreateRefreshableEnum ++ ; }
	void Increment_ProviderOperation_GetObjects () { m_ProviderOperation_GetObjects ++ ; }

	void Increment_ProviderOperation_GetProperty () { m_ProviderOperation_GetProperty ++ ; }
	void Increment_ProviderOperation_PutProperty () { m_ProviderOperation_PutProperty ++ ; }

	void Increment_ProviderOperation_ProvideEvents () { m_ProviderOperation_ProvideEvents ++ ; }
	void Increment_ProviderOperation_NewQuery () { m_ProviderOperation_NewQuery ++ ; }
	void Increment_ProviderOperation_CancelQuery () { m_ProviderOperation_CancelQuery ++ ; }
	void Increment_ProviderOperation_AccessCheck () { m_ProviderOperation_AccessCheck ++ ; }
	void Increment_ProviderOperation_SetRegistrationObject () { m_ProviderOperation_SetRegistrationObject ++ ; }
	void Increment_ProviderOperation_FindConsumer () { m_ProviderOperation_FindConsumer ++ ; }
	void Increment_ProviderOperation_ValidateSubscription () { m_ProviderOperation_ValidateSubscription ++ ; }

	UINT64 Get_ProviderOperation_GetObjectAsync () { return m_ProviderOperation_GetObjectAsync ; }
	UINT64 Get_ProviderOperation_PutClassAsync () { return m_ProviderOperation_PutClassAsync ; }
	UINT64 Get_ProviderOperation_DeleteClassAsync () { return m_ProviderOperation_DeleteClassAsync ; }
	UINT64 Get_ProviderOperation_CreateClassEnumAsync () { return m_ProviderOperation_CreateClassEnumAsync ; }
	UINT64 Get_ProviderOperation_PutInstanceAsync () { return m_ProviderOperation_PutInstanceAsync ; }
	UINT64 Get_ProviderOperation_DeleteInstanceAsync () { return m_ProviderOperation_DeleteInstanceAsync ; }
	UINT64 Get_ProviderOperation_CreateInstanceEnumAsync () { return m_ProviderOperation_CreateInstanceEnumAsync ; }
	UINT64 Get_ProviderOperation_ExecQueryAsync () { return m_ProviderOperation_ExecQueryAsync ; }
	UINT64 Get_ProviderOperation_ExecNotificationQueryAsync () { return m_ProviderOperation_ExecNotificationQueryAsync ; }
	UINT64 Get_ProviderOperation_ExecMethodAsync () { return m_ProviderOperation_ExecMethodAsync ; }

	UINT64 Get_ProviderOperation_Begin () { return m_ProviderOperation_Begin ; }
	UINT64 Get_ProviderOperation_Rollback () { return m_ProviderOperation_Rollback ; }
	UINT64 Get_ProviderOperation_Commit () { return m_ProviderOperation_Commit ; }
	UINT64 Get_ProviderOperation_QueryState () { return m_ProviderOperation_QueryState ; }

	UINT64 Get_ProviderOperation_QueryInstances () { return m_ProviderOperation_QueryInstances ; }
	UINT64 Get_ProviderOperation_CreateRefresher () { return m_ProviderOperation_CreateRefresher ; }
	UINT64 Get_ProviderOperation_CreateRefreshableObject () { return m_ProviderOperation_CreateRefreshableObject ; }
	UINT64 Get_ProviderOperation_StopRefreshing () { return m_ProviderOperation_StopRefreshing ; }
	UINT64 Get_ProviderOperation_CreateRefreshableEnum () { return m_ProviderOperation_CreateRefreshableEnum ; }
	UINT64 Get_ProviderOperation_GetObjects () { return m_ProviderOperation_GetObjects ; }

	UINT64 Get_ProviderOperation_GetProperty () { return m_ProviderOperation_GetProperty ; }
	UINT64 Get_ProviderOperation_PutProperty () { return m_ProviderOperation_PutProperty ; }

	UINT64 Get_ProviderOperation_ProvideEvents () { return m_ProviderOperation_ProvideEvents ; }
	UINT64 Get_ProviderOperation_NewQuery () { return m_ProviderOperation_NewQuery ; }
	UINT64 Get_ProviderOperation_CancelQuery () { return m_ProviderOperation_CancelQuery ; }
	UINT64 Get_ProviderOperation_AccessCheck () { return m_ProviderOperation_AccessCheck ; }
	UINT64 Get_ProviderOperation_SetRegistrationObject () { return m_ProviderOperation_SetRegistrationObject ; }
	UINT64 Get_ProviderOperation_FindConsumer () { return m_ProviderOperation_FindConsumer ; }
	UINT64 Get_ProviderOperation_ValidateSubscription () { return m_ProviderOperation_ValidateSubscription ; }

private:

	HRESULT SetStatus ( 

		LPWSTR a_Operation ,
		LPWSTR a_Parameters ,
		LPWSTR a_Description ,
		HRESULT a_Result ,
		IWbemObjectSink *a_Sink
	) ;

	HRESULT Begin_IWbemServices (

		BOOL &a_Impersonating ,
		IUnknown *&a_OldContext ,
		IServerSecurity *&a_OldSecurity ,
		BOOL &a_IsProxy ,
		IWbemServices *&a_Interface ,
		BOOL &a_Revert ,
		IUnknown *&a_Proxy
	) ;

	HRESULT End_IWbemServices (

		BOOL a_Impersonating ,
		IUnknown *a_OldContext ,
		IServerSecurity *a_OldSecurity ,
		BOOL a_IsProxy ,
		IWbemServices *a_Interface ,
		BOOL a_Revert ,
		IUnknown *a_Proxy
	) ;

	HRESULT Begin_Interface (

		IUnknown *a_ServerInterface ,
		REFIID a_InterfaceIdentifier ,
		DWORD a_ProxyIndex ,
		BOOL &a_Impersonating ,
		IUnknown *&a_OldContext ,
		IServerSecurity *&a_OldSecurity ,
		BOOL &a_IsProxy ,
		IUnknown *&a_Interface ,
		BOOL &a_Revert ,
		IUnknown *&a_Proxy
	) ;

	HRESULT End_Interface (

		IUnknown *a_ServerInterface ,
		REFIID a_InterfaceIdentifier ,
		DWORD a_ProxyIndex ,
		BOOL a_Impersonating ,
		IUnknown *a_OldContext ,
		IServerSecurity *a_OldSecurity ,
		BOOL a_IsProxy ,
		IUnknown *a_Interface ,
		BOOL a_Revert ,
		IUnknown *a_Proxy
	) ;

	HRESULT Begin_Interface_Events (

		bool a_Identify ,
		IUnknown *a_ServerInterface ,
		REFIID a_InterfaceIdentifier ,
		DWORD a_ProxyIndex ,
		BOOL &a_Impersonating ,
		IUnknown *&a_OldContext ,
		IServerSecurity *&a_OldSecurity ,
		BOOL &a_IsProxy ,
		IUnknown *&a_Interface ,
		BOOL &a_Revert ,
		IUnknown *&a_Proxy
	) ;

	HRESULT End_Interface_Events (

		IUnknown *a_ServerInterface ,
		REFIID a_InterfaceIdentifier ,
		DWORD a_ProxyIndex ,
		BOOL a_Impersonating ,
		IUnknown *a_OldContext ,
		IServerSecurity *a_OldSecurity ,
		BOOL a_IsProxy ,
		IUnknown *a_Interface ,
		BOOL a_Revert ,
		IUnknown *a_Proxy
	) ;

	HRESULT AdjustGetContext (

		IWbemContext *a_Context
	) ;

	HRESULT Helper_HiPerfGetObjectAsync (

		IWbemHiPerfProvider *a_HighPerformanceProvider ,
 		const BSTR a_ObjectPath ,
		long a_Flags ,
		IWbemContext *a_Context ,
		IWbemObjectSink *a_Sink
	) ;

	HRESULT Helper_GetObjectAsync (

		BOOL a_IsProxy ,
 		const BSTR a_ObjectPath ,
		long a_Flags ,
		IWbemContext *a_Context ,
		IWbemObjectSink *a_Sink ,
		IWbemServices *a_Service 
	) ;

	HRESULT Helper_PutClassAsync (

		BOOL a_IsProxy ,
		IWbemClassObject *a_Object , 
		long a_Flags ,
		IWbemContext FAR *a_Context ,
		IWbemObjectSink *a_Sink ,
		IWbemServices *a_Service 
	) ;

	HRESULT Helper_DeleteClassAsync (

		BOOL a_IsProxy ,
		const BSTR a_Class ,
		long a_Flags ,
		IWbemContext FAR *a_Context ,
		IWbemObjectSink *a_Sink ,
		IWbemServices *a_Service 
	) ;

	HRESULT Helper_CreateClassEnumAsync (

		BOOL a_IsProxy ,
		const BSTR a_SuperClass ,
		long a_Flags ,
		IWbemContext FAR *a_Context ,
		IWbemObjectSink *a_Sink ,
		IWbemServices *a_Service 
	) ;

	HRESULT Helper_PutInstanceAsync (

		BOOL a_IsProxy ,
		IWbemClassObject *a_Instance ,
		long a_Flags ,
		IWbemContext FAR *a_Context ,
		IWbemObjectSink *a_Sink ,
		IWbemServices *a_Service 
	) ;

	HRESULT Helper_DeleteInstanceAsync (

		BOOL a_IsProxy ,
		const BSTR a_ObjectPath ,
		long a_Flags ,
		IWbemContext FAR *a_Context ,
		IWbemObjectSink *a_Sink ,
		IWbemServices *a_Service 
	) ;

    HRESULT Helper_CreateInstanceEnumAsync (

		BOOL a_IsProxy ,
		const BSTR a_Class ,
		long a_Flags ,
		IWbemContext *a_Context ,
		IWbemObjectSink *a_Sink ,
		IWbemServices *a_Service
	) ;

	HRESULT Helper_QueryInstancesAsync (

		IWbemHiPerfProvider *a_PerformanceProvider ,
 		const BSTR a_Class ,
		long a_Flags ,
		IWbemContext *a_Context ,
		IWbemObjectSink *a_Sink 
	) ;

	HRESULT Helper_ExecQueryAsync (

		BOOL a_IsProxy ,
		const BSTR a_QueryLanguage ,
		const BSTR a_Query, 
		long a_Flags ,
		IWbemContext FAR *a_Context ,
		IWbemObjectSink *a_Sink ,
		IWbemServices *a_Service 
	) ;

	HRESULT Helper_ExecMethodAsync (

		BOOL a_IsProxy ,
		const BSTR a_ObjectPath ,
		const BSTR a_MethodName ,
		long a_Flags ,
		IWbemContext *a_Context ,
		IWbemClassObject *a_InParams ,
		IWbemObjectSink *a_Sink ,
		IWbemServices *a_Service 
	) ;

	HRESULT STDMETHODCALLTYPE InternalEx_ProvideEvents (

		bool a_Identify ,
		IWbemObjectSink *a_Sink ,
		long a_Flags
	) ;

	HRESULT STDMETHODCALLTYPE InternalEx_NewQuery (

		bool a_Identify ,
		unsigned long a_Id ,
		WBEM_WSTR a_QueryLanguage ,
		WBEM_WSTR a_Query
	);

	HRESULT STDMETHODCALLTYPE InternalEx_CancelQuery (

		bool a_Identify ,
		unsigned long a_Id
	) ;

	HRESULT STDMETHODCALLTYPE InternalEx_AccessCheck (

		bool a_Identify ,
		WBEM_CWSTR a_QueryLanguage ,
		WBEM_CWSTR a_Query ,
		long a_SidLength ,
		const BYTE *a_Sid
	) ;

	HRESULT STDMETHODCALLTYPE InternalEx_FindConsumer (

		bool a_Identify ,
		IWbemClassObject *a_LogicalConsumer ,
		IWbemUnboundObjectSink **a_Consumer
	);

	HRESULT STDMETHODCALLTYPE InternalEx_ValidateSubscription (

		bool a_Identify ,
		IWbemClassObject *a_LogicalConsumer
	) ;

	HRESULT STDMETHODCALLTYPE InternalEx_IndicateToConsumer (

		bool a_Identify ,
		IWbemClassObject *a_LogicalConsumer ,
		long a_ObjectCount ,
		IWbemClassObject **a_Objects
	) ;

public:

	CInterceptor_IWbemSyncProvider ( 

		WmiAllocator &a_Allocator ,
		IUnknown *a_ServerSideUnknown , 
		IWbemServices *a_CoreStub ,
		CWbemGlobal_IWbemSyncProviderController *a_Controller ,
		IWbemContext *a_InitializationContext ,
		CServerObject_ProviderRegistrationV1 &a_Registration ,
		GUID &a_Guid 
	) ;

    ~CInterceptor_IWbemSyncProvider () ;

public:

	//Non-delegating object IUnknown

    STDMETHODIMP QueryInterface ( REFIID , LPVOID FAR * ) ;
    STDMETHODIMP_( ULONG ) AddRef () ;
    STDMETHODIMP_( ULONG ) Release () ;

    /* IWbemServices methods */

    HRESULT STDMETHODCALLTYPE OpenNamespace ( 

        const BSTR a_Namespace ,
        long a_Flags ,
        IWbemContext *a_Context ,
        IWbemServices **a_Service ,
        IWbemCallResult **a_CallResult
	) ;
    
    HRESULT STDMETHODCALLTYPE CancelAsyncCall ( 

        IWbemObjectSink *a_Sink
	) ;
    
    HRESULT STDMETHODCALLTYPE QueryObjectSink ( 

        long a_Flags ,
        IWbemObjectSink **a_Sink
	) ;
    
    HRESULT STDMETHODCALLTYPE GetObject ( 

		const BSTR a_ObjectPath ,
        long a_Flags ,
        IWbemContext *a_Context ,
        IWbemClassObject **ppObject ,
        IWbemCallResult **a_CallResult
	) ;
    
    HRESULT STDMETHODCALLTYPE GetObjectAsync (
        
		const BSTR a_ObjectPath ,
        long a_Flags ,
        IWbemContext *a_Context ,
        IWbemObjectSink *a_Sink
	) ;

    HRESULT STDMETHODCALLTYPE PutClass ( 

        IWbemClassObject *a_Object ,
        long a_Flags ,
        IWbemContext *a_Context ,
        IWbemCallResult **a_CallResult
	) ;
    
    HRESULT STDMETHODCALLTYPE PutClassAsync ( 

        IWbemClassObject *a_Object ,
        long a_Flags ,
        IWbemContext *a_Context ,
        IWbemObjectSink *a_Sink
	) ;
    
    HRESULT STDMETHODCALLTYPE DeleteClass ( 

        const BSTR a_Class ,
        long a_Flags ,
        IWbemContext *a_Context ,
        IWbemCallResult **a_CallResult
	) ;
    
    HRESULT STDMETHODCALLTYPE DeleteClassAsync ( 

        const BSTR a_Class ,
        long a_Flags ,
        IWbemContext *a_Context ,
        IWbemObjectSink *a_Sink
	) ;
    
    HRESULT STDMETHODCALLTYPE CreateClassEnum ( 

        const BSTR a_Superclass ,
        long a_Flags ,
        IWbemContext *a_Context ,
        IEnumWbemClassObject **a_Enum
	) ;
    
    HRESULT STDMETHODCALLTYPE CreateClassEnumAsync ( 

		const BSTR a_Superclass ,
		long a_Flags ,
		IWbemContext *a_Context ,
		IWbemObjectSink *a_Sink
	) ;
    
    HRESULT STDMETHODCALLTYPE PutInstance (

		IWbemClassObject *a_Instance ,
		long a_Flags , 
		IWbemContext *a_Context ,
		IWbemCallResult **a_CallResult
	) ;
    
    HRESULT STDMETHODCALLTYPE PutInstanceAsync (

		IWbemClassObject *a_Instance ,
		long a_Flags ,
		IWbemContext *a_Context ,
		IWbemObjectSink *a_Sink 
	) ;
    
    HRESULT STDMETHODCALLTYPE DeleteInstance ( 

		const BSTR a_ObjectPath ,
		long a_Flags ,
		IWbemContext *a_Context ,
		IWbemCallResult **a_CallResult
	) ;
    
    HRESULT STDMETHODCALLTYPE DeleteInstanceAsync ( 

		const BSTR a_ObjectPath,
		long a_Flags,
		IWbemContext *a_Context ,
		IWbemObjectSink *a_Sink
	) ;
    
    HRESULT STDMETHODCALLTYPE CreateInstanceEnum (

		const BSTR a_Class ,
		long a_Flags ,
		IWbemContext *a_Context ,
		IEnumWbemClassObject **a_Enum
	) ;
    
    HRESULT STDMETHODCALLTYPE CreateInstanceEnumAsync (

		const BSTR a_Class ,
		long a_Flags ,
		IWbemContext *a_Context ,
		IWbemObjectSink *a_Sink
	) ;
    
    HRESULT STDMETHODCALLTYPE ExecQuery ( 

		const BSTR a_QueryLanguage,
		const BSTR a_Query,
		long a_Flags ,
		IWbemContext *a_Context ,
		IEnumWbemClassObject **a_Enum
	) ;
    
    HRESULT STDMETHODCALLTYPE ExecQueryAsync (

		const BSTR a_QueryLanguage ,
		const BSTR a_Query ,
		long a_Flags ,
		IWbemContext *a_Context ,
		IWbemObjectSink *a_Sink
	) ;
    
    HRESULT STDMETHODCALLTYPE ExecNotificationQuery (

		const BSTR a_QueryLanguage ,
		const BSTR a_Query ,
		long a_Flags ,
		IWbemContext *a_Context ,
		IEnumWbemClassObject **a_Enum
	) ;
    
    HRESULT STDMETHODCALLTYPE ExecNotificationQueryAsync ( 

        const BSTR a_QueryLanguage ,
        const BSTR a_Query ,
        long a_Flags ,
        IWbemContext *a_Context ,
        IWbemObjectSink *a_Sink
	) ;
    
    HRESULT STDMETHODCALLTYPE ExecMethod (

        const BSTR a_ObjectPath ,
        const BSTR a_MethodName ,
        long a_Flags ,
        IWbemContext *a_Context ,
        IWbemClassObject *a_InParams ,
        IWbemClassObject **a_OutParams ,
        IWbemCallResult **a_CallResult
	) ;
    
    HRESULT STDMETHODCALLTYPE ExecMethodAsync ( 

		const BSTR a_ObjectPath ,
		const BSTR a_MethodName ,
		long a_Flags ,
		IWbemContext *a_Context ,
		IWbemClassObject *a_InParams ,
		IWbemObjectSink *a_Sink
	) ;

	/* IWbemPropertyProvider */

    HRESULT STDMETHODCALLTYPE GetProperty (

        long a_Flags ,
        const BSTR a_Locale ,
        const BSTR a_ClassMapping ,
        const BSTR a_InstanceMapping ,
        const BSTR a_PropertyMapping ,
        VARIANT *a_Value
	) ;
        
    HRESULT STDMETHODCALLTYPE PutProperty (

        long a_Flags ,
        const BSTR a_Locale ,
        const BSTR a_ClassMapping ,
        const BSTR a_InstanceMapping ,
        const BSTR a_PropertyMapping ,
        const VARIANT *a_Value
	) ;

	/* IWbemEventProvider */

	HRESULT STDMETHODCALLTYPE ProvideEvents (

		IWbemObjectSink *a_Sink ,
		long a_Flags
	) ;

	/* IWbemEventProviderQuerySink */

	HRESULT STDMETHODCALLTYPE NewQuery (

		unsigned long a_Id ,
		WBEM_WSTR a_QueryLanguage ,
		WBEM_WSTR a_Query
	);

	HRESULT STDMETHODCALLTYPE CancelQuery (

		unsigned long a_Id
	) ;

	/* IWbemEventProviderSecurity */

	HRESULT STDMETHODCALLTYPE AccessCheck (

		WBEM_CWSTR a_QueryLanguage ,
		WBEM_CWSTR a_Query ,
		long a_SidLength ,
		const BYTE *a_Sid
	) ;

	/* IWbemProviderIdentity */

	HRESULT STDMETHODCALLTYPE SetRegistrationObject (

		long a_Flags ,
		IWbemClassObject *a_ProviderRegistration
	) ;

	/* IWbemEventConsumerProvider */

	HRESULT STDMETHODCALLTYPE FindConsumer (

		IWbemClassObject *a_LogicalConsumer ,
		IWbemUnboundObjectSink **a_Consumer
	);

	/* IWbemEventConsumerProviderEx */

	HRESULT STDMETHODCALLTYPE ValidateSubscription (

		IWbemClassObject *a_LogicalConsumer
	) ;

	/* IWbemUnboundObjectSink */

	HRESULT STDMETHODCALLTYPE IndicateToConsumer (

		IWbemClassObject *a_LogicalConsumer ,
		long a_ObjectCount ,
		IWbemClassObject **a_Objects
	) ;

	/* IWbemHiPerfProvider */

	HRESULT STDMETHODCALLTYPE QueryInstances (

		IWbemServices *a_Namespace ,
		WCHAR *a_Class ,
		long a_Flags ,
		IWbemContext *a_Context ,
		IWbemObjectSink *a_Sink
	) ;

	HRESULT STDMETHODCALLTYPE CreateRefresher (

		IWbemServices *a_Namespace ,
		long a_Flags ,
		IWbemRefresher **a_Refresher
	) ; 

	HRESULT STDMETHODCALLTYPE CreateRefreshableObject (

		IWbemServices *a_Namespace ,
		IWbemObjectAccess *a_Template ,
		IWbemRefresher *a_Refresher ,
		long a_Flags ,
		IWbemContext *a_Context ,
		IWbemObjectAccess **a_Refreshable ,
		long *a_Id
	) ;

	HRESULT STDMETHODCALLTYPE StopRefreshing (

		IWbemRefresher *a_Refresher ,
		long a_Id ,
		long a_Flags
	) ;

	HRESULT STDMETHODCALLTYPE CreateRefreshableEnum (

		IWbemServices *a_Namespace ,
		LPCWSTR a_Class ,
		IWbemRefresher *a_Refresher ,
		long a_Flags ,
		IWbemContext *a_Context ,
		IWbemHiPerfEnum *a_HiPerfEnum ,
		long *a_Id
	) ;

	HRESULT STDMETHODCALLTYPE GetObjects (

		IWbemServices *a_Namespace ,
		long a_ObjectCount ,
		IWbemObjectAccess **a_Objects ,
		long a_Flags ,
		IWbemContext *a_Context
	) ;

/* Internal_IWbemServices */
 
     HRESULT STDMETHODCALLTYPE Internal_OpenNamespace ( 

		WmiInternalContext a_InternalContext ,
        const BSTR a_Namespace ,
        long a_Flags ,
        IWbemContext *a_Context ,
        IWbemServices **a_Service ,
        IWbemCallResult **a_CallResult
	) ;
    
    HRESULT STDMETHODCALLTYPE Internal_CancelAsyncCall ( 

		WmiInternalContext a_InternalContext ,
        IWbemObjectSink *a_Sink
	) ;
    
    HRESULT STDMETHODCALLTYPE Internal_QueryObjectSink ( 

		WmiInternalContext a_InternalContext ,
        long a_Flags ,
        IWbemObjectSink **a_Sink
	) ;
    
    HRESULT STDMETHODCALLTYPE Internal_GetObject ( 

		WmiInternalContext a_InternalContext ,
		const BSTR a_ObjectPath ,
        long a_Flags ,
        IWbemContext *a_Context ,
        IWbemClassObject **ppObject ,
        IWbemCallResult **a_CallResult
	) ;
    
    HRESULT STDMETHODCALLTYPE Internal_GetObjectAsync (
        
		WmiInternalContext a_InternalContext ,
		const BSTR a_ObjectPath ,
        long a_Flags ,
        IWbemContext *a_Context ,
        IWbemObjectSink *a_Sink
	) ;

    HRESULT STDMETHODCALLTYPE Internal_PutClass ( 

		WmiInternalContext a_InternalContext ,
        IWbemClassObject *a_Object ,
        long a_Flags ,
        IWbemContext *a_Context ,
        IWbemCallResult **a_CallResult
	) ;
    
    HRESULT STDMETHODCALLTYPE Internal_PutClassAsync ( 

		WmiInternalContext a_InternalContext ,
        IWbemClassObject *a_Object ,
        long a_Flags ,
        IWbemContext *a_Context ,
        IWbemObjectSink *a_Sink
	) ;
    
    HRESULT STDMETHODCALLTYPE Internal_DeleteClass ( 

		WmiInternalContext a_InternalContext ,
        const BSTR a_Class ,
        long a_Flags ,
        IWbemContext *a_Context ,
        IWbemCallResult **a_CallResult
	) ;
    
    HRESULT STDMETHODCALLTYPE Internal_DeleteClassAsync ( 

		WmiInternalContext a_InternalContext ,
        const BSTR a_Class ,
        long a_Flags ,
        IWbemContext *a_Context ,
        IWbemObjectSink *a_Sink
	) ;
    
    HRESULT STDMETHODCALLTYPE Internal_CreateClassEnum ( 

		WmiInternalContext a_InternalContext ,
        const BSTR a_Superclass ,
        long a_Flags ,
        IWbemContext *a_Context ,
        IEnumWbemClassObject **a_Enum
	) ;
    
    HRESULT STDMETHODCALLTYPE Internal_CreateClassEnumAsync ( 

		WmiInternalContext a_InternalContext ,
		const BSTR a_Superclass ,
		long a_Flags ,
		IWbemContext *a_Context ,
		IWbemObjectSink *a_Sink
	) ;
    
    HRESULT STDMETHODCALLTYPE Internal_PutInstance (

		WmiInternalContext a_InternalContext ,
		IWbemClassObject *a_Instance ,
		long a_Flags , 
		IWbemContext *a_Context ,
		IWbemCallResult **a_CallResult
	) ;
    
    HRESULT STDMETHODCALLTYPE Internal_PutInstanceAsync (

		WmiInternalContext a_InternalContext ,
		IWbemClassObject *a_Instance ,
		long a_Flags ,
		IWbemContext *a_Context ,
		IWbemObjectSink *a_Sink 
	) ;
    
    HRESULT STDMETHODCALLTYPE Internal_DeleteInstance ( 

		WmiInternalContext a_InternalContext ,
		const BSTR a_ObjectPath ,
		long a_Flags ,
		IWbemContext *a_Context ,
		IWbemCallResult **a_CallResult
	) ;
    
    HRESULT STDMETHODCALLTYPE Internal_DeleteInstanceAsync ( 

		WmiInternalContext a_InternalContext ,
		const BSTR a_ObjectPath,
		long a_Flags,
		IWbemContext *a_Context ,
		IWbemObjectSink *a_Sink
	) ;
    
    HRESULT STDMETHODCALLTYPE Internal_CreateInstanceEnum (

		WmiInternalContext a_InternalContext ,
		const BSTR a_Class ,
		long a_Flags ,
		IWbemContext *a_Context ,
		IEnumWbemClassObject **a_Enum
	) ;
    
    HRESULT STDMETHODCALLTYPE Internal_CreateInstanceEnumAsync (

		WmiInternalContext a_InternalContext ,
		const BSTR a_Class ,
		long a_Flags ,
		IWbemContext *a_Context ,
		IWbemObjectSink *a_Sink
	) ;
    
    HRESULT STDMETHODCALLTYPE Internal_ExecQuery ( 

		WmiInternalContext a_InternalContext ,
		const BSTR a_QueryLanguage,
		const BSTR a_Query,
		long a_Flags ,
		IWbemContext *a_Context ,
		IEnumWbemClassObject **a_Enum
	) ;
    
    HRESULT STDMETHODCALLTYPE Internal_ExecQueryAsync (

		WmiInternalContext a_InternalContext ,
		const BSTR a_QueryLanguage ,
		const BSTR a_Query ,
		long a_Flags ,
		IWbemContext *a_Context ,
		IWbemObjectSink *a_Sink
	) ;
    
    HRESULT STDMETHODCALLTYPE Internal_ExecNotificationQuery (

		WmiInternalContext a_InternalContext ,
		const BSTR a_QueryLanguage ,
		const BSTR a_Query ,
		long a_Flags ,
		IWbemContext *a_Context ,
		IEnumWbemClassObject **a_Enum
	) ;
    
    HRESULT STDMETHODCALLTYPE Internal_ExecNotificationQueryAsync ( 

		WmiInternalContext a_InternalContext ,
        const BSTR a_QueryLanguage ,
        const BSTR a_Query ,
        long a_Flags ,
        IWbemContext *a_Context ,
        IWbemObjectSink *a_Sink
	) ;
    
    HRESULT STDMETHODCALLTYPE Internal_ExecMethod (

		WmiInternalContext a_InternalContext ,
        const BSTR a_ObjectPath ,
        const BSTR a_MethodName ,
        long a_Flags ,
        IWbemContext *a_Context ,
        IWbemClassObject *a_InParams ,
        IWbemClassObject **a_OutParams ,
        IWbemCallResult **a_CallResult
	) ;
    
    HRESULT STDMETHODCALLTYPE Internal_ExecMethodAsync ( 

		WmiInternalContext a_InternalContext ,
		const BSTR a_ObjectPath ,
		const BSTR a_MethodName ,
		long a_Flags ,
		IWbemContext *a_Context ,
		IWbemClassObject *a_InParams ,
		IWbemObjectSink *a_Sink
	) ;

	/* Internal_IWbemPropertyProvider */

    HRESULT STDMETHODCALLTYPE Internal_GetProperty (

		WmiInternalContext a_InternalContext ,
        long a_Flags ,
        const BSTR a_Locale ,
        const BSTR a_ClassMapping ,
        const BSTR a_InstanceMapping ,
        const BSTR a_PropertyMapping ,
        VARIANT *a_Value
	) ;
        
    HRESULT STDMETHODCALLTYPE Internal_PutProperty (

		WmiInternalContext a_InternalContext ,
        long a_Flags ,
        const BSTR a_Locale ,
        const BSTR a_ClassMapping ,
        const BSTR a_InstanceMapping ,
        const BSTR a_PropertyMapping ,
        const VARIANT *a_Value
	) ;

	/* Internal_IWbemEventProvider */

	HRESULT STDMETHODCALLTYPE Internal_ProvideEvents (

		WmiInternalContext a_InternalContext ,
		IWbemObjectSink *a_Sink ,
		long a_Flags
	) ;

	/* Internal_IWbemEventProviderQuerySink */

	HRESULT STDMETHODCALLTYPE Internal_NewQuery (

		WmiInternalContext a_InternalContext ,
		unsigned long a_Id ,
		WBEM_WSTR a_QueryLanguage ,
		WBEM_WSTR a_Query
	);

	HRESULT STDMETHODCALLTYPE Internal_CancelQuery (

		WmiInternalContext a_InternalContext ,
		unsigned long a_Id
	) ;

	/* Internal_IWbemEventProviderSecurity */

	HRESULT STDMETHODCALLTYPE Internal_AccessCheck (

		WmiInternalContext a_InternalContext ,
		WBEM_CWSTR a_QueryLanguage ,
		WBEM_CWSTR a_Query ,
		long a_SidLength ,
		const BYTE *a_Sid
	) ;

	/* Internal_IWbemEventConsumerProvider */

	HRESULT STDMETHODCALLTYPE Internal_FindConsumer (

		WmiInternalContext a_InternalContext ,
		IWbemClassObject *a_LogicalConsumer ,
		IWbemUnboundObjectSink **a_Consumer
	);

	/* Internal_IWbemEventConsumerProviderEx */

	HRESULT STDMETHODCALLTYPE Internal_ValidateSubscription (

		WmiInternalContext a_InternalContext ,
		IWbemClassObject *a_LogicalConsumer
	) ;

	/* Internal_IWbemUnboundObjectSink */

	HRESULT STDMETHODCALLTYPE Internal_IndicateToConsumer (

		WmiInternalContext a_InternalContext ,
		IWbemClassObject *a_LogicalConsumer ,
		long a_ObjectCount ,
		IWbemClassObject **a_Objects
	) ;

	/* _IWmiProviderConfiguration methods */

	HRESULT STDMETHODCALLTYPE Get (

		IWbemServices *a_Service ,
		long a_Flags ,
		IWbemContext *a_Context ,
		LPCWSTR a_Class ,
		LPCWSTR a_Path ,
		IWbemObjectSink *a_Sink
	) ;

	HRESULT STDMETHODCALLTYPE Set (

		IWbemServices *a_Service ,
		long a_Flags ,
		IWbemContext *a_Context ,
		LPCWSTR a_Provider ,
		LPCWSTR a_Class ,
		LPCWSTR a_Path ,
		IWbemClassObject *a_OldObject ,
		IWbemClassObject *a_NewObject  
	) ;

	HRESULT STDMETHODCALLTYPE Deleted (

		IWbemServices *a_Service ,
		long a_Flags ,
		IWbemContext *a_Context ,
		LPCWSTR a_Provider ,
		LPCWSTR a_Class ,
		LPCWSTR a_Path ,
		IWbemClassObject *a_Object  
	) ;

	HRESULT STDMETHODCALLTYPE Enumerate (

		IWbemServices *a_Service ,
		long a_Flags ,
		IWbemContext *a_Context ,
		LPCWSTR a_Class ,
		IWbemObjectSink *a_Sink
	) ;

	HRESULT STDMETHODCALLTYPE Shutdown (

		IWbemServices *a_Service ,
		long a_Flags ,
		IWbemContext *a_Context ,
		LPCWSTR a_Provider ,
		ULONG a_MilliSeconds
	) ;

	HRESULT STDMETHODCALLTYPE Call (

		IWbemServices *a_Service ,
		long a_Flags ,
		IWbemContext *a_Context ,
		LPCWSTR a_Class ,
		LPCWSTR a_Path ,		
		LPCWSTR a_Method,
		IWbemClassObject *a_InParams,
		IWbemObjectSink *a_Sink
	) ;

	HRESULT STDMETHODCALLTYPE Query (

		IWbemServices *a_Service ,
		long a_Flags ,
		IWbemContext *a_Context ,
		WBEM_PROVIDER_CONFIGURATION_CLASS_ID a_ClassIdentifier ,
		WBEM_PROVIDER_CONFIGURATION_PROPERTY_ID a_PropertyIdentifier ,
		VARIANT *a_Value 
	) ;

	HRESULT STDMETHODCALLTYPE ForceReload () ;

	/* Internal_IWmiProviderConfiguration methods */

	HRESULT STDMETHODCALLTYPE Internal_Get (

		WmiInternalContext a_InternalContext ,
		IWbemServices *a_Service ,
		long a_Flags ,
		IWbemContext *a_Context ,
		LPCWSTR a_Class ,
		LPCWSTR a_Path ,
		IWbemObjectSink *a_Sink
	) ;

	HRESULT STDMETHODCALLTYPE Internal_Set (

		WmiInternalContext a_InternalContext ,
		IWbemServices *a_Service ,
		long a_Flags ,
		IWbemContext *a_Context ,
		LPCWSTR a_Provider ,
		LPCWSTR a_Class ,
		LPCWSTR a_Path ,
		IWbemClassObject *a_OldObject ,
		IWbemClassObject *a_NewObject  
	) ;

	HRESULT STDMETHODCALLTYPE Internal_Deleted (

		WmiInternalContext a_InternalContext ,
		IWbemServices *a_Service ,
		long a_Flags ,
		IWbemContext *a_Context ,
		LPCWSTR a_Provider ,
		LPCWSTR a_Class ,
		LPCWSTR a_Path ,
		IWbemClassObject *a_Object  
	) ;

	HRESULT STDMETHODCALLTYPE Internal_Enumerate (

		WmiInternalContext a_InternalContext ,
		IWbemServices *a_Service ,
		long a_Flags ,
		IWbemContext *a_Context ,
		LPCWSTR a_Class ,
		IWbemObjectSink *a_Sink
	) ;

	HRESULT STDMETHODCALLTYPE Internal_Shutdown (

		WmiInternalContext a_InternalContext ,
		IWbemServices *a_Service ,
		long a_Flags ,
		IWbemContext *a_Context ,
		LPCWSTR a_Provider ,
		ULONG a_MilliSeconds
	) ;

	HRESULT STDMETHODCALLTYPE Internal_Call (

		WmiInternalContext a_InternalContext ,
		IWbemServices *a_Service ,
		long a_Flags ,
		IWbemContext *a_Context ,
		LPCWSTR a_Class ,
		LPCWSTR a_Path ,		
		LPCWSTR a_Method,
		IWbemClassObject *a_InParams,
		IWbemObjectSink *a_Sink
	) ;

	HRESULT STDMETHODCALLTYPE Internal_Query (

		WmiInternalContext a_InternalContext ,
		IWbemServices *a_Service ,
		long a_Flags ,
		IWbemContext *a_Context ,
		WBEM_PROVIDER_CONFIGURATION_CLASS_ID a_ClassIdentifier ,
		WBEM_PROVIDER_CONFIGURATION_PROPERTY_ID a_PropertyIdentifier ,
		VARIANT *a_Value 
	) ;


	/* _IWmiProviderQuota */

	HRESULT STDMETHODCALLTYPE Violation (

		long a_Flags ,
		IWbemContext *a_Context ,
		IWbemClassObject *a_Object	
	) ;

	/* _IWmiProviderSite */

	HRESULT STDMETHODCALLTYPE GetSite ( DWORD *a_ProcessIdentifier ) ;

	HRESULT STDMETHODCALLTYPE SetContainer ( IUnknown *a_Container ) ;

	/* IWbemProviderInit methods */

	HRESULT STDMETHODCALLTYPE Initialize (

		LONG a_Flags ,
		IWbemContext *a_Context ,
		GUID *a_TransactionIdentifier,
		LPCWSTR a_User ,
		LPCWSTR a_Locale ,
		LPCWSTR a_Namespace ,
		IWbemServices *a_Repository ,
		IWbemServices *a_Service ,
		IWbemProviderInitSink *a_Sink
	) ;

	HRESULT STDMETHODCALLTYPE WaitProvider ( IWbemContext *a_Context , ULONG a_Timeout ) ;

	HRESULT STDMETHODCALLTYPE GetInitializeResult () 
	{
		return m_InitializeResult ;
	}

	HRESULT STDMETHODCALLTYPE GetHosting ( ULONG *a_Value )
	{
		return WBEM_E_NOT_AVAILABLE ;
	}

	HRESULT STDMETHODCALLTYPE GetHostingGroup ( BSTR *a_Value )
	{
		return WBEM_E_NOT_AVAILABLE ;
	}

	HRESULT STDMETHODCALLTYPE IsInternal ( BOOL *a_Value )
	{
		return WBEM_E_NOT_AVAILABLE ;
	}

	HRESULT STDMETHODCALLTYPE IsPerUserInitialization ( BOOL *a_Value )
	{
		return WBEM_E_NOT_AVAILABLE ;
	}

	HRESULT STDMETHODCALLTYPE IsPerLocaleInitialization ( BOOL *a_Value )
	{
		return WBEM_E_NOT_AVAILABLE ;
	}

	// IWmi_UnInitialize members

	HRESULT STDMETHODCALLTYPE Shutdown (

		LONG a_Flags ,
		ULONG a_MaxMilliSeconds ,
		IWbemContext *a_Context
	) ; 
} ;

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

class CInterceptor_IWbemDecoupledProvider :	public IWbemServices , 
											public IWbemPropertyProvider ,
											public IWbemEventProvider ,
											public IWbemEventProviderQuerySink ,
											public IWbemEventProviderSecurity ,
											public IWbemProviderInit ,
											public IWbemProviderIdentity ,
											public IWbemEventConsumerProviderEx ,
											public IWbemUnboundObjectSink ,

											public IWbemShutdown , 
											public _IWmiProviderInitialize ,
											public _IWmiProviderAbnormalShutdown ,
											public SyncProviderContainerElement ,
											public CWbemGlobal_IWmiObjectSinkController 
{
private:

	IUnknown *m_Unknown ;
	IWbemServices *m_Provider_IWbemServices ;
	IWbemPropertyProvider *m_Provider_IWbemPropertyProvider ;
	IWbemEventProvider *m_Provider_IWbemEventProvider ;
	IWbemEventProviderQuerySink *m_Provider_IWbemEventProviderQuerySink ;
	IWbemEventProviderSecurity *m_Provider_IWbemEventProviderSecurity ;
	IWbemEventConsumerProvider *m_Provider_IWbemEventConsumerProvider ;
	IWbemEventConsumerProviderEx *m_Provider_IWbemEventConsumerProviderEx ;
	IWbemUnboundObjectSink *m_Provider_IWbemUnboundObjectSink ;
	IWbemProviderInit *m_Provider_IWbemProviderInit ;
	IWbemProviderIdentity *m_Provider_IWbemProviderIdentity ;

	Internal_IWbemServices *m_Provider_Internal_IWbemServices ;
	Internal_IWbemPropertyProvider *m_Provider_Internal_IWbemPropertyProvider ;
	Internal_IWbemEventProvider *m_Provider_Internal_IWbemEventProvider ;
	Internal_IWbemEventProviderQuerySink *m_Provider_Internal_IWbemEventProviderQuerySink ;
	Internal_IWbemEventProviderSecurity *m_Provider_Internal_IWbemEventProviderSecurity ;
	Internal_IWbemEventConsumerProvider *m_Provider_Internal_IWbemEventConsumerProvider ;
	Internal_IWbemEventConsumerProviderEx *m_Provider_Internal_IWbemEventConsumerProviderEx ;
	Internal_IWbemUnboundObjectSink *m_Provider_Internal_IWbemUnboundObjectSink ;
	Internal_IWmiProviderConfiguration *m_Provider_Internal_IWmiProviderConfiguration ;
	Internal_IWbemProviderInit *m_Provider_Internal_IWbemProviderInit ;
	Internal_IWbemProviderIdentity *m_Provider_Internal_IWbemProviderIdentity ;

	IWbemServices *m_CoreStub ;

	IWbemClassObject *m_ExtendedStatusObject ;

	WmiAllocator &m_Allocator ;

	ProxyContainer m_ProxyContainer ;

	LONG m_Initialized ;
	HRESULT m_InitializeResult ;
	HANDLE m_InitializedEvent ;
	IWbemContext *m_InitializationContext ;
	SECURITY_DESCRIPTOR * m_expandedSD;

	DWORD m_ProcessIdentifier ;

	HRESULT Begin_Interface (

		IUnknown *a_ServerInterface ,
		REFIID a_InterfaceIdentifier ,
		DWORD a_ProxyIndex ,
		IUnknown *a_InternalServerInterface ,
		REFIID a_InternalInterfaceIdentifier ,
		DWORD a_InternalProxyIndex ,
		DWORD a_ProcessIdentifier ,
		HANDLE &a_IdentifyToken ,
		BOOL &a_Impersonating ,
		IUnknown *&a_OldContext ,
		IServerSecurity *&a_OldSecurity ,
		BOOL &a_IsProxy ,
		IUnknown *&a_Interface ,
		BOOL &a_Revert ,
		IUnknown *&a_Proxy ,
		IWbemContext *a_Context = NULL
	) ;

	HRESULT End_Interface (

		IUnknown *a_ServerInterface ,
		REFIID a_InterfaceIdentifier ,
		DWORD a_ProxyIndex ,
		IUnknown *a_InternalServerInterface ,
		REFIID a_InternalInterfaceIdentifier ,
		DWORD a_InternalProxyIndex ,
		DWORD a_ProcessIdentifier ,
		HANDLE a_IdentifyToken ,
		BOOL a_Impersonating ,
		IUnknown *a_OldContext ,
		IServerSecurity *a_OldSecurity ,
		BOOL a_IsProxy ,
		IUnknown *a_Interface ,
		BOOL a_Revert ,
		IUnknown *a_Proxy
	) ;
	SECURITY_DESCRIPTOR* GetSD(){ if (m_expandedSD) return m_expandedSD; else return m_Registration->GetComRegistration ().GetSecurityDescriptor ();}
	HRESULT AddProcessToSD (DWORD pid, SECURITY_DESCRIPTOR*& sourceSD, SECURITY_DESCRIPTOR* destSD );
public:

	HRESULT SetInitialized ( HRESULT a_InitializeResult ) ;

public:

	CServerObject_ProviderRegistrationV1 *m_Registration ;
	BSTR m_Locale ;
	BSTR m_User ;
	BSTR m_Namespace ;
	BSTR m_TransactionIdentifier ;

	UINT64 m_ProviderOperation_GetObjectAsync ;
	UINT64 m_ProviderOperation_PutClassAsync ;
	UINT64 m_ProviderOperation_DeleteClassAsync ;
	UINT64 m_ProviderOperation_CreateClassEnumAsync ;
	UINT64 m_ProviderOperation_PutInstanceAsync ;
	UINT64 m_ProviderOperation_DeleteInstanceAsync ;
	UINT64 m_ProviderOperation_CreateInstanceEnumAsync ;
	UINT64 m_ProviderOperation_ExecQueryAsync ;
	UINT64 m_ProviderOperation_ExecNotificationQueryAsync ;
	UINT64 m_ProviderOperation_ExecMethodAsync ;

	UINT64 m_ProviderOperation_Begin ;
	UINT64 m_ProviderOperation_Rollback ;
	UINT64 m_ProviderOperation_Commit ;
	UINT64 m_ProviderOperation_QueryState ;

	UINT64 m_ProviderOperation_QueryInstances ;
	UINT64 m_ProviderOperation_CreateRefresher ;
	UINT64 m_ProviderOperation_CreateRefreshableObject ;
	UINT64 m_ProviderOperation_StopRefreshing ;
	UINT64 m_ProviderOperation_CreateRefreshableEnum ;
	UINT64 m_ProviderOperation_GetObjects ;

	UINT64 m_ProviderOperation_GetProperty ;
	UINT64 m_ProviderOperation_PutProperty ;

	UINT64 m_ProviderOperation_ProvideEvents ;
	UINT64 m_ProviderOperation_NewQuery ;
	UINT64 m_ProviderOperation_CancelQuery ;
	UINT64 m_ProviderOperation_AccessCheck ;
	UINT64 m_ProviderOperation_SetRegistrationObject ;
	UINT64 m_ProviderOperation_FindConsumer ;
	UINT64 m_ProviderOperation_ValidateSubscription ;

	void Increment_ProviderOperation_GetObjectAsync () { m_ProviderOperation_GetObjectAsync ++ ; }
 	void Increment_ProviderOperation_PutClassAsync () { m_ProviderOperation_PutClassAsync ++ ; }
	void Increment_ProviderOperation_DeleteClassAsync () { m_ProviderOperation_DeleteClassAsync ++ ; }
	void Increment_ProviderOperation_CreateClassEnumAsync () { m_ProviderOperation_CreateClassEnumAsync ++ ; }
	void Increment_ProviderOperation_PutInstanceAsync () { m_ProviderOperation_PutInstanceAsync ++ ; }
	void Increment_ProviderOperation_DeleteInstanceAsync () { m_ProviderOperation_DeleteInstanceAsync ++ ; }
	void Increment_ProviderOperation_CreateInstanceEnumAsync () { m_ProviderOperation_CreateInstanceEnumAsync ++ ; }
	void Increment_ProviderOperation_ExecQueryAsync () { m_ProviderOperation_ExecQueryAsync ++ ; }
	void Increment_ProviderOperation_ExecNotificationQueryAsync () { m_ProviderOperation_ExecNotificationQueryAsync ++ ; }
	void Increment_ProviderOperation_ExecMethodAsync () { m_ProviderOperation_ExecMethodAsync ++ ; }

	void Increment_ProviderOperation_Begin () { m_ProviderOperation_Begin ++ ; }
	void Increment_ProviderOperation_Rollback () { m_ProviderOperation_Rollback ++ ; }
	void Increment_ProviderOperation_Commit () { m_ProviderOperation_Commit ++ ; }
	void Increment_ProviderOperation_QueryState () { m_ProviderOperation_QueryState ++ ; }

	void Increment_ProviderOperation_QueryInstances () { m_ProviderOperation_QueryInstances ++ ; }
	void Increment_ProviderOperation_CreateRefresher () { m_ProviderOperation_CreateRefresher ++ ; }
	void Increment_ProviderOperation_CreateRefreshableObject () { m_ProviderOperation_CreateRefreshableObject ++ ; }
	void Increment_ProviderOperation_StopRefreshing () { m_ProviderOperation_StopRefreshing ++ ; }
	void Increment_ProviderOperation_CreateRefreshableEnum () { m_ProviderOperation_CreateRefreshableEnum ++ ; }
	void Increment_ProviderOperation_GetObjects () { m_ProviderOperation_GetObjects ++ ; }

	void Increment_ProviderOperation_GetProperty () { m_ProviderOperation_GetProperty ++ ; }
	void Increment_ProviderOperation_PutProperty () { m_ProviderOperation_PutProperty ++ ; }

	void Increment_ProviderOperation_ProvideEvents () { m_ProviderOperation_ProvideEvents ++ ; }
	void Increment_ProviderOperation_NewQuery () { m_ProviderOperation_NewQuery ++ ; }
	void Increment_ProviderOperation_CancelQuery () { m_ProviderOperation_CancelQuery ++ ; }
	void Increment_ProviderOperation_AccessCheck () { m_ProviderOperation_AccessCheck ++ ; }
	void Increment_ProviderOperation_SetRegistrationObject () { m_ProviderOperation_SetRegistrationObject ++ ; }
	void Increment_ProviderOperation_FindConsumer () { m_ProviderOperation_FindConsumer ++ ; }
	void Increment_ProviderOperation_ValidateSubscription () { m_ProviderOperation_ValidateSubscription ++ ; }

	UINT64 Get_ProviderOperation_GetObjectAsync () { return m_ProviderOperation_GetObjectAsync ; }
	UINT64 Get_ProviderOperation_PutClassAsync () { return m_ProviderOperation_PutClassAsync ; }
	UINT64 Get_ProviderOperation_DeleteClassAsync () { return m_ProviderOperation_DeleteClassAsync ; }
	UINT64 Get_ProviderOperation_CreateClassEnumAsync () { return m_ProviderOperation_CreateClassEnumAsync ; }
	UINT64 Get_ProviderOperation_PutInstanceAsync () { return m_ProviderOperation_PutInstanceAsync ; }
	UINT64 Get_ProviderOperation_DeleteInstanceAsync () { return m_ProviderOperation_DeleteInstanceAsync ; }
	UINT64 Get_ProviderOperation_CreateInstanceEnumAsync () { return m_ProviderOperation_CreateInstanceEnumAsync ; }
	UINT64 Get_ProviderOperation_ExecQueryAsync () { return m_ProviderOperation_ExecQueryAsync ; }
	UINT64 Get_ProviderOperation_ExecNotificationQueryAsync () { return m_ProviderOperation_ExecNotificationQueryAsync ; }
	UINT64 Get_ProviderOperation_ExecMethodAsync () { return m_ProviderOperation_ExecMethodAsync ; }

	UINT64 Get_ProviderOperation_Begin () { return m_ProviderOperation_Begin ; }
	UINT64 Get_ProviderOperation_Rollback () { return m_ProviderOperation_Rollback ; }
	UINT64 Get_ProviderOperation_Commit () { return m_ProviderOperation_Commit ; }
	UINT64 Get_ProviderOperation_QueryState () { return m_ProviderOperation_QueryState ; }

	UINT64 Get_ProviderOperation_QueryInstances () { return m_ProviderOperation_QueryInstances ; }
	UINT64 Get_ProviderOperation_CreateRefresher () { return m_ProviderOperation_CreateRefresher ; }
	UINT64 Get_ProviderOperation_CreateRefreshableObject () { return m_ProviderOperation_CreateRefreshableObject ; }
	UINT64 Get_ProviderOperation_StopRefreshing () { return m_ProviderOperation_StopRefreshing ; }
	UINT64 Get_ProviderOperation_CreateRefreshableEnum () { return m_ProviderOperation_CreateRefreshableEnum ; }
	UINT64 Get_ProviderOperation_GetObjects () { return m_ProviderOperation_GetObjects ; }

	UINT64 Get_ProviderOperation_GetProperty () { return m_ProviderOperation_GetProperty ; }
	UINT64 Get_ProviderOperation_PutProperty () { return m_ProviderOperation_PutProperty ; }

	UINT64 Get_ProviderOperation_ProvideEvents () { return m_ProviderOperation_ProvideEvents ; }
	UINT64 Get_ProviderOperation_NewQuery () { return m_ProviderOperation_NewQuery ; }
	UINT64 Get_ProviderOperation_CancelQuery () { return m_ProviderOperation_CancelQuery ; }
	UINT64 Get_ProviderOperation_AccessCheck () { return m_ProviderOperation_AccessCheck ; }
	UINT64 Get_ProviderOperation_SetRegistrationObject () { return m_ProviderOperation_SetRegistrationObject ; }
	UINT64 Get_ProviderOperation_FindConsumer () { return m_ProviderOperation_FindConsumer ; }
	UINT64 Get_ProviderOperation_ValidateSubscription () { return m_ProviderOperation_ValidateSubscription ; }

public:

	CInterceptor_IWbemDecoupledProvider ( 

		WmiAllocator &a_Allocator ,
		IUnknown *a_ServerSideUnknown , 
		IWbemServices *a_CoreStub ,
		CWbemGlobal_IWbemSyncProviderController *a_Controller ,
		IWbemContext *a_InitializationContext ,
		CServerObject_ProviderRegistrationV1 &a_Registration ,
		GUID &a_Guid 
	) ;

    ~CInterceptor_IWbemDecoupledProvider () ;

public:

	//Non-delegating object IUnknown

    STDMETHODIMP QueryInterface ( REFIID , LPVOID FAR * ) ;
    STDMETHODIMP_( ULONG ) AddRef () ;
    STDMETHODIMP_( ULONG ) Release () ;

    /* IWbemServices methods */

    HRESULT STDMETHODCALLTYPE OpenNamespace ( 

        const BSTR a_Namespace ,
        long a_Flags ,
        IWbemContext *a_Context ,
        IWbemServices **a_Service ,
        IWbemCallResult **a_CallResult
	) ;
    
    HRESULT STDMETHODCALLTYPE CancelAsyncCall ( 

        IWbemObjectSink *a_Sink
	) ;
    
    HRESULT STDMETHODCALLTYPE QueryObjectSink ( 

        long a_Flags ,
        IWbemObjectSink **a_Sink
	) ;
    
    HRESULT STDMETHODCALLTYPE GetObject ( 

		const BSTR a_ObjectPath ,
        long a_Flags ,
        IWbemContext *a_Context ,
        IWbemClassObject **ppObject ,
        IWbemCallResult **a_CallResult
	) ;
    
    HRESULT STDMETHODCALLTYPE GetObjectAsync (
        
		const BSTR a_ObjectPath ,
        long a_Flags ,
        IWbemContext *a_Context ,
        IWbemObjectSink *a_Sink
	) ;

    HRESULT STDMETHODCALLTYPE PutClass ( 

        IWbemClassObject *a_Object ,
        long a_Flags ,
        IWbemContext *a_Context ,
        IWbemCallResult **a_CallResult
	) ;
    
    HRESULT STDMETHODCALLTYPE PutClassAsync ( 

        IWbemClassObject *a_Object ,
        long a_Flags ,
        IWbemContext *a_Context ,
        IWbemObjectSink *a_Sink
	) ;
    
    HRESULT STDMETHODCALLTYPE DeleteClass ( 

        const BSTR a_Class ,
        long a_Flags ,
        IWbemContext *a_Context ,
        IWbemCallResult **a_CallResult
	) ;
    
    HRESULT STDMETHODCALLTYPE DeleteClassAsync ( 

        const BSTR a_Class ,
        long a_Flags ,
        IWbemContext *a_Context ,
        IWbemObjectSink *a_Sink
	) ;
    
    HRESULT STDMETHODCALLTYPE CreateClassEnum ( 

        const BSTR a_Superclass ,
        long a_Flags ,
        IWbemContext *a_Context ,
        IEnumWbemClassObject **a_Enum
	) ;
    
    HRESULT STDMETHODCALLTYPE CreateClassEnumAsync ( 

		const BSTR a_Superclass ,
		long a_Flags ,
		IWbemContext *a_Context ,
		IWbemObjectSink *a_Sink
	) ;
    
    HRESULT STDMETHODCALLTYPE PutInstance (

		IWbemClassObject *a_Instance ,
		long a_Flags , 
		IWbemContext *a_Context ,
		IWbemCallResult **a_CallResult
	) ;
    
    HRESULT STDMETHODCALLTYPE PutInstanceAsync (

		IWbemClassObject *a_Instance ,
		long a_Flags ,
		IWbemContext *a_Context ,
		IWbemObjectSink *a_Sink 
	) ;
    
    HRESULT STDMETHODCALLTYPE DeleteInstance ( 

		const BSTR a_ObjectPath ,
		long a_Flags ,
		IWbemContext *a_Context ,
		IWbemCallResult **a_CallResult
	) ;
    
    HRESULT STDMETHODCALLTYPE DeleteInstanceAsync ( 

		const BSTR a_ObjectPath,
		long a_Flags,
		IWbemContext *a_Context ,
		IWbemObjectSink *a_Sink
	) ;
    
    HRESULT STDMETHODCALLTYPE CreateInstanceEnum (

		const BSTR a_Class ,
		long a_Flags ,
		IWbemContext *a_Context ,
		IEnumWbemClassObject **a_Enum
	) ;
    
    HRESULT STDMETHODCALLTYPE CreateInstanceEnumAsync (

		const BSTR a_Class ,
		long a_Flags ,
		IWbemContext *a_Context ,
		IWbemObjectSink *a_Sink
	) ;
    
    HRESULT STDMETHODCALLTYPE ExecQuery ( 

		const BSTR a_QueryLanguage,
		const BSTR a_Query,
		long a_Flags ,
		IWbemContext *a_Context ,
		IEnumWbemClassObject **a_Enum
	) ;
    
    HRESULT STDMETHODCALLTYPE ExecQueryAsync (

		const BSTR a_QueryLanguage ,
		const BSTR a_Query ,
		long a_Flags ,
		IWbemContext *a_Context ,
		IWbemObjectSink *a_Sink
	) ;
    
    HRESULT STDMETHODCALLTYPE ExecNotificationQuery (

		const BSTR a_QueryLanguage ,
		const BSTR a_Query ,
		long a_Flags ,
		IWbemContext *a_Context ,
		IEnumWbemClassObject **a_Enum
	) ;
    
    HRESULT STDMETHODCALLTYPE ExecNotificationQueryAsync ( 

        const BSTR a_QueryLanguage ,
        const BSTR a_Query ,
        long a_Flags ,
        IWbemContext *a_Context ,
        IWbemObjectSink *a_Sink
	) ;
    
    HRESULT STDMETHODCALLTYPE ExecMethod (

        const BSTR a_ObjectPath ,
        const BSTR a_MethodName ,
        long a_Flags ,
        IWbemContext *a_Context ,
        IWbemClassObject *a_InParams ,
        IWbemClassObject **a_OutParams ,
        IWbemCallResult **a_CallResult
	) ;
    
    HRESULT STDMETHODCALLTYPE ExecMethodAsync ( 

		const BSTR a_ObjectPath ,
		const BSTR a_MethodName ,
		long a_Flags ,
		IWbemContext *a_Context ,
		IWbemClassObject *a_InParams ,
		IWbemObjectSink *a_Sink
	) ;

	/* IWbemPropertyProvider */

    HRESULT STDMETHODCALLTYPE GetProperty (

        long a_Flags ,
        const BSTR a_Locale ,
        const BSTR a_ClassMapping ,
        const BSTR a_InstanceMapping ,
        const BSTR a_PropertyMapping ,
        VARIANT *a_Value
	) ;
        
    HRESULT STDMETHODCALLTYPE PutProperty (

        long a_Flags ,
        const BSTR a_Locale ,
        const BSTR a_ClassMapping ,
        const BSTR a_InstanceMapping ,
        const BSTR a_PropertyMapping ,
        const VARIANT *a_Value
	) ;

	/* IWbemEventProvider */

	HRESULT STDMETHODCALLTYPE ProvideEvents (

		IWbemObjectSink *a_Sink ,
		long a_Flags
	) ;

	/* IWbemEventProviderQuerySink */

	HRESULT STDMETHODCALLTYPE NewQuery (

		unsigned long a_Id ,
		WBEM_WSTR a_QueryLanguage ,
		WBEM_WSTR a_Query
	);

	HRESULT STDMETHODCALLTYPE CancelQuery (

		unsigned long a_Id
	) ;

	/* IWbemEventProviderSecurity */

	HRESULT STDMETHODCALLTYPE AccessCheck (

		WBEM_CWSTR a_QueryLanguage ,
		WBEM_CWSTR a_Query ,
		long a_SidLength ,
		const BYTE *a_Sid
	) ;

	/* IWbemProviderIdentity */

	HRESULT STDMETHODCALLTYPE SetRegistrationObject (

		long a_Flags ,
		IWbemClassObject *a_ProviderRegistration
	) ;

	/* IWbemEventConsumerProvider */

	HRESULT STDMETHODCALLTYPE FindConsumer (

		IWbemClassObject *a_LogicalConsumer ,
		IWbemUnboundObjectSink **a_Consumer
	);

	/* IWbemEventConsumerProviderEx */

	HRESULT STDMETHODCALLTYPE ValidateSubscription (

		IWbemClassObject *a_LogicalConsumer
	) ;

	/* IWbemUnboundObjectSink */

	HRESULT STDMETHODCALLTYPE IndicateToConsumer (

		IWbemClassObject *a_LogicalConsumer ,
		long a_ObjectCount ,
		IWbemClassObject **a_Objects
	) ;

	/* IWbemProviderInit methods */

	HRESULT STDMETHODCALLTYPE Initialize (

		LPWSTR a_User ,
		LONG a_Flags ,
		LPWSTR a_Namespace ,
		LPWSTR a_Locale ,
		IWbemServices *a_CoreService ,
		IWbemContext *a_Context ,
		IWbemProviderInitSink *a_Sink
	) ;
    
	HRESULT STDMETHODCALLTYPE Initialize (

		LONG a_Flags ,
		IWbemContext *a_Context ,
		GUID *a_TransactionIdentifier,
		LPCWSTR a_User ,
		LPCWSTR a_Locale ,
		LPCWSTR a_Namespace ,
		IWbemServices *a_Repository ,
		IWbemServices *a_Service ,
		IWbemProviderInitSink *a_Sink
	) ;

	HRESULT STDMETHODCALLTYPE WaitProvider ( IWbemContext *a_Context , ULONG a_Timeout ) ;

	HRESULT STDMETHODCALLTYPE GetInitializeResult () 
	{
		return m_InitializeResult ;
	}

	HRESULT STDMETHODCALLTYPE GetHosting ( ULONG *a_Value )
	{
		return WBEM_E_NOT_AVAILABLE ;
	}

	HRESULT STDMETHODCALLTYPE GetHostingGroup ( BSTR *a_Value )
	{
		return WBEM_E_NOT_AVAILABLE ;
	}

	HRESULT STDMETHODCALLTYPE IsInternal ( BOOL *a_Value )
	{
		return WBEM_E_NOT_AVAILABLE ;
	}

	HRESULT STDMETHODCALLTYPE IsPerUserInitialization ( BOOL *a_Value )
	{
		return WBEM_E_NOT_AVAILABLE ;
	}

	HRESULT STDMETHODCALLTYPE IsPerLocaleInitialization ( BOOL *a_Value )
	{
		return WBEM_E_NOT_AVAILABLE ;
	}

	HRESULT STDMETHODCALLTYPE AbnormalShutdown () ;

	// IWmi_UnInitialize members

	HRESULT STDMETHODCALLTYPE Shutdown (

		LONG a_Flags ,
		ULONG a_MaxMilliSeconds ,
		IWbemContext *a_Context
	) ; 
} ;

#endif // _Server_Interceptor_IWbemServices_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\winmgmt\provsubsys\server\include\statask.h ===
/*++

Copyright (C) 1996-2001 Microsoft Corporation

Module Name:

	ProvFact.h

Abstract:


History:

--*/

#ifndef _Server_StaTask_H
#define _Server_StaTask_H

#include <Thread.h>
#include "ProvRegInfo.h"

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

class StaTask_Create : public WmiTask < ULONG > 
{
private:

	CServerObject_StaThread &m_Thread ;

	HRESULT m_Result ;

	LPWSTR m_Scope ;
	LPWSTR m_Namespace ;

	LPSTREAM m_ContextStream ;
	LPSTREAM m_RepositoryStream ;
	LPSTREAM m_ProviderStream ;

protected:

public:	/* Internal */

    StaTask_Create (

		WmiAllocator & a_Allocator , 
		CServerObject_StaThread &a_Thread ,
		LPCWSTR a_Scope ,
		LPCWSTR a_Namespace 
	) ;

    ~StaTask_Create () ;

	HRESULT UnMarshalContext () ;

	HRESULT MarshalContext (

		IWbemContext *a_Context ,
		IWbemServices *a_Repository
	) ;

	HRESULT MarshalOutgoing ( IUnknown *a_ProviderService ) ;

	HRESULT UnMarshalOutgoing () ;

	WmiStatusCode Process ( WmiThread <ULONG> &a_Thread ) ;

	HRESULT GetResultCode () { return m_Result ; }
};

#endif // _Server_StaTask_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\winmgmt\provsubsys\server\include\provwsvs.h ===
/*++

Copyright (C) 1996-2001 Microsoft Corporation

Module Name:

	ProvResv.H

Abstract:


History:

--*/

#ifndef _Server_Interceptor_IWbemServices_Stub_H
#define _Server_Interceptor_IWbemServices_Stub_H

#define ProxyIndex_Proxy_IWbemServices					0
#define ProxyIndex_Proxy_IWbemRefreshingServices		1
#define ProxyIndex_Proxy_Internal_IWbemServices			2
#define ProxyIndex_Proxy_Size							3

#define ProxyIndex_EnumProxy_IEnumWbemClassObject			0
#define ProxyIndex_EnumProxy_Internal_IEnumWbemClassObject	1
#define ProxyIndex_EnumProxy_Size							2

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

class CInterceptor_IWbemServices_Interceptor :	public IWbemServices , 
												public IWbemRefreshingServices ,
												public IWbemShutdown
{
private:

	LONG m_ReferenceCount ;         //Object reference count

	LONG m_GateClosed ;
	LONG m_InProgress ;

	CriticalSection m_CriticalSection ;

	WmiAllocator &m_Allocator ;

	IWbemServices *m_Core_IWbemServices ;
	IWbemRefreshingServices *m_Core_IWbemRefreshingServices ;

public:

	CInterceptor_IWbemServices_Interceptor ( 

		WmiAllocator &a_Allocator , 
		IWbemServices *a_Service
	) ;

    ~CInterceptor_IWbemServices_Interceptor () ;

public:

	//Non-delegating object IUnknown

    STDMETHODIMP QueryInterface ( REFIID , LPVOID FAR * ) ;
    STDMETHODIMP_( ULONG ) AddRef () ;
    STDMETHODIMP_( ULONG ) Release () ;

    /* IWbemServices methods */

    HRESULT STDMETHODCALLTYPE OpenNamespace ( 

        const BSTR a_Namespace ,
        long a_Flags ,
        IWbemContext *a_Context ,
        IWbemServices **a_Service ,
        IWbemCallResult **a_CallResult
	) ;
    
    HRESULT STDMETHODCALLTYPE CancelAsyncCall ( 

        IWbemObjectSink *a_Sink
	) ;
    
    HRESULT STDMETHODCALLTYPE QueryObjectSink ( 

        long a_Flags ,
        IWbemObjectSink **a_Sink
	) ;
    
    HRESULT STDMETHODCALLTYPE GetObject ( 

		const BSTR a_ObjectPath ,
        long a_Flags ,
        IWbemContext *a_Context ,
        IWbemClassObject **ppObject ,
        IWbemCallResult **a_CallResult
	) ;
    
    HRESULT STDMETHODCALLTYPE GetObjectAsync (
        
		const BSTR a_ObjectPath ,
        long a_Flags ,
        IWbemContext *a_Context ,
        IWbemObjectSink *a_Sink
	) ;

    HRESULT STDMETHODCALLTYPE PutClass ( 

        IWbemClassObject *a_Object ,
        long a_Flags ,
        IWbemContext *a_Context ,
        IWbemCallResult **a_CallResult
	) ;
    
    HRESULT STDMETHODCALLTYPE PutClassAsync ( 

        IWbemClassObject *a_Object ,
        long a_Flags ,
        IWbemContext *a_Context ,
        IWbemObjectSink *a_Sink
	) ;
    
    HRESULT STDMETHODCALLTYPE DeleteClass ( 

        const BSTR a_Class ,
        long a_Flags ,
        IWbemContext *a_Context ,
        IWbemCallResult **a_CallResult
	) ;
    
    HRESULT STDMETHODCALLTYPE DeleteClassAsync ( 

        const BSTR a_Class ,
        long a_Flags ,
        IWbemContext *a_Context ,
        IWbemObjectSink *a_Sink
	) ;
    
    HRESULT STDMETHODCALLTYPE CreateClassEnum ( 

        const BSTR a_Superclass ,
        long a_Flags ,
        IWbemContext *a_Context ,
        IEnumWbemClassObject **a_Enum
	) ;
    
    HRESULT STDMETHODCALLTYPE CreateClassEnumAsync ( 

		const BSTR a_Superclass ,
		long a_Flags ,
		IWbemContext *a_Context ,
		IWbemObjectSink *a_Sink
	) ;
    
    HRESULT STDMETHODCALLTYPE PutInstance (

		IWbemClassObject *a_Instance ,
		long a_Flags , 
		IWbemContext *a_Context ,
		IWbemCallResult **a_CallResult
	) ;
    
    HRESULT STDMETHODCALLTYPE PutInstanceAsync (

		IWbemClassObject *a_Instance ,
		long a_Flags ,
		IWbemContext *a_Context ,
		IWbemObjectSink *a_Sink 
	) ;
    
    HRESULT STDMETHODCALLTYPE DeleteInstance ( 

		const BSTR a_ObjectPath ,
		long a_Flags ,
		IWbemContext *a_Context ,
		IWbemCallResult **a_CallResult
	) ;
    
    HRESULT STDMETHODCALLTYPE DeleteInstanceAsync ( 

		const BSTR a_ObjectPath,
		long a_Flags,
		IWbemContext *a_Context ,
		IWbemObjectSink *a_Sink
	) ;
    
    HRESULT STDMETHODCALLTYPE CreateInstanceEnum (

		const BSTR a_Class ,
		long a_Flags ,
		IWbemContext *a_Context ,
		IEnumWbemClassObject **a_Enum
	) ;
    
    HRESULT STDMETHODCALLTYPE CreateInstanceEnumAsync (

		const BSTR a_Class ,
		long a_Flags ,
		IWbemContext *a_Context ,
		IWbemObjectSink *a_Sink
	) ;
    
    HRESULT STDMETHODCALLTYPE ExecQuery ( 

		const BSTR a_QueryLanguage,
		const BSTR a_Query,
		long a_Flags ,
		IWbemContext *a_Context ,
		IEnumWbemClassObject **a_Enum
	) ;
    
    HRESULT STDMETHODCALLTYPE ExecQueryAsync (

		const BSTR a_QueryLanguage ,
		const BSTR a_Query ,
		long a_Flags ,
		IWbemContext *a_Context ,
		IWbemObjectSink *a_Sink
	) ;
    
    HRESULT STDMETHODCALLTYPE ExecNotificationQuery (

		const BSTR a_QueryLanguage ,
		const BSTR a_Query ,
		long a_Flags ,
		IWbemContext *a_Context ,
		IEnumWbemClassObject **a_Enum
	) ;
    
    HRESULT STDMETHODCALLTYPE ExecNotificationQueryAsync ( 

        const BSTR a_QueryLanguage ,
        const BSTR a_Query ,
        long a_Flags ,
        IWbemContext *a_Context ,
        IWbemObjectSink *a_Sink
	) ;
    
    HRESULT STDMETHODCALLTYPE ExecMethod (

        const BSTR a_ObjectPath ,
        const BSTR a_MethodName ,
        long a_Flags ,
        IWbemContext *a_Context ,
        IWbemClassObject *a_InParams ,
        IWbemClassObject **a_OutParams ,
        IWbemCallResult **a_CallResult
	) ;
    
    HRESULT STDMETHODCALLTYPE ExecMethodAsync ( 

		const BSTR a_ObjectPath ,
		const BSTR a_MethodName ,
		long a_Flags ,
		IWbemContext *a_Context ,
		IWbemClassObject *a_InParams ,
		IWbemObjectSink *a_Sink
	) ;

    HRESULT STDMETHODCALLTYPE AddObjectToRefresher (

		WBEM_REFRESHER_ID *a_RefresherId ,
		LPCWSTR a_Path,
		long a_Flags ,
		IWbemContext *a_Context,
		DWORD a_ClientRefresherVersion ,
		WBEM_REFRESH_INFO *a_Information ,
		DWORD *a_ServerRefresherVersion
	) ;

    HRESULT STDMETHODCALLTYPE AddObjectToRefresherByTemplate (

		WBEM_REFRESHER_ID *a_RefresherId ,
		IWbemClassObject *a_Template ,
		long a_Flags ,
		IWbemContext *a_Context ,
		DWORD a_ClientRefresherVersion ,
		WBEM_REFRESH_INFO *a_Information ,
		DWORD *a_ServerRefresherVersion
	) ;

    HRESULT STDMETHODCALLTYPE AddEnumToRefresher(

		WBEM_REFRESHER_ID *a_RefresherId ,
		LPCWSTR a_Class ,
		long a_Flags ,
		IWbemContext *a_Context,
		DWORD a_ClientRefresherVersion ,
		WBEM_REFRESH_INFO *a_Information ,
		DWORD *a_ServerRefresherVersion
	) ;

    HRESULT STDMETHODCALLTYPE RemoveObjectFromRefresher (

		WBEM_REFRESHER_ID *a_RefresherId ,
		long a_Id ,
		long a_Flags ,
		DWORD a_ClientRefresherVersion ,
		DWORD *a_ServerRefresherVersion
	) ;

	HRESULT STDMETHODCALLTYPE GetRemoteRefresher (

		WBEM_REFRESHER_ID *a_RefresherId ,
		long a_Flags ,
		DWORD a_ClientRefresherVersion ,
		IWbemRemoteRefresher **a_RemoteRefresher ,
		GUID *a_Guid ,
		DWORD *a_ServerRefresherVersion
	) ;

    HRESULT STDMETHODCALLTYPE ReconnectRemoteRefresher (

		WBEM_REFRESHER_ID *a_RefresherId,
		long a_Flags,
		long a_NumberOfObjects,
		DWORD a_ClientRefresherVersion ,
		WBEM_RECONNECT_INFO *a_ReconnectInformation ,
		WBEM_RECONNECT_RESULTS *a_ReconnectResults ,
		DWORD *a_ServerRefresherVersion
	) ;

	HRESULT ServiceInitialize () ;

	HRESULT STDMETHODCALLTYPE Shutdown (

		LONG a_Flags ,
		ULONG a_MaxMilliSeconds ,
		IWbemContext *a_Context
	) ; 
} ;

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

class CInterceptor_IWbemServices_RestrictingInterceptor :	public IWbemServices , 
															public IWbemRefreshingServices ,
															public IWbemShutdown
{
private:

	LONG m_ReferenceCount ;         //Object reference count

	LONG m_GateClosed ;
	LONG m_InProgress ;

	CriticalSection m_CriticalSection ;

	WmiAllocator &m_Allocator ;

	IWbemServices *m_Core_IWbemServices ;
	IWbemRefreshingServices *m_Core_IWbemRefreshingServices ;

	CServerObject_ProviderRegistrationV1 &m_Registration ;

	ProxyContainer m_ProxyContainer ;

private:

	HRESULT Begin_IWbemServices (

		BOOL &a_Impersonating ,
		IUnknown *&a_OldContext ,
		IServerSecurity *&a_OldSecurity ,
		BOOL &a_IsProxy ,
		IWbemServices *&a_Interface ,
		BOOL &a_Revert ,
		IUnknown *&a_Proxy ,
		IWbemContext *a_Context = NULL
	) ;

	HRESULT End_IWbemServices (

		BOOL a_Impersonating ,
		IUnknown *a_OldContext ,
		IServerSecurity *a_OldSecurity ,
		BOOL a_IsProxy ,
		IWbemServices *a_Interface ,
		BOOL a_Revert ,
		IUnknown *a_Proxy
	) ;

	HRESULT Begin_IWbemRefreshingServices (

		BOOL &a_Impersonating ,
		IUnknown *&a_OldContext ,
		IServerSecurity *&a_OldSecurity ,
		BOOL &a_IsProxy ,
		IWbemRefreshingServices *&a_Interface ,
		BOOL &a_Revert ,
		IUnknown *&a_Proxy ,
		IWbemContext *a_Context = NULL
	) ;

	HRESULT End_IWbemRefreshingServices (

		BOOL a_Impersonating ,
		IUnknown *a_OldContext ,
		IServerSecurity *a_OldSecurity ,
		BOOL a_IsProxy ,
		IWbemRefreshingServices *a_Interface ,
		BOOL a_Revert ,
		IUnknown *a_Proxy
	) ;

public:

	CInterceptor_IWbemServices_RestrictingInterceptor ( 

		WmiAllocator &a_Allocator , 
		IWbemServices *a_Service ,
		CServerObject_ProviderRegistrationV1 &a_Registration
	) ;

    ~CInterceptor_IWbemServices_RestrictingInterceptor () ;

public:

	//Non-delegating object IUnknown

    STDMETHODIMP QueryInterface ( REFIID , LPVOID FAR * ) ;
    STDMETHODIMP_( ULONG ) AddRef () ;
    STDMETHODIMP_( ULONG ) Release () ;

    /* IWbemServices methods */

    HRESULT STDMETHODCALLTYPE OpenNamespace ( 

        const BSTR a_Namespace ,
        long a_Flags ,
        IWbemContext *a_Context ,
        IWbemServices **a_Service ,
        IWbemCallResult **a_CallResult
	) ;
    
    HRESULT STDMETHODCALLTYPE CancelAsyncCall ( 

        IWbemObjectSink *a_Sink
	) ;
    
    HRESULT STDMETHODCALLTYPE QueryObjectSink ( 

        long a_Flags ,
        IWbemObjectSink **a_Sink
	) ;
    
    HRESULT STDMETHODCALLTYPE GetObject ( 

		const BSTR a_ObjectPath ,
        long a_Flags ,
        IWbemContext *a_Context ,
        IWbemClassObject **ppObject ,
        IWbemCallResult **a_CallResult
	) ;
    
    HRESULT STDMETHODCALLTYPE GetObjectAsync (
        
		const BSTR a_ObjectPath ,
        long a_Flags ,
        IWbemContext *a_Context ,
        IWbemObjectSink *a_Sink
	) ;

    HRESULT STDMETHODCALLTYPE PutClass ( 

        IWbemClassObject *a_Object ,
        long a_Flags ,
        IWbemContext *a_Context ,
        IWbemCallResult **a_CallResult
	) ;
    
    HRESULT STDMETHODCALLTYPE PutClassAsync ( 

        IWbemClassObject *a_Object ,
        long a_Flags ,
        IWbemContext *a_Context ,
        IWbemObjectSink *a_Sink
	) ;
    
    HRESULT STDMETHODCALLTYPE DeleteClass ( 

        const BSTR a_Class ,
        long a_Flags ,
        IWbemContext *a_Context ,
        IWbemCallResult **a_CallResult
	) ;
    
    HRESULT STDMETHODCALLTYPE DeleteClassAsync ( 

        const BSTR a_Class ,
        long a_Flags ,
        IWbemContext *a_Context ,
        IWbemObjectSink *a_Sink
	) ;
    
    HRESULT STDMETHODCALLTYPE CreateClassEnum ( 

        const BSTR a_Superclass ,
        long a_Flags ,
        IWbemContext *a_Context ,
        IEnumWbemClassObject **a_Enum
	) ;
    
    HRESULT STDMETHODCALLTYPE CreateClassEnumAsync ( 

		const BSTR a_Superclass ,
		long a_Flags ,
		IWbemContext *a_Context ,
		IWbemObjectSink *a_Sink
	) ;
    
    HRESULT STDMETHODCALLTYPE PutInstance (

		IWbemClassObject *a_Instance ,
		long a_Flags , 
		IWbemContext *a_Context ,
		IWbemCallResult **a_CallResult
	) ;
    
    HRESULT STDMETHODCALLTYPE PutInstanceAsync (

		IWbemClassObject *a_Instance ,
		long a_Flags ,
		IWbemContext *a_Context ,
		IWbemObjectSink *a_Sink 
	) ;
    
    HRESULT STDMETHODCALLTYPE DeleteInstance ( 

		const BSTR a_ObjectPath ,
		long a_Flags ,
		IWbemContext *a_Context ,
		IWbemCallResult **a_CallResult
	) ;
    
    HRESULT STDMETHODCALLTYPE DeleteInstanceAsync ( 

		const BSTR a_ObjectPath,
		long a_Flags,
		IWbemContext *a_Context ,
		IWbemObjectSink *a_Sink
	) ;
    
    HRESULT STDMETHODCALLTYPE CreateInstanceEnum (

		const BSTR a_Class ,
		long a_Flags ,
		IWbemContext *a_Context ,
		IEnumWbemClassObject **a_Enum
	) ;
    
    HRESULT STDMETHODCALLTYPE CreateInstanceEnumAsync (

		const BSTR a_Class ,
		long a_Flags ,
		IWbemContext *a_Context ,
		IWbemObjectSink *a_Sink
	) ;
    
    HRESULT STDMETHODCALLTYPE ExecQuery ( 

		const BSTR a_QueryLanguage,
		const BSTR a_Query,
		long a_Flags ,
		IWbemContext *a_Context ,
		IEnumWbemClassObject **a_Enum
	) ;
    
    HRESULT STDMETHODCALLTYPE ExecQueryAsync (

		const BSTR a_QueryLanguage ,
		const BSTR a_Query ,
		long a_Flags ,
		IWbemContext *a_Context ,
		IWbemObjectSink *a_Sink
	) ;
    
    HRESULT STDMETHODCALLTYPE ExecNotificationQuery (

		const BSTR a_QueryLanguage ,
		const BSTR a_Query ,
		long a_Flags ,
		IWbemContext *a_Context ,
		IEnumWbemClassObject **a_Enum
	) ;
    
    HRESULT STDMETHODCALLTYPE ExecNotificationQueryAsync ( 

        const BSTR a_QueryLanguage ,
        const BSTR a_Query ,
        long a_Flags ,
        IWbemContext *a_Context ,
        IWbemObjectSink *a_Sink
	) ;
    
    HRESULT STDMETHODCALLTYPE ExecMethod (

        const BSTR a_ObjectPath ,
        const BSTR a_MethodName ,
        long a_Flags ,
        IWbemContext *a_Context ,
        IWbemClassObject *a_InParams ,
        IWbemClassObject **a_OutParams ,
        IWbemCallResult **a_CallResult
	) ;
    
    HRESULT STDMETHODCALLTYPE ExecMethodAsync ( 

		const BSTR a_ObjectPath ,
		const BSTR a_MethodName ,
		long a_Flags ,
		IWbemContext *a_Context ,
		IWbemClassObject *a_InParams ,
		IWbemObjectSink *a_Sink
	) ;

    HRESULT STDMETHODCALLTYPE AddObjectToRefresher (

		WBEM_REFRESHER_ID *a_RefresherId ,
		LPCWSTR a_Path,
		long a_Flags ,
		IWbemContext *a_Context,
		DWORD a_ClientRefresherVersion ,
		WBEM_REFRESH_INFO *a_Information ,
		DWORD *a_ServerRefresherVersion
	) ;

    HRESULT STDMETHODCALLTYPE AddObjectToRefresherByTemplate (

		WBEM_REFRESHER_ID *a_RefresherId ,
		IWbemClassObject *a_Template ,
		long a_Flags ,
		IWbemContext *a_Context ,
		DWORD a_ClientRefresherVersion ,
		WBEM_REFRESH_INFO *a_Information ,
		DWORD *a_ServerRefresherVersion
	) ;

    HRESULT STDMETHODCALLTYPE AddEnumToRefresher(

		WBEM_REFRESHER_ID *a_RefresherId ,
		LPCWSTR a_Class ,
		long a_Flags ,
		IWbemContext *a_Context,
		DWORD a_ClientRefresherVersion ,
		WBEM_REFRESH_INFO *a_Information ,
		DWORD *a_ServerRefresherVersion
	) ;

    HRESULT STDMETHODCALLTYPE RemoveObjectFromRefresher (

		WBEM_REFRESHER_ID *a_RefresherId ,
		long a_Id ,
		long a_Flags ,
		DWORD a_ClientRefresherVersion ,
		DWORD *a_ServerRefresherVersion
	) ;

	HRESULT STDMETHODCALLTYPE GetRemoteRefresher (

		WBEM_REFRESHER_ID *a_RefresherId ,
		long a_Flags ,
		DWORD a_ClientRefresherVersion ,
		IWbemRemoteRefresher **a_RemoteRefresher ,
		GUID *a_Guid ,
		DWORD *a_ServerRefresherVersion
	) ;

    HRESULT STDMETHODCALLTYPE ReconnectRemoteRefresher (

		WBEM_REFRESHER_ID *a_RefresherId,
		long a_Flags,
		long a_NumberOfObjects,
		DWORD a_ClientRefresherVersion ,
		WBEM_RECONNECT_INFO *a_ReconnectInformation ,
		WBEM_RECONNECT_RESULTS *a_ReconnectResults ,
		DWORD *a_ServerRefresherVersion
	) ;

	HRESULT ServiceInitialize () ;

	HRESULT STDMETHODCALLTYPE Shutdown (

		LONG a_Flags ,
		ULONG a_MaxMilliSeconds ,
		IWbemContext *a_Context
	) ; 
} ;

#ifdef INTERNAL_IDENTIFY

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

class CInterceptor_IEnumWbemClassObject_Stub :	public IEnumWbemClassObject , 
												public IWbemShutdown ,
												public Internal_IEnumWbemClassObject ,
												public VoidPointerContainerElement ,
												public CWbemGlobal_VoidPointerController 
{
private:

	LONG m_GateClosed ;
	LONG m_InProgress ;
	WmiAllocator &m_Allocator ;

	IEnumWbemClassObject *m_InterceptedEnum ;

protected:
public:

	CInterceptor_IEnumWbemClassObject_Stub (

		CWbemGlobal_VoidPointerController *a_Controller ,
		WmiAllocator &a_Allocator ,
		IEnumWbemClassObject *a_InterceptedEnum
	) ;

	~CInterceptor_IEnumWbemClassObject_Stub () ;

	HRESULT EnumInitialize () ;

	HRESULT Enqueue_IEnumWbemClassObject (

		IEnumWbemClassObject *a_Enum ,
		IEnumWbemClassObject *&a_Proxy
	) ;

public:

	//Non-delegating object IUnknown

    STDMETHODIMP QueryInterface ( REFIID , LPVOID FAR * ) ;
    STDMETHODIMP_( ULONG ) AddRef () ;
    STDMETHODIMP_( ULONG ) Release () ;

    HRESULT STDMETHODCALLTYPE Reset () ;

    HRESULT STDMETHODCALLTYPE Next (

		long a_Timeout ,
		ULONG a_Count ,
		IWbemClassObject **a_Objects ,
		ULONG *a_Returned
	) ;

    HRESULT STDMETHODCALLTYPE NextAsync (

		ULONG a_Count,
		IWbemObjectSink *a_Sink
	) ;

    HRESULT STDMETHODCALLTYPE Clone (

		IEnumWbemClassObject **a_Enum
	) ;

    HRESULT STDMETHODCALLTYPE Skip (

        long a_Timeout,
        ULONG a_Count
	) ;

    HRESULT STDMETHODCALLTYPE Internal_Reset (
	
		WmiInternalContext a_InternalContext
	) ;

    HRESULT STDMETHODCALLTYPE Internal_Next (

		WmiInternalContext a_InternalContext ,
		long a_Timeout ,
		ULONG a_Count ,
		IWbemClassObject **a_Objects ,
		ULONG *a_Returned
	) ;

    HRESULT STDMETHODCALLTYPE Internal_NextAsync (

		WmiInternalContext a_InternalContext ,
		ULONG a_Count,
		IWbemObjectSink *a_Sink
	) ;

    HRESULT STDMETHODCALLTYPE Internal_Clone (

		WmiInternalContext a_InternalContext ,
		IEnumWbemClassObject **a_Enum
	) ;

    HRESULT STDMETHODCALLTYPE Internal_Skip (

		WmiInternalContext a_InternalContext ,
        long a_Timeout,
        ULONG a_Count
	) ;

	HRESULT STDMETHODCALLTYPE Shutdown (

		LONG a_Flags ,
		ULONG a_MaxMilliSeconds ,
		IWbemContext *a_Context
	) ; 
} ;

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

class CInterceptor_IEnumWbemClassObject_Proxy :	public IEnumWbemClassObject , 
												public VoidPointerContainerElement ,
												public CWbemGlobal_VoidPointerController

{
private:

	LONG m_GateClosed ;
	LONG m_InProgress ;

	WmiAllocator &m_Allocator ;

	IEnumWbemClassObject *m_InterceptedEnum ;
	Internal_IEnumWbemClassObject *m_Internal_InterceptedEnum ;

	ProxyContainer m_ProxyContainer ;
	
protected:

	HRESULT Begin_IEnumWbemClassObject (

		DWORD a_ProcessIdentifier ,
		HANDLE &a_IdentifyToken ,
		BOOL &a_Impersonating ,
		IUnknown *&a_OldContext ,
		IServerSecurity *&a_OldSecurity ,
		BOOL &a_IsProxy ,
		IUnknown *&a_Interface ,
		BOOL &a_Revert ,
		IUnknown *&a_Proxy
	) ;

	HRESULT End_IEnumWbemClassObject (

		DWORD a_ProcessIdentifier ,
		HANDLE a_IdentifyToken ,
		BOOL a_Impersonating ,
		IUnknown *a_OldContext ,
		IServerSecurity *a_OldSecurity ,
		BOOL a_IsProxy ,
		IUnknown *a_Interface ,
		BOOL a_Revert ,
		IUnknown *a_Proxy
	) ;

	HRESULT Enqueue_IEnumWbemClassObject (

		IEnumWbemClassObject *a_Enum ,
		IEnumWbemClassObject *&a_Proxy
	) ;

public:

	CInterceptor_IEnumWbemClassObject_Proxy (

		CWbemGlobal_VoidPointerController *a_Controller ,
		WmiAllocator &a_Allocator ,
		IEnumWbemClassObject *a_InterceptedEnum
	) ;

	~CInterceptor_IEnumWbemClassObject_Proxy () ;

	virtual HRESULT EnumInitialize () ;

	//Non-delegating object IUnknown

    STDMETHODIMP QueryInterface ( REFIID , LPVOID FAR * ) ;
    STDMETHODIMP_( ULONG ) AddRef () ;
    STDMETHODIMP_( ULONG ) Release () ;

    HRESULT STDMETHODCALLTYPE Reset () ;

    HRESULT STDMETHODCALLTYPE Next (

		long a_Timeout ,
		ULONG a_Count ,
		IWbemClassObject **a_Objects ,
		ULONG *a_Returned
	) ;

    HRESULT STDMETHODCALLTYPE NextAsync (

		ULONG a_Count,
		IWbemObjectSink *a_Sink
	) ;

    HRESULT STDMETHODCALLTYPE Clone (

		IEnumWbemClassObject **a_Enum
	) ;

    HRESULT STDMETHODCALLTYPE Skip (

        long a_Timeout,
        ULONG a_Count
	) ;

    HRESULT STDMETHODCALLTYPE Internal_Reset (
	
		WmiInternalContext a_InternalContext
	) ;

    HRESULT STDMETHODCALLTYPE Internal_Next (

		WmiInternalContext a_InternalContext ,
		long a_Timeout ,
		ULONG a_Count ,
		IWbemClassObject **a_Objects ,
		ULONG *a_Returned
	) ;

    HRESULT STDMETHODCALLTYPE Internal_NextAsync (

		WmiInternalContext a_InternalContext ,
		ULONG a_Count,
		IWbemObjectSink *a_Sink
	) ;

    HRESULT STDMETHODCALLTYPE Internal_Clone (

		WmiInternalContext a_InternalContext ,
		IEnumWbemClassObject **a_Enum
	) ;

    HRESULT STDMETHODCALLTYPE Internal_Skip (

		WmiInternalContext a_InternalContext ,
        long a_Timeout,
        ULONG a_Count
	) ;

	HRESULT STDMETHODCALLTYPE Shutdown (

		LONG a_Flags ,
		ULONG a_MaxMilliSeconds ,
		IWbemContext *a_Context
	) ; 
} ;

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

class CInterceptor_IWbemServices_Proxy :	public IWbemServices , 
											public IWbemRefreshingServices ,
											public IWbemShutdown ,
											public VoidPointerContainerElement ,
											public CWbemGlobal_VoidPointerController
{
private:

	LONG m_GateClosed ;
	LONG m_InProgress ;

	CriticalSection m_CriticalSection ;

	WmiAllocator &m_Allocator ;

	CServerObject_ProviderRegistrationV1 &m_Registration ;

	IWbemServices *m_Core_IWbemServices ;
	IWbemRefreshingServices *m_Core_IWbemRefreshingServices ;

	Internal_IWbemServices *m_Core_Internal_IWbemServices ;

	ProxyContainer m_ProxyContainer ;

	HRESULT Begin_IWbemServices (

		DWORD a_ProcessIdentifier ,
		HANDLE &a_IdentifyToken ,
		BOOL &a_Impersonating ,
		IUnknown *&a_OldContext ,
		IServerSecurity *&a_OldSecurity ,
		BOOL &a_IsProxy ,
		IUnknown *&a_Interface ,
		BOOL &a_Revert ,
		IUnknown *&a_Proxy
	) ;

	HRESULT End_IWbemServices (

		DWORD a_ProcessIdentifier ,
		HANDLE a_IdentifyToken ,
		BOOL a_Impersonating ,
		IUnknown *a_OldContext ,
		IServerSecurity *a_OldSecurity ,
		BOOL a_IsProxy ,
		IUnknown *a_Interface ,
		BOOL a_Revert ,
		IUnknown *a_Proxy
	) ;

	HRESULT Begin_IWbemRefreshingServices (

		BOOL &a_Impersonating ,
		IUnknown *&a_OldContext ,
		IServerSecurity *&a_OldSecurity ,
		BOOL &a_IsProxy ,
		IWbemRefreshingServices *&a_Interface ,
		BOOL &a_Revert ,
		IUnknown *&a_Proxy ,
		IWbemContext *a_Context = NULL
	) ;

	HRESULT End_IWbemRefreshingServices (

		BOOL a_Impersonating ,
		IUnknown *a_OldContext ,
		IServerSecurity *a_OldSecurity ,
		BOOL a_IsProxy ,
		IWbemRefreshingServices *a_Interface ,
		BOOL a_Revert ,
		IUnknown *a_Proxy
	) ;

	HRESULT Enqueue_IWbemServices (

		IWbemServices *a_Service ,
		IWbemServices *&a_Proxy
	) ;

	HRESULT Enqueue_IEnumWbemClassObject (

		IEnumWbemClassObject *a_Enum ,
		IEnumWbemClassObject *&a_Proxy
	) ;

public:

	CInterceptor_IWbemServices_Proxy ( 

		CWbemGlobal_VoidPointerController *a_Controller ,
		WmiAllocator &a_Allocator , 
		IWbemServices *a_Service ,
		CServerObject_ProviderRegistrationV1 &a_Registration
	) ;

    ~CInterceptor_IWbemServices_Proxy () ;

public:

	//Non-delegating object IUnknown

    STDMETHODIMP QueryInterface ( REFIID , LPVOID FAR * ) ;
    STDMETHODIMP_( ULONG ) AddRef () ;
    STDMETHODIMP_( ULONG ) Release () ;

    /* IWbemServices methods */

    HRESULT STDMETHODCALLTYPE OpenNamespace ( 

        const BSTR a_Namespace ,
        long a_Flags ,
        IWbemContext *a_Context ,
        IWbemServices **a_Service ,
        IWbemCallResult **a_CallResult
	) ;
    
    HRESULT STDMETHODCALLTYPE CancelAsyncCall ( 

        IWbemObjectSink *a_Sink
	) ;
    
    HRESULT STDMETHODCALLTYPE QueryObjectSink ( 

        long a_Flags ,
        IWbemObjectSink **a_Sink
	) ;
    
    HRESULT STDMETHODCALLTYPE GetObject ( 

		const BSTR a_ObjectPath ,
        long a_Flags ,
        IWbemContext *a_Context ,
        IWbemClassObject **ppObject ,
        IWbemCallResult **a_CallResult
	) ;
    
    HRESULT STDMETHODCALLTYPE GetObjectAsync (
        
		const BSTR a_ObjectPath ,
        long a_Flags ,
        IWbemContext *a_Context ,
        IWbemObjectSink *a_Sink
	) ;

    HRESULT STDMETHODCALLTYPE PutClass ( 

        IWbemClassObject *a_Object ,
        long a_Flags ,
        IWbemContext *a_Context ,
        IWbemCallResult **a_CallResult
	) ;
    
    HRESULT STDMETHODCALLTYPE PutClassAsync ( 

        IWbemClassObject *a_Object ,
        long a_Flags ,
        IWbemContext *a_Context ,
        IWbemObjectSink *a_Sink
	) ;
    
    HRESULT STDMETHODCALLTYPE DeleteClass ( 

        const BSTR a_Class ,
        long a_Flags ,
        IWbemContext *a_Context ,
        IWbemCallResult **a_CallResult
	) ;
    
    HRESULT STDMETHODCALLTYPE DeleteClassAsync ( 

        const BSTR a_Class ,
        long a_Flags ,
        IWbemContext *a_Context ,
        IWbemObjectSink *a_Sink
	) ;
    
    HRESULT STDMETHODCALLTYPE CreateClassEnum ( 

        const BSTR a_Superclass ,
        long a_Flags ,
        IWbemContext *a_Context ,
        IEnumWbemClassObject **a_Enum
	) ;
    
    HRESULT STDMETHODCALLTYPE CreateClassEnumAsync ( 

		const BSTR a_Superclass ,
		long a_Flags ,
		IWbemContext *a_Context ,
		IWbemObjectSink *a_Sink
	) ;
    
    HRESULT STDMETHODCALLTYPE PutInstance (

		IWbemClassObject *a_Instance ,
		long a_Flags , 
		IWbemContext *a_Context ,
		IWbemCallResult **a_CallResult
	) ;
    
    HRESULT STDMETHODCALLTYPE PutInstanceAsync (

		IWbemClassObject *a_Instance ,
		long a_Flags ,
		IWbemContext *a_Context ,
		IWbemObjectSink *a_Sink 
	) ;
    
    HRESULT STDMETHODCALLTYPE DeleteInstance ( 

		const BSTR a_ObjectPath ,
		long a_Flags ,
		IWbemContext *a_Context ,
		IWbemCallResult **a_CallResult
	) ;
    
    HRESULT STDMETHODCALLTYPE DeleteInstanceAsync ( 

		const BSTR a_ObjectPath,
		long a_Flags,
		IWbemContext *a_Context ,
		IWbemObjectSink *a_Sink
	) ;
    
    HRESULT STDMETHODCALLTYPE CreateInstanceEnum (

		const BSTR a_Class ,
		long a_Flags ,
		IWbemContext *a_Context ,
		IEnumWbemClassObject **a_Enum
	) ;
    
    HRESULT STDMETHODCALLTYPE CreateInstanceEnumAsync (

		const BSTR a_Class ,
		long a_Flags ,
		IWbemContext *a_Context ,
		IWbemObjectSink *a_Sink
	) ;
    
    HRESULT STDMETHODCALLTYPE ExecQuery ( 

		const BSTR a_QueryLanguage,
		const BSTR a_Query,
		long a_Flags ,
		IWbemContext *a_Context ,
		IEnumWbemClassObject **a_Enum
	) ;
    
    HRESULT STDMETHODCALLTYPE ExecQueryAsync (

		const BSTR a_QueryLanguage ,
		const BSTR a_Query ,
		long a_Flags ,
		IWbemContext *a_Context ,
		IWbemObjectSink *a_Sink
	) ;
    
    HRESULT STDMETHODCALLTYPE ExecNotificationQuery (

		const BSTR a_QueryLanguage ,
		const BSTR a_Query ,
		long a_Flags ,
		IWbemContext *a_Context ,
		IEnumWbemClassObject **a_Enum
	) ;
    
    HRESULT STDMETHODCALLTYPE ExecNotificationQueryAsync ( 

        const BSTR a_QueryLanguage ,
        const BSTR a_Query ,
        long a_Flags ,
        IWbemContext *a_Context ,
        IWbemObjectSink *a_Sink
	) ;
    
    HRESULT STDMETHODCALLTYPE ExecMethod (

        const BSTR a_ObjectPath ,
        const BSTR a_MethodName ,
        long a_Flags ,
        IWbemContext *a_Context ,
        IWbemClassObject *a_InParams ,
        IWbemClassObject **a_OutParams ,
        IWbemCallResult **a_CallResult
	) ;
    
    HRESULT STDMETHODCALLTYPE ExecMethodAsync ( 

		const BSTR a_ObjectPath ,
		const BSTR a_MethodName ,
		long a_Flags ,
		IWbemContext *a_Context ,
		IWbemClassObject *a_InParams ,
		IWbemObjectSink *a_Sink
	) ;

    HRESULT STDMETHODCALLTYPE AddObjectToRefresher (

		WBEM_REFRESHER_ID *a_RefresherId ,
		LPCWSTR a_Path,
		long a_Flags ,
		IWbemContext *a_Context,
		DWORD a_ClientRefresherVersion ,
		WBEM_REFRESH_INFO *a_Information ,
		DWORD *a_ServerRefresherVersion
	) ;

    HRESULT STDMETHODCALLTYPE AddObjectToRefresherByTemplate (

		WBEM_REFRESHER_ID *a_RefresherId ,
		IWbemClassObject *a_Template ,
		long a_Flags ,
		IWbemContext *a_Context ,
		DWORD a_ClientRefresherVersion ,
		WBEM_REFRESH_INFO *a_Information ,
		DWORD *a_ServerRefresherVersion
	) ;

    HRESULT STDMETHODCALLTYPE AddEnumToRefresher(

		WBEM_REFRESHER_ID *a_RefresherId ,
		LPCWSTR a_Class ,
		long a_Flags ,
		IWbemContext *a_Context,
		DWORD a_ClientRefresherVersion ,
		WBEM_REFRESH_INFO *a_Information ,
		DWORD *a_ServerRefresherVersion
	) ;

    HRESULT STDMETHODCALLTYPE RemoveObjectFromRefresher (

		WBEM_REFRESHER_ID *a_RefresherId ,
		long a_Id ,
		long a_Flags ,
		DWORD a_ClientRefresherVersion ,
		DWORD *a_ServerRefresherVersion
	) ;

	HRESULT STDMETHODCALLTYPE GetRemoteRefresher (

		WBEM_REFRESHER_ID *a_RefresherId ,
		long a_Flags ,
		DWORD a_ClientRefresherVersion ,
		IWbemRemoteRefresher **a_RemoteRefresher ,
		GUID *a_Guid ,
		DWORD *a_ServerRefresherVersion
	) ;

    HRESULT STDMETHODCALLTYPE ReconnectRemoteRefresher (

		WBEM_REFRESHER_ID *a_RefresherId,
		long a_Flags,
		long a_NumberOfObjects,
		DWORD a_ClientRefresherVersion ,
		WBEM_RECONNECT_INFO *a_ReconnectInformation ,
		WBEM_RECONNECT_RESULTS *a_ReconnectResults ,
		DWORD *a_ServerRefresherVersion
	) ;

	HRESULT ServiceInitialize () ;

	HRESULT STDMETHODCALLTYPE Shutdown (

		LONG a_Flags ,
		ULONG a_MaxMilliSeconds ,
		IWbemContext *a_Context
	) ; 
} ;

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

class CInterceptor_IWbemServices_Stub : public IWbemServices , 
										public IWbemRefreshingServices ,
										public IWbemShutdown ,
										public Internal_IWbemServices ,
										public VoidPointerContainerElement ,
										public CWbemGlobal_VoidPointerController
{
private:

	LONG m_GateClosed ;
	LONG m_InProgress ;
	BOOL m_InterceptCallContext ;

	CriticalSection m_CriticalSection ;

	WmiAllocator &m_Allocator ;

	IWbemServices *m_Core_IWbemServices ;
	IWbemRefreshingServices *m_Core_IWbemRefreshingServices ;

	HRESULT Begin_IWbemServices (

		BOOL &a_Impersonating ,
		IUnknown *&a_OldContext ,
		IServerSecurity *&a_OldSecurity ,
		BOOL &a_IsProxy ,
		IWbemServices *&a_Interface ,
		BOOL &a_Revert ,
		IUnknown *&a_Proxy ,
		IWbemContext *a_Context = NULL
	) ;

	HRESULT End_IWbemServices (

		BOOL a_Impersonating ,
		IUnknown *a_OldContext ,
		IServerSecurity *a_OldSecurity ,
		BOOL a_IsProxy ,
		IWbemServices *a_Interface ,
		BOOL a_Revert ,
		IUnknown *a_Proxy
	) ;

	HRESULT Begin_IWbemRefreshingServices (

		BOOL &a_Impersonating ,
		IUnknown *&a_OldContext ,
		IServerSecurity *&a_OldSecurity ,
		BOOL &a_IsProxy ,
		IWbemRefreshingServices *&a_Interface ,
		BOOL &a_Revert ,
		IUnknown *&a_Proxy ,
		IWbemContext *a_Context = NULL
	) ;

	HRESULT End_IWbemRefreshingServices (

		BOOL a_Impersonating ,
		IUnknown *a_OldContext ,
		IServerSecurity *a_OldSecurity ,
		BOOL a_IsProxy ,
		IWbemRefreshingServices *a_Interface ,
		BOOL a_Revert ,
		IUnknown *a_Proxy
	) ;

	HRESULT Enqueue_IWbemServices (

		IWbemServices *a_Service ,
		IWbemServices *&a_Stub
	) ;

	HRESULT Enqueue_IEnumWbemClassObject (

		IEnumWbemClassObject *a_Enum ,
		IEnumWbemClassObject *&a_Stub
	) ;

public:

	CInterceptor_IWbemServices_Stub (

		CWbemGlobal_VoidPointerController *a_Controller ,
		WmiAllocator &a_Allocator , 
		IWbemServices *a_Service
	) ;

    ~CInterceptor_IWbemServices_Stub () ;

public:

	//Non-delegating object IUnknown

    STDMETHODIMP QueryInterface ( REFIID , LPVOID FAR * ) ;
    STDMETHODIMP_( ULONG ) AddRef () ;
    STDMETHODIMP_( ULONG ) Release () ;

    /* IWbemServices methods */

    HRESULT STDMETHODCALLTYPE OpenNamespace ( 

        const BSTR a_Namespace ,
        long a_Flags ,
        IWbemContext *a_Context ,
        IWbemServices **a_Service ,
        IWbemCallResult **a_CallResult
	) ;
    
    HRESULT STDMETHODCALLTYPE CancelAsyncCall ( 

        IWbemObjectSink *a_Sink
	) ;
    
    HRESULT STDMETHODCALLTYPE QueryObjectSink ( 

        long a_Flags ,
        IWbemObjectSink **a_Sink
	) ;
    
    HRESULT STDMETHODCALLTYPE GetObject ( 

		const BSTR a_ObjectPath ,
        long a_Flags ,
        IWbemContext *a_Context ,
        IWbemClassObject **ppObject ,
        IWbemCallResult **a_CallResult
	) ;
    
    HRESULT STDMETHODCALLTYPE GetObjectAsync (
        
		const BSTR a_ObjectPath ,
        long a_Flags ,
        IWbemContext *a_Context ,
        IWbemObjectSink *a_Sink
	) ;

    HRESULT STDMETHODCALLTYPE PutClass ( 

        IWbemClassObject *a_Object ,
        long a_Flags ,
        IWbemContext *a_Context ,
        IWbemCallResult **a_CallResult
	) ;
    
    HRESULT STDMETHODCALLTYPE PutClassAsync ( 

        IWbemClassObject *a_Object ,
        long a_Flags ,
        IWbemContext *a_Context ,
        IWbemObjectSink *a_Sink
	) ;
    
    HRESULT STDMETHODCALLTYPE DeleteClass ( 

        const BSTR a_Class ,
        long a_Flags ,
        IWbemContext *a_Context ,
        IWbemCallResult **a_CallResult
	) ;
    
    HRESULT STDMETHODCALLTYPE DeleteClassAsync ( 

        const BSTR a_Class ,
        long a_Flags ,
        IWbemContext *a_Context ,
        IWbemObjectSink *a_Sink
	) ;
    
    HRESULT STDMETHODCALLTYPE CreateClassEnum ( 

        const BSTR a_Superclass ,
        long a_Flags ,
        IWbemContext *a_Context ,
        IEnumWbemClassObject **a_Enum
	) ;
    
    HRESULT STDMETHODCALLTYPE CreateClassEnumAsync ( 

		const BSTR a_Superclass ,
		long a_Flags ,
		IWbemContext *a_Context ,
		IWbemObjectSink *a_Sink
	) ;
    
    HRESULT STDMETHODCALLTYPE PutInstance (

		IWbemClassObject *a_Instance ,
		long a_Flags , 
		IWbemContext *a_Context ,
		IWbemCallResult **a_CallResult
	) ;
    
    HRESULT STDMETHODCALLTYPE PutInstanceAsync (

		IWbemClassObject *a_Instance ,
		long a_Flags ,
		IWbemContext *a_Context ,
		IWbemObjectSink *a_Sink 
	) ;
    
    HRESULT STDMETHODCALLTYPE DeleteInstance ( 

		const BSTR a_ObjectPath ,
		long a_Flags ,
		IWbemContext *a_Context ,
		IWbemCallResult **a_CallResult
	) ;
    
    HRESULT STDMETHODCALLTYPE DeleteInstanceAsync ( 

		const BSTR a_ObjectPath,
		long a_Flags,
		IWbemContext *a_Context ,
		IWbemObjectSink *a_Sink
	) ;
    
    HRESULT STDMETHODCALLTYPE CreateInstanceEnum (

		const BSTR a_Class ,
		long a_Flags ,
		IWbemContext *a_Context ,
		IEnumWbemClassObject **a_Enum
	) ;
    
    HRESULT STDMETHODCALLTYPE CreateInstanceEnumAsync (

		const BSTR a_Class ,
		long a_Flags ,
		IWbemContext *a_Context ,
		IWbemObjectSink *a_Sink
	) ;
    
    HRESULT STDMETHODCALLTYPE ExecQuery ( 

		const BSTR a_QueryLanguage,
		const BSTR a_Query,
		long a_Flags ,
		IWbemContext *a_Context ,
		IEnumWbemClassObject **a_Enum
	) ;
    
    HRESULT STDMETHODCALLTYPE ExecQueryAsync (

		const BSTR a_QueryLanguage ,
		const BSTR a_Query ,
		long a_Flags ,
		IWbemContext *a_Context ,
		IWbemObjectSink *a_Sink
	) ;
    
    HRESULT STDMETHODCALLTYPE ExecNotificationQuery (

		const BSTR a_QueryLanguage ,
		const BSTR a_Query ,
		long a_Flags ,
		IWbemContext *a_Context ,
		IEnumWbemClassObject **a_Enum
	) ;
    
    HRESULT STDMETHODCALLTYPE ExecNotificationQueryAsync ( 

        const BSTR a_QueryLanguage ,
        const BSTR a_Query ,
        long a_Flags ,
        IWbemContext *a_Context ,
        IWbemObjectSink *a_Sink
	) ;
    
    HRESULT STDMETHODCALLTYPE ExecMethod (

        const BSTR a_ObjectPath ,
        const BSTR a_MethodName ,
        long a_Flags ,
        IWbemContext *a_Context ,
        IWbemClassObject *a_InParams ,
        IWbemClassObject **a_OutParams ,
        IWbemCallResult **a_CallResult
	) ;
    
    HRESULT STDMETHODCALLTYPE ExecMethodAsync ( 

		const BSTR a_ObjectPath ,
		const BSTR a_MethodName ,
		long a_Flags ,
		IWbemContext *a_Context ,
		IWbemClassObject *a_InParams ,
		IWbemObjectSink *a_Sink
	) ;

    HRESULT STDMETHODCALLTYPE AddObjectToRefresher (

		WBEM_REFRESHER_ID *a_RefresherId ,
		LPCWSTR a_Path,
		long a_Flags ,
		IWbemContext *a_Context,
		DWORD a_ClientRefresherVersion ,
		WBEM_REFRESH_INFO *a_Information ,
		DWORD *a_ServerRefresherVersion
	) ;

    HRESULT STDMETHODCALLTYPE AddObjectToRefresherByTemplate (

		WBEM_REFRESHER_ID *a_RefresherId ,
		IWbemClassObject *a_Template ,
		long a_Flags ,
		IWbemContext *a_Context ,
		DWORD a_ClientRefresherVersion ,
		WBEM_REFRESH_INFO *a_Information ,
		DWORD *a_ServerRefresherVersion
	) ;

    HRESULT STDMETHODCALLTYPE AddEnumToRefresher(

		WBEM_REFRESHER_ID *a_RefresherId ,
		LPCWSTR a_Class ,
		long a_Flags ,
		IWbemContext *a_Context,
		DWORD a_ClientRefresherVersion ,
		WBEM_REFRESH_INFO *a_Information ,
		DWORD *a_ServerRefresherVersion
	) ;

    HRESULT STDMETHODCALLTYPE RemoveObjectFromRefresher (

		WBEM_REFRESHER_ID *a_RefresherId ,
		long a_Id ,
		long a_Flags ,
		DWORD a_ClientRefresherVersion ,
		DWORD *a_ServerRefresherVersion
	) ;

	HRESULT STDMETHODCALLTYPE GetRemoteRefresher (

		WBEM_REFRESHER_ID *a_RefresherId ,
		long a_Flags ,
		DWORD a_ClientRefresherVersion ,
		IWbemRemoteRefresher **a_RemoteRefresher ,
		GUID *a_Guid ,
		DWORD *a_ServerRefresherVersion
	) ;

    HRESULT STDMETHODCALLTYPE ReconnectRemoteRefresher (

		WBEM_REFRESHER_ID *a_RefresherId,
		long a_Flags,
		long a_NumberOfObjects,
		DWORD a_ClientRefresherVersion ,
		WBEM_RECONNECT_INFO *a_ReconnectInformation ,
		WBEM_RECONNECT_RESULTS *a_ReconnectResults ,
		DWORD *a_ServerRefresherVersion
	) ;

	HRESULT ServiceInitialize () ;

	HRESULT STDMETHODCALLTYPE Shutdown (

		LONG a_Flags ,
		ULONG a_MaxMilliSeconds ,
		IWbemContext *a_Context
	) ; 

/* Internal_IWbemServices */
 
     HRESULT STDMETHODCALLTYPE Internal_OpenNamespace ( 

		WmiInternalContext a_InternalContext ,
        const BSTR a_Namespace ,
        long a_Flags ,
        IWbemContext *a_Context ,
        IWbemServices **a_Service ,
        IWbemCallResult **a_CallResult
	) ;
    
    HRESULT STDMETHODCALLTYPE Internal_CancelAsyncCall ( 

		WmiInternalContext a_InternalContext ,
        IWbemObjectSink *a_Sink
	) ;
    
    HRESULT STDMETHODCALLTYPE Internal_QueryObjectSink ( 

		WmiInternalContext a_InternalContext ,
        long a_Flags ,
        IWbemObjectSink **a_Sink
	) ;
    
    HRESULT STDMETHODCALLTYPE Internal_GetObject ( 

		WmiInternalContext a_InternalContext ,
		const BSTR a_ObjectPath ,
        long a_Flags ,
        IWbemContext *a_Context ,
        IWbemClassObject **ppObject ,
        IWbemCallResult **a_CallResult
	) ;
    
    HRESULT STDMETHODCALLTYPE Internal_GetObjectAsync (
        
		WmiInternalContext a_InternalContext ,
		const BSTR a_ObjectPath ,
        long a_Flags ,
        IWbemContext *a_Context ,
        IWbemObjectSink *a_Sink
	) ;

    HRESULT STDMETHODCALLTYPE Internal_PutClass ( 

		WmiInternalContext a_InternalContext ,
        IWbemClassObject *a_Object ,
        long a_Flags ,
        IWbemContext *a_Context ,
        IWbemCallResult **a_CallResult
	) ;
    
    HRESULT STDMETHODCALLTYPE Internal_PutClassAsync ( 

		WmiInternalContext a_InternalContext ,
        IWbemClassObject *a_Object ,
        long a_Flags ,
        IWbemContext *a_Context ,
        IWbemObjectSink *a_Sink
	) ;
    
    HRESULT STDMETHODCALLTYPE Internal_DeleteClass ( 

		WmiInternalContext a_InternalContext ,
        const BSTR a_Class ,
        long a_Flags ,
        IWbemContext *a_Context ,
        IWbemCallResult **a_CallResult
	) ;
    
    HRESULT STDMETHODCALLTYPE Internal_DeleteClassAsync ( 

		WmiInternalContext a_InternalContext ,
        const BSTR a_Class ,
        long a_Flags ,
        IWbemContext *a_Context ,
        IWbemObjectSink *a_Sink
	) ;
    
    HRESULT STDMETHODCALLTYPE Internal_CreateClassEnum ( 

		WmiInternalContext a_InternalContext ,
        const BSTR a_Superclass ,
        long a_Flags ,
        IWbemContext *a_Context ,
        IEnumWbemClassObject **a_Enum
	) ;
    
    HRESULT STDMETHODCALLTYPE Internal_CreateClassEnumAsync ( 

		WmiInternalContext a_InternalContext ,
		const BSTR a_Superclass ,
		long a_Flags ,
		IWbemContext *a_Context ,
		IWbemObjectSink *a_Sink
	) ;
    
    HRESULT STDMETHODCALLTYPE Internal_PutInstance (

		WmiInternalContext a_InternalContext ,
		IWbemClassObject *a_Instance ,
		long a_Flags , 
		IWbemContext *a_Context ,
		IWbemCallResult **a_CallResult
	) ;
    
    HRESULT STDMETHODCALLTYPE Internal_PutInstanceAsync (

		WmiInternalContext a_InternalContext ,
		IWbemClassObject *a_Instance ,
		long a_Flags ,
		IWbemContext *a_Context ,
		IWbemObjectSink *a_Sink 
	) ;
    
    HRESULT STDMETHODCALLTYPE Internal_DeleteInstance ( 

		WmiInternalContext a_InternalContext ,
		const BSTR a_ObjectPath ,
		long a_Flags ,
		IWbemContext *a_Context ,
		IWbemCallResult **a_CallResult
	) ;
    
    HRESULT STDMETHODCALLTYPE Internal_DeleteInstanceAsync ( 

		WmiInternalContext a_InternalContext ,
		const BSTR a_ObjectPath,
		long a_Flags,
		IWbemContext *a_Context ,
		IWbemObjectSink *a_Sink
	) ;
    
    HRESULT STDMETHODCALLTYPE Internal_CreateInstanceEnum (

		WmiInternalContext a_InternalContext ,
		const BSTR a_Class ,
		long a_Flags ,
		IWbemContext *a_Context ,
		IEnumWbemClassObject **a_Enum
	) ;
    
    HRESULT STDMETHODCALLTYPE Internal_CreateInstanceEnumAsync (

		WmiInternalContext a_InternalContext ,
		const BSTR a_Class ,
		long a_Flags ,
		IWbemContext *a_Context ,
		IWbemObjectSink *a_Sink
	) ;
    
    HRESULT STDMETHODCALLTYPE Internal_ExecQuery ( 

		WmiInternalContext a_InternalContext ,
		const BSTR a_QueryLanguage,
		const BSTR a_Query,
		long a_Flags ,
		IWbemContext *a_Context ,
		IEnumWbemClassObject **a_Enum
	) ;
    
    HRESULT STDMETHODCALLTYPE Internal_ExecQueryAsync (

		WmiInternalContext a_InternalContext ,
		const BSTR a_QueryLanguage ,
		const BSTR a_Query ,
		long a_Flags ,
		IWbemContext *a_Context ,
		IWbemObjectSink *a_Sink
	) ;
    
    HRESULT STDMETHODCALLTYPE Internal_ExecNotificationQuery (

		WmiInternalContext a_InternalContext ,
		const BSTR a_QueryLanguage ,
		const BSTR a_Query ,
		long a_Flags ,
		IWbemContext *a_Context ,
		IEnumWbemClassObject **a_Enum
	) ;
    
    HRESULT STDMETHODCALLTYPE Internal_ExecNotificationQueryAsync ( 

		WmiInternalContext a_InternalContext ,
        const BSTR a_QueryLanguage ,
        const BSTR a_Query ,
        long a_Flags ,
        IWbemContext *a_Context ,
        IWbemObjectSink *a_Sink
	) ;
    
    HRESULT STDMETHODCALLTYPE Internal_ExecMethod (

		WmiInternalContext a_InternalContext ,
        const BSTR a_ObjectPath ,
        const BSTR a_MethodName ,
        long a_Flags ,
        IWbemContext *a_Context ,
        IWbemClassObject *a_InParams ,
        IWbemClassObject **a_OutParams ,
        IWbemCallResult **a_CallResult
	) ;
    
    HRESULT STDMETHODCALLTYPE Internal_ExecMethodAsync ( 

		WmiInternalContext a_InternalContext ,
		const BSTR a_ObjectPath ,
		const BSTR a_MethodName ,
		long a_Flags ,
		IWbemContext *a_Context ,
		IWbemClassObject *a_InParams ,
		IWbemObjectSink *a_Sink
	) ;

} ;

#endif

#endif // _Server_Interceptor_IWbemServices_Stub_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\winmgmt\provsubsys\server\include\stathread.h ===
/*++

Copyright (C) 1996-2001 Microsoft Corporation

Module Name:

	ProvFact.h

Abstract:


History:

--*/

#ifndef _Server_StaThread_H
#define _Server_StaThread_H

#include <Thread.h>
#include "ProvRegInfo.h"

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

#define ProxyIndex_Sta_IWbemServices					0
#define ProxyIndex_Sta_IWbemEventProvider				1
#define ProxyIndex_Sta_IWbemEventProviderQuerySink		2
#define ProxyIndex_Sta_IWbemEventProviderSecurity		3
#define ProxyIndex_Sta_IWbemEventConsumerProvider		4
#define ProxyIndex_Sta_IWbemEventConsumerProviderEx		5
#define ProxyIndex_Sta_IWbemUnboundObjectSink			6

#define ProxyIndex_Sta_Size								7

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

class CServerObject_StaThread : public IWbemServices , 
								public IWbemEventProvider ,
								public IWbemEventProviderQuerySink ,
								public IWbemEventProviderSecurity ,
								public IWbemEventConsumerProviderEx ,
								public IWbemUnboundObjectSink ,
								public IWbemProviderInit , 
								public IWbemShutdown , 
								public WmiThread < ULONG > , 
								public CWbemGlobal_IWmiObjectSinkController 
{
private:

	WmiAllocator &m_Allocator ;

	LONG m_Flags ;
	IWbemContext *m_Context ;
	GUID *m_TransactionIdentifier ;
	LPWSTR m_User ;
	LPWSTR m_Locale ;
	LPWSTR m_Scope ;
	LPWSTR m_Namespace ;
	LPWSTR m_ProviderName ;
	IWbemPath *m_NamespacePath ;
	IWbemServices *m_Repository ;

	IUnknown *m_Provider_IUnknown ;
	IWbemServices *m_Provider_IWbemServices ;
	IWbemEventConsumerProvider *m_Provider_IWbemEventConsumerProvider ;
	IWbemEventConsumerProviderEx *m_Provider_IWbemEventConsumerProviderEx ;
	IWbemUnboundObjectSink *m_Provider_IWbemUnboundObjectSink ;
	IWbemEventProvider *m_Provider_IWbemEventProvider ;
	IWbemEventProviderQuerySink *m_Provider_IWbemEventProviderQuerySink ;
	IWbemEventProviderSecurity *m_Provider_IWbemEventProviderSecurity ;

	CServerObject_ProviderRegistrationV1 *m_Registration ;

	ProxyContainer m_ProxyContainer ;

protected:

public:	/* Internal */

    CServerObject_StaThread ( 

		WmiAllocator & a_Allocator,
		CServerObject_ProviderRegistrationV1& registration	
	) ;

    ~CServerObject_StaThread () ;

	WmiStatusCode Initialize_Callback () ;

	WmiStatusCode UnInitialize_Callback () ;

	void CallBackRelease () ;

	LPCWSTR Direct_GetProviderName () { return m_ProviderName ; }
	LPCWSTR Direct_GetLocale () { return m_Locale ; }
	LPCWSTR Direct_GetUser () { return m_User ; }
	GUID *Direct_GetTransactionIdentifier () { return m_TransactionIdentifier ; }
	IWbemContext *Direct_GetContext () { return m_Context ; }
	LPCWSTR Direct_GetNamespace () { return m_Namespace ; }
	IWbemPath *Direct_GetNamespacePath () { return m_NamespacePath ; }
	LPCWSTR Direct_GetScope () { return m_Scope ; }
	IWbemServices *Direct_GetRepository () { return m_Repository ; }
	IWbemServices *Direct_GetProviderService () { return m_Provider_IWbemServices ; }

	HRESULT SetProviderName ( wchar_t *a_ProviderName ) ;
	HRESULT SetContext ( IWbemContext *a_Context ) ;
	HRESULT SetScope ( LPCWSTR a_Scope ) ;
	HRESULT SetNamespace ( LPCWSTR a_Namespace ) ;
	HRESULT SetNamespacePath ( IWbemPath *a_NamespacePath ) ;
	HRESULT SetRepository ( IWbemServices *a_Repository ) ;
	HRESULT SetProviderService ( IUnknown *a_ProviderService ) ;

	HRESULT InitializeProvider (

		GUID *a_TransactionIdentifier ,
		LPCWSTR a_User ,
		LPCWSTR a_Locale ,
		LPCWSTR a_Namespace ,
		IWbemPath *a_NamespacePath ,
		IWbemServices *a_Repository ,
		LONG a_Flags ,
		IWbemContext *a_Context ,
		LPCWSTR a_Scope ,
		CServerObject_ProviderRegistrationV1 &a_Registration
	) ;

	HRESULT GetApartmentInstanceProvider (

		GUID *a_TransactionIdentifier ,
		LPCWSTR a_User ,
		LPCWSTR a_Locale ,
		LPCWSTR a_Namespace ,
		IWbemPath *a_NamespacePath ,
		IWbemServices *a_Repository ,
		LONG a_Flags ,
		IWbemContext *a_Context ,
		LPCWSTR a_Scope ,
		CServerObject_ProviderRegistrationV1 &a_Registration
	) ;

public:	/* External */

	//Non-delegating object IUnknown

    STDMETHODIMP QueryInterface ( REFIID , LPVOID FAR * ) ;
    STDMETHODIMP_( ULONG ) AddRef () ;
    STDMETHODIMP_( ULONG ) Release () ;

    /* IWbemServices methods */

    HRESULT STDMETHODCALLTYPE OpenNamespace ( 

        const BSTR a_Namespace ,
        long a_Flags ,
        IWbemContext *a_Context ,
        IWbemServices **a_Service ,
        IWbemCallResult **a_CallResult
	) ;
    
    HRESULT STDMETHODCALLTYPE CancelAsyncCall ( 

        IWbemObjectSink *a_Sink
	) ;
    
    HRESULT STDMETHODCALLTYPE QueryObjectSink ( 

        long a_Flags ,
        IWbemObjectSink **a_Sink
	) ;
    
    HRESULT STDMETHODCALLTYPE GetObject ( 

		const BSTR a_ObjectPath ,
        long a_Flags ,
        IWbemContext *a_Context ,
        IWbemClassObject **ppObject ,
        IWbemCallResult **a_CallResult
	) ;
    
    HRESULT STDMETHODCALLTYPE GetObjectAsync (
        
		const BSTR a_ObjectPath ,
        long a_Flags ,
        IWbemContext *a_Context ,
        IWbemObjectSink *a_Sink
	) ;

    HRESULT STDMETHODCALLTYPE PutClass ( 

        IWbemClassObject *a_Object ,
        long a_Flags ,
        IWbemContext *a_Context ,
        IWbemCallResult **a_CallResult
	) ;
    
    HRESULT STDMETHODCALLTYPE PutClassAsync ( 

        IWbemClassObject *a_Object ,
        long a_Flags ,
        IWbemContext *a_Context ,
        IWbemObjectSink *a_Sink
	) ;
    
    HRESULT STDMETHODCALLTYPE DeleteClass ( 

        const BSTR a_Class ,
        long a_Flags ,
        IWbemContext *a_Context ,
        IWbemCallResult **a_CallResult
	) ;
    
    HRESULT STDMETHODCALLTYPE DeleteClassAsync ( 

        const BSTR a_Class ,
        long a_Flags ,
        IWbemContext *a_Context ,
        IWbemObjectSink *a_Sink
	) ;
    
    HRESULT STDMETHODCALLTYPE CreateClassEnum ( 

        const BSTR a_Superclass ,
        long a_Flags ,
        IWbemContext *a_Context ,
        IEnumWbemClassObject **a_Enum
	) ;
    
    HRESULT STDMETHODCALLTYPE CreateClassEnumAsync ( 

		const BSTR a_Superclass ,
		long a_Flags ,
		IWbemContext *a_Context ,
		IWbemObjectSink *a_Sink
	) ;
    
    HRESULT STDMETHODCALLTYPE PutInstance (

		IWbemClassObject *a_Instance ,
		long a_Flags , 
		IWbemContext *a_Context ,
		IWbemCallResult **a_CallResult
	) ;
    
    HRESULT STDMETHODCALLTYPE PutInstanceAsync (

		IWbemClassObject *a_Instance ,
		long a_Flags ,
		IWbemContext *a_Context ,
		IWbemObjectSink *a_Sink 
	) ;
    
    HRESULT STDMETHODCALLTYPE DeleteInstance ( 

		const BSTR a_ObjectPath ,
		long a_Flags ,
		IWbemContext *a_Context ,
		IWbemCallResult **a_CallResult
	) ;
    
    HRESULT STDMETHODCALLTYPE DeleteInstanceAsync ( 

		const BSTR a_ObjectPath,
		long a_Flags,
		IWbemContext *a_Context ,
		IWbemObjectSink *a_Sink
	) ;
    
    HRESULT STDMETHODCALLTYPE CreateInstanceEnum (

		const BSTR a_Class ,
		long a_Flags ,
		IWbemContext *a_Context ,
		IEnumWbemClassObject **a_Enum
	) ;
    
    HRESULT STDMETHODCALLTYPE CreateInstanceEnumAsync (

		const BSTR a_Class ,
		long a_Flags ,
		IWbemContext *a_Context ,
		IWbemObjectSink *a_Sink
	) ;
    
    HRESULT STDMETHODCALLTYPE ExecQuery ( 

		const BSTR a_QueryLanguage,
		const BSTR a_Query,
		long a_Flags ,
		IWbemContext *a_Context ,
		IEnumWbemClassObject **a_Enum
	) ;
    
    HRESULT STDMETHODCALLTYPE ExecQueryAsync (

		const BSTR a_QueryLanguage ,
		const BSTR a_Query ,
		long a_Flags ,
		IWbemContext *a_Context ,
		IWbemObjectSink *a_Sink
	) ;
    
    HRESULT STDMETHODCALLTYPE ExecNotificationQuery (

		const BSTR a_QueryLanguage ,
		const BSTR a_Query ,
		long a_Flags ,
		IWbemContext *a_Context ,
		IEnumWbemClassObject **a_Enum
	) ;
    
    HRESULT STDMETHODCALLTYPE ExecNotificationQueryAsync ( 

        const BSTR a_QueryLanguage ,
        const BSTR a_Query ,
        long a_Flags ,
        IWbemContext *a_Context ,
        IWbemObjectSink *a_Sink
	) ;
    
    HRESULT STDMETHODCALLTYPE ExecMethod (

        const BSTR a_ObjectPath ,
        const BSTR a_MethodName ,
        long a_Flags ,
        IWbemContext *a_Context ,
        IWbemClassObject *a_InParams ,
        IWbemClassObject **a_OutParams ,
        IWbemCallResult **a_CallResult
	) ;
    
    HRESULT STDMETHODCALLTYPE ExecMethodAsync ( 

		const BSTR a_ObjectPath ,
		const BSTR a_MethodName ,
		long a_Flags ,
		IWbemContext *a_Context ,
		IWbemClassObject *a_InParams ,
		IWbemObjectSink *a_Sink
	) ;

	/* IWbemEventConsumerProvider */

	HRESULT STDMETHODCALLTYPE FindConsumer (

		IWbemClassObject *a_LogicalConsumer ,
		IWbemUnboundObjectSink **a_Consumer
	);

	/* IWbemEventConsumerProviderEx */

	HRESULT STDMETHODCALLTYPE ValidateSubscription (

		IWbemClassObject *a_LogicalConsumer
	) ;

	/* IWbemUnboundObjectSink */

	HRESULT STDMETHODCALLTYPE IndicateToConsumer (

		IWbemClassObject *a_LogicalConsumer ,
		long a_ObjectCount ,
		IWbemClassObject **a_Objects
	) ;

	/* IWbemEventProvider */

	HRESULT STDMETHODCALLTYPE ProvideEvents (

		IWbemObjectSink *a_Sink ,
		long a_Flags
	) ;

	/* IWbemEventProviderQuerySink */

	HRESULT STDMETHODCALLTYPE NewQuery (

		unsigned long a_Id ,
		WBEM_WSTR a_QueryLanguage ,
		WBEM_WSTR a_Query
	);

	HRESULT STDMETHODCALLTYPE CancelQuery (

		unsigned long a_Id
	) ;

	/* IWbemEventProviderSecurity */

	HRESULT STDMETHODCALLTYPE AccessCheck (

		WBEM_CWSTR a_QueryLanguage ,
		WBEM_CWSTR a_Query ,
		long a_SidLength ,
		const BYTE *a_Sid
	) ;

	/* IWbemProviderInit methods */

	HRESULT STDMETHODCALLTYPE Initialize (

		LPWSTR a_User ,
		LONG a_Flags ,
		LPWSTR a_Namespace ,
		LPWSTR a_Locale ,
		IWbemServices *a_Core ,
		IWbemContext *a_Context ,
		IWbemProviderInitSink *a_Sink
	) ;

	HRESULT STDMETHODCALLTYPE Shutdown (

		LONG a_Flags ,
		ULONG a_MaxMilliSeconds ,
		IWbemContext *a_Context
	) ; 
};

#endif // _Server_StaThread_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\winmgmt\provsubsys\server\include\resource.h ===
/*++

Copyright (C) 1996-2001 Microsoft Corporation

Module Name:

	Resource.h

Abstract:


History:

--*/

//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by propprov.rc
//

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NO_MFC                     1
#define _APS_NEXT_RESOURCE_VALUE        101
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1000
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\winmgmt\provsubsys\server\include\strobethread.h ===
/*++

Copyright (C) 1996-2001 Microsoft Corporation

Module Name:

	ProvFact.h

Abstract:


History:

--*/

#ifndef _StrobeThread_H
#define _StrobeThread_H

#include <Thread.h>

class StrobeThread : public EventHandler
{
private:

	WmiAllocator &m_Allocator ;
	DWORD timeout_;

public:

	StrobeThread ( WmiAllocator & a_Allocator , DWORD timeout) ;
	~StrobeThread () ;

	int handleTimeout (void) ;

	ULONG GetTimeout () { return timeout_; }

	void SetTimeout ( DWORD timeout ) 
	{
		timeout_ = ( timeout_ < timeout ) ? timeout_ : timeout ;
		Dispatcher::changeTimer( *this, timeout_ ) ;
	}
};

class Task_ProcessTermination : public EventHandler
{
	DWORD m_ProcessIdentifier ;
	HANDLE processHandle_;
public:
	Task_ProcessTermination(WmiAllocator & a_Allocator , HANDLE a_Process , DWORD a_ProcessIdentifier );
	~Task_ProcessTermination(void);
	int handleEvent(void);
	HANDLE getHandle(void);
};


#if 0
/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

class StrobeThread : public WmiThread < ULONG > 
{
private:

	WmiAllocator &m_Allocator ;

protected:

public:	// Internal 

    StrobeThread ( 

		WmiAllocator & a_Allocator ,
		const ULONG &a_Timeout 
	) ;

    ~StrobeThread () ;

	WmiStatusCode Initialize_Callback () ;

	WmiStatusCode UnInitialize_Callback () ;

	WmiStatusCode TimedOut () ;

	WmiStatusCode Shutdown () ;

};

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

class Task_ProcessTermination : public WmiTask < ULONG > 
{
private:

	DWORD m_ProcessIdentifier ;

protected:

public:	// Internal 

    Task_ProcessTermination ( 

		WmiAllocator & a_Allocator ,
		HANDLE a_Process ,
		DWORD a_ProcessIdentifier 
	) ;

    ~Task_ProcessTermination () ;

	WmiStatusCode Process ( WmiThread <ULONG> &a_Thread ) ;
};

#endif
#endif // _StrobeThread_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\winmgmt\redirect\precomp.h ===
/*++

Copyright (C) 1997-2001 Microsoft Corporation

Module Name:

Abstract:

History:

--*/

#pragma warning (disable : 4786)
#include <ole2.h>
#include <windows.h>
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\winmgmt\redirect\unsecapp.cpp ===
/*++

Copyright (C) 1997-2001 Microsoft Corporation

Module Name:

    MAIN.CPP

Abstract:

	"Main" file for unsecapp.exe: initialize the app as a com server.  See 
	wrapper.cpp for a description of what unsecapp does.

History:

	a-levn        8/24/97       Created.
	a-davj        6/11/98       commented

--*/

#include "precomp.h"

#include <commain.h>
#include <clsfac.h>
#include "wbemidl.h"
#include "wrapper.h"

#include <tchar.h>

class CMyServer : public CComServer
{
public:
    virtual HRESULT InitializeCom() 
    {
        HRESULT hres = CoInitialize(NULL);
        if(FAILED(hres))
            return hres;
        return CoInitializeSecurity(NULL, -1, NULL, NULL, 
            RPC_C_AUTHN_LEVEL_NONE, RPC_C_IMP_LEVEL_IDENTIFY, NULL, 0, 0);
    }

    virtual HRESULT Initialize() 
    {
        CSimpleClassFactory<CUnsecuredApartment> * pFact = 
            new CSimpleClassFactory<CUnsecuredApartment>(GetLifeControl());
        if(pFact == NULL)
            return WBEM_E_OUT_OF_MEMORY;
        AddClassInfo(CLSID_UnsecuredApartment, 
            pFact, TEXT("Unsecured Apartment"), TRUE);
        return S_OK;
    }
} Server;
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\winmgmt\redirect\wrapper.cpp ===
/*++

Copyright (C) 1997-2001 Microsoft Corporation

Module Name:

    WRAPPER.CPP

Abstract:

	Unsecapp (Unsecured appartment) is used by clients can recieve asynchronous
	call backs in cases where the client cannot initialize security and the server
	is running on a remote machine using an account with no network identity.  
	A prime example would be code running under MMC which is trying to get async
	notifications from a remote WINMGMT running as an nt service under the "local"
	account.

	SEE WRAPPER.H FOR MORE DETAILS.

History:

	a-levn        8/24/97       Created.
	a-davj        6/11/98       commented

--*/

#include "precomp.h"
#include "wrapper.h"
#include <wbemidl.h>
#include <sync.h>
#include <comutl.h>
#include <wbemutil.h>
#include <reg.h>

long lAptCnt = 0;

CStub::CStub( IWbemObjectSink* pAggregatee, 
              CLifeControl* pControl, 
              BOOL bCheckAccess )
{
    m_pControl = pControl;
    m_bStatusSent = false;
    m_bCheckAccess = bCheckAccess;
    pControl->ObjectCreated((IWbemObjectSink*)this);
    m_pAggregatee = pAggregatee;
    m_pAggregatee->AddRef();
    m_lRef = 0;
}

CStub::~CStub()
{
    IWbemObjectSink * pSink = NULL;
    if(m_pAggregatee)
    {
        CInCritSec cs(&m_cs);
        pSink = m_pAggregatee;
        m_pAggregatee = NULL;
    }
    if(pSink)
        pSink->Release();
    m_pControl->ObjectDestroyed((IWbemObjectSink*)this);
}


// This is called by either the client or server.  

STDMETHODIMP CStub::QueryInterface(REFIID riid, void** ppv)
{
    if( riid == IID_IUnknown || riid == IID_IWbemObjectSink )
    {
        *ppv = (void*)(IWbemObjectSink*)this;
        AddRef();
        return S_OK;
    }
    else if ( riid == IID__IWmiObjectSinkSecurity )
    {
        *ppv = (void*)(_IWmiObjectSinkSecurity*)this;
        AddRef();
        return S_OK;
    }
    else
        return E_NOINTERFACE;
}


ULONG STDMETHODCALLTYPE CStub::Release()
{
    long lRef = InterlockedDecrement(&m_lRef);
    if(lRef == 0) delete this;
    return lRef;
}


HRESULT CStub::CheckAccess()
{
    if ( !m_bCheckAccess )
        return WBEM_S_NO_ERROR;

    HRESULT hres = CoImpersonateClient();
    if(FAILED(hres))
    {
        ERRORTRACE((LOG_WBEMCORE,"Unsecapp::AccessCheck() Failed.  Could not "
                    "impersonate caller. hres=0x%x\n", hres ));
        return hres;
    }

    CNtSid Sid(CNtSid::CURRENT_THREAD);
    CoRevertToSelf();

    if ( Sid.GetStatus() != CNtSid::NoError )
    {
        ERRORTRACE((LOG_WBEMCORE,"Unsecapp::AccessCheck() Failed.  Could not "
                    "obtain caller sid.\n"));
        return WBEM_E_ACCESS_DENIED;
    }

    CInCritSec ics(&m_cs);
    for( int i=0; i < m_CallbackSids.size(); i++ )
        if ( Sid == m_CallbackSids[i] )
            return WBEM_S_NO_ERROR;
   
    WCHAR achSid[256];
    DWORD cSid = 256;
    if ( Sid.GetTextSid( achSid, &cSid ) )
    {
        ERRORTRACE((LOG_WBEMCORE,"Unsecapp::AccessCheck() ACCESS_DENIED. "
                    "Caller is %S\n", achSid));
    }

    return E_ACCESSDENIED;
}

STDMETHODIMP CStub::AddCallbackPrincipalSid( PBYTE pSid, DWORD cSid )
{
    HRESULT hr;

    if ( pSid != NULL )
    {
        if ( !IsValidSid( pSid ) )
            return WBEM_E_INVALID_PARAMETER;
    }
    else
    {
        if ( !m_bCheckAccess )
            return WBEM_S_NO_ERROR;

        return WBEM_E_INVALID_PARAMETER;
    }

    CInCritSec cs(&m_cs);

    for( int i=0; i < m_CallbackSids.size(); i++ )
    {
        if ( GetLengthSid( m_CallbackSids[i].GetPtr() ) == cSid &&
             EqualSid( pSid, m_CallbackSids[i].GetPtr() ) )
        {
            return WBEM_S_NO_ERROR;
        }
    }

    try
    {
        m_CallbackSids.push_back( CNtSid( pSid ) );
    }
    catch( CX_MemoryException& )
    {
        return WBEM_E_OUT_OF_MEMORY;
    }

    return WBEM_S_NO_ERROR;
}    


STDMETHODIMP CStub::Indicate(long lObjectCount, IWbemClassObject** pObjArray)
{
    IWbemObjectSink * pSink = NULL;
    HRESULT hRes = WBEM_E_FAILED;
    if(m_pAggregatee)
    {
        CInCritSec cs(&m_cs);

        hRes = CheckAccess();

        if( FAILED(hRes) )
            return hRes;

        pSink = m_pAggregatee;
        pSink->AddRef();
    }
    if(pSink)
    {
        hRes = pSink->Indicate(lObjectCount, pObjArray);
        pSink->Release();
    }
    return hRes;
};

STDMETHODIMP CStub::SetStatus(long lFlags, long lParam, BSTR strParam,
                         IWbemClassObject* pObjParam)
{
    IWbemObjectSink * pSink = NULL;
    if(FAILED(lParam))
        m_bStatusSent = true;
    else if(lParam == S_OK)
        m_bStatusSent = true;

    HRESULT hRes = WBEM_E_FAILED;
    if(m_pAggregatee)
    {
        CInCritSec cs(&m_cs);

        hRes = CheckAccess();

        if( FAILED(hRes) )
            return hRes;

        pSink = m_pAggregatee;
        pSink->AddRef();
       
    }
    if(pSink)
    {
        hRes = pSink->SetStatus(lFlags, lParam, strParam, pObjParam);
        pSink->Release();
    }
    return hRes;
};


void* CUnsecuredApartment::GetInterface(REFIID riid)
{
    if(riid == IID_IUnknown || riid == IID_IUnsecuredApartment || 
       riid == IID_IWbemUnsecuredApartment )
    {
        return &m_XApartment;
    }
    else return NULL;
}

STDMETHODIMP CUnsecuredApartment::XApartment::CreateObjectStub(
        IUnknown* pObject, 
        IUnknown** ppStub)
{
    HRESULT hr;
    *ppStub = NULL;

    if(pObject == NULL)
        return E_POINTER;

    CWbemPtr<IWbemObjectSink> pSink;
    hr = pObject->QueryInterface( IID_IWbemObjectSink, (void**)&pSink );
    if ( FAILED(hr) )
        return hr;

    IWbemObjectSink* pStub = NULL;
    hr = CreateSinkStub( pSink, 
                         WBEM_FLAG_UNSECAPP_DEFAULT_CHECK_ACCESS,
                         NULL,
                         &pStub );

    *ppStub = pStub;
    return hr;
}


STDMETHODIMP CUnsecuredApartment::XApartment::CreateSinkStub( 
    IWbemObjectSink* pSink, 
    DWORD dwFlags,
    LPCWSTR wszReserved,
    IWbemObjectSink** ppStub )
{
    *ppStub = NULL;

    if(pSink == NULL)
        return E_POINTER;

    BOOL bCheckAccess;

    if ( dwFlags != WBEM_FLAG_UNSECAPP_DEFAULT_CHECK_ACCESS &&
         dwFlags != WBEM_FLAG_UNSECAPP_CHECK_ACCESS &&
         dwFlags != WBEM_FLAG_UNSECAPP_DONT_CHECK_ACCESS )
        return WBEM_E_INVALID_PARAMETER;

    if ( wszReserved != NULL )
        return WBEM_E_INVALID_PARAMETER;

    if ( dwFlags == WBEM_FLAG_UNSECAPP_DEFAULT_CHECK_ACCESS )
    {
        Registry r(WBEM_REG_WINMGMT);
        DWORD dw = 0;
        r.GetDWORDStr(__TEXT("UnsecappAccessControlDefault"), &dw);
        bCheckAccess = dw == 1 ? TRUE : FALSE;
    }
    else
    {
        bCheckAccess = dwFlags == WBEM_FLAG_UNSECAPP_CHECK_ACCESS ? TRUE:FALSE;
    }

    CStub* pIdentity = new CStub( pSink, m_pObject->m_pControl, bCheckAccess );
    pIdentity->AddRef();
    *ppStub = (IWbemObjectSink*)pIdentity;

    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\winmgmt\stdprov\cfdyn.h ===
/*++

Copyright (C) 1995-2001 Microsoft Corporation

Module Name:

    CFDYN.H

Abstract:

	Declares the the CCFDyn Class.

History:

	a-davj  27-Sep-95   Created.

--*/

#ifndef _CCFDYN_H_
#define _CCFDYN_H_

//Get the object definitions

#include "impdyn.h"


//***************************************************************************
//
//  CLASS NAME:
//
//  CCFDyn
//
//  DESCRIPTION:
//
//  This is the generic class factory.  It is always overridden so as to 
//  create a specific type of provider, such as a registry provider.
//
//***************************************************************************

class CCFDyn : public IClassFactory
    {
    protected:
        long           m_cRef;

    public:
        CCFDyn(void);
        ~CCFDyn(void);

        virtual IUnknown * CreateImpObj() = 0;

        //IUnknown members
        STDMETHODIMP         QueryInterface(REFIID, PPVOID);
        STDMETHODIMP_(ULONG) AddRef(void);
        STDMETHODIMP_(ULONG) Release(void);

        //IClassFactory members
        STDMETHODIMP         CreateInstance(LPUNKNOWN, REFIID
                                 , PPVOID);
        STDMETHODIMP         LockServer(BOOL);
    };

typedef CCFDyn *PCCFDyn;

#endif //_CCFDYN_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\winmgmt\redirect\wrapper.h ===
/*++

Copyright (C) 1997-2001 Microsoft Corporation

Module Name:

    WRAPPER.H

Abstract:

	Unsecapp (Unsecured appartment) is used by clients can recieve asynchronous
	call backs in cases where the client cannot initialize security and the server
	is running on a remote machine using an account with no network identity.  
	A prime example would be code running under MMC which is trying to get async
	notifications from a remote WINMGMT running as an nt service under the "local"
	account.

	See below for more info

History:

	a-levn        8/24/97       Created.
	a-davj        6/11/98       commented

--*/

//***************************************************************************
//
//  Wrapper.h
//
//  Unsecapp (Unsecured appartment) is used by clients can recieve asynchronous
//  call backs in cases where the client cannot initialize security and the server
//  is running on a remote machine using an account with no network identity.  
//  A prime example would be code running under MMC which is trying to get async
//  notifications from a remote WINMGMT running as an nt service under the "local"
//  account.
//
//  The suggested sequence of operations for making asynchronous calls from a client process is, then, the following (error checking omitted for brevity):
//
//  1) Create an instance of CLSID_UnsecuredApartment. Only one instance per client application is needed.  Since this object is implemented as a local server, this will launch UNSECAPP.EXE if it is not already running.
//
//	IUnsecuredApartment* pUnsecApp = NULL;
//	CoCreateInstance(CLSID_UnsecuredApartment, NULL, CLSCTX_LOCAL_SERVER, IID_IUnsecuredApartment, 
//				(void**)&pUnsecApp);
//
//  When making a call:
//
//  2) Instantiate your own implementation of IWbemObjectSink, e.g.
//
//	CMySink* pSink = new CMySink;
//	pSink->AddRef();
//
//  3) Create a "stub" for your object --- an UNSECAPP-produced wrapper --- and ask it for the IWbemObjectSink interface.
//
//	IUnknown* pStubUnk = NULL;
//	pUnsecApp->CreateObjectStub(pSink, &pStubUnk);
//
//	IWbemObjectSink* pStubSink = NULL;
//	pStubUnk->QueryInterface(IID_IWbemObjectSink, &pStubSink);
//	pStubUnk->Release();
//
//  4) Release your own object, since the "stub" now owns it.
//	pSink->Release();
//
//  5) Use this stub in the asynchronous call of your choice and release your own ref-count on it, e.g.
//	
//	pServices->CreateInstanceEnumAsync(strClassName, 0, NULL, pStubSink);
//	pStubSink->Release();
//
//  You are done. Whenever UNSECAPP receives a call in your behalf (Indicate or SetStatus) it will forward that call to your own object (pSink), and when it is finally released by WINMGMT, it will release your object. Basically, from the perspective of pSink, everything will work exactly as if it itself was passed into CreateInstanceEnumAsync.
//
//  Do once:
//  6) Release pUnsecApp before uninitializing COM:
//	pUnsecApp->Release();
//
//  When CreateObjectStub() is callec, a CStub object is created.  
//
//  History:
//
//  a-levn        8/24/97       Created.
//  a-davj        6/11/98       commented
//
//***************************************************************************

#include <unk.h>
#include <sync.h>
#include "wbemidl.h"
#include "wbemint.h"
#include <vector>
#include <winntsec.h>
#include <wstlallc.h>

// One of these is created for each stub on the client

class CStub : public IWbemObjectSink, public _IWmiObjectSinkSecurity
{
protected:
    IWbemObjectSink* m_pAggregatee;
    CLifeControl* m_pControl;
    long m_lRef;
    CCritSec  m_cs;
    bool m_bStatusSent;
    
    BOOL m_bCheckAccess;
    std::vector<CNtSid, wbem_allocator<CNtSid> > m_CallbackSids;

    HRESULT CheckAccess();

public:
    CStub( IWbemObjectSink* pAggregatee, 
           CLifeControl* pControl, 
           BOOL bCheckAccess );
    ~CStub();
    void ServerWentAway();

    STDMETHOD(QueryInterface)(REFIID riid, void** ppv);
    STDMETHOD_(ULONG, AddRef)()
        {return InterlockedIncrement(&m_lRef);};
    STDMETHOD_(ULONG, Release)();

    STDMETHOD(Indicate)(long lObjectCount, IWbemClassObject** pObjArray);
    STDMETHOD(SetStatus)(long lFlags, long lParam, BSTR strParam,
                         IWbemClassObject* pObjParam);

    STDMETHOD(AddCallbackPrincipalSid)( PBYTE pSid, DWORD cSid );
};


// When the client does a CCI, one of these is created.  Its only purpose
// is to support CreateObjectStub
extern long lAptCnt;

class CUnsecuredApartment : public CUnk
{
protected:
    typedef CImpl<IWbemUnsecuredApartment, CUnsecuredApartment> XApartmentImpl;
    class XApartment : public XApartmentImpl
    {
    public:
        XApartment(CUnsecuredApartment* pObject) : XApartmentImpl(pObject){}
        STDMETHOD(CreateObjectStub)(IUnknown* pObject, IUnknown** ppStub);
        STDMETHOD(CreateSinkStub)( IWbemObjectSink* pSink, 
                                   DWORD dwFlags,
                                   LPCWSTR wszReserved,
                                   IWbemObjectSink** ppStub );
    } m_XApartment;
    friend XApartment;

public:
    CUnsecuredApartment(CLifeControl* pControl) : CUnk(pControl),
        m_XApartment(this)
    {
        lAptCnt++;
    }                            
    ~CUnsecuredApartment()
    {
        lAptCnt--;
    }
    void* GetInterface(REFIID riid);
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\winmgmt\stdprov\cfdyn.cpp ===
/*++

Copyright (C) 1995-2001 Microsoft Corporation

Module Name:

    CFDYN.CPP

Abstract:

	Defines the virtual base class for the Dynamic Provider
	class factory objects.  This code was largly pilfered from
	the Brockschmidt samples.  The class is always overriden
	so that each provider type (DDE, registry, etc.) will have
	its own class factory.

History:

	a-davj  27-Sep-95   Created.

--*/

#include "precomp.h"
#include "cfdyn.h"

 
//***************************************************************************
// CCFDyn::CCFDyn
// CCFDyn::~CCFDyn
//
// DESCRIPTION:
//
// Constructor and destructor.
//
//***************************************************************************

CCFDyn::CCFDyn(void)
{
    InterlockedIncrement(&lObj); 
    m_cRef=0L;
    return;
}

CCFDyn::~CCFDyn(void)
{
    InterlockedDecrement(&lObj); 
    return;
}

//***************************************************************************
// HRESULT CCFDyn::QueryInterface
// long CCFDyn::AddRef
// long CCFDyn::Release
//
// DESCRIPTION:
//
// Standard Com IUNKNOWN functions.
//
//***************************************************************************

STDMETHODIMP CCFDyn::QueryInterface(
    IN REFIID riid,
    OUT PPVOID ppv)
{
    *ppv=NULL;

    if (IID_IUnknown==riid || IID_IClassFactory==riid)
        *ppv=this;

    if (NULL!=*ppv)
    {
        ((LPUNKNOWN)*ppv)->AddRef();
        return NOERROR;
    }

    return ResultFromScode(E_NOINTERFACE);
}


STDMETHODIMP_(ULONG) CCFDyn::AddRef(void)
{
    return InterlockedIncrement(&m_cRef);
}


STDMETHODIMP_(ULONG) CCFDyn::Release(void)
{
    long lRet = InterlockedDecrement(&m_cRef);

    if (0L!=lRet)
        return lRet;

    delete this;
    return 0L;
}


//***************************************************************************
// HRESULT CCFDyn::CreateInstance
//
//  DESCRIPTION:
//
//  Instantiates a provider object returning an interface pointer.  Note
//  that the CreateImpObj routine is always overriden in order
//  to create a particular type of provider.
//
//  PARAMETERS:
//  pUnkOuter       LPUNKNOWN to the controlling IUnknown if we are
//                  being used in an aggregation.
//  riid            REFIID identifying the interface the caller
//                  desires to have for the new object.
//  ppvObj          PPVOID in which to store the desired
//                  interface pointer for the new object.
//
//  RETURN VALUE:
//  HRESULT         NOERROR if successful, otherwise E_NOINTERFACE
//                  if we cannot support the requested interface.
//***************************************************************************

STDMETHODIMP CCFDyn::CreateInstance(
    IN LPUNKNOWN pUnkOuter,
    IN REFIID riid, 
    OUT PPVOID ppvObj)
{
    IUnknown *     pObj;
    HRESULT             hr;

    *ppvObj=NULL;
    hr=ResultFromScode(E_OUTOFMEMORY);

    //Verify that a controlling unknown asks for IUnknown

    if (NULL!=pUnkOuter && IID_IUnknown!=riid)
        return ResultFromScode(CLASS_E_NOAGGREGATION);

    //Create the object passing function to notify on destruction.

    pObj = CreateImpObj(); 

    if (NULL==pObj)
        return hr;

    hr=pObj->QueryInterface(riid, ppvObj);

    //Kill the object if initial creation or Init failed.
    if (FAILED(hr))
        delete pObj;
    else
        InterlockedIncrement(&lObj);  // dec takes place in the objects destructor

    return hr;
}

//***************************************************************************
// HRESULT CCFDyn::LockServer
//
// DESCRIPTION:
//  Increments or decrements the lock count of the DLL.  If the
//  lock count goes to zero and there are no objects, the DLL
//  is allowed to unload.  See DllCanUnloadNow.
//
// PARAMETERS:
//  fLock           BOOL specifying whether to increment or
//                  decrement the lock count.
//
// RETURN VALUE:
//  HRESULT         NOERROR always.
//***************************************************************************

STDMETHODIMP CCFDyn::LockServer(
    IN BOOL fLock)
{
    if (fLock)
        InterlockedIncrement(&lLock);
    else
        InterlockedDecrement(&lLock);
    return NOERROR;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\winmgmt\stdprov\counters.cpp ===
/*++

Copyright (C) 1995-2001 Microsoft Corporation

Module Name:

    COUNTERS.CPP

Abstract:

	Has the routines needed to message the counter data.  Note that
	this code was almost completly pilfered from the perfmon sample
	code done by Robert Watson and this ensures that the answers
	match what perfmon would give.

History:

	a-davj  12-20-95   v0.01.

--*/

#include "precomp.h"

#include <winperf.h>
#include "perfcach.h"      // Exported declarations for this file

#define INVERT             PERF_COUNTER_TIMER_INV
#define NS100_INVERT       PERF_100NSEC_TIMER_INV
#define NS100              PERF_100NSEC_TIMER
#define TIMER_MULTI        PERF_COUNTER_MULTI_TIMER
#define TIMER_MULTI_INVERT PERF_COUNTER_MULTI_TIMER_INV
#define NS100_MULTI        PERF_100NSEC_MULTI_TIMER
#define NS100_MULTI_INVERT PERF_100NSEC_MULTI_TIMER_INV


#define FRACTION 1
#define BULK     1

#define TOO_BIG   (FLOAT)1500000000
#pragma optimize("", off)

//***************************************************************************
//  FLOAT eGetTimeInterval
//
//  DESCRIPTION:
//  
//  Get the difference between the current and previous time counts,
//  then divide by the frequency.
//      
//  PARAMETERS:
//  
//  pCurrentTime    current time in ticks.
//  pPreviousTime   previous time in ticks.
//  pliFreq         # of  counts (clock ticks) per second
//  
//  RETURN VALUE:
//  
//  Floating point representation of Time Interval (seconds), 0.0 if error
//***************************************************************************

FLOAT eGetTimeInterval(
    IN LONGLONG *pliCurrentTime, 
    IN LONGLONG *pliPreviousTime,
    IN LONGLONG *pliFreq)

{
    FLOAT   eTimeDifference;
    FLOAT   eFreq;
    FLOAT   eTimeInterval ;

    LONGLONG liDifference;

    // Get the number of counts that have occured since the last sample

    liDifference = *pliCurrentTime - *pliPreviousTime;

    if (liDifference <= (LONGLONG)0) 
    {
        return (FLOAT) 0.0f;
    } 
    else 
    {
        eTimeDifference = (FLOAT)liDifference;

        // Get the counts per second

        eFreq = (FLOAT)(*pliFreq) ;
        if (eFreq <= 0.0f)
           return (FLOAT) 0.0f;

        // Get the time since the last sample.

        eTimeInterval = eTimeDifference / eFreq ;

        return (eTimeInterval) ;
    }
} // eGetTimeInterval

//***************************************************************************
//  FLOAT Counter_Counter_Common
//  
//  DESCRIPTION:
//  
//  Take the difference between the current and previous counts
//  then divide by the time interval
//      
//  PARAMETERS:
//  
//  pLineStruct Line structure containing data to perform computations on
//  
//  iType       Counter Type
//          
//  
//  RETURN VALUE:
//  
//  Floating point representation of outcome, 0.0 if error
//***************************************************************************

FLOAT Counter_Counter_Common(
        IN PLINESTRUCT pLineStruct,
        IN INT iType)
{
    FLOAT   eTimeInterval;
    FLOAT   eDifference;
    FLOAT   eCount ;
    BOOL    bValueDrop = FALSE ;

    LONGLONG   liDifference;

    if (iType != BULK) 
    {

        // check if it is too big to be a wrap-around case
        if (pLineStruct->lnaCounterValue[0] <
            pLineStruct->lnaOldCounterValue[0])
           {
           if (pLineStruct->lnaCounterValue[0] -
               pLineStruct->lnaOldCounterValue[0] > (DWORD)0x00ffff0000)
              {
              return (FLOAT) 0.0f;
              }
           bValueDrop = TRUE ;
           }

        liDifference = pLineStruct->lnaCounterValue[0] -
                       pLineStruct->lnaOldCounterValue[0];

        liDifference &= (DWORD)(0x0ffffffff);

    } 
    else 
    {
        liDifference = pLineStruct->lnaCounterValue[0] -
                       pLineStruct->lnaOldCounterValue[0];
    }
    
    if (liDifference <= (LONGLONG) 0) 
    {
        return (FLOAT) 0.0f;
    } 
    else 
    {
        eTimeInterval = eGetTimeInterval(&pLineStruct->lnNewTime,
                                        &pLineStruct->lnOldTime,
                                        &pLineStruct->lnPerfFreq) ;
        if (eTimeInterval <= 0.0f) 
        {
            return (FLOAT) 0.0f;
        } 
        else 
        {
            eDifference = (FLOAT)(liDifference);

            eCount         = eDifference / eTimeInterval ;
            
            if (bValueDrop && eCount > (FLOAT) TOO_BIG) 
            {
                // ignore this bogus data since it is too big for 
                // the wrap-around case
                eCount = (FLOAT) 0.0f ;
            }
            return(eCount) ;
        }
    }
} // Counter_Counter_Common


//***************************************************************************
//  FLOAT Counter_Queuelen
//  
//  DESCRIPTION:
//  
//  Calculates queue lengths.
//      
//  PARAMETERS:
//  
//  pLineStruct Line structure containing data to perform computations on
//  
//  bLarge      TRUE if type LARGE
//          
//  
//  RETURN VALUE:
//  
//  Floating point representation of outcome, 0.0 if error
//***************************************************************************

FLOAT Counter_Queuelen(IN PLINESTRUCT pLineStruct, IN BOOL bLarge, IN BOOL b100NS)
{

    FLOAT   eTimeInterval;
    FLOAT   eDifference;
    FLOAT   eCount ;
    BOOL    bValueDrop = FALSE ;

    LONGLONG   liDifference;

    if (!bLarge) 
    {

        // check if it is too big to be a wrap-around case
        if (pLineStruct->lnaCounterValue[0] <
            pLineStruct->lnaOldCounterValue[0])
           {
           if (pLineStruct->lnaCounterValue[0] -
               pLineStruct->lnaOldCounterValue[0] > (DWORD)0x00ffff0000)
              {
              return (FLOAT) 0.0f;
              }
           bValueDrop = TRUE ;
           }

        liDifference = pLineStruct->lnaCounterValue[0] -
                       pLineStruct->lnaOldCounterValue[0];

        liDifference &= (DWORD)(0x0ffffffff);

    } 
    else 
    {
        liDifference = pLineStruct->lnaCounterValue[0] -
                       pLineStruct->lnaOldCounterValue[0];
    }
    
    if (liDifference <= (LONGLONG) 0) 
    {
        return (FLOAT) 0.0f;
    } 

    eDifference = (float)liDifference;

    if(b100NS)
        eTimeInterval = pLineStruct->lnNewTime100Ns - pLineStruct->lnOldTime100Ns;
    else
        eTimeInterval = pLineStruct->lnNewTime - pLineStruct->lnOldTime;
                                        
    if (eTimeInterval <= 0.0f) 
    {
        return (FLOAT) 0.0f;
    } 
 
    eCount = eDifference / eTimeInterval ;
    return(eCount) ;
}

//***************************************************************************
//  FLOAT Counter_Average_Timer
//  
//  DESCRIPTION:
//  
//  Take the differences between the current and previous times and counts
//  divide the time interval by the counts multiply by 10,000,000 (convert
//  from 100 nsec to sec)
//      
//  PARAMETERS:
//  
//  pLineStruct     Line structure containing data to perform computations on
//  
//  RETURN VALUE:
//  
//  Floating point representation of outcome, 0.0 if error
//***************************************************************************

FLOAT Counter_Average_Timer(
        IN PLINESTRUCT pLineStruct)
{
    FLOAT   eTimeInterval;
    FLOAT   eCount;

    LONGLONG    liDifference;

    // Get the current and previous counts.

    liDifference = (DWORD)pLineStruct->lnaCounterValue[1] - 
            (DWORD)pLineStruct->lnaOldCounterValue[1];

    if ( liDifference <= 0) 
    {
        return (FLOAT) 0.0f;
    } 
    else 
    {
        // Get the amount of time that has passed since the last sample
        eTimeInterval = eGetTimeInterval(&pLineStruct->lnaCounterValue[0],
                                            &pLineStruct->lnaOldCounterValue[0],
                                            &pLineStruct->lnPerfFreq) ;

        if (eTimeInterval < 0.0f) 
        { // return 0 if negative time has passed
            return (0.0f);
        } 
        else 
        {
            // Get the number of counts in this time interval.
            eCount = eTimeInterval / ((FLOAT)liDifference);
            return(eCount) ;
        }
    }
} //Counter_Average_Timer

//***************************************************************************
//  FLOAT Counter_Average_Bulk
//  
//  DESCRIPTION:
//  
//  Take the differences between the current and previous byte counts and
//  operation counts divide the bulk count by the operation counts
//      
//  PARAMETERS:
//  
//  pLineStruct Line structure containing data to perform computations on
//  
//  RETURN VALUE:
//  
//  Floating point representation of outcome, 0.0 if error
//***************************************************************************

FLOAT Counter_Average_Bulk(
        IN PLINESTRUCT pLineStruct)
{
    FLOAT   eBulkDelta;
    FLOAT   eDifference;
    FLOAT   eCount;

    LONGLONG liDifference;
    LONGLONG liBulkDelta;

    // Get the bulk count increment since the last sample

    liBulkDelta = pLineStruct->lnaCounterValue[0] -
            pLineStruct->lnaOldCounterValue[0];

    if (liBulkDelta <= (LONGLONG) 0) 
    {
        return (FLOAT) 0.0f;
    } 
    else 
    {
        // Get the current and previous counts.
        liDifference = (DWORD)pLineStruct->lnaCounterValue[1] -
                (DWORD) pLineStruct->lnaOldCounterValue[1];
        liDifference &= (DWORD) (0x0ffffffff);

        // Get the number of counts in this time interval.

        if ( liDifference <= (LONGLONG) 0) 
        {
            // Counter value invalid
            return (FLOAT) 0.0f;
        } 
        else 
        {
            eBulkDelta = (FLOAT) (liBulkDelta);
            eDifference = (FLOAT) (liDifference);
            eCount = eBulkDelta / eDifference ;

            // Scale the value to up to 1 second

            return(eCount) ;
        }
    }
} // Counter_Average_Bulk

//***************************************************************************
//  FLOAT Counter_Timer_Common
//  
//  DESCRIPTION:
//  
//  Take the difference between the current and previous counts,
//  Normalize the count (counts per interval)
//  divide by the time interval (count = % of interval)
//  if (invert)
//        subtract from 1 (the normalized size of an interval)
//  multiply by 100 (convert to a percentage)
//  this value from 100.
//      
//  PARAMETERS:
//  
//  pLineStruct     Line structure containing data to perform computations on
//  iType           Counter Type
//  
//  RETURN VALUE:
//  Floating point representation of outcome, 0.0 if error
//***************************************************************************

FLOAT Counter_Timer_Common(
        IN  PLINESTRUCT pLineStruct,
        IN  INT iType)
{
    FLOAT   eTimeInterval;
    FLOAT   eDifference;
    FLOAT   eFreq;
    FLOAT   eFraction;
    FLOAT   eMultiBase;
    FLOAT   eCount ;

    LONGLONG   liTimeInterval;
    LONGLONG   liDifference;

    // Get the amount of time that has passed since the last sample

    if (iType == NS100 ||
        iType == NS100_INVERT ||
        iType == NS100_MULTI ||
        iType == NS100_MULTI_INVERT) 
    {
        liTimeInterval = pLineStruct->lnNewTime100Ns -
                pLineStruct->lnOldTime100Ns ;
        eTimeInterval = (FLOAT) (liTimeInterval);
    } 
    else 
    {
        eTimeInterval = eGetTimeInterval(&pLineStruct->lnNewTime,
                                            &pLineStruct->lnOldTime,
                                            &pLineStruct->lnPerfFreq) ;
    }

    if (eTimeInterval <= 0.0f)
       return (FLOAT) 0.0f;

    // Get the current and previous counts.

    liDifference = pLineStruct->lnaCounterValue[0] -
            pLineStruct->lnaOldCounterValue[0] ;

    // Get the number of counts in this time interval.
    // (1, 2, 3 or any number of seconds could have gone by since
    // the last sample)

    eDifference = (FLOAT) (liDifference) ;

    if (iType == 0 || iType == INVERT)
    {
        // Get the counts per interval (second)

        eFreq = (FLOAT) (pLineStruct->lnPerfFreq) ;
        if (eFreq <= 0.0f)
           return (FLOAT) 0.0f;

        // Calculate the fraction of the counts that are used by whatever
        // we are measuring

        eFraction = eDifference / eFreq ;
    }
    else
    {
        eFraction = eDifference ;
    }

    // Calculate the fraction of time used by what were measuring.

    eCount = eFraction / eTimeInterval ;

     // If this is  an inverted count take care of the inversion.

    if (iType == INVERT || iType == NS100_INVERT)
        eCount = (FLOAT) 1.0 - eCount ;

    // Do extra calculation for multi timers.

    if(iType == TIMER_MULTI || iType == NS100_MULTI ||
       iType == TIMER_MULTI_INVERT || iType == NS100_MULTI_INVERT) 
    {

        eMultiBase = (float)pLineStruct->lnaCounterValue[1];
        if(eMultiBase == 0.0)
            return 0.0f;

        if (iType == TIMER_MULTI_INVERT || iType == NS100_MULTI_INVERT)
            eCount = eMultiBase - eCount;
        eCount /= eMultiBase;
    }

    // Scale the value to up to 100.

    eCount *= 100.0f ;

    if (eCount < 0.0f) eCount = 0.0f ;

    if (eCount > 100.0f &&
        iType != NS100_MULTI &&
        iType != NS100_MULTI_INVERT &&
        iType != TIMER_MULTI &&
        iType != TIMER_MULTI_INVERT) 
    {
        eCount = 100.0f;
    }

    return(eCount) ;
} // Counter_Timer_Common

//***************************************************************************
//  FLOAT Counter_Raw_Fraction
//  
//  DESCRIPTION:
//  
//  Evaluate a raw fraction (no time, just two values: Numerator and
//  Denominator) and multiply by 100 (to make a percentage;
//  
//  PARAMETERS:
//  
//  pLineStruct     Line structure containing data to perform computations on
//  
//  RETURN VALUE:
//  Floating point representation of outcome, 0.0 if error
//***************************************************************************

FLOAT Counter_Raw_Fraction(
        IN PLINESTRUCT pLineStruct)
{
    FLOAT   eCount ;

    LONGLONG   liNumerator;

    if ( pLineStruct->lnaCounterValue[0] == 0 ||
            pLineStruct->lnaCounterValue[1] == 0 ) 
    {
        // invalid value
        return (0.0f);
    } 
    else 
    {
        liNumerator = pLineStruct->lnaCounterValue[0] * 100;
        eCount = ((FLOAT) (liNumerator))  /
                 ((FLOAT) pLineStruct->lnaCounterValue[1]);
        return(eCount) ;
    }
} // Counter_Raw_Fraction

//***************************************************************************
//  FLOAT eElapsedTime
//  
//  DESCRIPTION:
//  
//  Converts 100NS elapsed time to fractional seconds
//  
//  PARAMETERS:
//  
//  pLineStruct     Line structure containing data to perform computations on
//  iType           Unused.
//  
//  RETURN VALUE:
//  
//  Floating point representation of elapsed time in seconds, 0.0 if error
//***************************************************************************

FLOAT eElapsedTime(
        IN PLINESTRUCT pLineStruct,
        IN INT iType)
{
    FLOAT   eSeconds ;

    LONGLONG   liDifference;

    if (pLineStruct->lnaCounterValue[0] <= (LONGLONG) 0) 
    {
        // no data [start time = 0] so return 0
        return (FLOAT) 0.0f;
    } 
    else 
    {
        LONGLONG PerfFreq;
       
        PerfFreq = *(LONGLONG UNALIGNED *)(&pLineStruct->ObjPerfFreq) ;

        // otherwise compute difference between current time and start time
        liDifference = 
            pLineStruct->ObjCounterTimeNew - pLineStruct->lnaCounterValue[0];

        if (liDifference <= (LONGLONG) 0 ||
            PerfFreq <= 0) 
        {
            return (FLOAT) 0.0f;
        } 
        else 
        {
            // convert to fractional seconds using object counter
            eSeconds = ((FLOAT) (liDifference)) /
                ((FLOAT) (PerfFreq));

            return (eSeconds);
        }
    }
    
} // eElapsedTime

//***************************************************************************
//  FLOAT Sample_Common
//  
//  DESCRIPTION:
//  
//  Divides "Top" differenced by Base Difference
//  
//  PARAMETERS:
//  
//  pLineStruct     Line structure containing data to perform computations on
//  iType           Counter Type
//  
//  RETURN VALUE:
//  
//  Floating point representation of outcome, 0.0 if error
//***************************************************************************

FLOAT Sample_Common(
        IN PLINESTRUCT pLineStruct,
        IN INT iType)
{
    FLOAT   eCount ;

    LONG    lDifference;
    LONG    lBaseDifference;

    lDifference = (DWORD)pLineStruct->lnaCounterValue[0] -
        (DWORD)pLineStruct->lnaOldCounterValue[0] ;
    lDifference &= (DWORD) (0x0ffffffff);

    if (lDifference <= 0) 
    {
        return (FLOAT) 0.0f;
    } 
    else 
    {
        lBaseDifference = (DWORD)pLineStruct->lnaCounterValue[1] -
            (DWORD)pLineStruct->lnaOldCounterValue[1] ;

        if ( lBaseDifference <= 0 ) 
        {
            // invalid value
            return (0.0f);
        } 
        else 
        {
            eCount = ((FLOAT)lDifference) / ((FLOAT)lBaseDifference) ;

            if (iType == FRACTION) 
            {
                eCount *= (FLOAT) 100.0f ;
            }
            return(eCount) ;
        }
    }
} // Sample_Common

//***************************************************************************
//
//  FLOAT Counter_Delta
// 
//  DESCRIPTION:
//  
//  Take the difference between the current and previous counts,
//  PARAMETERS:
//  
//  pLineStruct     Line structure containing data to perform computations on
//  bLargeData      true if data is large
//  
//  RETURN VALUE:
//  
//  Floating point representation of outcome, 0.0 if error
//***************************************************************************

FLOAT Counter_Delta(PLINESTRUCT pLineStruct, BOOL bLargeData)
{
    FLOAT   eDifference;
    LONGLONG    llDifference;
    ULONGLONG   ullThisValue, ullPrevValue;

    // Get the current and previous counts.

    if (!bLargeData) {
        // then clear the high part of the word
        ullThisValue = (ULONGLONG)pLineStruct->lnaCounterValue[0];
        ullPrevValue = (ULONGLONG)pLineStruct->lnaOldCounterValue[0];
    } else {
        ullThisValue = (ULONGLONG)pLineStruct->lnaCounterValue[0];
        ullPrevValue = (ULONGLONG)pLineStruct->lnaOldCounterValue[0];
    }

    if (ullThisValue > ullPrevValue) {
        llDifference = (LONGLONG)(ullThisValue - ullPrevValue);
        eDifference = (FLOAT)llDifference;
    } else {
        // the new value is smaller than or equal to the old value
        // and negative numbers are not allowed.
        eDifference = 0.0f;
    }

    return(eDifference) ;

}

//***************************************************************************
//  FLOAT GenericConv
//  
//  DESCRIPTION:
//  
//  This handles the data types which the perf monitor doesnt currently
//  handle and does so by simply using the "formulas" indicated by the
//  bit fields in the counter's type.
//  
//  PARAMETERS:
//  
//  pLine       Line structure containing data to perform computations on
//  
//  RETURN VALUE:
//  
//  Floating point representation of outcome
//***************************************************************************

FLOAT GenericConv(
        IN PLINESTRUCT pLine)
{
    FLOAT fRet = 0.0f;  // default if nothing makes sense

    // extract the various bit fields as defined in winperf.h

    DWORD PerfType = pLine->lnCounterType & 0x00000c00;
    DWORD SubType = pLine->lnCounterType &  0x000f0000;
    DWORD CalcMod = pLine->lnCounterType &  0x0fc00000;
    DWORD TimerType=pLine->lnCounterType &  0x00300000;
    DWORD Display = pLine->lnCounterType &  0xf0000000;
    DWORD dwSize =  pLine->lnCounterType &  0x00000300;

    if(PerfType == PERF_TYPE_NUMBER) 
    {
        
        // For simple number the calculation is fairly simple and only
        // involves a possible division by 1000

        fRet = (FLOAT)pLine->lnaCounterValue[0];
        if(SubType == PERF_NUMBER_DEC_1000)
            fRet /= 1000.0f;
        }
    else if(PerfType == PERF_TYPE_COUNTER) 
    {
        FLOAT eTimeDelta;
        FLOAT eDataDelta;
        FLOAT eBaseDelta;
        if(SubType == PERF_COUNTER_RATE || SubType ==PERF_COUNTER_QUEUELEN) 
        {

             // Need the delta time.  The data used for time delta is 
             // indicated by a subfield.

             if(TimerType == PERF_TIMER_TICK)
                 eTimeDelta = (((float)pLine->lnNewTime) - pLine->lnOldTime)/
                                    ((float)pLine->lnPerfFreq);
             else if(TimerType == PERF_TIMER_100NS)
                 eTimeDelta = ((float)pLine->lnNewTime100Ns) - pLine->lnOldTime100Ns;
             else
                 eTimeDelta = ((float)pLine->ObjCounterTimeNew -
                    pLine->ObjCounterTimeOld) / ((float)pLine->ObjPerfFreq);
             if(eTimeDelta == 0.0f)   // shouldnt happen, but delta can end
                    return 0.0f;    // up as a denominator.
        }
        if(SubType == PERF_COUNTER_FRACTION) 
        {

             // The base value is going to be used as the denominator.

             if(CalcMod & PERF_DELTA_BASE)
                eBaseDelta = (float)pLine->lnaCounterValue[1] - 
                                    pLine->lnaOldCounterValue[1];
            else
                eBaseDelta = (float)pLine->lnaCounterValue[1];
             if(eBaseDelta == 0.0f)   // shouldnt happen, but delta can end
                    return 0.0f;    // up as a denominator.
        }


        // Get the deta data value.

        if(CalcMod & PERF_DELTA_COUNTER)
            eDataDelta = (FLOAT)(pLine->lnaCounterValue[0] -
                    pLine->lnaOldCounterValue[0]);
        else
            eDataDelta = (FLOAT)pLine->lnaCounterValue[0];

        // Apply the appropriate formula

        switch(SubType) 
        {
             case PERF_COUNTER_VALUE:
                 fRet = eDataDelta;
                 break;
             case PERF_COUNTER_RATE:
                 fRet = eDataDelta / eTimeDelta;
                 break;
             case PERF_COUNTER_FRACTION:
                 fRet = ((FLOAT)eDataDelta)/eBaseDelta;
                 break;
             case PERF_COUNTER_ELAPSED:
                 if(TimerType == PERF_OBJECT_TIMER)
                    fRet = ((float)pLine->ObjCounterTimeNew - pLine->lnaCounterValue[0]) /
                                ((float)pLine->ObjPerfFreq);
                 else if(TimerType == PERF_TIMER_TICK)
                    fRet = ((float)pLine->lnNewTime - pLine->lnaCounterValue[0]) /
                                ((float)pLine->lnPerfFreq);
                 else 
                    fRet = (((float)pLine->lnNewTime100Ns) - pLine->lnaCounterValue[0]);
                 break;
             case PERF_COUNTER_QUEUELEN:
                 fRet = (FLOAT)pLine->lnaCounterValue[0];
                 fRet = (fRet + (pLine->lnNewTime *pLine->lnaCounterValue[1]))/
                    eTimeDelta; 
                 break;
             default:
                 fRet = (FLOAT)pLine->lnaCounterValue[0];
        }
            
        // Apply the final modifiers for "counters"

        if(CalcMod & PERF_INVERSE_COUNTER)
            fRet = 1.0f - fRet;
        if(Display == PERF_DISPLAY_PERCENT)
            fRet *= 100.0f;
        }
    return fRet;
 }


// ***************************************************************************
//  FLOAT CounterEntry
//  
//  DESCRIPTION:
//  
//  Main routine for converting perf data.  In general this routine is
//  just a swither for the actual routines that do the conversion.
//  
//  PARAMETERS:
//  
//  pLine       Line structure containing data to perform computations on
//  
//  RETURN VALUE:
//  
//  Floating point representation of outcome, 0.0 if error
// ***************************************************************************

FLOAT CounterEntry (
        IN PLINESTRUCT pLine)
{
    switch (pLine->lnCounterType) 
    {
        case  PERF_COUNTER_COUNTER:
            return Counter_Counter_Common(pLine, 0);

        case  PERF_COUNTER_TIMER:
        case  PERF_PRECISION_SYSTEM_TIMER:
            return Counter_Timer_Common(pLine, 0);

        case  PERF_COUNTER_BULK_COUNT:
            return Counter_Counter_Common(pLine, BULK);

        case  PERF_COUNTER_TEXT:
            return 0.0f;

        case  PERF_COUNTER_RAWCOUNT:
        case  PERF_COUNTER_RAWCOUNT_HEX:
            return (FLOAT) ((DWORD) (pLine->lnaCounterValue[0]));

        case  PERF_COUNTER_LARGE_RAWCOUNT:
        case  PERF_COUNTER_LARGE_RAWCOUNT_HEX:
            return (FLOAT) (pLine->lnaCounterValue[0]);

        case  PERF_SAMPLE_FRACTION:
            return Sample_Common(pLine, FRACTION);

        case  PERF_SAMPLE_COUNTER:
            return Sample_Common(pLine, 0);

        case  PERF_COUNTER_NODATA:
            return 0.0f;

        case  PERF_COUNTER_TIMER_INV:
            return Counter_Timer_Common(pLine, INVERT);

        case  PERF_RAW_BASE:
//      case  PERF_SAMPLE_BASE:
//      case  PERF_AVERAGE_BASE:
            return 0.0f;

        case  PERF_AVERAGE_TIMER:
            return Counter_Average_Timer(pLine); 

        case  PERF_AVERAGE_BULK:
            return Counter_Average_Bulk (pLine);

        case  PERF_100NSEC_TIMER:
        case  PERF_PRECISION_100NS_TIMER:
            return Counter_Timer_Common(pLine, NS100);

        case  PERF_100NSEC_TIMER_INV:
            return Counter_Timer_Common(pLine, NS100_INVERT);

        case  PERF_COUNTER_MULTI_TIMER:
            return Counter_Timer_Common(pLine, TIMER_MULTI);

        case  PERF_COUNTER_MULTI_TIMER_INV:
            return Counter_Timer_Common(pLine, TIMER_MULTI_INVERT);

        case  PERF_COUNTER_MULTI_BASE:
            return 0.0f;

        case  PERF_100NSEC_MULTI_TIMER:
            return Counter_Timer_Common(pLine, NS100_MULTI);
                 
        case  PERF_100NSEC_MULTI_TIMER_INV:
            return Counter_Timer_Common(pLine, NS100_MULTI_INVERT);

        case  PERF_COUNTER_LARGE_QUEUELEN_TYPE:
            return Counter_Queuelen(pLine, TRUE, FALSE);

        case PERF_COUNTER_100NS_QUEUELEN_TYPE:
            return Counter_Queuelen(pLine, TRUE, TRUE);

        case  PERF_COUNTER_QUEUELEN_TYPE:
            return Counter_Queuelen(pLine, FALSE, FALSE);

        case  PERF_RAW_FRACTION:
        case  PERF_LARGE_RAW_FRACTION:
            return Counter_Raw_Fraction (pLine);
        case  PERF_COUNTER_DELTA:
            return Counter_Delta(pLine, FALSE);
        case  PERF_COUNTER_LARGE_DELTA:
            return Counter_Delta(pLine, TRUE);

        case  PERF_ELAPSED_TIME:
            return eElapsedTime (pLine, 0); 
        default:
            return GenericConv (pLine);

    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\winmgmt\stdprov\crc32.h ===
/*++

Copyright (C) 1997-2001 Microsoft Corporation

Module Name:

    CRC32.H

Abstract:

    Standard CRC-32 implementation

History:

	raymcc      07-Jul-97       Createada

--*/

#ifndef _CRC_H_
#define _CRC_H_

#define STARTING_CRC32_VALUE    0xFFFFFFFF

DWORD UpdateCRC32(
    LPBYTE  pSrc,               // Points to buffer
    int     nBytes,             // Number of bytes to compute
    DWORD   dwOldCrc            // Must be STARTING_CRC_VALUE (0xFFFFFFFF) 
                                // if no previous CRC, otherwise this is the
                                // CRC of the previous cycle.
    );

#define FINALIZE_CRC32(x)    (x=~x)

/*
The CRC holding value must be preinitialized to STARTING_CRC32_VALUE
UpdateCRC32() may be called as many times as necessary on a single buffer.  
When computing the CRC32

The final value must be post-processed using the FINALIZE_CRC32() macro.

Example:

void main()
{
    BYTE Data[] = { 1, 2, 3 };

    DWORD dwCRC = STARTING_CRC32_VALUE;

    dwCRC = UpdateCRC32(Data, 3, dwCRC);

    FINALIZE_CRC32(dwCRC);

    printf("CRC32 = 0x%X\n", dwCRC);
}

*/


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\winmgmt\stdprov\crc32.cpp ===
/*++

Copyright (C) 1997-2001 Microsoft Corporation

Module Name:

    CRC32.CPP

Abstract:

    Standard CRC-32 implementation

History:

    raymcc      07-Jul-97       Createada

--*/

#include "precomp.h"
#include <stdio.h>
#include <crc32.h>

static DWORD CrcTable[] =
{
0x00000000, 0x77073096, 0xee0e612c, 0x990951ba, 0x076dc419, 0x706af48f, 0xe963a535, 0x9e6495a3,
0x0edb8832, 0x79dcb8a4, 0xe0d5e91e, 0x97d2d988, 0x09b64c2b, 0x7eb17cbd, 0xe7b82d07, 0x90bf1d91,
0x1db71064, 0x6ab020f2, 0xf3b97148, 0x84be41de, 0x1adad47d, 0x6ddde4eb, 0xf4d4b551, 0x83d385c7,
0x136c9856, 0x646ba8c0, 0xfd62f97a, 0x8a65c9ec, 0x14015c4f, 0x63066cd9, 0xfa0f3d63, 0x8d080df5,
0x3b6e20c8, 0x4c69105e, 0xd56041e4, 0xa2677172, 0x3c03e4d1, 0x4b04d447, 0xd20d85fd, 0xa50ab56b,
0x35b5a8fa, 0x42b2986c, 0xdbbbc9d6, 0xacbcf940, 0x32d86ce3, 0x45df5c75, 0xdcd60dcf, 0xabd13d59,
0x26d930ac, 0x51de003a, 0xc8d75180, 0xbfd06116, 0x21b4f4b5, 0x56b3c423, 0xcfba9599, 0xb8bda50f,
0x2802b89e, 0x5f058808, 0xc60cd9b2, 0xb10be924, 0x2f6f7c87, 0x58684c11, 0xc1611dab, 0xb6662d3d,
0x76dc4190, 0x01db7106, 0x98d220bc, 0xefd5102a, 0x71b18589, 0x06b6b51f, 0x9fbfe4a5, 0xe8b8d433,
0x7807c9a2, 0x0f00f934, 0x9609a88e, 0xe10e9818, 0x7f6a0dbb, 0x086d3d2d, 0x91646c97, 0xe6635c01,
0x6b6b51f4, 0x1c6c6162, 0x856530d8, 0xf262004e, 0x6c0695ed, 0x1b01a57b, 0x8208f4c1, 0xf50fc457,
0x65b0d9c6, 0x12b7e950, 0x8bbeb8ea, 0xfcb9887c, 0x62dd1ddf, 0x15da2d49, 0x8cd37cf3, 0xfbd44c65,
0x4db26158, 0x3ab551ce, 0xa3bc0074, 0xd4bb30e2, 0x4adfa541, 0x3dd895d7, 0xa4d1c46d, 0xd3d6f4fb,
0x4369e96a, 0x346ed9fc, 0xad678846, 0xda60b8d0, 0x44042d73, 0x33031de5, 0xaa0a4c5f, 0xdd0d7cc9,
0x5005713c, 0x270241aa, 0xbe0b1010, 0xc90c2086, 0x5768b525, 0x206f85b3, 0xb966d409, 0xce61e49f,
0x5edef90e, 0x29d9c998, 0xb0d09822, 0xc7d7a8b4, 0x59b33d17, 0x2eb40d81, 0xb7bd5c3b, 0xc0ba6cad,
0xedb88320, 0x9abfb3b6, 0x03b6e20c, 0x74b1d29a, 0xead54739, 0x9dd277af, 0x04db2615, 0x73dc1683,
0xe3630b12, 0x94643b84, 0x0d6d6a3e, 0x7a6a5aa8, 0xe40ecf0b, 0x9309ff9d, 0x0a00ae27, 0x7d079eb1,
0xf00f9344, 0x8708a3d2, 0x1e01f268, 0x6906c2fe, 0xf762575d, 0x806567cb, 0x196c3671, 0x6e6b06e7,
0xfed41b76, 0x89d32be0, 0x10da7a5a, 0x67dd4acc, 0xf9b9df6f, 0x8ebeeff9, 0x17b7be43, 0x60b08ed5,
0xd6d6a3e8, 0xa1d1937e, 0x38d8c2c4, 0x4fdff252, 0xd1bb67f1, 0xa6bc5767, 0x3fb506dd, 0x48b2364b,
0xd80d2bda, 0xaf0a1b4c, 0x36034af6, 0x41047a60, 0xdf60efc3, 0xa867df55, 0x316e8eef, 0x4669be79,
0xcb61b38c, 0xbc66831a, 0x256fd2a0, 0x5268e236, 0xcc0c7795, 0xbb0b4703, 0x220216b9, 0x5505262f,
0xc5ba3bbe, 0xb2bd0b28, 0x2bb45a92, 0x5cb36a04, 0xc2d7ffa7, 0xb5d0cf31, 0x2cd99e8b, 0x5bdeae1d,
0x9b64c2b0, 0xec63f226, 0x756aa39c, 0x026d930a, 0x9c0906a9, 0xeb0e363f, 0x72076785, 0x05005713,
0x95bf4a82, 0xe2b87a14, 0x7bb12bae, 0x0cb61b38, 0x92d28e9b, 0xe5d5be0d, 0x7cdcefb7, 0x0bdbdf21,
0x86d3d2d4, 0xf1d4e242, 0x68ddb3f8, 0x1fda836e, 0x81be16cd, 0xf6b9265b, 0x6fb077e1, 0x18b74777,
0x88085ae6, 0xff0f6a70, 0x66063bca, 0x11010b5c, 0x8f659eff, 0xf862ae69, 0x616bffd3, 0x166ccf45,
0xa00ae278, 0xd70dd2ee, 0x4e048354, 0x3903b3c2, 0xa7672661, 0xd06016f7, 0x4969474d, 0x3e6e77db,
0xaed16a4a, 0xd9d65adc, 0x40df0b66, 0x37d83bf0, 0xa9bcae53, 0xdebb9ec5, 0x47b2cf7f, 0x30b5ffe9,
0xbdbdf21c, 0xcabac28a, 0x53b39330, 0x24b4a3a6, 0xbad03605, 0xcdd70693, 0x54de5729, 0x23d967bf,
0xb3667a2e, 0xc4614ab8, 0x5d681b02, 0x2a6f2b94, 0xb40bbe37, 0xc30c8ea1, 0x5a05df1b, 0x2d02ef8d
};


DWORD UpdateCRC32(
    LPBYTE  pSrc,               // Points to buffer
    int     nBytes,             // Number of bytes to compute
    DWORD   dwOldCrc            // Must be 0xFFFFFFFF if no previous CRC
    )
{
    if(nBytes == 0)
        return dwOldCrc;

    DWORD dwNewCrc = 0;

    for (int n = 0; n < nBytes; n++)
    {
        dwNewCrc = CrcTable[ BYTE(dwOldCrc ^ DWORD(pSrc[n]))] 
            ^ ((dwOldCrc >> 8) & 0x00FFFFFF);
        dwOldCrc = dwNewCrc;            
    }
    
    return dwNewCrc;
}
    

/*
void main(int argc, char **argv)
{
    if (argc < 2)
    {
        return;
    }

    FILE *f = fopen(argv[1], "rb");
    
    DWORD dwCrc = STARTING_CRC32_VALUE;
    
    int nBytes = 0;

    while (1)
    {
        BYTE Buf[256];
        
        int nRes = fread(Buf, 1, 256, f);

        nBytes += nRes;

        if (nRes == 0)
            break;
            
        if (nRes != 0)
        {
            dwCrc = UpdateCRC32(Buf, nRes, dwCrc);
        }
    }        

    FINALIZE_CRC32(dwCrc);
    
    fclose(f);

    printf("Bytes = %d\n", nBytes);
        
    printf("CRC32 is 0x%X\n", dwCrc);
}

*/
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\winmgmt\stdprov\cvariant.h ===
/*++

Copyright (C) 1995-2001 Microsoft Corporation

Module Name:

    CVARIANT.H

Abstract:

	Declares the CVariantClass

History:

	a-davj  9-27-95   Created.

--*/

#ifndef _CVARIANT_H_
#define _CVARIANT_H_

#include "stdprov.h"

//***************************************************************************
//
//  CLASS NAME:
//
//  CVariant
//
//  DESCRIPTION:
//
//  A wrapper around the VARIANT stucture.  
//
//***************************************************************************

class CVariant : public CObject {
    public:

    CVariant();
    CVariant(LPWSTR pwcStr);
    SCODE SetData(void * pData, VARTYPE vt, int iSize = -1);
    SCODE GetData(void ** pData, DWORD dwRegType, DWORD * pdwSize);
    SCODE DoPut(long lFlags,IWbemClassObject FAR *,BSTR PropName, CVariant * pVar);
    ~CVariant();
    void SetType(VARTYPE vtNew){var.vt =  vtNew;};
    VARTYPE GetType(){return var.vt;};
    void * GetDataPtr(){return (void *)&var.lVal;};
    VARIANT * GetVarPtr(){return &var;};
    BSTR GetBstr(){return var.bstrVal;};
    BOOL bGetBOOL(){return var.boolVal;};
    DWORD GetNumElements(void);
    BOOL IsArray(void){return var.vt & VT_ARRAY;};
    SCODE ChangeType(VARTYPE vtNew);    
    void Clear(void);
    
    private:
    VARIANT var;
    int CalcNumStrings(TCHAR *pTest);
    SCODE SetArrayData(void * pData,VARTYPE vtSimple, int iSize);
    SCODE GetArrayData(void ** pData,  DWORD * pdwSize);

};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\winmgmt\stdprov\enuminst.cpp ===
/*++

Copyright (C) 1995-2001 Microsoft Corporation

Module Name:

    ENUMINST.CPP

Abstract:

	Implements the CEnumInst class which enumerates instances.

History:

	a-davj  19-Oct-95   Created.

--*/

#include "precomp.h"
#include "impdyn.h"

//***************************************************************************
//
//  CCFDyn::CCFDyn
//
//  DESCRIPTION:
//
//  Constructor.
//
//  PARAMETERS:
//
//  pEnumInfo       Object which enumerates the key values
//  lFlags          flags passed to the CreateInstanceEnum call
//  pClass          name of the class
//  pWBEMGateway     pointer to WBEM core
//  pProvider       pointer to provider obect which was asked to create
//                  the enumerator.
//***************************************************************************

CEnumInst::CEnumInst(
            IN CEnumInfo * pEnumInfo,
            IN long lFlags,
            IN WCHAR * pClass, 
            IN IWbemServices FAR* pWBEMGateway,
            IN CImpDyn * pProvider,
            IWbemContext  *pCtx):
            m_iIndex(0), m_pEnumInfo(0),m_pwcClass(0), m_lFlags(0), m_pCtx(0),  m_pWBEMGateway(0), 
            m_pProvider(0), m_cRef(0), m_bstrKeyName(0),  m_PropContextCache()
            
{
    DWORD dwLen = wcslen(pClass)+1;
    m_pwcClass = new WCHAR[dwLen];
    if(m_pwcClass == NULL) return;

    StringCchCopyW (m_pwcClass, dwLen, pClass);
    m_pWBEMGateway = pWBEMGateway;
    m_pWBEMGateway->AddRef();
    m_pProvider = pProvider;
    m_pProvider->AddRef();
    m_lFlags = lFlags;
    m_pEnumInfo = pEnumInfo;
    m_pEnumInfo->AddRef();
    m_pCtx = pCtx;
    if(pCtx) pCtx->AddRef();
    InterlockedIncrement(&lObj);

	// Get the KeyName

	IWbemClassObject * pClassObj = NULL;
    SCODE sc = m_pWBEMGateway->GetObject(pClass,0,m_pCtx,&pClassObj,NULL);
    if(FAILED(sc)) return;
    
	m_bstrKeyName = m_pProvider->GetKeyName(pClassObj);
	pClassObj->Release();
}

//***************************************************************************
//
//  CCFDyn::~CCFDyn
//
//  DESCRIPTION:
//
//  Destructor.
//
//***************************************************************************

CEnumInst::~CEnumInst(void)
{
    if(m_pwcClass)
        delete m_pwcClass;
    if(m_pWBEMGateway != NULL) {
        m_pWBEMGateway->Release();
        m_pProvider->Release();
        m_pEnumInfo->Release();
        InterlockedDecrement(&lObj);
        }
    if(m_pEnumInfo != NULL)
        delete m_pEnumInfo;
    if(m_pCtx)
        m_pCtx->Release();
	if(m_bstrKeyName)
		SysFreeString(m_bstrKeyName);
    return;
}

//***************************************************************************
// HRESULT CEnumInst::QueryInterface
// long CEnumInst::AddRef
// long CEnumInst::Release
//
// DESCRIPTION:
//
// Standard Com IUNKNOWN functions.
//
//***************************************************************************

STDMETHODIMP CEnumInst::QueryInterface(
                IN REFIID riid,
                OUT PPVOID ppv)
{
    *ppv=NULL;

    if ((IID_IUnknown==riid || IID_IEnumWbemClassObject==riid)
                            && m_pWBEMGateway != NULL) 
    {
        *ppv=this;
        AddRef();
        return NOERROR;
    }
    else
        return ResultFromScode(E_NOINTERFACE);
}

STDMETHODIMP_(ULONG) CEnumInst::AddRef(void)
{
    return InterlockedIncrement(&m_cRef);
}

STDMETHODIMP_(ULONG) CEnumInst::Release(void)
{
    long lRet = InterlockedDecrement(&m_cRef);
    if (0L!=lRet)
        return lRet;
    delete this;
    return 0L;
}

//***************************************************************************
//
//  CEnumInst::Reset
//
//  DESCRIPTION:
//
//  Sets pointer back to first element.
//
//  RETURN VALUES:
//
//  S_OK
//
//***************************************************************************

STDMETHODIMP CEnumInst::Reset()
{
    m_iIndex = 0;
    return S_OK;
}

//***************************************************************************
//
//  CEnumInst::Clone
//
//  DESCRIPTION:
//
//  Create a duplicate of the enumerator
//
//  PARAMETERS:
//
//  pEnum       Set to point to duplicate.
//
//  RETURN VALUES:
// 
//  S_OK                    if all is well
//  WBEM_E_OUT_OF_MEMORY     if out of memory
//  WBEM_E_INVALID_PARAMETER if passed a null
//
//***************************************************************************

STDMETHODIMP CEnumInst::Clone(
    OUT IEnumWbemClassObject FAR* FAR* pEnum)
{
    CEnumInst * pEnumObj;
    SCODE sc;
    if(pEnum == NULL)
        return WBEM_E_INVALID_PARAMETER;

    pEnumObj=new CEnumInst(m_pEnumInfo,m_lFlags,m_pwcClass, 
                                m_pWBEMGateway,m_pProvider, m_pCtx);
    if(pEnumObj == NULL)
        return WBEM_E_OUT_OF_MEMORY;
    sc = pEnumObj->QueryInterface(IID_IEnumWbemClassObject,(void **) pEnum);
    if(FAILED(sc))
        delete pEnumObj;
    pEnumObj->m_iIndex = m_iIndex;
    return S_OK;
}


//***************************************************************************
//
//  CEnumInst::Skip
//
//  DESCRIPTION:
//
//  Skips one or more elements in the enumeration.
//
//  PARAMETERS:
//
//  nNum        number of elements to skip
//
//  RETURN VALUES:
//
//  S_OK        if we still are not past the end of the list
//  S_FALSE     if requested skip number would go beyond the end of the list
//
//***************************************************************************

STDMETHODIMP CEnumInst::Skip(long lTimeout,
                IN ULONG nNum)
{
    SCODE sc;;
    int iTest = m_iIndex + nNum;    
    LPWSTR pwcKey;
    sc = m_pProvider->GetKey(m_pEnumInfo,iTest,&pwcKey);
    if(sc == S_OK) {
        delete pwcKey;
        m_iIndex = iTest;
        return S_OK;
        }
    return S_FALSE;
}

//***************************************************************************
//
//  CEnumInst::Next
//
//  DESCRIPTION:
//
//  Returns one or more instances.
//
//  PARAMETERS:
//
//  uCount      Number of instances to return.
//  pObj        Pointer to array of objects.
//  puReturned  Pointer to number of objects successfully returned.
//
//  RETURN VALUES:
//  S_OK if all the request instances are returned.  Note that WBEM_E_FAILED
//  is returned even if there are some instances returned so long as the 
//  number is less than uCount. Also WBEM_E_INVALID_PARAMETER may be
//  return if the arguments are bogus. 
//
//***************************************************************************

STDMETHODIMP CEnumInst::Next(long lTimeout,
                            IN ULONG uCount, 
                            OUT IWbemClassObject FAR* FAR* pObj, 
                            OUT ULONG FAR* puReturned)
{
    ULONG uIndex;
    SCODE sc;
    LPWSTR pwcKey;
    if(pObj == NULL || puReturned == NULL)
        return WBEM_E_INVALID_PARAMETER;
    IWbemClassObject FAR* FAR* pNewInst = pObj;
    *puReturned = 0;
    for(uIndex = 0; uIndex < uCount; ) 
    {
        sc = m_pProvider->GetKey(m_pEnumInfo,m_iIndex,&pwcKey);
        m_iIndex++;
        if(sc != S_OK) 
            break;  // if no more in registry, then we are done
        sc = m_pProvider->CreateInst(m_pWBEMGateway,m_pwcClass,
                                    pwcKey,pNewInst,m_bstrKeyName,
                                    &m_PropContextCache, m_pCtx);
        delete pwcKey;
        if(sc == S_OK)
        {
            uIndex++;
            pNewInst++;
            (*puReturned)++;  // add one to number of objects created
        }
    }
    return (uIndex == uCount) ? S_OK : WBEM_E_FAILED;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\winmgmt\stdprov\dataconv.cpp ===
/*++

Copyright (C) 1995-2001 Microsoft Corporation

Module Name:

    DATACONV.CPP

Abstract:

	Provides a some generic data conversion routines.  In particular,
	OMSVariantChangeType and OMSVariantClear provide the same
	capabilities as the Ole VariantChangeType and VariantClear
	functions except that the OMS versions handle more data types.

History:

	a-davj  19-Oct-95   Created.

--*/

#include "precomp.h"

#include "resource.h"
#include "CVariant.h"
#include <ole2.h>


//***************************************************************************
//
//  char * WideToNarrow
//
//  DESCRIPTION:
//
//  Takes a WCHAR string and creates a MBS equivalent.  The caller should
//  free the string when done.
//
//  PARAMETERS:
//
//  pConv       UNICODE string to convert.
//
//  RETURN VALUE:
//
//  NULL if out of memory, otherwise a mbs string that the caller should free
//  via CoTaskMemFree.
//
//***************************************************************************

char * WideToNarrow(
        IN LPCWSTR pConv)
{
    char * cpRet = NULL;
    int iMBSLen = wcstombs(NULL,pConv,0) + 1;
    if(iMBSLen == 0)
        return NULL;
    cpRet = (char *)CoTaskMemAlloc(iMBSLen);
    if(cpRet)
    {
        memset(cpRet, 0, iMBSLen);
        wcstombs(cpRet,pConv,iMBSLen);
    }
    return cpRet;
}

int gDiag;

char * WideToNarrowA(
        IN LPCWSTR pConv)
{
    char * cpRet = NULL;
    int iMBSLen = wcstombs(NULL,pConv,0) + 1;
    if(iMBSLen == 0)
        return NULL;
    cpRet = new char[iMBSLen];
    gDiag = iMBSLen;
    if(cpRet)
    {
        memset(cpRet, 0, iMBSLen);
        wcstombs(cpRet,pConv,iMBSLen);
    }
    return cpRet;
}
//***************************************************************************
//
//  SAFEARRAY * OMSSafeArrayCreate
//
//  DESCRIPTION:
//
//  Creates a safe array.  
//
//  PARAMETERS:
//
//  vt              element type
//  iNumElements    number of elements
//
//  RETURN VALUE:
//
//  Returns null if there is a problem.
//
//***************************************************************************

SAFEARRAY * OMSSafeArrayCreate(
                IN VARTYPE vt,
                IN int iNumElements)
{
    if(iTypeSize(vt) < 1 || iNumElements < 1)
        return NULL;
    SAFEARRAYBOUND rgsabound[1];
    rgsabound[0].lLbound = 0;
    rgsabound[0].cElements = iNumElements;
    return SafeArrayCreate(vt,1,rgsabound);
}

//***************************************************************************
//
//  SCODE OMSVariantChangeType
//
//  DESCRIPTION:
//
//  Converts a variant from one type into another.  This functions takes the
//  same arguments and does the same action as the standard 
//  VariantChangeType except that it also handles arrays.
//
//
//  PARAMETERS:
//
//  pDest       points to the variant which is to be updated
//  pSrc        points to the variant that is the source
//  wFlags      flags which are passed on to VariantChangeType
//  vtDest      Type that the pDest is conveted to
//
//  RETURN VALUE:
//
//  S_OK                        All is well.
//  WBEM_E_INVALID_PARAMETER     Invalid argument
//  WBEM_E_OUT_OF_MEMORY         Out of memory
//  otherwise various return codes from VariantChangeType, or safe array
//  manipulation
//
//***************************************************************************

HRESULT OMSVariantChangeType(
            IN OUT VARIANTARG * pDest, 
            IN VARIANTARG *pSrc, 
            IN USHORT wFlags, 
            IN VARTYPE vtDest)
{
    SCODE sc;

    // Verify arguments and clear out the destination

    if(pDest == NULL || pSrc == NULL || iTypeSize(vtDest)<1 || iTypeSize(pSrc->vt)<1)
        return WBEM_E_INVALID_PARAMETER;          // Junk args
    OMSVariantClear(pDest);

    // if both are arrays,

    if(vtDest & VT_ARRAY && pSrc->vt & VT_ARRAY) {

        // Set the VARTYPES without the VT_ARRAY bits

        VARTYPE vtDestSimple = vtDest & ~VT_ARRAY;
        VARTYPE vtSrcSimple = pSrc->vt &~ VT_ARRAY;

        // Determine the size of the source array.  Also make sure that the array 
        // only has one dimension

        unsigned int uDim = SafeArrayGetDim(pSrc->parray);
        if(uDim != 1)
            return WBEM_E_FAILED;      // Bad array, or too many dimensions
        long ix[2] = {0,0};
        long lLower, lUpper;
        sc = SafeArrayGetLBound(pSrc->parray,1,&lLower);
        if(sc != S_OK)
            return sc;
        sc = SafeArrayGetUBound(pSrc->parray,1,&lUpper);
        if(sc != S_OK)
            return sc;
        int iNumElements = lUpper - lLower +1; 

        // Create a destination array of equal size

        SAFEARRAY * pDestArray = OMSSafeArrayCreate(vtDestSimple,iNumElements);
        if(pDestArray == NULL)
            return WBEM_E_FAILED;  // Most likely a bad type!

        // For each element in the source array

        for(ix[0] = lLower; ix[0] <= lUpper && sc == S_OK; ix[0]++) {
 
            CVariant varSrc, varDest;
                   
            // Set Temp CVariant to the source data

            sc = SafeArrayGetElement(pSrc->parray,ix,varSrc.GetDataPtr());
            if(sc != S_OK)
                break;
            varSrc.SetType(vtSrcSimple);

            // Convert to destination data using VariantConvert
            
            sc = VariantChangeType(varDest.GetVarPtr(),varSrc.GetVarPtr(),wFlags,vtDestSimple);
            if(sc != S_OK)
                break;

            // Set destination data into the array
            
            if(vtDestSimple == VT_BSTR || vtDestSimple == VT_UNKNOWN || 
                                                    vtDestSimple == VT_DISPATCH)
                sc = SafeArrayPutElement(pDestArray,ix,(void *)varDest.GetBstr());
            else
                sc = SafeArrayPutElement(pDestArray,ix,(void *)varDest.GetDataPtr());

            }

        if(sc != S_OK){
            SafeArrayDestroy(pDestArray);
            }
        else {
            // set the VARTYPE of the destination

            pDest->vt = vtDest;
            pDest->parray = pDestArray;
            }
        return sc;
        }
    
    // if one, but not the other is an array, bail out

    if(vtDest & VT_ARRAY || pSrc->vt & VT_ARRAY) 
        return WBEM_E_FAILED;

    // Attempt to use standard conversion

    return VariantChangeType(pDest,pSrc,wFlags,vtDest);
   
}

//***************************************************************************
//
//  OMSVariantClear
//
//  DESCRIPTION:
//
//  Does the same as the Ole VariantClear function except
//  that it also sets the data to all 0.
//
//  PARAMETERS:
//
//  pClear      Variant to be cleared.
//
//  RETURN VALUE:
//
//  Result from VariantClear, most always S_OK
//
//***************************************************************************

HRESULT OMSVariantClear(
            IN OUT VARIANTARG * pClear)
{
    HRESULT sc;
    sc = VariantClear(pClear);
    memset((void *)&pClear->lVal,0,8);
    return sc;
}

//***************************************************************************
//
//  int ITypeSize
//
//  DESCRIPTION:
//
//  Gets the number of bytes acutally used to store
//  a variant type.  0 if the type is unknown 
//
//  PARAMETERS:
//
//  vtTest      Type in question.
//
//
//  RETURN VALUE:
//
//  see description
//
//***************************************************************************

int iTypeSize(
        IN VARTYPE vtTest)
{
    int iRet;
    vtTest &= ~ VT_ARRAY; // get rid of possible array bit
    switch (vtTest) {
        case VT_UI1:
        case VT_LPSTR:
            iRet = 1;
            break;
        case VT_LPWSTR:
        case VT_BSTR:
        case VT_I2:
            iRet = 2;
            break;
        case VT_I4:
        case VT_R4:
            iRet = 4;
            break;
        case VT_R8:
            iRet = 8;
            break;
        case VT_BOOL:
            iRet = sizeof(VARIANT_BOOL);
            break;
        case VT_ERROR:
            iRet = sizeof(SCODE);
            break;
        case VT_CY:
            iRet = sizeof(CY);
            break;
        case VT_DATE:
            iRet = sizeof(DATE);
            break;
        case CIM_SINT64:
        case CIM_UINT64:
            iRet = 8;
            break;

        default:
            iRet = 0;
        }
    return iRet;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\winmgmt\stdprov\cvariant.cpp ===
/*++

Copyright (C) 1995-2001 Microsoft Corporation

Module Name:

    CVARIANT.CPP

Abstract:

	Defines the CVarinat class which is a purpose object to 
	wrap VARIANT structures.

History:

	a-davj  4-27-95 Created.

--*/


#include "precomp.h"
#include "impdyn.h"
#include "cvariant.h"
//#include <afxpriv.h>

BSTR SysAllocBstrFromTCHAR(TCHAR * pFrom)
{
#ifdef UNICODE
    return SysAllocString(pFrom);
#else
	WCHAR * pTemp = new WCHAR[lstrlen(pFrom)+1];
	if(pTemp == NULL)
		return NULL;
	mbstowcs(pTemp, pFrom,  lstrlen(pFrom)+1);
	BSTR bRet = SysAllocString(pTemp);
	delete pTemp;
	return bRet;
#endif
}
//***************************************************************************
//
//  int CVariant::CalcNumStrings
//
//  DESCRIPTION:
//
//  Calculates the number of strings
//
//  PARAMETERS:
//
//  pTest   points to string to test
//
//  RETURN VALUE:
//  Return - the number of strings in a multistring block.
//
//***************************************************************************

int CVariant::CalcNumStrings(
        IN TCHAR *pTest)
{
    int iRet = 0;
    if(pTest == NULL)
        return 0;
    while(*pTest) 
    {
        iRet++;
        pTest += lstrlen(pTest)+1;
    }
    return iRet;
}

//***************************************************************************
//
//  CVariant::ChangeType
//
//  DESCRIPTION:
//  
//  Changes the CVariant data into a new type.
//
//  PARAMETERS:
//
//  vtNew   Type to convert to
//
//  RETURN VALUE:
//
//  S_OK if alright, otherwise an error set by OMSVariantChangeType
//
//***************************************************************************

SCODE CVariant::ChangeType(
        IN VARTYPE vtNew)
{
    SCODE sc;

    // if type doesnt need changing, then already done!

    if(vtNew == var.vt)
        return S_OK;

    // Create and initialize a temp VARIANT

    VARIANTARG vTemp;
    VariantInit(&vTemp);
    
    // Change to the desired type.  Then delete the current value
    // and copy the temp copy

    sc = OMSVariantChangeType(&vTemp,&var,0,vtNew);
    OMSVariantClear(&var);
    
    var = vTemp; // structure copy
    return sc;
}

//***************************************************************************
//
//  CVariant::Clear
//
//  DESCRIPTION:
//
//  Clears out the VARIANT.
//
//***************************************************************************

void CVariant::Clear(void)
{
    OMSVariantClear(&var);
}


//***************************************************************************
//
//  CVariant::
//  CVariant::~CVariant
//
//  DESCRIPTION:
//
//  Constructor and destructor.
//
//***************************************************************************

CVariant::CVariant()
{
    VariantInit(&var);
    memset((void *)&var.lVal,0,8);
}

CVariant::CVariant(LPWSTR pwcStr)
{
    VariantInit(&var);
    if(pwcStr)
    {
        var.bstrVal = SysAllocString(pwcStr);
        if(var.bstrVal)
            var.vt = VT_BSTR;
    }
}

CVariant::~CVariant()
{
    OMSVariantClear(&var);
}


//***************************************************************************
//
//  SCODE CVariant::DoPut
//
//  DESCRIPTION:
//
//  "Puts" the data out to the WBEM server (if pClassInt isnt NULL), or just
//  copies the data to the variant.
//
//  PARAMETERS:
//
//  lFlags      flags to pass along to wbem server
//  pClassInt   pointer to class/instance object
//  PropName    property name
//  pVar        variant value
//
//  RETURN VALUE:
//
//  S_OK if no error other wise see wbemsvc error codes when, pClass isnt
//  null, or see the OMSVariantChangeType function.
//
//***************************************************************************

SCODE CVariant::DoPut(
        IN long lFlags,
        IN IWbemClassObject FAR * pClassInt,
        IN BSTR PropName, 
        IN CVariant * pVar)
{
    SCODE sc;

    if(pClassInt)
    {

        sc = pClassInt->Put(PropName,lFlags,&var,0);
    }
    else if(pVar)
    {
        pVar->Clear();
        sc = OMSVariantChangeType(&pVar->var,&var,0,var.vt);
    }
    else sc = WBEM_E_FAILED;
    return sc;
}

//***************************************************************************
//
//  SCODE CVariant::GetArrayData
//
//  DESCRIPTION:
//
//  Converts array data into a single data block.  This is used by the 
//  registry provider when it writes out array data.
//
//  PARAMETERS:
//
//  ppData      pointer to the return data.  Note it is the job of the 
//              caller to free this when the return code is S_OK
//  pdwSize     Size of returned data
//
//  RETURN VALUE:
//
//  S_OK                if all is well
//  WBEM_E_OUT_OF_MEMORY when we memory allocation fails
//  WBEM_E_FAILED        when variant has bogus type.
//  ???                 when failure is in SafeArrayGetElement
//
//***************************************************************************

SCODE CVariant::GetArrayData(
        OUT void ** ppData, 
        OUT DWORD * pdwSize)
{
    SCODE sc;
    DWORD dwSoFar = 0;
    SAFEARRAY * psa;
    long ix[2] = {0,0};
    BYTE * pb;
    TCHAR * ptc;
    BOOL bString = ((var.vt & ~VT_ARRAY) == CHARTYPE ||(var.vt & ~VT_ARRAY) == VT_BSTR );

    int iNumElements = GetNumElements();

    int iSizeOfType = iTypeSize(var.vt);
    if(iSizeOfType < 1)
        return WBEM_E_FAILED;
    
    // Calculate necessary size;

    psa = var.parray;
    if(bString) {
        *pdwSize = CHARSIZE;       // 1 for the final double null!
        for(ix[0] = 0; ix[0] < iNumElements; ix[0]++) {
            BSTR bstr;
            sc = SafeArrayGetElement(psa,ix,&bstr);
            if(FAILED(sc))
                return sc;
#ifdef UNICODE
            *pdwSize += 2 * (wcslen(bstr) +1);
#else
            int iWCSLen  = wcslen(bstr) + 1;
            *pdwSize += wcstombs(NULL,bstr,iWCSLen) + 1;            
#endif
            SysFreeString(bstr);
            }
        }
    else {
        *pdwSize = iNumElements * iSizeOfType;
        }

    // Allocate the memory to be filled

    *ppData = CoTaskMemAlloc(*pdwSize);
    if(*ppData == NULL)
        return WBEM_E_OUT_OF_MEMORY;

    pb = (BYTE *)*ppData;
    ptc = (TCHAR *)*ppData;

    // loop for each array element

    sc = S_OK;
    for(ix[0] = 0; ix[0] < iNumElements && sc == S_OK; ix[0]++) {
        if (bString) {
            BSTR bstr;
            sc = SafeArrayGetElement(psa,ix,&bstr);
            if(sc != S_OK)
                break;
            DWORD dwBytesLeft  = *pdwSize-dwSoFar;
#ifdef UNICODE
            lstrcpyn(ptc,bstr,dwBytesLeft/2);
#else
            wcstombs(ptc,bstr,dwBytesLeft);
#endif
            dwSoFar += CHARSIZE * (lstrlen(ptc) + 1);
            ptc += lstrlen(ptc) + 1;
            SysFreeString(bstr);
            *ptc = 0;       // double null
            }
        else {
            sc = SafeArrayGetElement(psa,ix,pb);
            pb += iSizeOfType;
            }
         }
    if(sc != S_OK)
        CoTaskMemFree(*ppData);
    
    return S_OK;
}

//***************************************************************************
//
//  SCODE CVariant::GetData
//
//  DESCRIPTION:
//
//  Used by the registry provider to take the data from VARIANT arg format
//  into a raw block for output. Note that the data allocated and stuck into
//  *ppData should be freed using CoTaskMemFree!
//
//  PARAMETERS:
//
//  ppData      Pointer to output data.
//  dwRegType   Type to convert to
//  pdwSize     Pointer to size of returned data
//
//  RETURN VALUE:
//
//  S_OK if all is well, otherwise a error code which is set by either 
//  OMSVariantChangeType, or GetArrayData.
//
//***************************************************************************

SCODE CVariant::GetData(
        OUT void ** ppData, 
        IN DWORD dwRegType, 
        OUT DWORD * pdwSize)
{

    SCODE sc =  S_OK;

    // Determine the type it may need to be converted to.  Note that binary
    // data is not converted intentionally.

    switch(dwRegType) {
        case REG_DWORD:
            sc = ChangeType(VT_I4);
            break;
        case REG_SZ:
            sc = ChangeType(VT_BSTR);
            break;

        case REG_MULTI_SZ:
            sc = ChangeType(VT_BSTR | VT_ARRAY);
            break;
        default:
            break;
        }

    if(sc != S_OK)
        return sc;

    // Special case for arrays

    if(dwRegType == REG_BINARY || dwRegType == REG_MULTI_SZ)
        return GetArrayData(ppData, pdwSize);

    // Allocate some memory and move the data into it.

    if(dwRegType == REG_SZ) {
#ifdef UNICODE
        *pdwSize = 2 * (wcslen(var.bstrVal)+1);
        *ppData = CoTaskMemAlloc(*pdwSize);
        if(*ppData == NULL) 
            return WBEM_E_OUT_OF_MEMORY;
        StringCchCopyW((WCHAR *)*ppData, *pdwSize/sizeof(WCHAR),var.bstrVal);
#else
        *ppData = WideToNarrow(var.bstrVal);
        if(*ppData == NULL)
            return WBEM_E_OUT_OF_MEMORY;
        *pdwSize = lstrlenA((char *)*ppData)+1;
#endif
        }
    else {
        *pdwSize = iTypeSize(var.vt);
        *ppData = CoTaskMemAlloc(*pdwSize);
        if(*ppData == NULL)
            return WBEM_E_OUT_OF_MEMORY;
        memcpy(*ppData,(void *)&var.lVal,*pdwSize);
        }

    return S_OK;
}


//***************************************************************************
//
//  CVariant::GetNumElements
//
//  DESCRIPTION:
//
//  Gets the number of elements in an array. 
//
//  RETURN VALUE:
//
//  number of elements.  Scalers return a 1.
//
//***************************************************************************

DWORD CVariant::GetNumElements(void)
{
    SCODE sc;
    if(!IsArray())
        return 1;
    SAFEARRAY * psa = var.parray;
    long uLower, uUpper;
    sc = SafeArrayGetLBound(psa,1,&uLower);
    sc |= SafeArrayGetUBound(psa,1,&uUpper);
    if(sc != S_OK)
        return 0;
    else
        return uUpper - uLower +1;
}

//***************************************************************************
//
//  SCODE CVariant::SetArrayData
//
//  DESCRIPTION:
//
//  Sets the CVariant value using raw data.  Used by the reg provider.
//
//  PARAMETERS:
//
//  pData       pointer to data to set
//  vtSimple    Type to set the data to
//  iSize       size of data pointed to by pData
//
//  RETURN VALUE:
//
//  S_OK if OK.
//  WBEM_E_INVALID_PARAMETER if the arguments are bad
//  WBEM_E_OUT_OF_MEMORY     if out of memory
//  other wise error from SafeArrayPutElement
//
//***************************************************************************

SCODE CVariant::SetArrayData(
        IN void * pData, 
        IN VARTYPE vtSimple, 
        IN int iSize)
{
    SCODE sc;
    int iNumElements;
    BYTE * pNext;
    long ix[2] = {0,0};
    DWORD dwLeftOver = 0;
    int iSizeOfType = iTypeSize(vtSimple);
    
    if(pData  == NULL || iSizeOfType < 1 || iSize < 1)
        return WBEM_E_INVALID_PARAMETER; 
        
    // Calculate the number of elements and make sure it is a type that
    // is supported

    if(vtSimple == VT_BSTR) {
        iNumElements = CalcNumStrings((TCHAR *)pData);
        }
    else {
        iNumElements = iSize / iSizeOfType;
        dwLeftOver = iSize % iSizeOfType;
        }
    
    // Allocate array
    
    int iNumCreate = (dwLeftOver) ? iNumElements + 1 : iNumElements;
    SAFEARRAY * psa = OMSSafeArrayCreate(vtSimple,iNumCreate);
    if(psa == NULL)
        return WBEM_E_FAILED;

    // Set each element of the array

    for(ix[0] = 0, pNext = (BYTE *)pData; ix[0] < iNumElements; ix[0]++) {
        if(vtSimple == VT_BSTR) {
            BSTR bstr;
			bstr = SysAllocBstrFromTCHAR((LPTSTR)pNext);
            if(bstr == NULL)   {  // todo, free previously allocated strings!
                SafeArrayDestroy(psa);
                return WBEM_E_OUT_OF_MEMORY;
                }
            sc = SafeArrayPutElement(psa,ix,(void*)bstr);
            pNext += sizeof(TCHAR)*(lstrlen((TCHAR *)pNext) + 1);
            SysFreeString(bstr);
            }
        else {
            sc = SafeArrayPutElement(psa,ix,pNext);
            pNext += iSizeOfType;
            }
        if(sc) {    // todo, cleanup???
            SafeArrayDestroy(psa);
            return sc;
            }
        }

    // it is possible that the number of bytes being set doesnt evenly factor
    // into the type size.  For instance, there may be 10 bytes of registry
    // data being put into a DWORD array.  In this case, the last two bytes
    // are left overs

    if(dwLeftOver) {
        __int64 iTemp = 0;
        memcpy((void *)&iTemp,(void *)pNext,dwLeftOver);
        sc = SafeArrayPutElement(psa,ix,&iTemp);
        }

    var.vt = vtSimple | VT_ARRAY;
    var.parray = psa;
    return S_OK;
}

//***************************************************************************
//
// CVariant::SetData
//
//  Sets the CVariant value using raw data.  Used by the reg provider.
//
//  DESCRIPTION:
//
//  PARAMETERS:
//
//  pData       Data to be set
//  vtChangeTo  Type to change the data to
//  iSize       size of data pointed to by pData
//
//  RETURN VALUE:
//
//  S_OK if OK.
//  WBEM_E_INVALID_PARAMETER if the arguments are bad
//  WBEM_E_OUT_OF_MEMORY     if out of memory
//  other wise error from SafeArrayPutElement
//
//***************************************************************************

SCODE CVariant::SetData(
        IN void * pData, 
        IN VARTYPE vtChangeTo, 
        IN int iSize)
{
    int iToSize = iTypeSize(vtChangeTo);

    // check arguments and clear the variant

    if(pData == NULL || iToSize < 1)
        return WBEM_E_INVALID_PARAMETER;
    OMSVariantClear(&var);
    if(iSize < 1) 
        iSize = iToSize;

    // Special case for arrays!
    
    if(vtChangeTo & VT_ARRAY)
        return SetArrayData(pData,vtChangeTo & ~VT_ARRAY,iSize);

    if(vtChangeTo == CIM_SINT64 || vtChangeTo == CIM_UINT64)
    {

        // int64 and uint64 need to be converted to strings

        WCHAR wcTemp[50];
        __int64 iLong;
        memcpy((void *)&iLong, pData, 8);
        if(vtChangeTo == CIM_SINT64)
            StringCchPrintfW(wcTemp, 50, L"%I64d", iLong);
        else
            StringCchPrintfW(wcTemp, 50, L"%I64u", iLong);
        
        var.bstrVal = SysAllocString(wcTemp);
        if(var.bstrVal == NULL)
            return WBEM_E_OUT_OF_MEMORY;
        var.vt = VT_BSTR;
    }
    else if(vtChangeTo == VT_BSTR) 
    {

        // All strings are stored as BSTRS

        var.bstrVal = SysAllocBstrFromTCHAR((LPTSTR)pData);
        if(var.bstrVal == NULL)
            return WBEM_E_OUT_OF_MEMORY;
        var.vt = VT_BSTR;
    }
    else 
    {
        memcpy((void *)&var.lVal,pData,iToSize);
        var.vt = vtChangeTo;
    }
    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\winmgmt\stdprov\localloc.cpp ===
/*++

Copyright (C) 1996-2001 Microsoft Corporation

Module Name:

Abstract:

History:

--*/


#include "precomp.h"
#include <arena.h>

void* __cdecl operator new ( size_t size )
{
    return CWin32DefaultArena::WbemMemAlloc( size );
}
    
void __cdecl operator delete ( void* pv )
{
    CWin32DefaultArena::WbemMemFree( pv );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\winmgmt\stdprov\general.cpp ===
/*++

Copyright (C) 1995-2001 Microsoft Corporation

Module Name:

    GENERAL.CPP

Abstract:

	Containes some general purpose classes 
	which are of use to serveral providers.
	Specifically, this contains the code for
	the classes used to cache open handles and
	the classes used to parse the mapping strings.

History:

	a-davj  11-Nov-95   Created.

--*/

#include "precomp.h"

//***************************************************************************
//
//  CEntry::CEntry()
//
//  DESCRIPTION:
//
//  Constructor.
//
//***************************************************************************

CEntry::CEntry()
{
    hHandle = NULL;
    sPath.Empty();
}

//***************************************************************************
//
//  CEntry::~CEntry()
//
//  DESCRIPTION:
//
//  Destructor.
//
//***************************************************************************

CEntry::~CEntry()
{
    sPath.Empty();
}
    
//***************************************************************************
//
//  CHandleCache::~CHandleCache
//
//  DESCRIPTION:
//
//  Destructor.
//
//***************************************************************************

CHandleCache::~CHandleCache()
{
    Delete(0);    
}

//***************************************************************************
//
//  CHandleCache::lAddToList
//
//  DESCRIPTION:
//
//  Adds an entry to the handle list.
//
//
//  PARAMETERS:
//
//  pAdd    Name that will be used to retrieve the handle
//  hAdd    handle to be added
//  
//  RETURN VALUE:
//  
//  S_OK                    all is well.
//  WBEM_E_OUT_OF_MEMORY     out of memory
//
//***************************************************************************

long int CHandleCache::lAddToList(
                        IN const TCHAR * pAdd, 
                        IN HANDLE hAdd)
{
    CEntry * pNew = new CEntry();
    if(pNew == NULL) 
        return WBEM_E_OUT_OF_MEMORY; 
    pNew->hHandle = hAdd;
    pNew->sPath = pAdd;
    
    if(CFlexArray::no_error != List.Add(pNew))
        return WBEM_E_OUT_OF_MEMORY;
    return S_OK;
}

//***************************************************************************
//
//  CHandleCache::lGetNumMatch
//
//  DESCRIPTION:
//
//  Returns the number of entries which match the path tokens.  For example,
//  the path might be    HKEY_LOCAL_MACHINE, hardware, description, xyz, and 
//  if the tokens, were, HKEY_LOCAL_MACHINE, hardware, devicemap, xyz then a 
//  two would be returned since the first two parts matched.
//
//  PARAMETERS:
//
//  iEntry      Entry to start checking at
//  iToken      Token to start checking
//  Path        This object supplies the tokens to be checked.
//
//  RETURN VALUE:
//
//  see description.
//
//***************************************************************************

long int CHandleCache::lGetNumMatch(
                        IN int iEntry,
                        IN int iToken, 
                        IN CProvObj & Path)
{
    int iMatch = 0;
    for(;iEntry < List.Size() && iToken < Path.iGetNumTokens();
            iEntry++, iToken++, iMatch++) 
    {
        CEntry * pCurr = (CEntry *)List.GetAt(iEntry);
        TString sTemp = Path.sGetFullToken(iToken);
        if(lstrcmpi(pCurr->sPath,sTemp))
            break;
    }
    return iMatch;            
}

//***************************************************************************
//
//  CHandleCache::Delete
//
//  DESCRIPTION:
// 
//  Empties all or part of the cache.
//
//  PARAMETERS:
//
//  lStart      Indicates first element to delete.  To empty entire cache,
//              a zero should be entered.
//
//***************************************************************************

void CHandleCache::Delete(
                    IN long int lStart)
{
    int iCurr;
    for(iCurr = List.Size()-1; iCurr >= lStart; iCurr--) 
    {
        CEntry * pCurr = (CEntry *)List.GetAt(iCurr);
        delete pCurr;
        List.RemoveAt(iCurr);        
    }
}


//***************************************************************************
//
//  CHandleCache::hGetHandle
//
//  DESCRIPTION:
//
//  Gets a handle.
//
//  PARAMETERS:
//
//  lIndex      Indicates which handle to get.  0 is the first.
//
//  RETURN VALUE:
//  handle retuested, NULL only if bad index is entered.
//
//***************************************************************************

HANDLE CHandleCache::hGetHandle(
                        IN long int lIndex)
{
    if(lIndex < List.Size()) 
    {
        CEntry * pCurr = (CEntry *)List.GetAt(lIndex);
        if(pCurr)
            return pCurr->hHandle;
    }
    return NULL;
}

//***************************************************************************
//
//  CHandleCache::sGetString
//
//  DESCRIPTION:
//
//  Gets the string associated with a cache entry.
//
//  PARAMETERS:
//
//  lIndex          Index in cache, 0 is the first element.
//
//  RETURN VALUE:
//
//  Returns a pointer to the string.  NULL if bad index.
//
//***************************************************************************

const TCHAR * CHandleCache::sGetString(
                                IN long int lIndex)
{
    if(lIndex < List.Size()) {
        CEntry * pCurr = (CEntry *)List.GetAt(lIndex);
        if(pCurr)
            return pCurr->sPath;
        }
    return NULL;
}

//***************************************************************************
//
//  CToken::CToken
//
//  DESCRIPTION:
//
//  constructor.
// 
//  PARAMETERS:
//
//  cpStart         String to be parsed.
//  cDelim          Token delimeter.
//  bUsesEscapes    If true, then need to look for special characters
//
//***************************************************************************

#define MAX_TEMP 150

CToken::CToken(
                IN const TCHAR * cpStart,
                IN const OLECHAR cDelim, 
                bool bUsesEscapes)
{
    const TCHAR * cpCurr;        //atoi
    iOriginalLength = -1;
    TString *psExp;
    int iNumQuote;
    BOOL bLastWasEsc, bInExp, bInString;
    bLastWasEsc = bInExp = bInString = FALSE;

	
	// Before doing an elaborate parse, first check for the simple case where there
	// are no quotes, escapes, commas, etc

    bool bGotSpecialChar = false;

	for(cpCurr = cpStart; *cpCurr && *cpCurr != cDelim; cpCurr++)
	{
		if(*cpCurr == ESC || *cpCurr == '\"' || *cpCurr == '(')
			bGotSpecialChar = true;
	}


	if(!bUsesEscapes || cDelim != MAIN_DELIM || *cpCurr == cDelim || !bGotSpecialChar)
	{
		// Simple case do it quickly

		iOriginalLength = cpCurr - cpStart;
		if(iOriginalLength < MAX_TEMP)
		{
			TCHAR tcTemp[MAX_TEMP];
			lstrcpyn(tcTemp, cpStart, iOriginalLength + 1);
			sFullData = tcTemp;
			sData = tcTemp;
			if(*cpCurr)
				iOriginalLength++;
			return;
		}
	}


    for(cpCurr = cpStart; *cpCurr; cpCurr++) {
        
        // check if end of token

        if(*cpCurr == cDelim && !bLastWasEsc) {
            cpCurr++;
            break;                    
            }

        // full data stores everything.  Check if character
        // is the escape which means that the following
        // character should be interpreted as a literal

        sFullData += *cpCurr;
        if(*cpCurr == ESC && !bLastWasEsc) {
            bLastWasEsc = TRUE;
            continue;
            }
        
        // tokens can include indexs of the form 
        // (xxx) or ("xxx").  If an index is detected,
        // then store the characters between () separately

        if((*cpCurr == '(' && !bInExp && !bLastWasEsc)||
           (*cpCurr == ',' && bInExp && !bLastWasEsc)) {
            
            // start of index expression. Allocate a new
            // string to store it and store the string 
            // in the expression collection. 
    
            psExp = new (TString);
            if(psExp) {    
                Expressions.Add((CObject *)psExp);
                bInExp = TRUE;
                iNumQuote = 0;
                }
            }
        else if(*cpCurr == ')' && bInExp && !bInString && !bLastWasEsc)
            bInExp = FALSE;    // end of index expression
        else if (*cpCurr == '\"' && bInExp && !bLastWasEsc) {
            iNumQuote++;
            if(iNumQuote == 1) {
                bInString = TRUE;
                *psExp += *cpCurr;
                }
            else if(iNumQuote == 2)
                bInString = FALSE;
            else 
                return; 
            }
        else if (bInExp)
            *psExp += *cpCurr;
        else
            sData += *cpCurr;
        bLastWasEsc = FALSE;
        }
    if(bInString || bInExp)   
        return; // got junk!!!
    iOriginalLength = cpCurr - cpStart;
    return;
}

//***************************************************************************
//
//  CToken::~CToken
//
//  DESCRIPTION:
//
//  Destructor.
//
//***************************************************************************

CToken::~CToken()
{
    int iCnt;
    TString * pCurr;
    for (iCnt = 0; iCnt < Expressions.Size(); iCnt++) {
        pCurr = (TString *)Expressions.GetAt(iCnt);
        delete pCurr;
        }
    Expressions.Empty();
    sData.Empty();
    sFullData.Empty();
}

//***************************************************************************
//
//  CToken::iConvOprand
//
//  DESCRIPTION:
//
//  Converts the characters in a string into an integer.
//
//  PARAMETERS:
//
//  tpCurr      String to be converted.
//  iArray      Not used anymore.
//  dwValue     where the result is set.
//
//  RETURN VALUE:
//
//  Number of digits converted.
//
//***************************************************************************

long int CToken::iConvOprand(
                    IN const TCHAR * tpCurr, 
                    IN int iArray, 
                    OUT long int & dwValue)
{
    TString sTemp;
    long int iRet = 0;

    // Build up a string containing
    // all characters upto the first non didgit

    for(;*tpCurr; tpCurr++)
        if(wbem_iswdigit(*tpCurr)) 
        {
            sTemp += *tpCurr;
            iRet++;
        }
        else
            break;        
    
    // Convert and return the length

    dwValue = _wtoi(sTemp);    
    return iRet;
}

//***************************************************************************
//
//  CToken::GetIntExp
//
//  DESCRIPTION:
//
//  Converts the expression into an integer.  The expression
//  can only be made up of integers, '+', '-' and a special
//  character ('#' as of now)for substituting iArray.  Examples,
//  (23)  (#+3)  (#-4)
//
//  PARAMETERS:
//  
//  iExp        which integer to retrieve in the case where you have 2,5,8
//  iArray      Not used anymore
//
//  RETURN VALUE:
//  
//  -1 if error.
//
//***************************************************************************

long int CToken::GetIntExp(int iExp,int iArray)
{
    TString * psTest;
    TString sNoBlanks;
    TCHAR const * tpCurr;
    long int lOpSize;
    int iCnt;
    long int lAccum = 0, lOperand;
    TCHAR tUnary = ' ';
    TCHAR tBinary = '+';
    BOOL bNeedOperator = FALSE; // Start off needing operand
    
    // Do some intial check such as making sure the expression
    // exists and that it isnt a string expression

    if(Expressions.Size() <= iExp)
        return -1;
    if(IsExpString(iExp)) 
        return -1;
    psTest = (TString *)Expressions.GetAt(iExp);
    if(psTest == NULL) {
        return -1;
        }

    // Get rid of any blanks

    for(iCnt = 0; iCnt < psTest->Length(); iCnt++)
        if(psTest->GetAt(iCnt) != ' ')
            sNoBlanks += psTest->GetAt(iCnt);
    
    // Evalate the expression

    for(tpCurr = sNoBlanks; *tpCurr; tpCurr++) 
    {
        if(*tpCurr == '+' || *tpCurr == '-') 
        {
            
            // got an operator.  Note that if an operator is not needed,
            // such as before the first operand, then it must be a unary 
            // operator.  Only one unary operator in a row is valid.

            if(bNeedOperator) 
            {
                tBinary = *tpCurr;
                bNeedOperator = FALSE;
            }
            else
            {
                if(tUnary != ' ') // Gratuitous unary operator
                    return -1;
                tUnary = *tpCurr;
            }
        }
        else 
        {
            // got an operand
            
            if(bNeedOperator) // Gratuitous unary operand
                return -1;
            lOpSize = iConvOprand(tpCurr,iArray,lOperand);
            if(lOpSize > 1)
                tpCurr += lOpSize-1;
            if(tUnary == '-')
                lOperand =  -lOperand;
            if(tBinary == '+')
                lAccum = lAccum + lOperand;
            else
                lAccum = lAccum - lOperand;
            bNeedOperator = TRUE;
            tUnary = ' ';
        }
    }
    return lAccum;
}

//***************************************************************************
//
//  CToken::GetStringExp
//
//  DESCRIPTION:
//
//  Returns a string expression.
//
//  PARAMETERS:
//
//  iExp        Which string to use when they are separated by commans
//
//  RETURN VALUE:
//
//  Pointer to string, NULL if iExp is bogus.
//
//***************************************************************************

TCHAR const * CToken::GetStringExp(
                        IN int iExp)
{
    TString * psTest;
    TCHAR const * tp;
    
    // start by making sure expression exists.
            
    if(Expressions.Size() <= iExp)
        return NULL;
    psTest = (TString *)Expressions.GetAt(iExp);
    if(psTest != NULL) 
    {
        int iIndex;
        iIndex = psTest->Find('\"');
        if(iIndex != -1) 
        {

            // All is well.  Return a pointer one passed
            // the initial \" whose only purpose is to 
            // indicate that this is a string expression.

            tp = *psTest;
            return tp + iIndex + 1;
            }
    }
    return NULL;  
}

//***************************************************************************
//
//  CToken::IsExpString
//
//  DESCRIPTION:
//
//  Tests if the token contains a string
//
//  PARAMETERS:
//
//  iExp        Indicates which substring for when the strings are divided
//              by commas
//
//  RETURN VALUE:
//  Returns true if the expression is a string.
//
//***************************************************************************

BOOL CToken::IsExpString(int iExp)
{
    TString * psTest;
    
    // make sure that the expression exists.
            
    if(Expressions.Size() <= iExp)
        return FALSE;
    psTest = (TString *)Expressions.GetAt(iExp);
    if(psTest != NULL) {
        int iIndex;
        
        // String expressions always contain at least one \"
        
        iIndex = psTest->Find('\"');
        if(iIndex != -1)
            return TRUE;
        }
    return FALSE;
}
            


//***************************************************************************
//
//  CProvObj::CProvObj(const char * ProviderString,const TCHAR cDelim)
//
//  DESCRIPTION:
//
//  Constructor.
//
//  PARAMETERS:
//
//  ProviderString      String passed from wbem
//  cDelim              Token delimeter
//  bUsesEscapes        True if we need to treat escapes in a special way.
//
//***************************************************************************
#ifndef UNICODE
CProvObj::CProvObj(
                IN const char * ProviderString,
                IN const TCHAR cDelim, bool bUsesEscapes)
{
    m_bUsesEscapes = bUsesEscapes;
    Init(ProviderString,cDelim);
    return;
}
#endif

//***************************************************************************
//
//  CProvObj::CProvObj(const WCHAR * ProviderString,const TCHAR cDelim)
//
//  DESCRIPTION:
//
//  Constructor.
//
//  PARAMETERS:
//
//  ProviderString      String passed from wbem
//  cDelim              Token delimeter
//
//***************************************************************************


CProvObj::CProvObj(
                IN const WCHAR * ProviderString,
                IN const TCHAR cDelim, bool bUsesEscapes)
{
    m_bUsesEscapes = bUsesEscapes;
#ifdef UNICODE
    Init(ProviderString,cDelim);
#else
    char * pTemp = WideToNarrowA(ProviderString);
    if(pTemp == NULL)
        dwStatus = WBEM_E_FAILED;
    else {
        Init(pTemp,cDelim);
        delete pTemp;
        }
#endif
    return;
}

//***************************************************************************
//
//  void CProvObj::Init
//
//  DESCRIPTION:
//
//  Doest the acutal work for the various constructors.
//
//  PARAMETERS:
//  ProviderString      String passed from wbem
//  cDelim              Token delimeter
//
//***************************************************************************

void CProvObj::Init(
                IN const TCHAR * ProviderString,
                IN const TCHAR cDelim)
{
    CToken * pNewToken;
    const TCHAR * cpCurr;

	m_cDelim = cDelim;

    // Create a list of tokens

        for(cpCurr = ProviderString; *cpCurr;cpCurr+=pNewToken->GetOrigLength()) 
        {
			int iRet = 0;
            pNewToken = new CToken(cpCurr,cDelim, m_bUsesEscapes);
			if(pNewToken)
				iRet = myTokens.Add(pNewToken);
			if(pNewToken == NULL || iRet != CFlexArray::no_error)
			{
				dwStatus = WBEM_E_OUT_OF_MEMORY;
				return;
			}
            if(pNewToken->GetOrigLength() == -1)
            {
				dwStatus = WBEM_E_INVALID_PARAMETER;
				return;
            }
        }
        dwStatus = WBEM_NO_ERROR;
        return;

}            

//***************************************************************************
//
//  CProvObj::Empty
//
//  DESCRIPTION:
// 
//  frees up all the data
//
//***************************************************************************

void CProvObj::Empty(void)
{
    int iCnt;
    CToken * pCurr;
    for (iCnt = 0; iCnt < myTokens.Size(); iCnt++) {
        pCurr = (CToken *)myTokens.GetAt(iCnt);
        delete pCurr;
        }
    myTokens.Empty();
}

//***************************************************************************
//
//  BOOL CProvObj::Update
//
//  DESCRIPTION:
//
//  Resets the value with a new provider string. 
//
//  PARAMETERS:
//
//  pwcProvider     New provider string
//
//  RETURN VALUE:
//
//  TRUE if ok.
//***************************************************************************

BOOL CProvObj::Update(
                        IN WCHAR * pwcProvider)
{
	// Do a quick check to see if the "fast" update can be used

	BOOL bComplex = FALSE;
	int iDelim = 0;
	WCHAR * pwcCurr;
	for(pwcCurr = pwcProvider; *pwcCurr; pwcCurr++)
	{
		if(*pwcCurr == m_cDelim) 
			iDelim++;
		else if(*pwcCurr == ESC || *pwcCurr == L'\"' || *pwcCurr == L'(')
		{
			bComplex = TRUE;
			break;
		}
	}

	// If the number of tokens changed, or there is some embedded junk
	// just empty and retry.

	if(bComplex || iDelim != myTokens.Size()-1)
	{
		Empty();
#ifdef UNICODE
		Init(pwcProvider,m_cDelim);
#else
		char * pTemp = WideToNarrowA(pwcProvider);
		if(pTemp == NULL)
			return FALSE;
		Init(pTemp,m_cDelim);
        delete pTemp;
#endif
		return TRUE;
	}

	// We can take the shortcut.  Start by creating a TCHAR temp version

	int iLen = 2*wcslen(pwcProvider) + 1;
	TCHAR * pTemp = new TCHAR[iLen];
	if(pTemp == NULL)
		return FALSE;
#ifdef UNICODE
	StringCchCopyW(pTemp, iLen,pwcProvider);
#else
	wcstombs(pTemp, pwcProvider, iLen);
#endif	

	TCHAR * ptcCurr;
	TCHAR * pStart;
	BOOL bTheEnd = FALSE;
    
    iDelim = 0;
	for(pStart = ptcCurr = pTemp;!bTheEnd;ptcCurr++)
	{
		if(*ptcCurr == m_cDelim || *ptcCurr == NULL)
		{
			bTheEnd = (*ptcCurr == NULL);
			*ptcCurr = NULL;
			CToken * pToken = (CToken *)myTokens.GetAt(iDelim);
			if(pToken && lstrcmpi(pStart,pToken->sFullData))
			{
				pToken->sFullData = pStart;
				pToken->sData = pStart;
			}
            iDelim++;
			pStart = ptcCurr+1;
		}
	}

	delete pTemp;
	return TRUE;
}

//***************************************************************************
//
//  CProvObj::GetTokenPointer
//
//  DESCRIPTION:
//
//  Gets a pointer to a token
//
//  PARAMETERS:
//
//  iToken              Which token to get
//
//  RETURN VALUE:
//  
//  pointer to token, or NULL if bad request.
//
//***************************************************************************

CToken * CProvObj::GetTokenPointer(
                        IN int iToken)
{
    if(iToken >= myTokens.Size() || iToken < 0) 
        return NULL;
    return (CToken *)myTokens.GetAt(iToken);
}

//***************************************************************************
//
//  CProvObj::dwGetStatus
//
//  DESCRIPTION:
//
//  Gets status and also checks to make sure a minimum number of tokens
//  exist.
//
//  PARAMETERS:
//
//  iMin                minimum number of tokens.
//
//  RETURN VALUE:
//
//  Returns S_OK if OK, WBEM_E_FAILED otherwise.
//
//***************************************************************************

DWORD CProvObj::dwGetStatus(
                        IN int iMin)
{
    if(dwStatus)
        return dwStatus;
    else
        return (iMin <= myTokens.Size()) ? S_OK : WBEM_E_FAILED;

}
//***************************************************************************
//
//  CProvObj::sGetToken
//
//  DESCRIPTION:
//
//  Gets a token.  Note that the token will not include embleded "(stuff)"
//
//  PARAMETERS:
//
//  iToken              which token to get
//
//  RETURN VALUE:
//
//  pointer to token, NULL if invalid argument
//***************************************************************************

const TCHAR * CProvObj::sGetToken(
                        IN int iToken)
{
    CToken * pCurr = GetTokenPointer(iToken);
    return (pCurr) ? pCurr->GetStringValue() : NULL;
}

//***************************************************************************
//
//  const TCHAR * CProvObj::sGetFullToken
//
//  DESCRIPTION:
//
//  Gets a full and unadulterated token.
//
//  PARAMETERS:
//
//  iToken              token to get
//
//  RETURN VALUE:
//
//  pointer to token, NULL if invalid argument
//***************************************************************************

const TCHAR * CProvObj::sGetFullToken(
                        IN int iToken)
{
    CToken * pCurr = GetTokenPointer(iToken);
    return (pCurr) ? pCurr->GetFullStringValue() : NULL;
}


//***************************************************************************
//
//  const TCHAR * CProvObj::sGetStringExp
//
//  DESCRIPTION:
//
//  Gets a substring for a particular token
//
//  PARAMETERS:
//
//  iToken              token to get
//  iExp                substring to get
//
//  RETURN VALUE:
//
//  pointer to substring, NULL if invalid argument
//***************************************************************************

const TCHAR * CProvObj::sGetStringExp(
                        IN int iToken,
                        IN int iExp)
{
    CToken * pCurr = GetTokenPointer(iToken);
    return (pCurr) ? pCurr->GetStringExp(iExp) : NULL;
}

//***************************************************************************
//
//  long int CProvObj::iGetIntExp
//
//  DESCRIPTION:
//
//  For a particular token, gets the integer value of a substring.
//
//  PARAMETERS:
//
//  iToken              token to get
//  iExp                substring
//  iArray              no longer used
//
//  RETURN VALUE:
//  
//  int value, or -1 if bad argument
//***************************************************************************

long int CProvObj::iGetIntExp(
                        IN int iToken, 
                        IN int iExp, 
                        IN int iArray)
{
    CToken * pCurr = GetTokenPointer(iToken);
    return (pCurr) ? pCurr->GetIntExp(iExp,iArray) : -1;
}

//***************************************************************************
//
//  BOOL CProvObj::IsExpString
//
//  DESCRIPTION:
//
//  Tests a substring to see if it is a string, or numeric
//
//  PARAMETERS:
//
//  iToken              token to get
//  iExp                substring
//
//
//  RETURN VALUE:
//
//  True if arguments are valid and it is not numeric
//***************************************************************************

BOOL CProvObj::IsExpString(
                        IN int iToken, 
                        IN int iExp)
{
    CToken * pCurr = GetTokenPointer(iToken);
    return (pCurr) ? pCurr->IsExpString(iExp) : FALSE;
}

//***************************************************************************
//
//  long int CProvObj::iGetNumExp
//
//  DESCRIPTION:
//
//  Gets the number of subexpressions
//
//  PARAMETERS:
//
//  iToken              token to check
//
//  RETURN VALUE:
//
//  number of substrings (subexpressions) or -1 if invalid argument
//***************************************************************************

long int CProvObj::iGetNumExp(
                        IN int iToken)
{
    CToken * pCurr = GetTokenPointer(iToken);
    return (pCurr) ? pCurr->GetNumExp() : -1;
}


//***************************************************************************
//
//  IWbemClassObject * GetNotifyObj
//
//  DESCRIPTION:
//
//  This utility is useful for setting notify objects 
//  at the end of async calls.
//
//  PARAMETERS:
//
//  pServices           pointer back into WBEM
//  lRet                status code to set in notify object
//                
//  RETURN VALUE:
//
//  Class object.  Null if failure.
//***************************************************************************

IWbemClassObject * GetNotifyObj(
                        IN IWbemServices * pServices, 
                        IN long lRet,
                        IN IWbemContext  *pCtx)
{
    
    if(pServices == NULL)
        return NULL;
    IWbemClassObject * pInst = NULL;
    IWbemClassObject * pClass = NULL;

    SCODE sc = pServices->GetObject(L"__ExtendedStatus", 0, pCtx, &pClass, NULL);
    if(sc != S_OK)
        return NULL;

    sc = pClass->SpawnInstance(0, &pInst);
    pClass->Release();

    if(sc == S_OK && pInst)
    {

        VARIANT v;
        v.vt = VT_I4;
        v.lVal = lRet;
        sc = pInst->Put(L"StatusCode", 0, &v, 0);
        if(sc != S_OK)
        {
            pInst->Release();
            return NULL;
        }
        else
            return pInst;

    }
    return NULL;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\winmgmt\stdprov\idynprov.h ===
/*++

Copyright (C) 1997-2001 Microsoft Corporation

Module Name:

    IDYNPROV.H

Abstract:

	Declares the CProvStub class.

History:

	a-davj  04-Mar-97   Created.

--*/

/* this ALWAYS GENERATED file contains the definitions for the interfaces */


/* File created by MIDL compiler version 2.00.0102 */
/* at Thu Aug 10 09:54:39 1995
 */
//@@MIDL_FILE_HEADING(  )
#include "rpc.h"
#include "rpcndr.h"
#ifndef COM_NO_WINDOWS_H
#include "windows.h"
#include "ole2.h"
#endif /*COM_NO_WINDOWS_H*/

#ifndef __idynprov_h__
#define __idynprov_h__

#ifdef __cplusplus
extern "C"{
#endif 

/* Forward Declarations */ 

#ifndef __IMoDynPropProvider_FWD_DEFINED__
#define __IMoDynPropProvider_FWD_DEFINED__
typedef interface IMoDynPropProvider IMoDynPropProvider;
#endif 	/* __IMoDynPropProvider_FWD_DEFINED__ */


/* header files for imported files */
#include "wtypes.h"
#include "unknwn.h"

void __RPC_FAR * __RPC_USER MIDL_user_allocate(size_t);
void __RPC_USER MIDL_user_free( void __RPC_FAR * ); 

/****************************************
 * Generated header for interface: __MIDL__intf_0000
 * at Thu Aug 10 09:54:39 1995
 * using MIDL 2.00.0102
 ****************************************/
/* [local] */ 


			/* size is 36 */
typedef struct  tagMODYNPROP
    {
    DWORD dwStructSize;
    OLECHAR __RPC_FAR *pPropertySetName;
    OLECHAR __RPC_FAR *pPropertyName;
    OLECHAR __RPC_FAR *pProviderString;
    DWORD dwType;
    BYTE __RPC_FAR *pPropertyValue;
    DWORD dwBufferSize;
    DWORD dwOptArrayIndex;
    DWORD dwResult;
    }	MODYNPROP;

			/* size is 4 */
typedef struct tagMODYNPROP __RPC_FAR *LPMODYNPROP;



extern RPC_IF_HANDLE __MIDL__intf_0000_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL__intf_0000_v0_0_s_ifspec;

#ifndef __IMoDynPropProvider_INTERFACE_DEFINED__
#define __IMoDynPropProvider_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: IMoDynPropProvider
 * at Thu Aug 10 09:54:39 1995
 * using MIDL 2.00.0102
 ****************************************/
/* [object][uuid] */ 



EXTERN_C const IID IID_IMoDynPropProvider;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    interface IMoDynPropProvider : public IUnknown
    {
    public:
        virtual HRESULT __stdcall GetProperties( 
            /* [in] */ LPMODYNPROP pPropList,
            /* [in] */ unsigned long dwListSize) = 0;
        
        virtual HRESULT __stdcall SetProperties( 
            /* [in] */ LPMODYNPROP pPropList,
            /* [in] */ unsigned long dwListSize) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IMoDynPropProviderVtbl
    {
        
        HRESULT ( __stdcall __RPC_FAR *QueryInterface )( 
            IMoDynPropProvider __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( __stdcall __RPC_FAR *AddRef )( 
            IMoDynPropProvider __RPC_FAR * This);
        
        ULONG ( __stdcall __RPC_FAR *Release )( 
            IMoDynPropProvider __RPC_FAR * This);
        
        HRESULT ( __stdcall __RPC_FAR *GetProperties )( 
            IMoDynPropProvider __RPC_FAR * This,
            /* [in] */ LPMODYNPROP pPropList,
            /* [in] */ unsigned long dwListSize);
        
        HRESULT ( __stdcall __RPC_FAR *SetProperties )( 
            IMoDynPropProvider __RPC_FAR * This,
            /* [in] */ LPMODYNPROP pPropList,
            /* [in] */ unsigned long dwListSize);
        
    } IMoDynPropProviderVtbl;

    interface IMoDynPropProvider
    {
        CONST_VTBL struct IMoDynPropProviderVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IMoDynPropProvider_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IMoDynPropProvider_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IMoDynPropProvider_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IMoDynPropProvider_GetProperties(This,pPropList,dwListSize)	\
    (This)->lpVtbl -> GetProperties(This,pPropList,dwListSize)

#define IMoDynPropProvider_SetProperties(This,pPropList,dwListSize)	\
    (This)->lpVtbl -> SetProperties(This,pPropList,dwListSize)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT __stdcall IMoDynPropProvider_GetProperties_Proxy( 
    IMoDynPropProvider __RPC_FAR * This,
    /* [in] */ LPMODYNPROP pPropList,
    /* [in] */ unsigned long dwListSize);


void __RPC_STUB IMoDynPropProvider_GetProperties_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT __stdcall IMoDynPropProvider_SetProperties_Proxy( 
    IMoDynPropProvider __RPC_FAR * This,
    /* [in] */ LPMODYNPROP pPropList,
    /* [in] */ unsigned long dwListSize);


void __RPC_STUB IMoDynPropProvider_SetProperties_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IMoDynPropProvider_INTERFACE_DEFINED__ */


/* Additional Prototypes for ALL interfaces */

/* end of Additional Prototypes */

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\winmgmt\stdprov\makefile.inc ===
!INCLUDE $(_NTDRIVE)$(_NTROOT)\WMI\COMMON\makefile.cmn
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\winmgmt\stdprov\impdyn.cpp ===
/*++

Copyright (C) 1995-2001 Microsoft Corporation

Module Name:

    IMPDYN.CPP

Abstract:

	Defines the virtual base class for the Dynamic Provider
	objects.  The base class is overriden for each specific
	provider which provides the details of how an actual
	property "Put" or "Get" is done.

History:

	a-davj  27-Sep-95   Created.

--*/

#include "precomp.h"
#include <wbemidl.h>
//#define _MT

#include <process.h>
#include "impdyn.h"
#include "CVariant.h"
#include <genlex.h>
#include <objpath.h>
#include <genutils.h>
#include <cominit.h>

//***************************************************************************
//
// CImpDyn::CImpDyn
//
// DESCRIPTION:
//
// Constructor.
//
// PARAMETERS:
//
// ObjectPath           Full path to the namespace
// User                 User name
// Password             Password
//
//***************************************************************************

CImpDyn::CImpDyn() : m_pGateway(NULL), m_cRef(0)
{
    wcCLSID[0] = 0;       // Set to correct value in derived class constructors
}

HRESULT STDMETHODCALLTYPE CImpDyn::Initialize(LPWSTR wszUser, long lFlags,
                LPWSTR wszNamespace, LPWSTR wszLocale, 
                IWbemServices* pNamespace, IWbemContext* pContext, 
                IWbemProviderInitSink* pSink)
{
    m_pGateway = pNamespace;
    m_pGateway->AddRef();
    pSink->SetStatus(WBEM_S_NO_ERROR, 0);
    return WBEM_S_NO_ERROR;
}

//***************************************************************************
//
// CImpDyn::~CImpDyn
//
// DESCRIPTION:
//
// Destructor.
//
//***************************************************************************

CImpDyn::~CImpDyn(void)
{
    if(m_pGateway)
        m_pGateway->Release();
    return;
}

//***************************************************************************
//
// SCODE CImpDyn::CreateInstanceEnum
//
// DESCRIPTION:
//
// Creates an enumerator object that can be used to enumerate 
// the instances of this class.
//
// PARAMETERS:
//
// Class                Path specifying the class to be enumerated
// lFlags               flags to control the enumeration
// phEnum               returned pointer to enumerator 
// ppErrorObject        returned pointer to error object
//
// RETURN VALUE:
//
// S_OK                 if all is well
// WBEM_E_OUT_OF_MEMORY  if not enough memory
// various error codes from IWbemServices::GetObject
//
//***************************************************************************

SCODE CImpDyn::CreateInstanceEnum(
                        IN const BSTR Class, 
                        IN long lFlags, 
						IWbemContext  *pCtx,
                        OUT IN IEnumWbemClassObject FAR* FAR* phEnum)
{
    CEnumInst * pEnumObj;
    SCODE sc;
    WCHAR * pwcClassContext = NULL;
    IWbemClassObject * pClassInt = NULL;
    CEnumInfo * pInfo = NULL;

    // Get the class

    sc = m_pGateway->GetObject(Class,0, pCtx, &pClassInt,NULL);
    if(sc != S_OK)
		return sc;

    // Get the class context string

    sc = GetAttString(pClassInt, NULL, L"classcontext", &pwcClassContext);
    pClassInt->Release();
    if(sc != S_OK)
		return sc;

    // Get the info needed for enumeration.  This is overrided by any 
    // provider that supports dynamic instances.
    
    CProvObj ProvObj(pwcClassContext,MAIN_DELIM, NeedsEscapes());

    sc = MakeEnum(pClassInt,ProvObj,&pInfo);
    delete pwcClassContext;
	
    if(sc != S_OK)
        return sc;

    pEnumObj=new CEnumInst(pInfo,lFlags,Class,m_pGateway,this, pCtx);
    if(pEnumObj == NULL) 
    {
        delete pInfo;
        return WBEM_E_OUT_OF_MEMORY;
    }

    // Once the enumerator object is created, it owns the info object and
    // will free it appropriatly

    sc = pEnumObj->QueryInterface(IID_IEnumWbemClassObject,(void **) phEnum);
    if(FAILED(sc))
        delete pEnumObj;

    return sc;

}

//***************************************************************************
//
// CreateInstanceEnumAsyncThread
//
// DESCRIPTION:
//
// Routine for which does the work and sends the
// subsequent notify for the Instance provider's CreateInstanceEnumAsync
// routine.
//
// PARAMETERS:
//
// pIEnum               Our enumerator
// pSink             Core's sink
// pGateway             IWbemServices pointer to the core
// pCtx                 context to be used.
//
//***************************************************************************

void CreateInstanceEnumAsyncThread(   IEnumWbemClassObject FAR* pIEnum,
   IWbemObjectSink FAR* pSink, IWbemServices FAR *  pGateway,    IWbemContext  *pCtx)
{
    IWbemClassObject * pNewInst = NULL;
    SCODE sc = S_OK;

    // enumerate and send each object to the notify interface

    while (sc == S_OK) 
    {
        ULONG uRet;
        sc = pIEnum->Next(-1, 1,&pNewInst,&uRet);
        if(sc == S_OK) 
        {
            pSink->Indicate(1,&pNewInst);
            pNewInst->Release();
        }
    }

    pSink->SetStatus(0,0,NULL, NULL);

}


//***************************************************************************
//
// SCODE CInstPro::CreateInstanceEnumAsync
//
// DESCRIPTION:
//
// Asynchronously enumeratres the instances of this class.
//
// PARAMETERS:
//
// RefStr               Path which defines the object class
// lFlags               enumeration flags
// pSink             Pointer to the notify object
// plAsyncRequestHandle pointer to the enumeration cancel handle (future use)
//
// RETURN VALUE:
//
// S_OK                 All is well
// WBEM_E_INVALID_PARAMETER  Bad argument
// WBEM_E_OUT_OF_MEMORY  Lacked resources to create a thread
// otherwise, error from CreateInstanceEnum
//
//***************************************************************************

SCODE CImpDyn::CreateInstanceEnumAsync(
                        IN const BSTR RefStr,
                        IN long lFlags,
						IWbemContext __RPC_FAR *pCtx,
                        OUT IWbemObjectSink FAR* pSink)
{
    SCODE sc = S_OK;
    IEnumWbemClassObject * pIEnum = NULL;
    if(pSink == NULL || RefStr == NULL)
        return WBEM_E_INVALID_PARAMETER;

    if(IsNT() && IsDcomEnabled())
        sc = WbemCoImpersonateClient();

    if(sc == S_OK)
        sc = CreateInstanceEnum(RefStr,lFlags, pCtx, &pIEnum);
    if(sc != S_OK) 
    {
        pSink->SetStatus(0, sc, NULL, NULL);
        return S_OK;
    }
    CreateInstanceEnumAsyncThread(pIEnum, pSink, m_pGateway, pCtx);
    pIEnum->Release();

    return S_OK;
}

//***************************************************************************
//
// SCODE CImpDyn::CreateClassEnumAsync
//
// DESCRIPTION:
//
// Asynchronously enumeratres the classes that this provider supplies.  This is
// acutally just a ruse to get the core to load the dll.
//
// PARAMETERS:
//
// SuperClass           Parent to be enumerated.
// lFlags               enumeration flags
// pResponseHandler     Pointer to the notify object
// plAsyncRequestHandle pointer to the enumeration cancel handle (future use)
//
// RETURN VALUE:
//
// S_OK                 All is well
//
//***************************************************************************

IWbemServices * gGateway;

SCODE CImpDyn::CreateClassEnumAsync(BSTR Superclass,  long lFlags,IWbemContext *pCtx, IWbemObjectSink FAR* pResponseHandler)
{
	return E_NOTIMPL;
}


//***************************************************************************
//
// SCODE CImpDyn::GetObject
//
// DESCRIPTION:
//
// Creates an instance given a particular path value.
//
// PARAMETERS:
//
// ObjectPath           Object path
// lFlags               flags
// pObj                 Set to point to the created object
// ppErrorObject        Optional error object pointer
//
// RETURN VALUE:
//
// S_OK                 All is well
// WBEM_E_NOT_FOUND      bad path
// otherwise the return code from CreateInst
//
//***************************************************************************

SCODE CImpDyn::GetObject(
                        IN BSTR ObjectPath,
                        IN long lFlags,
						IWbemContext *pCtx,
                        OUT IWbemClassObject FAR* FAR* pObj,
						IWbemCallResult  **ppCallResult)
{
    SCODE sc = S_OK;
    
    // Parse the object path.
    // ======================

    ParsedObjectPath * pOutput = 0;
    CObjectPathParser p;

    int nStatus = p.Parse(ObjectPath, &pOutput);

    if(nStatus != 0)
        return ReturnAndSetObj(WBEM_E_NOT_FOUND, ppCallResult);

    WCHAR wcKeyValue[BUFF_SIZE];
    
    sc = WBEM_E_NOT_FOUND;
    
    if(pOutput->m_dwNumKeys > 0 || pOutput->m_bSingletonObj)
    {


        if(pOutput->m_bSingletonObj)
            StringCchCopyW(wcKeyValue, BUFF_SIZE, L"@");
        else
        {
            KeyRef *pTmp = pOutput->m_paKeys[0];
        
            switch (V_VT(&pTmp->m_vValue))
            {
                case VT_I4:
                    StringCchPrintfW (wcKeyValue, BUFF_SIZE, L"%d", V_I4(&pTmp->m_vValue));
                    break;
                case VT_BSTR:
                    wcsncpy(wcKeyValue, V_BSTR(&pTmp->m_vValue), BUFF_SIZE-1);
                    break;
                default:
                    StringCchCopyW(wcKeyValue, BUFF_SIZE, L"<unknown>");;
            }
        }
        sc = CreateInst(m_pGateway,pOutput->m_pClass,wcKeyValue,pObj, NULL, NULL, pCtx);

    }

    
    // Create the instance.
    
    p.Free(pOutput);
    return ReturnAndSetObj(sc, ppCallResult);
}

//***************************************************************************
//
// GetObjectAsyncThread
//
// DESCRIPTION:
//
// Routine for the thread which does the work and sends the
// subsequent notify to the Instance provider's GetObjectAsync
// routine.
//
// PARAMETERS:
//
// pTemp                pointer to the argument structure
//
//***************************************************************************

void GetObjectAsyncThread(WCHAR * pObjPath, long lFlags, IWbemObjectSink FAR* pSink,
                          CImpDyn * pThis, IWbemContext  *pCtx)
{

    IWbemClassObject FAR* pNewInst = NULL;

    SCODE sc = pThis->GetObject(pObjPath, lFlags, pCtx, &pNewInst, NULL);
    if(sc == WBEM_NO_ERROR) 
    {
        pSink->Indicate(1,&pNewInst);
        pNewInst->Release();
    }

    pSink->SetStatus(0, sc, NULL, NULL);
}


//***************************************************************************
//
// SCODE CInstPro::GetObjectAsync
//
// DESCRIPTION:
//
// Asynchronously gets an instance of this class.
//
// PARAMETERS:
//
// RefStr               Path which defines the object class
// lFlags               enumeration flags
// pSink             Pointer to the notify object
// plAsyncRequestHandle pointer to the enumeration cancel handle (future use)
//
// RETURN VALUE:
//
// S_OK                 All is well
// WBEM_E_INVALID_PARAMETER  Bad argument
// WBEM_E_OUT_OF_MEMORY  Lacked resources to create a thread
//
//***************************************************************************

SCODE CImpDyn::GetObjectAsync(
                        IN BSTR ObjPath,
                        IN long lFlags,
						IWbemContext __RPC_FAR *pCtx,
                        IN IWbemObjectSink FAR* pSink)
{
    if(pSink == NULL || ObjPath == NULL)
        return WBEM_E_INVALID_PARAMETER;

    if(IsNT() && IsDcomEnabled())
    {
        SCODE sc = WbemCoImpersonateClient();
        if(sc != S_OK) 
        {
            pSink->SetStatus(0, sc, NULL, NULL);
            return S_OK;
        }
    }

    GetObjectAsyncThread(ObjPath, lFlags, pSink, this, pCtx);
    return S_OK;
}

//***************************************************************************
//
// SCODE CImpDyn::StartBatch
//
// DESCRIPTION:
//
// Called at the start of a batch of gets or puts.  Overriden by
// derived classes which need to do something.  
//
// PARAMETERS:
//
// lFlags               flags
// pClassInt            Points to an instance object
// pObj                 Misc object pointer
// bGet                 TRUE if we will be getting data.
//
// RETURN VALUE:
//
// S_OK
//***************************************************************************

SCODE CImpDyn::StartBatch(
                        IN long lFlags,
                        IN IWbemClassObject FAR * pClassInt,
                        IN CObject **pObj,
                        IN BOOL bGet)
{
    *pObj = NULL;
    return S_OK;
}

//***************************************************************************
//
// CImpDyn::EndBatch
//
// DESCRIPTION:
//
// Called at the end of a batch of gets or puts.  Overriden by
// derived classes which need to do something.  
//
// lFlags               flags
// pClassInt            Points to an instance object
// pObj                 Misc object pointer
// bGet                 TRUE if we will be getting data.
//
// RETURN VALUE:
//
// S_OK
//***************************************************************************

void CImpDyn::EndBatch(
                        IN long lFlags,
                        IN IWbemClassObject FAR * pClassInt,
                        IN CObject *pObj,
                        IN BOOL bGet)
{
    if(pObj)
        delete pObj;
}

//***************************************************************************
// HRESULT CImpDyn::QueryInterface
// long CImpDyn::AddRef
// long CImpDyn::Release
//
// DESCRIPTION:
//
// Standard Com IUNKNOWN functions.
//
//***************************************************************************

STDMETHODIMP CImpDyn::QueryInterface(
                        IN REFIID riid, 
                        OUT PPVOID ppv)
{
    *ppv=NULL;
    
    // The only calls for IUnknown are either in a nonaggregated
    // case or when created in an aggregation, so in either case
    // always return our IUnknown for IID_IUnknown.

    if (IID_IUnknown==riid || IID_IWbemServices == riid)
        *ppv=(IWbemServices*)this;
    else if (IID_IWbemProviderInit==riid)
        *ppv=(IWbemProviderInit*)this;

    if (NULL!=*ppv)
        {
        ((LPUNKNOWN)*ppv)->AddRef();
        return NOERROR;
        }

    return ResultFromScode(E_NOINTERFACE);
 }


STDMETHODIMP_(ULONG) CImpDyn::AddRef(void)
{
    return InterlockedIncrement(&m_cRef);
}

STDMETHODIMP_(ULONG) CImpDyn::Release(void)
{
    long lRet = InterlockedDecrement(&m_cRef);
    if (0L!=lRet)
        return lRet;

    /*
     * Tell the housing that an object is going away so it can
     * shut down if appropriate.
     */
    delete this; // do before decrementing module obj count.
    InterlockedDecrement(&lObj);
    return 0;
}

//***************************************************************************
//
// CImpDyn::EnumPropDoFunc
//
// DESCRIPTION:
//
// This gets an objects attributes and then loops through the propeties
// calling UpdateProperty or RefreshProperty to put or get the data.
//
// PARAMETERS:
//
// lFlags               flags
// pClassInt            Object being refreshed or updated
// FuncType             Indicates if refresh or update
// pwcKey               Optional Key value of the object
// pCache               Option cache
//
// RETURN VALUE:
//
// S_OK                 all is well
// otherwise an WBEMSVC type error.
//
//***************************************************************************

SCODE CImpDyn::EnumPropDoFunc(
                        IN long lFlags,
                        OUT IN IWbemClassObject FAR* pInstance,
                        IN FUNCTYPE FuncType,
                        IN WCHAR * pwcKey,
                        OUT IN CIndexCache * pCache,
                        IN IWbemClassObject * pClass)
{

    SCODE sc;
    BSTR PropName;
    WCHAR * pwcClassContext =  NULL;
    WCHAR * pwcKeyValue = NULL;
    WCHAR * pwcTemp = NULL;
    BOOL bClsidSetForClass = FALSE;
    CProvObj * pProvObj = NULL;
    BSTR bstrKeyName = NULL;
    BOOL bGotOurClass = FALSE;
	int iWorked = 0;
    int iCurr = 0;
    CVariant vProp;
    BOOL bTesterDetails = FALSE;
	bool bAccessDenied = false;

    // Make sure we have a class object.  In some cases, such as enumeration, it
    // is passed.  In others, it must be obtained

    if(pClass == NULL)
    {
        VARIANT var;
        VariantInit(&var);
        sc = pInstance->Get(L"__Class",0,&var,NULL,NULL);
        if(sc != S_OK)
            return sc;
        if(m_pGateway == NULL)
            return WBEM_E_FAILED;
        sc = m_pGateway->GetObject(var.bstrVal,0, NULL, &pClass, NULL);
        VariantClear(&var);
        if(FAILED(sc)) 
            return sc;
        bGotOurClass = TRUE;
    }

    // Find out if expensive test data is desired

    {
        IWbemQualifierSet * pQualifier = NULL;
        CVariant var;

        sc = pClass->GetQualifierSet(&pQualifier); // Get instance Qualifier
        if(FAILED(sc))
            return sc;

        sc = pQualifier->Get(L"TesterDetails" ,0,var.GetVarPtr(), NULL);
        pQualifier->Release();     // free up the interface
        if(sc == S_OK && var.GetType() == VT_BOOL && var.bGetBOOL())
            bTesterDetails = TRUE;
    }


    CObject * pPackageObj = NULL;
    sc = StartBatch(lFlags,pInstance,&pPackageObj,FuncType == REFRESH);
    if(sc != S_OK)
        return WBEM_E_FAILED;

    sc = GetAttString(pClass, NULL, L"classcontext", &pwcClassContext);


    if(pwcKey)
    {
        // This is a special case and means that we are being called
        // as part of instance enumeration.  This means that the key value
        // is already known, and that the class is one of ours

        pwcKeyValue = pwcKey;
        bClsidSetForClass = TRUE;
    }
    else
    {
        
        // Get the Key property.  Note that this doesnt have to work since
        // there might be single instance classes supported by this provider!

        bstrKeyName = GetKeyName(pClass);

        if(bstrKeyName != NULL) 
        {
            sc = pInstance->Get(bstrKeyName,0,vProp.GetVarPtr(),NULL,NULL);
            SysFreeString(bstrKeyName);
            if(sc == S_OK) 
            {
                VARIANT * pTemp = vProp.GetVarPtr();
                if(pTemp->vt == VT_BSTR && pTemp->bstrVal != 0)
                {
                    DWORD dwLen = wcslen(vProp.GetBstr())+1;
                    pwcKeyValue = new WCHAR[dwLen];
                    if(pwcKeyValue == NULL) 
                    {
                        sc = WBEM_E_OUT_OF_MEMORY;
                        goto EnumCleanUp;
                    }
                    StringCchCopyW(pwcKeyValue, dwLen, vProp.GetBstr());
                }
            }
            vProp.Clear();
        }
    }

    // For each property, Get the properties Qualifiers and
    // call the appropriate function to do the a refreshing/updating

    pInstance->BeginEnumeration(0);

    while(WBEM_NO_ERROR == pInstance->Next(0,&PropName, vProp.GetVarPtr(), NULL, NULL)) 
    {
        vProp.Clear();
        pwcTemp = NULL;
        sc = GetAttString(pClass, PropName, L"propertycontext", &pwcTemp, pCache, iCurr);
        iCurr++;
        if(sc== S_OK) 
        {
            LPWSTR pwcFullContext =  NULL;
            sc = MergeStrings(&pwcFullContext,pwcClassContext,pwcKeyValue,pwcTemp);
            if(pwcTemp)
            {
                delete pwcTemp;
                pwcTemp = NULL;
            }
            if(sc == S_OK) 
            {
                if(pProvObj == NULL)
                {
                    pProvObj = new CProvObj(pwcFullContext,MAIN_DELIM,NeedsEscapes());
                    if(pProvObj == NULL)
                    {
                        sc = WBEM_E_OUT_OF_MEMORY;
                        break;
                    }
                }
                else if (!pProvObj->Update(pwcFullContext))
                {
                    sc = WBEM_E_FAILED;
                    break;
                }

                sc = pProvObj->dwGetStatus(iGetMinTokens());

                if(FuncType == REFRESH && sc == S_OK)
				{
                    sc = RefreshProperty(lFlags,pInstance,
                        PropName, *pProvObj, pPackageObj, NULL,bTesterDetails);
					if(sc == S_OK)
							iWorked++;
					else if (sc == 5)
						bAccessDenied = true;
				}
                 else if(FuncType == UPDATE && sc == S_OK)
				 {
                    sc = UpdateProperty(lFlags,pInstance,
                        PropName,  *pProvObj, pPackageObj, NULL);
					if(sc == S_OK)
							iWorked++;
					else if (sc == 5)
						bAccessDenied = true;
				 }
                if(pwcFullContext)
                    delete pwcFullContext;
            }
        }
        else
            sc = S_OK;  // ignore props without propertyContext
        SysFreeString(PropName);
    }  
 
EnumCleanUp:
	if(iWorked > 0)
		sc = S_OK;
    else if(bAccessDenied)
		sc = WBEM_E_ACCESS_DENIED;
	else
        sc = WBEM_E_INVALID_OBJECT_PATH;
    if(pProvObj)
        delete pProvObj;
    if(pwcTemp)
        delete pwcTemp;  
    if(pwcClassContext)
        delete pwcClassContext;  
    if(pwcKeyValue && pwcKey == NULL)
        delete pwcKeyValue;  
    if(bGotOurClass)
        pClass->Release();
    EndBatch(lFlags,pInstance,pPackageObj,FuncType == REFRESH); 
    return sc;
}

//***************************************************************************
//
// SCODE CImpDyn::GetAttString
//
// DESCRIPTION:
//
// Gets an Qualifier string.  The string is will be pointed to by 
// the ppResult argument and should be freed by "delete".
//
// PARAMETERS:
//
// pClassInt            Class object pointer
// pPropName            Property Name, could be null if going after
//                      class attribute
// pAttName             Attribute name
// ppResult             Set to point to the retuned value.
// pCache               Optional cache of values
// iIndex               Optional index in the cache
//
// RETURN VALUE:
//
// S_OK                 all is well
// WBEM_E_OUT_OF_MEMORY  
// otherwise the error is set by the class object's GetQualifierSet function
// or by the qualifier sets "Get" function.
//
//***************************************************************************

SCODE CImpDyn::GetAttString(
                        IN IWbemClassObject FAR* pClassInt,
                        IN LPWSTR pPropName, 
                        IN LPWSTR pAttName,
                        OUT IN LPWSTR * ppResult,
                        OUT IN CIndexCache * pCache,
                        IN int iIndex)
{
    SCODE sc;
    IWbemQualifierSet * pQualifier = NULL;
    CVariant var;

    if(*ppResult)
        delete *ppResult;
    *ppResult = NULL;

    // if there is a cache, try to get it from there
    if(pCache && iIndex != -1)
    {
        *ppResult = pCache->GetWString(iIndex);
        if(*ppResult != NULL)
            return S_OK;
    }
    // Get an Qualifier set interface.

    if(pPropName == NULL)
        sc = pClassInt->GetQualifierSet(&pQualifier); // Get instance Qualifier
    else
        sc = pClassInt->GetPropertyQualifierSet(pPropName,&pQualifier); // Get prop att
    if(FAILED(sc))
        return sc;

    // Get the string and free the Qualifier interface

    sc = pQualifier->Get(pAttName,0,var.GetVarPtr(), NULL);
    pQualifier->Release();     // free up the interface
    if(FAILED(sc))
        return sc;

    // make sure the type is OK

    if(var.GetType() != VT_BSTR) 
        return WBEM_E_FAILED;

    // Allocate data for the buffer and copy the results

    DWORD dwLen = wcslen(var.GetBstr())+1;
    *ppResult = new WCHAR[dwLen];
    if(*ppResult) 
    {
        StringCchCopyW(*ppResult, dwLen, var.GetBstr());
        sc = S_OK;
    }
    else
        sc = WBEM_E_OUT_OF_MEMORY;

    // If there is a cache, add this to it

    if(pCache && iIndex != -1 && *ppResult)
    {
        pCache->SetAt(*ppResult, iIndex);
    }

    return sc;

}

//***************************************************************************
//
// BSTR CImpDyn::GetKeyName
//
// DESCRIPTION:
//
// Gets the name of the property with the the key Qualifier.
//
// PARAMETERS:
//
// pClassInt            Class object pointer
//
// RETURN VALUE:
//
// NULL if error,
// other wise a BSTR which the caller must free
//
//***************************************************************************

BSTR CImpDyn::GetKeyName(
                        IN IWbemClassObject FAR* pClassInt)
{
    IWbemQualifierSet * pQualifier = NULL;
    BSTR PropName = NULL;
    pClassInt->BeginEnumeration(WBEM_FLAG_KEYS_ONLY);


    // Loop through each of the properties and stop once one if found that
    // has a "Key" Qualifier

    while(WBEM_NO_ERROR == pClassInt->Next(0,&PropName,NULL, NULL, NULL)) 
    {
        return PropName;
    }
    return NULL;
}

//***************************************************************************
//
// SCODE CImpDyn::PutInstanceAsync
//
// DESCRIPTION:
//
// PutInstaceAsync writes instance data out.
//
// PARAMETERS:
//
// pClassInt            Class Object pointer
// lFlags               flags.
// pCtx                 Context object, not used anymore.
// pResponseHandler     Where to set the return code.
//
// RETURN VALUE:
//
// Set by EnumPropDoFunc
//
//***************************************************************************

STDMETHODIMP CImpDyn::PutInstanceAsync(
 
            /* [in] */ IWbemClassObject __RPC_FAR *pInst,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler)
{
    SCODE sc = S_OK;
    if(pInst == NULL || pResponseHandler == NULL)
        return WBEM_E_INVALID_PARAMETER;

    if(IsNT() && IsDcomEnabled())
        sc = WbemCoImpersonateClient();
    if(sc == S_OK)
        sc = EnumPropDoFunc(lFlags,pInst,UPDATE);

    // Set the status

    pResponseHandler->SetStatus(0,sc, NULL, NULL);
    return sc;

}

//***************************************************************************
//
// SCODE CImpDyn::ExecMethodAsync
//
// DESCRIPTION:
//
// Executes methods.
//
// PARAMETERS:
//
// pClassInt            Class Object pointer
// lFlags               flags.
// pCtx                 Context object, not used anymore.
// pResponseHandler     Where to set the return code.
//
// RETURN VALUE:
//
// Set by EnumPropDoFunc
//
//***************************************************************************

STDMETHODIMP CImpDyn::ExecMethodAsync(            
			/* [in] */ const BSTR ObjectPath,
            /* [in] */ const BSTR MethodName,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [in] */ IWbemClassObject __RPC_FAR *pInParams,
            /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler
 )
{

    return MethodAsync(ObjectPath, MethodName, 
            lFlags,pCtx, pInParams, pResponseHandler);

}
//***************************************************************************
//
// SCODE CImpDyn::RefreshInstance
//
// DESCRIPTION:
//
// gets fresh values for the properties.
//
// PARAMETERS:
//
// pClassInt            Class Object pointer
// lFlags               flags.
// ppErrorObject        Optional error object
//
// RETURN VALUE:
//
// Set by EnumPropDoFunc
//
//***************************************************************************

STDMETHODIMP CImpDyn::RefreshInstance(
                        IN long lFlags,
                        OUT IN IWbemClassObject FAR* pClassInt)
{
    return EnumPropDoFunc(lFlags,pClassInt,REFRESH);        
}

//***************************************************************************
//
// SCODE CImpDyn::CreateInst
//
// DESCRIPTION:
//
// Creates a new instance via the gateway provider and sets
// the inital values of the properties.
//
// PARAMETERS:
//
// pGateway             Pointer to WBEM 
// pwcClass             Class Name
// pKey                 Key value
// pNewInst             returned pointer to created instance
// pwcKeyName           Name of key property
// pCache               Optional cache
//
// RETURN VALUE:
//
// Return:   S_OK if all is well, 
// otherwise an error code is returned by either GetObject(most likely)
// or spawn instance.
//
//***************************************************************************

SCODE CImpDyn::CreateInst(
                        IN IWbemServices * pGateway,
                        IN LPWSTR pwcClass,
                        IN LPWSTR pKey,
                        OUT IN IWbemClassObject ** pNewInst,
                        IN LPWSTR pwcKeyName,
                        OUT IN CIndexCache * pCache,
                        IWbemContext  *pCtx)
{   
    SCODE sc;
    IWbemClassObject * pClass = NULL;
    

    // Create the new instance

    sc = pGateway->GetObject(pwcClass,0, pCtx, &pClass, NULL);
    if(FAILED(sc)) 
        return sc;
    sc = pClass->SpawnInstance(0, pNewInst);
    if(FAILED(sc)) 
    {
        pClass->Release();
        return sc;
    }
    // Set the key value.  Note that CVariant isnt used because
    // it assumes that the input is a TCHAR.

    VARIANT var;
    var.vt = VT_BSTR;
    var.bstrVal = SysAllocString(pKey);
    if(var.bstrVal == NULL)    
    {
 		(*pNewInst)->Release();
        pClass->Release();
        return WBEM_E_OUT_OF_MEMORY;
    }

    BSTR bstrKeyName;
    if(pwcKeyName == NULL)
        bstrKeyName = GetKeyName(*pNewInst);
    else
        bstrKeyName = SysAllocString(pwcKeyName);

    if(bstrKeyName != NULL) 
    {
        sc = (*pNewInst)->Put(bstrKeyName,0,&var,0);
        SysFreeString(bstrKeyName);
    }
    VariantClear(&var);
    // Use the RefreshInstance routine to set all the other properties

    sc = EnumPropDoFunc(0,*pNewInst,REFRESH, pKey,  pCache, pClass);
    pClass->Release();

	if (FAILED(sc))
		(*pNewInst)->Release();
    // Clean up

    return sc;
}

//***************************************************************************
//
// SCODE CImpDyn::MergeStrings
//
// DESCRIPTION:
//
// Combines the Class Context, Key, and Property Context strings.
//
// PARAMETERS:
//
// ppOut                output combined string, must be freed via delete
// pClassContext        class context
// pKey                 key value
// pPropContext         property context
//
// RETURN VALUE:
//
// S_OK                 if all is well, 
// WBEM_E_INVALID_PARAMETER no property context string or ppOut is NULL
// WBEM_E_OUT_OF_MEMORY
//***************************************************************************

SCODE CImpDyn::MergeStrings(
                        OUT LPWSTR * ppOut,
                        IN LPWSTR  pClassContext,
                        IN LPWSTR  pKey,
                        IN LPWSTR  pPropContext)
{
    
    // Allocate space for output

    int iLen = 3;
    if(pClassContext)
        iLen += wcslen(pClassContext);
    if(pKey)
        iLen += wcslen(pKey);
    if(pPropContext)
        iLen += wcslen(pPropContext);
    else
        return WBEM_E_INVALID_PARAMETER;  // should always have this!
    if(ppOut == NULL)
        return WBEM_E_INVALID_PARAMETER;  // should always have this!

    *ppOut = new WCHAR[iLen];
    if(*ppOut == NULL)
        return WBEM_E_OUT_OF_MEMORY;

    // simple case is that everything is in the property context.  That would
    // be the case when the provider is being used as a simple dynamic 
    // property provider

    if(pClassContext == NULL || pKey == NULL) {
        StringCchCopyW(*ppOut, iLen, pPropContext);
        return S_OK;
        }

    // Copy the class context, then search for the delimeter 

    StringCchCopyW(*ppOut, iLen, pClassContext);
    WCHAR * pTest;
    for(pTest = *ppOut; *pTest; pTest++)
        if(*pTest == MAIN_DELIM)
            break;
    
     // Three cases;

    if(*pTest == NULL)
        StringCchCatW(*ppOut, iLen,L"|");    // HKLM  BLA VALUE      add |
    else if( *(pTest +1))
        StringCchCatW(*ppOut, iLen,L"\\");   // HKLM|BLA BLA VALUE   add \ 
    else;                       // HKLM| BLA VALUE      do nothing!
    
    StringCchCatW(*ppOut, iLen,pKey);
    if(pPropContext[0] != L'|' && pPropContext[0] != L'\\')
    StringCchCatW(*ppOut, iLen,L"|");
    StringCchCatW(*ppOut, iLen,pPropContext);
    return S_OK;
}


//***************************************************************************
//
// SCODE CImpDyn::ReturnAndSetObj
//
// DESCRIPTION:
//
// Takes care of creating and setting an error object.
//
// PARAMETERS:
//
// sc                   value to set
// ppErrorObject        point which will point to the error object.
//
// RETURN VALUE:
//
// what ever was passed in.
//***************************************************************************

SCODE CImpDyn::ReturnAndSetObj(
                        IN SCODE sc,
                        OUT IN IWbemCallResult FAR* FAR* ppCallResult)
{
//    if(ppErrorObject)
//        *ppErrorObject = GetNotifyObj(m_pGateway,sc);
    return sc;
}


//***************************************************************************
//
// long CImpDyn::AddRef
//
// DESCRIPTION:
//
// Adds to the reference count.
//  
// RETURN VALUE:
//
// current reference count.
//
//***************************************************************************

long CEnumInfo::AddRef(void)
{
    return InterlockedIncrement(&m_cRef);
}

//***************************************************************************
//
// long CImpDyn::Release
//
// DESCRIPTION:
//
// Interface has been released.  Object will be deleted if the
// usage count is zero.
//
// RETURN VALUE:
//
// current reference count.
//
//***************************************************************************

long CEnumInfo::Release(void)
{
    long lRet = InterlockedDecrement(&m_cRef);
    if (0L!=lRet)
        return lRet;
    delete this;
    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\winmgmt\stdprov\impdyn.h ===
/*++

Copyright (C) 1995-2001 Microsoft Corporation

Module Name:

    IMPDYN.H

Abstract:

	Declares the various generic provider classes.

History:

	a-davj  27-Sep-95   Created.

--*/

#ifndef _IMPDYN_H_
#define _IMPDYN_H_

#include "indexcac.h"
#include "cvariant.h"

typedef enum {REFRESH,UPDATE} FUNCTYPE;

typedef struct SET_STATUS{
    DWORD dwType;
    DWORD dwSize;
    DWORD dwResult;
    } STATSET, * PSETSTAT;

#ifndef PPVOID
typedef LPVOID * PPVOID;
#endif  //PPVOID

//***************************************************************************
//
//  CLASS NAME:
//
//  CEnumInfo
//
//  DESCRIPTION:
//
//  base class of various collection objects used to keep track of instances
//  for enumeration.
//
//***************************************************************************

class CEnumInfo : public CObject{
    public:
        CEnumInfo(){m_cRef = 1;};
        virtual ~CEnumInfo(){return;};
        long AddRef(void);
        long Release(void);
    private:
        long m_cRef;         //Object reference count
};

//***************************************************************************
//
//  CLASS NAME:
//
//  CImpDyn
//
//  DESCRIPTION:
//
//  This is the base class of the instance providers.  It does quite a lot
//  though the actual getting and putting of data is overriden by derived
//  classes.
//
//***************************************************************************

class CImpDyn : public IWbemServices, public IWbemProviderInit
    {
    protected:
        long           m_cRef;         //Object reference count
        IWbemServices *  m_pGateway;
        WCHAR           wcCLSID[42];
        IWbemContext *   m_pCtx;
    public:
        CImpDyn();
        virtual ~CImpDyn(void);

        SCODE ReturnAndSetObj(SCODE sc, IWbemCallResult FAR* FAR* ppCallResult);
        virtual SCODE MakeEnum(IWbemClassObject * pClass, CProvObj & ProvObj, 
                                 CEnumInfo ** ppInfo) { return E_NOTIMPL;};
        virtual SCODE GetKey(CEnumInfo * pInfo, int iIndex, LPWSTR * ppKey) 
                                 {return E_NOTIMPL;};

        BSTR GetKeyName(IWbemClassObject FAR* pClassInt);
        virtual int iGetMinTokens(void) = 0;
        virtual SCODE RefreshProperty(long lFlags, IWbemClassObject FAR * pClassInt,
                                        BSTR PropName,CProvObj & ProvObj,CObject * pPackage,
                                        CVariant * pVar, BOOL bTesterDetails) = 0;
        virtual SCODE UpdateProperty(long lFlags, IWbemClassObject FAR * pClassInt,
                                        BSTR PropName,CProvObj & ProvObj,CObject * pPackage,
                                        CVariant * pVar) = 0;
        virtual SCODE StartBatch(long lFlags, IWbemClassObject FAR * pClassInt,CObject **pObj,BOOL bGet);
        virtual void EndBatch(long lFlags, IWbemClassObject FAR * pClassInt,CObject *pObj,BOOL bGet);
        
        SCODE EnumPropDoFunc( long lFlags, IWbemClassObject FAR* pInstance, FUNCTYPE FuncType,
                              LPWSTR pwcKey = NULL,
                              CIndexCache * pCache = NULL,
                              IWbemClassObject * pClass = NULL);
        SCODE CImpDyn::GetAttString(IWbemClassObject FAR* pClassInt, LPWSTR pPropName, 
                                            LPWSTR pAttName, LPWSTR * ppResult,
                                            CIndexCache * pCache = NULL, int iIndex = -1);
        
        SCODE GetByKey( BSTR ClassRef, long lFlags, SAFEARRAY FAR* FAR* pKeyNames, SAFEARRAY FAR* FAR* pKeyValues, IWbemClassObject FAR* FAR* pObj);
        SCODE CreateInst( IWbemServices * pGateway, LPWSTR pwcClass, 
                              LPWSTR pKey, IWbemClassObject ** pNewInst,
                              LPWSTR pwcKeyName = NULL,
                              CIndexCache * pCache = NULL,
                              IWbemContext  *pCtx = NULL);
		virtual SCODE MethodAsync(BSTR ObjectPath, BSTR MethodName, 
            long lFlags, IWbemContext* pCtx, IWbemClassObject* pInParams, 
            IWbemObjectSink* pSink){return WBEM_E_NOT_SUPPORTED;};

        virtual SCODE MergeStrings(LPWSTR *ppOut,LPWSTR  pClassContext,LPWSTR  pKey,LPWSTR  pPropContext);

        virtual bool NeedsEscapes(){return false;};     // so far, on reg prov needs this
    STDMETHOD_(SCODE, RefreshInstance)(THIS_  long lFlags, IWbemClassObject FAR* pObj);

    //Non-delegating object IUnknown
        STDMETHODIMP         QueryInterface(REFIID, PPVOID);
        STDMETHODIMP_(ULONG) AddRef(void);
        STDMETHODIMP_(ULONG) Release(void);

    /* IWbemProviderInit methods */
    
        HRESULT STDMETHODCALLTYPE Initialize(LPWSTR wszUser, long lFlags,
                LPWSTR wszNamespace, LPWSTR wszLocale, 
                IWbemServices* pNamespace, IWbemContext* pContext, 
                IWbemProviderInitSink* pSink);

    /* IWbemServices methods */

        HRESULT STDMETHODCALLTYPE OpenNamespace( 
            /* [in] */ const BSTR Namespace,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [unique][in][out] */ IWbemServices __RPC_FAR *__RPC_FAR *ppWorkingNamespace,
            /* [unique][in][out] */ IWbemCallResult __RPC_FAR *__RPC_FAR *ppResult){return WBEM_E_NOT_SUPPORTED;};
        
        HRESULT STDMETHODCALLTYPE CancelAsyncCall( 
            /* [in] */ IWbemObjectSink __RPC_FAR *pSink){return WBEM_E_NOT_SUPPORTED;};
        
        HRESULT STDMETHODCALLTYPE QueryObjectSink( 
            /* [in] */ long lFlags,
            /* [out] */ IWbemObjectSink __RPC_FAR *__RPC_FAR *ppResponseHandler){return WBEM_E_NOT_SUPPORTED;};
        
        HRESULT STDMETHODCALLTYPE GetObject( 
            /* [in] */ const BSTR ObjectPath,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [unique][in][out] */ IWbemClassObject __RPC_FAR *__RPC_FAR *ppObject,
            /* [unique][in][out] */ IWbemCallResult __RPC_FAR *__RPC_FAR *ppCallResult);
        
        HRESULT STDMETHODCALLTYPE GetObjectAsync( 
            /* [in] */ const BSTR ObjectPath,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler);
        
        HRESULT STDMETHODCALLTYPE PutClass( 
            /* [in] */ IWbemClassObject __RPC_FAR *pObject,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [unique][in][out] */ IWbemCallResult __RPC_FAR *__RPC_FAR *ppCallResult){return WBEM_E_NOT_SUPPORTED;};
        
        HRESULT STDMETHODCALLTYPE PutClassAsync( 
            /* [in] */ IWbemClassObject __RPC_FAR *pObject,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler){return WBEM_E_NOT_SUPPORTED;};
        
        HRESULT STDMETHODCALLTYPE DeleteClass( 
            /* [in] */ const BSTR Class,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [unique][in][out] */ IWbemCallResult __RPC_FAR *__RPC_FAR *ppCallResult){return WBEM_E_NOT_SUPPORTED;};
        
        HRESULT STDMETHODCALLTYPE DeleteClassAsync( 
            /* [in] */ const BSTR Class,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler){return WBEM_E_NOT_SUPPORTED;};
        
        HRESULT STDMETHODCALLTYPE CreateClassEnum( 
            /* [in] */ const BSTR Superclass,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [out] */ IEnumWbemClassObject __RPC_FAR *__RPC_FAR *ppEnum){return WBEM_E_NOT_SUPPORTED;};
        
        HRESULT STDMETHODCALLTYPE CreateClassEnumAsync( 
            /* [in] */ const BSTR Superclass,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler);
        
        HRESULT STDMETHODCALLTYPE PutInstance( 
            /* [in] */ IWbemClassObject __RPC_FAR *pInst,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [unique][in][out] */ IWbemCallResult __RPC_FAR *__RPC_FAR *ppCallResult){return WBEM_E_NOT_SUPPORTED;};
        
        HRESULT STDMETHODCALLTYPE PutInstanceAsync( 
            /* [in] */ IWbemClassObject __RPC_FAR *pInst,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler);
        
        HRESULT STDMETHODCALLTYPE DeleteInstance( 
            /* [in] */ const BSTR ObjectPath,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [unique][in][out] */ IWbemCallResult __RPC_FAR *__RPC_FAR *ppCallResult){return WBEM_E_NOT_SUPPORTED;};
        
        HRESULT STDMETHODCALLTYPE DeleteInstanceAsync( 
            /* [in] */ const BSTR ObjectPath,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler){return WBEM_E_NOT_SUPPORTED;};
        
        HRESULT STDMETHODCALLTYPE CreateInstanceEnum( 
            /* [in] */ const BSTR Class,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [out] */ IEnumWbemClassObject __RPC_FAR *__RPC_FAR *ppEnum);
        
        HRESULT STDMETHODCALLTYPE CreateInstanceEnumAsync( 
            /* [in] */ const BSTR Class,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler);
        
        HRESULT STDMETHODCALLTYPE ExecQuery( 
            /* [in] */ const BSTR QueryLanguage,
            /* [in] */ const BSTR Query,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [out] */ IEnumWbemClassObject __RPC_FAR *__RPC_FAR *ppEnum){return WBEM_E_NOT_SUPPORTED;};
        
        HRESULT STDMETHODCALLTYPE ExecQueryAsync( 
            /* [in] */ const BSTR QueryLanguage,
            /* [in] */ const BSTR Query,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler){return WBEM_E_NOT_SUPPORTED;};
        
        HRESULT STDMETHODCALLTYPE ExecNotificationQuery( 
            /* [in] */ const BSTR QueryLanguage,
            /* [in] */ const BSTR Query,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [out] */ IEnumWbemClassObject __RPC_FAR *__RPC_FAR *ppEnum){return WBEM_E_NOT_SUPPORTED;};
        
        HRESULT STDMETHODCALLTYPE ExecNotificationQueryAsync( 
            /* [in] */ const BSTR QueryLanguage,
            /* [in] */ const BSTR Query,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler){return WBEM_E_NOT_SUPPORTED;};
        
        HRESULT STDMETHODCALLTYPE ExecMethod( 
            /* [in] */ const BSTR ObjectPath,
            /* [in] */ const BSTR MethodName,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [in] */ IWbemClassObject __RPC_FAR *pInParams,
            /* [unique][in][out] */ IWbemClassObject __RPC_FAR *__RPC_FAR *ppOutParams,
            /* [unique][in][out] */ IWbemCallResult __RPC_FAR *__RPC_FAR *ppCallResult) 
						{return WBEM_E_NOT_SUPPORTED;};
        
        HRESULT STDMETHODCALLTYPE ExecMethodAsync( 
            /* [in] */ const BSTR ObjectPath,
            /* [in] */ const BSTR MethodName,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [in] */ IWbemClassObject __RPC_FAR *pInParams,
            /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler);
   };

typedef CImpDyn *PCImpDyn;


//***************************************************************************
//
//  CLASS NAME:
//
//  CImpDynProp
//
//  DESCRIPTION:
//
//  This is the base class of the property providers.  It does quite a lot
//  though the actual getting and putting of data is overriden by derived
//  classes.
//
//***************************************************************************

class CImpDynProp : public IWbemPropertyProvider
    {
    protected:
        long            m_cRef;         //Object reference count
        WCHAR           wcCLSID[42];
        CImpDyn *       m_pImpDynProv;
        WCHAR * BuildString(BSTR ClassMapping, BSTR InstMapping, 
                                  BSTR PropMapping);
    public:
        CImpDynProp();
        virtual ~CImpDynProp(void);
        virtual bool NeedsEscapes(){return false;};     // so far, on reg prov needs this

    //Non-delegating object IUnknown
        STDMETHODIMP         QueryInterface(REFIID, PPVOID);
        STDMETHODIMP_(ULONG) AddRef(void);
        STDMETHODIMP_(ULONG) Release(void);

    
    /* IWbemPropertyProvider methods */

       virtual HRESULT STDMETHODCALLTYPE GetProperty( 
		    long lFlags,
		    const BSTR Locale,
            const BSTR ClassMapping,
            const BSTR InstMapping,
            const BSTR PropMapping,
            VARIANT *pvValue);
        
        virtual HRESULT STDMETHODCALLTYPE PutProperty( 
		    long lFlags,
		    const BSTR Locale,
            /* [in] */ const BSTR ClassMapping,
            /* [in] */ const BSTR InstMapping,
            /* [in] */ const BSTR PropMapping,
            /* [in] */ const VARIANT __RPC_FAR *pvValue);
    };



//***************************************************************************
//
//  CLASS NAME:
//
//  CEnumInst
//
//  DESCRIPTION:
//
//  This class is used to enumerate instances
//
//***************************************************************************

class CEnumInst : public IEnumWbemClassObject
    {
    protected:
        int    m_iIndex;
        CEnumInfo * m_pEnumInfo;
        WCHAR * m_pwcClass;
        long m_lFlags;
        IWbemContext  * m_pCtx;
        

        IWbemServices FAR* m_pWBEMGateway;
        CImpDyn * m_pProvider;
        long           m_cRef;
        BSTR m_bstrKeyName;
        CIndexCache m_PropContextCache;
    public:
        CEnumInst(CEnumInfo * pEnumInfo,long lFlags,WCHAR * pClass,IWbemServices FAR* pWBEMGateway,
            CImpDyn * pProvider, IWbemContext  *pCtx);
        ~CEnumInst(void);

        //IUnknown members
        STDMETHODIMP         QueryInterface(REFIID, PPVOID);
        STDMETHODIMP_(ULONG) AddRef(void);
        STDMETHODIMP_(ULONG) Release(void);

    STDMETHOD(GetTypeInfoCount)(THIS_ UINT FAR* pctinfo){return WBEM_E_NOT_SUPPORTED;};

        STDMETHOD(GetTypeInfo)(
           THIS_
           UINT itinfo,
           LCID lcid,
           ITypeInfo FAR* FAR* pptinfo){return WBEM_E_NOT_SUPPORTED;};

        STDMETHOD(GetIDsOfNames)(
          THIS_
          REFIID riid,
          OLECHAR FAR* FAR* rgszNames,
          UINT cNames,
          LCID lcid,
          DISPID FAR* rgdispid){return WBEM_E_NOT_SUPPORTED;};

        STDMETHOD(Invoke)(
          THIS_
          DISPID dispidMember,
          REFIID riid,
          LCID lcid,
          WORD wFlags,
          DISPPARAMS FAR* pdispparams,
          VARIANT FAR* pvarResult,
          EXCEPINFO FAR* pexcepinfo,
          UINT FAR* puArgErr){return WBEM_E_NOT_SUPPORTED;};
      
       /* IEnumWbemClassObject methods */

        HRESULT STDMETHODCALLTYPE Reset( void);
        
        HRESULT STDMETHODCALLTYPE Next( 
            /* [in] */ long lTimeout,
            /* [in] */ unsigned long uCount,
            /* [length_is][size_is][out] */ IWbemClassObject __RPC_FAR *__RPC_FAR *ppObject,
            /* [out] */ unsigned long __RPC_FAR *puReturned);
        
        HRESULT STDMETHODCALLTYPE NextAsync( 
            /* [in] */ unsigned long uCount,
            /* [in] */ IWbemObjectSink __RPC_FAR *pSink){return WBEM_E_NOT_SUPPORTED;};
        
        HRESULT STDMETHODCALLTYPE Clone( 
            /* [out] */ IEnumWbemClassObject __RPC_FAR *__RPC_FAR *ppEnum);
        
        HRESULT STDMETHODCALLTYPE Skip( 
            /* [in] */ long lTimeout,
            /* [in] */ unsigned long nNum);

    };
// This structure is passed to async enumerators

typedef struct {
   IEnumWbemClassObject FAR* pIEnum;
   IWbemObjectSink FAR* pHandler;
   } ArgStruct;

// this utility is useful for setting error objects and end of async calls

IWbemClassObject * GetNotifyObj(IWbemServices * pServices, long lRet, IWbemContext * pCtx);


#endif //_IMPDYN_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\winmgmt\stdprov\indexcac.h ===
/*++

Copyright (C) 1997-2001 Microsoft Corporation

Module Name:

    INDEXCAC.H

Abstract:

	Declares the CCacheEntry and CIndexCache classes.

History:

	a-davj  04-Mar-97   Created.

--*/

#ifndef _INDEXCAC_H_
#define _INDEXCAC_H_


//***************************************************************************
//
//  CLASS NAME:
//
//  CCacheEntry
//
//  DESCRIPTION:
//
//   This "object" is used as a structure.   It holds a cache entry.
//
//***************************************************************************

class CCacheEntry : public CObject {
   public:
      CCacheEntry(TCHAR * pValue, int iIndex);
      CCacheEntry(WCHAR * pValue);
      ~CCacheEntry();
      int m_iIndex;
      TCHAR * m_ptcValue;
      WCHAR * m_pwcValue;
};


//***************************************************************************
//
//  CLASS NAME:
//
//  CIndexCache
//
//  DESCRIPTION:
//
//  Holds a cache for string/integer combinations that the perf monitor 
//  provider uses to speed up lookup.
//
//***************************************************************************

class CIndexCache : public CObject {
   public:
      CIndexCache();
      ~CIndexCache(){Empty();};
      void Empty();

      // this routine returns -1, if the entry isnt found.  The second
      // argument can be used to find subsequent entries.

      int Find(const TCHAR * pFind, DWORD dwWhichEntry = 0);

      // this routine returns TRUE if the add worked

      BOOL Add(TCHAR * pAdd, int iIndex);
      
      // this routine returns NULL if the index isnt found.  Note that
      // the index isnt necessarily the m_iIndex value as found in the entry

      WCHAR * GetWString(int iIndex);
      BOOL SetAt(WCHAR * pwcAdd, int iIndex);


   private:
      CFlexArray m_Array;
};

#endif //_INDEXCAC_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\winmgmt\stdprov\indexcac.cpp ===
/*++

Copyright (C) 1997-2001 Microsoft Corporation

Module Name:

    INDEXCAC.CPP

Abstract:

	Caches string/integer combinations.

History:

	a-davj  04-Mar-97   Created.

--*/

#include "precomp.h"
#include "indexcac.h"

//***************************************************************************
//
//  CCacheEntry::CCacheEntry  
//
//  DESCRIPTION:
//
//  Constructor.
//
//  PARAMETERS:
//
//  pValue              string value to save
//  iIndex              integer value to save
//***************************************************************************

CCacheEntry::CCacheEntry(
                        TCHAR * pValue,
                        int iIndex) 
                        : CObject()
{
    m_iIndex = iIndex;
    m_ptcValue = pValue;
    m_pwcValue = NULL;
}

//***************************************************************************
//
//  CCacheEntry::CCacheEntry  
//
//  DESCRIPTION:
//
//  Constructor.
//
//  PARAMETERS:
//
//  pValue              string value to save
//  
//***************************************************************************

CCacheEntry::CCacheEntry(
                        WCHAR * pValue) 
                        : CObject()
{
    m_iIndex = -1;
    m_ptcValue = NULL;
    m_pwcValue = pValue;
}

//***************************************************************************
//
//  CCacheEntry::~CCacheEntry  
//
//  DESCRIPTION:
//
//  Destructor.
//
//***************************************************************************

CCacheEntry::~CCacheEntry()
{
    if(m_ptcValue)
        delete m_ptcValue;
    if(m_pwcValue)
        delete m_pwcValue;
}

//***************************************************************************
//
//  CIndexCache::CIndexCache  
//
//  DESCRIPTION:
//
//  Constructor.
//  
//***************************************************************************

CIndexCache::CIndexCache()
{

}

//***************************************************************************
//
//  void CIndexCache::Empty  
//
//  DESCRIPTION:
//
//  Frees up the storage.
//  
//***************************************************************************

void CIndexCache::Empty()
{
    CCacheEntry * pEntry;
    int iCnt, iSize;
    iSize = m_Array.Size();
    for(iCnt = 0; iCnt < iSize; iCnt++)
    {
        pEntry = (CCacheEntry *)m_Array.GetAt(iCnt);
        if(pEntry)
            delete pEntry;
    }
    if(iSize > 0)
        m_Array.Empty();

}

//***************************************************************************
//
//  int CIndexCache::Find  
//
//  DESCRIPTION:
//
//  Finds an entry in the cache.
//
//  PARAMETERS:
//
//  pFind               string value used to locate the entry
//  dwWhichEntry        a non zero value would return subsequent 
//                      matching entries.
//
//  RETURN VALUE:
//
//  index in cache.  -1 if the entry cant be found
//  
//***************************************************************************

int CIndexCache::Find(
                        IN const TCHAR * pFind, DWORD dwWhichEntry)
{
    CCacheEntry * pEntry;
    int iCnt, iSize;
    DWORD dwFound = 0;
    iSize = m_Array.Size();
    for(iCnt = 0; iCnt < iSize; iCnt++)
    {
        pEntry = (CCacheEntry *)m_Array.GetAt(iCnt);
        if(!lstrcmpi(pEntry->m_ptcValue, pFind))
            if(dwFound == dwWhichEntry)
                return pEntry->m_iIndex;
            else
                dwFound++;
    }
    return -1;  // never found it
}

//***************************************************************************
//
//  BOOL CIndexCache::Add  
//
//  DESCRIPTION:
//
//  Adds an entry to the cache.
//
//  PARAMETERS:
//
//  pAdd                string to add to cache
//  iIndex              associated number
//
//  RETURN VALUE:
//
//  
//***************************************************************************

BOOL CIndexCache::Add(
                        IN TCHAR * pAdd,
                        IN int iIndex)
{
    DWORD dwLen = lstrlen(pAdd)+1;
    TCHAR * pValue = new TCHAR[dwLen];

    if(pValue == NULL)
        return FALSE;
    StringCchCopyW(pValue, dwLen, pAdd);

    // Note that if created, the CCacheEntry object owns the string and
    // will take care of freeing it

    CCacheEntry * pNew = new CCacheEntry(pValue, iIndex);
    if(pNew == NULL)
    {
        delete pValue;
        return FALSE;
    }
    int iRet = m_Array.Add(pNew);
	if(iRet == CFlexArray::no_error)
		return TRUE;
    {
        delete pNew;
        return FALSE;
    }
}


//***************************************************************************
//
//  WCHAR * CIndexCache::GetWString  
//
//  DESCRIPTION:
//
//  Gets a string from the cache.
//
//  PARAMETERS:
//
//  iIndex              cache index
//
//  RETURN VALUE:
//
//  pointer to string, does not need to be freed.  NULL if the index 
//  is invalid.
//***************************************************************************

WCHAR * CIndexCache::GetWString(
                        IN int iIndex)
{
    DWORD dwLen;
    if(iIndex >= m_Array.Size())
        return NULL;
    CCacheEntry * pEntry = (CCacheEntry *)m_Array.GetAt(iIndex);
    if(pEntry == NULL)
        return NULL;

    dwLen = wcslen(pEntry->m_pwcValue)+1;
    WCHAR * pRet = new WCHAR[dwLen];
    if(pRet)
        StringCchCopyW(pRet, dwLen, pEntry->m_pwcValue);
    return pRet;
}

//***************************************************************************
//
//  BOOL CIndexCache::SetAt  
//
//  DESCRIPTION:
//
//  Sets a cache entry.
//
//  PARAMETERS:
//
//  pwcAdd              string to store
//  iIndex              cache index to use
//
//  RETURN VALUE:
//
//  
//***************************************************************************

BOOL CIndexCache::SetAt(
                        IN WCHAR * pwcAdd,
                        IN int iIndex)
{
    DWORD dwLen = wcslen(pwcAdd)+1;
    WCHAR * pValue = new WCHAR[dwLen];

    if(pValue == NULL)
        return FALSE;
    StringCchCopyW(pValue, dwLen, pwcAdd);

    // Note that if created, the CCacheEntry object owns the string and
    // will take care of freeing it

    CCacheEntry * pNew = new CCacheEntry(pValue);
    if(pNew == NULL)
    {
        delete pValue;
        return FALSE;
    }
    
	if(iIndex < m_Array.Size())
	{
		m_Array.SetAt(iIndex, pNew);
		return TRUE;
	}

	if(CFlexArray::no_error == m_Array.InsertAt(iIndex, pNew))
        return TRUE;
    {
        delete pNew;
        return FALSE;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\winmgmt\stdprov\impdynp.cpp ===
/*++

Copyright (C) 1995-2001 Microsoft Corporation

Module Name:

    IMPDYNP.CPP

Abstract:

	Defines the virtual base class for the Property Provider
	objects.  The base class is overriden for each specific
	provider which provides the details of how an actual
	property "Put" or "Get" is done.

History:

	a-davj  27-Sep-95   Created.

--*/

#include "precomp.h"

//#define _MT
#include <process.h>
#include "impdyn.h"
#include "CVariant.h"
#include <genlex.h>
#include <objpath.h>
#include <genutils.h>
#include <cominit.h>

//***************************************************************************
//
//  CImpDynProp::CImpDynProp  
//
//  DESCRIPTION:
//
//  Constructor.
//
//***************************************************************************

CImpDynProp::CImpDynProp()
{
    m_pImpDynProv = NULL;  // This is set in the derived class constructors.
    m_cRef=0;

    return;
}

//***************************************************************************
//
//  CImpDynProp::~CImpDynProp  
//
//  DESCRIPTION:
//
//  Destructor.
//  
//***************************************************************************

CImpDynProp::~CImpDynProp(void)
{
    return;
}

//***************************************************************************
// HRESULT CImpDynProp::QueryInterface
// long CImpDynProp::AddRef
// long CImpDynProp::Release
//
// DESCRIPTION:
//
// Standard Com IUNKNOWN functions.
//
//***************************************************************************

STDMETHODIMP CImpDynProp::QueryInterface(
                        REFIID riid,
                        PPVOID ppv)
{
    *ppv=NULL;
    
    // The only calls for IUnknown are either in a nonaggregated
    // case or when created in an aggregation, so in either case
    // always return our IUnknown for IID_IUnknown.

    if (IID_IUnknown==riid || IID_IWbemPropertyProvider == riid)
        *ppv=this;

    if (NULL!=*ppv)
        {
        ((LPUNKNOWN)*ppv)->AddRef();
        return NOERROR;
        }

    return ResultFromScode(E_NOINTERFACE);
 }

STDMETHODIMP_(ULONG) CImpDynProp::AddRef(void)
{
    return InterlockedIncrement(&m_cRef);
}

STDMETHODIMP_(ULONG) CImpDynProp::Release(void)
{
    long lRet = InterlockedDecrement(&m_cRef);
    if (0L != lRet)
        return lRet;

     // Tell the housing that an object is going away so it can
     // shut down if appropriate.
     
    delete this; // do before decrementing module obj count.
    InterlockedDecrement(&lObj);
    return 0;
}

//***************************************************************************
//
//  WCHAR * CImpDynProp::BuildString  
//
//  DESCRIPTION:
//
//  Creates a concatenation of the mapping strings.
//
//  PARAMETERS:
//
//  ClassMapping        Class Mapping string passed in by WBEM
//  InstMapping         Instance Mapping string passed in by WBEM
//  PropMapping         Property Mapping string passed in by WBEM
//
//  RETURN VALUE:
//
//  Pointer to the combined string.  This must be freed by the caller 
//  via "delete".  NULL is return if low memory.
//
//***************************************************************************

WCHAR * CImpDynProp::BuildString(
                        IN BSTR ClassMapping,
                        IN BSTR InstMapping,
                        IN BSTR PropMapping)
{

    int iLen = 3;
    if(ClassMapping)
        iLen += wcslen(ClassMapping);
        
    if(InstMapping)
        iLen += wcslen(InstMapping);
        
    if(PropMapping) 
        iLen += wcslen(PropMapping);

    WCHAR * pNew = new WCHAR[iLen]; 
    if(pNew == NULL)
        return NULL;

    *pNew = NULL;
    if(ClassMapping)
        StringCchCatW(pNew, iLen, ClassMapping);

    if(InstMapping)
        StringCchCatW(pNew, iLen, InstMapping);

    if(PropMapping)
        StringCchCatW(pNew, iLen, PropMapping);

    return pNew;
 
}

//***************************************************************************
//
//  STDMETHODIMP CImpDynProp::PutProperty  
//
//  DESCRIPTION:
//
//  Writes data out to something like the registry.
//
//  PARAMETERS:
//
//  ClassMapping        Class Mapping string passed in by WBEM
//  InstMapping         Instance Mapping string passed in by WBEM
//  PropMapping         Property Mapping string passed in by WBEM
//  pvValue             Value to be put
//
//  RETURN VALUE:
//
//  S_OK                    all is well
//  WBEM_E_OUT_OF_MEMORY     low memory
//  WBEM_E_INVALID_PARAMETER missing tokens
//  otherwise error code from OMSVariantChangeType, or UpdateProperty
//
//***************************************************************************

STDMETHODIMP CImpDynProp::PutProperty(
					    long lFlags,
						const BSTR Locale,
                        IN const BSTR ClassMapping,
                        IN const BSTR InstMapping,
                        IN const BSTR PropMapping,
                        IN const VARIANT *pvValue)
{
    SCODE sc;
    if(IsNT())
    {
        sc = WbemCoImpersonateClient();
        if(FAILED(sc))
            return sc;
    }
    WCHAR * pNew = BuildString(ClassMapping, InstMapping, PropMapping);
    if(pNew == NULL)
        return WBEM_E_OUT_OF_MEMORY;
    if(wcslen(pNew) == 3)
    {
        delete pNew;
        return WBEM_E_INVALID_PARAMETER;
    }

    CObject * pPackageObj = NULL;
    sc = m_pImpDynProv->StartBatch(0,NULL,&pPackageObj,FALSE);
    if(sc != S_OK) 
    {
        delete pNew;
        return WBEM_E_OUT_OF_MEMORY;
    }

    CVariant cVar;
    sc = OMSVariantChangeType(cVar.GetVarPtr(), (VARIANT *)pvValue, 0, pvValue->vt);

    if(sc == S_OK)
    {
        CProvObj ProvObj(pNew,MAIN_DELIM,NeedsEscapes());

        sc = m_pImpDynProv->UpdateProperty(0,NULL, NULL, ProvObj, pPackageObj, &cVar);
    }
    delete pNew;

    m_pImpDynProv->EndBatch(0, NULL,pPackageObj, FALSE); 
    return sc;

}

//***************************************************************************
//
//  STDMETHODIMP CImpDynProp::GetProperty  
//
//  DESCRIPTION:
//
//  Gets data from something like the registry.
//
//  PARAMETERS:
//
//  ClassMapping        Class Mapping string passed in by WBEM
//  InstMapping         Instance Mapping string passed in by WBEM
//  PropMapping         Property Mapping string passed in by WBEM
//  pvValue             Value to be put
//
//  RETURN VALUE:
//
//  S_OK                    all is well
//  WBEM_E_OUT_OF_MEMORY     low memory
//  WBEM_E_INVALID_PARAMETER missing tokens
//  otherwise error code from RefreshProperty
//
//***************************************************************************

STDMETHODIMP CImpDynProp::GetProperty(
					    long lFlags,
						const BSTR Locale,
                        IN const BSTR ClassMapping,
                        IN const BSTR InstMapping,
                        IN const BSTR PropMapping,
                        OUT IN VARIANT *pvValue)
{
    SCODE sc;
    if(IsNT())
    {
        sc = WbemCoImpersonateClient();
        if(FAILED(sc))
            return sc;
    }

    WCHAR * pNew = BuildString(ClassMapping, InstMapping, PropMapping);
    memset((void *)&(pvValue->bstrVal),0,8);
    if(pNew == NULL)
        return WBEM_E_OUT_OF_MEMORY;

    if(wcslen(pNew) == 3)
    {
        delete pNew;
        return WBEM_E_INVALID_PARAMETER;
    }

    CObject * pPackageObj = NULL;
    sc = m_pImpDynProv->StartBatch(0,NULL,&pPackageObj,TRUE);
    if(sc != S_OK) 
    {
        delete pNew;
        return WBEM_E_OUT_OF_MEMORY;
    }

    CVariant cVar;
    CProvObj ProvObj(pNew,MAIN_DELIM,NeedsEscapes());

    sc = m_pImpDynProv->RefreshProperty(0, NULL, NULL, ProvObj, pPackageObj, &cVar, FALSE);

    if(sc == S_OK)
        sc = VariantCopy(pvValue, cVar.GetVarPtr());

    delete pNew;
    m_pImpDynProv->EndBatch(0,NULL,pPackageObj, TRUE); 
    return sc;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\winmgmt\stdprov\perfcach.h ===
/*++

Copyright (C) 1997-2001 Microsoft Corporation

Module Name:

    PERFCACH.H

Abstract:

	Defines data useful for the NT performance providers.

History:

	a-davj  04-Mar-97   Created.

--*/

#define PERMANENT 0xFFFFFFFF

// If an object has not be retrieved in this many MS, the stop 
// automatically getting it

#define MAX_UNUSED_KEEP 30000

// Define how big the buffers will start as.  This size should be a bit 
// bigger than the "standard" counters and thus reallocations shouldnt
// be necessary

#define INITIAL_ALLOCATION 25000

// maximum age in ms of the "newest" data in the cache

#define MAX_NEW_AGE     2000

// maximum age in ms of the "oldest" data in the cache

#define MAX_OLD_AGE     10000

// minimum time difference between old and new sample

#define MIN_TIME_DIFF 1000


typedef struct _LINESTRUCT
   {
   LONGLONG                        lnNewTime;
   LONGLONG                        lnOldTime;
   LONGLONG                        lnOldTime100Ns ;
   LONGLONG                        lnNewTime100Ns ;
   LONGLONG                        lnaCounterValue[2];
   LONGLONG                        lnaOldCounterValue[2];
   DWORD                           lnCounterType;
   LONGLONG                        lnPerfFreq ;
   LONGLONG                        ObjPerfFreq ;
   LONGLONG                        ObjCounterTimeNew;
   LONGLONG                        ObjCounterTimeOld;
   }LINESTRUCT ;

typedef LINESTRUCT *PLINESTRUCT ;

FLOAT CounterEntry (PLINESTRUCT pLine);


class Entry : public CObject {
    public:
    int iObject;
    DWORD dwLastUsed;
};


//***************************************************************************
//
//  CLASS NAME:
//
//  CIndicyList
//
//  DESCRIPTION:
//
//  Implementation of the CIndicyList class.  This class keeps a list of the
//  object types that are to be retrieved.  Each object type also has a time
//  of last use so that object types that are no longer used will not be 
//  retrieved forever.  Some entries are part of the standard globals and 
//  are marked as permanent so that they will always be read.
//
//***************************************************************************

class CIndicyList : public CObject {
    
    public:
        BOOL SetUse(int iObj);
        BOOL bItemInList(int iObj);
        BOOL bAdd(int iObj, DWORD dwTime);
        void PruneOld(void);
        LPCTSTR pGetAll(void);
  //      BOOL bItemInList(int iObj);
        ~CIndicyList(){FreeAll();};
        CIndicyList & operator = ( CIndicyList & from);
        void FreeAll(void);
    private:
        TString sAll;
        CFlexArray Entries;
};

//***************************************************************************
//
//  CLASS NAME:
//
//  PerfBuff
//
//  DESCRIPTION:
//
//  Holds a chunk of data read from the registry's perf monitor data.
//
//***************************************************************************

class PerfBuff : public CObject {
    public:
        friend class PerfCache;
        DWORD Read(HKEY hKey, int iObj, BOOL bInitial);
        LPSTR Get(int iObj);
        void Free();
        ~PerfBuff(){Free();};
        PerfBuff();
        BOOL bOK(HKEY hKey, DWORD dwMaxAge, int iObj);
        PerfBuff & operator = ( PerfBuff & from);
        BOOL bEmpty(void){return !dwSize;};
 //       __int64 Time(void){return dwBuffLastRead;};
 //      __int64 Time2(void){return PerfTime;};
    private:
        DWORD dwSize;
        LPSTR pData;
        CIndicyList List;
        HKEY hKeyLastRead;
        DWORD dwBuffLastRead;           // GetCurrentTime of last read
        LONGLONG PerfTime;               // Time in last block
        LONGLONG PerfTime100nSec;               // Time in last block
        LONGLONG PerfFreq;
};


//***************************************************************************
//
//  CLASS NAME:
//
//  PerfCache
//
//  DESCRIPTION:
//
//  Implementation of the PerfCache class.  This is the object which is 
//  directly used by the perf provider class.  Each object keeps track of
//  several PerfBuff object.  There is a newest which is what was just read,
//  an oldest which has previously read data and an intermediate buffer which
//  has data that isnt quite old enough to be moved into the old buffer.  Note
//  that time average data requires having two samples which are separated by
//  a MIN_TIME_DIFF time difference.
//
//***************************************************************************

class PerfCache : public CObject {
    public:
        void FreeOldBuffers(void);
        DWORD dwGetNew(LPCTSTR pName, int iObj, LPSTR * pData,PLINESTRUCT pls);
        DWORD dwGetPair(LPCTSTR pName, int iObj, LPSTR * pOldData,
                            LPSTR * pNewData,PLINESTRUCT pls);
        PerfCache();
        ~PerfCache();
    private:
        PerfBuff Old,New;
        HKEY hHandle;
        TString sMachine;
        DWORD dwGetHandle(LPCTSTR pName);
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\winmgmt\stdprov\perfprov.h ===
/*++

Copyright (C) 1997-2001 Microsoft Corporation

Module Name:

    PERFPROV.H

Abstract:

	Defines the guids for performance monitor provider.

History:

	a-davj  04-Mar-97   Created.

--*/

#ifndef _PERFPROV_H_
#define _PERFPROV_H_

DEFINE_GUID(LIBID_PERFPROV,0xF00B4403L,0xF8F1,0x11CE,0xA5,0xB6,0x00,0xAA,0x00,0x68,0x0C,0x3F);

DEFINE_GUID(CLSID_PerfProvider,0xF00B4404L,0xF8F1,0x11CE,0xA5,0xB6,0x00,0xAA,0x00,0x68,0x0C,0x3F);

// {72967903-68EC-11d0-B729-00AA0062CBB7}
DEFINE_GUID(CLSID_PerfPropProv, 
0x72967903, 0x68ec, 0x11d0, 0xb7, 0x29, 0x0, 0xaa, 0x0, 0x62, 0xcb, 0xb7);

#ifdef __cplusplus
class PerfProvider;
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\winmgmt\stdprov\perfcach.cpp ===
/*++

Copyright (C) 1995-2001 Microsoft Corporation

Module Name:

    PERFCACH.CPP

Abstract:

	Containes some classes which are used to cache NT performance data.

History:

	a-davj  15-DEC-95   Created.

--*/

#include "precomp.h"
#include <wbemidl.h>
#include "perfcach.h"
#include <winperf.h>

//***************************************************************************
//
//  BOOL CIndicyList::SetUse  
//
//  DESCRIPTION:
//
//  Indicates that an object type has just been used.  If the object
//  is already on the list, then its last accessed time is updated.  New
//  object types are added to the list
//
//  PARAMETERS:
//
//  iObj                Number.  The acutally translates to the object number
//                      that perf monitor uses to identify objects.
//
//  RETURN VALUE:
//
//  always TRUE unless it was a new entry and there isnt enough memory
//  to add.
//***************************************************************************

BOOL CIndicyList::SetUse(
                        IN int iObj)
{
    int iNumEntries, iCnt;

    // Go Through list and determine if there is an entry
    
    Entry * pCurr;
    iNumEntries = Entries.Size();
    for(iCnt = 0; iCnt < iNumEntries; iCnt++) 
    {
        pCurr = (Entry *)Entries.GetAt(iCnt);
        if(iObj == pCurr->iObject)  // found it!
            break;
    }

    if(iCnt < iNumEntries) 
    {

        // Found the entry.  Set its last used to to the
        // present unless it is a permanent entry

        if(pCurr->dwLastUsed != PERMANENT)
            pCurr->dwLastUsed = GetCurrentTime();
        return TRUE;
    }
    else
        
        // Entry  not found, add to list
         
        return bAdd(iObj,GetCurrentTime());
}

//***************************************************************************
//
//  BOOL CIndicyList::bItemInList  
//
//  DESCRIPTION:
//
//  Checks if an item is in the list.
//
//  PARAMETERS:
//
//  iObj                Number.  The acutally translates to the object number
//                      that perf monitor uses to identify objects.
//
//  RETURN VALUE:
//
//  TRUE if the item is in the list
//  
//***************************************************************************

BOOL CIndicyList::bItemInList(
                        IN int iObj)
{
    int iNumEntries, iCnt;

    // Go Through list and determine if the entry is there
    
    Entry * pCurr;
    iNumEntries = Entries.Size();
    for(iCnt = 0; iCnt < iNumEntries; iCnt++) 
    {
        pCurr = (Entry *)Entries.GetAt(iCnt);
        if(iObj == pCurr->iObject)  // found it!
            return TRUE;
    }
    return FALSE;
}

//***************************************************************************
//
//  BOOL CIndicyList::bAdd  
//
//  DESCRIPTION:
//
//  Adds an object type to the list
//
//  PARAMETERS:
//
//  iObj                Number.  The acutally translates to the object number
//                      that perf monitor uses to identify objects.
//  dwTime              Current system time
//
//  RETURN VALUE:
//
//  Returns TRUE if OK.
//  
//***************************************************************************

BOOL CIndicyList::bAdd(
                        IN int iObj,
                        IN DWORD dwTime)
{
    Entry * pNew = new Entry;
    if(pNew == NULL)
        return FALSE;
    pNew->iObject = iObj;
    pNew->dwLastUsed = dwTime;
          
    int iRet = Entries.Add(pNew);
    if(iRet != CFlexArray::no_error)
    {
        delete pNew;
        return FALSE;
    }
    return TRUE;
}

//***************************************************************************
//
//  void CIndicyList::PruneOld  
//
//  DESCRIPTION:
//
//  Looks at the entries in the list and removes any that have
//  not been used in a long time.
//
//***************************************************************************

void CIndicyList::PruneOld(void)
{
    Entry * pCurr;
    int iNumEntries, iCnt;
    DWORD dwCurr = GetCurrentTime();
    iNumEntries = Entries.Size();
    for(iCnt = iNumEntries-1; iCnt >= 0; iCnt--) 
    {
        pCurr = (Entry *)Entries.GetAt(iCnt);
        if(pCurr->dwLastUsed != PERMANENT)
            if((dwCurr - pCurr->dwLastUsed) > MAX_UNUSED_KEEP) 
            {
                Entries.RemoveAt(iCnt);
                delete pCurr;
            }
    }
//    Entries.FreeExtra();
}

//***************************************************************************
//
//  LPCTSTR CIndicyList::pGetAll  
//
//  DESCRIPTION:
//
//  Returns a pointer to a string containing the numbers of all the objects
//  on the list.  For example, if the list had objects 2,4, and 8; then
//  the string "2 4 8" would be retrieved.  Null is returned if there
//  isnt enough memory.
//
//  RETURN VALUE:
//
//  see description
//
//***************************************************************************

LPCTSTR CIndicyList::pGetAll(void)
{
    int iNumEntries, iCnt;
    Entry * pCurr;
    
    // Go Through list and add each object number to the string
    
    sAll.Empty();
    iNumEntries = Entries.Size();
    for(iCnt = 0; iCnt < iNumEntries; iCnt++) 
    {
        TCHAR pTemp[20];
        pCurr = (Entry *)Entries.GetAt(iCnt);
        sAll += _itow(pCurr->iObject,pTemp,10);
        if(iCnt < iNumEntries-1)
            sAll += TEXT(" ");
    }
    return sAll;
}

//***************************************************************************
//
//  CIndicyList & CIndicyList::operator =   
//
//  DESCRIPTION:
//
//  Supports the assignment of one CIndicyList object to another
//
//  PARAMETERS:
//
//  from                Value to copy
//
//  RETURN VALUE:
//
//  reterence the "this" object  
//***************************************************************************

CIndicyList & CIndicyList::operator = (
                        CIndicyList & from)
{
    int iNumEntries, iCnt;
    Entry * pCurr;

    // Free existing list

    FreeAll();  
    
    iNumEntries = from.Entries.Size();
    for(iCnt = 0; iCnt < iNumEntries; iCnt++) 
    {
        pCurr = (Entry *)from.Entries.GetAt(iCnt);
        bAdd(pCurr->iObject, pCurr->dwLastUsed);
    }            
    return *this;
}

//***************************************************************************
//
//  void CIndicyList::FreeAll  
//
//  DESCRIPTION:
//
//  Purpose: Clears out the list and frees memory.
//
//***************************************************************************

void CIndicyList::FreeAll(void)
{
    int iNumEntries, iCnt;
    // Go Through list and determine if there is an entry
    
    Entry * pCurr;

    // delete each object in the list.

    iNumEntries = Entries.Size();
    for(iCnt = 0; iCnt < iNumEntries; iCnt++) 
    {
        pCurr = (Entry *)Entries.GetAt(iCnt);
        delete pCurr;
    }
    Entries.Empty();
}

//***************************************************************************
//
//  DWORD PerfBuff::Read  
//
//  DESCRIPTION:
//
//  Read the perf monitor data.
//
//  PARAMETERS:
//
//  hKey                Registry key for perf mon data
//  iObj                Number.  The acutally translates to the object number
//                      that perf monitor uses to identify objects.
//  bInitial            Set to TRUE for first call
//
//  RETURN VALUE:
//
//  0                   All is well
//  WBEM_E_OUT_OF_MEMORY
//
//***************************************************************************

DWORD PerfBuff::Read(
                        IN HKEY hKey,
                        IN int iObj,
                        IN BOOL bInitial)
{
    DWORD dwRet;
    LPCTSTR pRequest;
    // Make sure there is a data buffer

    if(dwSize == 0) 
    {
        pData = new char[INITIAL_ALLOCATION];
        if(pData == NULL)
            return WBEM_E_OUT_OF_MEMORY;
        dwSize = INITIAL_ALLOCATION;
    }
    hKeyLastRead = hKey; // record the key that was used
    
    // Make sure that the desired object is in the list of
    // objects to be retrieved.  Also set pRequest to the string that will
    // be passed to retrieve the perf counter block.  An initial read is done
    // in order to establish the list of permanent object types which are
    // always to be retrived and that includes the standard "global" types
    // such as memory, processor, disk, etc.

    if(!bInitial) 
    {
        if(!List.SetUse(iObj))
            return WBEM_E_OUT_OF_MEMORY;
        List.PruneOld();
        pRequest = List.pGetAll();
        if(pRequest == NULL)
            return WBEM_E_OUT_OF_MEMORY;
    }
    else
        pRequest = TEXT("Global");
    
    // Read the data.  Note that the read may be retried if the data
    // block needs to be expanded

    do 
    {
        DWORD dwTempSize, dwType;
        dwTempSize = dwSize;
try
{
        dwRet = RegQueryValueEx (hKey,pRequest,NULL,&dwType,
                                        (BYTE *)pData,&dwTempSize);
}
catch(...)
{
        delete pData;
        return WBEM_E_FAILED;
}
        if(dwRet == ERROR_MORE_DATA) 
        {
            delete pData;
            dwSize += 5000;
            pData = new char[dwSize];
            if(pData == NULL)
            {
                dwSize = 0; 
                return WBEM_E_OUT_OF_MEMORY;
            }
        }
    } while (dwRet == ERROR_MORE_DATA);
    
    // Set the age of the data

    if(dwRet == ERROR_SUCCESS) 
    {
        PERF_DATA_BLOCK * pBlock = (PERF_DATA_BLOCK *)pData; 
        PerfTime = *(LONGLONG UNALIGNED *)(&pBlock->PerfTime);
        PerfTime100nSec = *(LONGLONG UNALIGNED *)(&pBlock->PerfTime100nSec);
        PerfFreq = *(LONGLONG UNALIGNED *)(&pBlock->PerfFreq);
        dwBuffLastRead = GetCurrentTime();
    }
    else
        dwBuffLastRead = 0;

    // If this was an initial read of the default objects, add all the
    // default objects to the list as permanent entries

    if(bInitial && dwRet == ERROR_SUCCESS) 
    {
        int iIndex;
        PERF_DATA_BLOCK * pBlock = (PERF_DATA_BLOCK * )pData;
        PPERF_OBJECT_TYPE pObj;
            pObj = (PPERF_OBJECT_TYPE)((PBYTE)pBlock + pBlock->HeaderLength);
        for(iIndex = 0; iIndex < (int)pBlock->NumObjectTypes; iIndex++) 
        {
            //todo, check for errors on add.
            if(!List.bAdd((int)pObj->ObjectNameTitleIndex,PERMANENT))
                return WBEM_E_OUT_OF_MEMORY;

            pObj = (PPERF_OBJECT_TYPE)((PBYTE)pObj + pObj->TotalByteLength);
        }
    }

    return dwRet;
}

//***************************************************************************
//
//  LPSTR PerfBuff::Get  
//
//  DESCRIPTION:
//
//  Returns a pointer to the data and also indicates that the particular type
//  was just used.
//
//  PARAMETERS:
//
//  iObj                Number.  The acutally translates to the object number
//                      that perf monitor uses to identify objects.
//
//  RETURN VALUE:
//
//  see description.
//***************************************************************************

LPSTR PerfBuff::Get(
                        int iObj)
{
    List.SetUse(iObj);
    return pData;
}

//***************************************************************************
//
//  void PerfBuff::Free  
//
//  DESCRIPTION:
//
//  Frees up the memory
//
//***************************************************************************

void PerfBuff::Free()
{
    if(pData)
        delete pData;
    pData = NULL;
    dwSize = 0;
    hKeyLastRead = NULL;
    dwBuffLastRead = 0;
    List.FreeAll();
}

//***************************************************************************
//
//  PerfBuff::PerfBuff  
//
//  DESCRIPTION:
//
//  Constructor.
//
//***************************************************************************

PerfBuff::PerfBuff()
{
    dwSize = 0;
    pData = NULL;
    hKeyLastRead = NULL;
    dwBuffLastRead = 0;
}

//***************************************************************************
//
//  BOOL PerfBuff::bOK  
//
//  DESCRIPTION:
//
//  Returns TRUE, if and only if the same registry key was used to read
//  the data, the data isnt too old, and the particular object type is
//  in the data block.
//
//  PARAMETERS:
//
//  hKey                Registry key for reading data
//  dwMaxAge            Maximum acceptable age
//  iObj                Number.  The acutally translates to the object number
//                      that perf monitor uses to identify objects.
//
//  RETURN VALUE:
//
//  see desription
//***************************************************************************

BOOL PerfBuff::bOK(
                        IN HKEY hKey,
                        IN DWORD dwMaxAge,
                        IN int iObj)
{
    if(dwSize ==0)
        return FALSE;
    if(hKey != hKeyLastRead)
        return FALSE;
    if((GetCurrentTime() - dwBuffLastRead) > dwMaxAge)
        return FALSE;
    return List.bItemInList(iObj);
}

//***************************************************************************
//
//  PerfBuff & PerfBuff::operator =   
//
//  DESCRIPTION:
//
//  Allows assignment.
//
//  PARAMETERS:
//
//  from                Assignment source
//
//  RETURN VALUE:
//
//  reference to "this" object.
//***************************************************************************

PerfBuff & PerfBuff::operator = (
                        IN PerfBuff & from)
{
    // if the objects have different buffer sizes, free up the destinations
    // buffer and reallocate on of the same size as the source.

    if(from.dwSize != dwSize) 
    {
        Free();
        pData = new char[from.dwSize];
        if(pData == NULL) 
        {

            // failure in assignment isnt too serious since the buffer
            // will just return null when asked for the data.

            dwSize = 0;
            dwBuffLastRead = 0;
            return *this;
        }
        dwSize = from.dwSize;
    }

    // Copy the list of objects and times etc.

    memcpy(pData,from.pData,dwSize);
    List = from.List;
    hKeyLastRead = from.hKeyLastRead;
    dwBuffLastRead = from.dwBuffLastRead;
    PerfTime = from.PerfTime;
    PerfTime100nSec = from.PerfTime100nSec;
    PerfFreq = from.PerfFreq;
    return *this;
}

//***************************************************************************
//
//  void PerfCache::FreeOldBuffers  
//
//  DESCRIPTION:
//
//  Called by the house keeping thread to free up any buffers tool old to
//  be of any use.
//
//***************************************************************************

void PerfCache::FreeOldBuffers(void)
{
    if(Old.dwSize != 0 && 
        (GetCurrentTime() - Old.dwBuffLastRead) > MAX_OLD_AGE)
        Old.Free();
    if(New.dwSize != 0 && 
        (GetCurrentTime() - New.dwBuffLastRead) > MAX_OLD_AGE)
        New.Free();
}

//***************************************************************************
//
//  DWORD PerfCache::dwGetNew  
//
//  DESCRIPTION:
//
//  Sets a pointer to the most recently read data and will actually do a read
//  if the data in the new buffer isnt fresh enough.  The PLINESTRUCT data is
//  also set.
//
//  PARAMETERS:
//
//  pName               Machine name
//  iObj                Number.  The acutally translates to the object number
//                      that perf monitor uses to identify objects.
//  pData               Set to the object name
//  pls                 Set to info used to do calculations.
//
//  RETURN VALUE:
//
//  0                   all is well
//  WBEM_E_OUT_OF_MEMORY
//  otherwise error from dwGetHandle, or Read.
//***************************************************************************

DWORD PerfCache::dwGetNew(
                        IN LPCTSTR pName,
                        IN int iObj,
                        OUT IN LPSTR * pData,
                        OUT IN PLINESTRUCT pls)
{
    DWORD dwRet;

    // Get the handle

    dwRet = dwGetHandle(pName);
    if(hHandle == NULL || dwRet != 0) 
        return dwRet; 


    // If the new data is acceptable, then use it

    if(New.bOK(hHandle,MAX_NEW_AGE, iObj)) 
    {
//        OutputDebugString(TEXT("\r\nCurrent New is OK"));
    }
    else 
    {
        // If the new data has the correct type, AND either the old data
        // is junk, or the new data has aged enough to be old, copy the
        // new into the old.

        if(New.bOK(hHandle,MAX_OLD_AGE, iObj) &&
           (!Old.bOK(hHandle,MAX_OLD_AGE, iObj) || 
            (GetCurrentTime() - New.dwBuffLastRead >= MIN_TIME_DIFF)))
            {
//            OutputDebugString("\r\nMoving New into Old in dwGetNew");
            Old = New;
            if(Old.dwSize == 0)     // could happen in low memory
                return WBEM_E_OUT_OF_MEMORY;
        }
    
        // Read the latest data.  
        
        dwRet = New.Read(hHandle, iObj, FALSE);
//        OutputDebugString(TEXT("\r\nRead in New"));
        if(dwRet != ERROR_SUCCESS) 
            return dwRet;
    }        
    *pData = New.Get(iObj);
    pls->lnNewTime = New.PerfTime;
    pls->lnNewTime100Ns = New.PerfTime100nSec;
    pls->lnPerfFreq = New.PerfFreq;
    return ERROR_SUCCESS;
    
}
            
//***************************************************************************
//
//  DWORD PerfCache::dwGetPair  
//
//  DESCRIPTION:
//
//  Sets a pointer to the most recently read data and to the old data so that
//  time averaging can be done.  This routine will ensure that the time 
//  difference between the old and new is sufficient.  The dwGetNew
//  routine should always be called first.  The PLINESTRUCT data is
//  also set.
//
//  PARAMETERS:
//
//  pName               Object Name
//  iObj                Number.  The acutally translates to the object number
//                      that perf monitor uses to identify objects.
//
//  pOldData            Older data sample
//  pNewData            Newer data sample
//  pls                 line struct data with things like frequency, age etc.
//
//  RETURN VALUE:
//
//  0 if OK, otherwise retuns an error code.
//  
//***************************************************************************

DWORD PerfCache::dwGetPair(
                        IN LPCTSTR pName,
                        IN int iObj,
                        OUT IN LPSTR * pOldData,
                        OUT IN LPSTR * pNewData,
                        OUT IN PLINESTRUCT pls)
{
    DWORD dwRet;
    BOOL bOldOK;

    // Check to see if the old buffer is OK.

    bOldOK = Old.bOK(hHandle,MAX_OLD_AGE, iObj);

    // If both buffers are ok, then we are done

    if(bOldOK) 
    {
        *pOldData = Old.Get(iObj);
        pls->lnOldTime = Old.PerfTime;
        pls->lnOldTime100Ns = Old.PerfTime100nSec;
//        OutputDebugString(TEXT("\r\nOld is OK"));
        return ERROR_SUCCESS;
    }


    // Since the new buffer has already been read, use it as the old buffer

    Old = New;
    if(Old.dwSize == 0)     // could happen in low memory
        return WBEM_E_OUT_OF_MEMORY;
//    OutputDebugString(TEXT("\r\nCopying New into Old in dwGetPair"));

    // Possibly delay long enough so that there is a decent interval

    DWORD dwAge = GetCurrentTime() - Old.dwBuffLastRead;
    if(dwAge < MIN_TIME_DIFF) 
    {
        DWORD dwSleep = MIN_TIME_DIFF - dwAge;
        Sleep(dwSleep);
    } 

    // Read in the new buffer

    dwRet = New.Read(hHandle, iObj, FALSE);
//    OutputDebugString(TEXT("\r\ndoing raw read of new after delay"));
    if(dwRet != ERROR_SUCCESS) 
        return dwRet;
 
    *pNewData = New.Get(iObj);
    *pOldData = Old.Get(iObj);
    pls->lnOldTime = Old.PerfTime;
    pls->lnOldTime100Ns = Old.PerfTime100nSec;

    pls->lnNewTime = New.PerfTime;
    pls->lnNewTime100Ns = New.PerfTime100nSec;
    pls->lnPerfFreq = New.PerfFreq;
    return ERROR_SUCCESS;
}

//***************************************************************************
//
//  PerfCache::PerfCache  
//
//  DESCRIPTION:
//
//  Constructor.
//
//***************************************************************************

PerfCache::PerfCache()
{
    // Read in the standard counters.  This builds a list containing
    // those standards as well as providing immediate data for any 
    // request to come in the near future.
    
    hHandle = HKEY_PERFORMANCE_DATA;
  ///  New.Read(hHandle, 0, TRUE);
}

//***************************************************************************
//
//  PerfCache::~PerfCache  
//
//  DESCRIPTION:
//
//  Destructor.
//
//***************************************************************************

PerfCache::~PerfCache()
{
    // If the handle is to a remote machine, close it.

    if(hHandle != NULL && hHandle != HKEY_PERFORMANCE_DATA)
        RegCloseKey(hHandle);
}

//***************************************************************************
//
//  DWORD PerfCache::dwGetHandle  
//
//  DESCRIPTION:
//
//  Makes sure that hHandle is set correctly.
//
//  PARAMETERS:
//
//  pMachine            Machine name.
//
//  RETURN VALUE:
//
//  0                   all is well
//  WBEM_E_OUT_OF_MEMORY
//  WBEM_E_INVALID_PARAMETER  bad argument
//  otherwise error from RegConnectRegistry
//
//***************************************************************************

DWORD PerfCache::dwGetHandle(
                        LPCTSTR pMachine)
{
    DWORD dwRet;

    // if the machines are the same, the just use the existing handle

    if(pMachine == NULL)
        return WBEM_E_INVALID_PARAMETER;   // bad mapping string

    if(!lstrcmpi(sMachine,pMachine) && hHandle != NULL)
        return 0;           // already got it!

    // handle is needed for machine other that the local.  Start
    // by freeing the existing handle if it too is non local

    if(hHandle != NULL && hHandle != HKEY_PERFORMANCE_DATA)
        RegCloseKey(hHandle);

    // save the machine name so that we dont reopen this

    sMachine = pMachine;
    
    if(lstrcmpi(pMachine,TEXT("local"))) 
    {

        LPTSTR pTemp = NULL;    
        int iLen = sMachine.Length() +1;

        dwRet = RegConnectRegistry(sMachine,HKEY_PERFORMANCE_DATA,
                    &hHandle);

        if(dwRet != ERROR_SUCCESS) 
        { // could not remote connect
            hHandle = NULL;
            sMachine.Empty();
        }
    }
    else 
    {              // local machine, use standard handle.
        sMachine = TEXT("Local");
        hHandle = HKEY_PERFORMANCE_DATA;
        dwRet = 0;
    }
    return dwRet;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\winmgmt\stdprov\ntcnfg.h ===
/*++

Copyright (C) 1997-2001 Microsoft Corporation

Module Name:

    NTCONFIG.H

Abstract:

    This module contains the definitions associated with the conventions
    used to access the configuration registry.

History:

	a--davj  04-Mar-97   Created.

--*/

#include <winnt.h>

#ifndef _NTCONFIG_
#define _NTCONFIG_


typedef enum _CM_RESOURCE_TYPE {
    CmResourceTypeNull = 0,    // Reserved
    CmResourceTypePort,
    CmResourceTypeInterrupt,
    CmResourceTypeMemory,
    CmResourceTypeDma,
    CmResourceTypeDeviceSpecific
} CM_RESOURCE_TYPE;

/*
typedef union _LARGE_INTEGER {
    struct {
        ULONG LowPart;
        LONG HighPart;
    };
    LONGLONG QuadPart;
} LARGE_INTEGER, *PLARGE_INTEGER;
*/

typedef LARGE_INTEGER PHYSICAL_ADDRESS;


typedef enum Interface_Type {
    Internal,
    Isa,
    Eisa,
    MicroChannel,
    TurboChannel,
    PCIBus,
    VMEBus,
    NuBus,
    PCMCIABus,
    CBus,
    MPIBus,
    MPSABus,
    MaximumInterfaceType
}INTERFACE_TYPE;


#define REG_RESOURCE_LIST            ( 8 )   // Resource list in the resource map
#define REG_FULL_RESOURCE_DESCRIPTOR ( 9 )  // Resource list in the hardware description

//
// Make sure alignment is made properly by compiler; otherwise move
// flags back to the top of the structure (common to all members of the
// union).
//

#pragma pack(4)
typedef struct _CM_PARTIAL_RESOURCE_DESCRIPTOR {
    UCHAR Type;
    UCHAR ShareDisposition;
    USHORT Flags;
    union {

        //
        // Range of port numbers, inclusive. These are physical, bus
        // relative. The value should be the same as the one passed to
        // HalTranslateBusAddress().
        //

        struct {
            PHYSICAL_ADDRESS Start;
            ULONG Length;
        } Port;

        //
        // IRQL and vector. Should be same values as were passed to
        // HalGetInterruptVector().
        //

        struct {
            ULONG Level;
            ULONG Vector;
            ULONG Affinity;
        } Interrupt;

        //
        // Range of memory addresses, inclusive. These are physical, bus
        // relative. The value should be the same as the one passed to
        // HalTranslateBusAddress().
        //

        struct {
            PHYSICAL_ADDRESS Start;    // 64 bit physical addresses.
            ULONG Length;
        } Memory;

        //
        // Physical DMA channel.
        //

        struct {
            ULONG Channel;
            ULONG Port;
            ULONG Reserved1;
        } Dma;

        //
        // Device Specific information defined by the driver.
        // The DataSize field indicates the size of the data in bytes. The
        // data is located immediately after the DeviceSpecificData field in
        // the structure.
        //

        struct {
            ULONG DataSize;
            ULONG Reserved1;
            ULONG Reserved2;
        } DeviceSpecificData;
    } u;
} CM_PARTIAL_RESOURCE_DESCRIPTOR, *PCM_PARTIAL_RESOURCE_DESCRIPTOR;
#pragma pack()

//
// A Partial Resource List is what can be found in the ARC firmware
// or will be generated by ntdetect.com.
// The configuration manager will transform this structure into a Full
// resource descriptor when it is about to store it in the regsitry.
//
// Note: There must a be a convention to the order of fields of same type,
// (defined on a device by device basis) so that the fields can make sense
// to a driver (i.e. when multiple memory ranges are necessary).
//

typedef struct _CM_PARTIAL_RESOURCE_LIST {
    USHORT Version;
    USHORT Revision;
    ULONG Count;
    CM_PARTIAL_RESOURCE_DESCRIPTOR PartialDescriptors[1];
} CM_PARTIAL_RESOURCE_LIST, *PCM_PARTIAL_RESOURCE_LIST;

//
// A Full Resource Descriptor is what can be found in the registry.
// This is what will be returned to a driver when it queries the registry
// to get device information; it will be stored under a key in the hardware
// description tree.
//
// Note: The BusNumber and Type are redundant information, but we will keep
// it since it allows the driver _not_ to append it when it is creating
// a resource list which could possibly span multiple buses.
//
// Note2: There must a be a convention to the order of fields of same type,
// (defined on a device by device basis) so that the fields can make sense
// to a driver (i.e. when multiple memory ranges are necessary).
//

typedef struct _CM_FULL_RESOURCE_DESCRIPTOR {
    INTERFACE_TYPE InterfaceType;
    ULONG BusNumber;
    CM_PARTIAL_RESOURCE_LIST PartialResourceList;
} CM_FULL_RESOURCE_DESCRIPTOR, *PCM_FULL_RESOURCE_DESCRIPTOR;

//
// The Resource list is what will be stored by the drivers into the
// resource map via the IO API.
//

typedef struct _CM_RESOURCE_LIST {
    ULONG Count;
    CM_FULL_RESOURCE_DESCRIPTOR List[1];
} CM_RESOURCE_LIST, *PCM_RESOURCE_LIST;

#endif // _NTCONFIG_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\winmgmt\stdprov\precomp.h ===
/*++

Copyright (C) 1997-2001 Microsoft Corporation

Module Name:

    PRECOMP.H

Abstract:

	include file for standard system include files,
	or project specific include files that are used frequently, but
	are changed infrequently

History:

	a--davj  04-Mar-97   Created.

--*/

#pragma warning (disable : 4786)
#pragma warning( disable : 4251 )
#include <ole2.h>
#include <windows.h>

#include <comdef.h>

#include <strsafe.h>

#include <helper.h>
#include <autoptr.h>

#define COREPROX_POLARITY __declspec( dllimport )
#define ESSLIB_POLARITY __declspec( dllimport )

#include <wbemidl.h>
#include <stdio.h>
#include <wbemcomn.h>
#include "tstring.h"
class CObject
{
public:
    virtual ~CObject(){}

};

#include "stdprov.h"

#undef PURE
#define PURE {return (unsigned long)E_NOTIMPL;}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\winmgmt\stdprov\provperf.cpp ===
/*++

Copyright (C) 1995-2001 Microsoft Corporation

Module Name:

    PROVPERF.CPP

Abstract:

	Defines the acutal "Put" and "Get" functions for the
	performance counter provider.  The format of the mapping
	string is;
			  machine|Object|counter[|instance]
	Examples;
			  local|memory|available bytes
			  a-davj2|LogicalDisk|Free Megabytes|C:

History:

	a-davj  9-27-95    Created.

--*/

#include "precomp.h"
#include "provperf.h"
#include "cvariant.h"


// maximum amount of time to wait for exclusive access

#define MAX_EXEC_WAIT 5000


//***************************************************************************
//
//  AddTesterDetails
//
//  DESCRIPTION:
//
//  This function is used add the counter type to the property and is useful
//  to wbem testers.  Normal users dont want the overhead caused by this.
//
//  PARAMETERS:
//
//  pClassInt           Object being refreshed
//  PropName            Property Name
//  dwCtrType           counter type
//
//  RETURN VALUE:
//
//  always 0
//
//***************************************************************************

void AddTesterDetails(IWbemClassObject FAR * pClassInt,BSTR PropName,DWORD dwCtrType)
{
    // Get the qualifier pointer for the property

    IWbemQualifierSet * pQualifier = NULL;

    // Get an Qualifier set interface.

    SCODE sc = pClassInt->GetPropertyQualifierSet(PropName,&pQualifier); // Get prop attribute
    if(FAILED(sc))
        return;

    WCHAR wcName[40];

    switch(dwCtrType)
    {
        case PERF_COUNTER_COUNTER:
            wcsncpy(wcName,L"PERF_COUNTER_COUNTER", 39);
            break;

        case PERF_COUNTER_TIMER:
            wcsncpy(wcName,L"PERF_COUNTER_TIMER", 39);
            break;

        case PERF_COUNTER_QUEUELEN_TYPE:
            wcsncpy(wcName,L"PERF_COUNTER_QUEUELEN_TYPE", 39);
            break;

        case PERF_COUNTER_LARGE_QUEUELEN_TYPE:
            wcsncpy(wcName,L"PERF_COUNTER_LARGE_QUEUELEN_TYPE", 39);
            break;

        case PERF_COUNTER_BULK_COUNT:
            wcsncpy(wcName,L"PERF_COUNTER_BULK_COUNT", 39);
            break;

        case PERF_COUNTER_TEXT:
            wcsncpy(wcName,L"PERF_COUNTER_TEXT", 39);
            break;

        case PERF_COUNTER_RAWCOUNT:
            wcsncpy(wcName,L"PERF_COUNTER_RAWCOUNT", 39);
            break;

        case PERF_COUNTER_LARGE_RAWCOUNT:
            wcsncpy(wcName,L"PERF_COUNTER_LARGE_RAWCOUNT", 39);
            break;

        case PERF_COUNTER_RAWCOUNT_HEX:
            wcsncpy(wcName,L"PERF_COUNTER_RAWCOUNT_HEX", 39);
            break;

        case PERF_COUNTER_LARGE_RAWCOUNT_HEX:
            wcsncpy(wcName,L"PERF_COUNTER_LARGE_RAWCOUNT_HEX", 39);
            break;

        case PERF_SAMPLE_FRACTION:
            wcsncpy(wcName,L"PERF_SAMPLE_FRACTION", 39);
            break;

        case PERF_SAMPLE_COUNTER:
            wcsncpy(wcName,L"PERF_SAMPLE_COUNTER", 39);
            break;

        case PERF_COUNTER_NODATA:
            wcsncpy(wcName,L"PERF_COUNTER_NODATA", 39);
            break;

        case PERF_COUNTER_TIMER_INV:
            wcsncpy(wcName,L"PERF_COUNTER_TIMER_INV", 39);
            break;

        case PERF_SAMPLE_BASE:
            wcsncpy(wcName,L"PERF_SAMPLE_BASE", 39);
            break;

        case PERF_AVERAGE_TIMER:
            wcsncpy(wcName,L"PERF_AVERAGE_TIMER", 39);
            break;

        case PERF_AVERAGE_BASE:
            wcsncpy(wcName,L"PERF_AVERAGE_BASE", 39);
            break;

        case PERF_AVERAGE_BULK:
            wcsncpy(wcName,L"PERF_AVERAGE_BULK", 39);
            break;

        case PERF_100NSEC_TIMER:
            wcsncpy(wcName,L"PERF_100NSEC_TIMER", 39);
            break;

        case PERF_100NSEC_TIMER_INV:
            wcsncpy(wcName,L"PERF_100NSEC_TIMER_INV", 39);
            break;

        case PERF_COUNTER_MULTI_TIMER:
            wcsncpy(wcName,L"PERF_COUNTER_MULTI_TIMER", 39);
            break;

        case PERF_COUNTER_MULTI_TIMER_INV:
            wcsncpy(wcName,L"PERF_COUNTER_MULTI_TIMER_INV", 39);
            break;

        case PERF_COUNTER_MULTI_BASE:
            wcsncpy(wcName,L"PERF_COUNTER_MULTI_BASE", 39);
            break;

        case PERF_100NSEC_MULTI_TIMER:
            wcsncpy(wcName,L"PERF_100NSEC_MULTI_TIMER", 39);
            break;

        case PERF_100NSEC_MULTI_TIMER_INV:
            wcsncpy(wcName,L"PERF_100NSEC_MULTI_TIMER_INV", 39);
            break;

        case PERF_RAW_FRACTION:
            wcsncpy(wcName,L"PERF_RAW_FRACTION", 39);
            break;

        case PERF_RAW_BASE:
            wcsncpy(wcName,L"PERF_RAW_BASE", 39);
            break;

        case PERF_ELAPSED_TIME:
            wcsncpy(wcName,L"PERF_ELAPSED_TIME", 39);
            break;

        case PERF_COUNTER_HISTOGRAM_TYPE:
            wcsncpy(wcName,L"PERF_COUNTER_HISTOGRAM_TYPE", 39);
            break;

        case PERF_COUNTER_DELTA:
            wcsncpy(wcName,L"PERF_COUNTER_DELTA", 39);
            break;

        case PERF_COUNTER_LARGE_DELTA:
            wcsncpy(wcName,L"PERF_COUNTER_LARGE_DELTA", 39);
            break;

        default:
            StringCchPrintfW(wcName, sizeof(wcName)/sizeof(WCHAR), L"0x%x", dwCtrType);
    }
    wcName[39] = 0;
    CVariant var(wcName);
    
    BSTR bstr = SysAllocString(L"CounterType");
    if(bstr)
    {
        sc = pQualifier->Put(bstr, var.GetVarPtr(), 0);
        SysFreeString(bstr);
    }
    pQualifier->Release();

}


//***************************************************************************
//
//  CImpPerf::CImpPerf
//
//  DESCRIPTION:
//
//  Constuctor.
//
//  PARAMETERS:
//
//***************************************************************************

CImpPerf::CImpPerf()
{
    StringCchCopyW(wcCLSID, sizeof(wcCLSID)/sizeof(WCHAR), L"{F00B4404-F8F1-11CE-A5B6-00AA00680C3F}");
    sMachine = TEXT("local");
    hKeyMachine = HKEY_LOCAL_MACHINE;
    dwLastTimeUsed = 0;
    hKeyPerf =    HKEY_PERFORMANCE_DATA;
    m_TitleBuffer = NULL;
    m_Size = 0;
    m_pCounter = NULL;    
    hExec = CreateMutex(NULL, false, NULL);
    m_hTermEvent = CreateEvent(NULL,TRUE,FALSE,NULL);
    return;
}

//***************************************************************************
//
//  CImpPerf::~CImpPerf
//
//  DESCRIPTION:
//
//  Destructor.
//
//***************************************************************************

CImpPerf::~CImpPerf()
{
    bool bGotMutex = false;
    if(hExec)
    {
        DWORD dwRet = WaitForSingleObject(hExec,2*MAX_EXEC_WAIT);  
        if(dwRet == WAIT_OBJECT_0 || dwRet == WAIT_ABANDONED)
            bGotMutex = true;
    }
    if(bGotMutex)
        ReleaseMutex(hExec);
    FreeStuff();
    sMachine.Empty();
    if(hExec)
        CloseHandle(hExec);
    if(m_hTermEvent)
        CloseHandle(m_hTermEvent);
}

//***************************************************************************
//
//  SCODE CImpPerf::LoadData
//
//  DESCRIPTION:
//
//  Loads up the perf monitor data.
//
//  PARAMETERS:
//
//  ProvObj             Object containing the property context string.
//  pls                 Where to put the data
//  piObject            Identifies the perf mon object
//  piCounter           Identifies the perf mon counter
//  **ppNew             Created data block
//  bJustGettingInstances Flag which indicates that we are actully
//                      looking for the instance names.
//
//  RETURN VALUE:
//
//  WBEM_E_INVALID_PARAMETER     Bad  context string
//  WBEM_E_OUT_OF_MEMORY         low memory
//  otherwise error from called function
//
//***************************************************************************

SCODE CImpPerf::LoadData(
                        CProvObj & ProvObj,
                        LINESTRUCT * pls,
                        int * piObject, 
                        int * piCounter,
                        PERF_DATA_BLOCK **ppNew,
                        BOOL bJustGettingInstances)
{
    SCODE sc;
    BOOL bChange;
    if( ( ProvObj.sGetToken(0) == NULL ) || ( piObject == NULL ) || ( piCounter == NULL ) ) 
        return WBEM_E_INVALID_PARAMETER;  //BAD MAPPING STRING
 
    // Determine if there has been a change in the machine being
    // accessed.  Save the current machine and get the handles if
    // there was a change.

    bChange = lstrcmpi(sMachine,ProvObj.sGetToken(0));
    sMachine = ProvObj.sGetToken(0);

    if(bChange)
    {
        sc = dwGetRegHandles(ProvObj.sGetToken(0));
        if(sc != S_OK)
            return sc;
    }

    // build up a table of the performance strings and
    // their corresponding indexes.  This only needs to be done
    // when the buffer is empty or when the machine changes.  

    if(bChange || (m_TitleBuffer == NULL && m_pCounter == NULL)) 
    {
        sc = GetPerfTitleSz ();
        if(sc != S_OK) 
            return sc;
    }

    // get the indexs for the object and counter names

    dwLastTimeUsed = GetCurrentTime();
    *piObject = iGetTitleIndex(ProvObj.sGetToken(1), FALSE);
    if(bJustGettingInstances)
        *piCounter = 0;
    else    
        *piCounter = iGetTitleIndex(ProvObj.sGetToken(2), TRUE);
    if(*piObject == -1 || *piCounter == -1) 
    {
        return WBEM_E_INVALID_PARAMETER;  // bad mapping string
    }

    // Using the index for the object, get the perf counter data
    // data.

    sc = Cache.dwGetNew(ProvObj.sGetToken(0),*piObject,(LPSTR *)ppNew,pls);
    return sc;
} 

//***************************************************************************
//
//  SCODE CImpPerf::RefreshProperty
//
//  DESCRIPTION:
//
//  Gets the value of a single property from the NT performance
//  counter data.
//
//  PARAMETERS:
//
//  lFlags              flags.  Not currently used
//  pClassInt           Instance object
//  PropName            Property name
//  ProvObj             Object containing the property context string.
//  pPackage            Caching object
//  pVar                Points to value to set
//  bTesterDetails      Provide extra info for testers
//  RETURN VALUE:
//
//  S_OK                all is well
//  else probably set by LoadData or FindData.
//
//***************************************************************************

SCODE CImpPerf::RefreshProperty(
                        IN long lFlags,
                        IN IWbemClassObject FAR * pClassInt,
                        IN BSTR PropName,
                        IN CProvObj & ProvObj,
                        OUT IN CObject * pPackage,
                        OUT CVariant * pVar, BOOL bTesterDetails)
{
    DWORD dwCtrType;
    float fRet;
    SCODE sc;
    int iObject,iCounter;
    PERF_DATA_BLOCK *  pNew, * pOld;
    DWORD dwSize;
    LINESTRUCT ls;
    void * pCountData, *pIgnore;
    CVariant vPerf;

    //  The perf counter provider keeps some rather expensive data and 
    //  so it doesnt support complete reentrancy. 

    if(hExec) 
    {
        DWORD dwRet;
        dwRet = WaitForSingleObject(hExec,MAX_EXEC_WAIT);  
        if(dwRet != WAIT_ABANDONED && dwRet != WAIT_OBJECT_0)
            return WBEM_E_FAILED; 
    }
    else
        return WBEM_E_FAILED;

    // Load up the data

    sc = LoadData(ProvObj,&ls,&iObject,&iCounter,&pNew,FALSE);
    if(sc != S_OK)
        goto Done;

    // Find the desired data.
    
    sc = FindData(pNew,iObject,iCounter,ProvObj,&dwSize,&pCountData,
            &ls,TRUE,NULL); // find data sets the error in pMo!
    if(sc != S_OK) 
        goto Done;

    // determine what type of counter it is

    dwCtrType = ls.lnCounterType & 0xc00;

    if(dwCtrType == PERF_TYPE_COUNTER) 
    {
        
        // This type of counter requires time average data.  Get the cache to
        // get two buffers which are separated by a minimum amount of time

        sc = Cache.dwGetPair(ProvObj.sGetToken(0),iObject,
                                    (LPSTR *)&pOld,(LPSTR *)&pNew,&ls);
        if(sc != S_OK) 
            goto Done;
        sc = FindData(pNew,iObject,iCounter,ProvObj,&dwSize,&pCountData,&ls,TRUE,NULL);
        if(sc != S_OK) 
            goto Done;
        sc = FindData(pOld,iObject,iCounter,ProvObj,&dwSize,&pIgnore,&ls,FALSE,NULL);
        if(sc != S_OK) 
            goto Done;
        fRet = CounterEntry(&ls);
        vPerf.SetData(&fRet,VT_R4);
    
    }
    else if(dwCtrType == PERF_TYPE_NUMBER) 
    {
        
        // Simple counter. 

        fRet = CounterEntry(&ls);
        vPerf.SetData(&fRet,VT_R4);
    }
    else if(dwCtrType == PERF_TYPE_TEXT) 
    {
        
        // Text.  Allocate enough space to hold the text and
        // copy the text into temp WCHAR buffer since it is not
        // clear from the documentation if the data in the block
        // is null terminated.        
        
        WCHAR * pNew = (WCHAR *)CoTaskMemAlloc(dwSize+2);
        if(pNew == NULL) 
        {
            sc = WBEM_E_OUT_OF_MEMORY;
            goto Done;
        }
        memset(pNew,0,dwSize+2);
        if(ls.lnCounterType & 0x10000)
            mbstowcs(pNew,(char *)pCountData,dwSize);
        else
            memcpy(pNew,pCountData,dwSize);

        VARIANT * pVar = vPerf.GetVarPtr();
        VariantClear(pVar);
        pVar->vt = VT_BSTR;
        pVar->bstrVal = SysAllocString(pNew);
        if(pVar->bstrVal == NULL)
            sc = WBEM_E_OUT_OF_MEMORY;
        CoTaskMemFree(pNew);
        if(sc != S_OK) 
        {
            goto Done;
        }
    }
        
    // Convert the data into the desired form
    sc = vPerf.DoPut(lFlags,pClassInt,PropName,pVar);

    if(bTesterDetails)
        AddTesterDetails(pClassInt, PropName, dwCtrType);

Done:
    if(hExec)
        ReleaseMutex(hExec);
    return sc;
}

//***************************************************************************
//
//  SCODE CImpPerf::UpdateProperty
//
//  DESCRIPTION:
//
//  Normally this routine is used to save properties, but NT 
//  performance counter data is Read only.
//
//  PARAMETERS:
//
//  lFlags              N/A
//  pClassInt           N/A
//  PropName            N/A
//  ProvObj             N/A
//  pPackage            N/A
//  pVar                N/A
//
//  RETURN VALUE:
//
//  E_NOTIMPL
//
//***************************************************************************

SCODE CImpPerf::UpdateProperty(
                        long lFlags,
                        IWbemClassObject FAR * pClassInt,
                        BSTR PropName,
                        CProvObj & ProvObj,
                        CObject * pPackage,
                        CVariant * pVar)
{
    return E_NOTIMPL;
}

//***************************************************************************
//
//  void CImpPerf::FreeStuff
//
//  DESCRIPTION:
//
//  Used to free up memory that is no longer needed as well as
//  freeing up registry handles.
//
//***************************************************************************

void CImpPerf::FreeStuff(void)
{
    if(hKeyMachine != HKEY_LOCAL_MACHINE)
    {
        RegCloseKey(hKeyMachine);
        hKeyMachine = NULL;
    }
    if(hKeyPerf != HKEY_PERFORMANCE_DATA)
    {
        RegCloseKey(hKeyPerf);
        hKeyPerf = NULL;
    }

    if(m_TitleBuffer)
    {
        delete [] m_TitleBuffer;
        m_TitleBuffer = NULL;
    }
    if (m_pCounter)
    {
        delete [] m_pCounter;
        m_pCounter = NULL;
    }
    m_Size = 0;
    
    m_IndexCache.Empty();

    return;
}

//***************************************************************************
//
//  DWORD   CImpPerf::GetPerfTitleSz 
//
//  DESCRIPTION:
//
//  Retrieves the performance data title strings.
//  This call retrieves english version of the title strings.
//
//  RETURN VALUE:
//
//  0                   if OK
//  WBEM_E_OUT_OF_MEMORY if low memory
//  else set by RegOpenKeyEx
//
//***************************************************************************

DWORD   CImpPerf::GetPerfTitleSz ()
{
    HKEY    hKey1;
    DWORD   Type;
    DWORD   dwR;

    // Free any existing stuff

    if(m_TitleBuffer)
    {
        delete [] m_TitleBuffer;
        m_TitleBuffer = NULL;
    }
    if (m_pCounter)
    {
        delete [] m_pCounter;
        m_pCounter = NULL;
    }
    m_Size = 0;    
    m_IndexCache.Empty();

    DWORD   DataSize = 65536;
    DWORD nChars = DataSize/sizeof(WCHAR);    

    wmilib::auto_buffer<WCHAR> pTitleBuffer( new WCHAR[nChars]);
    if (NULL == pTitleBuffer.get())  return WBEM_E_OUT_OF_MEMORY;
    
    
    // Find out the size of the data.    
    dwR = RegQueryValueExW(HKEY_PERFORMANCE_TEXT, 
                                           TEXT("Counter"), 
                                            0, &Type, (BYTE *)pTitleBuffer.get(), &DataSize);
    
     if (ERROR_MORE_DATA == dwR)
     {
        // Allocate more memory
        //
        nChars = DataSize/sizeof(WCHAR);
        pTitleBuffer.reset( new WCHAR[nChars]);
        if (NULL == pTitleBuffer.get())  return WBEM_E_OUT_OF_MEMORY;
        

        // Query the data
        //
        dwR = RegQueryValueEx (HKEY_PERFORMANCE_TEXT, TEXT("Counter"), 
                                               0, &Type, (BYTE *)pTitleBuffer.get(), &DataSize);
     }


    if(dwR == ERROR_ACCESS_DENIED)  return WBEM_E_ACCESS_DENIED;
    if (dwR) return MAKE_HRESULT(SEVERITY_ERROR, FACILITY_WIN32, dwR);

    //
    //  now parse the string, and set-up the arrays
    // string will be parsed backwards
    // expected fomat is
    // L"12345678\0description\0\0"
    //
    WCHAR * pEnd = pTitleBuffer.get()+nChars;
    // points to the last char
    pEnd--;
    while (*pEnd == L'\0') pEnd--;
    while (*pEnd)  pEnd--;
    // past the zero after the last index
    pEnd--; 
    while (*pEnd) pEnd--;
    // this should point to the last index as a string
    pEnd++;
    
    DWORD LastValidIndex = _wtoi(pEnd);

    if (0 == LastValidIndex) return WBEM_E_FAILED;

    LastValidIndex+=2; // just to be safe
    

    wmilib::auto_buffer<WCHAR *> pCounter( new WCHAR*[LastValidIndex]);
    if (NULL == pCounter.get()) return WBEM_E_OUT_OF_MEMORY;

    memset(pCounter.get(),0,LastValidIndex*sizeof(WCHAR *));

    DWORD IndexCounter;
    WCHAR * pStartCounter = pTitleBuffer.get();

    WCHAR * LimitMultiCounter = pTitleBuffer.get() + nChars;

    while ((*pStartCounter) && (pStartCounter < LimitMultiCounter))
    {
        IndexCounter = _wtoi(pStartCounter);
        while(*pStartCounter)
            pStartCounter++;
        pStartCounter++;     // points to the string
        if (IndexCounter && (IndexCounter < LastValidIndex))
        {            
            pCounter[IndexCounter] = (WCHAR *)(((ULONG_PTR)pStartCounter)|1);
        }
        // skip the string
        while(*pStartCounter)  pStartCounter++;  
        pStartCounter++; // points to the next number
    }    

    m_TitleBuffer = pTitleBuffer.release();
    m_pCounter = pCounter.release();
    m_Size = LastValidIndex;

    EliminateRanges();
    
    return dwR;
} 

void CImpPerf::EliminateRanges()
{
    // the index1 is the span of the system reserved indexes
    WCHAR * pString = m_pCounter[1];
    DWORD SystemIndexes = 0;
    if (pString)
    {
        SystemIndexes = 1 + _wtoi((WCHAR *)((ULONG_PTR)pString & (~1)));
    }
    for (DWORD i = 0; i<min(SystemIndexes,m_Size); i++)
    {
        ULONG_PTR p = (ULONG_PTR)m_pCounter[i];
        if (p) 
        {
            p &= (~1L);
            m_pCounter[i] = (WCHAR *)p;
        }
    }

   OnDeleteObjIf0<CImpPerf,void(CImpPerf:: *)(void),&CImpPerf::MakeAllValid> AllValid(this);

    HKEY hKey;
    LONG lRet = RegOpenKeyExW(HKEY_LOCAL_MACHINE, 
                                                L"SYSTEM\\CurrentControlSet\\Services",
                                                0,
                                                KEY_ENUMERATE_SUB_KEYS,
                                                &hKey);
    if (ERROR_SUCCESS != lRet) return;
    OnDelete<HKEY,LONG(*)(HKEY),RegCloseKey> regClMe(hKey);

    DWORD BaseSize = 256;
    wmilib::auto_buffer<WCHAR> pKeyName(new WCHAR[BaseSize]);
    if (NULL == pKeyName.get()) return;

    DWORD FullKeySize = 256 + 13; // add length_of "\\performance"
    wmilib::auto_buffer<WCHAR> pFullKeyName(new WCHAR[FullKeySize]);
    if (NULL == pFullKeyName.get()) return;    
    
    DWORD dwEnumIndex = 0;
    LONG lRes;
    while (TRUE)
    {
        DWORD dwRequiredSize = BaseSize;
        lRes = RegEnumKeyExW(hKey,dwEnumIndex,pKeyName.get(),&dwRequiredSize,
                                             NULL, NULL, NULL, NULL);
        if (ERROR_SUCCESS == lRes)
        {
            if (BaseSize > FullKeySize)
            {
                pFullKeyName.reset(new WCHAR[BaseSize + 13]);
                if (NULL == pFullKeyName.get()) return;
                FullKeySize = BaseSize + 13;                
            }
            StringCchCopyW(pFullKeyName.get(),FullKeySize,pKeyName.get());
            StringCchCatW(pFullKeyName.get(),FullKeySize,L"\\Performance");

            HKEY hKeySec;
            LONG lResInner = RegOpenKeyExW(hKey,pFullKeyName.get(),
                                                                 0,
                                                                 KEY_READ,
                                                                 &hKeySec);
            if (ERROR_SUCCESS != lResInner) 
            {
                //DbgPrintfA(0,"KEY: %S ERR: %08x\n",pFullKeyName.get(),lResInner);
                dwEnumIndex++;
                continue;
            }
            OnDelete<HKEY,LONG(*)(HKEY),RegCloseKey> regClMe2(hKeySec);

            DWORD FirstCounter;
            DWORD LastCounter;
            DWORD dwSize = sizeof(DWORD);
            DWORD dwType;
            lResInner = RegQueryValueExW(hKeySec,
                                                            L"First Counter",
                                                            0,
                                                            &dwType,
                                                            (BYTE*)&FirstCounter,
                                                            &dwSize);
            if (ERROR_SUCCESS != lResInner || REG_DWORD != dwType) goto end_internal;

            dwSize = sizeof(DWORD);
            lResInner = RegQueryValueExW(hKeySec,
                                                            L"Last Counter",
                                                            0,
                                                            &dwType,
                                                            (BYTE*)&LastCounter,
                                                            &dwSize);            
            if (ERROR_SUCCESS != lResInner || REG_DWORD != dwType) goto end_internal;

            //DbgPrintfA(0,"PerfLib %S First %d Last %d\n",pKeyName.get(),FirstCounter,LastCounter);

            if (FirstCounter > m_Size) goto end_internal;
            if (LastCounter > m_Size) goto end_internal;            

            for (DWORD i=FirstCounter; i<=LastCounter;i++)
            {
                ULONG_PTR p = (ULONG_PTR)m_pCounter[i];
                if (p) 
                {
                    p &= (~1L);
                    m_pCounter[i] = (WCHAR *)p;
                }                
            };
            
end_internal:            
            dwEnumIndex++;
            continue;
        }
        else if (ERROR_MORE_DATA == lRes)
        {
            BaseSize += 256;
            pKeyName.reset(new WCHAR[BaseSize]);
            if (NULL == pKeyName.get()) return; // fall back to the regular case
            continue;
        }
        else if (ERROR_NO_MORE_ITEMS == lRes)
        {
            break; // exit the loop;
        }
        else
        {
            return; // not a known error
        }
    }       
    
    AllValid.dismiss();

/*
    for (DWORD i = 0; i< m_Size; i++)
    {
        ULONG_PTR p = (ULONG_PTR)m_pCounter[i];
        if (p) 
        {
            if ((ULONG_PTR)p & 1L)
            {
                DbgPrintfA(0,"Eliminated Index %d - %S\n",i,(WCHAR *)((ULONG_PTR)p & (~1)));
            }
        }
    }    
*/    
}

//
// this function is used if we cannot estabilish which indexes are valid
//
////////////////////////////////////////////////////////////

void CImpPerf::MakeAllValid()
{
    for (DWORD i = 0; i< m_Size; i++)
    {
        ULONG_PTR p = (ULONG_PTR)m_pCounter[i];
        if (p) 
        {
            p &= (~1L);
            m_pCounter[i] = (WCHAR *)p;
        }
    }    
}

//***************************************************************************
//
//  DWORD CImpPerf::dwGetRegHandles
//
//  DESCRIPTION:
//
//  Sets the handles for the local computer and the performance
//  information.
//
//  PARAMETERS:
//
//  pMachine            Machine name
//
//  RETURN VALUE:
//
//  S_OK                all is well
//  otherwise return is from RegConnectRegistry  
//***************************************************************************

DWORD CImpPerf::dwGetRegHandles(
                    const TCHAR * pMachine)
{
    DWORD dwRet;
    TCHAR pTemp[256];
    if(pMachine == NULL)
        return WBEM_E_INVALID_PARAMETER;
    StringCchCopyW(pTemp, 256, pMachine);

    // if the current handles are to a remote machine, then free them

    if(!lstrcmpi(sMachine,TEXT("local"))) 
    {
        if(hKeyPerf && hKeyPerf != HKEY_PERFORMANCE_DATA)
            RegCloseKey(hKeyPerf);
        if(hKeyMachine)
            RegCloseKey(hKeyMachine);
        hKeyPerf = hKeyMachine = NULL;
    }

    // Determine if the target is remote or local

    if(lstrcmpi(pMachine,TEXT("local"))) 
    {
    
        // Remote, connect up

        dwRet = RegConnectRegistry(pTemp,HKEY_PERFORMANCE_DATA,
                    &hKeyPerf);
        if(dwRet != S_OK) // could not remote connect
            return dwRet;

        dwRet = RegConnectRegistry(pTemp,HKEY_LOCAL_MACHINE,
                    &hKeyMachine);
        if(dwRet != S_OK)
        {
            RegCloseKey(hKeyPerf);
            hKeyPerf = hKeyMachine = NULL;
            return dwRet;
        }
    }
    else 
    {
        hKeyMachine = HKEY_LOCAL_MACHINE;
        hKeyPerf = HKEY_PERFORMANCE_DATA;
    }
    return 0;
}

//***************************************************************************
//
//  int CImpPerf::iGetTitleIndex
//
//  DESCRIPTION:
//
//  Looks for the name in the buffer containing the names and 
//  returns the index.  The buffer is a series of strings with a double
//  null at the end.  Each counter or object is represented by a pair of
//  strings with the first having the number and the second having the 
//  text.  This code goes through the pairs, storing the number string and
//  checking the text vs the input.  If a match, then the number is returned.
//
//  PARAMETERS:
//
//  pSearch             String to be found in buffer
//
//  RETURN VALUE:
//
//  integer that goes with the string.  -1 if not found
//
//***************************************************************************

int CImpPerf::iGetTitleIndex(
                    const TCHAR * pSearch, BOOL addDups)
{
    int iRet = -1;
    if(pSearch == NULL) return -1;
    DWORD Index = m_IndexCache.Find(pSearch);
    if(Index != -1) return Index;
    
    for (DWORD i = 0; i< m_Size; i++)
    {
        ULONG_PTR p = (ULONG_PTR)m_pCounter[i];
        if (p) 
        {
            if (!(p & 1))  // a pointer is valid if it DOES NOT have the low bit set
            {
                if (0 == wbem_wcsicmp(pSearch,m_pCounter[i]))
                {
                    m_IndexCache.Add(m_pCounter[i], i);
                    //DbgPrintfA(0,"%d - %S\n",i,m_pCounter[i]);
                    if(addDups == FALSE)
                    	return i;
                    if(iRet == -1)
                    	iRet = i;
                }
            }
        }
    }    
    return iRet;
}

//***************************************************************************
//
//  SCODE CImpPerf::FindData
//
//  DESCRIPTION:
//
//  Finds the counter in the data block.  Note that the steps are quite
//  involved and an understanding of the structure of performance data
//  is probably required.  See chap 66 of the Win32 Programmers Ref.
//
//
//  PARAMETERS:
//
//  pData               Data block to be searched
//  iObj                Int which identifies the object
//  iCount              Int which identifies the counter
//  ProvObj             Object containing the parsed context string
//  pdwSize             Size of data
//  **ppRetData         points to data
//  pls                 Line structure
//  bNew                If true, indicates that we are searching the newest
//                      sample of data.
//  pInfo               If set, points to an collection object which 
//                      contains a list of instance names.  By being set
//                      the function doesnt look for actual data, instead
//                      it is used just to get the instance names.
//
//  RETURN VALUE:
//
//  S_OK                    all is well
//  WBEM_E_FAILED            couldnt find the data in the block
//  
//***************************************************************************

SCODE CImpPerf::FindData(
                    IN PERF_DATA_BLOCK * pData,
                    IN int iObj,
                    IN int iCount,
                    IN CProvObj & ProvObj,
                    OUT DWORD * pdwSize,
                    OUT void **ppRetData,
                    OUT PLINESTRUCT pls,
                    IN BOOL bNew,
                    OUT CEnumPerfInfo * pInfo)
{
    try
    {
    int iIndex;
    BOOL bEqual;
    DWORD dwSize = 0;
    DWORD dwType,dwTypeBase = 0;
    *ppRetData = NULL;
    void * pVoid = NULL, * pVoidBase = NULL;
    PPERF_OBJECT_TYPE pObj = NULL;
    PPERF_COUNTER_DEFINITION pCount = NULL;
    PPERF_COUNTER_DEFINITION pCountBase= NULL;
    PPERF_INSTANCE_DEFINITION pInst = NULL;

    // Some objects, such as disks, have what are called instances and in
    // that case the provider string will have an extra token with the 
    // instance name in it.

    WCHAR wInstName[MAX_PATH];
    wInstName[0] = 0;
    WCHAR * pwInstName = wInstName;
    long lDuplicateNum = 0;

    // If there is an instance name, convert it to WCHAR.  Also, the 
    // instance name may be of the for "[123]chars" and in this case the
    // didits between "[]" are converted to a number and the actual name
    // starts after the ']'.

    if(ProvObj.iGetNumTokens() > 3) 
    {
        if(lstrlen(ProvObj.sGetToken(3)) > MAX_PATH -1)
            return WBEM_E_FAILED;
#ifdef UNICODE
       StringCchCopyW(wInstName, MAX_PATH,  ProvObj.sGetToken(3));
#else
        mbstowcs(wInstName, ProvObj.sGetToken(3), MAX_PATH-1);
#endif
        if(wInstName[0] == L'[')
        {
            lDuplicateNum = _wtol(&wInstName[1]);
            for(pwInstName = &wInstName[1]; *pwInstName && *pwInstName != L']'; 
                        pwInstName++);      // INTENTIONAL SEMI!
            if(*pwInstName == L']')
                pwInstName++;
        }
    }
    else
    {
        // if there is not an instance name and the argument for enumeration is null, then we have a
        // bad path

        if(pInfo == NULL)
            return WBEM_E_INVALID_OBJECT_PATH;
    }


    // Go through the list of objects and find the one
    // that matches iObj

    pObj = (PPERF_OBJECT_TYPE)((PBYTE)pData + pData->HeaderLength);
    for(iIndex = 0; iIndex < (int)pData->NumObjectTypes; iIndex++) 
    {
        if((int)pObj->ObjectNameTitleIndex == iObj)
            break; // found it!
        pObj = (PPERF_OBJECT_TYPE)((PBYTE)pObj + pObj->TotalByteLength);
    }
    if(iIndex == (int)pData->NumObjectTypes) 
        return WBEM_E_FAILED; // never found object in the block
    
    // Object was found, set the object type data

    if(bNew) 
    {
        pls->ObjPerfFreq = *(LONGLONG UNALIGNED *)(&pObj->PerfFreq);
        pls->ObjCounterTimeNew = *(LONGLONG UNALIGNED *)(&pObj->PerfTime);
    }
    else
        pls->ObjCounterTimeOld = *(LONGLONG UNALIGNED *)(&pObj->PerfTime);

    // Go through the list of counters for the object and find the one that 
    // matches iCount.  Note that some counter names may be have more than 
    // one id.  Therefore, try the other ids if the intial one doesnt work.

    bool bFound = false;
    bool bEndOfList = false;
    int lTry = 0;               // how may times we have tried
    do 
    {

        pCount = (PPERF_COUNTER_DEFINITION)((PBYTE)pObj + pObj->HeaderLength);
        for(iIndex = 0; iIndex < (int)pObj->NumCounters; iIndex++) 
        {
            if((int)pCount->CounterNameTitleIndex == iCount || pInfo)
            {
                bFound = true;
                break; // found it!
            }
            pCount = (PPERF_COUNTER_DEFINITION)((PBYTE)pCount + pCount->ByteLength);
        }
        if(bFound == false)
        {
            lTry++;
            iCount = m_IndexCache.Find(ProvObj.sGetToken(2), lTry);
            if(iCount == -1)
                bEndOfList = true;
        }
        
    } while (bFound == false && bEndOfList == false);


    if(bFound == false) 
    {
        return WBEM_E_FAILED; // never found object in the block
    }

    // The counter was found, save the counter information
    // If the counter is not the last one in the object, then the
    // next one might be the base which is used for certain calculations

    dwType = pCount->CounterType;
    pls->lnCounterType = pCount->CounterType;
    if(iIndex < (int)pObj->NumCounters - 1) 
    {

        // might be the base

        pCountBase = (PPERF_COUNTER_DEFINITION)((PBYTE)pCount + 
                            pCount->ByteLength);
        dwTypeBase = pCountBase->CounterType;
    }

    // Get a pointer to the start of the perf counter block
    // There are two cases:  If there are no instances, then
    // the data starts after the last counter descriptor.  
    // If there are instances, each instance has it's own block.

    pVoid = NULL;
    if(pObj->NumInstances == -1) 
    {
		// The object is a singleton

        if(pInfo)         // If we are enumerating instances
        {
            pInfo->AddEntry(L"@");
            return S_OK; 
        }

        // easy case, get offset into data, add offset
        // for particular counter.

        pVoid = (PBYTE)pObj + pObj->DefinitionLength 
                     + pCount->CounterOffset;
        if(pCountBase)
            pVoidBase = (PBYTE)pObj + pObj->DefinitionLength 
                     + pCountBase->CounterOffset;
    }
    else if(pObj->NumInstances > 0) 
    {

		WCHAR wNum[12];
		
        // hard case, got a list of instaces, start off
        // by getting a pointer to the first one.

        long lNumDupsSoFar = 0;
        pInst= (PPERF_INSTANCE_DEFINITION)((PBYTE)pObj + pObj->DefinitionLength);
        for(iIndex = 0; iIndex < (int)pObj->NumInstances; iIndex++) 
        {

            // Each instance has a unicode name, get it and
            // compare it against the name passed in the
            // provider string.

            PPERF_COUNTER_BLOCK pCtrBlk;
            WCHAR * pwName;
            if(pInst->UniqueID == PERF_NO_UNIQUE_ID)
            	pwName = (WCHAR *)((PBYTE)pInst + pInst->NameOffset);
            else
            {
            	_ltow (pInst->UniqueID, wNum, 10);
				pwName = wNum;
            }
            if(pInfo)
            {
                // We we are mearly getting the instance names, just add the
                // instance name to the list.  If the instance name is a 
                // duplicate, prepend "[num]" to the name.

                if(wcslen(pwName) > 240)
                    continue;       // should never happen but just in case!
                int iRet = pInfo->GetNumDuplicates(pwName);
                if(iRet > 0)
                {
                    StringCchPrintfW (wInstName, MAX_PATH, L"[%ld]", iRet);
                    StringCchCatW(wInstName, MAX_PATH, pwName);
                }
                else
                    StringCchCopyW(wInstName, MAX_PATH,  pwName);
                pInfo->AddEntry(wInstName);
            }
            else 
            {
            
              // for now the code assumes that the first instance
              // will be retrieved if the instance is not specified

              if(wcslen(pwInstName) == 0)
                bEqual = TRUE;
              else 
              {  
                bEqual = !wbem_wcsicmp(pwName ,pwInstName);
                if(lDuplicateNum > lNumDupsSoFar && bEqual)
                {
                    bEqual = FALSE;
                    lNumDupsSoFar++;
                }
              }
            
              if(bEqual) 
              {
                
                // we found the instance !!!!  Data is found
                // in data block following instance offset 
                // appropriatly for this counter.

                pVoid = (PBYTE)pInst + pInst->ByteLength +
                    pCount->CounterOffset;
                if(pCountBase)
                    pVoidBase =  (PBYTE)pInst + pInst->ByteLength +
                                   pCountBase->CounterOffset;
                break;
              }
            }
            
            // not found yet, next instance is after this
            // instance + this instance's counter data

            pCtrBlk = (PPERF_COUNTER_BLOCK)((PBYTE)pInst +
                        pInst->ByteLength);
            pInst = (PPERF_INSTANCE_DEFINITION)((PBYTE)pInst +
                pInst->ByteLength + pCtrBlk->ByteLength);
        }
    }

    // Bail out if data was never found or if we were just looking for instances

    if(pInfo)
        return pInfo->GetStatus();

    if(pVoid == NULL) 
    {
        return WBEM_E_FAILED; // never found object in the block
    }

    // Move the counter data and possibly the base data into the structure
    // Note that text is handled via the ppRetData pointer and is not
    // done here.

    DWORD dwSizeField = dwType & 0x300;
    void * pDest = (bNew) ? &pls->lnaCounterValue[0] : &pls->lnaOldCounterValue[0]; 
    if(dwSizeField == PERF_SIZE_DWORD) 
    {
        memset(pDest,0,sizeof(LONGLONG));  // zero out unused portions
        dwSize = sizeof(DWORD);
        memcpy(pDest,pVoid,dwSize);
    }
    else if(dwSizeField == PERF_SIZE_LARGE) 
    {
        dwSize = sizeof(LONGLONG);
        memcpy(pDest,pVoid,dwSize);
    }
    else if(dwSizeField == PERF_SIZE_VARIABLE_LEN) 
        dwSize = pCount->CounterSize;   // this sets it for text
    else 
    {
        return WBEM_E_FAILED; // never found object in the block
    }

    // possibly do the base now.  

    dwSizeField = dwTypeBase & 0x300;
    pDest = (bNew) ? &pls->lnaCounterValue[1] : &pls->lnaOldCounterValue[1]; 
    if(dwSizeField == PERF_SIZE_DWORD && pVoidBase) 
    {
        memset(pDest,0,sizeof(LONGLONG));
        memcpy(pDest,pVoidBase,sizeof(DWORD));
    }
    else if(dwSizeField == PERF_SIZE_LARGE && pVoidBase)
        memcpy(pDest,pVoidBase,sizeof(LONGLONG));

    *ppRetData = pVoid;  // Set to return data
    *pdwSize = dwSize;
    return S_OK;
    }
    catch(...)
    {
        return WBEM_E_FAILED;
    }
 }

//***************************************************************************
//
//  SCODE CImpPerf::MakeEnum
//
//  DESCRIPTION:
//
//  Creates a CEnumPerfInfo object which can be used for enumeration
//
//  PARAMETERS:
//
//  pClass              Pointer to the class object.
//  ProvObj             Object containing the property context string.
//  ppInfo              Set to point to an collection object which has
//                      the keynames of the instances.
//
//  RETURN VALUE:
//
//  S_OK                all is well,
//  else set by LoadData or FindData
//  
//***************************************************************************

SCODE CImpPerf::MakeEnum(
                    IN IWbemClassObject * pClass,
                    IN CProvObj & ProvObj, 
                    OUT CEnumInfo ** ppInfo)
{
    SCODE sc;
    int iObject,iCounter;
    PERF_DATA_BLOCK *  pNew;
    DWORD dwSize;
    LINESTRUCT ls;
    void * pCountData;
    CVariant vPerf;
    CEnumPerfInfo * pInfo = NULL;
    *ppInfo = NULL;

    //  The perf counter provider keeps some rather expensive data and 
    //  so it doesnt support complete reentrancy. 

    if(hExec) 
    {
        DWORD dwRet;
        dwRet = WaitForSingleObject(hExec,MAX_EXEC_WAIT);  
        if(dwRet != WAIT_ABANDONED && dwRet != WAIT_OBJECT_0)
            return WBEM_E_FAILED; 
    }
    else
        return WBEM_E_FAILED;

    // Load up the data

    sc = LoadData(ProvObj,&ls,&iObject,&iCounter,&pNew,TRUE);
    if(sc != S_OK)
        goto DoneMakeEnum;
    
    // Create a new CEnumPerfInfo object.  Its entries will be filled
    // in by Find Data.
    
    pInfo = new CEnumPerfInfo();
    if(pInfo == NULL) 
    {
        sc = WBEM_E_OUT_OF_MEMORY;
        goto DoneMakeEnum;
    }
    sc = FindData(pNew,iObject,iCounter,ProvObj,&dwSize,&pCountData,
            &ls,TRUE,pInfo); 
    if(sc != S_OK)
        delete pInfo;

DoneMakeEnum:
    if(sc == S_OK)
        *ppInfo = pInfo;
    if(hExec)
        ReleaseMutex(hExec);
    return sc;
}
                                 
//***************************************************************************
//
//  SCODE CImpPerf::GetKey
//
//  DESCRIPTION:
//
//  Gets the key name of an entry in the enumeration list.
//
//  PARAMETERS:
//
//  pInfo               Collection list
//  iIndex              Index in the collection
//  ppKey               Set to the string.  MUST BE FREED with "delete"
//
//  RETURN VALUE:
//
//  S_OK                    if all is well
//  WBEM_E_INVALID_PARAMETER bad index
//  WBEM_E_OUT_OF_MEMORY
//***************************************************************************

SCODE CImpPerf::GetKey(
                    IN CEnumInfo * pInfo,
                    IN int iIndex,
                    OUT LPWSTR * ppKey)
{
    DWORD dwLen;
    CEnumPerfInfo * pPerfInfo = (CEnumPerfInfo *)pInfo;
    LPWSTR pEntry = pPerfInfo->GetEntry(iIndex);
    if(pEntry == NULL)
        return WBEM_E_INVALID_PARAMETER;
    dwLen = wcslen(pEntry)+1;
    *ppKey = new WCHAR[dwLen];
    if(*ppKey == NULL)
        return WBEM_E_OUT_OF_MEMORY;
    StringCchCopyW(*ppKey, dwLen,pEntry);
    return S_OK;
}

//***************************************************************************
//
//  SCODE CImpPerf::MergeStrings
//
//  DESCRIPTION:
//
//  Combines the Class Context, Key, and Property Context strings.
//
//  PARAMETERS:
//
//  ppOut               Output string.  MUST BE FREED VIA "delete"
//  pClassContext       Class context
//  pKey                Key property value
//  pPropContext        Property context
//
//  RETURN VALUE:
//
//  S_OK                    if all is well
//  WBEM_E_INVALID_PARAMETER context string
//  WBEM_E_OUT_OF_MEMORY
//  
//***************************************************************************

SCODE CImpPerf::MergeStrings(
                    OUT LPWSTR * ppOut,
                    IN LPWSTR  pClassContext,
                    IN LPWSTR  pKey,
                    IN LPWSTR  pPropContext)
{
    
    // Allocate space for output

    int iLen = 3;
    if(pClassContext)
        iLen += wcslen(pClassContext);
    if(pKey)
        iLen += wcslen(pKey);
    if(pPropContext)
        iLen += wcslen(pPropContext);
    else
        return WBEM_E_INVALID_PARAMETER;  // should always have this!
    *ppOut = new WCHAR[iLen];
    if(*ppOut == NULL)
        return WBEM_E_OUT_OF_MEMORY;

    //todo todo, remove this demo specical
    if(pPropContext[0] == L'@')
    {
        StringCchCopyW(*ppOut, iLen, pPropContext+1);
        return S_OK;
    }
    //todo todo, remove this demo specical

    // simplecase is that everything is in the property context.  That would
    // be the case when the provider is being used as a simple dynamic 
    // property provider

    if(pClassContext == NULL || pKey == NULL) 
    {
        StringCchCopyW(*ppOut, iLen, pPropContext);
        return S_OK;
    }

    // Copy the class context, property, and finally the key

    StringCchCopyW(*ppOut, iLen, pClassContext);
    StringCchCatW(*ppOut, iLen, L"|");
    StringCchCatW(*ppOut, iLen, pPropContext);
    StringCchCatW(*ppOut, iLen, L"|");
    StringCchCatW(*ppOut, iLen, pKey);
    return S_OK;
}

//***************************************************************************
//
//  CEnumPerfInfo::CEnumPerfInfo
//
//  DESCRIPTION:
//
//  Constructor.
//
//***************************************************************************

CEnumPerfInfo::CEnumPerfInfo()
{
    m_iNumUniChar = 0;
    m_iNumEntries = 0;
    m_pBuffer = NULL;
    m_status = S_OK;
}

//***************************************************************************
//
//  CEnumPerfInfo::~CEnumPerfInfo
//
//  DESCRIPTION:
//
//  Destructor.
//  
//***************************************************************************

CEnumPerfInfo::~CEnumPerfInfo()
{
    if(m_pBuffer)
        delete m_pBuffer;
}

//***************************************************************************
//
//  void CEnumPerfInfo::AddEntry
//
//  DESCRIPTION:
//
//  Adds an entry to the enumeration list.
//
//  PARAMETERS:
//
//  pNew                String to add to collection.
//
//***************************************************************************

void CEnumPerfInfo::AddEntry(
                    LPWSTR pNew)
{
    if(m_status != S_OK)
        return;     // already had memory problems.
    int iNewSize = wcslen(pNew) + 1 + m_iNumUniChar;
    LPWSTR pNewBuff = new WCHAR[iNewSize];
    if(pNewBuff == NULL) 
    {
        m_status = WBEM_E_OUT_OF_MEMORY;
        return;
    }
    StringCchCopyW(&pNewBuff[m_iNumUniChar], iNewSize - m_iNumUniChar,pNew);
    if(m_pBuffer) 
    {
        memcpy(pNewBuff,m_pBuffer,m_iNumUniChar*2);
        delete m_pBuffer;
    }
    m_iNumEntries++;
    m_iNumUniChar = iNewSize;
    m_pBuffer = pNewBuff;
}

//***************************************************************************
//
//  int CEnumPerfInfo::GetNumDuplicates
//
//  DESCRIPTION:
//
//  Checks the list to find duplicate entries.
//
//  PARAMETERS:
//
//  pwcTest             string to test for duplicates
//
//  RETURN VALUE:
//
//  number of matching strings in the collection.
//
//***************************************************************************

int CEnumPerfInfo::GetNumDuplicates(
                    LPWSTR pwcTest)
{
    int iRet = 0;
    int iCnt;
    LPWSTR pVal = m_pBuffer;
    for(iCnt = 0; iCnt < m_iNumEntries; iCnt++)
    {
        WCHAR * pwcText = pVal;

        // If the string is of the form "[number]text", skip the "[number]"
        // part.

        if(*pVal == L'[')
        {
            for(pwcText = pVal+1; *pwcText && *pwcText != L']';pwcText++);
            if(*pwcText == L']')
                pVal = pwcText+1;
        }
        if(!wbem_wcsicmp(pwcTest, pVal))
            iRet++;
        pVal += wcslen(pVal) + 1;       
    }
    return iRet;
}


//***************************************************************************
//
//  LPWSTR CEnumPerfInfo::GetEntry
//
//  DESCRIPTION:
//
//  Gets a list entry.
//
//  PARAMETERS:
//
//  iIndex              collection index
//
//  RETURN VALUE:
//
//  pointer to string in index.  Should NOT be freed.
//  NULL if bad index
// 
//***************************************************************************

LPWSTR CEnumPerfInfo::GetEntry(
                    IN int iIndex)
{
    // fist check for bad conditions

    if(m_status != S_OK || iIndex < 0 || iIndex >= m_iNumEntries)
        return NULL;
    
    int iCnt;
    LPWSTR pRet = m_pBuffer;
    for(iCnt = 0; iCnt < iIndex; iCnt++)
        pRet += wcslen(pRet) + 1;       
    return pRet;
}

//***************************************************************************
//
//  CImpPerfProp::CImpPerfProp
//
//  DESCRIPTION:
//
//  Constructor.
//
//***************************************************************************

CImpPerfProp::CImpPerfProp()
{
    m_pImpDynProv = new CImpPerf();
}

//***************************************************************************
//
//  CImpPerfProp::~CImpPerfProp
//
//  DESCRIPTION:
//
//  Destructor.
//
//***************************************************************************

CImpPerfProp::~CImpPerfProp()
{
    if(m_pImpDynProv)
        delete m_pImpDynProv;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\winmgmt\stdprov\provreg.cpp ===
/*++

Copyright (C) 1995-2001 Microsoft Corporation

Module Name:

    PROVREG.CPP

Abstract:

	Defines the acutal "Put" and "Get" functions for the
			 registry provider.  The mapping string format is;
	machine|regpath[|datafield]
         
	Examples:

	local|hkey_current_user\dave
	local|hkey_current_user\dave|stringdata
	local|hkey_local_machine\hardware\resourcemap\hardware abstraction layer\
		pc compatible eisa/isa HAL|.raw("internal")(0)(2)("interrupt.vector")
	LMPGM|hkey_local_machine\clone\clone\control|CurrentUser

History:

	a-davj  9-27-95    Created.

--*/

#include "precomp.h"
#include <initguid.h>
#include "perfprov.h"
#include "cvariant.h"
#include "provreg.h"
#include <genutils.h>
#include <cominit.h>
#include <userenv.h>

#define NUM_FOR_LIST 4
#define NUM_FOR_PARTIAL 2 
#define TYPE_OFFSET 0
#define BUS_OFFSET 1
#define PARTIAL_OFFSET 0
#define DATA_OFFSET 1
#define NUM_LIST_ONLY 2

#define MIN_REG_TOKENS 2

#define BOGUS 0

// for certain "resource" registry item it is necessary to specify which bus
// and what part of the data union is to be returned.  These strings allow
// the mapping string to specify both using text

TCHAR * cpIntTypes[] = {
    TEXT("Internal"),TEXT("Isa"),TEXT("Eisa"),TEXT("MicroChannel"),TEXT("TurboChannel"),
    TEXT("PCIBus"),TEXT("VMEBus"),TEXT("NuBus"),TEXT("PCMCIABus"),TEXT("CBus"),
    TEXT("MPIBus"),TEXT("MPSABus"),TEXT("MaximumInterfaceType")};

struct UnionOffset 
{
    TCHAR * tpName;
    int iOffset;
    int iType;
    int iSize;
} Offsets[] = 
    {
        {TEXT("Port.Start"),0,CmResourceTypePort,8},
        {TEXT("Port.PhysicalAddress"),0,CmResourceTypePort,8},
        {TEXT("Port.Physical Address"),0,CmResourceTypePort,8},
        {TEXT("Port.Length"),8,CmResourceTypePort,4},
        {TEXT("Interrupt.Level"),0,CmResourceTypeInterrupt,4},
        {TEXT("Interrupt.Vector"),4,CmResourceTypeInterrupt,4},
        {TEXT("Interrupt.Affinity"),8,CmResourceTypeInterrupt,4},
        {TEXT("Memory.Start"),0,CmResourceTypeMemory,8},
        {TEXT("Memory.PhysicalAddress"),0,CmResourceTypeMemory,8},
        {TEXT("Memory.Physical Address"),0,CmResourceTypeMemory,8},
        {TEXT("Memory.Length"),8,CmResourceTypeMemory,4},
        {TEXT("Dma.Channel"),0,CmResourceTypeDma,4},
        {TEXT("Dma.Port"),4,CmResourceTypeDma,4},
        {TEXT("Dma.Reserved1"),8,CmResourceTypeDma,4},
        {TEXT("DeviceSpecificData.DataSize"),0,CmResourceTypeDeviceSpecific,4},
        {TEXT("DeviceSpecificData.Data Size"),0,CmResourceTypeDeviceSpecific,4},
        {TEXT("DeviceSpecificData.Reserved1"),4,CmResourceTypeDeviceSpecific,4},
        {TEXT("DeviceSpecificData.Reserved2"),8,CmResourceTypeDeviceSpecific,4}
    };

// Define the names of the basic registry handles

struct BaseTypes 
{
    LPTSTR lpName;
    HKEY hKey;
} Bases[] = 
    {
       {TEXT("HKEY_CLASSES_ROOT") , HKEY_CLASSES_ROOT},
       {TEXT("HKEY_CURRENT_USER") , HKEY_CURRENT_USER},
       {TEXT("HKEY_LOCAL_MACHINE") ,  HKEY_LOCAL_MACHINE},
       {TEXT("HKEY_USERS") ,  HKEY_USERS},
       {TEXT("HKEY_PERFORMANCE_DATA") ,  HKEY_PERFORMANCE_DATA},
       {TEXT("HKEY_CURRENT_CONFIG") ,  HKEY_CURRENT_CONFIG},
       {TEXT("HKEY_DYN_DATA") ,  HKEY_DYN_DATA}};

//***************************************************************************
//
//  BOOL CImpReg::bGetOffsetData
//
//  DESCRIPTION:
//
//  Getting data from a resource list requires four offsets while getting
//  it from a single descriptor requires the last two offsets. 
//   
//  PARAMETERS:
//
//  dwReg               Indicates if we are looking for a full or partial
//                      resource descriptor.
//  ProvObj             Object containing the property context string.
//  iIntType            interface type - could be a string such as "eisa"
//  iBus                bus number
//  iPartial            partial descriptor number - each full descriptor 
//                      has several partial desc.
//  iDataOffset         Data Offset - each partial descriptor has data in 
//                      a union and this is the byte offset.  Could be a 
//                      sting such as "Dma.Channel"
//  iDataType           Data type
//  iSourceSize         Size of data
//  dwArray             no longer used, should always be 0
//
//  RETURN VALUE:
//  
//  TRUE if data is found
//
//***************************************************************************

BOOL CImpReg::bGetOffsetData(
                    IN DWORD dwReg,
                    IN CProvObj & ProvObj,
                    OUT IN int & iIntType,
                    OUT IN int & iBus,
                    OUT IN int & iPartial,
                    OUT IN int & iDataOffset,
                    OUT IN int & iDataType,
                    OUT IN int & iSourceSize,
                    DWORD dwArray)
{
    int iNumRequired, iListOffset;
    int iLastToken = ProvObj.iGetNumTokens()-1;

    // determine the number needed for the type of data being requested

    if(dwReg == REG_RESOURCE_LIST)
        iNumRequired = NUM_FOR_LIST;
    else
        iNumRequired = NUM_FOR_PARTIAL;

    if(ProvObj.iGetNumExp(iLastToken) < iNumRequired)
        return FALSE;
    
    // Get the first two descriptors that are only needed in the list case.

    if(dwReg == REG_RESOURCE_LIST) 
    {

        // the first offset can either be a string such as "EISA" or a
        // numeric offset.

        if(ProvObj.IsExpString(iLastToken,TYPE_OFFSET))
            iIntType = iLookUpInt(ProvObj.sGetStringExp(iLastToken,TYPE_OFFSET));
        else
            iIntType = ProvObj.iGetIntExp(iLastToken,TYPE_OFFSET,dwArray);
        iBus = ProvObj.iGetIntExp(iLastToken,BUS_OFFSET,dwArray);
        if(iBus == -1 || iIntType == -1)
            return FALSE;
        iListOffset = NUM_LIST_ONLY;
    }
    else
        iListOffset = 0;

    // Get the last two offsets which are for identenfying which partial
    // descriptor and the last is for specifying the offset inside the 
    // union.

    iPartial = ProvObj.iGetIntExp(iLastToken,PARTIAL_OFFSET+iListOffset,dwArray);
    
    // The data offset can be a string such as "Dma.Port".
    iDataType = -1; // not necessarily an error, see the function
                    // GetResourceDescriptorData for more info.
    iSourceSize = 0; 
    if(ProvObj.IsExpString(iLastToken,DATA_OFFSET+iListOffset))
        iDataOffset = iLookUpOffset(ProvObj.sGetStringExp(iLastToken,
                            DATA_OFFSET+iListOffset),
                            iDataType,iSourceSize);
    else
        iDataOffset = ProvObj.iGetIntExp(iLastToken,DATA_OFFSET+iListOffset,dwArray);

    if(iPartial == -1 || iDataOffset == -1) 
        return FALSE;
    return TRUE;
}

//***************************************************************************
//
//  CImpReg::CImpReg
//
//  DESCRIPTION:
//
//  Constructor.
//
//  PARAMETERS:
//
//***************************************************************************

CImpReg::CImpReg()
{                       
    StringCchCopyW(wcCLSID, sizeof(wcCLSID)/sizeof(WCHAR), 
                                    L"{FE9AF5C0-D3B6-11CE-A5B6-00AA00680C3F}");

//  To disable dmreg, uncomment hDMRegLib = NULL;
//  To disable dmreg, uncomment return;
    
    hDMRegLib = NULL; //LoadLibrary("DMREG.DLL");

    m_hRoot = NULL;
    m_bLoadedProfile = false;
    if(IsNT())
    {
        SCODE sc = WbemCoImpersonateClient();
        if(sc == S_OK)
        {
            sc = m_ap.LoadProfile(m_hRoot);
            if(sc == S_OK)
                m_bLoadedProfile = true;

            WbemCoRevertToSelf();
        }
    }
    return;
}

//***************************************************************************
//
//  CImpReg::~CImpReg
//
//  DESCRIPTION:
//
//  Destructor.
//
//***************************************************************************

CImpReg::~CImpReg()
{
    if(hDMRegLib)
        FreeLibrary(hDMRegLib);
}

//***************************************************************************
//
//  CImpReg::ConvertGetDataFromDesc
//
//  DESCRIPTION:
//
//  Extracts the data when it is in either the REG_RESOURCE_LIST or
//  REG_FULL_RESOURCE_DESCRIPTOR format.  The REG_RESOURCE_LIST has a list
//  of "full resource" blocks and so in that case it is necessary to first
//  determine which block to extract from and after that the code is common.
//
//  PARAMETERS:
//
//  cVar                reference to CVariant that get set with the result
//  pData               raw data
//  dwRegType           Indicates if we are looking for a full or partial
//                      resource descriptor.
//  dwBufferSize        not used
//  ProvObj             Object containing the property context string.
//
//  RETURN VALUE:
//
//  S_OK                all is well
//  WBEM_E_INVALID_PARAMETER  couldnt find the data.  Probably a bad context
//                           string
//  otherwise, error converting the data in SetData()
//***************************************************************************

SCODE CImpReg::ConvertGetDataFromDesc(
                        OUT CVariant  & cVar,
                        IN void * pData,
                        IN DWORD dwRegType,
                        IN DWORD dwBufferSize,
                        IN CProvObj & ProvObj)
{
    int iIntType, iBus, iPartial, iDataOffset,iDataType,iSourceSize;
    ULONG uCnt;

    PCM_FULL_RESOURCE_DESCRIPTOR pFull;
    PCM_PARTIAL_RESOURCE_DESCRIPTOR pPartial;

    // Get the various operator values.  A typical provider string would
    // be "..|.raw("internal")(0)(2)("interrupt.vector")

    if(!bGetOffsetData(dwRegType,ProvObj,iIntType,iBus,iPartial,
            iDataOffset,iDataType, iSourceSize, BOGUS)) 
        return WBEM_E_INVALID_PARAMETER;

    // if list, get the right full resource block.

    if(dwRegType == REG_RESOURCE_LIST) 
    {
        PCM_RESOURCE_LIST pList = (PCM_RESOURCE_LIST)pData;
        pFull = &pList->List[0];
        for(uCnt=0; uCnt < pList->Count; uCnt++)
            if(pFull->InterfaceType == iIntType && pFull->BusNumber == (unsigned)iBus)
                break;  // found it!
            else 
                pFull = GetNextFull(pFull);
                
        if(uCnt == pList->Count) 
            return WBEM_E_INVALID_PARAMETER; // specified invalid type or bus number
    }
    else
        pFull = (PCM_FULL_RESOURCE_DESCRIPTOR)pData;
    
    // Get the partial resource descriptor.  Each full 
    // descriptor is a list of partial descriptors. If the
    // last expression was of the form ("interrupt.vector"),
    // then all the partial blocks that arn't interrupt data
    // will be ignored.  If the last expression just has a
    // number, then the type of block is ignored.
        
    unsigned uSoFar = 0;
    pPartial = pFull->PartialResourceList.PartialDescriptors;
    unsigned uLimit = pFull->PartialResourceList.Count;
    for(uCnt = 0; uCnt < (unsigned)uLimit; uCnt++) 
    {
        if(iDataType == -1 || iDataType == pPartial->Type)
        { 
            if(uSoFar == (unsigned)iPartial)
                break;  // got it!
            uSoFar++;
        }
        pPartial = GetNextPartial(pPartial); 
    }
    if(uCnt == uLimit)
        return WBEM_E_INVALID_PARAMETER; // specified invalid block

    // Copy the data into a variant

    char * cpTemp = (char *)&pPartial->u.Dma.Channel + iDataOffset;
    if(iSourceSize == 1)
        return cVar.SetData(cpTemp,VT_UI1);
    else if(iSourceSize == 2)
        return cVar.SetData(cpTemp,VT_I2);
    else if(iSourceSize == 4)
        return cVar.SetData(cpTemp,VT_I4);
    else
        return cVar.SetData(cpTemp,VT_I8);  //todo fix this VT_I8 dont work!!!
}

//***************************************************************************
//
//  SCODE CImpReg::ConvertGetDataFromSimple
//
//  DESCRIPTION:
//
//  Converts that data returned by the registry into the closest VARIANT 
//  type.  
//
//  PARAMETERS:
//
//  cVar                Reference to CVariant where result is to be put
//  pData               pointer to data
//  dwRegType           registry type, ex, REG_MUTISZ
//  dwBufferSize        size of data
//  pClassInt           Pointer to class object
//  PropName            Property name.
//
//  RETURN VALUE:
//
//  S_OK                all is well
//  else could fail if the "Get" on the property fails,
//  or if the data conversion fails in SetData.
//***************************************************************************

SCODE CImpReg::ConvertGetDataFromSimple(
                        OUT CVariant & cVar,
                        IN void * pData,
                        IN DWORD dwRegType,
                        IN DWORD dwBufferSize,
                        IN IWbemClassObject FAR * pClassInt,
                        IN BSTR PropName)
{           
    TCHAR tTemp[1];
    TCHAR * pTemp;
    SCODE sc = S_OK;
    int nSize;
    char * cpTo, * cpFrom;
    long vtProp;

    // Note that the current winnt.h file defines the constants 
    // REG_DWORD_LITTLE_ENDIAN and REG_DWORD as being the same.  
    // The compiler considers this an error in a switch statement and so
    // there is this "if" to ensure that they are handled the same even
    // if someday the constants become different

    if(dwRegType == REG_DWORD_LITTLE_ENDIAN)
        dwRegType = REG_DWORD;

    switch(dwRegType) 
    {
        case REG_SZ:
            sc = cVar.SetData(pData, VT_BSTR,dwBufferSize);
            break;    
       
        case REG_EXPAND_SZ:
            nSize = ExpandEnvironmentStrings((TCHAR *)pData,tTemp,1) + 1;
            pTemp = new TCHAR[nSize+1];
            if(pTemp == NULL) 
                return WBEM_E_OUT_OF_MEMORY;
            ExpandEnvironmentStrings((TCHAR *)pData,pTemp,nSize+1);
            sc = cVar.SetData(pTemp, VT_BSTR, nSize+1);
            delete pTemp;
            break;

        case REG_BINARY:
            if(pClassInt)
            {
                sc = pClassInt->Get(PropName,0,NULL,&vtProp,NULL);
                if(sc != S_OK)
                    return sc;
             }
            else 
                vtProp = VT_UI1 | VT_ARRAY;
            if((vtProp & VT_ARRAY) == 0)
                sc = WBEM_E_FAILED;        // Incompatible types
            else
                sc = cVar.SetData(pData,vtProp, dwBufferSize);
            break;

        case REG_DWORD:
            sc = cVar.SetData(pData,VT_I4);
            break;

        case REG_DWORD_BIG_ENDIAN:
            sc = cVar.SetData(pData,VT_I4);
            cpTo = (char *)cVar.GetDataPtr();
            cpFrom = (char *)pData;
            cpTo[0] = cpFrom[3];
            cpTo[1] = cpFrom[2];
            cpTo[2] = cpFrom[1];
            cpTo[3] = cpFrom[0];
            break;

        case REG_MULTI_SZ: 
            sc = cVar.SetData(pData, VT_BSTR | VT_ARRAY, dwBufferSize);
            break;

        default:
            sc = WBEM_E_TYPE_MISMATCH;
    }        
    return sc;
}
  
//***************************************************************************
//
//  SCODE CImpReg::ConvertSetData
//
//  DESCRIPTION:
//
//  Takes WBEM type data and converts it into the proper
//  form for storage in the registry.  There are two distinct
//  case:  Binary array data and normal data.
//
//  PARAMETERS:
//
//  cVar                Contains the source
//  **ppData            pointer which will be set to point to some allocate
//                      data.  Note that the data allocated should be freed 
//                      using CoTaskMemFree
//  pdwRegType          desired registry type
//  pdwBufferSize       size of allocated data
//
//  RETURN VALUE:
//
//  S_OK                all is well
//  WBEM_E_TYPE_MISMATCH invalied type
//  else error is set by GetData()
//  
//***************************************************************************

SCODE CImpReg::ConvertSetData(
                         IN CVariant & cVar,
                         OUT void **ppData,
                         IN DWORD * pdwRegType,
                         OUT DWORD * pdwBufferSize)
{
    void * pRet = NULL;
    SCODE sc;

    switch (cVar.GetType() & ~VT_ARRAY) 
    {
        case VT_I1:
        case VT_UI1:
        case VT_I2: 
        case VT_UI2:
        case VT_I4: 
        case VT_UI4:  
        case VT_BOOL:
        case VT_INT:
        case VT_UINT:

            // convert data into DWORD format which is equivalent to 
            // the REG_DWORD.

            *pdwRegType = (cVar.IsArray()) ? REG_BINARY : REG_DWORD;
            sc = cVar.GetData(ppData,*pdwRegType,pdwBufferSize);
            break;      
                       
        case VT_I8:
        case VT_UI8:
        case VT_LPSTR:
        case VT_LPWSTR:
        case VT_R4: 
        case VT_R8: 
        case VT_CY: 
        case VT_DATE: 
        case VT_BSTR:
            *pdwRegType = (cVar.IsArray()) ? REG_MULTI_SZ : REG_SZ;
            sc = cVar.GetData(ppData,*pdwRegType,pdwBufferSize);
            break;
        
        default:
            
            sc = WBEM_E_TYPE_MISMATCH;
    }
    return sc;
}

//***************************************************************************
//
//  void CImpReg::EndBatch
//
//  DESCRIPTION:
//
//  Called at the end of a batch of Refrest/Update Property calls.  Free up 
//  any cached handles and then delete the handle cache.
//
//  PARAMETERS:
//
//  lFlags              flags, not used
//  pClassInt           class object, not used
//  *pObj               pointer to our cache, free it
//  bGet                indicates if a Refresh or Put was being done
//
//***************************************************************************

void CImpReg::EndBatch(
                    long lFlags,
                    IWbemClassObject FAR * pClassInt,
                    CObject *pObj,
                    BOOL bGet)
{
    if(pObj != NULL) 
    {
        Free(0,(CHandleCache *)pObj);
        delete pObj;
    }
}

//***************************************************************************
//
//  void CImpReg::Free
//
//  DESCRIPTION:
//
//  Frees up cached registry handles starting with position
//  iStart till the end.  After freeing handles, the cache object 
//  member function is used to delete the cache entries.
//
//  PARAMETERS:
//
//  iStart              Where to start freeing.  0 indicates that whole
//                      cache should be emptied
//  pCache              Cache to be freed
//
//***************************************************************************

void CImpReg::Free(
                    IN int iStart,
                    IN CHandleCache * pCache)
{
    HKEY hClose;
    int iCurr; long lRet;
    for(iCurr = pCache->lGetNumEntries()-1; iCurr >= iStart; iCurr--) 
    { 
        hClose = (HKEY)pCache->hGetHandle(iCurr); 
        if(hClose != NULL) 
            if(hDMRegLib && !pCache->IsRemote())
                lRet = pClose(hClose);
            else
                lRet = RegCloseKey(hClose);
    }
    pCache->Delete(iStart); // get cache to delete the entries
}

//***************************************************************************
//
//  PCM_FULL_RESOURCE_DESCRIPTOR CImpReg::GetNextFull
//
//  DESCRIPTION:
//
//  Returns a pointer to the next full resource descritor block.  Used
//  when stepping through resource data.
//
//  PARAMETERS:
//
//  pCurr               points to current location.
//
//  RETURN VALUE:
//
//  see description.
//***************************************************************************

PCM_FULL_RESOURCE_DESCRIPTOR CImpReg::GetNextFull(
                    IN PCM_FULL_RESOURCE_DESCRIPTOR pCurr)
{
    unsigned uCount;
    PCM_PARTIAL_RESOURCE_DESCRIPTOR pPartial;

    // Get a pointer to the first partial descriptor and then step
    // through each of the partial descriptor blocks.

    pPartial = &pCurr->PartialResourceList.PartialDescriptors[0];

    for(uCount = 0; uCount < pCurr->PartialResourceList.Count; uCount++)
        pPartial = GetNextPartial(pPartial);
    return (PCM_FULL_RESOURCE_DESCRIPTOR)pPartial;
}

//***************************************************************************
//
//  PCM_PARTIAL_RESOURCE_DESCRIPTOR CImpReg::GetNextPartial
//
//  DESCRIPTION:
//
//  Returns a pointer to the next partial resource descritor block.  Used
//  when stepping through resource data.
//
//  PARAMETERS:
//
//  pCurr               Current location.
//
//  RETURN VALUE:
//
//  see description.
//***************************************************************************

PCM_PARTIAL_RESOURCE_DESCRIPTOR CImpReg::GetNextPartial(
                    IN PCM_PARTIAL_RESOURCE_DESCRIPTOR pCurr)
{
    char * cpTemp = (char *)pCurr;
    cpTemp += sizeof(CM_PARTIAL_RESOURCE_DESCRIPTOR);
    if(pCurr->Type == CmResourceTypeDeviceSpecific)
        cpTemp += pCurr->u.DeviceSpecificData.DataSize;
    return (PCM_PARTIAL_RESOURCE_DESCRIPTOR)cpTemp;
}

//***************************************************************************
//
//  int CImpReg::GetRoot
//
//  DESCRIPTION:
//
//  Gets the starting registry key.  The key can be on either the local 
//  machine or a remote one.  If there are handles in the cache, then
//  the starting key can be retrieved from it in so far as the paths match.
//
//  PARAMETERS:
//
//  pKey                Set to point to the root key
//  Path                registry path
//  pNewMachine         Machine name
//  pCache              Handle cache object
//  iNumSkip            Set to the number of tokens that matched 
//
//  RETURN VALUE:
//
//  
//***************************************************************************

int CImpReg::GetRoot(
                    OUT HKEY * pKey,
                    IN CProvObj & Path,
                    IN const TCHAR * pNewMachine,
                    OUT IN CHandleCache * pCache,
                    OUT int & iNumSkip)
{
    int iCnt;
    *pKey = NULL;
    iNumSkip = 0;
    int iRet;
    HKEY hRoot = NULL;
    const TCHAR * pNewRoot = Path.sGetFullToken(0);
    if(pNewRoot == NULL || pNewMachine == NULL)
        return ERROR_UNKNOWN;   // bad mapping string

    // If there are handles in the cache, then they may be used if and
    // only if the machines names and root keys match.

    if(pCache->lGetNumEntries() > 0)
    {    
        const TCHAR * pOldMachine = pCache->sGetString(0);
        const TCHAR * pOldRoot = pCache->sGetString(1);
        if(pOldMachine == NULL || pOldRoot == NULL)
            return ERROR_UNKNOWN;
        if(lstrcmpi(pOldMachine,pNewMachine) ||
              lstrcmpi(pOldRoot,pNewRoot))
    
                 // Either machine or root key has changed, in either 
                 // case, free all the cached handles and get a new root.

                 Free(0,pCache);
             else 
             {
                 
                 // Machine and root are in common.  Determine how much 
                 // else is in common, free what isnt in common, and return
                 // the subkey share a common path.

                 iNumSkip = pCache->lGetNumMatch(2,1,Path);
                 Free(2+iNumSkip,pCache);
                 *pKey = (HKEY)pCache->hGetHandle(1+iNumSkip);
                 return ERROR_SUCCESS;
             }
    }

    // Got to get the root key.  First, use the second token to determine
    // which predefined key to use. That would be something like;
    // HKEY_CURRENT_USER.

    int iSize= sizeof(Bases) / sizeof(struct BaseTypes);
    for(iCnt = 0; iCnt < iSize; iCnt++)
        if(!lstrcmpi(pNewRoot,Bases[iCnt].lpName)) 
        {
            hRoot = Bases[iCnt].hKey;
            break;
        }
    if(hRoot == HKEY_CURRENT_USER && m_bLoadedProfile)
        hRoot = m_hRoot;

    if(hRoot == NULL)
        return ERROR_UNKNOWN;

    // Now use the first key to determine if it is the local machine or
    // another.

    if(lstrcmpi(pNewMachine,TEXT("LOCAL"))) 
    { 
        
        // Connect to a remote machine.

        int iRet;
        pCache->SetRemote(TRUE);
        // Note that RegConnectRegistry requires a NON constant name 
        // pointer (ARG!) and thus a temp string must be created!!

        TString sTemp;
    
        sTemp = pNewMachine;
        iRet = RegConnectRegistry(sTemp, hRoot,pKey);

        sTemp.Empty();
        if(iRet == 0)
            iRet = pCache->lAddToList(pNewMachine,NULL);   // dont need to free this
        if(iRet == 0)
            iRet = pCache->lAddToList(pNewRoot,*pKey);        // do free this.
        return iRet;
    }
    else 
    {

        // Local registry.  Save tokens and handles.  By adding NULL to the
        // cache, the handle will not be freed.  

        pCache->SetRemote(FALSE);
        iRet = pCache->lAddToList(pNewMachine,NULL);
        if(iRet == 0)
            iRet = pCache->lAddToList(pNewRoot,NULL); // standard handles dont need to be freed
        *pKey = hRoot;
    }
    return iRet;
}

//***************************************************************************
//
//  int CImpReg::iLookUpInt
//
//  DESCRIPTION:
//
//  Searches (case insensitive) the list of interface types and
//  returns the index of the match or -1 if no match.
//
//  PARAMETERS:
//
//  tpTest              name to search for
//
//  RETURN VALUE:
//
//  see description.
//***************************************************************************

int CImpReg::iLookUpInt(
                    const TCHAR * tpTest)
{
    int iCnt,iSize;
    iSize = sizeof(cpIntTypes) / sizeof(TCHAR *);
    for(iCnt = 0; iCnt < iSize; iCnt++)
        if(tpTest != NULL && !lstrcmpi(tpTest,cpIntTypes[iCnt]))
            return iCnt;
    return -1; 
}

//***************************************************************************
//
//  int CImpReg::iLookUpOffset
//
//  DESCRIPTION:
//
//  Searches (case insensitive) the list data types held in
//  resource descripters.
//
//  PARAMETERS:
//
//  tpTest              String to look for
//  iType               Set to the type
//  iTypeSize           Set to the type's size
//
//  RETURN VALUE:
//
//  Returns index if match is found (-1 for failure) and also
//  sets the referneces that specifiy which type and the type's
//  size.
//
//  
//***************************************************************************

int CImpReg::iLookUpOffset(
                    IN const TCHAR * tpTest,
                    OUT int & iType,
                    OUT int & iTypeSize)
{
    int iCnt, iSize;
    iSize = sizeof(Offsets) / sizeof(struct UnionOffset);  
    for(iCnt = 0; iCnt < iSize; iCnt++)
        if(tpTest != NULL && !lstrcmpi(tpTest,Offsets[iCnt].tpName)) 
        {
            iType = Offsets[iCnt].iType;
            iTypeSize = Offsets[iCnt].iSize; 
            return Offsets[iCnt].iOffset;
        }
    return -1; 
}

//***************************************************************************
//
//  int CImpReg::OpenKeyForWritting
//
//  DESCRIPTION:
//
//  Opens a registry for updates.  Since updates are writes, it is
//  possible that the key may need to be created.  Since DM reg
//  does not support RegCreateKey, then it must be called and the
//  resulting key closed for the new key case.
//
//  PARAMETERS:
//
//  hCurr               Parent key
//  pName               sub key to be opened/created
//  pNew                pointer to opened/created key
//  pCache              handle cache.
//
//  RETURN VALUE:
//
//  0                   if OK,
//  else set by RegOpenKey or RegCreateKey
//
//***************************************************************************

int CImpReg::OpenKeyForWritting(
                    HKEY hCurr,
                    LPTSTR pName,
                    HKEY * pNew,
                    CHandleCache * pCache)
{
    int iRet;
    iRet = RegOpenKeyEx(hCurr,pName,0,KEY_WRITE,pNew);
    if(iRet == 0)   // all done should be normal case.
        return 0;

    iRet = RegOpenKeyEx(hCurr,pName,0,KEY_SET_VALUE,pNew);
    if(iRet == 0)   // all done should be normal case.
        return 0;
    
    // Try creating the key.  If not using DM reg, just use the key from
    // here

    iRet = RegCreateKey(hCurr,pName,pNew);
    if(hDMRegLib!=NULL && !pCache->IsRemote() && iRet == 0)
    {
        // Close the key and reopen

        RegCloseKey(*pNew);
        iRet = pOpen(hCurr,pName,0,0,KEY_QUERY_VALUE,pNew);
    }
    return iRet;
}

//***************************************************************************
//
//  SCODE CImpReg::ReadRegData
//
//  DESCRIPTION:
//
//  Allocates a buffer and reads the registry.  If the buffer is not large
//  enough, then it is reallocated and reread.
//
//  PARAMETERS:
//
//  hKey                Registry Key
//  pName               Value Name
//  dwRegType           Set to the type
//  dwSize              set to the size
//  pData               set to the allocated data.  This must be freed via
//                      CoTaskmemFree()
//  pCache              Handle Cache.
//
//  RETURN VALUE:
//
//  Return: Registry value.  Also sets the size and type of the registry data
//  
//***************************************************************************

SCODE CImpReg::ReadRegData(
                    IN HKEY hKey,
                    IN const TCHAR * pName,
                    OUT DWORD & dwRegType, 
                    OUT DWORD & dwSize,
                    OUT void ** pData,
                    IN CHandleCache * pCache)
{
    void * pRet;
    int iRet;
        
    // Initially the buffer is set to hold INIT_SIZE 
    // bytes.  If that isnt enough, the query will be 
    // repeated a second time

    dwSize = INIT_SIZE;
    pRet = (unsigned char *)CoTaskMemAlloc(dwSize);
    if(pRet == NULL) 
    {
        return WBEM_E_OUT_OF_MEMORY;
    }

    if(hDMRegLib && !pCache->IsRemote())
        iRet = pQueryValue(hKey, (TCHAR *) pName, 0l, &dwRegType, (LPBYTE)pRet,&dwSize);
    else
        iRet = RegQueryValueEx(hKey, pName, 0l, &dwRegType, 
                (LPBYTE)pRet,&dwSize);

    // If we failed for lack of space, retry once.

    if(iRet == ERROR_MORE_DATA) 
    { 
        void * pSave = pRet;
        pRet= (char *)CoTaskMemRealloc(pRet, dwSize); 
        if(pRet == NULL) 
        { 
            CoTaskMemFree(pSave);
            return WBEM_E_OUT_OF_MEMORY;
        }
        if(hDMRegLib && !pCache->IsRemote())
            iRet = pQueryValue(hKey, (TCHAR *) pName, 0l, &dwRegType, 
                    (LPBYTE)pRet,&dwSize);
        else
            iRet = RegQueryValueEx(hKey, pName, 0l, &dwRegType, 
                (LPBYTE)pRet, &dwSize);
    }
    *pData = pRet;
    return iRet;
}

//***************************************************************************
//
//  SCODE CImpReg::RefreshProperty
//
//  DESCRIPTION:
//
//  Gets the value of a single property from the registry.
//
//  PARAMETERS:
//
//  lFlags              flags.  Not currently used
//  pClassInt           Instance object
//  PropName            Property name
//  ProvObj             Object containing the property context string.
//  pPackage            Caching object
//  pVar                Points to value to set
//  bTesterDetails      Provide extra info for testers
//
//  RETURN VALUE:
//
//  S_OK
//  WBEM_E_INVALID_PARAMETER
//  or others??
//***************************************************************************

SCODE CImpReg::RefreshProperty(
                    long lFlags,
                    IWbemClassObject FAR * pClassInt,
                    BSTR PropName,
                    CProvObj & ProvObj,
                    CObject * pPackage,
                    CVariant * pVar, BOOL bTesterDetails)
{
    int iCnt;
    int iNumSkip;   // number of handles already provided by cache.

    CHandleCache * pCache = (CHandleCache *)pPackage; 
    DWORD dwRegType,dwBufferSize;
    void * pData = NULL;
    const TCHAR * pName;
    HKEY hCurr,hNew;  
    SCODE sc;

    // Do a second parse on the provider string.  The initial parse
    // is done by the calling routine and it's first token is 
    // the path.  The path token is then parsed 
    // into RegPath and it will have a token for each part of the
    // registry path.  

    CProvObj RegPath(ProvObj.sGetFullToken(1),SUB_DELIM,true);
    sc = RegPath.dwGetStatus(1);
    if(sc != S_OK)
        return WBEM_E_INVALID_PARAMETER;
    
    // Get a handle to a place in the reg path. Note that it might be just
    // a root key (such as HKEY_LOCAL_MACHINE) or it might be a subkey
    // if the cache contains some open handles that can be used.

    sc = GetRoot(&hCurr,RegPath,ProvObj.sGetFullToken(0),
                        pCache,iNumSkip);
    if(sc != ERROR_SUCCESS)  
        return sc;

    // Go down the registry path till we get to the key

    for(iCnt = 1+iNumSkip; iCnt < RegPath.iGetNumTokens(); iCnt ++) 
    {
        int iRet;
        if(hDMRegLib && !pCache->IsRemote())
            iRet = pOpen(hCurr,RegPath.sGetToken(iCnt),0,0,KEY_QUERY_VALUE,&hNew);
        else
            iRet = RegOpenKeyEx(hCurr,RegPath.sGetToken(iCnt),0,KEY_READ,&hNew);
        if(iRet != ERROR_SUCCESS) 
        {
            sc = iRet;  // bad path!
            return sc;
        }
        hCurr = hNew;
        sc = pCache->lAddToList(RegPath.sGetToken(iCnt),hNew);
        if(sc != ERROR_SUCCESS)
            return sc;
    }

    // If it is a named value, get a pointer to the name
        
    if(ProvObj.iGetNumTokens() > MIN_REG_TOKENS) 
        pName = ProvObj.sGetToken(MIN_REG_TOKENS);
    else
        pName = NULL;

    // Time to get the data. 

    sc  = ReadRegData(hCurr, pName,dwRegType, dwBufferSize, &pData,pCache);
	if(sc == S_OK && dwBufferSize == 0)
		sc = 2;
    if(sc == S_OK) 
    {
        CVariant cVar;
        if(dwRegType == REG_RESOURCE_LIST || dwRegType == REG_FULL_RESOURCE_DESCRIPTOR)
            sc = ConvertGetDataFromDesc(cVar,pData,dwRegType,dwBufferSize,ProvObj);
        else
            sc = ConvertGetDataFromSimple(cVar,pData,dwRegType,dwBufferSize,pClassInt,PropName);
        if(sc == S_OK)
            sc = cVar.DoPut(lFlags,pClassInt,PropName,pVar);
    }
    if(pData != NULL)
        CoTaskMemFree(pData);
    return sc;
}

//***************************************************************************
//
//  SCODE CImpReg::StartBatch
//
//  DESCRIPTION:
//
//  Called at the start of a batch of Refrest/Update Property calls.  Initialize
//  the handle cache.
//
//  PARAMETERS:
//
//  lFlags               flags
//  pClassInt            Points to an instance object
//  pObj                 Misc object pointer
//  bGet                 TRUE if we will be getting data.
//
//  RETURN VALUE:
//
//  S_OK                 all is well
//  WBEM_E_OUT_OF_MEMORY
//***************************************************************************

SCODE CImpReg::StartBatch(
                    long lFlags,
                    IWbemClassObject FAR * pClassInt,
                    CObject **pObj,
                    BOOL bGet)
{
    *pObj = new CHandleCache;
    return (*pObj) ? S_OK : WBEM_E_OUT_OF_MEMORY;
}

//***************************************************************************
//
//  SCODE CImpReg::UpdateProperty
//
//  DESCRIPTION:
//
//  Sets the value of a single property into the registry.
//
//  PARAMETERS:
//
//  lFlags              not used
//  pClassInt           pointer to instance object
//  PropName            property name
//  ProvObj             Object containing the property context string.
//  pPackage            pointer to the handle cache
//  pVar                value to be set
//
//  RETURN VALUE:
//
//  S_OK                if ok,
//  otherwise misc errors.
//***************************************************************************

SCODE CImpReg::UpdateProperty(
                    IN long lFlags,
                    IN IWbemClassObject FAR * pClassInt,
                    IN BSTR PropName,
                    IN CProvObj & ProvObj,
                    IN CObject * pPackage,
                    IN CVariant * pVar)
{
    int iCnt;
    SCODE sc;
    void * pData;
    TString sProv;
    CHandleCache * pCache = (CHandleCache *)pPackage; 
    const TCHAR * pName;
    int iNumSkip;
    HKEY hCurr,hNew;
    DWORD dwRegType, dwBufferSize;

    // Do a second parse on the provider string.  The initial parse
    // is done by the calling routine and it's first token is 
    // the path.  The path token is then parsed 
    // into RegPath and it will have a token for each part of the
    // registry path.  

    CProvObj RegPath(ProvObj.sGetFullToken(1),SUB_DELIM,true);
    sc = RegPath.dwGetStatus(1);
    if(sc != WBEM_NO_ERROR)
        return sc;

    // Get a handle to a place in the reg path. Note that it might be just
    // a root key (such as HKEY_LOCAL_MACHINE) or it might be a subkey
    // if the cache contains some open handles that can be used.

    sc = GetRoot(&hCurr,RegPath,ProvObj.sGetFullToken(0),
                        pCache,iNumSkip);
    if(sc != ERROR_SUCCESS) 
        return sc;

    // Go down the registry path, creating keys if necessary
    
    for(iCnt = 1+iNumSkip; iCnt < RegPath.iGetNumTokens(); iCnt ++) 
    {
        int iRet;
        iRet = OpenKeyForWritting(hCurr,(LPTSTR)RegPath.sGetToken(iCnt),
                                        &hNew, pCache);
        if(iRet != ERROR_SUCCESS) 
        {
            sc = iRet;
            return sc;
        }
        hCurr = hNew;
        sc = pCache->lAddToList(RegPath.sGetToken(iCnt),hNew);
        if(sc != ERROR_SUCCESS)
            return sc;
    }

    // If it is a named value, get a pointer to the name
        
    if(ProvObj.iGetNumTokens() > MIN_REG_TOKENS) 
        pName = ProvObj.sGetToken(MIN_REG_TOKENS);
    else
        pName = NULL;

    // Get the data and set it

    CVariant cVar;

    if(pClassInt)
    {
        sc = pClassInt->Get(PropName,0,cVar.GetVarPtr(),NULL,NULL);
    }
    else if(pVar)
    {
        sc = OMSVariantChangeType(cVar.GetVarPtr(), 
                            pVar->GetVarPtr(),0, pVar->GetType());
    }
    else
        sc = WBEM_E_FAILED;
    if(sc != S_OK)
        return sc;

    sc = ConvertSetData(cVar, &pData, &dwRegType, &dwBufferSize);
    if(sc == S_OK) 
    {

        if(hDMRegLib && !pCache->IsRemote())
            sc = pSetValue(hCurr, pName, 0l, 
                   dwRegType, (LPBYTE)pData, dwBufferSize);
        else
            sc = RegSetValueEx(hCurr, pName, 0l, 
                   dwRegType, (LPBYTE)pData, dwBufferSize);
        CoTaskMemFree(pData);
    }
    
    return sc;
}

//***************************************************************************
//
//  SCODE CImpReg::MakeEnum
//
//  DESCRIPTION:
//
//  Creates a CEnumRegInfo object which can be used for enumeration
//
//  PARAMETERS:
//
//  pClass              Pointer to the class object.
//  ProvObj             Object containing the property context string.
//  ppInfo              Set to point to an collection object which has
//                      the keynames of the instances.
//
//  RETURN VALUE:
//
//  S_OK                all is well,
//  WBEM_E_INVALID_PARAMETER  bad context string
//  WBEM_E_OUT_OF_MEMORY
//  WBEM_E_FAILED             couldnt open the root key
//  or RegConnectRegistry failure,
//  or RegOpenKeyEx failure
//
//***************************************************************************

SCODE CImpReg::MakeEnum(
                    IWbemClassObject * pClass,
                    CProvObj & ProvObj, 
                    CEnumInfo ** ppInfo)
{
    HKEY hRoot = NULL;
    HKEY hKey =  NULL;
    HKEY hRemoteKey = NULL;
    DWORD dwLen;
    
    // Parse the class context
    
    if(ProvObj.iGetNumTokens() < 2)
        return WBEM_E_INVALID_PARAMETER;
    dwLen = lstrlen(ProvObj.sGetToken(1))+1;
    TCHAR * pTemp = new TCHAR[dwLen];
    if(pTemp == NULL)
        return WBEM_E_OUT_OF_MEMORY;



    StringCchCopyW(pTemp, dwLen, ProvObj.sGetToken(1));

    // Point to the root name and path.  These initially in a single string
    // and separated by a '\'.  find the backslash and replace with a null

    LPTSTR pRoot = pTemp;
    LPTSTR pPath;
    for(pPath = pRoot; *pPath; pPath++)
        if(*pPath == TEXT('\\'))
            break;
    if(*pPath == NULL || pPath[1] == NULL) 
    {   
        pPath = NULL;
    }
    else
    {
        *pPath = NULL;
        pPath ++;
    }

    // Got to get the root key.  First, use the second token to determine
    // which predefined key to use. That would be something like;
    // HKEY_CURRENT_USER.

    int iSize= sizeof(Bases) / sizeof(struct BaseTypes), iCnt;
    for(iCnt = 0; iCnt < iSize; iCnt++)
        if(!lstrcmpi(pRoot,Bases[iCnt].lpName)) 
        {
            hRoot = Bases[iCnt].hKey;
            break;
        }
    if(hRoot == NULL) 
    {
        delete pTemp;
        return WBEM_E_FAILED;
    }
    if(hRoot == HKEY_CURRENT_USER && m_bLoadedProfile && !lstrcmpi(ProvObj.sGetToken(0),TEXT("local")))
        hRoot = m_hRoot;

    // If the machine is remote, hook up to it.  Note that RegConnectRegistry
    // requires a non constant arg for the machine name and so a temp string
    // must be created.

    if(lstrcmpi(ProvObj.sGetToken(0),TEXT("local"))) 
    {
        dwLen = lstrlen(ProvObj.sGetToken(0))+1;
        TCHAR * pMachine = new TCHAR[dwLen];
        if(pMachine == NULL) 
        {
            delete pTemp;
            return WBEM_E_FAILED;
        }
        StringCchCopyW(pMachine, dwLen, ProvObj.sGetToken(0));
        int iRet = RegConnectRegistry(pMachine,hRoot,&hRemoteKey);
        delete pMachine;
        if(iRet != 0)
        {
            delete pTemp;
            return iRet;
        }
       hRoot = hRemoteKey;
   }

    // Open the key down to be used for enumeration!

    int iRet;
    if(hDMRegLib && hRemoteKey == NULL)
            iRet = pOpen(hRoot,pPath,0,0,KEY_ALL_ACCESS,&hKey);
    else
            iRet = RegOpenKeyEx(hRoot,pPath,0,KEY_QUERY_VALUE | KEY_ENUMERATE_SUB_KEYS ,&hKey);

    delete pTemp;   // all done
	if(iRet == ERROR_BAD_IMPERSONATION_LEVEL)
		return WBEM_E_ACCESS_DENIED;
    if(iRet != 0)
        return WBEM_E_FAILED;
    
    if(hDMRegLib && hRemoteKey == NULL)
        *ppInfo = new CEnumRegInfo(hKey,hRemoteKey,pClose);
    else
        *ppInfo = new CEnumRegInfo(hKey,hRemoteKey,NULL);

    return (*ppInfo) ? S_OK : WBEM_E_OUT_OF_MEMORY;

}
                                 
//***************************************************************************
//
//  SCODE CImpReg::GetKey
//
//  DESCRIPTION:
//
//  Gets the key name of an entry in the enumeration list.
//
//  PARAMETERS:
//
//  pInfo               Collection list
//  iIndex              Index in the collection
//  ppKey               Set to the string.  MUST BE FREED with "delete"
//
//  RETURN VALUE:
//
//  S_OK                    if all is well
//  WBEM_E_FAILED            end of data
//  WBEM_E_OUT_OF_MEMORY
//***************************************************************************

SCODE CImpReg::GetKey(
                    CEnumInfo * pInfo,
                    int iIndex,
                    LPWSTR * ppKey)
{
    CEnumRegInfo * pRegInfo = (CEnumRegInfo *)pInfo;
    BOOL bUseDM = (hDMRegLib && pRegInfo->GetRemoteKey() == NULL);
    int iSize = 100;
    LPTSTR pData = NULL;
    *ppKey = NULL;
    long lRet = ERROR_MORE_DATA;
    while(lRet == ERROR_MORE_DATA && iSize < 1000) 
    {
        FILETIME ft;
        iSize *= 2;
        if(pData)
            delete pData;
        pData = new TCHAR[iSize];
        if(pData == NULL)
            return WBEM_E_OUT_OF_MEMORY;
        DWORD dwSize = iSize;
        if(bUseDM)
            lRet = pEnumKey(pRegInfo->GetKey(),iIndex,pData,&dwSize,NULL,NULL,NULL,&ft);
        else    
            lRet = RegEnumKeyEx(pRegInfo->GetKey(),iIndex,pData,&dwSize,NULL,NULL,NULL,&ft);
    }
    if(lRet == 0) 
    {

        // got data.  if we are in unicode, just use the current buffer, otherwise
        // we have to convert
#ifdef UNICODE
        *ppKey = pData;
        return S_OK;
#else
        *ppKey = new WCHAR[lstrlen(pData)+1];
        if(*ppKey == NULL) 
        {
            delete pData;
            return WBEM_E_OUT_OF_MEMORY;
        }
        mbstowcs(*ppKey,pData,lstrlen(pData)+1);
        delete pData;
        return S_OK;
#endif
    }
    delete pData;    
    return WBEM_E_FAILED;
}

//***************************************************************************
//
//  CEnumRegInfo::CEnumRegInfo
//
//  DESCRIPTION:
//
//  Constructor.
//
//  PARAMETERS:
//
//  hKey            Registry Key
//  hRemoteKey      Remote registry key
//  pClose          pointer to function used to close the handle
//
//***************************************************************************

CEnumRegInfo::CEnumRegInfo(
                    HKEY hKey,
                    HKEY hRemoteKey,
                    PCLOSE pClose)
{
    m_pClose = pClose;
    m_hKey = hKey;
    m_hRemoteKey = hRemoteKey;
}

//***************************************************************************
//
//  CEnumRegInfo::~CEnumRegInfo
//
//  DESCRIPTION:
//
//  Destructor.
//  
//***************************************************************************

CEnumRegInfo::~CEnumRegInfo()
{
    long lRet;
    if(m_pClose != NULL && m_hRemoteKey == NULL)
        lRet = m_pClose(m_hKey);
    else
        lRet = RegCloseKey(m_hKey);
    if(m_hRemoteKey)
        lRet = RegCloseKey(m_hRemoteKey);
}

//***************************************************************************
//
//  CImpRegProp::CImpRegProp
//
//  DESCRIPTION:
//
//  Constructor.
//  
//***************************************************************************

CImpRegProp::CImpRegProp()
{
    m_pImpDynProv = new CImpReg();
}

//***************************************************************************
//
//  CImpRegProp::~CImpRegProp
//
//  DESCRIPTION:
//
//  Destructor.
//  
//***************************************************************************

CImpRegProp::~CImpRegProp()
{
    if(m_pImpDynProv)
        delete m_pImpDynProv;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\winmgmt\stdprov\regcrc.h ===
/*++

Copyright (C) 1996-2001 Microsoft Corporation

Module Name:

    REGCRC.H

Abstract:

History:

--*/

#include <windows.h>
#include <stdio.h>
#include <wbemcomn.h>
#include <crc32.h>

class CRegCRC
{
public:
    static HRESULT ComputeValueCRC(HKEY hKey, LPCTSTR szValueName, 
                                    DWORD dwPrevCRC, DWORD& dwNewCRC);
    static HRESULT ComputeKeyValuesCRC(HKEY hKey, DWORD dwPrevCRC, 
                                       DWORD& dwNewCRC);
    static HRESULT ComputeKeyCRC(HKEY hKey, DWORD dwPrevCRC, DWORD& dwNewCRC);
    static HRESULT ComputeTreeCRC(HKEY hKey, DWORD dwPrevCRC, DWORD& dwNewCRC);
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\winmgmt\stdprov\provperf.h ===
/*++

Copyright (C) 1995-2001 Microsoft Corporation

Module Name:

    PROVPERF.H

Abstract:

	Declares the classes needed for the perm monitor provider.

History:

	a-davj  27-Nov-95   Created.

--*/

#ifndef _PROVPERF_H_
#define _PROVPERF_H_

#include <winperf.h>
#include "perfprov.h"
#include "impdyn.h"
#include "cfdyn.h"
#include "perfcach.h"
#include "indexcac.h"

//***************************************************************************
//
//  CLASS NAME:
//
//  CEnumPerfInfo
//
//  DESCRIPTION:
//
//  A collection class that holds the instance information for use when
//  support enumeration.
//
//***************************************************************************

class CEnumPerfInfo : public CEnumInfo
{
    public:
       CEnumPerfInfo();
       ~CEnumPerfInfo();
       void AddEntry(LPWSTR pNew);
       LPWSTR GetEntry(int iIndex);
       int GetNumDuplicates(LPWSTR pwcTest);
       SCODE GetStatus(void){return m_status;};
    private:
       int m_iNumUniChar;
       int m_iNumEntries;
       LPWSTR m_pBuffer;
       SCODE m_status;
};

//***************************************************************************
//
//  CLASS NAME:
//
//  CImpPerf
//
//  DESCRIPTION:
//
//  This overrides the CImpDyn class and provides the main functions of 
//  support the perf monitor instance provider.
//
//***************************************************************************

class CImpPerf : public CImpDyn 
{
    public:
    friend DWORD CleanUpThreadRoutine( LPDWORD pParam );
    CImpPerf();
    ~CImpPerf();
    int iGetMinTokens(void){return 3;};
    SCODE RefreshProperty(long lFlags, IWbemClassObject FAR * pClassInt,
                    BSTR PropName,CProvObj & ProvObj,CObject * pPackage,
               CVariant * pVar, BOOL bTesterDetails);
    SCODE UpdateProperty(long lFlags, IWbemClassObject FAR * pClassInt,
                    BSTR PropName,CProvObj & ProvObj,CObject * pPackage,
               CVariant * pVar);
    SCODE LoadData(CProvObj & ProvObj,LINESTRUCT * pls,int * piObject, 
        int * piCounter, PERF_DATA_BLOCK **ppNew, BOOL bJustGettingInstances);
    SCODE MakeEnum(IWbemClassObject * pClass, CProvObj & ProvObj, 
                CEnumInfo ** ppInfo);
    SCODE GetKey(CEnumInfo * pInfo, int iIndex, LPWSTR * ppKey);
    virtual void FreeStuff(void);
    DWORD   GetPerfTitleSz ();
    DWORD dwGetRegHandles(const TCHAR * pMachine);
    int iGetTitleIndex(const TCHAR * pSearch, BOOL addDups);
    SCODE FindData(PERF_DATA_BLOCK * pData,int iObj, int iCount,CProvObj & ProvObj,DWORD * pdwSize,
        void **ppRetData,PLINESTRUCT pls, BOOL bNew,CEnumPerfInfo * pInfo);
    SCODE MergeStrings(LPWSTR *ppOut,LPWSTR  pClassContext,LPWSTR  pKey,LPWSTR  pPropContext);
    void EliminateRanges();
    void MakeAllValid();
private:
    HANDLE hExec;
    PerfCache Cache;
    HKEY hKeyMachine;
    DWORD dwLastTimeUsed;
    HKEY    hKeyPerf;
    TString sMachine;
    HANDLE m_hTermEvent;
    WCHAR * m_TitleBuffer; // raw buffer of counter titles
    DWORD m_Size;
    WCHAR ** m_pCounter;
   CIndexCache m_IndexCache;

    
};

//***************************************************************************
//
//  CLASS NAME:
//
//  CCFPerf
//
//  DESCRIPTION:
//
//  Class factory for CLocatorPerf class
//
//***************************************************************************

class CCFPerf : public CCFDyn 
{

    public:
    IUnknown * CreateImpObj() {return (IWbemServices*) new CImpPerf;};
}  ;

//***************************************************************************
//
//  CLASS NAME:
//
//  CImpPerfProp
//
//  DESCRIPTION:
//
//  Perf Provider property provider class.
//
//***************************************************************************

class CImpPerfProp : public CImpDynProp {

    public:
      CImpPerfProp();
      ~CImpPerfProp();
};

//***************************************************************************
//
//  CLASS NAME:
//
//  CCFPerfProp
//
//  DESCRIPTION:
//
//  Class factory for CImpPerfProp class.
//
//***************************************************************************

class CCFPerfProp : public CCFDyn 
{

    public:
    IUnknown * CreateImpObj() {return new CImpPerfProp();};

}  ;

#endif //_PROVPERF_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\winmgmt\stdprov\regedefs.h ===
/*++

Copyright (C) 1996-2001 Microsoft Corporation

Module Name:

    REGEDEFS.H

Abstract:

History:

--*/

#ifndef __WBEM_REG_EVENT_DEFS__H_
#define __WBEM_REG_EVENT_DEFS__H_

#define REG_KEY_EVENT_CLASS L"RegistryKeyChangeEvent"
#define REG_VALUE_EVENT_CLASS L"RegistryValueChangeEvent"
#define REG_TREE_EVENT_CLASS L"RegistryTreeChangeEvent"

#define REG_HIVE_PROPERTY_NAME L"Hive"
#define REG_KEY_PROPERTY_NAME L"KeyPath"
#define REG_VALUE_PROPERTY_NAME L"ValueName"
#define REG_ROOT_PROPERTY_NAME L"RootPath"

enum
{
    e_RegValueChange,
    e_RegKeyChange,
    e_RegTreeChange
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\winmgmt\stdprov\provreg.h ===
/*++

Copyright (C) 1997-2001 Microsoft Corporation

Module Name:

    PROVREG.H

Abstract:

	Defines the classes for supporting the registry provider.

History:

	a-davj  04-Mar-97   Created.

--*/

#ifndef _PROVREG_H_
#define _PROVREG_H_

#include "regprov.h"
#include "ntcnfg.h"
//#include <DMREG.H>
#include "impdyn.h"
#include "cfdyn.h"

// define for calling dmreg indirectly

typedef LONG (PASCAL * POPEN)(HKEY              hKey,
			    LPCTSTR             lpszSubKey,     
				DWORD           dwInstanceIndex,
			    DWORD               dwReserved,
			    REGSAM              samDesired,
			    PHKEY               phkResult);
typedef LONG (PASCAL *  PQUERYVALUE)(HKEY               hKey,
			    LPTSTR              lpszValueName,
			    LPDWORD             lpdwReserved,
			    LPDWORD             lpdwType,
			    LPBYTE              lpbData,
			    LPDWORD             lpcbData);
typedef LONG (PASCAL * PCLOSE)(HKEY hKey);

typedef LONG (PASCAL * PSETVALUE)(HKEY          hKey,
			    LPCTSTR             lpValueName,
			    DWORD               Reserved,
			    DWORD               dwType,
			    CONST BYTE *lpData,
			    DWORD               cbDat);
typedef LONG (PASCAL *PENUMKEY)( HKEY           hKey,
			    DWORD               iSubkey,
			    LPTSTR              lpszName,
			    LPDWORD             lpcchName,
			    LPDWORD             lpdwReserved,
			    LPTSTR              lpszClass,
			    LPDWORD             lpcchClass,
			    PFILETIME   lpftLastWrite); 

//***************************************************************************
//
//  CLASS NAME:
//
//  CEnumRegInfo
//
//  DESCRIPTION:
//
//  A collection used to hold the instance keys so as to support enumeration.
//
//***************************************************************************

class CEnumRegInfo : public CEnumInfo{
    public:
	CEnumRegInfo(HKEY hKey, HKEY hRemoteKey,PCLOSE pClose);
	~CEnumRegInfo();
	HKEY GetKey(void){return m_hKey;};
	HKEY GetRemoteKey(void){return m_hRemoteKey;};
    private:
	 HKEY m_hKey;
	 HKEY m_hRemoteKey;
	 PCLOSE m_pClose;
};

//***************************************************************************
//
//  CLASS NAME:
//
//  CImpReg
//
//  DESCRIPTION:
//
//  Support the registry as an instance provider.
//
//***************************************************************************

class CImpReg : public CImpDyn {
    public:
	CImpReg();
	~CImpReg();
	int iGetMinTokens(void){return 2;};
     
	SCODE RefreshProperty(long lFlags, IWbemClassObject FAR * pClassInt,
					BSTR PropName,CProvObj & ProvObj,CObject * pPackage,
               CVariant * pVar, BOOL bTesterDetails);
	SCODE UpdateProperty(long lFlags, IWbemClassObject FAR * pClassInt,
					BSTR PropName,CProvObj & ProvObj,CObject * pPackage,
               CVariant * pVar);
	SCODE StartBatch(long lFlags, IWbemClassObject FAR * pClassInt,CObject **pObj,BOOL bGet);
	void EndBatch(long lFlags, IWbemClassObject FAR * pClassInt,CObject *pObj,BOOL bGet);

	SCODE MakeEnum(IWbemClassObject * pClass, CProvObj & ProvObj, 
				 CEnumInfo ** ppInfo);
	SCODE GetKey(CEnumInfo * pInfo, int iIndex, LPWSTR * ppKey); 
	void Free(int iStart,CHandleCache * pCache);
	int GetRoot(HKEY * pKey,CProvObj &Path,const TCHAR * pMachine,
			CHandleCache * pCache,int & iNumToSkip);
	SCODE ConvertSetData(CVariant & cVar, void **ppData, DWORD * pdwRegType, 
			DWORD * pdwBufferSize);
	SCODE ReadRegData(HKEY hKey, const TCHAR * pName,DWORD & dwRegType, 
			DWORD & dwSize, void ** pData,CHandleCache * pCache);
	int OpenKeyForWritting(HKEY hCurr, LPTSTR pName, HKEY * pNew,CHandleCache * pCache);
	int iLookUpInt(const TCHAR * tpTest);
	int iLookUpOffset(const TCHAR * tpTest,int & iType,int & iTypeSize);
	BOOL bGetOffsetData(DWORD dwReg,CProvObj & ProvObj, int & iIntType,
			int & iBus, int & iPartial,int & iDataOffset,
			int & iDataType, int & iSourceSize,DWORD dwArray);
	PCM_PARTIAL_RESOURCE_DESCRIPTOR GetNextPartial(PCM_PARTIAL_RESOURCE_DESCRIPTOR pCurr);
	PCM_FULL_RESOURCE_DESCRIPTOR GetNextFull(PCM_FULL_RESOURCE_DESCRIPTOR pCurr);
	SCODE ConvertGetDataFromDesc(CVariant  & cVar,void * pData,DWORD dwRegType,DWORD dwBufferSize,CProvObj & ProvObj);
	SCODE ConvertGetDataFromSimple(CVariant  & cVar, void * pData,DWORD dwRegType,DWORD dwBufferSize,
					  IWbemClassObject FAR * pClassInt, BSTR PropName);
	SCODE MethodAsync(BSTR ObjectPath, BSTR MethodName, 
            long lFlags, IWbemContext* pCtx, IWbemClassObject* pInParams, 
            IWbemObjectSink* pSink);
    bool NeedsEscapes(){return true;};     // so far, on reg prov needs this

    private:
	HINSTANCE hDMRegLib;
	POPEN pOpen;
	PCLOSE pClose;
	PQUERYVALUE pQueryValue;
	PSETVALUE pSetValue;
	PENUMKEY pEnumKey;
    HKEY m_hRoot;
    AutoProfile m_ap;
    bool m_bLoadedProfile;
};


//***************************************************************************
//
//  CLASS NAME:
//
//  CCFReg
//
//  DESCRIPTION:
//
//  class factory for CLocatorReg
//
//***************************************************************************

class CCFReg : public CCFDyn 
{
    public:
	IUnknown * CreateImpObj() {return (IWbemServices*) new CImpReg;};
}  ;


//***************************************************************************
//
//  CLASS NAME:
//
//  CImpRegProp
//
//  DESCRIPTION:
//
//  Support registry property provider
//
//***************************************************************************

class CImpRegProp : public CImpDynProp {

    public:
      CImpRegProp();
      ~CImpRegProp();
      bool NeedsEscapes(){return true;};     // so far, on reg prov needs this


};

//***************************************************************************
//
//  CLASS NAME:
//
//  CCFRegProp
//
//  DESCRIPTION:
//
//  Class factory for CImpRegProp
//
//***************************************************************************

class CCFRegProp : public CCFDyn 
{

    public:
	IUnknown * CreateImpObj() {return new CImpRegProp();};

}  ;

#endif //_PROVREG_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\winmgmt\stdprov\regcrc.cpp ===
/*++

Copyright (C) 1996-2001 Microsoft Corporation

Module Name:

    REGCRC.CPP

Abstract:

History:

--*/

#include "precomp.h"
#include "regcrc.h"

HRESULT CRegCRC::ComputeValueCRC(HKEY hKey, LPCTSTR szValueName, 
                                    DWORD dwPrevCRC, DWORD& dwNewCRC)
{
    dwNewCRC = dwPrevCRC;

    // Get the size of the value
    // =========================

    DWORD dwSize = 0;
    long lRes = RegQueryValueEx(hKey, szValueName, NULL, NULL, NULL, &dwSize);
    if(lRes)
    {
        return S_FALSE;
    }

    // Get the actual value
    // ====================

    BYTE* pBuffer = new BYTE[dwSize];

    if ( pBuffer == NULL )
        return WBEM_E_OUT_OF_MEMORY;

    DWORD dwType;
    lRes = RegQueryValueEx(hKey, szValueName, NULL, &dwType, 
                                pBuffer, &dwSize);
    if(lRes)
    {
        return S_FALSE;
    }

    // Hash the type
    // =============

    dwNewCRC = UpdateCRC32((BYTE*)&dwType, sizeof(DWORD), dwNewCRC);

    // Hash the data
    // =============

    dwNewCRC = UpdateCRC32(pBuffer, dwSize, dwNewCRC);

    delete [] pBuffer;

    return S_OK;
}

HRESULT CRegCRC::ComputeKeyValuesCRC(HKEY hKey, DWORD dwPrevCRC, 
                                     DWORD& dwNewCRC)
{
    dwNewCRC = dwPrevCRC;

    // Get maximum value length
    // ========================

    DWORD dwNumValues, dwMaxValueLen;
    long lRes = RegQueryInfoKey(hKey, NULL, NULL, NULL, NULL, NULL, NULL,
                                &dwNumValues, &dwMaxValueLen, NULL, NULL, NULL);
    if(lRes && lRes != ERROR_INSUFFICIENT_BUFFER)
    {
        return E_FAIL;
    }
    
    // Enuremate all the values
    // ========================

    for(DWORD dwIndex = 0; dwIndex < dwNumValues; dwIndex++)
    {
        TCHAR* szName = new TCHAR[dwMaxValueLen + 1];

        if ( szName == NULL )
            return WBEM_E_OUT_OF_MEMORY;

        DWORD dwLen = dwMaxValueLen + 1;
        long lRes = RegEnumValue(hKey, dwIndex, szName, &dwLen, NULL, 
                                NULL, NULL, NULL);

        if(lRes)
        {
            delete [] szName;
            continue;
        }

        // Hash the name
        // =============

        dwNewCRC = UpdateCRC32((LPBYTE)szName, lstrlen(szName), dwNewCRC);

        // Hash the value
        // ==============

        ComputeValueCRC(hKey, szName, dwNewCRC, dwNewCRC);
        delete [] szName;
    }

    return S_OK;
}

HRESULT CRegCRC::ComputeKeyCRC(HKEY hKey, DWORD dwPrevCRC, 
                                     DWORD& dwNewCRC)
{
    HRESULT hres = ComputeKeyValuesCRC(hKey, dwPrevCRC, dwNewCRC);

    // Get maximum subkey length
    // =========================

    DWORD dwNumKeys, dwMaxKeyLen;
    long lRes = RegQueryInfoKey(hKey, NULL, NULL, NULL, &dwNumKeys, 
                                &dwMaxKeyLen, NULL, NULL,
                                NULL, NULL, NULL, NULL);
    if(lRes && lRes != ERROR_INSUFFICIENT_BUFFER)
    {
        return E_FAIL;
    }
    
    // Enuremate all the subkeys
    // =========================

    for(DWORD dwIndex = 0; dwIndex < dwNumKeys; dwIndex++)
    {
        TCHAR* szName = new TCHAR[dwMaxKeyLen + 1];

        if ( szName == NULL )
            return WBEM_E_OUT_OF_MEMORY;

        DWORD dwLen = dwMaxKeyLen + 1;
        long lRes = RegEnumKeyEx(hKey, dwIndex, szName, &dwLen, NULL, 
                                NULL, NULL, NULL);

        if(lRes)
        {
            delete [] szName;
            continue;
        }

        // Hash the name
        // =============

        dwNewCRC = UpdateCRC32((LPBYTE)szName, lstrlen(szName), dwNewCRC);
        delete [] szName;
    }

    return S_OK;
}

HRESULT CRegCRC::ComputeTreeCRC(HKEY hKey, DWORD dwPrevCRC, DWORD& dwNewCRC)
{
    dwNewCRC = dwPrevCRC;

    // Compute this key's CRC
    // ======================

    HRESULT hres = ComputeKeyValuesCRC(hKey, dwNewCRC, dwNewCRC);
    if(FAILED(hres)) return hres;

    // Get maximum subkey length
    // =========================

    DWORD dwNumKeys, dwMaxKeyLen;
    long lRes = RegQueryInfoKey(hKey, NULL, NULL, NULL, &dwNumKeys, 
                                &dwMaxKeyLen, NULL, NULL,
                                NULL, NULL, NULL, NULL);
    if(lRes && lRes != ERROR_INSUFFICIENT_BUFFER)
    {
        return E_FAIL;
    }
    
    // Enuremate all the subkeys
    // =========================

    for(DWORD dwIndex = 0; dwIndex < dwNumKeys; dwIndex++)
    {
        TCHAR* szName = new TCHAR[dwMaxKeyLen + 1];

        if ( szName == NULL )
            return WBEM_E_OUT_OF_MEMORY;

        DWORD dwLen = dwMaxKeyLen + 1;
        long lRes = RegEnumKeyEx(hKey, dwIndex, szName, &dwLen, NULL, 
                                NULL, NULL, NULL);

        if(lRes)
        {
            delete [] szName;
            continue;
        }

        // Hash the name
        // =============

        dwNewCRC = UpdateCRC32((LPBYTE)szName, lstrlen(szName), dwNewCRC);

        // Open the subkey
        // ===============

        HKEY hChild;
        lRes = RegOpenKeyEx(hKey, szName, 0, KEY_READ, &hChild);
        delete [] szName; 

        if(lRes)
        {
            continue;
        }
        else
        {
            // Hash the value
            // ==============
    
            ComputeTreeCRC(hChild, dwNewCRC, dwNewCRC);
            RegCloseKey(hChild);
        }
    }

    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\winmgmt\stdprov\regeprov.cpp ===
/*++

Copyright (C) 1996-2001 Microsoft Corporation

Module Name:

    REGEPROV.CPP

Abstract:

History:

--*/

#include "precomp.h"
#include <wbemidl.h>
#include <stdio.h>
#include "cfdyn.h"
#include "stdprov.h"
#include "regeprov.h"
#include <sync.h>
#include <tss.h>
#include <genutils.h>
#include <analyser.h>
#include <cominit.h>
#include <GroupsForUser.h>


template <class T>
class CLockUnlock
{
private:
	T *m_pObj;
public:
	CLockUnlock(T *pObj) : m_pObj(pObj) { if(pObj) pObj->Lock(); }
	~CLockUnlock() { if(m_pObj) m_pObj->Unlock(); }
};

CRegEventProvider::CRegEventProvider()
    : m_lRef(0), m_hThread(NULL), m_dwId(NULL), m_hQueueSemaphore(NULL),
    m_pKeyClass(NULL), m_pValueClass(NULL), m_pTreeClass(NULL), m_pSink(NULL)
{
}

CRegEventProvider::~CRegEventProvider()
{
    if(m_pSink)
        m_pSink->Release();
    if(m_pKeyClass)
        m_pKeyClass->Release();
    if(m_pValueClass)
        m_pValueClass->Release();
    if(m_pTreeClass)
        m_pTreeClass->Release();

    InterlockedDecrement(&lObj);
    if (m_hThread) CloseHandle(m_hThread);
    if (m_hQueueSemaphore) CloseHandle(m_hQueueSemaphore);
}

STDMETHODIMP CRegEventProvider::QueryInterface(REFIID riid, void** ppv)
{
    *ppv = NULL;
    if(riid == IID_IWbemEventProvider || riid == IID_IUnknown)
    {
        *ppv = (IWbemEventProvider*)this;
        AddRef();
        return S_OK;
    }
    else if(riid == IID_IWbemEventProviderQuerySink)
    {
        *ppv = (IWbemEventProviderQuerySink*)this;
        AddRef();
        return S_OK;
    }
    else if(riid == IID_IWbemEventProviderSecurity)
    {
        *ppv = (IWbemEventProviderSecurity*)this;
        AddRef();
        return S_OK;
    }
    else if(riid == IID_IWbemProviderInit)
    {
        *ppv = (IWbemProviderInit*)this;
        AddRef();
        return S_OK;
    }
    else return E_NOINTERFACE;
}

ULONG STDMETHODCALLTYPE CRegEventProvider::AddRef()
{
    return InterlockedIncrement(&m_lRef);
}

ULONG STDMETHODCALLTYPE CRegEventProvider::Release()
{
    long lRef = InterlockedDecrement(&m_lRef);
    if(lRef == 0)
    {
      {
        CInCritSec ics(&m_cs);
		    // deactivate all event requests

		    for(int i = 0; i < m_apRequests.GetSize(); i++)
		    {
			    CRegistryEventRequest* pReq = m_apRequests[i];

			    if(pReq) pReq->ForceDeactivate();
		    }

		    m_apRequests.RemoveAll();

        if(m_hThread) KillWorker();
      }
		  delete this;
    }

    return lRef;
}

STDMETHODIMP CRegEventProvider::Initialize(LPWSTR wszUser, 
											long lFlags, 
											LPWSTR wszNamespace,
											LPWSTR wszLocale, 
											IWbemServices* pNamespace, 
											IWbemContext* pCtx,
											IWbemProviderInitSink* pSink)
{
    HRESULT hres;

    hres = pNamespace->GetObject(REG_KEY_EVENT_CLASS,// strObjectPath
                                 0,				// lFlags
                                 pCtx,			// pCtx
                                 &m_pKeyClass,	// ppObject
                                 NULL);			// ppCallResult

    if ( SUCCEEDED(hres) )
    {
        hres = pNamespace->GetObject(REG_VALUE_EVENT_CLASS, 
                                     0, 
                                     pCtx, 
                                     &m_pValueClass, 
                                     NULL);
    }

    if ( SUCCEEDED(hres) )
    {
        hres = pNamespace->GetObject( REG_TREE_EVENT_CLASS, 
                                      0, 
                                      pCtx, 
                                      &m_pTreeClass, 
                                      NULL );
    }

    if ( SUCCEEDED(hres) )
    {
        m_hQueueSemaphore = CreateSemaphore( NULL, // lpSemaphoreAttributes
                                             0,    //lInitialCount
                                             0x7fffffff,      // lMaximumCount
                                             NULL);	      // lpName
        if ( m_hQueueSemaphore != NULL )
            hres = WBEM_S_NO_ERROR;
        else
            hres = WBEM_E_OUT_OF_MEMORY;
    }

    pSink->SetStatus(hres, 0);
    return hres;
}


STDMETHODIMP CRegEventProvider::ProvideEvents(IWbemObjectSink* pSink, 
											  long lFlags)
{
    m_pSink = pSink;
    pSink->AddRef();

    return S_OK;
}

HRESULT CRegEventProvider::AddRequest(CRegistryEventRequest* pNewReq)
{
	// This is only called after entering the critical section m_cs


	int nActiveRequests = m_apRequests.GetSize();

    // Search for a similar request
    // ============================

	// This will not change the number of active requests.
	// It will cause the request Id to be served by an existing
	// CRegistryEventRequest.

    for(int i = 0; i < nActiveRequests; i++)
    {
        CRegistryEventRequest* pReq = m_apRequests[i];
		
		// Only active requests are in the array.

        if(pReq->IsSameAs(pNewReq))
        {
            // Found it!
            // =========

            HRESULT hres = pReq->Reactivate(pNewReq->GetPrimaryId(), 
                                                pNewReq->GetMsWait());
            delete pNewReq;
            return hres;
        }
    }

    // Not found. Add it
    // =================

    HRESULT hres = pNewReq->Activate();
    if(SUCCEEDED(hres))
    {
        m_apRequests.Add(pNewReq);

		// If there were no active requests before this one was added
		// then we have to start up the worker thread.

		if ( nActiveRequests == 0 )
		{
			CreateWorker();
		}
    }
    return hres;
}
    

STDMETHODIMP CRegEventProvider::CancelQuery(DWORD dwId)
{
    CInCritSec ics(&m_cs);

	int nOriginalSize = m_apRequests.GetSize();

    // Remove all requests with this Id
    // ================================


    for(int i = 0; i < m_apRequests.GetSize(); i++)
    {
        CRegistryEventRequest* pReq = m_apRequests[i];

		// If Deactivate returns WBEM_S_FALSE then the request was not serving 
		// this id or it is still serving other ids so we leave it in the array.
		// If S_OK is returned then the request is no longer serving any ids
		// and it is marked as inactive and its resources are released. There
		// may still be references to it in the worker thread queue, but the 
		// worker thread will see that it is inactive and not fire the events.

		if (pReq->Deactivate(dwId) == S_OK)
		{
			m_apRequests.RemoveAt(i);
			--i;
		}
    }
        

	// If we have cancelled the last subscription then kill the worker thread.

	if (nOriginalSize > 0 && m_apRequests.GetSize() == 0)
	{
		if(m_hThread) KillWorker();
	}

    return WBEM_S_NO_ERROR;
}

void CRegEventProvider::CreateWorker()
{
	// This is only called while in m_cs

	m_hThread = CreateThread(NULL,		// lpThreadAttributes
							0,			// dwStackSize
		(LPTHREAD_START_ROUTINE)&CRegEventProvider::Worker, // lpStartAddress
							this,		// lpParameter
							0,			// dwCreationFlags
							&m_dwId);	// lpThreadId
}

void CRegEventProvider::KillWorker()
{
	// When this is called the following is true:

	// All waits have been unregistered .
	// All thread pool requests have been processed.
	// All CRegistryEventRequests in the queue are inactive.
	// m_cs has been entered.

	// Therefore no other threads will:

	// Place events in the queue.
	// Modify CRegistryEventRequests in the queue.
	// Create or destroy a worker thread.

	// So the worker thread will empty the queue of the remaining
	// inactive CRegistryEventRequests and then retrieve the null
	// event and return.

	EnqueueEvent((CRegistryEventRequest*)0);

	WaitForSingleObject(m_hThread,		//	hHandle
						INFINITE);		// dwMilliseconds

	CloseHandle(m_hThread);
	m_hThread = 0;
	m_dwId = 0;
}

HRESULT CRegEventProvider::GetValuesForProp(QL_LEVEL_1_RPN_EXPRESSION* pExpr,
											CPropertyName& PropName, 
											CWStringArray& awsVals)
{
    awsVals.Empty();

    // Get the necessary query
    // =======================

    QL_LEVEL_1_RPN_EXPRESSION* pPropExpr = NULL;
    HRESULT hres = CQueryAnalyser::GetNecessaryQueryForProperty(pExpr, 
                            PropName, pPropExpr);
    if(FAILED(hres))
    {
        return hres;
    }

    if(pPropExpr == NULL)
    	return WBEM_E_FAILED;
    
    // See if there are any tokens
    // ===========================

    if(pPropExpr->nNumTokens == 0)
    {
        delete pPropExpr;
        return WBEMESS_E_REGISTRATION_TOO_BROAD;
    }

    // Combine them all
    // ================

    for(int i = 0; i < pPropExpr->nNumTokens; i++)
    {
        QL_LEVEL_1_TOKEN& Token = pPropExpr->pArrayOfTokens[i];
        if(Token.nTokenType == QL1_NOT)
        {
            delete pPropExpr;
            return WBEMESS_E_REGISTRATION_TOO_BROAD;
        }
        else if(Token.nTokenType == QL1_AND || Token.nTokenType == QL1_OR)
        {
            // We treat them all as ORs
            // ========================
        }
        else    
        {
            // This is a token
            // ===============

            if(Token.nOperator != QL1_OPERATOR_EQUALS)
            {
                delete pPropExpr;
                return WBEMESS_E_REGISTRATION_TOO_BROAD;
            }

            if(V_VT(&Token.vConstValue) != VT_BSTR)
            {
                delete pPropExpr;
                return WBEM_E_INVALID_QUERY;
            }

            // This token is a string equality. Add the string to the list
            // ===========================================================

            if ( awsVals.Add(V_BSTR(&Token.vConstValue)) != CWStringArray::no_error)
            {
            	delete pPropExpr;
            	return WBEM_E_OUT_OF_MEMORY;
            }
        }
    }

    delete pPropExpr;
    return WBEM_S_NO_ERROR;
}

HRESULT CRegEventProvider::RaiseEvent(IWbemClassObject* pEvent)
{
    if(m_pSink)
        return m_pSink->Indicate(1, &pEvent);
    else
        return WBEM_S_NO_ERROR;
}

HKEY CRegEventProvider::TranslateHiveName(LPCWSTR wszName)
{
    if(!wbem_wcsicmp(wszName, L"HKEY_CLASSES_ROOT"))
        return HKEY_CLASSES_ROOT;
/* Disallowed: different semantics for client and server
    else if(!wbem_wcsicmp(wszName, L"HKEY_CURRENT_USER"))
        return HKEY_CURRENT_USER;
*/
    else if(!wbem_wcsicmp(wszName, L"HKEY_LOCAL_MACHINE"))
        return HKEY_LOCAL_MACHINE;
    else if(!wbem_wcsicmp(wszName, L"HKEY_USERS"))
        return HKEY_USERS;
    else if(!wbem_wcsicmp(wszName, L"HKEY_PERFORMANCE_DATA"))
        return HKEY_PERFORMANCE_DATA;
    else if(!wbem_wcsicmp(wszName, L"HKEY_CURRENT_CONFIG"))
        return HKEY_CURRENT_CONFIG;
    else if(!wbem_wcsicmp(wszName, L"HKEY_DYN_DATA"))
        return HKEY_DYN_DATA;
    else
        return NULL;
}

DWORD CRegEventProvider::Worker(void* p)
{
    CoInitializeEx(0,COINIT_MULTITHREADED);

    CRegEventProvider* pThis = (CRegEventProvider*)p;

    while(true)
    {
        DWORD dwRes = WaitForSingleObject(
            pThis->m_hQueueSemaphore,	// hHandle
            INFINITE );			// dwMilliseconds

        if ( dwRes != WAIT_OBJECT_0 )
        {
            CoUninitialize();
            return dwRes;
        }

        CRegistryEventRequest *pReq = 0;

        try
        {
            {
                CInCritSec ics(&(pThis->m_csQueueLock));
                pReq = pThis->m_qEventQueue.Dequeue();
            }

            // If pReq is null then it is a signal for the thread to terminate.

            if (pReq)
            {
                pReq->ProcessEvent();

                // Dequeueing the request doesn't release it.
                // If it did then it might be deleted before we had a chance to use it.
                // Now we are done with it.

                pReq->Release();
            }
            else
            {
                break;
            }
        }
        catch( CX_MemoryException& )
        {
            CoUninitialize();
            return ERROR_NOT_ENOUGH_MEMORY;
        }
    }

    CoUninitialize();

    return 0;
}

void CRegEventProvider::EnqueueEvent(CRegistryEventRequest *pReq)
{
    {
        CInCritSec ics(&m_csQueueLock);
        
        // Placing the request in the queue AddRefs it.
        
        if ( !m_qEventQueue.Enqueue(pReq) )
            throw CX_MemoryException();
    }

    // Tell the worker thread that there is an item to process in the queue.

    ReleaseSemaphore(m_hQueueSemaphore,	// hSemaphore
                     1,					// lReleaseCount
                     NULL);				// lpPreviousCount
}

VOID CALLBACK CRegEventProvider::EnqueueEvent(PVOID lpParameter,        
												BOOLEAN TimerOrWaitFired)
{
	CRegistryEventRequest *pReq = (CRegistryEventRequest*) lpParameter;
	CRegEventProvider *pProv = pReq->GetProvider();

	pProv->EnqueueEvent(pReq);
}

const CLSID CLSID_RegistryEventProvider = 
    {0xfa77a74e,0xe109,0x11d0,{0xad,0x6e,0x00,0xc0,0x4f,0xd8,0xfd,0xff}};

IUnknown* CRegEventProviderFactory::CreateImpObj()
{
    return (IWbemEventProvider*) new CRegEventProvider;
}

STDMETHODIMP CRegEventProvider::NewQuery(DWORD dwId, 
										WBEM_WSTR wszLanguage, 
										WBEM_WSTR wszQuery)
{
    HRESULT hres;

	CancelQuery(dwId);
    
    // Parse the query
    // ===============

    CTextLexSource Source(wszQuery);
    QL1_Parser Parser(&Source);
    
    QL_LEVEL_1_RPN_EXPRESSION* pExpr;
    if(Parser.Parse(&pExpr))
    {
        return WBEM_E_INVALID_QUERY;
    }
    CDeleteMe<QL_LEVEL_1_RPN_EXPRESSION> dm(pExpr);

    // Check the class
    // ===============

    int nEventType;
    if(!wbem_wcsicmp(pExpr->bsClassName, REG_VALUE_EVENT_CLASS))
    {
        nEventType = e_RegValueChange;
    }
    else if(!wbem_wcsicmp(pExpr->bsClassName, REG_KEY_EVENT_CLASS))
    {   
        nEventType = e_RegKeyChange;
    }
    else if(!wbem_wcsicmp(pExpr->bsClassName, REG_TREE_EVENT_CLASS))
    {
        nEventType = e_RegTreeChange;
    }
    else
    {
        // No such class
        // =============

        return WBEM_E_INVALID_QUERY;
    }

    // Check tolerance on Win95
    // ========================

    if(!IsNT() && pExpr->Tolerance.m_bExact)
    {
        return WBEMESS_E_REGISTRATION_TOO_PRECISE;
    }

    // Extract the values of hive from the query
    // =========================================

    CPropertyName Name;

    Name.AddElement(REG_HIVE_PROPERTY_NAME);
    CWStringArray awsHiveVals;

    hres = GetValuesForProp(pExpr, Name, awsHiveVals);
    if(FAILED(hres)) return hres;

    // Translate them to real hives
    // ============================

    CUniquePointerArray<HKEY> aHives;
    for(int i = 0; i < awsHiveVals.Size(); i++)
    {
        HKEY hHive = TranslateHiveName(awsHiveVals[i]);
        if(hHive == NULL)
        {
            return WBEM_E_INVALID_QUERY;
        }

        HKEY* phNew = new HKEY(hHive);

        if ( phNew == NULL )
            return WBEM_E_OUT_OF_MEMORY;
        
        if ( aHives.Add(phNew) < 0 )
            return WBEM_E_OUT_OF_MEMORY;
    }
        
    // Extract the values of key from the query
    // ========================================

    Name.Empty();
    if(nEventType == e_RegTreeChange)
    {
        Name.AddElement(REG_ROOT_PROPERTY_NAME);
    }
    else
    {
        Name.AddElement(REG_KEY_PROPERTY_NAME);
    }

    CWStringArray awsKeyVals;
    hres = GetValuesForProp(pExpr, Name, awsKeyVals);
    if(FAILED(hres)) 
    {
        return hres;
    }
                                      
    CWStringArray awsValueVals;
    if(nEventType == e_RegValueChange)
    {
        // Extract the values for the value
        // ================================
            
        Name.Empty();
        Name.AddElement(REG_VALUE_PROPERTY_NAME);
    
        hres = GetValuesForProp(pExpr, Name, awsValueVals);
        if(FAILED(hres)) 
        {
            return hres;
        }
    }

    HRESULT hresGlobal = WBEM_E_INVALID_QUERY;

    {
        CInCritSec ics(&m_cs); // do this in a critical section

        // Go through every combination of the above and create requests
        // =============================================================
    
        for(int nHiveIndex = 0; nHiveIndex < aHives.GetSize(); nHiveIndex++)
        {
            HKEY hHive = *aHives[nHiveIndex];
            LPWSTR wszHive = awsHiveVals[nHiveIndex];
            
            for(int nKeyIndex = 0; nKeyIndex < awsKeyVals.Size(); nKeyIndex++)
            {
                LPWSTR wszKey = awsKeyVals[nKeyIndex];
    
                if(nEventType == e_RegValueChange)
                {
                    for(int nValueIndex = 0; nValueIndex < awsValueVals.Size();
                            nValueIndex++)
                    {
                        LPWSTR wszValue = awsValueVals[nValueIndex];
        
                        CRegistryEventRequest* pReq = 
                            new CRegistryValueEventRequest(this, 
                                pExpr->Tolerance,
                                dwId, hHive, wszHive, wszKey, wszValue);
    
                        if(pReq->IsOK())
                        {
                            HRESULT hres = AddRequest(pReq);
                            if(SUCCEEDED(hres))
                                hresGlobal = hres;
                        }
                        else
                        {
                            DEBUGTRACE((LOG_ESS, "Invalid registration: key "
                                "%S, value %S\n", wszKey, wszValue));
                            delete pReq;
                        }
                    }
                }
                else
                {
                    // Value-less request
                    // ==================
    
                    CRegistryEventRequest* pReq;
                    if(nEventType == e_RegKeyChange)
                    {
                        pReq = new CRegistryKeyEventRequest(this, 
                                            pExpr->Tolerance,
                                            dwId, hHive, wszHive, wszKey);
                    }   
                    else
                    {
                        pReq = new CRegistryTreeEventRequest(this, 
                                            pExpr->Tolerance,
                                            dwId, hHive, wszHive, wszKey);
                    }   
                    
                    if(pReq->IsOK())
                    {
                        hres = AddRequest(pReq);
                        if(SUCCEEDED(hres))
                            hresGlobal = hres;
                    }
                    else
                    {
                        DEBUGTRACE((LOG_ESS, "Invalid registration: key %S\n", 
                                            wszKey));
                        delete pReq;
                    }
                }
            }
        }

    } // out of critical section

    return hresGlobal;
}

STDMETHODIMP CRegEventProvider::AccessCheck(WBEM_CWSTR wszLanguage, 
											WBEM_CWSTR wszQuery, 
											long lSidLength,
											const BYTE* aSid)
{
    HRESULT hres;

    PSID pSid = (PSID)aSid;
    HANDLE hToken = NULL;
    if(pSid == NULL)
    {
        //
        // Access check based on the thread
        //

        hres = WbemCoImpersonateClient();
        if(FAILED(hres))
            return hres;
        
        BOOL bRes = OpenThreadToken(GetCurrentThread(),	// ThreadHandle
									TOKEN_READ,			// DesiredAccess
									TRUE,				// OpenAsSelf
                                    &hToken);			// TokenHandle
        WbemCoRevertToSelf();
        if(!bRes)
        {
            return WBEM_E_ACCESS_DENIED;
        }    
    }
    CCloseMe cm1(hToken);
        
    // Parse the query
    // ===============

    CTextLexSource Source(wszQuery);
    QL1_Parser Parser(&Source);
    
    QL_LEVEL_1_RPN_EXPRESSION* pExpr;
    if(Parser.Parse(&pExpr))
    {
        return WBEM_E_INVALID_QUERY;
    }
    CDeleteMe<QL_LEVEL_1_RPN_EXPRESSION> dm(pExpr);

    // Check the class
    // ===============

    int nEventType;
    if(!wbem_wcsicmp(pExpr->bsClassName, REG_VALUE_EVENT_CLASS))
    {
        nEventType = e_RegValueChange;
    }
    else if(!wbem_wcsicmp(pExpr->bsClassName, REG_KEY_EVENT_CLASS))
    {   
        nEventType = e_RegKeyChange;
    }
    else if(!wbem_wcsicmp(pExpr->bsClassName, REG_TREE_EVENT_CLASS))
    {
        nEventType = e_RegTreeChange;
    }
    else
    {
        // No such class
        // =============

        return WBEM_E_INVALID_QUERY;
    }

    // Extract the values of hive from the query
    // =========================================

    CPropertyName Name;

    Name.AddElement(REG_HIVE_PROPERTY_NAME);
    CWStringArray awsHiveVals;

    hres = GetValuesForProp(pExpr, Name, awsHiveVals);
    if(FAILED(hres)) return hres;

    // Translate them to real hives
    // ============================

    CUniquePointerArray<HKEY> aHives;
    for(int i = 0; i < awsHiveVals.Size(); i++)
    {
        HKEY hHive = TranslateHiveName(awsHiveVals[i]);
        if(hHive == NULL)
        {
            return WBEM_E_INVALID_QUERY;
        }
        
        HKEY* phNew = new HKEY(hHive);

        if ( phNew == NULL )
            return WBEM_E_OUT_OF_MEMORY;
        
        if ( aHives.Add(phNew) < 0 )
            return WBEM_E_OUT_OF_MEMORY;
    }
        
    // Extract the values of key from the query
    // ========================================

    Name.Empty();
    if(nEventType == e_RegTreeChange)
    {
        Name.AddElement(REG_ROOT_PROPERTY_NAME);
    }
    else
    {
        Name.AddElement(REG_KEY_PROPERTY_NAME);
    }

    CWStringArray awsKeyVals;
    hres = GetValuesForProp(pExpr, Name, awsKeyVals);
    if(FAILED(hres)) 
    {
        return hres;
    }
                                      
    HRESULT hresGlobal = WBEM_E_INVALID_QUERY;

    // Go through every combination of the above and create requests
    // =============================================================

    for(int nHiveIndex = 0; nHiveIndex < aHives.GetSize(); nHiveIndex++)
    {
        HKEY hHive = *aHives[nHiveIndex];
        LPWSTR wszHive = awsHiveVals[nHiveIndex];
        
        for(int nKeyIndex = 0; nKeyIndex < awsKeyVals.Size(); nKeyIndex++)
        {
            LPWSTR wszKey = awsKeyVals[nKeyIndex];
        
            // Get that key's security
            // =======================

            HKEY hKey;
            long lRes = RegOpenKeyExW(hHive,			// hKey
										wszKey,			// lpSubKey
										0,				// ulOptions
										READ_CONTROL,	// samDesired
										&hKey);			// phkResult
            if(lRes)
                return WBEM_E_NOT_FOUND;
            CRegCloseMe cm2(hKey);

            DWORD dwLen = 0;
            lRes = RegGetKeySecurity(hKey,			// hKey
							OWNER_SECURITY_INFORMATION | 
							GROUP_SECURITY_INFORMATION |
							DACL_SECURITY_INFORMATION,	// SecurityInformation
									NULL,			// pSecurityDescriptor
									&dwLen);		// lpcbSecurityDescriptor		

            if(lRes != ERROR_INSUFFICIENT_BUFFER)
                return WBEM_E_FAILED;

            PSECURITY_DESCRIPTOR pDesc = (PSECURITY_DESCRIPTOR)new BYTE[dwLen];
            if(pDesc == NULL)
                return WBEM_E_OUT_OF_MEMORY;
            CVectorDeleteMe<BYTE> vdm((BYTE*)pDesc);

            lRes = RegGetKeySecurity(hKey, 
							OWNER_SECURITY_INFORMATION | 
                            GROUP_SECURITY_INFORMATION |
                            DACL_SECURITY_INFORMATION,
									pDesc,
									&dwLen);
            if(lRes)
                return WBEM_E_FAILED;

            //
            // Check permissions differently depending on whether we have a SID
            // or an actual token
            //
            
            if(pSid)
            {
                //
                // We have a SID --- walk the ACL
                //

                //
                // Extract the ACL
                // 

                PACL pAcl = NULL;
                BOOL bAclPresent, bAclDefaulted;
                if(!GetSecurityDescriptorDacl(pDesc,	// pSecurityDescriptor
											&bAclPresent,	// lpbDaclPresent
											&pAcl,			// pDacl
											&bAclDefaulted))// lpbDaclDefaulted
                {
                    return WBEM_E_FAILED;
                }
            
                if(bAclPresent)
                {
                    //
                    // This is our own ACL walker
                    //
    
                    DWORD dwAccessMask;
                    NTSTATUS st = GetAccessMask((PSID)pSid, pAcl, 
                                            &dwAccessMask);
                    if(st)
                    {
                        ERRORTRACE((LOG_ESS, "Registry event provider unable "
                            "to retrieve access mask for the creator of "
                            "registration %S: NT status %d.\n"
                            "Registration disabled\n", wszQuery, st));
                        return WBEM_E_FAILED;
                    }
    
                    if((dwAccessMask & KEY_NOTIFY) == 0)
                        return WBEM_E_ACCESS_DENIED;
                }
            }
            else
            {
                // 
                // We have a token --- use AccessCheck
                //

                //
                // Construct generic mapping for registry keys
                //

                GENERIC_MAPPING map;
                map.GenericRead = KEY_READ;
                map.GenericWrite = KEY_WRITE;
                map.GenericExecute = KEY_EXECUTE;
                map.GenericAll = KEY_ALL_ACCESS;

                //
                // Construct privilege array receptacle
                //

                PRIVILEGE_SET ps[10];
                DWORD dwSize = 10 * sizeof(PRIVILEGE_SET);

                DWORD dwGranted;
                BOOL bResult;

                BOOL bOK = ::AccessCheck(pDesc,		// pSecurityDescriptor
										hToken,		// ClientToken
										KEY_NOTIFY,	// DesiredAccess	
										&map,		// GenericMapping
										ps,			// PrivilegeSet
                                        &dwSize,	// PrivilegeSetLength
										&dwGranted,	// GrantedAccess
										&bResult);	// AccessStatus
                if(!bOK || !bResult)
                    return WBEM_E_ACCESS_DENIED;
            }
        }
    }

    return WBEM_S_NO_ERROR;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\winmgmt\stdprov\regeprov.h ===
/*++

Copyright (C) 1996-2001 Microsoft Corporation

Module Name:

    REGEPROV.H

Abstract:

History:

--*/

#ifndef __WBEM_REG_EVENT_PROVIDER__H_
#define __WBEM_REG_EVENT_PROVIDER__H_

#include <windows.h>
#include <wbemidl.h>
#include <stdio.h>
#include "regereq.h"
#include <ql.h>
#include "cfdyn.h"

class CRegEventProvider : public IWbemEventProvider, 
                            public IWbemEventProviderQuerySink,
                            public IWbemEventProviderSecurity,
                            public IWbemProviderInit
{
public:
    STDMETHOD(QueryInterface)(REFIID riid, void** ppv);
    STDMETHOD_(ULONG, AddRef)();
    STDMETHOD_(ULONG, Release)();

    STDMETHOD(Initialize)(LPWSTR wszUser, long lFlags, LPWSTR wszNamespace,
        LPWSTR wszLocale, IWbemServices* pNamespace, IWbemContext* pCtx,
        IWbemProviderInitSink* pSink);
    STDMETHOD(ProvideEvents)(IWbemObjectSink* pSink, long lFlags);

    STDMETHOD(NewQuery)(DWORD dwId, WBEM_WSTR wszLanguage, WBEM_WSTR wszQuery);
    STDMETHOD(CancelQuery)(DWORD dwId);
    STDMETHOD(AccessCheck)(WBEM_CWSTR wszLanguage, WBEM_CWSTR wszQuery, 
                                long lSidLength, const BYTE* aSid);

	static VOID CALLBACK EnqueueEvent(PVOID lpParameter,        
										BOOLEAN TimerOrWaitFired);

	void EnqueueEvent(CRegistryEventRequest *pReq);

protected:
    long m_lRef;

    IWbemClassObject* m_pKeyClass;
    IWbemClassObject* m_pValueClass;
    IWbemClassObject* m_pTreeClass;

    DWORD m_dwId;
    HANDLE m_hThread;
    IWbemObjectSink* m_pSink;

    CRefedPointerArray<CRegistryEventRequest> m_apRequests;
    CCritSec m_cs;

    HANDLE m_hQueueSemaphore;
    CCritSec m_csQueueLock;
    CRefedPointerQueue<CRegistryEventRequest> m_qEventQueue;

protected:
    static DWORD Worker(void* p);

    HRESULT GetValuesForProp(QL_LEVEL_1_RPN_EXPRESSION* pExpr,
                            CPropertyName& PropName, CWStringArray& awsVals);
    HKEY TranslateHiveName(LPCWSTR wszName);
    HRESULT AddRequest(CRegistryEventRequest* pNewReq);
	void KillWorker();
	void CreateWorker();

    friend class CRegistryEventRequest;
    friend class CRegistryKeyEventRequest;
    friend class CRegistryValueEventRequest;
    friend class CRegistryTreeEventRequest;
    
public:
    CRegEventProvider();
    ~CRegEventProvider();

    void* GetInterface(REFIID riid);

    HRESULT RaiseEvent(IWbemClassObject* pEvent);
};

extern const CLSID CLSID_RegistryEventProvider;

class CRegEventProviderFactory : public CCFDyn
{
public:
    IUnknown* CreateImpObj();
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\winmgmt\stdprov\regereq.h ===
/*++

Copyright (C) 1996-2001 Microsoft Corporation

Module Name:

    REGEREQ.H

Abstract:

History:

--*/

#ifndef __WBEM_REGEVENT_REQUEST__H_
#define __WBEM_REGEVENT_REQUEST__H_

#include <windows.h>
#include <stdio.h>
#include <wbemidl.h>
#include "CWbemTime.h"
#include <tss.h>
#include <ql.h>
#include <wbemcomn.h>
#include "regedefs.h"



class CRegEventProvider;
class CRegistryEventRequest;

class CRegistryEventRequest
{
protected:
    long m_lRef;
    BOOL m_bOK;

    CRegEventProvider* m_pProvider;
    DWORD m_dwMsWait;

    CFlexArray m_adwIds;

    HKEY m_hHive;
    WString m_wsHive;
    WString m_wsKey;

    HKEY m_hKey;
    HANDLE m_hEvent;
    DWORD m_dwLastCRC;
    long m_lActiveCount;
    BOOL m_bNew;

	HANDLE m_hWaitRegistration;
	CCritSec m_cs;

public:
    CRegistryEventRequest(CRegEventProvider* pProvider, 
                          WBEM_QL1_TOLERANCE& Tolerance, DWORD dwId, 
                          HKEY hHive, LPWSTR wszHive, LPWSTR wszKey);
    virtual ~CRegistryEventRequest();
    BOOL IsOK() {return m_bOK;}
    BOOL IsActive() {return m_lActiveCount >= 0;}
    DWORD GetPrimaryId();
    BOOL DoesContainId(DWORD dwId);
    BOOL IsNew() {return m_bNew;}
	CRegEventProvider* GetProvider() { return m_pProvider; }
    void AddRef();
    void Release();

    DWORD GetMsWait() {return m_dwMsWait;}

    HRESULT Activate();
    HRESULT Reactivate(DWORD dwId, DWORD dwMsWait);
    HRESULT Deactivate(DWORD dwId);
    HRESULT ForceDeactivate(void);
    virtual HRESULT Execute(BOOL bOnTimer);
    HANDLE GetOnChangeHandle();
    BOOL ResetOnChangeHandle();
    virtual void CacheValue(){}

    virtual int GetType() = 0;
    virtual HRESULT CreateNewEvent(IWbemClassObject** ppEvent) = 0;
    virtual HRESULT ComputeCRC(DWORD& dwCRC) = 0;

    virtual BOOL IsSameAs(CRegistryEventRequest* pOther);

	void ProcessEvent();

protected:
    HRESULT SetCommonProperties(IWbemClassObject* pEvent);
};


class CRegistryValueEventRequest : public CRegistryEventRequest
{
protected:

    WString m_wsValue;

public:
    CRegistryValueEventRequest(CRegEventProvider* pProvider, 
                          WBEM_QL1_TOLERANCE& Tolerance, DWORD dwId, HKEY hHive,
                          LPWSTR wszHive, LPWSTR wszKey, LPWSTR wszValue)
         : CRegistryEventRequest(pProvider, Tolerance, dwId, hHive, 
                                    wszHive, wszKey), m_wsValue(wszValue)
    {}

    int GetType() {return e_RegValueChange;}
    HRESULT CreateNewEvent(IWbemClassObject** ppEvent);
    HRESULT ComputeCRC(DWORD& dwCRC);
    virtual HRESULT Execute(BOOL bOnTimer);
    virtual void CacheValue();
    BOOL IsSameAs(CRegistryEventRequest* pOther);
};

class CRegistryKeyEventRequest : public CRegistryEventRequest
{
public:
    CRegistryKeyEventRequest(CRegEventProvider* pProvider, 
                          WBEM_QL1_TOLERANCE& Tolerance, DWORD dwId, HKEY hHive,
                          LPWSTR wszHive, LPWSTR wszKey)
         : CRegistryEventRequest(pProvider, Tolerance, dwId, hHive, 
                                    wszHive, wszKey)
    {}

    int GetType() {return e_RegKeyChange;}
    HRESULT CreateNewEvent(IWbemClassObject** ppEvent);
    HRESULT ComputeCRC(DWORD& dwCRC);
};

class CRegistryTreeEventRequest : public CRegistryEventRequest
{
public:
    CRegistryTreeEventRequest(CRegEventProvider* pProvider, 
                          WBEM_QL1_TOLERANCE& Tolerance, DWORD dwId, HKEY hHive,
                          LPWSTR wszHive, LPWSTR wszKey)
         : CRegistryEventRequest(pProvider, Tolerance, dwId, hHive, 
                                    wszHive, wszKey)
    {}

    int GetType() {return e_RegTreeChange;}
    HRESULT CreateNewEvent(IWbemClassObject** ppEvent);
    HRESULT ComputeCRC(DWORD& dwCRC);
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\winmgmt\stdprov\regereq.cpp ===
/*++

Copyright (C) 1996-2001 Microsoft Corporation

Module Name:

    REGEREQ.CPP

Abstract:

History:

--*/

#include "precomp.h"
#include "regereq.h"
#include "regcrc.h"
#include <genutils.h>
#include "regeprov.h"

//******************************************************************************
//******************************************************************************
//
//                      GENERIC REQUEST
//
//******************************************************************************
//******************************************************************************



CRegistryEventRequest::CRegistryEventRequest(CRegEventProvider* pProvider,
                                    WBEM_QL1_TOLERANCE& Tolerance, 
                                    DWORD dwId, HKEY hHive, LPWSTR wszHive,
                                    LPWSTR wszKey)
    : m_hHive(hHive), m_wsKey(wszKey), m_pProvider(pProvider),
      m_wsHive(wszHive), m_lActiveCount(0), m_bNew(TRUE),
      m_lRef(0), m_bOK(TRUE), m_dwLastCRC(0), m_hKey(NULL), m_hEvent(NULL),
      m_hWaitRegistration(NULL)
{
    if(Tolerance.m_bExact)
    {
        m_dwMsWait = 0;
    }
    else
    {
        m_dwMsWait = Tolerance.m_fTolerance * 1000;
    }

    if ( CFlexArray::no_error != m_adwIds.Add(ULongToPtr(dwId)) )
    {
        throw CX_MemoryException( );
    }
}

CRegistryEventRequest::~CRegistryEventRequest()
{
    if (m_hKey)
    {
        RegCloseKey(m_hKey);
    }
    
    if(m_hEvent)
    {
        CloseHandle(m_hEvent);
    }
}

void CRegistryEventRequest::AddRef()
{
    InterlockedIncrement(&m_lRef);
}

void CRegistryEventRequest::Release()
{
    if(InterlockedDecrement(&m_lRef) == 0) delete this;
}

BOOL CRegistryEventRequest::IsSameAs(CRegistryEventRequest* pOther)
{
    if(GetType() != pOther->GetType())
        return FALSE;

    if(m_hHive != pOther->m_hHive)
        return FALSE;

    if(!m_wsHive.EqualNoCase(pOther->m_wsHive))
        return FALSE;

    if(!m_wsKey.EqualNoCase(pOther->m_wsKey))
        return FALSE;

    return TRUE;
}


DWORD CRegistryEventRequest::GetPrimaryId()
{
    return PtrToLong(m_adwIds[0]);
}

BOOL CRegistryEventRequest::DoesContainId(DWORD dwId)
{
	// not called

    for(int i = 0; i < m_adwIds.Size(); i++)
    {
        if(PtrToLong(m_adwIds[i]) == dwId)
            return TRUE;
    }
    return FALSE;
}

HRESULT CRegistryEventRequest::Reactivate(DWORD dwId, DWORD dwMsWait)
{
	// This is only called on active objects.

	CInCritSec ics(&m_cs);

    if(m_dwMsWait > dwMsWait)
        m_dwMsWait = dwMsWait;

    m_adwIds.Add(ULongToPtr(dwId));

	InterlockedIncrement(&m_lActiveCount);

	return WBEM_S_NO_ERROR;
}

HRESULT CRegistryEventRequest::Activate()
{
    // This function doesn't need to enter a critical section
    // for the reasons explained in the following argument. 
    // This reasoning might be invalidated by design changes.
    
    // This is only called on new objects before they are added
    // to the active request array.
    
    // Since all the independent COM client threads get access 
    // to these objects through that array, this object is locked to
    // all threads but the current one.
    
    // Once RegisterWaitForSingleObject is called this object is registered
    // with the thread pool but it won't be accessed because no events will
    // occur until ResetOnChangeHandle is called by the worker thread.
    
    // When m_pProvider->EnqueueEvent(this) is called then the worker thread
    // has access to the object. At this point there is nothing left to do 
    // but return.
    
    // Open the key
    // ============

#ifdef UNICODE
    long lRes = RegOpenKeyEx(m_hHive, m_wsKey, 0, KEY_READ, &m_hKey);
#else
    LPSTR szName = m_wsKey.GetLPSTR();
    long lRes = RegOpenKeyEx(m_hHive, szName, 0, KEY_READ, &m_hKey);
    delete [] szName;
#endif

    if(lRes)
    {
        return WBEM_E_INVALID_PARAMETER;
    }

    // Create an event
    // ===============

    m_hEvent = CreateEvent(NULL,	// lpEventAttributes
                           FALSE,	// bManualReset
                           FALSE,	// bInitialState
                           NULL);	// lpName
    
    if ( m_hEvent == NULL )
        return WBEM_E_OUT_OF_MEMORY;

    if ( !RegisterWaitForSingleObject(
        &m_hWaitRegistration,	// phNewWaitObject
        m_hEvent,				// hObject
        CRegEventProvider::EnqueueEvent, // Callback
        this,					// Context
        INFINITE,				// dwMilliseconds
        WT_EXECUTEINWAITTHREAD) ) // dwFlags
    {
        return HRESULT_FROM_WIN32( GetLastError() );
    }
    
    // This represents the thread pool's reference.
    
    AddRef();

    // It will be connected to the key by the worker thread
    // because when the thread that calls RegNotifyChangeKeyValue
    // exits the event is signaled. Therefore if this thread called
    // RegNotifyChangeKeyValue then we would get a spurious event when
    // this thread exits. When the worker thread exits all the event
    // subscriptions will have already been cancelled.
    // ==========================================================

    m_bNew = TRUE;

    CacheValue();

    m_pProvider->EnqueueEvent(this);

    return S_OK;
}

BOOL CRegistryEventRequest::ResetOnChangeHandle()
{
	// This is only called from ProcessEvent which has already
	// acquired the lock.

    m_bNew = FALSE;

    long lRes = RegNotifyChangeKeyValue(
							m_hKey,							// hKey
							(GetType() == e_RegTreeChange), // bWatchSubtree
							REG_NOTIFY_CHANGE_NAME | 
							REG_NOTIFY_CHANGE_LAST_SET | 
							REG_NOTIFY_CHANGE_ATTRIBUTES,	// dwNotifyFilter
							m_hEvent,						// hEvent
							TRUE);							// fAsynchronous
    return (lRes == 0);
}

HANDLE CRegistryEventRequest::GetOnChangeHandle() 
{
	// not called

    return m_hEvent;
}

HRESULT CRegistryEventRequest::Deactivate(DWORD dwId)
{
	CInCritSec ics(&m_cs);

    // Remove the ID from the list
    // ===========================

	bool bFoundId = false;
	int nIdCount = m_adwIds.Size();

    for(int i = 0; i < nIdCount; i++)
    {
        if(PtrToLong(m_adwIds[i]) == dwId)
        {
            m_adwIds.RemoveAt(i);
			bFoundId = true;
			break;
        }
    }

    if(!bFoundId || (InterlockedDecrement(&m_lActiveCount) >= 0))
        return WBEM_S_FALSE;

	// Unregister the event with the thread pool and wait for
	// pending requests to be processed.

	// We wait because this object could be released and deleted when this
	// function returns which would mean the thread pool holds an invalid
	// pointer.

	// When the thread pool processes a request it places it in the worker thread
	// queue which AddRefs the request.

	UnregisterWaitEx(m_hWaitRegistration,		// WaitHandle
						INVALID_HANDLE_VALUE);	// CompletionEvent

	m_hWaitRegistration = NULL;

	// This will signal m_hEvent but we just unregistered it
	// so nobody is waiting on it.

	RegCloseKey(m_hKey);
	m_hKey = 0;

	CloseHandle(m_hEvent);
	m_hEvent = 0;

	// The thread pool no longer holds a reference 
	// so call Release on its behalf.

	Release();

    return S_OK;
}

HRESULT CRegistryEventRequest::ForceDeactivate(void)
{
    CInCritSec ics(&m_cs);

	// deactivate the event request

    InterlockedExchange(&m_lActiveCount, -1);

    // Remove all IDs from the list

    int nIdCount = m_adwIds.Size();

	m_adwIds.Empty();

    // Unregister the event with the thread pool and wait for
    // pending requests to be processed.

    // We wait because this object could be released and deleted when this
    // function returns which would mean the thread pool holds an invalid
    // pointer.

    // When the thread pool processes a request it places it in the worker thread
    // queue which AddRefs the request.

    UnregisterWaitEx(m_hWaitRegistration,       // WaitHandle
                        INVALID_HANDLE_VALUE);  // CompletionEvent

    m_hWaitRegistration = NULL;

    // This will signal m_hEvent but we just unregistered it
    // so nobody is waiting on it.

    RegCloseKey(m_hKey);
    m_hKey = 0;

    CloseHandle(m_hEvent);
    m_hEvent = 0;

    // The thread pool no longer holds a reference
    // so call Release on its behalf.

    Release();

    return S_OK;
}

HRESULT CRegistryEventRequest::Execute(BOOL bOnTimer)
{
    // If called by the timer, we need to check if anything actually changed
    // =====================================================================

    if(bOnTimer || GetType() == e_RegValueChange)
    {
        DWORD dwNewCRC;
        HRESULT hres = ComputeCRC(dwNewCRC);
        if(FAILED(hres))
        {
            return hres;
        }
        if(dwNewCRC == m_dwLastCRC)
        {
            // No real change. Return
            // ======================

            return S_FALSE;
        }

        m_dwLastCRC = dwNewCRC;
    }

    // If here, a real change has occurred
    // ===================================

    IWbemClassObject* pEvent;

    HRESULT hres = CreateNewEvent(&pEvent);
    if(FAILED(hres))
    {
        return hres;
    }

    hres = m_pProvider->RaiseEvent(pEvent);
    pEvent->Release();
    return hres;
}

HRESULT CRegistryEventRequest::SetCommonProperties(IWbemClassObject* pEvent)
{
    // Set the hive name
    // =================

    VARIANT v;
    VariantInit(&v);
    V_VT(&v) = VT_BSTR;
    V_BSTR(&v) = SysAllocString(m_wsHive);
    pEvent->Put(REG_HIVE_PROPERTY_NAME, 0, &v, NULL);
    VariantClear(&v);

    return WBEM_S_NO_ERROR;
}

void CRegistryEventRequest::ProcessEvent()
{
	CInCritSec ics(&m_cs);

	if(IsActive())
    {
		// New requests are immediately queued in order for the worker
		// thread to initialize them. They don't represent actual events.

		// We need to save the new status because ResetOnChangeHandle 
		// erases it.

		BOOL bIsNew = IsNew();
		
        ResetOnChangeHandle();

		if (!bIsNew)
		{
			Execute(FALSE);
		}
    }
}

//******************************************************************************
//******************************************************************************
//
//                          VALUE REQUEST
//
//******************************************************************************
//******************************************************************************

HRESULT CRegistryValueEventRequest::CreateNewEvent(IWbemClassObject** ppEvent)
{
    *ppEvent = NULL;
    
    // Create an instance
    // ==================

    IWbemClassObject* pEvent;
    if ( FAILED(m_pProvider->m_pValueClass->SpawnInstance(0, &pEvent)))
    	return WBEM_E_OUT_OF_MEMORY;

    // Set the hive property
    // =====================

    SetCommonProperties(pEvent);

    // Set the key
    // ===========

    VARIANT v;
    VariantInit(&v);
    V_VT(&v) = VT_BSTR;
    V_BSTR(&v) = SysAllocString(m_wsKey);
    pEvent->Put(REG_KEY_PROPERTY_NAME, 0, &v, NULL);
    VariantClear(&v);

    // Set the value
    // =============

    V_VT(&v) = VT_BSTR;
    V_BSTR(&v) = SysAllocString(m_wsValue);
    pEvent->Put(REG_VALUE_PROPERTY_NAME, 0, &v, NULL);
    VariantClear(&v);

    *ppEvent = pEvent;
    return WBEM_S_NO_ERROR;
}

HRESULT CRegistryValueEventRequest::ComputeCRC(DWORD& dwCRC)
{
#ifdef UNICODE
    HRESULT hres = CRegCRC::ComputeValueCRC(m_hKey, m_wsValue, 
                        STARTING_CRC32_VALUE, dwCRC);
#else
    LPSTR szValue = m_wsValue.GetLPSTR();
    HRESULT hres = CRegCRC::ComputeValueCRC(m_hKey, szValue, 
                        STARTING_CRC32_VALUE, dwCRC);
    delete [] szValue;
#endif
    return hres;
}

HRESULT CRegistryValueEventRequest::Execute(BOOL bOnTimer)
{
    // Since NT does not allow per-value change registration, CRC needs to be
    // computed no matter what
    // ======================================================================

    return CRegistryEventRequest::Execute(TRUE);
}

void CRegistryValueEventRequest::CacheValue()
{
    ComputeCRC(m_dwLastCRC);
}

BOOL CRegistryValueEventRequest::IsSameAs(CRegistryEventRequest* pOther)
{
    if(!CRegistryEventRequest::IsSameAs(pOther))
        return FALSE;

    CRegistryValueEventRequest* pValueOther = 
        (CRegistryValueEventRequest*)pOther;

    if(!m_wsValue.EqualNoCase(pValueOther->m_wsValue))
        return FALSE;

    return TRUE;
}

    
//******************************************************************************
//******************************************************************************
//
//                          KEY REQUEST
//
//******************************************************************************
//******************************************************************************

HRESULT CRegistryKeyEventRequest::CreateNewEvent(IWbemClassObject** ppEvent)
{
    *ppEvent = NULL;
    
    // Create an instance
    // ==================

    IWbemClassObject* pEvent;
    if ( FAILED(m_pProvider->m_pKeyClass->SpawnInstance(0, &pEvent) ) )
    	return WBEM_E_OUT_OF_MEMORY;

    // Set the hive property
    // =====================

    SetCommonProperties(pEvent);

    // Set the key
    // ===========

    VARIANT v;
    VariantInit(&v);
    V_VT(&v) = VT_BSTR;
    V_BSTR(&v) = SysAllocString(m_wsKey);
    pEvent->Put(REG_KEY_PROPERTY_NAME, 0, &v, NULL);
    VariantClear(&v);

    *ppEvent = pEvent;
    return WBEM_S_NO_ERROR;
}

HRESULT CRegistryKeyEventRequest::ComputeCRC(DWORD& dwCRC)
{
    HRESULT hres = CRegCRC::ComputeKeyCRC(m_hKey, STARTING_CRC32_VALUE, dwCRC);
    return hres;
}
    
//******************************************************************************
//******************************************************************************
//
//                          TREE REQUEST
//
//******************************************************************************
//******************************************************************************

HRESULT CRegistryTreeEventRequest::CreateNewEvent(IWbemClassObject** ppEvent)
{
    *ppEvent = NULL;
    
    // Create an instance
    // ==================

    IWbemClassObject* pEvent;
    if ( FAILED(m_pProvider->m_pTreeClass->SpawnInstance(0, &pEvent) ) )
    	return WBEM_E_OUT_OF_MEMORY;

    // Set the hive property
    // =====================

    SetCommonProperties(pEvent);

    // Set the root
    // ============

    VARIANT v;
    VariantInit(&v);
    V_VT(&v) = VT_BSTR;
    V_BSTR(&v) = SysAllocString(m_wsKey);
    pEvent->Put(REG_ROOT_PROPERTY_NAME, 0, &v, NULL);
    VariantClear(&v);

    *ppEvent = pEvent;
    return WBEM_S_NO_ERROR;
}

HRESULT CRegistryTreeEventRequest::ComputeCRC(DWORD& dwCRC)
{
    HRESULT hres = CRegCRC::ComputeTreeCRC(m_hKey, STARTING_CRC32_VALUE, dwCRC);
    return hres;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\winmgmt\stdprov\resource.h ===
/*++

Copyright (C) 1997-2001 Microsoft Corporation

Module Name:

    RESOURCE.H

Abstract:

	defiines stuff in the resource file

History:

	a-davj  04-Mar-97   Created.

--*/

//{{NO_DEPENDENCIES}}
// Microsoft Visual C++ generated include file.
// Used by SERVER2.RC
//

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS

#define _APS_NEXT_RESOURCE_VALUE        129
#define _APS_NEXT_COMMAND_VALUE         32771
#define _APS_NEXT_CONTROL_VALUE         1000
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\winmgmt\stdprov\regprov.h ===
/*++

Copyright (C) 1997-2001 Microsoft Corporation

Module Name:

    REGPROV.H

Abstract:

	Defines the guids for the registry provider.

History:

	a-davj  04-Mar-97   Created.

--*/

#ifndef _regprov_H_
#define _regprov_H_

DEFINE_GUID(LIBID_SAMPLEMO,0x8B26C640L,0xE46F,0x11CE,0xA5,0xB6,0x00,0xAA,0x00,0x68,0x0C,0x3F);

DEFINE_GUID(CLSID_RegProvider,0xFE9AF5C0L,0xD3B6,0x11CE,0xA5,0xB6,0x00,0xAA,0x00,0x68,0x0C,0x3F);

// {72967901-68EC-11d0-B729-00AA0062CBB7}
DEFINE_GUID(CLSID_RegPropProv, 
0x72967901, 0x68ec, 0x11d0, 0xb7, 0x29, 0x0, 0xaa, 0x0, 0x62, 0xcb, 0xb7);


// {AA2B1081-EC0B-11d0-9E4D-00C04FC324A8}
DEFINE_GUID(CLSID_RegEventCallback, 
0xaa2b1081, 0xec0b, 0x11d0, 0x9e, 0x4d, 0x0, 0xc0, 0x4f, 0xc3, 0x24, 0xa8);

class AutoProfile
{
    public:
        AutoProfile();
        ~AutoProfile();
        HRESULT LoadProfile(HKEY &  hRoot);
        
    private:
        BOOL m_bLoaded;
        HANDLE m_hToken;
        HKEY  m_hRoot;
};

#ifdef __cplusplus
class RegProvider;
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\winmgmt\stdprov\stdafx.h ===
/*++

Copyright (C) 1997-2001 Microsoft Corporation

Module Name:

    STDAFX.H

Abstract:

	include file for standard system include files,
	or project specific include files that are used frequently, but
	are changed infrequently

History:

	a-davj  04-Mar-97   Created.

--*/

#include <afxwin.h>         // MFC core and standard components
#include <afxext.h>         // MFC extensions
#include <afxole.h>         // MFC OLE classes
#include <afxodlgs.h>       // MFC OLE dialog classes
#include <afxdisp.h>        // MFC OLE automation classes
#include <afxdb.h>          // MFC database classes
#include "stdprov.h"

#undef PURE
#define PURE {return (unsigned long)E_NOTIMPL;}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\winmgmt\stdprov\regmethods.cpp ===
/*++

Copyright (C) 1998-2001 Microsoft Corporation

Module Name:

    REGMETHODS.CPP

Abstract:

	Purpose: Implements the registry provider methods.

History:

--*/

#include "precomp.h"
#include "perfprov.h"
#include "cvariant.h"
#include "provreg.h"
#include "reg.h"
#include "genutils.h"
#include <cominit.h>
#include <arrtempl.h>
#include <userenv.h>
#include <lmcons.h>
enum StringType{SIMPLE, EXPANDED};

AutoProfile::AutoProfile() : m_bLoaded(FALSE), m_hToken(NULL),
    m_hRoot(NULL)
{
}
AutoProfile::~AutoProfile()
{
    if(m_bLoaded)
    {
        UnloadUserProfile(m_hToken, m_hRoot);
    }
    if(m_hToken != NULL)
        CloseHandle(m_hToken);
}

HRESULT AutoProfile::LoadProfile(HKEY &  hRoot)
{
    PROFILEINFO pi;
    HRESULT hr;
    // If the profile is already loaded, there is no need to do it

    DWORD dwFlags, dwLastError;
    if(GetProfileType(&dwFlags))
    {
        hRoot = HKEY_CURRENT_USER;
        return S_OK;
    }
    memset((void *)&pi, 0, sizeof(pi));
    pi.dwSize = sizeof(pi);

    BOOL bRes;
    bRes = OpenThreadToken(GetCurrentThread(), 
                TOKEN_IMPERSONATE | TOKEN_DUPLICATE | TOKEN_QUERY, 
                                                TRUE, &m_hToken); 
    if(!bRes)
        return WBEM_E_FAILED;
    
    TCHAR cUsername[UNLEN + 1];
    cUsername[0] = 0;
    DWORD dwSize = UNLEN + 1;
    BOOL bRet = GetUserName(cUsername, &dwSize);
    if(!bRet)
        return WBEM_E_FAILED;
    pi.lpUserName = cUsername;
    pi.dwFlags = 1;
    CoRevertToSelf();
    bRet = LoadUserProfile(m_hToken, &pi);
    if(bRet == 0)
    {
        hRoot = NULL;
        dwLastError = GetLastError();
        HRESULT hr2 = CoImpersonateClient();
        if(FAILED(hr2))
                ERRORTRACE((LOG_STDPROV, "Registry event provider unable "
                    "to CoImpersonateClient hr2= 0x%x.\n", hr2));
            
        if(dwLastError == ERROR_ACCESS_DENIED ||dwLastError ==  ERROR_PRIVILEGE_NOT_HELD)
            hr = WBEM_E_ACCESS_DENIED;
        else
            hr = WBEM_E_FAILED;        
    }
    else
    {
        hr = CoImpersonateClient();
        m_bLoaded = TRUE;
        m_hRoot = (HKEY)pi.hProfile;
        hRoot = (HKEY)pi.hProfile;
    }
    return hr;
}
        
void CopyOrConvert(TCHAR * pTo, WCHAR * pFrom, int iLen)
{ 
#ifdef UNICODE
    wcsncpy(pTo, pFrom,iLen);
#else
    wcstombs(pTo, pFrom, iLen);
#endif
    pTo[iLen-1] = 0;
    return;
}
BSTR GetBSTR(TCHAR * pIn)
{
#ifdef UNICODE 
    return SysAllocString(pIn);
#else
    int iBuffLen = lstrlen(pIn)+1;
    WCHAR * pTemp = new WCHAR[iBuffLen];
    if(pTemp == NULL)
        return NULL;
    mbstowcs(pTemp, pIn, iBuffLen);
    BSTR bRet = SysAllocString(pTemp);
    delete []pTemp;
    return bRet;
#endif
}

BOOL IsTypeMismatch(Registry & reg, TCHAR * pValueName, DWORD dwExpectedType)
{
    DWORD dwType;
    long lRet = reg.GetType(pValueName, &dwType);
    if(lRet == ERROR_SUCCESS && dwExpectedType != dwType)
        return TRUE;
    else
        return FALSE;
}

//***************************************************************************
//
//  HRESULT SetStatusAndReturnOK;
//
//  Purpose: Sets the status code in the sink.
//
//***************************************************************************

HRESULT SetStatusAndReturnOK(SCODE sc, IWbemObjectSink* pSink)
{
    pSink->SetStatus(0,sc, NULL, NULL);
    return S_OK;
}

//***************************************************************************
//
//  SAFEARRAY FAR* MySafeArrayCreate
//
//  Purpose:  Creates a safearray.
//
//  Return:  pointer to safearray, NULL if error.
//
//***************************************************************************

SAFEARRAY FAR* MySafeArrayCreate(long lNumElement, VARTYPE vt)
{

    SAFEARRAYBOUND rgsabound[1];    
    rgsabound[0].lLbound = 0;
    rgsabound[0].cElements = lNumElement;
    return SafeArrayCreate( vt, 1 , rgsabound );
}

//***************************************************************************
//
//  bool GetInArgString
//
//  Purpose:  Reads a string argument from the input object and puts it into
//  a value allocated by the caller.
//
//  Return:  true if OK.
//
//***************************************************************************

TCHAR * GetInArgString(IWbemClassObject* pInParams, WCHAR * pwcName)
{
    TCHAR * pOut = NULL;
    if(pInParams == NULL || pwcName == NULL)
        return NULL;
    VARIANT var;
    VariantInit(&var);
    SCODE sc = pInParams->Get(pwcName, 0, &var, NULL, NULL);   
    if(sc == S_OK && var.vt == VT_BSTR)
    {
        DWORD dwLen = wcslen(var.bstrVal) + 1;
        pOut = new TCHAR[dwLen];
        if(pOut)
            StringCchCopyW(pOut, dwLen, var.bstrVal);
    }
    VariantClear(&var);
    return pOut;
}


//***************************************************************************
//
//  SCODE EnumKey
//
//  Purpose:  Enumerate the subkeys and loads them into the output arguments.
//
//  Return:  error code or 0 if OK.
//
//***************************************************************************

SCODE EnumKey(HKEY hRoot, TCHAR * cSubKey, IWbemClassObject* pOutParams)
{
    SCODE sc;
    DWORD dwNumSubKeys, dwMaxSubKeyLen, dwNumValues, dwMaxValueNameLen;
    TCHAR * pcTemp = NULL;
    
    // Open the key

    HKEY hKey;
    long lRet = RegOpenKeyEx(hRoot, cSubKey, 0, KEY_ENUMERATE_SUB_KEYS|KEY_QUERY_VALUE , &hKey);
    if(lRet != ERROR_SUCCESS)
        return lRet;
    CRegCloseMe cm(hKey);
    
    // Count the number of keys and the max size

    lRet = RegQueryInfoKey(hKey, NULL, NULL, NULL,
                &dwNumSubKeys,             // number of subkeys
                &dwMaxSubKeyLen,        // longest subkey name
                NULL,         
                &dwNumValues,              // number of value entries
                &dwMaxValueNameLen,     // longest value name
                NULL, NULL, NULL);

    if(lRet != ERROR_SUCCESS || dwMaxSubKeyLen == 0)
        return lRet;

    pcTemp = new TCHAR[dwMaxSubKeyLen+1];
    if(pcTemp == NULL)
        return WBEM_E_OUT_OF_MEMORY;

    CVectorDeleteMe<TCHAR> dm(pcTemp);

    // Create the safe array for returning the data

    SAFEARRAY FAR* psa = MySafeArrayCreate(dwNumSubKeys, VT_BSTR);
    if(psa == NULL)
    {
        return WBEM_E_OUT_OF_MEMORY;
    }

    // Put each value name into the array

    for(long lTry = 0; lTry < dwNumSubKeys; lTry++)
    {
        lRet = RegEnumKey(hKey, lTry, pcTemp, dwMaxSubKeyLen+1);
        if(lRet == ERROR_SUCCESS)
        {
            pcTemp[dwMaxSubKeyLen] = 0;
            BSTR bstr = GetBSTR(pcTemp);
            if(bstr)
            {
                sc = SafeArrayPutElement(psa, &lTry, bstr);
                SysFreeString(bstr);
                if(FAILED(sc))
                {
                    SafeArrayDestroy(psa);
                    return sc;
                }
            }
        }
    }

	// Write the data back!

    VARIANT var;
    var.vt = VT_BSTR | VT_ARRAY;
    var.parray = psa;
    sc = pOutParams->Put( L"sNames", 0, &var, 0);      
    VariantClear(&var);
    return sc;
}

//***************************************************************************
//
//  SCODE EnumValue
//
//  Purpose:  Enumerates the value names and types and puts the results into
//  the output object.
//
//  Return:  error code or 0 if OK.
//
//***************************************************************************

SCODE EnumValue(HKEY hRoot, TCHAR * cSubKey, IWbemClassObject* pOutParams)
{
    SCODE sc1, sc2;
    DWORD dwNumSubKeys, dwMaxSubKeyLen, dwNumValues, dwMaxValueNameLen;
    TCHAR * pcTemp = NULL;
    DWORD dwType, dwSize;

    // Open the registry key

    HKEY hKey;
    long lRet = RegOpenKeyEx((HKEY)hRoot, cSubKey, 0, KEY_QUERY_VALUE, &hKey);
    if(lRet != ERROR_SUCCESS)
        return lRet;
   CRegCloseMe cm(hKey);

	// Count the number of values and the max size

    lRet = RegQueryInfoKey(hKey, NULL, NULL, NULL,
                &dwNumSubKeys,             // number of subkeys
                &dwMaxSubKeyLen,        // longest subkey name
                NULL,         
                &dwNumValues,              // number of value entries
                &dwMaxValueNameLen,     // longest value name
                NULL, NULL, NULL);

	if(lRet != ERROR_SUCCESS || dwMaxValueNameLen == 0)
		return lRet;

    pcTemp = new TCHAR[dwMaxValueNameLen+1];
    if(pcTemp == NULL)
        return WBEM_E_OUT_OF_MEMORY;

    CVectorDeleteMe<TCHAR> dm(pcTemp);
    
	// Create safe arrays for the data names and types

    SAFEARRAY FAR* psaNames = MySafeArrayCreate(dwNumValues, VT_BSTR);
	if(psaNames == NULL)
	{
		return WBEM_E_OUT_OF_MEMORY;
	}
    SAFEARRAY FAR* psaTypes = MySafeArrayCreate(dwNumValues, VT_I4);
	if(psaTypes == NULL)
	{
		SafeArrayDestroy(psaNames);
		return WBEM_E_OUT_OF_MEMORY;
	}

	// Fill in the arrays

    for(long lTry = 0; lTry < dwNumValues; lTry++)
    {
        dwSize = dwMaxValueNameLen+1;
        lRet = RegEnumValue(hKey, lTry, pcTemp, &dwSize, 0, &dwType, NULL, 0);
        if(lRet == ERROR_SUCCESS)
        {
            pcTemp[dwMaxValueNameLen] = 0;
            BSTR bstr = GetBSTR(pcTemp);
            if(bstr)
            {
                sc1 = SafeArrayPutElement(psaNames, &lTry, bstr);
                sc2 = SafeArrayPutElement(psaTypes, &lTry, &dwType);
                SysFreeString(bstr);
                if(FAILED(sc1) || FAILED(sc2))
                {
                    SafeArrayDestroy(psaNames);
                    SafeArrayDestroy(psaTypes);
                    return WBEM_E_OUT_OF_MEMORY;
                }
            }
        }
    }

	// Put the arrays containing the value names and types into the output object

    VARIANT var;
    var.vt = VT_BSTR | VT_ARRAY;
    var.parray = psaNames;
    pOutParams->Put( L"sNames", 0, &var, 0);
    VariantClear(&var);

    var.vt = VT_I4 | VT_ARRAY;
    var.parray = psaTypes;
    SCODE sc = pOutParams->Put( L"Types", 0, &var, 0);      
    VariantClear(&var);
    return sc;
}

//***************************************************************************
//
//  SCODE GetStr
//
//  Purpose:  Reads a string and puts it into the output argument.  Note that
//  this works with either normal strings or expanded registry strings.
//
//  Return:  error code or 0 if OK.
//
//***************************************************************************

SCODE GetStr(HKEY hRoot, TCHAR * cSubKey, TCHAR * cValueName, IWbemClassObject* pOutParams)
{
	Registry reg(hRoot, KEY_QUERY_VALUE, (TCHAR *)cSubKey);
	long lRet = reg.GetLastError();
	if(lRet != ERROR_SUCCESS)
		return lRet;

    // Get the string

	TCHAR * pcValue;
	lRet = reg.GetStr(cValueName, &pcValue);
	if(lRet != ERROR_SUCCESS)
    {
        DWORD dwType;
        long lRet2 = reg.GetType(cValueName, &dwType);
        if(lRet2 == ERROR_SUCCESS && dwType != REG_SZ && dwType != REG_EXPAND_SZ)
            return WBEM_E_TYPE_MISMATCH;
		return lRet;
    }
    CDeleteMe<TCHAR> dm(pcValue);

	VARIANT var;
    var.bstrVal = GetBSTR(pcValue);
	var.vt = VT_BSTR;
	if(var.bstrVal == NULL)
		return WBEM_E_OUT_OF_MEMORY;

	lRet = pOutParams->Put( L"sValue", 0, &var, 0);
	VariantClear(&var);
	return lRet;
}

//***************************************************************************
//
//  SCODE SetMultiStrValue
//
//  Purpose:  Writes multi string values to the registry.
//
//  Return:  error code or 0 if OK.
//
//***************************************************************************

SCODE SetMultiStrValue(HKEY hRoot, TCHAR * cSubKey, TCHAR * cValueName, IWbemClassObject* pInParams)
{
    SCODE sc;
    Registry reg(hRoot, KEY_SET_VALUE, (TCHAR *)cSubKey);
    if(reg.GetLastError() != 0)
        return reg.GetLastError();

    VARIANT var;
    VariantInit(&var);

    sc = pInParams->Get(L"sValue", 0, &var, NULL, NULL);   
    if(sc != S_OK)
        return sc;

    CClearMe cm(&var);
    
    if(var.vt != (VT_ARRAY | VT_BSTR))
    {
        return WBEM_E_INVALID_PARAMETER;
    }

    SAFEARRAY * psa = var.parray;
    long lLbound, lUbound;
    sc = SafeArrayGetLBound(psa,   1, &lLbound  );
    sc |= SafeArrayGetUBound(psa,   1, &lUbound  );
    if(sc != S_OK)
    {
        return WBEM_E_INVALID_PARAMETER;
    }

    long lNumElements = lUbound - lLbound + 1;

    // Calculate the necessary size

    long lSize = 1, lTry;

    for(lTry = lLbound; lTry <= lUbound; lTry++)
    {
        BSTR bstr = NULL;
        if(S_OK == SafeArrayGetElement(psa, &lTry, &bstr) && bstr)
        {
            lSize += SysStringLen(bstr) + 1;
            SysFreeString(bstr);
        }
        else
        {
            return WBEM_E_INVALID_PARAMETER;
        }
    }

    WCHAR * pMulti = new WCHAR [lSize];
    if(pMulti == NULL)
    {
        return WBEM_E_OUT_OF_MEMORY;
    }

    memset(pMulti, 0, lSize * sizeof(WCHAR));
    WCHAR * pNext = pMulti;

    // Do the conversion;

    for(lTry = lLbound; lTry <= lUbound; lTry++)
    {
        BSTR bstr;
        if(S_OK == SafeArrayGetElement(psa, &lTry, &bstr))
        {
            StringCchCopyW(pNext, lSize - (pNext - pMulti), bstr);
            pNext += SysStringLen(bstr) + 1;
            SysFreeString(bstr);
        }
    }

    long lRet;
    lRet = reg.SetMultiStr(cValueName, pMulti, lSize * sizeof(WCHAR));
    delete [] pMulti;
    return lRet;
}

//***************************************************************************
//
//  SCODE GetMultiStrValue
//
//  Purpose:  Reads multi strings from the registry.
//
//  Return:  error code or 0 if OK.
//
//***************************************************************************

SCODE GetMultiStrValue(HKEY hRoot, TCHAR * cSubKey, TCHAR * cValueName, IWbemClassObject* pOutParams)
{
    SCODE sc;
    Registry reg(hRoot, KEY_QUERY_VALUE, (TCHAR *)cSubKey);
    if(reg.GetLastError() != 0)
        return reg.GetLastError();

    DWORD dwSize = 0;
    TCHAR * pMulti = reg.GetMultiStr(cValueName, dwSize);
    if(pMulti == NULL)
        return reg.GetLastError();

    CVectorDeleteMe<TCHAR> dm(pMulti);
    
    // count the number of strings

    long lNumString = 0;
    TCHAR * pNext;
    DWORD dwNumChar = dwSize / sizeof(WCHAR);
    WCHAR * pFinalNull = pMulti + dwNumChar - 1;
    for(pNext = pMulti; pNext < pFinalNull; pNext += lstrlen(pNext) + 1)
        lNumString++;

    // create the bstr array

    SAFEARRAY FAR* psa = MySafeArrayCreate(lNumString, VT_BSTR);
    if(psa == NULL)
    {
        return WBEM_E_OUT_OF_MEMORY;
    }
    pNext = pMulti;
    for(long lTry = 0; lTry < lNumString; lTry++, pNext += lstrlen(pNext) + 1)
    {
        int iLen = lstrlen(pNext) + 1;
        BSTR bstr = GetBSTR(pNext);
        if(bstr)
        {
            sc = SafeArrayPutElement(psa, &lTry, bstr);
            SysFreeString(bstr);
            if(FAILED(sc))
            {
                SafeArrayDestroy(psa);
                return sc;
            }
        }
    }

    // put the data

    VARIANT var;
    var.vt = VT_BSTR | VT_ARRAY;
    var.parray = psa;
    sc = pOutParams->Put( L"sValue", 0, &var, 0);
    VariantClear(&var);
    return sc;
}


//***************************************************************************
//
//  SCODE SetStringValue
//
//  Purpose:  Writes strings to the registry.  These strings may 
//  contain environment strings.
//
//  Return:  error code or 0 if OK.
//
//***************************************************************************

SCODE SetStringValue(HKEY hRoot, TCHAR * cSubKey, TCHAR * cValueName, IWbemClassObject* pInParams,
							 StringType st)
{
	Registry reg(hRoot, KEY_SET_VALUE, (TCHAR *)cSubKey);
	long lRet = reg.GetLastError();
	if(lRet != ERROR_SUCCESS)
		return  lRet;

	VARIANT var;
	VariantInit(&var);

	SCODE sc = pInParams->Get(L"sValue", 0, &var, NULL, NULL);
	if(sc != S_OK)
		return sc;
	if(var.vt != VT_BSTR)
	{
		VariantClear(&var);
		return WBEM_E_INVALID_PARAMETER;
	}
	int iLen = 2*wcslen(var.bstrVal) + 2;
	TCHAR * pValue = new TCHAR[iLen];
	if(pValue)
	{
		CopyOrConvert(pValue, var.bstrVal, iLen);
		if(st == SIMPLE)
			sc = reg.SetStr(cValueName, pValue);
		else
			sc = reg.SetExpandStr(cValueName, pValue);
		delete [] pValue;
	}
	else
		sc = WBEM_E_OUT_OF_MEMORY;
	VariantClear(&var);
	return sc;
}

//***************************************************************************
//
//  SCODE SetBinaryValue
//
//  Purpose:  Writes binary data to the registry.
//
//  Return:  error code or 0 if OK.
//
//***************************************************************************

SCODE SetBinaryValue(HKEY hRoot, TCHAR * cSubKey, TCHAR * cValueName, IWbemClassObject* pInParams)
{
	Registry reg(hRoot, KEY_SET_VALUE, (TCHAR *)cSubKey);
	if(reg.GetLastError() != 0)
		return reg.GetLastError();

	VARIANT var;
	VariantInit(&var);

    SCODE sc = pInParams->Get(L"uValue", 0, &var, NULL, NULL);   
	if(sc != S_OK)
		return sc;

	if(var.vt != (VT_ARRAY | VT_UI1) || var.parray == NULL)
	{
		VariantClear(&var);
		return WBEM_E_INVALID_PARAMETER;
	}

    SAFEARRAY * psa = var.parray;
    long lLbound, lUbound;
    sc = SafeArrayGetLBound(psa,   1, &lLbound  );
    sc |= SafeArrayGetUBound(psa,   1, &lUbound  );
	if(sc == S_OK)
	{
		byte * pData;
		sc = SafeArrayAccessData(psa, (void HUGEP* FAR*)&pData);
		if(sc == S_OK)
		{
			sc = reg.SetBinary(cValueName, pData, DWORD(lUbound - lLbound + 1));
		}
	}
    VariantClear(&var);
	return sc;

}

//***************************************************************************
//
//  SCODE GetBinaryValue
//
//  Purpose:  Reads binary data from the registry.
//
//  Return:  error code or 0 if OK.
//
//***************************************************************************

SCODE GetBinaryValue(HKEY hRoot, TCHAR * cSubKey, TCHAR * cValueName, IWbemClassObject* pOutParams)
{
	Registry reg(hRoot, KEY_QUERY_VALUE, (TCHAR *)cSubKey);
	if(reg.GetLastError() != 0)
		return reg.GetLastError();

	SCODE sc;
    DWORD dwSize;
    byte * pRegData;
    long lRet = reg.GetBinary(cValueName, &pRegData, &dwSize);
	if(lRet != ERROR_SUCCESS || pRegData == NULL)
    {
        if(IsTypeMismatch(reg, cValueName, REG_BINARY))
            return WBEM_E_TYPE_MISMATCH;
        else
		    return lRet;
    }

    SAFEARRAY FAR* psa = MySafeArrayCreate(dwSize, VT_UI1);
	if(psa)
	{
		TCHAR * pData = NULL;
		sc = SafeArrayAccessData(psa, (void HUGEP* FAR*)&pData);
		if(sc == S_OK)
		{
			memcpy(pData, pRegData, dwSize);
			SafeArrayUnaccessData(psa);
			VARIANT var;
			var.vt = VT_UI1|VT_ARRAY;
			var.parray = psa;
			sc = pOutParams->Put(L"uValue" , 0, &var, 0);      
			VariantClear(&var);
		}
	}
	else
		sc = WBEM_E_OUT_OF_MEMORY;
	delete [] pRegData;
	return sc;
}



/************************************************************************
*                                                                       *      
*CMethodPro::ExecMethodAsync                                            *
*                                                                       *
*Purpose: This is the Async function implementation.                    *
*                                                                       *
************************************************************************/

SCODE CImpReg::MethodAsync(const BSTR ObjectPath, const BSTR MethodName, 
            long lFlags, IWbemContext* pCtx, IWbemClassObject* pInParams, 
            IWbemObjectSink* pSink)
{
    HRESULT hr;    
    IWbemClassObject * pClass = NULL;
    IWbemClassObject * pOutClass = NULL;    
    IWbemClassObject* pOutParams = NULL;
    TCHAR * pcValueName = NULL;
    TCHAR * pcSubKey = NULL;
    long lRet = 0;
    AutoProfile ap;

	if(ObjectPath == NULL || MethodName == NULL || pInParams == NULL || pSink == NULL)
		return WBEM_E_INVALID_PARAMETER;

    // Kevin needs a way to tell if something is write

    // Get the class object, this is hard coded and matches the class
    // in the MOF.  Then create the output argument

    hr = m_pGateway->GetObject(L"StdRegProv", 0, pCtx, &pClass, NULL);
	if(hr == S_OK)
	{
		hr = pClass->GetMethod(MethodName, 0, NULL, &pOutClass);
		if(hr == S_OK)
		{
			hr  = pOutClass->SpawnInstance(0, &pOutParams);
			pOutClass->Release();    
		}
		pClass->Release();
	}
	if(hr != S_OK)
		return SetStatusAndReturnOK(hr, pSink);

	CReleaseMe rm0(pOutParams);
    
    // Get the root key and subkeys

    VARIANT var;
    VariantInit(&var);    // Get the input argument
    hr = pInParams->Get(L"hDefKey", 0, &var, NULL, NULL);   
	if(hr != S_OK)
		return SetStatusAndReturnOK(hr, pSink);
#ifdef _WIN64
    HKEY hRoot = (HKEY)IntToPtr(var.lVal);
#else
    HKEY hRoot = (HKEY)var.lVal;
#endif
    pcSubKey = GetInArgString(pInParams, L"sSubKeyName");
    if(pcSubKey == NULL)
		return SetStatusAndReturnOK(WBEM_E_INVALID_PARAMETER, pSink);
    CVectorDeleteMe<TCHAR> dm1(pcSubKey);

	// This may or may not work since the value name isnt required

    pcValueName = GetInArgString(pInParams, L"sValueName");
    CVectorDeleteMe<TCHAR> dm2(pcValueName);

	SCODE sc = S_OK;

    // Impersonate if using NT

    if(IsNT() && IsDcomEnabled())
    {
        sc = WbemCoImpersonateClient();
        if(sc != S_OK)
			return sc;
	}

    // If we are using HKCU, the hive may need to be loaded

    bool bUsingHKCU = IsNT() && hRoot == HKEY_CURRENT_USER;

    if(bUsingHKCU)
        sc = ap.LoadProfile(hRoot);

    if(sc != S_OK)
		return sc;

    if(!wbem_wcsicmp(MethodName, L"CreateKey"))
    {
		HKEY hKey;
        if(lstrlen(pcSubKey) < 1)
            sc = WBEM_E_INVALID_PARAMETER;
        else
        {
    		lRet = RegCreateKey(hRoot, pcSubKey, &hKey);
		    if(lRet == ERROR_SUCCESS)
			    RegCloseKey(hKey);
        }
    }
    else if(!wbem_wcsicmp(MethodName, L"DeleteKey"))
    {
        if(lstrlen(pcSubKey) < 1)
            sc = WBEM_E_INVALID_PARAMETER;
        else
            lRet = RegDeleteKey(hRoot, pcSubKey);
    }
    else if(!wbem_wcsicmp(MethodName, L"DeleteValue"))
    {
        HKEY hKey;
        lRet = RegOpenKey(hRoot, pcSubKey, &hKey);
		if(lRet == ERROR_SUCCESS)
		{
			lRet = RegDeleteValue(hKey, pcValueName);
			RegCloseKey(hKey);
		}
    }
    else if(!wbem_wcsicmp(MethodName, L"EnumKey"))
    {
		lRet = EnumKey(hRoot, pcSubKey, pOutParams);
    }
    else if(!wbem_wcsicmp(MethodName, L"EnumValues"))
    {
        lRet = EnumValue(hRoot, pcSubKey, pOutParams);
    }
    else if(!wbem_wcsicmp(MethodName, L"GetStringValue") ||
		    !wbem_wcsicmp(MethodName, L"GetExpandedStringValue"))
    {
		lRet = GetStr(hRoot, pcSubKey, pcValueName, pOutParams);
    }
    else if(!wbem_wcsicmp(MethodName, L"SetMultiStringValue"))
    {
		lRet = SetMultiStrValue(hRoot,pcSubKey,pcValueName,pInParams);
    }
    else if(!wbem_wcsicmp(MethodName, L"GetMultiStringValue"))
    {
		lRet = GetMultiStrValue(hRoot,pcSubKey,pcValueName,pOutParams);
    }
    else if(!wbem_wcsicmp(MethodName, L"SetExpandedStringValue"))
    {
		lRet = SetStringValue(hRoot, pcSubKey, pcValueName, pInParams, EXPANDED);
    }
    else if(!wbem_wcsicmp(MethodName, L"SetStringValue"))
    {
		lRet = SetStringValue(hRoot, pcSubKey, pcValueName, pInParams, SIMPLE);
    }
    else if(!wbem_wcsicmp(MethodName, L"SetBinaryValue"))
    {
		lRet = SetBinaryValue(hRoot, pcSubKey, pcValueName, pInParams);
    }
    else if(!wbem_wcsicmp(MethodName, L"SetDWORDValue"))
    {
        lRet = pInParams->Get(L"uValue", 0, &var, NULL, NULL); 
		if(lRet == S_OK)
		{
			DWORD dwValue = var.lVal;
			Registry reg(hRoot, KEY_SET_VALUE, (TCHAR *)pcSubKey);
			lRet = reg.GetLastError();
			if(lRet ==0)
				lRet = reg.SetDWORD(pcValueName, dwValue);
		}
    }
    else if(!wbem_wcsicmp(MethodName, L"GetDWORDValue"))
    {
        // Get the value name

		Registry reg(hRoot, KEY_QUERY_VALUE, (TCHAR *)pcSubKey);
		lRet = reg.GetLastError();
		if(lRet == 0)
	        lRet = reg.GetDWORD(pcValueName, (DWORD *)&var.lVal);
		if(lRet == ERROR_SUCCESS)
		{
			var.vt = VT_I4;
			lRet = pOutParams->Put( L"uValue", 0, &var, 0);      
		}
        else if(IsTypeMismatch(reg, pcValueName, REG_DWORD))
            lRet = WBEM_E_TYPE_MISMATCH;
    }
    else if(!wbem_wcsicmp(MethodName, L"GetBinaryValue"))
    {
		lRet = GetBinaryValue(hRoot,pcSubKey,pcValueName,pOutParams);
    }
	else if(!wbem_wcsicmp(MethodName, L"CheckAccess"))
	{
        lRet = pInParams->Get(L"uRequired", 0, &var, NULL, NULL); 
		if(lRet == S_OK)
		{
			BOOL bSuccess = FALSE;
			DWORD dwValue = var.lVal;
			HKEY hKey;
			lRet = RegOpenKeyEx(hRoot, pcSubKey, 0,  dwValue, &hKey);
			if(lRet == ERROR_SUCCESS)
			{
				RegCloseKey(hKey);
				bSuccess = TRUE;
			}
			var.vt = VT_BOOL;
			var.boolVal = (bSuccess) ? VARIANT_TRUE : VARIANT_FALSE;
			pOutParams->Put( L"bGranted", 0, &var, 0);      
		}
	}
    else
        sc = WBEM_E_INVALID_METHOD;

    if(bUsingHKCU)
    {
        WbemCoRevertToSelf();
    }
    
	// Set the return value

    if(sc == S_OK)
    {
        BSTR retValName = SysAllocString(L"ReturnValue");
	    if(retValName)
	    {
		    var.vt = VT_I4;
		    var.lVal = lRet;
	        pOutParams->Put(retValName , 0, &var, 0); 
    	    SysFreeString(retValName);
	    }
        hr = pSink->Indicate(1, &pOutParams);    
    }

    return SetStatusAndReturnOK(sc, pSink);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\winmgmt\stdprov\stdprov.cpp ===
/*++

Copyright (C) 1995-2001 Microsoft Corporation

Module Name:

    STDPROV.CPP

Abstract:

	Contains DLL entry points.  Also has code that controls
	when the DLL can be unloaded by tracking the number of
	object.  Also holds various utility classes and 
	functions.

History:

	a-davj  9-27-95    Created.

--*/

#include "precomp.h"
#include <wbemidl.h>
#include <genutils.h>
#include "cvariant.h"
#include "cfdyn.h"
#include "provreg.h"
#include "provperf.h"
#include <regeprov.h>

// Count number of objects and number of locks so DLL can know when to unload

long lObj = 0;
long lLock = 0;
HINSTANCE ghModule = NULL;

//***************************************************************************
//
//  BOOL WINAPI DllMain
//
//  DESCRIPTION:
//
//  Entry point for DLL.  Good place for initialization.
//
//  PARAMETERS:
//
//  hInstance           instance handle
//  ulReason            why we are being called
//  pvReserved          reserved
//
//  RETURN VALUE:
//
//  TRUE if OK.
//
//***************************************************************************

BOOL WINAPI DllMain(
                        IN HINSTANCE hInstance,
                        IN ULONG ulReason,
                        LPVOID pvReserved)
{
 	if(ghModule == NULL)
    {
		ghModule = hInstance;
    }
 
    if (DLL_PROCESS_DETACH==ulReason)
    {
        return TRUE;
    }
    else if (DLL_PROCESS_ATTACH==ulReason)
    {
        return TRUE;
    }

    return TRUE;
}              
//***************************************************************************
//
//  STDAPI DllGetClassObject
//
//  DESCRIPTION:
//
//  Called when Ole wants a class factory.  Return one only if it is the sort
//  of class this DLL supports.
//
//  PARAMETERS:
//
//  rclsid              CLSID of the object that is desired.
//  riid                ID of the desired interface.
//  ppv                 Set to the class factory.
//
//  RETURN VALUE:
//
//  S_OK                all is well
//  E_FAILED            not something we support
//  E_OUTOFMEMORY       out of memory
//  
//***************************************************************************

STDAPI DllGetClassObject(
                        IN REFCLSID rclsid,
                        IN REFIID riid,
                        OUT PPVOID ppv)
{
    HRESULT             hr;
//    CCFDyn *pObj;
    IClassFactory *pObj;

// ****  FOR EACH PROVIDER  ***
    if (CLSID_RegProvider ==rclsid)
        pObj=new CCFReg();
    else if (CLSID_RegPropProv ==rclsid)
        pObj=new CCFRegProp();
    else if (CLSID_PerfProvider ==rclsid)
        pObj=new CCFPerf();
    else if (CLSID_PerfPropProv ==rclsid)
        pObj=new CCFPerfProp();
    else if (CLSID_RegistryEventProvider ==rclsid)
        pObj=new CRegEventProviderFactory;
    else
        return ResultFromScode(E_FAIL);

// ****  FOR EACH PROVIDER  ***

    if (NULL==pObj)
        return ResultFromScode(E_OUTOFMEMORY);

    hr=pObj->QueryInterface(riid, ppv);

    if (FAILED(hr))
        delete pObj;

    return hr;
}

//***************************************************************************
//
//  STDAPI DllCanUnloadNow
//
//  DESCRIPTION:
//
//  Answers if the DLL can be freed, that is, if there are no
//  references to anything this DLL provides.
//
//  RETURN VALUE:
//
//  S_OK                if it is OK to unload
//  S_FALSE             if still in use
//  
//***************************************************************************

STDAPI DllCanUnloadNow(void)
{
	if(lLock == 0 && lObj == 0)
		return S_OK;
	else
		return S_FALSE;
}

//***************************************************************************
//
// DllRegisterServer
//
// Purpose: Called during setup or by regsvr32.
//
// Return:  NOERROR if registration successful, error otherwise.
//***************************************************************************

STDAPI DllRegisterServer(void)
{ 
    RegisterDLL(ghModule, CLSID_RegProvider, __TEXT("WBEM Registry Instance Provider"), __TEXT("Both"), NULL);
    RegisterDLL(ghModule, CLSID_RegPropProv, __TEXT("WBEM Registry Property Provider"), __TEXT("Both"), NULL);
	if(IsNT())
	{
		RegisterDLL(ghModule, CLSID_PerfProvider, __TEXT("WBEM PerfMon Instance Provider"), __TEXT("Both"), NULL);
		RegisterDLL(ghModule, CLSID_PerfPropProv, __TEXT("WBEM PerfMon Property Provider"), __TEXT("Both"), NULL);
	}
    RegisterDLL(ghModule, CLSID_RegistryEventProvider, 
                __TEXT("WBEM Registry Event Provider"), __TEXT("Both"), NULL);
	return S_OK;
}

//***************************************************************************
//
// DllUnregisterServer
//
// Purpose: Called when it is time to remove the registry entries.
//
// Return:  NOERROR if registration successful, error otherwise.
//***************************************************************************

STDAPI DllUnregisterServer(void)
{
	UnRegisterDLL(CLSID_RegProvider, NULL);
 	UnRegisterDLL(CLSID_RegPropProv, NULL);
	UnRegisterDLL(CLSID_PerfProvider, NULL);
	UnRegisterDLL(CLSID_PerfPropProv, NULL);
	UnRegisterDLL(CLSID_RegistryEventProvider, NULL);
	return NOERROR;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\winmgmt\stdprov\tstring.h ===
/*++

Copyright (C) 1997-2001 Microsoft Corporation

Module Name:

    TSTRING.H

Abstract:

	Utility string class

History:

	a-davj    1-July-97       Created.

--*/

#ifndef _TString_H_
#define _TString_H_

class TString
{
    TCHAR *m_pString;
    TCHAR m_empty;		// something to point at if memory alloc fails.
	int m_Size;
	void assign(const TCHAR * pSrc);
public:
	TString();
    TString(const TCHAR *pSrc);
    TString& operator =(LPTSTR);
#ifndef UNICODE
    TString& operator =(WCHAR *);
#endif
	TString& operator =(const TString &);
    void Empty();
	~TString() { Empty(); }
    TString& operator +=(TCHAR *);
    TString& operator +=(TCHAR tAdd);

	TCHAR GetAt(int iIndex);
	int Find(TCHAR cFind);

    operator TCHAR *() { return m_pString; } 
    int Length() { return lstrlen(m_pString); }
    BOOL Equal(TCHAR *pTarget) 
        { return lstrcmp(m_pString, pTarget) == 0; }
    BOOL EqualNoCase(TCHAR *pTarget) 
        { return lstrcmpi(m_pString, pTarget) == 0; }

};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\winmgmt\stdprov\tstring.cpp ===
/*++

Copyright (C) 1996-2001 Microsoft Corporation

Module Name:

    TSTRING.CPP

Abstract:

History:

--*/

#include "precomp.h"

TString::TString()
{
	m_empty = 0;
	m_pString = &m_empty;
	m_Size = 0;
}


TString::TString(const TCHAR *pSrc)
{
	m_empty = 0;
	m_pString = &m_empty;
	m_Size = 0;
	assign(pSrc);
}


void TString::assign(const TCHAR * pSrc)
{
	if(pSrc)
	{
		int iLen = lstrlen(pSrc)+1;
		TCHAR * pNew = new TCHAR[iLen];
		if(pNew)
		{
			m_pString = pNew;
			m_Size = iLen;
			StringCchCopyW(m_pString, iLen,  pSrc);
		}
	}
}

#ifndef UNICODE
TString& TString::operator =(WCHAR * pwcSrc)
{
	Empty();
    long len = 2*(wcslen(pwcSrc)+1);
	TCHAR * pNew = new TCHAR[len];
	if(pNew)
	{
		wcstombs(pNew, pwcSrc, len);
		assign(pNew);
		delete pNew;
	}
	return *this;
}
#endif

TString& TString::operator =(LPTSTR pSrc)
{
	Empty();
	assign(pSrc);
	return *this;
}

TString& TString::operator =(const TString &Src)
{
    Empty();
    assign(Src.m_pString);
    return *this;    
}
//TString::operator=(class TString const &)

void TString::Empty()
{
	m_Size = 0;
	if(m_pString != &m_empty)
		delete m_pString;
	m_pString = &m_empty;
}

TString& TString::operator +=(TCHAR * pSrc)
{
	if(pSrc)
	{
		int iLen = lstrlen(m_pString) + lstrlen(pSrc)+1;
		TCHAR * pNew = new TCHAR[iLen];
		if(pNew)
		{
			StringCchCopyW(pNew, iLen, m_pString);
			StringCchCatW(pNew, iLen, pSrc);
			Empty();
			m_Size = iLen;
			m_pString = pNew;
		}
	}
	return *this;
}

TString& TString::operator +=(TCHAR Src)
{
	if(lstrlen(m_pString) + 2 > m_Size)
	{
		int iLen =  lstrlen(m_pString) + 32;

		TCHAR * pNew = new TCHAR[iLen];
		if(pNew == NULL)
			return *this;
		StringCchCopyW(pNew, iLen, m_pString);
        Empty();
		m_pString = pNew;
		m_Size = iLen;
	}
	TCHAR temp[2];
	temp[0] = Src;
	temp[1] = 0;
	StringCchCatW(m_pString, m_Size, temp); 
	return *this;
}


TCHAR TString::GetAt(int iIndex)
{
	if(iIndex < 0 || iIndex >= lstrlen(m_pString))
		return -1;
	else
		return m_pString[iIndex];
}

int TString::Find(TCHAR cFind)
{
	int iCnt, iLen = lstrlen(m_pString);
	for(iCnt = 0 ;iCnt < iLen; iCnt++)
		if(cFind == m_pString[iCnt])
			return iCnt;
	return -1;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\winmgmt\wbemcomn\arena.cpp ===
/*++

Copyright (C) 1996-2001 Microsoft Corporation

Module Name:

Abstract:

History:

--*/

#include "precomp.h"
#include "genutils.h"
#include "arena.h"
#include "sync.h"
#include "reg.h"
#include "arrtempl.h"

static HANDLE g_hHeap = NULL;

static class DefaultInitializer
{
public:
    DefaultInitializer() 
    {
        CWin32DefaultArena::WbemHeapInitialize( GetProcessHeap() );
    }
} g_hDefaultInitializer;

BOOL CWin32DefaultArena::WbemHeapInitialize( HANDLE hHeap )
{
    if ( g_hHeap != NULL )
    {
        return FALSE;
    }
    g_hHeap = hHeap;
    return TRUE;
}

void CWin32DefaultArena::WbemHeapFree()
{
    if ( g_hHeap == NULL )
    {
        return;
    }
	if (g_hHeap != GetProcessHeap())
	    HeapDestroy(g_hHeap);
	g_hHeap = NULL;
    return;
}

//
//***************************************************************************

LPVOID CWin32DefaultArena::WbemMemAlloc(SIZE_T dwBytes)
{
    if ( g_hHeap == NULL )
        return NULL;

    return HeapAlloc( g_hHeap, 0, dwBytes);
}

//***************************************************************************
//
//***************************************************************************

LPVOID CWin32DefaultArena::WbemMemReAlloc(LPVOID pOriginal, SIZE_T dwNewSize)
{   
    if ( g_hHeap == NULL )
        return NULL;
    return HeapReAlloc( g_hHeap, 0, pOriginal, dwNewSize);
}

//***************************************************************************
//
//***************************************************************************

BOOL CWin32DefaultArena::WbemMemFree(LPVOID pBlock)
{
    if ( g_hHeap == NULL )
        return FALSE;
	if (pBlock==0)
		return TRUE;
    return HeapFree( g_hHeap, 0, pBlock);
}

//***************************************************************************
//
//***************************************************************************

SIZE_T CWin32DefaultArena::WbemMemSize(LPVOID pBlock)
{
    if ( g_hHeap == NULL )
        return 0;
    return HeapSize( g_hHeap, 0, pBlock);
}

//***************************************************************************
//
//***************************************************************************

BSTR CWin32DefaultArena::WbemSysAllocString(const wchar_t *wszString)
{
    if ( g_hHeap == NULL )
        return NULL;
    BSTR pBuffer = SysAllocString(wszString);

    return pBuffer;
}

//***************************************************************************
//
//***************************************************************************


BSTR CWin32DefaultArena::WbemSysAllocStringByteLen(const char *szString, UINT len)
{
    if ( g_hHeap == NULL )
        return NULL;
	BSTR pBuffer = SysAllocStringByteLen(szString, len);

	return pBuffer;
}

//***************************************************************************
//
//****************************************************************************

INT  CWin32DefaultArena::WbemSysReAllocString(BSTR *bszString, const wchar_t *wszString)
{
    if ( g_hHeap == NULL )
        return FALSE;
	INT nRet = SysReAllocString(bszString, wszString);

	return nRet;
}

//***************************************************************************
//
//***************************************************************************


BSTR CWin32DefaultArena::WbemSysAllocStringLen(const wchar_t *wszString, UINT len)
{
    if ( g_hHeap == NULL )
        return NULL;
	BSTR pBuffer = SysAllocStringLen(wszString, len);

	return pBuffer;
}

//***************************************************************************
//
//***************************************************************************


int CWin32DefaultArena::WbemSysReAllocStringLen( BSTR *bszString, 
                                                 const wchar_t *wszString, 
                                                 UINT nLen)
{
    if ( g_hHeap == NULL )
        return FALSE;
    INT nRet = SysReAllocStringLen(bszString, wszString, nLen);
    
    return nRet;
}

//***************************************************************************
//
//***************************************************************************


BOOL CWin32DefaultArena::WbemOutOfMemory()
{
    return FALSE;
}

BOOL CWin32DefaultArena::ValidateMemSize(BOOL bLargeValidation)
{
    if ( g_hHeap == NULL )
        return FALSE;
    MEMORYSTATUS memBuffer;
    memset(&memBuffer, 0, sizeof(MEMORYSTATUS));
    memBuffer.dwLength = sizeof(MEMORYSTATUS);
    DWORD dwMemReq = 0;

    if (bLargeValidation)
        dwMemReq = 0x400000;    //4MB
    else
        dwMemReq = 0x200000;    //2MB

    GlobalMemoryStatus(&memBuffer);

    if (memBuffer.dwAvailPageFile >= dwMemReq)
    {
        return TRUE;
    }

    //THIS ABSOLUTELY HAS TO BE HeapAlloc, and not the WBEM Allocator!!!
    LPVOID pBuff = HeapAlloc( g_hHeap, 0, dwMemReq);
    //THIS ABSOLUTELY HAS TO BE HeapAlloc, and not the WBEM Allocator!!!
    if (pBuff == NULL)
    {
        return FALSE;
    }

    HeapFree( g_hHeap, 0, pBuff);
    GlobalMemoryStatus(&memBuffer);

    if (memBuffer.dwAvailPageFile >= dwMemReq)
    {
        return TRUE;
    }

    return FALSE;
}

HANDLE CWin32DefaultArena::GetArenaHeap()
{
	return g_hHeap;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\winmgmt\stdprov\assoc\assrule.cpp ===
/*++

Copyright (C) 1996-2001 Microsoft Corporation

Module Name:

    ASSRULE.CPP

Abstract:

History:

--*/

#include "assrule.h"
#include <stdio.h>

#define CLASSNAME_ASSOCIATION_RULE L"AssociationRule"
#define PROPNAME_ASSOCIATION_CLASS L"AssociationClass"
#define PROPNAME_RULE_IMMUTABLE L"RuleIsImmutable"
#define PROPNAME_PROPNAME_1 L"PropertyName1"
#define PROPNAME_QUERY_1 L"PropertyQuery1"
#define PROPNAME_IMMUTABLE_1 L"Property1IsImmutable"
#define PROPNAME_PROPNAME_2 L"PropertyName2"
#define PROPNAME_QUERY_2 L"PropertyQuery2"
#define PROPNAME_IMMUTABLE_2 L"Property2IsImmutable"

#define EXTRA_GET_PARAMS ,NULL, NULL
#define EXTRA_PUT_PARAMS ,0

CEndpointCache::CEndpointCache()
    : m_strQuery(NULL), m_pEnum(NULL)
{
}

void CEndpointCache::Create(BSTR strQuery, BOOL bCache)
{
    m_strQuery = SysAllocString(strQuery);
    m_bCache = bCache; 
}

CEndpointCache::~CEndpointCache()
{
    SysFreeString(m_strQuery);
    if(m_pEnum)
        m_pEnum->Release();
}


HRESULT CEndpointCache::GetInstanceEnum(IWbemServices* pNamespace,
                                        IEnumWbemClassObject** ppEnum)
{
    if(m_pEnum)
    {
        *ppEnum = m_pEnum;
        m_pEnum->AddRef();
        return S_OK;
    }

    HRESULT hres = pNamespace->ExecQuery(L"WQL", m_strQuery, 0, ppEnum, NULL);
    if(FAILED(hres)) return hres;

    if(m_bCache)
    {
        m_pEnum = *ppEnum;
        m_pEnum->AddRef();
    }
    
    return hres;
}



CAssocRule::CAssocRule() 
    : m_strAssocClass(NULL), m_strProp1(NULL), m_strProp2(NULL), m_pClass(NULL),
    m_nRef(0), m_bMayCacheResult(FALSE), m_bResultCached(FALSE)
{
}

CAssocRule::~CAssocRule()
{
    SysFreeString(m_strAssocClass);
    SysFreeString(m_strProp1);
    SysFreeString(m_strProp2);

    if(m_pClass)
        m_pClass->Release();
}

void CAssocRule::AddRef()
{
    m_nRef++;
}

void CAssocRule::Release()
{
    if(--m_nRef == 0)
    {
        delete this;
    }
}

HRESULT CAssocRule::LoadFromObject(IWbemClassObject* pRule, BOOL bLongTerm)
{
    HRESULT hres;

    VARIANT v;
    VariantInit(&v);

    // Read association name
    // =====================

    hres = pRule->Get(PROPNAME_ASSOCIATION_CLASS, 0, &v EXTRA_GET_PARAMS);
    if(FAILED(hres) || V_VT(&v) == VT_NULL)
    {
        return WBEM_E_FAILED;
    }
    m_strAssocClass = SysAllocString(V_BSTR(&v));
    VariantClear(&v);

    // Read property names
    // ===================

    hres = pRule->Get(PROPNAME_PROPNAME_1, 0, &v EXTRA_GET_PARAMS);
    if(FAILED(hres) || V_VT(&v) == VT_NULL)
    {
        return WBEM_E_FAILED;
    }
    m_strProp1 = SysAllocString(V_BSTR(&v));
    VariantClear(&v);

    hres = pRule->Get(PROPNAME_PROPNAME_2, 0, &v EXTRA_GET_PARAMS);
    if(FAILED(hres) || V_VT(&v) == VT_NULL)
    {
        return WBEM_E_FAILED;
    }
    m_strProp2 = SysAllocString(V_BSTR(&v));
    VariantClear(&v);

    m_bMayCacheResult = bLongTerm;

    // Read property rule (1)
    // ======================

    VARIANT vImmutable;
    VariantInit(&vImmutable);

    hres = pRule->Get(PROPNAME_QUERY_1, 0, &v EXTRA_GET_PARAMS);
    if(FAILED(hres) || V_VT(&v) == VT_NULL)
    {
        return WBEM_E_FAILED;
    }

    hres = pRule->Get(PROPNAME_IMMUTABLE_1, 0, &vImmutable EXTRA_GET_PARAMS);
    if(FAILED(hres) || V_VT(&vImmutable) == VT_NULL)
    {
        return WBEM_E_FAILED;
    }

    m_Cache1.Create(V_BSTR(&v), V_BOOL(&vImmutable));
    VariantClear(&v);
    if(!V_BOOL(&vImmutable)) 
        m_bMayCacheResult = FALSE;

    // Read property rule (2)
    // ======================

    hres = pRule->Get(PROPNAME_QUERY_2, 0, &v EXTRA_GET_PARAMS);
    if(FAILED(hres) || V_VT(&v) == VT_NULL)
    {
        return WBEM_E_FAILED;
    }

    hres = pRule->Get(PROPNAME_IMMUTABLE_2, 0, &vImmutable EXTRA_GET_PARAMS);
    if(FAILED(hres) || V_VT(&vImmutable) == VT_NULL)
    {
        return WBEM_E_FAILED;
    }

    m_Cache2.Create(V_BSTR(&v), V_BOOL(&vImmutable));
    VariantClear(&v);
    if(!V_BOOL(&vImmutable)) 
        m_bMayCacheResult = FALSE;

    return S_OK;
}

HRESULT CAssocRule::Produce(IWbemServices* pNamespace, IWbemObjectSink* pNotify)
{
    HRESULT hres;

    // Check if we have it cached
    // ==========================

    if(m_bResultCached)
    {
        return m_ObjectCache.Indicate(pNotify);
    }

    // Get first enumerator
    // ====================

    IEnumWbemClassObject* pEnum1;
    hres = m_Cache1.GetInstanceEnum(pNamespace, &pEnum1);
    if(FAILED(hres))
    {
        return hres;
    }

    // Get second enumerator
    // =====================

    IEnumWbemClassObject* pEnum2;
    hres = m_Cache2.GetInstanceEnum(pNamespace, &pEnum2);
    if(FAILED(hres))
    {
        pEnum1->Release();
        return hres;
    }

    // Get the association class
    // =========================

    IWbemClassObject* pClass;
    if(m_pClass != NULL)
    {
        pClass = m_pClass;
        pClass->AddRef();
    }
    else
    {
        hres = pNamespace->GetObject(m_strAssocClass, 0, &pClass, NULL);
        if(FAILED(hres))
        {
            pEnum1->Release();
            pEnum2->Release();
            return hres;
        }
    }

    // Create all the associations
    // ===========================

    
    IWbemClassObject* pInstance1, *pInstance2;
    ULONG lNum;

    VARIANT v;
    VariantInit(&v);

    // Iterate through the first result set
    // ====================================

    pEnum1->Reset();
    while(pEnum1->Next(1, &pInstance1, &lNum) == S_OK)
    {
        // Get the first path
        // ==================

        hres = pInstance1->Get(L"__PATH", 0, &v EXTRA_GET_PARAMS);
        if(FAILED(hres))
        {
            pEnum1->Release();
            pEnum2->Release();
            pClass->Release();
            return hres;
        }
        BSTR strPath1 = V_BSTR(&v);
        VariantInit(&v); // intentional.

        // Iterate through the second result set
        // =====================================

        pEnum2->Reset();
        while(pEnum2->Next(1, &pInstance2, &lNum) == S_OK)
        {
            // Get the second path
            // ===================

            hres = pInstance2->Get(L"__PATH", 0, &v EXTRA_GET_PARAMS);
            if(FAILED(hres))
            {
                pEnum1->Release();
                pEnum2->Release();
                pClass->Release();
                return hres;
            }
            BSTR strPath2 = V_BSTR(&v);
            VariantInit(&v); // intentional

            // Create the association instance
            // ===============================

            IWbemClassObject* pInstance;
            hres = pClass->SpawnInstance(0, &pInstance);
            if(FAILED(hres))
            {
                pEnum1->Release();
                pEnum2->Release();
                pClass->Release();
                return hres;
            }

            // Set the properties
            // ==================

            V_VT(&v) = VT_BSTR;
            V_BSTR(&v) = strPath1;

            hres = pInstance->Put(m_strProp1, 0, &v EXTRA_PUT_PARAMS);
            if(FAILED(hres))
            {
                pEnum1->Release();
                pEnum2->Release();
                pClass->Release();
                pInstance->Release();
                return hres;
            }

            V_BSTR(&v) = strPath2;
            hres = pInstance->Put(m_strProp2, 0, &v EXTRA_PUT_PARAMS);
            if(FAILED(hres))
            {
                pEnum1->Release();
                pEnum2->Release();
                pClass->Release();
                pInstance->Release();
                return hres;
            }

            // Supply it
            // =========

            pNotify->Indicate(1, &pInstance);

            // Cache it if allowed
            // ===================

            if(m_bMayCacheResult)
                m_ObjectCache.Add(pInstance);

            pInstance->Release();

            SysFreeString(strPath2);
            pInstance2->Release();
        }

        SysFreeString(strPath1);
        pInstance1->Release();
    }

    pEnum1->Release();
    pEnum2->Release();
    pClass->Release();

    if(m_bMayCacheResult)
        m_bResultCached = TRUE;
    return S_OK;
}

//*****************************************************************************

CAssocInfoCache::CAssocInfoCache() : m_pNamespace(NULL)
{
}

void CAssocInfoCache::SetNamespace(IWbemServices* pNamespace)
{
    m_pNamespace = pNamespace;
    m_pNamespace->AddRef();
}

CAssocInfoCache::~CAssocInfoCache()
{
    if(m_pNamespace)
        m_pNamespace->Release();

    for(int i = 0; i < m_aRules.Size(); i++)
    {
        CAssocRule* pRule = (CAssocRule*)m_aRules[i];
        pRule->Release();
    }
}


HRESULT CAssocInfoCache::GetRuleForClass(BSTR strClass, CAssocRule** ppRule)
{
    // Search our rules to see if we have it
    // =====================================

    for(int i = 0; i < m_aRules.Size(); i++)
    {
        CAssocRule* pRule = (CAssocRule*)m_aRules[i];
        if(!wcsicmp(pRule->GetAssocClass(), strClass))
        {
            pRule->AddRef();
            *ppRule = pRule;
            return S_OK;
        }
    }

    // Don't have it. Search for the rule in the database.
    // ===================================================

    HRESULT hres;

    BSTR strPath = SysAllocStringLen(NULL, wcslen(strClass) + 100);
    swprintf(strPath, L"%s.%s=\"%s\"", CLASSNAME_ASSOCIATION_RULE,
        PROPNAME_ASSOCIATION_CLASS, strClass);

    IWbemClassObject* pRuleInstance;
    hres = m_pNamespace->GetObject(strPath, 0, &pRuleInstance, NULL);
    SysFreeString(strPath);
    if(FAILED(hres))
    {
        return hres;
    }

    // Check if it is cachable
    // ========================

    VARIANT v;
    VariantInit(&v);
    hres = pRuleInstance->Get(PROPNAME_RULE_IMMUTABLE, 0, &v EXTRA_GET_PARAMS);
    if(FAILED(hres))
    {
        pRuleInstance->Release();
        return hres;
    }

    // Got it. Create the rule.
    // ========================

    CAssocRule* pRule = new CAssocRule;
    hres = pRule->LoadFromObject(pRuleInstance, V_BOOL(&v));
    pRuleInstance->Release();
  
    if(FAILED(hres))
    {
        delete pRule;
        return hres;
    }

    // Cache if allowed
    // ================

    if(V_BOOL(&v))
    {
        m_aRules.Add(pRule);
        pRule->AddRef();
    }

    // Return it to the caller
    // =======================

    pRule->AddRef();
    *ppRule = pRule;

    return S_OK;
}




//****************************************************************************

CObjectCache::~CObjectCache()
{
    Invalidate();
}

void CObjectCache::Invalidate()
{
    for(int i = 0; i < m_aObjects.Size(); i++)
    {
        IWbemClassObject* pObject = (IWbemClassObject*)m_aObjects[i];
        pObject->Release();
    }
    m_aObjects.Empty();
}

void CObjectCache::Add(IWbemClassObject* pObject)
{
    m_aObjects.Add((void*)pObject);
    pObject->AddRef();
}

HRESULT CObjectCache::Indicate(IWbemObjectSink* pSink)
{
    if(m_aObjects.Size() == 0) 
        return S_OK;

    void** ppvData = m_aObjects.GetArrayPtr();

    return pSink->Indicate(m_aObjects.Size(), (IWbemClassObject**)ppvData);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\winmgmt\wbemcomn\arena.h ===
/*++

Copyright (C) 1996-2001 Microsoft Corporation

Module Name:

    ARENA.H

Abstract:

    Standard Arena allocators.

History:

    a-raymcc    23-Apr-96

--*/

#ifndef _ALLOC_H_
#define _ALLOC_H_

#include "corepol.h"

class POLARITY CArena
{
    virtual LPVOID Alloc(SIZE_T dwBytes) = 0;
    virtual LPVOID Realloc(LPVOID pOriginal, SIZE_T dwNewSize) = 0;
    virtual BOOL   Free(LPVOID) = 0;
};

class POLARITY CWin32DefaultArena : public CArena
{
public:

    CWin32DefaultArena() {}
    ~CWin32DefaultArena() {}

    //  Allocates dwBytes of memory using the standard WBEM allocator
    LPVOID Alloc(SIZE_T dwBytes) {return WbemMemAlloc(dwBytes);}

    //  Reallocates the block from Alloc using the standard WBEM allocator
    LPVOID Realloc(LPVOID pOriginal, SIZE_T dwNewSize) 
    {return WbemMemReAlloc(pOriginal, dwNewSize);}

    //  Frees the block of memory from Alloc or Realloc using the standard
    //  WBEM allocator
    BOOL   Free(LPVOID pBlock) {return WbemMemFree(pBlock);}

    //
    // sets the heap used by the allocation functions.  Will return false 
    // if one is already set.  Most likely this function will be called at 
    // module initialization, such as DllMain.  Calling this function 
    // is optional when -- 1 ) You can accept using the ProcessHeap and 
    // 2 ) You are guaranteed that no allocations will occur before 
    // static initialization has occurred in this module.
    //
    static BOOL WbemHeapInitialize( HANDLE hHeap );
    static void WbemHeapFree( );

	//	Explicitly define as __cdecl as these are causing backwards compatibility
	//	issues WbemMemAlloc, WbemMemFree and WbemMemSize

    //  This is the main allocator for the whole of WinMgmt.  All parts
    //  of WinMgmt which allocate memory through HeapAlloc and the
    //  the likes should use this instead
    static LPVOID __cdecl WbemMemAlloc(SIZE_T dwBytes);

    //  This is the main allocator for the whole of WinMgmt.  This
    //  reallocates a block returned through WbemMemAlloc
    static LPVOID WbemMemReAlloc(LPVOID pOriginal, SIZE_T dwNewSize);

    //  This is the main allocator for the whole of WinMgmt.  This
    //  frees up a block returned through WbemMemAlloc or WbemMemReAlloc.
    static BOOL __cdecl WbemMemFree(LPVOID pBlock) ;

    static BSTR WbemSysAllocString(const wchar_t *wszString);
    static BSTR WbemSysAllocStringByteLen(const char *szString, UINT len);
    static INT  WbemSysReAllocString(BSTR *, const wchar_t *wszString);
    static BSTR WbemSysAllocStringLen(const wchar_t *wszString, UINT);
    static int  WbemSysReAllocStringLen(BSTR *, const wchar_t *wszString, UINT);
    static void WbemSysFreeString(BSTR bszString) {SysFreeString(bszString);}

    static BOOL WbemOutOfMemory();

    //Returns the size of an allocated block
    static SIZE_T __cdecl WbemMemSize(LPVOID pBlock);

    //  Makes sure there is probably enough virtual memory available to
    //  carry out an operation.
    static BOOL ValidateMemSize(BOOL bLargeValidation = FALSE);

	//
	static HANDLE GetArenaHeap();
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\winmgmt\wbemcomn\arrtempl.h ===
/*++

Copyright (C) 1996-2001 Microsoft Corporation

Module Name:

    ARRTEMPL.H

Abstract:

    This file defines a simple template for an array of arbitrary pointers.
    Actual growing array functionality is provided by CFlexArray.

    Classes defined:

        template CPointerArray

History:

    11/27/96    a-levn      Compiles.

--*/

#ifndef __ARRAY_TEMPLATE__H_
#define __ARRAY_TEMPLATE__H_

#pragma warning(disable:4786)

#include <map>
#include <strutils.h>


using namespace std;
class wcsless : public binary_function<LPWSTR, LPWSTR, bool>
{
public:
    bool operator()(const LPWSTR& wcs1, const LPWSTR& wcs2) const
        {return wcscmp(wcs1, wcs2) < 0;}
};

class wcsiless : public binary_function<LPWSTR, LPWSTR, bool>
{
public:
    bool operator()(const LPWSTR& wcs1, const LPWSTR& wcs2) const
        {return wbem_wcsicmp(wcs1, wcs2) < 0;}
};


class CReleaseMe
{
protected:
    IUnknown* m_pUnk;

public:
    CReleaseMe(IUnknown* pUnk) : m_pUnk(pUnk){}
    ~CReleaseMe() { release();}
    void release() { if(m_pUnk) m_pUnk->Release(); m_pUnk=0;}
    IUnknown* dismiss(){ IUnknown* p_ = m_pUnk; m_pUnk = NULL; return p_;}
};

template <typename T>
class CReleaseMeRef
{
protected:
    T & m_pUnkRef;

public:
    CReleaseMeRef(T& pUnkRef) : m_pUnkRef(pUnkRef){}
    ~CReleaseMeRef() { release();}
    void release() { if(m_pUnkRef) m_pUnkRef->Release(); m_pUnkRef=0;}
    T dismiss(){ T p_ = m_pUnkRef; m_pUnkRef = NULL; return p_;}    
};

template<class T>
class CTemplateReleaseMe
{
protected:
    T* m_p;

public:
    CTemplateReleaseMe(T* p) : m_p(p){}
    ~CTemplateReleaseMe() { release();}
    void release(){ if(m_p) m_p->Release();m_p=0;}
};

template<class T>
class CDeleteMe
{
protected:
    T* m_p;

public:
    CDeleteMe(T* p = NULL) : m_p(p){}
    ~CDeleteMe() {delete m_p;}

    //  overwrites the previous pointer, does NOT delete it
    void operator= (T* p) {m_p = p;}
};

class CCloseMe
{
protected:
    HANDLE m_h;
public:
    CCloseMe(HANDLE hToClose){m_h = hToClose;};
    ~CCloseMe(){if(m_h && m_h != INVALID_HANDLE_VALUE)CloseHandle(m_h);};
};

class CfcloseMe
{
protected:
    FILE * m_h;
public:
    CfcloseMe(FILE * ToClose){m_h = ToClose;};
    ~CfcloseMe(){if(m_h != NULL)fclose(m_h);};
};

typedef CCloseMe CCloseHandle;

class CRegCloseMe
{
protected:
    HKEY m_h;
public:
    CRegCloseMe(HKEY hToClose){m_h = hToClose;};
    ~CRegCloseMe(){if(m_h)RegCloseKey(m_h);};
};

template<class T>
class CVectorDeleteMe
{
protected:
    T* m_p;
    T** m_pp;

public:
    CVectorDeleteMe(T* p) : m_p(p), m_pp(NULL){}
    CVectorDeleteMe(T** pp) : m_p(NULL), m_pp(pp){}
    ~CVectorDeleteMe() {if(m_p) delete [] m_p; else if(m_pp) delete [] *m_pp;}
};

class CClearMe
{
protected:
    VARIANT* m_pv;

public:
    CClearMe(VARIANT* pv) : m_pv(pv){}
    ~CClearMe() {VariantClear(m_pv);}
};

class CSysFreeMe
{
protected:
    BSTR m_str;

public:
    CSysFreeMe(BSTR str) : m_str(str){}
    ~CSysFreeMe() { if ( NULL != m_str ) SysFreeString(m_str);}
};

class CSysFreeMeRef
{
protected:
    BSTR & m_str;

public:
    CSysFreeMeRef(BSTR & str) : m_str(str){}
    ~CSysFreeMeRef() { SysFreeString(m_str);}
};


class CUnaccessMe
{
protected:
    SAFEARRAY* m_psa;
public:
    CUnaccessMe(SAFEARRAY* psa) : m_psa(psa){}
    ~CUnaccessMe() {SafeArrayUnaccessData(m_psa);}
};

class CMemFreeMe
{
protected:
    void*	m_pMem;
public:
    CMemFreeMe( void* pMem ) : m_pMem(pMem){}
    ~CMemFreeMe() { if ( NULL != m_pMem ) CoTaskMemFree(m_pMem);}
};

#include <arena.h>
#include <flexarry.h>
#include <flexq.h>
#include <smallarr.h>

//*****************************************************************************
//
//  class CPointerArray
//
//  Array of pointers to TMember, where TMember is any class. See CFlexArray
//  in coredll\flexarry.h/cpp for documentation.
//
//*****************************************************************************

template <class TMember>
class CNullManager
{
public:
    void AddRefElement(TMember*){}
    void ReleaseElement(TMember*){}
};

template <class TMember, class TManager = CNullManager<TMember>,
                class TArray = CFlexArray>
class CPointerArray
{
protected:
    TArray m_Array;
    TManager m_Manager;
public:
    CPointerArray(const TManager& Manager = TManager())
        : m_Manager(Manager){}
    ~CPointerArray();

     int GetSize() const
        {return m_Array.Size();}
     void SetSize(int nNewSize)
        {m_Array.SetSize(nNewSize);}
     const TMember* GetAt(int nIndex) const
        {return (TMember*)m_Array.GetAt(nIndex);}
     TMember* GetAt(int nIndex)
        {return (TMember*)m_Array.GetAt(nIndex);}
     const TMember* operator[](int nIndex) const
        {return (TMember*)m_Array.GetAt(nIndex);}
     TMember* operator[](int nIndex)
        {return (TMember*)m_Array.GetAt(nIndex);}
     void SetAt(int nIndex, TMember* pElement, TMember** ppOld = NULL);
     void Discard(int nIndex);
     bool RemoveAt(int nIndex, TMember** ppOld = NULL);
     bool InsertAt(int nIndex, TMember* pElement);
     int Add(TMember* pElement);
     TMember** GetArrayPtr();
     TMember** UnbindPtr();
     void RemoveAll();
     void Swap(int nIndex1, int nIndex2);
     void Trim() {m_Array.Trim();}

     TArray & GetArray(){ return  m_Array; };
protected:
     void AddRefElement(TMember* p){m_Manager.AddRefElement(p);}
     void ReleaseElement(TMember* p){m_Manager.ReleaseElement(p);}
};

template<class TMember>
class CPointerSmallArray :
        public CPointerArray<TMember, CNullManager<TMember>, CSmallArray>
{
};

//*****************************************************************************
//
//  class CPointerQueue
//
//  Queue of pointers to TMember, where TMember is any class. See CFlexQueue
//  in coredll\flexq.h/cpp for documentation.
//
//*****************************************************************************
template <class TMember, class TManager = CNullManager<TMember> >
class CPointerQueue
{
protected:
    CFlexQueue m_Queue;
    TManager m_Manager;
public:
    CPointerQueue(int nInitialSize = 1, const TManager& Manager = TManager())
        : m_Manager(Manager), m_Queue(nInitialSize){}
    void Clear();
    ~CPointerQueue()
        {Clear();}

    inline int GetQueueSize() const
        {return m_Queue.GetQueueSize();}

    bool Enqueue(TMember* pNew)
    {
        AddRefElement(pNew);
        return m_Queue.Enqueue(pNew);
    }
    TMember* Dequeue()
    {
        TMember* p = (TMember*)m_Queue.Dequeue();
        return p;
    }
    bool Requeue(TMember* pNew)
    {
        AddRefElement(pNew);
        return m_Queue.Requeue(pNew);
    }
    TMember* Unqueue()
    {
        TMember* p = (TMember*)m_Queue.Unqueue();
        AddRefElement(p);
        return p;
    }
protected:
     void AddRefElement(TMember* p){m_Manager.AddRefElement(p);}
     void ReleaseElement(TMember* p){m_Manager.ReleaseElement(p);}
};


//*****************************************************************************
//
//  UNIQUE POINTER ARRAY
//
//*****************************************************************************

template <class TMember>
class CUniqueManager
{
public:
    void AddRefElement(TMember*){}
    void ReleaseElement(TMember* pMember) {delete pMember;}
};

template<class TMember>
class CUniquePointerArray :
        public CPointerArray<TMember, CUniqueManager<TMember> >
{
};

template<class TMember>
class CUniquePointerSmallArray :
        public CPointerArray<TMember, CUniqueManager<TMember>, CSmallArray>
{
};

template<class TMember>
class CUniquePointerQueue :
        public CPointerQueue<TMember, CUniqueManager<TMember> >
{
public:
    CUniquePointerQueue<TMember>(int nInitialSize = 1)
        : CPointerQueue<TMember, CUniqueManager<TMember> >(nInitialSize)
    {}
};

//*****************************************************************************
//
//  REFED POINTER ARRAY
//
//*****************************************************************************
template <class TMember>
class CReferenceManager
{
public:
    void AddRefElement(TMember* pMember) {if(pMember)pMember->AddRef();}
    void ReleaseElement(TMember* pMember) {if(pMember)pMember->Release();}
};

template<class TMember>
class CRefedPointerArray :
        public CPointerArray<TMember, CReferenceManager<TMember> >
{
};

template<class TMember>
class CRefedPointerSmallArray :
        public CPointerArray<TMember, CReferenceManager<TMember>, CSmallArray>
{
};

template<class TMember>
class CRefedPointerQueue :
        public CPointerQueue<TMember, CReferenceManager<TMember> >
{
public:
    CRefedPointerQueue(int nInitialSize = 1)
        : CPointerQueue<TMember, CReferenceManager<TMember> >(nInitialSize)
    {}
};

//*****************************************************************************
//
//  ARRAY OF UNIQUE ARRAYS
//
//*****************************************************************************

template <class TMember>
class CUniqueArrayManager
{
    void AddRefElement(TMember**){}
    void ReleaseElement(TMember** pMember) {delete [] pMember;}
};
template<class TMember>
class CUniqueArrayArray : public CPointerArray<TMember,
                                               CUniqueArrayManager<TMember> >
{
};

//*****************************************************************************
//
//  IMPLEMENTATION
//
//*****************************************************************************

template <class TMember, class TManager, class TArray>
CPointerArray<TMember, TManager, TArray>::~CPointerArray()
{
    RemoveAll();
}

template <class TMember, class TManager, class TArray>
void CPointerArray<TMember, TManager, TArray>::RemoveAll()
{
    for(int i = 0; i < m_Array.Size(); i++)
    {
        //
        // Remove it from array before releasing --- otherwise for a moment 
        // there we have a garbage pointer in array!
        //
        
        TMember* p = GetAt(i);
        m_Array.SetAt(i, NULL);
        ReleaseElement(p);
    }
    m_Array.Empty();
}

template <class TMember, class TManager, class TArray>
void CPointerArray<TMember, TManager, TArray>::SetAt(int nIndex,
                                            TMember* pElement, TMember** ppOld)
{
    AddRefElement(pElement);

    //
    // Remove it from array before releasing --- otherwise for a moment 
    // there we have a garbage pointer in array!
    //

    TMember* pOld = GetAt(nIndex);
    m_Array.SetAt(nIndex, (void*)pElement);
    
    if(ppOld == NULL)
        ReleaseElement(pOld);
    else
        *ppOld = pOld;
}

template <class TMember, class TManager, class TArray>
void CPointerArray<TMember, TManager, TArray>::Discard(int nIndex)
{
    m_Array.SetAt(nIndex, NULL);
}

template <class TMember, class TManager, class TArray>
bool CPointerArray<TMember, TManager, TArray>::RemoveAt(int nIndex,
                                                        TMember** ppOld)
{
    //
    // Remove it from array before releasing --- otherwise for a moment 
    // there we have a garbage pointer in array!
    //

    TMember* pOld = GetAt(nIndex);
    if(m_Array.RemoveAt(nIndex) != CFlexArray::no_error)
        return false;

    if(ppOld == NULL)
        ReleaseElement(pOld);
    else
        *ppOld = pOld;

    return true;
}

template <class TMember, class TManager, class TArray>
bool CPointerArray<TMember, TManager, TArray>::InsertAt(int nIndex,
                                                        TMember* pElement)
{
    if(m_Array.InsertAt(nIndex, (void*)pElement) != CFlexArray::no_error)
        return false;

    AddRefElement(pElement);
    return true;
}

template <class TMember, class TManager, class TArray>
int CPointerArray<TMember, TManager, TArray>::Add(TMember* pElement)
{
    if(m_Array.Add((void*)pElement) != CFlexArray::no_error)
        return -1;

    AddRefElement(pElement);
    return m_Array.Size()-1;
}

template <class TMember, class TManager, class TArray>
TMember** CPointerArray<TMember, TManager, TArray>::GetArrayPtr()
{
    return (TMember**)m_Array.GetArrayPtr();
}

template <class TMember, class TManager, class TArray>
TMember** CPointerArray<TMember, TManager, TArray>::UnbindPtr()
{
    return (TMember**)m_Array.UnbindPtr();
}

template <class TMember, class TManager, class TArray>
void CPointerArray<TMember, TManager, TArray>::Swap(int nIndex1, int nIndex2)
{
    void* pTemp = m_Array[nIndex1];
    m_Array.SetAt(nIndex1, m_Array[nIndex2]);
    m_Array.SetAt(nIndex2, pTemp);
}

template <class TMember, class TManager>
void CPointerQueue<TMember, TManager>::Clear()
{
    TMember* p;
    while(p = (TMember*)m_Queue.Dequeue())
    {
        ReleaseElement(p);
    }
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\winmgmt\stdprov\stdprov.h ===
/*++

Copyright (C) 1997-2001 Microsoft Corporation

Module Name:

    STDPROV.H

Abstract:

	Defines general purpose defines as well as some common
	objects that are generaly useful for all the different
	provider types.

History:

	a-davj  27-Sep-97   Created.

--*/

#ifndef _SERVER2_H_
#define _SERVER2_H_

#define INC_OBJ    1
#define INC_LOCK   2
#define DEC_OBJ    3
#define DEC_LOCK   4

#define INIT_SIZE            20



// Used to parse all provider strings

#define MAIN_DELIM '|'

// Used to parse substrings for the registry and
// compound file providers

#define SUB_DELIM '\\'

// Used to parse substrings for the automation

#define DOT '.'

// Used to parse the PATH/CLASS token for the automation

#define DQUOTE '\"'
#define SEPARATOR ','


// Used to parse ini strings.

#define COMMA ','

// Use in dde provider strings to delimit item names

#define DELIMCHR '@'
#define DELIMSTR "@"

// Used to ignore any of the above!

#define ESC '^'

// Indicates that the dwUseOptArray value should
// be substituted

#define USE_ARRAY '#'

#define ERROR_UNKNOWN 255

#ifdef UNICODE
#define CHARTYPE VT_LPWSTR
#define CHARSIZE 2
#else
#define CHARTYPE VT_LPSTR
#define CHARSIZE 1
#endif

SAFEARRAY * OMSSafeArrayCreate(VARTYPE vt,int iNumElements);
HRESULT OMSVariantChangeType(VARIANTARG * pDest, VARIANTARG *pSrc,USHORT wFlags, VARTYPE vtNew);
HRESULT OMSVariantClear(VARIANTARG * pClear);
int iTypeSize(VARTYPE vtTest);
char * WideToNarrow(LPCWSTR);
char * WideToNarrowA(LPCWSTR);      // uses new instead of CoTaskMemAlloc

#define BUFF_SIZE 256

extern long lObj;
extern long lLock;


//***************************************************************************
//
//  CLASS NAME:
//
//  CToken
//
//  DESCRIPTION:
//
//  The CToken holds a single token in the provider string
//
//***************************************************************************

class CToken : public CObject {
private:
    long int iOriginalLength;
    long int iOptArrayIndex;
    TString sData;
    TString sFullData;
    CFlexArray Expressions;
public:
	friend class CProvObj;
    CToken(const TCHAR * cpStart,const OLECHAR cDelim, bool bUsesEscapes);
    ~CToken();
    TCHAR const * GetStringValue(void){return sData;};
    TCHAR const * GetFullStringValue(void){return sFullData;};    
    long int GetOrigLength(void){return iOriginalLength;};    
    long int GetIntExp(int iExp,int iArray);    
    long int iConvOprand(const TCHAR * tpCurr, int iArray, long int & dwValue);
    TCHAR const * GetStringExp(int iExp);
    long int GetNumExp(void){return    Expressions.Size();};
    BOOL IsExpString(int iExp);
};

//***************************************************************************
//
//  CLASS NAME:
//
//  CProvObj
//
//  DESCRIPTION:
//
//  The CProvObj class holds a an array of CTokens objects which together
//  contain the provider string.
//
//***************************************************************************

class CProvObj : public CObject {
private:
    CToken * GetTokenPointer(int iToken);
    CFlexArray myTokens;
    DWORD dwStatus;
    TCHAR m_cDelim;
    void Init(const TCHAR * ProviderString,const TCHAR cDelim);
    bool m_bUsesEscapes;
public:
    DWORD dwGetStatus(int iMin);
    CProvObj(const WCHAR * ProviderString,const TCHAR cDelim, bool bUsesEscapes);
#ifndef UNICODE
    CProvObj(const char * ProviderString,const TCHAR cDelim, bool bUsesEscapes);
#endif
    const TCHAR * sGetToken(int iToken);
    const TCHAR * sGetFullToken(int iToken);
    const TCHAR * sGetStringExp(int iToken,int iExp);
    long int iGetIntExp(int iToken,int iExp, int iArray);
    BOOL IsExpString(int iToken,int iExp);
    long int iGetNumExp(int iToken);
    long int iGetNumTokens(void) {return myTokens.Size();};
    ~CProvObj(){Empty(); return;};
    void Empty();
    BOOL Update(WCHAR * pwcProvider);

};


//***************************************************************************
//
//  CLASS NAME:
//
//  CEntry and CHandleCache
//
//  DESCRIPTION:
//
//  The CEntry and CHandleCache objects provide an way
//  to cache handles and the path strings associated
//  with them.
//
//***************************************************************************

class CEntry : public CObject {
public:
    CEntry();
    ~CEntry();
    TString sPath;
    HANDLE hHandle;
};
    
class CHandleCache : public CObject {
public:
    ~CHandleCache();
    BOOL IsRemote(void){return bRemote;};
    void SetRemote(BOOL bSet){bRemote = bSet;};
    long int lAddToList(const TCHAR * pAdd, HANDLE hAdd);
    long int lGetNumEntries(void){return List.Size();};
    long int lGetNumMatch(int iStart,int iTokenStart, CProvObj & Path);
    void Delete(long int lStart);
    HANDLE hGetHandle(long int lIndex);
    const TCHAR *  sGetString(long int lIndex);
private:
    CFlexArray List;
    BOOL bRemote;
};
 


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\winmgmt\wbemcomn\buffer.cpp ===
/*++

Copyright (C) 1996-2001 Microsoft Corporation

Module Name:

Abstract:

History:

--*/

#include "precomp.h"
#include "buffer.h"
#include "comutl.h"

/************************************************************************
  CBuffer
*************************************************************************/

CBuffer::CBuffer( PBYTE pData, ULONG cData, BOOL bDelete )
: m_pData(pData), m_cData(cData), m_bDelete(bDelete), m_iData(0), m_cRefs(0)
{

}

CBuffer::~CBuffer()
{
    if ( m_bDelete )
    {
        delete [] m_pData;
    }
}

CBuffer::CBuffer( const CBuffer& rOther )
: m_pData(NULL), m_cData(0), m_bDelete(FALSE), m_iData(0), m_cRefs(0)
{
    *this = rOther;
}

CBuffer& CBuffer::operator= ( const CBuffer& rOther )
{
    EnsureSize( rOther.m_iData );
    memcpy( m_pData, rOther.m_pData, m_iData );
    return *this;
}

void CBuffer::EnsureSize( ULONG ulSize )
{
    if ( ulSize <= m_cData )
    {
        return;
    }

    ULONG cData = m_cData*2 > ulSize ? m_cData*2 : ulSize + 256;

    BYTE* pData = new BYTE[cData];
    
    if ( pData == NULL ) 
    {
        throw CX_MemoryException();
    }
    
    memcpy( pData, m_pData, m_iData ); 

    if ( m_bDelete )
    {
        delete [] m_pData; 
    }

    m_bDelete = TRUE;
    m_cData = cData;
    m_pData = pData;
}


HRESULT CBuffer::ReadLPWSTR( LPCWSTR& rwszStr )
{
    HRESULT hr;
    ULONG cStr;

    hr = Read( &cStr, sizeof(DWORD), NULL );

    if ( hr != S_OK )
    {
        return hr;
    }

    if ( m_cData-m_iData < cStr )
    {
        return S_FALSE;
    }

    rwszStr = LPCWSTR(m_pData+m_iData);

    m_iData += cStr;

    return S_OK;
}

HRESULT CBuffer::WriteLPWSTR( LPCWSTR wszStr )
{
    HRESULT hr;

    //
    // ensure that the packed string's length is divisible by sizeof WCHAR.
    // this makes it easier to ensure that all strings in the message are 
    // at least aligned appropriately.
    //

    DWORD cStr = (wcslen(wszStr) + 1)*2; // in bytes
    DWORD cPad = cStr%2;
    DWORD cPackedStr = cStr + cPad;

    hr = Write( &cPackedStr, sizeof(DWORD), NULL );

    if ( FAILED(hr) )
    {
        return hr;
    }

    hr = Write( wszStr, cStr, NULL );

    if ( SUCCEEDED(hr) )
    {
        hr = Advance( cPad );
    }

    return hr;
}

ULONG CBuffer::AddRef()
{
    return InterlockedIncrement( &m_cRefs );
}

ULONG CBuffer::Release()
{
    ULONG cRefs = InterlockedDecrement( &m_cRefs );

    if ( cRefs == 0 )
    {
        delete this;
    }

    return cRefs;
}

STDMETHODIMP CBuffer::QueryInterface( REFIID riid, void** ppv )
{
    *ppv = NULL;

    if ( riid==IID_IStream || 
         riid==IID_ISequentialStream ||
         riid==IID_IUnknown )
    {
        *ppv = (IStream*)this;
        AddRef();
        return S_OK;
    }

    return E_NOINTERFACE;
}

STDMETHODIMP CBuffer::Read( void *pv, ULONG cb, ULONG *pcbRead )
{
    ULONG cRead = cb > m_cData-m_iData ? m_cData-m_iData : cb; 
    
    memcpy( pv, m_pData + m_iData, cRead );

    if ( pcbRead != NULL )
    {
        *pcbRead = cRead;
    }
    
    m_iData += cRead;
    
    return cRead == cb ? S_OK : S_FALSE;
}

STDMETHODIMP CBuffer::Write( const void *pv, ULONG cb, ULONG *pcbWritten )
{
    ENTER_API_CALL

    HRESULT hr;

    if ( pcbWritten != NULL )
    {
        *pcbWritten = 0;
    }

    EnsureSize( m_iData + cb );
    memcpy( m_pData + m_iData, pv, cb );
    
    m_iData += cb;

    if ( pcbWritten != NULL )
    {
        *pcbWritten = cb;
    }

    return S_OK;

    EXIT_API_CALL
}

STDMETHODIMP CBuffer::Seek( LARGE_INTEGER dlibMove, 
                            DWORD dwOrigin,
                            ULARGE_INTEGER *plibNewPosition )
{
    ENTER_API_CALL 

    HRESULT hr;
    
    __int64 i64Data;
    __int64 i64Move = dlibMove.QuadPart;

    if ( plibNewPosition != NULL )
    {
        plibNewPosition->QuadPart = m_iData;
    }

    if ( dwOrigin == STREAM_SEEK_SET )
    {
        i64Data = 0;
    }
    else if ( dwOrigin == STREAM_SEEK_CUR  )
    {
        i64Data = m_iData;
    }
    else if ( dwOrigin == STREAM_SEEK_END )
    {
        i64Data = m_cData;
    }
    else
    {
        return STG_E_INVALIDFUNCTION;   
    }

    i64Data += i64Move;

    EnsureSize( ULONG(i64Data) );

    m_iData = ULONG(i64Data);

    if ( plibNewPosition != NULL )
    {
        plibNewPosition->QuadPart = i64Data;
    }

    return S_OK;

    EXIT_API_CALL
}

STDMETHODIMP CBuffer::SetSize( ULARGE_INTEGER libNewSize )
{
    ENTER_API_CALL
    EnsureSize( libNewSize.LowPart );
    return S_OK;
    EXIT_API_CALL
}

STDMETHODIMP CBuffer::CopyTo( IStream *pstm,
                              ULARGE_INTEGER cb,
                              ULARGE_INTEGER *pcbRead,
                              ULARGE_INTEGER *pcbWritten )
{
    ENTER_API_CALL

    HRESULT hr;
    ULONG cRead, cWritten;

    if ( pcbRead != NULL )
    {
        pcbRead->QuadPart = 0;
    }

    cRead = cb.LowPart > m_cData-m_iData ? m_cData-m_iData : cb.LowPart;
    
    hr = pstm->Write( m_pData + m_iData, cRead, &cWritten ); 

    if ( pcbWritten != NULL )
    {
        pcbWritten->QuadPart = cWritten;
    }

    if ( FAILED(hr) )
    {
        return hr;
    }
    
    m_iData += cRead;

    if ( pcbRead != NULL )
    {
        pcbRead->QuadPart = cRead;
    }

    return hr;

    EXIT_API_CALL
}
        
STDMETHODIMP CBuffer::Stat( STATSTG* pstatstg, DWORD grfStatFlag )
{
    if ( pstatstg == NULL )
    {
        return STG_E_INVALIDPOINTER;
    }

    ZeroMemory( pstatstg, sizeof(STATSTG) );

    pstatstg->cbSize.LowPart = m_cData;

    return S_OK;
}

STDMETHODIMP CBuffer::Clone( IStream **ppstm )
{
    ENTER_API_CALL

    BYTE* pData = new BYTE[m_cData];
    
    if ( pData == NULL )
    {
        return E_OUTOFMEMORY;
    }

    CBuffer* pNew;

    try 
    {
        pNew = new CBuffer( pData, m_cData );
    }
    catch( CX_MemoryException )
    {
        delete pData;
        throw;
    }

    if ( pNew == NULL ) // just in case we don't have a new which throws on OOM
    {
        delete pData;    
        return E_OUTOFMEMORY;
    }

    pNew->m_iData = m_iData;

    return pNew->QueryInterface( IID_IStream, (void**)ppstm );

    EXIT_API_CALL
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\winmgmt\wbemcomn\buffer.h ===
/*++

Copyright (C) 1996-2001 Microsoft Corporation

Module Name:

Abstract:

History:

--*/



#ifndef __BUFFER_H__
#define __BUFFER_H__

#include "corepol.h"

/************************************************************************
  CBuffer
*************************************************************************/

class POLARITY CBuffer : public IStream
{
    long m_cRefs;
    PBYTE m_pData;
    ULONG m_cData;
    ULONG m_iData;
    BOOL m_bDelete;

    void EnsureSize( ULONG ulSize );

public:

    CBuffer( PBYTE pData=NULL, ULONG cData=0, BOOL bDelete=TRUE );
    CBuffer& operator= ( const CBuffer& );
    CBuffer( const CBuffer& );
    ~CBuffer();

    void Reset() { m_iData = 0; }
    ULONG GetIndex() { return m_iData; }
    ULONG GetSize() { return m_cData; }
    PBYTE GetRawData() { return m_pData; }
    
    HRESULT SetSize( ULONG ulSize )
    {
        ULARGE_INTEGER uliSize;
        uliSize.LowPart = ulSize;
        uliSize.HighPart = 0;
        return SetSize( uliSize );
    }

    HRESULT Advance( ULONG ulMove )
    {
        LARGE_INTEGER dlibMove;
        dlibMove.LowPart = ulMove;
        dlibMove.HighPart = 0;
        return Seek( dlibMove, STREAM_SEEK_CUR, NULL );
    }

    HRESULT ReadLPWSTR( LPCWSTR& rwszStr );
    HRESULT WriteLPWSTR( LPCWSTR wszStr );

    //
    // IUnknown
    //

    STDMETHOD_(ULONG, AddRef)();
    STDMETHOD_(ULONG, Release)();
    STDMETHOD(QueryInterface)(REFIID riid, void** ppv);

    //
    // ISequentialStream
    //

    STDMETHOD(Read)( void *pv, ULONG cb, ULONG *pcbRead );

    STDMETHOD(Write)( const void *pv, ULONG cb, ULONG *pcbWritten);

    //
    // IStream
    //

    STDMETHOD(Seek)( LARGE_INTEGER dlibMove, 
                     DWORD dwOrigin,
                     ULARGE_INTEGER *plibNewPosition );

    STDMETHOD(SetSize)( ULARGE_INTEGER libNewSize );
 
    STDMETHOD(CopyTo)( IStream *pstm,
                       ULARGE_INTEGER cb,
                       ULARGE_INTEGER *pcbRead,
                       ULARGE_INTEGER *pcbWritten );

    STDMETHOD(Commit)( DWORD grfCommitFlags ) { return E_NOTIMPL; }

    STDMETHOD(Revert)( void) { return E_NOTIMPL; }

    STDMETHOD(LockRegion)( ULARGE_INTEGER libOffset,
                           ULARGE_INTEGER cb,
                           DWORD dwLockType ) { return E_NOTIMPL; }

    STDMETHOD(UnlockRegion)( ULARGE_INTEGER libOffset,
                             ULARGE_INTEGER cb,
                             DWORD dwLockType ) { return E_NOTIMPL; }

    STDMETHOD(Stat)( STATSTG *pstatstg, DWORD grfStatFlag );

    STDMETHOD(Clone)( IStream **ppstm );
};


#endif __BUFFER_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\winmgmt\wbemcomn\cimval.h ===
/*++

Copyright (C) 1996-2001 Microsoft Corporation

Module Name:

Abstract:

History:

--*/



#ifndef __CIMVALUE_H__
#define __CIMVALUE_H__

const ULONG CIM_INTERVAL = 99;

class CCimValue
{
    union {
        __int32 m_iVal; 
        __int64 m_lVal;
        unsigned __int32 m_uiVal;
        unsigned __int64 m_ulVal;
        float m_fVal;
        double m_dbVal;
        long double m_ldbVal;
    };

public:
 
   enum { 
        e_Int, 
        e_UnsignedInt, 
        e_Float, 
        e_Double, 
        e_Long, 
        e_UnsignedLong, 
        e_LongDouble
    } m_eType;

    CCimValue();

    HRESULT GetValue( VARIANT& rvValue, ULONG lCimType );
    HRESULT SetValue( VARIANT& rvValue, ULONG lCimType );

    void CoerceToLongDouble();
    void CoerceToDouble();
    void CoerceToFloat();
    void CoerceToUnsignedLong();
    void CoerceToLong();
    void CoerceToUnsignedInt();
    void CoerceToInt();

    friend CCimValue operator+ ( CCimValue ValA, CCimValue ValB );
    friend CCimValue operator- ( CCimValue ValA, CCimValue ValB );
    friend CCimValue operator% ( CCimValue ValA, CCimValue ValB );
    friend CCimValue operator/ ( CCimValue ValA, CCimValue ValB );
    friend CCimValue operator* ( CCimValue ValA, CCimValue ValB );
};

class CX_DivideByZeroException
{
};

class CX_InvalidFloatingPointOperationException
{
};

#endif __CIMVALUE_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\winmgmt\wbemcomn\cimval.cpp ===
/*++

Copyright (C) 1996-2001 Microsoft Corporation

Module Name:

Abstract:

History:

--*/

 
#include "precomp.h"
#include <stdlib.h>
#include <stdio.h>
#include <assert.h>
#include <wbemcli.h>
#include "cimval.h"

BOOL SecondsToInterval( long double ldbSeconds, LPWSTR wszText, size_t cchSize )
{
    int nDay, nHour, nMinute, nSecond, nMicro;

    nDay = int(ldbSeconds / 86400);
    ldbSeconds -= nDay * 86400;
    nHour = int(ldbSeconds / 3600);
    ldbSeconds -= nHour * 3600;
    nMinute = int(ldbSeconds / 60);
    ldbSeconds -= nMinute * 60;
    nSecond = int(ldbSeconds);
    ldbSeconds -= nSecond;
    nMicro = int(ldbSeconds * 1000000);
    
    if(FAILED(StringCchPrintfW( wszText, cchSize, L"%08.8d%02.2d%02.2d%02.2d.%06.6d:000", 
              nDay, nHour, nMinute, nSecond, nMicro )))
              return FALSE;

    return TRUE;
}

// this should be a WBEM common thing ...

BOOL FileTimeToDateTime( FILETIME* pft, LPWSTR wszText, size_t cchSize )
{
    SYSTEMTIME st;
    __int64 llnss = *(__int64*)pft;

    if ( !FileTimeToSystemTime( pft, &st ) )
    {
        return FALSE;
    }

    //
    // have to account for microseconds as well (probably a much better way
    // to do this.)
    //
    st.wMilliseconds = 0;

    FILETIME ft;
    if ( !SystemTimeToFileTime( &st, &ft ) )
    {
        return FALSE;
    }

    __int64 llnss2 = *(__int64*)&ft;
    int nMicro = int((llnss - llnss2)/10);
    
    if (FAILED(StringCchPrintfW( wszText, cchSize, 
              L"%04.4d%02.2d%02.2d%02.2d%02.2d%02.2d.%06.6d+000",
              st.wYear, st.wMonth, st.wDay, st.wHour, 
              st.wMinute, st.wSecond, nMicro )))
              return FALSE;

    return TRUE;
}

BOOL SecondsToDateTime( long double ldbSeconds, LPWSTR wszText, size_t cchSize )
{
    FILETIME* pft;
    __int64 llnss = __int64(ldbSeconds * 10000000);
    pft = (FILETIME*)&llnss;
    return FileTimeToDateTime( pft, wszText, cchSize );
}


BOOL IntervalToSeconds( LPCWSTR wszText, long double& rldbSeconds )
{
    int nDay, nHour, nMinute, nSecond, nMicro;

    int nRes = swscanf( wszText, L"%8d%2d%2d%2d.%6d", 
                        &nDay, &nHour, &nMinute, &nSecond, &nMicro );
    if ( nRes != 5 )
    {
        return FALSE;
    }

    rldbSeconds = nSecond + 60*nMinute + 3600*nHour + 86400*nDay;
    rldbSeconds += nMicro / 1000000.0;

    return TRUE;
}


BOOL DateTimeToSeconds( LPCWSTR wszText, long double& rldbSeconds )
{
    WORD nYear, nMonth, nDay, nHour, nMinute, nSecond, nMicro, nOffset;
    WCHAR wchSep;

    int nRes = swscanf( wszText, L"%4d%2d%2d%2d%2d%2d.%6d%c%3d", 
                        &nYear, &nMonth, &nDay, &nHour, &nMinute, 
                        &nSecond, &nMicro, &wchSep, &nOffset );
    if(nRes != 9)
    {
        return FALSE;
    }
    
    int nSign;
    if( wchSep == L'+' )
    {
        nSign = -1;
    }
    else if ( wchSep == L'-' )
    {
        nSign = 1;
    }
    else
    {
        return FALSE;
    }
    
    // Convert it to SYSTEMTIME
    // ========================
    
    SYSTEMTIME st;
    st.wYear = nYear;
    st.wMonth = nMonth;
    st.wDay = nDay;
    st.wHour = nHour;
    st.wMinute = nMinute;
    st.wSecond = nSecond;
    st.wMilliseconds = 0;
    
    //
    // convert SYSTEMTIME to FILETIME
    //

    FILETIME ft;
    if ( !SystemTimeToFileTime( &st, &ft ) )
    {
        return FALSE;
    }
    
    rldbSeconds = (long double)*(__int64*)&ft;
    rldbSeconds += nMicro*10;
    rldbSeconds /= 10000000;
    
    // Now adjust for the offset
    // =========================
    
    rldbSeconds += nSign * nOffset * 60;     
    return TRUE;
}

BOOL DMTFToSeconds( LPCWSTR wszText, long double& rldbSeconds )
{
    if( wcslen(wszText) != 25 )
    {
        return FALSE;
    }

    if ( wszText[21] != ':' )
    {
        return DateTimeToSeconds( wszText, rldbSeconds );
    }

    return IntervalToSeconds( wszText, rldbSeconds );
}

   
CCimValue::CCimValue( ) : m_eType( e_Int ), m_iVal( 0 ) { }
 

HRESULT CCimValue::GetValue( VARIANT& rvValue, ULONG lCimType )
{
    VariantInit( &rvValue );
    WCHAR achBuff[255];
    BOOL bRes;

    switch( lCimType )
    {
    case CIM_SINT8: 
    case CIM_SINT16:
    case CIM_SINT32:
    case CIM_BOOLEAN:
        CoerceToInt();        
        V_VT(&rvValue) = VT_I4;
        V_I4(&rvValue) = m_iVal;
        break;

    case CIM_UINT8:	
    case CIM_UINT16:
    case CIM_UINT32:
        CoerceToUnsignedInt();
        V_VT(&rvValue) = VT_I4;
        V_I4(&rvValue) = m_uiVal;
        break;
	
    case CIM_SINT64:
    case CIM_STRING:
        CoerceToLong();
        _i64tow( m_lVal, achBuff, 10 );
        V_VT(&rvValue) = VT_BSTR;
        V_BSTR(&rvValue) = SysAllocString(achBuff);
        break;

    case CIM_REAL32:
        CoerceToFloat();
        V_VT(&rvValue) = VT_R4;
        V_R4(&rvValue) = m_fVal;
        break;

    case CIM_REAL64:
        CoerceToDouble();
        V_VT(&rvValue) = VT_R8;
        V_R8(&rvValue) = m_dbVal;
        break;

    case CIM_UINT64:
        CoerceToUnsignedLong();
        _ui64tow( m_ulVal, achBuff, 10 );
        V_VT(&rvValue) = VT_BSTR;
        V_BSTR(&rvValue) = SysAllocString(achBuff);
        break;

    case CIM_INTERVAL:
        CoerceToLongDouble();
        bRes = SecondsToInterval( m_ldbVal, achBuff, 255 );
        if ( !bRes ) { return WBEM_E_TYPE_MISMATCH; }
        V_VT(&rvValue) = VT_BSTR;
        V_BSTR(&rvValue) = SysAllocString(achBuff);
        break;

    case CIM_DATETIME:
        CoerceToLongDouble();
        bRes = SecondsToDateTime( m_ldbVal, achBuff, 255 );
        if ( !bRes ) { return WBEM_E_TYPE_MISMATCH; }
        V_VT(&rvValue) = VT_BSTR;
        V_BSTR(&rvValue) = SysAllocString(achBuff);
        break;

    default:
        return WBEM_E_TYPE_MISMATCH;
    };

    return WBEM_S_NO_ERROR;
}

HRESULT CCimValue::SetValue( VARIANT& rvValue, ULONG lCimType )
{
    HRESULT hr;
    VARIANT vValue;
    VariantInit( &vValue );

    if ( lCimType == CIM_EMPTY )
    {
        //
        // must be a numeric value. 
        //
        switch( V_VT(&rvValue) )
        {
        case VT_R4:
            m_eType = e_Float;
            m_fVal = V_R4(&rvValue);
            break;
        case VT_R8:
            m_eType = e_Double;
            m_dbVal = V_R8(&rvValue);
            break;
        case VT_BSTR:
            m_lVal = (__int64)_wtoi64( V_BSTR(&rvValue) );
            break;
        default:
            hr = VariantChangeType( &vValue, &rvValue, 0, VT_I4 );
            if ( FAILED(hr) ) return WBEM_E_TYPE_MISMATCH;
            m_eType = e_Int;
            m_iVal = V_I4(&vValue);
        };
        
        return WBEM_S_NO_ERROR;
    }
            
    switch( lCimType )
    {
    case CIM_SINT8: 
    case CIM_SINT16:
    case CIM_SINT32:
    case CIM_BOOLEAN:
        
        hr = VariantChangeType( &vValue, &rvValue, 0, VT_I4 );
        if ( FAILED(hr) ) return WBEM_E_TYPE_MISMATCH;
        m_eType = e_Int;
        m_iVal = V_I4(&vValue);
        break;

    case CIM_UINT8:	
    case CIM_UINT16:
    case CIM_UINT32:

        hr = VariantChangeType( &vValue, &rvValue, 0, VT_UI4 );
        if ( FAILED(hr) ) return WBEM_E_TYPE_MISMATCH;
        m_eType = e_UnsignedInt;
        m_uiVal = V_UI4(&vValue);
        break;
	
    case CIM_SINT64:
    case CIM_STRING:

        if ( V_VT(&rvValue) == VT_BSTR )
        {
            m_lVal = _wtoi64( V_BSTR(&rvValue) );
        }
        else
        {
            return WBEM_E_TYPE_MISMATCH;
        }
        m_eType = e_Long;
        break;

    case CIM_UINT64:

        if ( V_VT(&rvValue) == VT_BSTR )
        {
            m_ulVal = (unsigned __int64)_wtoi64( V_BSTR(&rvValue) );
        }
        else
        {
            return WBEM_E_TYPE_MISMATCH;
        }
        m_eType = e_UnsignedLong;
        break;

    case CIM_REAL32:

        hr = VariantChangeType( &vValue, &rvValue, 0, VT_R4 );
        if ( FAILED(hr) ) return WBEM_E_TYPE_MISMATCH;
        m_eType = CCimValue::e_Float;
        m_fVal = V_R4(&vValue);
        break;

    case CIM_REAL64:

        hr = VariantChangeType( &vValue, &rvValue, 0, VT_R8 );
        if ( FAILED(hr) ) return WBEM_E_TYPE_MISMATCH;
        m_eType = CCimValue::e_Double;
        m_dbVal = V_R8(&vValue);
        break;

    case CIM_DATETIME:
    case CIM_INTERVAL:
        
        if ( V_VT(&rvValue) == VT_BSTR )
        {
            BOOL bRes = DMTFToSeconds( V_BSTR(&rvValue), m_ldbVal );
        
            if ( !bRes )
            {
                return WBEM_E_TYPE_MISMATCH;
            }
        }
        else
        {
            return WBEM_E_TYPE_MISMATCH;
        }
        m_eType = e_LongDouble;
        break;

    default:
        return WBEM_E_TYPE_MISMATCH;
    };

    return WBEM_S_NO_ERROR;
}

void CCimValue::CoerceToLongDouble()
{
    switch( m_eType )
    {
    case e_Int:
        m_ldbVal = (long double)m_iVal;
        break;
    case e_UnsignedInt:
        m_ldbVal = (long double)m_uiVal;
        break;
    case e_Float:
        m_ldbVal = (long double)m_fVal;
        break;
    case e_Double:
        m_ldbVal = (long double)m_dbVal;
        break;
    case e_Long:
        m_ldbVal = (long double)m_lVal;
        break;
    case e_UnsignedLong: 
        m_ldbVal = (long double)(__int64)m_ulVal;
        break;
    };
    m_eType = e_LongDouble;
}

void CCimValue::CoerceToDouble()
{
    switch( m_eType )
    {
    case e_Int:
        m_dbVal = (double)m_iVal;
        break;
    case e_UnsignedInt:
        m_dbVal = (double)m_uiVal;
        break;
    case e_Float:
        m_dbVal = (double)m_fVal;
        break;
    case e_LongDouble:
        m_dbVal = (double)m_ldbVal;
        break;
    case e_Long:
        m_dbVal = (double)m_lVal;
        break;
    case e_UnsignedLong: 
        m_dbVal = (double)(__int64)m_ulVal;
        break;
    };
    m_eType = e_Double;
}

void CCimValue::CoerceToFloat()
{
    switch( m_eType )
    {
    case e_Int:
        m_fVal = (float)m_iVal;
        break;
    case e_UnsignedInt:
        m_fVal = (float)m_uiVal;
        break;
    case e_LongDouble:
        m_fVal = (float)m_ldbVal;
        break;
    case e_Double:
        m_fVal = (float)m_dbVal;
        break;
    case e_Long:
        m_fVal = (float)m_lVal;
        break;
    case e_UnsignedLong: 
        m_fVal = (float)(__int64)m_ulVal;
        break;
    };
    m_eType = e_Float;
}

void CCimValue::CoerceToUnsignedLong()
{
    switch( m_eType )
    {
    case e_Int:
        m_ulVal = (unsigned __int64)m_iVal;
        break;
    case e_UnsignedInt:
        m_ulVal = (unsigned __int64)m_uiVal;
        break;
    case e_Float:
        m_ulVal = (unsigned __int64)m_fVal;
        break;
    case e_Double:
        m_ulVal = (unsigned __int64)m_dbVal;
        break;
    case e_Long:
        m_ulVal = (unsigned __int64)m_lVal;
        break;
    case e_LongDouble: 
        m_ulVal = (unsigned __int64)m_ldbVal;
        break;
    };
    m_eType = e_UnsignedLong;
}

void CCimValue::CoerceToLong()
{
    switch( m_eType )
    {
    case e_Int:
        m_lVal = (__int64)m_iVal;
        break;
    case e_UnsignedInt:
        m_lVal = (__int64)m_uiVal;
        break;
    case e_Float:
        m_lVal = (__int64)m_fVal;
        break;
    case e_Double:
        m_lVal = (__int64)m_dbVal;
        break;
    case e_UnsignedLong:
        m_lVal = (__int64)m_ulVal;
        break;
    case e_LongDouble: 
        m_lVal = (__int64)m_ldbVal;
        break;
    };
    m_eType = e_Long;
}

void CCimValue::CoerceToUnsignedInt()
{
    switch( m_eType )
    {
    case e_Int:
        m_uiVal = (unsigned __int32)m_iVal;
        break;
    case e_Float:
        m_uiVal = (unsigned __int32)m_fVal;
        break;
    case e_Double:
        m_uiVal = (unsigned __int32)m_dbVal;
        break;
    case e_Long:
        m_uiVal = (unsigned __int32)m_lVal;
        break;
    case e_UnsignedLong:
        m_uiVal = (unsigned __int32)m_ulVal;
        break;
    case e_LongDouble: 
        m_uiVal = (unsigned __int32)m_ldbVal;
        break;
    };
    m_eType = e_UnsignedInt;
}

void CCimValue::CoerceToInt()
{
    switch( m_eType )
    {
    case e_Long:
        m_iVal = (__int32)m_lVal;
        break;
    case e_UnsignedInt:
        m_iVal = (__int32)m_uiVal;
        break;
    case e_Float:
        m_iVal = (__int32)m_fVal;
        break;
    case e_Double:
        m_iVal = (__int32)m_dbVal;
        break;
    case e_UnsignedLong:
        m_iVal = (__int32)m_ulVal;
        break;
    case e_LongDouble: 
        m_iVal = (__int32)m_ldbVal;
        break;
    };
    m_eType = e_Int;
}

void HandleConversion( CCimValue& rValA, CCimValue& rValB )
{
    if ( rValA.m_eType == rValB.m_eType )
    {
        return;
    }

    if ( rValA.m_eType == CCimValue::e_LongDouble )
    {
        rValB.CoerceToLongDouble();
        return;
    }
    
    if ( rValB.m_eType == CCimValue::e_LongDouble )
    {
        rValA.CoerceToLongDouble();
        return;
    }

    if ( rValA.m_eType == CCimValue::e_Double )
    {
        rValB.CoerceToDouble();
        return;
    }
    
    if ( rValB.m_eType == CCimValue::e_Double )
    {
        rValA.CoerceToDouble();
        return;
    }

    if ( rValA.m_eType == CCimValue::e_Float )
    {
        rValB.CoerceToFloat();
        return;
    }
    
    if ( rValB.m_eType == CCimValue::e_Float )
    {
        rValA.CoerceToFloat();
        return;
    }

    if ( rValA.m_eType == CCimValue::e_UnsignedLong )
    {
        rValB.CoerceToUnsignedLong();
        return;
    }
    
    if ( rValB.m_eType == CCimValue::e_UnsignedLong )
    {
        rValA.CoerceToUnsignedLong();
        return;
    }

    if ( rValA.m_eType == CCimValue::e_Long && 
         rValB.m_eType == CCimValue::e_UnsignedInt || 
         rValB.m_eType == CCimValue::e_Long && 
         rValA.m_eType == CCimValue::e_UnsignedInt )
    {
        rValA.CoerceToUnsignedLong();
        rValB.CoerceToUnsignedLong();
        return;
    }

    if ( rValA.m_eType == CCimValue::e_Long )
    {
        rValB.CoerceToLong();
        return;
    }
    
    if ( rValB.m_eType == CCimValue::e_Long )
    {
        rValA.CoerceToLong();
        return;
    }

    if ( rValA.m_eType == CCimValue::e_UnsignedInt )
    {
        rValB.CoerceToUnsignedInt();
        return;
    }
    
    if ( rValB.m_eType == CCimValue::e_UnsignedInt )
    {
        rValA.CoerceToUnsignedInt();
        return;
    }

    // this means both must be e_Int, but our check in the beginning 
    // should have handled this...

    assert( 0 );
    
}

CCimValue operator+ ( CCimValue ValA, CCimValue ValB )
{
    HandleConversion( ValA, ValB );

    assert( ValA.m_eType == ValB.m_eType );

    switch( ValA.m_eType )
    {
    case CCimValue::e_Int:
        ValA.m_iVal += ValB.m_iVal;
        break;
    case CCimValue::e_UnsignedInt:
        ValA.m_uiVal += ValB.m_uiVal;
        break;
    case CCimValue::e_Float:
        ValA.m_fVal += ValB.m_fVal;
        break;
    case CCimValue::e_Double:
        ValA.m_dbVal += ValB.m_dbVal;
        break;
    case CCimValue::e_LongDouble:
        ValA.m_ldbVal += ValB.m_ldbVal;
        break;
    case CCimValue::e_Long:
        ValA.m_lVal += ValB.m_lVal;
        break;
    case CCimValue::e_UnsignedLong: 
        ValA.m_ulVal += ValB.m_ulVal;
        break;
    default:
        assert(0);
    };

    return ValA;
}

CCimValue operator- ( CCimValue ValA, CCimValue ValB )
{
    HandleConversion( ValA, ValB );

    assert( ValA.m_eType == ValB.m_eType );

    switch( ValA.m_eType )
    {
    case CCimValue::e_Int:
        ValA.m_iVal -= ValB.m_iVal;
        break;
    case CCimValue::e_UnsignedInt:
        ValA.m_uiVal -= ValB.m_uiVal;
        break;
    case CCimValue::e_Float:
        ValA.m_fVal -= ValB.m_fVal;
        break;
    case CCimValue::e_Double:
        ValA.m_dbVal -= ValB.m_dbVal;
        break;
    case CCimValue::e_Long:
        ValA.m_lVal -= ValB.m_lVal;
        break;
    case CCimValue::e_UnsignedLong: 
        ValA.m_ulVal -= ValB.m_ulVal;
        break;
    case CCimValue::e_LongDouble:
        ValA.m_ldbVal -= ValB.m_ldbVal;
        break;
    default:
        assert(0);
    };

    return ValA;
}

CCimValue operator* ( CCimValue ValA, CCimValue ValB )
{
    HandleConversion( ValA, ValB );

    assert( ValA.m_eType == ValB.m_eType );

    switch( ValA.m_eType )
    {
    case CCimValue::e_Int:
        ValA.m_iVal *= ValB.m_iVal;
        break;
    case CCimValue::e_UnsignedInt:
        ValA.m_uiVal *= ValB.m_uiVal;
        break;
    case CCimValue::e_Float:
        ValA.m_fVal *= ValB.m_fVal;
        break;
    case CCimValue::e_Double:
        ValA.m_dbVal *= ValB.m_dbVal;
        break;
    case CCimValue::e_Long:
        ValA.m_lVal *= ValB.m_lVal;
        break;
    case CCimValue::e_UnsignedLong: 
        ValA.m_ulVal *= ValB.m_ulVal;
        break;
    case CCimValue::e_LongDouble:
        ValA.m_ldbVal *= ValB.m_ldbVal;
        break;
    default:
        assert(0);
    };

    return ValA;
}

CCimValue operator/ ( CCimValue ValA, CCimValue ValB )
{
    HandleConversion( ValA, ValB );

    assert( ValA.m_eType == ValB.m_eType );

    //
    // will raise a structured exception if div by 0.
    // caller is expected to handle this..
    //
   
    switch( ValA.m_eType )
    {
    case CCimValue::e_Int:
        if ( ValB.m_iVal == 0 ) throw CX_DivideByZeroException();
        ValA.m_iVal /= ValB.m_iVal;
        break;
    case CCimValue::e_UnsignedInt:
        if ( ValB.m_uiVal == 0 ) throw CX_DivideByZeroException();
        ValA.m_uiVal /= ValB.m_uiVal;
        break;
    case CCimValue::e_Float:
        if ( ValB.m_fVal == 0 ) throw CX_DivideByZeroException();
        ValA.m_fVal /= ValB.m_fVal;
        break;
    case CCimValue::e_Double:
        if ( ValB.m_dbVal == 0 ) throw CX_DivideByZeroException();
        ValA.m_dbVal /= ValB.m_dbVal;
        break;
    case CCimValue::e_Long:
        if ( ValB.m_lVal == 0 ) throw CX_DivideByZeroException();
        ValA.m_lVal /= ValB.m_lVal;
        break;
    case CCimValue::e_UnsignedLong: 
        if ( ValB.m_ulVal == 0 ) throw CX_DivideByZeroException();
        ValA.m_ulVal /= ValB.m_ulVal;
        break;
    case CCimValue::e_LongDouble:
        if ( ValB.m_ldbVal == 0 ) throw CX_DivideByZeroException();
        ValA.m_ldbVal /= ValB.m_ldbVal;
        break;
    default:
        assert(0);
    };   

    return ValA;
}

CCimValue operator% ( CCimValue ValA, CCimValue ValB )
{
    HandleConversion( ValA, ValB );

    assert( ValA.m_eType == ValB.m_eType );

    //
    // will raise a structured exception if div by 0.
    // caller is expected to handle this..
    //
   
    switch( ValA.m_eType )
    {
    case CCimValue::e_Int:
        if ( ValB.m_iVal == 0 ) throw CX_DivideByZeroException();
        ValA.m_iVal %= ValB.m_iVal;
        break;
    case CCimValue::e_UnsignedInt:
        if ( ValB.m_uiVal == 0 ) throw CX_DivideByZeroException();
        ValA.m_uiVal %= ValB.m_uiVal;
        break;
    case CCimValue::e_Float:
    case CCimValue::e_Double:
    case CCimValue::e_LongDouble:
        throw CX_InvalidFloatingPointOperationException();
    case CCimValue::e_Long:
        if ( ValB.m_lVal == 0 ) throw CX_DivideByZeroException();
        ValA.m_lVal %= ValB.m_lVal;
        break;
    case CCimValue::e_UnsignedLong: 
        if ( ValB.m_ulVal == 0 ) throw CX_DivideByZeroException();
        ValA.m_ulVal %= ValB.m_ulVal;
        break;
    default:
        assert(0);
    };

    return ValA;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\winmgmt\wbemcomn\callsec.cpp ===
/*++

Copyright (C) 1998-2001 Microsoft Corporation

Module Name:

    CALLSEC.CPP

Abstract:

    IWbemCallSecurity, IServerSecurity implementation for
    provider impersonation.

History:

    raymcc      29-Jul-98        First draft.

--*/

#include "precomp.h"
#include <stdio.h>

#include <initguid.h>
#include <winntsec.h>
#include <callsec.h>
#include <cominit.h>
#include <arrtempl.h>
#include <cominit.h>
#include <genutils.h>
#include <helper.h>

//***************************************************************************
//
//  CWbemCallSecurity
//
//  This object is used to supply client impersonation to providers.
//
//  Usage:
//  (1) When client first makes call, call CreateInst() and get a new
//      empty object (ref count of 1).  Constructors/Destructors are private.
//  
//***************************************************************************
// ok

CWbemCallSecurity::CWbemCallSecurity()
{
#ifdef WMI_PRIVATE_DBG
	m_currentThreadID = 0;
	m_lastRevert = 0;
#endif
    m_lRef = 1;                             // Ref count

    m_hThreadToken = 0;                     // Handle to thread imp token

    m_dwPotentialImpLevel   = 0;            // Potential 
    m_dwActiveImpLevel      = 0;            // Active impersonation

    m_dwAuthnSvc   = 0;
    m_dwAuthzSvc   = 0;
    m_dwAuthnLevel = 0;

    m_pServerPrincNam = 0;
    m_pIdentity = 0;
}



//***************************************************************************
//
//  ~CWbemCallSecurity
//
//  Destructor.  Closes any open handles, deallocates any non-NULL
//  strings.
//
//***************************************************************************
// ok

CWbemCallSecurity::~CWbemCallSecurity()
{
    if (m_hThreadToken)
        CloseHandle(m_hThreadToken);

    if (m_pServerPrincNam)
        CoTaskMemFree(m_pServerPrincNam);

    if (m_pIdentity)
        CoTaskMemFree(m_pIdentity);
}


CWbemCallSecurity::CWbemCallSecurity(const CWbemCallSecurity& Other)
{
#ifdef WMI_PRIVATE_DBG
	m_currentThreadID = 0;
        m_lastRevert = 0;
#endif

    HANDLE hTmpToken = NULL;

    if ( Other.m_hThreadToken )
    {
        if (!DuplicateHandle(
                GetCurrentProcess(),
                Other.m_hThreadToken, 
                GetCurrentProcess(),
                &hTmpToken,
                0,
                TRUE,
                DUPLICATE_SAME_ACCESS))
        throw CX_Exception();
    }

    WCHAR * pTmpPrincipal = NULL;
    if (Other.m_pServerPrincNam)
    {        
        size_t tmpLength = wcslen(Other.m_pServerPrincNam) + 1;
        pTmpPrincipal = (LPWSTR)CoTaskMemAlloc(tmpLength * (sizeof wchar_t));
        if(NULL == pTmpPrincipal) 
        {
            if (hTmpToken) CloseHandle(hTmpToken);
            throw CX_MemoryException();
        }
        StringCchCopyW(pTmpPrincipal , tmpLength, Other.m_pServerPrincNam);
    }

    WCHAR * pTmpIdentity = NULL;
    if (Other.m_pIdentity)
    {        
        size_t tmpLength = wcslen(Other.m_pIdentity) + 1;
        pTmpIdentity = (LPWSTR)CoTaskMemAlloc( tmpLength * (sizeof wchar_t));
        if(NULL == pTmpIdentity)
        {
           if (hTmpToken) CloseHandle(hTmpToken);
           CoTaskMemFree(pTmpPrincipal);
           throw CX_MemoryException();            
        }
        StringCchCopyW(pTmpIdentity, tmpLength , Other.m_pIdentity);
    }

    m_hThreadToken = hTmpToken;
    m_dwPotentialImpLevel   = Other.m_dwPotentialImpLevel; 
    m_dwActiveImpLevel      = 0; 
    m_dwAuthnSvc   = Other.m_dwAuthnSvc;
    m_dwAuthzSvc   = Other.m_dwAuthzSvc;
    m_dwAuthnLevel = Other.m_dwAuthnLevel;
    m_pServerPrincNam = pTmpPrincipal;
    m_pIdentity = pTmpIdentity;
}
    
CWbemCallSecurity &
CWbemCallSecurity::operator=(const CWbemCallSecurity& Other)
{
    CWbemCallSecurity tmp(Other);

    std::swap(m_hThreadToken, tmp.m_hThreadToken);
    std::swap( m_dwPotentialImpLevel,tmp.m_dwPotentialImpLevel);
    std::swap( m_dwActiveImpLevel, tmp.m_dwActiveImpLevel);
    std::swap( m_dwAuthnSvc, tmp.m_dwAuthnSvc);
    std::swap( m_dwAuthzSvc, tmp.m_dwAuthzSvc);
    std::swap( m_dwAuthnLevel, tmp.m_dwAuthnLevel);
    std::swap( m_pServerPrincNam, tmp.m_pServerPrincNam);
    std::swap( m_pIdentity, tmp.m_pIdentity);
    return *this;
}

    
//***************************************************************************
//
//  CWbemCallSecurity::AddRef
//
//***************************************************************************
// ok

ULONG CWbemCallSecurity::AddRef()
{
    return InterlockedIncrement(&m_lRef);
}

//***************************************************************************
//
//  CWbemCallSecurity::Release
//
//***************************************************************************
// ok

ULONG CWbemCallSecurity::Release()
{
    long lRef = InterlockedDecrement(&m_lRef);
    if(lRef == 0)
        delete this;
    return lRef;
}

//***************************************************************************
//
//  CWbemCallSecurity::QueryInterface
//
//***************************************************************************
// ok

HRESULT CWbemCallSecurity::QueryInterface(REFIID riid, void** ppv)
{
    if(riid == IID_IUnknown)
    {
        *ppv = (IUnknown *) this;
        AddRef();
        return S_OK;
    }
    else if (riid == IID_IServerSecurity)
    {
        *ppv = (IServerSecurity *) this;
        AddRef();
        return S_OK;
    }
    else if (riid == IID_IWbemCallSecurity)
    {
        *ppv = (IWbemCallSecurity *) this;
        AddRef();
        return S_OK;
    }

    else return E_NOINTERFACE;
}


//***************************************************************************
//
// CWbemCallSecurity:QueryBlanket
//
//***************************************************************************
// ok

HRESULT STDMETHODCALLTYPE CWbemCallSecurity::QueryBlanket( 
    /* [out] */ DWORD __RPC_FAR *pAuthnSvc,
    /* [out] */ DWORD __RPC_FAR *pAuthzSvc,
    /* [out] */ OLECHAR __RPC_FAR *__RPC_FAR *pServerPrincName,
    /* [out] */ DWORD __RPC_FAR *pAuthnLevel,
    /* [out] */ DWORD __RPC_FAR *pImpLevel,
    /* [out] */ void __RPC_FAR *__RPC_FAR *pPrivs,
    /* [out] */ DWORD __RPC_FAR *pCapabilities
    )
{
    if (m_dwPotentialImpLevel == 0 )
        return E_FAIL;

    // Return DWORD parameters, after checking.
    // ========================================

    if (pAuthnSvc)
        *pAuthnSvc = m_dwAuthnSvc;

    if (pAuthzSvc)
        *pAuthzSvc = m_dwAuthzSvc ;

    if (pImpLevel)
        *pImpLevel = m_dwActiveImpLevel ;

    if (pAuthnLevel)
        *pAuthnLevel = m_dwAuthnLevel;

    if (pServerPrincName)
    {
        *pServerPrincName = 0;
        
        if (m_pServerPrincNam)
        {        
        size_t tmpLength = wcslen(m_pServerPrincNam) + 1;
            *pServerPrincName = (LPWSTR) CoTaskMemAlloc(tmpLength * (sizeof wchar_t));
            if (*pServerPrincName)
            {
                StringCchCopyW(*pServerPrincName, tmpLength , m_pServerPrincNam);
            }
            else
            {
                return E_OUTOFMEMORY;
            }
        }
    }        

    if (pPrivs)
    {
        *pPrivs = m_pIdentity;  // Documented to point to an internal!!
    }

    return S_OK;
}

//***************************************************************************
//
//  CWbemCallSecurity::ImpersonateClient
//
//***************************************************************************
// ok
        
HRESULT STDMETHODCALLTYPE CWbemCallSecurity::ImpersonateClient(void)
{
#ifdef WMI_PRIVATE_DBG
    _DBG_ASSERT(m_currentThreadID == 0 || m_currentThreadID == GetCurrentThreadId());
    m_currentThreadID = GetCurrentThreadId();
#endif
    if (m_dwActiveImpLevel != 0)        // Already impersonating
        return S_OK;

    if(m_hThreadToken == NULL)
    {
        return WBEM_E_INVALID_CONTEXT;
    }
    
    if (m_dwPotentialImpLevel == 0)
        return (ERROR_CANT_OPEN_ANONYMOUS | 0x80070000);

    BOOL bRes;

    bRes = SetThreadToken(NULL, m_hThreadToken);

    if (bRes)
    {
        m_dwActiveImpLevel = m_dwPotentialImpLevel; 
        return S_OK;
    }

    return E_FAIL;
}


//***************************************************************************
//
//  CWbemCallSecurity::RevertToSelf
//
//  Returns S_OK or E_FAIL.
//  Returns E_NOTIMPL on Win9x platforms.
//
//***************************************************************************        
// ok

HRESULT STDMETHODCALLTYPE CWbemCallSecurity::RevertToSelf( void)
{
#ifdef WMI_PRIVATE_DBG
    _DBG_ASSERT(m_currentThreadID == GetCurrentThreadId() || m_currentThreadID == 0);
    m_currentThreadID = 0;
    m_lastRevert = GetCurrentThreadId();
#endif

    if (m_dwActiveImpLevel == 0)
        return S_OK;

    if (m_dwPotentialImpLevel == 0)
        return (ERROR_CANT_OPEN_ANONYMOUS | 0x80070000);

    // If here,we are impersonating and can definitely revert.
    // =======================================================

    BOOL bRes = SetThreadToken(NULL, NULL);

    if (bRes == FALSE)
        return E_FAIL;

    m_dwActiveImpLevel = 0;        // No longer actively impersonating

    return S_OK;
}


//***************************************************************************
//
//  CWbemCallSecurity::IsImpersonating
//
//***************************************************************************
        
BOOL STDMETHODCALLTYPE CWbemCallSecurity::IsImpersonating( void)
{
#ifdef WMI_PRIVATE_DBG
#ifdef DBG
    IServerSecurity * privateDbgCallSec = NULL;
    CoGetCallContext(IID_IUnknown,(void **)&privateDbgCallSec);
    if (m_dwActiveImpLevel && privateDbgCallSec == this)
    {
        HANDLE hToken = NULL;
        BOOL bRes = OpenThreadToken(GetCurrentThread(),TOKEN_QUERY,TRUE,&hToken);
        _DBG_ASSERT(bRes);
        if (hToken) CloseHandle(hToken);
    };
    if (privateDbgCallSec) privateDbgCallSec->Release();
#endif
#endif

    if (m_hThreadToken && m_dwActiveImpLevel != 0)
        return TRUE;

    return FALSE;
}

        

//***************************************************************************
//
//  CWbemCallSecurity::CreateInst
//
//  Creates a new instance 
//***************************************************************************
// ok

IWbemCallSecurity * CWbemCallSecurity::CreateInst()
{
    return (IWbemCallSecurity *) new CWbemCallSecurity;   // Constructed with ref count of 1
}


//***************************************************************************
//
//  CWbemCallSecurity::GetPotentialImpersonation
//
//  Returns 0 if no impersonation is currently possible or the
//  level which would be active during impersonation:
//
//  RPC_C_IMP_LEVEL_ANONYMOUS    
//  RPC_C_IMP_LEVEL_IDENTIFY     
//  RPC_C_IMP_LEVEL_IMPERSONATE  
//  RPC_C_IMP_LEVEL_DELEGATE     
//  
//***************************************************************************
// ok

HRESULT CWbemCallSecurity::GetPotentialImpersonation()
{
    return m_dwPotentialImpLevel;
}


//***************************************************************************
//
//  CWbemCallSecurity::GetActiveImpersonation
//
//  Returns 0 if no impersonation is currently active or the
//  currently active level:
//
//  RPC_C_IMP_LEVEL_ANONYMOUS    
//  RPC_C_IMP_LEVEL_IDENTIFY     
//  RPC_C_IMP_LEVEL_IMPERSONATE  
//  RPC_C_IMP_LEVEL_DELEGATE     
//  
//***************************************************************************
// ok
       
HRESULT CWbemCallSecurity::GetActiveImpersonation()
{
    return m_dwActiveImpLevel;
}


//***************************************************************************
//
//  CWbemCallSecurity::CloneThreadContext
//
//  Call this on a thread to retrieve the potential impersonation info for
//  that thread and set the current object to be able to duplicate it later.
//
//  Return codes:
//
//  S_OK
//  E_FAIL
//  E_NOTIMPL on Win9x
//  E_ABORT if the calling thread is already impersonating a client.
//
//***************************************************************************

HRESULT CWbemCallSecurity::CloneThreadContext(BOOL bInternallyIssued)
{
    if (m_hThreadToken)     // Already called this
        return E_ABORT; 

    // Get the current context.
    // ========================

    IServerSecurity *pSec = 0;
    HRESULT hRes = WbemCoGetCallContext(IID_IServerSecurity, (LPVOID *) &pSec);
    CReleaseMe rmSec(pSec);

    if (hRes != S_OK)
    {
        // There is no call context --- this must be an in-proc object calling
        // us from its own thread.  Initialize from current thread token
        // ===================================================================

        return CloneThreadToken();
    }

    // Figure out if the call context is ours or RPCs
    // ==============================================

    IWbemCallSecurity* pInternal = NULL;
    if(SUCCEEDED(pSec->QueryInterface(IID_IWbemCallSecurity, 
                                        (void**)&pInternal)))
    {
        CReleaseMe rmInt(pInternal);
        // This is our own call context --- this must be ab in-proc object
        // calling us from our thread.  Behave depending on the flags
        // ===============================================================
        if(bInternallyIssued)
        {
            // Internal requests always propagate context. Therefore, we just
            // copy the context that we have got
            // ==============================================================
            try 
            {
                *this = *(CWbemCallSecurity*)pInternal;
                return S_OK;
            }
            catch (CX_Exception &)
            {
                return WBEM_E_OUT_OF_MEMORY;
            }
        }
        else
        {
            // Provider request --- Initialize from the current thread token
            // =============================================================
            return CloneThreadToken();
        }
    }

    // If here, we are not impersonating and we want to gather info
    // about the client's call.
    // ============================================================

    RPC_AUTHZ_HANDLE hAuth;

    DWORD t_ImpLevel = 0 ;

    hRes = pSec->QueryBlanket(
        &m_dwAuthnSvc,
        &m_dwAuthzSvc,
        &m_pServerPrincNam,
        &m_dwAuthnLevel,
        &t_ImpLevel,
        &hAuth,              // RPC_AUTHZ_HANDLE
        NULL                    // Capabilities; not used
        );

    if(FAILED(hRes))
    {
        
        // In some cases, we cant get the name, but the rest is ok.  In particular
        // the temporary SMS accounts have that property.  Or nt 4 after IPCONFIG /RELEASE

        hRes = pSec->QueryBlanket(
        &m_dwAuthnSvc,
        &m_dwAuthzSvc,
        &m_pServerPrincNam,
        &m_dwAuthnLevel,
        &t_ImpLevel,
        NULL,              // RPC_AUTHZ_HANDLE
        NULL                    // Capabilities; not used
        );
        hAuth = NULL;
    }

    if(FAILED(hRes))
    {
        // THIS IS A WORKAROUND FOR COM BUG:
        // This failure is indicative of an anonymous-level client. 
        // ========================================================

        m_dwPotentialImpLevel = 0;
        return S_OK;
    }
        
    if (hAuth)
    {
        size_t tmpLenght = wcslen(LPWSTR(hAuth)) + 1;
        m_pIdentity = LPWSTR(CoTaskMemAlloc(tmpLenght * (sizeof wchar_t)));
        if(m_pIdentity)
            StringCchCopyW(m_pIdentity, tmpLenght , LPWSTR(hAuth));
    }

    // Impersonate the client long enough to clone the thread token.
    // =============================================================

    BOOL bImp = pSec->IsImpersonating();
    if(!bImp)
        hRes = pSec->ImpersonateClient();

    if (FAILED(hRes))
    {
        if(!bImp)
            pSec->RevertToSelf();
        return E_FAIL;
    }

    HRESULT hres = CloneThreadToken();

    if(!bImp)
        pSec->RevertToSelf();

    return hres;
}

void AdjustPrivIfLocalSystem(HANDLE hPrimary)
{
    ////////////////////
    // if we are in LocalSystem, enable all the privileges here
    // to prevent the AdjustTokenPrivileges call done
    // when ESS calls into WmiPrvSe, and preventing WmiPrvSe to 
    // build a HUGE LRPC_SCONTEXT dictionary
    // from now on, if we fail, we bail out with success,
    // since the Token Duplication has succeeded

    DWORD dwSize = sizeof(TOKEN_USER)+sizeof(SID)+(SID_MAX_SUB_AUTHORITIES*sizeof(DWORD));       
    BYTE Array[sizeof(TOKEN_USER)+sizeof(SID)+(SID_MAX_SUB_AUTHORITIES*sizeof(DWORD))];
    TOKEN_USER * pTokenUser = (TOKEN_USER *)Array;

    BOOL bRet = GetTokenInformation(hPrimary,TokenUser,pTokenUser,dwSize,&dwSize);

    if (!bRet) return;

    SID SystemSid = { SID_REVISION,
                      1,
                      SECURITY_NT_AUTHORITY,
                      SECURITY_LOCAL_SYSTEM_RID 
                    };
    PSID pSIDUser = pTokenUser->User.Sid;
    DWORD dwUserSidLen = GetLengthSid(pSIDUser);
    DWORD dwSystemSid = GetLengthSid(&SystemSid);
    BOOL bIsSystem = FALSE;
    if (dwUserSidLen == dwSystemSid)
    {
        bIsSystem = (0 == memcmp(&SystemSid,pSIDUser,dwUserSidLen));
    };

    if (bIsSystem) // enable all the priviliges
    {
        DWORD dwReturnedLength = 0;
        if (FALSE == GetTokenInformation(hPrimary,TokenPrivileges,NULL,0,&dwReturnedLength))
        {
            if (ERROR_INSUFFICIENT_BUFFER != GetLastError()) return;
        }

        BYTE * pBufferPriv = (BYTE *)LocalAlloc(0,dwReturnedLength);
        
        if (NULL == pBufferPriv) return;
        OnDelete<HLOCAL,HLOCAL(*)(HLOCAL),LocalFree> FreeMe(pBufferPriv);

        bRet = GetTokenInformation(hPrimary,TokenPrivileges,pBufferPriv,dwReturnedLength,&dwReturnedLength);
        if (!bRet) return;

        TOKEN_PRIVILEGES *pPrivileges = ( TOKEN_PRIVILEGES * ) pBufferPriv ;
        BOOL bNeedToAdjust = FALSE;

        for ( ULONG lIndex = 0; lIndex < pPrivileges->PrivilegeCount ; lIndex ++ )
        {
            if (!(pPrivileges->Privileges [lIndex].Attributes & SE_PRIVILEGE_ENABLED))
            {
                bNeedToAdjust = TRUE;
                pPrivileges->Privileges[lIndex].Attributes |= SE_PRIVILEGE_ENABLED ;
            }
        }

        if (bNeedToAdjust)
        {
            bRet = AdjustTokenPrivileges (hPrimary, FALSE, pPrivileges,0,NULL,NULL);            
        }

        if ( !bRet) return;    
    }
}

    
HRESULT CWbemCallSecurity::CloneThreadToken()
{
    HANDLE hPrimary = 0 ;
    HANDLE hToken = 0;

    BOOL bRes = OpenThreadToken(
        GetCurrentThread(),
        TOKEN_QUERY | TOKEN_DUPLICATE | TOKEN_IMPERSONATE,
        TRUE,
        &hToken
        );

    if (bRes == FALSE)
    {
        m_hThreadToken = NULL;
        m_dwAuthnSvc = RPC_C_AUTHN_WINNT;
        m_dwAuthzSvc = RPC_C_AUTHZ_NONE;
        m_dwAuthnLevel = RPC_C_AUTHN_LEVEL_PKT_PRIVACY;
        m_pServerPrincNam = NULL;
        m_pIdentity = NULL;

        long lRes = GetLastError();
        if(lRes == ERROR_NO_IMPERSONATION_TOKEN || lRes == ERROR_NO_TOKEN)
        {
            // This is the basic process thread. 
            // =================================

            bRes = OpenProcessToken(GetCurrentProcess(),
                                   TOKEN_QUERY | TOKEN_DUPLICATE | TOKEN_IMPERSONATE,
                                   &hPrimary);

            if (bRes==FALSE)
            {
                // Unknown error
                // =============
                m_dwPotentialImpLevel = 0;
                return E_FAIL;
            }
        }
        else if(lRes == ERROR_CANT_OPEN_ANONYMOUS)
        {
            // Anonymous call   
            // ==============

            m_dwPotentialImpLevel = 0;
            return S_OK;
        }
        else
        {
            // Unknown error
            // =============

            m_dwPotentialImpLevel = 0;
            return E_FAIL;
        }
    }


    // Find out token info.
    // =====================

    SECURITY_IMPERSONATION_LEVEL t_Level = SecurityImpersonation ;

    if ( hToken )
    {
        DWORD dwBytesReturned = 0;

        bRes = GetTokenInformation (

            hToken,
            TokenImpersonationLevel, 
            ( void * ) & t_Level,
            sizeof ( t_Level ),
            &dwBytesReturned
        );

        if (bRes == FALSE)
        {
            CloseHandle(hToken);
            return E_FAIL;
        }
    }

    switch (t_Level)
    {
        case SecurityAnonymous:
            m_dwPotentialImpLevel = RPC_C_IMP_LEVEL_ANONYMOUS;
            break;
            
        case SecurityIdentification:
            m_dwPotentialImpLevel = RPC_C_IMP_LEVEL_IDENTIFY;
            break;

        case SecurityImpersonation:
            m_dwPotentialImpLevel = RPC_C_IMP_LEVEL_IMPERSONATE;
            break;

        case SecurityDelegation:
            m_dwPotentialImpLevel = RPC_C_IMP_LEVEL_DELEGATE;
            break;

        default:
            m_dwPotentialImpLevel = 0;
            break;
    }

    // Duplicate the handle.
    // ============================

    bRes = DuplicateToken (
        hToken ? hToken : hPrimary ,
        (SECURITY_IMPERSONATION_LEVEL)t_Level,
        &m_hThreadToken
        );

    if ( hToken )
    {
        CloseHandle(hToken);
    }
    else
    {
        CloseHandle(hPrimary);
    }

    if (bRes == FALSE)
        return E_FAIL;

    AdjustPrivIfLocalSystem(m_hThreadToken);

    return S_OK;
}

RELEASE_ME CWbemCallSecurity* CWbemCallSecurity::MakeInternalCopyOfThread()
{
    IServerSecurity* pSec;
    HRESULT hres = WbemCoGetCallContext(IID_IServerSecurity, (void**)&pSec);
    if(FAILED(hres))
        return NULL;

    CReleaseMe rm1(pSec);

    IServerSecurity* pIntSec;
    hres = pSec->QueryInterface(IID_IWbemCallSecurity, (void**)&pIntSec);
    if(FAILED(hres))
        return NULL;

    CWbemCallSecurity* pCopy = new CWbemCallSecurity;
    
    if (pCopy)
        *pCopy = *(CWbemCallSecurity*)pIntSec;

    pIntSec->Release();
    return pCopy;
}
        

DWORD CWbemCallSecurity::GetAuthenticationId(LUID& rluid)
{
    if(m_hThreadToken == NULL)
        return ERROR_INVALID_HANDLE;

    TOKEN_STATISTICS stat;
    DWORD dwRet;
    if(!GetTokenInformation(m_hThreadToken, TokenStatistics, 
            (void*)&stat, sizeof(stat), &dwRet))
    {
        return GetLastError();
    }
    
    rluid = stat.AuthenticationId;
    return 0;
}
    
HANDLE CWbemCallSecurity::GetToken()
{
    return m_hThreadToken;
}
            
HRESULT RetrieveSidFromCall(CNtSid & sid)
{
    HANDLE hToken;
    HRESULT hres;
    BOOL bRes;

    // Check if we are on an impersonated thread
    // =========================================

    bRes = OpenThreadToken(GetCurrentThread(), TOKEN_READ, TRUE, &hToken);
    if(bRes)
    {
        // We are --- just use this token for authentication
        // =================================================
        hres = RetrieveSidFromToken(hToken, sid);
        CloseHandle(hToken);
        return hres;
    }

    // Construct CWbemCallSecurity that will determine (according to our
    // non-trivial provider handling rules) the security context of this 
    // call
    // =================================================================

    IWbemCallSecurity* pServerSec = CWbemCallSecurity::CreateInst();
    if(pServerSec == NULL)
        return WBEM_E_OUT_OF_MEMORY;

    CReleaseMe rm1(pServerSec);

    hres = pServerSec->CloneThreadContext(FALSE);
    if(FAILED(hres))
        return hres;

    // Impersonate client
    // ==================

    hres = pServerSec->ImpersonateClient();
    if(FAILED(hres))
        return hres;

    // Open impersonated token
    // =======================

    bRes = OpenThreadToken(GetCurrentThread(), TOKEN_READ, TRUE, &hToken);
    if(!bRes)
    {
        long lRes = GetLastError();
        if(lRes == ERROR_NO_IMPERSONATION_TOKEN || lRes == ERROR_NO_TOKEN)
        {
            // Not impersonating --- get the process token instead
            // ===================================================

            bRes = OpenProcessToken(GetCurrentProcess(), TOKEN_READ, &hToken);
            if(!bRes)
            {
                pServerSec->RevertToSelf();
                return WBEM_E_ACCESS_DENIED;
            }
        }
        else
        {
            // Real problems
            // =============
            pServerSec->RevertToSelf();
            return WBEM_E_ACCESS_DENIED;
        }
    }

    hres = RetrieveSidFromToken(hToken, sid);
    CloseHandle(hToken);
    pServerSec->RevertToSelf();
    return hres;
}

HRESULT RetrieveSidFromToken(HANDLE hToken, CNtSid & sid)
{
    // Retrieve the length of the user sid structure
    BOOL bRes;
    struct TOKEN_USER_ : TOKEN_USER {
        SID RealSid;
        DWORD SubAuth[SID_MAX_SUB_AUTHORITIES];
    } tu;
    DWORD dwLen = sizeof(tu);
    bRes = GetTokenInformation(hToken, TokenUser,  &tu, sizeof(tu), &dwLen);
    if(FALSE == bRes) return WBEM_E_CRITICAL_ERROR;

    TOKEN_USER* pUser = (TOKEN_USER*)&tu;
    
    // Set our sid to the returned one
    sid = CNtSid(pUser->User.Sid);
    
    return WBEM_S_NO_ERROR;
}

//
//
//
///////////////////////////////////////////////

CIdentitySecurity::CIdentitySecurity()
{
    SID SystemSid = { SID_REVISION,
                      1,
                      SECURITY_NT_AUTHORITY,
                      SECURITY_LOCAL_SYSTEM_RID 
                    };
    
    CNtSid tempSystem((PSID)&SystemSid);
    m_sidSystem = tempSystem;
    if (!m_sidSystem.IsValid())
        throw CX_Exception();

    HRESULT hres = RetrieveSidFromCall(m_sidUser);
    if(FAILED(hres))
           throw CX_Exception();
}

CIdentitySecurity::~CIdentitySecurity()
{
}

HRESULT 
CIdentitySecurity::GetSidFromThreadOrProcess(/*out*/ CNtSid & UserSid)
{
    HANDLE hToken = NULL;
    BOOL bRet = OpenThreadToken(GetCurrentThread(),TOKEN_QUERY, TRUE, &hToken);
    if (FALSE == bRet)
    {
        long lRes = GetLastError();
        if(ERROR_NO_IMPERSONATION_TOKEN == lRes || ERROR_NO_TOKEN == lRes)            
        {
            bRet = OpenProcessToken(GetCurrentProcess(),TOKEN_QUERY,&hToken);
            if (FALSE == bRet) HRESULT_FROM_WIN32(GetLastError());
        }
        else
            return HRESULT_FROM_WIN32(GetLastError());
    }
    OnDelete<HANDLE,BOOL(*)(HANDLE),CloseHandle> CloseMe(hToken);

    DWORD dwSize = sizeof(TOKEN_USER)+sizeof(SID)+(SID_MAX_SUB_AUTHORITIES*sizeof(DWORD));       
    BYTE Array[sizeof(TOKEN_USER)+sizeof(SID)+(SID_MAX_SUB_AUTHORITIES*sizeof(DWORD))];
    TOKEN_USER * pTokenUser = (TOKEN_USER *)Array;

    bRet = GetTokenInformation(hToken,TokenUser,pTokenUser,dwSize,&dwSize);
    if (!bRet) return HRESULT_FROM_WIN32(GetLastError());

    PSID pSIDUser = pTokenUser->User.Sid;
    CNtSid tempSid(pSIDUser);
    UserSid = tempSid;

    if (UserSid.IsValid())
        return S_OK;
    else
        return WBEM_E_OUT_OF_MEMORY;
    
}

HRESULT 
CIdentitySecurity::RetrieveSidFromCall(/*out*/ CNtSid & UserSid)
{
    HRESULT hr;
    IServerSecurity * pCallSec = NULL;
    if (S_OK == CoGetCallContext(IID_IServerSecurity,(void **)&pCallSec))
    {
        OnDelete<IUnknown *,void(*)(IUnknown *),RM> dm(pCallSec);
        if (pCallSec->IsImpersonating())
            return GetSidFromThreadOrProcess(UserSid);
        else
        {
            RETURN_ON_ERR(pCallSec->ImpersonateClient());
            OnDeleteObj0<IServerSecurity ,
                         HRESULT(__stdcall IServerSecurity:: * )(void),
                         &IServerSecurity::RevertToSelf> RevertSec(pCallSec);
            
            return GetSidFromThreadOrProcess(UserSid); 
        }
    } 
    else
        return GetSidFromThreadOrProcess(UserSid);
}

BOOL CIdentitySecurity::AccessCheck()
{
    // Find out who is calling
    // =======================

    CNtSid sidCaller;
    HRESULT hres = RetrieveSidFromCall(sidCaller);
    if(FAILED(hres))
        return FALSE;

    // Compare the caller to the issuing user and ourselves
    // ====================================================

    if(sidCaller == m_sidUser || sidCaller == m_sidSystem)
        return TRUE;
    else
        return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\winmgmt\wbemcomn\clsfac.h ===
/*++

Copyright (C) 1996-2001 Microsoft Corporation

Module Name:

    CLSFAC.H

Abstract:

    Class Factory Helpers

History:

--*/

#ifndef __WBEM_CLASS_FACTORY__H_
#define __WBEM_CLASS_FACTORY__H_

#include <unk.h>
#include <sync.h>
#include <comutl.h>

/***************************************************************************
  CBaseClassFactory
****************************************************************************/

class CBaseClassFactory : public CUnkInternal
{
public:

    CBaseClassFactory( CLifeControl* pControl ) 
    : CUnkInternal( pControl ), m_XClassFactory( this ) {}

    class XClassFactory : public CImpl<IClassFactory,CBaseClassFactory>
    {
    public:

        STDMETHOD(CreateInstance)(IUnknown* pOuter, REFIID riid, void** ppv)
        {
            return m_pObject->CreateInstance( pOuter, riid, ppv );
        }

        STDMETHOD(LockServer)(BOOL fLock)
        {
            return m_pObject->LockServer( fLock );
        }

        XClassFactory( CBaseClassFactory* pOwner ) 
        : CImpl<IClassFactory,CBaseClassFactory>( pOwner ) {} 

    } m_XClassFactory;

    void* GetInterface( REFIID riid )
    {
        if ( riid == IID_IClassFactory )
        {
            return &m_XClassFactory;
        }
        return NULL;
    }

    virtual HRESULT CreateInstance( IUnknown* pOuter, 
                                    REFIID riid, 
                                    void** ppv ) = 0;

    virtual HRESULT LockServer( BOOL fLock ) = 0;
};

/****************************************************************************
  CSimpleClassFactory - does not support aggregation
*****************************************************************************/

template<class TObject>
class CSimpleClassFactory : public CBaseClassFactory
{
public:

    CSimpleClassFactory( CLifeControl* pControl = NULL )
    : CBaseClassFactory( pControl ) {} 
    
    HRESULT CreateInstance( IUnknown* pOuter, REFIID riid, void** ppv )
    {
        HRESULT hr;
        *ppv = NULL;

        if(pOuter)
            return CLASS_E_NOAGGREGATION;
    
        // Lock
        if(m_pControl && !m_pControl->ObjectCreated(NULL))
        {
            // Shutting down
            // =============
            return CO_E_SERVER_STOPPING;
        }
            
        // Create

        try 
        {
            CWbemPtr<TObject> pObject = new TObject(m_pControl);

            if ( pObject != NULL )
            {
                hr = pObject->QueryInterface(riid, ppv);
            }
            else
            {
                hr = E_FAIL;
            }
        }
        catch(...)
        {
            hr = E_FAIL;
        }

        //
        // Unlock
        //
        
        if( m_pControl != NULL )
        {
            m_pControl->ObjectDestroyed(NULL);
        }

        return hr;
    }

    HRESULT LockServer( BOOL fLock )
    {
        if(fLock)
            m_pControl->ObjectCreated(NULL);
        else
            m_pControl->ObjectDestroyed(NULL);
        return S_OK;
    }
};        

/****************************************************************************
  CClassFactory - supports aggregation
*****************************************************************************/

template<class TObject>
class CClassFactory : public CSimpleClassFactory<TObject>
{
public:
    CClassFactory(CLifeControl* pControl = NULL) : 
        CSimpleClassFactory<TObject>(pControl){}

    HRESULT CreateInstance( IUnknown* pOuter, REFIID riid, void** ppv )
    {
        HRESULT hr;
        *ppv = NULL;

        //
        // Lock
        //
        if(m_pControl && !m_pControl->ObjectCreated(NULL))
        {
            // Shutting down
            // =============

            return CO_E_SERVER_STOPPING;
        }

        //
        // Create
        //        
        TObject * pNewObject = 0;
        try
        {          
            pNewObject = new TObject(m_pControl, pOuter);
        }
        catch(...) // do not let exception go beyond COM
        {
            return E_OUTOFMEMORY;
        }

        CWbemPtr<TObject> pObject(pNewObject);
        //
        // Initialize
        //
        if ( pObject != NULL && pObject->Initialize() )
        {
            if ( pOuter == NULL )
            {
                hr = pObject->QueryInterface(riid, ppv);
            }
            else
            {
                if ( riid == IID_IUnknown )
                {
                    *ppv = pObject->GetInnerUnknown();
                    pObject->AddRef();
                    hr = S_OK;
                }
                else
                {
                    hr = CLASS_E_NOAGGREGATION;
                }
            }
        }
        else
        {
            hr = E_FAIL;
        }

        // Unlock
        if( m_pControl != NULL )
        {
            m_pControl->ObjectDestroyed(NULL);
        }

        return hr;
    }
};        

/****************************************************************************
  CSingletonClassFactory 
*****************************************************************************/

template<class T> 
class CSingletonClassFactory : public CBaseClassFactory
{
    CCritSec m_cs;
    T* m_pObj;

public:

    CSingletonClassFactory( CLifeControl* pControl ) 
      : CBaseClassFactory( pControl ), m_pObj(NULL) {}

    ~CSingletonClassFactory() 
    { 
        if ( m_pObj != NULL )
        {
            m_pObj->InternalRelease(); 
        }
    }

    HRESULT CreateInstance( IUnknown* pOuter, REFIID riid, void** ppv )
    {
        HRESULT hr;
        *ppv = NULL;
        
        if( pOuter != NULL )
        {
            return CLASS_E_NOAGGREGATION;
        }
        
        //
        // lock the server.
        //
        
        if ( !m_pControl->ObjectCreated( this ) )
        {
            return CO_E_SERVER_STOPPING;
        }

        {
            CInCritSec ics( &m_cs );

            if ( m_pObj != NULL )
            {
                hr = m_pObj->QueryInterface( riid, ppv );
            }
            else
            {
                m_pObj = new T( m_pControl );

                if ( m_pObj != NULL )
                {
                    m_pObj->InternalAddRef(); 
                    hr = m_pObj->QueryInterface( riid, ppv );
                }
                else
                {
                    hr = E_FAIL;
                }
            }
        }
                
        //
        // Unlock the server and return;
        //
        
        m_pControl->ObjectDestroyed( this );
        
        return hr;
    }

    HRESULT LockServer( BOOL fLock )
    {
        if(fLock)
            m_pControl->ObjectCreated(NULL);
        else
            m_pControl->ObjectDestroyed(NULL);
        return S_OK;
    }
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\winmgmt\wbemcomn\callsec.h ===
/*++

Copyright (C) 1998-2001 Microsoft Corporation

Module Name:

    CALLSEC.H

Abstract:

    IWbemCallSecurity, IServerSecurity implementation for
    provider impersonation.

History:

    raymcc      29-Jul-98        First draft.

--*/


#ifndef _CALLSEC_H_
#define _CALLSEC_H_

#include "parmdefs.h"

// {2ECF39D0-2B26-11d2-AEC8-00C04FB68820}
DEFINE_GUID(IID_IWbemCallSecurity, 
0x2ecf39d0, 0x2b26, 0x11d2, 0xae, 0xc8, 0x0, 0xc0, 0x4f, 0xb6, 0x88, 0x20);


class IWbemCallSecurity : public IServerSecurity
{
public:
    virtual HRESULT GetPotentialImpersonation() = 0;
        // Tells what the impersonation level would be if
        // this object were applied to a thread.
        
    virtual HRESULT GetActiveImpersonation() = 0;
        // Tells the true level of impersonation in the
        // executing thread.

    virtual HRESULT CloneThreadContext(BOOL bInternallyIssued) = 0;
        // Called to clone the execution context of the calling thread.
    virtual DWORD GetAuthenticationId(LUID& rluid) = 0; 
    virtual HANDLE GetToken() = 0;
};

//
//  Adjust Token Privileges if LocalSystem and if not alredy enabled
//
/////////////////////////////////

void POLARITY AdjustPrivIfLocalSystem(HANDLE hPrimary);

//***************************************************************************
//
//  CWbemCallSecurity
//
//  This object is used to supply client impersonation to providers.
//
//***************************************************************************

class POLARITY CWbemCallSecurity : public IWbemCallSecurity
{
#ifdef WMI_PRIVATE_DBG
	DWORD m_currentThreadID;
	DWORD m_lastRevert;
#endif

    LONG    m_lRef;                     // COM ref count
    HANDLE  m_hThreadToken;             // Client token for impersonation

    DWORD   m_dwPotentialImpLevel;      // Potential RPC_C_IMP_LEVEL_ or 0
    DWORD   m_dwActiveImpLevel;         // Active RPC_C_IMP_LEVEL_ or 0
    

    // IServerSecurity::QueryBlanket values
    
    DWORD   m_dwAuthnSvc;               // Authentication service 
    DWORD   m_dwAuthzSvc;               // Authorization service
    DWORD   m_dwAuthnLevel;             // Authentication level
    LPWSTR  m_pServerPrincNam;          // 
    LPWSTR  m_pIdentity;                // User identity

    CWbemCallSecurity(const CWbemCallSecurity &);
    CWbemCallSecurity & operator =(const CWbemCallSecurity &);    
    	
    CWbemCallSecurity();
   ~CWbemCallSecurity();

    HRESULT CloneThreadToken();

public:
    static IWbemCallSecurity * CreateInst();
    const wchar_t *GetCallerIdentity() { return m_pIdentity; } 

    virtual DWORD GetAuthenticationId(LUID& rluid);
    virtual HANDLE GetToken();

    // IUnknown.
    // =========

    virtual ULONG STDMETHODCALLTYPE AddRef();
    virtual ULONG STDMETHODCALLTYPE Release();        
    virtual HRESULT STDMETHODCALLTYPE QueryInterface(REFIID riid, void** ppv);


    // IServerSecurity.
    // ================

    virtual HRESULT STDMETHODCALLTYPE QueryBlanket( 
            /* [out] */ DWORD __RPC_FAR *pAuthnSvc,
            /* [out] */ DWORD __RPC_FAR *pAuthzSvc,
            /* [out] */ OLECHAR __RPC_FAR *__RPC_FAR *pServerPrincName,
            /* [out] */ DWORD __RPC_FAR *pAuthnLevel,
            /* [out] */ DWORD __RPC_FAR *pImpLevel,
            /* [out] */ void __RPC_FAR *__RPC_FAR *pPrivs,
            /* [out] */ DWORD __RPC_FAR *pCapabilities
            );
        
    virtual HRESULT STDMETHODCALLTYPE ImpersonateClient( void);
        
    virtual HRESULT STDMETHODCALLTYPE RevertToSelf( void);
        
    virtual BOOL STDMETHODCALLTYPE IsImpersonating( void);
        


    // IWbemCallSecurity methods.
    // ============================

    virtual HRESULT GetPotentialImpersonation();
        // Tells what the impersonation level would be if
        // this object were applied to a thread.
        
    virtual HRESULT GetActiveImpersonation();
        // Tells the true level of impersonation in the
        // executing thread.

    virtual HRESULT CloneThreadContext(BOOL bInternallyIssued);
        // Called to clone the execution context of the calling thread.
        
    static RELEASE_ME CWbemCallSecurity* MakeInternalCopyOfThread();
};
            

POLARITY HRESULT RetrieveSidFromToken(HANDLE hToken, CNtSid & sid);
POLARITY HRESULT RetrieveSidFromCall(CNtSid & sid);

class POLARITY CIdentitySecurity
{
private:
    CNtSid m_sidUser;
    CNtSid m_sidSystem;	

    HRESULT GetSidFromThreadOrProcess(CNtSid & UserSid);
    HRESULT RetrieveSidFromCall(CNtSid & UserSid);
public:	
	CIdentitySecurity();
	~CIdentitySecurity();
    BOOL AccessCheck();
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\winmgmt\wbemcomn\comutl.h ===
/*++

Copyright (C) 1996-2001 Microsoft Corporation

Module Name:

Abstract:

History:

--*/


#ifndef __COMUTL_H__
#define __COMUTL_H__

#include <wbemcli.h>
#include "corex.h"

#define STRSAFE_NO_DEPRECATE
#include <strsafe.h>

/**************************************************************************
  CWbemPtr
***************************************************************************/

template<class T> class CWbemPtr
{
public :
    T* m_pObj;

    void SetPtr( T* pObj )
    {
        if ( m_pObj != NULL )
            m_pObj->Release();

        m_pObj = pObj;

        if ( m_pObj != NULL )
            m_pObj->AddRef();
    }

    void Attach(T* pObj)
    {
        if ( m_pObj != NULL )
            m_pObj->Release();

        m_pObj = pObj;    
    }
    
    CWbemPtr() : m_pObj(NULL) { }
    CWbemPtr( T* pObj ) : m_pObj(NULL) { SetPtr(pObj); }
    CWbemPtr( const CWbemPtr<T>& p ) : m_pObj(NULL) { SetPtr(p.m_pObj); }
    CWbemPtr<T>& operator=( const CWbemPtr<T>& p ) 
        { SetPtr(p.m_pObj); return *this; }
    ~CWbemPtr() { if ( m_pObj != NULL ) m_pObj->Release(); }
    
    operator T* () { return m_pObj; } 
    T** operator& () { return &m_pObj; } 
    T* operator-> () { return m_pObj; }
    
    void Release() { if( m_pObj != NULL ) m_pObj->Release(); m_pObj = NULL; }
};

/***************************************************************************
  CWbemBSTR
****************************************************************************/

class CWbemBSTR
{
    BSTR m_bstr;
 
    public :
    
    CWbemBSTR() : m_bstr(NULL) { }

    CWbemBSTR( LPCWSTR lpszStr ) 
    {
        if ( lpszStr != NULL )
        {
            m_bstr = ::SysAllocString(lpszStr);

            if ( m_bstr == NULL )
            {
                throw CX_MemoryException();
            }
        }
        else
        {
            m_bstr = NULL;
        }
    }

    CWbemBSTR( LPCWSTR lpszStr, ULONG cLen )
    {
        if ( cLen > 0 )
        {
            m_bstr = ::SysAllocStringLen( NULL, cLen+1 );

            if ( m_bstr == NULL )
            {
                throw CX_MemoryException();
            }

            StringCchCopyW( m_bstr, cLen+1, lpszStr );
        }
        else
        {
            m_bstr = NULL;
        }
    }

    CWbemBSTR( ULONG cLen )
    {
        m_bstr = ::SysAllocStringLen( NULL, cLen + 1 );
        
        if ( m_bstr == NULL )
        {
            throw CX_MemoryException();
        }

        *m_bstr = '\0';
    }
        
    CWbemBSTR( const CWbemBSTR& m ) : m_bstr(NULL) { *this = m; }
    CWbemBSTR& operator=( const CWbemBSTR& m) 
    { 
        ::SysFreeString( m_bstr );
        m_bstr = ::SysAllocString( m.m_bstr );
            
        if ( m_bstr == NULL )
        {
            throw CX_MemoryException();
        }
            
        return *this; 
    }

    ~CWbemBSTR( ) { ::SysFreeString( m_bstr ); }
    
    operator BSTR() { return m_bstr; }
    BOOL operator!() { return m_bstr == NULL; }
    BSTR* operator& () { return &m_bstr; }
    
    void operator += ( LPCWSTR lpszStr ) 
    { 
        if ( lpszStr == NULL ) return;
        Resize( wcslen(lpszStr) + Length() + 10 );
        StringCchCatW( m_bstr, MaxLength(), lpszStr ); 
    }

    void Free() { ::SysFreeString( m_bstr ); m_bstr = NULL; }

    ULONG Length() const {return m_bstr!=NULL ? wcslen(m_bstr) : 0;}
    ULONG MaxLength() const {return m_bstr!=NULL ? ::SysStringLen(m_bstr) : 0;}
    
    void Resize( ULONG cLen )
    {
        cLen++;

        if ( cLen > MaxLength() )
        {
            BSTR bstrNewStr = ::SysAllocStringLen( NULL, cLen );

            if ( bstrNewStr == NULL )
            {
                throw CX_MemoryException();
            }

            if ( m_bstr != NULL )
            {
                StringCchCopyW( bstrNewStr, cLen, m_bstr );
                ::SysFreeString( m_bstr );
            }
            else
            {
                *bstrNewStr = '\0';
            }
            m_bstr = bstrNewStr;
        }
    }
};

/***************************************************************************
  CPropVar
****************************************************************************/

class CPropVar
{
public:
    
    VARIANT v;
    
    CPropVar() { VariantInit( &v ); }
    ~CPropVar() { VariantClear( &v ); }
    
    VARIANT* operator& () { return &v; }
    
    HRESULT CheckType( VARTYPE vt )
    {
        if ( V_VT(&v) != vt )
        {
            return DISP_E_TYPEMISMATCH;
        }
        return S_OK;
    }

    HRESULT SetType( VARTYPE vt ) 
    {
        if ( vt == V_VT(&v) ) 
        {
            return S_OK;
        }
        return VariantChangeType( &v, &v, 0, vt ); 
    }
};

/***************************************************************************
  CPropSafeArray
****************************************************************************/

template<class T> class CPropSafeArray
{
    T* m_aElems;
    SAFEARRAY* m_psa;
    
public:

    CPropSafeArray( SAFEARRAY* psa = NULL ) : m_psa(psa), m_aElems(NULL)
    {
        SafeArrayAccessData( psa, (void**)&m_aElems );
    }

    CPropSafeArray( CPropSafeArray& rOther )
    : m_psa(NULL), m_aElems(NULL)
    {
        *this = rOther.m_psa;
    }

    CPropSafeArray& operator=( SAFEARRAY* psa )
    {
        if ( m_psa != NULL )
        {
            SafeArrayUnaccessData( m_psa );
        }
        m_psa = psa;
        SafeArrayAccessData( m_psa, (void**)&m_aElems );
        return *this;
    }
            
    ~CPropSafeArray()
    {
        if ( m_psa == NULL )
        {
            return;
        }
        SafeArrayUnaccessData( m_psa );
    }

    ULONG Length()
    {
        if ( m_aElems == NULL )
        {
            return 0;
        }

        long lUBound;
        SafeArrayGetUBound( m_psa, 1, &lUBound );
        return lUBound+1;
    }

    T* GetArray() { return m_aElems; }

    T& operator[](int i) { return m_aElems[i]; }
};

/***************************************************************************
  platform independent string conversion routines.
****************************************************************************/

inline BOOL tsz2wsz( LPCWSTR tsz, WCHAR* pwch, ULONG* pcwch )
{   
    ULONG cwch = *pcwch;
    *pcwch = wcslen(tsz)+1;
    if ( cwch < *pcwch ) return FALSE;
    StringCchCopyW( pwch, cwch, tsz );
    return TRUE;
}

inline BOOL tsz2wsz( LPCSTR tsz, WCHAR* pwch, ULONG* pcwch )
{
    ULONG cwch = *pcwch;
    *pcwch = MultiByteToWideChar(CP_ACP, 0, tsz, -1, NULL, 0 );
    if ( cwch < *pcwch ) return FALSE;
    MultiByteToWideChar(CP_ACP, 0, tsz, -1, pwch, cwch );
    return TRUE;
}

/****************************************************************************
  API Enter/Exit macros - catch out of memory conditions and return appropriate
  hresult.  Use at top level COM Interface implementations. 
*****************************************************************************/

#define ENTER_API_CALL try {
#define EXIT_API_CALL } catch(CX_MemoryException & ){return WBEM_E_OUT_OF_MEMORY;} \
                      catch (CX_Exception &) {return WBEM_E_CRITICAL_ERROR; }
     

#endif // __COMUTL_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\winmgmt\wbemcomn\corepol.h ===
/*++

Copyright (C) 1996-2001 Microsoft Corporation

Module Name:

    COREPOL.H

Abstract:

    declspec import/export helpers

History:

--*/

//#define TRACKING 

// If we are building the DLL then define the 
// class as exported otherwise as imported
// ============================================
#ifndef COREPOL_HEADERFILE_IS_INCLUDED
#define COREPOL_HEADERFILE_IS_INCLUDED
//#pragma message( "Including COREPOL.H..." )


#ifdef USE_POLARITY
  #ifdef BUILDING_DLL
//   #pragma message( "Building static library or DLL..." )
   #define POLARITY __declspec( dllexport )
  #else 
//   #pragma message( "Building Provider..." )
   #define POLARITY __declspec( dllimport )
  #endif
 #else
  #define POLARITY
//  #pragma message( "NO Polarity...")
 #endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\winmgmt\wbemcomn\cwbemtime.cpp ===
/*++

Copyright (C) 1996-2001 Microsoft Corporation

Module Name:

    WBEMTIME.CPP

Abstract:

    Time helper

History:

--*/

#include "precomp.h"

#include "CWbemTime.h"
#include <stdio.h>

static void i64ToFileTime( const __int64 *p64, FILETIME *pft )
{
    __int64 iTemp = *p64;
    pft->dwLowDateTime = (DWORD)iTemp;
    iTemp = iTemp >> 32;
    pft->dwHighDateTime = (DWORD)iTemp; 
}

static int CompareSYSTEMTIME(const SYSTEMTIME *pst1, const SYSTEMTIME *pst2)
{
    FILETIME ft1, ft2;

    SystemTimeToFileTime(pst1, &ft1);
    SystemTimeToFileTime(pst2, &ft2);

    return CompareFileTime(&ft1, &ft2);
}

// This function is used to convert the relative values that come
// back from GetTimeZoneInformation into an actual date for the year
// in question.  The system time structure that is passed in is updated
// to contain the absolute values.
static void DayInMonthToAbsolute(SYSTEMTIME *pst, const WORD wYear)
{
    const static int _lpdays[] = {
        -1, 30, 59, 90, 120, 151, 181, 212, 243, 273, 304, 334, 365
    };
    
    const static int _days[] = {
        -1, 30, 58, 89, 119, 150, 180, 211, 242, 272, 303, 333, 364
    };
    
    SHORT shYearDay;
    
    // If this is not 0, this is not a relative date
    if (pst->wYear == 0)
    {
        // Was that year a leap year?
        BOOL bLeap =  ( (( wYear % 400) == 0) || ((( wYear % 4) == 0) && (( wYear % 100) != 0)));
        
        // Figure out the day of the year for the first day of the month in question
        if (bLeap)
            shYearDay = 1 + _lpdays[pst->wMonth - 1];
        else
            shYearDay = 1 + _days[pst->wMonth - 1];
        
        // Now, figure out how many leap days there have been since 1/1/1601
        WORD yc = wYear - 1601;
        WORD y4 = (yc) / 4;
        WORD y100 = (yc) / 100;
        WORD y400 = (yc) / 400;
        
        // This will tell us the day of the week for the first day of the month in question.
        // The '1 +' reflects the fact that 1/1/1601 was a monday (figures).  You might ask,
        // 'why do we care what day of the week this is?'  Well, I'll tell you.  The way
        // daylight savings time is defined is with things like 'the last sunday of the month
        // of october.'  Kinda helps to know what day that is.
        SHORT monthdow = (1 + (yc * 365 + y4 + y400 - y100) + shYearDay) % 7;
        
        if ( monthdow < pst->wDayOfWeek )
            shYearDay += (pst->wDayOfWeek - monthdow) + (pst->wDay - 1) * 7;
        else
            shYearDay += (pst->wDayOfWeek - monthdow) + pst->wDay * 7;
        
            /*
            * May have to adjust the calculation above if week == 5 (meaning
            * the last instance of the day in the month). Check if yearday falls
            * beyond month and adjust accordingly.
        */
        if ( (pst->wDay == 5) &&
            (shYearDay > (bLeap ? _lpdays[pst->wMonth] :
        _days[pst->wMonth])) )
        {
            shYearDay -= 7;
        }

        // Now update the structure.
        pst->wYear = wYear;
        pst->wDay = shYearDay - (bLeap ? _lpdays[pst->wMonth - 1] :
        _days[pst->wMonth - 1]);
    }
    
}

CWbemTime CWbemTime::GetCurrentTime()
{
    SYSTEMTIME st;
    ::GetSystemTime(&st);

    CWbemTime CurrentTime;
    CurrentTime.SetSystemTime(st);
    return CurrentTime;
}

BOOL CWbemTime::SetSystemTime(const SYSTEMTIME& st)
{
    FILETIME ft;
    if(!SystemTimeToFileTime(&st, &ft))
        return FALSE;

    __int64 i64Time = ft.dwHighDateTime;
    i64Time = (i64Time << 32) + ft.dwLowDateTime;
    Set100nss(i64Time);
    return TRUE;
}

BOOL CWbemTime::SetFileTime(const FILETIME& ft)
{
    __int64 i64Time = ft.dwHighDateTime;
    i64Time = (i64Time << 32) + ft.dwLowDateTime;
    Set100nss(i64Time);
    return TRUE;
}

BOOL CWbemTime::GetSYSTEMTIME(SYSTEMTIME * pst) const
{

    FILETIME t_ft;

    if (GetFILETIME(&t_ft))
    {
        if (!FileTimeToSystemTime(&t_ft, pst))
        {
            return FALSE;
        }
    }
    else
    {
        return FALSE;
    }

    return TRUE;
}

BOOL CWbemTime::GetFILETIME(FILETIME * pft) const
{
    if ( pft == NULL )
    {
        return FALSE;
    }

	i64ToFileTime( &m_i64, pft );
    return TRUE;
}


CWbemInterval CWbemTime::RemainsUntil(const CWbemTime& Other) const
{
    __int64 i64Diff = Other.m_i64 - m_i64;
    if(i64Diff < 0) i64Diff = 0;

    return CWbemInterval((DWORD)(i64Diff/10000));
}

CWbemTime CWbemTime::operator+(const CWbemInterval& ToAdd) const
{
    return CWbemTime(m_i64 + 10000*(__int64)ToAdd.GetMilliseconds());
}

BOOL CWbemTime::SetDMTF(LPCWSTR wszText)
{
    if(wcslen(wszText) != 25)
        return FALSE;

    // Parse it
    // ========

    int nYear, nMonth, nDay, nHour, nMinute, nSecond, nMicro, nOffset;
    WCHAR wchSep;

    int nRes = swscanf(wszText, L"%4d%2d%2d%2d%2d%2d.%6d%c%3d", 
                &nYear, &nMonth, &nDay, &nHour, &nMinute, &nSecond, &nMicro, 
                &wchSep, &nOffset);
    if(nRes != 9)
        return FALSE;

    int nSign;
    if(wchSep == L'+')
        nSign = -1;
    else if(wchSep == L'-')
        nSign = 1;
    else if(wchSep == L':')
        nSign = 0;
    else 
        return FALSE;

    // Convert it to SYSTEMTIME
    // ========================

    SYSTEMTIME st;
    st.wYear = (WORD)nYear;
    st.wMonth = (WORD)nMonth;
    st.wDay = (WORD)nDay;
    st.wHour = (WORD)nHour;
    st.wMinute = (WORD)nMinute;
    st.wSecond = (WORD)nSecond;
    st.wMilliseconds = nMicro / 1000;

    // NOTE: ignored timezone for now
    // ==============================

    if(!SetSystemTime(st))
        return FALSE;

    // Now adjust for the offset
    // =========================

    m_i64 += (__int64)nSign * (__int64)nOffset * 60 * 10000000;

    return TRUE;
}

LONG CWbemTime::GetLocalOffsetForDate(const SYSTEMTIME *pst)
{
    TIME_ZONE_INFORMATION tzTime;
    DWORD dwRes = GetTimeZoneInformation(&tzTime);
    LONG lRes = 0xffffffff;

    switch (dwRes)
    {
    case TIME_ZONE_ID_UNKNOWN:
        {
            // Read tz, but no dst defined in this zone
            lRes = tzTime.Bias * -1;
            break;
        }
    case TIME_ZONE_ID_STANDARD:
    case TIME_ZONE_ID_DAYLIGHT:
        {

            // Convert the relative dates to absolute dates
            DayInMonthToAbsolute(&tzTime.DaylightDate, pst->wYear);
            DayInMonthToAbsolute(&tzTime.StandardDate, pst->wYear);

            if ( CompareSYSTEMTIME(&tzTime.DaylightDate, &tzTime.StandardDate) < 0 ) 
            {
                /*
                 * Northern hemisphere ordering
                 */
                if ( CompareSYSTEMTIME(pst, &tzTime.DaylightDate) < 0 || CompareSYSTEMTIME(pst, &tzTime.StandardDate) > 0)
                {
                    lRes = tzTime.Bias * -1;
                }
                else
                {
                    lRes = (tzTime.Bias + tzTime.DaylightBias) * -1;
                }
            }
            else 
            {
                /*
                 * Southern hemisphere ordering
                 */
                if ( CompareSYSTEMTIME(pst, &tzTime.StandardDate) < 0 || CompareSYSTEMTIME(pst, &tzTime.DaylightDate) > 0)
                {
                    lRes = (tzTime.Bias + tzTime.DaylightBias) * -1;
                }
                else
                {
                    lRes = tzTime.Bias * -1;
                }
            }

            break;

        }
    case TIME_ZONE_ID_INVALID:
    default:
        {
            // Can't read the timezone info
            //ASSERT_BREAK(BAD_TIMEZONE);
            break;
        }
    }

    return lRes;
}
    
BOOL CWbemTime::GetDMTF( BOOL bLocal, DWORD dwBuffLen, LPWSTR pwszBuff )
{

    SYSTEMTIME t_Systime;
    wchar_t chsign = L'-';
    int offset = 0;

	// Need to Localize the offset
	if ( dwBuffLen < WBEMTIME_LENGTH + 1 )
	{
		return FALSE;
	}

    // If the date to be converted is within 12 hours of
    // 1/1/1601, return the greenwich time
    ULONGLONG t_ConversionZone = 12L * 60L * 60L ;
    t_ConversionZone = t_ConversionZone * 10000000L ;
    if ( !bLocal || ( m_i64 < t_ConversionZone ) )
    {
        if(!GetSYSTEMTIME(&t_Systime))
        {
            return NULL;
        }
    }
	else
    {
        if (GetSYSTEMTIME(&t_Systime))
        {
            offset = GetLocalOffsetForDate(&t_Systime);

            CWbemTime wt;
            if (offset >= 0)
            {
                chsign = '+';
                wt = *this + CWbemTimeSpan(0, 0, offset, 0);
            }
            else
            {
                offset *= -1;
                wt = *this - CWbemTimeSpan(0, 0, offset, 0);
            }
            wt.GetSYSTEMTIME(&t_Systime);
        }
        else
        {
            return NULL;
        }
    }

    LONGLONG tmpMicros = m_i64%10000000;
    LONG micros = (LONG)(tmpMicros / 10);

    if (FAILED(StringCchPrintfW(
        pwszBuff, dwBuffLen, 
        L"%04.4d%02.2d%02.2d%02.2d%02.2d%02.2d.%06.6d%c%03.3ld",
        t_Systime.wYear,
        t_Systime.wMonth, 
        t_Systime.wDay,
        t_Systime.wHour,
        t_Systime.wMinute,
        t_Systime.wSecond,
        micros, 
        chsign, 
        offset
    ))) return FALSE;

    return TRUE ;

}

CWbemTime CWbemTime::operator+(const CWbemTimeSpan &uAdd) const
{
    CWbemTime ret;
    ret.m_i64 = m_i64 + uAdd.m_Time;

    return ret;
}

CWbemTime CWbemTime::operator-(const CWbemTimeSpan &uSub) const
{
    CWbemTime ret;
    ret.m_i64 = m_i64 - uSub.m_Time;

    return ret;
}

CWbemTimeSpan::CWbemTimeSpan(int iDays, int iHours, int iMinutes, int iSeconds, 
                int iMSec, int iUSec, int iNSec)
{
    m_Time = 0;        //todo, check values!!!
    m_Time += iSeconds;
    m_Time += iMinutes * 60;
    m_Time += iHours * 60 * 60;
    m_Time += iDays * 24 * 60 * 60;
    m_Time *= 10000000;
    m_Time += iNSec / 100;  // Nanoseconds
    m_Time += iUSec*10;   // Microseconds
    m_Time += iMSec*10000; // Milliseconds
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\winmgmt\wbemcomn\datepart.h ===
//***************************************************************************
//
//   (c) 2000-2001 by Microsoft Corp. All Rights Reserved.
//
//   datepart.h
//
//   a-davcoo     28-Feb-00       Implements the SQL datepart operation.
//
//***************************************************************************

#ifndef _DATEPART_H_
#define _DATEPART_H_


#include <strutils.h>
#include <datetimeparser.h>


#define DATEPART_YEAR			1			// "yy", "year"
#define DATEPART_MONTH			3			// "mm", "month"
#define DATEPART_DAY			5			// "dd", "day"
#define DATEPART_HOUR			8			// "hh", "hour"
#define DATEPART_MINUTE			9			// "mi", "minute"
#define DATEPART_SECOND         10          // "ss", "second"
#define DATEPART_MILLISECOND	11			// "ms", "millisecond"


class CDMTFParser;


// The CDatePart class implements the SQL "datepart" operation.  To use
// this class, construct an instance, supplying the date string you wish
// to parse.  Then use the GetPart() method to extract the specified part.
// Contants for the "parts" are presented above.  The class makes it's own
// copy of the date string supplied during construction.
class POLARITY CDatePart
{
	public:
        CDatePart ();
		~CDatePart ();

        HRESULT SetDate (LPCWSTR lpDate);
        HRESULT SetDate (LPCSTR lpDate);
		HRESULT GetPart (int datepart, int *value);

	protected:
		CDMTFParser *m_date;
};


class POLARITY CDMTFParser
{
	public:
		enum {YEAR, MONTH, DAY, HOUR, MINUTE, SECOND, MICROSECOND, OFFSET};

		CDMTFParser (LPCWSTR date);
		~CDMTFParser (void);

		bool IsValid (void);
		bool IsInterval (void);

		bool IsUsed (int part);
		bool IsWildcard (int part);
		int GetValue (int part);

	protected:
		enum {INVALID=0x0, VALID=0x1, NOTSUPPLIED=0x2, NOTUSED=0x4};
		enum {NUMPARTS=8};

		bool m_valid;
		bool m_interval;

		int m_status[NUMPARTS];
		int m_part[NUMPARTS];

	    void ParseDate (LPCWSTR date);
		void ParseInterval (LPCWSTR date);
		void ParseAbsolute (LPCWSTR date);
		int ParsePart (LPCWSTR date, int pos, int length, int *result, int min, int max);
};


#endif // _DATEPART_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\winmgmt\wbemcomn\datepart.cpp ===
//***************************************************************************
//
//   (c) 2000-2001 by Microsoft Corp. All Rights Reserved.
//
//   datepart.cpp
//
//   a-davcoo     28-Feb-00       Implements the SQL datepart operation.
//
//***************************************************************************

#include "precomp.h"
#include "datepart.h"
#include <stdio.h>
#include "wbemcli.h"


CDatePart::CDatePart ()
{
	m_date=NULL;
}


CDatePart::~CDatePart (void)
{
	delete m_date;
}

HRESULT CDatePart::SetDate (LPCWSTR lpDate)
{
    HRESULT hr = 0;

	delete m_date;
	m_date=NULL;
    m_date = new CDMTFParser(lpDate);
    if (!m_date)
        hr = WBEM_E_OUT_OF_MEMORY;

    return hr;
}

HRESULT CDatePart::SetDate (LPCSTR lpDate)
{
    HRESULT hr = 0;

	delete m_date;
	m_date=NULL;
	size_t tmpLength = (strlen(lpDate)*4)+1;
    wchar_t *pNew = new wchar_t [tmpLength];
    if (pNew)
    {
        StringCchPrintfW(pNew, tmpLength, L"%S", lpDate);
        m_date = new CDMTFParser(pNew);
        delete pNew;
    }
    
    if (!m_date)
        hr = WBEM_E_OUT_OF_MEMORY;

    return hr;
}


HRESULT CDatePart::GetPart (int datepart, int *value)
{
	HRESULT hr=WBEM_S_NO_ERROR;

	int part;
	switch (datepart)
	{
		case DATEPART_YEAR:
		{
			part=CDMTFParser::YEAR;
			break;
		}

		case DATEPART_MONTH:
		{
			part=CDMTFParser::MONTH;
			break;
		}

		case DATEPART_DAY:
		{
			part=CDMTFParser::DAY;
			break;
		}

		case DATEPART_HOUR:
		{
			part=CDMTFParser::HOUR;
			break;
		}

		case DATEPART_MINUTE:
		{
			part=CDMTFParser::MINUTE;
			break;
		}

		case DATEPART_SECOND:
		{
			part=CDMTFParser::SECOND;
			break;
		}

		case DATEPART_MILLISECOND:
		{
			part=CDMTFParser::MICROSECOND;
			break;
		}

		default:
		{
			hr=WBEM_E_NOT_AVAILABLE;
			*value=0;
			break;
		}
	}

	if (SUCCEEDED(hr))
	{
		if (!m_date->IsValid())
		{
			hr=WBEM_E_INVALID_PARAMETER;
		}
		else if (!m_date->IsUsed (part) || m_date->IsWildcard (part))
		{
			hr=WBEM_E_NOT_AVAILABLE;
		}
		else
		{
			*value=m_date->GetValue (part);
			if (datepart==DATEPART_MILLISECOND) *value/=1000;
		}
	}

	return hr;
}


CDMTFParser::CDMTFParser (LPCWSTR date)
{
	ParseDate (date);
}

		
CDMTFParser::~CDMTFParser (void)
{
}


void CDMTFParser::ParseDate (LPCWSTR date)
{
	m_valid=true;

	for (int index=0; index<NUMPARTS; index++)
	{
		m_status[index]=NOTUSED;
		m_part[index]=0;
	}

	int length=wcslen (date);
	if (length!=25 || date[14]!=L'.')
	{
		m_valid=false;
	}
	else
	{
		m_interval=!wcscmp (&date[21], L":000");
		if (m_interval)
		{
			ParseInterval (date);
		}
		else
		{
			ParseAbsolute (date);
		}
	}

	for (index=0; index<NUMPARTS; index++)
	{
		if (m_status[index]==INVALID)
		{
			m_valid=false;
			break;
		}
	}
}


void CDMTFParser::ParseInterval (LPCWSTR date)
{
	m_status[DAY]=ParsePart (date, 0, 8, &m_part[DAY], 0, 999999999);
	m_status[HOUR]=ParsePart (date, 8, 2, &m_part[HOUR], 0, 23);
	m_status[MINUTE]=ParsePart (date, 10, 2, &m_part[MINUTE], 0, 59);
	m_status[SECOND]=ParsePart (date, 12, 2, &m_part[SECOND], 0, 59);
	m_status[MICROSECOND]=ParsePart (date, 15, 6, &m_part[MICROSECOND], 0, 999999);
}


void CDMTFParser::ParseAbsolute (LPCWSTR date)
{
	m_status[YEAR]=ParsePart (date, 0, 4, &m_part[YEAR], 0, 9999);
	m_status[MONTH]=ParsePart (date, 4, 2, &m_part[MONTH], 1, 12);
	m_status[DAY]=ParsePart (date, 6, 2, &m_part[DAY], 1, 31);
	m_status[HOUR]=ParsePart (date, 8, 2, &m_part[HOUR], 0, 23);
	m_status[MINUTE]=ParsePart (date, 10, 2, &m_part[MINUTE], 0, 59);
	m_status[SECOND]=ParsePart (date, 12, 2, &m_part[SECOND], 0, 59);
	m_status[MICROSECOND]=ParsePart (date, 15, 6, &m_part[MICROSECOND], 0, 999999);
	m_status[OFFSET]=ParsePart (date, 22, 3, &m_part[OFFSET], 0, 999);

	if (date[21]==L'-')
		m_part[OFFSET]*=(-1);
	else if (date[21]!=L'+')
		m_status[OFFSET]=INVALID;
}


int CDMTFParser::ParsePart (LPCWSTR date, int pos, int length, int *result, int min, int max)
{
	*result=0;

	bool digits=false, wildcard=false;
	for (int index=pos; index<pos+length; index++)
	{
		if (wbem_iswdigit (date[index]))
		{
			if (wildcard) return INVALID;

			*result*=10;
			*result+=date[index]-L'0';

			digits=true;
		}
		else if (date[index]==L'*')
		{
			if (digits) return INVALID;
			wildcard=true;
		}
		else
		{
			return INVALID;
		}
	}

	if (!wildcard && (*result<min || *result>max)) return INVALID;

	return VALID;
}


bool CDMTFParser::IsValid (void)
{
	return m_valid;
}


bool CDMTFParser::IsInterval (void)
{
	return m_interval;
}


bool CDMTFParser::IsUsed (int part)
{
	return m_valid && !(m_status[part] & NOTUSED);
}


bool CDMTFParser::IsWildcard (int part)
{
	return m_valid && (m_status[part] & NOTSUPPLIED);
}


int CDMTFParser::GetValue (int part)
{
	return m_valid ? m_part[part] : 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\winmgmt\wbemcomn\datetimeparser.cpp ===
/*++

Copyright (C) 1996-2001 Microsoft Corporation

Module Name:

    DATETIMEPARSER.CPP

Abstract:

    Parses a date/time string and converts it into it's component values.

History:

    raymcc  25-Jul-99       Updated to bypass strict checks on DMTF
                            formats due to backward compatibility issues
                            and breaks reported by other teams.  See
                            NOT_USED_IN_WIN2000 #idndef bracketed code.


--*/

//=============================================================================
//
//  CDateTimeParser
//
//  Parses a date/time string and converts it into it's component values.
//
//  Supported DMTF date/time formats:
//  1:  yyyymmddhhmmss.uuuuuu+UTC
//  2:  yyyymmddhhmmss.uuuuuu-UTC
//
//  Supported date formats:
//  1:  Mon[th] dd[,] [yy]yy
//  2:  Mon[th][,] yyyy
//  3:  Mon[th] [yy]yy dd
//  4:  dd Mon[th][,][ ][yy]yy
//  5:  dd [yy]yy Mon[th]
//  6:  [yy]yy Mon[th] dd
//  7:  yyyy Mon[th]
//  8:  yyyy dd Mon[th]
//  9:  [M]M{/-.}dd{/-,}[yy]yy      ->Has to be same separator!
//  10: dd{/-.}[M]M{/-.}[yy]yy      ->Has to be same separator!
//  11: [M]M{/-.}[yy]yy{/-.}dd      ->Has to be same separator!
//  12: dd{/-.}[yy]yy{/-.}[M]M      ->Has to be same separator!
//  13: [yy]yy{/-.}dd{/-.}[M]M      ->Has to be same separator!
//  14: [yy]yy{/-.}[M]M{/-.}dd      ->Has to be same separator!
//  15: [yy]yyMMdd and yyyy[MM[dd]]
//
//  Supported Time formats:
//  1:  hh[ ]{AP}M
//  2:  hh:mm
//  3:  hh:mm[ ]{AP}M
//  4:  hh:mm:ss
//  5:  hh:mm:ss[ ]{AP}M
//  6:  hh:mm:ss:uuu
//  7:  hh:mm:ss.[[u]u]u
//  8:  hh:mm:ss:uuu[ ]{AP}M
//  9:  hh:mm:ss.[[u]u]u[ ]{AP}M
//=============================================================================

#include "precomp.h"
#include <string.h>
#include <stdio.h>
#include "wbemutil.h"
#include "DateTimeParser.h"

//=============================================================================
//  Constructor. This takes a DateTime string and parses it.
//=============================================================================
CDateTimeParser::CDateTimeParser(const wchar_t *pszDateTime)
:   m_nDayFormatPreference(mdy)
{
    // Get the prefered date format by using NLS locale call
    GetPreferedDateFormat();

    //Get the localised long month strings
    GetLocalInfoAndAlloc(LOCALE_SMONTHNAME1, m_pszFullMonth[0]);
    GetLocalInfoAndAlloc(LOCALE_SMONTHNAME2, m_pszFullMonth[1]);
    GetLocalInfoAndAlloc(LOCALE_SMONTHNAME3, m_pszFullMonth[2]);
    GetLocalInfoAndAlloc(LOCALE_SMONTHNAME4, m_pszFullMonth[3]);
    GetLocalInfoAndAlloc(LOCALE_SMONTHNAME5, m_pszFullMonth[4]);
    GetLocalInfoAndAlloc(LOCALE_SMONTHNAME6, m_pszFullMonth[5]);
    GetLocalInfoAndAlloc(LOCALE_SMONTHNAME7, m_pszFullMonth[6]);
    GetLocalInfoAndAlloc(LOCALE_SMONTHNAME8, m_pszFullMonth[7]);
    GetLocalInfoAndAlloc(LOCALE_SMONTHNAME9, m_pszFullMonth[8]);
    GetLocalInfoAndAlloc(LOCALE_SMONTHNAME10, m_pszFullMonth[9]);
    GetLocalInfoAndAlloc(LOCALE_SMONTHNAME11, m_pszFullMonth[10]);
    GetLocalInfoAndAlloc(LOCALE_SMONTHNAME12, m_pszFullMonth[11]);
    GetLocalInfoAndAlloc(LOCALE_SMONTHNAME13, m_pszFullMonth[12]);

    //Get the localised short month strings
    GetLocalInfoAndAlloc(LOCALE_SABBREVMONTHNAME1, m_pszShortMonth[0]);
    GetLocalInfoAndAlloc(LOCALE_SABBREVMONTHNAME2, m_pszShortMonth[1]);
    GetLocalInfoAndAlloc(LOCALE_SABBREVMONTHNAME3, m_pszShortMonth[2]);
    GetLocalInfoAndAlloc(LOCALE_SABBREVMONTHNAME4, m_pszShortMonth[3]);
    GetLocalInfoAndAlloc(LOCALE_SABBREVMONTHNAME5, m_pszShortMonth[4]);
    GetLocalInfoAndAlloc(LOCALE_SABBREVMONTHNAME6, m_pszShortMonth[5]);
    GetLocalInfoAndAlloc(LOCALE_SABBREVMONTHNAME7, m_pszShortMonth[6]);
    GetLocalInfoAndAlloc(LOCALE_SABBREVMONTHNAME8, m_pszShortMonth[7]);
    GetLocalInfoAndAlloc(LOCALE_SABBREVMONTHNAME9, m_pszShortMonth[8]);
    GetLocalInfoAndAlloc(LOCALE_SABBREVMONTHNAME10, m_pszShortMonth[9]);
    GetLocalInfoAndAlloc(LOCALE_SABBREVMONTHNAME11, m_pszShortMonth[10]);
    GetLocalInfoAndAlloc(LOCALE_SABBREVMONTHNAME12, m_pszShortMonth[11]);
    GetLocalInfoAndAlloc(LOCALE_SABBREVMONTHNAME13, m_pszShortMonth[12]);

    //Get the localised AM/PM strings
    GetLocalInfoAndAlloc(LOCALE_S1159, m_pszAmPm[0]);
    GetLocalInfoAndAlloc(LOCALE_S2359, m_pszAmPm[1]);

    //Decode the date time string.
    SetDateTime(pszDateTime);
}

CDateTimeParser::CDateTimeParser( void )
:   m_nDayFormatPreference(mdy),
    m_bValidDateTime( FALSE ),
    m_nDay( 0 ),
    m_nMonth( 0 ),
    m_nYear( 0 ),
    m_nHours( 0 ),
    m_nMinutes( 0 ),
    m_nSeconds( 0 ),
    m_nMicroseconds( 0 ),
    m_nUTC( 0 )
{
    ZeroMemory( m_pszFullMonth, sizeof(m_pszFullMonth) );
    ZeroMemory( m_pszShortMonth, sizeof(m_pszShortMonth) );
    ZeroMemory( m_pszAmPm, sizeof(m_pszAmPm) );
}

//=============================================================================
//  Destructor.  Tidies up after itself.
//=============================================================================
CDateTimeParser::~CDateTimeParser()
{
    if ( NULL != m_pszFullMonth[0] ) delete [] m_pszFullMonth[0];
    if ( NULL != m_pszFullMonth[1] ) delete [] m_pszFullMonth[1];
    if ( NULL != m_pszFullMonth[2] ) delete [] m_pszFullMonth[2];
    if ( NULL != m_pszFullMonth[3] ) delete [] m_pszFullMonth[3];
    if ( NULL != m_pszFullMonth[4] ) delete [] m_pszFullMonth[4];
    if ( NULL != m_pszFullMonth[5] ) delete [] m_pszFullMonth[5];
    if ( NULL != m_pszFullMonth[6] ) delete [] m_pszFullMonth[6];
    if ( NULL != m_pszFullMonth[7] ) delete [] m_pszFullMonth[7];
    if ( NULL != m_pszFullMonth[8] ) delete [] m_pszFullMonth[8];
    if ( NULL != m_pszFullMonth[9] ) delete [] m_pszFullMonth[9];
    if ( NULL != m_pszFullMonth[10] ) delete [] m_pszFullMonth[10];
    if ( NULL != m_pszFullMonth[11] ) delete [] m_pszFullMonth[11];
    if ( NULL != m_pszFullMonth[12] ) delete [] m_pszFullMonth[12];

    if ( NULL != m_pszShortMonth[0] ) delete [] m_pszShortMonth[0];
    if ( NULL != m_pszShortMonth[1] ) delete [] m_pszShortMonth[1];
    if ( NULL != m_pszShortMonth[2] ) delete [] m_pszShortMonth[2];
    if ( NULL != m_pszShortMonth[3] ) delete [] m_pszShortMonth[3];
    if ( NULL != m_pszShortMonth[4] ) delete [] m_pszShortMonth[4];
    if ( NULL != m_pszShortMonth[5] ) delete [] m_pszShortMonth[5];
    if ( NULL != m_pszShortMonth[6] ) delete [] m_pszShortMonth[6];
    if ( NULL != m_pszShortMonth[7] ) delete [] m_pszShortMonth[7];
    if ( NULL != m_pszShortMonth[8] ) delete [] m_pszShortMonth[8];
    if ( NULL != m_pszShortMonth[9] ) delete [] m_pszShortMonth[9];
    if ( NULL != m_pszShortMonth[10] ) delete [] m_pszShortMonth[10];
    if ( NULL != m_pszShortMonth[11] ) delete [] m_pszShortMonth[11];
    if ( NULL != m_pszShortMonth[12] ) delete [] m_pszShortMonth[12];

    if ( NULL != m_pszAmPm[0] ) delete [] m_pszAmPm[0];
    if ( NULL != m_pszAmPm[1] ) delete [] m_pszAmPm[1];
}

wchar_t* CDateTimeParser::AllocAmPm()
{
    wchar_t* pszAP = new wchar_t[4];

    if (pszAP)
    {
        pszAP[0] = ' ';
        pszAP[1] = m_pszAmPm[0][0];
        pszAP[2] = m_pszAmPm[1][0];
        pszAP[3] = 0;
    }

    return pszAP;
}

//=============================================================================
//  Does a GetLocalInfo and allocates the buffer large enough for the item.
//=============================================================================
void CDateTimeParser::GetLocalInfoAndAlloc(LCTYPE LCType, LPTSTR &lpLCData)
{
    int nSize;
    nSize = GetLocaleInfo(LOCALE_USER_DEFAULT, LCType, NULL, 0);
    lpLCData =  new wchar_t[nSize];

    if (lpLCData)
        GetLocaleInfo(LOCALE_USER_DEFAULT, LCType, lpLCData, nSize);
}

//=============================================================================
//  Uses locale call to work out the prefered date format.
//=============================================================================
void CDateTimeParser::GetPreferedDateFormat()
{
    int nSize;
    if (!(nSize = GetLocaleInfo(LOCALE_USER_DEFAULT, LOCALE_SSHORTDATE, NULL, 0)))
        return;     // will use default of mdy
    wchar_t* lpLCData =  new wchar_t[nSize];
    if(lpLCData == NULL)
        return;

    if (!GetLocaleInfo(LOCALE_USER_DEFAULT, LOCALE_SSHORTDATE, lpLCData, nSize))
    {
        delete [] lpLCData;
        return;     // will use default of mdy
    }

    nSize -= 2;     // index of last character

    // It is only necessary to check first and last character to determine format
    if (lpLCData[0] == 'M')
    {
        if (lpLCData[nSize] == 'y')
            m_nDayFormatPreference = mdy;
        else // lpLCData[nSize] == 'd'
            m_nDayFormatPreference = myd;
    }
    else if (lpLCData[0] == 'd')
    {
        if (lpLCData[nSize] == 'y')
            m_nDayFormatPreference = dmy;
        else // lpLCData[nSize] == 'M'
            m_nDayFormatPreference = dym;
    }
    else // lpLCPata[0] == 'y'
    {
        if (lpLCData[nSize] == 'd')
            m_nDayFormatPreference = ymd;
        else // lpLCData[nSize] == 'M'
            m_nDayFormatPreference = ydm;
    }
    delete [] lpLCData;
}


//=============================================================================
//  Tidies up and parses a new date and time.
//=============================================================================
BOOL CDateTimeParser::SetDateTime(const wchar_t *pszDateTime)
{
    ResetDateTime(TRUE);

    if (CheckDMTFDateTimeFormatInternal(pszDateTime) == TRUE)
        return TRUE;

    if (CheckDateFormat(pszDateTime, TRUE) == TRUE)
        return TRUE;

    if (CheckTimeFormat(pszDateTime, TRUE) == TRUE)
        return TRUE;

    return TRUE;
}

//=============================================================================
//  Resets all the date/time values to the default values.
//  If bSQL is TRUE it sets to the SQL default.  Otherwise
//  sets to the DMTF default.
//=============================================================================
void CDateTimeParser::ResetDateTime(BOOL bSQL)
{
    ResetDate(bSQL);
    ResetTime(bSQL);
}

void CDateTimeParser::ResetDate(BOOL bSQL)
{
    m_bValidDateTime = FALSE;
    m_nDay = 1;
    m_nMonth = 1;
    m_nYear = 1990;
}

void CDateTimeParser::ResetTime(BOOL bSQL)
{
    m_bValidDateTime = FALSE;
    m_nHours = 0;
    m_nMinutes = 0;
    m_nSeconds = 0;
    m_nMicroseconds = 0;
    m_nUTC = 0;
}

//=============================================================================
//  Checks the date time for a valid DMTF string
//  1:  yyyymmddhhmmss.uuuuuu+UTC
//  2:  yyyymmddhhmmss.uuuuuu-UTC
// Note, this code is a near duplicate of the checks used to test the interval format.
//=============================================================================
BOOL CDateTimeParser::CheckDMTFDateTimeFormatInternal(const wchar_t *pszDateTime)
{
    if (wcslen(pszDateTime) != 25)
        return FALSE;

    //Validate digits and puntuation...
    for (int i = 0; i < 14; i++)
    {
        if (!wbem_isdigit(pszDateTime[i]))
            return FALSE;
    }
    if (pszDateTime[i] != '.')
        return FALSE;
    for (i++;i < 21; i++)
    {
        if (!wbem_isdigit(pszDateTime[i]))
            return FALSE;
    }
    if ((pszDateTime[i] != '+') && (pszDateTime[i] != '-'))
        return FALSE;
    for (i++; i < 25; i++)
    {
        if (!wbem_isdigit(pszDateTime[i]))
            return FALSE;
    }

    m_nYear = ((pszDateTime[0] - '0') * 1000) +
              ((pszDateTime[1] - '0') * 100) +
              ((pszDateTime[2] - '0') * 10) +
               (pszDateTime[3] - '0');

    if (m_nYear < 1601)
        return FALSE;

    m_nMonth = ((pszDateTime[4] - '0') * 10) +
                (pszDateTime[5] - '0');

    if (m_nMonth < 1 || m_nMonth > 12)
        return FALSE;

    m_nDay = ((pszDateTime[6] - '0') * 10) +
              (pszDateTime[7] - '0');

    if (m_nDay < 1 || m_nDay > 31)
        return FALSE;

    m_nHours = ((pszDateTime[8] - '0') * 10) +
                (pszDateTime[9] - '0');

    if (m_nHours > 23)
        return FALSE;

    m_nMinutes = ((pszDateTime[10] - '0') * 10) +
                  (pszDateTime[11] - '0');

    if (m_nMinutes > 59)
        return FALSE;

    m_nSeconds = ((pszDateTime[12] - '0') * 10) +
                  (pszDateTime[13] - '0');

    if (m_nSeconds > 59)
        return FALSE;

    //14 is '.'

    m_nMicroseconds = ((pszDateTime[15] - '0') * 100000) +
                      ((pszDateTime[16] - '0') * 10000) +
                      ((pszDateTime[17] - '0') * 1000) +
                      ((pszDateTime[18] - '0') * 100) +
                      ((pszDateTime[19] - '0') * 10) +
                       (pszDateTime[20] - '0');

    //21 is '+' or '-'

    m_nUTC = ((pszDateTime[22] - '0') * 100) +
             ((pszDateTime[23] - '0') * 10) +
              (pszDateTime[24] - '0');

    if (pszDateTime[21] == '-')
        m_nUTC = 0 - m_nUTC;

    m_bValidDateTime = TRUE;

    return TRUE;
}

//=============================================================================
//  Static helper function so outside code can do quick DMTF format checks.
//=============================================================================
BOOL CDateTimeParser::CheckDMTFDateTimeFormat(
    const wchar_t *wszDateTime,
    BOOL bFailIfRelative,
    BOOL bFailIfUnzoned
    )
{

    if (wszDateTime == 0)
        return FALSE;

    int nLen = wcslen(wszDateTime);
    if (nLen != 25)
        return FALSE;

    // Do two quick checks.  Ensure that the . and : are in
    // the right places or at least that * chars are there.

    wchar_t c1 = wszDateTime[14];
    wchar_t c2 = wszDateTime[21];
    if (!(c1 == L'.' || c1 == L'*'))
        return FALSE;
    if (!(c2 == L'+' || c2 == L'*' || c2 == '-'))
        return FALSE;

    return TRUE;

#ifdef NOT_USED_IN_WIN2000

    BOOL    bReturn = FALSE;

    // Temporary buffer for conversion
    char    szTemp[64];
    int     nNumChars = WideCharToMultiByte( CP_ACP, 0L, wszDateTime, -1, NULL, 0, NULL, NULL );

    if ( nNumChars < sizeof(szTemp) - 1 )
    {
        // We know it will fit, so do the conversion and use the date/time parser to
        // perform a conversion
        WideCharToMultiByte( CP_ACP, 0L, wszDateTime, -1, szTemp, sizeof(szTemp), NULL, NULL );

        // Check for use of asterisks for relative date/time
        if (!bFailIfRelative)
        {
            // Check year and if ALL asterisks then replace with a valid number
            if (szTemp[0] == '*' && szTemp[1] == '*' && szTemp[2] == '*' && szTemp[3] == '*')
            {
                szTemp[0] = '1'; szTemp[1] = '9'; szTemp[2] = '9'; szTemp[3] = '0';
            }
            // Check month and if ALL asterisks then replace with a valid number
            if (szTemp[4] == '*' && szTemp[5] == '*')
            {
                szTemp[4] = '0'; szTemp[5] = '1';
            }
            // Check day and if ALL asterisks then replace with a valid number
            if (szTemp[6] == '*' && szTemp[7] == '*')
            {
                szTemp[6] = '0'; szTemp[7] = '1';
            }
            // Check hour and if ALL asterisks then replace with a valid number
            if (szTemp[8] == '*' && szTemp[9] == '*')
            {
                szTemp[8] = '0'; szTemp[9] = '0';
            }
            // Check minutes and if ALL asterisks then replace with a valid number
            if (szTemp[10] == '*' && szTemp[11] == '*')
            {
                szTemp[10] = '0'; szTemp[11] = '0';
            }
            // Check seconds and if ALL asterisks then replace with a valid number
            if (szTemp[12] == '*' && szTemp[13] == '*')
            {
                szTemp[12] = '0'; szTemp[13] = '0';
            }
            // Check microseconds and if ALL asterisks then replace with a valid number
            if (szTemp[15] == '*' && szTemp[16] == '*' && szTemp[17] == '*' &&
                szTemp[18] == '*' && szTemp[19] == '*' && szTemp[20] == '*')
            {
                szTemp[15] = '0'; szTemp[16] = '0'; szTemp[17] = '0';
                szTemp[18] = '0'; szTemp[19] = '0'; szTemp[20] = '0';
            }
        }

        // Check for use of asterisks for unzoned date/time
        if (!bFailIfUnzoned)
        {
            // Check UTC and if ALL asterisks then replace with a valid number
            if (szTemp[22] == '*' && szTemp[23] == '*' && szTemp[24] == '*')
            {
                szTemp[22] = '0'; szTemp[23] = '0'; szTemp[24] = '0';
            }
        }

        CDateTimeParser dtParse;

        bReturn = dtParse.CheckDMTFDateTimeFormatInternal( szTemp );
    }

    return bReturn;
#endif

}

//=============================================================================
//  Static helper function so outside code can do quick DMTF format checks.
//  Currently, a time interval can only be validated, it cannot be used
//  to initialize a CDateTimeParser instance.
//=============================================================================
BOOL CDateTimeParser::CheckDMTFDateTimeInterval(
    LPCTSTR wszInterval
    )
{

    if (wszInterval == 0)
        return FALSE;

    int nLen = wcslen(wszInterval);
    if (nLen != 25)
        return FALSE;

    // Do two quick checks.  Ensure that the . and : are in
    // the right places or at least that * chars are there.

    wchar_t c1 = wszInterval[14];
    wchar_t c2 = wszInterval[21];
    if (!(c1 == L'.' || c1 == L'*'))
        return FALSE;
    if (!(c2 == L':' || c2 == L'*'))
        return FALSE;


    return TRUE;

#ifdef NOT_USED_IN_WIN2000

    // Temporary buffer for conversion
    char    szTemp[64];
    int     nNumChars = WideCharToMultiByte( CP_ACP, 0L, wszInterval, -1, NULL, 0, NULL, NULL );

    if ( nNumChars < sizeof(szTemp) - 1 )
    {
        // We know it will fit, so do the conversion and use the date/time parser to
        // perform a conversion
        WideCharToMultiByte( CP_ACP, 0L, wszInterval, -1, szTemp, sizeof(szTemp), NULL, NULL );

        // =======================================================================================
        // Check the date time for a valid DMTF interval string:
        //   ddddddddHHMMSS.mmmmmm:000
        // Note, this code is a near duplicate of the checks used to test the non-interval format.
        // =======================================================================================

        if (strlen(szTemp) != 25)
            return FALSE;

        //Validate digits and puntuation...
        for (int i = 0; i < 14; i++)
        {
            if (!wbem_isdigit(szTemp[i]))
                return FALSE;
        }
        if (szTemp[i] != '.')
            return FALSE;
        for (i++;i < 21; i++)
        {
            if (!wbem_isdigit(szTemp[i]))
                return FALSE;
        }
        if (szTemp[i] != ':')
            return FALSE;
        for (i++; i < 25; i++)
        {
            if (szTemp[i] != '0')
                return FALSE;
        }

        int nHours = ((szTemp[8] - '0') * 10) +
                    (szTemp[9] - '0');

        if (nHours > 23)
            return FALSE;

        int nMinutes = ((szTemp[10] - '0') * 10) +
                      (szTemp[11] - '0');

        if (nMinutes > 59)
            return FALSE;

        int nSeconds = ((szTemp[12] - '0') * 10) +
                      (szTemp[13] - '0');

        if (nSeconds > 59)
            return FALSE;

        return TRUE;
    }

    return FALSE;
#endif

}

//=============================================================================
//  Goes through each of the date formats checking to see if any are valid
//=============================================================================
BOOL CDateTimeParser::CheckDateFormat(const wchar_t *pszDate, BOOL bCheckTimeAfter)
{
    if (DateFormat1(pszDate, bCheckTimeAfter))
        return TRUE;
    if (DateFormat2(pszDate, bCheckTimeAfter))
        return TRUE;
    if (DateFormat3(pszDate, bCheckTimeAfter))
        return TRUE;
    if (DateFormat4(pszDate, bCheckTimeAfter))
        return TRUE;
    if (DateFormat5(pszDate, bCheckTimeAfter))
        return TRUE;
    if (DateFormat6(pszDate, bCheckTimeAfter))
        return TRUE;
    if (DateFormat7(pszDate, bCheckTimeAfter))
        return TRUE;
    if (DateFormat8(pszDate, bCheckTimeAfter))
        return TRUE;
    if (DateFormat15(pszDate, bCheckTimeAfter))
        return TRUE;

    switch(m_nDayFormatPreference)
    {
    case dmy:
        if (DateFormat10(pszDate, TEXT("/"), bCheckTimeAfter))
            return TRUE;
        if (DateFormat10(pszDate, TEXT("-"), bCheckTimeAfter))
            return TRUE;
        if (DateFormat10(pszDate, TEXT("."), bCheckTimeAfter))
            return TRUE;
        if (DateFormat9(pszDate, TEXT("/"), bCheckTimeAfter))
            return TRUE;
        if (DateFormat9(pszDate, TEXT("-"), bCheckTimeAfter))
            return TRUE;
        if (DateFormat9(pszDate, TEXT("."), bCheckTimeAfter))
            return TRUE;
        if (DateFormat11(pszDate, TEXT("/"), bCheckTimeAfter))
            return TRUE;
        if (DateFormat11(pszDate, TEXT("-"), bCheckTimeAfter))
            return TRUE;
        if (DateFormat11(pszDate, TEXT("."), bCheckTimeAfter))
            return TRUE;
        if (DateFormat12(pszDate, TEXT("/"), bCheckTimeAfter))
            return TRUE;
        if (DateFormat12(pszDate, TEXT("-"), bCheckTimeAfter))
            return TRUE;
        if (DateFormat12(pszDate, TEXT("."), bCheckTimeAfter))
            return TRUE;
        if (DateFormat13(pszDate, TEXT("/"), bCheckTimeAfter))
            return TRUE;
        if (DateFormat13(pszDate, TEXT("-"), bCheckTimeAfter))
            return TRUE;
        if (DateFormat13(pszDate, TEXT("."), bCheckTimeAfter))
            return TRUE;
        if (DateFormat14(pszDate, TEXT("/"), bCheckTimeAfter))
            return TRUE;
        if (DateFormat14(pszDate, TEXT("-"), bCheckTimeAfter))
            return TRUE;
        if (DateFormat14(pszDate, TEXT("."), bCheckTimeAfter))
            return TRUE;
        break;
    case dym:
        if (DateFormat12(pszDate, TEXT("/"), bCheckTimeAfter))
            return TRUE;
        if (DateFormat12(pszDate, TEXT("-"), bCheckTimeAfter))
            return TRUE;
        if (DateFormat12(pszDate, TEXT("."), bCheckTimeAfter))
            return TRUE;
        if (DateFormat9(pszDate, TEXT("/"), bCheckTimeAfter))
            return TRUE;
        if (DateFormat9(pszDate, TEXT("-"), bCheckTimeAfter))
            return TRUE;
        if (DateFormat9(pszDate, TEXT("."), bCheckTimeAfter))
            return TRUE;
        if (DateFormat10(pszDate, TEXT("/"), bCheckTimeAfter))
            return TRUE;
        if (DateFormat10(pszDate, TEXT("-"), bCheckTimeAfter))
            return TRUE;
        if (DateFormat10(pszDate, TEXT("."), bCheckTimeAfter))
            return TRUE;
        if (DateFormat11(pszDate, TEXT("/"), bCheckTimeAfter))
            return TRUE;
        if (DateFormat11(pszDate, TEXT("-"), bCheckTimeAfter))
            return TRUE;
        if (DateFormat11(pszDate, TEXT("."), bCheckTimeAfter))
            return TRUE;
        if (DateFormat13(pszDate, TEXT("/"), bCheckTimeAfter))
            return TRUE;
        if (DateFormat13(pszDate, TEXT("-"), bCheckTimeAfter))
            return TRUE;
        if (DateFormat13(pszDate, TEXT("."), bCheckTimeAfter))
            return TRUE;
        if (DateFormat14(pszDate, TEXT("/"), bCheckTimeAfter))
            return TRUE;
        if (DateFormat14(pszDate, TEXT("-"), bCheckTimeAfter))
            return TRUE;
        if (DateFormat14(pszDate, TEXT("."), bCheckTimeAfter))
            return TRUE;
        break;
    case mdy:
        if (DateFormat9(pszDate, TEXT("/"), bCheckTimeAfter))
            return TRUE;
        if (DateFormat9(pszDate, TEXT("-"), bCheckTimeAfter))
            return TRUE;
        if (DateFormat9(pszDate, TEXT("."), bCheckTimeAfter))
            return TRUE;
        if (DateFormat10(pszDate, TEXT("/"), bCheckTimeAfter))
            return TRUE;
        if (DateFormat10(pszDate, TEXT("-"), bCheckTimeAfter))
            return TRUE;
        if (DateFormat10(pszDate, TEXT("."), bCheckTimeAfter))
            return TRUE;
        if (DateFormat11(pszDate, TEXT("/"), bCheckTimeAfter))
            return TRUE;
        if (DateFormat11(pszDate, TEXT("-"), bCheckTimeAfter))
            return TRUE;
        if (DateFormat11(pszDate, TEXT("."), bCheckTimeAfter))
            return TRUE;
        if (DateFormat12(pszDate, TEXT("/"), bCheckTimeAfter))
            return TRUE;
        if (DateFormat12(pszDate, TEXT("-"), bCheckTimeAfter))
            return TRUE;
        if (DateFormat12(pszDate, TEXT("."), bCheckTimeAfter))
            return TRUE;
        if (DateFormat13(pszDate, TEXT("/"), bCheckTimeAfter))
            return TRUE;
        if (DateFormat13(pszDate, TEXT("-"), bCheckTimeAfter))
            return TRUE;
        if (DateFormat13(pszDate, TEXT("."), bCheckTimeAfter))
            return TRUE;
        if (DateFormat14(pszDate, TEXT("/"), bCheckTimeAfter))
            return TRUE;
        if (DateFormat14(pszDate, TEXT("-"), bCheckTimeAfter))
            return TRUE;
        if (DateFormat14(pszDate, TEXT("."), bCheckTimeAfter))
            return TRUE;
        break;
    case myd:
        if (DateFormat11(pszDate, TEXT("/"), bCheckTimeAfter))
            return TRUE;
        if (DateFormat11(pszDate, TEXT("-"), bCheckTimeAfter))
            return TRUE;
        if (DateFormat11(pszDate, TEXT("."), bCheckTimeAfter))
            return TRUE;
        if (DateFormat9(pszDate, TEXT("/"), bCheckTimeAfter))
            return TRUE;
        if (DateFormat9(pszDate, TEXT("-"), bCheckTimeAfter))
            return TRUE;
        if (DateFormat9(pszDate, TEXT("."), bCheckTimeAfter))
            return TRUE;
        if (DateFormat10(pszDate, TEXT("/"), bCheckTimeAfter))
            return TRUE;
        if (DateFormat10(pszDate, TEXT("-"), bCheckTimeAfter))
            return TRUE;
        if (DateFormat10(pszDate, TEXT("."), bCheckTimeAfter))
            return TRUE;
        if (DateFormat12(pszDate, TEXT("/"), bCheckTimeAfter))
            return TRUE;
        if (DateFormat12(pszDate, TEXT("-"), bCheckTimeAfter))
            return TRUE;
        if (DateFormat12(pszDate, TEXT("."), bCheckTimeAfter))
            return TRUE;
        if (DateFormat13(pszDate, TEXT("/"), bCheckTimeAfter))
            return TRUE;
        if (DateFormat13(pszDate, TEXT("-"), bCheckTimeAfter))
            return TRUE;
        if (DateFormat13(pszDate, TEXT("."), bCheckTimeAfter))
            return TRUE;
        if (DateFormat14(pszDate, TEXT("/"), bCheckTimeAfter))
            return TRUE;
        if (DateFormat14(pszDate, TEXT("-"), bCheckTimeAfter))
            return TRUE;
        if (DateFormat14(pszDate, TEXT("."), bCheckTimeAfter))
            return TRUE;
        break;
    case ydm:
        if (DateFormat13(pszDate, TEXT("/"), bCheckTimeAfter))
            return TRUE;
        if (DateFormat13(pszDate, TEXT("-"), bCheckTimeAfter))
            return TRUE;
        if (DateFormat13(pszDate, TEXT("."), bCheckTimeAfter))
            return TRUE;
        if (DateFormat9(pszDate, TEXT("/"), bCheckTimeAfter))
            return TRUE;
        if (DateFormat9(pszDate, TEXT("-"), bCheckTimeAfter))
            return TRUE;
        if (DateFormat9(pszDate, TEXT("."), bCheckTimeAfter))
            return TRUE;
        if (DateFormat10(pszDate, TEXT("/"), bCheckTimeAfter))
            return TRUE;
        if (DateFormat10(pszDate, TEXT("-"), bCheckTimeAfter))
            return TRUE;
        if (DateFormat10(pszDate, TEXT("."), bCheckTimeAfter))
            return TRUE;
        if (DateFormat11(pszDate, TEXT("/"), bCheckTimeAfter))
            return TRUE;
        if (DateFormat11(pszDate, TEXT("-"), bCheckTimeAfter))
            return TRUE;
        if (DateFormat11(pszDate, TEXT("."), bCheckTimeAfter))
            return TRUE;
        if (DateFormat12(pszDate, TEXT("/"), bCheckTimeAfter))
            return TRUE;
        if (DateFormat12(pszDate, TEXT("-"), bCheckTimeAfter))
            return TRUE;
        if (DateFormat12(pszDate, TEXT("."), bCheckTimeAfter))
            return TRUE;
        if (DateFormat14(pszDate, TEXT("/"), bCheckTimeAfter))
            return TRUE;
        if (DateFormat14(pszDate, TEXT("-"), bCheckTimeAfter))
            return TRUE;
        if (DateFormat14(pszDate, TEXT("."), bCheckTimeAfter))
            return TRUE;
        break;
    case ymd:
        if (DateFormat14(pszDate, TEXT("/"), bCheckTimeAfter))
            return TRUE;
        if (DateFormat14(pszDate, TEXT("-"), bCheckTimeAfter))
            return TRUE;
        if (DateFormat14(pszDate, TEXT("."), bCheckTimeAfter))
            return TRUE;
        if (DateFormat9(pszDate, TEXT("/"), bCheckTimeAfter))
            return TRUE;
        if (DateFormat9(pszDate, TEXT("-"), bCheckTimeAfter))
            return TRUE;
        if (DateFormat9(pszDate, TEXT("."), bCheckTimeAfter))
            return TRUE;
        if (DateFormat10(pszDate, TEXT("/"), bCheckTimeAfter))
            return TRUE;
        if (DateFormat10(pszDate, TEXT("-"), bCheckTimeAfter))
            return TRUE;
        if (DateFormat10(pszDate, TEXT("."), bCheckTimeAfter))
            return TRUE;
        if (DateFormat11(pszDate, TEXT("/"), bCheckTimeAfter))
            return TRUE;
        if (DateFormat11(pszDate, TEXT("-"), bCheckTimeAfter))
            return TRUE;
        if (DateFormat11(pszDate, TEXT("."), bCheckTimeAfter))
            return TRUE;
        if (DateFormat12(pszDate, TEXT("/"), bCheckTimeAfter))
            return TRUE;
        if (DateFormat12(pszDate, TEXT("-"), bCheckTimeAfter))
            return TRUE;
        if (DateFormat12(pszDate, TEXT("."), bCheckTimeAfter))
            return TRUE;
        if (DateFormat13(pszDate, TEXT("/"), bCheckTimeAfter))
            return TRUE;
        if (DateFormat13(pszDate, TEXT("-"), bCheckTimeAfter))
            return TRUE;
        if (DateFormat13(pszDate, TEXT("."), bCheckTimeAfter))
            return TRUE;
        break;
    default:
        return FALSE;
    }

    return FALSE;
}

//=============================================================================
//  Goes through each of the time formats checking to see if any are valid
//  Order is important here.  Re-arranged to properly recognize AM/PM - mdavis.
//=============================================================================
BOOL CDateTimeParser::CheckTimeFormat(const wchar_t *pszTime, BOOL bCheckDateAfter)
{
    if (TimeFormat1(pszTime, bCheckDateAfter))
        return TRUE;
    if (TimeFormat3(pszTime, bCheckDateAfter))
        return TRUE;
    if (TimeFormat2(pszTime, bCheckDateAfter))
        return TRUE;
    if (TimeFormat5(pszTime, bCheckDateAfter))
        return TRUE;
    if (TimeFormat4(pszTime, bCheckDateAfter))
        return TRUE;
    if (TimeFormat8(pszTime, bCheckDateAfter))
        return TRUE;
    if (TimeFormat6(pszTime, bCheckDateAfter))
        return TRUE;
    if (TimeFormat9(pszTime, bCheckDateAfter))
        return TRUE;
    if (TimeFormat7(pszTime, bCheckDateAfter))
        return TRUE;

    return FALSE;
}

//=============================================================================
//  Checks for date/time in the following format...
//  'Mon[th] dd[,] [yy]yy'
//  passes remaining string on to time parser if bCheckTimeAfter is set
//=============================================================================
BOOL CDateTimeParser::DateFormat1(const wchar_t *pszDateTime, BOOL bCheckTimeAfter)
{
    //Copy of string which we can change...
    wchar_t *pszString;
    DUP_STRING_NEW(pszString,pszDateTime);

    if (!pszString)
        goto error;

    if (IsValidMonthString(pszString, TEXT(" "), m_pszFullMonth, m_pszShortMonth) != ok)
        goto error;

    if (IsValidDayNumber(NULL, TEXT(" ,")) != ok)
        goto error;

    if (IsValidYearNumber(NULL, TEXT(" "), FALSE) != ok)
        goto error;

    if (bCheckTimeAfter)
    {
        //Get the remaining string
        wchar_t *pszRemainingString = wcstok(NULL, TEXT(""));

        if (pszRemainingString)
        {
            //Skip white space
            while (*pszRemainingString == TEXT(' '))
                pszRemainingString++;

            //if we are not at the end of the string pass on to the time
            //parser
            if (*pszRemainingString != TEXT('\0'))
            {
                if (!CheckTimeFormat(pszRemainingString, FALSE))
                {
                    goto error;
                }
            }
        }
    }

    delete [] pszString;

    //mark date/time as valid...
    m_bValidDateTime = TRUE;

    return TRUE;

error:
    //mark date/time as invalid...
    ResetDate(TRUE);

    //Tidy up
    if (pszString)
        delete [] pszString;


    return FALSE;
}

//=============================================================================
//  Checks for date/time in the following format...
//  'Mon[th][,] yyyy'
//  passes remaining string on to time parser if bCheckTimeAfter is set
//=============================================================================
BOOL CDateTimeParser::DateFormat2(const wchar_t *pszDateTime, BOOL bCheckTimeAfter)
{
    //Copy of string which we can change...
    wchar_t *pszString;
    DUP_STRING_NEW(pszString, pszDateTime);

    if (!pszString)
        goto error;

    if (IsValidMonthString(pszString, TEXT(" ,"), m_pszFullMonth, m_pszShortMonth) != ok)
        goto error;

    if (IsValidYearNumber(NULL, TEXT(" "), TRUE) != ok)
        goto error;

    if (bCheckTimeAfter)
    {
        //Get the remaining string
        wchar_t *pszRemainingString = wcstok(NULL, TEXT(""));

        if (pszRemainingString)
        {
            //Skip white space
            while (*pszRemainingString == TEXT(' '))
                pszRemainingString++;

            //if we are not at the end of the string pass on to the time
            //parser
            if (*pszRemainingString != TEXT('\0'))
            {
                if (!CheckTimeFormat(pszRemainingString, FALSE))
                {
                    goto error;
                }
            }
        }
    }

    delete [] pszString;

    //mark date/time as valid...
    m_bValidDateTime = TRUE;

    return TRUE;

error:
    //mark date/time as invalid...
    ResetDate(TRUE);

    //Tidy up
    if (pszString)
        delete [] pszString;


    return FALSE;
}

//=============================================================================
//  Checks for date/time in the following format...
//  'Mon[th] [yy]yy dd'
//  passes remaining string on to time parser if bCheckTimeAfter is set
//=============================================================================
BOOL CDateTimeParser::DateFormat3(const wchar_t *pszDateTime, BOOL bCheckTimeAfter)
{
    //Copy of string which we can change...
    wchar_t *pszString;
    DUP_STRING_NEW(pszString, pszDateTime);

    if (!pszString)
        goto error;

    if (IsValidMonthString(pszString, TEXT(" ,"), m_pszFullMonth, m_pszShortMonth) != ok)
        goto error;

    if (IsValidYearNumber(NULL, TEXT(" "), FALSE) != ok)
        goto error;

    if (IsValidDayNumber(NULL, TEXT(" ")) != ok)
        goto error;


    if (bCheckTimeAfter)
    {
        //Get the remaining string
        wchar_t *pszRemainingString = wcstok(NULL, TEXT(""));

        if (pszRemainingString)
        {
            //Skip white space
            while (*pszRemainingString == TEXT(' '))
                pszRemainingString++;

            //if we are not at the end of the string pass on to the time
            //parser
            if (*pszRemainingString != TEXT('\0'))
            {
                if (!CheckTimeFormat(pszRemainingString, FALSE))
                {
                    goto error;
                }
            }
        }
    }
    delete [] pszString;

    //mark date/time as valid...
    m_bValidDateTime = TRUE;

    return TRUE;

error:
    //mark date/time as invalid...
    ResetDate(TRUE);

    //Tidy up
    if (pszString)
        delete [] pszString;


    return FALSE;
}

//=============================================================================
//  Checks for date/time in the following format...
//  'dd Mon[th][,][ ][yy]yy'
//  passes remaining string on to time parser if bCheckTimeAfter is set
//=============================================================================
BOOL CDateTimeParser::DateFormat4(const wchar_t *pszDateTime, BOOL bCheckTimeAfter)
{
    //Copy of string which we can change...
    wchar_t *pszString;
    DUP_STRING_NEW(pszString, pszDateTime);

    if (!pszString)
        goto error;

    if (IsValidDayNumber(pszString, TEXT(" ")) != ok)
        goto error;

    if (IsValidMonthString(NULL, TEXT(" ,"), m_pszFullMonth, m_pszShortMonth) != ok)
        goto error;

    if (IsValidYearNumber(NULL, TEXT(" "), FALSE) != ok)
        goto error;

    if (bCheckTimeAfter)
    {
        //Get the remaining string
        wchar_t *pszRemainingString = wcstok(NULL, TEXT(""));

        if (pszRemainingString)
        {
            //Skip white space
            while (*pszRemainingString == TEXT(' '))
                pszRemainingString++;

            //if we are not at the end of the string pass on to the time
            //parser
            if (*pszRemainingString != TEXT('\0'))
            {
                if (!CheckTimeFormat(pszRemainingString, FALSE))
                {
                    goto error;
                }
            }
        }
    }

    delete [] pszString;

    //mark date/time as valid...
    m_bValidDateTime = TRUE;

    return TRUE;

error:
    //mark date/time as invalid...
    ResetDate(TRUE);

    //Tidy up
    if (pszString)
        delete [] pszString;


    return FALSE;
}

//=============================================================================
//  Checks for date/time in the following format...
//  'dd [yy]yy Mon[th]'
//  passes remaining string on to time parser if bCheckTimeAfter is set
//=============================================================================
BOOL CDateTimeParser::DateFormat5(const wchar_t *pszDateTime, BOOL bCheckTimeAfter)
{
    //Copy of string which we can change...
    wchar_t *pszString;
    DUP_STRING_NEW(pszString, pszDateTime);

    if (!pszString)
        goto error;

    if (IsValidDayNumber(pszString, TEXT(" ")) != ok)
        goto error;

    if (IsValidYearNumber(NULL, TEXT(" "), FALSE) != ok)
        goto error;

    if (IsValidMonthString(NULL, TEXT(" "), m_pszFullMonth, m_pszShortMonth) != ok)
        goto error;

    if (bCheckTimeAfter)
    {
        //Get the remaining string
        wchar_t *pszRemainingString = wcstok(NULL, TEXT(""));

        if (pszRemainingString)
        {
            //Skip white space
            while (*pszRemainingString == TEXT(' '))
                pszRemainingString++;

            //if we are not at the end of the string pass on to the time
            //parser
            if (*pszRemainingString != TEXT('\0'))
            {
                if (!CheckTimeFormat(pszRemainingString, FALSE))
                {
                    goto error;
                }
            }
        }
    }

    delete [] pszString;

    //mark date/time as valid...
    m_bValidDateTime = TRUE;

    return TRUE;

error:
    //mark date/time as invalid...
    ResetDate(TRUE);

    //Tidy up
    if (pszString)
        delete [] pszString;


    return FALSE;
}

//=============================================================================
//  Checks for date/time in the following format...
//  '[yy]yy Mon[th] dd'
//  passes remaining string on to time parser if bCheckTimeAfter is set
//=============================================================================
BOOL CDateTimeParser::DateFormat6(const wchar_t *pszDateTime, BOOL bCheckTimeAfter)
{
    //Copy of string which we can change...
    wchar_t *pszString;
    DUP_STRING_NEW(pszString, pszDateTime);

    if (!pszString)
        goto error;

    if (IsValidYearNumber(pszString, TEXT(" "), FALSE) != ok)
        goto error;

    if (IsValidMonthString(NULL, TEXT(" "), m_pszFullMonth, m_pszShortMonth) != ok)
        goto error;

    if (IsValidDayNumber(NULL, TEXT(" ")) != ok)
        goto error;

    if (bCheckTimeAfter)
    {
        //Get the remaining string
        wchar_t *pszRemainingString = wcstok(NULL, TEXT(""));

        if (pszRemainingString)
        {
            //Skip white space
            while (*pszRemainingString == ' ')
                pszRemainingString++;

            //if we are not at the end of the string pass on to the time
            //parser
            if (*pszRemainingString != '\0')
            {
                if (!CheckTimeFormat(pszRemainingString, FALSE))
                {
                    goto error;
                }
            }
        }
    }

    delete [] pszString;

    //mark date/time as valid...
    m_bValidDateTime = TRUE;

    return TRUE;

error:
    //mark date/time as invalid...
    ResetDate(TRUE);

    //Tidy up
    if (pszString)
        delete [] pszString;


    return FALSE;
}

//=============================================================================
//  Checks for date in the following format...
//  yyyy Mon[th]
//  passes remaining string on to time parser if bCheckTimeAfter is set
//=============================================================================
BOOL CDateTimeParser::DateFormat7(const wchar_t *pszDateTime, BOOL bCheckTimeAfter)
{
    //Copy of string which we can change...
    wchar_t *pszString;
    DUP_STRING_NEW(pszString, pszDateTime);

    if (!pszString)
        goto error;

    if (IsValidYearNumber(pszString, TEXT(" "), TRUE) != ok)
        goto error;

    if (IsValidMonthString(NULL, TEXT(" "), m_pszFullMonth, m_pszShortMonth) != ok)
        goto error;

    if (bCheckTimeAfter)
    {
        //Get the remaining string
        wchar_t *pszRemainingString = wcstok(NULL, TEXT(""));

        if (pszRemainingString)
        {
            //Skip white space
            while (*pszRemainingString == TEXT(' '))
                pszRemainingString++;

            //if we are not at the end of the string pass on to the time
            //parser
            if (*pszRemainingString != TEXT('\0'))
            {
                if (!CheckTimeFormat(pszRemainingString, FALSE))
                {
                    goto error;
                }
            }
        }
    }

    delete [] pszString;

    //mark date/time as valid...
    m_bValidDateTime = TRUE;

    return TRUE;

error:
    //mark date/time as invalid...
    ResetDate(TRUE);

    //Tidy up
    if (pszString)
        delete [] pszString;


    return FALSE;
}

//=============================================================================
//  Checks for date/time in the following format...
//  yyyy dd Mon[th]
//  passes remaining string on to time parser if bCheckTimeAfter is set
//=============================================================================
BOOL CDateTimeParser::DateFormat8(const wchar_t *pszDateTime, BOOL bCheckTimeAfter)
{
    //Copy of string which we can change...
    wchar_t *pszString;
    DUP_STRING_NEW(pszString, pszDateTime);

    if (!pszString)
        goto error;

    if (IsValidYearNumber(pszString, TEXT(" "), TRUE) != ok)
        goto error;

    if (IsValidDayNumber(NULL, TEXT(" ")) != ok)
        goto error;

    if (IsValidMonthString(NULL, TEXT(" "), m_pszFullMonth, m_pszShortMonth) != ok)
        goto error;

    if (bCheckTimeAfter)
    {
        //Get the remaining string
        wchar_t *pszRemainingString = wcstok(NULL, TEXT(""));

        if (pszRemainingString)
        {
            //Skip white space
            while (*pszRemainingString == TEXT(' '))
                pszRemainingString++;

            //if we are not at the end of the string pass on to the time
            //parser
            if (*pszRemainingString != '\0')
            {
                if (!CheckTimeFormat(pszRemainingString, FALSE))
                {
                    goto error;
                }
            }
        }
    }

    delete [] pszString;

    //mark date/time as valid...
    m_bValidDateTime = TRUE;

    return TRUE;

error:
    //mark date/time as invalid...
    ResetDate(TRUE);

    //Tidy up
    if (pszString)
        delete [] pszString;


    return FALSE;
}

//=============================================================================
//  Checks for date in the following format...
//  '[M]M{/-.}dd{/-.}[yy]yy         -> Separators have to be the same
//  passes remaining string on to time parser if bCheckTimeAfter is set
//=============================================================================
BOOL CDateTimeParser::DateFormat9(const wchar_t *pszDateTime,
                                  const wchar_t *pszDateSeparator,
                                  BOOL bCheckTimeAfter)
{
    //Copy of string which we can change...
    wchar_t *pszString;
    DUP_STRING_NEW(pszString, pszDateTime);

    if (!pszString)
        goto error;

    if (IsValidMonthNumber(pszString, pszDateSeparator) != ok)
        goto error;

    if (IsValidDayNumber(NULL, pszDateSeparator) != ok)
        goto error;

    if (IsValidYearNumber(NULL, TEXT(" "), FALSE) != ok)
        goto error;

    if (bCheckTimeAfter)
    {
        //Get the remaining string
        wchar_t *pszRemainingString = wcstok(NULL, TEXT(""));

        if (pszRemainingString)
        {
            //Skip white space
            while (*pszRemainingString == TEXT(' '))
                pszRemainingString++;

            //if we are not at the end of the string pass on to the time
            //parser
            if (*pszRemainingString != TEXT('\0'))
            {
                if (!CheckTimeFormat(pszRemainingString, FALSE))
                {
                    goto error;
                }
            }
        }
    }

    delete [] pszString;

    //mark date/time as valid...
    m_bValidDateTime = TRUE;

    return TRUE;

error:
    //mark date/time as invalid...
    ResetDate(TRUE);

    //Tidy up
    if (pszString)
        delete [] pszString;


    return FALSE;
}

//=============================================================================
//  Checks for date in the following format...
//  dd{/-.}[M]M{/-.}[yy]yy      -> Separators have to be the same
//  passes remaining string on to time parser if bCheckTimeAfter is set
//=============================================================================
BOOL CDateTimeParser::DateFormat10(const wchar_t *pszDateTime,
                                   const wchar_t *pszDateSeparator,
                                   BOOL bCheckTimeAfter)
{
    //Copy of string which we can change...
    wchar_t *pszString;
    DUP_STRING_NEW(pszString, pszDateTime);

    if (!pszString)
        goto error;


    if (IsValidDayNumber(pszString, pszDateSeparator) != ok)
        goto error;

    if (IsValidMonthNumber(NULL, pszDateSeparator) != ok)
        goto error;

    if (IsValidYearNumber(NULL, TEXT(" "), FALSE) != ok)
        goto error;

    if (bCheckTimeAfter)
    {
        //Get the remaining string
        wchar_t *pszRemainingString = wcstok(NULL, TEXT(""));

        if (pszRemainingString)
        {
            //Skip white space
            while (*pszRemainingString == TEXT(' '))
                pszRemainingString++;

            //if we are not at the end of the string pass on to the time
            //parser
            if (*pszRemainingString != TEXT('\0'))
            {
                if (!CheckTimeFormat(pszRemainingString, FALSE))
                {
                    goto error;
                }
            }
        }
    }

    delete [] pszString;

    //mark date/time as valid...
    m_bValidDateTime = TRUE;

    return TRUE;

error:
    //mark date/time as invalid...
    ResetDate(TRUE);

    //Tidy up
    if (pszString)
        delete [] pszString;

    return FALSE;
}

//=============================================================================
//  Checks for date in the following format...
//  [M]M{/-.}[yy]yy{/-.}dd      ->Has to be same separator!
//  passes remaining string on to time parser if bCheckTimeAfter is set
//=============================================================================
BOOL CDateTimeParser::DateFormat11(const wchar_t *pszDateTime,
                                   const wchar_t *pszDateSeparator,
                                   BOOL bCheckTimeAfter)
{
    //Copy of string which we can change...
    wchar_t *pszString;
    DUP_STRING_NEW(pszString, pszDateTime);

    if (!pszString)
        goto error;

    if (IsValidMonthNumber(pszString, pszDateSeparator) != ok)
        goto error;

    if (IsValidYearNumber(NULL, pszDateSeparator, FALSE) != ok)
        goto error;

    if (IsValidDayNumber(NULL, TEXT(" ")) != ok)
        goto error;

    if (bCheckTimeAfter)
    {
        //Get the remaining string
        wchar_t *pszRemainingString = wcstok(NULL, TEXT(""));

        if (pszRemainingString)
        {
            //Skip white space
            while (*pszRemainingString == TEXT(' '))
                pszRemainingString++;

            //if we are not at the end of the string pass on to the time
            //parser
            if (*pszRemainingString != TEXT('\0'))
            {
                if (!CheckTimeFormat(pszRemainingString, FALSE))
                {
                    goto error;
                }
            }
        }
    }

    delete [] pszString;

    //mark date/time as valid...
    m_bValidDateTime = TRUE;

    return TRUE;

error:
    //mark date/time as invalid...
    ResetDate(TRUE);

    //Tidy up
    if (pszString)
        delete [] pszString;

    return FALSE;
}

//=============================================================================
//  Checks for date in the following format...
//  dd{/-.}[yy]yy{/-.}[M]M      ->Has to be same separator!
//  passes remaining string on to time parser if bCheckTimeAfter is set
//=============================================================================
BOOL CDateTimeParser::DateFormat12(const wchar_t *pszDateTime,
                                   const wchar_t *pszDateSeparator,
                                   BOOL bCheckTimeAfter)
{
    //Copy of string which we can change...
    wchar_t *pszString;
    DUP_STRING_NEW(pszString, pszDateTime);

    if (!pszString)
        goto error;

    if (IsValidDayNumber(pszString, pszDateSeparator) != ok)
        goto error;

    if (IsValidYearNumber(NULL, pszDateSeparator, FALSE) != ok)
        goto error;

    if (IsValidMonthNumber(NULL, TEXT(" ")) != ok)
        goto error;

    if (bCheckTimeAfter)
    {
        //Get the remaining string
        wchar_t *pszRemainingString = wcstok(NULL, TEXT(""));

        if (pszRemainingString)
        {
            //Skip white space
            while (*pszRemainingString == TEXT(' '))
                pszRemainingString++;

            //if we are not at the end of the string pass on to the time
            //parser
            if (*pszRemainingString != TEXT('\0'))
            {
                if (!CheckTimeFormat(pszRemainingString, FALSE))
                {
                    goto error;
                }
            }
        }
    }

    delete [] pszString;

    //mark date/time as valid...
    m_bValidDateTime = TRUE;

    return TRUE;

error:
    //mark date/time as invalid...
    ResetDate(TRUE);

    //Tidy up
    if (pszString)
        delete [] pszString;

    return FALSE;
}

//=============================================================================
//  Checks for date in the following format...
//  [yy]yy{/-.}dd{/-.}[M]M      ->Has to be same separator!
//  passes remaining string on to time parser if bCheckTimeAfter is set
//=============================================================================
BOOL CDateTimeParser::DateFormat13(const wchar_t *pszDateTime,
                                   const wchar_t *pszDateSeparator,
                                   BOOL bCheckTimeAfter)
{
    //Copy of string which we can change...
    wchar_t *pszString;
    DUP_STRING_NEW(pszString, pszDateTime);

    if (!pszString)
        goto error;

    if (IsValidYearNumber(pszString, pszDateSeparator, FALSE) != ok)
        goto error;

    if (IsValidDayNumber(NULL, pszDateSeparator) != ok)
        goto error;

    if (IsValidMonthNumber(NULL, TEXT(" ")) != ok)
        goto error;

    if (bCheckTimeAfter)
    {
        //Get the remaining string
        wchar_t *pszRemainingString = wcstok(NULL, TEXT(""));

        if (pszRemainingString)
        {
            //Skip white space
            while (*pszRemainingString == TEXT(' '))
                pszRemainingString++;

            //if we are not at the end of the string pass on to the time
            //parser
            if (*pszRemainingString != TEXT('\0'))
            {
                if (!CheckTimeFormat(pszRemainingString, FALSE))
                {
                    goto error;
                }
            }
        }
    }

    delete [] pszString;

    //mark date/time as valid...
    m_bValidDateTime = TRUE;

    return TRUE;

error:
    //mark date/time as invalid...
    ResetDate(TRUE);

    //Tidy up
    if (pszString)
        delete [] pszString;

    return FALSE;
}

//=============================================================================
//  Checks for date in the following format...
//  [yy]yy{/-.}[M]M{/-.}dd      ->Has to be same separator!
//  passes remaining string on to time parser if bCheckTimeAfter is set
//=============================================================================
BOOL CDateTimeParser::DateFormat14(const wchar_t *pszDateTime,
                                   const wchar_t *pszDateSeparator,
                                   BOOL bCheckTimeAfter)
{
    //Copy of string which we can change...
    wchar_t *pszString;
    DUP_STRING_NEW(pszString, pszDateTime);

    if (!pszString)
        goto error;

    if (IsValidYearNumber(pszString, pszDateSeparator, FALSE) != ok)
        goto error;

    if (IsValidMonthNumber(NULL, pszDateSeparator) != ok)
        goto error;

    if (IsValidDayNumber(NULL, TEXT(" ")) != ok)
        goto error;

    if (bCheckTimeAfter)
    {
        //Get the remaining string
        wchar_t *pszRemainingString = wcstok(NULL, TEXT(""));

        if (pszRemainingString)
        {
            //Skip white space
            while (*pszRemainingString == TEXT(' '))
                pszRemainingString++;

            //if we are not at the end of the string pass on to the time
            //parser
            if (*pszRemainingString != TEXT('\0'))
            {
                if (!CheckTimeFormat(pszRemainingString, FALSE))
                {
                    goto error;
                }
            }
        }
    }

    delete [] pszString;

    //mark date/time as valid...
    m_bValidDateTime = TRUE;

    return TRUE;

error:
    //mark date/time as invalid...
    ResetDate(TRUE);

    //Tidy up
    if (pszString)
        delete [] pszString;

    return FALSE;
}

//=============================================================================
//  Checks for date in the following format...
//  [yy]yyMMdd
//  yyyy[MM[dd]]
//  passes remaining string on to time parser if bCheckTimeAfter is set
//=============================================================================
BOOL CDateTimeParser::DateFormat15(const wchar_t *pszDateTime,
                                   BOOL bCheckTimeAfter)
{
    //Copy of string which we can change...
    wchar_t *pszString;
    DUP_STRING_NEW(pszString, pszDateTime);

    if (!pszString)
        goto error;

    if (IsValidYearMonthDayNumber(pszString) != ok)
        goto error;

    if (bCheckTimeAfter)
    {
        //Get the remaining string
        wchar_t *pszRemainingString = wcstok(NULL, TEXT(""));

        if (pszRemainingString)
        {
            //Skip white space
            while (*pszRemainingString == TEXT(' '))
                pszRemainingString++;

            //if we are not at the end of the string pass on to the time
            //parser
            if (*pszRemainingString != TEXT('\0'))
            {
                if (!CheckTimeFormat(pszRemainingString, FALSE))
                {
                    goto error;
                }
            }
        }
    }

    delete [] pszString;

    //mark date/time as valid...
    m_bValidDateTime = TRUE;

    return TRUE;

error:
    //mark date/time as invalid...
    ResetDate(TRUE);

    //Tidy up
    if (pszString)
        delete [] pszString;

    return FALSE;
}


//=============================================================================
//  Checks for time in the following format...
//  hh[ ]{AP}M
//  passes remaining string on to date parser if bCheckDateAfter is set
//=============================================================================
BOOL CDateTimeParser::TimeFormat1(const wchar_t *pszDateTime, BOOL bCheckDateAfter)
{
    //Copy of string which we can change...
    wchar_t *pszString;
    DUP_STRING_NEW(pszString, pszDateTime);

    wchar_t *pszAP = AllocAmPm();

    if (!pszString || !pszAP)
        goto error;

    if (IsValidHourNumber(pszString, pszAP) != ok)
        goto error;

    if (IsValidAmPmString(NULL, TEXT(" "), m_pszAmPm) != ok)
        goto error;

    if (bCheckDateAfter)
    {
        //Get the remaining string
        wchar_t *pszRemainingString = wcstok(NULL, TEXT(""));

        if (pszRemainingString)
        {
            //Skip white space
            while (*pszRemainingString == TEXT(' '))
                pszRemainingString++;

            //if we are not at the end of the string pass on to the date
            //parser
            if (*pszRemainingString != TEXT('\0'))
            {
                if (!CheckDateFormat(pszRemainingString, FALSE))
                {
                    goto error;
                }
            }
        }
    }

    delete [] pszString;
    delete [] pszAP;

    //mark date/time as valid...
    m_bValidDateTime = TRUE;

    return TRUE;

error:
    //mark date/time as invalid...
    ResetTime(TRUE);

    //Tidy up
    if (pszString)
        delete [] pszString;

    if (pszAP)
        delete [] pszAP;

    return FALSE;
}

//=============================================================================
//  Checks for time in the following format...
//  hh:mm
//  passes remaining string on to date parser if bCheckDateAfter is set
//=============================================================================
BOOL CDateTimeParser::TimeFormat2(const wchar_t *pszDateTime, BOOL bCheckDateAfter)
{
    //Copy of string which we can change...
    wchar_t *pszString;
    DUP_STRING_NEW(pszString, pszDateTime);

    if (!pszString)
        goto error;

    if (IsValidHourNumber(pszString, TEXT(":")) != ok)
        goto error;

    if (IsValidMinuteNumber(NULL, TEXT(" ")) != ok)
        goto error;

    if (bCheckDateAfter)
    {
        //Get the remaining string
        wchar_t *pszRemainingString = wcstok(NULL, TEXT(""));

        if (pszRemainingString)
        {
            //Skip white space
            while (*pszRemainingString == TEXT(' '))
                pszRemainingString++;

            //if we are not at the end of the string pass on to the date
            //parser
            if (*pszRemainingString != TEXT('\0'))
            {
                if (!CheckDateFormat(pszRemainingString, FALSE))
                {
                    goto error;
                }
            }
        }
    }

    delete [] pszString;

    //mark date/time as valid...
    m_bValidDateTime = TRUE;

    return TRUE;

error:
    //mark date/time as invalid...
    ResetTime(TRUE);

    //Tidy up
    if (pszString)
        delete [] pszString;

    return FALSE;
}

//=============================================================================
//  Checks for time in the following format...
//  hh:mm[ ]{AP}M
//  passes remaining string on to date parser if bCheckDateAfter is set
//=============================================================================
BOOL CDateTimeParser::TimeFormat3(const wchar_t *pszDateTime, BOOL bCheckDateAfter)
{
    //Copy of string which we can change...
    wchar_t *pszString;
    DUP_STRING_NEW(pszString, pszDateTime);

    wchar_t *pszAP = AllocAmPm();

    if (!pszString || !pszAP)
        goto error;

    if (IsValidHourNumber(pszString, TEXT(":")) != ok)
        goto error;

    if (IsValidMinuteNumber(NULL, pszAP) != ok)
        goto error;

    if (IsValidAmPmString(NULL, TEXT(" "), m_pszAmPm) != ok)
        goto error;

    if (bCheckDateAfter)
    {
        //Get the remaining string
        wchar_t *pszRemainingString = wcstok(NULL, TEXT(""));

        if (pszRemainingString)
        {
            //Skip white space
            while (*pszRemainingString == TEXT(' '))
                pszRemainingString++;

            //if we are not at the end of the string pass on to the date
            //parser
            if (*pszRemainingString != TEXT('\0'))
            {
                if (!CheckDateFormat(pszRemainingString, FALSE))
                {
                    goto error;
                }
            }
        }
    }

    delete [] pszString;
    delete [] pszAP;

    //mark date/time as valid...
    m_bValidDateTime = TRUE;

    return TRUE;

error:
    //mark date/time as invalid...
    ResetTime(TRUE);

    //Tidy up
    if (pszString)
        delete [] pszString;

    if (pszAP)
        delete [] pszAP;

    return FALSE;
}

//=============================================================================
//  Checks for time in the following format...
//  hh:mm:ss
//  passes remaining string on to date parser if bCheckDateAfter is set
//=============================================================================
BOOL CDateTimeParser::TimeFormat4(const wchar_t *pszDateTime, BOOL bCheckDateAfter)
{
    //Copy of string which we can change...
    wchar_t *pszString;
    DUP_STRING_NEW(pszString, pszDateTime);

    if (!pszString)
        goto error;

    if (IsValidHourNumber(pszString, TEXT(":")) != ok)
        goto error;

    if (IsValidMinuteNumber(NULL, TEXT(":")) != ok)
        goto error;

    if (IsValidSecondNumber(NULL, TEXT(" ")) != ok)
        goto error;

    if (bCheckDateAfter)
    {
        //Get the remaining string
        wchar_t *pszRemainingString = wcstok(NULL, TEXT(""));

        if (pszRemainingString)
        {
            //Skip white space
            while (*pszRemainingString == TEXT(' '))
                pszRemainingString++;

            //if we are not at the end of the string pass on to the date
            //parser
            if (*pszRemainingString != TEXT('\0'))
            {
                if (!CheckDateFormat(pszRemainingString, FALSE))
                {
                    goto error;
                }
            }
        }
    }

    delete [] pszString;

    //mark date/time as valid...
    m_bValidDateTime = TRUE;

    return TRUE;

error:
    //mark date/time as invalid...
    ResetTime(TRUE);

    //Tidy up
    if (pszString)
        delete [] pszString;

    return FALSE;
}

//=============================================================================
//  Checks for time in the following format...
//  hh:mm:ss[ ]{AP}M
//  passes remaining string on to date parser if bCheckDateAfter is set
//=============================================================================
BOOL CDateTimeParser::TimeFormat5(const wchar_t *pszDateTime, BOOL bCheckDateAfter)
{
    //Copy of string which we can change...
    wchar_t *pszString;
    DUP_STRING_NEW(pszString, pszDateTime);

    wchar_t *pszAP = AllocAmPm();

    if (!pszString || !pszAP)
        goto error;

    if (IsValidHourNumber(pszString, TEXT(":")) != ok)
        goto error;

    if (IsValidMinuteNumber(NULL, TEXT(":")) != ok)
        goto error;

    if (IsValidSecondNumber(NULL, pszAP) != ok)
        goto error;

    if (IsValidAmPmString(NULL, TEXT(" "), m_pszAmPm) != ok)
        goto error;

    if (bCheckDateAfter)
    {
        //Get the remaining string
        wchar_t *pszRemainingString = wcstok(NULL, TEXT(""));

        if (pszRemainingString)
        {
            //Skip white space
            while (*pszRemainingString == TEXT(' '))
                pszRemainingString++;

            //if we are not at the end of the string pass on to the date
            //parser
            if (*pszRemainingString != TEXT('\0'))
            {
                if (!CheckDateFormat(pszRemainingString, FALSE))
                {
                    goto error;
                }
            }
        }
    }

    delete [] pszString;
    delete [] pszAP;

    //mark date/time as valid...
    m_bValidDateTime = TRUE;

    return TRUE;

error:
    //mark date/time as invalid...
    ResetTime(TRUE);

    //Tidy up
    if (pszString)
        delete [] pszString;

    if (pszAP)
        delete [] pszAP;

    return FALSE;
}

//=============================================================================
//  Checks for time in the following format...
//  hh:mm:ss:uuu
//  passes remaining string on to date parser if bCheckDateAfter is set
//=============================================================================
BOOL CDateTimeParser::TimeFormat6(const wchar_t *pszDateTime, BOOL bCheckDateAfter)
{
    //Copy of string which we can change...
    wchar_t *pszString;
    DUP_STRING_NEW(pszString, pszDateTime);

    if (!pszString)
        goto error;

    if (IsValidHourNumber(pszString, TEXT(":")) != ok)
        goto error;

    if (IsValidMinuteNumber(NULL, TEXT(":")) != ok)
        goto error;

    if (IsValidSecondNumber(NULL, TEXT(":")) != ok)
        goto error;

    if (IsValidColonMillisecond(NULL, TEXT(" ")) != ok)
        goto error;

    if (bCheckDateAfter)
    {
        //Get the remaining string
        wchar_t *pszRemainingString = wcstok(NULL, TEXT(""));

        if (pszRemainingString)
        {
            //Skip white space
            while (*pszRemainingString == TEXT(' '))
                pszRemainingString++;

            //if we are not at the end of the string pass on to the date
            //parser
            if (*pszRemainingString != TEXT('\0'))
            {
                if (!CheckDateFormat(pszRemainingString, FALSE))
                {
                    goto error;
                }
            }
        }
    }

    delete [] pszString;

    //mark date/time as valid...
    m_bValidDateTime = TRUE;

    return TRUE;

error:
    //mark date/time as invalid...
    ResetTime(TRUE);

    //Tidy up
    if (pszString)
        delete [] pszString;

    return FALSE;
}

//=============================================================================
//  Checks for time in the following format...
//  hh:mm:ss.[[u]u]u
//  passes remaining string on to date parser if bCheckDateAfter is set
//=============================================================================
BOOL CDateTimeParser::TimeFormat7(const wchar_t *pszDateTime, BOOL bCheckDateAfter)
{
    //Copy of string which we can change...
    wchar_t *pszString;
    DUP_STRING_NEW(pszString, pszDateTime);

    if (!pszString)
        goto error;

    if (IsValidHourNumber(pszString, TEXT(":")) != ok)
        goto error;

    if (IsValidMinuteNumber(NULL, TEXT(":")) != ok)
        goto error;

    if (IsValidSecondNumber(NULL, TEXT(".")) != ok)
        goto error;

    if (IsValidDotMillisecond(NULL, TEXT(" ")) != ok)
        goto error;

    if (bCheckDateAfter)
    {
        //Get the remaining string
        wchar_t *pszRemainingString = wcstok(NULL, TEXT(""));

        if (pszRemainingString)
        {
            //Skip white space
            while (*pszRemainingString == TEXT(' '))
                pszRemainingString++;

            //if we are not at the end of the string pass on to the date
            //parser
            if (*pszRemainingString != TEXT('\0'))
            {
                if (!CheckDateFormat(pszRemainingString, FALSE))
                {
                    goto error;
                }
            }
        }
    }

    delete [] pszString;

    //mark date/time as valid...
    m_bValidDateTime = TRUE;

    return TRUE;

error:
    //mark date/time as invalid...
    ResetTime(TRUE);

    //Tidy up
    if (pszString)
        delete [] pszString;

    return FALSE;
}

//=============================================================================
//  Checks for time in the following format...
//  hh:mm:ss:uuu[ ]{AP}M
//  passes remaining string on to date parser if bCheckDateAfter is set
//=============================================================================
BOOL CDateTimeParser::TimeFormat8(const wchar_t *pszDateTime, BOOL bCheckDateAfter)
{
    //Copy of string which we can change...
    wchar_t *pszString;
    DUP_STRING_NEW(pszString, pszDateTime);

    wchar_t *pszAP = AllocAmPm();

    if (!pszString || !pszAP)
        goto error;

    if (IsValidHourNumber(pszString, TEXT(":")) != ok)
        goto error;

    if (IsValidMinuteNumber(NULL, TEXT(":")) != ok)
        goto error;

    if (IsValidSecondNumber(NULL, TEXT(":")) != ok)
        goto error;

    if (IsValidColonMillisecond(NULL, pszAP) != ok)
        goto error;

    if (IsValidAmPmString(NULL, TEXT(" "), m_pszAmPm) != ok)
        goto error;

    if (bCheckDateAfter)
    {
        //Get the remaining string
        wchar_t *pszRemainingString = wcstok(NULL, TEXT(""));

        if (pszRemainingString)
        {
            //Skip white space
            while (*pszRemainingString == TEXT(' '))
                pszRemainingString++;

            //if we are not at the end of the string pass on to the date
            //parser
            if (*pszRemainingString != TEXT('\0'))
            {
                if (!CheckDateFormat(pszRemainingString, FALSE))
                {
                    goto error;
                }
            }
        }
    }

    delete [] pszString;
    delete [] pszAP;

    //mark date/time as valid...
    m_bValidDateTime = TRUE;

    return TRUE;

error:
    //mark date/time as invalid...
    ResetTime(TRUE);

    //Tidy up
    if (pszString)
        delete [] pszString;

    if (pszAP)
        delete [] pszAP;

    return FALSE;
}

//=============================================================================
//  Checks for time in the following format...
//  hh:mm:ss.[[u]u]u[ ]{AP}M
//  passes remaining string on to date parser if bCheckDateAfter is set
//=============================================================================
BOOL CDateTimeParser::TimeFormat9(const wchar_t *pszDateTime, BOOL bCheckDateAfter)
{
    //Copy of string which we can change...
    wchar_t *pszString;
    DUP_STRING_NEW(pszString, pszDateTime);

    wchar_t *pszAP = AllocAmPm();

    if (!pszString || !pszAP)
        goto error;

    if (IsValidHourNumber(pszString, TEXT(":")) != ok)
        goto error;

    if (IsValidMinuteNumber(NULL, TEXT(":")) != ok)
        goto error;

    if (IsValidSecondNumber(NULL, TEXT(".")) != ok)
        goto error;

    if (IsValidDotMillisecond(NULL, pszAP) != ok)
        goto error;

    if (IsValidAmPmString(NULL, TEXT(" "), m_pszAmPm) != ok)
        goto error;

    if (bCheckDateAfter)
    {
        //Get the remaining string
        wchar_t *pszRemainingString = wcstok(NULL, TEXT(""));

        if (pszRemainingString)
        {
            //Skip white space
            while (*pszRemainingString == TEXT(' '))
                pszRemainingString++;

            //if we are not at the end of the string pass on to the date
            //parser
            if (*pszRemainingString != TEXT('\0'))
            {
                if (!CheckDateFormat(pszRemainingString, FALSE))
                {
                    goto error;
                }
            }
        }
    }

    delete [] pszString;
    delete [] pszAP;

    //mark date/time as valid...
    m_bValidDateTime = TRUE;

    return TRUE;

error:
    //mark date/time as invalid...
    ResetTime(TRUE);

    //Tidy up
    if (pszString)
        delete [] pszString;

    if (pszAP)
        delete [] pszAP;

    return FALSE;
}


//=========================================================================
//Check the month.
//=========================================================================
int CDateTimeParser::IsValidMonthString(wchar_t *pszString,
                                           const wchar_t *pszSeparator,
                                           wchar_t *pszFullMonth[],
                                           wchar_t *pszShortMonth[])
{
    BOOL bOK = FALSE;

    wchar_t *pszToken = wcstok(pszString, pszSeparator);
    if (pszToken == NULL)
        return nothingLeft;

    //Skip spaces
    while (*pszToken == TEXT(' '))
        pszToken++;

    if (*pszToken == TEXT('\0'))
        return nothingLeft;

    //Work through the possible months...
    for (int i = 0; i < 12; i++)
    {
        if ((lstrcmpi(pszShortMonth[i], pszToken) == 0) ||
            (lstrcmpi(pszFullMonth[i], pszToken) == 0))
        {
            //That is valid...
            bOK = TRUE;
            break;
        }
    }

    //Is this a valid month?
    if (!bOK)
    {
        return failed;
    }

    m_nMonth = i + 1;

    return ok;
}

//=========================================================================
//Check the month as a number.
//=========================================================================
int CDateTimeParser::IsValidMonthNumber(wchar_t *pszString,
                                        const wchar_t *pszSeparator)
{
    wchar_t *pszToken = wcstok(pszString, pszSeparator);
    if (pszToken == NULL)
        return nothingLeft;

    //Skip spaces...
    while (*pszToken == TEXT(' '))
        pszToken++;

    if (*pszToken == TEXT('\0'))
        return nothingLeft;

    //Check it is digits...
    for (int i = 0; pszToken[i] != TEXT('\0'); i++)
    {
        if (!wbem_isdigit(pszToken[i]))
            return failed;
    }

    //convert it to a number
    i = _wtoi(pszToken);

    if ((i < 1) || (i > 12))
        return failed;

    m_nMonth = (unsigned char)i;

    return ok;
}

//=========================================================================
//Check the day.
//=========================================================================
int CDateTimeParser::IsValidDayNumber(wchar_t *pszString,
                                      const wchar_t *pszSeparator)
{
    wchar_t *pszToken = wcstok(pszString, pszSeparator);
    if (pszToken == NULL)
        return nothingLeft;

    //Skip spaces...
    while (*pszToken == TEXT(' '))
        pszToken++;

    if (*pszToken == TEXT('\0'))
        return nothingLeft;

    //Check it is digits...
    for (int i = 0; pszToken[i] != TEXT('\0'); i++)
    {
        if (!wbem_isdigit(pszToken[i]))
            return failed;
    }

    //convert it to a number
    i = _wtoi(pszToken);

    if ((i < 1) || (i > 31))
        return failed;

    m_nDay = (unsigned char)i;

    return ok;
}

//=========================================================================
//Check the year.
//=========================================================================
int CDateTimeParser::IsValidYearNumber(wchar_t *pszString,
                                       const wchar_t *pszSeparator,
                                       BOOL bFourDigitsOnly)
{
    wchar_t *pszToken = wcstok(pszString, pszSeparator);
    if (pszToken == NULL)
        return nothingLeft;

    //Skip space
    while (*pszToken == TEXT(' '))
        pszToken++;

    if (*pszToken == TEXT('\0'))
        return nothingLeft;

    //Check it is digits...
    for (int i = 0; pszToken[i] != TEXT('\0'); i++)
    {
        if (!wbem_isdigit(pszToken[i]))
            return failed;
    }

    //Needs to be 2 or 4 digits
    if ((i != 2) && (i != 4))
        return failed;

    if ((i == 2) && bFourDigitsOnly)
        return failed;

    //convert it to a number
    m_nYear = _wtoi(pszToken);

    //Do any conversions for 2 digit years...
    if ((i == 2) && (m_nYear < 50))
    {
        m_nYear += 2000;
    }
    else if (i == 2)
    {
        m_nYear += 1900;
    }

    return ok;
}

//=========================================================================
//Check the hours.
//=========================================================================
int CDateTimeParser::IsValidHourNumber(wchar_t *pszString,
                                       const wchar_t *pszSeparator)
{
    wchar_t *pszToken = wcstok(pszString, pszSeparator);
    if (pszToken == NULL)
        return nothingLeft;

    //Skip space
    while (*pszToken == TEXT(' '))
        pszToken++;

    if (*pszToken == TEXT('\0'))
        return nothingLeft;

    //Check it is digits...
    for (int i = 0; pszToken[i] != TEXT('\0'); i++)
    {
        if (!wbem_isdigit(pszToken[i]))
            return failed;
    }

    //convert it to a number
    i = _wtoi(pszToken);

    //Validate a little
    if ((i < 0) || (i > 23))
        return failed;

    m_nHours = (unsigned char)i;

    return ok;
}

//=========================================================================
//Check the Minutes.
//=========================================================================
int CDateTimeParser::IsValidMinuteNumber(wchar_t *pszString,
                                         const wchar_t *pszSeparator)
{
    wchar_t *pszToken = wcstok(pszString, pszSeparator);
    if (pszToken == NULL)
        return nothingLeft;

    if (*pszToken == TEXT('\0'))
        return nothingLeft;

    //Check it is digits...
    for (int i = 0; pszToken[i] != TEXT('\0'); i++)
    {
        if (!wbem_isdigit(pszToken[i]))
            return failed;
    }

    //convert it to a number
    i = _wtoi(pszToken);

    //Validate a little
    if ((i < 0) || (i > 59))
        return failed;

    m_nMinutes = (unsigned char)i;

    return ok;
}

//=========================================================================
//Check the Seconds.
//=========================================================================
int CDateTimeParser::IsValidSecondNumber(wchar_t *pszString,
                                         const wchar_t *pszSeparator)
{
    wchar_t *pszToken = wcstok(pszString, pszSeparator);
    if (pszToken == NULL)
        return nothingLeft;

    if (*pszToken == TEXT('\0'))
        return nothingLeft;

    //Check it is digits...
    for (int i = 0; pszToken[i] != TEXT('\0'); i++)
    {
        if (!wbem_isdigit(pszToken[i]))
            return failed;
    }

    //convert it to a number
    i = _wtoi(pszToken);

    //Validate a little
    if ((i < 0) || (i > 59))
        return failed;

    m_nSeconds = (unsigned char)i;

    return ok;
}

//=========================================================================
//Check the milliseconds.  This is a colon prefix version
//=========================================================================
int CDateTimeParser::IsValidColonMillisecond(wchar_t *pszString,
                                             const wchar_t *pszSeparator)
{
    wchar_t *pszToken = wcstok(pszString, pszSeparator);
    if (pszToken == NULL)
        return nothingLeft;

    if (*pszToken == TEXT('\0'))
        return nothingLeft;

    //Check it is digits...
    for (int i = 0; pszToken[i] != TEXT('\0'); i++)
    {
        if (!wbem_isdigit(pszToken[i]))
            return failed;
    }

    //convert it to a number
    i = _wtoi(pszToken);

    //Validate a little
    if ((i < 0) || (i > 999))
        return failed;

    //milliseconds to microseconds
    m_nMicroseconds = i * 1000;

    return ok;
}

//=========================================================================
//Check the milliseconds.  This is a dot prefix (decimal) version
//=========================================================================
int CDateTimeParser::IsValidDotMillisecond(wchar_t *pszString,
                                           const wchar_t *pszSeparator)
{
    wchar_t *pszToken = wcstok(pszString, pszSeparator);
    if (pszToken == NULL)
        return nothingLeft;

    if (*pszToken == TEXT('\0'))
        return nothingLeft;

    //Check it is digits...
    for (int i = 0; pszToken[i] != TEXT('\0'); i++)
    {
        if (!wbem_isdigit(pszToken[i]))
            return failed;
    }

    //convert it to a number
    int nVal = _wtoi(pszToken);

    //Convert the value into thousandths of a second.
    if (i < 3)
        nVal *= 10;

    if (i < 2)
        nVal *= 10;

    //Validate a little
    if ((nVal < 0) || (nVal > 999))
        return failed;

    //milliseconds to microseconds
    m_nMicroseconds = nVal * 1000;

    return ok;
}

//=========================================================================
//Check the AM/PM part.
//=========================================================================
int CDateTimeParser::IsValidAmPmString(wchar_t *pszString,
                                       const wchar_t *pszSeparator,
                                       wchar_t *pszAmPm[])
{
    wchar_t *pszToken = wcstok(pszString, pszSeparator);
    if (pszToken == NULL)
        return nothingLeft;

    BOOL bOK = FALSE;

    //Skip spaces
    while (*pszToken == TEXT(' '))
    {
        pszToken++;
    }

    if (*pszToken == TEXT('\0'))
        return nothingLeft;

    //Check it is digits...
    //Work through the possible AM/PM items...
    for (int i = 0; i < 2; i++)
    {
        if (lstrcmpi(pszAmPm[i], pszToken) == 0)
        {
            //That is valid...
            bOK = TRUE;
            break;
        }
    }

    if (!bOK)
        return failed;

    if (i == 1)
    {
        //PM adds 12 hours
        m_nHours += 12;
    }
    else if (m_nHours == 12)
    {
        //for AM, 12 o'clock equals 0 in 24 hour time.
        m_nHours = 0;
    }


    //Does this make the number too large now?
    if (m_nHours > 23)
        return failed;

    return ok;
}

//=========================================================================
//  Check the purely numeric year, month, day format...
//  [yy]yyMMdd
//  yyyy[MMdd]
//  NOTE:   6 and 8 digit dates are always ymd.
//          4 digits is always year
//=========================================================================
int CDateTimeParser::IsValidYearMonthDayNumber(wchar_t *pszString)
{
    int j;
    wchar_t *pszToken = wcstok(pszString, TEXT(" "));
    if (pszToken == NULL)
        return nothingLeft;

    BOOL bOK = FALSE;

    //Skip spaces
    while (*pszToken == TEXT(' '))
    {
        pszToken++;
    }

    if (*pszToken == TEXT('\0'))
        return nothingLeft;

    //Check it is digits...
    for (int i = 0; pszToken[i] != TEXT('\0'); i++)
    {
        if (!wbem_isdigit(pszToken[i]))
            return failed;
    }

    //We support 4, 6 and 8 digits
    if ((i != 4) && (i != 6) && (i != 8))
        return failed;

    //4 digit years...
    if ((i == 4) || (i == 8))
    {
        m_nYear = 0;
        for (j = 0;j < 4; j++)
        {
            m_nYear *= 10;
            m_nYear += (*pszToken - '0');
            pszToken++;
        }
    }
    else
    {
        //2 digit years
        m_nYear = 0;
        for (j = 0;j < 2; j++)
        {
            m_nYear *= 10;
            m_nYear += (*pszToken - '0');
            pszToken++;
        }

        if (m_nYear >= 50)
        {
            m_nYear += 1900;
        }
        else
        {
            m_nYear += 2000;
        }
    }

    //If we have month and year...
    if (i > 4)
    {
        m_nMonth = ((*pszToken - TEXT('0')) * 10) + (*(pszToken+1) - TEXT('0'));
        pszToken += 2;

        if ((m_nMonth < 0) && (m_nMonth > 12))
            return failed;

        m_nDay = ((*pszToken - TEXT('0')) * 10) + (*(pszToken+1) - TEXT('0'));
        if ((m_nDay < 0) && (m_nDay > 31))
            return failed;
    }

    return ok;
}

int CDateTimeParser::FillDMTF(WCHAR* pwszBuffer, size_t cchSize)
{
    if(!IsValidDateTime())
        return failed;

    if(FAILED(StringCchPrintfW(pwszBuffer, cchSize, L"%04d%02d%02d%02d%02d%02d.%06d%c%03d",
        m_nYear, m_nMonth, m_nDay, m_nHours, m_nMinutes, m_nSeconds,
        m_nMicroseconds,
        ((m_nUTC >= 0)?L'+':L'-'),
        ((m_nUTC >= 0)?m_nUTC:-m_nUTC)))) return failed;

    return ok;
}

BOOL NormalizeCimDateTime(
    IN  LPCWSTR pszSrc,
    OUT BSTR *strAdjusted
    )
{
    int yr = 0, mo = 0, da = 0, hh = 0, mm = 0, ss = 0, micro = 0, utcOffset = 0;
    wchar_t wcSign = 0;

    if (pszSrc == 0 || strAdjusted == 0)
        return FALSE;

    // Parse DMTF format.
    // yyyymmddhhmmss.mmmmmmsuuu
    // =========================

    swscanf(pszSrc, L"%04d%02d%02d%02d%02d%02d.%06d%C%03d",
        &yr, &mo, &da, &hh, &mm, &ss, &micro, &wcSign, &utcOffset
        );

    if (wcSign == 0)
        return FALSE;

    // Convert to Win32 time for adjustment.
    // =====================================

    SYSTEMTIME st;
    FILETIME ft;

    st.wYear = WORD(yr);
    st.wMonth = WORD(mo);
    st.wDay = WORD(da);
    st.wDayOfWeek = 0;
    st.wHour = WORD(hh);
    st.wMinute = WORD(mm);
    st.wSecond = WORD(ss);
    st.wMilliseconds = WORD(micro / 1000);

    BOOL bRes = SystemTimeToFileTime(&st, &ft);
    if (!bRes)
        return bRes;

    ULARGE_INTEGER ul;
    ul.HighPart = ft.dwHighDateTime;
    ul.LowPart = ft.dwLowDateTime;
    unsigned __int64 u64 = ul.QuadPart;

    // Adjust rest of time so that we normalize to UTC

    if (wcSign == L'-')
        u64 += (unsigned __int64) 600000000 * (unsigned __int64) utcOffset;
    else
        u64 -= (unsigned __int64) 600000000 * (unsigned __int64) utcOffset;

    ul.QuadPart = u64;
    ft.dwHighDateTime = ul.HighPart;
    ft.dwLowDateTime = ul.LowPart;

    bRes = FileTimeToSystemTime(&ft, &st);
    if (!bRes)
        return bRes;

    wchar_t buf[128];
    StringCchPrintfW(buf, 128, L"%04d%02d%02d%02d%02d%02d.%06d+000",
        st.wYear, st.wMonth, st.wDay,
        st.wHour, st.wMinute, st.wSecond, st.wMilliseconds*1000
        );

    *strAdjusted = SysAllocString(buf);
    if (*strAdjusted == 0)
        return FALSE;

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\winmgmt\wbemcomn\cwbemtime.h ===
/*++

Copyright (C) 1996-2001 Microsoft Corporation

Module Name:

    CWBEMTIME.H

Abstract:

    Time helper

History:

--*/

#ifndef __WBEM_TIME__H_
#define __WBEM_TIME__H_

#include "corepol.h"

#define WBEMTIME_LENGTH	25

class POLARITY CWbemInterval
{
protected:
    DWORD m_dwMs;

    CWbemInterval(DWORD dwMs) : m_dwMs(dwMs){}
    friend class CWbemTime;
public:
    CWbemInterval() : m_dwMs(0){}

    static CWbemInterval GetInfinity() {return CWbemInterval(INFINITE);}
    BOOL IsFinite() const {return m_dwMs != INFINITE;}
    BOOL IsZero() const {return m_dwMs == 0;}

    DWORD GetMilliseconds() const {return m_dwMs;}
    DWORD GetSeconds() const {return m_dwMs/1000;}
    void SetMilliseconds(DWORD dwMs) {m_dwMs = dwMs;}

    BOOL operator<(const CWbemInterval Other)
        {return m_dwMs < Other.m_dwMs;}
    BOOL operator>(const CWbemInterval Other)
        {return m_dwMs > Other.m_dwMs;}
    
    CWbemInterval operator*(double dblFactor) const
        {return CWbemInterval((DWORD)(m_dwMs * dblFactor));}

    CWbemInterval operator+(const CWbemInterval Other) const
        {return CWbemInterval(m_dwMs + Other.m_dwMs);}

    void operator+=(const CWbemInterval Other)
        {m_dwMs += Other.m_dwMs;}
};

#define I64_INFINITY 0x7FFFFFFFFFFFFFFF

class POLARITY CWbemTimeSpan 
{
private:

    ULONGLONG m_Time;
    friend class CWbemTime;

public:

    CWbemTimeSpan ( 

        int iDays , 
        int iHours , 
        int iMinutes ,  
        int iSeconds , 
        int iMSec=0 , 
        int iUSec=0, 
        int iNSec=0 
    ) ;

};

class POLARITY CWbemTime
{
protected:
    __int64 m_i64;

    CWbemTime(__int64 i64) : m_i64(i64){}
    friend class CWbemInterval;
public:
    CWbemTime() : m_i64(0){}
    CWbemTime(const CWbemTime& Other) : m_i64(Other.m_i64){}
    void operator=(const CWbemTime& Other)
    {
        m_i64 = Other.m_i64;
    }

    static CWbemTime GetCurrentTime();
    static CWbemTime GetInfinity() {return CWbemTime(I64_INFINITY);}
    static CWbemTime GetZero() {return CWbemTime(0);}

    BOOL SetSystemTime(const SYSTEMTIME& st);
    BOOL SetFileTime(const FILETIME& ft);
    BOOL GetSYSTEMTIME ( SYSTEMTIME *pst ) const;
    BOOL GetFILETIME ( FILETIME *pst ) const;

    __int64 Get100nss() const {return m_i64;}
    void Set100nss(__int64 i64) {m_i64 = i64;}

    CWbemInterval RemainsUntil(const CWbemTime& Other) const;
    BOOL IsFinite() const {return m_i64 != I64_INFINITY;}
    BOOL IsZero() const {return m_i64 == 0;}
   
    CWbemTime        operator+ ( const CWbemTimeSpan &uAdd ) const ;
    CWbemTime        operator- ( const CWbemTimeSpan &sub ) const;

    BOOL operator <(const CWbemTime& Other) const 
        {return m_i64 < Other.m_i64;}
    BOOL operator >(const CWbemTime& Other) const 
        {return m_i64 > Other.m_i64;}
    BOOL operator <=(const CWbemTime& Other) const 
        {return m_i64 <= Other.m_i64;}
    BOOL operator >=(const CWbemTime& Other) const 
        {return m_i64 >= Other.m_i64;}
    CWbemTime operator+(const CWbemInterval& ToAdd) const;
    CWbemInterval operator-(const CWbemTime& ToSubtract) const
        {return ToSubtract.RemainsUntil(*this);}

    BOOL SetDMTF(LPCWSTR wszText);
    static LONG GetLocalOffsetForDate(const SYSTEMTIME *pst);    

 private:
	BOOL GetDMTF( BOOL bLocal, DWORD dwBuffLen, LPWSTR pwszBuff );



};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\winmgmt\wbemcomn\dothrow.cpp ===
#include "precomp.h"
#include <dothrow.h>
const CX_MemoryException wmibad_alloc;

void dothrow_t::raise_bad_alloc()
{
	throw wmibad_alloc;
}

void dothrow_t::raise_lock_failure()
{
	throw wmibad_alloc;
}

const dothrow_t dothrow;
const wminothrow_t wminothrow;
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\winmgmt\wbemcomn\datetimeparser.h ===
/*++

Copyright (C) 1996-2001 Microsoft Corporation

Module Name:

    DATETIMEPARSER.H

Abstract:

    Validates a date/time string and converts into it's component values.

History:

--*/

#ifndef _datetimeparser_
#define _datetimeparser_

#include "corepol.h"

class POLARITY CDateTimeParser
{
public:
    enum { ok = 0, failed, nothingLeft };

    //nDayFormatPreference values
    typedef enum { dmy, dym, mdy, myd, ydm, ymd } DayFormatPreference;

    //Constructor. This takes a DateTime string and parses it.
    CDateTimeParser(const TCHAR *pszDateTime);

    //Destructor.  Tidies up after itself.
    ~CDateTimeParser();

    //Tidies up and parses a new date and time.
    BOOL SetDateTime(const TCHAR *pszDateTime);

    //Returns the status of the currently parsed date/time.
    BOOL IsValidDateTime()          { return m_bValidDateTime; }

    //Retrieves the bits and pieces we found.  Zero means it was not
    //found or was zero!  This may change!
    unsigned char GetDay()          { return m_nDay; }
    unsigned char GetMonth()        { return m_nMonth; }
    unsigned int  GetYear()         { return m_nYear; }
    unsigned char GetHours()        { return m_nHours; }
    unsigned char GetMinutes()      { return m_nMinutes; }
    unsigned char GetSeconds()      { return m_nSeconds; }
    unsigned int  GetMicroseconds() { return m_nMicroseconds; }
    int  GetUTC()           { return m_nUTC; }

    int FillDMTF(WCHAR* pwszBuffer, size_t cchSize);

    // Static helper functions to allow other code to perform quick DMTF DateTime validation
    // without executing a lot of unnecessary NLS code.

    static BOOL CheckDMTFDateTimeFormat(const TCHAR *wszDateTime, BOOL bFailIfRelative = FALSE,
                    BOOL bFailIfUnzoned = FALSE);
    static BOOL CheckDMTFDateTimeInterval(const TCHAR *wszInterval);

protected:

    // Protected constructor, to keep outside code from instantiating us in a half-initialized
    // state.  This constructor is used by a static helper function for validating DMTF formats.
    CDateTimeParser(void);

    // Prevents others from accessing
    //Resets all the date/time values to the default values.
    //If bSQL is TRUE it sets to the SQL default.  Otherwise
    //sets to the DMTF default.
    void ResetDateTime(BOOL bSQL);
    void ResetDate(BOOL bSQL);
    void ResetTime(BOOL bSQL);

    //Does a check to make sure the date/time is in the DMTF
    //date/time format.
    //Fills in the class date/time elements.
    BOOL CheckDMTFDateTimeFormatInternal(const TCHAR *pszDateTime);

    //Does a check from the start of the string specified.  If
    //bCheckTimeAfter set a call to CheckTimeFormat is called
    //after each successful parse of the date.
    //Fills in the class date/time elements.
    BOOL CheckDateFormat(const TCHAR *pszDate, BOOL bCheckTimeAfter);

    //Does a check from the start of the string specified.  If
    //bCheckDateAfter set a call to CheckDateFormat is called
    //after each successful parse of the time.
    //Fills in the class date/time elements.
    BOOL CheckTimeFormat(const TCHAR *pszTime, BOOL bCheckDateAfter);

    BOOL DateFormat1(const TCHAR *pszDate, BOOL bCheckTimeAfter);
    BOOL DateFormat2(const TCHAR *pszDate, BOOL bCheckTimeAfter);
    BOOL DateFormat3(const TCHAR *pszDate, BOOL bCheckTimeAfter);
    BOOL DateFormat4(const TCHAR *pszDate, BOOL bCheckTimeAfter);
    BOOL DateFormat5(const TCHAR *pszDate, BOOL bCheckTimeAfter);
    BOOL DateFormat6(const TCHAR *pszDate, BOOL bCheckTimeAfter);
    BOOL DateFormat7(const TCHAR *pszDate, BOOL bCheckTimeAfter);
    BOOL DateFormat8(const TCHAR *pszDate, BOOL bCheckTimeAfter);
    BOOL DateFormat9(const TCHAR *pszDate, const TCHAR *pszDateSeparator, BOOL bCheckTimeAfter);
    BOOL DateFormat10(const TCHAR *pszDate, const TCHAR *pszDateSeparator, BOOL bCheckTimeAfter);
    BOOL DateFormat11(const TCHAR *pszDate, const TCHAR *pszDateSeparator, BOOL bCheckTimeAfter);
    BOOL DateFormat12(const TCHAR *pszDate, const TCHAR *pszDateSeparator, BOOL bCheckTimeAfter);
    BOOL DateFormat13(const TCHAR *pszDate, const TCHAR *pszDateSeparator, BOOL bCheckTimeAfter);
    BOOL DateFormat14(const TCHAR *pszDate, const TCHAR *pszDateSeparator, BOOL bCheckTimeAfter);
    BOOL DateFormat15(const TCHAR *pszDate, BOOL bCheckTimeAfter);

    BOOL TimeFormat1(const TCHAR *pszTime, BOOL bCheckDateAfter);
    BOOL TimeFormat2(const TCHAR *pszTime, BOOL bCheckDateAfter);
    BOOL TimeFormat3(const TCHAR *pszTime, BOOL bCheckDateAfter);
    BOOL TimeFormat4(const TCHAR *pszTime, BOOL bCheckDateAfter);
    BOOL TimeFormat5(const TCHAR *pszTime, BOOL bCheckDateAfter);
    BOOL TimeFormat6(const TCHAR *pszTime, BOOL bCheckDateAfter);
    BOOL TimeFormat7(const TCHAR *pszTime, BOOL bCheckDateAfter);
    BOOL TimeFormat8(const TCHAR *pszTime, BOOL bCheckDateAfter);
    BOOL TimeFormat9(const TCHAR *pszTime, BOOL bCheckDateAfter);

    //Checks for long and short month string.  Leading spaces allowed.
    int IsValidMonthString(TCHAR *pszString,
                           const TCHAR *pszSeparator,
                           TCHAR *pszFullMonth[13],
                           TCHAR *pszShortMonth[13]);

    //Checks for a month as a numeric string.  Leading spaces allowed.
    //Checks to make sure month is in range 1-12
    int IsValidMonthNumber(TCHAR *pszString,
                           const TCHAR *pszSeparator);

    //Checks for valid day number.  Does no validation of
    //number except checking it is in range of 1-31
    //Leading spaces allowed.
    int IsValidDayNumber(TCHAR *pszString,
                         const TCHAR *pszSeparator);

    //Checks for valid year number.  Does conversion for
    //2 digit years.  Leading spaces allowed.
    int IsValidYearNumber(TCHAR *pszString,
                          const TCHAR *pszSeparator,
                          BOOL bFourDigitsOnly);

    //Checks for valid hours.  Validates for range 0-23
    //Leading spaces allowed.
    int IsValidHourNumber(TCHAR *pszString,
                          const TCHAR *pszSeparator);

    //Checks for valid minutes.  Validates for range 0-59.
    //No leading spaces allowed.
    int IsValidMinuteNumber(TCHAR *pszString,
                            const TCHAR *pszSeparator);

    //Checks for valid minutes.  Validates for range 0-59.
    //No leading spaces allowed.
    int IsValidSecondNumber(TCHAR *pszString,
                            const TCHAR *pszSeparator);

    //treats the number as thousandth of a second.
    int IsValidColonMillisecond(TCHAR *pszString,
                                const TCHAR *pszSeparator);

    //converts value to a thousandth of a second based on number
    //of digits included.
    int IsValidDotMillisecond(TCHAR *pszString,
                              const TCHAR *pszSeparator);

    //Checks for valid AM/PM string.  Leading space is allowed.  If
    //PM, adds 12 onto hours.  Validates hours so it is < 23.
    BOOL IsValidAmPmString(TCHAR *pszString,
                           const TCHAR *pszSeparator,
                           TCHAR *pszAmPm[2]);

    //Checks for a valid [yy]yyMMdd or yyyy day.  Validates
    //month to 1..12 and day to 1..31
    BOOL IsValidYearMonthDayNumber(TCHAR *pszString);

    void GetLocalInfoAndAlloc(LCTYPE LCType, LPTSTR &lpLCData);
    void GetPreferedDateFormat();
    TCHAR* AllocAmPm();

private:
    //Localised strings retrieved from GetLocalInfo which holds the long month strings
    TCHAR * m_pszFullMonth[13];

    //Localised strings retrieved from GetLocalInfo which holds the short month strings
    TCHAR * m_pszShortMonth[13];

    //Localised strings retrieved from GetLocalInfo which holds the short am/pm strings
    TCHAR *m_pszAmPm[2];

    //Lets us know if the string is valid or not.
    BOOL m_bValidDateTime;

    //These are the values which get filled in as we find then throughout the
    //parsing.
    unsigned char m_nDay;
    unsigned char m_nMonth;
    unsigned int  m_nYear;
    unsigned char m_nHours;
    unsigned char m_nMinutes;
    unsigned char m_nSeconds;
    unsigned int  m_nMicroseconds;
    int  m_nUTC;

    //Preference for date decoding
    DayFormatPreference m_nDayFormatPreference;
};

BOOL POLARITY NormalizeCimDateTime(
    IN  LPCWSTR pszSrc,
    OUT BSTR *strAdjusted
    );

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\winmgmt\wbemcomn\dothrow.h ===
#ifndef DOTHROW_H
#define DOTHROW_H
#include <new>
#include <corex.h>


struct dothrow_t 
{
	static void raise_bad_alloc();
	static void raise_lock_failure();
};

struct wminothrow_t 
{
	static void raise_bad_alloc(){};
	static void raise_lock_failure(){};
};

extern const dothrow_t dothrow;
extern const wminothrow_t wminothrow;

typedef wminothrow_t NOTHROW;
typedef dothrow_t DOTHROW;

/*
#if _MSC_VER > 1400

void * _cdecl operator new[](size_t size, const dothrow_t& ex_spec)
{
	void * p = ::operator new[](size);
	if (p) return p;
	dothrow_t::raise_bad_alloc();
	return p;

};

void _cdecl operator delete[](void * p, const dothrow_t&)
{
	::operator delete[](p);
};

#endif
*/

inline void * _cdecl operator new(size_t size,const dothrow_t&  ex_spec)
{
	void * p = operator new(size);
	if (p) return p;
	dothrow_t::raise_bad_alloc();
    return p;
};

inline void _cdecl operator delete(void * p, const dothrow_t&)
{
	operator delete(p);
};


// TEMPLATE CLASS allocator
template<class Ty>
	class throw_allocator {
public:
	typedef size_t size_type;
	typedef ptrdiff_t difference_type;
	typedef Ty *pointer;
	typedef const Ty *const_pointer;
	typedef Ty & reference;
	typedef const Ty & const_reference;
	typedef Ty value_type;
	pointer address(reference X) const
		{return (&X); }
	const_pointer address(const_reference X) const
		{return (&X); }
	pointer allocate(size_type N, const void *)
		{return (Allocate((difference_type)N, (pointer)0)); }
	char *_Charalloc(size_type N)
		{return (Allocate((difference_type)N,
			(char *)0)); }
	void deallocate(void *P, size_type)
		{operator delete(P,dothrow); }
	void construct(pointer P, const Ty& V)
		{Construct(P, V); }
	void destroy(pointer P)
		{Destroy(P); }
	size_t max_size() const
		{size_t N = (size_t)(-1) / sizeof (Ty);
		return (0 < N ? N : 1); }
	// TEMPLATE FUNCTION _Construct
	template<class T1, class T2> inline
		void Construct(T1 *P, const T2& V)
		{new ((void *)P) T1(V); }

	// TEMPLATE FUNCTION _Destroy
	template<class Ty> inline
	void Destroy(Ty *P)
		{_DESTRUCTOR(Ty, P); }

	inline void Destroy(char *)
	{}
	inline void Destroy(wchar_t *)
	{}
	// TEMPLATE FUNCTION _Allocate
	template<class Ty> inline
	Ty *Allocate(ptrdiff_t N, Ty *)
	{if (N < 0)
		N = 0;
	return ((Ty *)operator new(
		(size_t)N * sizeof (Ty),dothrow)); }

	};

template<class Ty, class U> inline
	bool operator==(const throw_allocator<Ty>&, const throw_allocator<U>&)
	{return (true); }
template<class Ty, class U> inline
	bool operator!=(const throw_allocator<Ty>&, const throw_allocator<U>&)
	{return (false); }

// CLASS allocator<void>
template<> class _CRTIMP throw_allocator<void> {
public:
	typedef void Ty;
	typedef Ty *pointer;
	typedef const Ty *const_pointer;
	typedef Ty value_type;
	};


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\winmgmt\wbemcomn\evtlog.h ===
/*++

Copyright (C) 1996-2001 Microsoft Corporation

Module Name:

    EVTLOG.H

Abstract:

    Event Log helpers

History:

--*/

#ifndef __WBEM_EVENT_LOG__H_
#define __WBEM_EVENT_LOG__H_

#define WBEM_EVENT_LOG_SOURCE L"WinMgmt"
#define WBEM_EVENT_LOG_DUPLICATE_TIMEOUT 10

#include "sync.h"

class POLARITY CHex
{
protected:
    long m_l;
public:
    CHex(long l) : m_l(l){}
    operator long() {return m_l;}
};

class POLARITY CInsertionString
{
protected:
    BOOL m_bEmpty;
    WString m_ws;

public:
    CInsertionString() : m_bEmpty(TRUE){}
    CInsertionString(LPCWSTR wsz) : m_bEmpty(FALSE), m_ws(wsz){}
    CInsertionString(LPCSTR sz) : m_bEmpty(FALSE), m_ws(sz){}
    CInsertionString(long l);
    CInsertionString(CHex h);

    LPCWSTR GetString() {return m_ws;}
    BOOL IsEmpty() {return m_bEmpty;}
};
    
class POLARITY CEventLogRecord
{
protected:
    WORD m_wType;
    DWORD m_dwEventID;
    CWStringArray m_awsStrings;
    CWbemTime m_CreationTime;

protected:
    void AddInsertionString(CInsertionString& s);

public:
    CEventLogRecord(WORD wType, DWORD dwEventID, 
                    CInsertionString s1 = CInsertionString(),
                    CInsertionString s2 = CInsertionString(),
                    CInsertionString s3 = CInsertionString(),
                    CInsertionString s4 = CInsertionString(),
                    CInsertionString s5 = CInsertionString(),
                    CInsertionString s6 = CInsertionString(),
                    CInsertionString s7 = CInsertionString(),
                    CInsertionString s8 = CInsertionString(),
                    CInsertionString s9 = CInsertionString(),
                    CInsertionString s10 = CInsertionString());
    ~CEventLogRecord(){}

    WORD GetNumStrings() {return (WORD) m_awsStrings.Size();}
    LPCWSTR GetStringAt(int nIndex);
    CWbemTime GetCreationTime() {return m_CreationTime;}

    BOOL operator==(const CEventLogRecord& Other);
};
    
POLARITY typedef CUniquePointerArray<CEventLogRecord> LogRecords;


class POLARITY CEventLog
{
private:
    WString m_wsServerName;
    WString m_wsSourceName;

    HANDLE m_hSource;
    FILE* m_fLog;

    BOOL m_bNT;
    DWORD m_dwTimeout;
    LogRecords* m_pRecords;
    CCritSec m_cs;
    
protected:
    BOOL SearchForRecord(CEventLogRecord* pRecord);
    void AddRecord(CEventLogRecord* pRecord);

public:
    CEventLog(LPCWSTR wszUNCServerName = NULL, 
                LPCWSTR wszSourceName = WBEM_EVENT_LOG_SOURCE,
                DWORD dwTimeout = WBEM_EVENT_LOG_DUPLICATE_TIMEOUT);
    ~CEventLog();

    BOOL Close();
    BOOL Open();

    BOOL Report(WORD wType, DWORD dwEventID, 
                    CInsertionString s1 = CInsertionString(),
                    CInsertionString s2 = CInsertionString(),
                    CInsertionString s3 = CInsertionString(),
                    CInsertionString s4 = CInsertionString(),
                    CInsertionString s5 = CInsertionString(),
                    CInsertionString s6 = CInsertionString(),
                    CInsertionString s7 = CInsertionString(),
                    CInsertionString s8 = CInsertionString(),
                    CInsertionString s9 = CInsertionString(),
                    CInsertionString s10 = CInsertionString());
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\winmgmt\wbemcomn\evtlog.cpp ===
/*++

Copyright (C) 1996-2001 Microsoft Corporation

Module Name:

    EVTLOG.CPP

Abstract:

    Event Log helpers

History:

--*/

#include "precomp.h"
#include <stdio.h>
#include <wbemcomn.h>
#include "CWbemTime.h"
#include <evtlog.h>
#include <genutils.h>

CInsertionString::CInsertionString(long l) : m_bEmpty(FALSE)
{
    WCHAR wsz[100];
    StringCchPrintfW(wsz, 100, L"%d", l);
    m_ws = wsz;
}

CInsertionString::CInsertionString(CHex h) : m_bEmpty(FALSE)
{
    WCHAR wsz[100];
    StringCchPrintfW(wsz, 100 , L"0x%x", (long)h);
    m_ws = wsz;
}

CEventLogRecord::CEventLogRecord(WORD wType, DWORD dwEventID, 
                    CInsertionString s1,
                    CInsertionString s2,
                    CInsertionString s3,
                    CInsertionString s4,
                    CInsertionString s5,
                    CInsertionString s6,
                    CInsertionString s7,
                    CInsertionString s8,
                    CInsertionString s9,
                    CInsertionString s10)
{
    m_wType = wType;
    m_dwEventID = dwEventID;
    m_CreationTime = CWbemTime::GetCurrentTime();
   
    AddInsertionString(s10);
    AddInsertionString(s9);
    AddInsertionString(s8);
    AddInsertionString(s7);
    AddInsertionString(s6);
    AddInsertionString(s5);
    AddInsertionString(s4);
    AddInsertionString(s3);
    AddInsertionString(s2);
    AddInsertionString(s1);
}

void CEventLogRecord::AddInsertionString(CInsertionString& s)
{
    if(!s.IsEmpty() || m_awsStrings.Size() > 0)
        m_awsStrings.InsertAt(0, s.GetString());
}

LPCWSTR CEventLogRecord::GetStringAt(int nIndex)
{
    if(nIndex >= m_awsStrings.Size())
        return NULL;
    else 
        return m_awsStrings[nIndex];
}

BOOL CEventLogRecord::operator==(const CEventLogRecord& Other)
{
    if(m_wType != Other.m_wType)
        return FALSE;
    if(m_dwEventID != Other.m_dwEventID)
        return FALSE;
    if(m_awsStrings.Size() != Other.m_awsStrings.Size())
        return FALSE;

    for(int i = 0;  i < m_awsStrings.Size(); i++)
    {
        if(wcscmp(m_awsStrings[i], Other.m_awsStrings[i]))
        {
            return FALSE;
        }
    }

    return TRUE;
}

    


CEventLog::CEventLog(LPCWSTR wszUNCServerName, LPCWSTR wszSourceName, 
                        DWORD dwTimeout)
    : m_wsServerName(wszUNCServerName), m_wsSourceName(wszSourceName),
        m_hSource(NULL), m_fLog(NULL), m_dwTimeout(dwTimeout)
{
    m_pRecords = new LogRecords;
    m_bNT = IsNT();
}

CEventLog::~CEventLog()
{
    delete m_pRecords;
    Close();
}

BOOL CEventLog::Close()
{
    if(m_bNT)
    {
        if(m_hSource != NULL)
        {
            DeregisterEventSource(m_hSource);
            m_hSource = NULL;
        }
    }

    return TRUE;
}

BOOL CEventLog::Open()
{
    if(m_bNT)
    {
        if(m_hSource == NULL)
        {
            m_hSource = RegisterEventSourceW(m_wsServerName, m_wsSourceName);
        }
        return (m_hSource != NULL);
    }
    else return TRUE;
}

BOOL CEventLog::SearchForRecord(CEventLogRecord* pRecord)
{
    for(int i = 0; i < m_pRecords->GetSize(); i++)
    {
        // Check if this record is still current
        // =====================================

        CWbemInterval Age = 
            CWbemTime::GetCurrentTime() - (*m_pRecords)[i]->GetCreationTime();
        if(Age.GetSeconds() > m_dwTimeout)
        {
            m_pRecords->RemoveAt(i);
            i--;
            continue;
        }

        // Compare the data
        // ================

        if( *(*m_pRecords)[i] == *pRecord)
            return TRUE;
    }
    return FALSE;
}

void CEventLog::AddRecord(CEventLogRecord* pRecord)
{
    m_pRecords->Add(pRecord);
}

BOOL CEventLog::Report(WORD wType, DWORD dwEventID, 
                CInsertionString s1,
                CInsertionString s2,
                CInsertionString s3,
                CInsertionString s4,
                CInsertionString s5,
                CInsertionString s6,
                CInsertionString s7,
                CInsertionString s8,
                CInsertionString s9,
                CInsertionString s10)
{
    CInCritSec ics(&m_cs);

    // Create a record
    // ===============

    CEventLogRecord* pRecord = new CEventLogRecord(wType, dwEventID, 
        s1, s2, s3, s4, s5, s6, s7, s8, s9, s10);
    if(!pRecord)
        return FALSE;

    // Search for it
    // =============

    BOOL bDuplicate = SearchForRecord(pRecord);
    if(bDuplicate)
    {
        delete pRecord;
        return TRUE;
    }

    AddRecord(pRecord);

    WORD wNumStrings = pRecord->GetNumStrings();

    // Log it
    // ======

    if(m_bNT)
    {
        if(m_hSource == NULL)
            return FALSE;

        LPCWSTR* awszStrings = new LPCWSTR[wNumStrings];
        if(!awszStrings)
            return FALSE;
        for(int i = 0; i < wNumStrings; i++)
            awszStrings[i] = pRecord->GetStringAt(i);
    
        BOOL bRes = ReportEventW(m_hSource, wType, 0, dwEventID, NULL, 
                        wNumStrings, 0, awszStrings, NULL);

        delete [] awszStrings;
        return bRes;
    }
    else
    {
        Registry r(HKEY_LOCAL_MACHINE, KEY_READ, WBEM_REG_WINMGMT);
        TCHAR* szInstDir;
        if(r.GetStr(__TEXT("Working Directory"), &szInstDir) != Registry::no_error)
        {
            ERRORTRACE((LOG_EVENTLOG, "Logging is unable to read the system "
                                            "registry!\n"));
            return FALSE;
        }
        CDeleteMe<TCHAR> dm1(szInstDir);
        size_t instDirLength = lstrlen(szInstDir);
		TCHAR* szDllPath = new TCHAR[instDirLength + 100];
        if(!szDllPath)
            return FALSE;
        
		StringCchPrintf(szDllPath, instDirLength+100, __TEXT("%s\\WinMgmtR.dll"), szInstDir);
        
		HINSTANCE hDll = LoadLibrary(szDllPath);
        delete [] szDllPath;
        if(hDll == NULL)
        {
            ERRORTRACE((LOG_EVENTLOG, "Logging is unable to open the message "
                            "DLL. Error code %d\n", GetLastError()));
            return FALSE;
        }
        

        LPSTR* aszStrings = new LPSTR[wNumStrings];
        if(!aszStrings)
            return FALSE;
        int i;
        for(i = 0; i < wNumStrings; i++)
            aszStrings[i] = WString(pRecord->GetStringAt(i)).GetLPSTR();
    
        char* szMessage;
        DWORD dwRes = FormatMessageA(FORMAT_MESSAGE_ALLOCATE_BUFFER | 
                            FORMAT_MESSAGE_FROM_HMODULE | 
                            FORMAT_MESSAGE_ARGUMENT_ARRAY,
                            hDll, dwEventID, 0, (char*)&szMessage,
                            0, (va_list*)aszStrings);

        for(i = 0; i < wNumStrings; i++)
            delete [] aszStrings[i];
        delete [] aszStrings;

        if(dwRes == 0)
        {
            ERRORTRACE((LOG_EVENTLOG, "Logging is unable to format the message "
                            "for event 0x%X. Error code: %d\n", 
                    dwEventID, GetLastError()));
            return FALSE;
        }
                        
        switch(wType)
        {
        case EVENTLOG_ERROR_TYPE:
        case EVENTLOG_WARNING_TYPE:
        case EVENTLOG_AUDIT_FAILURE:
            ERRORTRACE((LOG_EVENTLOG, "%s\n", szMessage));
        default:
            DEBUGTRACE((LOG_EVENTLOG, "%s\n", szMessage));
        }
        
        LocalFree(szMessage);

        return TRUE;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\winmgmt\wbemcomn\execq.cpp ===
/*++

Copyright (C) 1996-2001 Microsoft Corporation

Module Name:

    EXECQ.CPP

Abstract:

  Implements classes related to abstract execution queues.

  Classes implemeted:

      CExecRequest    An abstract request.
      CExecQueue      A queue of requests with an associated thread

History:

      23-Jul-96   raymcc    Created.
      3/10/97     levn      Fully documented (heh, heh)
      14-Aug-99   raymcc    Changed timeouts
      30-Oct-99   raymcc    Critsec changes for NT Wksta Stress Oct 30 1999
--*/

#include "precomp.h"
#include <stdio.h>
#include <wbemcomn.h>
#include <execq.h>
#include <cominit.h>
#include <sync.h>
#include "genutils.h"

#define IDLE_THREAD_TIMEOUT     12000
#define OVERLFLOW_TIMEOUT        5000


//***************************************************************************

long CExecQueue::mstatic_lNumInits = -1;
POLARITY DWORD mstatic_dwTlsIndex = 0xFFFFFFFF;

class CTlsStaticCleanUp
{
public:
    CTlsStaticCleanUp() {}
    ~CTlsStaticCleanUp() { if (mstatic_dwTlsIndex != 0xFFFFFFFF) TlsFree(mstatic_dwTlsIndex); }
};
CTlsStaticCleanUp g_tlsStaticCleanup;

#ifdef WINMGMT_THREAD_DEBUG
    CCritSec CExecRequest::mstatic_cs;
    CPointerArray<CExecRequest> CExecRequest::mstatic_apOut;

    #define THREADDEBUGTRACE DEBUGTRACE
#else
    #define THREADDEBUGTRACE(X)
#endif


CExecRequest::CExecRequest() : m_hWhenDone(NULL), m_pNext(NULL), m_lPriority(0), m_fOk( true )
{
#ifdef WINMGMT_THREAD_DEBUG
    CInCritSec ics(&mstatic_cs);
    mstatic_apOut.Add(this);
#endif
}

CExecRequest::~CExecRequest()
{
#ifdef WINMGMT_THREAD_DEBUG
    CInCritSec ics(&mstatic_cs);
    for(int i = 0; i < mstatic_apOut.GetSize(); i++)
    {
        if(mstatic_apOut[i] == this)
        {
            mstatic_apOut.RemoveAt(i);
            break;
        }
    }
#endif
}

DWORD CExecQueue::GetTlsIndex()
{
    return mstatic_dwTlsIndex;
}

CExecQueue::CThreadRecord::CThreadRecord(CExecQueue* pQueue)
    : m_pQueue(pQueue), m_pCurrentRequest(NULL), m_bReady(FALSE),
        m_bExitNow(FALSE),m_hThread(NULL)
{
    m_hAttention = CreateEvent(NULL, FALSE, FALSE, NULL);
    if (NULL == m_hAttention) throw CX_MemoryException();
}

CExecQueue::CThreadRecord::~CThreadRecord()
{
    CloseHandle(m_hAttention);
    if (m_hThread) CloseHandle(m_hThread);
}

void CExecQueue::CThreadRecord::Signal()
{
    SetEvent(m_hAttention);
}


//******************************************************************************
//
//  See execq.h for documentation
//
//******************************************************************************
CExecQueue::CExecQueue() : 
    m_lNumThreads(0), 
    m_lMaxThreads(1), 
    m_lNumIdle(0),
    m_lNumRequests(0), 
    m_pHead(NULL), 
    m_pTail(NULL), 
    m_dwTimeout(IDLE_THREAD_TIMEOUT),
    m_dwOverflowTimeout(OVERLFLOW_TIMEOUT), 
    m_lHiPriBound(-1), 
    m_lHiPriMaxThreads(1),
    m_lRef(0),
    m_bShutDonwCalled(FALSE)
{
    InitTls();
    SetRequestLimits(4000);
}

//******************************************************************************
//
//  See execq.h for documentation
//
//******************************************************************************
CExecQueue::~CExecQueue()
{
    Shutdown();
}

void CExecQueue::Shutdown()
{
    CCritSecWrapper cs(&m_cs);

    // Get all member thread handles
    // =============================

    if (m_bShutDonwCalled) return;
    cs.Enter();
    if (m_bShutDonwCalled) return;
    m_bShutDonwCalled = TRUE;
    
    int nNumHandles = m_aThreads.Size();
    int i, j=0;
    HANDLE* ah = NULL;
    if (nNumHandles)
    {    
	    ah = new HANDLE[nNumHandles];
	    DEBUGTRACE((LOG_WBEMCORE, "Queue is shutting down!\n"));

	    for(i = 0; i < nNumHandles; i++)
	    {
	        CThreadRecord* pRecord = (CThreadRecord*)m_aThreads[i];

	        if ( pRecord->m_hThread && ah)
	        {
	            ah[j++] = pRecord->m_hThread;
	        }
	        
	        // Inform the thread it should go away when ready
	        // ==============================================

	        pRecord->m_bExitNow = TRUE;

	        // Wake it up if necessary
	        // =======================

	        pRecord->Signal();
	    }
   	}
    
    cs.Leave();

    // Make sure all our threads are gone
    // ==================================

    for( i=0; i < j && ah; i++ )
    {
        DWORD dwRet = WaitForSingleObject( ah[i], INFINITE );
        _DBG_ASSERT( dwRet != WAIT_FAILED );
        CloseHandle(ah[i]);
    }

    delete [] ah;

    
    // Remove all outstanding requests
    // ===============================

    while(m_pHead)
    {
        CExecRequest* pReq = m_pHead;
        m_pHead = m_pHead->GetNext();
        delete pReq;
    }

}

//******************************************************************************
//
//  See execq.h for documentation
//
//******************************************************************************
// static
void CExecQueue::InitTls()
{
    if(InterlockedIncrement(&mstatic_lNumInits) == 0)
    {
        mstatic_dwTlsIndex = TlsAlloc();
    }
}

void CExecQueue::Enter()
{
    m_cs.Enter();
}

void CExecQueue::Leave()
{
    m_cs.Leave();
}

//******************************************************************************
//
//  See dbgalloc.h for documentation
//
//******************************************************************************
void CExecQueue::Register(CThreadRecord* pRecord)
{
    TlsSetValue(mstatic_dwTlsIndex, (void*)pRecord);
}

BOOL CExecQueue::IsSuitableThread(CThreadRecord* pRecord, CExecRequest* pReq)
{
    if(pRecord->m_pCurrentRequest == NULL)
        return TRUE;

    // This thread is in the middle of something. By default, ignore it
    // ================================================================

    return FALSE;
}

//******************************************************************************
//
//  See dbgalloc.h for documentation
//
//******************************************************************************
HRESULT CExecQueue::Enqueue(CExecRequest* pRequest, HANDLE* phWhenDone)
{
    if (m_bShutDonwCalled) return WBEM_E_FAILED;    
    CCritSecWrapper cs(&m_cs);
    if (m_bShutDonwCalled) return WBEM_E_FAILED;    

    // Check if the request has a problem with it.  If so, return the
    // appropriate error code.

    if ( !pRequest->IsOk() )
    {
        return WBEM_E_OUT_OF_MEMORY;
    }

    // Create an event handle to signal when request is finished, if required
    // ======================================================================
    if(phWhenDone)
    {
        *phWhenDone = CreateEvent(NULL, FALSE, FALSE, NULL);
        if (NULL == *phWhenDone) return WBEM_E_OUT_OF_MEMORY;
        pRequest->SetWhenDoneHandle(*phWhenDone);
    }

    cs.Enter();

    // Search for a suitable thread
    // ============================

    for(int i = 0; i < m_aThreads.Size(); i++)
    {
        CThreadRecord* pRecord = (CThreadRecord*)m_aThreads[i];

        if(pRecord->m_bReady)
        {
            // Free. Check if suitable
            // =======================

            if(IsSuitableThread(pRecord, pRequest))
            {
                pRecord->m_pCurrentRequest = pRequest;
                pRecord->m_bReady = FALSE;
                pRecord->Signal();
                m_lNumIdle--;

                // Done!
                // =====

                cs.Leave();
                return WBEM_S_NO_ERROR;
            }
        }
    }

    // No suitable thread found. Add to the queue
    // ==========================================

    if(m_lNumRequests >= m_lAbsoluteLimitCount)
    {
        cs.Leave();
        return WBEM_E_FAILED;
    }

    // Search for insert position based on priority
    // ============================================

    AdjustInitialPriority(pRequest);

    CExecRequest* pCurrent = m_pHead;
    CExecRequest* pLast = NULL;

    while(pCurrent && pCurrent->GetPriority() <= pRequest->GetPriority())
    {
        pLast = pCurrent;
        pCurrent = pCurrent->GetNext();
    }

    // Insert
    // ======

    if(pCurrent)
    {
        pRequest->SetNext(pCurrent);
    }
    else
    {
        m_pTail = pRequest;
    }

    if(pLast)
    {
        pLast->SetNext(pRequest);
    }
    else
    {
        m_pHead= pRequest;
    }

    m_lNumRequests++;

    // Adjust priorities of the loosers
    // ================================

    while(pCurrent)
    {
        AdjustPriorityForPassing(pCurrent);
        pCurrent = pCurrent->GetNext();
    }

    // Create a new thread, if required
    // ================================

    if(DoesNeedNewThread(pRequest))
        CreateNewThread();

    long lIndex = m_lNumRequests;
    cs.Leave();

    // Sit out whatever penalty is imposed
    // ===================================

    SitOutPenalty(lIndex);
    return WBEM_S_NO_ERROR;
}

//******************************************************************************
//
//  See dbgalloc.h for documentation
//
//******************************************************************************
HRESULT CExecQueue::EnqueueWithoutSleep(CExecRequest* pRequest, HANDLE* phWhenDone)
{
    if (m_bShutDonwCalled) return WBEM_E_FAILED;
    CCritSecWrapper cs(&m_cs);
    if (m_bShutDonwCalled) return WBEM_E_FAILED;        

    // Check if the request has a problem with it.  If so, return the
    // appropriate error code.

    if ( !pRequest->IsOk() )
    {
        return WBEM_E_OUT_OF_MEMORY;
    }

    // Create an event handle to signal when request is finished, if required
    // ======================================================================

    if(phWhenDone)
    {
        *phWhenDone = CreateEvent(NULL, FALSE, FALSE, NULL);
        if (NULL == *phWhenDone) return WBEM_E_OUT_OF_MEMORY;
        pRequest->SetWhenDoneHandle(*phWhenDone);
    }

    cs.Enter();

    // Search for a suitable thread
    // ============================

    for(int i = 0; i < m_aThreads.Size(); i++)
    {
        CThreadRecord* pRecord = (CThreadRecord*)m_aThreads[i];

        if(pRecord->m_bReady)
        {
            // Free. Check if suitable
            // =======================

            if(IsSuitableThread(pRecord, pRequest))
            {
                pRecord->m_pCurrentRequest = pRequest;
                pRecord->m_bReady = FALSE;
                pRecord->Signal();
                m_lNumIdle--;

                // Done!
                // =====

                cs.Leave();
                return WBEM_S_NO_ERROR;
            }
        }
    }

    // No suitable thread found. Add to the queue
    // ==========================================

    if(m_lNumRequests >= m_lAbsoluteLimitCount)
    {
        cs.Leave();
        return WBEM_E_FAILED;
    }

    // Search for insert position based on priority
    // ============================================

    AdjustInitialPriority(pRequest);

    CExecRequest* pCurrent = m_pHead;
    CExecRequest* pLast = NULL;

    while(pCurrent && pCurrent->GetPriority() <= pRequest->GetPriority())
    {
        pLast = pCurrent;
        pCurrent = pCurrent->GetNext();
    }

    // Insert
    // ======

    if(pCurrent)
    {
        pRequest->SetNext(pCurrent);
    }
    else
    {
        m_pTail = pRequest;
    }

    if(pLast)
    {
        pLast->SetNext(pRequest);
    }
    else
    {
        m_pHead= pRequest;
    }

    m_lNumRequests++;

    // Adjust priorities of the loosers
    // ================================

    while(pCurrent)
    {
        AdjustPriorityForPassing(pCurrent);
        pCurrent = pCurrent->GetNext();
    }

    // Create a new thread, if required
    // ================================

    if(DoesNeedNewThread(pRequest))
        CreateNewThread();

    long lIndex = m_lNumRequests;
    cs.Leave();

    return WBEM_S_NO_ERROR;
}

DWORD CExecQueue::CalcSitOutPenalty(long lRequestIndex)
{
    if(lRequestIndex <= m_lStartSlowdownCount)
        return 0; // no penalty

    if(lRequestIndex > m_lAbsoluteLimitCount)
        lRequestIndex = ( m_lAbsoluteLimitCount -1 );

    // Calculate the timeout
    // =====================

    double dblTimeout =
        m_dblAlpha / (m_lAbsoluteLimitCount - lRequestIndex) +
            m_dblBeta;

    // Return penalty
    // ===========

    return ((DWORD) dblTimeout);
}

void CExecQueue::SitOutPenalty(long lRequestIndex)
{
    DWORD   dwSitOutPenalty = CalcSitOutPenalty( lRequestIndex );

    // Sleep on it
    // ===========

    if ( 0 != dwSitOutPenalty )
    {
        Sleep( dwSitOutPenalty );
    }
}


HRESULT CExecQueue::EnqueueAndWait(CExecRequest* pRequest)
{
    if(IsAppropriateThread())
    {
        pRequest->Execute();
        delete pRequest;
        return WBEM_S_NO_ERROR;
    }

    HANDLE hWhenDone;
    HRESULT hr = Enqueue(pRequest, &hWhenDone);
    CCloseMe    cmWhenDone( hWhenDone );
    
    if ( FAILED(hr) ) return hr;

    DWORD dwRes = WbemWaitForSingleObject(hWhenDone, INFINITE);
    return ( dwRes == WAIT_OBJECT_0 ? WBEM_S_NO_ERROR : WBEM_E_FAILED );
}


BOOL CExecQueue::DoesNeedNewThread(CExecRequest* pRequest)
{
    if(m_lNumIdle > 0 || m_lNumRequests == 0)
        return FALSE;

    if(m_lNumThreads < m_lMaxThreads)
        return TRUE;
    else if(pRequest->GetPriority() <= m_lHiPriBound &&
            m_lNumThreads < m_lHiPriMaxThreads)
        return TRUE;
    else
        return FALSE;
}

//******************************************************************************
//
//  See dbgalloc.h for documentation
//
//******************************************************************************
BOOL CExecQueue::Execute(CThreadRecord* pRecord)
{
    CExecRequest* pReq = pRecord->m_pCurrentRequest;

    HRESULT hres = pReq->Execute();


    if(hres == RPC_E_RETRY)
    {
        // The request has been postponed
        // ==============================

        DEBUGTRACE((LOG_WBEMCORE, "Thread %p postponed request %p\n",
                    pRecord, pReq));
    }
    else
    {
        if(hres != WBEM_NO_ERROR)
        {
            LogError(pReq, hres);
        }

        HANDLE hWhenDone = pReq->GetWhenDoneHandle();
        if(hWhenDone != NULL)
        {
            SetEvent(hWhenDone);
        }

        THREADDEBUGTRACE((LOG_WBEMCORE, "Thread %p done with request %p\n",
                        pRecord, pReq));
        delete pReq;
    }

    pRecord->m_pCurrentRequest = NULL;
    return TRUE;
}

//******************************************************************************
//
//  See dbgalloc.h for documentation
//
//******************************************************************************
void CExecQueue::LogError(CExecRequest* pRequest, int nRes)
{
    DEBUGTRACE((LOG_WBEMCORE,
        "Error %X occured executing queued request\n", nRes));
    pRequest->DumpError();
}

HRESULT CExecQueue::InitializeThread()
{
    return CoInitializeEx(0,COINIT_MULTITHREADED|COINIT_DISABLE_OLE1DDE);
}

void CExecQueue::UninitializeThread()
{
    CoUninitialize();
}


CExecRequest* CExecQueue::SearchForSuitableRequest(CThreadRecord* pRecord)
{
    // Assumes in critical section
    // ===========================

    CExecRequest* pCurrent = m_pHead;
    CExecRequest* pPrev = NULL;

    while(pCurrent)
    {
        if(IsSuitableThread(pRecord, pCurrent))
        {
            // Found one --- take it
            // =====================

            if(pPrev)
                pPrev->SetNext(pCurrent->GetNext());
            else
                m_pHead = pCurrent->GetNext();

            if(pCurrent == m_pTail)
                m_pTail = pPrev;

            m_lNumRequests--;
            break;
        }
        pPrev = pCurrent;
        pCurrent = pCurrent->GetNext();
    }

    return pCurrent;
}

//******************************************************************************
//
//  See dbgalloc.h for documentation
//
//******************************************************************************
void CExecQueue::ThreadMain(CThreadRecord* pRecord)
{
    CCritSecWrapper cs(&m_cs);

    if (FAILED(InitializeThread())) return;

    // Register this queue with this thread, so any further wait would be
    // interruptable
    // ==================================================================

    Register(pRecord);

    while (1)
    {
        // Returning from work. At this point, our event is not signaled,
        // our m_pCurrentRequest is NULL and our m_bReady is FALSE
        // ====================================================================

        // Search for work in the queue
        // ============================

        cs.Enter();

        CExecRequest* pCurrent = SearchForSuitableRequest(pRecord);
        if(pCurrent)
        {
            // Found some. Take it
            // ===================

            pRecord->m_pCurrentRequest = pCurrent;
        }
        else
        {
            // No work in the queue. Wait
            // ==========================

            pRecord->m_bReady = TRUE;
            m_lNumIdle++;
            DWORD dwTimeout = GetIdleTimeout(pRecord);
            cs.Leave();
            DWORD dwRes = WbemWaitForSingleObject(pRecord->m_hAttention,
                                        dwTimeout);
            cs.Enter();

            if(dwRes != WAIT_OBJECT_0)
            {
                // Check if someone managed to place a request in our record
                // after the timeout.
                // =========================================================

                if(WbemWaitForSingleObject(pRecord->m_hAttention, 0) ==
                    WAIT_OBJECT_0)
                {
                    DEBUGTRACE((LOG_WBEMCORE, "AMAZING: Thread %p received "
                        "request %p after timing out. Returning to the "
                        "queue\n", pRecord, pRecord->m_pCurrentRequest));

					if(pRecord->m_bExitNow || pRecord->m_pCurrentRequest == NULL)
					{
						ShutdownThread(pRecord);
						cs.Leave();
						return;
					}
                    pRecord->m_pQueue->Enqueue(pRecord->m_pCurrentRequest);
                    pRecord->m_pCurrentRequest = NULL;
                }

                // Timeout. See if it is time to quit
                // ==================================


                pRecord->m_bReady = FALSE;
                if(IsIdleTooLong(pRecord, dwTimeout))
                {
                    ShutdownThread(pRecord);
                    cs.Leave();
                    return;
                }

                // Go and wait a little more
                // =========================

                m_lNumIdle--;
                cs.Leave();
                continue;
            }
            else
            {
                // Check why we were awaken
                // ========================

                if(pRecord->m_bExitNow || pRecord->m_pCurrentRequest == NULL)
                {
                    ShutdownThread(pRecord);
                    cs.Leave();
                    return;
                }

                // We have a request. Enqueue already adjusted lNumIdle and
                // our m_bReady;
            }
        }

        // Execute the request
        // ===================
        cs.Leave();
        Execute(pRecord);

    }
}

DWORD CExecQueue::GetIdleTimeout(CThreadRecord* pRecord)
{
    if(m_lNumThreads > m_lMaxThreads)
        return m_dwOverflowTimeout;
    else
        return m_dwTimeout;
}

BOOL CExecQueue::IsIdleTooLong(CThreadRecord* pRecord, DWORD dwTimeout)
{
    if(m_lNumThreads > m_lMaxThreads)
        return TRUE;
    else if(dwTimeout < m_dwTimeout)
        return FALSE;
    else
        return TRUE;
}

void CExecQueue::ShutdownThread(CThreadRecord* pRecord)
{
    CCritSecWrapper cs(&m_cs);

    cs.Enter();
    TlsSetValue(mstatic_dwTlsIndex, NULL);
    for(int i = 0; i < m_aThreads.Size(); i++)
    {
        if(m_aThreads[i] == pRecord)
        {
            m_aThreads.RemoveAt(i);

            // Make sure we don't close the handle if the queue's Shutdown is
            // waiting on it
            // ==============================================================

            if(pRecord->m_bExitNow)
                pRecord->m_hThread = NULL;
            delete pRecord;
            m_lNumIdle--;
            m_lNumThreads--;

            break;
        }
    }
    UninitializeThread();
    cs.Leave();
}

//******************************************************************************
//
//  See dbgalloc.h for documentation
//
//******************************************************************************
// static
DWORD WINAPI CExecQueue::_ThreadEntry(LPVOID pObj)
{
    CThreadRecord* pRecord = (CThreadRecord*)pObj;
    pRecord->m_pQueue->ThreadMain(pRecord);
    return 0;
}

//******************************************************************************
//
//  See dbgalloc.h for documentation
//
//******************************************************************************
BOOL CExecQueue::CreateNewThread()
{
    BOOL            bRet = FALSE;
    try 
    {
	    CInCritSec ics(&m_cs);

	    // Create new thread record
	    // ========================

	    wmilib::auto_ptr<CThreadRecord> pNewRecord( new CThreadRecord(this));
	    if (NULL == pNewRecord.get()) return FALSE;

        if (CFlexArray::no_error != m_aThreads.Add(pNewRecord.get())) return FALSE;

        DWORD dwId;
        pNewRecord->m_hThread = CreateThread(0, 0, _ThreadEntry, pNewRecord.get(), 0,&dwId);

        if( NULL == pNewRecord->m_hThread )
        {
            m_aThreads.RemoveAt(m_aThreads.Size()-1);
            return FALSE;
        }
        
        pNewRecord.release(); // array took ownership
        m_lNumThreads++;
        bRet = TRUE;
    }
    catch (CX_Exception &)
    {
        bRet = FALSE;
    }
    return bRet;
}

DWORD CompensateForBug(DWORD dwOriginal, DWORD dwElapsed)
{
    if(dwOriginal == 0xFFFFFFFF)
        return 0xFFFFFFFF;

    DWORD dwLeft = dwOriginal - dwElapsed;
    if(dwLeft > 0x7FFFFFFF)
        dwLeft = 0x7FFFFFFF;

    return dwLeft;
}

DWORD CExecQueue::WaitForSingleObjectWhileBusy(HANDLE hHandle, DWORD dwWait,
                                                CThreadRecord* pRecord)
{
    CCritSecWrapper cs(&m_cs);

    CExecRequest* pOld = pRecord->m_pCurrentRequest;
    DWORD dwStart = GetTickCount();
    while (dwWait > GetTickCount() - dwStart)
    {
        // Search for work in the queue
        // ============================

        cs.Enter();
        CExecRequest* pCurrent = SearchForSuitableRequest(pRecord);
        if(pCurrent != NULL)
        {
            pRecord->m_pCurrentRequest = pCurrent;

            if(pRecord->m_pCurrentRequest == pOld)
            {
                // Something is very wrong
                // =======================
            }
        }
        else
        {
            // No work in the queue. Wait
            // ==========================

            pRecord->m_bReady = TRUE;

            // Block until a request comes through.
            // ====================================

            HANDLE ahSems[2];
            ahSems[0] = hHandle;
            ahSems[1] = pRecord->m_hAttention;

            cs.Leave();
            DWORD dwLeft = CompensateForBug(dwWait, (GetTickCount() - dwStart));
            DWORD dwRes = WbemWaitForMultipleObjects(2, ahSems, dwLeft);

            cs.Enter();

            pRecord->m_bReady = FALSE;
            if(dwRes != WAIT_OBJECT_0 + 1)
            {
                // Either our target handle is ready or we timed out
                // =================================================

                // Check if anyone placed a request in our record
                // ==============================================

                if(pRecord->m_pCurrentRequest != pOld)
                {
                    // Re-issue it to the queue
                    // ========================

                    pRecord->m_pQueue->Enqueue(pRecord->m_pCurrentRequest);
                    pRecord->m_pCurrentRequest = pOld;

                    // Decrement our semaphore
                    // =======================

                    dwRes = WaitForSingleObject(pRecord->m_hAttention, 0);
                    if(dwRes != WAIT_OBJECT_0)
                    {
                        // Internal error --- whoever placed the request had
                        // to have upped the semaphore
                        // =================================================

                        ERRORTRACE((LOG_WBEMCORE, "Internal error: queue "
                            "semaphore is too low\n"));
                    }
                }

                cs.Leave();
                return dwRes;
            }
            else
            {
                // Check why we were awaken
                // ========================

                if(pRecord->m_bExitNow || pRecord->m_pCurrentRequest == NULL)
                {
                    // Can't exit in the middle of a request. Leave it for later
                    // =========================================================

                    pRecord->Signal();
                    cs.Leave();
                    DWORD dwLeft2 = CompensateForBug(dwWait,
                                        (GetTickCount() - dwStart));
                    return WbemWaitForSingleObject(hHandle, dwLeft2);
                }

                // We've got work to do
                // ====================

                if(pRecord->m_pCurrentRequest == pOld)
                {
                    // Something is very wrong
                    // =======================
                }
            }
        }

        // Execute the request
        // ===================

        cs.Leave();
        Execute(pRecord);
        pRecord->m_pCurrentRequest = pOld;

    }
    return WAIT_TIMEOUT;
}

DWORD CExecQueue::UnblockedWaitForSingleObject(HANDLE hHandle, DWORD dwWait,
                                                CThreadRecord* pRecord)
{
    CCritSecWrapper cs(&m_cs);

    // Silently bump the max threads count.  We will not allow the queue to reuse
    // this thread, so we need to account for this missing thread while we
    // are blocked.  Essentially, we are hijacking the code that was hijacking
    // the thread

    cs.Enter();
        m_lMaxThreads++;
        m_lHiPriMaxThreads++;
    cs.Leave();

    DWORD   dwRet = WbemWaitForSingleObject( hHandle, dwWait );

    // The thread is back, so bump down the max threads number.  If extra threads were in
    // fact created, they should eventually peter out and go away.
    cs.Enter();
        m_lMaxThreads--;
        m_lHiPriMaxThreads--;
    cs.Leave();

    return dwRet;
}

//******************************************************************************
//
//  See dbgalloc.h for documentation
//
//******************************************************************************
// static
DWORD CExecQueue::QueueWaitForSingleObject(HANDLE hHandle, DWORD dwWait)
{
    InitTls();

    // Get the queue that is registered for this thread, if any
    // ========================================================

    CThreadRecord* pRecord = (CThreadRecord*)TlsGetValue(mstatic_dwTlsIndex);

    if(pRecord == NULL)
    {
        // No queue is registered with this thread. Just wait
        // ==================================================

        return WbemWaitForSingleObject(hHandle, dwWait);
    }

    CExecQueue* pQueue = pRecord->m_pQueue;

    return pQueue->WaitForSingleObjectWhileBusy(hHandle, dwWait, pRecord);
}

// static
DWORD CExecQueue::QueueUnblockedWaitForSingleObject(HANDLE hHandle, DWORD dwWait)
{
    InitTls();

    // Get the queue that is registered for this thread, if any
    // ========================================================

    CThreadRecord* pRecord = (CThreadRecord*)TlsGetValue(mstatic_dwTlsIndex);

    if(pRecord == NULL)
    {
        // No queue is registered with this thread. Just wait
        // ==================================================

        return WbemWaitForSingleObject(hHandle, dwWait);
    }

    CExecQueue* pQueue = pRecord->m_pQueue;

    return pQueue->UnblockedWaitForSingleObject(hHandle, dwWait, pRecord);
}

void CExecQueue::SetThreadLimits(long lMaxThreads, long lHiPriMaxThreads,
                                    long lHiPriBound)
{
    m_lMaxThreads = lMaxThreads;
    if(lHiPriMaxThreads == -1)
        m_lHiPriMaxThreads = lMaxThreads * 1.1;
    else
        m_lHiPriMaxThreads = lHiPriMaxThreads;
    m_lHiPriBound = lHiPriBound;

    while(DoesNeedNewThread(NULL))
        CreateNewThread();
}

BOOL CExecQueue::IsAppropriateThread()
{
    // Get the queue that is registered for this thread, if any
    // ========================================================

    CThreadRecord* pRecord = (CThreadRecord*)TlsGetValue(mstatic_dwTlsIndex);

    if(pRecord == NULL)
        return FALSE;

    CExecQueue* pQueue = pRecord->m_pQueue;
    if(pQueue != this)
        return FALSE;

    return TRUE;
}

BOOL CExecQueue::IsSTAThread()
{
    // Get the queue that is registered for this thread, if any
    // ========================================================

    CThreadRecord* pRecord = (CThreadRecord*)TlsGetValue(mstatic_dwTlsIndex);

    if(pRecord == NULL) return FALSE;

    return pRecord->m_pQueue->IsSTA();
}

void CExecQueue::SetRequestLimits(long lAbsoluteLimitCount,
                              long lStartSlowdownCount,
                              long lOneSecondDelayCount)
{
    CCritSecWrapper cs(&m_cs);

    cs.Enter();

    m_lAbsoluteLimitCount = lAbsoluteLimitCount;

    m_lStartSlowdownCount = lStartSlowdownCount;
    if(m_lStartSlowdownCount < 0)
    {
        m_lStartSlowdownCount = m_lAbsoluteLimitCount / 2;
    }

    m_lOneSecondDelayCount = lOneSecondDelayCount;

    if(m_lOneSecondDelayCount < 0)
    {
        m_lOneSecondDelayCount =
            m_lAbsoluteLimitCount * 0.2 + m_lStartSlowdownCount * 0.8;
    }

    // Calculate coefficients
    // ======================

    m_dblBeta =
        1000 *
        ((double)m_lAbsoluteLimitCount - (double)m_lOneSecondDelayCount) /
        ((double)m_lStartSlowdownCount - (double)m_lOneSecondDelayCount);

    m_dblAlpha = m_dblBeta *
        ((double)m_lStartSlowdownCount - (double)m_lAbsoluteLimitCount);
    cs.Leave();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\winmgmt\wbemcomn\flexarry.cpp ===
/*++

Copyright (C) 1996-2001 Microsoft Corporation

Module Name:

    FLEXARRAY.CPP

Abstract:

  CFlexArray and CWStringArray implementation.

  These objects can operate from any allocator, and be constructed
  on arbitrary memory blocks.

History:

  11-Apr-96   a-raymcc    Created.
  24-Apr-96   a-raymcc    Updated for CArena support.

--*/

#include "precomp.h"
#include <stdio.h>
#include <flexarry.h>
#include <corex.h>
#include "strutils.h"
#include <statsync.h>

#define DUP_STRING_ARENA(dest,src) \
	{ size_t tmpLenDoNotReuse = wcslen(src)+1; \
	  dest = (wchar_t*)CWin32DefaultArena::WbemMemAlloc(tmpLenDoNotReuse * 2); \
	  if (dest) StringCchCopyW(dest,tmpLenDoNotReuse , src); } 


//***************************************************************************
//
//  CFlexArray::CFlexArray
//
//  Constructs the array.
//
//  Parameters:
//  <nSize>         The starting preallocated size of the array.
//  <nGrowBy>       The amount to grow by when the array fills up.
//
//  Size() returns the number of elements in use, not the 'true' size.
//
//***************************************************************************
// ok

CFlexArray::CFlexArray(
    int nSize, 
    int nGrowByPercent
    )
{
    m_nExtent = nSize;
    m_nSize = 0;
    m_nGrowByPercent = nGrowByPercent;
    if(nSize > 0)
    {
        m_pArray = 
            (void**)CWin32DefaultArena::WbemMemAlloc(sizeof(void *) * nSize);

        // Check for allocation failures
        if ( NULL == m_pArray )
        {
            m_nExtent = 0;
            throw CX_MemoryException();
        }
    }
    else
        m_pArray = NULL;
}
    
//***************************************************************************
//
//  CFlexArray::~CFlexArray
//
//***************************************************************************
// ok
CFlexArray::~CFlexArray()
{
    CWin32DefaultArena::WbemMemFree(m_pArray);
}


//***************************************************************************
//
//  Copy constructor.
//  
//  Copies the pointers, not their contents.
//
//***************************************************************************
// ok

CFlexArray::CFlexArray(CFlexArray &Src)
{
    m_pArray = 0;
    m_nSize = 0;
    m_nExtent = 0;
    m_nGrowByPercent = 0;

    *this = Src;
}

//***************************************************************************
//
//  operator =
//
//  Assignment operator.
//
//  Arenas are not copied.  This allows transfer of arrays between arenas.
//  Arrays are copied by pointer only.
//
//***************************************************************************
// ok

CFlexArray& CFlexArray::operator=(CFlexArray &Src)
{
    m_nSize   = Src.m_nSize;
    m_nExtent = Src.m_nExtent;
    m_nGrowByPercent = Src.m_nGrowByPercent;

    CWin32DefaultArena::WbemMemFree(m_pArray);
    if(m_nExtent > 0)
    {
        m_pArray = 
           (void**)CWin32DefaultArena::WbemMemAlloc(sizeof(void *) * m_nExtent);

        // Check for allocation failures
        if ( NULL == m_pArray )
        {
            m_nExtent = m_nSize = 0;
            throw CX_MemoryException();
        }

    }
    else
        m_pArray = NULL;
    memcpy(m_pArray, Src.m_pArray, sizeof(void *) * m_nSize);
        
    return *this;    
}

//***************************************************************************
//
//  CFlexArray::RemoveAt
//
//  Removes the element at the specified location.  Does not
//  actually delete the pointer. Shrinks the array over the top of
//  the 'doomed' element.
//
//  Parameters:
//  <nIndex>    The location of the element.
//    
//  Return value:
//  range_error     The index is not legal.
//  no_error        Success.
//  
//***************************************************************************
// ok

int CFlexArray::RemoveAt(int nIndex)
{
    if (nIndex >= m_nSize)
        return range_error;

    // Account for the index being 0 based and size being 1 based
    MoveMemory( &m_pArray[nIndex], &m_pArray[nIndex+1], ( ( m_nSize - nIndex ) - 1 ) * sizeof(void *) );
    
    m_nSize--;
    m_pArray[m_nSize] = 0;

    return no_error;
}

int CFlexArray::EnsureExtent(int nExtent)
{
    if(m_nExtent < nExtent)
    {
        if(m_pArray)
        {
            register void** pTmp = (void **) CWin32DefaultArena::WbemMemReAlloc(m_pArray, sizeof(void *) * nExtent);
            if (pTmp == 0)
                return out_of_memory;
            m_nExtent = nExtent;
            m_pArray =  pTmp;
        }
        else
        {
            m_pArray = (void **) CWin32DefaultArena::WbemMemAlloc(sizeof(void *) * nExtent);    
            if (!m_pArray)
            {
                m_nExtent = 0;
                return out_of_memory;                
            }
            m_nExtent = nExtent;
        }
    }

    return no_error;
}
        
    
//***************************************************************************
//
//  CFlexArray::InsertAt
//
//  Inserts a new element at the specified location.  The pointer is copied.
//
//  Parameters:
//  <nIndex>        The 0-origin location at which to insert the new element.
//  <pSrc>          The pointer to copy. (contents are not copied).
//
//  Return value:
//  array_full
//  out_of_memory
//  no_error
//
//***************************************************************************
// ok

int CFlexArray::InsertAt(int nIndex, void *pSrc)
{
    // TEMP: fix for sparse functionality in stdprov
    // =============================================

    while(nIndex > m_nSize)
        Add(NULL);

    // If the array is full, we need to expand it.
    // ===========================================
    
    if (m_nSize == m_nExtent) {
        if (m_nGrowByPercent == 0)
            return array_full;
        register nTmpExtent = m_nExtent;
        m_nExtent += 1;
        m_nExtent *= (100 + m_nGrowByPercent);
        m_nExtent /= 100;

        if(m_pArray)
        {
            register void** pTmp = (void **) CWin32DefaultArena::WbemMemReAlloc(m_pArray, sizeof(void *) * m_nExtent);
            if (pTmp == 0)
            {
                m_nExtent = nTmpExtent; //Change it back, otherwise the extent could constantly grow even though  it keeps failing...
                return out_of_memory;
            }
            m_pArray =  pTmp;
        }
        else
        {
            m_pArray = (void **) CWin32DefaultArena::WbemMemAlloc(sizeof(void *) * m_nExtent);    

            if (!m_pArray)
            {
                m_nExtent = 0;
                return out_of_memory;                
            }
        }
    }

    // Special case of appending.  This is so frequent
    // compared to true insertion that we want to optimize.
    // ====================================================
    
    if (nIndex == m_nSize) {
        m_pArray[m_nSize++] = pSrc;
        return no_error;
    }
    
    // If here, we are inserting at some random location.
    // We start at the end of the array and copy all the elements 
    // one position farther to the end to make a 'hole' for
    // the new element.
    // ==========================================================

    // Account for nIndex being 0 based and m_nSize being 1 based
    MoveMemory( &m_pArray[nIndex+1], &m_pArray[nIndex], ( m_nSize - nIndex ) * sizeof(void *) );

    m_pArray[nIndex] = pSrc;
    m_nSize++;
            
    return no_error;    
}

void CFlexArray::Sort()
{
    if(m_pArray)
        qsort((void*)m_pArray, m_nSize, sizeof(void*), CFlexArray::CompareEls);
}

int __cdecl CFlexArray::CompareEls(const void* pelem1, const void* pelem2)
{
    return *(int*)pelem1 - *(int*)pelem2;
}
//***************************************************************************
//
//  CFlexArray::DebugDump
//
//***************************************************************************
void CFlexArray::DebugDump()
{
    printf("----CFlexArray Debug Dump----\n");
    printf("m_pArray = 0x%p\n", m_pArray);
    printf("m_nSize = %d\n", m_nSize);
    printf("m_nExtent = %d\n", m_nExtent);
    printf("m_nGrowByPercent = %d\n", m_nGrowByPercent);

    for (int i = 0; i < m_nExtent; i++)
    {
        if (i < m_nSize)
            printf("![%d] = %p\n", i, m_pArray[i]);
        else
            printf("?[%d] = %p\n", i, m_pArray[i]);                    
    }        
}

//***************************************************************************
//
//  CFlexArray::Compress
//
//  Removes NULL elements by moving all non-NULL pointers to the beginning
//  of the array.  The array "Size" changes, but the extent is untouched.
//
//***************************************************************************
// ok

void CFlexArray::Compress()
{
    int nLeftCursor = 0, nRightCursor = 0;
    
    while (nLeftCursor < m_nSize - 1) {
        if (m_pArray[nLeftCursor]) {
            nLeftCursor++;
            continue;
        }
        else {
            nRightCursor = nLeftCursor + 1;
            while ( nRightCursor < m_nSize && m_pArray[nRightCursor] == 0 )
                nRightCursor++;
            if (nRightCursor == m_nSize)
                break;  // Short circuit, no more nonzero elements.
            m_pArray[nLeftCursor] = m_pArray[nRightCursor];
            m_pArray[nRightCursor] = 0;                                            
        }                    
    }
    
    Trim();
}    

void CFlexArray::Trim()
{
    while (m_nSize >  0 && m_pArray[m_nSize - 1] == NULL) m_nSize--;
}

//***************************************************************************
//
//  CFlexArray::Empty
//
//  Clears the array of all pointers (does not deallocate them) and sets
//  its apparent size to zero.
//
//***************************************************************************
// ok
void CFlexArray::Empty()
{
    CWin32DefaultArena::WbemMemFree(m_pArray);
    m_pArray = NULL;
    m_nSize = 0;
    m_nExtent = 0;
}

//***************************************************************************
//
//  CFlexArray::UnbindPtr
//
//  Empties the array and returns the pointer to the data it contained
//
//***************************************************************************

void** CFlexArray::UnbindPtr()
{
    void** pp = m_pArray;
    m_pArray = NULL;
    Empty();
    return pp;
}

//
// an empty CFlexArray will take ownership 
// of the memory of a second CFlexAray, empty-ing the source
//
///////////////////////////////////////////////////////////////////////
void CFlexArray::Bind(CFlexArray & Src)
{
    if (this == &Src) return;
    if (this->m_nSize > 0 || NULL != this->m_pArray) throw CX_Exception(); //cannot self delete hence invalid usage
    this->m_nSize = Src.m_nSize;
    Src.m_nSize = 0;
    this->m_nExtent = Src.m_nExtent;
    Src.m_nExtent = 0;
    this->m_pArray = Src.m_pArray;
    Src.m_pArray = NULL;
}

//***************************************************************************
//
//  CFlexArray::CopyData
//
//  Copies the data but not the settings of another flexarray
//
//***************************************************************************

int CFlexArray::CopyDataFrom(const CFlexArray& aOther)
{
    // Check if there is enough room
    // =============================

    if(aOther.m_nSize > m_nExtent)
    {
        // Extend the array to the requisite size
        // ======================================

        if(m_pArray)
        {
            register void** pTmp = (void **) CWin32DefaultArena::WbemMemReAlloc(m_pArray, sizeof(void *) * aOther.m_nSize);
            if (pTmp == 0)
                return out_of_memory;
            m_pArray =  pTmp;
            m_nExtent = aOther.m_nSize;
            
        }
        else
        {
            m_pArray = (void **) CWin32DefaultArena::WbemMemAlloc(sizeof(void *) * aOther.m_nSize);    
            if (!m_pArray)
            {
                m_nExtent = 0;
                return out_of_memory;                
            }
            m_nExtent = aOther.m_nSize;
        }
    }

    // Copy the data
    // =============

    m_nSize = aOther.m_nSize;
    memcpy(m_pArray, aOther.m_pArray, sizeof(void*) * m_nSize);
    return no_error;
}

//***************************************************************************
//
//  CWStringArray::CWStringArray
//
//  Constructs a wide-string array.
//
//  Parameters:
//  <nSize>         The starting preallocated size of the array.
//  <nGrowBy>       The amount to grow by when the array fills up.
//
//  Size() returns the number of elements in use, not the 'true' size.
//
//***************************************************************************

CWStringArray::CWStringArray(
        int nSize, 
        int nGrowBy
        )
        : 
        m_Array(nSize, nGrowBy)
{
}        

//***************************************************************************
//
//  Copy constructor.
//
//***************************************************************************

CWStringArray::CWStringArray(CWStringArray &Src)
{
    
    *this = Src;    
}

//***************************************************************************
//
//  Destructor.  Cleans up all the strings.
//
//***************************************************************************

CWStringArray::~CWStringArray()
{
    Empty();
}

//***************************************************************************
//
//  CWStringArray::DeleteStr
//
//  Frees the string at the specified index and sets the element to NULL.  
//  Does not compress array.
// 
//  Does not currently do a range check.
//
//  Parameters:
//  <nIndex>    The 0-origin index of the string to remove.
//
//  Return values:
//  no_error
//  
//***************************************************************************

int CWStringArray::DeleteStr(int nIndex)
{
    CWin32DefaultArena::WbemMemFree(m_Array[nIndex]);
    m_Array[nIndex] = 0;
    return no_error;
}   

//***************************************************************************
//
//  CWStringArray::FindStr
//
//  Finds the specified string and returns its location.
//
//  Parameters:
//  <pTarget>       The string to find.
//  <nFlags>        <no_case> or <with_case>
//  
//  Return value:
//  The 0-origin location of the string, or -1 if not found.
//
//***************************************************************************

int CWStringArray::FindStr(const wchar_t *pTarget, int nFlags)
{
    if (nFlags == no_case) {
        for (int i = 0; i < m_Array.Size(); i++)
            if (wbem_wcsicmp((wchar_t *) m_Array[i], pTarget) == 0)
                return i;
    }
    else {
        for (int i = 0; i < m_Array.Size(); i++)
            if (wcscmp((wchar_t *) m_Array[i], pTarget) == 0)
                return i;
    }
    return not_found;
}

//***************************************************************************
//
//  operator =
//  
//***************************************************************************

//  Heap handle & allocation functions are not copied. This allows
//  transfer of arrays between heaps.
         
CWStringArray& CWStringArray::operator =(CWStringArray &Src)
{
    Empty();
    
    for (int i = 0; i < Src.Size(); i++) 
    {
        wchar_t *pSrc = (wchar_t *) Src.m_Array[i];
        wchar_t *pCopy;
	DUP_STRING_ARENA(pCopy, pSrc);

        if ( !pCopy || m_Array.Add(pCopy) != CFlexArray::no_error )
        {
            throw CX_MemoryException();
        }
    }

    return *this;
}

//***************************************************************************
//
//  CWStringArray::Add
//
//  Appends a new string to the end of the array.
//
//  Parameters:
//  <pSrc>      The string to copy.
//
//  Return value:
//  The return values of CFlexArray::Add.
//  
//***************************************************************************
    
int CWStringArray::Add(const wchar_t *pSrc)
{
    wchar_t *pNewStr;
    DUP_STRING_ARENA(pNewStr, pSrc);

    // Check for allocation failures
    if ( NULL == pNewStr )
    {
        return out_of_memory;
    }

    return m_Array.Add(pNewStr);
}
//***************************************************************************
//
//  CWStringArray::InsertAt
//
//  Inserts a copy of a string in the array.
//
//  Parameters:
//  <nIndex>    The 0-origin location at which to insert the string.
//  <pSrc>      The string to copy.
//
//  Return values:
//  The return values of CFlexArray::InsertAt
//
//***************************************************************************

int CWStringArray::InsertAt(int nIndex, const wchar_t *pSrc)
{
    wchar_t *pNewStr;
    DUP_STRING_ARENA(pNewStr, pSrc);

    // Check for allocation failures
    if ( NULL == pNewStr )
    {
        return out_of_memory;
    }

    int iRet = m_Array.InsertAt(nIndex, pNewStr);

    if (iRet == array_full)
        CWin32DefaultArena::WbemMemFree(pNewStr);        

    return iRet;
}


//***************************************************************************
//
//  CWStringArray::RemoveAt
//
//  Removes and deallocates the string at the specified location.
//  Shrinks the array.
//
//  Parameters:
//  <nIndex>    The 0-origin index of the 'doomed' string.
//  
//  Return value:
//  Same as CFlexArray::RemoveAt.
//
//***************************************************************************

int CWStringArray::RemoveAt(int nIndex)
{
    wchar_t *pDoomedString = (wchar_t *) m_Array[nIndex];
    CWin32DefaultArena::WbemMemFree(pDoomedString);
    return m_Array.RemoveAt(nIndex);
}

//***************************************************************************
//
//  CWStringArray::SetAt
//
//  Replaces the string at the targeted location with the new one.
//  The old string at the location is cleaned up.
//
//  No range checking or out-of-memory checks at present.
//
//  Parameters:
//  <nIndex>        The 0-origin location at which to replace the string.
//  <pSrc>          The string to copy.  
//
//  Return value:
//  no_error
//   
//***************************************************************************

int CWStringArray::SetAt(int nIndex, const wchar_t *pSrc)
{
    wchar_t *pNewStr;
    DUP_STRING_ARENA(pNewStr, pSrc);

    // Check for allocation failures
    if ( NULL == pNewStr )
    {
        return out_of_memory;
    }

    wchar_t *pDoomedString = (wchar_t *) m_Array[nIndex];
    if (pDoomedString)
        CWin32DefaultArena::WbemMemFree(pDoomedString);

    m_Array[nIndex] = pNewStr;

    return no_error;
}

//***************************************************************************
//
//  CWStringArray::ReplaceAt
//
//  Directly replaces the pointer at the specified location with the
//  one in the parameter.   No copy or cleanup.
//
//  Parameters:
//  <nIndex>     The 0-origin location at which to replace.
//  <pSrc>       The new pointer to copy over the old one.
//
//  Return value:
//  no_error        (No checking done at present).
//  
//***************************************************************************

int CWStringArray::ReplaceAt(int nIndex, wchar_t *pSrc)
{
    m_Array[nIndex] = pSrc;
    return no_error;
}



//***************************************************************************
//
//  CWStringArray::Empty
//
//  Empties the array, deallocates all strings, and sets the apparent
//  array size to zero.
//
//***************************************************************************

void CWStringArray::Empty()
{
    for (int i = 0; i < m_Array.Size(); i++)
        CWin32DefaultArena::WbemMemFree(m_Array[i]);
    m_Array.Empty();        
}

//***************************************************************************
//
//  CWStringArray::Sort
//
//  Sorts the array according to UNICODE order.  
//  (Shell sort).
//
//***************************************************************************
void CWStringArray::Sort()
{
    for (int nInterval = 1; nInterval < m_Array.Size() / 9; nInterval = nInterval * 3 + 1);    

    while (nInterval) 
    {
        for (int iCursor = nInterval; iCursor < m_Array.Size(); iCursor++) 
        {
            int iBackscan = iCursor;
            while (iBackscan - nInterval >= 0 &&
               wbem_wcsicmp((const wchar_t *) m_Array[iBackscan],
                    (const wchar_t *) m_Array[iBackscan-nInterval]) < 0) 
            {
                wchar_t *pTemp = (wchar_t *) m_Array[iBackscan - nInterval];
                m_Array[iBackscan - nInterval] = m_Array[iBackscan];
                m_Array[iBackscan] = pTemp;
                iBackscan -= nInterval;
            }
        }
        nInterval /= 3;
    }
}


//***************************************************************************
//
//  CWStringArray::Difference
//
//  Set-theoretic difference operation on the arrays.
//  
//  Parameters:
//  <Src1>      First array (not modified).
//  <Src2>      Second array which is 'subtracted' from first (not modified).    
//  <Diff>      Receives the difference.  Should be an empty array on entry.
//
//***************************************************************************
void CWStringArray::Difference(
    CWStringArray &Src1, 
    CWStringArray &Src2,
    CWStringArray &Diff
    )
{
    for (int i = 0; i < Src1.Size(); i++)
    {
        if (Src2.FindStr(Src1[i], no_case) == -1)
        {
            if ( Diff.Add(Src1[i]) != no_error )
            {
                throw CX_MemoryException();
            }
        }
    }
}

//***************************************************************************
//
//  CWStringArray::Intersection
//
//  Set-theoretic intersection operation on the arrays.
//  
//  Parameters:
//  <Src1>      First array (not modified).
//  <Src2>      Second array (not modified).    
//  <Diff>      Receives the intersection.  Should be an empty array on entry.

//***************************************************************************

void CWStringArray::Intersection(
    CWStringArray &Src1,
    CWStringArray &Src2,
    CWStringArray &Output
    )
{
    for (int i = 0; i < Src1.Size(); i++)
    {
        if (Src2.FindStr(Src1[i], no_case) != -1)
        {
            if ( Output.Add(Src1[i]) != no_error )
            {
                throw CX_MemoryException();
            }
        }

    }
}    

//***************************************************************************
//
//  CWStringArray::Union
//
//  Set-theoretic union operation on the arrays.
//  
//  Parameters:
//  <Src1>      First array (not modified).
//  <Src2>      Second array (not modified).    
//  <Diff>      Receives the union.  Should be an empty array on entry.
//
//***************************************************************************

void CWStringArray::Union(
    CWStringArray &Src1,
    CWStringArray &Src2,
    CWStringArray &Output
    )
{
    Output = Src1;
    for (int i = 0; i < Src2.Size(); i++)
    {
        if (Output.FindStr(Src2[i], no_case) == not_found)
        {
            if ( Output.Add(Src2[i]) != no_error )
            {
                throw CX_MemoryException();
            }
        }
    }
}

//
// that's the fee to pay to have template __dllexport()-ed 
//
void LinkerPleaseRemoveMe()
{
    CLockableFlexArray<CStaticCritSec> a;
    a.Lock();
    a.Unlock();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\winmgmt\wbemcomn\execq.h ===
/*++

Copyright (C) 1996-2001 Microsoft Corporation

Module Name:

    EXECQ.H

Abstract:

  Defines classes related to execution queues.

  Classes defined:

      CExecRequest    An abstract request.
      CExecQueue      A queue of requests with an associated thread

History:

      23-Jul-96   a-raymcc    Created.
      3/10/97     a-levn      Fully documented
      9/6/97      a-levn      Rewrote for thread pool

--*/

#ifndef __EXECQUEUE__H_
#define __EXECQUEUE__H_

#include "sync.h"
#include "wbemutil.h"

#ifdef __COLLECT_ALLOC_STAT
   #include "stackcom.h"
#endif
//******************************************************************************
//******************************************************************************
//
//  class CExecRequest
//
//  Abstract base class for any schedulable request
//
//******************************************************************************
//
//  Execute
//
//  Primary method. Executes the request, whatever that means. 
//
//  Returns:
//
//      int:    return code. 0 means success, everything else --- failure.
//              Exact error codes are request-specific.
//
//******************************************************************************

class POLARITY CExecRequest
{
protected:

    HANDLE m_hWhenDone;
    CExecRequest* m_pNext;
    long m_lPriority;
	bool	m_fOk;


public:
    void SetWhenDoneHandle(HANDLE h) {m_hWhenDone = h;}
    HANDLE GetWhenDoneHandle() {return m_hWhenDone;}
    void SetNext(CExecRequest* pNext) {m_pNext = pNext;}
    CExecRequest* GetNext() {return m_pNext;}
    void SetPriority(long lPriority) {m_lPriority = lPriority;}
    long GetPriority() {return m_lPriority;}
    virtual void DumpError(){   DEBUGTRACE((LOG_WBEMCORE,
        "No additional info\n"));};
	bool IsOk( void ) { return m_fOk; }

public:
    CExecRequest();
    virtual ~CExecRequest();
    virtual HRESULT Execute() = 0;
};


//******************************************************************************
//******************************************************************************
//
//  class CExecQueue
//
//  CExecQueue represents the concept of a queue of requests with an associated
//  thread to execute those requests. In a lot of respects, it is similar to
//  a message queue. Requests are added to the queue (which is represented by
//  an array) and the thread (created by the Run function) picks them up one
//  by one and executes them.
//
//  The trick is what to do if while processing one request, another one
//  is generated and needs to be processed before the first one succeeds. This
//  is similar to a SendMessage, but trickier: the thread generating the new
//  request may not be the thread attached to the queue!
//
//  To overcome this problem, we make all our waits interruptible in the
//  following sense. Whenever the thread attached to the queue needs to block
//  waiting for something to happen (which is when another thread may post a 
//  new request and deadlock the system), it uses QueueWaitForSingleObject
//  instead. This function will wait for the object that the thread wanted to
//  wait for but it will also wake up if a new Critical request is added to 
//  the queue and process any such request while waiting.
//
//  See QueueWaitForSingleObject for details.
//
//  Operations of CExecQueue are protected by a critical section, so multiple
//  threads can add requests simultaneously.
//
//******************************************************************************
//
//  Constructor
//
//  Creates and initializes all the synchronization objects, as well as the
//  thread local storage required by QueueWaitForSingleObject.
//
//******************************************************************************
//
//  Destructor
//
//  Deletes synchronization objects.
//
//******************************************************************************
//
//  virtual Enqueue
//
//  Adds a request to the queue. The acction depends on whether the request is
//  critical or not.  If not, it is added to the queue and the semaphor of
//  non-critical requests is incremented. The processing thread will pick it up
//  in FIFO order. If critical, request is added to the front of the queye and
//  the semaphor of critical requests is incremented. This will cause the
//  processing thread to take this request the next time it enters into a 
//  waiting state (see QueueWaitForSingleObject).
//
//******************************************************************************
//
//  QueueWaitForSingleObject
//
//  The core of the trick. In WINMGMT, whenever a thread needs to wait for an
//  object, it calls this function instead. This function checks if the calling
//  thread is the registered processing thread for any CExecQueue object (by
//  looking up the m_dwTlsIndex thread local variable for the thread). If it
//  is not, the function simply calls WaitForSingleObject.
//
//  If it is, the function queries the queue for the semaphore indicating the
//  number of critical requests on the queue. It then calls 
//  WaitForMultipleObjects with the original handle and the semaphore. If the
//  semaphore is signaled during the wait (or was singlaled when we came in),
//  this function picks up the first requests on the queue and executes it;
//  once that request is complete, it resumes the wait (with adjusted timeout).
//
//  Parameters:
//
//      HANDLE hHandle      The handle of synchronization object to wait for.
//      DWORD dwTimeout     Timeout in milliseconds.
//
//  Returns:
//
//      Same values as WaitForSingleObject:
//          WAIT_OBJECT_0   hHandle became signaled
//          WAIT_TIMEOUT    Timed out.
//
//******************************************************************************
//**************************** protected ***************************************
//
//  Register
//
//  Registers the calling thread as the processing thread of this queue by
//  storing the pointer to the queue in the m_dwTlsIndex thread local storage
//  variable. QueueWaitForSingleObject reads this index to interrupt waits 
//  when needed (see QueueWaitForSingleObject).
//
//  Returns:
//
//      CExecQueue*:    the previous CExecQueue this thread was registered for,
//                      or NULL if none. The caller MUST not delete this object.
//
//******************************************************************************
//
//  ThreadMain
//
//  This is the function that the thread created by Run executes.  It sits in
//  an infinite loop, retrieving requests and executing them one by one.
//  This function never returns.
//
//******************************************************************************
//
//  Dequeue
//
//  Retrieves the request at the head of the queue and removes it from the
//  queue.
//
//  Returns:
//
//      CExecRequest*:  the request that was at the head of the queue, or NULL
//                      if the queue was empty. The caller must delete this
//                      object when no longer needed.
//
//******************************************************************************
//
//  static _ThreadEntry
//
//  Stub function used to create the tread. Calls ThreadEntry on the real 
//  CExecQueue.
//
//  Parameters:
//
//      LPVOID pObj     Actually CExecQueue* to the queue this thread is 
//                      supposed to serve.
//
//  Returns:
//
//      never.
//
//******************************************************************************
//
//  static InitTls
//
//  Invoked only once during the life of the system (not the life of a queue),
//  creates a thread local storage location where the pointer to the queue is
//  stored for the attached threads (see Register and QueueWaitForSingleObject)
//  
//******************************************************************************
//
//  GetNormalReadyHandle
//
//  Returns the handle to the semaphore which contains the number of
//  non-critical requests currently on the queue.
//
//  Returns:
//
//      HANDLE: the the semaphore
//
//******************************************************************************
//
//  GetCriticalReadyHandle
//
//  Returns the handle to the semaphore which contains the number of
//  critical requests currently on the queue.
//
//  Returns:
//
//      HANDLE: the the semaphore
//
//******************************************************************************
//
//  Execute
//
//  Dequeues and executes a single request.
//
//******************************************************************************

    

class POLARITY CExecQueue
{
protected:
    class CThreadRecord
    {
    public:
        CExecQueue* m_pQueue;
        CExecRequest* m_pCurrentRequest;
        BOOL m_bReady;
        BOOL m_bExitNow;
        HANDLE m_hThread;
        HANDLE m_hAttention;
    
    public:
        CThreadRecord(CExecQueue* pQueue);
        ~CThreadRecord();
        void Signal();
    };

protected:
    static long mstatic_lNumInits;

    long m_lRef;
    CCritSec m_cs;

    CFlexArray m_aThreads;
    CExecRequest* m_pHead;
    CExecRequest* m_pTail;

    long m_lNumThreads;
    long m_lNumIdle;
    long m_lNumRequests;

    long m_lMaxThreads;
    long m_lHiPriBound;
    long m_lHiPriMaxThreads;

    long m_lStartSlowdownCount;
    long m_lAbsoluteLimitCount;
    long m_lOneSecondDelayCount;

    double m_dblAlpha;
    double m_dblBeta;

    DWORD m_dwTimeout;
    DWORD m_dwOverflowTimeout;

    BOOL m_bShutDonwCalled;


protected:    
    virtual void ThreadMain(CThreadRecord* pRecord);

    virtual void LogError(CExecRequest* pRequest, int nRes);

    static DWORD WINAPI _ThreadEntry(LPVOID pObj);
    static void InitTls();

    virtual HRESULT InitializeThread();
    virtual void UninitializeThread();
    virtual BOOL CreateNewThread();
    static void Register(CThreadRecord* pRecord);
    virtual void ShutdownThread(CThreadRecord* pRecord);

    virtual BOOL IsSuitableThread(CThreadRecord* pRecord, CExecRequest* pReq);
    virtual BOOL DoesNeedNewThread(CExecRequest* pReq);
    virtual BOOL IsIdleTooLong(CThreadRecord* pRecord, DWORD dwIdle);
    virtual DWORD GetIdleTimeout(CThreadRecord* pRecord);
    virtual BOOL IsAppropriateThread();
    virtual DWORD WaitForSingleObjectWhileBusy(HANDLE hHandle, DWORD dwWait,
                                                CThreadRecord* pRecord);

	virtual DWORD UnblockedWaitForSingleObject(HANDLE hHandle, DWORD dwWait,
                                                CThreadRecord* pRecord);

    virtual BOOL Execute(CThreadRecord* pRecord);
    virtual BOOL IsSTA() {return FALSE;}
    virtual CExecRequest* SearchForSuitableRequest(CThreadRecord* pRecord);
    virtual void SitOutPenalty(long lRequestIndex);
    virtual DWORD CalcSitOutPenalty(long lRequestIndex);

    virtual void AdjustInitialPriority(CExecRequest* pRequest){}
    virtual void AdjustPriorityForPassing(CExecRequest* pRequest){}
public:
    CExecQueue();
    ~CExecQueue();

    void AddRef() {InterlockedIncrement(&m_lRef);}
    void Release() {LONG lRet = InterlockedDecrement(&m_lRef); if(0 == lRet) delete this;}
    static DWORD GetTlsIndex();
    void Enter();
    void Leave();

    virtual HRESULT Enqueue(CExecRequest* pRequest, HANDLE* phWhenDone = NULL);
	HRESULT EnqueueWithoutSleep(CExecRequest* pRequest, HANDLE* phWhenDone = NULL );
    HRESULT EnqueueAndWait(CExecRequest* pRequest);

    virtual LPCWSTR GetType() {return L"";}

    void SetThreadLimits(long lMaxThreads, long lHiPriMaxThreads = -1,
                            long lHiPriBound = 0);
    void SetIdleTimeout(DWORD dwTimeout) {m_dwTimeout = dwTimeout;}
    void SetOverflowIdleTimeout(DWORD dwTimeout) 
        {m_dwOverflowTimeout = dwTimeout;}
    void SetRequestLimits(long lAbsoluteLimitCount, 
            long lStartSlowdownCount = -1, long lOneSecondDelayCount = -1);
    
    void Shutdown();

	DWORD GetSitoutPenalty( void ) { return CalcSitOutPenalty( m_lNumRequests ); }

    static DWORD QueueWaitForSingleObject(HANDLE hHandle, DWORD dwWait);
    static DWORD QueueUnblockedWaitForSingleObject(HANDLE hHandle, DWORD dwWait);
    static BOOL IsSTAThread();
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\winmgmt\wbemcomn\flexarry.h ===
/*++

Copyright (C) 1996-2001 Microsoft Corporation

Module Name:

    FLEXARRAY.H

Abstract:

  CFlexArray and CWStringArray implementation.

  These objects can operate from any allocator, and be constructed
  on arbitrary memory blocks.

History:

  11-Apr-96   a-raymcc    Created.

--*/

#ifndef _FLEXARRY_H_
#define _FLEXARRY_H_

#include "corepol.h"

#include <arena.h>
#include <sync.h>

//***************************************************************************
//
//  class CFlexArray
//
//  This class is a generic pointer array.
//
//***************************************************************************

class POLARITY CFlexArray
{
protected:
    int m_nSize;            // apparent size
    int m_nExtent;          // de facto size
    int m_nGrowByPercent;          
    void** m_pArray;
            
public:
    enum { no_error, failed, out_of_memory, array_full, range_error };

    // Constructs a flex array at an initial size and
    // specifies the initial size and growth-size chunk.
    // =================================================
    CFlexArray(
        IN int nInitialSize = 0, 
        IN int nGrowByPercent = 100
        );

   ~CFlexArray(); 
    CFlexArray(CFlexArray &);
    CFlexArray& operator=(CFlexArray &);

    int CopyDataFrom(const CFlexArray& aOther);
    int EnsureExtent(int nExtent);

    // Gets an element at a particular location.
    // =========================================
    inline void *  GetAt(int nIndex) const { return m_pArray[nIndex]; }

    // Returns a ptr in the array; allows use on left-hand side of assignment.
    // =======================================================================
    inline void * operator[](int nIndex) const { return m_pArray[nIndex]; }
    inline void *& operator[](int nIndex) { return m_pArray[nIndex]; }

    // Sets the element at the requested location.
    // ===========================================
    void inline SetAt(int nIndex, void *p) { m_pArray[nIndex] = p; }

    // Removes an element.
    // ====================
    int   RemoveAt(int nIndex);

    // Inserts an element.
    // ===================
    int   InsertAt(int nIndex, void *);

    // Removes all zero entries (null ptrs) and shrinks the array size.
    // ================================================================
    void  Compress();    

    // Removes all zero entries from the end of the array and shrinks it
    // =================================================================

    void Trim();

    // Adds a new element to the end of the array.
    // ===========================================
    int inline Add(void *pSrc) { return InsertAt(m_nSize, pSrc); }    

    // Gets the apparent size of the array (number of used elements)
    // =============================================================
    int inline Size() const { return m_nSize; }

    // Sets the apparent size of the array
    // ===================================
    void inline SetSize(int nNewSize) { m_nSize = nNewSize;}

    // Removes all entries and reduces array size to zero. The elements
    // are simply removed; not deallocated (this class doesn't know what
    // they are).
    // =================================================================
    void  Empty();

    // Gets a pointer to the internal array.
    // =====================================
    inline void**  GetArrayPtr() { return m_pArray; }
    inline void* const*  GetArrayPtr() const { return m_pArray; }
    
    // Gets a pointer to the internal array and Resets the contents to none
    // ====================================================================

    void** UnbindPtr();

    void Bind(CFlexArray & Src);

    // For debugging.
    // ==============
    void  DebugDump();

    void Sort();

protected:
    static int __cdecl CompareEls(const void* pelem1, const void* pelem2);
};

//***************************************************************************
//
//  class CWStringArray
//
//  This class is a generic wide-string array.
//
//***************************************************************************


class POLARITY CWStringArray
{
    CFlexArray m_Array;
    
public:
    enum { no_error, failed, out_of_memory, array_full, range_error };
    enum { not_found = -1, no_case, with_case };
        
    CWStringArray(
        int nSize = 0, 
        int nGrowBy = 100
        );

    CWStringArray(CWStringArray &Src);
   ~CWStringArray();
            
    CWStringArray& operator =(CWStringArray &Src);

    // Gets the read-only ptr to the string at the requested index.
    // =============================================================    
    inline wchar_t *GetAt(int nIndex) const { return (wchar_t *) m_Array[nIndex]; }

    // Same as GetAt().
    // ================
    inline wchar_t *operator[](int nIndex) const{ return (wchar_t *) m_Array[nIndex]; }

    // Appends a new element to the end of the array. Copies the param.
    // ================================================================
    int  Add(const wchar_t *pStr);

    // Inserts a new element within the array.
    // =======================================
    int  InsertAt(int nIndex, const wchar_t *pStr);

    // Removes an element at the specified index.  Takes care of
    // cleanup.
    // =========================================================
    int  RemoveAt(int nIndex);

    // Inserts a copy of <pStr> at that location after removing
    // the prior string and deallocating it.
    // ========================================================
    int  SetAt(int nIndex, const wchar_t *pStr);

    // Directly replaces the pointer at the specified location
    // with the ptr value in <pStr>. No allocs or deallocs are done.
    // =============================================================
    int  ReplaceAt(int nIndex, wchar_t *pStr);
        // Unchecked replacement

    // Deletes the string at the location and sets the entry to zero
    // without compressing the array.
    // =============================================================
    int  DeleteStr(int nIndex);  

    // Returns the 'apparent' size of the array.
    // =========================================
    inline int  Size() const { return m_Array.Size(); }

    // Empties the array by cleaning up after all strings and
    // setting the size to zero.
    // ======================================================
    void Empty();

    // Locates a string or returns -1 if not found.
    // ============================================
    int  FindStr(const wchar_t *pTarget, int nFlags);  

    // Compresses the array by removing all zero elements.
    // ===================================================
    inline void Compress() { m_Array.Compress(); }

    // Sorts the array according to UNICODE order.
    // ===========================================
    void Sort();

    inline LPCWSTR*  GetArrayPtr() { return (LPCWSTR*) m_Array.GetArrayPtr(); }

    // Standard set-theoretic operations.
    // ==================================
    static void Difference(
        CWStringArray &Src1, 
        CWStringArray &Src2,
        CWStringArray &Diff
        );

    static void Intersection(
        CWStringArray &Src1,
        CWStringArray &Src2,
        CWStringArray &Output
        );

    static void Union(
        CWStringArray &Src1,
        CWStringArray &Src2,
        CWStringArray &Output
        );
};

template <typename T>
class POLARITY CLockableFlexArray : public CFlexArray
{
private:
    T m_cs;
public:
       void Lock() { m_cs.Enter(); };
       void Unlock() { m_cs.Leave(); };
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\winmgmt\wbemcomn\flexq.cpp ===
/*++

Copyright (C) 1996-2001 Microsoft Corporation

Module Name:

    FLEXQ.CPP

Abstract:

  CFlexQueue.

History:

--*/

#include "precomp.h"
//#include <dbgalloc.h>
#include <flexq.h>

CFlexQueue::CFlexQueue(int nInitialSize) :
    m_nSize(nInitialSize), m_nHeadIndex(0), m_nTailIndex(0)
{
    if(m_nSize)
        m_ppData = new void*[m_nSize];
    else
        m_ppData = NULL;
}

CFlexQueue::~CFlexQueue()
{
    delete [] m_ppData;
}

bool CFlexQueue::Grow()
{
    int nNewSize = (m_nSize + 1) * 2;

    // Allocate new memory block
    // =========================

    void** ppNewData = new void*[nNewSize];
    if(ppNewData == NULL)
        return false;

    // Copy the queue data to the beginning of the array
    // =================================================

    if(m_nHeadIndex <= m_nTailIndex)
    {
        memcpy(ppNewData, m_ppData + m_nHeadIndex,
                    (m_nTailIndex - m_nHeadIndex) * sizeof(void*));
    }
    else
    {
        memcpy(ppNewData, m_ppData + m_nHeadIndex,
                    (m_nSize - m_nHeadIndex) * sizeof(void*));
        memcpy(ppNewData + (m_nSize - m_nHeadIndex), m_ppData,
                    m_nTailIndex * sizeof(void*));
    }

    m_nTailIndex = GetQueueSize();
    m_nHeadIndex = 0;
    m_nSize = nNewSize;
    delete [] m_ppData;
    m_ppData = ppNewData;

    return true;
}

bool CFlexQueue::Enqueue(void* pNew)
{
    if(GetQueueSize() >= m_nSize - 1)
    {
        if(!Grow()) return false;
    }

    m_ppData[m_nTailIndex] = pNew;
    IncrementIndex(m_nTailIndex);
    return true;
}

void* CFlexQueue::Dequeue()
{
    if(GetQueueSize() == 0)
        return NULL;
    void* pRet = m_ppData[m_nHeadIndex];
    IncrementIndex(m_nHeadIndex);
    return pRet;
}

void* CFlexQueue::Peek()
{
    if(GetQueueSize() == 0)
        return NULL;
    return m_ppData[m_nHeadIndex];
}


bool CFlexQueue::Requeue(void* pNew)
{
    if(GetQueueSize() >= m_nSize - 1)
    {
        if(!Grow()) return false;
    }

    DecrementIndex(m_nHeadIndex);
    m_ppData[m_nHeadIndex] = pNew;
    return true;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\winmgmt\wbemcomn\flexq.h ===
/*++

Copyright (C) 1996-2001 Microsoft Corporation

Module Name:

    FLEXQ.H

Abstract:

  This file defines CFlexQueue.

History:

--*/
#ifndef __WBEM_FLEXQ__H_
#define __WBEM_FLEXQ__H_

class POLARITY CFlexQueue
{
protected:
    void** m_ppData;
    int m_nSize;
    int m_nHeadIndex;
    int m_nTailIndex;

public:
    inline int GetQueueSize() const
    {
        if(m_nHeadIndex <= m_nTailIndex)
            return m_nTailIndex - m_nHeadIndex;
        else
            return m_nTailIndex - m_nHeadIndex + m_nSize;
    }
protected:
    inline void IncrementIndex(int& nIndex)
    {
        if(++nIndex == m_nSize)
            nIndex = 0;
    }
    inline void DecrementIndex(int& nIndex)
    {
        if(nIndex-- == 0)
            nIndex = m_nSize - 1;
    }

    bool Grow();

public:
    CFlexQueue(int nInitialSize = 1);
    ~CFlexQueue();

    bool Enqueue(void* pNew);
    void* Dequeue();
    bool Requeue(void* pNew);
    inline void* Unqueue()
    {
        if(GetQueueSize() == 0)
            return NULL;
        DecrementIndex(m_nTailIndex);
        return m_ppData[m_nTailIndex];
    }
    void* Peek();
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\winmgmt\wbemcomn\genutils.h ===
/*++

Copyright (C) 1997-2001 Microsoft Corporation

Module Name:

    GENUTILS.H

Abstract:

    Declares various utilities.

History:

    a-davj    21-June-97   Created.

--*/

#ifndef _genutils_H_
#define _genutils_H_

#include "corepol.h"
#include "strutils.h"
#include <wbemidl.h>

#define HR_LAST_ERR  MAKE_HRESULT(SEVERITY_ERROR, FACILITY_WIN32, GetLastError() )

// These are some generally useful routines
// ========================================

POLARITY BOOL IsW2KOrMore(void);
POLARITY BOOL IsNT(void);

POLARITY void RegisterDLL(HMODULE hModule, GUID guid, TCHAR * pDesc, TCHAR * pModel, TCHAR * progid);
POLARITY void UnRegisterDLL(GUID guid, TCHAR * progid);

POLARITY HRESULT RegisterDllAppid(HMODULE hModule,
                                       CLSID Clsid,
                                       WCHAR * pDescription,
                                       WCHAR * ThreadingModel,
                                       WCHAR * pLaunchPermission,
                                       WCHAR * pAccessPermission);
POLARITY HRESULT UnregisterDllAppid(CLSID Clsid);

POLARITY HRESULT WbemVariantChangeType(VARIANT* pvDest, VARIANT* pvSrc, 
            VARTYPE vtNew);
POLARITY BOOL ReadI64(LPCWSTR wsz, UNALIGNED __int64& i64);
POLARITY BOOL ReadUI64(LPCWSTR wsz, UNALIGNED unsigned __int64& ui64);
POLARITY HRESULT ChangeVariantToCIMTYPE(VARIANT* pvDest, VARIANT* pvSource,
                                            CIMTYPE ct);
POLARITY void SecurityMutexRequest();
POLARITY void SecurityMutexClear();
POLARITY bool IsStandAloneWin9X();
POLARITY BOOL bAreWeLocal(WCHAR * pServerMachine);
POLARITY WCHAR *ExtractMachineName ( IN BSTR a_Path );

POLARITY HRESULT WbemSetDynamicCloaking(IUnknown* pProxy, 
                    DWORD dwAuthnLevel, DWORD dwImpLevel);

#define TOKEN_THREAD    0
#define TOKEN_PROCESS   1

POLARITY HRESULT EnableAllPrivileges(DWORD dwTokenType = TOKEN_THREAD);
POLARITY BOOL EnablePrivilege(DWORD dwTokenType, LPCTSTR pName);
POLARITY bool IsPrivilegePresent(HANDLE hToken, LPCTSTR pName);

#define GLOBAL_WINMGMT_PREFIX L"Global\\WINMGMTCLIENTREQ"

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\winmgmt\wbemcomn\like.cpp ===
//***************************************************************************
//
//   (c) 2000-2001 by Microsoft Corp. All Rights Reserved.
//
//   like.cpp
//
//   a-davcoo     28-Feb-00       Implements the SQL like operation.
//
//***************************************************************************


#include "precomp.h"
#include "like.h"
#include "corex.h"

#define WILDCARD		L'%'
#define ANYSINGLECHAR	L'_'

CLike::CLike (LPCWSTR expression, WCHAR escape)
: m_expression(NULL)
{
    SetExpression( expression, escape );
}

CLike& CLike::operator=( const CLike& rOther )
{
    if ( rOther.m_expression != NULL )
    {
        SetExpression( rOther.m_expression, rOther.m_escape );
    }
    else
    {
        delete [] m_expression;
        m_expression = NULL;
    }

    return *this;
}
                             
CLike::~CLike (void)
{
    delete [] m_expression;
}

void CLike::SetExpression( LPCWSTR string, WCHAR escape ) 
{
    delete [] m_expression;
    size_t stringSize = wcslen(string)+1;
    m_expression = new WCHAR[stringSize];
    if ( m_expression == NULL )
    {
        throw CX_MemoryException();
    }
    StringCchCopyW( m_expression, stringSize, string );
    m_escape = escape;
}

bool CLike::Match( LPCWSTR string )
{
    bool bRes;

    if ( m_expression != NULL )
    {
        bRes = DoLike( m_expression, string, m_escape );
    }
    else
    {
        bRes = false;
    }

    return bRes; 
}


bool CLike::DoLike (LPCWSTR pattern, LPCWSTR string, WCHAR escape)
{
	bool like=false;
	while (!like && *pattern && *string)
	{
		// Wildcard match.
		if (*pattern==WILDCARD)
		{
			pattern++;

			do
			{
				like=DoLike (pattern, string, escape);
				if (!like) string++;
			}
			while (*string && !like);
		}
		// Set match.
		else if (*pattern=='[')
		{
			int skip;
			if (MatchSet (pattern, string, skip))
			{
				pattern+=skip;
				string++;
			}
			else
			{
				break;
			}
		}
		// Single character match.
		else
		{
			if (escape!='\0' && *pattern==escape) pattern++;
			if (wbem_towupper(*pattern)==wbem_towupper(*string) || *pattern==ANYSINGLECHAR)
			{
				pattern++;
				string++;
			}
			else
			{
				break;
			}
		}
	}

	// Skip any trailing wildcard characters.
	while (*pattern==WILDCARD) pattern++;

	// It's a match if we reached the end of both strings, or a recursion 
	// succeeded.
	return (!(*pattern) && !(*string)) || like;
}


bool CLike::MatchSet (LPCWSTR pattern, LPCWSTR string, int &skip)
{
	// Skip the opening '['.
	LPCWSTR pos=pattern+1;

	// See if we are matching a [^] set.
	bool notinset=(*pos=='^');
	if (notinset) pos++;

	// See if the target character matches any character in the set.
	bool matched=false;
	WCHAR lastchar='\0';
	while (*pos && *pos!=']' && !matched)
	{
		// A range of characters is indicated by a '-' unless it's the first
		// character in the set (in which case it's just a character to be
		// matched.
		if (*pos=='-' && lastchar!='\0')
		{
			pos++;
			if (*pos && *pos!=']')
			{
				matched=(wbem_towupper(*string)>=lastchar && wbem_towupper(*string)<=wbem_towupper(*pos));
				lastchar=wbem_towupper(*pos);
				pos++;
			}
		}
		else
		{
			// Match a normal character in the set.
			lastchar=wbem_towupper(*pos);
			matched=(wbem_towupper(*pos)==wbem_towupper(*string));
			if (!matched) pos++;
		}
	}

	// Skip the trailing ']'.  If the set did not contain a closing ']'
	// we return a failed match.
	while (*pos && *pos!=']') pos++;
	if (*pos==']') pos++;
	if (!*pos) matched=false;

	// Done.
	skip=(int)(pos-pattern);
	return matched==!notinset;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\winmgmt\wbemcomn\genutils.cpp ===
/*++

Copyright (C) 1997-2001 Microsoft Corporation

Module Name:

    GENUTILS.CPP

Abstract:

    Defines various utilities.

History:

    a-davj    21-June-97   Created.

--*/

#include "precomp.h"
#include "corepol.h"
#include "arena.h"
#include <wbemidl.h>
#include <arrtempl.h>
#include "reg.h"
#include "genutils.h"
#include "wbemutil.h"
#include "var.h"
#include <helper.h>
#include <sddl.h>

#define IsSlash(x) (x == L'\\' || x== L'/')

#ifndef EOAC_STATIC_CLOAKING
#define EOAC_STATIC_CLOAKING 0x20
#define EOAC_DYNAMIC_CLOAKING 0x40
#endif

//***************************************************************************
//
//  BOOL IsNT
//
//  DESCRIPTION:
//
//  Returns true if running windows NT.
//
//  RETURN VALUE:
//
//  see description.
//
//***************************************************************************

POLARITY BOOL IsNT(void)
{
    OSVERSIONINFO os;
    os.dwOSVersionInfoSize = sizeof(OSVERSIONINFO);
    if(!GetVersionEx(&os))
        return FALSE;           // should never happen
    return os.dwPlatformId == VER_PLATFORM_WIN32_NT;
}

POLARITY BOOL IsW2KOrMore(void)
{
    OSVERSIONINFO os;
    os.dwOSVersionInfoSize = sizeof(OSVERSIONINFO);
    if(!GetVersionEx(&os))
        return FALSE;           // should never happen
    return ( os.dwPlatformId == VER_PLATFORM_WIN32_NT ) && ( os.dwMajorVersion >= 5 ) ;
}

//***************************************************************************
//
//  void RegisterDLL
//
//  DESCRIPTION:
//
//  Adds the current dll to the registry as an inproc server.
//
//  PARAMETERS:
//
//  guid                GUILD that this supports
//  pDesc               Text description for this object.
//
//***************************************************************************

POLARITY void RegisterDLL(IN HMODULE hModule, IN GUID guid, IN TCHAR * pDesc, TCHAR * pModel,
            TCHAR * pProgID)
{
    TCHAR      wcID[128];
    TCHAR      szCLSID[128];
    TCHAR      szModule[MAX_PATH+1];
    HKEY hKey1 = NULL, hKey2 = NULL;

    // Create the path.

    wchar_t strCLSID[128];
    if(0 ==StringFromGUID2(guid, strCLSID, 128))
        return;
    StringCchCopy(wcID, 128, strCLSID);

    StringCchCopy(szCLSID, 128, __TEXT("SOFTWARE\\CLASSES\\CLSID\\"));
    StringCchCat(szCLSID, 128, wcID);

    // Create entries under CLSID

    if(ERROR_SUCCESS != RegCreateKey(HKEY_LOCAL_MACHINE, szCLSID, &hKey1)) return;
    OnDelete<HKEY,LONG(*)(HKEY),RegCloseKey> cm1(hKey1);

    RegSetValueEx(hKey1, NULL, 0, REG_SZ, (BYTE *)pDesc, 2*(lstrlen(pDesc)+1));
    if(ERROR_SUCCESS != RegCreateKey(hKey1,__TEXT("InprocServer32"),&hKey2)) return;
    OnDelete<HKEY,LONG(*)(HKEY),RegCloseKey> cm2(hKey2);    

    szModule[MAX_PATH] = L'0';
    if(0 == GetModuleFileName(hModule, szModule,  MAX_PATH)) return;

    RegSetValueEx(hKey2, NULL, 0, REG_SZ, (BYTE *)szModule, 2*(lstrlen(szModule)+1));
    RegSetValueEx(hKey2, TEXT("ThreadingModel"), 0, REG_SZ, (BYTE *)pModel, 2*(lstrlen(pModel)+1));

    // If there is a progid, then add it too

    if(pProgID)
    {
        StringCchPrintf(wcID, 128, __TEXT("SOFTWARE\\CLASSES\\%s"), pProgID);
        HKEY hKey3;
        if(ERROR_SUCCESS != RegCreateKey(HKEY_LOCAL_MACHINE, wcID, &hKey3)) return;
        OnDelete<HKEY,LONG(*)(HKEY),RegCloseKey> cm3(hKey3);   

        RegSetValueEx(hKey3, NULL, 0, REG_SZ, (BYTE *)pDesc , 2*(lstrlen(pDesc)+1));

        HKEY hKey4;
        if(ERROR_SUCCESS != RegCreateKey(hKey3,__TEXT("CLSID"),&hKey4)) return;
        OnDelete<HKEY,LONG(*)(HKEY),RegCloseKey> cm4(hKey4);   
        
        RegSetValueEx(hKey4, NULL, 0, REG_SZ, (BYTE *)strCLSID, 2*(lstrlen(strCLSID)+1));
            
    }
    return;
}

//***************************************************************************
//
//  void UnRegisterDLL
//
//  DESCRIPTION:
//
//  Removes an in proc guid from the clsid section
//
//  PARAMETERS:
//
//  guid                guild to be removed.
//
//***************************************************************************

POLARITY void UnRegisterDLL(GUID guid, TCHAR * pProgID)
{

    TCHAR      wcID[128];
    TCHAR  szCLSID[128];
    HKEY hKey;

    // Create the path using the CLSID

    wchar_t strCLSID[128];
    if(0 ==StringFromGUID2(guid, strCLSID, 128))
        return;
#ifdef UNICODE
    StringCchCopy(wcID, 128, strCLSID);
#else
    wcstombs(wcID, strCLSID, 128);
#endif


    StringCchCopy(szCLSID, 128, __TEXT("SOFTWARE\\CLASSES\\CLSID\\"));
    StringCchCat(szCLSID, 128, wcID);

    // First delete the InProcServer subkey.

    DWORD dwRet = RegOpenKey(HKEY_LOCAL_MACHINE, szCLSID, &hKey);
    if(dwRet == NO_ERROR)
    {
        RegDeleteKey(hKey, __TEXT("InProcServer32"));
        RegCloseKey(hKey);
    }

    dwRet = RegOpenKey(HKEY_LOCAL_MACHINE, __TEXT("SOFTWARE\\CLASSES\\CLSID"), &hKey);
    if(dwRet == NO_ERROR)
    {
        RegDeleteKey(hKey,wcID);
        RegCloseKey(hKey);
    }

    if(pProgID)
    {
        HKEY hKey2;
        DWORD dwRet2 = RegOpenKey(HKEY_LOCAL_MACHINE, pProgID, &hKey2);
        if(dwRet2 == NO_ERROR)
        {
            RegDeleteKey(hKey2, __TEXT("CLSID"));
            RegCloseKey(hKey2);
        }
        RegDeleteKey(HKEY_LOCAL_MACHINE, pProgID);

    }
}

//
//
//  HKLM\Software\Classes\Appid\{} @ =  ""
//                                                  DllSurrogate = 
//                                                  LaunchPermission = 
//                                                  AccessPermission =
//  HKLM\Software\Classes\Clsid\{} @ =  ""
//                                                  AppId = {}
// HKLM\Software\Classes\Clsid\{}\InprocServer32 @ = "path"
//                                                                         ThreadingModel = ""
////////////////////////////////////
HRESULT RegisterDllAppid(HMODULE hModule,
                                       CLSID Clsid,
                                       WCHAR * pDescription,
                                       WCHAR * ThreadingModel,
                                       WCHAR * pLaunchPermission,
                                       WCHAR * pAccessPermission)
{
    WCHAR ClsidStr[sizeof("Software\\Classes\\Clsid\\{0010890e-8789-413c-adbc-48f5b511b3af}\\InProcServer32")];

    StringCchCopy(ClsidStr,LENGTH_OF(ClsidStr),L"Software\\Classes\\Clsid\\");

    WCHAR * strCLSID = &ClsidStr[0] + LENGTH_OF(L"Software\\Classes\\Clsid");

    if(0 ==StringFromGUID2(Clsid, strCLSID, 128)) return HR_LAST_ERR;


    WCHAR szModule[MAX_PATH+1];
    szModule[MAX_PATH] = L'0';
    if(0 == GetModuleFileName(hModule, szModule,  MAX_PATH)) return HR_LAST_ERR;    

    HKEY hKey;
    if(ERROR_SUCCESS != RegCreateKey(HKEY_LOCAL_MACHINE, ClsidStr, &hKey)) return HR_LAST_ERR;    
    CRegCloseMe RegClose(hKey);

    size_t StrLen = wcslen(pDescription);
    if (ERROR_SUCCESS != RegSetValueEx(hKey,NULL,0,REG_SZ,(BYTE *)pDescription,StrLen*sizeof(WCHAR))) return HR_LAST_ERR;

    StringCchCatW(ClsidStr,LENGTH_OF(ClsidStr),L"\\InProcServer32");

    HKEY hKey2;
    if(ERROR_SUCCESS != RegCreateKey(HKEY_LOCAL_MACHINE, ClsidStr, &hKey2)) return HR_LAST_ERR;    
    CRegCloseMe RegClose2(hKey2);

    StrLen = wcslen(szModule);
    if (ERROR_SUCCESS != RegSetValueEx(hKey2,NULL,0,REG_SZ,(BYTE *)szModule,StrLen*sizeof(WCHAR))) return HR_LAST_ERR;

    StrLen = wcslen(ThreadingModel);
    if (ERROR_SUCCESS != RegSetValueEx(hKey2,L"ThreadingModel",0,REG_SZ,(BYTE *)ThreadingModel,StrLen*sizeof(WCHAR))) return HR_LAST_ERR;

    strCLSID[sizeof("{0010890e-8789-413c-adbc-48f5b511b3af}")-1] = 0;
    StrLen = wcslen(strCLSID);
    if (ERROR_SUCCESS != RegSetValueEx(hKey,L"AppID",0,REG_SZ,(BYTE *)strCLSID,StrLen*sizeof(WCHAR))) return HR_LAST_ERR;

    WCHAR * StrAppId =  strCLSID - 6; // get to the 'Cls' to replace it
    StrAppId[0] = L'A';
    StrAppId[1] = L'p';
    StrAppId[2] = L'p';    

    HKEY hKey3;
    if(ERROR_SUCCESS != RegCreateKey(HKEY_LOCAL_MACHINE, ClsidStr, &hKey3)) return HR_LAST_ERR;    
    CRegCloseMe RegClose3(hKey3);
    
    if (ERROR_SUCCESS != RegSetValueEx(hKey3,L"DllSurrogate",0,REG_SZ,(BYTE *)L"",2)) return HR_LAST_ERR;    

    if (pLaunchPermission)
    {
        PSECURITY_DESCRIPTOR pSD = NULL;
        ULONG SizeSd;
        if (FALSE == ConvertStringSecurityDescriptorToSecurityDescriptor(pLaunchPermission,
                                                    SDDL_REVISION_1, 
                                                    &pSD, 
                                                    &SizeSd)) return HR_LAST_ERR;
        OnDelete<HLOCAL,HLOCAL(*)(HLOCAL),LocalFree> dm1(pSD);
        if (ERROR_SUCCESS != RegSetValueEx(hKey3,L"LaunchPermission",0,REG_BINARY,(BYTE *)pSD,SizeSd)) return HR_LAST_ERR;            
    }

    if (pAccessPermission)
    {
        PSECURITY_DESCRIPTOR pSD = NULL;
        ULONG SizeSd;        
        if (FALSE == ConvertStringSecurityDescriptorToSecurityDescriptor(pAccessPermission,
                                                    SDDL_REVISION_1, 
                                                    &pSD, 
                                                    &SizeSd)) return HR_LAST_ERR;
        OnDelete<HLOCAL,HLOCAL(*)(HLOCAL),LocalFree> dm1(pSD);        
        if (ERROR_SUCCESS != RegSetValueEx(hKey3,L"AccessPermission",0,REG_BINARY,(BYTE *)pSD,SizeSd)) return HR_LAST_ERR;        
    }
    
    return S_OK;    
}

HRESULT UnregisterDllAppid(CLSID Clsid)
{
    WCHAR ClsidStr[sizeof("Software\\Classes\\Clsid\\{0010890e-8789-413c-adbc-48f5b511b3af}\\InProcServer32")];

    StringCchCopy(ClsidStr,LENGTH_OF(ClsidStr),L"Software\\Classes\\Clsid\\");

    WCHAR * strCLSID = &ClsidStr[0] + LENGTH_OF(L"Software\\Classes\\Clsid");

    if(0 ==StringFromGUID2(Clsid, strCLSID, 128)) return HR_LAST_ERR;

    if(ERROR_SUCCESS != RegDeleteKey(HKEY_LOCAL_MACHINE, ClsidStr)) return HR_LAST_ERR;    

    WCHAR * StrAppId =  strCLSID - 6; // get to the 'Cls' to replace it
    StrAppId[0] = L'A';
    StrAppId[1] = L'p';
    StrAppId[2] = L'p';    

    if(ERROR_SUCCESS != RegDeleteKey(HKEY_LOCAL_MACHINE, ClsidStr)) return HR_LAST_ERR;    

    return S_OK;
}


//***************************************************************************
//
//  HRESULT WbemVariantChangeType
//
//  DESCRIPTION:
//
//  Just like VariantChangeType, but deals with arrays as well.
//
//  PARAMETERS:
//
//  VARIANT pvDest      Destination variant
//  VARIANT pvSrc       Source variant (can be the same as pvDest)
//  VARTYPE vtNew       The type to coerce to.
//
//***************************************************************************

POLARITY HRESULT WbemVariantChangeType(VARIANT* pvDest, VARIANT* pvSrc, 
                                        VARTYPE vtNew)
{
    HRESULT hres;

    if(V_VT(pvSrc) == VT_NULL)
    {
        return VariantCopy(pvDest, pvSrc);
    }

    if(vtNew & VT_ARRAY)
    {
        // It's an array, we have to do our own conversion
        // ===============================================

        if((V_VT(pvSrc) & VT_ARRAY) == 0)
            return DISP_E_TYPEMISMATCH;

        SAFEARRAY* psaSrc = V_ARRAY(pvSrc);

        SAFEARRAYBOUND aBounds[1];

        long lLBound;
        SafeArrayGetLBound(psaSrc, 1, &lLBound);

        long lUBound;
        SafeArrayGetUBound(psaSrc, 1, &lUBound);

        aBounds[0].cElements = lUBound - lLBound + 1;
        aBounds[0].lLbound = lLBound;

        SAFEARRAY* psaDest = SafeArrayCreate(vtNew & ~VT_ARRAY, 1, aBounds);
        if (NULL == psaDest) return WBEM_E_OUT_OF_MEMORY;
        OnDeleteIf<SAFEARRAY*,HRESULT(*)(SAFEARRAY*),SafeArrayDestroy> Del_(psaDest);

        // Stuff the individual data pieces
        // ================================

        for(long lIndex = lLBound; lIndex <= lUBound; lIndex++)
        {
            // Load the initial data element into a VARIANT
            // ============================================

            VARIANT vSrcEl;            
            hres = SafeArrayGetElement(psaSrc, &lIndex, &V_UI1(&vSrcEl));
            if(FAILED(hres)) return hres;

            // if success, set the type
            V_VT(&vSrcEl) = V_VT(pvSrc) & ~VT_ARRAY;
            OnDelete<VARIANT *,HRESULT(*)(VARIANT *),VariantClear> Clear(&vSrcEl);
                        
            // Cast it to the new type
            hres = VariantChangeType(&vSrcEl, &vSrcEl, 0, vtNew & ~VT_ARRAY);
            if(FAILED(hres)) return hres;

            // Put it into the new array
            // =========================

            if(V_VT(&vSrcEl) == VT_BSTR)
            {
                hres = SafeArrayPutElement(psaDest, &lIndex, V_BSTR(&vSrcEl));
            }
            else
            {
                hres = SafeArrayPutElement(psaDest, &lIndex, &V_UI1(&vSrcEl));
            }
            if(FAILED(hres)) return hres;
        }

        if(pvDest == pvSrc)
        {
            VariantClear(pvSrc);
        }

        V_VT(pvDest) = vtNew;
        V_ARRAY(pvDest) = psaDest;
        Del_.dismiss();

        return S_OK;
    }
    else
    {
        // Not an array. Can use OLE functions
        // ===================================

        return VariantChangeType(pvDest, pvSrc, VARIANT_NOVALUEPROP, vtNew);
    }
}

//***************************************************************************
//
//  BOOL ReadI64
//
//  DESCRIPTION:
//
//  Reads a signed 64-bit value from a string
//
//  PARAMETERS:
//
//      LPCWSTR wsz     String to read from
//      __int64& i64    Destination for the value
//
//***************************************************************************
POLARITY BOOL ReadI64(LPCWSTR wsz, UNALIGNED __int64& ri64)
{
    __int64 i64 = 0;
    const WCHAR* pwc = wsz;

	// Check for a NULL pointer
	if ( NULL == wsz )
	{
		return FALSE;
	}

    int nSign = 1;
    if(*pwc == L'-')
    {
        nSign = -1;
        pwc++;
    }
        
    while(i64 >= 0 && i64 < 0x7FFFFFFFFFFFFFFF / 8 && 
            *pwc >= L'0' && *pwc <= L'9')
    {
        i64 = i64 * 10 + (*pwc - L'0');
        pwc++;
    }

    if(*pwc)
        return FALSE;

    if(i64 < 0)
    {
        // Special case --- largest negative number
        // ========================================

        if(nSign == -1 && i64 == (__int64)0x8000000000000000)
        {
            ri64 = i64;
            return TRUE;
        }
        
        return FALSE;
    }

    ri64 = i64 * nSign;
    return TRUE;
}

//***************************************************************************
//
//  BOOL ReadUI64
//
//  DESCRIPTION:
//
//  Reads an unsigned 64-bit value from a string
//
//  PARAMETERS:
//
//      LPCWSTR wsz              String to read from
//      unsigned __int64& i64    Destination for the value
//
//***************************************************************************
POLARITY BOOL ReadUI64(LPCWSTR wsz, UNALIGNED unsigned __int64& rui64)
{
    unsigned __int64 ui64 = 0;
    const WCHAR* pwc = wsz;

	// Check for a NULL pointer
	if ( NULL == wsz )
	{
		return FALSE;
	}

    while(ui64 < 0xFFFFFFFFFFFFFFFF / 8 && *pwc >= L'0' && *pwc <= L'9')
    {
        unsigned __int64 ui64old = ui64;
        ui64 = ui64 * 10 + (*pwc - L'0');
        if(ui64 < ui64old)
            return FALSE;

        pwc++;
    }

    if(*pwc)
    {
        return FALSE;
    }

    rui64 = ui64;
    return TRUE;
}

POLARITY HRESULT ChangeVariantToCIMTYPE(VARIANT* pvDest, VARIANT* pvSource,
                                            CIMTYPE ct)
{
    if(ct == CIM_CHAR16)
    {
        //
        // Special case --- use CVar's code
        //

        CVar v;
        try
        {
            v.SetVariant(pvSource);
            if(!v.ToSingleChar())
                return WBEM_E_TYPE_MISMATCH;
            v.FillVariant(pvDest);            
            return WBEM_S_NO_ERROR;
        }
        catch(...)
        {
            return WBEM_E_OUT_OF_MEMORY;
        }
    }

    VARTYPE vt;
    switch(ct)
    {
    case CIM_UINT8:
        vt = VT_UI1;
        break;
    case CIM_SINT8:
    case CIM_SINT16:
        vt = VT_I2;
        break;
    case CIM_UINT16:
    case CIM_SINT32:
        vt = VT_I4;
        break;
    case CIM_UINT32:
    case CIM_UINT64:
    case CIM_SINT64:
    case CIM_STRING:
    case CIM_DATETIME:
    case CIM_REFERENCE:
        vt = VT_BSTR;
        break;
    case CIM_REAL32:
        vt = VT_R4;
        break;
    case CIM_REAL64:
        vt = VT_R8;
        break;
    case CIM_OBJECT:
        vt = VT_UNKNOWN;
        break;
    case CIM_BOOLEAN:
        vt = VT_BOOL;
        break;
    default:
        return WBEM_E_TYPE_MISMATCH;
    }

    HRESULT hres = WbemVariantChangeType(pvDest, pvSource, vt);
    if(FAILED(hres))
        return hres;

    if(ct == CIM_SINT8)
    {
        if(V_I2(pvDest) > 127 || V_I2(pvDest) < -128)
            hres = WBEM_E_TYPE_MISMATCH;
    }
    else if(ct == CIM_UINT16)
    {
        if(V_I4(pvDest) > 65535 || V_I4(pvDest) < 0)
            hres = WBEM_E_TYPE_MISMATCH;
    }
    else if(ct == CIM_UINT32)
    {
        __int64 i64;
        if(!ReadI64(V_BSTR(pvDest), i64))
            hres = WBEM_E_INVALID_QUERY;
        else if(i64 < 0 || i64 >= (__int64)1 << 32)
            hres = WBEM_E_TYPE_MISMATCH;
    }
    else if(ct == CIM_UINT64)
    {
        unsigned __int64 ui64;
        if(!ReadUI64(V_BSTR(pvDest), ui64))
            hres = WBEM_E_INVALID_QUERY;
    }
    else if(ct == CIM_SINT64)
    {
        __int64 i64;
        if(!ReadI64(V_BSTR(pvDest), i64))
            hres = WBEM_E_INVALID_QUERY;
    }

    if(FAILED(hres))
    {
        VariantClear(pvDest);
    }
    return hres;
}


//***************************************************************************
//
//  WCHAR *ExtractMachineName
//
//  DESCRIPTION:
//
//  Takes a path of form "\\machine\xyz... and returns the
//  "machine" portion in a newly allocated WCHAR.  The return value should
//  be freed via delete. NULL is returned if there is an error.
//
//
//  PARAMETERS:
//
//  pPath               Path to be parsed.
//
//  RETURN VALUE:
//
//  see description.
//
//***************************************************************************

POLARITY WCHAR *ExtractMachineName ( IN BSTR a_Path )
{
    WCHAR *t_MachineName = NULL;

    //todo, according to the help file, the path can be null which is
    // default to current machine, however Ray's mail indicated that may
    // not be so.

    if ( a_Path == NULL )
    {
        t_MachineName = new WCHAR [ 2 ] ;
        if ( t_MachineName )
        {
           StringCchCopyW ( t_MachineName , 2, L"." ) ;
        }

        return t_MachineName ;
    }

    // First make sure there is a path and determine how long it is.

    if ( ! IsSlash ( a_Path [ 0 ] ) || ! IsSlash ( a_Path [ 1 ] ) || wcslen ( a_Path ) < 3 )
    {
        t_MachineName = new WCHAR [ 2 ] ;
        if ( t_MachineName )
        {
             StringCchCopyW ( t_MachineName , 2, L"." ) ;
        }

        return t_MachineName ;
    }

    WCHAR *t_ThirdSlash ;

    for ( t_ThirdSlash = a_Path + 2 ; *t_ThirdSlash ; t_ThirdSlash ++ )
    {
        if ( IsSlash ( *t_ThirdSlash ) )
            break ;
    }

    if ( t_ThirdSlash == &a_Path [2] )
    {
        return NULL;
    }

    // allocate some memory

    t_MachineName = new WCHAR [ t_ThirdSlash - a_Path - 1 ] ;
    if ( t_MachineName == NULL )
    {
        return t_MachineName ;
    }

    // temporarily replace the third slash with a null and then copy

    WCHAR t_SlashCharacter = *t_ThirdSlash ;
    *t_ThirdSlash = NULL;

    StringCchCopyW ( t_MachineName , t_ThirdSlash - a_Path - 1 , a_Path + 2 ) ;

    *t_ThirdSlash  = t_SlashCharacter ;        // restore it.

    return t_MachineName ;
}

//***************************************************************************
//
//  BOOL bAreWeLocal
//
//  DESCRIPTION:
//
//  Determines if the connection is to the current machine.
//
//  PARAMETERS:
//
//  pwcServerName       Server name as extracted from the path.
//
//  RETURN VALUE:
//
//  True if we are local
//
//***************************************************************************

POLARITY BOOL bAreWeLocal(WCHAR * pServerMachine)
{
    BOOL bRet = FALSE;
    if(pServerMachine == NULL)
        return TRUE;
    if(!wbem_wcsicmp(pServerMachine,L"."))
        return TRUE;

	if ( IsNT () )
	{
		wchar_t wczMyName[MAX_PATH];
		DWORD dwSize = MAX_PATH;

		if(!GetComputerNameW(wczMyName,&dwSize))
			return FALSE;

		bRet = !wbem_wcsicmp(wczMyName,pServerMachine);
	}
	else
	{
		TCHAR tcMyName[MAX_PATH];
		DWORD dwSize = MAX_PATH;
		if(!GetComputerName(tcMyName,&dwSize))
			return FALSE;

#ifdef UNICODE
		bRet = !wbem_wcsicmp(tcMyName,pServerMachine);
#else
		WCHAR wWide[MAX_PATH];
		mbstowcs(wWide, tcMyName, MAX_PATH-1);
		bRet = !wbem_wcsicmp(wWide,pServerMachine);
#endif
	}

    return bRet;
}

POLARITY HRESULT WbemSetDynamicCloaking(IUnknown* pProxy, 
                    DWORD dwAuthnLevel, DWORD dwImpLevel)
{
    HRESULT hres;

    if(!IsW2KOrMore())
    {
        // Not NT5 --- don't bother
        // ========================

        return WBEM_S_FALSE;
    }

    // Try to get IClientSecurity from it
    // ==================================

    IClientSecurity* pSec;
    hres = pProxy->QueryInterface(IID_IClientSecurity, (void**)&pSec);
    if(FAILED(hres))
    {
        // Not a proxy --- not a problem
        // =============================

        return WBEM_S_FALSE;
    }

    hres = pSec->SetBlanket(pProxy, RPC_C_AUTHN_WINNT, 
                    RPC_C_AUTHZ_NONE, NULL, dwAuthnLevel, 
                    dwImpLevel, NULL, EOAC_DYNAMIC_CLOAKING);
    pSec->Release();

    return hres;
}


POLARITY HRESULT EnableAllPrivileges(DWORD dwTokenType)
{
    // Open thread token
    // =================

    HANDLE hToken = NULL;
    BOOL bRes;

    switch (dwTokenType)
    {
    case TOKEN_THREAD:
        bRes = OpenThreadToken(GetCurrentThread(), TOKEN_QUERY | TOKEN_ADJUST_PRIVILEGES, TRUE, &hToken); 
        break;
    case TOKEN_PROCESS:
        bRes = OpenProcessToken(GetCurrentProcess(), TOKEN_QUERY | TOKEN_ADJUST_PRIVILEGES, &hToken); 
        break;
    }
    if(!bRes)
        return WBEM_E_ACCESS_DENIED;

    // Get the privileges
    // ==================

    DWORD dwLen = 0;
    bRes = GetTokenInformation(hToken, TokenPrivileges, NULL, 0, &dwLen);
    
    BYTE* pBuffer = new BYTE[dwLen];
    if(dwLen && pBuffer == NULL)
    {
        CloseHandle(hToken);
        return WBEM_E_OUT_OF_MEMORY;
    }
    
    bRes = GetTokenInformation(hToken, TokenPrivileges, pBuffer, dwLen, 
                                &dwLen);
    if(!bRes)
    {
        CloseHandle(hToken);
        delete [] pBuffer;
        return WBEM_E_ACCESS_DENIED;
    }

    // Iterate through all the privileges and enable them all
    // ======================================================

    TOKEN_PRIVILEGES* pPrivs = (TOKEN_PRIVILEGES*)pBuffer;
    for(DWORD i = 0; i < pPrivs->PrivilegeCount; i++)
    {
        pPrivs->Privileges[i].Attributes |= SE_PRIVILEGE_ENABLED;
    }

    // Store the information back into the token
    // =========================================

    bRes = AdjustTokenPrivileges(hToken, FALSE, pPrivs, 0, NULL, NULL);
    delete [] pBuffer;
    CloseHandle(hToken);

    if(!bRes)
        return WBEM_E_ACCESS_DENIED;
    else
        return WBEM_S_NO_ERROR;
}

POLARITY BOOL EnablePrivilege(DWORD dwTokenType, LPCTSTR pName)
{
    if(pName == NULL) return FALSE;
    
    LUID PrivilegeRequired ;
    if(!LookupPrivilegeValue(NULL, pName, &PrivilegeRequired)) return FALSE;

    BOOL bRes;
    HANDLE hToken;
    switch (dwTokenType)
    {
    case TOKEN_THREAD:
        bRes = OpenThreadToken(GetCurrentThread(), TOKEN_QUERY | TOKEN_ADJUST_PRIVILEGES, TRUE, &hToken); 
        break;
    case TOKEN_PROCESS:
        bRes = OpenProcessToken(GetCurrentProcess(), TOKEN_QUERY | TOKEN_ADJUST_PRIVILEGES, &hToken); 
        break;
    }
    if(!bRes) return FALSE;
    OnDelete<HANDLE,BOOL(*)(HANDLE),CloseHandle> cm(hToken);

    DWORD dwLen = 0;
    bRes = GetTokenInformation(hToken, TokenPrivileges, NULL, 0, &dwLen);
    if (TRUE == bRes) return FALSE;
    
    wmilib::auto_ptr<BYTE> pBuffer(new BYTE[dwLen]);
    if(NULL == pBuffer.get()) return FALSE;
    
    if (!GetTokenInformation(hToken, TokenPrivileges, pBuffer.get(), dwLen, &dwLen)) return FALSE;

    // Iterate through all the privileges and enable the one required
    bRes = FALSE;
    TOKEN_PRIVILEGES* pPrivs = (TOKEN_PRIVILEGES*)pBuffer.get();
    for(DWORD i = 0; i < pPrivs->PrivilegeCount; i++)
    {
        if (pPrivs->Privileges[i].Luid.LowPart == PrivilegeRequired.LowPart &&
          pPrivs->Privileges[i].Luid.HighPart == PrivilegeRequired.HighPart )
        {
            pPrivs->Privileges[i].Attributes |= SE_PRIVILEGE_ENABLED;
            // here it's found
            bRes = AdjustTokenPrivileges(hToken, FALSE, pPrivs, dwLen, NULL, NULL);
            break;
        }
    }
  
    return bRes;
}

POLARITY bool IsPrivilegePresent(HANDLE hToken, LPCTSTR pName)
{
    if(pName == NULL)
        return false;
    LUID PrivilegeRequired ;

    if(!LookupPrivilegeValue(NULL, pName, &PrivilegeRequired))
        return FALSE;

    // Get the privileges
    // ==================

    DWORD dwLen = 0;
    BOOL bRes = GetTokenInformation(hToken, TokenPrivileges, NULL, 0, &dwLen);

    if (0 == dwLen)  return false;
    
    BYTE* pBuffer = new BYTE[dwLen];
    if(pBuffer == NULL) return false;
    
    CDeleteMe<BYTE> dm(pBuffer);
    
    bRes = GetTokenInformation(hToken, TokenPrivileges, pBuffer, dwLen, &dwLen);
    if(!bRes)
        return false;

    // Iterate through all the privileges and look for the one in question.
    // ======================================================

    TOKEN_PRIVILEGES* pPrivs = (TOKEN_PRIVILEGES*)pBuffer;
    for(DWORD i = 0; i < pPrivs->PrivilegeCount; i++)
    {
        if(pPrivs->Privileges[i].Luid.LowPart == PrivilegeRequired.LowPart &&
           pPrivs->Privileges[i].Luid.HighPart == PrivilegeRequired.HighPart )
            return true;
    }
    return false;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\winmgmt\wbemcomn\locks.cpp ===
#include <precomp.h>
#include <locks.h>
#ifdef _WIN32_WINNT
#if _WIN32_WINNT > 0x0400

DWORD  POLARITY  BreakOnDbgAndRenterLoop(void)
{
    __try
    { 
        DebugBreak();
    }
    _except (EXCEPTION_EXECUTE_HANDLER) {};
    
    return EXCEPTION_CONTINUE_EXECUTION;
};


ReaderWriter::ReaderWriter(bool can_throw) : initialized_(false), can_throw_(can_throw)
{
  C_ASSERT(sizeof(::RTL_RESOURCE)==sizeof(ReaderWriter::RTL_RESOURCE));
  __try
  {
    RtlInitializeResource((::RTL_RESOURCE*)&lock_);
    initialized_ = true;
  }
  __except(GetExceptionCode() == STATUS_NO_MEMORY)
  {
  }
  if (initialized_ != true)
    raise_exception();
}

ReaderWriter::~ReaderWriter (void)
{ if (initialized_) RtlDeleteResource((::RTL_RESOURCE*)&lock_);}

bool 
ReaderWriter::acquire (void) 
{ return (RtlAcquireResourceExclusive((::RTL_RESOURCE*)&lock_,TRUE)==TRUE);}

bool 
ReaderWriter::tryacquire (void) 
{ return (RtlAcquireResourceExclusive((::RTL_RESOURCE*)&lock_,FALSE)==TRUE);}

bool 
ReaderWriter::release (void) 
{ RtlReleaseResource((::RTL_RESOURCE*)&lock_); return 0;}


bool 
ReaderWriter::acquire_read (void) 
{ return (RtlAcquireResourceShared((::RTL_RESOURCE*)&lock_,TRUE)==TRUE);}

bool 
ReaderWriter::acquire_write (void) 
{ return (RtlAcquireResourceExclusive((::RTL_RESOURCE*)&lock_,TRUE)==TRUE);}

bool 
ReaderWriter::tryacquire_read (void) 
{ return (RtlAcquireResourceShared((::RTL_RESOURCE*)&lock_,FALSE)==TRUE);}

bool 
ReaderWriter::tryacquire_write (void) 
{ return (RtlAcquireResourceExclusive((::RTL_RESOURCE*)&lock_,FALSE)==TRUE);}

void 
ReaderWriter::downgrade() 
{ RtlConvertExclusiveToShared((::RTL_RESOURCE*)&lock_);}

void
ReaderWriter::upgrade() 
{ RtlConvertSharedToExclusive((::RTL_RESOURCE*)&lock_);}

#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\winmgmt\wbemcomn\localloc.cpp ===
/*++

Copyright (C) 1996-2001 Microsoft Corporation

Module Name:

Abstract:

History:

--*/


#include "precomp.h"
#include "arena.h"

//
// this obj is only linked into the dll version of wbemcomn. components
// that use that static version will define their own localloc.
//

static class WbemComnInitializer
{
public:

    WbemComnInitializer()
    {
        HANDLE hHeap;

        hHeap = HeapCreate( 0,  // will not use exceptions and will serialize
                            0x100000, // init size of 1Meg
                            0 ); // no max size

        if (hHeap == 0)
            return;     // Arena remains uninitialized and properly returns errors later on

        if ( CWin32DefaultArena::WbemHeapInitialize( hHeap ) == FALSE )
        {
            HeapDestroy ( hHeap );
        }
    }
    ~WbemComnInitializer()
    {
        CWin32DefaultArena::WbemHeapFree();     // This destroys the heap
    }

} g_WbemComnInitializer;

void* __cdecl operator new ( size_t size )
{
    return CWin32DefaultArena::WbemMemAlloc( size );
}

void __cdecl operator delete ( void* pv )
{
    CWin32DefaultArena::WbemMemFree( pv );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\winmgmt\wbemcomn\like.h ===
//***************************************************************************
//
//   (c) 2000-2001 by Microsoft Corp. All Rights Reserved.
//
//   like.h
//
//   a-davcoo     28-Feb-00       Implements the SQL like operation.
//
//***************************************************************************

#ifndef _LIKE_H_
#define _LIKE_H_


#include <string.h>

//
// The CLike class implements the SQL "like" operation.  To compare test 
// strings to an expression, construct an instance of the CLike class using 
// the expression and an optional escape character.  Then use the Match() 
// method on that instance to test each string.  Note, this class makes it's
// own copy of the expression used to construct it.  This implementation 
// supports the '%' and '_' wildard characters as well as the [] and [^] 
// constructs for matching sets of characters and ranges of characters.
//
class POLARITY CLike
{
public:
    CLike() : m_expression(NULL) {} 
    CLike( LPCWSTR expression, WCHAR escape='\0' );
    CLike( const CLike& rOther ) : m_expression(NULL) { *this = rOther; }
    CLike& operator= ( const CLike& rOther );
    ~CLike();
    
    bool Match (LPCWSTR string);
    LPCWSTR GetExpression() { return m_expression; }
    void SetExpression( LPCWSTR string, WCHAR escape='\0' );

protected:
    LPWSTR m_expression;
    WCHAR m_escape;
    
    // Recursive function and helpers for performing like operation.
    bool DoLike (LPCWSTR pattern, LPCWSTR string, WCHAR escape);
    bool MatchSet (LPCWSTR pattern, LPCWSTR string, int &skip);
};


#endif // _LIKE_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\winmgmt\wbemcomn\md5wbem.cpp ===
/*++

Copyright (C) 1996-2001 Microsoft Corporation

Module Name:

Abstract:

History:

--*/


#include "precomp.h"

#include <stdio.h>
#include <stdlib.h>
#include <memory.h>

#include "md5.h"
#include "md5wbem.h"




void MD5::Transform(
    IN  LPVOID  pInputValue,
    IN  UINT    uValueLength,
    OUT BYTE    MD5Buffer[16]
    )
{
    MD5_CTX Ctx;
    MD5Init(&Ctx);

    MD5Update(
        &Ctx,
        (unsigned char *) pInputValue,
        uValueLength
    );

    MD5Final(&Ctx);
    CopyMemory(MD5Buffer, Ctx.digest, 16);
}

void MD5::ContinueTransform(
    IN  LPVOID  pInputValue,
    IN  UINT    uValueLength,
    IN OUT BYTE    MD5Buffer[16]
    )
{
    MD5_CTX Ctx;
    MD5Init(&Ctx);      // zeros buffer, and counts

    CopyMemory( Ctx.buf, MD5Buffer, 16 );

    MD5Update(
        &Ctx,
        (unsigned char *) pInputValue,
        uValueLength
    );

    MD5Final(&Ctx);
    CopyMemory(MD5Buffer, Ctx.digest, 16);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\winmgmt\wbemcomn\locks.h ===
#ifndef __LOCKS_H__
#define __LOCKS_H__

#include <windows.h>
#include <dothrow.h>
# pragma once

const bool THROW_LOCK = true;
const bool NOTHROW_LOCK = false;

class CriticalSection
{
public:
  CriticalSection (bool can_throw , DWORD count = 0 );
  // Initialize the CRITICAL_SECTION.

  ~CriticalSection (void);
  // Implicitly destroy the CRITICAL_SECTION.
  bool close (void);
  // dummy call
  bool acquire (void);
  // Acquire lock ownership ( block if necessary).

  bool tryacquire (void);
  // Conditionally acquire lock ( non blocking ).  Returns
  // false on failure

  bool release (void);

  // Release lock 

  bool acquire_read (void);
  bool acquire_write (void);

  bool tryacquire_read (void);
  bool tryacquire_write (void);

  bool valid() const { return initialized_;}

  const CRITICAL_SECTION &lock (void) const;
  // Return the underlying mutex.

  void dump( void ) const ;

private:

  CRITICAL_SECTION lock_;
  bool initialized_;
  bool can_throw_;
  void raise_exception();

private:
  // = Prevent assignment and initialization.
  void operator= (CriticalSection &);
  CriticalSection (const CriticalSection &);
};

template <class Lock> 
bool SleepAndLock( Lock& lock, int timeout )
{
    if (lock.valid())
	for (;!lock.locked();)
	{
	Sleep(timeout);
	lock.acquire();
	}	
    return lock.locked();	
}

inline 
CriticalSection::CriticalSection (bool can_throw,DWORD count):initialized_(false),can_throw_(can_throw)
{
#ifdef _WIN32_WINNT
#if _WIN32_WINNT > 0x0400
   initialized_ = (InitializeCriticalSectionAndSpinCount(&lock_,count))?true:false;
#else
  __try
  {
	InitializeCriticalSection(&lock_);
        initialized_ = true;
  }
  __except(GetExceptionCode() == STATUS_NO_MEMORY)
  {
  }
#endif
#else
  __try
  {
	InitializeCriticalSection(&lock_);
        initialized_ = true;
  }
  __except(GetExceptionCode() == STATUS_NO_MEMORY)
  {
  }
#endif    

  if (initialized_ != true)
    raise_exception();
};

inline 
CriticalSection::~CriticalSection ()
{
  if (initialized_)
    DeleteCriticalSection(&lock_);
}

inline void 
CriticalSection::raise_exception()
{
  if (can_throw_)
	throw CX_MemoryException();
};

inline bool
CriticalSection::acquire(void)
{
  return acquire_write();
};

inline bool
CriticalSection::acquire_read(void)
{
  return acquire_write();
};

#ifndef STATUS_POSSIBLE_DEADLOCK 
#define STATUS_POSSIBLE_DEADLOCK (0xC0000194L)
#endif /*STATUS_POSSIBLE_DEADLOCK */

DWORD POLARITY BreakOnDbgAndRenterLoop(void);

inline bool
CriticalSection::acquire_write(void)
{
  if (initialized_)
  {
      __try {
          EnterCriticalSection(&lock_);
      } __except((STATUS_POSSIBLE_DEADLOCK == GetExceptionCode())? BreakOnDbgAndRenterLoop():EXCEPTION_CONTINUE_SEARCH) {
      }
	  return true;
  }
  return false;
};

inline bool
CriticalSection::release(void)
{
  if (initialized_)
  {
    LeaveCriticalSection(&lock_);
    return true;
  }
  return false;
}

inline bool
CriticalSection::tryacquire()
{
  return tryacquire_write();
};

inline bool
CriticalSection::tryacquire_read()
{
  return tryacquire_write();
};

inline bool
CriticalSection::tryacquire_write()
{
  __try
  {
#ifdef _WIN32_WINNT
#if _WIN32_WINNT > 0x0400
    return TRUE == TryEnterCriticalSection(&lock_);
#else
    return false;
#endif
#else
    return false;
#endif      
  }
  __except(GetExceptionCode() == STATUS_NO_MEMORY)
  {
  };
  return false;
};

inline bool
CriticalSection::close()
{
  return false;
};

#ifdef _WIN32_WINNT
#if _WIN32_WINNT > 0x0400

class ReaderWriter
{
   struct RTL_RESOURCE {
    struct RTL_RESOURCE_DEBUG;
    RTL_CRITICAL_SECTION CriticalSection;
    HANDLE SharedSemaphore;
    ULONG NumberOfWaitingShared;
    HANDLE ExclusiveSemaphore;
    ULONG NumberOfWaitingExclusive;
    LONG NumberOfActive;
    HANDLE ExclusiveOwnerThread;
    ULONG Flags;        // See RTL_RESOURCE_FLAG_ equates below.
    RTL_RESOURCE_DEBUG* DebugInfo;
   };

public:
  ReaderWriter (bool can_throw);

  ~ReaderWriter (void);

  bool close (void);

  bool acquire (void);

  bool tryacquire (void);

  bool release (void);

  // Release lock 

  bool acquire_read (void);
  bool acquire_write (void);

  bool tryacquire_read (void);
  bool tryacquire_write (void);

  void upgrade();
  void downgrade();

  bool valid() const { return initialized_;}

  const ReaderWriter &lock (void) const;
  // Return the underlying mutex.

  void dump( void ) const;

private:

  RTL_RESOURCE lock_;
  bool initialized_;
  bool can_throw_;
  void raise_exception();

private:
  // = Prevent assignment and initialization.
  void operator= (ReaderWriter &);
  ReaderWriter (const ReaderWriter &);
};

inline void 
ReaderWriter::raise_exception()
{
  if (can_throw_)
	throw CX_MemoryException();
};
#endif
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\winmgmt\wbemcomn\lockst.h ===
#ifndef __LOCKST_H__
#define __LOCKST_H__

#include "locks.h"
#include <assert.h>
# pragma once

#define CS_GUARD(name_of_lock , source_of_lock ) \
LockGuard<CriticalSection> name_of_lock(source_of_lock); 

#define CS_GUARD_RETURN(name_of_lock , source_of_lock, return_code_of_lock ) \
LockGuard<CriticalSection> name_of_lock(source_of_lock); \
if (name_of_lock.locked() == false) \
	return (return_code_of_lock); 

#define CS_GUARD_RETURN_VOID(name_of_lock , source_of_lock) \
LockGuard<CriticalSection> name_of_lock(source_of_lock); \
if (name_of_lock.locked() == false) \
	return ; 
 
template <class LOCK, class EXCEPTION_STRATEGY = wminothrow_t>
class LockGuard
{
  //     It performs automatic aquisition and release of
  //     a parameterized synchronization object <LOCK>.
public:

  // = Initialization and termination methods.
  LockGuard (LOCK &l);
  LockGuard (LOCK &l, bool block);
  // Implicitly and automatically acquire (or try to acquire) the
  // lock.

  ~LockGuard (void);
  // Implicitly release the lock.
  // = Lock accessors.
  bool acquire (void);
  // Explicitly acquire the lock.

  bool tryacquire (void);
  // Conditionally acquire the lock (i.e., won't block).

  bool release (void);
  // Explicitly release the lock, but only if it is held!

  bool locked (void);
  // true if locked, false if couldn't acquire the lock
  bool valid() { return lock_->valid();};

  void dump (void) const;
  // Dump the state of an object.

protected:
  bool raise_exception(void)
  {
	if (!owner_)
		EXCEPTION_STRATEGY::raise_lock_failure();
	return owner_;
  }
  LockGuard (LOCK *lock): lock_ (lock) { }
  // Helper, meant for subclass only.

  LOCK *lock_;
  // Pointer to the LOCK we're LockGuarding.
  bool owner_;
  // Keeps track of whether we acquired the lock or failed.
private:
  // = Prevent assignment and initialization.
  void operator= (const LockGuard<LOCK,EXCEPTION_STRATEGY> &);
  LockGuard (const LockGuard<LOCK,EXCEPTION_STRATEGY> &);
};

template <class LOCK, class EXCEPTION_STRATEGY = wminothrow_t>
class ReadLockGuard : public LockGuard<LOCK,EXCEPTION_STRATEGY>
{
public:
	ReadLockGuard(LOCK& lock):LockGuard(&lock){ aquire();}
	ReadLockGuard(LOCK& lock, bool block);
	~ReadLockGuard(){ release() }
  bool acquire (void)
  {
	assert(owner_==false);
	owner_ = lock_->acquire_read ();
	return raise_exception();
  };
  bool tryacquire (void)
  {
	assert(owner_==false);
	owner_ = lock_->tryacquire_read ();
	return raise_exception();
  }
  bool release (void)
  { if (owner_) 
	{
		owner_ = false;
		lock_->release();
	}else
		return false;
  }
};

template <class LOCK, class EXCEPTION_STRATEGY = wminothrow_t>
class WriteLockGuard : public LockGuard<LOCK,EXCEPTION_STRATEGY>
{
public:
	WriteLockGuard(LOCK& lock):LockGuard(&lock){ aquire();}
	WriteLockGuard(LOCK& lock, bool block);
	~WriteLockGuard(){ release(); }
  bool acquire (void)
  {
	assert(owner_==false);
	owner_ = lock_->acquire_write ();
	return raise_exception();
  };
  bool tryacquire (void)
  {
	assert(owner_==false);
	owner_ = lock_->tryacquire_write ();
	return raise_exception();
  }
  bool release (void)
  { if (owner_) 
	{
		owner_ = false;
		lock_->release ();
	}else
		return false;
  }
};

template <class LOCK, class EXCEPTION_STRATEGY> inline bool
LockGuard<LOCK,EXCEPTION_STRATEGY>::acquire (void)
{
  assert(owner_==false);
  owner_ = lock_->acquire ();
  return raise_exception();
}

template <class LOCK, class EXCEPTION_STRATEGY> inline bool
LockGuard<LOCK,EXCEPTION_STRATEGY>::tryacquire (void)
{
  assert(owner_==false);
  owner_ = lock_->tryacquire ();
  return raise_exception();
}

template <class LOCK, class EXCEPTION_STRATEGY> inline bool
LockGuard<LOCK,EXCEPTION_STRATEGY>::release (void)
{
  if (owner_)
    {
      owner_ = false;
      return lock_->release ();
    }
  else
    return 0;
}

template <class LOCK, class EXCEPTION_STRATEGY> inline
LockGuard<LOCK,EXCEPTION_STRATEGY>::LockGuard (LOCK &l)
  : lock_ (&l),
    owner_ (false)
{
  acquire ();
}

template <class LOCK, class EXCEPTION_STRATEGY> inline
LockGuard<LOCK,EXCEPTION_STRATEGY>::LockGuard (LOCK &l, bool block)
  : lock_ (&l),   owner_ (false)
{
  if (block)
    acquire ();
  else
    tryacquire ();
}


template <class LOCK, class EXCEPTION_STRATEGY> inline
LockGuard<LOCK,EXCEPTION_STRATEGY>::~LockGuard (void)
{
  release ();
}

template <class LOCK, class EXCEPTION_STRATEGY> inline bool
LockGuard<LOCK,EXCEPTION_STRATEGY>::locked (void)
{
  return owner_;
}

template <class LOCK, class EXCEPTION_STRATEGY> inline
ReadLockGuard<LOCK,EXCEPTION_STRATEGY>::ReadLockGuard (LOCK &l, bool block)
  : LockGuard (&l),   owner_ (false)
{
  if (block)
    acquire ();
  else
    tryacquire ();
}

template <class LOCK, class EXCEPTION_STRATEGY> inline
WriteLockGuard<LOCK,EXCEPTION_STRATEGY>::WriteLockGuard (LOCK &l, bool block)
  : LockGuard (&l),   owner_ (false)
{
  if (block)
    acquire ();
  else
    tryacquire ();
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\winmgmt\wbemcomn\md5wbem.h ===
//***************************************************************************
//
//  MD5.H
//
//  MD5 Message Digest 
//
//  raymcc  21-Apr-97   Adapted Ron Rivest's source from RFC 1321.
//
//  This implementation was checked against a reference suite
//  on 24-Apr-97.  Do NOT ALTER the source code for any reason!
//
//  ------------------------------------------------------------------
//
//  Copyright (C) 1991-2, RSA Data Security, Inc. Created 1991. All
//  rights reserved.
//
//  License to copy and use this software is granted provided that it
//  is identified as the "RSA Data Security, Inc. MD5 Message-Digest
//  Algorithm" in all material mentioning or referencing this software
//  or this function.
//
//  License is also granted to make and use derivative works provided
//  that such works are identified as "derived from the RSA Data
//  Security, Inc. MD5 Message-Digest Algorithm" in all material
//  mentioning or referencing the derived work.
//
//  RSA Data Security, Inc. makes no representations concerning either
//  the merchantability of this software or the suitability of this
//  software for any particular purpose. It is provided "as is"
//  without express or implied warranty of any kind.
//
//***************************************************************************

#ifndef _MD5WBEM_H_
#define _MD5WBEM_H_
#include "corepol.h"

class POLARITY MD5
{
public:
    static void Transform(
        IN  LPVOID pInputValue,         // Value to be digested
        IN  UINT   uValueLength,        // Length of value, 0 is legal
        OUT BYTE   MD5Buffer[16]        // Receives the MD5 hash
        );    
    static void ContinueTransform(
        IN  LPVOID  pInputValue, 
        IN  UINT    uValueLength,
        IN OUT BYTE    MD5Buffer[16]
        );
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\winmgmt\wbemcomn\mkdir.cpp ===
/*++

Copyright (C) 1996-2001 Microsoft Corporation

Module Name:

    MKDIR.CPP

Abstract:

    Creates directories

History:

--*/
#include "precomp.h"

#include "corepol.h"
#include <sys/types.h>
#include <sys/stat.h>
#include <mbstring.h>
#include <helper.h>
#include <sddl.h>
#include <accctrl.h>
#include <aclapi.h>


class CTmpStrException
{
};

class TmpStr
{
private:
    TCHAR *pString;
public:
    TmpStr() : 
        pString(NULL)
    {
    }
    ~TmpStr() 
    { 
        delete [] pString; 
    }
    TmpStr &operator =(const TCHAR *szStr)
    {
        delete [] pString;
        pString = NULL;
        if (szStr)
        {
        	size_t stringSize = lstrlen(szStr) + 1;
            pString = new TCHAR[stringSize];
            
            if (!pString)
                throw CTmpStrException();

            StringCchCopy(pString, stringSize, szStr);
        }
        return *this;
    }
    operator const TCHAR *() const
    {
        return pString;
    }
    TCHAR Right(int i)
    {
        if (pString && (lstrlen(pString) >= i))
        {
            return pString[lstrlen(pString) - i];
        }
        else
        {
            return '\0';
        }
    }
    TmpStr &operator +=(const TCHAR ch)
    {
        if (pString)
        {
        	size_t stringLength = lstrlen(pString) + 2;
            TCHAR *tmpstr = new TCHAR[stringLength];
            
            if (!tmpstr)
                throw CTmpStrException();

            StringCchCopy(tmpstr, stringLength, pString);
            tmpstr[lstrlen(pString)] = ch;
            tmpstr[lstrlen(pString) + 1] = TEXT('\0');

            delete [] pString;
            pString = tmpstr;
        }
        else
        {
            TCHAR *tmpstr = new TCHAR[2];

            if (!tmpstr)
                throw CTmpStrException();

            tmpstr[0] = ch;
            tmpstr[1] = TEXT('\0');
            pString = tmpstr;
        }
        return *this;
    }
    TmpStr &operator +=(const TCHAR *sz)
    {
        if (sz && pString)
        {
        	size_t stringLength = lstrlen(pString) + lstrlen(sz) + 1;
            TCHAR *tmpstr = new TCHAR[stringLength];

            if (!tmpstr)
                throw CTmpStrException();

            StringCchCopy(tmpstr,stringLength, pString);
            StringCchCat(tmpstr, stringLength, sz);

            delete [] pString;
            pString = tmpstr;
        }
        else if (sz)
        {
        	size_t stringLength = lstrlen(sz) + 1;
            TCHAR *tmpstr = new TCHAR[stringLength];

            if (!tmpstr)
                throw CTmpStrException();

            StringCchCopy(tmpstr, stringLength, sz);
            pString = tmpstr;
        }
        return *this;
    }



};

BOOL POLARITY WbemCreateDirectory(const wchar_t *pszDirName)
{
    BOOL bStat = TRUE;
    wchar_t *pCurrent = NULL;
    size_t stringLength = wcslen(pszDirName) + 1;
    wchar_t *pDirName = new wchar_t[stringLength];

    if (!pDirName)
        return FALSE;

    StringCchCopy(pDirName, stringLength, pszDirName);

    try
    {
        TmpStr szDirName;
        pCurrent = wcstok(pDirName, TEXT("\\"));
        szDirName = pCurrent;

        while (pCurrent)
        {
            if ((pCurrent[lstrlen(pCurrent)-1] != ':') &&   //This is "<drive>:\\"
                (pCurrent[0] != TEXT('\\')))  //There is double slash in name 
            {

                struct _stat stats;
                int dwstat = _wstat(szDirName, &stats);
                if ((dwstat == 0) &&
                    !(stats.st_mode & _S_IFDIR))
                {
                    bStat = FALSE;
                    break;
                }
                else if (dwstat == -1)
                {
                    DWORD dwStatus = GetLastError();
                    if (!CreateDirectory(szDirName, 0))
                    {
                        bStat = FALSE;
                        break;
                    }
                }
                // else it exists already
            }

            szDirName += TEXT('\\');
            pCurrent = wcstok(0, TEXT("\\"));
            szDirName += pCurrent;
        }
    }
    catch(...)
    {
        bStat = FALSE;
    }

    delete [] pDirName;

    return bStat;
}

//
//  Test for directory Existence
//  if the name is a file, it deletes it.
//  if the directory is not found, then it creates the directory
//  with the specified Security descriptor
//
///////////////////////////////////////////////////////

HRESULT POLARITY TestDirExistAndCreateWithSDIfNotThere(TCHAR * pDirectory, TCHAR * pSDDLString)
{
    DWORD dwRes = 0;
    DWORD dwAttr  = GetFileAttributes(pDirectory);
    
    dwRes = GetLastError();        
    if (INVALID_FILE_ATTRIBUTES != dwAttr)
    {

	    if (FILE_ATTRIBUTE_DIRECTORY & dwAttr)
	    {
	        // it's there and it's a directory
	        return S_OK;
	    }
	    // it can be a file, wipe it out
        if (FALSE == DeleteFile(pDirectory)) 
        	return MAKE_HRESULT(SEVERITY_ERROR, FACILITY_WIN32,GetLastError());
        else
            dwRes = ERROR_PATH_NOT_FOUND;
    }

    // if here, the directory was not found, or it was found as a file
    
    if (ERROR_FILE_NOT_FOUND == dwRes ||
      ERROR_PATH_NOT_FOUND == dwRes)
    {
	    PSECURITY_DESCRIPTOR pSD = NULL;
	    if (FALSE == ConvertStringSecurityDescriptorToSecurityDescriptor(pSDDLString,
	                                                SDDL_REVISION_1, 
	                                                &pSD, 
	                                                NULL)) return MAKE_HRESULT(SEVERITY_ERROR, FACILITY_WIN32,GetLastError());
	    OnDelete<HLOCAL,HLOCAL(*)(HLOCAL),LocalFree> dm1(pSD);

        SECURITY_ATTRIBUTES SecAttr = {sizeof(SecAttr),pSD,FALSE};
        if (FALSE == CreateDirectory(pDirectory,&SecAttr)) 
        	dwRes = GetLastError();
        else 
        	dwRes = ERROR_SUCCESS;
    }
    if (ERROR_SUCCESS != dwRes)
       	return MAKE_HRESULT(SEVERITY_ERROR, FACILITY_WIN32, dwRes);
    else
    	return S_OK;

};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\winmgmt\wbemcomn\mrcicode.cpp ===
/*++

Copyright (C) 1994-2001 Microsoft Corporation

Module Name:

    MRCICODE.CPP

Abstract:

    MRCI 1 & MRCI 2 maxcompress and decompress functions

History:

--*/

#include "precomp.h"
#include "mrcicode.h"                   /* prototype verification */

#ifndef NDEBUG
#define NDEBUG                          /* turn off assertions */
#endif
#include <assert.h>                     /* use NDEBUG to inhibit */


#define hash(w)         ((w) & (CHASH - 1))
                                        /* Simply toss the high-order bits */
#define word(p)         ((p)[0] + (((p)[1]) << 8))
                                        /* Return word at location */

#define BITMASK(x)      ((1 << x) - 1)  /* returns lower 'x' bits set */

#define MINDISPSMALL    (0)             /* Minimum small displacement */
#define MINDISPMED      (MAXDISPSMALL + 1)
                                        /* Minimum medium displacement */
#define MINDISPBIG      (MAXDISPMED + 1)/* Minimum big displacement */

#define DISPMAX         (MAXDISPBIG - 1)/* MAXDISPBIG is our end marker */

#define MINMATCH1       (2)             /* Minimum match length for MRCI1 */
#define MINMATCH2       (3)             /* Minimum match length for MRCI2 */
#define MAXMATCH        (512)           /* Maximum match length */

#define EOB             (0)             /* length used to mean end of block */

#define SECTOR          (512)           /* blocking factor */

#define SIG_SIZE        (4)             /* # of block type prefix bytes */


/*
 *  (compress) Reset the hash tables between blocks.
 */

void CBaseMrciCompression::inithash(void)
{
    unsigned *entry;
    int i;

    entry = ahash;
    i = CHASH;

    do
    {
        *entry++ = (unsigned) -1;       /* Mark all entries as empty */
    } while (--i);
}


/*
 *  (compress) Add a character to compressed output buffer.
 */

void CBaseMrciCompression::charbuf(unsigned c)
{
    if (cCompressed-- == 0)             /* make sure there's room */
    {
        throw 1;						/* Data expanding! */
    }

    *pCompressed++ = (unsigned char) c; /* Put character into buffer */
}


/*
 *  (compress) Write n bits to the compressed bitstream.
 */

void CBaseMrciCompression::putbits(unsigned ab,unsigned cbits)
{
    do                                  /* Loop to emit bits */
    {
        if (cbits > cbitsleft)          /* if not enough space */
        {
            cbits -= cbitsleft;         /* doing partial */

            abits |= (ab << (8 - cbitsleft));
                                        /* Put bits in output buffer */

            ab >>= cbitsleft;           /* clip sent bits */

            charbuf(abits);             /* Emit the buffer */
            cbitsleft = 8;              /* Reset buffer count */
            abits = 0;                  /* Reset buffer */
        }
        else                            /* can do all in one pass */
        {
            abits |= ((ab & BITMASK(cbits)) << (8 - cbitsleft));
                                        /* Put bits in output buffer */

            cbitsleft -= cbits;         /* used up some buffer */

            if (cbitsleft == 0)         /* If buffer full */
            {
                charbuf(abits);         /* Emit the buffer */
                cbitsleft = 8;          /* Reset buffer count */
                abits = 0;              /* Reset buffer */
            }

            break;                      /* we've done all cbits */
        }
    } while (cbits);                    /* repeat until done */
}


/*
 *  (compress) Encode a length into the compressed stream.
 */

void CBaseMrciCompression::outlength(unsigned cb)
{
    unsigned alogbits, clogbits;
    unsigned avaluebits, cvaluebits;

    assert(cb >= 2);                    /* Length must be at least two */
    assert(cb <= MAXMATCH);

    if (cb <= 2)
    {
        alogbits = 1;
        clogbits = 1;
        cvaluebits = 0;
    }
    else if (cb <= 4)
    {
        alogbits = 1 << 1;
        clogbits = 2;
        avaluebits = cb - 3;
        cvaluebits = 1;
    }
    else if (cb <= 8)
    {
        alogbits = 1 << 2;
        clogbits = 3;
        avaluebits = cb - 5;
        cvaluebits = 2;
    }
    else if (cb <= 16)
    {
        alogbits = 1 << 3;
        clogbits = 4;
        avaluebits = cb - 9;
        cvaluebits = 3;
    }
    else if (cb <= 32)
    {
        alogbits = 1 << 4;
        clogbits = 5;
        avaluebits = cb - 17;
        cvaluebits = 4;
    }
    else if (cb <= 64)
    {
        alogbits = 1 << 5;
        clogbits = 6;
        avaluebits = cb - 33;
        cvaluebits = 5;
    }
    else if (cb <= 128)
    {
        alogbits = 1 << 6;
        clogbits = 7;
        avaluebits = cb - 65;
        cvaluebits = 6;
    }
    else if (cb <= 256)
    {
        alogbits = 1 << 7;
        clogbits = 8;
        avaluebits = cb - 129;
        cvaluebits = 7;
    }
    else /* (cb <= 512) */
    {
        alogbits = 1 << 8;
        clogbits = 9;
        avaluebits = cb - 257;
        cvaluebits = 8;
    }

    putbits(alogbits,clogbits);

    if (cvaluebits)
    {
        putbits(avaluebits,cvaluebits);
    }
}


/*
 *  (MRCI1 compress) Encode a literal into the compressed stream.
 */

void CBaseMrciCompression::mrci1outsingle(unsigned ch)
{
    ch = (ch << 2) | ((ch & 0x80) ? 1 : 2);

    putbits(ch,9);
}


/*
 *  (MRCI2 compress) Encode a literal into the compressed stream.
 */

void CBaseMrciCompression::mrci2outsingle(unsigned ch)
{
    if (ch & 0x80)
    {
        putbits((ch << 2) | 3,9);
    }
    else
    {
        putbits(ch << 1,8);
    }
}


/*
 *  (MRCI1 compress) Encode a match into the compressed stream.
 */

void CBaseMrciCompression::mrci1outstring(unsigned disp,unsigned cb)
{
    assert(((cb >= MINMATCH1) && (disp != 0) && (disp < MAXDISPBIG)) ||
            ((cb == EOB) && (disp == MAXDISPBIG)));

    if (disp <= MAXDISPSMALL)
    {
        putbits(((disp - MINDISPSMALL) << 2),LOGDISPSMALL + 2);
                                        /* Put small displacement */
    }
    else if (disp <= MAXDISPMED)
    {
        putbits(((disp - MINDISPMED) << 3) | 3,LOGDISPMED + 3);
                                        /* Put medium displacement */
    }
    else
    {
        putbits(((disp - MINDISPBIG) << 3) | 7,LOGDISPBIG + 3);
                                        /* Put big displacement */
    }

    if (cb != EOB)                      /* If not an end marker */
    {
        outlength(cb);                  /* Emit the match length */
    }
}


/*
 *  (MRCI2 compress) Encode a match into the compressed stream.
 */

void CBaseMrciCompression::mrci2outstring(unsigned disp,unsigned cb)
{
    assert(((cb >= MINMATCH2) && (disp != 0) && (disp < MAXDISPBIG)) ||
            ((cb == EOB) && (disp == MAXDISPBIG)));

    if (disp <= MAXDISPSMALL)
    {
        putbits(((disp - MINDISPSMALL) << 3) | 1,LOGDISPSMALL + 3);
                                        /* Put small displacement */
    }
    else if (disp <= MAXDISPMED)
    {
        putbits(((disp - MINDISPMED) << 4) | 5,LOGDISPMED + 4);
                                        /* Put medium displacement */
    }
    else
    {
        putbits(((disp - MINDISPBIG) << 4) | 13,LOGDISPBIG + 4);
                                        /* Put big displacement */
    }

    if (cb != EOB)                      /* If not an end marker */
    {
        outlength(cb - 1);              /* Emit the match length */
    }
}


/*
 *  (MRCI1) MaxCompress
 */

unsigned CBaseMrciCompression::Mrci1MaxCompress(unsigned char *pchbase,unsigned cchunc,
        unsigned char *pchcmpBase,unsigned cchcmpMax)
{
    unsigned cchbest;                   /* Length of best match */
    unsigned cchmatch;                  /* Length of this match */
    unsigned ibest;                     /* Position of best match */
    unsigned icur;                      /* Current position */
    unsigned ihash;                     /* Hash table index */
    unsigned ilink;                     /* Link index */
    unsigned char *pch;             /* Char pointer */
    unsigned char *pch2;            /* Char pointer */
    unsigned char *pchend;          /* End of input (-> last valid) */
    unsigned cch;                       /* per-pass limit */

    cbitsleft = 8;                      /* Buffer is empty */
    abits = 0;
    pCompressed = pchcmpBase;           /* Initialize pointer */

    if (cchunc < cchcmpMax)
    {
        cCompressed = cchunc;           /* limit to source size */
    }
    else
    {
        cCompressed = cchcmpMax;        /* limit to max size offered */
    }

    if (cCompressed < SIG_SIZE)
    {
        return((unsigned) -1);
    }

    *pCompressed++ = 'D';
    *pCompressed++ = 'S';
    *pCompressed++ = '\x00';
    *pCompressed++ = '\x01';

    cCompressed -= SIG_SIZE;

    pch = pchbase;                      /* Initialize */

    if (cchunc-- == 0)
    {
        return(0);                      /* Do nothing to empty buffer */
    }

    inithash();                         /* Initialize tables */

	try
	{
		cchbest = 0;                        /* no match yet */
		icur = 0;                           /* Initialize */

		for (cch = SECTOR - 1; cch <= (cchunc + SECTOR - 1); cch += SECTOR)
		{
			assert(cchbest == 0);           /* must always start with no match */

			if (cch > cchunc)
			{
				cch = cchunc;               /* limit to exact req count */
			}

			pchend = &pchbase[cch];         /* Remember end of buffer */

			while (icur < cch)              /* While at least two chars left */
			{
				/* update hash tables for this character */

				ihash = hash(word(&pchbase[icur]));
											/* Get hash index */
				ilink = ahash[ihash];       /* Get link index */
				ahash[ihash] = icur;        /* Remember position */
				alink[icur % MAXDISPBIG] = ilink;
											/* Chain on rest of list */

				/* walk hash chain looking for matches */

				while (ilink < icur && icur - ilink <= DISPMAX)
				{                           /* While link is valid and in range */
					pch = &pchbase[icur];   /* Point at first byte */
					pch2 = &pchbase[ilink]; /* Point at first byte */

					if (pch[cchbest] == pch2[cchbest] && word(pch) == word(pch2))
					{                       /* If we have a possible best match */
						pch += 2;           /* Skip first pair */
						pch2 += 2;          /* Skip first pair */

						while (pch <= pchend)  /* Loop to find end of match */
						{
							if (*pch != *pch2++)
							{
								break;      /* Break if mismatch */
							}
							pch++;          /* Skip matching character */
						}

						if ((cchmatch = (unsigned)(pch - pchbase) - icur) > cchbest)
						{                   /* If new best match */
							cchbest = cchmatch;  /* Remember length */
							ibest = ilink;  /* Remember position */

							assert((pch-1) <= pchend);

							if (pch > pchend)
							{
								break;      /* Break if we can't do any better */
							}
						}
					}

					assert((alink[ilink % MAXDISPBIG] == (unsigned) -1) ||
							(alink[ilink % MAXDISPBIG] < ilink));

					ilink = alink[ilink % MAXDISPBIG];
											/* Get next link */
				}   /* until end of hash chain reached */

				if (cchbest >= MINMATCH1)   /* If we have a string match */
				{
					mrci1outstring(icur - ibest,cchbest);
											/* Describe matching string */
	#ifdef VXD
					if (icur + cchbest >= cch )  /* If end of sector reached */
	#else
					if (icur + cchbest >= cchunc)  /* If end of buffer reached */
	#endif
					{
						icur += cchbest;    /* Advance the index */
						cchbest = 0;        /* reset for next match */
						break;              /* Done if buffer exhausted */
					}

					icur++;                 /* Skip to first unhashed pair */
	#ifdef VXD
					/* avoid re-seeding all of a big match */

					if (cchbest > MAXDISPSMALL)
					{                       /* If big match */
						icur += cchbest - MAXDISPSMALL - 1;
											/* Skip ahead */
						cchbest = MAXDISPSMALL + 1;
											/* Use shorter length */
					}
	#endif
					/* update hash tables for each add't char in string */

					ibest = icur % MAXDISPBIG;  /* Get current link table index */

					while (--cchbest != 0)  /* Loop to reseed link table */
					{
						ihash = hash(word(&pchbase[icur]));
											/* Get hash index */
						ilink = ahash[ihash];  /* Get link index */
						ahash[ihash] = icur++;  /* Remember position */
						alink[ibest] = ilink;  /* Chain on rest of list */

						if (++ibest < MAXDISPBIG)
						{
							continue;       /* Loop if we haven't wrapped yet */
						}

						ibest = 0;          /* Wrap to zero */
					}

					assert(cchbest == 0);   /* Counter must be 0 */
				}
				else
				{
					mrci1outsingle(pchbase[icur++]);
											/* Else output single character */
					cchbest = 0;            /* Reset counter */
				}
			}

			assert(icur == cch || icur == cch + 1);
											/* Must be at or past last character */
			if (icur == cch)
			{
	#ifndef VXD
				ihash = hash(word(&pchbase[icur]));
											/* Get hash index */
				ilink = ahash[ihash];       /* Get link index */
				ahash[ihash] = icur;        /* Remember position */
				alink[icur % MAXDISPBIG] = ilink;
											/* Chain on rest of list */
	#endif
				mrci1outsingle(pchbase[icur++]);  /* Output last character */
			}

			assert(icur == cch + 1);        /* Must be past last character */

			mrci1outstring(MAXDISPBIG,EOB);  /* Put out an end marker */
		}

		if (cbitsleft != 8)
		{
			charbuf(abits);                 /* Flush bit buffer */
		}

		if ((unsigned) (pCompressed - pchcmpBase) > cchunc)
		{
			return((unsigned) -1);          /* data expanded or not smaller */
		}
	}
	catch(int i)
	{
		return -1;
	}

    return(pCompressed - pchcmpBase);   /* Return compressed size */
}


/*
 *  (MRCI2) MaxCompress
 */

unsigned CBaseMrciCompression::Mrci2MaxCompress(unsigned char *pchbase,unsigned cchunc,
        unsigned char *pchcmpBase,unsigned cchcmpMax)
{
    unsigned cchbest;                   /* Length of best match */
    unsigned cchmatch;                  /* Length of this match */
    unsigned ibest;                     /* Position of best match */
    unsigned icur;                      /* Current position */
    unsigned ihash;                     /* Hash table index */
    unsigned ilink;                     /* Link index */
    unsigned char *pch;             /* Char pointer */
    unsigned char *pch2;            /* Char pointer */
    unsigned char *pchend;          /* End of input (-> last valid) */
    unsigned cch;                       /* per-pass limit */

    cbitsleft = 8;                      /* Buffer is empty */
    abits = 0;
    pCompressed = pchcmpBase;           /* Initialize pointer */

    if (cchunc < cchcmpMax)
    {
        cCompressed = cchunc;           /* limit to source size */
    }
    else
    {
        cCompressed = cchcmpMax;        /* limit to max size offered */
    }

    if (cCompressed < SIG_SIZE)
    {
        return((unsigned) -1);
    }

    *pCompressed++ = 'J';
    *pCompressed++ = 'M';
    *pCompressed++ = '\x00';
    *pCompressed++ = '\x01';

    cCompressed -= SIG_SIZE;

    pch = pchbase;                      /* Initialize */

    if (cchunc-- == 0)
    {
        return(0);                      /* Do nothing to empty buffer */
    }

    inithash();                         /* Initialize tables */

    try
	{
		cchbest = 0;                        /* no match yet */
		icur = 0;                           /* Initialize */

		for (cch = SECTOR - 1; cch <= (cchunc + SECTOR - 1); cch += SECTOR)
		{
			assert(cchbest == 0);           /* must always start with no match */

			if (cch > cchunc)
			{
				cch = cchunc;               /* limit to exact req count */
			}

			pchend = &pchbase[cch];         /* Remember end of buffer */

			while (icur < cch)              /* While at least two chars left */
			{
				/* update hash tables for this character */

				ihash = hash(word(&pchbase[icur]));
											/* Get hash index */
				ilink = ahash[ihash];       /* Get link index */
				ahash[ihash] = icur;        /* Remember position */
				alink[icur % MAXDISPBIG] = ilink;
											/* Chain on rest of list */

				/* walk hash chain looking for matches */

				while (ilink < icur && icur - ilink <= DISPMAX)
				{                           /* While link is valid and in range */
					pch = &pchbase[icur];   /* Point at first byte */
					pch2 = &pchbase[ilink]; /* Point at first byte */

					if (pch[cchbest] == pch2[cchbest] && word(pch) == word(pch2))
					{                       /* If we have a possible best match */
						pch += 2;           /* Skip first pair */
						pch2 += 2;          /* Skip first pair */

						while (pch <= pchend)  /* Loop to find end of match */
						{
							if (*pch != *pch2++)
							{
								break;      /* Break if mismatch */
							}
							pch++;          /* Skip matching character */
						}

						if ((cchmatch = (unsigned)(pch - pchbase) - icur) > cchbest)
						{                   /* If new best match */
							cchbest = cchmatch;  /* Remember length */
							ibest = ilink;  /* Remember position */

							assert((pch-1) <= pchend);

							if (pch > pchend)
							{
								break;      /* Break if we can't do any better */
							}
						}
					}

					assert((alink[ilink % MAXDISPBIG] == (unsigned) -1) ||
							(alink[ilink % MAXDISPBIG] < ilink));

					ilink = alink[ilink % MAXDISPBIG];
											/* Get next link */
				}   /* until end of hash chain reached */

				if (cchbest >= MINMATCH2)   /* If we have a string match */
				{
					mrci2outstring(icur - ibest,cchbest);
											/* Describe matching string */
	#ifdef VXD
					if (icur + cchbest >= cch )  /* If end of sector reached */
	#else
					if (icur + cchbest >= cchunc)  /* If end of buffer reached */
	#endif
					{
						icur += cchbest;    /* Advance the index */
						cchbest = 0;        /* reset for next match */
						break;              /* Done if buffer exhausted */
					}

					icur++;                 /* Skip to first unhashed pair */
	#ifdef VXD
					/* avoid re-seeding all of a big match */

					if (cchbest > MAXDISPSMALL)
					{                       /* If big match */
						icur += cchbest - MAXDISPSMALL - 1;
											/* Skip ahead */
						cchbest = MAXDISPSMALL + 1;
											/* Use shorter length */
					}
	#endif
					/* update hash tables for each add't char in string */

					ibest = icur % MAXDISPBIG;  /* Get current link table index */

					while (--cchbest != 0)  /* Loop to reseed link table */
					{
						ihash = hash(word(&pchbase[icur]));
											/* Get hash index */
						ilink = ahash[ihash];  /* Get link index */
						ahash[ihash] = icur++;  /* Remember position */
						alink[ibest] = ilink;  /* Chain on rest of list */

						if (++ibest < MAXDISPBIG)
						{
							continue;       /* Loop if we haven't wrapped yet */
						}

						ibest = 0;          /* Wrap to zero */
					}

					assert(cchbest == 0);   /* Counter must be 0 */
				}
				else
				{
					mrci2outsingle(pchbase[icur++]);
											/* Else output single character */
					cchbest = 0;            /* Reset counter */
				}
			}

			assert(icur == cch || icur == cch + 1);
											/* Must be at or past last character */
			if (icur == cch)
			{
	#ifndef VXD
				ihash = hash(word(&pchbase[icur]));
											/* Get hash index */
				ilink = ahash[ihash];       /* Get link index */
				ahash[ihash] = icur;        /* Remember position */
				alink[icur % MAXDISPBIG] = ilink;
											/* Chain on rest of list */
	#endif
				mrci2outsingle(pchbase[icur++]);  /* Output last character */
			}

			assert(icur == cch + 1);        /* Must be past last character */

			mrci2outstring(MAXDISPBIG,EOB);  /* Put out an end marker */
		}

		if (cbitsleft != 8)
		{
			charbuf(abits);                 /* Flush bit buffer */
		}

		if ((unsigned) (pCompressed - pchcmpBase) > cchunc)
		{
			return((unsigned) -1);          /* data expanded or not smaller */
		}
	}
	catch(int i)
	{
		return -1;
	}

    return(pCompressed - pchcmpBase);   /* Return compressed size */
}


/*
 *  (decompress) Get a single bit from the compressed input stream.
 */

unsigned CBaseMrciCompression::getbit(void)
{
    unsigned bit;                       /* Bit */

    if (cbitsleft)                      /* If bits available */
    {
        cbitsleft--;                    /* Decrement bit count */

        bit = abits & 1;                /* Get a bit */

        abits >>= 1;                    /* Remove it */
    }
    else                                /* no bits available */
    {
        if (cCompressed-- == 0)         /* If buffer empty */
        {
            throw 1;					/* input overrun */
        }

        cbitsleft = 7;                  /* Reset count */

        abits = *pCompressed++;         /* Get a byte */

        bit = abits & 1;                /* Get a bit */

        abits >>= 1;                    /* Remove it */
    }

    return(bit);                        /* Return the bit */
}


/*
 *  (decompress) Get multiple bits from the compressed input stream.
 */

unsigned CBaseMrciCompression::getbits(unsigned cbits)
{
    unsigned bits;                      /* Bits to return */
    unsigned cbitsdone;                 /* number of bits added so far */
    unsigned cbitsneeded;               /* number of bits still needed */

    if (cbits <= cbitsleft)             /* If we have enough bits */
    {
        bits = abits;                   /* Get the bits */
        cbitsleft -= cbits;             /* Decrement bit count */
        abits >>= cbits;                /* Remove used bits */
    }
    else                                /* If we'll need to read more bits */
    {
        bits = 0;                       /* No bits set yet */
        cbitsdone = 0;                  /* no bits added yet */
        cbitsneeded = cbits;            /* bits needed */

        do
        {
            if (cbitsleft == 0)         /* If no bits ready */
            {
                if (cCompressed-- == 0) /* count down used */
                {
                    throw 1;			/* if input overrun */
                }

                cbitsleft = 8;          /* Reset count */

                abits = *pCompressed++;  /* Get 8 new bits */
            }

            bits |= (abits << cbitsdone);  /* copy bits for output */

            if (cbitsleft >= cbitsneeded)  /* if enough now */
            {
                cbitsleft -= cbitsneeded;  /* reduce bits remaining available */
                abits >>= cbitsneeded;  /* discard used bits */
                break;                  /* got them */
            }
            else                        /* if not enough yet */
            {
                cbitsneeded -= cbitsleft;  /* reduce bits still needed */
                cbitsdone += cbitsleft;  /* increase shift for future bits */
                cbitsleft = 0;          /* reduce bits remaining available */
            }
        } while (cbitsneeded);          /* go back if more bits needed */
    }

    return(bits & BITMASK(cbits));      /* Return the bits */
}


/*
 *  (decompress) Expand a match.
 *
 *  Note: source overwrite is required (so we can't memcpy or memmove)
 */

void CBaseMrciCompression::expandstring(unsigned char **ppchout,unsigned disp,
        unsigned cb)
{
    unsigned char *source;
    unsigned char *target;

    assert(cb != 0);

    target = *ppchout;                  /* where the bytes go */
    source = target - disp;             /* where the bytes come from */

    *ppchout += cb;                     /* Update the output pointer */

    while (cb--)
    {
        *target++ = *source++;
    }
}


/*
 *  (MRCI1) Decompress
 */

unsigned CBaseMrciCompression::Mrci1Decompress(unsigned char *pchin,unsigned cchin,
        unsigned char *pchdecBase,unsigned cchdecMax)
{
    unsigned b;                         /* A byte */
    unsigned length;                    /* Length of match */
    unsigned disp;                      /* Displacement */
    unsigned char *pchout;          /* Output buffer pointer */

    abits = 0;                          /* Bit buffer is empty */
    cbitsleft = 0;                      /* No bits read yet */
    pCompressed = pchin;                /* setup source pointer */
    cCompressed = cchin;                /* setup source counter */

    if ((cCompressed <= SIG_SIZE) ||    /* must have a signature */
            (*pCompressed++ != 'D') || (*pCompressed++ != 'S'))
    {
        return((unsigned) -1);          /* Data corrupted */
    }

    pCompressed += 2;                   /* ignore flags */
    cCompressed -= SIG_SIZE;

    pchout = pchdecBase;                /* Point at output buffer */

    try
	{
		for (;;)
		{
			b = getbits(2);                 /* get two bits */

			if (b == 1)                     /* If single byte 128..255 */
			{                               /* Get the rest of byte */
				*pchout++ = (unsigned char) (getbits(7) | 0x80);
				continue;                   /* Next token */
			}

			if (b == 2)                     /* If single byte 0..127 */
			{                               /* Get the rest of byte */
				*pchout++ = (unsigned char) getbits(7);
				continue;                   /* Next token */
			}

			if (b == 0)
			{
				disp = getbits(6) + MINDISPSMALL;
			}
			else  /* b == 3 */
			{
				if (getbit() == 0)
				{
					disp = getbits(8) + MINDISPMED;
				}
				else
				{
					disp = getbits(12) + MINDISPBIG;
				}
			}

			if (disp == MAXDISPBIG)
			{
				if ((unsigned) (pchout - pchdecBase) >= cchdecMax)
				{
					break;                  /* End marker found */
				}
				else
				{
					continue;               /* End sector found */
				}
			}

			length = 0;                     /* Initialize */

			while (getbit() == 0)
			{
				length++;                   /* Count the leading zeroes */
			}

			assert(b <= 15);                /* Cannot be too big */

			if (length)
			{
				length = getbits(length) + (1 << length) + 1;
			}
			else
			{
				length = 2;
			}

			expandstring(&pchout,disp,length);  /* Copy the match */
		}
	}
	catch(int i)
	{
		return -1;
	}

    return((pchout - pchdecBase));      /* Return decompressed size */
}


/*
 *  (MRCI2) Decompress
 */

unsigned CBaseMrciCompression::Mrci2Decompress(unsigned char *pchin,unsigned cchin,
        unsigned char *pchdecBase,unsigned cchdecMax)
{
    unsigned length;                    /* Length of match */
    unsigned disp;                      /* Displacement */
    unsigned char *pchout;          /* Output buffer pointer */

    abits = 0;                          /* Bit buffer is empty */
    cbitsleft = 0;                      /* No bits read yet */
    pCompressed = pchin;                /* setup source pointer */
    cCompressed = cchin;                /* setup source counter */

    if ((cCompressed <= SIG_SIZE) ||    /* must have a signature */
            (*pCompressed++ != 'J') || (*pCompressed++ != 'M'))
    {
        return((unsigned) -1);          /* Data corrupted */
    }

    pCompressed += 2;                   /* ignore flags */
    cCompressed -= SIG_SIZE;

    pchout = pchdecBase;                /* Point at output buffer */

    try
	{
		for (;;)
		{
			if (getbit() == 0)              /* literal 00..7F */
			{
				*pchout++ = (unsigned char) getbits(7);

				continue;                   /* Next token */
			}

			if (getbit() == 1)              /* literal 80..FF */
			{
				*pchout++ = (unsigned char)(getbits(7) | 0x80);

				continue;                   /* Next token */
			}

			if (getbit() == 0)
			{
				disp = getbits(6) + MINDISPSMALL;
			}
			else
			{
				if (getbit() == 0)
				{
					disp = getbits(8) + MINDISPMED;
				}
				else
				{
					disp = getbits(12) + MINDISPBIG;
				}
			}

			if (disp == MAXDISPBIG)
			{
				if ((unsigned) (pchout - pchdecBase) >= cchdecMax)
				{
					break;                  /* End marker found */
				}
				else
				{
					continue;               /* End sector found */
				}
			}

			length = 0;                     /* Initialize */

			while (getbit() == 0)
			{
				length++;                   /* Count the leading zeroes */
			}

			assert(length <= 15);           /* Cannot be too big */

			if (length)
			{
				length = getbits(length) + (1 << length) + 1;
			}
			else
			{
				length = 2;
			}

			expandstring(&pchout,disp,length + 1);  /* Copy the match */
		}
	}
	catch(int i)
	{
		return -1;
	}

    return((pchout - pchdecBase));      /* Return decompressed size */
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\winmgmt\wbemcomn\mrciclass.h ===
/*++

Copyright (C) 1997-2001 Microsoft Corporation

Module Name:

    MRCICLASS.H

Abstract:

    Wrapper class for MRCI 1 & MRCI 2 maxcompress 
   and decompress functions

History:

  paulall       1-Jul-97    Created

--*/

#include "MRCIcode.h"

#include "corepol.h"
#define DEFAULT_MRCI_BUFFER_SIZE (32*1024)

class POLARITY CMRCIControl
{
private:
    BOOL bStop;                                 //Do we need to abort compression...

public:
    CMRCIControl() : bStop(FALSE) {}            //Constructor
    void AbortCompression() { bStop = TRUE; }   //Abort the compression request
    BOOL AbortRequested() { return bStop; }     //Queries if an abort was requested
    void Reset() { bStop = FALSE; }             //Reset everything to the norm
};

class POLARITY CMRCICompression : public CBaseMrciCompression
{
public:
    enum CompressionLevel { level1 = 1, 
                            level2 = 2 };

    CMRCICompression();
    ~CMRCICompression();

    BOOL CompressFile(const TCHAR *pchFromFile, 
                      const TCHAR *pchToFile, 
                      DWORD dwBufferSize = DEFAULT_MRCI_BUFFER_SIZE, 
                      CompressionLevel compressionLevel = level1,
                      CMRCIControl *pControlObject = NULL);
    BOOL UncompressFile(const TCHAR *pchFromFile, const TCHAR *pchToFile);

    unsigned CompressBuffer(unsigned char *pFromBuffer,
                        DWORD dwFromBufferSize,
                        unsigned char *pToBuffer,
                        DWORD dwToBufferSize, 
                        CompressionLevel compressionLevel = level1);
    unsigned UncompressBuffer(unsigned char *pFromBuffer,
                          DWORD dwFromBufferSize,
                          unsigned char *pToBuffer,
                          DWORD dwToBufferSize, 
                          CompressionLevel compressionLevel = level1);

    static BOOL GetCompressedFileInfo(const TCHAR *pchFile, 
                    CompressionLevel &compressionLevel,
                    DWORD &dwReadBufferSize,
                    FILETIME &ftCreateTime,
                    __int64  &dwOriginalSize);
                        


protected:
    BOOL CompressFileV1(int hFileFrom, 
                        int hFileTo, 
                        DWORD dwBufferSize, 
                        CompressionLevel compressionLevel,
                        CMRCIControl *pControlObject);
    BOOL UncompressFileV1(int hFileFrom, int hFileTo);

};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\winmgmt\wbemcomn\mrcicode.h ===
/*++

Copyright (C) 1994-2001 Microsoft Corporation

Module Name:

    MRCICODE.H

Abstract:

    MRCI 1 & MRCI 2 maxcompress and decompress functions

History:

--*/

#include <setjmp.h>
#include "corepol.h"

#define LOGCHASH        (13)            /* Log of max. no. of hash buckets */
#define CHASH           (1U << LOGCHASH) /* Reasonably large table */

#define LOGDISPSMALL    (6)             /* Number of bits in small disp */
#define LOGDISPMED      (8)             /* Number of bits in medium disp */
#define LOGDISPBIG      (12)            /* Number of bits in big displacement */

#define MAXDISPSMALL    ((1 << LOGDISPSMALL) - 1)
                                        /* Maximum small displacement */
#define MAXDISPMED      ((1 << LOGDISPMED) + MAXDISPSMALL)
                                        /* Maximum medium displacement */
#define MAXDISPBIG      ((1 << LOGDISPBIG) + MAXDISPMED)
                                        /* Maximum big displacement */

class POLARITY CBaseMrciCompression
{
public:
    unsigned int Mrci1MaxCompress(unsigned char *pchbase, unsigned int cchunc,
            unsigned char *pchcmpBase, unsigned int cchcmpMax);

    unsigned Mrci1Decompress(unsigned char *pchin, unsigned cchin,
            unsigned char *pchdecBase, unsigned cchdecMax);

    unsigned Mrci2MaxCompress(unsigned char *pchbase, unsigned cchunc,
            unsigned char *pchcmpBase, unsigned cchcmpMax);

    unsigned Mrci2Decompress(unsigned char *pchin, unsigned cchin,
            unsigned char *pchdecBase, unsigned cchdecMax);

private:
    /* compression internal functions */

    void inithash(void);
    void charbuf(unsigned c);
    void putbits(unsigned bits, unsigned cbits);
    void outlength(unsigned cb);

    void mrci1outsingle(unsigned ch);
    void mrci1outstring(unsigned disp, unsigned cb);

    void mrci2outsingle(unsigned ch);
    void mrci2outstring(unsigned disp, unsigned cb);


    /* decompression internal functions */

    unsigned getbit(void);
    unsigned getbits(unsigned cbits);
    void  expandstring(unsigned char **ppchout, unsigned disp, unsigned cb);

private:
    unsigned abits;                  /* Array of bits */
    unsigned cbitsleft;              /* Number of bits in abits */
    unsigned char *pCompressed;  /* pointer into compressed data */
    unsigned cCompressed;            /* # bytes remaining @ pCompressed */

    unsigned ahash[CHASH];    /* Hash table */
    unsigned alink[MAXDISPBIG];  /* Links */
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\winmgmt\wbemcomn\mrciclass.cpp ===
/*++

Copyright (C) 1997-2001 Microsoft Corporation

Module Name:

    MRCICLASS.CPP

Abstract:

   Implements the Wrapper class for MRCI 1 & MRCI 2 maxcompress 
   and decompress functions

History:

  paulall       1-Jul-97    Created

--*/

#include "precomp.h"

#include <io.h>
#include <stdio.h>
#include <fcntl.h>
#include <sys\stat.h>
#include "MRCIclass.h"


class CMRCICompressionHeaderV1
{
public:
    char     cVersion;          //Compression file format
    char     compressionLevel;  //Is this a level 1 or level 2 compression
    DWORD    dwReadBufferSize;  //Buffer size used to read original file
    FILETIME ftCreateTime;      //Time and date file created
    __int64  dwOriginalSize;    //Original file length
//  ... for each buffer
//  CMRCICompressionBlockV1 block;
//  ... until dwNextBufferSize is 0
};

class CMRCICompressionBlockV1
{
public:
    char    bCompressed;        //Was this block compressed
    DWORD   dwNextBufferSize;   //Size of the proceeding buffer
    DWORD   dwUncompressedBufferSize;   //Size needed for uncompress buffer
    //char[dwNextBufferSize];   //next block is the compression part
};


CMRCICompression::CMRCICompression()
{
}

CMRCICompression::~CMRCICompression()
{
}

BOOL CMRCICompression::GetCompressedFileInfo(const wchar_t *pchFile, 
                    CompressionLevel &compressionLevel,
                    DWORD &dwReadBufferSize,
                    FILETIME &ftCreateTime,
                    __int64  &dwOriginalSize)
{
    BOOL bStatus = FALSE;
    int hFile = _wopen(pchFile,_O_BINARY | _O_RDONLY, 0);
    if (hFile != -1)
    {
        CMRCICompressionHeaderV1 header;

        if (_read(hFile, &header, sizeof(CMRCICompressionHeaderV1)) ==
            sizeof(CMRCICompressionHeaderV1))
        {    
            compressionLevel = (CompressionLevel)header.cVersion;
            dwReadBufferSize = header.dwReadBufferSize;
            ftCreateTime = header.ftCreateTime;
            dwOriginalSize = header.dwOriginalSize;

            //If the version is 0xFF, the file is not valid!
            if (header.cVersion != 0xFF)
                bStatus = TRUE;
        }

        _close(hFile);
    }

    return bStatus;
}

BOOL CMRCICompression::CompressFile(const wchar_t *pchFileFrom, 
                                    const TCHAR *pchFileTo, 
                                    DWORD dwBufferSize,
                                    CompressionLevel compressionLevel,
                                    CMRCIControl *pControlObject)
{
    BOOL bStatus = FALSE;
    int fileFrom;
    int fileTo;

    //Open the files for processing
    //=============================
    fileFrom = _wopen(pchFileFrom,_O_BINARY | _O_RDONLY, 0);
    fileTo = _wopen(pchFileTo, _O_BINARY | _O_TRUNC | _O_CREAT | _O_WRONLY, _S_IREAD | _S_IWRITE);

    //If open sucessful
    //=================
    if ((fileFrom != -1) && (fileTo != -1))
    {
        //DO the compression using the latest and greatest version
        //========================================================
        bStatus = CompressFileV1(fileFrom, fileTo, dwBufferSize, compressionLevel, pControlObject);
    }

    //Close the files
    //===============
    if (fileFrom != -1)
        _close(fileFrom);
    if (fileTo != -1)
        _close(fileTo);

    if (pControlObject && pControlObject->AbortRequested())
    {
        //User requested an abort, so we need to delete the compressed file...
        _wunlink(pchFileTo);
        bStatus = FALSE;
    }

    return bStatus;
}

BOOL CMRCICompression::CompressFileV1(int hFileFrom, 
                                      int hFileTo, 
                                      DWORD dwBufferSize,
                                      CompressionLevel compressionLevel,
                                      CMRCIControl *pControlObject)
{
    BOOL bStatus = FALSE;
    unsigned char *pBufferFrom = new unsigned char[dwBufferSize + 4];
    unsigned char *pBufferTo   = new unsigned char[dwBufferSize + 4];

    if (pBufferFrom && pBufferTo)
    {
        //Write the header to the new file
        //================================
        CMRCICompressionHeaderV1 header;

        header.cVersion = char(0xFF);       //INVALID.  We write the header back when we have
                                    //finished!  When we read this, we check to see
                                    //if this is invalid.  We do not uncompress if it is
                                    //this value....
        header.compressionLevel = compressionLevel;
        header.dwReadBufferSize = dwBufferSize;

        SYSTEMTIME sysTime;
        GetSystemTime(&sysTime);
        SystemTimeToFileTime(&sysTime, &header.ftCreateTime);

        header.dwOriginalSize = _filelengthi64(hFileFrom);

        if (_write(hFileTo, &header, sizeof(CMRCICompressionHeaderV1)) != sizeof(CMRCICompressionHeaderV1))
        {
            delete [] pBufferFrom;
            delete [] pBufferTo;
            bStatus = FALSE;
            return bStatus;
        }

        __int64 remainingFileSize = header.dwOriginalSize;
        unsigned cbChunk;
        unsigned cbCompressed;

        bStatus = TRUE;

        //While we have some file to write...
        //===================================
        while (remainingFileSize)
        {
            //See if we need to abort the compression...
            if (pControlObject && pControlObject->AbortRequested())
            {
                break;
            }

            //Calculate the size of this buffer to compress
            //=============================================
            if (remainingFileSize > dwBufferSize)
            {
                cbChunk = dwBufferSize;
            }
            else
            {
                cbChunk = (unsigned) remainingFileSize;
            }

            //Read from the source file
            //=========================
            if (_read(hFileFrom, pBufferFrom, cbChunk) != (int) cbChunk)
            {
                bStatus = FALSE;
                break;
            }

            //Calculate what is left to read
            //==============================
            remainingFileSize -= cbChunk;

            //Compress the buffer
            //===================
            cbCompressed = CompressBuffer(pBufferFrom, cbChunk, pBufferTo, dwBufferSize, compressionLevel);

            //Create the compression block header
            CMRCICompressionBlockV1 block;
            unsigned char *pWriteBuffer;
            unsigned thisBufferSize;

            if ((cbCompressed == (unsigned) -1) || (cbCompressed >= cbChunk))
            {
                //This means compression failed or there was no compression...
                block.bCompressed = FALSE;
                pWriteBuffer = pBufferFrom;
                thisBufferSize = cbChunk;
            }
            else
            {
                block.bCompressed = TRUE;
                pWriteBuffer = pBufferTo;
                thisBufferSize = cbCompressed;
            }
            block.dwNextBufferSize = thisBufferSize;
            block.dwUncompressedBufferSize = cbChunk;

            //Write the block header
            //======================
            if (_write(hFileTo, &block, sizeof(CMRCICompressionBlockV1)) != sizeof(CMRCICompressionBlockV1))
            {
                bStatus = FALSE;
                break;
            }

            //Write the compressed block
            //==========================
            if (_write(hFileTo, pWriteBuffer, thisBufferSize) != (int)thisBufferSize)
            {
                bStatus = FALSE;
                break;
            }
        }

        if (pControlObject && pControlObject->AbortRequested())
        {
            //User requested an abort...
        }
        else
        {
            //Write final block header with zero length buffer marker
            CMRCICompressionBlockV1 block;
            block.dwNextBufferSize = 0;
            block.bCompressed = FALSE;
            if (_write(hFileTo, &block, sizeof(CMRCICompressionBlockV1)) != -1 &&
                _lseek(hFileTo, 0, SEEK_SET) != -1)
            {
                //Write a valid block header to the start with a correct version number
                header.cVersion = 1;        //Set this to the correct version
                bStatus =
                    _write(hFileTo, &header, sizeof(CMRCICompressionHeaderV1)) != -1;
            }
            else
                bStatus = FALSE;
        }

    }

    //Tidy up
    delete [] pBufferFrom;
    delete [] pBufferTo;

    return bStatus;
}
unsigned CMRCICompression::CompressBuffer(unsigned char *pFromBuffer,
                        DWORD dwFromBufferSize,
                        unsigned char *pToBuffer,
                        DWORD dwToBufferSize, 
                        CompressionLevel compressionLevel)
{
    unsigned cbCompressed;
    if (compressionLevel == level1)
    {
        cbCompressed = Mrci1MaxCompress(pFromBuffer, dwFromBufferSize, pToBuffer, dwToBufferSize);
    }
    else
    {
        cbCompressed = Mrci2MaxCompress(pFromBuffer, dwFromBufferSize, pToBuffer, dwToBufferSize);
    }

    return cbCompressed;
}


BOOL CMRCICompression::UncompressFile(const wchar_t *pchFromFile, const wchar_t *pchToFile)
{
    BOOL bStatus = FALSE;
    int fileFrom;
    int fileTo;

    //Open the files
    //==============
    fileFrom = _wopen(pchFromFile,_O_BINARY | _O_RDONLY, 0);
    fileTo = _wopen(pchToFile, _O_BINARY | _O_TRUNC | _O_CREAT | _O_WRONLY, _S_IREAD | _S_IWRITE);

    if ((fileFrom != -1) && (fileTo != -1))
    {
        //Read the version...
        //===================
        char cVer;

        if (_read(fileFrom, &cVer, sizeof(char)) == sizeof(char))
        {
            //Reset the file position to the start
            //====================================
            if (_lseek(fileFrom, 0, SEEK_SET) != -1)
            {
                //Call the uncompress with the equivelant method which created
                //the compression
                //============================================================
                switch(cVer)
                {
                case 1:
                    bStatus = UncompressFileV1(fileFrom, fileTo);
                    break;
                case 0xFF:
                    //INVALID FILE!
                default:
                    //Unsupported version
                    break;
                }
            }
        }
    }

    //CLose the files
    //===============
    if (fileFrom != -1)
        _close(fileFrom);
    if (fileTo != -1)
        _close(fileTo);

    return bStatus;
}

BOOL CMRCICompression::UncompressFileV1(int hFileFrom, int hFileTo)
{
    BOOL bStatus = FALSE;
    unsigned char *pBufferFrom = NULL;
    unsigned char *pBufferTo   = NULL;

    //Read the header
    //===============
    CMRCICompressionHeaderV1 header;

    if (_read(hFileFrom, &header, sizeof(CMRCICompressionHeaderV1)) !=
        sizeof(CMRCICompressionHeaderV1))
        return FALSE;    

    //Allocate buffers.  The read buffer is never buffer than the write buffer
    //cos if it would have been we saved the uncompressed version!
    pBufferFrom = new unsigned char[header.dwReadBufferSize + 4];
    if (pBufferFrom == 0)
        return FALSE;

    pBufferTo   = new unsigned char[header.dwReadBufferSize + 4];

    if (pBufferTo == 0)
    {
        delete [] pBufferFrom;
        return FALSE;
    }

    bStatus = TRUE;

    while (1)
    {
        //Read the block header
        //=====================
        CMRCICompressionBlockV1 block;
        if (_read(hFileFrom, &block, sizeof(CMRCICompressionBlockV1)) !=
            sizeof(CMRCICompressionBlockV1))
        {
            bStatus = FALSE;
            break;
        }
            
        if (block.dwNextBufferSize == 0)
        {
            bStatus = TRUE;
            break;
        }
        
        //Read the block data
        //===================
        if (_read(hFileFrom, pBufferFrom, block.dwNextBufferSize) != (int)block.dwNextBufferSize)
        {
            bStatus = FALSE;
            break;
        }

        unsigned char *pWriteBuffer;
        unsigned cbChunk, cbUncompressed;

        //If this block was compressed
        //============================
        if (block.bCompressed)
        {
            //Uncompress the block
            //====================
            if ((cbUncompressed = UncompressBuffer(pBufferFrom, block.dwNextBufferSize, pBufferTo, block.dwUncompressedBufferSize, (CompressionLevel)header.compressionLevel)) == (unsigned) -1)
            {
                bStatus = FALSE;
                break;
            }
            pWriteBuffer = pBufferTo;
            cbChunk = cbUncompressed;
        }
        else
        {
            //Otherwise we use the existing block
            pWriteBuffer = pBufferFrom;
            cbChunk = block.dwNextBufferSize;
        }

        //Write the file data
        _write(hFileTo, pWriteBuffer, cbChunk);
    }

    //Sanity check the file.  It should be the same size as the original
    //compressed file
    if (_filelengthi64(hFileTo) != header.dwOriginalSize)
    {
        bStatus = FALSE;
    }

    //Tidy up
    delete [] pBufferFrom;
    delete [] pBufferTo;

    return bStatus;
}

unsigned  CMRCICompression::UncompressBuffer(unsigned char *pFromBuffer,
                                             DWORD dwFromBufferSize,
                                             unsigned char *pToBuffer,
                                             DWORD dwToBufferSize, 
                                             CompressionLevel compressionLevel)
{
    unsigned cbCompressed;
    if (compressionLevel == level1)
    {
        cbCompressed = Mrci1Decompress(pFromBuffer, dwFromBufferSize, pToBuffer, dwToBufferSize);
    }
    else
    {
        cbCompressed = Mrci2Decompress(pFromBuffer, dwFromBufferSize, pToBuffer, dwToBufferSize);
    }

    return cbCompressed;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\winmgmt\wbemcomn\oahelp.inl ===
/*++

Copyright (C) 1998-2001 Microsoft Corporation

Module Name:

    OAHELP.INL

Abstract:

   OLE Automation Helpers for client code

History:

   raymcc  21-Jul-97

--*/

#ifndef _OAHELP_INL_
#define _OAHELP_INL_

class CBSTR
{
    BSTR m_pStr;
public:
    CBSTR() { m_pStr = 0; }
    CBSTR(LPWSTR pSrc) { SetStr(pSrc);}
   ~CBSTR() { Clear(); }
    operator BSTR() { return m_pStr; }

    void Unbind() { m_pStr = 0; }
    void Clear()  {if (m_pStr) SysFreeString(m_pStr);}
    void SetStr(LPWSTR pSrc) {m_pStr = SysAllocString(pSrc); }
};

class CVARIANT
{
	protected:
    VARIANT v;
public:
    CVARIANT() { VariantInit(&v); }
   ~CVARIANT() { VariantClear(&v); }
    void Clear()  { VariantClear(&v); }

    operator VARIANT *() { return &v; }
    VARIANT *operator &() { return &v; }

    CVARIANT(LPWSTR pSrc)   { VariantInit(&v); SetStr(pSrc); }
    CVARIANT(LONG lSrc)     { VariantInit(&v); SetLONG(lSrc); }
    CVARIANT(BOOL b)        { VariantInit(&v); SetBool(b); }
    CVARIANT(short i)       { VariantInit(&v); SetShort(i); }
    CVARIANT(double d)      { VariantInit(&v); SetDouble(d); }
    CVARIANT(BYTE b)        { VariantInit(&v); SetByte(b); }
    CVARIANT(IDispatch * pDisp) { VariantInit(&v); pDisp->AddRef(); SetDispatch(pDisp); }

    void   SetStr(LPWSTR pSrc)
    { Clear(); V_VT(&v) = pSrc ? VT_BSTR : VT_NULL; 
      V_BSTR(&v) = pSrc ? SysAllocString(pSrc) : 0; 
    }

    LPWSTR GetStr() { return V_VT(&v) == VT_BSTR ? V_BSTR(&v) : 0; }
    operator LPWSTR() { return V_VT(&v) == VT_BSTR ? V_BSTR(&v) : 0; }

    void SetLONG(LONG lSrc) { Clear(); V_VT(&v) = VT_I4; V_I4(&v) = lSrc; }
    LONG GetLONG() { return V_I4(&v); }
    operator LONG() { return V_I4(&v);  }

    void SetDouble(double dSrc) { Clear(); V_VT(&v) = VT_R8; V_R8(&v) = dSrc; }
    double GetDouble() { return V_R8(&v); }
    operator double() { return V_R8(&v);  }

    void SetByte(BYTE bySrc) { Clear(); V_VT(&v) = VT_UI1; V_UI1(&v) = bySrc; }
    BYTE GetByte() { return V_UI1(&v); }
    operator BYTE() { return V_UI1(&v);  }

    void SetBool(BOOL b) { V_VT(&v) = VT_BOOL; V_BOOL(&v) = b ? VARIANT_TRUE : VARIANT_FALSE; }
    BOOL GetBool() { return V_BOOL(&v) == VARIANT_TRUE; }
    operator BOOL() { return V_BOOL(&v); }

    void SetDispatch(IDispatch* pDisp) { V_VT(&v) = VT_DISPATCH; V_DISPATCH(&v) = pDisp; }
    IDispatch * GetDispatch() { return V_DISPATCH(&v); }

    void SetUnknown(IUnknown* pUnk) { V_VT(&v) = VT_UNKNOWN; V_UNKNOWN(&v) = pUnk; }
    IUnknown * GetUnknown() { return V_UNKNOWN(&v); }

    void SetShort(short i) { V_VT(&v) = VT_I2; V_I2(&v) = i; }
    short GetShort() { return V_I2(&v); }
    operator short() { return V_I2(&v); }

    VARTYPE GetType() { return V_VT(&v); }

    void SetArray(SAFEARRAY *p, VARTYPE vt) { Clear(); V_VT(&v) = vt; V_ARRAY(&v) = p; }
        // This function acquires the SAFEARRAY pointer and it is no longer owned
        // by the caller.

    operator SAFEARRAY *() { return (V_VT(&v) & VT_ARRAY ? V_ARRAY(&v) : 0); }

    void Unbind() { VariantInit(&v); }
};

class CSAFEARRAY
{
    SAFEARRAY *p;
public:
    CSAFEARRAY(VARTYPE v, int nSize) 
    {
        SAFEARRAYBOUND rgsabound[1];
    	rgsabound[0].lLbound = 0;
    	rgsabound[0].cElements = nSize;
        p = SafeArrayCreate(v, 1, rgsabound);
    }
    
    ~CSAFEARRAY() { if (p) SafeArrayDestroy(p); }
    CSAFEARRAY(SAFEARRAY *pSrc) { p = pSrc; }

    HRESULT Put(long nLocation, LPVOID pData) {
        return SafeArrayPutElement(p, &nLocation, pData);                
    }

    HRESULT Get(long nLocation, LPVOID pData) { 
        return SafeArrayGetElement(p, &nLocation, pData);                
    }

    HRESULT Access(void **pData) { return SafeArrayAccessData(p, pData); }
    HRESULT Unaccess() { return SafeArrayUnaccessData(p); }

    operator SAFEARRAY *() { return p; }
    long GetNumElements() { long upper; SafeArrayGetUBound(p, 1, &upper); return upper + 1; }

    void Unbind() { p = 0; }
};


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\winmgmt\wbemcomn\olewrap.h ===
/*++

Copyright (C) 1996-2001 Microsoft Corporation

Module Name:

    OLEWRAP.H

Abstract:

    Wrapper classes for COM data type functions.  

	If a COM data function is required to allocate memory and fails to do 
	so, then a CX_MemoryException exception is thrown.  All COM data type 
	functions are wrapped, regardless if they allocate memory, for the sake  
	of completeness.

History:

	a-dcrews	19-Mar-99	Created.

--*/

#ifndef _OLEWRAP_H_
#define _OLEWRAP_H_

class COleAuto
{
public:

	// Safe array methods
	// ==================

	static HRESULT _SafeArrayAccessData(SAFEARRAY* psa, void HUGEP** ppvData);
	static HRESULT _SafeArrayAllocData(SAFEARRAY* psa);
	static HRESULT _SafeArrayAllocDescriptor(unsigned int cDims, SAFEARRAY** ppsaOut);
	static HRESULT _SafeArrayCopy(SAFEARRAY* psa, SAFEARRAY** ppsaOut);
	static HRESULT _SafeArrayCopyData(SAFEARRAY* psaSource, SAFEARRAY* psaTarget);
	static SAFEARRAY* _SafeArrayCreate(VARTYPE vt, unsigned int cDims, SAFEARRAYBOUND* rgsabound);
	static SAFEARRAY* _SafeArrayCreateVector(VARTYPE vt, long lLbound, unsigned int cElements);
	static HRESULT _SafeArrayDestroy(SAFEARRAY* psa);
	static HRESULT _SafeArrayDestroyData(SAFEARRAY* psa);
	static HRESULT _SafeArrayDestroyDescriptor(SAFEARRAY* psa);
	static UINT _SafeArrayGetDim(SAFEARRAY* psa);
	static HRESULT _SafeArrayGetElement(SAFEARRAY* psa, long* rgIndices, void* pv);
	static UINT _SafeArrayGetElemsize(SAFEARRAY* psa);
	static HRESULT _SafeArrayGetLBound(SAFEARRAY* psa, unsigned int nDim, long* plLbound);
	static HRESULT _SafeArrayGetUBound(SAFEARRAY* psa, unsigned int nDim, long* plUbound);
	static HRESULT _SafeArrayLock(SAFEARRAY* psa);
	static HRESULT _SafeArrayPtrOfIndex(SAFEARRAY* psa, long* rgIndices, void HUGEP** ppvData);
	static HRESULT _SafeArrayPutElement(SAFEARRAY* psa, long* rgIndices, void* pv);
	static HRESULT _SafeArrayRedim(SAFEARRAY* psa, SAFEARRAYBOUND* psaboundNew);
	static HRESULT _SafeArrayUnaccessData(SAFEARRAY* psa);
	static HRESULT _SafeArrayUnlock(SAFEARRAY* psa);

	// Variant methods
	// ===============

	static HRESULT _WbemVariantChangeType(VARIANTARG* pvargDest, VARIANTARG* pvarSrc, VARTYPE vt);
	static HRESULT _VariantChangeType(VARIANTARG* pvargDest, VARIANTARG* pvarSrc, unsigned short wFlags, VARTYPE vt);
	static HRESULT _VariantChangeTypeEx(VARIANTARG* pvargDest, VARIANTARG* pvarSrc, LCID lcid, unsigned short wFlags, VARTYPE vt);
	static HRESULT _VariantClear(VARIANTARG* pvarg);
	static HRESULT _VariantCopy(VARIANTARG* pvargDest, VARIANTARG* pvargSrc);
	static HRESULT _VariantCopyInd(VARIANT* pvarDest, VARIANTARG* pvargSrc);
	static void _VariantInit(VARIANTARG* pvarg);

	// BSTR methods
	// ============

	static BSTR _SysAllocString(const OLECHAR* sz);
	static BSTR _SysAllocStringByteLen(LPCSTR psz, UINT len);
	static BSTR _SysAllocStringLen(const OLECHAR* pch, UINT cch);
	static void _SysFreeString(BSTR bstr);
	static HRESULT _SysReAllocString(BSTR* pbstr, const OLECHAR* sz);
	static HRESULT _SysReAllocStringLen(BSTR* pbstr, const OLECHAR* pch, UINT cch);
	static HRESULT _SysStringByteLen(BSTR bstr);
	static HRESULT _SysStringLen(BSTR bstr);

	// Conversion methods
	// ==================

	static HRESULT _VectorFromBstr (BSTR bstr, SAFEARRAY ** ppsa);
	static HRESULT _BstrFromVector (SAFEARRAY *psa, BSTR *pbstr);
};

#endif	//_OLEWRAP_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\winmgmt\wbemcomn\olewrap.cpp ===
/*++

Copyright (C) 1996-2001 Microsoft Corporation

Module Name:

    OLEWRAP.CPP

Abstract:

    Wrapper classes for COM data type functions.  

    If a COM data function is required to allocate memory and fails to do 
    so, then a CX_MemoryException exception is thrown.  All COM data type 
    functions are wrapped, regardless if they allocate memory, for the sake  
    of completeness.

History:

    a-dcrews    19-Mar-99   Created.

--*/

#include "precomp.h"
#include <corex.h>
#include <oleauto.h>

#include "OleWrap.h"
#include "genutils.h"

//***************************************************************************
//
//  SafeArray wrappers
//
//***************************************************************************


HRESULT COleAuto::_SafeArrayAccessData(SAFEARRAY FAR* psa, void HUGEP* FAR* ppvData)
{
    return SafeArrayAccessData(psa, ppvData);
}

HRESULT COleAuto::_SafeArrayAllocData(SAFEARRAY FAR* psa)
{
    HRESULT hRes = S_OK;

    hRes = SafeArrayAllocData(psa);
    return hRes;
}

HRESULT COleAuto::_SafeArrayAllocDescriptor(unsigned int cDims, SAFEARRAY FAR* FAR* ppsaOut)
{
    HRESULT hRes = S_OK;

    hRes = SafeArrayAllocDescriptor(cDims, ppsaOut);
    return hRes;
}

HRESULT COleAuto::_SafeArrayCopy(SAFEARRAY FAR* psa, SAFEARRAY FAR* FAR* ppsaOut)
{
    HRESULT hRes = S_OK;

    hRes = SafeArrayCopy(psa, ppsaOut);
    if (E_OUTOFMEMORY == hRes)
    {
        throw CX_MemoryException();
    }

    return hRes;
}

HRESULT COleAuto::_SafeArrayCopyData(SAFEARRAY FAR* psaSource, SAFEARRAY FAR* psaTarget)
{
    HRESULT hRes = S_OK;

    hRes = SafeArrayCopyData(psaSource, psaTarget);
    if (E_OUTOFMEMORY == hRes)
    {
        throw CX_MemoryException();
    }

    return hRes;
}

SAFEARRAY* COleAuto::_SafeArrayCreate(VARTYPE vt, unsigned int cDims, SAFEARRAYBOUND FAR* rgsabound)
{
    SAFEARRAY*  psa;

    psa = SafeArrayCreate(vt, cDims, rgsabound);
    if (NULL == psa)
    {
        throw CX_MemoryException();
    }

    return psa;
}

SAFEARRAY* COleAuto::_SafeArrayCreateVector(VARTYPE vt, long lLbound, unsigned int cElements)
{
    SAFEARRAY*  psa;

    psa = SafeArrayCreateVector(vt, lLbound, cElements);
    if (NULL == psa)
    {
        throw CX_MemoryException();
    }

    return psa;
}

HRESULT COleAuto::_SafeArrayDestroy(SAFEARRAY FAR* psa)
{
    return SafeArrayDestroy(psa);
}

HRESULT COleAuto::_SafeArrayDestroyData(SAFEARRAY FAR* psa)
{
    return SafeArrayDestroyData(psa);
}

HRESULT COleAuto::_SafeArrayDestroyDescriptor(SAFEARRAY FAR* psa)
{
    return SafeArrayDestroyDescriptor(psa);
}

UINT COleAuto::_SafeArrayGetDim(SAFEARRAY FAR* psa)
{
    return SafeArrayGetDim(psa);
}

HRESULT COleAuto::_SafeArrayGetElement(SAFEARRAY FAR* psa, long FAR* rgIndices, void FAR* pv)
{
    return SafeArrayGetElement(psa, rgIndices, pv);
}

UINT COleAuto::_SafeArrayGetElemsize(SAFEARRAY FAR* psa)
{
    return SafeArrayGetElemsize(psa);
}

HRESULT COleAuto::_SafeArrayGetLBound(SAFEARRAY FAR* psa, unsigned int nDim, long FAR* plLbound)
{
    return SafeArrayGetLBound(psa, nDim, plLbound);
}

HRESULT COleAuto::_SafeArrayGetUBound(SAFEARRAY FAR* psa, unsigned int nDim, long FAR* plUbound)
{
    return SafeArrayGetUBound(psa, nDim, plUbound);
}

HRESULT COleAuto::_SafeArrayLock(SAFEARRAY FAR* psa)
{
    return SafeArrayLock(psa);
}

HRESULT COleAuto::_SafeArrayPtrOfIndex(SAFEARRAY FAR* psa, long FAR* rgIndices, void HUGEP* FAR* ppvData)
{
    return SafeArrayPtrOfIndex(psa, rgIndices, ppvData);
}

HRESULT COleAuto::_SafeArrayPutElement(SAFEARRAY FAR* psa, long FAR* rgIndices, void FAR* pv)
{
    return SafeArrayPutElement(psa, rgIndices, pv);
}

HRESULT COleAuto::_SafeArrayRedim(SAFEARRAY FAR* psa, SAFEARRAYBOUND FAR* psaboundNew)
{
    return SafeArrayRedim(psa, psaboundNew);
}

HRESULT COleAuto::_SafeArrayUnaccessData(SAFEARRAY FAR* psa)
{
    return SafeArrayUnaccessData(psa);
}

HRESULT COleAuto::_SafeArrayUnlock(SAFEARRAY FAR* psa)
{
    return SafeArrayUnlock(psa);
}

//***************************************************************************
//
//  Variant wrappers
//
//***************************************************************************


HRESULT COleAuto::_WbemVariantChangeType(VARIANTARG FAR* pvargDest, VARIANTARG FAR* pvarSrc, VARTYPE vt)
{
    HRESULT hRes = WbemVariantChangeType(pvargDest, pvarSrc, vt);

    if (E_OUTOFMEMORY == hRes)
    {
        throw CX_MemoryException();
    }

    return hRes;
}

HRESULT COleAuto::_VariantChangeType(VARIANTARG FAR* pvargDest, VARIANTARG FAR* pvarSrc, unsigned short wFlags, VARTYPE vt)
{
    HRESULT hRes = VariantChangeType(pvargDest, pvarSrc, wFlags, vt);

    if (E_OUTOFMEMORY == hRes)
    {
        throw CX_MemoryException();
    }

    return hRes;
}

HRESULT COleAuto::_VariantChangeTypeEx(VARIANTARG FAR* pvargDest, VARIANTARG FAR* pvarSrc, LCID lcid, unsigned short wFlags, VARTYPE vt)
{
    HRESULT hRes = VariantChangeTypeEx(pvargDest, pvarSrc, lcid, wFlags, vt);

    if (E_OUTOFMEMORY == hRes)
    {
        throw CX_MemoryException();
    }

    return hRes;
}

HRESULT COleAuto::_VariantClear(VARIANTARG FAR* pvarg)
{
    return VariantClear(pvarg);
}

HRESULT COleAuto::_VariantCopy(VARIANTARG FAR* pvargDest, VARIANTARG FAR* pvargSrc)
{
    HRESULT hRes = VariantCopy(pvargDest, pvargSrc);

    if (E_OUTOFMEMORY == hRes)
    {
        throw CX_MemoryException();
    }

    return hRes;
}

HRESULT COleAuto::_VariantCopyInd(VARIANT FAR* pvarDest, VARIANTARG FAR* pvargSrc)
{
    HRESULT hRes = VariantCopyInd(pvarDest, pvargSrc);

    if (E_OUTOFMEMORY == hRes)
    {
        throw CX_MemoryException();
    }

    return hRes;
}

void COleAuto::_VariantInit(VARIANTARG FAR* pvarg)
{
    VariantInit(pvarg);
}


//***************************************************************************
//
//  BSTR wrappers
//
//***************************************************************************


BSTR COleAuto::_SysAllocString(const OLECHAR* sz)
{
    BSTR bstr = SysAllocString(sz);

    if (NULL == bstr)
    {
        throw CX_MemoryException();
    }

    return bstr;
}

BSTR COleAuto::_SysAllocStringByteLen(LPCSTR psz, UINT len)
{
    BSTR bstr = SysAllocStringByteLen(psz, len);

    if (NULL == bstr)
    {
        throw CX_MemoryException();
    }

    return bstr;
}

BSTR COleAuto::_SysAllocStringLen(const OLECHAR* pch, UINT cch)
{
    BSTR bstr = SysAllocStringLen(pch, cch);

    if (NULL == bstr)
    {
        throw CX_MemoryException();
    }

    return bstr;
}

void COleAuto::_SysFreeString(BSTR bstr)
{
    SysFreeString(bstr);
}

HRESULT COleAuto::_SysReAllocString(BSTR* pbstr, const OLECHAR* sz)
{
    HRESULT hRes = SysReAllocString(pbstr, sz);

    if (FAILED(hRes))
    {
        throw CX_MemoryException();
    }

    return hRes;
}

HRESULT COleAuto::_SysReAllocStringLen(BSTR* pbstr, const OLECHAR* pch, UINT cch)
{
    HRESULT hRes = SysReAllocStringLen(pbstr, pch, cch);

    if (FAILED(hRes))
    {
        throw CX_MemoryException();
    }

    return hRes;
}

HRESULT COleAuto::_SysStringByteLen(BSTR bstr)
{
    return SysStringByteLen(bstr);
}

HRESULT COleAuto::_SysStringLen(BSTR bstr)
{
    return SysStringLen(bstr);
}


//***************************************************************************
//
//  Conversion wrappers
//
//***************************************************************************


HRESULT COleAuto::_VectorFromBstr (BSTR bstr, SAFEARRAY ** ppsa)
{
    HRESULT hRes = VectorFromBstr(bstr, ppsa);

    if (E_OUTOFMEMORY == hRes)
    {
        throw CX_MemoryException();
    }

    return hRes;
}

HRESULT COleAuto::_BstrFromVector (SAFEARRAY *psa, BSTR *pbstr)
{
    HRESULT hRes = BstrFromVector(psa, pbstr);

    if (E_OUTOFMEMORY == hRes)
    {
        throw CX_MemoryException();
    }

    return hRes;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\winmgmt\wbemcomn\pathutl.cpp ===
/*++

Copyright (C) 1996-2001 Microsoft Corporation

Module Name:

Abstract:

History:

--*/


#include "precomp.h"
#include <assert.h>
#include "pathutl.h"

CRelativeObjectPath::CRelativeObjectPath()
: m_pPath(NULL), m_wszRelPath(NULL), m_Parser( e_ParserAcceptAll )
{

}

CRelativeObjectPath::~CRelativeObjectPath()
{
    delete m_wszRelPath;
 
    if ( m_pPath != NULL )
    {
        m_Parser.Free( m_pPath );
    }
}

LPCWSTR CRelativeObjectPath::GetPath( )
{
    assert( m_pPath != NULL );

    if ( m_wszRelPath != NULL )
    {
        return m_wszRelPath;
    }

    int nRes = m_Parser.Unparse( m_pPath, &m_wszRelPath );
    assert( nRes == CObjectPathParser::NoError );

    return m_wszRelPath;
}

BOOL CRelativeObjectPath::Parse( LPCWSTR wszPath )
{
    int nRes;

    // 
    // cannot save this relpath because it may not be normalized yet.
    //
    LPWSTR wszRelPath = CObjectPathParser::GetRelativePath( (LPWSTR)wszPath );

    if ( wszRelPath == NULL )
    {
        nRes = m_Parser.Parse( wszPath, &m_pPath );
    }
    else
    {
        nRes = m_Parser.Parse( wszRelPath, &m_pPath );
    }

    if ( nRes == CObjectPathParser::NoError )
    {
        if ( m_pPath->m_dwNumKeys == 1 )
        {
            delete m_pPath->m_paKeys[0]->m_pName;
            m_pPath->m_paKeys[0]->m_pName = NULL;
        }
        return TRUE;
    }

    return FALSE;
}

BOOL CRelativeObjectPath::operator==( CRelativeObjectPath& rOther )
{
    LPCWSTR wszRelPathA = GetPath();
    LPCWSTR wszRelPathB = rOther.GetPath();

    assert( wszRelPathA != NULL ); 
    assert( wszRelPathB != NULL );

    if (!wszRelPathA || !wszRelPathB)
        return FALSE;

    return wbem_wcsicmp( wszRelPathA, wszRelPathB ) == 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\winmgmt\wbemcomn\pathutl.h ===
/*++

Copyright (C) 1996-2001 Microsoft Corporation

Module Name:

Abstract:

History:

--*/



#ifndef __PATHUTL_H__
#define __PATHUTL_H__

#include <genlex.h>
#include <objpath.h>

class CRelativeObjectPath
{
    CObjectPathParser m_Parser;
    LPWSTR m_wszRelPath;

    CRelativeObjectPath( const CRelativeObjectPath& );
    CRelativeObjectPath& operator=( const CRelativeObjectPath& );
    
public:
    
    ParsedObjectPath* m_pPath;

    CRelativeObjectPath();
    ~CRelativeObjectPath();

    BOOL Parse( LPCWSTR wszPath );

    BOOL operator== ( CRelativeObjectPath& rPath );
    LPCWSTR GetPath();
};

#endif // __PATHUTL_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\winmgmt\wbemcomn\parmdefs.h ===
/*++

Copyright (C) 1996-2001 Microsoft Corporation

Module Name:

   PARMDEFS.H

Abstract:

  This file defines parameter modifier constants used throughout the system.
  These constants are defined to nothing and are used as reading aides only.

History:

  11/96   a-levn  Created.

--*/

#ifndef __PARMDEFS__H_
#define __PARMDEFS__H_

#define IN
#define OUT
#define OLE_MODIFY  // This object will be modified through the interface
#define MODIFY      // This object will be modified as a C++ object.
#define READ_ONLY   // This parameter is read-only
#define NEW_OBJECT  // New object will be returned in this parameter
#define RELEASE_ME  // The caller must release once the object is not needed.
#define DELETE_ME   // The caller must delete once the object is not needed.
#define SYSFREE_ME  // The caller must SysFreeString when no longer needed.
#define INTERNAL    // Internal pointer is returned. Do not delete. Lifetime
                    // is limited to that of the object.
#define COPY        // The function will make a copy of this object. The
                    // caller can do as it wishes with the original 
#define ACQUIRE     // The function acquires the pointer --- the caller may
                    // never delete it, the object will do it.
#define ADDREF      // This IN parameter is AddRef'ed by the function.
#define DELETE_IF_CHANGE // If the contents of this reference is changed by
                        // the caller, the old contents must be deleted
#define RELEASE_IF_CHANGE // If the contents of this reference is changed by
                        // the caller, the old contents must be Released
#define INIT_AND_CLEAR_ME  // This variant parameter must be VariantInit'ed
                            // by the caller before and VariantClear'ed after
#define STORE       // The function will store this pointer and assume that
                    // it will live long enough.

#define MODIFIED MODIFY
#define OLE_MODIFIED OLE_MODIFY
#define NOCS const  // This function does not acquire any resources
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\winmgmt\wbemcomn\precomp.h ===
/*++

Copyright (C) 1999-2001 Microsoft Corporation

Module Name:

Abstract:

History:

--*/


#include "corepol.h"

#undef _CRTIMP
#define _CRTIMP POLARITY
#include <yvals.h>
#undef _CRTIMP
#define _CRTIMP __declspec(dllimport)

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#define WIN32_NO_STATUS
#include <windows.h>
#include <ole2.h>
#include <wincrypt.h>
#include <comdef.h>

#include <strsafe.h>
#include <strutils.h>

#include <scopeguard.h>
#include <autoptr.h>
#include <helper.h>
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\winmgmt\wbemcomn\persistcfg.cpp ===
/*++

Copyright (C) 1998-2001 Microsoft Corporation

Module Name:

    PERSISTCFG.cpp

Abstract:

  This file implements the WinMgmt persistent configuration operations. 

  Classes implemented: 
      CPersistentConfig      persistent configuration manager

History:

  1/13/98       paulall     Created.

--*/

#include "precomp.h"
#include <sync.h>
#include <memory.h>
#include <stdio.h>
#include "PersistCfg.h"
#include "reg.h"

#define WinMgmt_CFG_ACTUAL  __TEXT("$WinMgmt.CFG")
#define WinMgmt_CFG_PENDING __TEXT("$WinMgmt.$FG")
#define WinMgmt_CFG_BACKUP  __TEXT("$WinMgmt.CFG.BAK")

CDirectoryPath CPersistentConfig::m_Directory;


/*=============================================================================
 *  CDirectoryPath::CDirectoryPath
 *
 *  Initialised the directory path
 *
 *=============================================================================
 */
CDirectoryPath::CDirectoryPath()
{

    Registry r(WBEM_REG_WINMGMT);
    OnDeleteIf0<void(*)(void),&CStaticCritSec::SetFailure> Fail;

    pszDirectory = NULL;
    
    if (r.GetStr(__TEXT("Repository Directory"), &pszDirectory))
    {
        size_t sizeString = MAX_PATH + LENGTH_OF(__TEXT("\\wbem\\repository"));
        wmilib::auto_buffer<TCHAR> pWindir(new TCHAR[sizeString]);
        if (NULL == pWindir.get()) return;
        
        UINT ReqSize = GetSystemDirectory(pWindir.get(),MAX_PATH+1);
        if (ReqSize > MAX_PATH)
        {
            sizeString = ReqSize + LENGTH_OF(__TEXT("\\wbem\\repository"));
            pWindir.reset(new TCHAR[sizeString]);
            if (NULL == pWindir.get()) return;
        
            if (0 == GetSystemDirectory(pWindir.get(),ReqSize+1)) return;
        }

        StringCchCat(pWindir.get(),sizeString,__TEXT("\\wbem\\repository"));

        r.SetExpandStr(__TEXT("Repository Directory"),__TEXT("%systemroot%\\system32\\wbem\\repository"));

        TCHAR * pDiscard = NULL;
        if (r.GetStr(__TEXT("Working Directory"), &pDiscard))
        {        
            r.SetExpandStr(__TEXT("Working Directory"),__TEXT("%systemroot%\\system32\\wbem"));
        }  
        delete [] pDiscard;
        
        pszDirectory = pWindir.release();
        Fail.dismiss();            
        return;
    }
    Fail.dismiss();
}

/*=============================================================================
 *  GetPersistentCfgValue
 *
 *  Retrieves the configuration from the configuration file if it
 *  has not yet been retrieved into memory, or retrieves it from a 
 *  memory cache.
 *
 *  Parameters:
 *      dwOffset    needs to be less than MaxNumberConfigEntries and specifies
 *                  the configuration entry required.
 *      dwValue     if sucessful this will contain the value.  If the value
 *                  has not been set this will return 0.
 *
 *  Return value:
 *      BOOL        returns TRUE if successful.
 *=============================================================================
 */

BOOL CPersistentConfig::GetPersistentCfgValue(DWORD dwOffset, DWORD &dwValue)
{
    dwValue = 0;
    if (dwOffset >= MaxNumberConfigEntries)
        return FALSE;

    //Try and read the file if it exists, otherwise it does not matter, we just 

    wmilib::auto_buffer<TCHAR> pszFilename( GetFullFilename(WinMgmt_CFG_ACTUAL));
    if (NULL == pszFilename.get()) return FALSE;

    HANDLE hFile = CreateFile(pszFilename.get(),  //Name of file
                                GENERIC_READ,   //Read only at
                                0,              //Don't need to allow anyone else in
                                0,              //Shouldn't need security
                                OPEN_EXISTING,  //Only open the file if it exists
                                0,              //No attributes needed
                                0);             //No template file required
    if (hFile != INVALID_HANDLE_VALUE)
    {
        DWORD dwNumBytesRead;
        if ((GetFileSize(hFile, NULL) >= sizeof(DWORD)*(dwOffset+1)) && 
	    (SetFilePointer (hFile, sizeof(DWORD)*dwOffset, 0, FILE_BEGIN) != INVALID_SET_FILE_POINTER) &&
	    ReadFile(hFile, &dwValue, sizeof(DWORD), &dwNumBytesRead, NULL))
	{
	}

        CloseHandle(hFile);
    }

    return TRUE;
}

/*=============================================================================
 *  WriteConfig
 *
 *  Writes the $WinMgmt.CFG file into the memory cache and to the file.  It
 *  protects the existing file until the last minute.
 *
 *  return value:
 *      BOOL        returns TRUE if successful.
 *=============================================================================
 */
BOOL CPersistentConfig::SetPersistentCfgValue(DWORD dwOffset, DWORD dwValue)
{
    if (dwOffset >= MaxNumberConfigEntries)
        return FALSE;

    BOOL bRet = FALSE;

    wmilib::auto_buffer<TCHAR> pszActual(GetFullFilename(WinMgmt_CFG_ACTUAL));

    if (NULL == pszActual.get()) return FALSE;

    //Create a new file to write to...
    HANDLE hFile = CreateFile(pszActual.get(),       //Name of file
                                GENERIC_WRITE | GENERIC_READ , 
                                0,              //Don't need to allow anyone else in
                                0,              //Shouldn't need security
                                OPEN_ALWAYS,  //create if does not exist
                                0,              //No attributes needed
                                0);             //No template file required

    if (hFile != INVALID_HANDLE_VALUE)
    {

        DWORD dwNumBytesWritten;  
        DWORD dwNumBytesReaded;  

	DWORD lowSize = GetFileSize(hFile, NULL);

	if (GetFileSize(hFile, NULL) != MaxNumberConfigEntries*sizeof(DWORD))
	{
		DWORD buff[MaxNumberConfigEntries]={0};
		ReadFile(hFile, buff, sizeof(buff), &dwNumBytesWritten, NULL); 
		buff[dwOffset] = dwValue;

                if (SetFilePointer(hFile,0,0, FILE_BEGIN)!=INVALID_SET_FILE_POINTER)
		{
			bRet = WriteFile(hFile, buff, sizeof(buff), &dwNumBytesWritten, NULL); 
                        if (bRet)
                        {
                            SetEndOfFile(hFile); 
                        }
		}
	}
	else
	{
            bRet = (SetFilePointer (hFile, sizeof(DWORD)*dwOffset, 0, FILE_BEGIN) != INVALID_SET_FILE_POINTER) ;
	    if (!bRet || !WriteFile(hFile, &dwValue, sizeof(DWORD), &dwNumBytesWritten, NULL) || 
            (dwNumBytesWritten != (sizeof(DWORD))))
            {
                //OK, this failed!!!
                CloseHandle(hFile);
                return FALSE;
            }
	}

        //Make sure it really is flushed to the disk
        FlushFileBuffers(hFile);
        CloseHandle(hFile);

        return bRet;
    }
    return FALSE;
}

TCHAR *CPersistentConfig::GetFullFilename(const TCHAR *pszFilename)
{
	size_t bufferLength = lstrlen(m_Directory.GetStr()) + lstrlen(pszFilename) + 2;

    TCHAR *pszPathFilename = new TCHAR[bufferLength];
    
    if (pszPathFilename)
    {
        StringCchCopy(pszPathFilename, bufferLength, m_Directory.GetStr());
        if ((lstrlen(pszPathFilename)) && (pszPathFilename[lstrlen(pszPathFilename)-1] != __TEXT('\\')))
        {
            StringCchCat(pszPathFilename, bufferLength, __TEXT("\\"));
        }
        StringCchCat(pszPathFilename, bufferLength, pszFilename);
    }

    return pszPathFilename;
}

void CPersistentConfig::TidyUp()
{
    //Recover the configuration file.
    //-------------------------------
    wmilib::auto_buffer<TCHAR> pszOriginalFile(GetFullFilename(WinMgmt_CFG_ACTUAL));
    wmilib::auto_buffer<TCHAR> pszPendingFile(GetFullFilename(WinMgmt_CFG_PENDING));
    wmilib::auto_buffer<TCHAR> pszBackupFile(GetFullFilename(WinMgmt_CFG_BACKUP));

    if (NULL == pszOriginalFile.get() ||
        NULL == pszPendingFile.get() ||
        NULL == pszBackupFile.get()) return;

    if (FileExists(pszOriginalFile.get()))
    {
        if (FileExists(pszPendingFile.get()))
        {
            if (FileExists(pszBackupFile.get()))
            {
                //BAD - Unexpected situation.
                DeleteFile(pszPendingFile.get());
                DeleteFile(pszBackupFile.get());
                //Back to the point where the interrupted operation did not 
                //happen
            }
            else
            {
                //Pending file with original file means we cannot guarentee
                //the integrety of the pending file so the last operation
                //will be lost.
                DeleteFile(pszPendingFile.get());
                //Back to the point where the interrupted operation did not 
                //happen
            }
        }
        else
        {
            if (FileExists(pszBackupFile.get()))
            {
                //Means we successfully copied the pending file to the original
                DeleteFile(pszBackupFile.get());
                //Everything is now normal.  Interrupted Operation completed!
            }
            else
            {
                //Nothing out of the ordinary here.
            }
        }
    }
    else
    {
        if (FileExists(pszPendingFile.get()))
        {
            if (FileExists(pszBackupFile.get()))
            {
                //This is an expected behaviour at the point we have renamed
                //the original file to the backup file.
                MoveFile(pszPendingFile.get(), pszOriginalFile.get());
                DeleteFile(pszBackupFile.get());
                //Everything is now normal.  Interrupted operation completed!
            }
            else
            {
                //BAD - Unexpected situation.
                DeleteFile(pszPendingFile.get());
                //There are now no files!  Operation did not take place
                //and there are now no files left.  This should be a
                //recoverable scenario!
            }
        }
        else
        {
            if (FileExists(pszBackupFile.get()))
            {
                //BAD - Unexpected situation.
                DeleteFile(pszBackupFile.get());
                //There are now no files!  Operation did not take place
                //and there are now no files left.  This should be a
                //recoverable scenario!
            }
            else
            {
                //May be BAD!  There are no files!  This should be a
                //recoverable scenario!
            }
        }
    }

}

//*****************************************************************************
//
//  FileExists()
//
//  Returns TRUE if the file exists, FALSE otherwise (or if an error
//  occurs while opening the file.
//*****************************************************************************
BOOL CPersistentConfig::FileExists(const TCHAR *pszFilename)
{
    BOOL bExists = FALSE;
    HANDLE hFile = CreateFile(pszFilename, 0, 0, 0, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, 0);
    if (hFile != INVALID_HANDLE_VALUE)
    {
        bExists = TRUE;
        CloseHandle(hFile);
    }
    else
    {
        //If the file does not exist we should have a LastError of ERROR_NOT_FOUND
        DWORD dwError = GetLastError();
        if (dwError != ERROR_FILE_NOT_FOUND)
        {
//          DEBUGTRACE((LOG_WBEMCORE,"File %s could not be opened for a reason other than not existing\n", pszFilename));
        }
    }
    return bExists;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\winmgmt\wbemcomn\persistcfg.h ===
/*++

Copyright (C) 1998-2001 Microsoft Corporation

Module Name:

    PERSISTCFG.H

Abstract:

  This file implements the WinMgmt persistent configuration operations. 

  Classes implemented: 
      CPersistentConfig      persistent configuration manager

History:

  1/13/98       paulall     Created.

--*/

#ifndef _persistcfg_h_
#define _persistcfg_h_

#include "corepol.h"
#include "statsync.h"


enum PERSIST_CFGVAL
{
    PERSIST_CFGVAL_CORE_DATABASE_DIRTY,
    PERSIST_CFGVAL_CORE_ESS_NEEDS_LOADING,
    PERSIST_CFGVAL_CORE_NEEDSBACKUPCHECK,
    PERSIST_CFGVAL_CORE_FSREP_VERSION,
    PERSIST_CFGVAL_CORE_ESS_TO_BE_INITIALIZED,
    PERSIST_CFGVAL_MAX_NUM_EVENTS // keep this last
};

class CDirectoryPath
{
    TCHAR *pszDirectory ;
public:
    CDirectoryPath();

    ~CDirectoryPath(){ delete [] pszDirectory;};
    TCHAR * GetStr(void){return pszDirectory;};
};

/*=============================================================================
 *
 * class CPersistentConfig
 *
 * Retrieves and stores persistent configuration in the $WinMgmt.CFG file.
 * All writes are going to be committed to disk by the return of the
 * operation. 
 *=============================================================================
 */
#pragma warning (disable : 4251)

class POLARITY CPersistentConfig
{
public:
    //Number of items in the config array.  Requesting/setting values
    //outside this range will fail the operation.
    enum { MaxNumberConfigEntries = PERSIST_CFGVAL_MAX_NUM_EVENTS };

    //Retrieves the configuration from the configuration file if it
    //has not yet been retrieved into memory, or retrieves it from a 
    //memory cache.
    // dwOffset needs to be less than MaxNumberConfigEntries and specifies
    //          the configuration entry required.
    // dwValue  if sucessful this will contain the value.  If the value
    //          has not been set this will return 0.
    // BOOL     returns TRUE if successful.
    BOOL GetPersistentCfgValue(DWORD dwOffset, DWORD &dwValue);

    //Stores the value into the configuration file and to the 
    //memory cache if it exists.  The replacment of the original
    //file (if it exists) is the last thing it does.
    //  dwOffset    needs to be less than MaxNumberConfigEntries and specifies
    //          the configuration entry required.
    //  dwValue is the value to set the configuration to.
    //  BOOL        returns TRUE if successful.
    BOOL SetPersistentCfgValue(DWORD dwOffset, DWORD dwValue);

    //Should be called once at startup to make sure the configuration files are
    //in a stable state.
    void CPersistentConfig::TidyUp();

private:
    //Directory of persistent date

    static CDirectoryPath m_Directory ;

    //Returns a filename with a full DB path prepended to the 
    //specified filename.  Need to delete[] the string returned.
    TCHAR *GetFullFilename(const TCHAR *pszFilename);
    
    //Returns TRUE if the file exists, FALSE otherwise (or if an error
    //occurs while opening the file.
    BOOL FileExists(const TCHAR *pszFilename);
    
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\winmgmt\wbemcomn\provinit.cpp ===
/*++

Copyright (C) 1996-2001 Microsoft Corporation

Module Name:

    PROVINIT.CPP

Abstract:

  This file implements the provider init sink

History:

--*/

#include "precomp.h"
#include <stdio.h>
#include <wbemcomn.h>
#include <sync.h>
#include <cominit.h>
#include "provinit.h"

ULONG STDMETHODCALLTYPE CProviderInitSink::AddRef()
{
    CInCritSec ics(&m_cs);
    return ++m_lRef;
}

ULONG STDMETHODCALLTYPE CProviderInitSink::Release()
{
    EnterCriticalSection(&m_cs);
    --m_lRef;
    if(m_lRef == 0)
    {
        LeaveCriticalSection(&m_cs);
        delete this;
    }
    else LeaveCriticalSection(&m_cs);

    return 99;
}

HRESULT STDMETHODCALLTYPE CProviderInitSink::QueryInterface(REFIID riid, 
                                                            void** ppv)
{
    CInCritSec ics(&m_cs);
    if(riid == IID_IUnknown || riid == IID_IWbemProviderInitSink)
    {
        *ppv = (IWbemProviderInitSink*)this;
        AddRef();
        return S_OK;
    }
    else return E_NOINTERFACE;
}

HRESULT STDMETHODCALLTYPE CProviderInitSink::SetStatus(long lStatus, 
                                                            long lFlags)
{
    CInCritSec ics(&m_cs);

    if(lFlags != 0)
        return WBEM_E_INVALID_PARAMETER;

    if(SUCCEEDED(lStatus) && lStatus != WBEM_S_INITIALIZED)
    {
        // Partial initialization is not supported in this version
        // =======================================================
        return WBEM_S_NO_ERROR;
    }

    m_lStatus = lStatus;
    SetEvent(m_hEvent);

    return WBEM_S_NO_ERROR;
}

CProviderInitSink::CProviderInitSink() : m_lRef(0)
{
    m_hEvent = CreateEvent(NULL, FALSE, FALSE, NULL);
}

CProviderInitSink::~CProviderInitSink()
{
    CloseHandle(m_hEvent);
}

HRESULT CProviderInitSink::WaitForCompletion()
{
    // Wait
    // ====

    DWORD dwRes = WbemWaitForSingleObject(m_hEvent, 300000);

    if(dwRes != WAIT_OBJECT_0)
    {
        ERRORTRACE((LOG_WBEMCORE, "Provider initialization phase timed out\n"));
    
        return WBEM_E_PROVIDER_LOAD_FAILURE;
    }

    return m_lStatus;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\winmgmt\wbemcomn\provinit.h ===
/*++

Copyright (C) 1996-2001 Microsoft Corporation

Module Name:

    PROVINIT.H

Abstract:

  This file implements the provider init sink

History:

--*/

#ifndef __WBEM_PROVINIT__H_
#define __WBEM_PROVINIT__H_

class POLARITY CProviderInitSink : public IWbemProviderInitSink
{
protected:
    CCritSec m_cs;
    long m_lRef;
    long m_lStatus;
    HANDLE m_hEvent;

public:
    ULONG STDMETHODCALLTYPE AddRef();
    ULONG STDMETHODCALLTYPE Release();
    HRESULT STDMETHODCALLTYPE QueryInterface(REFIID riid, void** ppv);

    HRESULT STDMETHODCALLTYPE SetStatus(long lStatus, long lFlags);

public:
    CProviderInitSink();
    ~CProviderInitSink();

    HRESULT WaitForCompletion();
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\winmgmt\wbemcomn\qllex.cpp ===
/*++

Copyright (C) 1995-2001 Microsoft Corporation

Module Name:

    QLLEX.CPP

Abstract:

    QL Level 1 DFA Table

History:

    raymcc    24-Jun-95       Created.

--*/

#include "precomp.h"
#include <stdio.h>

#include <genlex.h>
#include <qllex.h>             

#define ST_STRING       24
#define ST_IDENT        29
#define ST_GE           35
#define ST_LE           37
#define ST_NE           40
#define ST_NUMERIC      42
#define ST_REAL         47
#define ST_STRING2      53
#define ST_STRING_ESC   58
#define ST_STRING2_ESC  61   
#define ST_DOT          64
#define ST_NEGATIVE_NUM 66
#define ST_POSITIVE_NUM 69

// DFA State Table for QL Level 1 lexical symbols.
// ================================================

LexEl Ql_1_LexTable[] =
{

// State    First   Last        New state,  Return tok,      Instructions
// =======================================================================
/* 0 */  L'A',   L'Z',       ST_IDENT,   0,               GLEX_ACCEPT,
/* 1 */  L'a',   L'z',       ST_IDENT,   0,               GLEX_ACCEPT,
/* 2 */  L'_',   GLEX_EMPTY, ST_IDENT,   0,               GLEX_ACCEPT,
/* 3 */  0x80,  0xfffd,     ST_IDENT,   0,               GLEX_ACCEPT,

/* 4 */  L'(',   GLEX_EMPTY, 0,          QL_1_TOK_OPEN_PAREN,  GLEX_ACCEPT,
/* 5 */  L')',   GLEX_EMPTY, 0,  QL_1_TOK_CLOSE_PAREN, GLEX_ACCEPT,
/* 6 */  L'.',   GLEX_EMPTY, ST_DOT,  0,         GLEX_ACCEPT,
/* 7 */  L'*',   GLEX_EMPTY, 0,  QL_1_TOK_ASTERISK,    GLEX_ACCEPT,
/* 8 */  L'=',   GLEX_EMPTY, 0,  QL_1_TOK_EQ,          GLEX_ACCEPT,

/* 9 */  L'>',   GLEX_EMPTY, ST_GE,      0,               GLEX_ACCEPT,
/* 10 */  L'<',   GLEX_EMPTY, ST_LE,      0,               GLEX_ACCEPT,
/* 11 */ L'0',   L'9',       ST_NUMERIC, 0,               GLEX_ACCEPT,
/* 12 */ L'"',   GLEX_EMPTY, ST_STRING,  0,               GLEX_CONSUME,
/* 13 */ L'\'',  GLEX_EMPTY, ST_STRING2, 0,               GLEX_CONSUME,
/* 14 */ L'!',   GLEX_EMPTY, ST_NE,      0,               GLEX_ACCEPT,
/* 15 */ L'-',   GLEX_EMPTY, ST_NEGATIVE_NUM, 0,               GLEX_ACCEPT,

    // Whitespace, newlines, etc.
/* 16 */ L' ',   GLEX_EMPTY, 0,          0,               GLEX_CONSUME,
/* 17 */ L'\t',  GLEX_EMPTY, 0,  0,               GLEX_CONSUME,
/* 18 */ L'\n',  GLEX_EMPTY, 0,  0,               GLEX_CONSUME|GLEX_LINEFEED,
/* 19 */ L'\r',  GLEX_EMPTY, 0,  0,               GLEX_CONSUME,
/* 20 */ 0,      GLEX_EMPTY, 0,  QL_1_TOK_EOF,   GLEX_CONSUME|GLEX_RETURN, // Note forced return
/* 21 */ L',',   GLEX_EMPTY, 0,  QL_1_TOK_COMMA, GLEX_ACCEPT,
/* 22 */ L'+',   GLEX_EMPTY, ST_POSITIVE_NUM, 0,               GLEX_CONSUME,

    // Unknown characters

/* 23 */ GLEX_ANY, GLEX_EMPTY, 0,        QL_1_TOK_ERROR, GLEX_ACCEPT|GLEX_RETURN,

// ST_STRING
/* 24 */   L'\n', GLEX_EMPTY, 0,  QL_1_TOK_ERROR,    GLEX_ACCEPT|GLEX_LINEFEED,
/* 25 */   L'\r', GLEX_EMPTY, 0,  QL_1_TOK_ERROR,    GLEX_ACCEPT|GLEX_LINEFEED,
/* 26 */   L'"',  GLEX_EMPTY, 0,  QL_1_TOK_QSTRING,  GLEX_CONSUME,
/* 27 */   L'\\',  GLEX_EMPTY, ST_STRING_ESC,  0,     GLEX_CONSUME,
/* 28 */   GLEX_ANY, GLEX_EMPTY, ST_STRING, 0,        GLEX_ACCEPT,
                                                      
// ST_IDENT

/* 29 */  L'a',   L'z',       ST_IDENT,   0,          GLEX_ACCEPT,
/* 30 */  L'A',   L'Z',       ST_IDENT,   0,          GLEX_ACCEPT,
/* 31 */  L'_',   GLEX_EMPTY, ST_IDENT,   0,          GLEX_ACCEPT,
/* 32 */  L'0',   L'9',       ST_IDENT,   0,          GLEX_ACCEPT,
/* 33 */  0x80,  0xfffd,     ST_IDENT,   0,          GLEX_ACCEPT,
/* 34 */  GLEX_ANY, GLEX_EMPTY,  0,       QL_1_TOK_IDENT,  GLEX_PUSHBACK|GLEX_RETURN,

// ST_GE
/* 35 */  L'=',   GLEX_EMPTY,  0,  QL_1_TOK_GE,  GLEX_ACCEPT,
/* 36 */  GLEX_ANY, GLEX_EMPTY,  0,       QL_1_TOK_GT,   GLEX_PUSHBACK|GLEX_RETURN,

// ST_LE
/* 37 */  L'=',   GLEX_EMPTY,      0,  QL_1_TOK_LE,  GLEX_ACCEPT,
/* 38 */  L'>',   GLEX_EMPTY,      0,  QL_1_TOK_NE,  GLEX_ACCEPT,
/* 39 */  GLEX_ANY, GLEX_EMPTY,    0,  QL_1_TOK_LT,  GLEX_PUSHBACK|GLEX_RETURN,

// ST_NE
/* 40 */  L'=',   GLEX_EMPTY,      0,  QL_1_TOK_NE,     GLEX_ACCEPT,
/* 41 */  GLEX_ANY,  GLEX_EMPTY,   0,  QL_1_TOK_ERROR,  GLEX_ACCEPT|GLEX_RETURN,

// ST_NUMERIC
/* 42 */  L'0',   L'9',         ST_NUMERIC, 0,          GLEX_ACCEPT,
/* 43 */  L'.',   GLEX_EMPTY,   ST_REAL,    0,          GLEX_ACCEPT,
/* 44 */  L'E',   GLEX_EMPTY,   ST_REAL, 0,      GLEX_ACCEPT,
/* 45 */  L'e',   GLEX_EMPTY,   ST_REAL, 0,      GLEX_ACCEPT,
/* 46 */  GLEX_ANY, GLEX_EMPTY, 0,          QL_1_TOK_INT,  GLEX_PUSHBACK|GLEX_RETURN,

// ST_REAL
/* 47 */  L'0',   L'9',   ST_REAL, 0,          GLEX_ACCEPT,
/* 48 */  L'E',   GLEX_EMPTY, ST_REAL, 0,      GLEX_ACCEPT,
/* 49 */  L'e',   GLEX_EMPTY, ST_REAL, 0,      GLEX_ACCEPT,
/* 50 */  L'+',   GLEX_EMPTY, ST_REAL, 0,      GLEX_ACCEPT,
/* 51 */  L'-',   GLEX_EMPTY, ST_REAL, 0,      GLEX_ACCEPT,
/* 52 */  GLEX_ANY,       GLEX_EMPTY,   0,     QL_1_TOK_REAL, GLEX_PUSHBACK|GLEX_RETURN,

// ST_STRING2
/* 53 */   L'\n',  GLEX_EMPTY, 0,  QL_1_TOK_ERROR,     GLEX_ACCEPT|GLEX_LINEFEED,
/* 54 */   L'\r',  GLEX_EMPTY, 0,  QL_1_TOK_ERROR,     GLEX_ACCEPT|GLEX_LINEFEED,
/* 55 */   L'\'',  GLEX_EMPTY, 0,  QL_1_TOK_QSTRING,   GLEX_CONSUME,
/* 56 */   L'\\',  GLEX_EMPTY, ST_STRING2_ESC,  0,      GLEX_CONSUME,
/* 57 */   GLEX_ANY, GLEX_EMPTY, ST_STRING2, 0,        GLEX_ACCEPT,

// ST_STRING_ESC
/* 58 */   L'"', GLEX_EMPTY, ST_STRING, 0, GLEX_ACCEPT,
/* 59 */   L'\\', GLEX_EMPTY, ST_STRING, 0, GLEX_ACCEPT,
/* 60 */   GLEX_ANY, GLEX_EMPTY, 0, QL_1_TOK_ERROR, GLEX_ACCEPT|GLEX_RETURN,

// ST_STRING2_ESC
/* 61 */   L'\'', GLEX_EMPTY, ST_STRING2, 0, GLEX_ACCEPT,
/* 62 */   L'\\', GLEX_EMPTY, ST_STRING2, 0, GLEX_ACCEPT,
/* 63 */   GLEX_ANY, GLEX_EMPTY, 0, QL_1_TOK_ERROR, GLEX_ACCEPT|GLEX_RETURN,

// ST_DOT
/* 64 */  L'0',   L'9',   ST_REAL, 0,          GLEX_ACCEPT,
/* 65 */  GLEX_ANY,       GLEX_EMPTY,   0,     QL_1_TOK_DOT, GLEX_PUSHBACK|GLEX_RETURN,


// ST_NEGATIVE_NUM - Strips whitespace after '-'
/* 66 */ L' ', GLEX_EMPTY, ST_NEGATIVE_NUM, 0, GLEX_CONSUME,
/* 67 */ L'0', L'9',       ST_NUMERIC, 0, GLEX_ACCEPT,
/* 68 */ GLEX_ANY, GLEX_EMPTY, 0, QL_1_TOK_ERROR, GLEX_ACCEPT|GLEX_RETURN,

// ST_POSITIVE_NUM - Strips whitespace after '+'
/* 69 */ L' ', GLEX_EMPTY, ST_POSITIVE_NUM, 0, GLEX_CONSUME,
/* 70 */ L'0', L'9',       ST_NUMERIC, 0, GLEX_ACCEPT,
/* 71 */ GLEX_ANY, GLEX_EMPTY, 0, QL_1_TOK_ERROR, GLEX_ACCEPT|GLEX_RETURN,

};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\winmgmt\wbemcomn\ql.cpp ===
/*++

Copyright (C) 1996-2001 Microsoft Corporation

Module Name:

    QL.CPP

Abstract:

    Level 1 Syntax QL Parser

    Implements the syntax described in QL_1.BNF.  This translates the input
    into an RPN stream of tokens.

History:

    a-raymcc    21-Jun-96       Created.
    mdavis      23-Apr-99       Changed to allow 'group' as a property name
                              for Raid 47767.  Also fixed GetText() for
                              property comparisons and improved Dump().

--*/

#include "precomp.h"
#include <stdio.h>
#include <errno.h>

#include <math.h>

#include <corepol.h>
#include <genlex.h>
#include <qllex.h>
#include <ql.h>
#include <wbemcomn.h>
#include <wbemutil.h>
#include <genutils.h>
#include <corex.h>

#define trace(x) //printf x

WBEM_WSTR WbemStringAlloc(unsigned long lNumChars)
{
    return (WBEM_WSTR)CoTaskMemAlloc(lNumChars+1);
}

void WbemStringFree(WBEM_WSTR String)
{
    CoTaskMemFree(String);
}

unsigned long WbemStringLen(const WCHAR* String)
{
    return wcslen(String);
}

WBEM_WSTR WbemStringCopy(const WCHAR* String)
{
    if(String == NULL) return NULL;
	size_t newLength = wcslen(String)+1;
    WBEM_WSTR NewString = (WBEM_WSTR)CoTaskMemAlloc(2*newLength);
    if(NewString == NULL) return NULL;
    
	StringCchCopyW(NewString, newLength, String);
    
	return NewString;
}

//***************************************************************************
//
//  WCHARToDOUBLE
//
//  Converts a wchar to a double, but does it using the english locale rather
//  than whatever local the process is running in.  This allows us to support
//  all english queries even on German machines.
//
//***************************************************************************

DOUBLE WCHARToDOUBLE(WCHAR * pConv, bool & bSuccess)
{
    bSuccess = false;
    if(pConv == NULL)
        return 0.0;

    VARIANT varTo, varFrom;
    VariantInit(&varTo);

    varFrom.vt = VT_BSTR;
    varFrom.bstrVal = SysAllocString(pConv);

    if ( varFrom.bstrVal == NULL )
    {
        return 0.0;
    }

    SCODE sc = VariantChangeTypeEx(&varTo, &varFrom, 0x409, 0, VT_R8);

    SysFreeString(varFrom.bstrVal);

    if ( FAILED(sc) )
    {
        return 0.0;
    }

    bSuccess = true;

    return varTo.dblVal;
}

CPropertyName::CPropertyName(const CPropertyName& Other)
{
    Init();
    *this = Other;
}

void CPropertyName::Init()
{
    m_lNumElements = 0;
    m_lAllocated = 0;
    m_aElements = NULL;
    m_pvHandle = NULL;
}

void CPropertyName::operator=(const CPropertyName& Other)
{
    *this = (const WBEM_PROPERTY_NAME&)Other;
    m_pvHandle = Other.m_pvHandle;
}

void CPropertyName::operator=(const WBEM_PROPERTY_NAME& Other)
{
    Empty();

    if ( Other.m_lNumElements > 0)
    {
        m_aElements = new WBEM_NAME_ELEMENT[Other.m_lNumElements];

        if ( m_aElements == NULL )
        {
            throw CX_MemoryException();
        }
    }

    m_lAllocated = Other.m_lNumElements;

    for( long l=0 ; l < Other.m_lNumElements; l++ )
    {
        if(Other.m_aElements[l].m_nType == WBEM_NAME_ELEMENT_TYPE_PROPERTY)
        {
            m_aElements[l].Element.m_wszPropertyName =
                WbemStringCopy(Other.m_aElements[l].Element.m_wszPropertyName);

            if ( m_aElements[l].Element.m_wszPropertyName == NULL )
            {
                break;
            }
        }
        else
        {
            m_aElements[l].Element.m_lArrayIndex =
                Other.m_aElements[l].Element.m_lArrayIndex;
        }

        m_aElements[l].m_nType = Other.m_aElements[l].m_nType;
    }

    m_lNumElements = l;

    if ( m_lNumElements != Other.m_lNumElements )
    {
        throw CX_MemoryException();
    }
}

BOOL CPropertyName::operator==(const WBEM_PROPERTY_NAME& Other)
{
    if(m_lNumElements != Other.m_lNumElements)
        return FALSE;

    for(long l = 0; l < m_lNumElements; l++)
    {
        if(m_aElements[l].m_nType != Other.m_aElements[l].m_nType)
            return FALSE;
        if(m_aElements[l].m_nType == WBEM_NAME_ELEMENT_TYPE_PROPERTY)
        {
            if(wbem_wcsicmp(m_aElements[l].Element.m_wszPropertyName,
                        Other.m_aElements[l].Element.m_wszPropertyName))
            {
                return FALSE;
            }
        }
        else
        {
            if(m_aElements[l].Element.m_lArrayIndex !=
                Other.m_aElements[l].Element.m_lArrayIndex)
            {
                return FALSE;
            }
        }
    }

    return TRUE;
}

void CPropertyName::Empty()
{
    if ( m_aElements!=NULL )
    {   
        for(long l = 0; l < m_lNumElements; l++)
        {
            if(m_aElements[l].m_nType == WBEM_NAME_ELEMENT_TYPE_PROPERTY)
            {
                WbemStringFree(m_aElements[l].Element.m_wszPropertyName);
            }
        }
        delete [] m_aElements;
        m_aElements = NULL;
    }
    m_lNumElements = 0;
    m_lAllocated = 0;
    m_pvHandle = NULL;
}

LPCWSTR CPropertyName::GetStringAt(long lIndex) const
{
    if(m_aElements[lIndex].m_nType == WBEM_NAME_ELEMENT_TYPE_PROPERTY)
    {
        return m_aElements[lIndex].Element.m_wszPropertyName;
    }
    else return NULL;
}

void CPropertyName::AddElement(LPCWSTR wszElement)
{
    if ( wszElement == NULL )
        throw CX_MemoryException();

    EnsureAllocated(m_lNumElements+1);

    LPWSTR wszTemp = WbemStringCopy(wszElement);

    if ( wszTemp == NULL )
    {
        throw CX_MemoryException();
    }

    m_aElements[m_lNumElements].m_nType = WBEM_NAME_ELEMENT_TYPE_PROPERTY;
    m_aElements[m_lNumElements].Element.m_wszPropertyName = wszTemp;
    m_lNumElements++;
}

void CPropertyName::EnsureAllocated(long lElements)
{
    if(m_lAllocated < lElements)
    {
        WBEM_NAME_ELEMENT* pTemp = new WBEM_NAME_ELEMENT[lElements+5];
        if (!pTemp)
            throw CX_MemoryException();
        m_lAllocated = lElements+5;
        memcpy(pTemp, m_aElements, sizeof(WBEM_NAME_ELEMENT) * m_lNumElements);
        delete [] m_aElements;
        m_aElements = pTemp;
    }
}

DELETE_ME LPWSTR CPropertyName::GetText()
{
    WString wsText;
    for(int i = 0; i < m_lNumElements; i++)
    {
        if(m_aElements[i].m_nType != WBEM_NAME_ELEMENT_TYPE_PROPERTY)
            return NULL;
        if(i > 0)
            wsText += L".";
        wsText += m_aElements[i].Element.m_wszPropertyName;
    }
    return wsText.UnbindPtr();
}




//***************************************************************************
//***************************************************************************


DWORD CAbstractQl1Parser::TranslateIntrinsic(LPCWSTR pFuncName)
{
    if (wbem_wcsicmp(pFuncName, L"UPPER") == 0)
        return QL1_FUNCTION_UPPER;
    if (wbem_wcsicmp(pFuncName, L"LOWER") == 0)
        return QL1_FUNCTION_LOWER;
    return QL1_FUNCTION_NONE;
}

void CAbstractQl1Parser::InitToken(WBEM_QL1_TOKEN* pToken)
{
    pToken->m_lTokenType = QL1_NONE;
    pToken->m_PropertyName.m_lNumElements = 0;
    pToken->m_PropertyName.m_aElements = NULL;

    pToken->m_PropertyName2.m_lNumElements = 0;
    pToken->m_PropertyName2.m_aElements = NULL;

    VariantInit(&pToken->m_vConstValue);
}


CAbstractQl1Parser::CAbstractQl1Parser(CGenLexSource *pSrc)
{
    m_pLexer = new CGenLexer(Ql_1_LexTable, pSrc);


    if ( m_pLexer == NULL || GetLastError() == ERROR_NOT_ENOUGH_MEMORY)
    {
		delete m_pLexer;
        throw CX_MemoryException();
    }


    m_nLine = 0;
    m_pTokenText = 0;
    m_nCurrentToken = 0;

    // Semantic transfer variables.
    // ============================
    m_nRelOp = 0;
    VariantInit(&m_vTypedConst);
    m_dwPropFunction = 0;
    m_dwConstFunction = 0;
    m_PropertyName.m_lNumElements = 0;
    m_PropertyName.m_aElements = NULL;
    m_PropertyName2.m_lNumElements = 0;
    m_PropertyName2.m_aElements = NULL;
    m_bPropComp = FALSE;
}

CAbstractQl1Parser::~CAbstractQl1Parser()
{
    VariantClear(&m_vTypedConst);
    DeletePropertyName();
    delete m_pLexer;
}


int CAbstractQl1Parser::Parse(CQl1ParseSink* pSink, int nFlags)
{
    m_pSink = pSink;
    int nRes = parse(nFlags);
    m_pSink = NULL;
    return nRes;
}

//***************************************************************************
//
//  Next()
//
//  Advances to the next token and recognizes keywords, etc.
//
//***************************************************************************

BOOL CAbstractQl1Parser::Next(int nFlags)
{
    m_nCurrentToken = m_pLexer->NextToken();
    if (m_nCurrentToken == QL_1_TOK_ERROR)
        return FALSE;

    m_nLine = m_pLexer->GetLineNum();
    m_pTokenText = m_pLexer->GetTokenText();
    if (m_nCurrentToken == QL_1_TOK_EOF)
        m_pTokenText = L"<end of file>";

    // Keyword check.
    // ==============

    if (m_nCurrentToken == QL_1_TOK_IDENT && nFlags != NO_KEYWORDS)
    {
        if (wbem_wcsicmp(m_pTokenText, L"select") == 0)
            m_nCurrentToken = QL_1_TOK_SELECT;
        else if (wbem_wcsicmp(m_pTokenText, L"from") == 0)
            m_nCurrentToken = QL_1_TOK_FROM;
        else if (wbem_wcsicmp(m_pTokenText, L"where") == 0)
            m_nCurrentToken = QL_1_TOK_WHERE;
        else if (wbem_wcsicmp(m_pTokenText, L"like") == 0)
            m_nCurrentToken = QL_1_TOK_LIKE;
        else if (nFlags != EXCLUDE_EXPRESSION_KEYWORDS && wbem_wcsicmp(m_pTokenText, L"or") == 0)
            m_nCurrentToken = QL_1_TOK_OR;
        else if (nFlags != EXCLUDE_EXPRESSION_KEYWORDS && wbem_wcsicmp(m_pTokenText, L"and") == 0)
            m_nCurrentToken = QL_1_TOK_AND;
        else if (nFlags != EXCLUDE_EXPRESSION_KEYWORDS && wbem_wcsicmp(m_pTokenText, L"not") == 0)
            m_nCurrentToken = QL_1_TOK_NOT;
        else if (nFlags != EXCLUDE_EXPRESSION_KEYWORDS && wbem_wcsicmp(m_pTokenText, L"IS") == 0)
            m_nCurrentToken = QL_1_TOK_IS;
        else if (nFlags != EXCLUDE_EXPRESSION_KEYWORDS && wbem_wcsicmp(m_pTokenText, L"NULL") == 0)
            m_nCurrentToken = QL_1_TOK_NULL;
        else if (wbem_wcsicmp(m_pTokenText, L"WITHIN") == 0)
            m_nCurrentToken = QL_1_TOK_WITHIN;
        else if (nFlags != EXCLUDE_EXPRESSION_KEYWORDS && wbem_wcsicmp(m_pTokenText, L"ISA") == 0)
            m_nCurrentToken = QL_1_TOK_ISA;
        else if (nFlags != EXCLUDE_GROUP_KEYWORD && wbem_wcsicmp(m_pTokenText, L"GROUP") == 0)
            m_nCurrentToken = QL_1_TOK_GROUP;
        else if (wbem_wcsicmp(m_pTokenText, L"BY") == 0)
            m_nCurrentToken = QL_1_TOK_BY;
        else if (wbem_wcsicmp(m_pTokenText, L"HAVING") == 0)
            m_nCurrentToken = QL_1_TOK_HAVING;
        else if (nFlags != EXCLUDE_EXPRESSION_KEYWORDS && wbem_wcsicmp(m_pTokenText, L"TRUE") == 0)
            m_nCurrentToken = QL_1_TOK_TRUE;
        else if (nFlags != EXCLUDE_EXPRESSION_KEYWORDS && wbem_wcsicmp(m_pTokenText, L"FALSE") == 0)
            m_nCurrentToken = QL_1_TOK_FALSE;
    }

    return TRUE;
}

LPCWSTR CAbstractQl1Parser::GetSinglePropertyName()
{
    if(m_PropertyName.m_lNumElements < 1)
        return NULL;

    if(m_PropertyName.m_aElements[0].m_nType != WBEM_NAME_ELEMENT_TYPE_PROPERTY)
        return NULL;

    return m_PropertyName.m_aElements[0].Element.m_wszPropertyName;
}

void CAbstractQl1Parser::DeletePropertyName()
{
    for(long l = 0; l < m_PropertyName.m_lNumElements; l++)
    {
        if(m_PropertyName.m_aElements[l].m_nType ==
                                             WBEM_NAME_ELEMENT_TYPE_PROPERTY)
        {
            WbemStringFree(m_PropertyName.m_aElements[l].
                                Element.m_wszPropertyName);
        }
    }
    delete [] m_PropertyName.m_aElements;
    m_PropertyName.m_lNumElements = 0;
    m_PropertyName.m_aElements = NULL;
}

int CAbstractQl1Parser::FlipOperator(int nOp)
{
    switch(nOp)
    {
    case QL1_OPERATOR_EQUALS:
        return QL1_OPERATOR_EQUALS;

    case QL1_OPERATOR_NOTEQUALS:
        return QL1_OPERATOR_NOTEQUALS;

    case QL1_OPERATOR_GREATER:
        return QL1_OPERATOR_LESS;

    case QL1_OPERATOR_LESS:
        return QL1_OPERATOR_GREATER;

    case QL1_OPERATOR_LESSOREQUALS:
        return QL1_OPERATOR_GREATEROREQUALS;

    case QL1_OPERATOR_GREATEROREQUALS:
        return QL1_OPERATOR_LESSOREQUALS;

    case QL1_OPERATOR_LIKE:
        return QL1_OPERATOR_LIKE;

    case QL1_OPERATOR_UNLIKE:
        return QL1_OPERATOR_UNLIKE;

    case QL1_OPERATOR_ISA:
        return QL1_OPERATOR_INV_ISA;

    case QL1_OPERATOR_ISNOTA:
        return QL1_OPERATOR_INV_ISNOTA;

    case QL1_OPERATOR_INV_ISA:
        return QL1_OPERATOR_ISA;

    case QL1_OPERATOR_INV_ISNOTA:
        return QL1_OPERATOR_ISNOTA;

    default:
        return nOp;
    }
}

void CAbstractQl1Parser::AddAppropriateToken(const WBEM_QL1_TOKEN& Token)
{
    if(m_bInAggregation)
        m_pSink->AddHavingToken(Token);
    else
        m_pSink->AddToken(Token);
}

//***************************************************************************
//
// <parse> ::= SELECT <prop_list> FROM <classname> WHERE <expr>;
//
//***************************************************************************
// ok

int CAbstractQl1Parser::parse(int nFlags)
{
    int nRes;

    m_bInAggregation = FALSE;
    if(nFlags != JUST_WHERE)
    {
        m_pLexer->Reset();

        // SELECT
        // ======
        if (!Next())
            return LEXICAL_ERROR;
        if (m_nCurrentToken != QL_1_TOK_SELECT)
            return SYNTAX_ERROR;
        if (!Next(EXCLUDE_GROUP_KEYWORD))
            return LEXICAL_ERROR;

        // <prop_list>
        // ===========
        if (nRes = prop_list())
            return nRes;

        // FROM
        // ====
        if (m_nCurrentToken != QL_1_TOK_FROM)
            return SYNTAX_ERROR;
        if (!Next())
            return LEXICAL_ERROR;

        // <classname>
        // ===========
        if (nRes = class_name())
            return nRes;

        // <tolerance>
        // ===========

        if(nRes = tolerance())
            return nRes;
    }

    if(nFlags != NO_WHERE)
    {
        // WHERE clause.
        // =============
        if(nRes = opt_where())
            return nRes;

        // GROUP BY clause
        // ===============
        if(nRes = opt_aggregation())
            return nRes;
    }

    return SUCCESS;
}

//***************************************************************************
//
//  <opt_where> ::= WHERE <expr>;
//  <opt_where> ::= <>;
//
//***************************************************************************
int CAbstractQl1Parser::opt_where()
{
    int nRes;

    if (m_nCurrentToken == QL_1_TOK_EOF || m_nCurrentToken == QL_1_TOK_GROUP)
    {
        trace(("No WHERE clause\n"));
        return SUCCESS;
    }

    if (m_nCurrentToken != QL_1_TOK_WHERE)
        return SYNTAX_ERROR;

    if (!Next(EXCLUDE_GROUP_KEYWORD))
        return LEXICAL_ERROR;

    // <expr>
    // ======
    if (nRes = expr())
        return nRes;

    // Verify that the current token is QL_1_TOK_EOF.
    // ===============================================
    if (m_nCurrentToken != QL_1_TOK_EOF && m_nCurrentToken != QL_1_TOK_GROUP)
        return SYNTAX_ERROR;

    return SUCCESS;
}



//***************************************************************************
//
//  <prop_list> ::= <property_name> <prop_list_2>;
//
//***************************************************************************

int CAbstractQl1Parser::prop_list()
{
    int nRes;

    if (m_nCurrentToken != QL_1_TOK_ASTERISK &&
        m_nCurrentToken != QL_1_TOK_IDENT)
        return SYNTAX_ERROR;

    if (nRes = property_name())
        return nRes;

    return prop_list_2();
}

//***************************************************************************
//
//  <prop_list_2> ::= COMMA <prop_list>;
//  <prop_list_2> ::= <>;
//
//***************************************************************************

int CAbstractQl1Parser::prop_list_2()
{
    if (m_nCurrentToken == QL_1_TOK_COMMA)
    {
        if (!Next(EXCLUDE_GROUP_KEYWORD))
            return LEXICAL_ERROR;
        return prop_list();
    }

    return SUCCESS;
}


int CAbstractQl1Parser::parse_property_name(CPropertyName& Prop)
{
    int nCount = 0;
    Prop.Empty();

    try
    {
        while(m_nCurrentToken == QL_1_TOK_IDENT)
        {
            // VERY TEMPORARY: See if this is a count query
            // that should be forwarded to the repository.

            BOOL bSkipNext = FALSE;
            if (!wbem_wcsicmp(L"count", m_pTokenText))
            {
                if (Next() && m_nCurrentToken == QL_1_TOK_OPEN_PAREN)
                {
                    if (!Next() || m_nCurrentToken != QL_1_TOK_ASTERISK)
                        return LEXICAL_ERROR;
                    if (!Next() || m_nCurrentToken != QL_1_TOK_CLOSE_PAREN)
                        return LEXICAL_ERROR;
                    Prop.AddElement(L"count(*)");
                    m_pSink->SetCountQuery();
                }
                else
                {
                    bSkipNext = TRUE;
                    Prop.AddElement(L"count");
                }
            }
            else
                Prop.AddElement(m_pTokenText);

            nCount++;

            if (!bSkipNext)
            {
                if(!Next())
                    return LEXICAL_ERROR;
            }

            if(m_nCurrentToken != QL_1_TOK_DOT)
                break;

            if(!Next(EXCLUDE_GROUP_KEYWORD))
                return LEXICAL_ERROR;
        }
    }
    catch (CX_MemoryException)
    {
        return OUT_OF_MEMORY;
    }
    catch (...)
    {
        return FAILED;
    }

    if (nCount)
        return SUCCESS;
    else
        return SYNTAX_ERROR;
}

//***************************************************************************
//
//  <property_name> ::= PROPERTY_NAME_STRING;
//  <property_name> ::= ASTERISK;
//
//***************************************************************************

int CAbstractQl1Parser::property_name()
{
    try
    {
        if (m_nCurrentToken == QL_1_TOK_ASTERISK)
        {
            trace(("Asterisk\n"));

            if(m_bInAggregation)
                m_pSink->AddAllAggregationProperties();
            else
                m_pSink->AddAllProperties();

            if(!Next())
                return LEXICAL_ERROR;

            return SUCCESS;
        }

        // Else a list of property names
        // =============================

        CPropertyName Prop;
        int nRes = parse_property_name(Prop);
        if(nRes != SUCCESS)
            return nRes;

        if(m_bInAggregation)
            m_pSink->AddAggregationProperty(Prop);
        else
            m_pSink->AddProperty(Prop);
    }
    catch (CX_MemoryException)
    {
        return OUT_OF_MEMORY;
    }
    catch (...)
    {
        return FAILED;
    }

    return SUCCESS;
}


//***************************************************************************
//
//  <classname> ::= CLASS_NAME_STRING;
//
//***************************************************************************

int CAbstractQl1Parser::class_name()
{
    if (m_nCurrentToken != QL_1_TOK_IDENT)
        return SYNTAX_ERROR;

    trace(("Class name is %S\n", m_pTokenText));
    m_pSink->SetClassName(m_pTokenText);

    if (!Next())
        return LEXICAL_ERROR;

    return SUCCESS;
}

//***************************************************************************
//
//  <tolerance> ::= <>;
//  <tolerance> ::= WITHIN duration;
//
//***************************************************************************

int CAbstractQl1Parser::tolerance()
{
    LPWSTR wszGarbage;
    WBEM_QL1_TOLERANCE Tolerance;
    if(m_nCurrentToken != QL_1_TOK_WITHIN)
    {
        Tolerance.m_bExact = TRUE;
        m_pSink->SetTolerance(Tolerance);
        return SUCCESS;
    }

    if(!Next())
        return LEXICAL_ERROR;

    if (m_nCurrentToken == QL_1_TOK_REAL)
    {
        Tolerance.m_bExact = FALSE;
        bool bSuccess;
        Tolerance.m_fTolerance = WCHARToDOUBLE(m_pTokenText, bSuccess);
        if(Tolerance.m_fTolerance <= 0 || bSuccess == false)
        {
            return SYNTAX_ERROR;
        }
        m_pSink->SetTolerance(Tolerance);
        Next();
        return SUCCESS;
    }
    else if (m_nCurrentToken == QL_1_TOK_INT)
    {
        Tolerance.m_bExact = FALSE;
        Tolerance.m_fTolerance = wcstol(m_pTokenText, &wszGarbage, 10);
        if(Tolerance.m_fTolerance < 0)
        {
            return SYNTAX_ERROR;
        }
        m_pSink->SetTolerance(Tolerance);
        Next();
        return SUCCESS;
    }
    else
    {
        return SYNTAX_ERROR;
    }
}

//***************************************************************************
//
//  <expr> ::= <term> <expr2>;
//
//***************************************************************************

int CAbstractQl1Parser::expr()
{
    int nRes;

    if (nRes = term())
        return nRes;

    if (nRes = expr2())
        return nRes;

    return SUCCESS;
}

//***************************************************************************
//
//  <expr2> ::= OR <term> <expr2>;
//  <expr2> ::= <>;
//
//  Entry: Assumes token OR already current.
//  Exit:  Advances a token
//
//***************************************************************************

int CAbstractQl1Parser::expr2()
{
    int nRes;

    while (1)
    {
        if (m_nCurrentToken == QL_1_TOK_OR)
        {
            trace(("Token OR\n"));
            m_pSink->InOrder(QL1_OR);

            if (!Next(EXCLUDE_GROUP_KEYWORD))
                return LEXICAL_ERROR;

            if (nRes = term())
                return nRes;

            WBEM_QL1_TOKEN NewTok;
            InitToken(&NewTok);
            NewTok.m_lTokenType = QL1_OR;
            AddAppropriateToken(NewTok);
        }
        else break;
    }

    return SUCCESS;
}

//***************************************************************************
//
//  <term> ::= <simple_expr> <term2>;
//
//***************************************************************************

int CAbstractQl1Parser::term()
{
    int nRes;
    if (nRes = simple_expr())
        return nRes;

    if (nRes = term2())
        return nRes;

    return SUCCESS;
}

//***************************************************************************
//
//  <term2> ::= AND <simple_expr> <term2>;
//  <term2> ::= <>;
//
//***************************************************************************

int CAbstractQl1Parser::term2()
{
    int nRes;

    while (1)
    {
        if (m_nCurrentToken == QL_1_TOK_AND)
        {
            trace(("Token AND\n"));
            m_pSink->InOrder(QL1_AND);

            if (!Next(EXCLUDE_GROUP_KEYWORD))
                return LEXICAL_ERROR;

            if (nRes = simple_expr())
                return nRes;

            // Add the AND token.
            // ==================
            WBEM_QL1_TOKEN NewTok;
            InitToken(&NewTok);
            NewTok.m_lTokenType = QL1_AND;
            AddAppropriateToken(NewTok);
        }
        else break;
    }

    return SUCCESS;
}


//***************************************************************************
//
//  <simple_expr> ::= NOT <expr>;
//  <simple_expr> ::= OPEN_PAREN <expr> CLOSE_PAREN;
//  <simple_expr> ::= IDENTIFIER <leading_ident_expr> <finalize>;
//  <simple_expr> ::= VARIANT <rel_operator> <trailing_prop_expr> <finalize>;
//
//***************************************************************************
// ok
int CAbstractQl1Parser::simple_expr()
{
    int nRes;

    // NOT <expr>
    // ==========
    if (m_nCurrentToken == QL_1_TOK_NOT)
    {
        trace(("Operator NOT\n"));
        if (!Next(EXCLUDE_GROUP_KEYWORD))
            return LEXICAL_ERROR;
        if (nRes = simple_expr())
            return nRes;

        WBEM_QL1_TOKEN NewTok;
        InitToken(&NewTok);
        NewTok.m_lTokenType = QL1_NOT;
        AddAppropriateToken(NewTok);

        return SUCCESS;
    }

    // OPEN_PAREN <expr> CLOSE_PAREN
    // =============================
    else if (m_nCurrentToken == QL_1_TOK_OPEN_PAREN)
    {
        trace(("Open Paren: Entering subexpression\n"));
        if (!Next(EXCLUDE_GROUP_KEYWORD))
            return LEXICAL_ERROR;
        if (expr())
            return SYNTAX_ERROR;
        if (m_nCurrentToken != QL_1_TOK_CLOSE_PAREN)
            return SYNTAX_ERROR;
        trace(("Close paren: Exiting subexpression\n"));
        if (!Next())
            return LEXICAL_ERROR;

        return SUCCESS;
    }

    // IDENTIFIER <leading_ident_expr> <finalize>
    // ==========================================
    else if (m_nCurrentToken == QL_1_TOK_IDENT)
    {
        trace(("    Identifier <%S>\n", m_pTokenText));

        if(nRes = parse_property_name(m_PropertyName))
            return nRes;

        if (nRes = leading_ident_expr())
            return SYNTAX_ERROR;

        return finalize();
    }

    // <typed_constant> <rel_operator> <trailing_prop_expr> <finalize>
    // ======================================================
    else if (m_nCurrentToken == QL_1_TOK_INT ||
             m_nCurrentToken == QL_1_TOK_REAL ||
             m_nCurrentToken == QL_1_TOK_TRUE ||
             m_nCurrentToken == QL_1_TOK_FALSE ||
             m_nCurrentToken == QL_1_TOK_NULL ||
             m_nCurrentToken == QL_1_TOK_QSTRING
            )
    {
        if (nRes = typed_constant())
            return nRes;

        if (nRes = rel_operator())
            return nRes;

        // dont allow const followed by isa!

        if(m_nRelOp == QL1_OPERATOR_ISA)
            return SYNTAX_ERROR;

        // Since we always view the token as IDENT <rel> constant, we need
        // to invert this operator, e.g. replace > with <
        // ================================================================

        m_nRelOp = FlipOperator(m_nRelOp);

        if (nRes = trailing_prop_expr())
            return nRes;

        return finalize();
    }

    return SYNTAX_ERROR;
}


//***************************************************************************
//
//  <trailing_prop_expr> ::=  IDENTIFIER
//
//***************************************************************************
// ok
int CAbstractQl1Parser::trailing_prop_expr()
{
    if (m_nCurrentToken != QL_1_TOK_IDENT)
        return SYNTAX_ERROR;

    int nRes = parse_property_name(m_PropertyName);
    return nRes;
}

//***************************************************************************
//
//  <leading_ident_expr> ::= <comp_operator> <trailing_const_expr>;
//  <leading_ident_expr> ::= <equiv_operator> <trailing_or_null>;
//  <leading_ident_expr> ::= <is_operator> NULL;
//
//***************************************************************************
// ok
int CAbstractQl1Parser::leading_ident_expr()
{
    int nRes;
    if (SUCCESS ==  comp_operator())
    {
        return trailing_const_expr();
    }
    else if(SUCCESS == equiv_operator())
        return trailing_or_null();
    nRes = is_operator();
    if(nRes != SUCCESS)
        return nRes;
    if (m_nCurrentToken != QL_1_TOK_NULL)
        return LEXICAL_ERROR;
    if (Next())
    {
        V_VT(&m_vTypedConst) = VT_NULL;
        return SUCCESS;
    }
    else
        return LEXICAL_ERROR;
}


//***************************************************************************
//
//  <trailing_or_null> ::= NULL;
//  <trailing_or_null> ::= <trailing_const_expr>;
//
//***************************************************************************

int CAbstractQl1Parser::trailing_or_null()
{
    if (m_nCurrentToken == QL_1_TOK_NULL)
    {
        if (!Next())
            return LEXICAL_ERROR;
        else
        {
            V_VT(&m_vTypedConst) = VT_NULL;
            return SUCCESS;
        }
    }
    return trailing_const_expr();
}

//***************************************************************************
//
//  <trailing_const_expr> ::= IDENTIFIER OPEN_PAREN
//                            <typed_constant> CLOSE_PAREN;
//  <trailing_const_expr> ::= <typed_constant>;
//  <trailing_const_expr> ::= <trailing_ident_expr>
//
//***************************************************************************
// ok
int CAbstractQl1Parser::trailing_const_expr()
{
    int nRes;
    nRes = typed_constant();
    if (nRes != SUCCESS)
        nRes = trailing_ident_expr();
    return nRes;
}

//***************************************************************************
//
//  <trailing_ident_expr> ::= <property_name>
//
//***************************************************************************
// ok
int CAbstractQl1Parser::trailing_ident_expr()
{
    int nRes = parse_property_name(m_PropertyName2) ;
    if (nRes == SUCCESS)
        m_bPropComp = TRUE;
    return nRes;
}

//***************************************************************************
//
//  <finalize> ::= <>;
//
//  This composes the QL_LEVEL_1_TOKEN for a simple relational expression,
//  complete with any associated intrinsic functions.  All of the other
//  parse functions help isolate the terms of the expression, but only
//  this function builds the token.
//
//  To build the token, the following member variables are used:
//      m_pPropName
//      m_vTypedConst
//      m_dwPropFunction
//      m_dwConstFunction
//      m_nRelOp;
//
//  After the token is built, these are cleared/deallocated as appropriate.
//  No tokens are consumed and the input is not advanced.
//
//***************************************************************************
int CAbstractQl1Parser::finalize()
{
    // At this point, we have all the info needed for a token.
    // =======================================================

    WBEM_QL1_TOKEN NewTok;
    InitToken(&NewTok);

    NewTok.m_lTokenType = QL1_OP_EXPRESSION;
    VariantInit(&NewTok.m_vConstValue);

    memcpy((void*)&NewTok.m_PropertyName,
           (void*)(WBEM_PROPERTY_NAME*)&m_PropertyName,
           sizeof(WBEM_PROPERTY_NAME));

    if (m_bPropComp)
    {
        NewTok.m_bPropComp = true;
        memcpy((void*)&NewTok.m_PropertyName2,
               (void*)(WBEM_PROPERTY_NAME*)&m_PropertyName2,
               sizeof(WBEM_PROPERTY_NAME));
    }
    else
    {
        NewTok.m_bPropComp = false;
        if ( FAILED(VariantCopy(&NewTok.m_vConstValue, &m_vTypedConst) ))
        {
            return OUT_OF_MEMORY;
        }
    }

    NewTok.m_lOperator = m_nRelOp;
    NewTok.m_lPropertyFunction = m_dwPropFunction;
    NewTok.m_lConstFunction = m_dwConstFunction;
    NewTok.m_bQuoted = m_bQuoted;

    AddAppropriateToken(NewTok);

//    m_PropertyName.m_lNumElements = 0;
//    m_PropertyName.m_aElements = NULL;
    m_PropertyName.Empty();
    m_PropertyName2.Empty();

    // Cleanup.
    // ========
    VariantClear(&m_vTypedConst);
    VariantClear(&NewTok.m_vConstValue);
    m_nRelOp = 0;
    m_dwPropFunction = 0;
    m_dwConstFunction = 0;
    m_bPropComp = FALSE;

    return SUCCESS;
}

//***************************************************************************
//
//  <typed_constant> ::= VARIANT;
//
//  Ouput: m_vTypedConst is set to the value of the constant. The only
//         supported types are VT_I4, VT_R8 and VT_BSTR.
//
//***************************************************************************

int CAbstractQl1Parser::typed_constant()
{
    trace(("    Typed constant <%S> ", m_pTokenText));
    VariantClear(&m_vTypedConst);
    m_bQuoted = FALSE;

    if (m_nCurrentToken == QL_1_TOK_INT)
    {
        trace((" Integer\n"));

        // Read it in as a 64-bit one
        // ==========================

        __int64 i64;
        unsigned __int64 ui64;
        BOOL b32bits = FALSE;
        if(ReadI64(m_pTokenText, i64))
        {
            // Check if it is within range of I4
            // =================================

            if(i64 >= - (__int64)0x80000000 && i64 <= 0x7FFFFFFF)
            {
                V_VT(&m_vTypedConst) = VT_I4;
                V_I4(&m_vTypedConst) = (long)i64;
                b32bits = TRUE;
            }
        }
        else if(!ReadUI64(m_pTokenText, ui64))
        {
            // Not a valid number
            // ==================

            return LEXICAL_ERROR;
        }

        if(!b32bits)
        {
            // Valid 64-bit number but not 32-bit
            // ==================================

            BSTR bstr = SysAllocString(m_pTokenText);
            if ( bstr == NULL )
            {
                return OUT_OF_MEMORY;
            }
            V_VT(&m_vTypedConst) = VT_BSTR;
            V_BSTR(&m_vTypedConst) = bstr;
            m_bQuoted = FALSE;
        }
    }
    else if (m_nCurrentToken == QL_1_TOK_QSTRING)
    {
        trace((" String\n"));
        BSTR bstr = SysAllocString(m_pTokenText);
        if ( bstr == NULL )
        {
            return OUT_OF_MEMORY;
        }
        V_VT(&m_vTypedConst) = VT_BSTR;
        V_BSTR(&m_vTypedConst) = bstr;
        m_bQuoted = TRUE;
    }
    else if (m_nCurrentToken == QL_1_TOK_REAL)
    {
        trace((" Real\n"));
        V_VT(&m_vTypedConst) = VT_R8;
        bool bSuccess;
        V_R8(&m_vTypedConst) = WCHARToDOUBLE(m_pTokenText, bSuccess);
        if(bSuccess == false)
            return LEXICAL_ERROR;
    }
    else if(m_nCurrentToken == QL_1_TOK_TRUE)
    {
        V_VT(&m_vTypedConst) = VT_BOOL;
        V_BOOL(&m_vTypedConst) = VARIANT_TRUE;
    }
    else if(m_nCurrentToken == QL_1_TOK_FALSE)
    {
        V_VT(&m_vTypedConst) = VT_BOOL;
        V_BOOL(&m_vTypedConst) = VARIANT_FALSE;
    }
    else if (m_nCurrentToken == QL_1_TOK_NULL)
        V_VT(&m_vTypedConst) = VT_NULL;

    // Else, not a typed constant.
    else
        return SYNTAX_ERROR;

    if (!Next())
        return LEXICAL_ERROR;

    return SUCCESS;
}

//***************************************************************************
//
//  <rel_operator> ::= <equiv_operator>;
//  <rel_operator> ::= <comp_operator>;
//
//***************************************************************************

int CAbstractQl1Parser::rel_operator()
{
    if(SUCCESS == equiv_operator())
        return SUCCESS;
    else if (SUCCESS == comp_operator())
        return SUCCESS;
    else return LEXICAL_ERROR;
}

//***************************************************************************
//
//  <equiv_operator> ::= EQUIV_OPERATOR; // =, !=
//
//  Output: m_nRelOp is set to the correct operator for a QL_LEVEL_1_TOKEN.
//
//***************************************************************************

int CAbstractQl1Parser::equiv_operator()
{
    m_nRelOp = 0;

    if (m_nCurrentToken == QL_1_TOK_EQ)
    {
        trace(("    REL OP =\n"));
        m_nRelOp = QL_LEVEL_1_TOKEN::OP_EQUAL;
    }
    else if (m_nCurrentToken == QL_1_TOK_NE)
    {
        trace(("    REL OP <> (!=) \n"));
        m_nRelOp = QL_LEVEL_1_TOKEN::OP_NOT_EQUAL;
    }
    else
        return SYNTAX_ERROR;

    if (!Next(EXCLUDE_GROUP_KEYWORD))
        return LEXICAL_ERROR;

    return SUCCESS;
}

//***************************************************************************
//
//  <is_operator> ::= IS_OPERATOR; // is, isnot
//
//  Output: m_nRelOp is set to the correct operator for a QL_LEVEL_1_TOKEN.
//
//***************************************************************************

int CAbstractQl1Parser::is_operator()
{
    m_nRelOp = 0;
    if (m_nCurrentToken != QL_1_TOK_IS)
        return SYNTAX_ERROR;

    if (!Next())
        return LEXICAL_ERROR;

    if (m_nCurrentToken == QL_1_TOK_NOT)
    {
        m_nRelOp = QL_LEVEL_1_TOKEN::OP_NOT_EQUAL;
        if (!Next())
            return LEXICAL_ERROR;

        trace(("    REL OP IS NOT \n"));
        m_nRelOp = QL_LEVEL_1_TOKEN::OP_NOT_EQUAL;
        return SUCCESS;
    }
    else
    {
        trace(("    REL OP IS \n"));
        m_nRelOp = QL_LEVEL_1_TOKEN::OP_EQUAL;
        return SUCCESS;
    }

    return SUCCESS;
}

//***************************************************************************
//
//  <comp_operator> ::= COMP_OPERATOR; // <=, >=, <, >, like
//
//  Output: m_nRelOp is set to the correct operator for a QL_LEVEL_1_TOKEN.
//
//***************************************************************************

int CAbstractQl1Parser::comp_operator()
{
    m_nRelOp = 0;

    if (m_nCurrentToken == QL_1_TOK_LE)
    {
        trace(("    REL OP <=\n"));
        m_nRelOp = QL_LEVEL_1_TOKEN::OP_EQUALorLESSTHAN;
    }
    else if (m_nCurrentToken == QL_1_TOK_LT)
    {
        trace(("    REL OP <\n"));
        m_nRelOp = QL_LEVEL_1_TOKEN::OP_LESSTHAN;
    }
    else if (m_nCurrentToken == QL_1_TOK_GE)
    {
        trace(("    REL OP >=\n"));
        m_nRelOp = QL_LEVEL_1_TOKEN::OP_EQUALorGREATERTHAN;
    }
    else if (m_nCurrentToken == QL_1_TOK_GT)
    {
        trace(("    REL OP >\n"));
        m_nRelOp = QL_LEVEL_1_TOKEN::OP_GREATERTHAN;
    }
    else if (m_nCurrentToken == QL_1_TOK_LIKE)
    {
        trace(("    REL OP 'like' \n"));
        m_nRelOp = QL_LEVEL_1_TOKEN::OP_LIKE;
    }
    else if (m_nCurrentToken == QL_1_TOK_ISA)
    {
        trace(("    REL OP 'isa' \n"));
        m_nRelOp = QL1_OPERATOR_ISA;
    }
    else
        return SYNTAX_ERROR;

    if (!Next(EXCLUDE_GROUP_KEYWORD))
        return LEXICAL_ERROR;

    return SUCCESS;
}

int CAbstractQl1Parser::opt_aggregation()
{
    if(m_nCurrentToken == QL_1_TOK_EOF)
        return SUCCESS;

    if(m_nCurrentToken != QL_1_TOK_GROUP)
        return SYNTAX_ERROR;

    if (!Next())
        return LEXICAL_ERROR;

    m_pSink->SetAggregated();

    int nRes = aggregation_params();
    if(nRes)
        return nRes;

    if(nRes = opt_having())
        return nRes;

    // Make sure we've reached the end
    // ===============================

    if(m_nCurrentToken != QL_1_TOK_EOF)
        return SYNTAX_ERROR;

    return SUCCESS;
}

int CAbstractQl1Parser::aggregation_params()
{
    int nRes;
    WBEM_QL1_TOLERANCE Exact;
    Exact.m_bExact = TRUE;

    if(m_nCurrentToken == QL_1_TOK_BY)
    {
        if (!Next(EXCLUDE_GROUP_KEYWORD))
            return LEXICAL_ERROR;

        if(nRes = aggregate_by())
            return nRes;

        if(m_nCurrentToken == QL_1_TOK_WITHIN)
        {
            if (!Next())
                return LEXICAL_ERROR;

            if(nRes = aggregate_within())
                return nRes;
        }
        else
        {
            m_pSink->SetAggregationTolerance(Exact);
        }
    }
    else if(m_nCurrentToken == QL_1_TOK_WITHIN)
    {
        if (!Next())
            return LEXICAL_ERROR;

        if(nRes = aggregate_within())
            return nRes;

        if(m_nCurrentToken == QL_1_TOK_BY)
        {
            if (!Next(EXCLUDE_GROUP_KEYWORD))
                return LEXICAL_ERROR;

            if(nRes = aggregate_by())
                return nRes;
        }
    }
    else
    {
        return SYNTAX_ERROR;
    }

    return SUCCESS;
}

int CAbstractQl1Parser::aggregate_within()
{
    WBEM_QL1_TOLERANCE Tolerance;
    Tolerance.m_bExact = FALSE;
    LPWSTR wszGarbage;

    if (m_nCurrentToken == QL_1_TOK_REAL)
    {
        bool bSuccess;
        Tolerance.m_fTolerance = WCHARToDOUBLE(m_pTokenText, bSuccess);
        if(!bSuccess)
            return SYNTAX_ERROR;
        m_pSink->SetAggregationTolerance(Tolerance);
        Next();
        return SUCCESS;
    }
    else if (m_nCurrentToken == QL_1_TOK_INT)
    {
        Tolerance.m_fTolerance = (double)wcstol(m_pTokenText, &wszGarbage, 10);
        m_pSink->SetAggregationTolerance(Tolerance);
        Next();
        return SUCCESS;
    }
    else
    {
        return SYNTAX_ERROR;
    }
}

int CAbstractQl1Parser::aggregate_by()
{
    m_bInAggregation = TRUE;
    int nRes = prop_list();
    m_bInAggregation = FALSE;
    return nRes;
}

int CAbstractQl1Parser::opt_having()
{
    if(m_nCurrentToken == QL_1_TOK_HAVING)
    {
        if(!Next(EXCLUDE_GROUP_KEYWORD))
            return LEXICAL_ERROR;

        m_bInAggregation = TRUE;
        int nRes = expr();
        m_bInAggregation = FALSE;
        return nRes;
    }
    else return SUCCESS;
}


//***************************************************************************
//***************************************************************************
//
//  class QL1_Parser
//
//  A derivative of CAbstractQlParser for backward compatibility
//
//***************************************************************************
//
//

QL1_Parser::QL1_Parser(CGenLexSource *pSrc)
    : m_pExpression(NULL), CAbstractQl1Parser(pSrc), m_bPartiallyParsed(FALSE)
{
    m_pExpression = new QL_LEVEL_1_RPN_EXPRESSION;

    if ( m_pExpression == NULL )
    {
        throw CX_MemoryException();
    }
}

QL1_Parser::~QL1_Parser()
{
    delete m_pExpression;
}

int QL1_Parser::GetQueryClass(
    LPWSTR pDestBuf,
    int nBufLen
    )
{
    // Get the underlying parser to parse the first part of the query
    // ==============================================================

    if(!m_bPartiallyParsed)
    {
        int nRes = CAbstractQl1Parser::Parse(m_pExpression, NO_WHERE);
        if(nRes != SUCCESS) return nRes;
    }

    if (!m_pExpression->bsClassName)
        return SYNTAX_ERROR;

    m_bPartiallyParsed = TRUE;
    if(wcslen(m_pExpression->bsClassName) >= (unsigned int)nBufLen)
        return BUFFER_TOO_SMALL;

    StringCchCopyW(pDestBuf, nBufLen, m_pExpression->bsClassName);
    return WBEM_S_NO_ERROR;
}

int QL1_Parser::Parse(QL_LEVEL_1_RPN_EXPRESSION **pOutput)
{
    *pOutput = NULL;

    // Get the underying parser to completely parse the query. If
    // GetQueryClass was called in the past, no sense in duplcating
    // the work
    // ============================================================

    QL_LEVEL_1_RPN_EXPRESSION* pTemp = NULL;

	try
	{
		pTemp = new QL_LEVEL_1_RPN_EXPRESSION;
    }
    catch (CX_MemoryException)
    {
        return OUT_OF_MEMORY;
    }

    if ( pTemp == NULL )
    {
       return OUT_OF_MEMORY;
    }

    int nRes = CAbstractQl1Parser::Parse(m_pExpression,
        m_bPartiallyParsed?JUST_WHERE:FULL_PARSE);

    if ( nRes == SUCCESS )
    {
        *pOutput = m_pExpression;
        m_pExpression = pTemp;
        m_bPartiallyParsed = FALSE;
    }
    else
    {
        delete pTemp;
    }

    return nRes;
}

DELETE_ME LPWSTR QL1_Parser::ReplaceClassName(QL_LEVEL_1_RPN_EXPRESSION* pExpr,
                                                LPCWSTR wszClassName)
{
    QL_LEVEL_1_RPN_EXPRESSION NewExpr(*pExpr);

    if (NewExpr.bsClassName)
        SysFreeString(NewExpr.bsClassName);

    NewExpr.bsClassName = SysAllocString(wszClassName);

    if ( NewExpr.bsClassName == NULL )
    {
        return NULL;
    }

    LPWSTR wszNewQuery = NewExpr.GetText();
    return wszNewQuery;
}


//***************************************************************************
//
//  Expression and token structure methods.
//
//***************************************************************************

QL_LEVEL_1_RPN_EXPRESSION::QL_LEVEL_1_RPN_EXPRESSION()
{
    nNumTokens = 0;
    bsClassName = 0;
    bCount = FALSE;
    nNumberOfProperties = 0;
    bStar = FALSE;
    pRequestedPropertyNames = 0;
    nCurSize = 1;
    nCurPropSize = 1;
    pArrayOfTokens = new QL_LEVEL_1_TOKEN[nCurSize];
    pRequestedPropertyNames = new CPropertyName[nCurPropSize];

    bAggregated = FALSE;
    bAggregateAll = FALSE;
    nNumAggregatedProperties = 0;
    nCurAggPropSize = 1;
    pAggregatedPropertyNames = new CPropertyName[nCurAggPropSize];

    nNumHavingTokens = 0;
    nCurHavingSize = 1;
    pArrayOfHavingTokens = new QL_LEVEL_1_TOKEN[nCurHavingSize];

    if ( pArrayOfTokens == NULL || pRequestedPropertyNames == NULL ||
         pAggregatedPropertyNames == NULL || pArrayOfHavingTokens == NULL )
    {
        delete [] pArrayOfTokens;
        delete [] pRequestedPropertyNames;
        delete [] pAggregatedPropertyNames;
        delete [] pArrayOfHavingTokens;
        throw CX_MemoryException();
    }

    lRefCount = 0;
}

QL_LEVEL_1_RPN_EXPRESSION::QL_LEVEL_1_RPN_EXPRESSION(
                                const QL_LEVEL_1_RPN_EXPRESSION& Other)
{
    nNumTokens = Other.nNumTokens;

    nNumberOfProperties = Other.nNumberOfProperties;
    bStar = Other.bStar;
    bCount = Other.bCount;
    pRequestedPropertyNames = 0;
    nCurSize = Other.nCurSize;
    nCurPropSize = Other.nCurPropSize;

    bAggregated = Other.bAggregated;
    bAggregateAll = Other.bAggregateAll;
    nNumAggregatedProperties = Other.nNumAggregatedProperties;
    nCurAggPropSize = Other.nCurAggPropSize;
    nNumHavingTokens = Other.nNumHavingTokens;
    nCurHavingSize = Other.nCurHavingSize;

    bsClassName = SysAllocString(Other.bsClassName);
    pArrayOfTokens = new QL_LEVEL_1_TOKEN[nCurSize];
    pRequestedPropertyNames = new CPropertyName[nCurPropSize];
    pAggregatedPropertyNames = new CPropertyName[nCurAggPropSize];
    pArrayOfHavingTokens = new QL_LEVEL_1_TOKEN[nCurHavingSize];

    if ( pArrayOfTokens == NULL || pRequestedPropertyNames == NULL ||
         pAggregatedPropertyNames == NULL || pArrayOfHavingTokens == NULL ||
         bsClassName == NULL )
    {
        delete [] pArrayOfTokens;
        delete [] pRequestedPropertyNames;
        delete [] pAggregatedPropertyNames;
        delete [] pArrayOfHavingTokens;
        if ( bsClassName != NULL ) SysFreeString( bsClassName );
        throw CX_MemoryException();
    }

    int i;
    for(i = 0; i < nNumTokens; i++)
        pArrayOfTokens[i] = Other.pArrayOfTokens[i];

    for(i = 0; i < nNumberOfProperties; i++)
        pRequestedPropertyNames[i] = Other.pRequestedPropertyNames[i];

    for(i = 0; i < nNumAggregatedProperties; i++)
        pAggregatedPropertyNames[i] = Other.pAggregatedPropertyNames[i];

    for(i = 0; i < nNumHavingTokens; i++)
        pArrayOfHavingTokens[i] = Other.pArrayOfHavingTokens[i];

    lRefCount = 0;
}

void QL_LEVEL_1_RPN_EXPRESSION::AddRef()
{
    InterlockedIncrement(&lRefCount);
}

void QL_LEVEL_1_RPN_EXPRESSION::Release()
{
    if(InterlockedDecrement(&lRefCount) == 0)
        delete this;
}


QL_LEVEL_1_RPN_EXPRESSION::~QL_LEVEL_1_RPN_EXPRESSION()
{
    delete [] pArrayOfTokens;
    if (bsClassName)
        SysFreeString(bsClassName);
    delete [] pAggregatedPropertyNames;
    delete [] pArrayOfHavingTokens;
    delete [] pRequestedPropertyNames;
}

void QL_LEVEL_1_RPN_EXPRESSION::SetClassName(LPCWSTR wszClassName)
{
    if ( bsClassName != NULL )
    {
        SysFreeString( bsClassName );
    }

    bsClassName = SysAllocString(wszClassName);

    if ( bsClassName == NULL )
    {
        throw CX_MemoryException();
    }
}

void QL_LEVEL_1_RPN_EXPRESSION::SetTolerance(
                                const WBEM_QL1_TOLERANCE& _Tolerance)
{
    Tolerance = _Tolerance;
}

void QL_LEVEL_1_RPN_EXPRESSION::SetAggregationTolerance(
                                const WBEM_QL1_TOLERANCE& _Tolerance)
{
    AggregationTolerance = _Tolerance;
}

void QL_LEVEL_1_RPN_EXPRESSION::AddToken(const WBEM_QL1_TOKEN& Tok)
{
    if (nCurSize == nNumTokens)
    {
        nCurSize += 1;
        nCurSize *= 2;

        QL_LEVEL_1_TOKEN *pTemp = new QL_LEVEL_1_TOKEN[nCurSize];

        if ( pTemp == NULL )
        {
            throw CX_MemoryException();
        }

        for (int i = 0; i < nNumTokens; i++)
            pTemp[i] = pArrayOfTokens[i];
        delete [] pArrayOfTokens;
        pArrayOfTokens = pTemp;
    }

    pArrayOfTokens[nNumTokens++] = Tok;
}

void QL_LEVEL_1_RPN_EXPRESSION::AddToken(const QL_LEVEL_1_TOKEN& Tok)
{
    if (nCurSize == nNumTokens)
    {
        nCurSize += 1;
        nCurSize *= 2;

        QL_LEVEL_1_TOKEN *pTemp = new QL_LEVEL_1_TOKEN[nCurSize];

        if ( pTemp == NULL )
        {
            throw CX_MemoryException();
        }

        for (int i = 0; i < nNumTokens; i++)
            pTemp[i] = pArrayOfTokens[i];
        delete [] pArrayOfTokens;
        pArrayOfTokens = pTemp;
    }

    pArrayOfTokens[nNumTokens++] = Tok;
}

void QL_LEVEL_1_RPN_EXPRESSION::AddHavingToken(
                                  const WBEM_QL1_TOKEN& Tok)
{
    if (nCurHavingSize == nNumHavingTokens)
    {
        nCurHavingSize += 1;
        nCurHavingSize *= 2;

        QL_LEVEL_1_TOKEN *pTemp = new QL_LEVEL_1_TOKEN[nCurHavingSize];

        if ( pTemp == NULL )
        {
            throw CX_MemoryException();
        }

        for (int i = 0; i < nNumHavingTokens; i++)
            pTemp[i] = pArrayOfHavingTokens[i];
        delete [] pArrayOfHavingTokens;
        pArrayOfHavingTokens = pTemp;
    }

    pArrayOfHavingTokens[nNumHavingTokens++] = Tok;
}

void QL_LEVEL_1_RPN_EXPRESSION::AddProperty(const CPropertyName& Prop)
{
    if (nCurPropSize == nNumberOfProperties)
    {
        nCurPropSize += 1;
        nCurPropSize *= 2;
        CPropertyName *pTemp = new CPropertyName[nCurPropSize];

        if (!pTemp)
            throw CX_MemoryException();

        for(int i = 0; i < nNumberOfProperties; i++)
            pTemp[i] = pRequestedPropertyNames[i];
        delete [] pRequestedPropertyNames;
        pRequestedPropertyNames = pTemp;
    }

    pRequestedPropertyNames[nNumberOfProperties++] = Prop;
}

void QL_LEVEL_1_RPN_EXPRESSION::AddAllProperties()
{
    bStar = TRUE;
}

void QL_LEVEL_1_RPN_EXPRESSION::SetCountQuery()
{
    bCount = TRUE;
}

void QL_LEVEL_1_RPN_EXPRESSION::SetAggregated()
{
    bAggregated = TRUE;
}

void QL_LEVEL_1_RPN_EXPRESSION::AddAggregationProperty(
                                    const CPropertyName& Property)
{
    if(pAggregatedPropertyNames == NULL)
    {
        // '*' requested
        return;
    }
    if (nCurAggPropSize == nNumAggregatedProperties)
    {
        nCurAggPropSize += 1;
        nCurAggPropSize *= 2;
        CPropertyName *pTemp = new CPropertyName[nCurAggPropSize];

        if ( pTemp == NULL )
        {
            throw CX_MemoryException();
        }

        for(int i = 0; i < nNumAggregatedProperties; i++)
            pTemp[i] = pAggregatedPropertyNames[i];
        delete [] pAggregatedPropertyNames;
        pAggregatedPropertyNames = pTemp;
    }

    pAggregatedPropertyNames[nNumAggregatedProperties++] = Property;
}

void QL_LEVEL_1_RPN_EXPRESSION::AddAllAggregationProperties()
{
    bAggregateAll = TRUE;
}

DELETE_ME LPWSTR QL_LEVEL_1_RPN_EXPRESSION::GetText()
{
    WString wsText;

    wsText += L"select ";
    for(int i = 0; i < nNumberOfProperties; i++)
    {
        if(i != 0) wsText += L", ";
        wsText += (LPWSTR)pRequestedPropertyNames[i].GetStringAt(0);
    }
    if(bStar)
    {
        if(nNumberOfProperties > 0)
            wsText += L", ";
        wsText += L"*";
    }

    wsText += L" from ";
    if (bsClassName)
        wsText += bsClassName;

    if(nNumTokens > 0)
    {
        wsText += L" where ";

        CWStringArray awsStack;
        for(int i = 0; i < nNumTokens; i++)
        {
            QL_LEVEL_1_TOKEN& Token = pArrayOfTokens[i];
            LPWSTR wszTokenText = Token.GetText();
            if(wszTokenText == NULL)
                return NULL;

            if(Token.nTokenType == QL1_OP_EXPRESSION)
            {
                awsStack.Add(wszTokenText);
                delete [] wszTokenText;
            }
            else if(Token.nTokenType == QL1_NOT)
            {
                LPWSTR wszLast = awsStack[awsStack.Size()-1];
                WString wsNew;
                wsNew += wszTokenText;
                delete [] wszTokenText;
                wsNew += L" (";
                wsNew += wszLast;
                wsNew += L")";
                awsStack.RemoveAt(awsStack.Size()-1); //pop
                awsStack.Add(wsNew);
            }
            else
            {
                if(awsStack.Size() < 2) return NULL;

                LPWSTR wszLast = awsStack[awsStack.Size()-1];
                LPWSTR wszPrev = awsStack[awsStack.Size()-2];

                WString wsNew;
                wsNew += L"(";
                wsNew += wszPrev;
                wsNew += L" ";
                wsNew += wszTokenText;
                delete [] wszTokenText;
                wsNew += L" ";
                wsNew += wszLast;
                wsNew += L")";

                awsStack.RemoveAt(awsStack.Size()-1); //pop
                awsStack.RemoveAt(awsStack.Size()-1); //pop

                awsStack.Add(wsNew);
            }
        }

        if(awsStack.Size() != 1) return NULL;
        wsText += awsStack[0];
    }

    return wsText.UnbindPtr();
}

void QL_LEVEL_1_RPN_EXPRESSION::Dump(const char *pszTextFile)
{
    FILE *f = fopen(pszTextFile, "wt");
    if (!f)
        return;

    fprintf(f, "----RPN Expression----\n");
    fprintf(f, "Class name = %S\n", bsClassName);
    fprintf(f, "Properties selected: ");

    if (!nNumberOfProperties)
    {
        fprintf(f, "* = all properties selected\n");
    }
    else for (int i = 0; i < nNumberOfProperties; i++)
    {
        fprintf(f, "%S ", pRequestedPropertyNames[i].GetStringAt(0));
    }
    fprintf(f, "\n------------------\n");
    fprintf(f, "Tokens:\n");

    for (int i = 0; i < nNumTokens; i++)
        pArrayOfTokens[i].Dump(f);

    fprintf(f, "---end of expression---\n");
    fclose(f);
}

QL_LEVEL_1_TOKEN::QL_LEVEL_1_TOKEN()
{
    nTokenType = 0;
    nOperator = 0;
    VariantInit(&vConstValue);
    dwPropertyFunction = 0;
    dwConstFunction = 0;
    bQuoted = TRUE;
    m_bPropComp = FALSE;
}

QL_LEVEL_1_TOKEN::QL_LEVEL_1_TOKEN(const QL_LEVEL_1_TOKEN &Src)
{
    nTokenType = 0;
    nOperator = 0;
    VariantInit(&vConstValue);
    dwPropertyFunction = 0;
    dwConstFunction = 0;
    bQuoted = TRUE;
    m_bPropComp = FALSE;

    *this = Src;
}

QL_LEVEL_1_TOKEN& QL_LEVEL_1_TOKEN::operator =(const QL_LEVEL_1_TOKEN &Src)
{
    if ( FAILED(VariantCopy(&vConstValue, (VARIANT*)&Src.vConstValue)) )
    {
        throw CX_MemoryException();
    }

    nTokenType = Src.nTokenType;
    PropertyName = Src.PropertyName;
    if (Src.m_bPropComp)
        PropertyName2 = Src.PropertyName2;
    nOperator = Src.nOperator;
    dwPropertyFunction = Src.dwPropertyFunction;
    dwConstFunction = Src.dwConstFunction;
    bQuoted = Src.bQuoted;
    m_bPropComp = Src.m_bPropComp;
    return *this;

}

QL_LEVEL_1_TOKEN& QL_LEVEL_1_TOKEN::operator =(const WBEM_QL1_TOKEN &Src)
{
    if ( FAILED(VariantCopy(&vConstValue, (VARIANT*)&Src.m_vConstValue) ) )
    {
        throw CX_MemoryException();
    }

    nTokenType = Src.m_lTokenType;
    PropertyName = Src.m_PropertyName;
    if (Src.m_bPropComp)
        PropertyName2 = Src.m_PropertyName2;
    nOperator = Src.m_lOperator;
    dwPropertyFunction = Src.m_lPropertyFunction;
    dwConstFunction = Src.m_lConstFunction;
    bQuoted = Src.m_bQuoted;
    m_bPropComp = Src.m_bPropComp;
    return *this;
}

QL_LEVEL_1_TOKEN::~QL_LEVEL_1_TOKEN()
{
    nTokenType = 0;
    nOperator = 0;
    VariantClear(&vConstValue);
}

DELETE_ME LPWSTR QL_LEVEL_1_TOKEN::GetText()
{
    WString wsText;
    wmilib::auto_buffer<WCHAR> wszPropName;
    switch (nTokenType)
    {
        case OP_EXPRESSION:
            wszPropName.reset(PropertyName.GetText());
            if(NULL == wszPropName.get()) return NULL;
            wsText += wszPropName.get();
            wsText += L" ";

            WCHAR* wszOp;
            switch (nOperator)
            {
            case OP_EQUAL: wszOp = L"="; break;
            case OP_NOT_EQUAL: wszOp = L"<>"; break;
            case OP_EQUALorGREATERTHAN: wszOp = L">="; break;
            case OP_EQUALorLESSTHAN: wszOp = L"<="; break;
            case OP_LESSTHAN: wszOp = L"<"; break;
            case OP_GREATERTHAN: wszOp = L">"; break;
            case OP_LIKE: wszOp = L"LIKE"; break;
            case QL1_OPERATOR_ISA: wszOp = L"ISA"; break;
            default: wszOp = NULL;
            }
            if(wszOp)
                wsText += wszOp;
            wsText += L" ";

            if (m_bPropComp)
            {
                // property comparison (e.g., prop1 > prop2)
                wszPropName.reset(PropertyName2.GetText());
                if(NULL == wszPropName.get()) return NULL;
                wsText += wszPropName.get();
            }
            else
            {
                // expression with constant (e.g., prop1 > 5)
                WCHAR wszConst[100];
                switch (V_VT(&vConstValue))
                {
                case VT_NULL:
                    wsText += L"NULL";
                    break;
                case VT_I4:
                    StringCchPrintfW(wszConst, 100 , L"%d", V_I4(&vConstValue));
                    wsText += wszConst;
                    break;
                case VT_I2:
                    StringCchPrintfW(wszConst, 100, L"%d", (int)V_I2(&vConstValue));
                    wsText += wszConst;
                    break;
                case VT_UI1:
                    StringCchPrintfW(wszConst, 100, L"%d", (int)V_UI1(&vConstValue));
                    wsText += wszConst;
                    break;
                case VT_BSTR:
                {
                    if(bQuoted)
                        wsText += L"\"";
                    //If we need to parse the string we do it the hard way
                    WCHAR* pwc = V_BSTR(&vConstValue);
                    BOOL bLongMethod = FALSE;
                    for (int tmp = 0; pwc[tmp]; tmp++)
                        if ((pwc[tmp] == L'\\') || (pwc[tmp] == L'"'))
                            bLongMethod = TRUE;
                    if (bLongMethod)
                    {
                        for(pwc; *pwc; pwc++)
                        {
                            if(*pwc == L'\\' || *pwc == L'"')
                                wsText += L'\\';
                            wsText += *pwc;
                        }
                    }
                    else
                    {
                        //otherwise we do it the fast way...
                        wsText += pwc;
                    }
                    if(bQuoted)
                        wsText += L"\"";
                }
                    break;
                case VT_R4:
                    StringCchPrintfW(wszConst, 100, L"%G", V_R4(&vConstValue));
                    wsText += wszConst;
                    break;
                case VT_R8:
                    StringCchPrintfW(wszConst, 100, L"%lG", V_R8(&vConstValue));
                    wsText += wszConst;
                    break;
                case VT_BOOL:
                    wsText += (V_BOOL(&vConstValue)?L"TRUE":L"FALSE");
                    break;
                }
            }

            break;
        case TOKEN_AND:
            wsText = "AND";
            break;
        case TOKEN_OR:
            wsText = "OR";
            break;
        case TOKEN_NOT:
            wsText = "NOT";
            break;
    }

    return wsText.UnbindPtr();
}

void QL_LEVEL_1_TOKEN::Dump(FILE *f)
{
    switch (nTokenType)
    {
        case OP_EXPRESSION:
            fprintf(f, "OP_EXPRESSION ");
            break;
        case TOKEN_AND:
            fprintf(f, "TOKEN_AND ");
            break;
        case TOKEN_OR:
            fprintf(f, "TOKEN_OR ");
            break;
        case TOKEN_NOT:
            fprintf(f, "TOKEN_NOT ");
            break;
        default:
            fprintf(f, "Error: no token type specified\n");
    }

    if (nTokenType == OP_EXPRESSION)
    {
        char *pOp = "<no op>";
        switch (nOperator)
        {
            case OP_EQUAL: pOp = "OP_EQUAL"; break;
            case OP_NOT_EQUAL: pOp = "OP_NOT_EQUAL"; break;
            case OP_EQUALorGREATERTHAN: pOp = "OP_EQUALorGREATERTHAN"; break;
            case OP_EQUALorLESSTHAN: pOp = "OP_EQUALorLESSTHAN"; break;
            case OP_LESSTHAN: pOp = "OP_LESSTHAN"; break;
            case OP_GREATERTHAN: pOp = "OP_GREATERTHAN"; break;
            case OP_LIKE: pOp = "OP_LIKE"; break;
        }

        LPWSTR wszPropName = PropertyName.GetText();
        if(wszPropName == NULL)
            return;
        fprintf(f, "    Property = %S\n", wszPropName);
        delete [] wszPropName;
        fprintf(f, "    Operator = %s\n", pOp);
        fprintf(f, "    Value =    ");

        if (m_bPropComp)
        {
            wszPropName = PropertyName2.GetText();
            if(wszPropName == NULL)
                return;
            fprintf(f, "   <Property:%S>\n", wszPropName);
            delete [] wszPropName;
        }
        else
        {
            switch (V_VT(&vConstValue))
            {
                case VT_I4:
                    fprintf(f, "VT_I4 = %d\n", V_I4(&vConstValue));
                    break;
                case VT_I2:
                    fprintf(f, "VT_I2 = %d\n", (int)V_I2(&vConstValue));
                    break;
                case VT_UI1:
                    fprintf(f, "VT_UI1 = %d\n", (int)V_UI1(&vConstValue));
                    break;
                case VT_BSTR:
                    fprintf(f, "VT_BSTR = %S\n", V_BSTR(&vConstValue));
                    break;
                case VT_R4:
                    fprintf(f, "VT_R4 = %f\n", V_R4(&vConstValue));
                    break;
                case VT_R8:
                    fprintf(f, "VT_R8 = %f\n", V_R8(&vConstValue));
                    break;
                case VT_BOOL:
                    fprintf(f, "%S\n", V_BOOL(&vConstValue)?L"TRUE":L"FALSE");
                    break;
                case VT_NULL:
                    fprintf(f, "%S\n", L"NULL");
                    break;
                default:
                    fprintf(f, "<unknown>\n");
            }

            switch (dwPropertyFunction)
            {
                case IFUNC_NONE:
                    break;
                case IFUNC_LOWER:
                    fprintf(f, "Intrinsic function LOWER() applied to property\n");
                    break;
                case IFUNC_UPPER:
                    fprintf(f, "Intrinsic function UPPER() applied to property\n");
                    break;
            }
            switch (dwConstFunction)
            {
                case IFUNC_NONE:
                    break;
                case IFUNC_LOWER:
                    fprintf(f, "Intrinsic function LOWER() applied to const value\n");
                    break;
                case IFUNC_UPPER:
                    fprintf(f, "Intrinsic function UPPER() applied to const value\n");
                    break;
            }
        }
    }

    fprintf(f, " <end of token>\n");
}

/////////////////////////////////////////////////////////////////////////////
//
// Algorithm for evaluating the expression, assuming that it has been
// tokenized and translated to Reverse Polish.
//
// Starting point:  (a) An array of QL tokens.
//                  (b) An empty boolean token stack.
//
// 1.  Read Next Token
//
// 2.  If a SIMPLE EXPRESSION, evaluate it to TRUE or FALSE, and
//     place this boolean result on the stack.  Go to 1.
//
// 3.  If an OR operator, then pop a boolean token into A,
//     pop another boolean token into B. If either A or B are TRUE,
//     stack TRUE.  Else stack FALSE.
//     Go to 1.
//
// 4.  If an AND operator, then pop a boolean token into A,
//     and pop another into B.  If both are TRUE, stack TRUE.
//     Else stack FALSE.
//     Go to 1.
//
// 5.  If a NOT operator, reverse the value of the top-of-stack boolean.
//     Go to 1.
//
// At end-of-input, the result is at top-of-stack.
//
/////////////////////////////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\winmgmt\wbemcomn\ql.h ===
/*++

Copyright (C) 1996-2001 Microsoft Corporation

Module Name:

    QL.H

Abstract:

    Level 1 Syntax QL Parser

    Implements the syntax described in QL.BNF.  This translates the input
    into an RPN stream of tokens.

History:

    a-raymcc, a-tomasp    21-Jun-96       Created.

--*/

#ifndef _QL__H_
#define _QL__H_
#include <wbemidl.h>
#include <wbemint.h>
#include <qllex.h>
#include <corepol.h>
#include <parmdefs.h>
#include <stdio.h>

class POLARITY CPropertyName : public WBEM_PROPERTY_NAME
{
protected:
    long m_lAllocated;
    void* m_pvHandle;
    void EnsureAllocated(long lElements);
public:
    void Init();
    CPropertyName() {Init();}
    CPropertyName(const CPropertyName& Other);
    void operator=(const CPropertyName& Other);
    void operator=(const WBEM_PROPERTY_NAME& Other);
    BOOL operator==(const WBEM_PROPERTY_NAME& Other);

    void Empty();
    ~CPropertyName() {Empty();}

    long GetNumElements() const {return m_lNumElements;}
    LPCWSTR GetStringAt(long lIndex) const;
    void AddElement(LPCWSTR wszElement);
    DELETE_ME LPWSTR GetText();

    //
    // for convienience, a prop handle can be stored with this struct. example
    // of such a handle is the one used for fast access to properties on wbem
    // class objects. The handle is not used in any way by this implementation 
    // but will be treated as a regular member var in that it will be nulled,
    // copied, etc.. 
    //
    void* GetHandle() { return m_pvHandle; }
    void SetHandle( void* pvHandle ) { m_pvHandle = pvHandle; }
};

class POLARITY CQl1ParseSink
{
public:
    virtual void SetClassName(LPCWSTR wszClass) = 0;
    virtual void SetTolerance(const WBEM_QL1_TOLERANCE& Tolerance) = 0;
    virtual void AddToken(const WBEM_QL1_TOKEN& Token) = 0;
    virtual void AddProperty(const CPropertyName& Property) = 0;
    virtual void AddAllProperties() = 0;
    virtual void SetCountQuery() = 0;
    virtual void SetAggregated() = 0;
    virtual void SetAggregationTolerance(const WBEM_QL1_TOLERANCE& Tolerance)= 0;
    virtual void AddAggregationProperty(const CPropertyName& Property) = 0;
    virtual void AddAllAggregationProperties() = 0;
    virtual void AddHavingToken(const WBEM_QL1_TOKEN& Token) = 0;

    virtual void InOrder(long lOp){}
};

class POLARITY CAbstractQl1Parser
{
protected:
    // Controls keyword parsing in Next().
    // ===================================
    enum { 
        NO_KEYWORDS = 0,
        ALL_KEYWORDS,
        EXCLUDE_GROUP_KEYWORD,
        EXCLUDE_EXPRESSION_KEYWORDS
        };

    CQl1ParseSink* m_pSink;
    CGenLexer *m_pLexer;
    int        m_nLine;
    wchar_t*   m_pTokenText;
    int        m_nCurrentToken;

    // Semantic transfer variables.
    // ============================
    VARIANT    m_vTypedConst;
    BOOL       m_bQuoted;
    int        m_nRelOp;
    DWORD      m_dwConstFunction;
    DWORD      m_dwPropFunction;
    CPropertyName m_PropertyName;
    BOOL       m_bInAggregation;
    CPropertyName m_PropertyName2;
    BOOL       m_bPropComp;
        
    // Parsing functions.
    // ==================
    virtual BOOL Next(int nFlags = ALL_KEYWORDS);
    LPCWSTR GetSinglePropertyName();
    void DeletePropertyName();
    int FlipOperator(int nOp);
    void AddAppropriateToken(const WBEM_QL1_TOKEN& Token);

    int parse_property_name(CPropertyName& Prop);
    
    int parse(int nFlags);

    int prop_list();
    int class_name();
    int tolerance();
    int opt_where();
    int expr();
    int property_name();
    int prop_list_2();
    int term();
    int expr2();
    int simple_expr();
    int term2();
    int leading_ident_expr();
    int finalize();
    int rel_operator();
    int equiv_operator();
    int comp_operator();
    int is_operator();
    int trailing_prop_expr();
    int trailing_prop_expr2();
    int trailing_or_null();
    int trailing_const_expr();
    int trailing_ident_expr();
    int unknown_func_expr();
    int typed_constant();
    int opt_aggregation();
    int aggregation_params();
    int aggregate_by();
    int aggregate_within();
    int opt_having();

    static DWORD TranslateIntrinsic(LPCWSTR pFuncName);
    static void InitToken(WBEM_QL1_TOKEN* pToken);
public:
    enum { 
        SUCCESS = 0,
        SYNTAX_ERROR,
        LEXICAL_ERROR,
        FAILED,
        BUFFER_TOO_SMALL,
        OUT_OF_MEMORY
        };

    enum {
        FULL_PARSE = 0,
        NO_WHERE,
        JUST_WHERE
    };

    CAbstractQl1Parser(CGenLexSource *pSrc);
    virtual ~CAbstractQl1Parser();

    int Parse(CQl1ParseSink* pSink, int nFlags);
            
    int CurrentLine() { return m_nLine; }
    LPWSTR CurrentToken() { return m_pTokenText; }
};



struct POLARITY QL_LEVEL_1_TOKEN
{
    enum 
    { 
        OP_EXPRESSION = QL1_OP_EXPRESSION, 
        TOKEN_AND = QL1_AND, 
        TOKEN_OR = QL1_OR, 
        TOKEN_NOT = QL1_NOT
    };
    enum 
    { 
        IFUNC_NONE = QL1_FUNCTION_NONE, 
        IFUNC_UPPER = QL1_FUNCTION_UPPER, 
        IFUNC_LOWER = QL1_FUNCTION_LOWER 
    };    

    // If the field is a OP_EXPRESSION, then the following are used.
    enum 
    { 
        OP_EQUAL = QL1_OPERATOR_EQUALS, 
        OP_NOT_EQUAL = QL1_OPERATOR_NOTEQUALS, 
        OP_EQUALorGREATERTHAN = QL1_OPERATOR_GREATEROREQUALS,
        OP_EQUALorLESSTHAN = QL1_OPERATOR_LESSOREQUALS, 
        OP_LESSTHAN = QL1_OPERATOR_LESS, 
        OP_GREATERTHAN = QL1_OPERATOR_GREATER, 
        OP_LIKE  = QL1_OPERATOR_LIKE,
        OP_UNLIKE  = QL1_OPERATOR_UNLIKE
    };

    int nTokenType; //  OP_EXPRESSION,TOKEN_AND, TOKEN_OR, TOKEN_NOT
    CPropertyName PropertyName;  
                   // Name of the property on which the operator is applied
    int     nOperator;      // Operator that is applied on property
    VARIANT vConstValue;    // Value applied by operator
    BOOL bQuoted; // FALSE if the string should not have quotes around it.

    CPropertyName PropertyName2; // Property to compare, if applicable.
    BOOL m_bPropComp;        // TRUE if this is a property-to-property compare.

    DWORD   dwPropertyFunction; // 0=no instrinsic function applied
    DWORD   dwConstFunction;    // "

    QL_LEVEL_1_TOKEN();
    QL_LEVEL_1_TOKEN(const QL_LEVEL_1_TOKEN&);
   ~QL_LEVEL_1_TOKEN(); 
    QL_LEVEL_1_TOKEN& operator=(const QL_LEVEL_1_TOKEN &Src);
    QL_LEVEL_1_TOKEN& operator=(const WBEM_QL1_TOKEN &Src);
    
    void Dump(FILE *);
    DELETE_ME LPWSTR GetText();
};


// Contains RPN version of expression.
// ===================================

struct POLARITY QL_LEVEL_1_RPN_EXPRESSION : public CQl1ParseSink
{
    int nNumTokens;
    int nCurSize;
    QL_LEVEL_1_TOKEN *pArrayOfTokens;
    BSTR bsClassName;
    WBEM_QL1_TOLERANCE Tolerance;

    int nNumberOfProperties;          // Zero means all properties selected
    int nCurPropSize;
    BOOL bStar;
    CPropertyName *pRequestedPropertyNames;  
                // Array of property names which values are to be returned if
    
    BOOL bAggregated;
    BOOL bCount;
    WBEM_QL1_TOLERANCE AggregationTolerance;
    BOOL bAggregateAll;
    int nNumAggregatedProperties;   
    int nCurAggPropSize;
    CPropertyName *pAggregatedPropertyNames;  

    int nNumHavingTokens;
    int nCurHavingSize;
    QL_LEVEL_1_TOKEN *pArrayOfHavingTokens;
    
    long lRefCount;

    QL_LEVEL_1_RPN_EXPRESSION();
    QL_LEVEL_1_RPN_EXPRESSION(const QL_LEVEL_1_RPN_EXPRESSION& Other);
   ~QL_LEVEL_1_RPN_EXPRESSION();    
    void AddRef();
    void Release();

    void SetClassName(LPCWSTR wszName);
    void SetTolerance(const WBEM_QL1_TOLERANCE& Tolerance);
    void AddToken(const WBEM_QL1_TOKEN& Tok);
    void AddToken(const QL_LEVEL_1_TOKEN& Tok);
    void AddProperty(const CPropertyName& Prop);
    void AddAllProperties();
    void SetCountQuery();

    void SetAggregated();
    void SetAggregationTolerance(const WBEM_QL1_TOLERANCE& Tolerance);
    void AddAggregationProperty(const CPropertyName& Property);
    void AddAllAggregationProperties();
    void AddHavingToken(const WBEM_QL1_TOKEN& Tok);

    void Dump(const char *pszTextFile);
    DELETE_ME LPWSTR GetText();
};


class POLARITY QL1_Parser : public CAbstractQl1Parser
{
    QL_LEVEL_1_RPN_EXPRESSION* m_pExpression;
    BOOL m_bPartiallyParsed;

public:
    QL1_Parser(CGenLexSource *pSrc);
   ~QL1_Parser();

    int GetQueryClass(LPWSTR pBuf, int nBufSize);
       
    int Parse(QL_LEVEL_1_RPN_EXPRESSION **pOutput);
    static LPWSTR ReplaceClassName(QL_LEVEL_1_RPN_EXPRESSION* pExpr, 
        LPCWSTR wszClassName);
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\winmgmt\wbemcomn\qllex.h ===
/*++

Copyright (C) 1995-2001 Microsoft Corporation

Module Name:

    QLLEX.CH

Abstract:

	QL Level 1 DFA Table & Tokens

History:

	raymcc    24-Jun-95       Created.

--*/

#ifndef _QLLEX_H_

#include <genlex.h>
#define QL_1_TOK_EOF       0
#define QL_1_TOK_ERROR     1
#define QL_1_TOK_IDENT     100
#define QL_1_TOK_QSTRING   101
#define QL_1_TOK_INT       102
#define QL_1_TOK_REAL      103
#define QL_1_TOK_CHAR      104

#define QL_1_TOK_LE        105
#define QL_1_TOK_LT        106
#define QL_1_TOK_GE        107
#define QL_1_TOK_GT        108
#define QL_1_TOK_EQ        109
#define QL_1_TOK_NE        110

#define QL_1_TOK_DOT           111
#define QL_1_TOK_OPEN_PAREN    112
#define QL_1_TOK_CLOSE_PAREN   113
#define QL_1_TOK_ASTERISK      114
#define QL_1_TOK_COMMA         115

#define QL_1_TOK_SELECT        120
#define QL_1_TOK_WHERE         121
#define QL_1_TOK_FROM          122
#define QL_1_TOK_LIKE          123
#define QL_1_TOK_OR            124
#define QL_1_TOK_AND           125
#define QL_1_TOK_NOT           126
#define QL_1_TOK_IS            127
#define QL_1_TOK_NULL          128
#define QL_1_TOK_WITHIN        129
#define QL_1_TOK_ISA           130
#define QL_1_TOK_GROUP         131
#define QL_1_TOK_BY            132
#define QL_1_TOK_HAVING        133

#define QL_1_TOK_TRUE        140
#define QL_1_TOK_FALSE        141

extern LexEl Ql_1_LexTable[];


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\winmgmt\wbemcomn\ql_test.cpp ===
/*++

Copyright (C) 1999-2001 Microsoft Corporation

Module Name:

    QL_TEST.CPP

Abstract:

    Test driver for Level 1 Syntax QL Parser

    Takes the filename of a file containing one or more WQL queries.  Writes
    the output to the console.

History:

    mdavis    23-Apr-99    Created from sql_test.cpp in Stdlibrary

--*/

#include "precomp.h"
#include <stdio.h>

#include <genlex.h>
#include <qllex.h>
#include <ql.h>


void xmain(int argc, char **argv)
{
    if (argc < 2 || strchr(argv[1], '?') != NULL)
    {
        printf("Usage: ql_test WQL-query-file\n");
        return;
    }

    int nLine = 1;
    char buf[2048];
    FILE *f = fopen(argv[1], "rt");
    if (f == NULL)
    {
        printf("Usage: ql_test WQL-query-file\nError: cannot open file %s!\n", argv[1]);
        return;
    }

    while (fgets(buf, 2048, f) != NULL)
    {
        // get rid of newline
        char* ptr;
        if ((ptr = strchr(buf, '\n')) != NULL)
        {
            *ptr = '\0';
        }

        // get start of text
        ptr = buf;
        while (*ptr == ' ')
        {
            ptr++;
        }

        // ignore blank lines
        if (*ptr != '\0')
        {
            wchar_t buf2[2048];
            MultiByteToWideChar(CP_ACP, 0, ptr, -1, buf2, 2048);

            CTextLexSource src(buf2);
            QL1_Parser parser(&src);
            QL_LEVEL_1_RPN_EXPRESSION *pExp = NULL;

            // get the class (parse to WHERE clause)
            wchar_t classbuf[128];
            *classbuf = 0;
            printf("----GetQueryClass----\n");
            int nRes = parser.GetQueryClass(classbuf, 128);
            if (nRes)
            {
                printf("ERROR %d: line %d, token %S\n",
                    nRes,
                    parser.CurrentLine(),
                    parser.CurrentToken()
                    );
                goto ContinueRead;
            }
            printf("Query class is %S\n", classbuf);

            // parse the rest of the query
            nRes = parser.Parse(&pExp);

            if (nRes)
            {
                printf("ERROR %d: line %d, token %S\n",
                    nRes,
                    parser.CurrentLine(),
                    parser.CurrentToken()
                    );
                //goto ContinueRead;
            }
            else
            {
                printf("No errors.\n");
            }

            // call Dump function to display tokens and GetText function to show 
            // query passed to providers
            if (pExp)
            {
                pExp->Dump("CON");
                LPWSTR wszText = pExp->GetText();
                printf("--WQL passed to provider--\n");
                printf("%S\n", wszText);
                printf("----end of WQL----\n");
                delete [] wszText;
            }

ContinueRead:
            delete pExp;
            printf("%S\n", buf2);
            printf("=================================================EOL %d=======================================================\n", nLine);
        }
        nLine++;
    }

    if (ferror(f) != 0)
    {
        printf("\nError: line %d", nLine);
    }

    fclose(f);
}

void main(int argc, char **argv)
{
    xmain(argc, argv);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\winmgmt\wbemcomn\reg.h ===
/*++

Copyright (C) 1998-2001 Microsoft Corporation

Module Name:

    REG.H

Abstract:

  Utility Registry classes

History:

  a-raymcc    30-May-96   Created.

--*/

#ifndef _REG_H_
#define _REG_H_
#include "corepol.h"

#define WBEM_REG_WBEM L"Software\\Microsoft\\WBEM"
#define WBEM_REG_WINMGMT L"Software\\Microsoft\\WBEM\\CIMOM"

class POLARITY Registry
{
    HKEY hPrimaryKey;
    HKEY hSubkey;
    int nStatus;
    LONG m_nLastError;


public:
    enum { no_error, failed };

    int Open(HKEY hStart, wchar_t *pszStartKey, DWORD desiredAccess= KEY_ALL_ACCESS);
    Registry(wchar_t *pszLocalMachineStartKey, DWORD desiredAccess= KEY_ALL_ACCESS);

    // This create a special read only version which is usefull for marshalling
    // clients which are running with a lower priviledge set.

    Registry();
    Registry(HKEY hRoot, REGSAM flags, wchar_t *pszStartKey);
    Registry(HKEY hRoot, DWORD dwOptions, REGSAM flags, wchar_t *pszStartKey);
   ~Registry();

    int MoveToSubkey(wchar_t *pszNewSubkey);
    int GetDWORD(wchar_t *pszValueName, DWORD *pdwValue);
    int GetDWORDStr(wchar_t *pszValueName, DWORD *pdwValue);
    int GetStr(wchar_t *pszValue, wchar_t **pValue);

    // It is the callers responsibility to delete pData

    int GetBinary(wchar_t *pszValue, byte ** pData, DWORD * pdwSize);
    int SetBinary(wchar_t *pszValue, byte * pData, DWORD dwSize);

    //Returns a pointer to a string buffer containing the null-terminated string.
    //The last entry is a double null terminator (i.e. the registry format for
    //a REG_MULTI_SZ).  Caller has do "delete []" the returned pointer.
    //dwSize is the size of the buffer returned.
    wchar_t* GetMultiStr(wchar_t *pszValueName, DWORD &dwSize);

    int SetDWORD(wchar_t *pszValueName, DWORD dwValue);
    int SetDWORDStr(wchar_t *pszValueName, DWORD dwValue);
    int SetStr(wchar_t *pszValueName, wchar_t *psvValue);
    int SetExpandStr(wchar_t *pszValueName, wchar_t *psvValue);

    //pData should be passed in with the last entry double null terminated.
    //(i.e. the registry format for a REG_MULTI_SZ).
    int SetMultiStr(wchar_t *pszValueName, wchar_t* pData, DWORD dwSize);

    LONG GetLastError() { return m_nLastError; }
    int DeleteValue(wchar_t *pszValueName);
    int GetType(wchar_t *pszValueName, DWORD *pdwType);
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\winmgmt\wbemcomn\reg.cpp ===
/*++

Copyright (C) 1998-2001 Microsoft Corporation

Module Name:

    REG.CPP

Abstract:

  Utility Registry classes

History:

  raymcc    30-May-96   Created.
  raymcc    26-Jul-99   Updated for wchar_t.

--*/

#include "precomp.h"
#include <wbemcli.h>
#include <stdio.h>
#include <reg.h>
#include <malloc.h>

//***************************************************************************
//
//***************************************************************************
// ok
int Registry::Open(HKEY hStart, wchar_t *pszStartKey, DWORD desiredAccess )
{
    int nStatus = no_error;
    DWORD dwDisp = 0;

    m_nLastError = RegCreateKeyEx(hStart, pszStartKey,
                                    0, 0, 0,
                                    desiredAccess, 0, &hPrimaryKey, &dwDisp);

    if (m_nLastError != 0)
            nStatus = failed;

    return nStatus;
}

//***************************************************************************
//
//***************************************************************************
// ok
Registry::Registry(HKEY hRoot, REGSAM flags, wchar_t *pszStartKey)
{
    hPrimaryKey = 0;
    hSubkey = 0;
    nStatus = RegOpenKeyEx(hRoot, pszStartKey,
                        0, flags, &hPrimaryKey
                        );
    hSubkey = hPrimaryKey;
    m_nLastError = nStatus;
}

//***************************************************************************
//
//***************************************************************************
// ok
Registry::Registry(HKEY hRoot, DWORD dwOptions, REGSAM flags, wchar_t *pszStartKey)
{
    hPrimaryKey = 0;
    hSubkey = 0;

    int nStatus = no_error;
    DWORD dwDisp = 0;

    m_nLastError = RegCreateKeyEx(hRoot, pszStartKey,
                                    0, 0, dwOptions,
                                    flags, 0, &hPrimaryKey, &dwDisp
                                    );

    hSubkey = hPrimaryKey;
}


//***************************************************************************
//
//***************************************************************************
// ok
Registry::Registry(wchar_t *pszLocalMachineStartKey, DWORD desiredAccess)
{
    hPrimaryKey = 0;
    hSubkey = 0;
    nStatus = Open(HKEY_LOCAL_MACHINE, pszLocalMachineStartKey, desiredAccess);
    hSubkey = hPrimaryKey;
}

//***************************************************************************
//
//***************************************************************************
// ok
Registry::Registry()
{
    hPrimaryKey = 0;
    hSubkey = 0;
    nStatus = 0;
    hSubkey = 0;
}

//***************************************************************************
//
//***************************************************************************
// ok
Registry::~Registry()
{
    if (hSubkey)
        RegCloseKey(hSubkey);
    if (hPrimaryKey != hSubkey)
        RegCloseKey(hPrimaryKey);
}

//***************************************************************************
//
//***************************************************************************
// ok
int Registry::MoveToSubkey(wchar_t *pszNewSubkey)
{
    DWORD dwDisp = 0;
    m_nLastError = RegCreateKeyEx(hPrimaryKey, pszNewSubkey, 0, 0, 0, KEY_ALL_ACCESS,
                                    0, &hSubkey, &dwDisp);
    if (m_nLastError != 0)
            return failed;
    return no_error;
}

//***************************************************************************
//
//***************************************************************************
// ok
int Registry::GetDWORD(wchar_t *pszValueName, DWORD *pdwValue)
{
    DWORD dwSize = sizeof(DWORD);
    DWORD dwType = 0;

    if(hSubkey == NULL)
        return failed;

    m_nLastError = RegQueryValueEx(hSubkey, pszValueName, 0, &dwType,
                                LPBYTE(pdwValue), &dwSize);
    if (m_nLastError != 0)
            return failed;

    if (dwType != REG_DWORD)
        return failed;

    return no_error;
}

//***************************************************************************
//
//***************************************************************************
// ok
int Registry::GetType(wchar_t *pszValueName, DWORD *pdwType)
{
    if(hSubkey == NULL)
        return failed;

    m_nLastError = RegQueryValueEx(hSubkey, pszValueName, 0, pdwType,
                                NULL, NULL);
    if (m_nLastError != 0)
            return failed;
    return no_error;
}
//***************************************************************************
//
//***************************************************************************
// ok
int Registry::GetDWORDStr(wchar_t *pszValueName, DWORD *pdwValue)
{
    wchar_t cTemp[25];
    DWORD dwSize = 25;
    DWORD dwType = 0;
    wchar_t * pEnd = NULL;    // gets set to character that stopped the scan    
    if(hSubkey == NULL)
        return failed;

    m_nLastError = RegQueryValueEx(hSubkey, pszValueName, 0, &dwType,
        (LPBYTE)cTemp, &dwSize);

    if (m_nLastError != 0)
            return failed;

    if (dwType != REG_SZ)
        return failed;

    *pdwValue = wcstoul(cTemp, &pEnd, 10);
    if(pEnd == NULL || pEnd == cTemp)
        return failed;
    else
        return no_error;
}


//***************************************************************************
//
//  Use operator delete on the returned pointer!!
//
//***************************************************************************
// ok

int Registry::GetBinary(wchar_t *pszValue, byte ** pData, DWORD * pdwSize)
{
    *pData = 0;
    DWORD dwSize = 0;
    DWORD dwType = 0;
    if(m_nLastError)
        return failed;

    m_nLastError = RegQueryValueEx(hSubkey, pszValue, 0, &dwType,
                                    0, &dwSize);
    if (m_nLastError != 0)
            return failed;

    if (dwType != REG_BINARY)
        return failed;

    byte *p = new byte[dwSize];
    if (p == NULL)
        return failed;

    m_nLastError = RegQueryValueEx(hSubkey, pszValue, 0, &dwType,
                                    LPBYTE(p), &dwSize);
    if (m_nLastError != 0)
    {
        delete [] p;
        return failed;
    }

    *pdwSize = dwSize;
    *pData = p;
    return no_error;
}

//***************************************************************************
//
//***************************************************************************
// ok
int Registry::SetBinary(wchar_t *pszValue, byte * pData, DWORD dwSize)
{
    if(hSubkey == NULL)
        return failed;
    
    m_nLastError = RegSetValueEx(hSubkey, pszValue, 0, REG_BINARY, pData, dwSize);

    if (m_nLastError != 0)
        return failed;
    return no_error;
}

//***************************************************************************
//
//***************************************************************************
// ok
int Registry::SetDWORD(wchar_t *pszValueName, DWORD dwValue)
{
    if(hSubkey == NULL)
        return failed;

    m_nLastError = RegSetValueEx(hSubkey, pszValueName, 0, REG_DWORD, LPBYTE(&dwValue),
                                    sizeof(DWORD));
    if (m_nLastError != 0)
        return failed;
    return no_error;
}

//***************************************************************************
//
//***************************************************************************
// ok

int Registry::SetDWORDStr(wchar_t *pszValueName, DWORD dwVal)
{
    wchar_t cTemp[30];
    StringCchPrintfW(cTemp,30, L"%d",dwVal);

    if(hSubkey == NULL)
        return failed;

    m_nLastError = RegSetValueEx(hSubkey, pszValueName, 0, REG_SZ, LPBYTE(cTemp),
        (wcslen(cTemp)+1) * sizeof(wchar_t));

    if (m_nLastError != 0)
        return failed;

    return no_error;
}

//***************************************************************************
//
//***************************************************************************
// ok

int Registry::DeleteValue(wchar_t *pszValueName)
{
    if(hSubkey == NULL)
        return failed;

    return RegDeleteValue(hSubkey, pszValueName);
}

//***************************************************************************
//
//***************************************************************************
// ok
int Registry::SetMultiStr(wchar_t *pszValueName, wchar_t * pszValue, DWORD dwSize)
{
    if(hSubkey == NULL)
        return failed;

    m_nLastError = RegSetValueEx(hSubkey,
                                 pszValueName,
                                 0,
                                 REG_MULTI_SZ,
                                 LPBYTE(pszValue),
                                 dwSize);

    if (m_nLastError != 0)
        return failed;
    return no_error;
}


//***************************************************************************
//
//***************************************************************************
// ok

int Registry::SetStr(wchar_t *pszValueName, wchar_t *pszValue)
{

    int nSize = (wcslen(pszValue)+1) * sizeof(wchar_t);

    if(hSubkey == NULL)
        return failed;

    m_nLastError = RegSetValueEx(hSubkey, pszValueName, 0, REG_SZ, LPBYTE(pszValue), nSize);

    if (m_nLastError != 0)
        return failed;

    return no_error;
}


//***************************************************************************
//
//***************************************************************************
// ok

int Registry::SetExpandStr(wchar_t *pszValueName, wchar_t *pszValue)
{
    int nSize = (wcslen(pszValue)+1) * sizeof(wchar_t);

    if(hSubkey == NULL)
        return failed;

    m_nLastError = RegSetValueEx(hSubkey, pszValueName, 0, REG_EXPAND_SZ, LPBYTE(pszValue), nSize);

    if (m_nLastError != 0)
        return failed;

    return no_error;
}

//***************************************************************************
//
//***************************************************************************
//  ok

wchar_t* Registry::GetMultiStr(wchar_t *pszValueName, DWORD &dwSize)
{
    //Find out the size of the buffer required
    DWORD dwType;
    if(hSubkey == NULL)
        return NULL;

    dwSize = 0;
    m_nLastError = RegQueryValueEx(hSubkey, pszValueName, 0, &dwType, NULL, &dwSize);

    if ((m_nLastError == ERROR_SUCCESS) && (dwType != REG_MULTI_SZ))
    {
        m_nLastError = WBEM_E_TYPE_MISMATCH;
        dwSize = 0;
        return NULL;
    }

    //If the error is an unexpected one bail out
    if ((m_nLastError != ERROR_SUCCESS) || (dwType != REG_MULTI_SZ))
    {
        dwSize = 0;
        return NULL;
    }

    if (dwSize == 0)
    {
        dwSize = 0;
        return NULL;
    }

    wmilib::auto_ptr<BYTE> pData( new BYTE[dwSize]);
    if (NULL == pData.get()) return NULL;
    
    //get the values
    m_nLastError = RegQueryValueEx(hSubkey,
                                   pszValueName,
                                   0,
                                   &dwType,
                                   pData.get(),
                                   &dwSize);

    //if an error bail out
    if (m_nLastError != 0)
    {
        dwSize = 0;
        return NULL;
    }

    return (wchar_t *)pData.release();
}


//***************************************************************************
//
/// Use operator delete on returned value.
//
//***************************************************************************
// ok

int Registry::GetStr(wchar_t *pszValueName, wchar_t **pValue)
{
    *pValue = 0;
    DWORD dwSize = 0;
    DWORD dwType = 0;

    if(hSubkey == NULL)
        return failed;

    m_nLastError = RegQueryValueEx(hSubkey, pszValueName, 0, &dwType,
                                    0, &dwSize);
    if (m_nLastError != 0)
            return failed;

    if (dwType != REG_SZ && dwType != REG_EXPAND_SZ)
        return failed;

    //
    // length will not include the null terminated character when you don't 
    // pass the buffer and the reg value was not already null terminated, 
    // so make up for it.  If you give RegQueryValueEx enough room in the buff
    // it will add the null terminator for you.
    // 
    dwSize += sizeof(wchar_t);

    wchar_t *p = new wchar_t[dwSize];  // May be twice as big as required when _UNICODE
                                    // is defined, but harmless nonetheless.
    if (p == 0)
        return failed;

    m_nLastError = RegQueryValueEx(hSubkey, pszValueName, 0, &dwType,
                                    LPBYTE(p), &dwSize);
    if (m_nLastError != 0)
    {
        delete [] p;
        return failed;
    }

    if(dwType == REG_EXPAND_SZ)
    {
        wchar_t tTemp;

        // Get the initial length

        DWORD nSize = ExpandEnvironmentStrings((wchar_t *)p,&tTemp,1) + 1;
        wchar_t * pTemp = new wchar_t[nSize+1];
        if (pTemp == 0)
        {
            delete [] p;
            return failed;
        }
        ExpandEnvironmentStrings((wchar_t *)p,pTemp,nSize+1);
        delete [] p;
        *pValue = pTemp;
    }
    else
        *pValue = p;
    return no_error;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\winmgmt\wbemcomn\safearry.cpp ===
/*++

Copyright (C) 1996-2001 Microsoft Corporation

Module Name:

    SAFEARRY.CPP

Abstract:

  CSafeArray implementation.

  Notes:
  (1) Support only for arrays with origin at 0 or 1.
      Can VB deal with a SAFEARRAY of origin zero?

  (2) Support only for the following OA types:
        VT_BSTR, VT_VARIANT,
        VT_UI1, VT_I2, VT_I4, VT_R8

History:

    08-Apr-96   a-raymcc    Created.
    18-Mar-99   a-dcrews    Added out-of-memory exception handling

--*/

#include "precomp.h"

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <safearry.h>
#include <arrtempl.h>
#include <olewrap.h>

typedef struct 
{
    DWORD m_nMaxElementUsed;
    DWORD m_nFlags;
    DWORD m_nGrowBy;
    DWORD m_nStatus;
    DWORD m_nVarType;
    SAFEARRAYBOUND m_bound;    
}   PersistHeaderBlock;


//***************************************************************************
//  
//  CSafeArray::CheckType
//
//  Verifies that the constructor is being invoked with a supported type.
//
//  PARAMETERS:
//  nTest
//      One of the supported OLE VT_ constants.
//
//***************************************************************************
void CSafeArray::CheckType(int nTest)
{
    if (nTest != VT_BSTR &&
        nTest != VT_VARIANT &&
        nTest != VT_UI1 &&
        nTest != VT_I2 &&
        nTest != VT_I4 &&
        nTest != VT_R4 &&
        nTest != VT_R8 &&
        nTest != VT_BOOL &&
        nTest != VT_DISPATCH &&
        nTest != VT_UNKNOWN        
        )
        Fatal("Caller attempted to use unsupported OLE Automation Type (VT_*)");
}

//***************************************************************************
//
//  CSafeArray::CSafeArray
//
//  Constructor which creates a new SAFEARRAY.
//
//  PARAMETERS:
//  vt
//      An OLE VT_ type indicator, indicating the element type.
//  nFlags
//      The destruct policy, either <no_delete> or <auto_delete>.  With
//      <no_delete>, the underlying SAFEARRAY is not deallocated, whereas
//      with <auto_delete> the destructor destroys the SAFEARRAY.
//  nSize
//      The initial size of the SAFEARRAY.
//  nGrowBy
//      The amount the SAFEARRAY should grow by when the user attempts to
//      add elements to a full array.
//
//***************************************************************************

CSafeArray::CSafeArray(
    IN int vt,
    IN int nFlags,
    IN int nSize,
    IN int nGrowBy
    )
{
    CheckType(vt);

    m_nMaxElementUsed = -1;
    m_nFlags = nFlags;
    m_nGrowBy = nGrowBy;
    m_nVarType = vt;

    // Allocate the array.
    // ===================

    m_bound.cElements = nSize;
    m_bound.lLbound = 0;

    m_pArray = COleAuto::_SafeArrayCreate((VARENUM) vt, 1, &m_bound);

    if (m_pArray == 0)
        m_nStatus = failed;
    else
        m_nStatus = no_error;

	m_nElementSize = SafeArrayGetElemsize( m_pArray );
}

//***************************************************************************
//
//  CSafeArray::CSafeArray
//
//  Constructor based on an existing SAFEARRAY.
//
//  PARAMETERS:
//  pSrc
//      A pointer to an existing SAFEARRAY which is used as a source
//      during object construction.
//  nType
//      One of the OLE VT_ type indicators.
//  nFlags
//      OR'ed Bit flags indicating the bind vs. copy, and the 
//      object destruct policy.
//
//      The destruct policy is either <no_delete> or <auto_delete>.  With
//      <no_delete>, the underlying SAFEARRAY is not deallocated, whereas
//      with <auto_delete> the destructor destroys the SAFEARRAY.
//
//      Binding is indicated by <bind>, in which case the SAFEARRAY
//      pointed to by <pSrc> becomes the internal SAFEARRAY of the
//      object.  Otherwise, this constructor makes a new copy of the
//      SAFEARRAY for internal use.
//  nGrowBy
//      How much to grow the array by when it fills and the user attempts
//      to add more elements.  This allows the array to grow in chunks
//      so that continuous Add() operations do not operate slowly on
//      large arrays.
//
//***************************************************************************

CSafeArray::CSafeArray(
    IN SAFEARRAY *pSrcCopy,
    IN int nType,
    IN int nFlags,
    IN int nGrowBy
    )
{
    m_nStatus = no_error;

    CheckType(nType);

    // Verify that this is only a 1-dimensional array.
    // ===============================================

    if (1 != COleAuto::_SafeArrayGetDim(pSrcCopy))
        m_nStatus = failed;

    // Now copy the source or 'bind' the incoming array.
    // ====================================================

    if (nFlags & bind)
        m_pArray = pSrcCopy;
    else if (COleAuto::_SafeArrayCopy(pSrcCopy, &m_pArray) != S_OK)
        m_nStatus = failed;

    // Get bound information.
    // ======================

    LONG uBound = 0;
    if (S_OK != COleAuto::_SafeArrayGetUBound(m_pArray, 1, &uBound))
        m_nStatus = failed;

    // Correct the Upper Bound into a size.
    // ====================================

    m_bound.cElements = uBound + 1;
    m_bound.lLbound = 0;
    m_nMaxElementUsed = uBound;
    m_nVarType = nType;
    m_nGrowBy = nGrowBy;
    m_nFlags = nFlags & 3;  // Mask out the acquire & copy bits.

	m_nElementSize = SafeArrayGetElemsize( m_pArray );

}


//***************************************************************************
//
//  CSafeArray::GetScalarAt
//
//  For class internal use.  This function returns the element at
//  the specified index.
//  
//  PARAMETERS:
//  nIndex
//      The index at which to retrieve the scalar.
//
//  RETURN VALUE:
//  The scalar at the specified the location.
//
//***************************************************************************
SA_ArrayScalar CSafeArray::GetScalarAt(IN int nIndex)
{
    SA_ArrayScalar retval = {0};

    // Check for out-of-range condition.
    // =================================

    if (nIndex > m_nMaxElementUsed + 1)
        return retval;

    COleAuto::_SafeArrayGetElement(m_pArray, (long *) &nIndex, &retval);
    return retval;
}


//***************************************************************************
//
//  CSafeArray assignment operator.
//
//***************************************************************************

CSafeArray& CSafeArray::operator =(IN CSafeArray &Src)
{
    Empty();

    m_nMaxElementUsed = Src.m_nMaxElementUsed;
    m_nFlags = Src.m_nFlags;
    m_nGrowBy = Src.m_nGrowBy;
    m_nStatus = Src.m_nStatus;
    m_nVarType = Src.m_nVarType;
    m_bound = Src.m_bound;
	m_nElementSize = Src.m_nElementSize;

    if (COleAuto::_SafeArrayCopy(Src.m_pArray, &m_pArray) != S_OK)
        m_nStatus = failed;

    return *this;
}

//***************************************************************************
//
//  Copy constructor.
//
//  This is implemented primarily via the assignment operator.
//
//***************************************************************************

CSafeArray::CSafeArray(CSafeArray &Src)
{
    m_nMaxElementUsed = 0;
    m_nFlags = 0;
    m_nGrowBy = 0;
    m_nStatus = no_error;
    m_nVarType = VT_NULL;
    m_pArray = 0;
    m_bound.cElements = 0;
    m_bound.lLbound = 0;

    *this = Src;
}


//***************************************************************************
//
//  CSafeArray::Add
//
//  Adds the BSTR to the array, growing the array if required.
//
//  PARAMETERS:
//  Src
//      The source BSTR to add to the array.  If NULL, then a
//      blank string is added by the underlying SAFEARRAY implementation.
//      (there is no way to prevent this).  This can point to 
//      an LPWSTR as well.
//
//  RETURN VALUE:
//  <no_error> or <failed>.
//
//***************************************************************************

int CSafeArray::AddBSTR(IN BSTR Src)
{
    // If there is no more room in the array, then expand it.
    // ======================================================

    if (m_nMaxElementUsed == (int) m_bound.cElements - 1) {

        if (m_nGrowBy == 0)
            return range_error;

        m_bound.cElements += m_nGrowBy;

        if (S_OK != COleAuto::_SafeArrayRedim(m_pArray, &m_bound))
            m_nStatus = failed;
    }

    m_nMaxElementUsed++;

    BSTR Copy = COleAuto::_SysAllocString(Src);
    CSysFreeMe auto1(Copy);

    if (COleAuto::_SafeArrayPutElement(m_pArray, (long *) &m_nMaxElementUsed, Copy) != S_OK) {
        m_nStatus = failed;
        return failed;
    }

    return no_error;
}

//***************************************************************************
//
//  CSafeArray::AddVariant
//
//  Adds the specified VARIANT to the array.
//
//  PARAMETERS:
//  pSrc
//      A pointer to the source VARIANT, which is copied.
//
//  RETURN VALUE:
//  range_error, failed, no_error
//
//***************************************************************************

int CSafeArray::AddVariant(IN VARIANT *pSrc)
{
    // If there is no more room in the array, then expand it.
    // ======================================================

    if (m_nMaxElementUsed == (int) m_bound.cElements - 1) {

        if (m_nGrowBy == 0)
            return range_error;
            
        m_bound.cElements += m_nGrowBy;

        if (S_OK != COleAuto::_SafeArrayRedim(m_pArray, &m_bound))
            m_nStatus = failed;
    }

    m_nMaxElementUsed++;

    if (COleAuto::_SafeArrayPutElement(m_pArray, (long *) &m_nMaxElementUsed, pSrc) != S_OK) {
        m_nStatus = failed;
        return failed;
    }

    return no_error;
}

//***************************************************************************
//
//  CSafeArray::AddDispatch
//
//  Adds the specified IDispatch* to the array.
//
//  PARAMETERS:
//  pSrc
//      A pointer to the source IDispatch*, which is AddRefed.
//
//  RETURN VALUE:
//  range_error, failed, no_error
//
//***************************************************************************

int CSafeArray::AddDispatch(IN IDispatch *pDisp)
{
    // If there is no more room in the array, then expand it.
    // ======================================================

    if (m_nMaxElementUsed == (int) m_bound.cElements - 1) {

        if (m_nGrowBy == 0)
            return range_error;
            
        m_bound.cElements += m_nGrowBy;

        if (S_OK != COleAuto::_SafeArrayRedim(m_pArray, &m_bound))
            m_nStatus = failed;
    }

    m_nMaxElementUsed++;

    if (COleAuto::_SafeArrayPutElement(m_pArray, (long *) &m_nMaxElementUsed, pDisp) != S_OK) {
        m_nStatus = failed;
        return failed;
    }

    return no_error;
}

//***************************************************************************
//
//  CSafeArray::AddUnknown
//
//  Adds the specified IUnknown* to the array.
//
//  PARAMETERS:
//  pSrc
//      A pointer to the source IUnknown*, which is AddRefed.
//
//  RETURN VALUE:
//  range_error, failed, no_error
//
//***************************************************************************

int CSafeArray::AddUnknown(IN IUnknown *pUnk)
{
    // If there is no more room in the array, then expand it.
    // ======================================================

    if (m_nMaxElementUsed == (int) m_bound.cElements - 1) {

        if (m_nGrowBy == 0)
            return range_error;
            
        m_bound.cElements += m_nGrowBy;

        if (S_OK != COleAuto::_SafeArrayRedim(m_pArray, &m_bound))
            m_nStatus = failed;
    }

    m_nMaxElementUsed++;

    if (COleAuto::_SafeArrayPutElement(m_pArray, (long *) &m_nMaxElementUsed, pUnk) != S_OK) {
        m_nStatus = failed;
        return failed;
    }

    return no_error;
}



//***************************************************************************
//
//  CSafeArray::GetBSTRAt
//
//  If the array type is VT_BSTR, this returns the string at the specified
//  index.
//
//  PARAMETERS:
//  nIndex
//      The array index for which the string is requried.
//
//  RETURN VALUE:
//  A dynamically allocated BSTR which must be freed with SysFreeString.
//  NULL is returned on error. If NULL was originally added at this
//  location, a string with zero length will be returned, which still
//  must be freed with SysFreeString.
//
//***************************************************************************

BSTR CSafeArray::GetBSTRAt(int nIndex)
{
    BSTR StrPtr = 0;

    if (nIndex >= (int) m_bound.cElements)
        return NULL;

    if (S_OK != COleAuto::_SafeArrayGetElement(m_pArray, (long *) &nIndex, &StrPtr))
        return NULL;

    return StrPtr;
}

BSTR CSafeArray::GetBSTRAtThrow(int nIndex)
{
    BSTR StrPtr = 0;

    if (nIndex >= (int) m_bound.cElements)
        throw CX_MemoryException();

    if (S_OK != COleAuto::_SafeArrayGetElement(m_pArray, (long *) &nIndex, &StrPtr))
        throw CX_MemoryException();

    return StrPtr;
}


//***************************************************************************
//
//  CSafeArray::GetVariantAt
//
//  PARAMETERS:
//  nIndex
//      The array index from which to retrieve the VARIANT.
//  
//  RETURN VALUE:
//  Returns a new VARIANT at the specified location.  The receiver must
//  call VariantClear() on this VARIANT when it is no longer used.
//
//***************************************************************************

VARIANT CSafeArray::GetVariantAt(int nIndex)
{
    VARIANT Var;
    COleAuto::_VariantInit(&Var);

    if (nIndex >= (int) m_bound.cElements)
        return Var;

    if (S_OK != COleAuto::_SafeArrayGetElement(m_pArray, (long *) &nIndex, &Var))
        return Var;

    return Var;
}

//***************************************************************************
//
//  CSafeArray::GetDispatchAt
//
//  PARAMETERS:
//  nIndex
//      The array index from which to retrieve the IDispatch*.
//  
//  RETURN VALUE:
//  Returns the IDispatch* at the specified location.  The receiver must
//  call Release on this pointer (if not NULL) when it is no longer used.
//
//***************************************************************************

IDispatch* CSafeArray::GetDispatchAt(int nIndex)
{
    IDispatch* pDisp;
    if (nIndex >= (int) m_bound.cElements)
        return NULL;

    if (S_OK != COleAuto::_SafeArrayGetElement(m_pArray, (long *) &nIndex, &pDisp))
        return NULL;

    return pDisp;
}

//***************************************************************************
//
//  CSafeArray::GetUnknownAt
//
//  PARAMETERS:
//  nIndex
//      The array index from which to retrieve the IUnknown*.
//  
//  RETURN VALUE:
//  Returns the IUnknown* at the specified location.  The receiver must
//  call Release on this pointer (if not NULL) when it is no longer used.
//
//***************************************************************************

IUnknown* CSafeArray::GetUnknownAt(int nIndex)
{
    IUnknown* pUnk;
    if (nIndex >= (int) m_bound.cElements)
        return NULL;

    if (S_OK != COleAuto::_SafeArrayGetElement(m_pArray, (long *) &nIndex, &pUnk))
        return NULL;

    return pUnk;
}

//***************************************************************************
//
//  CSafeArray::SetAt
//
//  Replaces the BSTR value at the specified array index.   The original
//  BSTR value is automatically deallocated and replaced by the new value.
//  You can only call this to replace an existing element or to add a
//  new element to the end (one position past the last element).  If the
//  array size is 10, you can call this with 0..10, but not 11 or higher.
//
//  PARAMETERS:
//  nIndex
//      The position at which to replace the element.
//  Str
//      The new string.
//  nFlags
//      If <acquire> this function acquires ownership of the string and
//      can delete it.  Otherwise, the caller retains ownership of the
//      string.
//
//  RETURN VALUE:
//  no_error
//  range_error
//  failed
//
//***************************************************************************
int CSafeArray::SetBSTRAt(
    IN int nIndex,
    IN BSTR Str
    )
{
    // Check for out-of-range condition.
    // =================================

    if (nIndex > m_nMaxElementUsed + 1)
        return range_error;

    // Check to see if we are adding a new element.
    // ============================================

    if (nIndex == m_nMaxElementUsed + 1)
        return AddBSTR(Str);

    BSTR Copy = COleAuto::_SysAllocString(Str);
    CSysFreeMe auto1(Copy);

    // If here, we are replacing an element.
    // =====================================

    if (COleAuto::_SafeArrayPutElement(m_pArray, (long *) &nIndex, Copy) != S_OK) {
        m_nStatus = failed;
        return failed;
    }

    return no_error;
}

//***************************************************************************
//
//  CSafeArray::SetVariantAt
//
//  Sets the VARIANT at the specified index.
//
//  PARAMETERS:
//  nIndex
//      The index at which to set the VARIANT.  The original contents
//      at this location are automatically deallocated and replaced.
//  pVal
//      Used as the source of the new value.  This is treated as read-only.
//  
//  RETURN VALUE:
//  no_error, failed, range_error
//      
//***************************************************************************
int CSafeArray::SetVariantAt(
    IN int nIndex,
    IN VARIANT *pVal
    )
{
    // Check for out-of-range condition.
    // =================================

    if (nIndex > m_nMaxElementUsed + 1)
        return range_error;

    // Check to see if we are adding a new element.
    // ============================================

    if (nIndex == m_nMaxElementUsed + 1)
        return AddVariant(pVal);

    // If here, we are replacing an element.
    // =====================================

    if (COleAuto::_SafeArrayPutElement(m_pArray, (long *) &nIndex, pVal) != S_OK) {
        m_nStatus = failed;
        return failed;
    }

    return no_error;
}

//***************************************************************************
//
//  CSafeArray::SetDispatchAt
//
//  Sets the IDispatch* at the specified index.
//
//  PARAMETERS:
//  nIndex
//      The index at which to set the IDispatch*.  The original contents
//      at this location are automatically Released and replaced.
//  pVal
//      Used as the source of the new value.  This is treated as read-only.
//  
//  RETURN VALUE:
//  no_error, failed, range_error
//      
//***************************************************************************
int CSafeArray::SetDispatchAt(
    IN int nIndex,
    IN IDispatch *pDisp
    )
{
    // Check for out-of-range condition.
    // =================================

    if (nIndex > m_nMaxElementUsed + 1)
        return range_error;

    // Check to see if we are adding a new element.
    // ============================================

    if (nIndex == m_nMaxElementUsed + 1)
        return AddDispatch(pDisp);

    // If here, we are replacing an element.
    // =====================================

    if (COleAuto::_SafeArrayPutElement(m_pArray, (long *) &nIndex, pDisp) != S_OK) {
        m_nStatus = failed;
        return failed;
    }

    return no_error;
}

//***************************************************************************
//
//  CSafeArray::SetUnknownAt
//
//  Sets the IUnknown* at the specified index.
//
//  PARAMETERS:
//  nIndex
//      The index at which to set the IUnknown*.  The original contents
//      at this location are automatically Released and replaced.
//  pVal
//      Used as the source of the new value.  This is treated as read-only.
//  
//  RETURN VALUE:
//  no_error, failed, range_error
//      
//***************************************************************************
int CSafeArray::SetUnknownAt(
    IN int nIndex,
    IN IUnknown *pUnk
    )
{
    // Check for out-of-range condition.
    // =================================

    if (nIndex > m_nMaxElementUsed + 1)
        return range_error;

    // Check to see if we are adding a new element.
    // ============================================

    if (nIndex == m_nMaxElementUsed + 1)
        return AddUnknown(pUnk);

    // If here, we are replacing an element.
    // =====================================

    if (COleAuto::_SafeArrayPutElement(m_pArray, (long *) &nIndex, pUnk) != S_OK) {
        m_nStatus = failed;
        return failed;
    }

    return no_error;
}

//***************************************************************************
//
//  CSafeArray::RemoveAt
//
//  Removes the element at the specified index.  After a series of these
//  operations, the caller should call the Trim() function.
//
//  PARAMETERS:
//  nIndex
//      The target index for element removal.
//
//  RETURN VALUE:
//      no_error, range_error
//
//***************************************************************************
int CSafeArray::RemoveAt(IN int nIndex)
{
    // Check for out-of-range condition.
    // =================================

    if (nIndex > m_nMaxElementUsed + 1)
        return range_error;

    // Copy element n+1 into n.
    // ========================

    BSTR strVal;
    VARIANT v;
    SA_ArrayScalar scalar;
    IDispatch* pDisp;
    IUnknown* pUnk;

    for (long i = nIndex; i < m_nMaxElementUsed; i++) {
        long nNext = i + 1;

        if (m_nVarType == VT_BSTR) {
            COleAuto::_SafeArrayGetElement(m_pArray, &nNext, &strVal);
            COleAuto::_SafeArrayPutElement(m_pArray, &i, strVal);
            COleAuto::_SysFreeString(strVal);
        }
        else if (m_nVarType == VT_VARIANT) {
            COleAuto::_SafeArrayGetElement(m_pArray, &nNext, &v);
            COleAuto::_SafeArrayPutElement(m_pArray, &i, &v);
            COleAuto::_VariantClear(&v);
        }
        else if (m_nVarType == VT_DISPATCH) {
            COleAuto::_SafeArrayGetElement(m_pArray, &nNext, &pDisp);
            COleAuto::_SafeArrayPutElement(m_pArray, &i, pDisp);
            if(pDisp) pDisp->Release();
        }            
        else if (m_nVarType == VT_UNKNOWN) {
            COleAuto::_SafeArrayGetElement(m_pArray, &nNext, &pUnk);
            COleAuto::_SafeArrayPutElement(m_pArray, &i, pUnk);
            if(pUnk) pUnk->Release();
        }            
        else {
            COleAuto::_SafeArrayGetElement(m_pArray, &nNext, &scalar);
            COleAuto::_SafeArrayPutElement(m_pArray, &i, &scalar);
        }
    }

    m_nMaxElementUsed--;
    return no_error;
}

//***************************************************************************
//
//  CSafeArray::SetScalarAt
//
//  For class internal use.  Sets the scalar type at the specified index.
//  
//  PARAMETERS:
//  nIndex
//      The target index.
//  val
//      The new value.
//
//  RETURN VALUES:
//  range_error, failed, no_error    
//
//***************************************************************************
int CSafeArray::SetScalarAt(IN int nIndex, IN SA_ArrayScalar val)
{
    // Check for out-of-range condition.
    // =================================

    if (nIndex > m_nMaxElementUsed + 1)
        return range_error;

    // Check to see if we are adding a new element.
    // ============================================

    if (nIndex == m_nMaxElementUsed + 1)
        return AddScalar(val);

    // If here, we are replacing an element.
    // =====================================

    if (COleAuto::_SafeArrayPutElement(m_pArray, (long *) &nIndex, &val) != S_OK) {
        m_nStatus = failed;
        return failed;
    }

    return no_error;
}

//***************************************************************************
//
//  CSafeArray::AddScalar
//
//  For class internal use only.
//
//  Adds a new scalar to the 'end' of the array, growing it if required
//  and if possible.
//
//  PARAMETERS:
//  val
//      The new value.
//
//  RETURN VALUE:
//  no_error, range_error, failed
//
//***************************************************************************
int CSafeArray::AddScalar(IN SA_ArrayScalar val)
{
    // If there is no more room in the array, then expand it.
    // ======================================================

    if (m_nMaxElementUsed == (int) m_bound.cElements - 1) {

        if (m_nGrowBy == 0)
            return range_error;

        m_bound.cElements += m_nGrowBy;

        if (S_OK != COleAuto::_SafeArrayRedim(m_pArray, &m_bound))
            m_nStatus = failed;
    }

    m_nMaxElementUsed++;

    if (COleAuto::_SafeArrayPutElement(m_pArray, (long *) &m_nMaxElementUsed, &val) != S_OK) {
        m_nStatus = failed;
        return failed;
    }

    return no_error;
}



//***************************************************************************
//
//  CSafeArray::Empty
//
//  Empties the SAFEARRAY.
//
//***************************************************************************
void CSafeArray::Empty()
{
    m_nMaxElementUsed = 0;
    m_nFlags = 0;
    m_nGrowBy = 0;
    m_nStatus = no_error;
    m_nVarType = VT_NULL;
    if (m_pArray)
        COleAuto::_SafeArrayDestroy(m_pArray);
    m_pArray = 0;
    m_bound.cElements = 0;
    m_bound.lLbound = 0;
	m_nElementSize = 0L;
}

//***************************************************************************
//
//  CSafeArray::GetArrayCopy
//
//  RETURN VALUE:
//  A copy of the internal SAFEARRAY or NULL on error.
//
//***************************************************************************
SAFEARRAY *CSafeArray::GetArrayCopy()
{
    SAFEARRAY *pCopy = 0;
    if (COleAuto::_SafeArrayCopy(m_pArray, &pCopy) != S_OK)
        return 0;
    return pCopy;
}

//***************************************************************************
//
//  CSafeArray destructor.
//
//  If the internal flags are set to auto_delete, then the internal
//  SAFEARRAY is destroyed during destruction.
//
//***************************************************************************
CSafeArray::~CSafeArray()
{
    if (m_nFlags == auto_delete)
        COleAuto::_SafeArrayDestroy(m_pArray);
}


//***************************************************************************
//
//  CSafeArray::Trim
//
//***************************************************************************
int CSafeArray::Trim()
{                                           
    m_bound.cElements = m_nMaxElementUsed + 1;

    // HACK for NT 3.51: may not redimention to size 0
    // ===============================================

    if(m_bound.cElements == 0)
    {
        COleAuto::_SafeArrayDestroy(m_pArray);
        m_pArray = COleAuto::_SafeArrayCreate((VARENUM) m_nVarType, 1, &m_bound);
    }
    else
    {
        COleAuto::_SafeArrayRedim(m_pArray, &m_bound);
    }

    return no_error;
}

//***************************************************************************
//
//***************************************************************************
void CSafeArray::Fatal(const char *pszMsg)
{
//    MessageBox(0, pszMsg, "CSafeArray FATAL Error",
//        MB_OK | MB_SYSTEMMODAL | MB_ICONEXCLAMATION);
}

int CSafeArray::GetActualVarType( VARTYPE* pvt )
{
	if ( FAILED( SafeArrayGetVartype( m_pArray, pvt ) ) )
		return failed;

	return no_error;
}

int CSafeArray::SetRawData( void* pvSource, int nNumElements, int nElementSize )
{
	// If the number of elements we are setting is > than the number we are allocated
	// for, or element size does not match we fail the operation
	if ( nNumElements > m_bound.cElements || nElementSize != m_nElementSize )
	{
		return failed;
	}

	LPVOID	pvDest = NULL;

	HRESULT	hr = Access( &pvDest );

	if ( SUCCEEDED( hr ) )
	{
		CopyMemory( pvDest, pvSource, nElementSize * nNumElements );
		m_nMaxElementUsed = nNumElements - 1;
		Unaccess();
	}

	return ( SUCCEEDED( hr ) ? no_error : failed );
}

int CSafeArray::GetRawData( void* pvDest, int nBuffSize )
{
	
	// If the number of elements we will copy will exceed the destination
	// buffer, don't do it!
	if ( ( ( m_nMaxElementUsed + 1 ) * m_nElementSize ) > nBuffSize )
	{
		return failed;
	}
		
	LPVOID	pvSource = NULL;

	HRESULT	hr = Access( &pvSource );

	if ( SUCCEEDED( hr ) )
	{
		CopyMemory( pvDest, pvSource, ( m_nMaxElementUsed + 1) * m_nElementSize );
		Unaccess();
	}

	return ( SUCCEEDED( hr ) ? no_error : failed );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\winmgmt\wbemcomn\scopecheck.h ===
/*++

Copyright (C) 1999-2002 Microsoft Corporation

Module Name:

    scopecheck.h

Abstract:

	check if a thread has a token or not

History:

    ivanbrug 6 Jan 2002 Created

--*/

#ifndef __SCOPECHECK_H__
#define __SCOPECHECK_H__

#include <helper.h>

class CTestNullTokenOnScope {
private:
	DWORD Line_;
	char * File_;
	void TokenTest(bool bIsDestruct)
	{
		IServerSecurity *oldContext = NULL ;
		HRESULT result = CoGetCallContext ( IID_IServerSecurity , ( void ** ) & oldContext ) ;
		if ( SUCCEEDED ( result ) )
		{
			_DBG_ASSERT(!oldContext->IsImpersonating ());
			oldContext->Release();
		}

		HANDLE hThreadTok = NULL;
		if (OpenThreadToken(GetCurrentThread(),TOKEN_QUERY,FALSE,&hThreadTok))
		{
     		    if (bIsDestruct) { DBG_PRINTFA((pBuff, "~CTestNullTokenOnExit %d : %s\n",Line_,File_)); }
  		    DebugBreak();
		    CloseHandle(hThreadTok);
		};	
	};
public:
	CTestNullTokenOnScope(DWORD Line,char * FileName):Line_(Line),File_(FileName){ TokenTest(false); };
	~CTestNullTokenOnScope(){ TokenTest(true); };
};

#endif /*__SCOPECHECK_H__*/
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\winmgmt\wbemcomn\safearry.h ===
/*++

Copyright (C) 1996-2001 Microsoft Corporation

Module Name:

    SAFEARRY.H

Abstract:

  CSafeArray implementation.

History:

    08-Apr-96   a-raymcc    Created.
    18-Mar-99   a-dcrews    Added out-of-memory exception handling

--*/

#ifndef _SAFEARRY_H_
#define _SAFEARRY_H_

#include <stdio.h>
#include "corepol.h"
#include "corex.h"

typedef union 
{ 
    double dblVal; 
    float fltVal; 
    short iVal; 
    long lVal; 
    BYTE bVal; 
    VARIANT_BOOL boolVal;
}   SA_ArrayScalar;            

// Conversion functions due to VC 5.0 Optimizer Problems
inline SA_ArrayScalar ToSA_ArrayScalar( double dblVal )
{   SA_ArrayScalar sa;  sa.dblVal = dblVal; return sa;  }

inline SA_ArrayScalar ToSA_ArrayScalar( float fltVal )
{   SA_ArrayScalar sa;  sa.fltVal = fltVal; return sa;  }

inline SA_ArrayScalar ToSA_ArrayScalar( short iVal )
{   SA_ArrayScalar sa;  sa.iVal = iVal; return sa;  }

inline SA_ArrayScalar ToSA_ArrayScalar( long lVal )
{   SA_ArrayScalar sa;  sa.lVal = lVal; return sa;  }

inline SA_ArrayScalar ToSA_ArrayScalar( BYTE bVal )
{   SA_ArrayScalar sa;  sa.bVal = bVal; return sa;  }

inline SA_ArrayScalar ToSA_ArrayScalarBool( VARIANT_BOOL boolVal )
{   SA_ArrayScalar sa;  sa.boolVal = boolVal;   return sa;  }


class POLARITY CSafeArray
{
    int m_nMaxElementUsed;
    int m_nFlags;
    int m_nGrowBy;
    int m_nStatus;
    int m_nVarType;
	int m_nElementSize;
    SAFEARRAYBOUND m_bound;    
    SAFEARRAY *m_pArray;
    
    void Fatal(const char *);
    void CheckType(int n);
    int  AddScalar(IN SA_ArrayScalar val);
    int  SetScalarAt(IN int nIndex, IN SA_ArrayScalar val);
    SA_ArrayScalar GetScalarAt(IN int nIndex);
        
public:
    enum { no_error, failed, range_error };
    enum { no_delete = 0x1, auto_delete = 0x2, bind = 0x4 };

    void Empty();                    // Empty array    
    // Construction, destruction, and assignment.
    // ==========================================
        
    CSafeArray(
        IN int vt, 
        IN int nFlags,          // no_delete|auto_delete
        IN int nSize = 32, 
        IN int nGrowBy = 32
        );

    CSafeArray(
        IN SAFEARRAY *pSrc, 
        IN int nType,           // VT_ type of SAFEARRAY.
        IN int nFlags,          // no_delete|auto_delete [|bind]
        IN int nGrowBy = 32
        );

    CSafeArray &operator =(IN CSafeArray &Src);
    CSafeArray(IN CSafeArray &Src);
   ~CSafeArray();
    
    // Get functions.
    // ==============    

    BYTE    GetByteAt(IN int nIndex)
        { return GetScalarAt(nIndex).bVal; }
    LONG    GetLongAt(IN int nIndex)
        { return GetScalarAt(nIndex).lVal; }
    SHORT   GetShortAt(IN int nIndex)
        { return GetScalarAt(nIndex).iVal; }
    double  GetDoubleAt(IN int nIndex)
        { return GetScalarAt(nIndex).dblVal; }
    float   GetFloatAt(IN int nIndex)
        { return GetScalarAt(nIndex).fltVal; }
    VARIANT_BOOL GetBoolAt(IN int nIndex)
        { return GetScalarAt(nIndex).boolVal; }        

    BSTR    GetBSTRAt(IN int nIndex);          // Caller must use SysFreeString
    BSTR    GetBSTRAtThrow(int nIndex);        // Caller must use SysFreeString
    VARIANT GetVariantAt(IN int nIndex);      // 
    IDispatch* GetDispatchAt(IN int nIndex);
    IUnknown* GetUnknownAt(IN int nIndex);

    // Set functions.
    // ==============
        
    int SetByteAt(IN int nIndex, IN BYTE byVal)
        { return SetScalarAt(nIndex, ToSA_ArrayScalar(byVal)); }
    int SetLongAt(IN int nIndex, IN LONG lVal)
        { return SetScalarAt(nIndex, ToSA_ArrayScalar(lVal)); }
    int SetFloatAt(IN int nIndex, IN float fltVal)
        { return SetScalarAt(nIndex, ToSA_ArrayScalar(fltVal)); }
    int SetDoubleAt(IN int nIndex, IN double dVal)
        { return SetScalarAt(nIndex, ToSA_ArrayScalar(dVal)); }    
    int SetShortAt(IN int nIndex, IN SHORT iVal)
        { return SetScalarAt(nIndex, ToSA_ArrayScalar(iVal)); }        
    int SetBoolAt(IN int nIndex, IN VARIANT_BOOL boolVal)
        { return SetScalarAt(nIndex, ToSA_ArrayScalarBool(boolVal)); }        

    int SetBSTRAt(IN int nIndex, IN BSTR Str);     // A copy of the BSTR is made
    int SetVariantAt(IN int nIndex, IN VARIANT *pSrc);
    int SetDispatchAt(IN int nIndex, IN IDispatch* pDisp);
    int SetUnknownAt(IN int nIndex, IN IUnknown* pUnk);
    
    // Add (append) functions.
    // =======================
    
    int AddByte(IN BYTE byVal)  { return AddScalar(ToSA_ArrayScalar(byVal)); }
    int AddLong(IN LONG lVal)   { return AddScalar(ToSA_ArrayScalar(lVal)); }
    int AddFloat(IN float fltVal) { return AddScalar(ToSA_ArrayScalar(fltVal)); }
    int AddDouble(IN double dVal) { return AddScalar(ToSA_ArrayScalar(dVal)); }
    int AddShort(IN SHORT iVal)  { return AddScalar(ToSA_ArrayScalar(iVal)); }
    int AddBool(IN VARIANT_BOOL boolVal) { return AddScalar(ToSA_ArrayScalarBool(boolVal)); }
    int AddBSTR(IN BSTR Str);
    int AddVariant(IN VARIANT *pData);
    int AddDispatch(IN IDispatch* pDisp);
    int AddUnknown(IN IUnknown* pUnk);
    
    // Operations the array as a whole. 
    // ================================

    int RemoveAt(IN int nIndex);                    
    int Size()    { return m_nMaxElementUsed + 1; }
    int GetType() { return m_nVarType; }
    int Status()  { return m_nStatus; }
	int ElementSize()	{ return m_nElementSize; }
    int Trim();                    
    void SetGrowGranularity(IN int n)  { m_nGrowBy = n; }
    void SetDestructorPolicy(IN int n) { m_nFlags = n; }   // auto_delete|no_delete
	int GetActualVarType( VARTYPE* pvt );
            
    SAFEARRAY *GetArrayCopy();                 // Returns a copy of the array
    SAFEARRAY *GetArray() { return m_pArray; }

    int TextDump(IN FILE *fStream);

	HRESULT Access( void** ppv )	{ return SafeArrayAccessData( m_pArray, ppv ); }
	HRESULT Unaccess( void )	{ return SafeArrayUnaccessData( m_pArray ); }
	int SetRawData( void* pvSource, int nNumElements, int nElementSize );
	int GetRawData( void* pvDest, int nBuffSize );
	void SetRawArrayMaxElement( int nMaxElement )	{ m_nMaxElementUsed = nMaxElement; }
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\winmgmt\wbemcomn\sleeper.h ===
/*++

Copyright (C) 1996-2001 Microsoft Corporation

Module Name:

    SLEEPER.H

Abstract:

    MinMax controls.

History:

--*/

#ifndef ___WBEM_SLEEPER__H_
#define ___WBEM_SLEEPER__H_

#include "sync.h"
#include "wstring.h"

//******************************************************************************
//
//  class CLimitControl
//
//  Limits the growth of a certain quantity by delaying requests to add to it.
//  This is an abstract base class for the classes that actually implement a
//  a particular enforcement strategy.
//
//  Clients of this object call Add to request to increase the controlled 
//  quantity (which will often sleep), and Remove to inform it that the quantity
//  is being reduced (which may or may not affect the sleeping clients)
//
//******************************************************************************
class POLARITY CLimitControl
{
protected:
    DWORD m_dwMembers;

public:
    CLimitControl();
    virtual ~CLimitControl(){}

    virtual HRESULT AddMember();
    virtual HRESULT RemoveMember();
    virtual HRESULT Add(DWORD dwHowMuch, DWORD dwMemberTotal, 
                            DWORD* pdwSleep = NULL) = 0;
    virtual HRESULT Remove(DWORD dwHowMuch) = 0;
};

//******************************************************************************
//
//  class CMinMaxLimitControl
//
//  This derivative of CLimitControl controls the growth of a quantity by 
//  slowing down (sleeping) progressively longer periods of time after the
//  quantity exceeds the lower threshold --- m_dwMin.  The growth of the 
//  sleep interval is linear, and is calculates to reach m_dwSleepAnMax 
//  milliseconds by the time the quantity reaches m_dwMax.  At that point, an
//  error message is logged, but the sleep interval stays at m_dwSleepAtMax.
//
//  m_nLog is the index of the log file (e.g. LOG_ESS), m_wsName is the name
//  of the controlled quantity to use in the log message
//
//******************************************************************************

class POLARITY CMinMaxLimitControl : public CLimitControl
{
protected:
    DWORD m_dwMin;
    DWORD m_dwMax;
    DWORD m_dwSleepAtMax;
    int m_nLog;
    WString m_wsName;

    DWORD m_dwCurrentTotal;
    BOOL m_bMessageLogged;
    CCritSec m_cs;

public:
    CMinMaxLimitControl(int nLog, LPCWSTR wszName);
    void SetMin(DWORD dwMin) {m_dwMin = dwMin;}
    void SetMax(DWORD dwMax) {m_dwMax = dwMax;}
    void SetSleepAtMax(DWORD dwSleepAtMax) {m_dwSleepAtMax = dwSleepAtMax;}

    virtual HRESULT Add(DWORD dwHowMuch, DWORD dwMemberTotal,
                            DWORD* pdwSleep = NULL);
    virtual HRESULT Remove(DWORD dwHowMuch);

protected:
    HRESULT ComputePenalty(DWORD dwNewTotal, DWORD dwMemberTotal, 
                            DWORD* pdwSleep, BOOL* pbLog);
};

//******************************************************************************
//
//  class CRegistryMinMaxLimitControl
//
//  This derivative of CMinMaxLimitControl gets its limiting information from 
//  the specified place in the registry
//
//  m_hHive holds the hive, m_wsKey the path to the key (e.g. "SOFTWARE\\MSFT"),
//  m_wsMinValueName, m_wsMaxValueName, and m_wsSleepAtMaxValueName hold the 
//  names of the registry values holding the values of these parameters, as
//  described in CMinMaxLimitControl
//
//******************************************************************************

class POLARITY CRegistryMinMaxLimitControl : public CMinMaxLimitControl
{
protected:
    WString m_wsKey;
    WString m_wsMinValueName;
    WString m_wsMaxValueName;
    WString m_wsSleepAtMaxValueName;
    
public:
    CRegistryMinMaxLimitControl(int nLog, LPCWSTR wszName, 
                                LPCWSTR wszKey, LPCWSTR wszMinValueName,
                                LPCWSTR wszMaxValueName, 
                                LPCWSTR wszSleepAtMaxValueName)
        : CMinMaxLimitControl(nLog, wszName), m_wsKey(wszKey),
            m_wsMinValueName(wszMinValueName), 
            m_wsMaxValueName(wszMaxValueName),
            m_wsSleepAtMaxValueName(wszSleepAtMaxValueName)
    {}

    HRESULT Reread();

};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\winmgmt\wbemcomn\sleeper.cpp ===
/*++

Copyright (C) 1996-2001 Microsoft Corporation

Module Name:

    SLEEPER.CPP

Abstract:

    MinMax controls.

History:

--*/

#include "precomp.h"
#include <stdio.h>
#include <wbemcomn.h>
#include "sleeper.h"

CLimitControl::CLimitControl()
    : m_dwMembers(0)
{
}

HRESULT CLimitControl::AddMember()
{
    InterlockedIncrement((long*)&m_dwMembers);
    return S_OK;
}

HRESULT CLimitControl::RemoveMember()
{
    InterlockedDecrement((long*)&m_dwMembers);
    return S_OK;
}

CMinMaxLimitControl::CMinMaxLimitControl(int nLog, LPCWSTR wszName)
        : m_dwMin(10000000), m_dwMax(20000000), m_dwSleepAtMax(60000), 
        m_nLog(nLog), m_wsName(wszName), m_dwCurrentTotal(0),
        m_bMessageLogged(FALSE)
{
}

HRESULT CMinMaxLimitControl::Add(DWORD dwHowMuch, DWORD dwMemberTotal,
                                    DWORD* pdwSleep)
{
    // Add amount to the total
    // =======================

    DWORD dwNewTotal;
    {
        CInCritSec ics(&m_cs);

        m_dwCurrentTotal += dwHowMuch;
        dwNewTotal = m_dwCurrentTotal;
    }

    // Calculate the penalty
    // =====================

    DWORD dwSleep = 0;
    BOOL bLog = TRUE;

    HRESULT hres = ComputePenalty(dwNewTotal, dwMemberTotal, &dwSleep, &bLog);
    if(FAILED(hres))
        return hres;

    if(dwSleep)
    {
        DEBUGTRACE(((char) m_nLog, "Penalty for %d out of %d \n\tof %S (%d members) "
            "is %d ms\n", dwMemberTotal, dwNewTotal, (LPCWSTR)m_wsName, 
            m_dwMembers, dwSleep));
    }

    // Log a message if required
    // =========================

    if(bLog)
    {
        ERRORTRACE(((char) m_nLog, "The limit of %d was exceeded for %S. The system "
            "is under extreme stress and out-of-memory conditions can ensue\n",
            m_dwMax, (LPCWSTR)m_wsName));
    }

    // Sleep, if required
    // ==================

    if(pdwSleep == NULL)
    {
        if(dwSleep)
            Sleep(dwSleep);
    }
    else
    {
        // Just return the required amount
        // ===============================
        *pdwSleep = dwSleep;
    }

    return hres;
}

HRESULT CMinMaxLimitControl::ComputePenalty(DWORD dwNewTotal, 
                                DWORD dwMemberTotal, 
                                DWORD* pdwSleep, BOOL* pbLog)
{
    CInCritSec ics(&m_cs);

    *pdwSleep = 0;
    *pbLog = FALSE;

    if(dwNewTotal > m_dwMin)
    {
        // Threshold exceeded --- non-zero penalty
        // =======================================

        // Compute a linear value between 0 and m_dwSleepAtMax
        // ===================================================

        __int64 i64Temp = (__int64)(dwNewTotal - m_dwMin);
        i64Temp *= (__int64)m_dwSleepAtMax;
        i64Temp /= (__int64)(m_dwMax - m_dwMin);

        // i64Temp is how much we would have to sleep if all queues were
        // equal.
        // =============================================================

        if(dwMemberTotal * m_dwMembers < dwNewTotal)
        {
            for(int i = 0; i < 2; i++)
            {
                i64Temp *= (__int64)dwMemberTotal;
                i64Temp *= (__int64)m_dwMembers;
                i64Temp /= (__int64)dwNewTotal;
            }
        }
        
        *pdwSleep = (DWORD)i64Temp;

        // Check if we have exceeeded m_dwMax
        // ==================================

        if(dwNewTotal >= m_dwMax)
        {
            // Max exceeded --- log a message if not already done so
            // =====================================================

            if(!m_bMessageLogged)
            {
                *pbLog = TRUE;
                m_bMessageLogged = TRUE;
            }

            return S_FALSE; // to let the caller know that things are bad
        }
        else
        {
            return S_OK;
        }
    }
    else
    {
        // No penalty
        // ==========

        *pdwSleep = 0;
        return S_OK;
    }

    return S_OK;
}


            

HRESULT CMinMaxLimitControl::Remove(DWORD dwHowMuch)
{
    // Determine if we crossed the critical boundary back.
    // ===================================================

    BOOL bLog = FALSE;

    {
        CInCritSec ics(&m_cs);

        m_dwCurrentTotal -= dwHowMuch;
        if(m_dwCurrentTotal < (m_dwMax * 0.9) && m_bMessageLogged)
        {
            // We have crossed the boundary
            // ============================

            bLog = TRUE;
            m_bMessageLogged = FALSE;
        }
    }

    // Log the message if required
    // ===========================

    if(bLog)
    {
        ERRORTRACE(((char) m_nLog, "%S is back in its normal range: below %d\n", 
            (LPCWSTR)m_wsName, m_dwMax));
    }

    return S_OK;
}


HRESULT CRegistryMinMaxLimitControl::Reread()
{
    // Open the key
    // ============

#ifdef UNICODE
    Registry r(m_wsKey);
#else
    char *szKey = m_wsKey.GetLPSTR();
    CDeleteMe <char>delMe(szKey);
    Registry r(szKey);
#endif
    if(r.GetLastError())
    {
        ERRORTRACE(((char) m_nLog, "Unable to open registry key %S to read control "
            "information for %S.  Error code: %d.  Default values will be "
            "used\n", (const wchar_t*)m_wsKey, (LPCWSTR)m_wsName, r.GetLastError()));
        return WBEM_E_FAILED;
    }

    // Read the values
    // ===============

    DWORD dwMin, dwMax, dwSleepAtMax;

#ifdef UNICODE
    if(r.GetDWORDStr(m_wsMinValueName, &dwMin) != Registry::no_error)
    {
        r.SetDWORDStr(m_wsMinValueName, m_dwMin);
        dwMin = m_dwMin;
    }
#else
    char *pStr = m_wsMinValueName.GetLPSTR();
    if(r.GetDWORDStr(pStr, &dwMin) != Registry::no_error)
    {
        r.SetDWORDStr(pStr, m_dwMin);
        dwMin = m_dwMin;
    }
    delete [] pStr;
#endif

#ifdef UNICODE
    if(r.GetDWORDStr(m_wsMaxValueName, &dwMax) != Registry::no_error)
    {
        r.SetDWORDStr(m_wsMaxValueName, m_dwMax);
        dwMax = m_dwMax;
    }
#else
    pStr = m_wsMaxValueName.GetLPSTR();
    if(r.GetDWORDStr(pStr, &dwMax) != Registry::no_error)
    {
        r.SetDWORDStr(pStr, m_dwMax);
        dwMax = m_dwMax;
    }
    delete [] pStr;
#endif

#ifdef UNICODE
    if(r.GetDWORDStr(m_wsSleepAtMaxValueName, &dwSleepAtMax) != Registry::no_error)
    {
        r.SetDWORDStr(m_wsSleepAtMaxValueName, m_dwSleepAtMax);
        dwSleepAtMax = m_dwSleepAtMax;
    }
#else
    pStr = m_wsSleepAtMaxValueName.GetLPSTR();
    if(r.GetDWORDStr(pStr, &dwSleepAtMax) != Registry::no_error)
    {
        r.SetDWORDStr(pStr, m_dwSleepAtMax);
        dwSleepAtMax = m_dwSleepAtMax;
    }
    delete [] pStr;
#endif
    
    // Now store them in the member variables
    // ======================================

    {
        CInCritSec ics(&m_cs);

        m_dwMin = dwMin;
        m_dwMax = dwMax;
        m_dwSleepAtMax = dwSleepAtMax;
    }

    return WBEM_S_NO_ERROR;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\winmgmt\wbemcomn\smallarr.cpp ===
/*++

Copyright (C) 1996-2001 Microsoft Corporation

Module Name:

    SMALLARR.CPP

Abstract:

    Small Array

History:

--*/

#include "precomp.h"
#include <stdio.h>
#include "smallarr.h"

CSmallArrayBlob* CSmallArrayBlob::CreateBlob(int nInitialSize)
{
    // Allocate enough space for the header, plus the data
    // ===================================================

    DWORD dwSize = sizeof(CSmallArrayBlob) - sizeof(void*) * ANYSIZE_ARRAY;
    dwSize += nInitialSize * sizeof(void*);
   
    CSmallArrayBlob* pBlob = (CSmallArrayBlob*)(new BYTE[dwSize]);
    if(pBlob == NULL)
        return NULL;

    // Initialize it appropriately
    // ===========================

    pBlob->Initialize(nInitialSize);
    return pBlob;
}

void CSmallArrayBlob::Initialize(int nInitialSize)
{
    // It has already been allocated to be big enough
    // ==============================================

    m_nExtent = nInitialSize;
    m_nSize = 0;
}

CSmallArrayBlob* CSmallArrayBlob::Grow()
{
    // Allocate a new array of twice our size
    // ======================================

    CSmallArrayBlob* pNew = CreateBlob(m_nExtent*2);
    if(pNew == NULL)
        return NULL;
    
    // Copy our data into it
    // =====================

    pNew->CopyData(this);

    // Delete ourselves!
    // =================

    delete this;
    return pNew;
}

void CSmallArrayBlob::CopyData(CSmallArrayBlob* pOther)
{
    m_nSize = pOther->m_nSize;
    memcpy(m_apMembers, pOther->m_apMembers, sizeof(void*) * m_nSize);
}


CSmallArrayBlob* CSmallArrayBlob::EnsureExtent(int nDesired)
{
    if(m_nExtent < nDesired)
        return Grow(); // will delete this!
    else
        return this;
}
    
CSmallArrayBlob* CSmallArrayBlob::InsertAt(int nIndex, void* pMember)
{
    // Ensure there is enough space
    // ============================

    CSmallArrayBlob* pArray = EnsureExtent(m_nSize+1);
    if(pArray == NULL)
        return NULL;

    // Move the data forward to make room
    // ==================================

    if(pArray->m_nSize > nIndex)
    {
        memmove(pArray->m_apMembers + nIndex + 1, pArray->m_apMembers + nIndex, 
            sizeof(void*) * (pArray->m_nSize - nIndex));
    }

    // Insert
    // ======

    pArray->m_apMembers[nIndex] = pMember;
    pArray->m_nSize++;

    return pArray;
}
    
void CSmallArrayBlob::SetAt(int nIndex, void* pMember, void** ppOld)
{
    // Make sure we even have that index (sparse set)
    // ==============================================

    EnsureExtent(nIndex+1);
    if(nIndex >= m_nSize)
        m_nSize = nIndex+1;

    // Save old value
    // ==============

    if(ppOld)
        *ppOld = m_apMembers[nIndex];

    // Replace
    // =======

    m_apMembers[nIndex] = pMember;
}

CSmallArrayBlob* CSmallArrayBlob::RemoveAt(int nIndex, void** ppOld)
{
    // Save old value
    // ==============

    if(ppOld)
        *ppOld = m_apMembers[nIndex];
    
    // Move the data back
    // ==================

    memcpy(m_apMembers + nIndex, m_apMembers + nIndex + 1, 
            sizeof(void*) * (m_nSize - nIndex - 1));

    m_nSize--;

    // Ensure we are not too large
    // ===========================
    
    return ShrinkIfNeeded();
}

CSmallArrayBlob* CSmallArrayBlob::ShrinkIfNeeded()
{
    if(m_nSize < m_nExtent / 4)
        return Shrink(); // will delete this!
    else
        return this;
}

CSmallArrayBlob* CSmallArrayBlob::Shrink()
{
    // Allocate a new blob of half our size
    // ====================================

    CSmallArrayBlob* pNew = CreateBlob((m_nExtent+1)/2);
    if(pNew == NULL)
    {
        // Out of memory --- we'll just have to stay large
        // ===============================================

        return this;
    }

    // Copy our data
    // =============

    pNew->CopyData(this);

    delete this; // we are no longer needed
    return pNew;
}

void CSmallArrayBlob::Trim()
{
    while(m_nSize > 0 && m_apMembers[m_nSize-1] == NULL)
        m_nSize--;
}

void CSmallArrayBlob::Sort()
{
    qsort(m_apMembers, m_nSize, sizeof(void*), CSmallArrayBlob::CompareEls);
}

int __cdecl CSmallArrayBlob::CompareEls(const void* pelem1, const void* pelem2)
{
    return *(DWORD_PTR*)pelem1 - *(DWORD_PTR*)pelem2;
}

void** CSmallArrayBlob::CloneData()
{
    void** ppReturn = new void*[m_nSize];
    
    if (ppReturn)
        memcpy(ppReturn, m_apMembers, m_nSize * sizeof(void*));

    return ppReturn;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\winmgmt\wbemcomn\smallarr.h ===
/*++

Copyright (C) 1996-2001 Microsoft Corporation

Module Name:

    SMALLARR.H

Abstract:

    Small Array

History:

--*/

#ifndef __WMI_SMALL_ARR__H_
#define __WMI_SMALL_ARR__H_

#include "corepol.h"
#include "flexarry.h"

class POLARITY CSmallArrayBlob
{
protected:
    int m_nSize;
    int m_nExtent;
    void* m_apMembers[ANYSIZE_ARRAY];

public:
    static CSmallArrayBlob* CreateBlob(int nInitialSize);

    CSmallArrayBlob* InsertAt(int nIndex, void* pMember);
    void SetAt(int nIndex, void* pMember, void** ppOld = NULL);
    CSmallArrayBlob* RemoveAt(int nIndex, void** ppOld = NULL);

    void* operator[](int nIndex) const {return m_apMembers[nIndex];}
    void* GetAt(int nIndex) const {return m_apMembers[nIndex];}
    void** GetArrayPtr() {return (void**)m_apMembers;}
    void* const* GetArrayPtr() const {return (void**)m_apMembers;}
    int Size() const {return m_nSize;}
    void Sort();
    void Trim();
    void** CloneData();
    
protected:
    void Initialize(int nInitialSize);
    CSmallArrayBlob* Grow();
    void CopyData(CSmallArrayBlob* pOther);
    CSmallArrayBlob* EnsureExtent(int nDesired);
    CSmallArrayBlob* ShrinkIfNeeded();
    CSmallArrayBlob* Shrink();

    static int __cdecl CompareEls(const void* pelem1, const void* pelem2);
};
    
class CSmallArray
{
protected:
    void* m_pData;

public:
    inline CSmallArray();
    inline ~CSmallArray();
    inline void*  GetAt(int nIndex) const;
    inline void* operator[](int nIndex) const { return GetAt(nIndex); }
    inline void SetAt(int nIndex, void *p, void** ppOld = NULL);
    inline int RemoveAt(int nIndex, void** ppOld = NULL);
    inline int InsertAt(int nIndex, void* pMember);

    int inline Add(void *pSrc) { return InsertAt(Size(), pSrc); }    
    int inline Size() const;

    inline void Trim();
    inline void Empty();
    inline void**  GetArrayPtr();
    inline void* const*  GetArrayPtr() const;
    inline void Sort();
    inline void** UnbindPtr();

protected:
    inline BOOL IsSingleton() const;
    inline BOOL IsEmpty() const;
    inline BOOL IsBlob() const;
    inline void EnsureBlob(int nMinSize);
    inline void* const & GetOnlyMember() const;
    inline void* & GetOnlyMember();
    inline void SetOnlyMember(void* p);
    inline CSmallArrayBlob* GetBlob();
    inline const CSmallArrayBlob* GetBlob() const;
    inline void SetBlob(CSmallArrayBlob* pBlob);
};

#include <smallarr.inl>
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\winmgmt\wbemcomn\smallarr.inl ===
/*++

Copyright (C) 1996-2001 Microsoft Corporation

Module Name:

    SMALLARR.INL

Abstract:

    Small Array Inlines.

History:

--*/

CSmallArray::CSmallArray()
{
    SetBlob(NULL);
}

CSmallArray::~CSmallArray()
{
    Empty();
}

void* CSmallArray::GetAt(int nIndex) const
{
    if(IsSingleton())
        return GetOnlyMember(); // nIndex better be 0!
    else
    {
        const CSmallArrayBlob* pBlob;

        if (pBlob = GetBlob())
            return pBlob->GetAt(nIndex);
        else
            return NULL;
    }
}

void CSmallArray::SetAt(int nIndex, void *p, void** ppOld)
{
    if(IsSingleton() && nIndex == 0)
    {
        // Changing our only element
        // =========================

        if(ppOld) *ppOld = GetOnlyMember();
        SetOnlyMember(p);
    }
    else
    {
        EnsureBlob(nIndex+1);
        CSmallArrayBlob* pBlob;

        if (pBlob = GetBlob())
            pBlob->SetAt(nIndex, p, ppOld);
    }
}

int CSmallArray::RemoveAt(int nIndex, void** ppOld)
{
    if(IsSingleton())
    {
        // Removing our only element --- nIndex better be 0
        // ================================================

        Empty(); 
    }
    else
    {
        CSmallArrayBlob* pBlob;

        if (pBlob = GetBlob())
        {
            SetBlob(pBlob->RemoveAt(nIndex, ppOld));
            pBlob = NULL; // to ward off temptation --- pBlob is no longer valid
            
            // Check if the blob has become empty
            // ==================================

            pBlob = GetBlob();
            if(pBlob && pBlob->Size() == 0)
                Empty(); 
        }
        else
            return CFlexArray::out_of_memory;
    }

    return CFlexArray::no_error;
}

int CSmallArray::InsertAt(int nIndex, void* pMember)
{
    if(IsEmpty())
    {
        // Inserting our first element --- nIndex better be 0
        // ==================================================

        SetOnlyMember(pMember);
    }
    else
    {
        EnsureBlob(nIndex+1);

        CSmallArrayBlob* pBlob;
        if (pBlob = GetBlob())
            SetBlob(pBlob->InsertAt(nIndex, pMember));
        else
            return CFlexArray::out_of_memory;
    }

    return CFlexArray::no_error;
}

int CSmallArray::Size() const
{
    if(IsEmpty())
        return 0;
    else if(IsSingleton())
        return 1;
    else 
    {
        const CSmallArrayBlob* pBlob;

        if (pBlob = GetBlob())
            return pBlob->Size();
        else
            return 0;
    }
}

void CSmallArray::Trim()
{
    if(IsSingleton())
    {
        // If the member is NULL, get rid of it
        // ====================================

        if(GetOnlyMember() == NULL)
            Empty();
    }
    else if(IsEmpty())
    {
    }
    else
    {
        CSmallArrayBlob* pBlob;

        if (pBlob = GetBlob())
        {
            pBlob->Trim();

            // If the blob is now empty, convert to "empty"
            // ============================================

            if(pBlob->Size() == 0)
                Empty();
        }
    }
}
    
void CSmallArray::Empty()
{
    if(IsBlob())
        delete [] GetBlob();

    SetBlob(NULL);
}

void CSmallArray::EnsureBlob(int nMinSize)
{
    if(IsSingleton())
    {
        // Allocate a new blob
        // ===================

        CSmallArrayBlob* pBlob = CSmallArrayBlob::CreateBlob(nMinSize);

        // Copy the data
        // =============

        if(pBlob != NULL)
            pBlob->InsertAt(0, GetOnlyMember());

        SetBlob(pBlob);
    }
}

void**  CSmallArray::GetArrayPtr()
{
    if(IsEmpty())
        return NULL;
    else if(IsSingleton())
        return &GetOnlyMember();
    else
    {
        CSmallArrayBlob* pBlob;

        if (pBlob = GetBlob())
            return pBlob->GetArrayPtr();
        else
            return NULL;
    }
}

void**  CSmallArray::UnbindPtr()
{
    void** ppReturn = NULL;
    if(IsSingleton())
    {
        ppReturn = new void*[1];
        if (ppReturn)
            *ppReturn = GetOnlyMember();
    }
    else if(IsBlob())
    {
        CSmallArrayBlob* pBlob;

        if (pBlob = GetBlob())
            ppReturn = pBlob->CloneData();
    }
    Empty();
    return ppReturn;
}

void* const*  CSmallArray::GetArrayPtr() const
{
    if(IsEmpty())
        return NULL;
    else if(IsSingleton())
        return &GetOnlyMember();
    else
    {
        const CSmallArrayBlob* pBlob;

        if (pBlob = GetBlob())
            return pBlob->GetArrayPtr();
        else
            return NULL;
    }
}

void CSmallArray::Sort()
{
    if(IsBlob())
    {
        CSmallArrayBlob* pBlob;

        if (pBlob = GetBlob())
            pBlob->Sort();
    }
}

void*& CSmallArray::GetOnlyMember()
{
    return m_pData;
}

void* const & CSmallArray::GetOnlyMember() const
{
    return m_pData;
}

void CSmallArray::SetOnlyMember(void* p)
{
    m_pData = p;
}

BOOL CSmallArray::IsEmpty() const
{
    return (m_pData == (void*)1);
}

BOOL CSmallArray::IsSingleton() const
{
    return (((DWORD_PTR)m_pData & 1) == 0);
}

BOOL CSmallArray::IsBlob() const
{
    return (m_pData != (void*)1) && ((DWORD_PTR)m_pData & 1);
}

CSmallArrayBlob* CSmallArray::GetBlob()
{
    return (CSmallArrayBlob*)((DWORD_PTR)m_pData & ~(DWORD_PTR)1);
}

const CSmallArrayBlob* CSmallArray::GetBlob() const
{
    return (CSmallArrayBlob*)((DWORD_PTR)m_pData & ~(DWORD_PTR)1);
}

void CSmallArray::SetBlob(CSmallArrayBlob* pBlob)
{
    m_pData = (CSmallArrayBlob*)((DWORD_PTR)pBlob | 1);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\winmgmt\wbemcomn\statsync.cpp ===
/*++

Copyright (C) 1996-2001 Microsoft Corporation

Module Name:

    SYNC.CPP

Abstract:

    Synchronization

History:

--*/

#include "precomp.h"

#include "statsync.h"
#include <cominit.h>
#include <wbemutil.h>
#include <corex.h>

//
//
// Critical Section to be used when it's a Global or class static
//
///////////////////////////////////////////////////

#ifndef STATUS_POSSIBLE_DEADLOCK 
#define STATUS_POSSIBLE_DEADLOCK (0xC0000194L)
#endif /*STATUS_POSSIBLE_DEADLOCK */

DWORD POLARITY BreakOnDbgAndRenterLoop(void);

BOOL CStaticCritSec::anyFailed_ = FALSE; 

// This code is shared at binary level with Win9x.
// InitializeCriticalSectionAndSpinCount is not working in Win9x

CStaticCritSec::CStaticCritSec(): initialized_(false)  
{
    __try
    {
        InitializeCriticalSection(this);
        initialized_ = true;
    }
    __except( GetExceptionCode() == STATUS_NO_MEMORY )
    {
        anyFailed_ = TRUE;
    }
}
 
CStaticCritSec::~CStaticCritSec()
{
    if(initialized_)
        DeleteCriticalSection(this);
}

void CStaticCritSec::Enter()
    {
        __try {
          EnterCriticalSection(this);
        } __except((STATUS_POSSIBLE_DEADLOCK == GetExceptionCode())? BreakOnDbgAndRenterLoop():EXCEPTION_CONTINUE_SEARCH) {
        }    
    }

void CStaticCritSec::Leave()
    {
        LeaveCriticalSection(this);
    }


BOOL CStaticCritSec::anyFailure()
{ 
    return anyFailed_;
};

void CStaticCritSec::SetFailure()
{
    anyFailed_ = TRUE;
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\winmgmt\wbemcomn\stllock.cpp ===
/*++

Copyright (C) 1996-2001 Microsoft Corporation

Module Name:

    STLLOCK.CPP

Abstract:

  Lock for STL

History:

--*/

#include "precomp.h"
#include <statsync.h>

/*
    This file implements the STL lockit class to avoid linking to msvcprt.dll
*/

CStaticCritSec g_cs;

std::_Lockit::_Lockit()
{
    g_cs.Enter();
}

std::_Lockit::~_Lockit()
{
    g_cs.Leave();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\winmgmt\wbemcomn\sortarr.h ===
/*++

Copyright (C) 1996-2001 Microsoft Corporation

Module Name:

    SORTARR.H

Abstract:

History:


--*/

#ifndef __WMI__SMART_SORTED_ARRAY__H_
#define __WMI__SMART_SORTED_ARRAY__H_

#pragma warning( disable : 4786 )
#include <vector>
#include <arrtempl.h>
#include <wstlallc.h>

template<class TKey, class TEl, class TManager, class TComparer>
class CSmartSortedArray
{
protected:
    std::vector<TEl, wbem_allocator<TEl> > m_v;
    TManager m_Manager;
    TComparer m_Comparer;

public:
    typedef typename std::vector<TEl, wbem_allocator<TEl> >::iterator TIterator;
    typedef typename std::vector<TEl, wbem_allocator<TEl> >::const_iterator TConstIterator;

    CSmartSortedArray(){}
    virtual ~CSmartSortedArray();

    TIterator Begin() {return m_v.begin();}
    TConstIterator Begin() const {return m_v.begin();}
    TIterator End() {return m_v.end();}
    TConstIterator End() const {return m_v.end();}
    int Add(TEl& NewEl, RELEASE_ME TEl* pOld = NULL);
    bool Remove(const TKey& K, RELEASE_ME TEl* pOld = NULL);
    TIterator Remove(TIterator it, RELEASE_ME TEl* pOld = NULL);
    TIterator Insert(TIterator it, TEl& NewEl);
    void Append(TEl& NewEl);
    bool Find(const TKey& K, RELEASE_ME TEl* pEl);
    bool Find(const TKey& K, TIterator* pit);

    void Empty() {m_v.clear();}
    int GetSize() {return m_v.size();}

    TEl* UnbindPtr();
    void Clear();
};

template<class TKey, class TEl, class TComparer>
class TExtractor : public std::unary_function<TEl, TKey>
{
    TComparer m_Comparer;
public:
    const TKey& operator()(const TEl& El) const
    {
        return m_Comparer.Extract(El);
    }
};

template<class TKey, class TEl, class TManager, class TComparer>
class CSmartSortedTree
{
protected:
    TManager m_Manager;
    TComparer m_Comparer;

    class TPredicate : public std::binary_function<TKey, TKey, bool>
    {
        TComparer m_Comparer;
    public:
        bool operator()(const TKey& k1, const TKey& k2) const
        {
            return (m_Comparer.Compare(k1, k2) < 0);
        }
    };

    typedef
        std::_Tree< TKey, TEl, TExtractor<TKey, TEl, TComparer>, TPredicate, wbem_allocator<TEl> > 
        TTree;

    TTree m_t;

public:
    typedef typename TTree::iterator TIterator;
    typedef typename TTree::const_iterator TConstIterator;

    CSmartSortedTree() : m_t(TPredicate(), false) {}
    virtual ~CSmartSortedTree();

    TIterator Begin() {return m_t.begin();}
    TConstIterator Begin() const {return m_t.begin();}
    TIterator End() {return m_t.end();}
    TConstIterator End() const {return m_t.end();}
    int Add(TEl& NewEl, RELEASE_ME TEl* pOld = NULL);
    bool Remove(const TKey& K, RELEASE_ME TEl* pOld = NULL);
    TIterator Remove(TIterator it, RELEASE_ME TEl* pOld = NULL);
    TIterator Insert(TIterator it, TEl& NewEl);
    void Append(TEl& NewEl);
    bool Find(const TKey& K, RELEASE_ME TEl* pEl);
    bool Find(const TKey& K, TIterator* pit);

    void Empty() {m_t.clear();}
    int GetSize() {return (int)m_t.size();}

    TEl* UnbindPtr();
    void Clear();
};
#include "sortarr.inl"


template<class TKey, class TEl, class TComparer>
class CUniquePointerSortedArray : 
    public CSmartSortedArray<TKey, TEl*, CUniqueManager<TEl>, TComparer>
{
};

template<class TKey, class TEl, class TComparer>
class CRefedPointerSortedArray : 
    public CSmartSortedArray<TKey, TEl*, CReferenceManager<TEl>, TComparer>
{
};

template<class TKey, class TEl, class TComparer>
class CUniquePointerSortedTree : 
    public CSmartSortedTree<TKey, TEl*, CUniqueManager<TEl>, TComparer>
{
};

template<class TKey, class TEl, class TComparer>
class CRefedPointerSortedTree : 
    public CSmartSortedTree<TKey, TEl*, CReferenceManager<TEl>, TComparer>
{
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\winmgmt\wbemcomn\statsync.h ===
/*++

Copyright (C) 1996-2001 Microsoft Corporation

Module Name:

    SYNC.H

Abstract:

    Synchronization

History:

--*/

#ifndef __WBEM_CRITSEC2__H_
#define __WBEM_CRITSEC2__H_

#include "corepol.h"
#include <corex.h>

class POLARITY CStaticCritSec : public CRITICAL_SECTION
{
private:
    bool initialized_;      
    static BOOL anyFailed_;    
public:
    static BOOL anyFailure();    
    static void SetFailure();        
    CStaticCritSec();
    ~CStaticCritSec();
    void Enter();
    void Leave();
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\winmgmt\wbemcomn\sortarr.inl ===
/*++

Copyright (C) 1996-2001 Microsoft Corporation

Module Name:

    SORTARR.INL

Abstract:

History:


--*/

// included into sortarr.h

template<class TKey, class TEl, class TManager, class TComparer>
CSmartSortedArray<TKey, TEl, TManager, TComparer>::
~CSmartSortedArray()
{
    Clear();
}

template<class TKey, class TEl, class TManager, class TComparer>
void CSmartSortedArray<TKey, TEl, TManager, TComparer>::
Clear()
{
    // Release all elements
    // ====================

    for(int i = 0; i < m_v.size(); i++)
        m_Manager.ReleaseElement(m_v[i]);
    m_v.clear();
}

template<class TKey, class TEl, class TManager, class TComparer>
int CSmartSortedArray<TKey, TEl, TManager, TComparer>::
Add(TEl& NewEl, TEl* pOld)
{
    // Binary search
    // =============

    int nLower = 0;
    int nUpper = m_v.size() - 1;
    while(nUpper >= nLower)
    {
        int nMiddle = (nUpper + nLower) / 2;
        int nCompare = m_Comparer.Compare(NewEl, m_v[nMiddle]);
        if(nCompare < 0)
            nUpper = nMiddle-1;
        else if(nCompare > 0)
            nLower = nMiddle+1;
        else 
        {
            // Already there!
            // ==============

            if(pOld) 
                *pOld = m_v[nMiddle];
            else
                m_Manager.ReleaseElement(m_v[nMiddle]);

            m_v[nMiddle] = NewEl;
            m_Manager.AddRefElement(NewEl);
            return nMiddle;
        }
    }

    // At this point, nUpper == nLower - 1 and our element should be between
    // =====================================================================

    m_Manager.AddRefElement(NewEl);
    m_v.insert(m_v.begin()+nLower, NewEl);
    return nLower;
}
            
template<class TKey, class TEl, class TManager, class TComparer>
bool CSmartSortedArray<TKey, TEl, TManager, TComparer>::
Remove(const TKey& K, TEl* pOld)
{
    // Binary search
    // =============

    int nLower = 0;
    int nUpper = m_v.size() - 1;
    while(nUpper >= nLower)
    {
        int nMiddle = (nUpper + nLower) / 2;
        int nCompare = m_Comparer.Compare(K, m_v[nMiddle]);
        if(nCompare < 0)
            nUpper = nMiddle-1;
        else if(nCompare > 0)
            nLower = nMiddle+1;
        else // found it
        {
            if(pOld) 
                *pOld = m_v[nMiddle];
            else
                m_Manager.ReleaseElement(m_v[nMiddle]);
            m_v.erase(m_v.begin() + nMiddle);
            return true;
        }
    }

    // never found it
    // ==============

    return false;
}

template<class TKey, class TEl, class TManager, class TComparer>
typename CSmartSortedArray<TKey, TEl, TManager, TComparer>::TIterator 
CSmartSortedArray<TKey, TEl, TManager, TComparer>::
Insert(TIterator it, TEl& NewEl)
{
    m_Manager.AddRefElement(NewEl);
    return m_v.insert(it, NewEl);
}

template<class TKey, class TEl, class TManager, class TComparer>
void CSmartSortedArray<TKey, TEl, TManager, TComparer>::
Append(TEl& NewEl)
{
    m_Manager.AddRefElement(NewEl);
    m_v.insert(m_v.end(), NewEl);
}
    
template<class TKey, class TEl, class TManager, class TComparer>
typename CSmartSortedArray<TKey, TEl, TManager, TComparer>::TIterator 
CSmartSortedArray<TKey, TEl, TManager, TComparer>::
Remove(TIterator it, RELEASE_ME TEl* pOld)
{
    if(pOld)
        *pOld = *it;
    else
        m_Manager.ReleaseElement(*it);

    return m_v.erase(it);
}

template<class TKey, class TEl, class TManager, class TComparer>
bool CSmartSortedArray<TKey, TEl, TManager, TComparer>::
Find(const TKey& K, TEl* pEl)
{
    TIterator it;
    bool bFound = Find(K, &it);
    if(bFound && pEl)
    {
        *pEl = *it;
        m_Manager.AddRefElement(*pEl);
    }
    return bFound;
}

template<class TKey, class TEl, class TManager, class TComparer>
bool CSmartSortedArray<TKey, TEl, TManager, TComparer>::
Find(const TKey& K, TIterator* pit)
{
    // Binary search
    // =============

    int nLower = 0;
    int nUpper = m_v.size() - 1;
    while(nUpper >= nLower)
    {
        int nMiddle = (nUpper + nLower) / 2;
        int nCompare = m_Comparer.Compare(K, m_v[nMiddle]);
        if(nCompare < 0)
            nUpper = nMiddle-1;
        else if(nCompare > 0)
            nLower = nMiddle+1;
        else // found it
        {
            *pit = m_v.begin() + nMiddle;
            return true;
        }
    }

    *pit = m_v.begin() + nLower;
    return false;
}

template<class TKey, class TEl, class TManager, class TComparer>
TEl* CSmartSortedArray<TKey, TEl, TManager, TComparer>::
UnbindPtr()
{
    // Allocate a new buffer
    // =====================

    TEl* aBuffer = new TEl[GetSize()];
    if(aBuffer == NULL)
        return NULL;

    // Copy the elements over --- no addreffing required
    // =================================================

    for(int i = 0; i < GetSize(); i++)
        aBuffer[i] = m_v[i];

    m_v.clear();
    return aBuffer;
}

//*****************************************************************************
//*****************************************************************************

template<class TKey, class TEl, class TManager, class TComparer>
CSmartSortedTree<TKey, TEl, TManager, TComparer>::
~CSmartSortedTree()
{
    Clear();
}

template<class TKey, class TEl, class TManager, class TComparer>
void CSmartSortedTree<TKey, TEl, TManager, TComparer>::
Clear()
{
    // Release all elements
    // ====================

    for(TIterator it = Begin(); it != End(); it++)
        m_Manager.ReleaseElement(*it);
    m_t.clear();
}

template<class TKey, class TEl, class TManager, class TComparer>
int CSmartSortedTree<TKey, TEl, TManager, TComparer>::
Add(TEl& NewEl, TEl* pOld)
{
    TIterator it = m_t.lower_bound(m_Comparer.Extract(NewEl));

    // Check if there
    // ==============

    if(it != m_t.end() && m_Comparer.Compare(NewEl, *it) == 0)
    {
        // Already there!
        // ==============

        if(pOld) 
            *pOld = *it;
        else
            m_Manager.ReleaseElement(*it);

        *it = NewEl;
        m_Manager.AddRefElement(NewEl);
    }
    else
    {
        // Not there
        // =========

        m_Manager.AddRefElement(NewEl);
        m_t.insert(it, NewEl);
    }
    return 1;
}
            
template<class TKey, class TEl, class TManager, class TComparer>
bool CSmartSortedTree<TKey, TEl, TManager, TComparer>::
Remove(const TKey& K, TEl* pOld)
{
    TIterator it = m_t.find(K);
    if(it != m_t.end())
    {
        // Found it
        // ========
        
        if(pOld) 
            *pOld = *it;
        else
            m_Manager.ReleaseElement(*it);
        m_t.erase(it);
        return true;
    }
    else
    {
        // never found it
        // ==============
    
        return false;
    }
}

template<class TKey, class TEl, class TManager, class TComparer>
typename CSmartSortedTree<TKey, TEl, TManager, TComparer>::TIterator 
CSmartSortedTree<TKey, TEl, TManager, TComparer>::
Insert(TIterator it, TEl& NewEl)
{
    m_Manager.AddRefElement(NewEl);

    // This iterator points to the position *after* insertion point. STL likes
    // it before
    // =======================================================================

    TIterator it1 = it;
    it1--;
    return m_t.insert(it1, NewEl);
}

template<class TKey, class TEl, class TManager, class TComparer>
void CSmartSortedTree<TKey, TEl, TManager, TComparer>::
Append(TEl& NewEl)
{
    m_Manager.AddRefElement(NewEl);
    m_t.insert(m_t.end(), NewEl);
}
    
template<class TKey, class TEl, class TManager, class TComparer>
typename CSmartSortedTree<TKey, TEl, TManager, TComparer>::TIterator 
CSmartSortedTree<TKey, TEl, TManager, TComparer>::
Remove(TIterator it, RELEASE_ME TEl* pOld)
{
    if(pOld)
        *pOld = *it;
    else
        m_Manager.ReleaseElement(*it);

    return m_t.erase(it);
}

template<class TKey, class TEl, class TManager, class TComparer>
bool CSmartSortedTree<TKey, TEl, TManager, TComparer>::
Find(const TKey& K, TEl* pEl)
{
    TIterator it;
    bool bFound = Find(K, &it);
    if(bFound && pEl)
    {
        *pEl = *it;
        m_Manager.AddRefElement(*pEl);
    }
    return bFound;
}

template<class TKey, class TEl, class TManager, class TComparer>
bool CSmartSortedTree<TKey, TEl, TManager, TComparer>::
Find(const TKey& K, TIterator* pit)
{
    *pit = m_t.lower_bound(K);
    if(*pit != m_t.end() && m_Comparer.Compare(K, **pit) == 0)
        return true;
    else
        return false;
}

template<class TKey, class TEl, class TManager, class TComparer>
TEl* CSmartSortedTree<TKey, TEl, TManager, TComparer>::
UnbindPtr()
{
    // Allocate a new buffer
    // =====================

    TEl* aBuffer = new TEl[GetSize()];
    if(aBuffer == NULL)
        return NULL;

    // Copy the elements over --- no addreffing required
    // =================================================

    int i = 0;
    for(TIterator it = Begin(); it != End(); it++)
        aBuffer[i++] = *it;

    m_t.clear();
    return aBuffer;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\winmgmt\wbemcomn\strutils.h ===
/*++

Copyright (C) 1999-2001 Microsoft Corporation

Module Name:

    STRUTILS.H

Abstract:

	String utilities

History:

--*/

#ifndef __WBEM_STRING_UTILS__H_
#define __WBEM_STRING_UTILS__H_

#pragma optimize("gt", on)

#ifdef _DBG
#define _DBG_BREAK DebugBreak();
#else
#define _DBG_BREAK
#endif

inline wchar_t ToLower(wchar_t c)
{
    wchar_t wideChar ;

    if (LCMapStringW(LOCALE_INVARIANT, LCMAP_LOWERCASE, &c, 1, &wideChar, 1) ==0)
    {
        _DBG_BREAK;
	return c;
    }
    return wideChar;
}

inline wchar_t ToUpper(wchar_t c)
{
    wchar_t wideChar ;

    if (LCMapStringW(LOCALE_INVARIANT, LCMAP_UPPERCASE, &c, 1, &wideChar, 1) ==0)
    {
        _DBG_BREAK;
	return c;
    }
    return wideChar;
}

inline wchar_t wbem_towlower(wchar_t c)
{
    if(c >= 0 && c <= 127)
    {
        if(c >= 'A' && c <= 'Z')
            return c + ('a' - 'A');
        else
            return c;
    }
    else return ToLower(c);
}

inline wchar_t wbem_towupper(wchar_t c)
{
    if(c >= 0 && c <= 127)
    {
        if(c >= 'a' && c <= 'z')
            return c + ('A' - 'a');
        else
            return c;
    }
    else return ToUpper(c);
}

inline int wbem_wcsicmp( const wchar_t* wsz1, const wchar_t* wsz2)
{
    while(*wsz1 || *wsz2)
    {
        int diff = wbem_towlower(*wsz1) - wbem_towlower(*wsz2);
        if(diff) return diff;
        wsz1++; wsz2++;
    }

    return 0;
}

inline int wbem_unaligned_wcsicmp( UNALIGNED const wchar_t* wsz1, UNALIGNED const wchar_t* wsz2)
{
    while(*wsz1 || *wsz2)
    {
        int diff = wbem_towlower(*wsz1) - wbem_towlower(*wsz2);
        if(diff) return diff;
        wsz1++; wsz2++;
    }

    return 0;
}

// just like wcsicmp, but first 0 of unicode chracters have been omitted
inline int wbem_ncsicmp(const char* wsz1, const char* wsz2)
{
    while(*wsz1 || *wsz2)
    {
        int diff = wbem_towlower((unsigned char)*wsz1) - 
                    wbem_towlower((unsigned char)*wsz2);
        if(diff) return diff;
        wsz1++; wsz2++;
    }

    return 0;
}

inline int wbem_wcsnicmp( const wchar_t* wsz1, const wchar_t* wsz2, size_t n )
{
    while(n-- && (*wsz1 || *wsz2))
    {
        int diff = wbem_towlower(*wsz1) - wbem_towlower(*wsz2);
        if(diff) return diff;
        wsz1++; wsz2++;
    }

    return 0;
}

inline int wbem_unaligned_wcsnicmp( UNALIGNED const wchar_t* wsz1, UNALIGNED const wchar_t* wsz2, size_t n )
{
    while(n-- && (*wsz1 || *wsz2))
    {
        int diff = wbem_towlower(*wsz1) - wbem_towlower(*wsz2);
        if(diff) return diff;
        wsz1++; wsz2++;
    }

    return 0;
}

inline int wbem_stricmp(const char* sz1, const char* sz2)
{
    while(*sz1 || *sz2)
    {
        int diff = wbem_towlower(*sz1) - wbem_towlower(*sz2);
        if(diff) return diff;
        sz1++; sz2++;
    }

    return 0;
}

inline int wbem_strnicmp(const char* sz1, const char* sz2, size_t n)
{
    while(n-- && (*sz1 || *sz2))
    {
        int diff = wbem_towlower(*sz1) - wbem_towlower(*sz2);
        if(diff) return diff;
        sz1++; sz2++;
    }

    return 0;
}

inline bool wbem_iswdigit(wchar_t c)
{
    WORD result;
    if (GetStringTypeExW(LOCALE_INVARIANT, CT_CTYPE1, &c, 1, &result))
    {
    	return (result & C1_DIGIT) != 0;
    };
    return false;
};

inline bool wbem_iswalnum (wchar_t c)
{
    WORD result;
    if (GetStringTypeExW(LOCALE_INVARIANT, CT_CTYPE1, &c, 1, &result))
    {
    	return (result & (C1_DIGIT | C1_ALPHA)) != 0;
    };
    return false;
};

inline bool wbem_isdigit(char c)
{
    WORD result;
    if (GetStringTypeExA(LOCALE_INVARIANT, CT_CTYPE1, &c, 1, &result))
    {
    	return (result & C1_DIGIT) != 0;
    };
    return false;
};

//
// returns the real length or Max + 1 if it exceeds
// useful for not probing the entire string to see that it's too big
//
/////////////////////////////////////////
inline size_t wcslen_max(WCHAR * p, size_t Max)
{
	WCHAR * pBegin = p;
	WCHAR * pTail = p + Max + 1;
	while (*p && (p < pTail)) p++;
        return p-pBegin;
};

/*
size_t wbem_mbstowcs(        
        wchar_t  *pwcs,
        const char *s,
        size_t n)
{
        size_t count = 0;

        if (pwcs && n == 0)
            // dest string exists, but 0 bytes converted 
            return (size_t) 0;        

#ifdef  _WIN64
        // n must fit into an int for MultiByteToWideCha 
        if ( n > INT_MAX )
            return (size_t)-1;
#endif

        // if destination string exists, fill it in 
        if (pwcs)
        {
            int bytecnt, charcnt;
            unsigned char *p;

            // Assume that the buffer is large enough 
            if ( (count = MultiByteToWideChar( CP_ACP,
                                               MB_PRECOMPOSED | 
                                               MB_ERR_INVALID_CHARS,
                                               s, 
                                               -1, 
                                               pwcs, 
                                               (int)n )) != 0 )
                return count - 1; // don't count NUL 

            if (GetLastError() != ERROR_INSUFFICIENT_BUFFER)
            {
                errno = EILSEQ;
                return (size_t)-1;
            }

            // User-supplied buffer not large enough. 

            // How many bytes are in n characters of the string? 
            charcnt = (int)n;
            for (p = (unsigned char *)s; (charcnt-- && *p); p++)
            {
                if (__isleadbyte_mt(ptloci, *p))
                    p++;
            }
            bytecnt = ((int) ((char *)p - (char *)s));


            if ( (count = MultiByteToWideChar( ptloci->lc_codepage, 
                                                MB_PRECOMPOSED,
                                                s, 
                                                bytecnt, 
                                                pwcs, 
                                                (int)n )) == 0 )
            {                    
                return (size_t)-1;
            }

            return count; // no NUL in string 
        }
        else // pwcs == NULL, get size only, s must be NUL-terminated 
		{            
               if ( (count = MultiByteToWideChar( CP_ACP, 
                                                   MB_PRECOMPOSED | 
                                                   MB_ERR_INVALID_CHARS,
                                                   s, 
                                                   -1, 
                                                   NULL, 
                                                   0 )) == 0 )
                {                    
                    return (size_t)-1;
                }
                return count - 1;            
        }
}
*/


#pragma optimize("", on)

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\winmgmt\wbemcomn\sync.cpp ===
/*++

Copyright (C) 1996-2001 Microsoft Corporation

Module Name:

    SYNC.CPP

Abstract:

    Synchronization

History:

--*/

#include "precomp.h"

#include "sync.h"
#include <cominit.h>
#include <wbemutil.h>
#include <corex.h>

CHaltable::CHaltable() : m_lJustResumed(1), m_dwHaltCount(0), m_csHalt()
{
    // This event will be signaled whenever we are not halted
    // ======================================================

    m_hReady = CreateEvent(NULL, TRUE, TRUE, NULL);                            
    if (NULL == m_hReady) throw CX_MemoryException(); // exception caught in wbemess esssink.cpp
}

CHaltable::~CHaltable()
{
    CloseHandle(m_hReady);
}

HRESULT CHaltable::Halt()
{
    CInCritSec ics(&m_csHalt); // in critical section

    m_dwHaltCount++;
    ResetEvent(m_hReady);
    return S_OK;
}

HRESULT CHaltable::Resume()
{
    CInCritSec ics(&m_csHalt); // in critical section

    m_dwHaltCount--;
    if(m_dwHaltCount == 0)
    {
        SetEvent(m_hReady);
        m_lJustResumed = 1;
    }
    return S_OK;
}

HRESULT CHaltable::ResumeAll()
{
    CInCritSec ics(&m_csHalt); // in critical section
    m_dwHaltCount = 1;
    return Resume();
}


HRESULT CHaltable::WaitForResumption()
{
  while (WbemWaitForSingleObject(m_hReady, INFINITE) == WAIT_FAILED)
    Sleep(0);
    if(InterlockedDecrement(&m_lJustResumed) == 0)
    {
        // The first call after resumption
        return S_OK;
    }
    else
    {
        // weren't halted
        return S_FALSE;
    }
}

BOOL CHaltable::IsHalted()
{
    // Approximate!
    return m_dwHaltCount > 0;
}

CWbemCriticalSection::CWbemCriticalSection( void )
:   m_lLock( -1 ), m_lRecursionCount( 0 ), m_dwThreadId( 0 ), m_hEvent( NULL )
{
    m_hEvent = CreateEvent( NULL, FALSE, FALSE, NULL );

    if ( NULL == m_hEvent )
    {
        throw CX_MemoryException();
    }
}

CWbemCriticalSection::~CWbemCriticalSection( void )
{
    if ( NULL != m_hEvent )
    {
        CloseHandle( m_hEvent );
        m_hEvent = NULL;
    }
}

BOOL CWbemCriticalSection::Enter( DWORD dwTimeout /* = 0xFFFFFFFF */ )
{
    BOOL    fReturn = FALSE;

    // Only do this once
    DWORD   dwCurrentThreadId = GetCurrentThreadId();

    // Check if we are the current owning thread.  We can do this here because
    // this test will ONLY succeed in the case where we have a Nested Lock(),
    // AND because we are zeroing out the thread id when the lock count hits
    // 0.

    if( dwCurrentThreadId == m_dwThreadId )
    {
        // It's us - Bump the lock count
        // =============================

        InterlockedIncrement( &m_lRecursionCount );
        return TRUE;
    }

    // 0 means we got the lock
    if ( 0 == InterlockedIncrement( &m_lLock ) )
    {
        m_dwThreadId = dwCurrentThreadId;
        m_lRecursionCount = 1;
        fReturn = TRUE;
    }
    else
    {
        // We wait.  If we got a signalled event, then we now own the
        // critical section.  Otherwise, we should perform an InterlockedDecrement
        // to account for the Increment that got us here in the first place.
        if ( WaitForSingleObject( m_hEvent, dwTimeout ) == WAIT_OBJECT_0 )
        {
            m_dwThreadId = dwCurrentThreadId;
            m_lRecursionCount = 1;
            fReturn = TRUE;
        }
        else
        {
            InterlockedDecrement( &m_lLock );
        }
    }

    return fReturn;
}

void CWbemCriticalSection::Leave( void )
{
    // We don't check the thread id, so we can lock/unlock resources
    // across multiple threads

    BOOL    fReturn = FALSE;

    long    lRecurse = InterlockedDecrement( &m_lRecursionCount );

    // The recursion count hit zero, so it's time to unlock the object
    if ( 0 == lRecurse )
    {
        // If the lock count is >= 0, threads are waiting, so we need to
        // signal the event
        
        m_dwThreadId = 0;
        if ( InterlockedDecrement( &m_lLock ) >= 0 )
        {
            SetEvent( m_hEvent );
        }

    }   // If recursion count is at 0

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\winmgmt\wbemcomn\sync.h ===
/*++

Copyright (C) 1996-2001 Microsoft Corporation

Module Name:

    SYNC.H

Abstract:

    Synchronization

History:

--*/

#ifndef __WBEM_CRITSEC__H_
#define __WBEM_CRITSEC__H_

#include "corepol.h"
#include <corex.h>

#ifndef STATUS_POSSIBLE_DEADLOCK 
#define STATUS_POSSIBLE_DEADLOCK (0xC0000194L)
#endif /*STATUS_POSSIBLE_DEADLOCK */

DWORD POLARITY BreakOnDbgAndRenterLoop(void);

class POLARITY CCritSec : public CRITICAL_SECTION
{
public:
    CCritSec() 
    {
#ifdef _WIN32_WINNT
#if _WIN32_WINNT > 0x0400
        bool initialized = (InitializeCriticalSectionAndSpinCount(this,0))?true:false;
        if (!initialized) throw CX_MemoryException();
#else
        bool initialized = false;
        __try
        {
            InitializeCriticalSection(this);
            initialized = true;
        }
        __except(GetExceptionCode() == STATUS_NO_MEMORY)
        {
        }
        if (!initialized) throw CX_MemoryException();  
#endif
#else
        bool initialized = false;
        __try
        {
            InitializeCriticalSection(this);
            initialized = true;
        }
        __except(GetExceptionCode() == STATUS_NO_MEMORY)
        {
        }
        if (!initialized) throw CX_MemoryException();  
#endif        
    }

    ~CCritSec()
    {
        DeleteCriticalSection(this);
    }

    void Enter()
    {
        __try {
          EnterCriticalSection(this);
        } __except((STATUS_POSSIBLE_DEADLOCK == GetExceptionCode())? BreakOnDbgAndRenterLoop():EXCEPTION_CONTINUE_SEARCH) {
        }    
    }

    void Leave()
    {
        LeaveCriticalSection(this);
    }
};

        
class POLARITY CInCritSec
{
protected:
    CRITICAL_SECTION* m_pcs;
public:
    CInCritSec(CRITICAL_SECTION* pcs) : m_pcs(pcs)
    {
        __try {
          EnterCriticalSection(m_pcs);
        } __except((STATUS_POSSIBLE_DEADLOCK == GetExceptionCode())? BreakOnDbgAndRenterLoop():EXCEPTION_CONTINUE_SEARCH) {
        }    
    }
    inline ~CInCritSec()
    {
        LeaveCriticalSection(m_pcs);
    }
};


// Allows user to manually leave critical section, checks if inside before leaving
class POLARITY CCheckedInCritSec
{
protected:
    CCritSec* m_pcs;
    BOOL                m_fInside;
public:
    CCheckedInCritSec(CCritSec* pcs) : m_pcs(pcs), m_fInside( FALSE )
    {
        m_pcs->Enter();
        m_fInside = TRUE;
    }
    ~CCheckedInCritSec()
    {
        Leave();
    }

    void Enter( void )
    {
        if ( !m_fInside )
        {
            m_pcs->Enter();
            m_fInside = TRUE;
        }
    }

    void Leave( void )
    {
        if ( m_fInside )
        {
            m_pcs->Leave();
            m_fInside = FALSE;
        }
    }

    BOOL IsEntered( void )
    { return m_fInside; }
};


//
// Local wrapper class.  Does not initialize or clean up the critsec.  Simply
// used as a wrapper for scoping so that AV and exception stack unwinding will
// cause the critsec to be exited properly once it is entered.
//
/////////////////////////////////////////////////////////

class CCritSecWrapper
{
    BOOL m_bIn;
    CCritSec *m_pcs;
public:
    CCritSecWrapper(CCritSec *pcs) { m_pcs = pcs; m_bIn = FALSE; }
   ~CCritSecWrapper() { if (m_bIn) m_pcs->Leave(); }
    void Enter() { m_pcs->Enter(); m_bIn = TRUE; }
    void Leave() { m_pcs->Leave(); m_bIn = FALSE; }
};


class POLARITY CHaltable
{
public:
    CHaltable();
    virtual ~CHaltable();
    HRESULT Halt();
    HRESULT Resume();
    HRESULT ResumeAll();
    HRESULT WaitForResumption();
    BOOL IsHalted();
    bool isValid();

private:
    CCritSec m_csHalt;
    HANDLE m_hReady;
    DWORD m_dwHaltCount;
    long m_lJustResumed;
};

inline bool
CHaltable::isValid()
{ return m_hReady != NULL; };

// This class is designed to provide the behavior of a critical section,
// but without any of that pesky Kernel code.  In some circumstances, we
// need to lock resources across multiple threads (i.e. we lock on one
// thread and unlock on another).  If we do this using a critical section,
// this appears to work, but in checked builds, we end up throwing an
// exception.  Since we actually need to do this (for example using NextAsync
// in IEnumWbemClassObject) this class can be used to perform the
// operation, but without causing exceptions in checked builds.

// Please note that code that is going to do this MUST ensure that we don't
// get crossing Enter/Leave operations (in other words, it's responsible for
// synchronizing the Enter and Leave operations.)  Please note that this
// is a dangerous thing to do, so be VERY careful if you are using this
// code for that purpose.

class POLARITY CWbemCriticalSection
{
private:

    long    m_lLock;
    long    m_lRecursionCount;
    DWORD   m_dwThreadId;
    HANDLE  m_hEvent;

public:

    CWbemCriticalSection();
    ~CWbemCriticalSection();

    BOOL Enter( DWORD dwTimeout = INFINITE );
    void Leave( void );

    DWORD   GetOwningThreadId( void )
    { return m_dwThreadId; }

    long    GetLockCount( void )
    { return m_lLock; }

    long    GetRecursionCount( void )
    { return m_lRecursionCount; }

};

class POLARITY CEnterWbemCriticalSection
{
    CWbemCriticalSection*   m_pcs;
    BOOL                    m_fInside;
public:

    CEnterWbemCriticalSection( CWbemCriticalSection* pcs, DWORD dwTimeout = INFINITE )
        : m_pcs( pcs ), m_fInside( FALSE )
    {
        if ( m_pcs )
        {
            m_fInside = m_pcs->Enter( dwTimeout );
        }
    }

    ~CEnterWbemCriticalSection( void )
    {
        if ( m_fInside )
        {
            m_pcs->Leave();
        }
    }

    BOOL IsEntered( void )
    { return m_fInside; }
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\winmgmt\wbemcomn\tls.h ===
/*++

Copyright (C) 1996-2001 Microsoft Corporation

Module Name:

    TLS.H

Abstract:

	Thread Local Storage

History:

--*/

#ifndef __WBEM_TLS__H_
#define __WBEM_TLS__H_

#include <statsync.h>

class CTLS
{
protected:
    DWORD m_dwIndex;
public:
    inline CTLS() 
    {
        m_dwIndex = TlsAlloc();
        if (TLS_OUT_OF_INDEXES == m_dwIndex)
        	CStaticCritSec::SetFailure();
    }
    inline ~CTLS() {TlsFree(m_dwIndex);}
    inline void* Get() 
        {return ((TLS_OUT_OF_INDEXES == m_dwIndex)?NULL:TlsGetValue(m_dwIndex));}
    inline void Set(void* p)
        {if(TLS_OUT_OF_INDEXES != m_dwIndex) TlsSetValue(m_dwIndex, p);}
    inline DWORD GetIndex(){ return m_dwIndex; };
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\winmgmt\wbemcomn\throttle.h ===
/*++

Copyright (C) 1996-2001 Microsoft Corporation

Module Name:

    THROTTLE.H

Abstract:

    provide a way to do slow down an application, allowing it to execute
    only when there is no user activity (last input was XXX mseconds ago)
    and the IO level is very low (below YYY bytes per second)


History:

	24-Oct-200   ivanbrug    created.


--*/

#ifndef __THROTTLE_H__
#define __THROTTLE_H__

//
//  valid values for dwFlags
//

#define THROTTLE_USER 1
#define THROTTLE_IO   2
#define THROTTLE_ALLOWED_FLAGS (THROTTLE_USER | THROTTLE_IO)

//
//  returned values, might be a combination
//

#define THROTTLE_MAX_WAIT  1
#define THROTTLE_USER_IDLE 2
#define THROTTLE_IO_IDLE   4
#define THROTTLE_FORCE_EXIT 8


HRESULT POLARITY
Throttle(DWORD dwFlags,
         DWORD IdleMSec,         // in MilliSeconds
         DWORD IoIdleBytePerSec, // in BytesPerSecond
         DWORD SleepLoop,        // in MilliSeconds
         DWORD MaxWait);         // in MilliSeconds

//
// strings for registry settings to UnThrottle/Throttle the dredges
//

#define HOME_REG_PATH TEXT("Software\\Microsoft\\WBEM\\CIMOM")
#define DO_THROTTLE   TEXT("ThrottleDrege")

#endif /*__THROTTLE_H__*/
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\winmgmt\wbemcomn\throttle.cpp ===
/*++

Copyright (C) 1996-2001 Microsoft Corporation

Module Name:

    THROTTLE.CPP

Abstract:

        see throttle.h

History:

	24-Oct-200   ivanbrug    created.


--*/

#include "precomp.h"
#include <throttle.h>
#include <arrtempl.h>

#include <wbemint.h>

typedef NTSTATUS (NTAPI * fnNtQuerySystemInformation )(
    IN SYSTEM_INFORMATION_CLASS SystemInformationClass,
    OUT PVOID SystemInformation,
    IN ULONG SystemInformationLength,
    OUT PULONG ReturnLength OPTIONAL
    );    

fnNtQuerySystemInformation MyNtQuerySystemInformation = NULL;

HRESULT POLARITY
Throttle(DWORD dwFlags,
         DWORD IdleMSec,         // in MilliSeconds
         DWORD IoIdleBytePerSec, // in BytesPerSec
         DWORD SleepLoop,        // in MilliSeconds
         DWORD MaxWait)          // in MilliSeconds
//
//  This function will wait until one of this two/three things have happened:
//  - the system has been idle for at least IdleMSec milliseconds
//       (no user input within IdleMSec milliseconds)
//  - the Number of bytes per seconds passed through 
//      the IO system is below a threashold
//  - the MaxWait time has elapsed
//  
//  Reasonable Params are 
//  3000-5000 millisecond with THROTTLE_USER
//  300.000 - 500.000 bytes/second with THROTTLE_IO
//  200 - 500 milliseconds for SleepLoop 
//  several minutes  for MaxWait
//
//  remarks: 
//  - the function will SUCCEDED(Throttle), no matter 
//  - if the MaxWait has been reached or if the Idle conditions 
//    have been met the function will fail in any other case
//  - the function is 'precise' within the range if a System Tick 
//    (15ms on professional)
//  - in the case of an IO throttling, there will always be a Sleep(150)
//
{
    //
    // init static and globals
    //

    if (!MyNtQuerySystemInformation)
    {
        HMODULE hDll = GetModuleHandleW(L"ntdll.dll");
        if (hDll){
            MyNtQuerySystemInformation = (fnNtQuerySystemInformation)GetProcAddress(hDll,"NtQuerySystemInformation"); 
			if ( MyNtQuerySystemInformation == NULL )
			{
				return WBEM_E_FAILED;
			}
        } else {
            return WBEM_E_FAILED;
        }
    }

    static DWORD TimeInc = 0;
    if (!TimeInc)
    {
        BOOL  bIsValid;
        DWORD dwAdj;
        
        if (!GetSystemTimeAdjustment(&dwAdj,&TimeInc,&bIsValid))
        {
            return WBEM_E_FAILED;
        }
    }

    static DWORD PageSize = 0;
    if (!PageSize)
    {
        SYSTEM_INFO  SysInfo;
        GetSystemInfo(&SysInfo);
        PageSize = SysInfo.dwPageSize; 
    }
    //
    // param validation
    //
    if ((dwFlags & ~THROTTLE_ALLOWED_FLAGS) ||
        (0 == SleepLoop))
        return WBEM_E_INVALID_PARAMETER;

    DWORD nTimes = MaxWait/SleepLoop;
    // user input structures
    LASTINPUTINFO LInInfo;
    LInInfo.cbSize = sizeof(LASTINPUTINFO);
    DWORD i;
    DWORD Idle100ns = 10000*IdleMSec; // conversion from 1ms to 100ns
    // io throttling
    SYSTEM_PERFORMANCE_INFORMATION SPI[2];
    BOOL bFirstIOSampleDone = FALSE;
    DWORD dwWhich = 0;
    DWORD cbIO = 1+IoIdleBytePerSec;
    DWORD cbIOOld = 0;
    // boolean logic
    BOOL  bCnd1 = FALSE;
    BOOL  bCnd2 = FALSE;
    // registry stuff for wmisvc to force exit from this function
    HKEY hKey = NULL;
    LONG lRes;
    DWORD dwType;
    DWORD dwLen = sizeof(DWORD);
    DWORD dwVal;
    
    lRes = RegOpenKeyEx(HKEY_LOCAL_MACHINE,
    	               HOME_REG_PATH,
    	               0,
    	               KEY_READ,
    	               &hKey);
    if (ERROR_SUCCESS != lRes)
    	return WBEM_E_FAILED;
    CRegCloseMe cm_(hKey);
    
    if (dwFlags & THROTTLE_IO)
    {
        NTSTATUS Status;
    	Status = MyNtQuerySystemInformation(SystemPerformanceInformation,
                                          &SPI[dwWhich],
           	                              sizeof(SYSTEM_PERFORMANCE_INFORMATION),
               	                          0);        
        if (0 != Status)
        {
            return WBEM_E_FAILED;
        }
        dwWhich = (dwWhich+1)%2;
        Sleep(150);
    }


    for (i=0;i<nTimes;i++)
    {
        //
        // check if someone is telling us to stop waiting
        //
        lRes = RegQueryValueEx(hKey,
                             DO_THROTTLE,
                             0,
                             &dwType,                             
                             (BYTE*)&dwVal,
                             &dwLen);
        if(ERROR_SUCCESS == lRes &&
          0 == dwVal)
          return THROTTLE_FORCE_EXIT;
        	
        //
        //    check the user-input idleness
        //
        if (dwFlags & THROTTLE_USER)
        {
	        if (!GetLastInputInfo(&LInInfo))
	            return WBEM_E_FAILED;
	        DWORD Now = GetTickCount();
	        if (Now < LInInfo.dwTime)
	        {
	            continue; // one of the 49.7 days events
	        }
	        DWORD LastInput100ns = (Now - LInInfo.dwTime)*TimeInc;
	        if (LastInput100ns >= Idle100ns)
	        {
                if (0 == (dwFlags & ~THROTTLE_USER)) {
                    return THROTTLE_USER_IDLE;
                } else {
                    bCnd1 = TRUE;
                };	            
	        }
        }
        //
        // avoid checking the second condition 
        // if the first is FALSE
        //
        if (((dwFlags & (THROTTLE_IO|THROTTLE_USER)) == (THROTTLE_IO|THROTTLE_USER)) &&
            !bCnd1)
        {
            goto sleep_label;
        }
        //
        //  check the io idleness
        //
        if (dwFlags & THROTTLE_IO)
        {
	        NTSTATUS Status;
    	    Status = MyNtQuerySystemInformation(SystemPerformanceInformation,
        	                                  &SPI[dwWhich],
            	                              sizeof(SYSTEM_PERFORMANCE_INFORMATION),
                	                          0);
            if (0 == Status){
            
                cbIOOld = cbIO;
                cbIO = (DWORD)((SPI[dwWhich].IoReadTransferCount.QuadPart   - SPI[(dwWhich-1)%2].IoReadTransferCount.QuadPart) +
                               (SPI[dwWhich].IoWriteTransferCount.QuadPart  - SPI[(dwWhich-1)%2].IoWriteTransferCount.QuadPart) +
                               (SPI[dwWhich].IoOtherTransferCount.QuadPart  - SPI[(dwWhich-1)%2].IoOtherTransferCount.QuadPart) +
                               ((SPI[dwWhich].PageReadCount         - SPI[(dwWhich-1)%2].PageReadCount) +
                                (SPI[dwWhich].CacheReadCount        - SPI[(dwWhich-1)%2].CacheReadCount) +
                                (SPI[dwWhich].DirtyPagesWriteCount  - SPI[(dwWhich-1)%2].DirtyPagesWriteCount) +
                                (SPI[dwWhich].MappedPagesWriteCount - SPI[(dwWhich-1)%2].MappedPagesWriteCount)) * PageSize);

                cbIO = (cbIO * 1000)/SleepLoop;  

                //DBG_PRINTFA((pBuff,"%d - ",cbIO));
                
                cbIO = (cbIOOld+cbIO)/2;
                dwWhich = (dwWhich+1)%2;
                
                //DBG_PRINTFA((pBuff,"%d < %d\n",cbIO,IoIdleBytePerSec));
                
                if (cbIO < IoIdleBytePerSec)
                {
                    if (0 == (dwFlags & ~THROTTLE_IO)) {
                         return THROTTLE_IO_IDLE;
                     } else {
                         bCnd2 = TRUE;
                     };
                }
            }
            else
            {
                return WBEM_E_FAILED;
            }
        }
        //
        //  check the combined condition
        //
        if (dwFlags & (THROTTLE_IO|THROTTLE_USER))
        {
            if (bCnd1 && bCnd2) 
            {
                return (THROTTLE_IO_IDLE|THROTTLE_USER_IDLE);
            } 
            else 
            {
                bCnd1 = FALSE;
                bCnd2 = FALSE;
            }
        }   
        
sleep_label:        
        Sleep(SleepLoop);
    }   
    
    return THROTTLE_MAX_WAIT;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\winmgmt\wbemcomn\tpwrap.cpp ===
#include <tpwrap.h>
#include <windows.h>

class StaticTLS
{
public:
	StaticTLS() : index_(TlsAlloc()){}
	~StaticTLS() { if (index_!=TLS_OUT_OF_INDEXES) TlsFree(index_); index_ = TLS_OUT_OF_INDEXES;}
	void * getValue(void) { return TlsGetValue(index_);}
	BOOL setValue(void * ptr) { return TlsSetValue(index_, ptr);}
	bool valid() { return index_!=TLS_OUT_OF_INDEXES;};
	DWORD index_; 
} HandlerTLS;



LIST_ENTRY 
Dispatcher::handlerListHead_ = { &handlerListHead_, &handlerListHead_};

volatile 
LONG Dispatcher::registeredHandlers_ = 0;

bool 
Dispatcher::startShutDown_ = false;

CriticalSection 
Dispatcher::handlerListLock_(NOTHROW_LOCK, 4000 & 0x80000000);


EventHandler::EventHandler(void) : 
	handlerID_(NULL), once_(0), 
	dispatcher_(0), refCount_(1),
	scheduledClose_(0)

{ Flink = 0; Blink=0; };

EventHandler::~EventHandler(void)
{ }

HANDLE 
EventHandler::getHandle(void) 
{ return INVALID_HANDLE_VALUE;}


int 
EventHandler::handleTimeout(void) 
{ return -1; }

int 
EventHandler::handleEvent(void) 
{ return -1; }

void 
EventHandler::close(void) 
{ return; }

LONG 
EventHandler::AddRef(void) 
{ return InterlockedIncrement(&refCount_); }

LONG 
EventHandler::Release(void) 
{ LONG newReference = InterlockedDecrement(&refCount_);
  if (newReference==0)
	  delete this; 
  return newReference;
}

DWORD 
EventHandler::getTimeOut(void)
{ return INFINITE; }



VOID CALLBACK 
Dispatcher::HandleWaitOrTimerCallback( PVOID lpParameter, BOOLEAN TimerOrWaitFired )
{
  EventHandler * handler = reinterpret_cast<EventHandler *>(lpParameter);

  if (startShutDown_)
	return;

  if (handler->scheduledClose_)
  	return;
	
  assert(lpParameter!=0);
  assert(HandlerTLS.getValue()==0);
  HandlerTLS.setValue(lpParameter); 
  

  int result = 0;
  if (TimerOrWaitFired == TRUE)
    result = handler->handleTimeout();
  else
    result = handler->handleEvent();

  if (result == -1)
 	removeHandler(*handler);

  HandlerTLS.setValue(0);
};
 

int 
Dispatcher::registerHandler(EventHandler& eh, int flags) 
{
  assert(startShutDown_==0);
  assert(eh.handlerID_ == NULL);

  eh.type_ = EventHandler::WAIT;
  handlerListLock_.acquire();
  BOOL retVal = RegisterWaitForSingleObject(&eh.handlerID_, eh.getHandle(), HandleWaitOrTimerCallback, &eh, eh.getTimeOut(), flags);
  if (retVal)
  	openHandler(&eh);
  handlerListLock_.release();
  return retVal;
};


int 
Dispatcher::registerHandlerOnce(EventHandler& eh, int flags) 
{ 
  assert(startShutDown_==0);
  assert(eh.handlerID_ == NULL);
  
  eh.type_ = EventHandler::WAIT;
  handlerListLock_.acquire();
  eh.once_ = 1;
  BOOL retVal = RegisterWaitForSingleObject(&eh.handlerID_, eh.getHandle(), HandleWaitOrTimerCallback, &eh, eh.getTimeOut(), flags|WT_EXECUTEONLYONCE);
  if (retVal)
  	openHandler(&eh);
  handlerListLock_.release();
  return retVal;
};


void Dispatcher::insertTail(EventHandler *entry)
{
 
  LIST_ENTRY* _EX_Blink;
  LIST_ENTRY* _EX_ListhandlerListHead_;
  _EX_ListhandlerListHead_ = &handlerListHead_;
  _EX_Blink = _EX_ListhandlerListHead_->Blink;
  entry->Flink = _EX_ListhandlerListHead_;
  entry->Blink = _EX_Blink;
  _EX_Blink->Flink = entry;
  _EX_ListhandlerListHead_->Blink = entry;
};

void Dispatcher::removeEntry(EventHandler *entry)
{
  entry->Flink->Blink = entry->Blink;
  entry->Blink->Flink = entry->Flink;
  entry->Flink = 0;
  entry->Blink = 0;
};

void Dispatcher::openHandler(EventHandler* entry)
{
	entry->AddRef();
	InterlockedIncrement(&registeredHandlers_);
	insertTail(entry);
}

void Dispatcher::closeHandler(EventHandler* entry)
{
	handlerListLock_.acquire();
	removeEntry(entry);
	handlerListLock_.release();
	
	entry->handlerID_ = NULL;
	entry->close();
	entry->Release();
	InterlockedDecrement(&registeredHandlers_);
};

int 
Dispatcher::removeHandler(EventHandler& handler)
{ 
	long scheduledDelete = InterlockedCompareExchange(&handler.scheduledClose_, 1, 0);
	if (scheduledDelete==1)
	  return 0;

  	assert(handler.handlerID_);
	if (HandlerTLS.getValue()==0)
		{
		return DeleteNotification(&handler);
		}
	else
	{
		if (PostDeleteNotification(handler)==0)
			InterlockedDecrement(&registeredHandlers_);
	}
  return 0;
};

int 
Dispatcher::scheduleTimer(EventHandler& eh, DWORD first, DWORD repeat, DWORD mode )
{
   assert(startShutDown_==0);
   
   eh.type_ = EventHandler::TIMER;
   handlerListLock_.acquire();

	bool once = (repeat==0) ||( (mode & WT_EXECUTEONLYONCE) != 0);
	if (once)
		repeat = INFINITE-1;
	eh.once_ = once;

	BOOL retCode = CreateTimerQueueTimer(&eh.handlerID_, 0, TimerCallback, &eh, first, repeat, mode);
	
	if (retCode)
  		openHandler(&eh);
	handlerListLock_.release();  	
	return retCode;
};

int 
Dispatcher::cancelTimer(EventHandler& handler)
{ 
	long scheduledDelete = InterlockedCompareExchange(&handler.scheduledClose_, 1, 0);
	if (scheduledDelete==1)
	  return 0;

	if (HandlerTLS.getValue()==0)
		{
		return DeleteTimer(&handler);
		}
	else
		{
		if(PostDeleteTimer(handler)==0)
			InterlockedDecrement(&registeredHandlers_);
		}
        return 0;
};

int 
Dispatcher::changeTimer(EventHandler& handler, DWORD first, DWORD repeat)
{ 
  assert(handler.handlerID_);
  if (repeat==0)
	{
	repeat = INFINITE-1;
	handler.once_ = 1;
	}
  return ChangeTimerQueueTimer(NULL, handler.handlerID_, first, repeat);
};


DWORD WINAPI Dispatcher::DeleteTimer( LPVOID lpParameter)
{
	EventHandler * ev = reinterpret_cast<EventHandler *>(lpParameter);
	if (DeleteTimerQueueTimer(NULL, ev->handlerID_, INVALID_HANDLE_VALUE))	
		{
		closeHandler(ev);
		return 1;
		}
	else
		InterlockedDecrement(&registeredHandlers_);
	return 0;
};

DWORD WINAPI Dispatcher::DeleteNotification( LPVOID lpParameter)
{
	EventHandler * ev = reinterpret_cast<EventHandler *>(lpParameter);
	if (UnregisterWaitEx(ev->handlerID_, INVALID_HANDLE_VALUE))
		{
		closeHandler(ev);
		return 1;
		}
	else
		InterlockedDecrement(&registeredHandlers_);
	return 0;
};

BOOL Dispatcher::PostDeleteNotification(EventHandler& ev)
{
	return QueueUserWorkItem(DeleteNotification, &ev, WT_EXECUTEDEFAULT);
}

BOOL Dispatcher::PostDeleteTimer(EventHandler& ev)
{
	return QueueUserWorkItem(DeleteTimer, &ev, WT_EXECUTEDEFAULT);
};

void CALLBACK 
Dispatcher::TimerCallback(void* lpParameter, BOOLEAN TimerOrWaitFired)
{
  assert(registeredHandlers_!=0);
  assert(HandlerTLS.getValue()==0);
  assert(TimerOrWaitFired==TRUE);
  assert(lpParameter!=0);

  EventHandler * handler = reinterpret_cast<EventHandler*>(lpParameter);

  if (startShutDown_)
	return;

  if (handler->scheduledClose_)
  	return;

  if (handler->once_)
	{
	LONG fired = InterlockedCompareExchange(&handler->once_,2,1);
	if (fired != 1)
		return;
	}

  HandlerTLS.setValue(lpParameter);

  int result = handler->handleTimeout();
  if (result == -1)
	  cancelTimer(*handler);
  HandlerTLS.setValue(0);
};

int 
Dispatcher::open()
{ return handlerListLock_.valid() && HandlerTLS.valid(); };

int Dispatcher::close()
{
	startShutDown_ = 1;
	int outstandingHandlers = 0;
	handlerListLock_.acquire();
	LIST_ENTRY * p = &handlerListHead_;
	LIST_ENTRY * next  = p->Flink;
	int entries =  0;
	while((p = next) != &handlerListHead_)
		{
		next = next->Flink;
		EventHandler * ev = static_cast<EventHandler *>(p);
		long scheduledDelete = InterlockedCompareExchange(&ev->scheduledClose_, 1, 0);
		if (!scheduledDelete)
			{
			if (ev->type_==EventHandler::WAIT)
				DeleteNotification(ev);
			else
				DeleteTimer(ev);
			}
		}
	handlerListLock_.release();

	while(0!=registeredHandlers_)
		if (!SwitchToThread())
			Sleep(1);
		
	p = &handlerListHead_;
	next = p->Flink;	
	while((p = next) != &handlerListHead_)
		{
		BOOL ret;
		next = next->Flink;
		EventHandler * ev = static_cast<EventHandler *>(p);

		if (ev->type_==EventHandler::WAIT)
			ret = UnregisterWaitEx(ev->handlerID_, INVALID_HANDLE_VALUE);
		else
			ret = DeleteTimerQueueTimer(NULL, ev->handlerID_, INVALID_HANDLE_VALUE);
		if (ret)
			{
			ev->close();
			ev->Release();
			}
		}
	
	startShutDown_ = 0;
	return 0;
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\winmgmt\wbemcomn\tpwrap.h ===
#ifndef __TP_WRAP_
#define __TP_WRAP_

#ifdef DBG
  #undef NDEBUG
#endif
#include <assert.h>
#include <windows.h>
#include <locks.h>

class Dispatcher;

class EventHandler : public LIST_ENTRY
{
protected:
	LONG refCount_;
	LONG scheduledClose_;	// logicaly bool
  	HANDLE handlerID_;
 	LONG once_;
  	Dispatcher * dispatcher_;
  	friend class Dispatcher;
	
public:
	enum HANDLER_TYPE { TIMER, WAIT} type_;
	HANDLER_TYPE handlerType(){ return type_;}
	
	virtual LONG AddRef(void);
	virtual LONG Release(void);
       virtual void close(void);
	virtual HANDLE getHandle(void);

	virtual int handleTimeout(void);
	virtual int handleEvent(void);
	virtual DWORD getTimeOut(void);

	Dispatcher * dispatcher(void);
	void dispatcher(Dispatcher* r);

protected:
  	EventHandler(void);  
  	virtual ~EventHandler(void)=0;
};


#ifdef WINVER
#if (WINVER>=0x0500)

class Dispatcher{
	static LIST_ENTRY handlerListHead_;
	static volatile LONG registeredHandlers_;
	static bool startShutDown_;
	static CriticalSection handlerListLock_;	
public:
	static int registerHandler(EventHandler& eh, int flags = WT_EXECUTELONGFUNCTION) ;
	static int registerHandlerOnce(EventHandler& eh, int flags = WT_EXECUTELONGFUNCTION) ;
	static int removeHandler(EventHandler& handler);

	static int scheduleTimer(EventHandler& eh, DWORD first, DWORD repeat=0, DWORD mode = WT_EXECUTELONGFUNCTION);
	static int cancelTimer(EventHandler& handler);
	static int changeTimer(EventHandler& handler, DWORD first, DWORD repeat=0);
	static int close();
	static int open();

private:
	static void insertTail(EventHandler *entry);
	static void removeEntry(EventHandler *entry);
	static void closeHandler(EventHandler* entry);
	static void openHandler(EventHandler* entry);



	static DWORD WINAPI DeleteTimer( LPVOID lpParameter);
	static DWORD WINAPI DeleteNotification( LPVOID lpParameter);
	static BOOL PostDeleteNotification(EventHandler& ev);
	static BOOL PostDeleteTimer(EventHandler& ev);

	static VOID CALLBACK HandleWaitOrTimerCallback( PVOID lpParameter, BOOLEAN TimerOrWaitFired );
	static void CALLBACK TimerCallback(void* lpParameter, BOOLEAN TimerOrWaitFired);
	
};
#endif
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\winmgmt\wbemcomn\tss.cpp ===
/*++

Copyright (C) 1996-2001 Microsoft Corporation

Module Name:

    TSS.CPP

Abstract:

  This file implements the classes used by the Timer Subsystem.

History:

  26-Nov-96   raymcc      Draft
  28-Dec-96   a-richm     Alpha PDK Release
  12-Apr-97   a-levn      Extensive changes

--*/

#include "precomp.h"

#include "tss.h"
#include <cominit.h>
#include <stdio.h>
#include <wbemutil.h>


CInstructionQueue::CInstructionQueue()
    : m_pQueue(NULL), m_csQueue(), m_bBreak(FALSE)
{
    // Create the event which will be signaled whenever a new instruction
    // is added to the head of the queue
    // ==================================================================

    m_hNewHead = CreateEvent(NULL,
        FALSE, // automatic reset
        FALSE, // non-signalled
        NULL);
    if (NULL == m_hNewHead)
        throw CX_MemoryException(); // checked in esssink.cpp

}

CInstructionQueue::~CInstructionQueue()
{
    CInCritSec ics(&m_csQueue); // work inside critical section

    while(m_pQueue)
    {
        CQueueEl* pCurrent = m_pQueue;
        m_pQueue = m_pQueue->m_pNext;
        delete pCurrent;
    }
    CloseHandle(m_hNewHead);
}

void CInstructionQueue::TouchHead()
{
    SetEvent(m_hNewHead);
}

HRESULT CInstructionQueue::Enqueue(CWbemTime When,
                                   ADDREF CTimerInstruction* pInst)
{
    CInCritSec ics(&m_csQueue); // work inside critical section

    // Create the link-list element for the object
    // ===========================================

    CQueueEl* pNew = new CQueueEl(pInst, When);
    if(!pNew)
        return WBEM_E_OUT_OF_MEMORY;

    // Find the right place to insert this instruction
    // ===============================================

    CQueueEl* pCurrent = m_pQueue;
    CQueueEl* pLast = NULL;
    while(pCurrent && When >= pCurrent->m_When)
    {
        pLast = pCurrent;
        pCurrent = pCurrent->m_pNext;
    }

    // Insert it
    // =========

    if(pLast)
    {
        // Inserting in the middle
        // =======================

        pLast->m_pNext = pNew;
        pNew->m_pNext = pCurrent;
    }
    else
    {
        // Inserting at the head
        // =====================

        pNew->m_pNext = m_pQueue;
        m_pQueue = pNew;
        TouchHead();
    }

    return S_OK;
}

HRESULT CInstructionQueue::Dequeue(OUT RELEASE_ME CTimerInstruction*& pInst,
                                   OUT CWbemTime& When)
{
    CInCritSec ics(&m_csQueue); // all work in critical section

    if(m_pQueue == NULL)
        return S_FALSE;

    pInst = m_pQueue->m_pInst;
    When = m_pQueue->m_When;

    // Null out the instruction in the queue so it would not be deleted
    // ================================================================
    m_pQueue->m_pInst = NULL;

    // Delete the head from the queue
    // ==============================

    CQueueEl* pNewHead = m_pQueue->m_pNext;
    delete m_pQueue;
    m_pQueue = pNewHead;

    return S_OK;
}

HRESULT CInstructionQueue::Remove(IN CInstructionTest* pPred,
                                  OUT RELEASE_ME CTimerInstruction** ppInst)
{
    if(ppInst)
        *ppInst = NULL;

    CTimerInstruction* pToMark = NULL;
    BOOL bFound = FALSE;

    {
        CInCritSec ics(&m_csQueue); // all work in critical section
        CQueueEl* pCurrent = m_pQueue;
        CQueueEl* pLast = NULL;
        while(pCurrent)
        {
            if((*pPred)(pCurrent->m_pInst))
            {
                // Accepted. Remove
                // ================

                bFound = TRUE;
                CQueueEl* pNext;
                if(pLast)
                {
                    // removing from the middle
                    // ========================

                    pLast->m_pNext = pCurrent->m_pNext;
                    pNext = pLast->m_pNext;
                }
                else
                {
                    // Removing from the head
                    // ======================
                    m_pQueue = pCurrent->m_pNext;
                    pNext = m_pQueue;
                    TouchHead();
                }

                if(pToMark)
                {
                    // This is not entirely clean. This function was originally
                    // written to remove one instruction, but then converted to
                    // remove all matching ones.  The **ppInst and pToMark
                    // business is only applicable to the one instruction case.
                    // It would be cleaner to split this function up into two,
                    // but that's too risky at this point.
                    // ========================================================

                    pToMark->Release();
                }
                pToMark = pCurrent->m_pInst;
                pToMark->AddRef();

                delete pCurrent;
                pCurrent = pNext;
            }
            else
            {
                pLast = pCurrent;
                pCurrent = pCurrent->m_pNext;
            }
        }
    } // out of critical section

    // Preserve the instruction to be returned, if required
    // ====================================================

    if(ppInst != NULL)
    {
        // Release whatever may be in there
        // ================================

        if(*ppInst)
            (*ppInst)->Release();

        // Store the instruction being deleted there
        // =========================================

        *ppInst = pToMark;
    }
    else if(pToMark)
    {
        pToMark->MarkForRemoval();
        pToMark->Release();
    }

    if(!bFound) return S_FALSE;
    return S_OK;
}

HRESULT CInstructionQueue::Change(CTimerInstruction* pInst, CWbemTime When)
{
    CInCritSec ics(&m_csQueue); // all work in critical section

    CIdentityTest Test(pInst);
    CTimerInstruction* pObtained;
    if(Remove(&Test, &pObtained) == S_OK)
    {
        // pObtained == pInst, of course
        // =============================

        // Got it. Enqueue with new time
        // =============================

        HRESULT hres = S_OK;
        if(When.IsFinite())
            hres = Enqueue(When, pInst);
        pObtained->Release();
        return hres;
    }
    else
    {
        // This instruction is no longer there
        return S_FALSE;
    }
}

BOOL CInstructionQueue::IsEmpty()
{
    return (m_pQueue == NULL);
}

CWbemInterval CInstructionQueue::TimeToWait()
{
    // ================================================
    // Assumes that we are inside the critical section!
    // ================================================
    if(m_pQueue == NULL)
    {
        return CWbemInterval::GetInfinity();
    }
    else
    {
        return CWbemTime::GetCurrentTime().RemainsUntil(m_pQueue->m_When);
    }
}


void CInstructionQueue::BreakWait()
{
    m_bBreak = TRUE;
    SetEvent(m_hNewHead);
}


HRESULT CInstructionQueue::WaitAndPeek(
        OUT RELEASE_ME CTimerInstruction*& pInst, OUT CWbemTime& When)
{
    EnterCriticalSection(&m_csQueue);
    CWbemInterval ToWait = TimeToWait();

    // Wait that long. The wait may be interrupted and shortened by
    // insertion of new instructions
    // ============================================================

    while(!ToWait.IsZero())
    {
        LeaveCriticalSection(&m_csQueue);

        // If ToWait is infinite, wait for 30 seconds instead
        // ==================================================

        DWORD dwMilli;
        if(ToWait.IsFinite())
            dwMilli = ToWait.GetMilliseconds();
        else
            dwMilli = 30000;

        DWORD dwRes = WbemWaitForSingleObject(m_hNewHead, dwMilli);

	if(m_bBreak)
            return S_FALSE;

        if (dwRes == -1 || (dwRes == WAIT_TIMEOUT && !ToWait.IsFinite()))
        {
            if (dwRes == -1)
	      {
	      ERRORTRACE((LOG_WBEMCORE, "WaitForMultipleObjects failed. LastError = %X.\n", GetLastError()));
	      ::Sleep(0);
	      }

	    // We timed out on the 30 second wait --- time to quit for lack
            // of work
            // ============================================================

            return WBEM_S_TIMEDOUT;
        }

        EnterCriticalSection(&m_csQueue);

        ToWait = TimeToWait();
    }

    // still in critical section

    pInst = m_pQueue->m_pInst;
    When = m_pQueue->m_When;
    pInst->AddRef();
    LeaveCriticalSection(&m_csQueue);
    return S_OK;
}

long CInstructionQueue::GetNumInstructions()
{
    EnterCriticalSection(&m_csQueue);

    long lCount = 0;
    CQueueEl* pCurrent = m_pQueue;
    while(pCurrent)
    {
        lCount++;
        pCurrent = pCurrent->m_pNext;
    }
    LeaveCriticalSection(&m_csQueue);
    return lCount;
}



CTimerGenerator::CTimerGenerator()
    : CHaltable(), m_fExitNow(FALSE), m_hSchedulerThread(NULL) 
{
    // throws because of CHaltable
}

void CTimerGenerator::EnsureRunning()
{
    CInCritSec ics(&m_cs);

    if(m_hSchedulerThread)
        return;

    // Create scheduler thread.
    // ========================

    NotifyStartingThread();

    DWORD dwThreadId;
    m_hSchedulerThread = CreateThread(
        NULL,                // pointer to thread security attributes
        0,                   // initial thread stack size, in bytes
        (LPTHREAD_START_ROUTINE)SchedulerThread, // pointer to thread function
        (CTimerGenerator*)this,                // argument for new thread
        0,                   // creation flags
        &dwThreadId          // pointer to returned thread identifier
        );
}

HRESULT CTimerGenerator::Shutdown()
{
    if(m_hSchedulerThread)
    {
        // Set the flag indicating that the scheduler should stop
        m_fExitNow = 1;

        // Resume the scheduler if halted.
        ResumeAll();

        // Wake up scheduler. It will stop immediately because of the flag.
        m_Queue.BreakWait();

        // Wait for scheduler thread to exit.
        WbemWaitForSingleObject(m_hSchedulerThread, INFINITE);
        CloseHandle(m_hSchedulerThread);
        m_hSchedulerThread = NULL;
        return S_OK;
    }
    else return S_FALSE;
}

CTimerGenerator::~CTimerGenerator()
{
    Shutdown();
}

HRESULT CTimerGenerator::Set(ADDREF CTimerInstruction *pInst,
                             CWbemTime NextFiring)
{
  if (isValid() == false)
    return WBEM_E_OUT_OF_MEMORY;

	CInCritSec ics(&m_cs);

    //
    // 0 for NextFiring indicates that the instruction has not been fired or
    // scheduled before, and should therefore be asked when its first firing
    // time should be
    //

    if(NextFiring.IsZero())
    {
        NextFiring = pInst->GetFirstFiringTime();
    }

    //
    // Infinite firing time indicates that this istruction can never fire
    //

    if(!NextFiring.IsFinite())
        return S_FALSE;

    //
    // Real instruction --- enqueue
    //

    HRESULT hres = m_Queue.Enqueue(NextFiring, pInst);

    //
    // Ensure time generator thread is running, as it shuts down when there are
    // no instructions on the queue
    //

    EnsureRunning();
    return hres;
}

HRESULT CTimerGenerator::Remove(CInstructionTest* pPred)
{
    CInCritSec ics(&m_cs);

    HRESULT hres = m_Queue.Remove(pPred);
    if(FAILED(hres)) return hres;
    return S_OK;
}


DWORD  CTimerGenerator::SchedulerThread(LPVOID pArg)
{
    InitializeCom();
    CTimerGenerator * pGen = (CTimerGenerator *) pArg;

	try
	{
	    while(1)
	    {
	        // Wait until we are resumed. In non-paused state, returns immediately.
	        // ====================================================================

					pGen->WaitForResumption();

	        // Wait for the next instruction on the queue to mature
	        // ====================================================

	        CTimerInstruction* pInst;
	        CWbemTime WhenToFire;
	        HRESULT hres = pGen->m_Queue.WaitAndPeek(pInst, WhenToFire);
	        if(hres == S_FALSE)
	        {
	            // End of the game: destructor called BreakDequeue
	            // ===============================================

	            break;
	        }
	        else if(hres == WBEM_S_TIMEDOUT)
	        {
	            // The thread is exiting for lack of work
	            // ======================================

	            CInCritSec ics(&pGen->m_cs);

	            // Check if there is any work
	            // ==========================

	            if(pGen->m_Queue.IsEmpty())
	            {
	                // That's it --- exit
	                // ==================

	                CloseHandle( pGen->m_hSchedulerThread );
	                pGen->m_hSchedulerThread = NULL;
	                break;
	            }
	            else
	            {
	                // Work was added before we entered CS
	                // ===================================
	                continue;
	            }
	        }

	        // Make sure we haven't been halted while sitting here
	        // ===================================================

	        if(pGen->IsHalted())
	        {
	            // try again later.
	            pInst->Release();
	            continue;
	        }

	        // Figure out how many times this instruction has "fired"
	        // ======================================================

	        long lMissedFiringCount = 0;
	        CWbemTime NextFiring = pInst->GetNextFiringTime(WhenToFire,
	            &lMissedFiringCount);

	        // Notify accordingly
	        // ==================

	        pInst->Fire(lMissedFiringCount+1, NextFiring);

	        // Requeue the instruction
	        // =======================

	        if(pGen->m_Queue.Change(pInst, NextFiring) != S_OK)
	        {
	            //Error!!!
	        }
	        pInst->Release();
	    }
	}
	catch( CX_MemoryException )
	{ 
	}
	
    pGen->NotifyStoppingThread();
    CoUninitialize();

    return 0;
}


class CFreeUnusedLibrariesInstruction : public CTimerInstruction
{
protected:
    long m_lRef;
    CWbemInterval m_Delay;

public:
    CFreeUnusedLibrariesInstruction() : m_lRef(0)
    {
        m_Delay.SetMilliseconds(660000);
    }

    virtual void AddRef() { InterlockedIncrement(&m_lRef);}
    virtual void Release() {if(0 == InterlockedDecrement(&m_lRef)) delete this;}
    virtual int GetInstructionType() {return INSTTYPE_FREE_LIB;}

public:
    virtual CWbemTime GetNextFiringTime(CWbemTime LastFiringTime,
        OUT long* plFiringCount) const
    {
        *plFiringCount = 1;
        return CWbemTime::GetInfinity();
    }

    virtual CWbemTime GetFirstFiringTime() const
    {
        return CWbemTime::GetCurrentTime() + m_Delay;
    }
    virtual HRESULT Fire(long lNumTimes, CWbemTime NextFiringTime)
    {
        DEBUGTRACE((LOG_WBEMCORE, "Calling CoFreeUnusedLibraries...\n"));
        CoFreeUnusedLibraries();
        return S_OK;
    }
};


void CTimerGenerator::ScheduleFreeUnusedLibraries()
{
    // Inform our EXE that now and in 11 minutes would be a good time to call
    // CoFreeUnusedLibraries
    // ======================================================================

    HANDLE hEvent = OpenEvent(EVENT_MODIFY_STATE, FALSE, __TEXT("WINMGMT_PROVIDER_CANSHUTDOWN"));
	if (hEvent)
	{
        SetEvent(hEvent);
        CloseHandle(hEvent);
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\winmgmt\wbemcomn\tss.h ===
/*++

Copyright (C) 1996-2001 Microsoft Corporation

Module Name:

    TSS.CPP

Abstract:

  This file defines the classes used by the Timer Subsystem. 

  Classes defined:

      RecurrenceInstruction       Complex recurrence information.
      TimerInstruction            Single instruction for the timer

History:

  26-Nov-96   raymcc      Draft
  28-Dec-96   a-richm     Alpha PDK Release
  12-Apr-97   a-levn      Extensive changes

--*/

#ifndef _TSS_H_
#define _TSS_H_

#include <functional>
#include <wbemidl.h>
#include <stdio.h>
#include "sync.h"
#include "CWbemTime.h"
#include "parmdefs.h"

#define INSTTYPE_WBEM 1
#define INSTTYPE_INTERNAL 2
#define INSTTYPE_AGGREGATION 3
#define INSTTYPE_UNLOAD 4
#define INSTTYPE_FREE_LIB 5

class POLARITY CTimerInstruction
{
public:
    CTimerInstruction(){}
    virtual ~CTimerInstruction()
    {
    }

    virtual void AddRef() = 0;
    virtual void Release() = 0;
    virtual int GetInstructionType() = 0;

public:
    virtual CWbemTime GetNextFiringTime(CWbemTime LastFiringTime,
        OUT long* plFiringCount) const = 0;
    virtual CWbemTime GetFirstFiringTime() const = 0;
    virtual HRESULT Fire(long lNumTimes, CWbemTime NextFiringTime) = 0;
    virtual HRESULT MarkForRemoval(){return S_OK;}
};

class POLARITY CInstructionTest 
{
public:
    virtual BOOL operator()(CTimerInstruction* pToTest) = 0;
};


class POLARITY CIdentityTest : public CInstructionTest
{
protected:
    CTimerInstruction* m_pInst;
public:
    CIdentityTest(CTimerInstruction* pInst) : m_pInst(pInst)
    {
        pInst->AddRef();
    }
    ~CIdentityTest() {m_pInst->Release();}
    BOOL operator()(CTimerInstruction* pToTest) {return pToTest == m_pInst;}
};

class POLARITY CInstructionQueue
{
public:
    CInstructionQueue();
    ~CInstructionQueue();

    HRESULT Enqueue(IN CWbemTime When, IN ADDREF CTimerInstruction* pInst);
    HRESULT Remove(IN CInstructionTest* pPred, 
        OUT RELEASE_ME CTimerInstruction** ppInst = NULL);
    HRESULT Change(CTimerInstruction* pInst, CWbemTime When);
    HRESULT WaitAndPeek(OUT RELEASE_ME CTimerInstruction*& pInst, 
        OUT CWbemTime& When);

    void BreakWait();
    BOOL IsEmpty();

    HRESULT Dequeue(OUT RELEASE_ME CTimerInstruction*& pInst, 
        OUT CWbemTime& When);

    long GetNumInstructions();
protected:
    CWbemInterval TimeToWait();
    void TouchHead();
public:

protected:
    struct CQueueEl
    {
        CWbemTime m_When;
        CTimerInstruction* m_pInst;
        CQueueEl* m_pNext;

        CQueueEl() : m_pInst(NULL), m_pNext(NULL){}
        CQueueEl(ADDREF CTimerInstruction* pInst, CWbemTime When) 
            : m_pInst(pInst), m_pNext(NULL), m_When(When)
        {
            if(pInst)pInst->AddRef();
        }
        ~CQueueEl() 
        {
            if(m_pInst) m_pInst->Release();
        }
    };

    CQueueEl* m_pQueue;

    CCritSec m_csQueue;
    HANDLE m_hNewHead;
    BOOL m_bBreak;
};


///*****************************************************************************
//
//  class CTimerGenerator                       
//
//  Primary Timer Subsystem class. Accepts timer instructions and fires them
//  at approriate times.
//
//*****************************************************************************

class POLARITY CTimerGenerator : public CHaltable
{
public:    
    CTimerGenerator();
   ~CTimerGenerator(); 

    HRESULT Set(ADDREF CTimerInstruction *pInst, 
                    CWbemTime NextFiring = CWbemTime::GetZero());
    HRESULT Remove(CInstructionTest* pPred);
    virtual HRESULT Shutdown();
    void ScheduleFreeUnusedLibraries();

protected:
    virtual void NotifyStartingThread(){}
    virtual void NotifyStoppingThread(){}
private:
    static DWORD SchedulerThread(LPVOID pArg);
    void EnsureRunning();

protected:
    CCritSec m_cs;
    HANDLE    m_hSchedulerThread;
    BOOL    m_fExitNow;    
    CInstructionQueue m_Queue; // leave the queue last, so that the m_cs is not destructed yet
                             // when the destructor for this guy is called
};


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\winmgmt\wbemcomn\txttempl.cpp ===
/*++

Copyright (C) 1996-2001 Microsoft Corporation

Module Name:

Abstract:

History:

--*/


#include "precomp.h"
#include "txttempl.h"
#include <stdio.h>
#include <assert.h>
#include "var.h"
#include <arrtempl.h>

CTextTemplate::CTextTemplate(LPCWSTR wszTemplate) : m_wsTemplate(wszTemplate)
{
}
    
CTextTemplate::~CTextTemplate()
{
}

void CTextTemplate::SetTemplate(LPCWSTR wszTemplate)
{
    m_wsTemplate = wszTemplate;
}

// replace escape sequences with proper characters
// currently enabled for:
// \t; \n; \r;
// anything else is translated literally, minus the backwhack
// returned string may or may not be same string as passed in
// if not, then arg string is deleted & a new one returned.
// -=> Thou Hast Been Forewarned!
BSTR CTextTemplate::ReturnEscapedReturns(BSTR str)
{
    BSTR newStr = str;
    
    // if we find a backwhack
    if (NULL != wcschr(str, L'\\'))
    {
        if (newStr = SysAllocString(str))
        {
            WCHAR *pSource, *pDest;
            ZeroMemory(newStr, (wcslen(str)+1) *2);

            pDest = newStr;
            pSource = str;

            do 
            {
                if (*pSource == L'\\')
                {
                    pSource++;
                    switch (*pSource)
                    {
                        case L'n' : 
                        case L'N' : 
                            *pDest = L'\n';
                            break;
                        case L't' : 
                        case L'T' : 
                            *pDest = L'\t';
                            break;
                        case L'r' : 
                        case L'R' : 
                           *pDest = L'\r';
                            break;
                        default:
                            *pDest = *pSource;
                    }
                }
                else
                    *pDest = *pSource;

                pDest++;
            }
            while (*++pSource);

            *pDest = '\0';
            SysFreeString(str);
        }
        else
            // graceful degradation: return untranslated string if we're out of memory
            // user sees ugly escape sequence but is better than failing altogether.
            newStr = str;
    }

    return newStr;
};

// v is an array (caller's supposed to check)
// str is a string representing that array
// this fcn checks for single element arrays
// and if so, magically transforms 
// "{element}" to "element"
// BSTR returned may or may not be the same as the one passed in.
BSTR CTextTemplate::ProcessArray(const VARIANT& v, BSTR str)
{
    if (SafeArrayGetDim(v.parray) == 1)
    {
        long lBound =0, uBound =0;
        SafeArrayGetLBound(v.parray, 1, &lBound);
        SafeArrayGetUBound(v.parray, 1, &uBound);

        UINT nStrLen = wcslen(str);

        assert( nStrLen >= 2 );

        // check if there's one element

        if (uBound == lBound)
        {
            // single dimensioned array, with a single element.
            // nuke the curlies by copying everything but.
            
            UINT lastChar = nStrLen - 2;            

            for (UINT i = 1; i <= lastChar; i++)
                str[i-1] = str[i];
            str[lastChar] = L'\0';
        }
        else
        {
            //
            // convert the curlies to parentheses. note that this 
            // only works for single dimensional arrays.
            //
            str[0] = '(';
            str[nStrLen-1] = ')';
        }
            
    }
    
    return str;
}

// concatentates property onto string
// does so without quotes around the property, instead of:
//     str "prop"
// you get:
//     str prop
// we do *not* check for escapes in this function: we blindly strip off the leading & trailing quote
void CTextTemplate::ConcatWithoutQuotes(WString& str, BSTR& property)
{
    // dump the quotes
    if ((property[0] == L'\"') && (property[wcslen(property) -1] == L'\"'))
    {
        // hop past the first one
        WCHAR* p = property;
        p++;
        str += p;

        // null out the last one
        p = (wchar_t*)str;
        p[wcslen(p) -1] = L'\0';
    }
    else
        str += property;

}

BSTR CTextTemplate::Apply(IWbemClassObject* pObj)
{
    WString wsText; 
    
    WCHAR* pwc = (WCHAR*)m_wsTemplate;
    while(*pwc)
    {
        if(*pwc != L'%')
        {
            wsText += *pwc;
        }
        else
        {
            pwc++;

            if(*pwc == L'%')
            {
                // Double %
                // ========

                wsText += L'%';
            }
            else
            {
                // It's a property --- find the end
                // ================================

                WCHAR *pwcEnd = wcschr(pwc, L'%');
                if(pwcEnd == NULL)  
                {
                    // No end --- fail
                    // ===============

                    wsText += L"<error>";
                    break;
                }
                else
                {
                    // Look for the optional formatting string.
                    WCHAR *pszFormat = wcschr(pwc, '(');

                    // If we found a paren before what we thought was
                    // the end, look for the end of the formatting string.
                    // Once we find it, look again for the real end.  We do
                    // this in case the % we found was actually part of the
                    // formatting string.
                    if (pszFormat && pszFormat < pwcEnd)
                    {
                        pszFormat = wcschr(pszFormat + 1, ')');
                        if (pszFormat)
                            pwcEnd = wcschr(pszFormat + 1, '%');
                    }

                    wmilib::auto_buffer<WCHAR> wszName(new WCHAR[pwcEnd - pwc + 1]);
                          
                    if (NULL == wszName.get()) return NULL;

                    wcsncpy(wszName.get(), pwc, pwcEnd - pwc);
                    wszName[pwcEnd-pwc] = 0;

                    // Look for the optional formatting string.
                    if ((pszFormat = wcschr(wszName.get(), '(')) != NULL)
                    {
                        WCHAR *pszEndFormat;

                        *pszFormat = 0;
                        pszFormat++;

                        pszEndFormat = wcschr(pszFormat, ')');

                        if (pszEndFormat)
                            *pszEndFormat = 0;
                        else
                            // In case of a bad format string.
                            pszFormat = NULL;
                    }

                        
                    // Get it
                    // ======

                    if(!wbem_wcsicmp(wszName.get(), L"__TEXT"))
                    {
                        BSTR strText = NULL;

                        pObj->GetObjectText(0, &strText);
                        if(strText != NULL)
                        {
                            CSysFreeMe fm(strText);
                            wsText += strText;
                        }
                        else 
                            wsText += L"<error>";
                    }
                    else if(IsEmbeddedObjectProperty(wszName.get()))
                    {
                        // We have embedded object(s)
                        // ==========================

                        BSTR bstr = HandleEmbeddedObjectProperties(wszName.get(), pObj);

                        if (bstr)
                        {
                            CSysFreeMeRef fmref(bstr);
                            // we want to do this here, rather than in the HandleEmbeddedObjectProperties
                            // because that call can go recursive, thereby removing too many backwhacks!
                            bstr = ReturnEscapedReturns(bstr);
                            if (bstr)
                            {
                                ConcatWithoutQuotes(wsText, bstr);
                            }
                        }
                    }
                    else 
                    {
                        _variant_t v;
                        CIMTYPE ct;
                        HRESULT hres = pObj->Get(wszName.get(), 0, &v, &ct, NULL);
    
                        // Append its value
                        // ================
                        if (WBEM_E_NOT_FOUND == hres)
                            wsText += L"<unknown>";
                        else if(FAILED(hres))
                            wsText += L"<failed>";                
                        else if (V_VT(&v) == VT_NULL)
                        {
                            wsText += L"<null>";
                        }
                        else if (V_VT(&v) == VT_UNKNOWN)
                        {
                            BSTR strText = NULL;
                            IWbemClassObject* pEmbeddedObj;
                            if (SUCCEEDED(V_UNKNOWN(&v)->QueryInterface(IID_IWbemClassObject, (void**)&pEmbeddedObj)))
                            {                                                                
                                pEmbeddedObj->GetObjectText(0, &strText);
                                pEmbeddedObj->Release();
                            }
                            CSysFreeMe fm(strText);

                            if(strText != NULL)
                                wsText += strText;
                            else 
                                wsText += L"<error>";
                        }
                        else if ( V_VT(&v) == (VT_UNKNOWN | VT_ARRAY) )
                        {
                            // We have an array of objects
                            // ==============================================
                            
                            long ix[2] = {0,0};
                            long lLower, lUpper;

                            int iDim = SafeArrayGetDim(v.parray); 
                            SafeArrayGetLBound(v.parray,1,&lLower);
                            SafeArrayGetUBound(v.parray, 1, &lUpper);

                            wsText += L"{";

                            for(ix[0] = lLower; ix[0] <= lUpper; ix[0]++)
                            {
                                IUnknown HUGEP *pUnk;
                                // this array access does not copy anything, hence success assumed
                                SafeArrayGetElement( v.parray,
                                                          &(ix[0]),
                                                          &pUnk);

                                BSTR strText = NULL;
                                IWbemClassObject* pEmbeddedObj;
                                if (SUCCEEDED(pUnk->QueryInterface(
                                               IID_IWbemClassObject, 
                                               (void**)&pEmbeddedObj)))
                                {                                     
                                    pEmbeddedObj->GetObjectText(0, &strText);
                                    pEmbeddedObj->Release();
                                }
                                CSysFreeMe fm(strText);

                                if(strText != NULL)
                                    wsText += strText;
                                else 
                                    wsText += L"<error>";

                                if(ix[0] < lUpper)
                                {
                                    wsText += L", ";
                                }
                            }

                            wsText += L"}";
                        }
                        else 
                        {
                            CVar Var;
                            Var.SetVariant(&v);
                            BSTR str = Var.GetText(0, ct, pszFormat);

                            CSysFreeMeRef fmRef(str);

                            if (str == NULL)
                            {
                                wsText += L"<error>";
                            }
                            else 
                            {
                                if (V_VT(&v) & VT_ARRAY)
                                    str = ProcessArray(v, str);

                                if (str)
                                {                                
                                    str = ReturnEscapedReturns(str);

                                    if (str)
                                    {
                                        ConcatWithoutQuotes(wsText, str);
                                    }
                                }
                            }
                        }                        
                    }
                    // Move the pointer
                    pwc = pwcEnd;
                }
            }
        }

        pwc++;
    }

    BSTR str = SysAllocString(wsText);
    return str;
}

                                                
BSTR CTextTemplate::HandleEmbeddedObjectProperties(WCHAR* wszTemplate, IWbemClassObject* pObj)
{
    WString wsText;

    // Get the embedded object/array
    // =============================

    WCHAR* pwc = wszTemplate;
    WCHAR* pwcEnd = wcschr(wszTemplate, L'.');

    if(!pwcEnd)
    {
        BSTR bstr = SysAllocString(L"<error>");
        return bstr;    
    }

    WCHAR* wszName = new WCHAR[pwcEnd - pwc + 1];
    if (NULL == wszName) return SysAllocString(L"<failed>");
    CVectorDeleteMe<WCHAR> dm(wszName);

    wcsncpy(wszName, pwc, pwcEnd - pwc);
    wszName[pwcEnd-pwc] = 0;

    _variant_t v;
    HRESULT hres = pObj->Get(wszName, 0, &v, NULL, NULL);

   if (WBEM_E_NOT_FOUND == hres)
        return SysAllocString(L"<unknown>");
    else if(FAILED(hres))
        return SysAllocString(L"<failed>");                
    else if (V_VT(&v) == VT_NULL)
        return SysAllocString(L"<null>");

    pwc = wcschr(wszTemplate, L'.');
    WCHAR wszProperty[1024];
    StringCchCopyW(wszProperty, 1024, (pwc + 1));

    if(V_VT(&v) == VT_UNKNOWN)
    {
        // We have a single object, so process it
        // =======================================

        BSTR bstr = GetPropertyFromIUnknown(wszProperty, V_UNKNOWN(&v));

        if (bstr)
        {
            CSysFreeMe fm(bstr);
            wsText += bstr;
        }
    }
    else if((V_VT(&v) & VT_ARRAY) && (V_VT(&v) & VT_UNKNOWN))
    {
        // We have an array of objects, so process the elements
        // ====================================================
        
        long ix[2] = {0,0};
        long lLower, lUpper;

        int iDim = SafeArrayGetDim(v.parray); 

        SafeArrayGetLBound(v.parray, 1, &lLower);
        SafeArrayGetUBound(v.parray, 1, &lUpper);

        wsText += L"{";

        for(ix[0] = lLower; ix[0] <= lUpper; ix[0]++){

            IUnknown HUGEP *pUnk;
            // no copy performed when accessing the n-th element, hence no failure
            SafeArrayGetElement(v.parray, &(ix[0]), &pUnk);

            BSTR bstr = GetPropertyFromIUnknown(wszProperty, pUnk);
            if (bstr)
            {
                CSysFreeMe fm(bstr);
                wsText += bstr;
            }

            if(ix[0] < lUpper)
            {
                wsText += L", ";
            }
        }

        wsText += L"}";
    }
    else
    {
        // We have something else, which we shouldn't
        // ==========================================

        wsText += L"<error>";
    }

    BSTR str = SysAllocString(wsText);
    return str;
}

BOOL CTextTemplate::IsEmbeddedObjectProperty(WCHAR * wszProperty)
{
    WCHAR* pwcStart = wcschr(wszProperty, L'[');

    if(pwcStart)
    {
        return TRUE;
    }

    pwcStart = wcschr(wszProperty, L'.');

    if(pwcStart)
    {
        return TRUE;
    }

    return FALSE;
}

BSTR CTextTemplate::GetPropertyFromIUnknown(WCHAR *wszProperty, IUnknown *pUnk)
{
    BSTR bstrRetVal = NULL;
    IWbemClassObject *pEmbedded  = NULL;

    // Get an IWbemClassObject pointer
    // ===============================

    HRESULT hres = pUnk->QueryInterface( IID_IWbemClassObject, 
                                             (void **)&pEmbedded );

    if(SUCCEEDED(hres))
    {
        CReleaseMe rm(pEmbedded);
        
        // For each object get the desired property
        if(IsEmbeddedObjectProperty(wszProperty))
        {
            // We have more embedded object(s)
            // ===============================
            BSTR bstr = HandleEmbeddedObjectProperties( wszProperty, 
                                                        pEmbedded );
            if (bstr)
            {
                bstrRetVal = SysAllocString(bstr);
                SysFreeString(bstr);
            }
        }
        else
        {
            _variant_t vProp;
            CIMTYPE ct;
            HRESULT hRes = pEmbedded->Get( wszProperty, 0, &vProp,
                                           &ct, NULL );

            if (WBEM_E_NOT_FOUND == hRes)
            {
                bstrRetVal = SysAllocString(L"<unknown>");
            }
            else if(FAILED(hRes))
            {
                bstrRetVal = SysAllocString(L"<failed>");                
            }
            else if (V_VT(&vProp) == VT_NULL)
            {
                bstrRetVal = SysAllocString(L"<null>");
            }
            else 
            {
                BSTR str = NULL;
                
                if ( V_VT(&vProp) == ( VT_UNKNOWN | VT_ARRAY ) )
                {
                    WString wsText;

                    // We have an array of objects
                    // ==============================================
                    
                    long ix[2] = {0,0};
                    long lLower, lUpper;
                    
                    int iDim = SafeArrayGetDim(vProp.parray); 
                    HRESULT hr=SafeArrayGetLBound(vProp.parray,1,&lLower);
                    hr = SafeArrayGetUBound(vProp.parray, 1, &lUpper);
                    
                    wsText += L"{";

                    for(ix[0] = lLower; ix[0] <= lUpper; ix[0]++)
                    {
                        IUnknown *pUnkHere = NULL;
                        hr = SafeArrayGetElement( vProp.parray,
                                                  &(ix[0]),
                                                  &pUnkHere );
                        
                        BSTR strText = NULL;
                        IWbemClassObject* pEmbeddedObj = NULL;
                        if (SUCCEEDED(pUnkHere->QueryInterface(
                                           IID_IWbemClassObject, 
                                           (void**)&pEmbeddedObj)))
                        {                                     
                            pEmbeddedObj->GetObjectText(0, &strText);
                            pEmbeddedObj->Release();
                        }
                        CSysFreeMe sfm(strText);
                        
                        if(strText != NULL)
                            wsText += strText;
                        else 
                            wsText += L"<error>";

                        if(ix[0] < lUpper)
                        {
                            wsText += L", ";
                        }
                    }

                    wsText += L"}";

                    str = SysAllocString( wsText );
                }
                else if ( V_VT(&vProp) != VT_UNKNOWN )
                {
                    CVar Var;
                    Var.SetVariant(&vProp);
                    str = Var.GetText( 0, ct );
                }
                else
                {
                    IWbemClassObject* pEmbedded2;
                    hres = V_UNKNOWN(&vProp)->QueryInterface(
                                              IID_IWbemClassObject,
                                              (void**)&pEmbedded2 );
                    if ( SUCCEEDED(hres) )
                    {
                        pEmbedded2->GetObjectText( 0, &str );
                        pEmbedded2->Release();
                    }
                }
                
                if( str == NULL )
                {
                    bstrRetVal = SysAllocString(L"<error>");
                }
                else 
                {
                    bstrRetVal = str;
                }

                if ( V_VT(&vProp) & VT_ARRAY )
                {
                    bstrRetVal = ProcessArray(vProp, bstrRetVal);
                }
            }
        }

    }

    return bstrRetVal;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\winmgmt\wbemcomn\txttempl.h ===
/*++

Copyright (C) 1996-2001 Microsoft Corporation

Module Name:

Abstract:

History:

--*/

#ifndef __WBEM_TEXT_TEMPLATE__H_
#define __WBEM_TEXT_TEMPLATE__H_

#include <windows.h>
#include <wbemidl.h>
#include <wstring.h>

class CTextTemplate
{
protected:
    WString m_wsTemplate;

public:
    CTextTemplate(LPCWSTR wszTemplate = NULL);
    ~CTextTemplate();

    void SetTemplate(LPCWSTR wszTemplate);
    BSTR Apply(IWbemClassObject* pObj);

private:
	BSTR HandleEmbeddedObjectProperties(WCHAR* wszTemplate, IWbemClassObject* pObj);
	BOOL IsEmbeddedObjectProperty(WCHAR * wszProperty);
	BSTR GetPropertyFromIUnknown(WCHAR *wszProperty, IUnknown *pUnk);
    BSTR ProcessArray(const VARIANT& v, BSTR str);
    void ConcatWithoutQuotes(WString& str, BSTR& property);


    bool HasEscapeSequence(BSTR str);
    BSTR ReturnEscapedReturns(BSTR str);

};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\winmgmt\wbemcomn\unk.cpp ===
/*++

Copyright (C) 1996-2001 Microsoft Corporation

Module Name:

    UNK.CPP

Abstract:

    IUnknown Helpers

History:

--*/

#include "precomp.h"

#include "unk.h"


CUnk::CUnk(CLifeControl* pControl, IUnknown* pOuter)
    : m_lRef(0), m_pControl(pControl), m_pOuter(pOuter)
{
    if( m_pControl ) 
    {
        m_pControl->ObjectCreated((IUnknown*)this);
    }
}

CUnk::~CUnk()
{
    if( m_pControl ) 
    {
        m_pControl->ObjectDestroyed((IUnknown*)this);
    }
}

BOOL CUnk::Initialize()
{
    m_lRef++;
    GetUnknown()->AddRef();
    BOOL bRes = OnInitialize();
    GetUnknown()->Release();
    m_lRef--;
    return bRes;
}

// Non-delegating implementation
STDMETHODIMP CUnk::QueryInterface(REFIID riid, void** ppv)
{
    *ppv = NULL;
    
    if(riid == IID_IUnknown)
        *ppv = (IUnknown*)this;
    else
        *ppv = GetInterface(riid);

    if(*ppv)
    {
        ((IUnknown*)*ppv)->AddRef();
        return S_OK;
    }
    else return E_NOINTERFACE;
}

ULONG CUnk::AddRef()
{
    return InterlockedIncrement(&m_lRef);
}

ULONG CUnk::Release()
{
    long lRef = InterlockedDecrement(&m_lRef);
    if(lRef == 0)
    {
        m_lRef++;
        delete this;
    }
    return lRef;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\winmgmt\wbemcomn\unk.h ===
/*++

Copyright (C) 1996-2001 Microsoft Corporation

Module Name:

    UNK.H

Abstract:

    IUnknown Helpers

History:

--*/

#ifndef __WBEM_UNKNOWN__H_
#define __WBEM_UNKNOWN__H_

#include <objbase.h>
#include "corepol.h"

#pragma warning(disable : 4355)
class POLARITY CLifeControl
{
public:
    virtual BOOL ObjectCreated(IUnknown* pv) = 0;
    virtual void ObjectDestroyed(IUnknown* pv) = 0;
    virtual void AddRef(IUnknown* pv) = 0;
    virtual void Release(IUnknown* pv) = 0;
};
   
class POLARITY CContainerControl : public CLifeControl
{
protected:
    IUnknown* m_pUnk;
public:
    CContainerControl(IUnknown* pUnk) : m_pUnk(pUnk){}

    virtual BOOL ObjectCreated(IUnknown* pv){ return TRUE;};
    virtual void ObjectDestroyed(IUnknown* pv){};
    virtual void AddRef(IUnknown* pv){m_pUnk->AddRef();}
    virtual void Release(IUnknown* pv){m_pUnk->Release();}
};

class POLARITY CUnk : public IUnknown
{
public:// THIS IS DUE TO A VC++ BUG!!! protected:
    long m_lRef;
    CLifeControl* m_pControl;
    IUnknown* m_pOuter;

    IUnknown* GetUnknown() {return m_pOuter?m_pOuter:(IUnknown*)this;}

    virtual void* GetInterface(REFIID riid) = 0;
    virtual BOOL OnInitialize(){return TRUE;}
public:
    CUnk(CLifeControl* pControl = NULL, IUnknown* pOuter = NULL);
    virtual ~CUnk();
    virtual BOOL Initialize();

    // non-delegating interface
    STDMETHOD(QueryInterface)(REFIID riid, void** ppv);
    STDMETHOD_(ULONG, AddRef)();
    STDMETHOD_(ULONG, Release)();

    IUnknown* GetInnerUnknown() {return this;}
    void SetControl(CLifeControl* pControl);
};

class POLARITY CUnkInternal : public IUnknown
{
protected:

    long m_lRef;
    CLifeControl* m_pControl;

public:

    CUnkInternal( CLifeControl* pControl ) : m_pControl(pControl), m_lRef(0) {}
    virtual ~CUnkInternal() {}

    virtual void* GetInterface(REFIID riid) = 0;
    IUnknown* GetUnknown() { return (IUnknown*)this; }

    STDMETHOD(QueryInterface)(REFIID riid, void** ppv)
    {
        HRESULT hr = InternalQueryInterface( riid, ppv );
        if ( SUCCEEDED(hr) )
            AddRef();
        return hr;
    }

    STDMETHOD_(ULONG, AddRef)()
    {
        if ( m_pControl )
            m_pControl->ObjectCreated((IUnknown*)this);
        return InternalAddRef();
    }

    STDMETHOD_(ULONG, Release)()
    {
        CLifeControl* pControl = m_pControl;
        ULONG ulRef = InternalRelease();
        if ( pControl )
            pControl->ObjectDestroyed((IUnknown*)this);
        return ulRef;
    }

    HRESULT InternalQueryInterface( REFIID riid, void** ppv )
    {
        HRESULT hr;

        if( riid == IID_IUnknown )
            *ppv = (IUnknown*)this;
        else 
            *ppv = GetInterface(riid);

        if ( *ppv != NULL )
            hr = S_OK;
        else
            hr = E_NOINTERFACE;

        return hr;
    }

    ULONG InternalAddRef()
    {
         return InterlockedIncrement(&m_lRef);   
    }

    ULONG InternalRelease()
    {
        long lRef = InterlockedDecrement(&m_lRef);
        if(lRef == 0)
            delete this;
        return lRef;        
    }
};


template <class TInterface, class TObject>
class CImpl : public TInterface
{
protected:
    TObject* m_pObject;
public:
    CImpl(TObject* pObject) : m_pObject(pObject){}
    ~CImpl(){}

    // delegating interface
    STDMETHOD(QueryInterface)(REFIID riid, void** ppv)
    {
        return m_pObject->GetUnknown()->QueryInterface(riid, ppv);
    }
    STDMETHOD_(ULONG, AddRef)()
    {
        return m_pObject->GetUnknown()->AddRef();
    }
    STDMETHOD_(ULONG, Release)()
    {
        return m_pObject->GetUnknown()->Release();
    }
};

template <class TInterface, const IID* t_piid>
class CUnkBase : public TInterface
{
protected:
    long m_lRef;
    CLifeControl* m_pControl;

public:
    typedef CUnkBase<TInterface, t_piid> TUnkBase;

    CUnkBase(CLifeControl* pControl = NULL) 
    : m_pControl(pControl), m_lRef(0)
    {
        if ( m_pControl != NULL ) m_pControl->ObjectCreated(this);
    }

    virtual ~CUnkBase()
    {
        if ( m_pControl != NULL ) m_pControl->ObjectDestroyed(this);
    }

    ULONG STDMETHODCALLTYPE AddRef()
    {
        return InterlockedIncrement(&m_lRef);
    }
    ULONG STDMETHODCALLTYPE Release()
    {
        long lRef = InterlockedDecrement(&m_lRef);
        if(lRef == 0)
            delete this;
        return lRef;
    }
    HRESULT STDMETHODCALLTYPE QueryInterface(REFIID riid, void** ppv)
    {
        if(riid == IID_IUnknown || riid == *t_piid)
        {
            AddRef();
            *ppv = this;
            return S_OK;
        }
        else return E_NOINTERFACE;
    }
};

template <class TInterface, const IID* t_piid, class TInterface2,
            const IID* t_piid2>
class CUnkBase2 : public TInterface, public TInterface2
{
protected:
    long m_lRef;
    CLifeControl* m_pControl;

public:
    typedef CUnkBase2<TInterface, t_piid, TInterface2, t_piid2> TUnkBase;

    CUnkBase2(CLifeControl* pControl = NULL) : m_pControl(pControl), m_lRef(0)
    {
        if (m_pControl != NULL) 
            m_pControl->ObjectCreated((TInterface*)this);
    }

    virtual ~CUnkBase2()
    {
        if (m_pControl != NULL) 
            m_pControl->ObjectDestroyed((TInterface*)this);
    }

    ULONG STDMETHODCALLTYPE AddRef()
    {
        return InterlockedIncrement(&m_lRef);
    }
    ULONG STDMETHODCALLTYPE Release()
    {
        long lRef = InterlockedDecrement(&m_lRef);
        if(lRef == 0)
            delete this;
        return lRef;
    }
    HRESULT STDMETHODCALLTYPE QueryInterface(REFIID riid, void** ppv)
    {
        if(riid == IID_IUnknown || riid == *t_piid)
        {
            AddRef();
            *ppv = (TInterface*)this;
            return S_OK;
        }
        else if(riid == *t_piid2)
        {
            AddRef();
            *ppv = (TInterface2*)this;
            return S_OK;
        }
        else return E_NOINTERFACE;
    }
};


template<class TInterface1, class TInterface2>
class CChild2 : public virtual TInterface1, public virtual TInterface2
{
};

template<class TInterfaces>
class CUnkTemplate : public TInterfaces
{
protected:
    IUnknown* m_pOuter;

    class CInnerUnk : public IUnknown
    {
    private:
        CUnkTemplate<TInterfaces>* m_pObject;
        long m_lRef;
        CLifeControl* m_pControl;
    public:
        CInnerUnk(CUnkTemplate<TInterfaces>* pObject, CLifeControl* pControl)
        {
            if(m_pControl) m_pControl->ObjectCreated(this);
            m_lRef++;
            GetUnknown()->AddRef();
            m_pObject->Initialize();
            GetUnknown()->Release();
            m_lRef--;
        }
        ~CInnerUnk()
        {
            if(m_pControl) m_pControl->ObjectDestroyed(this);
        }

        // non-delegating interface
        STDMETHOD(QueryInterface)(REFIID riid, void** ppv)
        {
            if(riid == IID_IUnknown)
                *ppv = (IUnknown*)&m_Inner;
            else
                *ppv = m_pObject->GetInterface(riid);
        
            if(*ppv)
            {
                AddRef();
                return S_OK;
            }
            else return E_NOINTERFACE;
        }
        STDMETHOD_(ULONG, AddRef)()
        {
            if(m_pControl) m_pControl->AddRef((IUnknown*)this);
            return InterlockedIncrement(&m_lRef);
        }
        STDMETHOD_(ULONG, Release)()
        {
            if(m_pControl) m_pControl->Release((IUnknown*)this);
            long lRef = InterlockedDecrement(&m_lRef);
            if(lRef == 0)
            {
                m_lRef++;
                delete m_pObject;
            }
            return lRef;
        }
    } m_Inner;

    IUnknown* GetUnknown() 
        {return m_pOuter?m_pOuter:(IUnknown*)&m_Inner;}
    virtual void Initialize(){}

public:
    CUnkTemplate(CLifeControl* pControl = NULL, IUnknown* pOuter = NULL)
        : m_Inner(this, pControl), m_pOuter(pOuter){}
    virtual ~CUnkTemplate(){}

    // delegating interface
    STDMETHOD(QueryInterface)(REFIID riid, void** ppv)
    {
        return GetUnknown()->QueryInterface(riid, ppv);
    }
    STDMETHOD_(ULONG, AddRef)()
    {
        return GetUnknown()->AddRef();
    }
    STDMETHOD_(ULONG, Release)()
    {
        return GetUnknown()->Release();
    }

    IUnknown* GetInnerUnknown() {return &m_Inner;}
};


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\winmgmt\wbemcomn\unload.h ===
/*++

Copyright (C) 1996-2001 Microsoft Corporation

Module Name:

    UNLOAD.H

Abstract:

  Unloading helper.

History:

--*/

#ifndef _WBEM_UNLOAD__H_
#define _WBEM_UNLOAD__H_

#include <tss.h>
#include <wstring.h>
#include <wbemidl.h>

class POLARITY CBasicUnloadInstruction : public CTimerInstruction
{
protected:
    long m_lRef;
    BOOL m_bTerminate;
    CWbemInterval m_Interval;
    CCritSec m_cs;

protected:
    CBasicUnloadInstruction() : m_lRef(0), m_bTerminate(FALSE){}

public:
    CBasicUnloadInstruction(CWbemInterval Interval);
    virtual ~CBasicUnloadInstruction(){}

    void AddRef(){InterlockedIncrement(&m_lRef);}
    void Release(){LONG lRef = InterlockedDecrement(&m_lRef); if(0 == lRef) delete this;}

    int GetInstructionType() {return INSTTYPE_UNLOAD;}
    void SetInterval(CWbemInterval & Interval){m_Interval = Interval;};

    static CWbemInterval staticRead(IWbemServices* pRoot, 
                                      IWbemContext* pContext, LPCWSTR wszPath);

    virtual HRESULT Fire(long lNumTimes, CWbemTime NextFiringTime) = 0;

    CWbemTime GetNextFiringTime(CWbemTime LastFiringTime, 
                                    OUT long* plFiringCount) const;
        
    CWbemTime GetFirstFiringTime() const;
    void Terminate();
};

class  POLARITY CUnloadInstruction : public CBasicUnloadInstruction
{
protected:
    BSTR m_strPath;
    IWbemContext* m_pFirstContext;
    IWbemServices* m_pNamespace;


public:
    CUnloadInstruction(LPCWSTR wszPath, IWbemContext* pFirstContext);
    virtual ~CUnloadInstruction();
    const BSTR GetPath(){return m_strPath;};

    virtual void Reread(IWbemContext* pContext = NULL);
    virtual HRESULT Fire(long lNumTimes, CWbemTime NextFiringTime) = 0;

    CWbemTime GetFirstFiringTime() const;
    static void Clear();
    void SetToDefault();
};


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\winmgmt\wbemcomn\unload.cpp ===
/*++

Copyright (C) 1996-2001 Microsoft Corporation

Module Name:

    UNLOAD.CPP

Abstract:

  Unloading helper.

History:

--*/

#include "precomp.h"
#include <stdio.h>
#include <wbemcomn.h>
#include <unload.h>
#include <arrtempl.h>

CUnloadInstruction::CUnloadInstruction(LPCWSTR wszPath, 
                                        IWbemContext* pFirstContext)
    : CBasicUnloadInstruction(), m_strPath(SysAllocString(wszPath)),
        m_pFirstContext(pFirstContext), m_pNamespace(NULL)
{
    m_Interval.SetMilliseconds(0);
    if(m_pFirstContext)
        m_pFirstContext->AddRef();
}

void CUnloadInstruction::Clear()
{
}
    
CUnloadInstruction::~CUnloadInstruction()
{
    if(m_pNamespace)
        m_pNamespace->Release();

    SysFreeString(m_strPath);
    if(m_pFirstContext)
        m_pFirstContext->Release();
}

void CUnloadInstruction::SetToDefault()
{
    m_Interval.SetMilliseconds(3600000);
}

void CUnloadInstruction::Reread(IWbemContext* pContext)
{
    HRESULT hres;
    if(m_pNamespace == NULL)
    {
        IWbemLocator * pLocator = NULL;
        hres = CoCreateInstance(CLSID_WbemAdministrativeLocator, NULL, 
            CLSCTX_INPROC_SERVER, IID_IWbemLocator, (void**)&pLocator);
        if(hres == S_OK) 
        {
            hres = pLocator->ConnectServer(L"ROOT", NULL, NULL, NULL,
                0, NULL, NULL, &m_pNamespace);
            pLocator->Release();
        }
    
    
        if(m_pNamespace == NULL)
        {
            SetToDefault();
            return;
        }
    }

    m_Interval = staticRead(m_pNamespace, pContext, m_strPath);
}


CWbemTime CUnloadInstruction::GetFirstFiringTime() const 
{
    if(m_Interval.IsZero())
    {
        // This function is const, but Reread is not, so have to cast
        // ==========================================================

        ((CUnloadInstruction*)this)->Reread(m_pFirstContext);
    }

    return CBasicUnloadInstruction::GetFirstFiringTime();
}

//*****************************************************************************
//
//                      BASIC VERSION
// 
//*****************************************************************************
CBasicUnloadInstruction::CBasicUnloadInstruction(CWbemInterval Interval)
    : m_lRef(0), m_bTerminate(FALSE), m_Interval(Interval)
{
}

void CBasicUnloadInstruction::Terminate()
{
    CInCritSec ics(&m_cs);
    m_bTerminate = TRUE;
}



// static
CWbemInterval CBasicUnloadInstruction::staticRead(IWbemServices* pRoot, 
                IWbemContext* pContext, LPCWSTR wszPath)
{
    HRESULT hres;

    BSTR strPath = SysAllocString(wszPath);
    if(strPath == NULL)
        return CWbemInterval::GetInfinity();
    CSysFreeMe sfm1(strPath);

    IWbemClassObject* pObj = NULL;
    hres = pRoot->GetObject(strPath, 0, pContext, &pObj, NULL);
    if(FAILED(hres))
    {
        ERRORTRACE((LOG_WBEMCORE, "Unable to read cache configuration object "
            "at %S: %X\n", strPath, hres));
        return CWbemInterval::GetInfinity();
    }
    CReleaseMe rm1(pObj);

    VARIANT var;
	VariantInit(&var);
    hres = pObj->Get(L"ClearAfter", 0, &var, NULL, NULL);
    if(FAILED(hres))
    {
        ERRORTRACE((LOG_WBEMCORE, "No ClearCache property in cache "
            "configuration object at %S: %X\n", strPath, hres));
        return CWbemInterval::GetInfinity();
    }
	CClearMe cm(&var);

    if(var.vt != VT_BSTR)
    {
        return CWbemInterval::GetInfinity();
    }

    DWORD dwYears, dwMonths, dwDays, dwHours, dwMinutes, dwSeconds;
    if(swscanf(var.bstrVal, L"%4u%2u%2u%2u%2u%2u", &dwYears, &dwMonths, 
        &dwDays, &dwHours, &dwMinutes, &dwSeconds) != 6)
    {
        ERRORTRACE((LOG_WBEMCORE, "Unparsable ClearCache property in cache "
            "configuration object at %S: %X\n", strPath, hres));
        return CWbemInterval::GetInfinity();
    }
        
    if(dwYears != 0 || dwMonths != 0)
    {
        // makes no sense
        // ==============

        return CWbemInterval::GetInfinity();
    }

    dwSeconds += dwMinutes * 60 + dwHours * 3600 + dwDays * 3600 * 24;
    CWbemInterval Interval;
    Interval.SetMilliseconds(1000 * dwSeconds);
    return Interval;
}


CWbemTime CBasicUnloadInstruction::GetFirstFiringTime() const 
{
    return CWbemTime::GetCurrentTime() + m_Interval;
}

CWbemTime CBasicUnloadInstruction::GetNextFiringTime(CWbemTime LastFiringTime,
                                OUT long* plFiringCount) const
{
    if(m_bTerminate) 
        return CWbemTime::GetInfinity();

    *plFiringCount = 1;
    return LastFiringTime + m_Interval;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\winmgmt\wbemcomn\var.cpp ===
/*++

Copyright (C) 1996-2001 Microsoft Corporation

Module Name:

    VAR.H

Abstract:

  CVar & CVarVector implemntation

History:

    16-Apr-96   a-raymcc    Created.
    12//17/98   sanjes -    Partially Reviewed for Out of Memory.
    18-Mar-99   a-dcrews    Added out-of-memory exception handling

--*/

#include "precomp.h"

#include <stdio.h>
#include <stdlib.h>

#include <var.h>
#include <wbemutil.h>
#include <genutils.h>
#include <wbemidl.h>
#include <corex.h>
#include <arrtempl.h>
#include <olewrap.h>

static wchar_t g_szNullVarString[1] = {0};
static wchar_t* g_pszNullVarString = &g_szNullVarString[0];

//***************************************************************************
//
//  CVar::Empty
//
//  Constructor helper.
//
//  This merely clears everything.  VT_EMPTY is the default.
//
//***************************************************************************

void CVar::Init()
{
    m_nStatus = no_error; 
    m_vt = VT_EMPTY;
    m_bCanDelete = TRUE;
    memset(&m_value, 0, sizeof(METAVALUE));
}


//***************************************************************************
//
//  CVar::~CVar
//
//  Destructor.
//
//***************************************************************************

CVar::~CVar()
{
    Empty();
}



//***************************************************************************
//
//  CVar::CVar
//
//  Copy constructor.  This is implemented via the assignment operator.
//  
//***************************************************************************

CVar::CVar(const CVar &Src)
{
    m_vt = VT_EMPTY;
    m_nStatus = no_error; 
    memset(&m_value, 0, sizeof(METAVALUE));
    *this = Src;
}

//***************************************************************************
//
//  CVar::operator =
//
//  NOTES:
//  Observe that VT_EX_CVARVECTOR is dedicated to embedded CVarVector objects.
//  Also, only pointer types require a new allocation + copy, whereas
//  most of the simple types are directly assignable, in the <default>
//  label of the switch statement.
//
//***************************************************************************

CVar& CVar::operator =(const CVar &Src)
{
    Empty();

    m_vt = Src.m_vt;
    m_nStatus = m_nStatus;
    m_bCanDelete = TRUE;

    switch (m_vt) {
        case VT_LPSTR:

            // Check for an allocation failure
            if ( NULL != Src.m_value.pStr )
            {
            	  size_t stringLength = strlen(Src.m_value.pStr) + 1;
                m_value.pStr = new char[stringLength];

                if ( NULL == m_value.pStr )
                {
                    throw CX_MemoryException();
                }
                StringCchCopyA( m_value.pStr, stringLength, Src.m_value.pStr );
            }
            else
            {
                m_value.pStr = NULL;
            }

            break;

        case VT_LPWSTR:
            // Check for an allocation failure
            if ( NULL != Src.m_value.pWStr )
            {
            	  size_t stringLength = wcslen(Src.m_value.pWStr) + 1;
                m_value.pWStr = new wchar_t[stringLength];

                if ( NULL == m_value.pWStr )
                {
                    throw CX_MemoryException();
                }
                StringCchCopyW( m_value.pWStr, stringLength, Src.m_value.pWStr );
            }
            else
            {
                m_value.pWStr = NULL;
            }
	    break;

        case VT_BSTR:
            // Check for an allocation failure
            if ( NULL != Src.m_value.Str )
            {
            	m_value.Str = SysAllocString(Src.m_value.Str);
                if ( NULL == m_value.Str )
                {
                    throw CX_MemoryException();
                }
            }
            else
            {
                m_value.Str = NULL;
            }
            break;

        case VT_BLOB:
            // This will natively throw an exception, but make sure the
            // original value is cleared in case an exception is thrown
            // so we don't AV destructing this object
            ZeroMemory( &m_value.Blob, sizeof( m_value.Blob ) );
            m_value.Blob = BlobCopy(&Src.m_value.Blob);
            break;

        case VT_CLSID:
            m_value.pClsId = new CLSID(*Src.m_value.pClsId);

            // Check for a failed allocation
            if ( NULL == m_value.pClsId )
            {
                throw CX_MemoryException();
            }

            break;

        case VT_DISPATCH:
            m_value.pDisp = Src.m_value.pDisp;
            if(m_value.pDisp) m_value.pDisp->AddRef();
            break;

        case VT_UNKNOWN:
            m_value.pUnk = Src.m_value.pUnk;
            if(m_value.pUnk) m_value.pUnk->AddRef();
            break;

        // CVarVector
        // ==========

        case VT_EX_CVARVECTOR:
            m_value.pVarVector = new CVarVector(*Src.m_value.pVarVector);

            // Check for a failed allocation
            if ( NULL == m_value.pVarVector )
            {
                throw CX_MemoryException();
            }

            break;

        // All remaining simple types. 
        // ===========================
        default:        
            m_value = Src.m_value;
    }

    return *this;
}

//***************************************************************************
//
//  CVar::operator ==
//
//  Equality test operator.
//
//***************************************************************************

int CVar::operator ==(CVar &Src)
{
    return CompareTo(Src, TRUE);
}

BOOL CVar::CompareTo(CVar& Src, BOOL bIgnoreCase)
{
    // If types are not the same, forget the test.
    // ===========================================

    if (m_vt != Src.m_vt)
        return 0;

    // If here, the types are the same, so test
    // the fields.
    // ========================================

    switch (m_vt) {
        case VT_LPSTR:
            if(bIgnoreCase)
            {
                if (wbem_stricmp(m_value.pStr, Src.m_value.pStr) == 0)
                    return 1;
            }
            else
            {
                if (strcmp(m_value.pStr, Src.m_value.pStr) == 0)
                    return 1;
            }

            break;

        case VT_LPWSTR:
        case VT_BSTR:
            if(bIgnoreCase)
            {
                if (wbem_wcsicmp(m_value.pWStr, Src.m_value.pWStr) == 0)
                    return 1;
            }
            else
            {
                if (wcscmp( m_value.pWStr, Src.m_value.pWStr) == 0)
                    return 1;
            }
            break;

        case VT_BLOB:
            if (BlobLength(&m_value.Blob) != BlobLength(&Src.m_value.Blob))
                return 0;
            if (memcmp(BlobDataPtr(&m_value.Blob), BlobDataPtr(&Src.m_value.Blob),
                BlobLength(&m_value.Blob)) == 0)
                return 1;                            
            break;

        case VT_CLSID:
            if (memcmp(m_value.pClsId, Src.m_value.pClsId, sizeof(CLSID)) == 0)
                return 1;
            break;
    
        // CVarVector
        // ==========

        case VT_EX_CVARVECTOR:
            if (m_value.pVarVector == Src.m_value.pVarVector)
                return 1;
            if (m_value.pVarVector == 0 || Src.m_value.pVarVector == 0)
                return 0;
            return *m_value.pVarVector == *Src.m_value.pVarVector;

        // All remaining simple types. 
        // ===========================

        case VT_I1: 
            return m_value.cVal == Src.m_value.cVal;
        case VT_UI1:
            return m_value.bVal == Src.m_value.bVal;
        case VT_I2:
            return m_value.iVal == Src.m_value.iVal;
        case VT_UI2:
            return m_value.wVal == Src.m_value.wVal;
        case VT_I4:
            return m_value.lVal == Src.m_value.lVal;
        case VT_UI4:
            return m_value.dwVal == Src.m_value.dwVal;
        case VT_BOOL:
            return m_value.boolVal == Src.m_value.boolVal;
        case VT_R8:
            return m_value.dblVal == Src.m_value.dblVal;
        case VT_R4:
            return m_value.fltVal == Src.m_value.fltVal;
        case VT_DISPATCH:
            // Note: no proper comparison of embedded objects.
            return m_value.pDisp == Src.m_value.pDisp;
        case VT_UNKNOWN:
            // Note: no proper comparison of embedded objects.
            return m_value.pUnk == Src.m_value.pUnk;
        case VT_FILETIME:
            if (memcmp(&m_value.Time, &Src.m_value.Time, sizeof(FILETIME)) == 0)
                return 1;
        case VT_NULL:
            return 1;
    }

    return 0;    
}


//***************************************************************************
//
//  CVar::Empty
//
//  Clears the CVar to 'empty', deallocates any objects based on pointers, 
//  unless bCanDelete is set to FALSE, indicating that the stored pointer
//  is owned by somebody else.
//
//***************************************************************************

void CVar::Empty()
{
    if(m_bCanDelete)
    {
        // Only pointer types require a deallocation phase.
        // =================================================

        switch (m_vt) {
            case VT_LPSTR:       delete m_value.pStr; break;
            case VT_LPWSTR:      delete m_value.pWStr; break;
            case VT_BSTR:        SysFreeString(m_value.Str); break;
            case VT_BLOB:        BlobClear(&m_value.Blob); break;
            case VT_CLSID:       delete m_value.pClsId; break;
            case VT_EX_CVARVECTOR: delete m_value.pVarVector; break;
            case VT_DISPATCH:    if(m_value.pDisp) m_value.pDisp->Release(); break;
            case VT_UNKNOWN:    if(m_value.pUnk) m_value.pUnk->Release(); break;
        }
    }

    memset(&m_value, 0, sizeof(METAVALUE)); 
    m_vt = VT_EMPTY;
    m_nStatus = no_error;
    m_bCanDelete = TRUE;
}

//***************************************************************************
//
//  CVar::IsDataNull
//
//  Determines if this CVar contains a NULL pointer.
//
//***************************************************************************
BOOL CVar::IsDataNull()
{
    if(m_vt == VT_LPWSTR && m_value.pWStr == NULL)
        return TRUE;
    if(m_vt == VT_LPSTR && m_value.pStr == NULL)
        return TRUE;
    if(m_vt == VT_BSTR && m_value.Str == NULL)
        return TRUE;
    if(m_vt == VT_DISPATCH && m_value.pDisp == NULL)
        return TRUE;
    if(m_vt == VT_UNKNOWN && m_value.pUnk == NULL)
        return TRUE;

    return FALSE;
}
//***************************************************************************
//
//  CVar::SetRaw
//
//  Creates a CVar from raw data. Sets the type and copies the right
//  number of bytes from the source to METAVALUE.
//
//***************************************************************************

void CVar::SetRaw(int vt, void* pvData, int nDataLen)
{
    m_vt = vt;
    memcpy(&m_value, pvData, nDataLen);
    m_nStatus = no_error;
    m_bCanDelete = TRUE;
}

//***************************************************************************
//
//  CVar::SetSafeArray
//
//  PARAMETERS:
//  nType  
//      This is the VT_ type indicator of the SAFEARRAY.    
//  pArray 
//      This is the pointer to the SAFEARRAY which will be used as
//      a source.  The SAFEARRAY is not acquired; it is copied.
//
//***************************************************************************

void CVar::SetSafeArray(int nType, SAFEARRAY *pArray)
{
    CVarVector *pVec = NULL;
    m_nStatus = no_error;

    try
    {
        pVec = new CVarVector(nType, pArray);

        // Check for a failed allocation
        if ( NULL == pVec )
        {
            throw CX_MemoryException();
        }

        SetVarVector(pVec, TRUE);
    }
    catch (CX_MemoryException)
    {
        // SetVarVector can throw an exception
        // m_value aquires the pVec pointer, so auto delete will not work

        if (NULL != pVec)
        {
            delete pVec;
            pVec = NULL;
        }

        throw;
    }
}


//***************************************************************************
//
//  CVar::GetNewSafeArray
//
//  RETURN VALUE:
//  A pointer to newly allocated SAFEARRAY which must be released by
//  SafeArrayDestroy.
//
//***************************************************************************

SAFEARRAY *CVar::GetNewSafeArray()
{
    CVarVector *p = (CVarVector *) GetVarVector();
    return p->GetNewSafeArray();
}


//***************************************************************************
//
//  CVar::SetValue
//  
//  Sets the value based on an incoming VARIANT.  A VARIANT containing
//  a SAFEARRAY is supported as long as it is not an array of VARIANTs.
//  Some of the other VARIANT types, such as IUnknown, Currency, etc.,
//  are not supported.  The complete list is:
//      VT_UI1, VT_I2, VT_I4, VT_BSTR, VT_BOOL
//      VT_R4, VT_R8, or SAFEARRAY of any of these.
//
//  PARAMETERS:
//  pSrc 
//      A pointer to the source VARIANT.  This is treated as read-only.
//
//  RETURN VALUES:
//  no_error
//      Returned on succcess.
//  unsupported
//      Returned if the VARIANT contains unsupported types.
//
//***************************************************************************

int CVar::SetVariant(VARIANT *pSrc, BOOL fOptimize /*=FALSE*/)
{
    if(pSrc == NULL)
    {
        SetAsNull();
        return no_error;
    }

    // If a SAFEARRAY, check it.
    // =========================

    if (pSrc->vt & VT_ARRAY) 
    {
        CVarVector *pVec = NULL;

        try
        {
            int nType = pSrc->vt & 0xFF;    // Find the type of the array

            // BEGIN MODIFIED by a-levn

            // First, check if the incoming SAFEARRAY is NULL
            // ==============================================

            SAFEARRAY *pSafeArr;
    /*
            if(pSrc->parray == NULL)
            {
                pSafeArr = NULL;
            }
            else
            {
                // Make a copy of the SAFEARRAY using CSafeArray which will NOT 
                // autodestruct
                // ============================================================

                CSafeArray array(pSrc->parray, nType, CSafeArray::no_delete, 0);
                pSafeArr = array.GetArray();
            }

    */
            pSafeArr = pSrc->parray;

			pVec = new CVarVector( nType, pSafeArr, fOptimize );

			// Check for an allocation failure.
			if ( NULL == pVec )
			{
				throw CX_MemoryException();
			}

			// END MODIFIED

			if (pVec->Status() != no_error) 
			{

				// If here, the SAFEARRAY was not compatible.
				// ==========================================

				delete pVec;
				pVec = NULL;
				m_nStatus = unsupported;
				m_vt = VT_EMPTY;
				return unsupported;
			}

			SetVarVector(pVec, TRUE);
			return no_error;
        }
        catch(CX_MemoryException)
        {
            // new and SetVarVector can throw exceptions
            // m_value aquires the pVec pointer, so an auto delete will not work

            if (NULL != pVec)
            {
                delete pVec;
                pVec = NULL;
            }

            throw;
        }
    }

    // Simple copies.
    // ==============

    switch (pSrc->vt) {
        case VT_NULL:
            SetAsNull();
            return no_error;

        case VT_UI1:
            SetByte(pSrc->bVal);
            return no_error;

        case VT_I2:
            SetShort(pSrc->iVal);
            return no_error;
        
        case VT_I4:
            SetLong(pSrc->lVal);
            return no_error;

        case VT_R4:
            SetFloat(pSrc->fltVal);
            return no_error;

        case VT_R8:        
            SetDouble(pSrc->dblVal);
            return no_error;

        case VT_BSTR:
            SetBSTR(pSrc->bstrVal);
            return no_error;

        case VT_BOOL:
            SetBool(pSrc->boolVal);
            return no_error;

        case VT_DISPATCH:
            SetDispatch(V_DISPATCH(pSrc));
            return no_error;

        case VT_UNKNOWN:
            SetUnknown(V_UNKNOWN(pSrc));
            return no_error;
    }

    m_nStatus = unsupported;
    return unsupported;
}

//***************************************************************************
//
//  CVar::GetNewVariant
//  
//  RETURN VALUE:
//  A pointer to a new VARIANT which contains the value of object.
//  If the original value was a SAFEARRAY, then the VARIANT will contain
//  the embedded SAFEARRAY.
//      
//***************************************************************************

void CVar::FillVariant(VARIANT* pNew, BOOL fOptimized/* = FALSE*/)
{
    switch (m_vt) {
        case VT_NULL:
            V_VT(pNew) = VT_NULL;
            break;

        case VT_BOOL:
            V_VT(pNew) = VT_BOOL;
            V_BOOL(pNew) = (m_value.boolVal ? VARIANT_TRUE : VARIANT_FALSE);
            break;
            
        case VT_BSTR:

            // Set type afterwards here so if the SysAlloc throws an exception, the
            // type will not have been reset to a VT_BSTR which could cause a subtle
            // memory corruption (or worse) if VariantClear is called - SJS

            V_BSTR(pNew) = COleAuto::_SysAllocString(m_value.Str);
            V_VT(pNew) = VT_BSTR;
            break;

        case VT_DISPATCH:
            V_VT(pNew) = VT_DISPATCH;
            V_DISPATCH(pNew) = m_value.pDisp;
            if(m_value.pDisp) m_value.pDisp->AddRef();
            break;

        case VT_UNKNOWN:
            V_VT(pNew) = VT_UNKNOWN;
            V_UNKNOWN(pNew) = m_value.pUnk;
            if(m_value.pUnk) m_value.pUnk->AddRef();
            break;

        case VT_UI1:
            V_VT(pNew) = VT_UI1;
            V_UI1(pNew) = m_value.bVal;
            break;

        case VT_I4:
            V_VT(pNew) = VT_I4;
            V_I4(pNew) = m_value.lVal;
            break;

        case VT_I2:
            V_VT(pNew) = VT_I2;
            V_I2(pNew) = m_value.iVal;
            break;

        case VT_R4:
            V_VT(pNew) = VT_R4;
            V_R4(pNew) = m_value.fltVal;
            break;

        case VT_R8:        
            V_VT(pNew) = VT_R8;
            V_R8(pNew) = m_value.dblVal;
            break;

        // An embedded CVarVector which must be converted
        // to a SAFEARRAY.
        // ==============================================

        case VT_EX_CVARVECTOR:
            {
                // Set type afterwards here so if GetNewSafeArray throws an exception, the
                // type will not have been reset to an Array which could cause a subtle
                // memory corruption (or worse) if VariantClear is called - SJS

				if ( fOptimized && m_value.pVarVector->IsOptimized() )
				{
					// This will get the actual SAFEARRAY pointer without
					// copying what's underneath.  Underlying code should
					// not clear the array, since it is being acquired
					V_ARRAY(pNew) = m_value.pVarVector->GetSafeArray( TRUE );
					V_VT(pNew) = m_value.pVarVector->GetType() | VT_ARRAY;
				}
				else
				{
					V_ARRAY(pNew) = m_value.pVarVector->GetNewSafeArray();
					V_VT(pNew) = m_value.pVarVector->GetType() | VT_ARRAY;
				}
            }
            break;

        default:
            COleAuto::_VariantClear(pNew);        
    }
}

VARIANT *CVar::GetNewVariant()
{
    VARIANT *pNew = new VARIANT;

    // Check for an allocation failure.
    if ( NULL == pNew )
    {
        throw CX_MemoryException();
    }

    COleAuto::_VariantInit(pNew);
    
    FillVariant(pNew);       
    return pNew;    
}
    
//***************************************************************************
//
//***************************************************************************

int CVar::DumpText(FILE *fStream)
{
    return unsupported;
}

//***************************************************************************
//
//  CVar::SetLPWSTR
//
//  Sets the value of the CVar to the indicated LPWSTR.
//
//  PARAMETERS:
//  pStr
//      A pointer to the source string.
//  bAcquire
//      If TRUE, then the ownership of pStr is trasferred and becomes
//      the internal pointer to the string. If FALSE, then the string
//      is copied.
//      
//***************************************************************************

BOOL CVar::SetLPWSTR(LPWSTR pStr, BOOL bAcquire)
{
    m_vt = VT_LPWSTR;
    if (bAcquire)
    {
        m_value.pWStr = pStr;
        return TRUE;
    }
    else            
    {
        // Check for an allocation failure
        if ( NULL != pStr )
        {
        	size_t stringLength = wcslen(pStr) + 1;
            m_value.pWStr = new wchar_t[stringLength];

            if ( NULL == m_value.pWStr )
            {
                throw CX_MemoryException();
            }
            StringCchCopyW( m_value.pWStr, stringLength, pStr );
        }
        else
        {
            m_value.pWStr = NULL;
        }

        return TRUE;
    }
}

//***************************************************************************
//
//  CVar::SetLPSTR
//
//  Sets the value of the CVar to the indicated LPSTR.
//
//  PARAMETERS:
//  pStr
//      A pointer to the source string.
//  bAcquire
//      If TRUE, then the ownership of pStr is trasferred and becomes
//      the internal pointer to the string. If FALSE, then the string
//      is copied (it must have been allocated with operator new).
//    
//***************************************************************************
    
BOOL CVar::SetLPSTR(LPSTR pStr, BOOL bAcquire)
{
    m_vt = VT_LPSTR;
    if (bAcquire)
    {
        m_value.pStr = pStr;
        return TRUE;
    }
    else        
    {
        if ( NULL != pStr)
        {
        	size_t stringLength = strlen(pStr) + 1;
            m_value.pStr = new char[stringLength];

            // On failure, throw an exception
            if ( NULL == m_value.pStr )
            {
                throw CX_MemoryException();
            }

            StringCchCopyA( m_value.pStr, stringLength, pStr );
        }
        else
        {
            m_value.pStr = NULL;
        }
        
        return TRUE;

    }
}

//***************************************************************************
//
//  CVar::SetBSTR
//
//  Sets the value of the CVar to the indicated BSTR.
//
//  NOTE: This BSTR value is actually stored as an LPWSTR to avoid 
//  apartment-threading restrictions on real BSTR objects allocated 
//  with COleAuto::_SysAllocString.
//
//  PARAMETERS:
//  str
//      A pointer to the string, which is copied into an internal LPWSTR.
//  bAcquire
//      If FALSE, then the BSTR is treated as read-only and copied.
//      If TRUE, then this function becomes owner of the BSTR and
//      frees it after the copy is made.
//
//***************************************************************************

BOOL CVar::SetBSTR(BSTR str)
{
    m_vt = VT_BSTR;
    if (0 == str) 
    {
	m_value.Str = 0;
	return TRUE;
    }

    m_value.Str = SysAllocString(str);

    if ( NULL == m_value.Str )
    {
          throw CX_MemoryException();
    }

    // return whether or not we obtained a value
    return (TRUE );
}

//***************************************************************************
//
//  CVar::SetBSTR
//
//  Sets the value of the CVar to the indicated BSTR.
//
//  NOTE: This BSTR value is actually stored as an LPWSTR to avoid 
//  apartment-threading restrictions on real BSTR objects allocated 
//  with COleAuto::_SysAllocString.
//
//  PARAMETERS:
//  str
//      A pointer to the string, which is copied into an internal LPWSTR.
//  bAcquire
//      If FALSE, then the BSTR is treated as read-only and copied.
//      If TRUE, then this function becomes owner of the BSTR and
//      frees it after the copy is made.
//
//***************************************************************************

BOOL CVar::SetBSTR(auto_bstr str)
{
    m_vt = VT_BSTR;
  
    m_value.Str = str.release();
    return TRUE;
}


//***************************************************************************
//
//  CVar::GetBSTR
//
//  Returns the BSTR value of the current object.  
//
//  RETURN VALUE:
//  A newly allocated BSTR which must be freed with COleAuto::_SysFreeString().
//
//***************************************************************************

BSTR CVar::GetBSTR()
{
    if (m_vt != VT_BSTR)
        return NULL;
    return COleAuto::_SysAllocString(m_value.pWStr);
}
    
void CVar::SetDispatch(IDispatch* pDisp) 
{
    m_vt = VT_DISPATCH; 
    m_value.pDisp = pDisp; 

    if(pDisp) 
    {
        pDisp->AddRef();
    }
}

void CVar::SetUnknown(IUnknown* pUnk) 
{
    m_vt = VT_UNKNOWN; 
    m_value.pUnk = pUnk; 

    if(pUnk) 
    {
        pUnk->AddRef();
    }
}

//***************************************************************************
//
//  CVar::SetBlob
//
//  Sets the object to the value of the BLOB object.
//
//  PARAMETERS:
//  pBlob
//      A pointer to a valid VT_BLOB object.
//  bAcquire
//      If TRUE, then the pointer to the data will be acquired. It must
//      have been allocated with operator new in the current process, 
//      since operator delete will be used to free it.
//      
//***************************************************************************
    
void CVar::SetBlob(BLOB *pBlob, BOOL bAcquire)
{
    m_vt = VT_BLOB;
    if (pBlob == 0) 
        BlobClear(&m_value.Blob);
    else if (!bAcquire)
        m_value.Blob = BlobCopy(pBlob);        
    else
        m_value.Blob = *pBlob;        
}

//***************************************************************************
//
//  CVar::SetClsId
//
//  Sets the value of the object to a CLSID.
//  
//  PARAMETERS:
//  pClsId
//      Points the source CLSID.
//  bAcquire
//      If TRUE, the ownership of the pointer is transferred to the
//      object.  The CLSID must have been allocated with operator new.
//      If FALSE, the caller retains ownership and a copy is made.
//
//***************************************************************************
        
void CVar::SetClsId(CLSID *pClsId, BOOL bAcquire)
{
    m_vt = VT_CLSID;
    if (pClsId == 0)
        m_value.pClsId = 0;
    else
    {
        m_value.pClsId = new CLSID(*pClsId);

        // Check for an allocation failure.
        if ( NULL == m_value.pClsId )
        {
            throw CX_MemoryException();
        }

    }
}

//***************************************************************************
//
//  CVar::SetVarVector
//
//  Sets the value of the object to the specified CVarVector.  This
//  allows the CVar to contain a complete array.
//  
//  PARAMETERS:
//  pVec
//      A pointer to the CVarVector object which is the source.
//  bAcquire
//      If TRUE, then ownership of the CVarVector is transferred to
//      the object.  If FALSE, a new copy of the CVarVector is made and
//      the caller retains ownership.
//
//***************************************************************************
    
void CVar::SetVarVector(CVarVector *pVec, BOOL bAcquire)
{
    m_vt = VT_EX_CVARVECTOR;

    if (bAcquire) {
        // If here, we acquire the caller's pointer.
        // =========================================
        m_value.pVarVector = pVec;
        return;
    }

    // If here, make a copy.
    // =====================

    m_value.pVarVector = new CVarVector(*pVec);

    // Check for an allocation failure.
    if ( NULL == m_value.pVarVector )
    {
        throw CX_MemoryException();
    }


}

int CVar::GetOleType() 
{ 
    if(m_vt == VT_EX_CVARVECTOR)
    {
        if(m_value.pVarVector == NULL) return VT_ARRAY;
        else return VT_ARRAY | m_value.pVarVector->GetType();
    }
    else
    {
        return m_vt;
    }
}        


//***************************************************************************
//
//  CVar::GetText
//
//  Produces textual representation of the Var's type and data
//
//  PARAMETERS:
//  long lFlags      reseved, must be 0
//  long lType       CIM_TYPE
//  LPCWSTR szFormat optional formatting string
//  
//
//***************************************************************************

BSTR CVar::GetText(long lFlags, long lType, LPCWSTR szFormat)
{
    if(m_vt == VT_EX_CVARVECTOR)
    {
        // When we get the text for the array, make sure the CIM_FLAG_ARRAY is masked out
        BSTR strTemp = GetVarVector()->GetText(lFlags, lType & ~CIM_FLAG_ARRAY);
        CSysFreeMe auto1(strTemp);

	size_t bufferSize = COleAuto::_SysStringLen(strTemp) + 3;
        WCHAR* wszValue = new WCHAR[bufferSize];

        // Check for allocation failures
        if ( NULL == wszValue )
        {
            throw CX_MemoryException();
        }

        CVectorDeleteMe<WCHAR> auto2(wszValue);

        StringCchCopyW(wszValue, bufferSize, L"{");
        StringCchCatW(wszValue, bufferSize, strTemp);
        StringCchCatW(wszValue, bufferSize, L"}");

        BSTR strRet = COleAuto::_SysAllocString(wszValue);

        return strRet;
    }

    WCHAR* wszValue = new WCHAR[100];

    // Check for allocation failures
    if ( NULL == wszValue )
    {
        throw CX_MemoryException();
    }


    WCHAR* pwc;
    int i;

    if(m_vt == VT_NULL)
    {
        delete [] wszValue;
        return NULL;
    }

    if(lType == 0)
        lType = m_vt;

    try
    {
        switch(lType)
        {
        case CIM_SINT8:
            StringCchPrintfW(wszValue, 100, szFormat ? szFormat : L"%d", (long)(signed char)GetByte());
            break;

        case CIM_UINT8:
            StringCchPrintfW(wszValue, 100, szFormat ? szFormat : L"%d", GetByte());
            break;

        case CIM_SINT16:
            StringCchPrintfW(wszValue, 100, szFormat ? szFormat : L"%d", (long)GetShort());
            break;

        case CIM_UINT16:
            StringCchPrintfW(wszValue, 100, szFormat ? szFormat : L"%d", (long)(USHORT)GetShort());
            break;

        case CIM_SINT32:
            StringCchPrintfW(wszValue, 100, szFormat ? szFormat : L"%d", GetLong());
            break;

        case CIM_UINT32:
            StringCchPrintfW(wszValue, 100, szFormat ? szFormat : L"%lu", (ULONG)GetLong());
            break;

        case CIM_BOOLEAN:
            StringCchPrintfW(wszValue, 100, L"%s", (GetBool()?L"TRUE":L"FALSE"));
            break;

        case CIM_REAL32:
            {
                // Since the decimal point can be localized, and MOF text should
                // always be english, we will return values localized to 0x409,

                CVar    var( GetFloat() );

                // If this fails, we can't guarantee a good value,
                // so throw an exception.

                if ( !var.ChangeTypeToEx( VT_BSTR ) )
                {
                    throw CX_Exception();
                }

                StringCchCopyW( wszValue, 100, var.GetLPWSTR() );
            }
            break;

        case CIM_REAL64:
            {
                // Since the decimal point can be localized, and MOF text should
                // always be english, we will return values localized to 0x409,

                CVar    var( GetDouble() );

                // If this fails, we can't guarantee a good value,
                // so throw an exception.

                if ( !var.ChangeTypeToEx( VT_BSTR ) )
                {
                    throw CX_Exception();
                }

                StringCchCopyW( wszValue, 100, var.GetLPWSTR() );
            }
            break;

        case CIM_CHAR16:
            if(GetShort() == 0)
                StringCchCopyW(wszValue, 100, L"0x0");
            else
                StringCchPrintfW(wszValue, 100, L"'\\x%X'", (WCHAR)GetShort());
            break;

        case CIM_OBJECT:
            StringCchPrintfW(wszValue, 100, L"\"not supported\"");
            break;

        case CIM_REFERENCE:
        case CIM_DATETIME:
        case CIM_STRING:
        case CIM_SINT64:
        case CIM_UINT64:
        {
            // Escape all the quotes
            // =====================

            int nStrLen = wcslen(GetLPWSTR());
            delete [] wszValue;
            wszValue = NULL;

            wszValue = new WCHAR[nStrLen*2+10];

            // Check for allocation failures
            if ( NULL == wszValue )
            {
                throw CX_MemoryException();
            }

            wszValue[0] = L'"';
            pwc = wszValue+1;
            for(i = 0; i < (int)nStrLen; i++)
            {    
                WCHAR wch = GetLPWSTR()[i];
                if(wch == L'\n')
                {
                    *(pwc++) = L'\\';
                    *(pwc++) = L'n';
                }
                else if(wch == L'\t')
                {
                    *(pwc++) = L'\\';
                    *(pwc++) = L't';
                }
                else if(wch == L'"' || wch == L'\\')
                {
                    *(pwc++) = L'\\';
                    *(pwc++) = wch;
                }
                else
                {
                    *(pwc++) = wch;
                }
            }
            *(pwc++) = L'"';
            *pwc = 0;
        }
            break;
        default:
            StringCchPrintfW(wszValue, 100, L"\"not supported\"");
            break;
        }
        
        BSTR strRes = COleAuto::_SysAllocString(wszValue);

        // Still need to clean up this value
        delete [] wszValue;

        return strRes;
    }
    catch (...)
    {
        // Cleanup always if this has a value
        if ( NULL != wszValue )
        {
            delete [] wszValue;
        }

        // Rethrow the exception
        throw;
    }

}


BSTR CVar::TypeToText(int nType)
{
    const WCHAR* pwcType;

    switch(nType)
    {
    case VT_I1:
        pwcType = L"sint8";
        break;

    case VT_UI1:
        pwcType = L"uint8";
        break;

    case VT_I2:
        pwcType = L"sint16";
        break;

    case VT_UI2:
        pwcType = L"uint16";
        break;

    case VT_I4:
        pwcType = L"sint32";
        break;

    case VT_UI4:
        pwcType = L"uint32";
        break;

    case VT_I8:
        pwcType = L"sint64";
        break;

    case VT_UI8:
        pwcType = L"uint64";
        break;

    case VT_BOOL:
        pwcType = L"boolean";
        break;

    case VT_R4:
        pwcType = L"real32";
        break;

    case VT_R8:
        pwcType = L"real64";
        break;    

    case VT_BSTR:
        pwcType = L"string";
        break;

    case VT_DISPATCH:
        pwcType = L"object";
        break;

    case VT_UNKNOWN:
        pwcType = L"object";
        break;

    default:
        return NULL;
    }

    return COleAuto::_SysAllocString(pwcType);
}

BSTR CVar::GetTypeText() 
{
	if ( m_vt == VT_EX_CVARVECTOR )
	{
        return TypeToText(GetVarVector()->GetType());
	}
	else
	{
        return TypeToText(m_vt);
	}
}

BOOL CVar::ChangeTypeTo(VARTYPE vtNew)
{
    // TBD: there are more efficient ways!
    // ===================================

    // Create a VARIANT
    // ================

    VARIANT v;
    CClearMe auto1(&v);

    COleAuto::_VariantInit(&v);
    FillVariant(&v);

    // Coerce it
    // =========

    HRESULT hres = COleAuto::_WbemVariantChangeType(&v, &v, vtNew);
    if(FAILED(hres))
        return FALSE;

    // Load it back in
    // ===============

    Empty();
    SetVariant(&v, TRUE);

	// If this is an array, we will now be sitting on an optimized array
	// meaning that we will have acquired the actual safe array - so we should
	// make sure that the CVarVector cleans up the array when it is no longer
	// necessary.  We will  clear out the variant so it doesn't get deleted
	// when VariantClear is called.

	if ( m_vt == VT_EX_CVARVECTOR )
	{
		m_value.pVarVector->SetRawArrayBinding( CSafeArray::auto_delete );
		ZeroMemory( &v, sizeof(v) );
	}

    return TRUE;
}

// Performs localized changes (defaults to 0x409 for this)
BOOL CVar::ChangeTypeToEx(VARTYPE vtNew, LCID lcid /*=0x409*/)
{
    // TBD: there are more efficient ways!
    // ===================================

    // Create a VARIANT
    // ================

    VARIANT v;
    CClearMe auto1(&v);

    COleAuto::_VariantInit(&v);
    FillVariant(&v);

    // Coerce it
    // =========

    try
    {
        HRESULT hres = COleAuto::_VariantChangeTypeEx(&v, &v, lcid, 0L, vtNew);
        if(FAILED(hres))
            return FALSE;
    }
    catch(...)
    {
        return FALSE;
    }

    // Load it back in
    // ===============

    Empty();
    SetVariant(&v, TRUE);

	// If this is an array, we will now be sitting on an optimized array
	// meaning that we will have acquired the actual safe array - so we should
	// make sure that the CVarVector cleans up the array when it is no longer
	// necessary.  We will  clear out the variant so it doesn't get deleted
	// when VariantClear is called.

	if ( m_vt == VT_EX_CVARVECTOR )
	{
		m_value.pVarVector->SetRawArrayBinding( CSafeArray::auto_delete );
		ZeroMemory( &v, sizeof(v) );
	}

    return TRUE;
}

BOOL CVar::ToSingleChar()
{
    // Defer to CVarVector for arrays
    // ==============================

    if(m_vt == VT_EX_CVARVECTOR)
    {
        return GetVarVector()->ToSingleChar();
    }

    // Anything that's not a string follows normal OLE rules
    // =====================================================

    if(m_vt != VT_BSTR)
    {
        return ChangeTypeTo(VT_I2);
    }
    
    // It's a string. Make sure the length is 1
    // ========================================

    LPCWSTR wsz = GetLPWSTR();
    if(wcslen(wsz) != 1)
        return FALSE;

    // Take the first character
    // ========================
    
    WCHAR wc = wsz[0];
    Empty();

    SetShort(wc);
    return TRUE;
}

BOOL CVar::ToUI4()
{
    // Defer to CVarVector for arrays
    // ==============================

    if(m_vt == VT_EX_CVARVECTOR)
    {
        return GetVarVector()->ToUI4();
    }

    // Create a VARIANT
    // ================

    VARIANT v;
    CClearMe auto1(&v);

    COleAuto::_VariantInit(&v);
    FillVariant(&v);

    // Coerce it
    // =========

    HRESULT hres = COleAuto::_WbemVariantChangeType(&v, &v, VT_UI4);
    if(FAILED(hres))
        return FALSE;

    // Load it back in
    // ===============

    Empty();

    // Here we cheat and reset to VT_I4 so we can natively reset
    V_VT(&v) = VT_I4;
    SetVariant(&v);
    return TRUE;
}

//***************************************************************************
//
//  CVarVector::CVarVector
//
//  Default constructor.  The caller should not attempt to add any
//  elements when the internal type is VT_EMPTY.  Objects constructed
//  with this constructor should only be used as l-values in an 
//  assignment of CVarVector objects.
//
//***************************************************************************

CVarVector::CVarVector()
:	m_pSafeArray( NULL ),
	m_pRawData( NULL )
{
    m_Array.Empty();
    m_nType = VT_EMPTY;
    m_nStatus = no_error;
}

//***************************************************************************
//
//  CVarVector::CVarVector
//
//  This is the standard constructor.
//
//  PARAMETERS:
//  nVarType
//      An OLE VT_ type indicator.  Heterogeneous arrays are possible
//      if the type VT_EX_CVAR is used.  Embedded CVarVectors can
//      occur, since a CVar can in turn hold a CVarVector.
//  
//  nInitSize
//      The starting size of the internal CFlexArray. See FLEXARRY.CPP.
//  nGrowBy
//      The "grow by" factor of the internal CFlexArray. See FLEXARRAY.CPP.
//          
//***************************************************************************

CVarVector::CVarVector(
    int nVarType, 
    int nInitSize, 
    int nGrowBy
    ) :
    m_Array(nInitSize, nGrowBy),
	m_pSafeArray( NULL ),
	m_pRawData( NULL )

{
    m_nType = nVarType;
    m_nStatus = no_error;
}

//***************************************************************************
//
//  CVarVector::CVarVector
//
//  Alternate constructor to build a new CVarVector based on a 
//  SAFEARRAY object.  The only supported types for the SAFEARRAY
//  are VT_BSTR, VT_UI1, VT_I2, VT_I4, VT_R4, and VT_R8.
//
//  PARAMETERS:
//  nVarType
//      The VT_ type indicator of the incoming SAFEARRAY.
//  pSrc
//      A pointer to a SAFEARRAY, which is treated as read-only.
//
//  NOTES:
//  This will set the internal m_nStatus variable to <unsupported> if
//  an unsupported VT_ type is in the SAFEARRAY.  The caller can immediately
//  call CVarVector::Status() after construction to see if the operation
//  was successful.
//
//***************************************************************************

CVarVector::CVarVector(int nVarType, SAFEARRAY *pSrc, BOOL fOptimized /*= FALSE*/)
:	m_pSafeArray( NULL ),
	m_pRawData( NULL )
{
    SAFEARRAY* pNew = NULL;

    try
    {
        m_nType = nVarType;

		// If not a valid vector type, this is unsupported
		if ( !IsValidVectorArray( nVarType, pSrc ) )
		{
			m_nStatus = unsupported;
			return;
		}

        if(pSrc == NULL)
        {
            // NULL safearray --- empty
            // ========================

            m_nStatus = no_error;
            return;
        }

        // Bind to the incoming SAFEARRAY, but don't delete it during destruct.
        // ====================================================================
    
        if(COleAuto::_SafeArrayGetDim(pSrc) != 1)
        {
            m_nStatus = unsupported;
            return;
        }

        long lLBound, lUBound;
        COleAuto::_SafeArrayGetLBound(pSrc, 1, &lLBound);
        COleAuto::_SafeArrayGetUBound(pSrc, 1, &lUBound);

        if(lLBound != 0)
        {
            // Non-0-based safearray --- since CSafeArray doesn't support that, and
            // we can't change pSrc, create a copy
            // ====================================================================
    
            if(FAILED(COleAuto::_SafeArrayCopy(pSrc, &pNew)))
            {
                m_nStatus = failed;
                return;
            }
        
            SAFEARRAYBOUND sfb;
            sfb.cElements = (lUBound - lLBound) + 1;
            sfb.lLbound = 0;
            COleAuto::_SafeArrayRedim(pNew, &sfb);
        }
        else
        {
            pNew = pSrc;
        }
        
		if ( fOptimized )
		{
			// If we rebased the array, then we need to clean it up on delete, otherwise,
			// we don't
			if ( pNew != pSrc )
			{
				m_pSafeArray = new CSafeArray( pNew, nVarType, CSafeArray::auto_delete | CSafeArray::bind);
			}
			else
			{
				m_pSafeArray = new CSafeArray( pNew, nVarType, CSafeArray::no_delete | CSafeArray::bind);
			}

			if ( NULL == m_pSafeArray )
			{
				throw CX_MemoryException();
			}

			if ( m_pSafeArray->Status() != CSafeArray::no_error )
			{
				delete m_pSafeArray;
				m_pSafeArray = NULL;
				m_nStatus = failed;
			}

	        m_nStatus = no_error;

		}
		else
		{
			CSafeArray sa(pNew, nVarType, CSafeArray::no_delete | CSafeArray::bind);
    
			for (int i = 0; i < sa.Size(); i++) {

				CVar*   pVar = NULL;
        
				switch (m_nType) {
					case VT_BOOL:
						{
							VARIANT_BOOL boolVal = sa.GetBoolAt(i);

							pVar = new CVar(boolVal, VT_BOOL);

							// Check for allocation failure
							if ( NULL == pVar )
							{
								throw CX_MemoryException();
							}

							if ( m_Array.Add( pVar ) != CFlexArray::no_error )
							{
								delete pVar;
								throw CX_MemoryException();
							}

							break;
						}

					case VT_UI1: 
						{
							BYTE b = sa.GetByteAt(i);

							pVar = new CVar(b);

							// Check for allocation failure
							if ( NULL == pVar )
							{
								throw CX_MemoryException();
							}

							if ( m_Array.Add( pVar ) != CFlexArray::no_error )
							{
								delete pVar;
								throw CX_MemoryException();
							}
							break;
						}

					case VT_I2:  
						{
							SHORT s = sa.GetShortAt(i);

							pVar = new CVar(s);

							// Check for allocation failure
							if ( NULL == pVar )
							{
								throw CX_MemoryException();
							}

							if ( m_Array.Add( pVar ) != CFlexArray::no_error )
							{
								delete pVar;
								throw CX_MemoryException();
							}
							break;
						}

					case VT_I4:
						{
							LONG l = sa.GetLongAt(i);

							pVar = new CVar(l);

							// Check for allocation failure
							if ( NULL == pVar )
							{
								throw CX_MemoryException();
							}

							if ( m_Array.Add( pVar ) != CFlexArray::no_error )
							{
								delete pVar;
								throw CX_MemoryException();
							}
							break;
						}

					case VT_R4:
						{
							float f = sa.GetFloatAt(i);

							pVar = new CVar(f);

							// Check for allocation failure
							if ( NULL == pVar )
							{
								throw CX_MemoryException();
							}

							if ( m_Array.Add( pVar ) != CFlexArray::no_error )
							{
								delete pVar;
								throw CX_MemoryException();
							}
							break;
						}

					case VT_R8:
						{
							double d = sa.GetDoubleAt(i);

							pVar = new CVar(d);

							// Check for allocation failure
							if ( NULL == pVar )
							{
								throw CX_MemoryException();
							}

							if ( m_Array.Add( pVar ) != CFlexArray::no_error )
							{
								delete pVar;
								throw CX_MemoryException();
							}
							break;
						}

					case VT_BSTR:
						{
							BSTR bstr = sa.GetBSTRAtThrow(i);
							CSysFreeMe auto1(bstr);

							pVar = new CVar(VT_BSTR, bstr);

							// Check for allocation failure
							if ( NULL == pVar )
							{
								throw CX_MemoryException();
							}

							if ( m_Array.Add( pVar ) != CFlexArray::no_error )
							{
								delete pVar;
								throw CX_MemoryException();
							}

							break;
						}
					case VT_DISPATCH:
						{
							IDispatch* pDisp = sa.GetDispatchAt(i);
							CReleaseMe auto2(pDisp);

							pVar = new CVar;

							// Check for allocation failure
							if ( NULL == pVar )
							{
								throw CX_MemoryException();
							}

							pVar->SetDispatch(pDisp);
							if ( m_Array.Add( pVar ) != CFlexArray::no_error )
							{
								delete pVar;
								throw CX_MemoryException();
							}
							break;
						}
					case VT_UNKNOWN:
						{
							IUnknown* pUnk = sa.GetUnknownAt(i);
							CReleaseMe auto3(pUnk);
							pVar = new CVar;

							// Check for allocation failure
							if ( NULL == pVar )
							{
								throw CX_MemoryException();
							}

							pVar->SetUnknown(pUnk);
							if ( m_Array.Add( pVar ) != CFlexArray::no_error )
							{
								delete pVar;
								throw CX_MemoryException();
							}
							break;
						}

					default:
						m_nStatus = unsupported;
						if(pNew != pSrc)
							COleAuto::_SafeArrayDestroy(pNew);
						return;
				}
			}

			if(pNew != pSrc)
				COleAuto::_SafeArrayDestroy(pNew);

	        m_nStatus = no_error;

		}	// Else not bound
    }
    catch (CX_MemoryException)
    {
        // SafeArrayCopy, GetBSTRAtThrow, new can all throw exceptions

        m_nStatus = failed;

        if(pNew != pSrc)
            COleAuto::_SafeArrayDestroy(pNew);

        throw;
    }
}

//***************************************************************************
//
//  CVarVector::GetNewSafeArray
//
//  Allocates a new SAFEARRAY equivalent to the current CVarVector.
//  
//  RETURN VALUE:
//  A new SAFEARRAY pointer which must be deallocated with 
//  SafeArrayDestroy().  Returns NULL on error or unsupported types.
//
//***************************************************************************

SAFEARRAY *CVarVector::GetNewSafeArray()
{
	SAFEARRAY *pRetValue = NULL;

	CSafeArray *pArray = new CSafeArray(m_nType, CSafeArray::no_delete);

	// Check for an allocation failure
	if ( NULL == pArray )
	{
		throw CX_MemoryException();
	}

	CDeleteMe<CSafeArray> auto1(pArray);

	int	nSize = Size();

	for (int i = 0; i < nSize; i++) {
		CVar v;
		
		FillCVarAt( i, v );
		switch (m_nType) {
			case VT_UI1:
				pArray->AddByte(v.GetByte());
				break;

			case VT_I2:
				pArray->AddShort(v.GetShort());
				break;

			case VT_I4:
				pArray->AddLong(v.GetLong());
				break;

			case VT_R4:
				pArray->AddFloat(v.GetFloat());
				break;

			case VT_R8:
				pArray->AddDouble(v.GetDouble());
				break;

			case VT_BOOL:
				pArray->AddBool(v.GetBool());
				break;
            
			case VT_BSTR:
				{
					BSTR s = v.GetBSTR();
					CSysFreeMe auto2(s);
					pArray->AddBSTR(s);
					break;
				}
			case VT_DISPATCH:
				{
					IDispatch* pDisp = v.GetDispatch();
					CReleaseMe auto3(pDisp);
					pArray->AddDispatch(pDisp);
					break;
				}
			case VT_UNKNOWN:
				{
					IUnknown* pUnk = v.GetUnknown();
					CReleaseMe auto4(pUnk);
					pArray->AddUnknown(pUnk);
					break;
				}
			default:
				// For unsupported types, return a NULL.
				// Since we constructed the SAFEARRAY object to
				// not delete the SAFEARRAY and we have encountered
				// a condition where the internal SAFEARRAY of
				// CSafeArray should not be returned, we have
				// to switch our destruct policy.
				// ================================================
				pArray->SetDestructorPolicy(CSafeArray::auto_delete);
				return 0;
		}	// SWITCH

	}// FOR enum elements

	// Final cleanup.  Get the SAFEARRAY pointer, and delete
	// the wrapper.
	// =====================================================

	pArray->Trim();

	pRetValue = pArray->GetArray();

	return pRetValue;

}

//***************************************************************************
//
//  CVarVector::GetSafeArray
//
//  Returns a direct pointer to the underlying SafeArray.  If fAcquire is
//	set, the array is returned, and cleared from underneath
//  
//  RETURN VALUE:
//  A SAFEARRAY pointer which must be deallocated with 
//  SafeArrayDestroy() if fAcquire is set to TRUE
//
//***************************************************************************

SAFEARRAY *CVarVector::GetSafeArray( BOOL fAcquire /* = FALSE */)
{
	SAFEARRAY*	psa = NULL;

	_DBG_ASSERT( NULL != m_pSafeArray );

	if ( NULL != m_pSafeArray )
	{
		if ( fAcquire )
		{
			// Unaccess data if appropriate
			if ( NULL != m_pRawData )
			{
				m_pSafeArray->Unaccess();
				m_pRawData = NULL;
			}

			psa = m_pSafeArray->GetArray();

			// Now clear the array
			m_pSafeArray->SetDestructorPolicy( CSafeArray::no_delete );
			delete m_pSafeArray;
			m_pSafeArray = NULL;

		}
		else
		{
			psa = m_pSafeArray->GetArray();
		}
	}

	return psa;
}

//***************************************************************************
//
//  CVarVector::~CVarVector
//
//  Destructor.
//
//***************************************************************************

CVarVector::~CVarVector()
{
    Empty();
}

//***************************************************************************
//
//  CVarVector::Empty
//
//***************************************************************************

void CVarVector::Empty()
{
	if ( NULL != m_pSafeArray )
	{
		delete m_pSafeArray;
	}

    for (int i = 0; i < m_Array.Size(); i++)  {
        delete (CVar *) m_Array[i];
    }
    m_Array.Empty();
    m_nType = VT_EMPTY;
    m_nStatus = no_error;
	m_pSafeArray = NULL;
	m_pRawData = NULL;
}


//***************************************************************************
//
//  CVarVector::CVarVector
//   
//  Copy constructor.  This is implemented via the assignment operator.
// 
//***************************************************************************

CVarVector::CVarVector(CVarVector &Src)
:	m_pSafeArray( NULL ),
	m_pRawData( NULL )
{
    m_nType = 0;
    m_nStatus = no_error;    
    *this = Src;
}

//***************************************************************************
//
//  CVarVector::operator =
//
//  Assignment operator.
//
//***************************************************************************

CVarVector& CVarVector::operator =(CVarVector &Src)
{
    Empty();

	if ( NULL != Src.m_pSafeArray )
	{
		m_pSafeArray = new CSafeArray( *Src.m_pSafeArray );

		if ( NULL != m_pSafeArray )
		{
			if ( m_pSafeArray->Status() != CSafeArray::no_error )
			{
				delete m_pSafeArray;
				throw CX_MemoryException();
			}
		}
		else
		{
			throw CX_MemoryException();
		}
	}
	else
	{
		for (int i = 0; i < Src.m_Array.Size(); i++) 
		{
			CVar* pVar = new CVar(*(CVar *) Src.m_Array[i]);

			// Check for an allocation failure
			if ( NULL == pVar )
			{
				throw CX_MemoryException();
			}

			if ( m_Array.Add( pVar ) != CFlexArray::no_error )
			{
				delete pVar;
				throw CX_MemoryException();
			}
		}

	}

    m_nStatus = Src.m_nStatus;
    m_nType = Src.m_nType;

    return *this;
}

//***************************************************************************
//
//  CVarVector::operator ==
//
//  Equality test operator.
//
//***************************************************************************

int CVarVector::operator ==(CVarVector &Src)
{
    return CompareTo(Src, TRUE);
}

BOOL CVarVector::CompareTo(CVarVector& Src, BOOL bIgnoreCase)
{
    if (m_nType != Src.m_nType)
        return 0;

	// Need to do things indirectly here, since we are possibly mixing
	// CVarVectors not on SAFEARRAYs and those on SAFEARRAYs
	int Src_Size = Src.Size();
    if ( Size() != Src_Size )
        return 0;

	// Allocate the variants
    for (int i = 0; i < Src_Size; i++) 
	{
		CVar	varThis;
		CVar	varThat;

		FillCVarAt( i, varThis );
		Src.FillCVarAt( i, varThat );

        if ( !varThis.CompareTo( varThat, bIgnoreCase ) )
            return 0;
    }

    return 1;
}

//***************************************************************************
//
//  CVarVector::Add
//
//  Adds a new CVar to the array.  A reference is used so that anonymous
//  objects can be constructed in the Add() call:
//
//      pVec->Add(CVar(33));
//
//  PARAMETERS:
//  Value
//      A reference to a CVar object of the correct type for the array.
//      No type checking is done. 
//
//  RETURN VALUE:
//  no_error
//  failed
//
//***************************************************************************

int CVarVector::Add(CVar &Value)
{

	if ( NULL != m_pSafeArray )
	{
		switch ( Value.GetType() )
		{
			case VT_BOOL:
				// We can store differently from what is expected in Variants, hence we
				// need to make sure to convert
				m_pSafeArray->AddBool( Value.GetBool() ? VARIANT_TRUE : VARIANT_FALSE );
				break;

			case VT_UI1:
				m_pSafeArray->AddByte( Value.GetByte() );
				break;

			case VT_I2:
				m_pSafeArray->AddShort( Value.GetShort() );
				break;

			case VT_I4:
				m_pSafeArray->AddLong( Value.GetLong() );
				break;

			case VT_R4:
				m_pSafeArray->AddFloat( Value.GetFloat() );
				break;

			case VT_R8:
				m_pSafeArray->AddDouble( Value.GetDouble() );
				break;

			case VT_BSTR:
				m_pSafeArray->AddBSTR( Value.GetBSTR() );
				break;

			case VT_UNKNOWN:
				m_pSafeArray->AddUnknown( Value.GetUnknown() );
				break;

			default:
				return failed;
		}

		return no_error;
	}
	else
	{
		CVar *p = new CVar(Value);

		// Check for allocation failures
		if ( NULL == p )
		{
			return failed;
		}

		if (m_Array.Add(p) != CFlexArray::no_error)
		{
			delete p;
			return failed;
		}

		return no_error;
	}
}

//***************************************************************************
//
//  CVarVector::Add
//
//  Adds a new CVar to the array.  This overload simply takes ownership
//  of the incoming pointer and adds it directly.
//
//  PARAMETERS:
//  pAcquiredPtr
//      A pointer to a CVar object which is acquired by the vector.
//
//  RETURN VALUE:
//  no_error
//  failed
//
//***************************************************************************

int CVarVector::Add(CVar *pAcquiredPtr)
{
	// Not a valid operation if we are sitting on a SAFEARRAY
	_DBG_ASSERT( NULL == m_pSafeArray );

	// We don't support this if we are optimized to
	// us a safe array directly
	if ( NULL != m_pSafeArray )
	{
		return failed;
	}

    if (m_Array.Add(pAcquiredPtr) != CFlexArray::no_error)
    {
        return failed;
    }

    return no_error;
}

//***************************************************************************
//
//  CVarVector::RemoveAt
//
//  Removes the array element at the specified index.
//
//  PARAMETERS:
//  nIndex
//      The location at which to remove the element.
//
//  RETURN VALUE:
//  no_error
//      On success.
//  failed
//      On range errors, etc.
//
//***************************************************************************

int CVarVector::RemoveAt(int nIndex)
{
	if ( NULL != m_pSafeArray )
	{
		if ( m_pSafeArray->RemoveAt( nIndex ) != CSafeArray::no_error )
		{
			return failed;
		}

	}
	else
	{
		CVar *p = (CVar *) m_Array[nIndex];
		delete p;
		if (m_Array.RemoveAt(nIndex) != CFlexArray::no_error)
			return failed;
	}

    return no_error;
}

//***************************************************************************
//
//  CVarVector::InsertAt
//
//  Inserts the new element at the specified location.
//  
//  PARAMETERS:
//  nIndex
//      The location at which to add the new element.
//  Value
//      A reference to the new value.
//
//  RETURN VALUE:
//  no_error
//      On success.
//  failed
//      An invalid nIndex value was specified.      
//
//***************************************************************************

int CVarVector::InsertAt(int nIndex, CVar &Value)
{
	// We don't support this if we are optimized to
	// us a safe array directly

	_DBG_ASSERT( NULL == m_pSafeArray );

	if ( NULL != m_pSafeArray )
	{
		return failed;
	}

    CVar *pNew = new CVar(Value);

    // Check for allocation failures
    if ( NULL == pNew )
    {
        return failed;
    }

    if (m_Array.InsertAt(nIndex, pNew) != CFlexArray::no_error)
    {
        delete pNew;
        return failed;
    }
    return no_error;
}


BSTR CVarVector::GetText(long lFlags, long lType/* = 0 */)
{
    // Construct an array of values
    // ============================

    BSTR* aTexts = NULL;
    int i;

    try
    {
        aTexts = new BSTR[Size()];

        // Check for allocation failures
        if ( NULL == aTexts )
        {
            throw CX_MemoryException();
        }

        memset(aTexts, 0, Size() * sizeof(BSTR));

        int nTotal = 0;

        for(i = 0; i < Size(); i++)
        {
			CVar	v;

			FillCVarAt( i, v );
            aTexts[i] = v.GetText(lFlags, lType);
            nTotal += COleAuto::_SysStringLen(aTexts[i]) + 2; // 2: for ", "
        }

        // Allocate a BSTR to contain them all
        // ===================================

        BSTR strRes = COleAuto::_SysAllocStringLen(NULL, nTotal);
        CSysFreeMe auto2(strRes);
        *strRes = 0;

        for(i = 0; i < Size(); i++)
        {
            if(i != 0)
            {
                StringCchCatW(strRes, nTotal+1, L", ");
            }

            StringCchCatW(strRes, nTotal+1, aTexts[i]);
            COleAuto::_SysFreeString(aTexts[i]);
        }

        delete [] aTexts;
        aTexts = NULL;
        BSTR strPerfectRes = COleAuto::_SysAllocString(strRes);
        return strPerfectRes;
    }
    catch(CX_MemoryException)
    {
        // new, GetText, COleAuto::_SysAllocStringLen and COleAuto::_SysAllocString can all throw exceptions
        if (NULL != aTexts)
        {
            for(int x = 0; x < Size(); x++)
            {
                if (NULL != aTexts[x])
                    COleAuto::_SysFreeString(aTexts[x]);
            }
            delete [] aTexts;
            aTexts = NULL;
        }

        throw;
    }
}

BOOL CVarVector::ToSingleChar()
{
	// Handle this differently if we are sitting directly on a safearray
	if ( NULL != m_pSafeArray )
	{
		int	nSize = Size();

		// One element at a time is converted and copied into the new array
		CSafeArray*	pNewArray = new CSafeArray( VT_I2, CSafeArray::auto_delete, nSize );

		for ( int i = 0; i < nSize; i++ )
		{
			CVar	v;
			FillCVarAt( i, v );

			if ( !v.ToSingleChar() )
			{
				delete pNewArray;
				return FALSE;
			}

			if ( pNewArray->AddShort( v.GetShort() ) != CSafeArray::no_error )
			{
				delete pNewArray;
				return FALSE;
			}
		}

		// Now replace the old pointer
		delete m_pSafeArray;
		m_pSafeArray = pNewArray;
	}
	else
	{
		// One element at a time, convert in place
		for(int i = 0; i < Size(); i++)
		{
			if(!GetAt(i).ToSingleChar())
				return FALSE;
		}
	}

    // Since all of the conversions succeeded, we will
    // assume the vector type is now VT_I2.

    m_nType = VT_I2;
    return TRUE;
}

BOOL CVarVector::ToUI4()
{

	// Handle this differently if we are sitting directly on a safearray
	if ( NULL != m_pSafeArray )
	{
		int	nSize = Size();

		// One element at a time is converted and copied into the new array
		CSafeArray*	pNewArray = new CSafeArray( VT_I4, CSafeArray::auto_delete, nSize );

		for ( int i = 0; i < nSize; i++ )
		{
			CVar	v;
			FillCVarAt( i, v );

			if ( !v.ToUI4() )
			{
				delete pNewArray;
				return FALSE;
			}

			if ( pNewArray->AddLong( v.GetLong() ) != CSafeArray::no_error )
			{
				delete pNewArray;
				return FALSE;
			}
		}

		// Now replace the old pointer
		delete m_pSafeArray;
		m_pSafeArray = pNewArray;
	}
	else
	{
		// One element at a time, convert in place
		for(int i = 0; i < Size(); i++)
		{
			if(!GetAt(i).ToUI4())
				return FALSE;
		}
	}

    // Since all of the conversions succeeded, we will
    // assume the vector type is now VT_I4.

    m_nType = VT_I4;
    return TRUE;
}

BOOL CVarVector::IsValidVectorType( int nVarType )
{
	if (	VT_BOOL			==	nVarType	||
			VT_UI1			==	nVarType	||
			VT_I2			==	nVarType	||
			VT_I4			==	nVarType	||
			VT_R4			==	nVarType	||
			VT_R8			==	nVarType	||
			VT_BSTR			==	nVarType	||
			VT_DISPATCH		==	nVarType	||
			VT_UNKNOWN		==	nVarType	)
	{
		return TRUE;
	}
	else
	{
		return FALSE;
	}
}

BOOL CVarVector::IsValidVectorArray( int nVarType, SAFEARRAY* pArray )
{
	BOOL	fReturn = IsValidVectorType( nVarType );

	if ( !fReturn )
	{

		// We do supprt VT_VARIANT if the array is zero length
		if ( VT_VARIANT == nVarType )
		{
			if ( NULL != pArray )
			{
				// If lUBound is 1 less than lLBound, it's a zero length array
				long	lLBound = 0,
						lUBound = 0;
				COleAuto::_SafeArrayGetLBound(pArray, 1, &lLBound);
				COleAuto::_SafeArrayGetUBound(pArray, 1, &lUBound);

				fReturn = ( lUBound == ( lLBound - 1 ) );
			}

		}	// IF VT_VARIANT
		
	}	// IF Invalid Type

	return fReturn;
}

int CVarVector::Size()
{
	if ( NULL == m_pSafeArray )
	{
		return m_Array.Size();
	}
	else
	{
		return m_pSafeArray->Size();
	}
}

HRESULT CVarVector::AccessRawArray( void** ppv )
{
	if ( NULL == m_pSafeArray )
	{
		return E_FAIL;
	}

	return m_pSafeArray->Access( ppv );
}

HRESULT CVarVector::UnaccessRawArray( void )
{
	if ( NULL == m_pSafeArray )
	{
		return E_FAIL;
	}

	if ( NULL != m_pRawData )
	{
		m_pRawData = NULL;
	}

	return m_pSafeArray->Unaccess();
}

HRESULT CVarVector::InternalRawArrayAccess( void )
{
	if ( NULL == m_pSafeArray )
	{
		return E_FAIL;
	}

	if ( NULL != m_pRawData )
	{
		return WBEM_E_INVALID_OPERATION;
	}

	return m_pSafeArray->Access( &m_pRawData );
}


CVar&   CVarVector::GetAt(int nIndex)
{
	// Not a valid operation if we are sitting on a SAFEARRAY
	_DBG_ASSERT( NULL == m_pSafeArray );

	if ( NULL == m_pSafeArray )
	{
		return *(CVar *) m_Array[nIndex];
	}
	else
	{
		throw CX_VarVectorException();
	}
}

CVar&   CVarVector::operator [](int nIndex)
{
	// Not a valid operation if we are sitting on a SAFEARRAY
	_DBG_ASSERT( NULL == m_pSafeArray );

	if ( NULL == m_pSafeArray )
	{
		return *(CVar *) m_Array[nIndex];
	}
	else
	{
		throw CX_VarVectorException();
	}
}

void   CVarVector::FillCVarAt(int nIndex, CVar& vTemp)
{

	if ( NULL == m_pSafeArray )
	{
		vTemp = *(CVar *) m_Array[nIndex];
	}
	else if ( NULL == m_pRawData )
	{
		switch( m_nType )
		{
			case VT_BOOL:
				vTemp.SetBool( m_pSafeArray->GetBoolAt( nIndex ) );
				break;

			case VT_UI1:
				vTemp.SetByte( m_pSafeArray->GetByteAt( nIndex ) );
				break;

			case VT_I2:
				vTemp.SetShort( m_pSafeArray->GetShortAt( nIndex ) );
				break;

			case VT_I4:
				vTemp.SetLong( m_pSafeArray->GetLongAt( nIndex ) );
				break;

			case VT_R4:
				vTemp.SetFloat( m_pSafeArray->GetFloatAt( nIndex ) );
				break;

			case VT_R8:
				vTemp.SetDouble( m_pSafeArray->GetDoubleAt( nIndex ) );
				break;

			case VT_BSTR:
				vTemp.SetBSTR( auto_bstr(m_pSafeArray->GetBSTRAtThrow( nIndex )));
				break;

			case VT_UNKNOWN:
				IUnknown* pUnk = m_pSafeArray->GetUnknownAt(nIndex);
				CReleaseMe	rm( pUnk );

				vTemp.SetUnknown( pUnk );
				break;

		}

	}
	else
	{
		// When we pull data in this state, we're using the CVar as a
		// passthrough, so it won't do any allocations or addref()
		// hence it shouldn't do any cleanup either.

		int	nDataLen = 0L;
		void*	pvElement = m_pRawData;

		switch( m_nType )
		{
			case VT_UI1:
				nDataLen = sizeof(BYTE);
				pvElement = (void*) &((BYTE*) m_pRawData)[nIndex];
				break;

			case VT_BOOL:
			case VT_I2:
				nDataLen = sizeof(short);
				pvElement = (void*) &((short*) m_pRawData)[nIndex];
				break;

			case VT_I4:
				nDataLen = sizeof(long);
				pvElement = (void*) &((long*) m_pRawData)[nIndex];
				break;

			case VT_R4:
				nDataLen = sizeof(float);
				pvElement = (void*) &((float*) m_pRawData)[nIndex];
				break;

			case VT_R8:
				nDataLen = sizeof(double);
				pvElement = (void*) &((double*) m_pRawData)[nIndex];
				break;

			case VT_BSTR:
				nDataLen = sizeof(BSTR);
				pvElement = (void*) &((BSTR*) m_pRawData)[nIndex];

				// If the BSTR is a NULL, old code converted to "", so
				// we will point to a pointer to "".
				if ( (*(BSTR*) pvElement ) == NULL )
				{
					pvElement = (void*) &g_pszNullVarString;
				}

				break;

			case VT_UNKNOWN:
				nDataLen = sizeof(IUnknown*);
				pvElement = (void*) &((IUnknown**) m_pRawData)[nIndex];
				break;

		}

		// Splat the raw value in, and Can Delete is FALSE
		// This is strictly to support optimized pass-through logic
		vTemp.SetRaw( m_nType, pvElement, nDataLen);
		vTemp.SetCanDelete( FALSE );
	}

}

// This only works if there are no elements in the safe array
BOOL CVarVector::MakeOptimized( int nVarType, int nInitSize, int nGrowBy )
{
	BOOL	fReturn = FALSE;

	if ( NULL == m_pSafeArray )
	{
		if ( m_Array.Size() == 0 )
		{
			m_pSafeArray = new CSafeArray( nVarType, CSafeArray::auto_delete, nInitSize, nGrowBy );

			if ( NULL != m_pSafeArray )
			{
				if ( m_pSafeArray->Status() == CSafeArray::no_error )
				{
					m_nType = nVarType;
					m_nStatus = no_error;
					fReturn = TRUE;
				}
				else
				{
					delete m_pSafeArray;
					m_pSafeArray = NULL;
					m_nStatus = failed;
				}
			}
			else
			{
				m_nStatus = failed;
			}
		}	// IF no elements in array

	}

	return fReturn;
}

BOOL CVarVector::DoesVectorTypeMatchArrayType( void )
{
	// If we have an underlying safe array, sometimes the actualy type of the
	// data in the safe array may be different from the type that was reported
	// to us in VARANTARG.  This info is critical in determining how we will
	// go about handling certain operations

	BOOL	fReturn = TRUE;

	if ( NULL != m_pSafeArray )
	{
		VARTYPE	vt;

		// Only return TRUE if the actual types are equal
		if ( m_pSafeArray->GetActualVarType( &vt ) == no_error )
		{
			fReturn = ( vt == m_nType );
		}
		else
		{
			fReturn = FALSE;
		}
	}

	return fReturn;
}

void CVarVector::SetRawArrayBinding( int nBinding )
{
	if ( NULL != m_pSafeArray )
	{
		m_pSafeArray->SetDestructorPolicy( nBinding );
	}
}

HRESULT CVarVector::SetRawArrayData( void* pvData, int nNumElements, int nElementSize )
{
	_DBG_ASSERT( NULL != m_pSafeArray );

	HRESULT	hr = WBEM_S_NO_ERROR;

	if ( NULL != m_pSafeArray )
	{
		if ( m_pSafeArray->SetRawData( pvData, nNumElements, nElementSize ) != CSafeArray::no_error )
			hr = WBEM_E_FAILED;
	}
	else
	{
		hr = WBEM_E_FAILED;
	}

	return hr;
}

HRESULT CVarVector::GetRawArrayData( void* pvDest, int nBuffSize )
{
	_DBG_ASSERT( NULL != m_pSafeArray );

	HRESULT	hr = WBEM_S_NO_ERROR;

	if ( NULL != m_pSafeArray )
	{
		if ( m_pSafeArray->GetRawData( pvDest, nBuffSize ) != CSafeArray::no_error )
			hr = WBEM_E_FAILED;
	}
	else
	{
		hr = WBEM_E_FAILED;
	}

	return hr;
}

BOOL CVarVector::SetRawArraySize( int nSize )
{
	_DBG_ASSERT( NULL != m_pSafeArray );

	BOOL	fReturn = FALSE;

	if ( NULL != m_pSafeArray )
	{
		m_pSafeArray->SetRawArrayMaxElement( nSize - 1 );
		fReturn = TRUE;
	}

	return fReturn;
}

int CVarVector::GetElementSize( void )
{
	_DBG_ASSERT( NULL != m_pSafeArray );

	int	nReturn = 0L;

	if ( NULL != m_pSafeArray )
	{
		nReturn = m_pSafeArray->ElementSize();
	}

	return nReturn;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\winmgmt\wbemcomn\var.h ===
/*++

Copyright (C) 1996-2001 Microsoft Corporation

Module Name:

    VAR.H

Abstract:

  CVar & CVarVector.


  These are thread-safe translators for VARIANT and SAFEARRAY
  and represent all types support by WBEM.

  These are mutually nestable to any level.  A CVarVector can contain 
  an array of CVar, and a CVar can contain a CVarVector.    One CVar
  can therefore contain a whole tree of CVar objects, themselves
  containing homogeneous or heterogeneous arrays of CVar objects.

  Note: CVar should not be bound to one type and then immediately
  coerced to a new type.  This object is designed for speed, not safety,
  so there is no checking to see if this has been done.  A memory leak
  is likely to occur.

  The assignment operator and copy constructors are the only method
  of changing the type on a CVar.  Do NOT construct the object as
  a BSTR, for example, and then call SetDWORD.

History:

	16-Apr-96   a-raymcc    Created.
	12//17/98	sanjes -	Partially Reviewed for Out of Memory.
	18-Mar-99	a-dcrews	Added out-of-memory exception handling

--*/

#ifndef _VAR_H_
#define _VAR_H_

#include <flexarry.h>
#include <safearry.h>
#include <algorithm>
#include <autobstr.h>

#define VT_EX_CVAR           (VT_USERDEFINED | 0x80010000)
#define VT_EX_CVARVECTOR     (VT_USERDEFINED | 0x80010002)

class CVarVector;

typedef union
{
    char     cVal;          // VT_I1
    BYTE     bVal;          // VT_UI1
    SHORT    iVal;          // VT_I2
    WORD     wVal;          // VT_UI2
    LONG     lVal;          // VT_I4
    DWORD    dwVal;         // VT_UI4
    VARIANT_BOOL boolVal;   // VT_BOOL    

    float    fltVal;        // VT_R4
    double   dblVal;        // VT_R8

    LPSTR    pStr;          // VT_LPSTR
    LPWSTR   pWStr;         // VT_LPWSTR
    BSTR     Str;           // VT_BSTR      (stored as VT_LPWSTR)
    
    FILETIME Time;          // VT_FILETIME
    BLOB   Blob;            // VT_BLOB        
    LPCLSID  pClsId;        // VT_CLSID
    IUnknown* pUnk;         // VT_UNKNOWN
    IDispatch* pDisp;       // VT_DISPATCH
    CVarVector *pVarVector; // VT_EX_CVARVECTOR
        
}   METAVALUE;


class POLARITY CVar  
{
private:
    int m_vt;
    METAVALUE m_value;
    int m_nStatus;    
    BOOL m_bCanDelete;
    
    void Init();
public:
    enum { no_error, unsupported, failed };
    
    CVar() { Init(); } 
   ~CVar();
    CVar(const CVar &);
    CVar& operator =(const CVar &);

    CVar(char c)            { Init(); SetChar(c); }
    CVar(BYTE b)            { Init(); SetByte(b); }
    CVar(SHORT s)           { Init(); SetShort(s); }
    CVar(WORD w)            { Init(); SetWord(w); }
    CVar(LONG l)            { Init(); SetLong(l); }
    CVar(DWORD dw)          { Init(); SetDWORD(dw); }     
    CVar(float f)           { Init(); SetFloat(f); }
    CVar(double d)          { Init(); SetDouble(d); }
    CVar(VARIANT_BOOL b,int){ Init(); SetBool(b); }

    CVar(LPSTR p, BOOL bAcquire = FALSE)  
        { Init(); SetLPSTR(p, bAcquire); }

    CVar(LPWSTR p, BOOL bAcquire = FALSE)          
        { Init(); SetLPWSTR(p, bAcquire); }
        
    CVar(int, auto_bstr b)       
        { Init(); SetBSTR(b); }      

    CVar(int, BSTR b)       
        { Init(); SetBSTR(b); }      
        // Dummy int required for context, since BSTR is also LPWSTR
        // from Win32 point of view, although the VT_ indicators differ.
        
        
    CVar(CLSID *p, BOOL bAcquire = FALSE)  
        { Init(); SetClsId(p, bAcquire); }

    CVar(BLOB *p, BOOL bAcquire = FALSE)           
        { Init(); SetBlob(p, bAcquire); }
        
    CVar(FILETIME *p)       { Init(); SetFileTime(p); }

    CVar(CVarVector *p, BOOL bAcquire = FALSE) { Init(); SetVarVector(p, bAcquire); }
    CVar(VARIANT *p)        { Init(); SetVariant(p); }    
    CVar(int nType, SAFEARRAY *p) { Init(); SetSafeArray(nType, p); }
    int Status() { return m_nStatus; }

    int  DumpText(FILE *fStream);
    int  GetType() { return m_vt; }
    int  GetOleType();
    void Empty();

    int operator ==(CVar &Other);
    BOOL CompareTo(CVar& Other, BOOL bIgnoreCase);


    void SetRaw(int vt, void* pvData, int nDataLen);
    void* GetRawData() {return (void*)&m_value;}
    BOOL CanDelete() {return m_bCanDelete;}
    void SetCanDelete(BOOL bCanDelete) {m_bCanDelete = bCanDelete;}

    // Numeric types.
    // ==============
    
    void SetAsNull() { m_vt = VT_NULL; m_value.lVal = 0; }
    BOOL IsNull() {return m_vt == VT_NULL;}
    BOOL IsDataNull();
    
    void SetChar(char c) { m_vt = VT_I1; m_value.cVal = c; }
    char GetChar() { return m_value.cVal; }
    operator char() { return m_value.cVal; }
    
    void SetByte(BYTE b) { m_vt = VT_UI1; m_value.bVal = b; }
    BYTE GetByte() { return m_value.bVal; }
    operator BYTE() { return m_value.bVal; }
    
    void  SetShort(SHORT iVal) { m_vt = VT_I2; m_value.iVal = iVal; }
    SHORT GetShort() { return m_value.iVal; }
    operator SHORT() { return m_value.iVal; }
    
    void SetWord(WORD wVal) { m_vt = VT_UI2; m_value.wVal = wVal; }
    WORD GetWord() { return m_value.wVal; }
    operator WORD() { return m_value.wVal; }
    
    void SetLong(LONG lVal) { m_value.lVal = lVal; m_vt = VT_I4; }
    LONG GetLong() { return m_value.lVal; }
    operator LONG() { return m_value.lVal; }
    
    void SetDWORD(DWORD dwVal) { m_value.dwVal = dwVal; m_vt = VT_UI4; }
    DWORD GetDWORD() { return m_value.dwVal; }
    operator DWORD() { return m_value.dwVal; }
    
    void SetBool(VARIANT_BOOL b) { m_value.boolVal = b; m_vt = VT_BOOL; }
    VARIANT_BOOL GetBool() { return m_value.boolVal; }

    void SetFloat(float f) { m_value.fltVal = f; m_vt = VT_R4; }
    float GetFloat() { return m_value.fltVal; }
    operator float() { return m_value.fltVal; }
    
    void   SetDouble(double dblVal) { m_value.dblVal = dblVal; m_vt = VT_R8; }
    double GetDouble() { return m_value.dblVal; }
    operator double() { return m_value.dblVal; }

    void SetDispatch(IDispatch* pDisp);
    IDispatch* GetDispatch() 
    {if(m_value.pDisp) m_value.pDisp->AddRef(); return m_value.pDisp;}
    
    void SetUnknown(IUnknown* pUnk);
    IUnknown* GetUnknown() 
    {if(m_value.pUnk) m_value.pUnk->AddRef(); return m_value.pUnk;}

    void SetEmbeddedObject(IUnknown* pUnk) {SetUnknown(pUnk);}
    IUnknown* GetEmbeddedObject() {return GetUnknown();}

    int SetVariant(VARIANT *pSrc, BOOL fOptimize = FALSE);

    void FillVariant(VARIANT* pDest, BOOL fOptimized = FALSE);
    VARIANT *GetNewVariant();    
    
    // String types.
    // =============
    
    BOOL  SetLPWSTR(LPWSTR pVal, BOOL bAcquire = FALSE);
    wchar_t *GetLPWSTR() { return m_value.pWStr; }
    operator LPWSTR() { return m_value.pWStr; }    
    
    BOOL  SetLPSTR(LPSTR pStr, BOOL bAcquire = FALSE);
    LPSTR GetLPSTR() { return m_value.pStr; }
    operator LPSTR() { return m_value.pStr; }
    
    BOOL SetBSTR(auto_bstr str);
    BOOL SetBSTR(BSTR str);
    BSTR GetBSTR();     // Makes a dynamic copy which must be freed.
    
    // Misc. types.
    // ============
    
    void SetFileTime(FILETIME *pft) { m_value.Time = *pft; m_vt = VT_FILETIME; }
    FILETIME GetFileTime() { return m_value.Time; }
    operator FILETIME() { return m_value.Time; }    
    
    void SetBlob(BLOB *pBlob, BOOL bAcquire = FALSE);
    BLOB *GetBlob() { return &m_value.Blob; }
    operator BLOB *() { return &m_value.Blob; }        
    
    void SetClsId(CLSID *pClsId, BOOL bAcquire);
    CLSID* GetClsId() { return m_value.pClsId; }    // Return value is read-only
    operator CLSID*() { return m_value.pClsId; }    // Return value is read-only    
    
    void SetVarVector(CVarVector *pVec, BOOL bAcquire);
    CVarVector *GetVarVector()  { return m_value.pVarVector; }  
    operator CVarVector *()  { return m_value.pVarVector; }  
    
    void SetSafeArray(int nType, SAFEARRAY *pArray); // Copies the source
    SAFEARRAY *GetNewSafeArray();   // New SAFEARRAY which must be released

    void SetOptimizedSafeArray(int nType, SAFEARRAY *pArray, BOOL fAcquire = FALSE);
	SAFEARRAY* GetOptimizedSafeArray( void );

    static BSTR TypeToText(int nType);
    BSTR GetTypeText();
    BSTR GetText(long lFlags, long lType = 0, LPCWSTR szFormat = NULL);

    BOOL ChangeTypeTo(VARTYPE vtNew);
    BOOL ChangeTypeToEx(VARTYPE vtNew, LCID lcid = 0x409 );
    BOOL ToSingleChar();
    BOOL ToUI4();
};


class POLARITY CVarVector
{
    int         m_nType;
    CFlexArray  m_Array;
    int         m_nStatus;
	CSafeArray*	m_pSafeArray;
	void*		m_pRawData;

public:
    enum { no_error, failed, unsupported };

    CVarVector();    
    CVarVector(int nVarType, int nInitSize = 32, int nGrowBy = 32);

    // These two only support limited SAFEARRAY types.
    // ===============================================

    CVarVector(int nVarType, SAFEARRAY *pSrc, BOOL fOptimized = FALSE);
    SAFEARRAY *GetNewSafeArray();
	SAFEARRAY* GetSafeArray( BOOL fAcquire = FALSE );

    int  GetType() { return m_nType; }        
    int  Status() { return m_nStatus; }
    void Empty();
                    
   ~CVarVector();
    CVarVector(CVarVector &Src);
    CVarVector& operator =(CVarVector &Src);
    int operator ==(CVarVector &Src);     
    BOOL CompareTo(CVarVector& Other, BOOL bIgnoreCase);
    int Size();

    int    Add(CVar &Value);  
    int    Add(CVar *pAcquiredPtr);

    CVar&   GetAt(int nIndex);
    CVar&   operator [](int nIndex);

    int    RemoveAt(int nIndex);
    int    InsertAt(int nIndex, CVar &Value);

    BSTR GetText(long lFlags, long lType = 0);
    BOOL ToSingleChar();
    BOOL ToUI4();

	BOOL IsOptimized( void )	{ return NULL != m_pSafeArray; }
	BOOL MakeOptimized( int nVarType, int nInitSize = 32, int nGrowBy = 32 );
	void SetRawArrayBinding( int nBinding );
	
	HRESULT AccessRawArray( void** ppv );
	HRESULT UnaccessRawArray( void );

	// We access raw data using internal data member.
	HRESULT InternalRawArrayAccess( void );

	static BOOL IsValidVectorType( int nVarType );
	static BOOL IsValidVectorArray( int nVarType, SAFEARRAY* pArray );

	void FillCVarAt(int nIndex, CVar& vTemp);

	BOOL DoesVectorTypeMatchArrayType( void );
	
	HRESULT SetRawArrayData( void* pvData, int nNumElements, int nElementSize );
	HRESULT GetRawArrayData( void* pvDest, int nBuffSize );

	BOOL SetRawArraySize( int nSize );
	int GetElementSize( void );
};

class CUnaccessVarVector
{
private:
	CVarVector*	m_pVV;

public:

	CUnaccessVarVector( CVarVector*	pvv = NULL ) : m_pVV( pvv )	{}
	~CUnaccessVarVector() { Unaccess(); }

	void SetVV( CVarVector* pvv )	{ m_pVV = pvv; }
	void Unaccess( void ) { if ( NULL != m_pVV ) m_pVV->UnaccessRawArray(); m_pVV = NULL; }
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\winmgmt\wbemcomn\wbemcomn.h ===
/*++

Copyright (C) 1996-2001 Microsoft Corporation

Module Name:

    WBEMCOMN.H

Abstract:

History:

--*/

#ifndef __WBEMCOMN__H_
#define __WBEMCOMN__H_

#define _new new

#include<corepol.h>
#include<wbemidl.h>
#include<md5wbem.h>
#include<unk.h>
#include<clsfac.h>
#include<var.h>
#include<parmdefs.h>
#include<arena.h>
#include<arrtempl.h>
#include<flexarry.h>
#include<flexq.h>
#include<reg.h>
#include<safearry.h>
#include<wstring.h>
#include<wbemutil.h>
#include <CWbemTime.h>

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\winmgmt\wbemcomn\winntsec.cpp ===
/*++

Copyright (C) 1997-2001 Microsoft Corporation

Module Name:

    WINNTSEC.CPP

Abstract:

    Generic wrapper classes for NT security objects.

    Documention on class members is in WINNTSEC.CPP.  Inline members
    are commented in this file.

History:

    raymcc      08-Jul-97       Created.

--*/

#include "precomp.h"

#include <stdio.h>
#include <io.h>
#include <errno.h>
#include <winntsec.h>
#include <genutils.h>
#include "arena.h"
#include "reg.h"
#include "wbemutil.h"
#include "arrtempl.h"
#include <cominit.h>
#include <Sddl.h>
extern "C"
{
#include <lmaccess.h>
#include <lmapibuf.h>
#include <lmerr.h>
};
#include <helper.h>

//***************************************************************************
//
//  CNtSid::GetSize
//
//  Returns the size of the SID in bytes.
//
//***************************************************************************
// ok

DWORD CNtSid::GetSize()
{
    if (m_pSid == 0 || !IsValidSid(m_pSid))
        return 0;

    return GetLengthSid(m_pSid);
}

//***************************************************************************
//
//  CNtSid Copy Constructor
//
//***************************************************************************
// ok

CNtSid::CNtSid( const CNtSid &Src)
{
    m_pSid = 0;
    m_pMachine = 0;
    if (Src.m_dwStatus != CNtSid::NoError)
    {
       m_dwStatus = Src.m_dwStatus;
       return;
    }
    
    m_dwStatus = InternalError;

    if (NULL == Src.m_pSid) return;
        
    DWORD dwLen = GetLengthSid(Src.m_pSid);
    wmilib::auto_buffer<BYTE> pTmpSid( new BYTE [dwLen]);
    if (NULL == pTmpSid.get()) return;
 
    ZeroMemory(pTmpSid.get(),dwLen);
    if (!CopySid(dwLen, pTmpSid.get(), Src.m_pSid)) return;

    wmilib::auto_buffer<WCHAR> pTmpMachine;
    if (Src.m_pMachine)
    {
        size_t cchTmp = wcslen(Src.m_pMachine) + 1;
        pTmpMachine.reset(new WCHAR[cchTmp]);
        if (NULL == pTmpMachine.get()) return;
        memcpy(pTmpMachine.get(),Src.m_pMachine,cchTmp*sizeof(WCHAR));
    }

    m_pSid = pTmpSid.release();
    m_pMachine = pTmpMachine.release();
    m_dwStatus = NoError;
}

//***************************************************************************
//
//  CNtSid Copy Constructor
//
//***************************************************************************
// ok

CNtSid::CNtSid(SidType st)
{
    m_pSid = 0;
    m_dwStatus = InternalError;
    m_pMachine = 0;
    if(st == CURRENT_USER ||st == CURRENT_THREAD)
    {
        HANDLE hToken;
        if(st == CURRENT_USER)
        {
            if(!OpenProcessToken(GetCurrentProcess(), TOKEN_READ, &hToken))
                return;
        }
        else
        {
            if(!OpenThreadToken(GetCurrentThread(), TOKEN_QUERY, TRUE, &hToken))
                return;
        }
        OnDelete< HANDLE , BOOL(*)(HANDLE) , CloseHandle > cm(hToken);

        // Get the user sid
        // ================
        TOKEN_USER tu;
        DWORD dwLen = 0;
        GetTokenInformation(hToken, TokenUser, &tu, sizeof(tu), &dwLen);
        if(dwLen == 0) return;

        wmilib::auto_buffer<BYTE> pTemp( new BYTE[dwLen]);
        if (NULL == pTemp.get()) return;

        DWORD dwRealLen = dwLen;
        if(!GetTokenInformation(hToken, TokenUser, pTemp.get(), dwRealLen, &dwLen)) return;

        // Make a copy of the SID
        // ======================

        PSID pSid = ((TOKEN_USER*)pTemp.get())->User.Sid;
        DWORD dwSidLen = GetLengthSid(pSid);
        m_pSid = new BYTE[dwSidLen];
        if (m_pSid) 
        {
            CopySid(dwSidLen, m_pSid, pSid);
            m_dwStatus = NoError;            
        }        
    }
    return;
}



//***************************************************************************
//
//  CNtSid::CopyTo
//
//  An unchecked copy of the internal SID to the destination pointer.
//
//  Parameters:
//  <pDestination> points to the buffer to which to copy the SID. The
//  buffer must be large enough to hold the SID.
//
//  Return value:
//  TRUE on success, FALSE on failure.
//
//***************************************************************************
// ok

BOOL CNtSid::CopyTo(PSID pDestination)
{
    if (m_pSid == 0 || m_dwStatus != NoError)
        return FALSE;

    DWORD dwLen = GetLengthSid(m_pSid);
    memcpy(pDestination, m_pSid, dwLen);

    return TRUE;
}


//***************************************************************************
//
//  CNtSid assignment operator
//
//***************************************************************************
// ok

CNtSid & CNtSid::operator =( const CNtSid &Src)
{
    CNtSid tmp(Src);
    
    std::swap(this->m_dwStatus,tmp.m_dwStatus);
    std::swap(this->m_pMachine,tmp.m_pMachine);    
    std::swap(this->m_pSid,tmp.m_pSid);    
    std::swap(this->m_snu,tmp.m_snu);    
    
    return *this;
}

//***************************************************************************
//
//  CNtSid comparison operator
//
//***************************************************************************
int CNtSid::operator ==(CNtSid &Comparand)
{
    if (m_pSid == 0 && Comparand.m_pSid == 0 &&
      m_dwStatus == Comparand.m_dwStatus)
        return 1;
    if (m_dwStatus != Comparand.m_dwStatus)
        return 0;
    if (m_pSid && Comparand.m_pSid)
        return EqualSid(m_pSid, Comparand.m_pSid);
    else
        return 0;
}

//***************************************************************************
//
//  CNtSid::CNtSid
//
//  Constructor which builds a SID directly from a user or group name.
//  If the machine is available, then its name can be used to help
//  distinguish the same name in different SAM databases (domains, etc).
//
//  Parameters:
//
//  <pUser>     The desired user or group.
//
//  <pMachine>  Points to a machine name with or without backslashes,
//              or else is NULL, in which case the current machine, domain,
//              and trusted domains are searched for a match.
//
//  After construction, call GetStatus() to determine if the constructor
//  succeeded.  NoError is expected.
//
//***************************************************************************
// ok

CNtSid::CNtSid(
    LPWSTR pUser,
    LPWSTR pMachine
    )
{
    DWORD  dwRequired = 0;
    DWORD  dwDomRequired = 0;
    LPWSTR pszDomain = NULL;
    m_pSid = 0;
    m_pMachine = 0;

    if (pMachine)
    {
        size_t stringLength = wcslen(pMachine) + 1;
        m_pMachine = new wchar_t[stringLength];
        if (!m_pMachine)
        {
            m_dwStatus = Failed;
            return;
        }
        
        StringCchCopyW(m_pMachine, stringLength, pMachine);
    }

    BOOL bRes = LookupAccountNameW(
        m_pMachine,
        pUser,
        m_pSid,
        &dwRequired,
        pszDomain,
        &dwDomRequired,
        &m_snu
        );

    DWORD dwLastErr = GetLastError();

    if (dwLastErr != ERROR_INSUFFICIENT_BUFFER)
    {
        m_pSid = 0;
        if (dwLastErr == ERROR_ACCESS_DENIED)
            m_dwStatus = AccessDenied;
        else
            m_dwStatus = InvalidSid;
        return;
    }

    m_pSid = (PSID) new BYTE [dwRequired];
    if (!m_pSid)
    {
        m_dwStatus = Failed;
        return;
    }

    ZeroMemory(m_pSid, dwRequired);
    pszDomain = new wchar_t[dwDomRequired + 1];
    if (!pszDomain)
    {
        delete [] m_pSid;
        m_pSid = 0;
        m_dwStatus = Failed;
        return;
    }

    bRes = LookupAccountNameW(
        pMachine,
        pUser,
        m_pSid,
        &dwRequired,
        pszDomain,
        &dwDomRequired,
        &m_snu
        );

    if (!bRes || !IsValidSid(m_pSid))
    {
        delete [] m_pSid;
        delete [] pszDomain;
        m_pSid = 0;
        m_dwStatus = InvalidSid;
        return;
    }

    delete [] pszDomain;   // We never really needed this
    m_dwStatus = NoError;
}

//***************************************************************************
//
//  CNtSid::CNtSid
//
//  Constructs a CNtSid object directly from an NT SID. The SID is copied,
//  so the caller retains ownership.
//
//  Parameters:
//  <pSrc>      The source SID upon which to base the object.
//
//  Call GetStatus() after construction to ensure the object was
//  constructed correctly.  NoError is expected.
//
//***************************************************************************
// ok

CNtSid::CNtSid(PSID pSrc)
{
    m_pMachine = 0;
    m_pSid = 0;
    m_dwStatus = NoError;

    if (!IsValidSid(pSrc))
    {
        m_dwStatus = InvalidSid;
        return;
    }

    DWORD dwLen = GetLengthSid(pSrc);

    m_pSid = (PSID) new BYTE [dwLen];

    if ( m_pSid == NULL )
    {
        m_dwStatus = Failed;
        return;
    }

    ZeroMemory(m_pSid, dwLen);

    if (!CopySid(dwLen, m_pSid, pSrc))
    {
        delete [] m_pSid;
        m_dwStatus = InternalError;
        return;
    }
}

//***************************************************************************
//
//  CNtSid::GetInfo
//
//  Returns information about the SID.
//
//  Parameters:
//  <pRetAccount>       Receives a UNICODE string containing the account
//                      name (user or group).  The caller must use operator
//                      delete to free the memory.  This can be NULL if
//                      this information is not required.
//  <pRetDomain>        Returns a UNICODE string containing the domain
//                      name in which the account resides.   The caller must
//                      use operator delete to free the memory.  This can be
//                      NULL if this information is not required.
//  <pdwUse>            Points to a DWORD to receive information about the name.
//                      Possible return values are defined under SID_NAME_USE
//                      in NT SDK documentation.  Examples are
//                      SidTypeUser, SidTypeGroup, etc. 
//                      for an example.
//
//  Return values:
//  NoError, InvalidSid, Failed
//
//***************************************************************************
// ok

int CNtSid::GetInfo(
    LPWSTR *pRetAccount,       // Account, use operator delete
    LPWSTR *pRetDomain,        // Domain, use operator delete
    DWORD  *pdwUse             // See SID_NAME_USE for values
    )
{
    if (pRetAccount)
        *pRetAccount = 0;
    if (pRetDomain)
        *pRetDomain  = 0;
    if (pdwUse)
        *pdwUse   = 0;

    if (!m_pSid || !IsValidSid(m_pSid))
        return InvalidSid;

    DWORD  dwNameLen = 0;
    DWORD  dwDomainLen = 0;
    LPWSTR pUser = 0;
    LPWSTR pDomain = 0;
    SID_NAME_USE Use;


    // Do the first lookup to get the buffer sizes required.
    // =====================================================

    BOOL bRes = LookupAccountSidW(
        m_pMachine,
        m_pSid,
        pUser,
        &dwNameLen,
        pDomain,
        &dwDomainLen,
        &Use
        );

    DWORD dwLastErr = GetLastError();

    if (dwLastErr != ERROR_INSUFFICIENT_BUFFER)
    {
        return Failed;
    }

    // Allocate the required buffers and look them up again.
    // =====================================================

    pUser = new wchar_t[dwNameLen + 1];
    if (!pUser)
        return Failed;

    pDomain = new wchar_t[dwDomainLen + 1];
    if (!pDomain)
    {
        delete pUser;
        return Failed;
    }

    bRes = LookupAccountSidW(
        m_pMachine,
        m_pSid,
        pUser,
        &dwNameLen,
        pDomain,
        &dwDomainLen,
        &Use
        );

    if (!bRes)
    {
        delete [] pUser;
        delete [] pDomain;
        return Failed;
    }

    if (pRetAccount)
        *pRetAccount = pUser;
    else
        delete [] pUser;
    if (pRetDomain)
        *pRetDomain  = pDomain;
    else
        delete [] pDomain;
    if (pdwUse)
        *pdwUse = Use;

    return NoError;
}

//***************************************************************************
//
//  CNtSid destructor
//
//***************************************************************************

CNtSid::~CNtSid()
{
    delete [] m_pSid;
    delete [] m_pMachine;
}

//***************************************************************************
//
//  CNtSid::GetTextSid
//
//  Converts the sid to text form.  The caller should passin a 130 character
//  buffer.
//
//***************************************************************************

BOOL CNtSid::GetTextSid(LPTSTR pszSidText, LPDWORD dwBufferLen)
{

      // test if Sid is valid

      if(m_pSid == 0 || !IsValidSid(m_pSid))
          return FALSE;

    LPTSTR textualSid = 0;
    if (ConvertSidToStringSid(m_pSid, &textualSid))
        {
        HRESULT fit = StringCchCopy(pszSidText, *dwBufferLen, textualSid);
        LocalFree(textualSid);
        return SUCCEEDED(fit);
        };
    return FALSE;
}


//***************************************************************************
//
//  CNtAce::CNtAce
//
//  Constructor which directly builds the ACE based on a user, access mask
//  and flags without a need to build an explicit SID.
//
//
//  Parameters:
//  <AccessMask>        A WINNT ACCESS_MASK which specifies the permissions
//                      the user should have to the object being secured.
//                      See ACCESS_MASK in NT SDK documentation.
//  <dwAceType>         One of the following:
//                          ACCESS_ALLOWED_ACE_TYPE
//                          ACCESS_DENIED_ACE_TYPE
//                          ACCESS_AUDIT_ACE_TYPE
//                      See ACE_HEADER in NT SDK documentation.
//  <dwAceFlags>        Of of the ACE propation flags.  See ACE_HEADER
//                      in NT SDK documentation for legal values.
//  <sid>               CNtSid specifying the user or group for which the ACE is being
//                      created.
//
//  After construction, call GetStatus() to verify that the ACE
//  is valid. NoError is expected.
//
//***************************************************************************
// ok

CNtAce::CNtAce(
    ACCESS_MASK AccessMask,
    DWORD dwAceType,
    DWORD dwAceFlags,
    CNtSid & Sid
    )
{
    m_pAce = 0;
    m_dwStatus = NoError;

    // If the SID is invalid, the ACE will be as well.
    // ===============================================

    if (Sid.GetStatus() != CNtSid::NoError)
    {
        m_dwStatus = InvalidAce;
        return;
    }

    // Compute the size of the ACE.
    // ============================

    DWORD dwSidLength = Sid.GetSize();

    DWORD dwTotal = dwSidLength + sizeof(GENERIC_ACE) - 4;

    m_pAce = (PGENERIC_ACE) new BYTE[dwTotal];
    
    if (m_pAce)
    {
        ZeroMemory(m_pAce, dwTotal);

        // Build up the ACE info.
        // ======================

        m_pAce->Header.AceType  = BYTE(dwAceType);
        m_pAce->Header.AceFlags = BYTE(dwAceFlags);
        m_pAce->Header.AceSize = WORD(dwTotal);
        m_pAce->Mask = AccessMask;

        BOOL bRes = Sid.CopyTo(PSID(&m_pAce->SidStart));

        if (!bRes)
        {
            delete m_pAce;
            m_pAce = 0;
            m_dwStatus = InvalidAce;
            return;
        }

        m_dwStatus = NoError;
    }
    else
        m_dwStatus = InternalError;
}

//***************************************************************************
//
//  CNtAce::CNtAce
//
//  Constructor which directly builds the ACE based on a user, access mask
//  and flags without a need to build an explicit SID.
//
//
//  Parameters:
//  <AccessMask>        A WINNT ACCESS_MASK which specifies the permissions
//                      the user should have to the object being secured.
//                      See ACCESS_MASK in NT SDK documentation.
//  <dwAceType>         One of the following:
//                          ACCESS_ALLOWED_ACE_TYPE
//                          ACCESS_DENIED_ACE_TYPE
//                          ACCESS_AUDIT_ACE_TYPE
//                      See ACE_HEADER in NT SDK documentation.
//  <dwAceFlags>        Of of the ACE propation flags.  See ACE_HEADER
//                      in NT SDK documentation for legal values.
//  <pUser>             The user or group for which the ACE is being
//                      created.
//  <pMachine>          If NULL, the current machine, domain, and trusted
//                      domains are searched for a match.  If not NULL,
//                      can point to a UNICODE machine name (with or without
//                      leading backslashes) which contains the account.
//
//  After construction, call GetStatus() to verify that the ACE
//  is valid. NoError is expected.
//
//***************************************************************************
// ok

CNtAce::CNtAce(
    ACCESS_MASK AccessMask,
    DWORD dwAceType,
    DWORD dwAceFlags,
    LPWSTR pUser,
    LPWSTR pMachine
    )
{
    m_pAce = 0;
    m_dwStatus = NoError;

    // Create the SID of the user.
    // ===========================

    CNtSid Sid(pUser, pMachine);

    // If the SID is invalid, the ACE will be as well.
    // ===============================================

    if (Sid.GetStatus() != CNtSid::NoError)
    {
        m_dwStatus = InvalidAce;
        return;
    }

    // Compute the size of the ACE.
    // ============================

    DWORD dwSidLength = Sid.GetSize();

    DWORD dwTotal = dwSidLength + sizeof(GENERIC_ACE) - 4;

    m_pAce = (PGENERIC_ACE) new BYTE[dwTotal];
    if ( m_pAce == NULL )
    {
        m_dwStatus = InternalError;        
        return;
    }
    ZeroMemory(m_pAce, dwTotal);

    // Build up the ACE info.
    // ======================

    m_pAce->Header.AceType  = BYTE(dwAceType);
    m_pAce->Header.AceFlags = BYTE(dwAceFlags);
    m_pAce->Header.AceSize = WORD(dwTotal);
    m_pAce->Mask = AccessMask;

    BOOL bRes = Sid.CopyTo(PSID(&m_pAce->SidStart));

    if (!bRes)
    {
        delete m_pAce;
        m_pAce = 0;
        m_dwStatus = InvalidAce;
        return;
    }

    m_dwStatus = NoError;
}

//***************************************************************************
//
//  CNtAce::GetAccessMask
//
//  Returns the ACCESS_MASK of the ACe.
//
//***************************************************************************
ACCESS_MASK CNtAce::GetAccessMask()
{
    if (m_pAce == 0)
        return 0;
    return m_pAce->Mask;
}

//***************************************************************************
//
//  CNtAce::GetSerializedSize
//
//  Returns the number of bytes needed to store this
//
//***************************************************************************

DWORD CNtAce::GetSerializedSize()
{
    if (m_pAce == 0)
        return 0;
    return m_pAce->Header.AceSize;
}


//***************************************************************************
//
//  CNtAce::GetSid
//
//  Returns a copy of the CNtSid object which makes up the ACE.
//
//  Return value:
//      A newly allocated CNtSid which represents the user or group
//      referenced in the ACE.  The caller must use operator delete to free
//      the memory.
//
//***************************************************************************
// ok

CNtSid* CNtAce::GetSid()
{
    if (m_pAce == 0)
        return 0;

    PSID pSid = 0;

    pSid = &m_pAce->SidStart;

    if (!IsValidSid(pSid))
        return 0;

    return new CNtSid(pSid);
}

//***************************************************************************
//
//  CNtAce::GetSid
//
//  Gets the SID in an alternate manner, by assigning to an existing
//  object instead of returning a dynamically allocated one.
//
//  Parameters:
//  <Dest>              A reference to a CNtSid to receive the SID.
//
//  Return value:
//  TRUE on successful assignment, FALSE on failure.
//
//***************************************************************************

BOOL CNtAce::GetSid(CNtSid &Dest)
{
    CNtSid *pSid = GetSid();
    if (pSid == 0)
        return FALSE;

    Dest = *pSid;
    delete pSid;
    return TRUE;
}

//***************************************************************************
//
//  CNtAce::CNtAce
//
//  Alternate constructor which uses a normal NT ACE as a basis for
//  object construction.
//
//  Parameters:
//  <pAceSrc>       A read-only pointer to the source ACE upon which to
//                  base object construction.
//
//  After construction, GetStatus() can be used to determine if the
//  object constructed properly.  NoError is expected.
//
//***************************************************************************
// ok

CNtAce::CNtAce(PGENERIC_ACE pAceSrc)
{
    m_dwStatus = NoError;

    if (pAceSrc == 0)
    {
        m_dwStatus = NullAce;
        m_pAce = 0;
        return;
    }

    m_pAce = (PGENERIC_ACE) new BYTE[pAceSrc->Header.AceSize];
    if ( m_pAce == NULL )
    {
        m_dwStatus = InternalError;
        return;
    }
    ZeroMemory(m_pAce, pAceSrc->Header.AceSize);
    memcpy(m_pAce, pAceSrc, pAceSrc->Header.AceSize);
}

//***************************************************************************
//
//  CNtAce copy constructor.
//
//***************************************************************************
// ok

CNtAce::CNtAce(const CNtAce &Src)
{
    if (NoError == Src.m_dwStatus)
    {
        m_pAce = (PGENERIC_ACE)new BYTE[Src.m_pAce->Header.AceSize];
        if (NULL == m_pAce)
        {
            m_dwStatus = InternalError;
            return;
        }
        memcpy(m_pAce,Src.m_pAce,Src.m_pAce->Header.AceSize);
    }
    else
    {
        m_pAce = Src.m_pAce;
    }
    m_dwStatus = Src.m_dwStatus;
}

//***************************************************************************
//
//  CNtAce assignment operator.
//
//***************************************************************************
// ok

CNtAce &CNtAce::operator =(const CNtAce &Src)
{
    CNtAce tmp(Src);
    std::swap(m_pAce,tmp.m_pAce);
    std::swap(m_dwStatus,tmp.m_dwStatus);
    return *this;
}

//***************************************************************************
//
//  CNtAce destructor
//
//***************************************************************************
// ok

CNtAce::~CNtAce()
{
    delete m_pAce;
}

//***************************************************************************
//
//  CNtAce::GetType
//
//  Gets the Ace Type as defined under the NT SDK documentation for
//  ACE_HEADER.
//
//  Return value:
//      Returns ACCESS_ALLOWED_ACE_TYPE, ACCESS_DENIED_ACE_TYPE, or
//      SYSTEM_AUDIT_ACE_TYPE.  Returns -1 on error, such as a null ACE.
//
//      Returning -1 (or an analog) is required as an error code because
//      ACCESS_ALLOWED_ACE_TYPE is defined to be zero.
//
//***************************************************************************
// ok

int CNtAce::GetType()
{
    if (m_pAce == 0 || m_dwStatus != NoError)
        return -1;
    return m_pAce->Header.AceType;
}

//***************************************************************************
//
//  CNtAce::GetFlags
//
//  Gets the Ace Flag as defined under the NT SDK documentation for
//  ACE_HEADER.
//
//  Return value:
//      Returning -1 if error, other wise the flags.
//
//***************************************************************************

int CNtAce::GetFlags()
{
    if (m_pAce == 0 || m_dwStatus != NoError)
        return -1;
    return m_pAce->Header.AceFlags;
}


HRESULT CNtAce::GetFullUserName2(WCHAR ** pBuff)
{
    CNtSid *pSid = GetSid();
    CDeleteMe<CNtSid> d0(pSid);    
    if(NULL == pSid || CNtSid::NoError != pSid->GetStatus())
        return WBEM_E_OUT_OF_MEMORY;

    DWORD dwJunk;
    LPWSTR pRetAccount = NULL, pRetDomain = NULL;
    if(0 != pSid->GetInfo(&pRetAccount, &pRetDomain,&dwJunk))
        return WBEM_E_FAILED;

    CDeleteMe<WCHAR> d1(pRetAccount);
    CDeleteMe<WCHAR> d2(pRetDomain);

    int iLen = 3;
    if(pRetAccount)
        iLen += wcslen(pRetAccount);
    if(pRetDomain)
        iLen += wcslen(pRetDomain);
    (*pBuff) = new WCHAR[iLen];
    if((*pBuff) == NULL)
        return WBEM_E_OUT_OF_MEMORY;

    (*pBuff)[0] = 0;
    if(pRetDomain && wcslen(pRetDomain) > 0)
        StringCchCopyW(*pBuff, iLen, pRetDomain);
    else
        StringCchCopyW(*pBuff, iLen, L".");
    StringCchCatW(*pBuff, iLen, L"|");
    StringCchCatW(*pBuff, iLen, pRetAccount);
    return S_OK;

}
//***************************************************************************
//
//  CNtAce::Serialize
//
//  Serializes the ace.
//
//***************************************************************************

bool CNtAce::Serialize(BYTE * pData, size_t bufferSize)
{
    if(m_pAce == NULL)
        return false;
    DWORD dwSize = m_pAce->Header.AceSize;
    if (bufferSize < dwSize) return false;
    memcpy((void *)pData, (void *)m_pAce, dwSize);
    return true;
}

//***************************************************************************
//
//  CNtAce::Deserialize
//
//  Deserializes the ace.  Normally this isnt called since the
//  CNtAce(PGENERIC_ACE pAceSrc) constructor is fine.  However, this is
//  used for the case where the db was created on win9x and we are now
//  running on nt.  In that case, the format is the same as outlined in
//  C9XAce::Serialize
//
//***************************************************************************

bool CNtAce::Deserialize(BYTE * pData)
{
    BYTE * pNext;
    pNext = pData + 2*(wcslen((LPWSTR)pData) + 1);
    DWORD * pdwData = (DWORD *)pNext;
    DWORD dwFlags, dwType, dwAccess;
    dwFlags = *pdwData;
    pdwData++;
    dwType = *pdwData;
    pdwData++;
    dwAccess = *pdwData;
    pdwData++;
    CNtAce temp(dwAccess, dwType, dwFlags, (LPWSTR)pData);
    *this = temp;
    return true;

}

//***************************************************************************
//
//  CNtAcl::CNtAcl
//
//  Constructs an empty ACL with a user-specified size.

//
//  Parameters:
//  <dwInitialSize>     Defaults to 128. Recommended values are 128 or
//                      higher in powers of two.
//
//  After construction, GetStatus() should be called to verify
//  the ACL initialized properly.  Expected value is NoError.
//
//***************************************************************************
// ok

CNtAcl::CNtAcl(DWORD dwInitialSize)
{
    m_pAcl = (PACL) new BYTE[dwInitialSize];
    if ( m_pAcl == NULL )
    {
        m_dwStatus = InternalError;
        return;
    }
    ZeroMemory(m_pAcl, dwInitialSize);
    BOOL bRes = InitializeAcl(m_pAcl, dwInitialSize, ACL_REVISION);

    if (!bRes)
    {
        delete m_pAcl;
        m_pAcl = 0;
        m_dwStatus = NullAcl;
        return;
    }

    m_dwStatus = NoError;
}


//***************************************************************************
//
//  CNtAcl copy constructor.
//
//***************************************************************************
// ok

CNtAcl::CNtAcl(const CNtAcl &Src)
{
    if (Src.m_pAcl)
    {
        if (!IsValidAcl(Src.m_pAcl))
        {
            m_pAcl = 0;
            m_dwStatus = InvalidAcl;
            return;
        }

        m_pAcl = (PACL)new BYTE[Src.m_pAcl->AclSize];
        if (NULL == m_pAcl)
        {
            m_dwStatus = InternalError;
            return;
        }
        memcpy(m_pAcl, Src.m_pAcl,Src.m_pAcl->AclSize);
    }
    else
    {
        m_pAcl = Src.m_pAcl;
    }
    m_dwStatus = Src.m_dwStatus;
}

//***************************************************************************
//
//  CNtAcl assignment operator
//
//***************************************************************************
// ok

CNtAcl &CNtAcl::operator = (const  CNtAcl &Src)
{
    CNtAcl tmp(Src);
    std::swap(m_pAcl,tmp.m_pAcl);
    std::swap(m_dwStatus,tmp.m_dwStatus);
    return *this;
}

//***************************************************************************
//
//  CNtAcl::GetAce
//
//  Returns an ACE at the specified index.  To enumerate ACEs, the caller
//  should determine the number of ACEs using GetNumAces() and then call
//  this function with each index starting from 0 to number of ACEs - 1.
//
//  Parameters:
//  <nIndex>        The index of the desired ACE.
//
//  Return value:
//  A newly allocated CNtAce object which must be deallocated using
//  operator delete.  This is only a copy.  Modifications to the returned
//  CNtAce do not affect the ACL from which it came.
//
//  Returns NULL on error.
//
//***************************************************************************
// ok

CNtAce *CNtAcl::GetAce(int nIndex)
{
    if (m_pAcl == 0)
        return 0;

    LPVOID pAce = 0;

    BOOL bRes = ::GetAce(m_pAcl, (DWORD) nIndex, &pAce);

    if (!bRes)
        return 0;

    return new CNtAce(PGENERIC_ACE(pAce));
}

//***************************************************************************
//
//  CNtAcl::GetAce
//
//  Alternate method to get ACEs to avoid dynamic allocation & cleanup,
//  since an auto object can be used as the parameter.
//
//  Parameters:
//  <Dest>          A reference to a CNtAce to receive the ACE value.
//
//  Return value:
//  TRUE if assigned, FALSE if not.
//
//***************************************************************************

BOOL CNtAcl::GetAce(int nIndex, CNtAce &Dest)
{
    CNtAce *pNew = GetAce(nIndex);
    if (pNew == 0)
        return FALSE;

    Dest = *pNew;
    delete pNew;
    return TRUE;
}

//***************************************************************************
//
//  CNtAcl::DeleteAce
//
//  Removes the specified ACE from the ACL.
//
//  Parameters:
//  <nIndex>        The 0-based index of the ACE which should be removed.
//
//  Return value:
//  TRUE if the ACE was deleted, FALSE if not.
//
//***************************************************************************
// ok

BOOL CNtAcl::DeleteAce(int nIndex)
{
    if (m_pAcl == 0)
        return FALSE;

    BOOL bRes = ::DeleteAce(m_pAcl, DWORD(nIndex));

    return bRes;
}

//***************************************************************************
//
//  CNtAcl::GetSize()
//
//  Return value:
//  Returns the size in bytes of the ACL
//
//***************************************************************************
// ok

DWORD CNtAcl::GetSize()
{
    if (m_pAcl == 0 || !IsValidAcl(m_pAcl))
        return 0;

    return DWORD(m_pAcl->AclSize);
}


//***************************************************************************
//
//  CNtAcl::GetAclSizeInfo
//
//  Gets information about used/unused space in the ACL.  This function
//  is primarily for internal use.
//
//  Parameters:
//  <pdwBytesInUse>     Points to a DWORD to receive the number of
//                      bytes in use in the ACL.  Can be NULL.
//  <pdwBytesFree>      Points to a DWORD to receive the number of
//                      bytes free in the ACL.  Can be NULL.
//
//  Return value:
//  Returns TRUE if the information was retrieved, FALSE if not.
//
//***************************************************************************
// ok

BOOL CNtAcl::GetAclSizeInfo(
    PDWORD pdwBytesInUse,
    PDWORD pdwBytesFree
    )
{
    if (m_pAcl == 0)
        return 0;

    if (!IsValidAcl(m_pAcl))
        return 0;

    if (pdwBytesInUse)
        *pdwBytesInUse = 0;
    if (pdwBytesFree)
        *pdwBytesFree  = 0;

    ACL_SIZE_INFORMATION inf;

    BOOL bRes = GetAclInformation(
        m_pAcl,
        &inf,
        sizeof(ACL_SIZE_INFORMATION),
        AclSizeInformation
        );

    if (!bRes)
        return FALSE;

    if (pdwBytesInUse)
        *pdwBytesInUse = inf.AclBytesInUse;
    if (pdwBytesFree)
        *pdwBytesFree  = inf.AclBytesFree;

    return bRes;
}




/*   -------------------------------------------------------------------------- 
    | BOOL CNtAcl::OrderAces ( )
    |
    | Orders the ACEs in an ACL according to following
    |
    | { ACEni1, ACEni2, ACEni3.ACEnix | ACEin1, ACEin2, ACEin3.ACEinx  }
    |          (non-inherited)                   (inherited)
    |
    | Non-inherited ACEs are inserted at the beginning of the ACL followed by
    | inherited ACEs. Each group is also ordered according to recommended NT 
    | ACE grouping policy (DENY followed by ALLOW).
    |
    | Returns: [BOOL] TRUE if ACL is valid and grouping succeeded
    |                  FALSE if ACL is invalid and grouping failed.
    |
     --------------------------------------------------------------------------
*/
CNtAcl* CNtAcl::OrderAces ( )
{
    //
    // Verify valid ACL
    //
    if (m_pAcl == 0 || m_dwStatus != NoError)
    {
        return NULL ;
    }

    //
    // Create a new CNtAcl and use the AddAce (which performs ordering).
    //
    int numAces = GetNumAces();
    wmilib::auto_ptr<CNtAcl> pAcl(new CNtAcl(sizeof(ACL)));
    
    if ( NULL == pAcl.get() ) return NULL;
    
    if ( pAcl->GetStatus ( ) != CNtAcl::NoError ) return NULL;

    
    //
    // Loop through all ACEs and add to new ACL via AddAce
    //
    for ( int i = 0; i < numAces; i++ )
    {
        CNtAce* pAce = GetAce(i);
        if ( pAce )
        {
            CDeleteMe<CNtAce> delme (pAce);
            if ( pAcl->AddAce ( pAce  ) == FALSE )
            {
                return NULL;
            }
        }
        else
            return NULL;
    }
    return pAcl.release();
}


//***************************************************************************
//
//  CNtAcl::AddAce
//
//  Adds an ACE to the ACL.
//  Ordering semantics for denial ACEs are handled automatically.
//
//  Parameters:
//  <pAce>      A read-only pointer to the CNtAce to be added.
//
//  Return value:
//  TRUE on success, FALSE on failure.
//
//***************************************************************************
// ok

BOOL CNtAcl::AddAce(CNtAce *pAce)
{
    // Verify we have an ACL and a valid ACE.
    // ======================================

    if (m_pAcl == 0 || m_dwStatus != NoError)
        return FALSE;

    if (pAce->GetStatus() != CNtAce::NoError)
        return FALSE;

    // Inherited aces go after non inherited aces

    bool bInherited = (pAce->GetFlags() & INHERITED_ACE) != 0;
    int iFirstInherited = 0;

    // inherited aces must go after non inherited.  Find out
    // the position of the first inherited ace

    int iCnt;
    for(iCnt = 0; iCnt < m_pAcl->AceCount; iCnt++)
    {
        CNtAce *pAce2 = GetAce(iCnt);
        CDeleteMe<CNtAce> dm(pAce2);
        if (pAce2)
            if((pAce2->GetFlags() & INHERITED_ACE) != 0)
                break;
    }
    iFirstInherited = iCnt;


    // Since we want to add access denial ACEs to the front of the ACL,
    // we have to determine the type of ACE.
    // ================================================================

    DWORD dwIndex;

    if (pAce->GetType() == ACCESS_DENIED_ACE_TYPE)
        dwIndex = (bInherited) ? iFirstInherited : 0;
    else
        dwIndex = (bInherited) ? MAXULONG : iFirstInherited; 

    // Verify that there is enough room in the ACL.
    // ============================================

    DWORD dwRequiredFree = pAce->GetSize();

    DWORD dwFree = 0;
    DWORD dwUsed = 0;
    GetAclSizeInfo(&dwUsed, &dwFree);

    // If we don't have enough room, resize the ACL.
    // =============================================

    if (dwFree < dwRequiredFree)
    {
        BOOL bRes = Resize(dwUsed + dwRequiredFree);

        if (!bRes)
            return FALSE;
    }

    // Now actually add the ACE.
    // =========================

    BOOL bRes = ::AddAce(
        m_pAcl,
        ACL_REVISION,
        dwIndex,                      // Either beginning or end.
        pAce->GetPtr(),         // Get ptr to ACE.
        pAce->GetSize()                       // One ACE only.
        );

    return bRes;
}


//***************************************************************************
//
//  CNtAcl::Resize()
//
//  Expands the size of the ACL to hold more info or reduces the size
//  of the ACL for maximum efficiency after ACL editing is completed.
//
//  Normally, the user should not attempt to resize the ACL to a larger
//  size, as this is automatically handled by AddAce.  However, shrinking
//  the ACL to its minimum size is recommended.
//
//  Parameters:
//  <dwNewSize>     The required new size of the ACL in bytes.  If set to
//                  the class constant MinimumSize (1), then the ACL
//                  is reduced to its minimum size.
//
//  Return value:
//  TRUE on success, FALSE on failure.
//
//***************************************************************************
// ok

BOOL CNtAcl::Resize(DWORD dwNewSize)
{
    if (m_pAcl == 0 || m_dwStatus != NoError)
        return FALSE;

    if (!IsValidAcl(m_pAcl))
        return FALSE;

    // If the ACL cannot be reduced to the requested size,
    // return FALSE.
    // ===================================================

    DWORD dwInUse, dwFree;

    if (!GetAclSizeInfo(&dwInUse, &dwFree))
        return FALSE;

    if (dwNewSize == MinimumSize)       // If user is requesting a 'minimize'
        dwNewSize = dwInUse;

    if (dwNewSize < dwInUse)
        return FALSE;

    // Allocate a new ACL.
    // ===================

    CNtAcl *pNewAcl = new CNtAcl(dwNewSize);

    if (!pNewAcl || pNewAcl->GetStatus() != NoError)
    {
        delete pNewAcl;
        return FALSE;
    }

    // Loop through ACEs and transfer them.
    // ====================================

    for (int i = 0; i < GetNumAces(); i++)
    {
        CNtAce *pAce = GetAce(i);

        if (pAce == NULL)
        {
            delete pNewAcl;
            return FALSE;
        }

        BOOL bRes = pNewAcl->AddAce(pAce);

        if (!bRes)
        {
            DWORD dwLast = GetLastError();
            delete pAce;
            delete pNewAcl;
            return FALSE;
        }

        delete pAce;
    }

    if (!IsValid())
    {
        delete pNewAcl;
        return FALSE;
    }

    // Now transfer the ACL.
    // =====================

    *this = *pNewAcl;
    delete pNewAcl;

    return TRUE;
}


//***************************************************************************
//
//  CNtAcl::CNtAcl
//
//  Alternate constructor which builds the object based on a plain
//  NT ACL.
//
//  Parameters:
//  <pAcl>  Pointer to a read-only ACL.
//
//***************************************************************************
// ok
CNtAcl::CNtAcl(PACL pAcl)
{
    m_pAcl = 0;
    m_dwStatus = NoError;

    if (pAcl == 0)
    {
        m_dwStatus = NullAcl;
        return;
    }

    if (!IsValidAcl(pAcl))
    {
        m_dwStatus = InvalidAcl;
        return;
    }

    m_pAcl = (PACL) new BYTE[pAcl->AclSize];
    if(m_pAcl == NULL)
    {
        m_dwStatus = InternalError;
        return;
    }
    ZeroMemory(m_pAcl, pAcl->AclSize);
    memcpy(m_pAcl, pAcl, pAcl->AclSize);
}




/*
    --------------------------------------------------------------------------
   |
   | Checks to see if the Acl contains an ACE with the specified SID. 
   | The characteristics of the ACE is irrelevant. Only SID comparison applies.
   |
    --------------------------------------------------------------------------
*/
BOOL CNtAcl::ContainsSid ( CNtSid& sid, BYTE& flags )
{
    BOOL bContainsSid = FALSE ;    

    int iNumAces = GetNumAces ( ) ;
    if ( iNumAces < 0 )
    {
        return FALSE ;
    }

    for ( int i = 0 ; i < iNumAces; i++ )
    {
        CNtAce* pAce = GetAce ( i ) ;
        if (pAce)
        {
            CDeleteMe<CNtAce> AceDelete ( pAce ) ;
            
            CNtSid* pSid = pAce->GetSid ( ) ;
            CDeleteMe<CNtSid> SidDelete ( pSid ) ;

            if (pSid && pSid->IsValid())
            {
                if ( EqualSid ( sid.GetPtr ( ), pSid->GetPtr ( ) ) == TRUE )
                {
                    flags = ( BYTE ) pAce->GetFlags ( ) ;
                    bContainsSid = TRUE ;
                    break ;    
                }
            }
        }
    }
    return bContainsSid ;
}


//***************************************************************************
//
//  CNtAcl::GetNumAces
//
//  Return value:
//  Returns the number of ACEs available in the ACL.  Zero is a legal return
//  value. Returns -1 on error
//
//  Aces can be retrieved using GetAce using index values from 0...n-1 where
//  n is the value returned from this function.
//
//***************************************************************************
// ok

int CNtAcl::GetNumAces()
{
    if (m_pAcl == 0)
        return -1;

    ACL_SIZE_INFORMATION inf;

    BOOL bRes = GetAclInformation(
        m_pAcl,
        &inf,
        sizeof(ACL_SIZE_INFORMATION),
        AclSizeInformation
        );

    if (!bRes)
    {
        return -1;
    }

    return (int) inf.AceCount;
}

//***************************************************************************
//
//  CNtAcl destructor
//
//***************************************************************************
// ok

CNtAcl::~CNtAcl()
{
    if (m_pAcl)
        delete m_pAcl;
}


//***************************************************************************
//
//  CNtSecurityDescriptor::GetDacl
//
//  Returns the DACL of the security descriptor.
//
//  Return value:
//  A newly allocated CNtAcl which contains the DACL.   This object
//  is a copy of the DACL and modifications made to it do not affect
//  the security descriptor.  The caller must use operator delete
//  to deallocate the CNtAcl.
//
//  Returns NULL on error or if no DACL is available.
//
//***************************************************************************
// ok

CNtAcl *CNtSecurityDescriptor::GetDacl()
{
    BOOL bDaclPresent = FALSE;
    BOOL bDefaulted;

    PACL pDacl;
    BOOL bRes = GetSecurityDescriptorDacl(
        m_pSD,
        &bDaclPresent,
        &pDacl,
        &bDefaulted
        );

    if (!bRes)
    {
        return 0;
    }

    if (!bDaclPresent)  // No DACL present
        return 0;

    CNtAcl *pNewDacl = new CNtAcl(pDacl);

    return pNewDacl;
}

//***************************************************************************
//
//  CNtSecurityDescriptor::GetDacl
//
//  An alternate method to returns the DACL of the security descriptor.
//  This version uses an existing object instead of returning a
//  dynamically allocated object.
//
//  Parameters:
//  <DestAcl>           A object which will receive the DACL.
//
//  Return value:
//  TRUE on success, FALSE on failure
//
//***************************************************************************

BOOL CNtSecurityDescriptor::GetDacl(CNtAcl &DestAcl)
{
    CNtAcl *pNew = GetDacl();
    if (pNew == 0)
        return FALSE;

    DestAcl = *pNew;
    delete pNew;
    return TRUE;
}

//***************************************************************************
//
//  SNtAbsoluteSD
//
//  SD Helpers
//
//***************************************************************************

SNtAbsoluteSD::SNtAbsoluteSD()
{
    m_pSD = 0;
    m_pDacl = 0;
    m_pSacl = 0;
    m_pOwner = 0;
    m_pPrimaryGroup = 0;
}

SNtAbsoluteSD::~SNtAbsoluteSD()
{
    if (m_pSD)
        delete m_pSD;
    if (m_pDacl)
        delete m_pDacl;
    if (m_pSacl)
        delete m_pSacl;
    if (m_pOwner)
        delete m_pOwner;
    if (m_pPrimaryGroup)
        delete m_pPrimaryGroup;
}


//***************************************************************************
//
//  CNtSecurityDescriptor::GetAbsoluteCopy
//
//  Returns a copy of the current object's internal SD in absolute format.
//  Returns NULL on error.  The memory must be freed with LocalFree().
//
//***************************************************************************
// ok

SNtAbsoluteSD* CNtSecurityDescriptor::GetAbsoluteCopy()
{
    if (m_dwStatus != NoError || m_pSD == 0 || !IsValid())
        return 0;

    // Prepare for conversion.
    // =======================

    DWORD dwSDSize = 0, dwDaclSize = 0, dwSaclSize = 0,
        dwOwnerSize = 0, dwPrimaryGroupSize = 0;

    SNtAbsoluteSD *pNewSD = new SNtAbsoluteSD;
    if (!pNewSD)
        return NULL;

    BOOL bRes = MakeAbsoluteSD(
        m_pSD,
        pNewSD->m_pSD,
        &dwSDSize,
        pNewSD->m_pDacl,
        &dwDaclSize,
        pNewSD->m_pSacl,
        &dwSaclSize,
        pNewSD->m_pOwner,
        &dwOwnerSize,
        pNewSD->m_pPrimaryGroup,
        &dwPrimaryGroupSize
        );

    if (GetLastError() != ERROR_INSUFFICIENT_BUFFER)
    {
        delete pNewSD;
        return 0;
    }

    // Allocate the required buffers and convert.
    // ==========================================

    pNewSD->m_pSD = (PSECURITY_DESCRIPTOR) new BYTE[dwSDSize];
    if(pNewSD->m_pSD == NULL)
    {
        delete pNewSD;
        return NULL;
    }
    ZeroMemory(pNewSD->m_pSD, dwSDSize);

    pNewSD->m_pDacl   = (PACL) new BYTE[dwDaclSize];
    if(pNewSD->m_pDacl == NULL)
    {
        delete pNewSD;
        return NULL;
    }
    ZeroMemory(pNewSD->m_pDacl, dwDaclSize);

    pNewSD->m_pSacl   = (PACL) new BYTE[dwSaclSize];
    if(pNewSD->m_pSacl == NULL)
    {
        delete pNewSD;
        return NULL;
    }
    ZeroMemory(pNewSD->m_pSacl, dwSaclSize);

    pNewSD->m_pOwner  = (PSID) new BYTE[dwOwnerSize];
    if(pNewSD->m_pOwner == NULL)
    {
        delete pNewSD;
        return NULL;
    }
    ZeroMemory(pNewSD->m_pOwner, dwOwnerSize);

    pNewSD->m_pPrimaryGroup  = (PSID) new BYTE[dwPrimaryGroupSize];
    if(pNewSD->m_pPrimaryGroup == NULL)
    {
        delete pNewSD;
        return NULL;
    }
    ZeroMemory(pNewSD->m_pPrimaryGroup, dwPrimaryGroupSize);

    bRes = MakeAbsoluteSD(
        m_pSD,
        pNewSD->m_pSD,
        &dwSDSize,
        pNewSD->m_pDacl,
        &dwDaclSize,
        pNewSD->m_pSacl,
        &dwSaclSize,
        pNewSD->m_pOwner,
        &dwOwnerSize,
        pNewSD->m_pPrimaryGroup,
        &dwPrimaryGroupSize
        );

    if (!bRes)
    {
        delete pNewSD;
        return 0;
    }

    return pNewSD;
}

//***************************************************************************
//
//  CNtSecurityDescriptor::SetFromAbsoluteCopy
//
//  Replaces the current SD from an absolute copy.
//
//  Parameters:
//  <pSrcSD>    A read-only pointer to the absolute SD used as a source.
//
//  Return value:
//  TRUE on success, FALSE on failure.
//
//***************************************************************************
// ok

BOOL CNtSecurityDescriptor::SetFromAbsoluteCopy(
    SNtAbsoluteSD *pSrcSD
    )
{
    if (pSrcSD ==  0 || !IsValidSecurityDescriptor(pSrcSD->m_pSD))
        return FALSE;


    // Ensure that SD is self-relative
    // ===============================

    SECURITY_DESCRIPTOR_CONTROL ctrl;
    DWORD dwRev;

    BOOL bRes = GetSecurityDescriptorControl(
        pSrcSD->m_pSD,
        &ctrl,
        &dwRev
        );

    if (!bRes)
        return FALSE;

    if (ctrl & SE_SELF_RELATIVE)  // Source is not absolute!!
        return FALSE;

    // If here, we are committed to change.
    // ====================================

    if (m_pSD)
    {
        delete m_pSD;
    }
    m_pSD = 0;
    m_dwStatus = NullSD;


    DWORD dwRequired = 0;

    bRes = MakeSelfRelativeSD(
            pSrcSD->m_pSD,
            m_pSD,
            &dwRequired
            );

    if (GetLastError() != ERROR_INSUFFICIENT_BUFFER)
    {
        m_dwStatus = InvalidSD;
        return FALSE;
    }

    m_pSD = new BYTE[dwRequired];
    if (!m_pSD)
    {
        m_dwStatus = InvalidSD;
        return FALSE;
    }

    ZeroMemory(m_pSD, dwRequired);

    bRes = MakeSelfRelativeSD(
              pSrcSD->m_pSD,
              m_pSD,
              &dwRequired
              );

    if (!bRes)
    {
        m_dwStatus = InvalidSD;
        delete m_pSD;
        m_pSD = 0;
        return FALSE;
    }

    m_dwStatus = NoError;
    return TRUE;
}


//***************************************************************************
//
//  CNtSecurityDescriptor::SetDacl
//
//  Sets the DACL of the Security descriptor.
//
//  Parameters:
//  <pSrc>      A read-only pointer to the new DACL to replace the current one.
//
//  Return value:
//  TRUE on success, FALSE on failure.
//
//***************************************************************************

BOOL CNtSecurityDescriptor::SetDacl(CNtAcl *pSrc)
{
    if (m_dwStatus != NoError || m_pSD == 0)
        return FALSE;


    // Since we cannot alter a self-relative SD, we have to make
    // an absolute one, alter it, and then set the current
    // SD based on the absolute one (we keep the self-relative form
    // internally in the m_pSD variable.
    // ============================================================

    SNtAbsoluteSD *pTmp = GetAbsoluteCopy();

    if (pTmp == 0)
        return FALSE;

    BOOL bRes = ::SetSecurityDescriptorDacl(
        pTmp->m_pSD,
        TRUE,
        pSrc->GetPtr(),
        FALSE
        );

    if (!bRes)
    {
        delete pTmp;
        return FALSE;
    }

    bRes = SetFromAbsoluteCopy(pTmp);
    delete pTmp;

    return TRUE;
}


//***************************************************************************
//
//  CNtSecurityDescriptor constructor
//
//  A default constructor creates a no-access security descriptor.
//
//***************************************************************************
//  ok

CNtSecurityDescriptor::CNtSecurityDescriptor()
{
    m_pSD = 0;
    m_dwStatus = NoError;

    PSECURITY_DESCRIPTOR pTmp = new BYTE[SECURITY_DESCRIPTOR_MIN_LENGTH];
    if (!pTmp)
    {
        delete pTmp;
        m_dwStatus = InvalidSD;
        return;
    }
    
    ZeroMemory(pTmp, SECURITY_DESCRIPTOR_MIN_LENGTH);

    if (!InitializeSecurityDescriptor(pTmp, SECURITY_DESCRIPTOR_REVISION))
    {
        delete pTmp;
        m_dwStatus = InvalidSD;
        return;
    }

    DWORD dwRequired = 0;

    BOOL bRes = MakeSelfRelativeSD(
            pTmp,
            m_pSD,
            &dwRequired
            );

    if (GetLastError() != ERROR_INSUFFICIENT_BUFFER)
    {
        m_dwStatus = InvalidSD;
        delete pTmp;
        return;
    }

    m_pSD = new BYTE[dwRequired];
    if (!m_pSD)
    {
        m_dwStatus = InvalidSD;
        delete pTmp;
        return;
    }

    ZeroMemory(m_pSD, dwRequired);

    bRes = MakeSelfRelativeSD(
              pTmp,
              m_pSD,
              &dwRequired
              );

    if (!bRes)
    {
        m_dwStatus = InvalidSD;
        delete m_pSD;
        m_pSD = 0;
        delete pTmp;
        return;
    }

    delete pTmp;
    m_dwStatus = NoError;
}


//***************************************************************************
//
//  CNtSecurityDescriptor::GetSize
//
//  Returns the size in bytes of the internal SD.
//
//***************************************************************************
//  ok

DWORD CNtSecurityDescriptor::GetSize()
{
    if (m_pSD == 0 || m_dwStatus != NoError)
        return 0;

    return GetSecurityDescriptorLength(m_pSD);
}


//***************************************************************************
//
//  CNtSecurityDescriptor copy constructor
//
//***************************************************************************
// ok

CNtSecurityDescriptor::CNtSecurityDescriptor(CNtSecurityDescriptor &Src)
{
    m_pSD = 0;
    m_dwStatus = NoError;
    *this = Src;
}

//********************************************************************