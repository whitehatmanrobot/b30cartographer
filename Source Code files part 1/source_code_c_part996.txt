ntext,
					a_InParams,
					a_Sink
				) ;
			}
			else 
			{
				if ( SUCCEEDED ( t_Result ) )
				{
					IWbemServices *t_Service = ( IWbemServices * ) t_Proxy ;

					// Set cloaking on the proxy
					// =========================

					DWORD t_ImpersonationLevel = DecoupledProviderSubSystem_Globals :: GetCurrentImpersonationLevel () ;

					t_Result = DecoupledProviderSubSystem_Globals :: SetCloaking (

						t_Service ,
						RPC_C_AUTHN_LEVEL_CONNECT , 
						t_ImpersonationLevel
					) ;

					if ( SUCCEEDED ( t_Result ) )
					{
						BSTR t_ObjectPath = SysAllocString ( a_ObjectPath ) ;
						BSTR t_MethodName = SysAllocString ( a_MethodName ) ;
						if ( t_ObjectPath && t_MethodName )
						{
							t_Result = t_Service->ExecMethodAsync (

								a_ObjectPath,
								a_MethodName,
								a_Flags,
								a_Context,
								a_InParams,
								a_Sink
							) ;
						}
						else
						{
							t_Result = WBEM_E_OUT_OF_MEMORY ;
						}

						if ( t_ObjectPath )
						{
							SysFreeString ( t_ObjectPath ) ;
						}

						if ( t_MethodName )
						{
							SysFreeString ( t_MethodName ) ;
						}
					}

					HRESULT t_TempResult = DecoupledProviderSubSystem_Globals :: RevertProxyState ( m_ProxyContainer , ProxyIndex_Stub_IWbemServices , t_Proxy , t_Revert ) ;
				}
			}

			DecoupledProviderSubSystem_Globals :: EndImpersonation ( t_OldContext , t_OldSecurity , t_Impersonating ) ;
		}
	}

	InterlockedDecrement ( & m_InProgress ) ;

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_IWbemServices_Stub :: Initialize (

	LPWSTR a_User,
	LONG a_Flags,
	LPWSTR a_Namespace,
	LPWSTR a_Locale,
	IWbemServices *a_Core ,
	IWbemContext *a_Context ,
	IWbemProviderInitSink *a_Sink
)
{
	return WBEM_E_NOT_AVAILABLE ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_IWbemServices_Stub :: Shutdown (

	LONG a_Flags ,
	ULONG a_MaxMilliSeconds ,
	IWbemContext *a_Context
)
{
	HRESULT t_Result = S_OK ;

	InterlockedIncrement ( & m_GateClosed ) ;

	bool t_Acquired = false ;
	while ( ! t_Acquired )
	{
		if ( m_InProgress == 0 )
		{
			t_Acquired = true ;
			break ;
		}

		::Sleep(0);
	}

	return t_Result ;
}

#if 0
/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_IWbemServices_Stub :: Open (

    const BSTR a_Scope ,
    const BSTR a_Selector ,
    long a_Flags ,
    IWbemContext *a_Context ,
    IWbemServicesEx **a_ScopeObject ,
    IWbemCallResultEx **a_Result
)
{
	HRESULT t_Result = S_OK ;

	InterlockedIncrement ( & m_InProgress ) ;

	if ( m_GateClosed == 1 )
	{
		t_Result = WBEM_E_SHUTTING_DOWN ;
	}
	else
	{
		if ( m_CoreService )
		{
			BOOL t_Impersonating = FALSE ;
			IUnknown *t_OldContext = NULL ;
			IServerSecurity *t_OldSecurity = NULL ;

			t_Result = DecoupledProviderSubSystem_Globals :: BeginCallbackImpersonation ( t_OldContext , t_OldSecurity , t_Impersonating ) ;
			if ( SUCCEEDED ( t_Result ) ) 
			{
				BOOL t_Revert = FALSE ;
				IUnknown *t_Proxy = NULL ;

				t_Result = DecoupledProviderSubSystem_Globals :: SetProxyState ( m_ProxyContainer , ProxyIndex_Stub_IWbemServices , IID_IWbemServicesEx , m_CoreService , t_Proxy , t_Revert ) ;
				if ( t_Result == WBEM_E_NOT_FOUND )
				{
					t_Result = m_CoreService->Open (

						a_Scope ,
						a_Selector ,
						a_Flags ,
						a_Context ,
						a_ScopeObject ,
						a_Result
					) ;
				}
				else 
				{
					if ( SUCCEEDED ( t_Result ) )
					{
						IWbemServicesEx *t_ServiceEx = ( IWbemServicesEx * ) t_Proxy ;

						// Set cloaking on the proxy
						// =========================

						DWORD t_ImpersonationLevel = DecoupledProviderSubSystem_Globals :: GetCurrentImpersonationLevel () ;

						t_Result = DecoupledProviderSubSystem_Globals :: SetCloaking (

							t_ServiceEx ,
							RPC_C_AUTHN_LEVEL_CONNECT , 
							t_ImpersonationLevel
						) ;

						if ( SUCCEEDED ( t_Result ) )
						{
							BSTR t_Scope = SysAllocString ( a_Scope ) ;
							BSTR t_Selector = SysAllocString ( a_Selector ) ;
							if ( t_Scope && t_Selector )
							{
								t_Result = t_ServiceEx->Open (

									t_Scope ,
									t_Selector ,
									a_Flags ,
									a_Context ,
									a_ScopeObject ,
									a_Result
								) ;
							}
							else
							{
								t_Result = WBEM_E_OUT_OF_MEMORY ;
							}

							if ( t_Scope )
							{
								SysFreeString ( t_Scope ) ;
							}

							if ( t_Selector )
							{
								SysFreeString ( t_Selector ) ;
							}
						}

						HRESULT t_TempResult = DecoupledProviderSubSystem_Globals :: RevertProxyState ( m_ProxyContainer , ProxyIndex_Stub_IWbemServices , t_Proxy , t_Revert ) ;
					}
				}

				DecoupledProviderSubSystem_Globals :: EndImpersonation ( t_OldContext , t_OldSecurity , t_Impersonating ) ;
			}
		}
		else
		{
			t_Result = WBEM_E_NOT_AVAILABLE ;
		}
	}

	InterlockedDecrement ( & m_InProgress ) ;

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_IWbemServices_Stub :: OpenAsync (

    const BSTR a_Scope,
    const BSTR a_Selector,
    long a_Flags,
    IWbemContext *a_Context,
    IWbemObjectSinkEx *a_Sink
)
{
	HRESULT t_Result = S_OK ;

	InterlockedIncrement ( & m_InProgress ) ;

	if ( m_GateClosed == 1 )
	{
		t_Result = WBEM_E_SHUTTING_DOWN ;
	}
	else
	{
		if ( m_CoreService )
		{
			BOOL t_Impersonating = FALSE ;
			IUnknown *t_OldContext = NULL ;
			IServerSecurity *t_OldSecurity = NULL ;

			t_Result = DecoupledProviderSubSystem_Globals :: BeginCallbackImpersonation ( t_OldContext , t_OldSecurity , t_Impersonating ) ;
			if ( SUCCEEDED ( t_Result ) ) 
			{
				BOOL t_Revert = FALSE ;
				IUnknown *t_Proxy = NULL ;

				t_Result = DecoupledProviderSubSystem_Globals :: SetProxyState ( m_ProxyContainer , ProxyIndex_Stub_IWbemServices , IID_IWbemServicesEx , m_CoreService , t_Proxy , t_Revert ) ;
				if ( t_Result == WBEM_E_NOT_FOUND )
				{
					t_Result = m_CoreService->OpenAsync (

						a_Scope,
						a_Selector,
						a_Flags,
						a_Context,
						a_Sink
					) ;
				}
				else 
				{
					if ( SUCCEEDED ( t_Result ) )
					{
						IWbemServicesEx *t_ServiceEx = ( IWbemServicesEx * ) t_Proxy ;

						// Set cloaking on the proxy
						// =========================

						DWORD t_ImpersonationLevel = DecoupledProviderSubSystem_Globals :: GetCurrentImpersonationLevel () ;

						t_Result = DecoupledProviderSubSystem_Globals :: SetCloaking (

							t_ServiceEx ,
							RPC_C_AUTHN_LEVEL_CONNECT , 
							t_ImpersonationLevel
						) ;

						if ( SUCCEEDED ( t_Result ) )
						{
							BSTR t_Scope = SysAllocString ( a_Scope ) ;
							BSTR t_Selector = SysAllocString ( a_Selector ) ;
							if ( t_Scope && t_Selector )
							{
								t_Result = t_ServiceEx->OpenAsync (

									t_Scope,
									t_Selector,
									a_Flags,
									a_Context,
									a_Sink
								) ;
							}
							else
							{
								t_Result = WBEM_E_OUT_OF_MEMORY ;
							}

							if ( t_Scope )
							{
								SysFreeString ( t_Scope ) ;
							}

							if ( t_Selector )
							{
								SysFreeString ( t_Selector ) ;
							}
						}

						HRESULT t_TempResult = DecoupledProviderSubSystem_Globals :: RevertProxyState ( m_ProxyContainer , ProxyIndex_Stub_IWbemServices , t_Proxy , t_Revert ) ;
					}
				}

				DecoupledProviderSubSystem_Globals :: EndImpersonation ( t_OldContext , t_OldSecurity , t_Impersonating ) ;
			}
		}
		else
		{
			t_Result = WBEM_E_NOT_AVAILABLE ;
		}
	}

	InterlockedDecrement ( & m_InProgress ) ;

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_IWbemServices_Stub :: Add (

	const BSTR a_ObjectPath ,
    long a_Flags ,
    IWbemContext *a_Context ,
    IWbemCallResultEx **a_CallResult
)
{
	HRESULT t_Result = S_OK ;

	InterlockedIncrement ( & m_InProgress ) ;

	if ( m_GateClosed == 1 )
	{
		t_Result = WBEM_E_SHUTTING_DOWN ;
	}
	else
	{
		if ( m_CoreService )
		{
			BOOL t_Impersonating = FALSE ;
			IUnknown *t_OldContext = NULL ;
			IServerSecurity *t_OldSecurity = NULL ;

			t_Result = DecoupledProviderSubSystem_Globals :: BeginCallbackImpersonation ( t_OldContext , t_OldSecurity , t_Impersonating ) ;
			if ( SUCCEEDED ( t_Result ) ) 
			{
				BOOL t_Revert = FALSE ;
				IUnknown *t_Proxy = NULL ;

				t_Result = DecoupledProviderSubSystem_Globals :: SetProxyState ( m_ProxyContainer , ProxyIndex_Stub_IWbemServices , IID_IWbemServicesEx , m_CoreService , t_Proxy , t_Revert ) ;
				if ( t_Result == WBEM_E_NOT_FOUND )
				{
					t_Result = m_CoreService->Add (

						a_ObjectPath ,
						a_Flags ,
						a_Context ,
						a_CallResult
					) ;
				}
				else 
				{
					if ( SUCCEEDED ( t_Result ) )
					{
						IWbemServicesEx *t_ServiceEx = ( IWbemServicesEx * ) t_Proxy ;

						// Set cloaking on the proxy
						// =========================

						DWORD t_ImpersonationLevel = DecoupledProviderSubSystem_Globals :: GetCurrentImpersonationLevel () ;

						t_Result = DecoupledProviderSubSystem_Globals :: SetCloaking (

							t_ServiceEx ,
							RPC_C_AUTHN_LEVEL_CONNECT , 
							t_ImpersonationLevel
						) ;

						if ( SUCCEEDED ( t_Result ) )
						{
							BSTR t_ObjectPath = SysAllocString ( a_ObjectPath ) ;
							if ( t_ObjectPath )
							{
								t_Result = t_ServiceEx->Add (

									t_ObjectPath ,
									a_Flags ,
									a_Context ,
									a_CallResult
								) ;

								SysFreeString ( t_ObjectPath ) ;
							}
							else
							{
								t_Result = WBEM_E_OUT_OF_MEMORY ;
							}
						}

						HRESULT t_TempResult = DecoupledProviderSubSystem_Globals :: RevertProxyState ( m_ProxyContainer , ProxyIndex_Stub_IWbemServices , t_Proxy , t_Revert ) ;
					}
				}

				DecoupledProviderSubSystem_Globals :: EndImpersonation ( t_OldContext , t_OldSecurity , t_Impersonating ) ;
			}
		}
		else
		{
			t_Result = WBEM_E_NOT_AVAILABLE ;
		}
	}

	InterlockedDecrement ( & m_InProgress ) ;

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_IWbemServices_Stub :: AddAsync (

    const BSTR a_ObjectPath ,
    long a_Flags ,
    IWbemContext *a_Context ,
    IWbemObjectSink *a_Sink
)
{
	HRESULT t_Result = S_OK ;

	InterlockedIncrement ( & m_InProgress ) ;

	if ( m_GateClosed == 1 )
	{
		t_Result = WBEM_E_SHUTTING_DOWN ;
	}
	else
	{
		if ( m_CoreService )
		{
			BOOL t_Impersonating = FALSE ;
			IUnknown *t_OldContext = NULL ;
			IServerSecurity *t_OldSecurity = NULL ;

			t_Result = DecoupledProviderSubSystem_Globals :: BeginCallbackImpersonation ( t_OldContext , t_OldSecurity , t_Impersonating ) ;
			if ( SUCCEEDED ( t_Result ) ) 
			{
				BOOL t_Revert = FALSE ;
				IUnknown *t_Proxy = NULL ;

				t_Result = DecoupledProviderSubSystem_Globals :: SetProxyState ( m_ProxyContainer , ProxyIndex_Stub_IWbemServices , IID_IWbemServicesEx , m_CoreService , t_Proxy , t_Revert ) ;
				if ( t_Result == WBEM_E_NOT_FOUND )
				{
					t_Result = m_CoreService->AddAsync (

						a_ObjectPath,
						a_Flags,
						a_Context,
						a_Sink
					) ;
				}
				else 
				{
					if ( SUCCEEDED ( t_Result ) )
					{
						IWbemServicesEx *t_ServiceEx = ( IWbemServicesEx * ) t_Proxy ;

						// Set cloaking on the proxy
						// =========================

						DWORD t_ImpersonationLevel = DecoupledProviderSubSystem_Globals :: GetCurrentImpersonationLevel () ;

						t_Result = DecoupledProviderSubSystem_Globals :: SetCloaking (

							t_ServiceEx ,
							RPC_C_AUTHN_LEVEL_CONNECT , 
							t_ImpersonationLevel
						) ;

						if ( SUCCEEDED ( t_Result ) )
						{
							BSTR t_ObjectPath = SysAllocString ( a_ObjectPath ) ;
							if ( t_ObjectPath )
							{
								t_Result = t_ServiceEx->AddAsync (

									a_ObjectPath,
									a_Flags,
									a_Context,
									a_Sink
								) ;

								SysFreeString ( t_ObjectPath ) ;
							}
							else
							{
								t_Result = WBEM_E_OUT_OF_MEMORY ;
							}
						}

						HRESULT t_TempResult = DecoupledProviderSubSystem_Globals :: RevertProxyState ( m_ProxyContainer , ProxyIndex_Stub_IWbemServices , t_Proxy , t_Revert ) ;
					}
				}

				DecoupledProviderSubSystem_Globals :: EndImpersonation ( t_OldContext , t_OldSecurity , t_Impersonating ) ;
			}
		}
		else
		{
			t_Result = WBEM_E_NOT_AVAILABLE ;
		}
	}

	InterlockedDecrement ( & m_InProgress ) ;

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_IWbemServices_Stub :: Remove ( 

	const BSTR a_ObjectPath ,
    long a_Flags ,
    IWbemContext *a_Context ,
    IWbemCallResultEx **a_CallResult
)
{
	HRESULT t_Result = S_OK ;

	InterlockedIncrement ( & m_InProgress ) ;

	if ( m_GateClosed == 1 )
	{
		t_Result = WBEM_E_SHUTTING_DOWN ;
	}
	else
	{
		if ( m_CoreService )
		{
			BOOL t_Impersonating = FALSE ;
			IUnknown *t_OldContext = NULL ;
			IServerSecurity *t_OldSecurity = NULL ;

			t_Result = DecoupledProviderSubSystem_Globals :: BeginCallbackImpersonation ( t_OldContext , t_OldSecurity , t_Impersonating ) ;
			if ( SUCCEEDED ( t_Result ) ) 
			{
				BOOL t_Revert = FALSE ;
				IUnknown *t_Proxy = NULL ;

				t_Result = DecoupledProviderSubSystem_Globals :: SetProxyState ( m_ProxyContainer , ProxyIndex_Stub_IWbemServices , IID_IWbemServicesEx , m_CoreService , t_Proxy , t_Revert ) ;
				if ( t_Result == WBEM_E_NOT_FOUND )
				{
					t_Result = m_CoreService->Remove (

						a_ObjectPath,
						a_Flags,
						a_Context,
						a_CallResult
					) ;
				}
				else 
				{
					if ( SUCCEEDED ( t_Result ) )
					{
						IWbemServicesEx *t_ServiceEx = ( IWbemServicesEx * ) t_Proxy ;

						// Set cloaking on the proxy
						// =========================

						DWORD t_ImpersonationLevel = DecoupledProviderSubSystem_Globals :: GetCurrentImpersonationLevel () ;

						t_Result = DecoupledProviderSubSystem_Globals :: SetCloaking (

							t_ServiceEx ,
							RPC_C_AUTHN_LEVEL_CONNECT , 
							t_ImpersonationLevel
						) ;

						if ( SUCCEEDED ( t_Result ) )
						{
							BSTR t_ObjectPath = SysAllocString ( a_ObjectPath ) ;
							if ( t_ObjectPath )
							{
								t_Result = t_ServiceEx->Remove (

									t_ObjectPath,
									a_Flags,
									a_Context,
									a_CallResult
								) ;

								SysFreeString ( t_ObjectPath ) ;
							}
							else
							{
								t_Result = WBEM_E_OUT_OF_MEMORY ;
							}
						}

						HRESULT t_TempResult = DecoupledProviderSubSystem_Globals :: RevertProxyState ( m_ProxyContainer , ProxyIndex_Stub_IWbemServices , t_Proxy , t_Revert ) ;
					}
				}

				DecoupledProviderSubSystem_Globals :: EndImpersonation ( t_OldContext , t_OldSecurity , t_Impersonating ) ;
			}
		}
		else
		{
			t_Result = WBEM_E_NOT_AVAILABLE ;
		}
	}

	InterlockedDecrement ( & m_InProgress ) ;

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_IWbemServices_Stub :: RemoveAsync ( 

    const BSTR a_ObjectPath ,
    long a_Flags ,
    IWbemContext *a_Context ,
    IWbemObjectSink *a_Sink 
)
{
	HRESULT t_Result = S_OK ;

	InterlockedIncrement ( & m_InProgress ) ;

	if ( m_GateClosed == 1 )
	{
		t_Result = WBEM_E_SHUTTING_DOWN ;
	}
	else
	{
		if ( m_CoreService )
		{
			BOOL t_Impersonating = FALSE ;
			IUnknown *t_OldContext = NULL ;
			IServerSecurity *t_OldSecurity = NULL ;

			t_Result = DecoupledProviderSubSystem_Globals :: BeginCallbackImpersonation ( t_OldContext , t_OldSecurity , t_Impersonating ) ;
			if ( SUCCEEDED ( t_Result ) ) 
			{
				BOOL t_Revert = FALSE ;
				IUnknown *t_Proxy = NULL ;

				t_Result = DecoupledProviderSubSystem_Globals :: SetProxyState ( m_ProxyContainer , ProxyIndex_Stub_IWbemServices , IID_IWbemServicesEx , m_CoreService , t_Proxy , t_Revert ) ;
				if ( t_Result == WBEM_E_NOT_FOUND )
				{
					t_Result = m_CoreService->RemoveAsync (

						a_ObjectPath,
						a_Flags,
						a_Context,
						a_Sink
					) ;
				}
				else 
				{
					if ( SUCCEEDED ( t_Result ) )
					{
						IWbemServicesEx *t_ServiceEx = ( IWbemServicesEx * ) t_Proxy ;

						// Set cloaking on the proxy
						// =========================

						DWORD t_ImpersonationLevel = DecoupledProviderSubSystem_Globals :: GetCurrentImpersonationLevel () ;

						t_Result = DecoupledProviderSubSystem_Globals :: SetCloaking (

							t_ServiceEx ,
							RPC_C_AUTHN_LEVEL_CONNECT , 
							t_ImpersonationLevel
						) ;

						if ( SUCCEEDED ( t_Result ) )
						{
							BSTR t_ObjectPath = SysAllocString ( a_ObjectPath ) ;
							if ( t_ObjectPath )
							{
								t_Result = t_ServiceEx->RemoveAsync (

									t_ObjectPath,
									a_Flags,
									a_Context,
									a_Sink
								) ;

								SysFreeString ( t_ObjectPath ) ;
							}
							else
							{
								t_Result = WBEM_E_OUT_OF_MEMORY ;
							}
						}

						HRESULT t_TempResult = DecoupledProviderSubSystem_Globals :: RevertProxyState ( m_ProxyContainer , ProxyIndex_Stub_IWbemServices , t_Proxy , t_Revert ) ;
					}
				}

				DecoupledProviderSubSystem_Globals :: EndImpersonation ( t_OldContext , t_OldSecurity , t_Impersonating ) ;
			}
		}
		else
		{
			t_Result = WBEM_E_NOT_AVAILABLE ;
		}
	}

	InterlockedDecrement ( & m_InProgress ) ;

	return t_Result ;
}


/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_IWbemServices_Stub :: RefreshObject ( 

    IWbemClassObject **a_Target ,
    long a_Flags ,
    IWbemContext *a_Context ,
    IWbemCallResultEx **a_CallResult
)
{
	HRESULT t_Result = S_OK ;

	InterlockedIncrement ( & m_InProgress ) ;

	if ( m_GateClosed == 1 )
	{
		t_Result = WBEM_E_SHUTTING_DOWN ;
	}
	else
	{
		if ( m_CoreService )
		{
			BOOL t_Impersonating = FALSE ;
			IUnknown *t_OldContext = NULL ;
			IServerSecurity *t_OldSecurity = NULL ;

			t_Result = DecoupledProviderSubSystem_Globals :: BeginCallbackImpersonation ( t_OldContext , t_OldSecurity , t_Impersonating ) ;
			if ( SUCCEEDED ( t_Result ) ) 
			{
				BOOL t_Revert = FALSE ;
				IUnknown *t_Proxy = NULL ;

				t_Result = DecoupledProviderSubSystem_Globals :: SetProxyState ( m_ProxyContainer , ProxyIndex_Stub_IWbemServices , IID_IWbemServicesEx , m_CoreService , t_Proxy , t_Revert ) ;
				if ( t_Result == WBEM_E_NOT_FOUND )
				{
					t_Result = m_CoreService->RefreshObject (

						a_Target ,
						a_Flags,
						a_Context,
						a_CallResult
					) ;
				}
				else 
				{
					if ( SUCCEEDED ( t_Result ) )
					{
						IWbemServicesEx *t_ServiceEx = ( IWbemServicesEx * ) t_Proxy ;

						// Set cloaking on the proxy
						// =========================

						DWORD t_ImpersonationLevel = DecoupledProviderSubSystem_Globals :: GetCurrentImpersonationLevel () ;

						t_Result = DecoupledProviderSubSystem_Globals :: SetCloaking (

							t_ServiceEx ,
							RPC_C_AUTHN_LEVEL_CONNECT , 
							t_ImpersonationLevel
						) ;

						if ( SUCCEEDED ( t_Result ) )
						{
							t_Result = t_ServiceEx->RefreshObject (

								a_Target ,
								a_Flags,
								a_Context,
								a_CallResult
							) ;
						}

						HRESULT t_TempResult = DecoupledProviderSubSystem_Globals :: RevertProxyState ( m_ProxyContainer , ProxyIndex_Stub_IWbemServices , t_Proxy , t_Revert ) ;
					}
				}

				DecoupledProviderSubSystem_Globals :: EndImpersonation ( t_OldContext , t_OldSecurity , t_Impersonating ) ;
			}
		}
		else
		{
			t_Result = WBEM_E_NOT_AVAILABLE ;
		}
	}

	InterlockedDecrement ( & m_InProgress ) ;

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_IWbemServices_Stub :: RefreshObjectAsync ( 

    IWbemClassObject **a_Target ,
    long a_Flags ,
    IWbemContext *a_Context ,
    IWbemObjectSinkEx *a_Sink
)
{
	HRESULT t_Result = S_OK ;

	InterlockedIncrement ( & m_InProgress ) ;

	if ( m_GateClosed == 1 )
	{
		t_Result = WBEM_E_SHUTTING_DOWN ;
	}
	else
	{
		if ( m_CoreService )
		{
			BOOL t_Impersonating = FALSE ;
			IUnknown *t_OldContext = NULL ;
			IServerSecurity *t_OldSecurity = NULL ;

			t_Result = DecoupledProviderSubSystem_Globals :: BeginCallbackImpersonation ( t_OldContext , t_OldSecurity , t_Impersonating ) ;
			if ( SUCCEEDED ( t_Result ) ) 
			{
				BOOL t_Revert = FALSE ;
				IUnknown *t_Proxy = NULL ;

				t_Result = DecoupledProviderSubSystem_Globals :: SetProxyState ( m_ProxyContainer , ProxyIndex_Stub_IWbemServices , IID_IWbemServicesEx , m_CoreService , t_Proxy , t_Revert ) ;
				if ( t_Result == WBEM_E_NOT_FOUND )
				{
					t_Result = m_CoreService->RefreshObjectAsync (

						a_Target ,
						a_Flags,
						a_Context,
						a_Sink
					) ;
				}
				else 
				{
					if ( SUCCEEDED ( t_Result ) )
					{
						IWbemServicesEx *t_ServiceEx = ( IWbemServicesEx * ) t_Proxy ;

						// Set cloaking on the proxy
						// =========================

						DWORD t_ImpersonationLevel = DecoupledProviderSubSystem_Globals :: GetCurrentImpersonationLevel () ;

						t_Result = DecoupledProviderSubSystem_Globals :: SetCloaking (

							t_ServiceEx ,
							RPC_C_AUTHN_LEVEL_CONNECT , 
							t_ImpersonationLevel
						) ;

						if ( SUCCEEDED ( t_Result ) )
						{
							t_Result = t_ServiceEx->RefreshObjectAsync (

								a_Target ,
								a_Flags,
								a_Context,
								a_Sink
							) ;
						}

						HRESULT t_TempResult = DecoupledProviderSubSystem_Globals :: RevertProxyState ( m_ProxyContainer , ProxyIndex_Stub_IWbemServices , t_Proxy , t_Revert ) ;
					}
				}

				DecoupledProviderSubSystem_Globals :: EndImpersonation ( t_OldContext , t_OldSecurity , t_Impersonating ) ;
			}
		}
		else
		{
			t_Result = WBEM_E_NOT_AVAILABLE ;
		}
	}

	InterlockedDecrement ( & m_InProgress ) ;

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_IWbemServices_Stub :: RenameObject (

    const BSTR a_OldObjectPath ,
    const BSTR a_NewObjectPath ,
    long a_Flags ,
    IWbemContext *a_Context ,
    IWbemCallResultEx **a_CallResult
)
{
	HRESULT t_Result = S_OK ;

	InterlockedIncrement ( & m_InProgress ) ;

	if ( m_GateClosed == 1 )
	{
		t_Result = WBEM_E_SHUTTING_DOWN ;
	}
	else
	{
		if ( m_CoreService )
		{
			BOOL t_Impersonating = FALSE ;
			IUnknown *t_OldContext = NULL ;
			IServerSecurity *t_OldSecurity = NULL ;

			t_Result = DecoupledProviderSubSystem_Globals :: BeginCallbackImpersonation ( t_OldContext , t_OldSecurity , t_Impersonating ) ;
			if ( SUCCEEDED ( t_Result ) ) 
			{
				BOOL t_Revert = FALSE ;
				IUnknown *t_Proxy = NULL ;

				t_Result = DecoupledProviderSubSystem_Globals :: SetProxyState ( m_ProxyContainer , ProxyIndex_Stub_IWbemServices , IID_IWbemServicesEx , m_CoreService , t_Proxy , t_Revert ) ;
				if ( t_Result == WBEM_E_NOT_FOUND )
				{
					t_Result = m_CoreService->RenameObject (

						a_OldObjectPath ,
						a_NewObjectPath ,
						a_Flags,
						a_Context,
						a_CallResult
					) ;
				}
				else 
				{
					if ( SUCCEEDED ( t_Result ) )
					{
						IWbemServicesEx *t_ServiceEx = ( IWbemServicesEx * ) t_Proxy ;

						// Set cloaking on the proxy
						// =========================

						DWORD t_ImpersonationLevel = DecoupledProviderSubSystem_Globals :: GetCurrentImpersonationLevel () ;

						t_Result = DecoupledProviderSubSystem_Globals :: SetCloaking (

							t_ServiceEx ,
							RPC_C_AUTHN_LEVEL_CONNECT , 
							t_ImpersonationLevel
						) ;

						if ( SUCCEEDED ( t_Result ) )
						{
							BSTR t_OldObjectPath = SysAllocString ( a_OldObjectPath ) ;
							BSTR t_NewObjectPath = SysAllocString ( a_NewObjectPath ) ;
							if ( t_OldObjectPath && t_NewObjectPath )
							{
								t_Result = t_ServiceEx->RenameObject (

									t_OldObjectPath ,
									t_NewObjectPath ,
									a_Flags,
									a_Context,
									a_CallResult
								) ;
							}
							else
							{
								t_Result = WBEM_E_OUT_OF_MEMORY ;
							}

							if ( t_OldObjectPath )
							{
								SysFreeString ( t_OldObjectPath ) ;
							}

							if ( t_NewObjectPath )
							{
								SysFreeString ( t_NewObjectPath ) ;
							}
						}

						HRESULT t_TempResult = DecoupledProviderSubSystem_Globals :: RevertProxyState ( m_ProxyContainer , ProxyIndex_Stub_IWbemServices , t_Proxy , t_Revert ) ;
					}
				}

				DecoupledProviderSubSystem_Globals :: EndImpersonation ( t_OldContext , t_OldSecurity , t_Impersonating ) ;
			}
		}
		else
		{
			t_Result = WBEM_E_NOT_AVAILABLE ;
		}
	}

	InterlockedDecrement ( & m_InProgress ) ;

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_IWbemServices_Stub :: RenameObjectAsync (

    const BSTR a_OldObjectPath ,
    const BSTR a_NewObjectPath ,
    long a_Flags ,
    IWbemContext *a_Context ,
    IWbemObjectSink *a_Sink
)
{
	HRESULT t_Result = S_OK ;

	InterlockedIncrement ( & m_InProgress ) ;

	if ( m_GateClosed == 1 )
	{
		t_Result = WBEM_E_SHUTTING_DOWN ;
	}
	else
	{
		if ( m_CoreService )
		{
			BOOL t_Impersonating = FALSE ;
			IUnknown *t_OldContext = NULL ;
			IServerSecurity *t_OldSecurity = NULL ;

			t_Result = DecoupledProviderSubSystem_Globals :: BeginCallbackImpersonation ( t_OldContext , t_OldSecurity , t_Impersonating ) ;
			if ( SUCCEEDED ( t_Result ) ) 
			{
				BOOL t_Revert = FALSE ;
				IUnknown *t_Proxy = NULL ;

				t_Result = DecoupledProviderSubSystem_Globals :: SetProxyState ( m_ProxyContainer , ProxyIndex_Stub_IWbemServices , IID_IWbemServicesEx , m_CoreService , t_Proxy , t_Revert ) ;
				if ( t_Result == WBEM_E_NOT_FOUND )
				{
					t_Result = m_CoreService->RenameObjectAsync (

						a_OldObjectPath ,
						a_NewObjectPath ,
						a_Flags,
						a_Context,
						a_Sink
					) ;
				}
				else 
				{
					if ( SUCCEEDED ( t_Result ) )
					{
						IWbemServicesEx *t_ServiceEx = ( IWbemServicesEx * ) t_Proxy ;

						// Set cloaking on the proxy
						// =========================

						DWORD t_ImpersonationLevel = DecoupledProviderSubSystem_Globals :: GetCurrentImpersonationLevel () ;

						t_Result = DecoupledProviderSubSystem_Globals :: SetCloaking (

							t_ServiceEx ,
							RPC_C_AUTHN_LEVEL_CONNECT , 
							t_ImpersonationLevel
						) ;

						if ( SUCCEEDED ( t_Result ) )
						{
							BSTR t_OldObjectPath = SysAllocString ( a_OldObjectPath ) ;
							BSTR t_NewObjectPath = SysAllocString ( a_NewObjectPath ) ;
							if ( t_OldObjectPath && t_NewObjectPath )
							{
								t_Result = t_ServiceEx->RenameObjectAsync (

									t_OldObjectPath ,
									t_NewObjectPath ,
									a_Flags,
									a_Context,
									a_Sink
								) ;
							}
							else
							{
								t_Result = WBEM_E_OUT_OF_MEMORY ;
							}

							if ( t_OldObjectPath )
							{
								SysFreeString ( t_OldObjectPath ) ;
							}

							if ( t_NewObjectPath )
							{
								SysFreeString ( t_NewObjectPath ) ;
							}
						}

						HRESULT t_TempResult = DecoupledProviderSubSystem_Globals :: RevertProxyState ( m_ProxyContainer , ProxyIndex_Stub_IWbemServices , t_Proxy , t_Revert ) ;
					}
				}

				DecoupledProviderSubSystem_Globals :: EndImpersonation ( t_OldContext , t_OldSecurity , t_Impersonating ) ;
			}
		}
		else
		{
			t_Result = WBEM_E_NOT_AVAILABLE ;
		}
	}

	InterlockedDecrement ( & m_InProgress ) ;

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_IWbemServices_Stub :: DeleteObject (

    const BSTR a_ObjectPath ,
    long a_Flags ,
    IWbemContext *a_Context ,
    IWbemCallResult **a_CallResult
)
{
	HRESULT t_Result = S_OK ;

	InterlockedIncrement ( & m_InProgress ) ;

	if ( m_GateClosed == 1 )
	{
		t_Result = WBEM_E_SHUTTING_DOWN ;
	}
	else
	{
		if ( m_CoreService )
		{
			BOOL t_Impersonating = FALSE ;
			IUnknown *t_OldContext = NULL ;
			IServerSecurity *t_OldSecurity = NULL ;

			t_Result = DecoupledProviderSubSystem_Globals :: BeginCallbackImpersonation ( t_OldContext , t_OldSecurity , t_Impersonating ) ;
			if ( SUCCEEDED ( t_Result ) ) 
			{
				BOOL t_Revert = FALSE ;
				IUnknown *t_Proxy = NULL ;

				t_Result = DecoupledProviderSubSystem_Globals :: SetProxyState ( m_ProxyContainer , ProxyIndex_Stub_IWbemServices , IID_IWbemServicesEx , m_CoreService , t_Proxy , t_Revert ) ;
				if ( t_Result == WBEM_E_NOT_FOUND )
				{
					t_Result = m_CoreService->DeleteObject (

						a_ObjectPath ,
						a_Flags,
						a_Context,
						a_CallResult
					) ;
				}
				else 
				{
					if ( SUCCEEDED ( t_Result ) )
					{
						IWbemServicesEx *t_ServiceEx = ( IWbemServicesEx * ) t_Proxy ;

						// Set cloaking on the proxy
						// =========================

						DWORD t_ImpersonationLevel = DecoupledProviderSubSystem_Globals :: GetCurrentImpersonationLevel () ;

						t_Result = DecoupledProviderSubSystem_Globals :: SetCloaking (

							t_ServiceEx ,
							RPC_C_AUTHN_LEVEL_CONNECT , 
							t_ImpersonationLevel
						) ;

						if ( SUCCEEDED ( t_Result ) )
						{
							BSTR t_ObjectPath = SysAllocString ( a_ObjectPath ) ;
							if ( t_ObjectPath )
							{
								t_Result = t_ServiceEx->DeleteObject (

									t_ObjectPath ,
									a_Flags,
									a_Context,
									a_CallResult
								) ;

								SysFreeString ( t_ObjectPath ) ;
							}
							else
							{
								t_Result = WBEM_E_OUT_OF_MEMORY ;
							}
						}

						HRESULT t_TempResult = DecoupledProviderSubSystem_Globals :: RevertProxyState ( m_ProxyContainer , ProxyIndex_Stub_IWbemServices , t_Proxy , t_Revert ) ;
					}
				}

				DecoupledProviderSubSystem_Globals :: EndImpersonation ( t_OldContext , t_OldSecurity , t_Impersonating ) ;
			}
		}
		else
		{
			t_Result = WBEM_E_NOT_AVAILABLE ;
		}
	}

	InterlockedDecrement ( & m_InProgress ) ;

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_IWbemServices_Stub :: DeleteObjectAsync (

    const BSTR a_ObjectPath , 
    long a_Flags ,
    IWbemContext *a_Context ,
    IWbemObjectSink *a_Sink
)
{
	HRESULT t_Result = S_OK ;

	InterlockedIncrement ( & m_InProgress ) ;

	if ( m_GateClosed == 1 )
	{
		t_Result = WBEM_E_SHUTTING_DOWN ;
	}
	else
	{
		if ( m_CoreService )
		{
			BOOL t_Impersonating = FALSE ;
			IUnknown *t_OldContext = NULL ;
			IServerSecurity *t_OldSecurity = NULL ;

			t_Result = DecoupledProviderSubSystem_Globals :: BeginCallbackImpersonation ( t_OldContext , t_OldSecurity , t_Impersonating ) ;
			if ( SUCCEEDED ( t_Result ) ) 
			{
				BOOL t_Revert = FALSE ;
				IUnknown *t_Proxy = NULL ;

				t_Result = DecoupledProviderSubSystem_Globals :: SetProxyState ( m_ProxyContainer , ProxyIndex_Stub_IWbemServices , IID_IWbemServicesEx , m_CoreService , t_Proxy , t_Revert ) ;
				if ( t_Result == WBEM_E_NOT_FOUND )
				{
					t_Result = m_CoreService->DeleteObjectAsync (

						a_ObjectPath ,
						a_Flags,
						a_Context,
						a_Sink
					) ;
				}
				else 
				{
					if ( SUCCEEDED ( t_Result ) )
					{
						IWbemServicesEx *t_ServiceEx = ( IWbemServicesEx * ) t_Proxy ;

						// Set cloaking on the proxy
						// =========================

						DWORD t_ImpersonationLevel = DecoupledProviderSubSystem_Globals :: GetCurrentImpersonationLevel () ;

						t_Result = DecoupledProviderSubSystem_Globals :: SetCloaking (

							t_ServiceEx ,
							RPC_C_AUTHN_LEVEL_CONNECT , 
							t_ImpersonationLevel
						) ;

						if ( SUCCEEDED ( t_Result ) )
						{
							BSTR t_ObjectPath = SysAllocString ( a_ObjectPath ) ;
							if ( t_ObjectPath )
							{
								t_Result = t_ServiceEx->DeleteObjectAsync (

									a_ObjectPath ,
									a_Flags,
									a_Context,
									a_Sink
								) ;

								SysFreeString ( t_ObjectPath ) ;
							}
							else
							{
								t_Result = WBEM_E_OUT_OF_MEMORY ;
							}
						}

						HRESULT t_TempResult = DecoupledProviderSubSystem_Globals :: RevertProxyState ( m_ProxyContainer , ProxyIndex_Stub_IWbemServices , t_Proxy , t_Revert ) ;
					}
				}

				DecoupledProviderSubSystem_Globals :: EndImpersonation ( t_OldContext , t_OldSecurity , t_Impersonating ) ;
			}
		}
		else
		{
			t_Result = WBEM_E_NOT_AVAILABLE ;
		}
	}

	InterlockedDecrement ( & m_InProgress ) ;

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_IWbemServices_Stub :: PutObject (

	IWbemClassObject *a_Object ,
    long a_Flags ,
    IWbemContext *a_Context ,
    IWbemCallResult **a_CallResult
)
{
	HRESULT t_Result = S_OK ;

	InterlockedIncrement ( & m_InProgress ) ;

	if ( m_GateClosed == 1 )
	{
		t_Result = WBEM_E_SHUTTING_DOWN ;
	}
	else
	{
		if ( m_CoreService )
		{
			BOOL t_Impersonating = FALSE ;
			IUnknown *t_OldContext = NULL ;
			IServerSecurity *t_OldSecurity = NULL ;

			t_Result = DecoupledProviderSubSystem_Globals :: BeginCallbackImpersonation ( t_OldContext , t_OldSecurity , t_Impersonating ) ;
			if ( SUCCEEDED ( t_Result ) ) 
			{
				BOOL t_Revert = FALSE ;
				IUnknown *t_Proxy = NULL ;

				t_Result = DecoupledProviderSubSystem_Globals :: SetProxyState ( m_ProxyContainer , ProxyIndex_Stub_IWbemServices , IID_IWbemServicesEx , m_CoreService , t_Proxy , t_Revert ) ;
				if ( t_Result == WBEM_E_NOT_FOUND )
				{
					t_Result = m_CoreService->PutObject (

						a_Object ,
						a_Flags,
						a_Context,
						a_CallResult
					) ;
				}
				else 
				{
					if ( SUCCEEDED ( t_Result ) )
					{
						IWbemServicesEx *t_ServiceEx = ( IWbemServicesEx * ) t_Proxy ;

						// Set cloaking on the proxy
						// =========================

						DWORD t_ImpersonationLevel = DecoupledProviderSubSystem_Globals :: GetCurrentImpersonationLevel () ;

						t_Result = DecoupledProviderSubSystem_Globals :: SetCloaking (

							t_ServiceEx ,
							RPC_C_AUTHN_LEVEL_CONNECT , 
							t_ImpersonationLevel
						) ;

						if ( SUCCEEDED ( t_Result ) )
						{
							t_Result = t_ServiceEx->PutObject (

								a_Object ,
								a_Flags,
								a_Context,
								a_CallResult
							) ;
						}

						HRESULT t_TempResult = DecoupledProviderSubSystem_Globals :: RevertProxyState ( m_ProxyContainer , ProxyIndex_Stub_IWbemServices , t_Proxy , t_Revert ) ;
					}
				}

				DecoupledProviderSubSystem_Globals :: EndImpersonation ( t_OldContext , t_OldSecurity , t_Impersonating ) ;
			}
		}
		else
		{
			t_Result = WBEM_E_NOT_AVAILABLE ;
		}
	}

	InterlockedDecrement ( & m_InProgress ) ;

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_IWbemServices_Stub ::     PutObjectAsync (

	IWbemClassObject *a_Object ,
    long a_Flags ,
    IWbemContext *a_Context ,
    IWbemObjectSink *a_Sink
)
{
	HRESULT t_Result = S_OK ;

	InterlockedIncrement ( & m_InProgress ) ;

	if ( m_GateClosed == 1 )
	{
		t_Result = WBEM_E_SHUTTING_DOWN ;
	}
	else
	{
		if ( m_CoreService )
		{
			BOOL t_Impersonating = FALSE ;
			IUnknown *t_OldContext = NULL ;
			IServerSecurity *t_OldSecurity = NULL ;

			t_Result = DecoupledProviderSubSystem_Globals :: BeginCallbackImpersonation ( t_OldContext , t_OldSecurity , t_Impersonating ) ;
			if ( SUCCEEDED ( t_Result ) ) 
			{
				BOOL t_Revert = FALSE ;
				IUnknown *t_Proxy = NULL ;

				t_Result = DecoupledProviderSubSystem_Globals :: SetProxyState ( m_ProxyContainer , ProxyIndex_Stub_IWbemServices , IID_IWbemServicesEx , m_CoreService , t_Proxy , t_Revert ) ;
				if ( t_Result == WBEM_E_NOT_FOUND )
				{
					t_Result = m_CoreService->PutObjectAsync (

						a_Object ,
						a_Flags,
						a_Context,
						a_Sink
					) ;
				}
				else 
				{
					if ( SUCCEEDED ( t_Result ) )
					{
						IWbemServicesEx *t_ServiceEx = ( IWbemServicesEx * ) t_Proxy ;

						// Set cloaking on the proxy
						// =========================

						DWORD t_ImpersonationLevel = DecoupledProviderSubSystem_Globals :: GetCurrentImpersonationLevel () ;

						t_Result = DecoupledProviderSubSystem_Globals :: SetCloaking (

							t_ServiceEx ,
							RPC_C_AUTHN_LEVEL_CONNECT , 
							t_ImpersonationLevel
						) ;

						if ( SUCCEEDED ( t_Result ) )
						{
							t_Result = t_ServiceEx->PutObjectAsync (

								a_Object ,
								a_Flags,
								a_Context,
								a_Sink
							) ;
						}

						HRESULT t_TempResult = DecoupledProviderSubSystem_Globals :: RevertProxyState ( m_ProxyContainer , ProxyIndex_Stub_IWbemServices , t_Proxy , t_Revert ) ;
					}
				}

				DecoupledProviderSubSystem_Globals :: EndImpersonation ( t_OldContext , t_OldSecurity , t_Impersonating ) ;
			}
		}
		else
		{
			t_Result = WBEM_E_NOT_AVAILABLE ;
		}
	}

	InterlockedDecrement ( & m_InProgress ) ;

	return t_Result ;
}
#endif
/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_IWbemServices_Stub :: AddObjectToRefresher (

	WBEM_REFRESHER_ID *a_RefresherId ,
	LPCWSTR a_Path,
	long a_Flags ,
	IWbemContext *a_Context,
	DWORD a_ClientRefresherVersion ,
	WBEM_REFRESH_INFO *a_Information ,
	DWORD *a_ServerRefresherVersion
)
{
	HRESULT t_Result = S_OK ;

	InterlockedIncrement ( & m_InProgress ) ;

	if ( m_GateClosed == 1 )
	{
		t_Result = WBEM_E_SHUTTING_DOWN ;
	}
	else
	{
		if ( m_RefreshingService )
		{
			BOOL t_Impersonating = FALSE ;
			IUnknown *t_OldContext = NULL ;
			IServerSecurity *t_OldSecurity = NULL ;

			t_Result = DecoupledProviderSubSystem_Globals :: BeginCallbackImpersonation ( t_OldContext , t_OldSecurity , t_Impersonating ) ;
			if ( SUCCEEDED ( t_Result ) ) 
			{
				BOOL t_Revert = FALSE ;
				IUnknown *t_Proxy = NULL ;

				t_Result = DecoupledProviderSubSystem_Globals :: SetProxyState ( m_ProxyContainer , ProxyIndex_Stub_IWbemRefreshingServices , IID_IWbemRefreshingServices , m_RefreshingService , t_Proxy , t_Revert ) ;
				if ( t_Result == WBEM_E_NOT_FOUND )
				{
					t_Result = m_RefreshingService->AddObjectToRefresher (

						a_RefresherId ,
						a_Path,
						a_Flags ,
						a_Context,
						a_ClientRefresherVersion ,
						a_Information ,
						a_ServerRefresherVersion
					) ;
				}
				else 
				{
					if ( SUCCEEDED ( t_Result ) )
					{
						IWbemRefreshingServices *t_RefreshingService = ( IWbemRefreshingServices * ) t_Proxy ;

						// Set cloaking on the proxy
						// =========================

						DWORD t_ImpersonationLevel = DecoupledProviderSubSystem_Globals :: GetCurrentImpersonationLevel () ;

						t_Result = DecoupledProviderSubSystem_Globals :: SetCloaking (

							t_RefreshingService ,
							RPC_C_AUTHN_LEVEL_CONNECT , 
							t_ImpersonationLevel
						) ;

						if ( SUCCEEDED ( t_Result ) )
						{
							t_Result = t_RefreshingService->AddObjectToRefresher (

								a_RefresherId ,
								a_Path,
								a_Flags ,
								a_Context,
								a_ClientRefresherVersion ,
								a_Information ,
								a_ServerRefresherVersion
							) ;
						}

						HRESULT t_TempResult = DecoupledProviderSubSystem_Globals :: RevertProxyState ( m_ProxyContainer , ProxyIndex_Stub_IWbemRefreshingServices , t_Proxy , t_Revert ) ;
					}
				}

				DecoupledProviderSubSystem_Globals :: EndImpersonation ( t_OldContext , t_OldSecurity , t_Impersonating ) ;
			}
		}
		else
		{
			t_Result = WBEM_E_NOT_AVAILABLE ;
		}
	}

	InterlockedDecrement ( & m_InProgress ) ;

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_IWbemServices_Stub :: AddObjectToRefresherByTemplate (

	WBEM_REFRESHER_ID *a_RefresherId ,
	IWbemClassObject *a_Template ,
	long a_Flags ,
	IWbemContext *a_Context ,
	DWORD a_ClientRefresherVersion ,
	WBEM_REFRESH_INFO *a_Information ,
	DWORD *a_ServerRefresherVersion
)
{
	HRESULT t_Result = S_OK ;

	InterlockedIncrement ( & m_InProgress ) ;

	if ( m_GateClosed == 1 )
	{
		t_Result = WBEM_E_SHUTTING_DOWN ;
	}
	else
	{
		if ( m_RefreshingService )
		{
			BOOL t_Impersonating = FALSE ;
			IUnknown *t_OldContext = NULL ;
			IServerSecurity *t_OldSecurity = NULL ;

			t_Result = DecoupledProviderSubSystem_Globals :: BeginCallbackImpersonation ( t_OldContext , t_OldSecurity , t_Impersonating ) ;
			if ( SUCCEEDED ( t_Result ) ) 
			{
				BOOL t_Revert = FALSE ;
				IUnknown *t_Proxy = NULL ;

				t_Result = DecoupledProviderSubSystem_Globals :: SetProxyState ( m_ProxyContainer , ProxyIndex_Stub_IWbemRefreshingServices , IID_IWbemRefreshingServices , m_RefreshingService , t_Proxy , t_Revert ) ;
				if ( t_Result == WBEM_E_NOT_FOUND )
				{
					t_Result = m_RefreshingService->AddObjectToRefresherByTemplate (

						a_RefresherId ,
						a_Template ,
						a_Flags ,
						a_Context ,
						a_ClientRefresherVersion ,
						a_Information ,
						a_ServerRefresherVersion
					) ;
				}
				else 
				{
					if ( SUCCEEDED ( t_Result ) )
					{
						IWbemRefreshingServices *t_RefreshingService = ( IWbemRefreshingServices * ) t_Proxy ;

						// Set cloaking on the proxy
						// =========================

						DWORD t_ImpersonationLevel = DecoupledProviderSubSystem_Globals :: GetCurrentImpersonationLevel () ;

						t_Result = DecoupledProviderSubSystem_Globals :: SetCloaking (

							t_RefreshingService ,
							RPC_C_AUTHN_LEVEL_CONNECT , 
							t_ImpersonationLevel
						) ;

						if ( SUCCEEDED ( t_Result ) )
						{
							t_Result = t_RefreshingService->AddObjectToRefresherByTemplate (

								a_RefresherId ,
								a_Template ,
								a_Flags ,
								a_Context ,
								a_ClientRefresherVersion ,
								a_Information ,
								a_ServerRefresherVersion
							) ;
						}

						HRESULT t_TempResult = DecoupledProviderSubSystem_Globals :: RevertProxyState ( m_ProxyContainer , ProxyIndex_Stub_IWbemRefreshingServices , t_Proxy , t_Revert ) ;
					}
				}

				DecoupledProviderSubSystem_Globals :: EndImpersonation ( t_OldContext , t_OldSecurity , t_Impersonating ) ;
			}
		}
		else
		{
			t_Result = WBEM_E_NOT_AVAILABLE ;
		}
	}

	InterlockedDecrement ( & m_InProgress ) ;

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_IWbemServices_Stub :: AddEnumToRefresher (

	WBEM_REFRESHER_ID *a_RefresherId ,
	LPCWSTR a_Class ,
	long a_Flags ,
	IWbemContext *a_Context,
	DWORD a_ClientRefresherVersion ,
	WBEM_REFRESH_INFO *a_Information ,
	DWORD *a_ServerRefresherVersion
)
{
	HRESULT t_Result = S_OK ;

	InterlockedIncrement ( & m_InProgress ) ;

	if ( m_GateClosed == 1 )
	{
		t_Result = WBEM_E_SHUTTING_DOWN ;
	}
	else
	{
		if ( m_RefreshingService )
		{
			BOOL t_Impersonating = FALSE ;
			IUnknown *t_OldContext = NULL ;
			IServerSecurity *t_OldSecurity = NULL ;

			t_Result = DecoupledProviderSubSystem_Globals :: BeginCallbackImpersonation ( t_OldContext , t_OldSecurity , t_Impersonating ) ;
			if ( SUCCEEDED ( t_Result ) ) 
			{
				BOOL t_Revert = FALSE ;
				IUnknown *t_Proxy = NULL ;

				t_Result = DecoupledProviderSubSystem_Globals :: SetProxyState ( m_ProxyContainer , ProxyIndex_Stub_IWbemRefreshingServices , IID_IWbemRefreshingServices , m_RefreshingService , t_Proxy , t_Revert ) ;
				if ( t_Result == WBEM_E_NOT_FOUND )
				{
					t_Result = m_RefreshingService->AddEnumToRefresher (

						a_RefresherId ,
						a_Class ,
						a_Flags ,
						a_Context,
						a_ClientRefresherVersion ,
						a_Information ,
						a_ServerRefresherVersion
					) ;
				}
				else 
				{
					if ( SUCCEEDED ( t_Result ) )
					{
						IWbemRefreshingServices *t_RefreshingService = ( IWbemRefreshingServices * ) t_Proxy ;

						// Set cloaking on the proxy
						// =========================

						DWORD t_ImpersonationLevel = DecoupledProviderSubSystem_Globals :: GetCurrentImpersonationLevel () ;

						t_Result = DecoupledProviderSubSystem_Globals :: SetCloaking (

							t_RefreshingService ,
							RPC_C_AUTHN_LEVEL_CONNECT , 
							t_ImpersonationLevel
						) ;

						if ( SUCCEEDED ( t_Result ) )
						{
							t_Result = t_RefreshingService->AddEnumToRefresher (

								a_RefresherId ,
								a_Class ,
								a_Flags ,
								a_Context,
								a_ClientRefresherVersion ,
								a_Information ,
								a_ServerRefresherVersion
							) ;
						}

						HRESULT t_TempResult = DecoupledProviderSubSystem_Globals :: RevertProxyState ( m_ProxyContainer , ProxyIndex_Stub_IWbemRefreshingServices , t_Proxy , t_Revert ) ;
					}
				}

				DecoupledProviderSubSystem_Globals :: EndImpersonation ( t_OldContext , t_OldSecurity , t_Impersonating ) ;
			}
		}
		else
		{
			t_Result = WBEM_E_NOT_AVAILABLE ;
		}
	}

	InterlockedDecrement ( & m_InProgress ) ;

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_IWbemServices_Stub :: RemoveObjectFromRefresher (

	WBEM_REFRESHER_ID *a_RefresherId ,
	long a_Id ,
	long a_Flags ,
	DWORD a_ClientRefresherVersion ,
	DWORD *a_ServerRefresherVersion
)
{
	HRESULT t_Result = S_OK ;

	InterlockedIncrement ( & m_InProgress ) ;

	if ( m_GateClosed == 1 )
	{
		t_Result = WBEM_E_SHUTTING_DOWN ;
	}
	else
	{
		if ( m_RefreshingService )
		{
			BOOL t_Impersonating = FALSE ;
			IUnknown *t_OldContext = NULL ;
			IServerSecurity *t_OldSecurity = NULL ;

			t_Result = DecoupledProviderSubSystem_Globals :: BeginCallbackImpersonation ( t_OldContext , t_OldSecurity , t_Impersonating ) ;
			if ( SUCCEEDED ( t_Result ) ) 
			{
				BOOL t_Revert = FALSE ;
				IUnknown *t_Proxy = NULL ;

				t_Result = DecoupledProviderSubSystem_Globals :: SetProxyState ( m_ProxyContainer , ProxyIndex_Stub_IWbemRefreshingServices , IID_IWbemRefreshingServices , m_RefreshingService , t_Proxy , t_Revert ) ;
				if ( t_Result == WBEM_E_NOT_FOUND )
				{
					t_Result = m_RefreshingService->RemoveObjectFromRefresher (

						a_RefresherId ,
						a_Id ,
						a_Flags ,
						a_ClientRefresherVersion ,
						a_ServerRefresherVersion
					) ;
				}
				else 
				{
					if ( SUCCEEDED ( t_Result ) )
					{
						IWbemRefreshingServices *t_RefreshingService = ( IWbemRefreshingServices * ) t_Proxy ;

						// Set cloaking on the proxy
						// =========================

						DWORD t_ImpersonationLevel = DecoupledProviderSubSystem_Globals :: GetCurrentImpersonationLevel () ;

						t_Result = DecoupledProviderSubSystem_Globals :: SetCloaking (

							t_RefreshingService ,
							RPC_C_AUTHN_LEVEL_CONNECT , 
							t_ImpersonationLevel
						) ;

						if ( SUCCEEDED ( t_Result ) )
						{
							t_Result = t_RefreshingService->RemoveObjectFromRefresher (

								a_RefresherId ,
								a_Id ,
								a_Flags ,
								a_ClientRefresherVersion ,
								a_ServerRefresherVersion
							) ;
						}

						HRESULT t_TempResult = DecoupledProviderSubSystem_Globals :: RevertProxyState ( m_ProxyContainer , ProxyIndex_Stub_IWbemRefreshingServices , t_Proxy , t_Revert ) ;
					}
				}

				DecoupledProviderSubSystem_Globals :: EndImpersonation ( t_OldContext , t_OldSecurity , t_Impersonating ) ;
			}
		}
		else
		{
			t_Result = WBEM_E_NOT_AVAILABLE ;
		}
	}

	InterlockedDecrement ( & m_InProgress ) ;

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_IWbemServices_Stub :: GetRemoteRefresher (

	WBEM_REFRESHER_ID *a_RefresherId ,
	long a_Flags ,
	DWORD a_ClientRefresherVersion ,
	IWbemRemoteRefresher **a_RemoteRefresher ,
	GUID *a_Guid ,
	DWORD *a_ServerRefresherVersion
)
{
	HRESULT t_Result = S_OK ;

	InterlockedIncrement ( & m_InProgress ) ;

	if ( m_GateClosed == 1 )
	{
		t_Result = WBEM_E_SHUTTING_DOWN ;
	}
	else
	{
		if ( m_RefreshingService )
		{
			BOOL t_Impersonating = FALSE ;
			IUnknown *t_OldContext = NULL ;
			IServerSecurity *t_OldSecurity = NULL ;

			t_Result = DecoupledProviderSubSystem_Globals :: BeginCallbackImpersonation ( t_OldContext , t_OldSecurity , t_Impersonating ) ;
			if ( SUCCEEDED ( t_Result ) ) 
			{
				BOOL t_Revert = FALSE ;
				IUnknown *t_Proxy = NULL ;

				t_Result = DecoupledProviderSubSystem_Globals :: SetProxyState ( m_ProxyContainer , ProxyIndex_Stub_IWbemRefreshingServices , IID_IWbemRefreshingServices , m_RefreshingService , t_Proxy , t_Revert ) ;
				if ( t_Result == WBEM_E_NOT_FOUND )
				{
					t_Result = m_RefreshingService->GetRemoteRefresher (

						a_RefresherId ,
						a_Flags ,
						a_ClientRefresherVersion ,
						a_RemoteRefresher ,
						a_Guid ,
						a_ServerRefresherVersion
					) ;
				}
				else 
				{
					if ( SUCCEEDED ( t_Result ) )
					{
						IWbemRefreshingServices *t_RefreshingService = ( IWbemRefreshingServices * ) t_Proxy ;

						// Set cloaking on the proxy
						// =========================

						DWORD t_ImpersonationLevel = DecoupledProviderSubSystem_Globals :: GetCurrentImpersonationLevel () ;

						t_Result = DecoupledProviderSubSystem_Globals :: SetCloaking (

							t_RefreshingService ,
							RPC_C_AUTHN_LEVEL_CONNECT , 
							t_ImpersonationLevel
						) ;

						if ( SUCCEEDED ( t_Result ) )
						{
							t_Result = t_RefreshingService->GetRemoteRefresher (

								a_RefresherId ,
								a_Flags ,
								a_ClientRefresherVersion ,
								a_RemoteRefresher ,
								a_Guid ,
								a_ServerRefresherVersion
							) ;
						}

						HRESULT t_TempResult = DecoupledProviderSubSystem_Globals :: RevertProxyState ( m_ProxyContainer , ProxyIndex_Stub_IWbemRefreshingServices , t_Proxy , t_Revert ) ;
					}
				}

				DecoupledProviderSubSystem_Globals :: EndImpersonation ( t_OldContext , t_OldSecurity , t_Impersonating ) ;
			}
		}
		else
		{
			t_Result = WBEM_E_NOT_AVAILABLE ;
		}
	}

	InterlockedDecrement ( & m_InProgress ) ;

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_IWbemServices_Stub :: ReconnectRemoteRefresher (

	WBEM_REFRESHER_ID *a_RefresherId,
	long a_Flags,
	long a_NumberOfObjects,
	DWORD a_ClientRefresherVersion ,
	WBEM_RECONNECT_INFO *a_ReconnectInformation ,
	WBEM_RECONNECT_RESULTS *a_ReconnectResults ,
	DWORD *a_ServerRefresherVersion
)
{
	HRESULT t_Result = S_OK ;

	InterlockedIncrement ( & m_InProgress ) ;

	if ( m_GateClosed == 1 )
	{
		t_Result = WBEM_E_SHUTTING_DOWN ;
	}
	else
	{
		if ( m_RefreshingService )
		{
			BOOL t_Impersonating = FALSE ;
			IUnknown *t_OldContext = NULL ;
			IServerSecurity *t_OldSecurity = NULL ;

			t_Result = DecoupledProviderSubSystem_Globals :: BeginCallbackImpersonation ( t_OldContext , t_OldSecurity , t_Impersonating ) ;
			if ( SUCCEEDED ( t_Result ) ) 
			{
				BOOL t_Revert = FALSE ;
				IUnknown *t_Proxy = NULL ;

				t_Result = DecoupledProviderSubSystem_Globals :: SetProxyState ( m_ProxyContainer , ProxyIndex_Stub_IWbemRefreshingServices , IID_IWbemRefreshingServices , m_RefreshingService , t_Proxy , t_Revert ) ;
				if ( t_Result == WBEM_E_NOT_FOUND )
				{
					t_Result = m_RefreshingService->ReconnectRemoteRefresher (

						a_RefresherId,
						a_Flags,
						a_NumberOfObjects,
						a_ClientRefresherVersion ,
						a_ReconnectInformation ,
						a_ReconnectResults ,
						a_ServerRefresherVersion
					) ;
				}
				else 
				{
					if ( SUCCEEDED ( t_Result ) )
					{
						IWbemRefreshingServices *t_RefreshingService = ( IWbemRefreshingServices * ) t_Proxy ;

						// Set cloaking on the proxy
						// =========================

						DWORD t_ImpersonationLevel = DecoupledProviderSubSystem_Globals :: GetCurrentImpersonationLevel () ;

						t_Result = DecoupledProviderSubSystem_Globals :: SetCloaking (

							t_RefreshingService ,
							RPC_C_AUTHN_LEVEL_CONNECT , 
							t_ImpersonationLevel
						) ;

						if ( SUCCEEDED ( t_Result ) )
						{
							t_Result = t_RefreshingService->ReconnectRemoteRefresher (

								a_RefresherId,
								a_Flags,
								a_NumberOfObjects,
								a_ClientRefresherVersion ,
								a_ReconnectInformation ,
								a_ReconnectResults ,
								a_ServerRefresherVersion
							) ;
						}

						HRESULT t_TempResult = DecoupledProviderSubSystem_Globals :: RevertProxyState ( m_ProxyContainer , ProxyIndex_Stub_IWbemRefreshingServices , t_Proxy , t_Revert ) ;
					}
				}

				DecoupledProviderSubSystem_Globals :: EndImpersonation ( t_OldContext , t_OldSecurity , t_Impersonating ) ;
			}
		}
		else
		{
			t_Result = WBEM_E_NOT_AVAILABLE ;
		}
	}

	InterlockedDecrement ( & m_InProgress ) ;

	return t_Result ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\provsubsys\decoupledadaptor\registar.cpp ===
/*++

Copyright (C) 1996-2001 Microsoft Corporation

Module Name:

	XXXX

Abstract:


History:

--*/


#include "precomp.h"
#include <objbase.h>
#include <wbemint.h>
#include <wbemcli.h>
//#include <wbemdc.h>
#include "Globals.h"
#include "ProvRegDeCoupled.h"
#include <wmiutils.h>
#include "CGlobals.h"
#include "provcache.h"
#include "aggregator.h"
#include "ProvWsvS.h"
#include <assertbreak.h>
#include <dothrow.h>
#include <os.h>
class DCProxyAggr;


DC_reg::DC_reg( const DC_reg& _R ): 
		service_(_R.service_), context_(_R.context_),
		flags_( _R.flags_), 
		CServerObject_DecoupledClientRegistration_Element() 
	{ 
		*(CServerObject_DecoupledClientRegistration_Element *)(this) = _R; 
	};

HRESULT 
DC_reg::Load(	
		long a_Flags,
		IWbemContext *a_Context ,
		LPCWSTR a_User ,
		LPCWSTR a_Locale ,
		LPCWSTR a_Scope ,
		LPCWSTR a_Registration ,
		IUnknown *a_Unknown ,
		GUID a_Identity )
	{

		wchar_t identity[] = L"{00000000-0000-0000-0000-000000000000}";

		StringFromGUID2 ( a_Identity, identity, sizeof(identity)/sizeof(identity[0]) ) ;

		HRESULT t_Result;
		
		if ( 
			FAILED ( t_Result = SetScope( const_cast<LPWSTR>(a_Scope) ) ) ||
			FAILED ( t_Result = SetProvider( const_cast<LPWSTR>(a_Registration) ) ) ||
			FAILED ( t_Result = SetUser ( const_cast<LPWSTR>(a_User) ) ) ||
			FAILED ( t_Result = SetLocale( const_cast<LPWSTR>(a_Locale) ) ) ||
			FAILED ( t_Result = SetClsid( const_cast<LPWSTR>(identity) ) )
			)
			return t_Result;

		flags_ = a_Flags;
		service_ = a_Unknown;
		context_ = a_Context;

		return t_Result;
	};


const DC_reg& 
DC_reg::operator=(const DC_reg& _R)
	{
		CServerObject_DecoupledClientRegistration_Element(*this) = _R;
		service_ = _R.service_;
		context_ = _R.context_;
		return *this;
	};


GUID 
DC_reg::identity()
	{
		GUID t_Identity ;
		CLSIDFromString ( GetClsid () , & t_Identity ) ;
		return t_Identity;
	};




IUnknownPtr 
DC_reg::service() 
{ 
	if( service_ )
		return service_;

	BSTR t_CreationTime = GetCreationTime () ;
	DWORD t_ProcessIdentifier = GetProcessIdentifier () ;
	BYTE *t_MarshaledProxy = GetMarshaledProxy () ;
	DWORD t_MarshaledProxyLength = GetMarshaledProxyLength () ;

	HRESULT t_Result;

	if ( t_CreationTime && t_MarshaledProxy )
		{
		IUnknown *t_Unknown = NULL ;
		t_Result = DecoupledProviderSubSystem_Globals :: UnMarshalRegistration ( & t_Unknown , t_MarshaledProxy , t_MarshaledProxyLength ) ;
				
			if ( SUCCEEDED ( t_Result ) )
					service_.Attach( t_Unknown );
		}
	return service_;
};



//   Register a requested provider 
//   on waiting list for the decoupled partner
void 
DC_DBReg::Register( const DC_DBkey& key, auto_ref<DCProxyAggr>& ptr)
{
  LockGuard<CriticalSection> t_guard(m_Mutex);
  aggregators_.regist(ptr, key);		

};

// UnRegister a Pseudo Provider
void DC_DBReg::UnRegister( auto_ref<DCProxyAggr>& ptr)
{
  LockGuard<CriticalSection> t_guard(m_Mutex);
  aggregators_.unregist(ptr);
};



// a a Decoupled provider
HRESULT DC_DBReg::Register( DC_reg& reg )
{

  LockGuard<CriticalSection> t_guard(m_Mutex);
  if (t_guard.locked() == false)
    return WBEM_E_OUT_OF_MEMORY;

  // Search for the provider on the namespace
	for(requested_providers::iterator it=aggregators_.begin(); it!=aggregators_.end(); ++it)
		if(	it->key_.equal( reg ) )
			break;

	
	if ( it != aggregators_.end() )
		return it->client_->Register(reg);

	return S_OK;
};


// Unregister a Decoupled provider
HRESULT DC_DBReg::UnRegister( const DC_DBkey& key, const GUID identity )
{
  LockGuard<CriticalSection> t_guard(m_Mutex);
  if (t_guard.locked() == false)
    return WBEM_E_OUT_OF_MEMORY;

	for(requested_providers::iterator it=aggregators_.begin(); it!=aggregators_.end(); ++it)
		if(	it->key_ == key )
		{
			it->client_->UnRegister(identity);
			return S_OK;
		}
	return S_OK;
};


auto_ref<DCProxyAggr> 
DC_DBReg::find(const DC_DBkey& reg) const
{
  LockGuard<CriticalSection> t_guard(m_Mutex);
  for(requested_providers::iterator it=aggregators_.begin(); it!=aggregators_.end(); ++it)
		if(	it->key_ == reg )
		{
			return it->client_;
		};
  return auto_ref<DCProxyAggr>(NULL); 
};


auto_ref<DCProxyAggr> 
DC_DBReg::GetAggregator(const DC_DBkey& key) const
{ 
	auto_ref<DCProxyAggr> tmp = find( key );
	if( tmp )
		return tmp;

	return auto_ref<DCProxyAggr>( new DCProxyAggr() ); 
};







DC_registrar * DC_registrar::instance_ = NULL;

CriticalSection DC_registrar::m_Mutex(NOTHROW_LOCK);

DC_registrar::DC_registrar ():m_ReferenceCount(1)
{
  InterlockedIncrement(&DecoupledProviderSubSystem_Globals::s_RegistrarUsers);
}


DC_registrar::~DC_registrar ()
{
	instance_ = NULL;
}


 
/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT 
DC_registrar::QueryInterface (REFIID iid ,
			      LPVOID FAR *iplpv) 
{
  if (iplpv == NULL)
    return E_POINTER;
  
  if (iid == IID_IUnknown)
    *iplpv = static_cast<IUnknown *>(this);
  else if (iid == IID__IWmiProviderSubsystemRegistrar)
    *iplpv = static_cast<_IWmiProviderSubsystemRegistrar *>(this);		
  else 
  {
  *iplpv = NULL;
  return E_NOINTERFACE;
  }

  AddRef ();
  return S_OK;
}


ULONG 
DC_registrar::AddRef ()
{
    LONG counter = InterlockedIncrement(&m_ReferenceCount);
    InterlockedIncrement(&DecoupledProviderSubSystem_Globals::s_RegistrarUsers);
	return counter;
}


ULONG 
DC_registrar::Release ()
{
	InterlockedDecrement (&DecoupledProviderSubSystem_Globals::s_RegistrarUsers);
	LONG t_Reference = InterlockedDecrement(&m_ReferenceCount);
	if (0 == t_Reference)
	{
		delete this ;
	}
	return t_Reference ;
}


HRESULT 
DC_registrar :: Register (

	long a_Flags ,
	IWbemContext *a_Context ,
	LPCWSTR a_User ,
	LPCWSTR a_Locale ,
	LPCWSTR a_Scope ,
	LPCWSTR a_Registration ,
	DWORD a_ProcessIdentifier ,
	IUnknown *a_Unknown ,
	GUID a_Identity
)
{
	try
	{
		DC_reg t_Element;

		t_Element.Load( a_Flags, a_Context, a_User, a_Locale, a_Scope, a_Registration, a_Unknown, a_Identity );
		return mapping_database_.Register(t_Element);
	}
	catch(...){

		return WBEM_E_PROVIDER_FAILURE ;
	};
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT 
DC_registrar::UnRegister (

	long a_Flags ,
	IWbemContext *a_Context ,
	LPCWSTR a_User ,
	LPCWSTR a_Locale ,
	LPCWSTR a_Scope ,
	LPCWSTR a_Registration ,
	GUID a_Identity
)
{
	try
	{
		DC_DBkey key( a_User, a_Locale, a_Scope, a_Registration);
		return mapping_database_.UnRegister(key, a_Identity);
	}
	catch(...)
	{
		return WBEM_E_PROVIDER_FAILURE ;
	};

}


/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/


HRESULT DC_registrar :: SaveToRegistry (

	IUnknown *a_Unknown ,
	BYTE *a_MarshaledProxy ,
	DWORD a_MarshaledProxyLength
)
{
	HRESULT t_Result = S_OK ;

	CServerObject_DecoupledServerRegistration t_Element ( *DecoupledProviderSubSystem_Globals :: s_Allocator ) ;

	BSTR t_CreationTime = NULL ;

	FILETIME t_CreationFileTime ;
	FILETIME t_ExitFileTime ;
	FILETIME t_KernelFileTime ;
	FILETIME t_UserFileTime ;

	BOOL t_Status = OS::GetProcessTimes (

		  GetCurrentProcess (),
		  & t_CreationFileTime,
		  & t_ExitFileTime,
		  & t_KernelFileTime,
		  & t_UserFileTime
	);

	if ( t_Status ) 
	{
		CWbemDateTime t_Time ;
		t_Time.SetFileTimeDate ( t_CreationFileTime , VARIANT_FALSE ) ;
		t_Result = t_Time.GetValue ( & t_CreationTime ) ;
		if ( SUCCEEDED ( t_Result ) ) 
		{
			t_Result = t_Element.SetProcessIdentifier ( GetCurrentProcessId () ) ;

			if ( SUCCEEDED ( t_Result ) ) 
			{
				t_Result = t_Element.SetCreationTime ( ( BSTR ) t_CreationTime ) ;
			}

			if ( SUCCEEDED ( t_Result ) ) 
			{
				t_Result = t_Element.SetMarshaledProxy ( a_MarshaledProxy , a_MarshaledProxyLength ) ;
			}

			if ( SUCCEEDED ( t_Result ) )
			{
				t_Result = t_Element.Save () ;
			}

			SysFreeString ( t_CreationTime ) ;
		}
		else
		{
			t_Result = WBEM_E_UNEXPECTED ;
		}
	}
	else
	{
		t_Result = WBEM_E_UNEXPECTED ;
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT DC_registrar :: Save ()
{
	HRESULT t_Result = S_OK ;

	try
	{
		BYTE *t_MarshaledProxy = NULL ;
		DWORD t_MarshaledProxyLength = 0 ;

			t_Result = DecoupledProviderSubSystem_Globals :: MarshalRegistration ( 
				this ,
				t_MarshaledProxy ,
				t_MarshaledProxyLength
			) ;

			if ( SUCCEEDED ( t_Result ) )
			{
				t_Result = SaveToRegistry ( 

					this ,
					t_MarshaledProxy ,
					t_MarshaledProxyLength
				) ;

				delete [] t_MarshaledProxy ;
			}
	}
	catch ( ... )
	{
		t_Result = WBEM_E_PROVIDER_FAILURE ;
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT 
DC_registrar :: Delete ()
{
	HRESULT t_Result = S_OK ;
	try
	{
		CServerObject_DecoupledServerRegistration t_Element ( *DecoupledProviderSubSystem_Globals :: s_Allocator ) ;
		t_Result = t_Element.Delete () ;
	}
	catch ( ... )
	{
		t_Result = WBEM_E_PROVIDER_FAILURE ;
	}
	return t_Result ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\provsubsys\decoupledadaptor\include\callsec.h ===
/*++

Copyright (C) 1998-2001 Microsoft Corporation

Module Name:

    CALLSEC.H

Abstract:


History:

    raymcc      29-Jul-98        First draft.

--*/


#ifndef _CALLSEC_H_
#define _CALLSEC_H_

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

class CLifeControl
{
public:
    BOOL ObjectCreated(IUnknown* pv) { return TRUE;};
    void ObjectDestroyed(IUnknown* pv){};
    void AddRef(IUnknown* pv) {};
    void Release(IUnknown* pv){};;
};

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

class CLifeControl ;

class CWbemThreadSecurityHandle : public _IWmiThreadSecHandle
{
private:

    LONG m_ReferenceCount ;

    HANDLE m_ThreadToken ;
    DWORD m_ImpersonationLevel ;
	DWORD m_AuthenticationService ;
	DWORD m_AuthorizationService ;
	DWORD m_AuthenticationLevel ;
	LPWSTR m_ServerPrincipalName ;
	LPWSTR m_Identity ;

	WMI_THREAD_SECURITY_ORIGIN m_Origin ;

	CLifeControl *m_Control ;

public:

    CWbemThreadSecurityHandle ( CLifeControl *a_Control ) ;
	CWbemThreadSecurityHandle ( const CWbemThreadSecurityHandle &a_Copy ) ;
   ~CWbemThreadSecurityHandle () ;

    CWbemThreadSecurityHandle &operator= ( const CWbemThreadSecurityHandle &a_Copy ) ;

	HRESULT CloneRpcContext (

		IServerSecurity *a_Security
	) ;

	HRESULT CloneThreadContext () ;

	HRESULT CloneProcessContext () ;

/*
 * IUnknown.
 */

    ULONG STDMETHODCALLTYPE AddRef () ;
    ULONG STDMETHODCALLTYPE Release () ;
    HRESULT STDMETHODCALLTYPE QueryInterface ( REFIID a_Riid , void **a_Void ) ;

/*
 *
 */

	HRESULT STDMETHODCALLTYPE GetHandleType ( ULONG *a_Type ) { return WMI_HANDLE_THREAD_SECURITY; }

	HRESULT STDMETHODCALLTYPE GetTokenOrigin ( WMI_THREAD_SECURITY_ORIGIN *a_Origin ) { return m_Origin ; }

/*
 *	_IWmiThreadSecHandle
 */

    HRESULT STDMETHODCALLTYPE GetImpersonation (

		DWORD *a_Level
	) ;

	HRESULT STDMETHODCALLTYPE GetAuthentication (
	
		DWORD *a_Level
	) ;

    HRESULT STDMETHODCALLTYPE GetUser (

        ULONG *a_Size ,
        LPWSTR a_Buffer
	) ;

    HRESULT STDMETHODCALLTYPE GetUserSid (

		ULONG *a_Size ,
		PSID a_Sid
	) ;

    HRESULT STDMETHODCALLTYPE GetToken ( HANDLE *a_ThreadToken ) ;

    HRESULT STDMETHODCALLTYPE GetAuthenticationLuid ( LPVOID a_Luid ) ;

/*
 * Implementation publics
 */

    HANDLE GetThreadToken () { return m_ThreadToken ; }
    DWORD GetImpersonationLevel () { return m_ImpersonationLevel ; }
	DWORD GetAuthenticationService () { return m_AuthenticationService ; }
	DWORD GetAuthorizationService () { return m_AuthorizationService ; }
	DWORD GetAuthenticationLevel () { return m_AuthenticationLevel ; }
	LPWSTR GetServerPrincipalName () { return m_ServerPrincipalName ; }
	LPWSTR GetIdentity () { return m_Identity ; }

	void SetOrigin ( WMI_THREAD_SECURITY_ORIGIN a_Origin ) { m_Origin = a_Origin ; }

	static CWbemThreadSecurityHandle *New () ;
} ;

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

class CLifeControl ;

class CWbemCallSecurity : public IServerSecurity  , public _IWmiCallSec
{
private:

    LONG m_ReferenceCount ;
	DWORD m_ImpersonationLevel ;
	CWbemThreadSecurityHandle *m_ThreadSecurityHandle ;
	HANDLE m_ThreadToken ;
	CLifeControl *m_Control ;

public:

	CWbemCallSecurity ( CLifeControl *a_Control ) ;
   ~CWbemCallSecurity () ;

    CWbemCallSecurity &operator= ( const CWbemCallSecurity &a_Copy ) ;

public:

	CWbemThreadSecurityHandle *GetThreadSecurityHandle () { return m_ThreadSecurityHandle ; }

/*
 * IUnknown.
 */

    ULONG STDMETHODCALLTYPE AddRef () ;
    ULONG STDMETHODCALLTYPE Release () ;
    HRESULT STDMETHODCALLTYPE QueryInterface ( REFIID a_Riid , void **a_Void ) ;

/*
 * IServerSecurity.
 */

    HRESULT STDMETHODCALLTYPE QueryBlanket (

		DWORD *a_AuthenticationService ,
		DWORD *a_AuthorizationService ,
		OLECHAR **a_ServerPrincipleName ,
		DWORD *a_AuthorizationLevel ,
		DWORD *a_ImpersonationLevel ,
		void **a_Privileges ,
		DWORD *a_Capabilities
	) ;

	HRESULT STDMETHODCALLTYPE ImpersonateClient () ;

	HRESULT STDMETHODCALLTYPE RevertToSelf () ;

	BOOL STDMETHODCALLTYPE IsImpersonating () ;

/*
 *	_IWmiCallSec
 */

    HRESULT STDMETHODCALLTYPE GetImpersonation (

        DWORD *a_Level
	) ;

	HRESULT STDMETHODCALLTYPE GetAuthentication (
	
		DWORD *a_Level
	) ;

    HRESULT STDMETHODCALLTYPE GetUser (

        ULONG *a_Size ,
        LPWSTR a_Buffer
	) ;

    HRESULT STDMETHODCALLTYPE GetUserSid (

		ULONG *a_Size ,
		PSID a_Sid
	) ;

    HRESULT STDMETHODCALLTYPE GetAuthenticationLuid ( LPVOID a_Luid ) ;

    HRESULT STDMETHODCALLTYPE GetThreadSecurity ( WMI_THREAD_SECURITY_ORIGIN a_Origin , _IWmiThreadSecHandle **a_ThreadSecurity ) ;

    HRESULT STDMETHODCALLTYPE SetThreadSecurity ( _IWmiThreadSecHandle *a_ThreadSecurity ) ;

	static CWbemCallSecurity *New () ;
} ;

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\provsubsys\decoupledadaptor\sources.inc ===
############################################################################
#
#   Copyright (C) 1999, Microsoft Corporation.
#
#   All rights reserved.
#
############################################################################

WMIAUTOPRECOMPSHARED=precomp.h

!include $(PROJECT_ROOT)\wmi\wbem\common\makefile.cmn
SOURCES_USED=$(PROJECT_ROOT)\wmi\wbem\common\makefile.cmn

TARGETPATH=obj
TARGETNAME=Wmidcad
TARGETTYPE=DYNLINK

TARGETLIBS= \
	$(WBEMINT_LIB) \
	$(WMIIDL_LIB) \
	$(WBEMCOMN_STATIC_LIB) \
	$(STDLIBRARY_LIB) \
	$(NCOBJAPI_LIB) \
	$(SDK_LIB_PATH)\ntdll.lib \
	$(SDK_LIB_PATH)\kernel32.lib \
	$(SDK_LIB_PATH)\advapi32.lib \
	$(SDK_LIB_PATH)\user32.lib \
	$(SDK_LIB_PATH)\oleaut32.lib \
	$(SDK_LIB_PATH)\ole32.lib \
	$(SDK_LIB_PATH)\uuid.lib


INCLUDES=$(INCLUDES); \
	..\include;\
	$(WBEMSVC_INC);\
	$(WBEMCOMN_INC); \
	$(CONTAINER_INC); \
	$(CONTAINER_SRC); \
	$(NC_COMMON); \
	$(WMIREPOSITIDL_INC); \
	$(STDLIBRARY_INC); \
	$(UTILLIB_INC); \

SOURCES=\
	..\ver.rc \
	..\Globals.cpp \
	..\Maindll.cpp \
	..\aggregator.cpp \
	..\provwsvs.cpp \
	..\ProvInSk.cpp \
	..\ProvObSk.cpp \
	..\ProvCache.cpp \
	..\registar.cpp \
	..\assertbreak.cpp \
	..\callsec.cpp \
	..\proxy.cpp \
	..\ProvRegistrar.cpp \
	..\ProvEvents.cpp \
	..\ProvEvt.cpp \
	..\provinterceptor.cpp \
	..\provdwsv.cpp \
	..\DateTime.cpp \
	..\ProvObjectSink.cpp \
	..\CGlobals.cpp \
	..\ProvRegDeCoupled.cpp \
	..\ssdlhelper.cpp \
	..\os.cpp \
	..\ProvRegInfo.cpp \
	..\ProvDnf.cpp \
	..\ProvTree.cpp \



C_DEFINES=$(C_DEFINES) /D_WIN32_DCOM
USE_NATIVE_EH=ASYNC
USE_RTTI=1
USE_MSVCRT=1
USE_VCCOM=1

DLLENTRY=_DllMainCRTStartup
DLLDEF=$(O)\adapter.def
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\provsubsys\decoupledadaptor\proxy.cpp ===
#include "precomp.h"
#include <objbase.h>
#include <wbemcli.h>
#include <wbemint.h>
#include <wmiutils.h>
#include "Globals.h"
#include "ProvRegDeCoupled.h"
#include <wmiutils.h>
#include "CGlobals.h"
#include "provcache.h"
#include "aggregator.h"
#include "ProvWsvS.h"
#include "ProvWsv.h"
#include "ProvInSk.h"
#include "ProvobSk.h"

#include <genlex.h>
#include <flexarry.h>
#include <wqllex.h>
#include <wqlnode.h>
#include <wqlscan.h>


/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

DCProxy :: DCProxy ( ) : m_ReferenceCount ( 0 ) , 
	event_only_(false),
	m_Sink(NULL),
	NULL_IWbemServices( WBEM_E_NOT_AVAILABLE )
{
	InterlockedIncrement (&DecoupledProviderSubSystem_Globals::s_ObjectsInProgress);
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

DCProxy :: ~DCProxy ()
{
  if (m_aggregator_)
     DC_registrar::instance()->UnRegisterAggregator (m_aggregator_);

  InterlockedDecrement (&DecoupledProviderSubSystem_Globals::s_ObjectsInProgress);
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

STDMETHODIMP_(ULONG) DCProxy :: AddRef ( void )
{
	return InterlockedIncrement (&m_ReferenceCount) ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

STDMETHODIMP_(ULONG) DCProxy :: Release ( void )
{
	LONG t_Reference = InterlockedDecrement (&m_ReferenceCount);
	if (  0 == t_Reference )
	{
		delete this ;
		return 0 ;
	}
	else
	{
		return t_Reference ;
	}
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

STDMETHODIMP 
DCProxy :: QueryInterface ( REFIID iid , LPVOID FAR *iplpv ) 
{
  if (iplpv == 0)
    return E_POINTER;
  
  if (iid == IID_IUnknown)
    {
    *iplpv = static_cast<NULL_IWbemServices*>(this) ;
    }
  else if (iid == IID_IWbemServices)
    {
    *iplpv = static_cast<IWbemServices *>(this) ;
    }
  else if (iid == IID_IWbemPropertyProvider)
    {
    *iplpv = static_cast<IWbemPropertyProvider *>(this);
    }
  else if ( iid == IID_IWbemProviderInit )
	{
		*iplpv = static_cast<IWbemProviderInit *>(this) ;		
	}	
  else if ( iid == IID_IWbemEventProvider )
	{
		*iplpv = static_cast<IWbemEventProvider *>(this) ;	
	}	
  else if ( iid == IID_IWbemEventProviderSecurity )
	{
		*iplpv = static_cast<IWbemEventProviderSecurity *>(this) ;	
	}	
  else if ( iid == IID_IWbemProviderIdentity )
	{
		*iplpv = static_cast<IWbemProviderIdentity *>(this) ;	
	}
  else if ( iid == IID_IWbemEventProviderQuerySink)
	{
		*iplpv = static_cast<IWbemEventProviderQuerySink *>(this) ;	
	}
  else
	  { 
	  *iplpv = 0;
	  return E_NOINTERFACE;
	  }

	DCProxy::AddRef () ;
	return S_OK;
}





/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/
      

HRESULT DCProxy :: Initialize (

	LPWSTR a_User,
	LONG a_Flags,
	LPWSTR a_Namespace,
	LPWSTR a_Locale,
	IWbemServices *a_CoreService,         // For anybody
	IWbemContext *a_Context,
	IWbemProviderInitSink *a_Sink     // For init signals
)
{
	// The connection to the agregator is deffered

	if( !a_Sink)
		return WBEM_E_INVALID_PARAMETER;
	
	if(!a_CoreService )
		return a_Sink->SetStatus ( WBEM_E_INVALID_PARAMETER , 0 ) ;
	
	m_CoreService = a_CoreService;
	m_Context = a_Context;
	m_Flags = a_Flags;

	try{
		m_User = a_User;
		m_Locale = a_Locale;
		m_Namespace = a_Namespace;
		// Register the Registrar
		if (DC_registrar::instance())
			DC_registrar::instance()->Save();

		}
	catch( _com_error& err)
	{
		return a_Sink->SetStatus ( WBEM_E_OUT_OF_MEMORY , 0 ) ;
	}

	// Instance provider - we don't know the provider name
	// The real initialization is deffered
	
	if(!event_only_)
		return a_Sink->SetStatus ( S_OK , 0 ) ;

	// Event provider - safely to initialize
	HRESULT hr  = _initialize();

	return a_Sink->SetStatus ( hr , 0 ) ;

}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/



HRESULT 
DCProxy::GetObjectAsync (const BSTR a_ObjectPath, 
			 long a_Flags, 
			 IWbemContext *a_Context,
			 IWbemObjectSink *a_Sink) 
{

  HRESULT t_Result = initialize_from_instance (a_ObjectPath);
  if (FAILED (t_Result))
    return WBEM_E_FAILED;

  return m_aggregator_->GetObjectAsync( a_ObjectPath, a_Flags, a_Context, a_Sink );
}



HRESULT DCProxy :: PutInstanceAsync ( 
		
	IWbemClassObject *a_Instance, 
	long a_Flags ,
    IWbemContext *a_Context ,
	IWbemObjectSink *a_Sink
) 
{
	HRESULT t_Result = initialize( a_Instance );
	if ( FAILED (t_Result ) )
		return t_Result;
	
	return m_aggregator_->PutInstanceAsync( a_Instance, a_Flags, a_Context, a_Sink );
}


/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/
        
HRESULT 
DCProxy :: DeleteInstanceAsync (
  const BSTR a_ObjectPath,
  long a_Flags,
  IWbemContext *a_Context,
  IWbemObjectSink *a_Sink
)
{
  HRESULT t_Result = initialize_from_instance (a_ObjectPath);
  if (FAILED (t_Result))
    return WBEM_E_FAILED;

  return m_aggregator_->DeleteInstanceAsync(a_ObjectPath, a_Flags, a_Context, a_Sink );
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT 
DCProxy::CreateInstanceEnumAsync (const BSTR a_Class ,
				  long a_Flags ,
				  IWbemContext *a_Context ,
				  IWbemObjectSink *a_Sink) 
{
  HRESULT t_Result = initialize (a_Class);
  if (FAILED (t_Result))
    return t_Result;
  
  return m_aggregator_->CreateInstanceEnumAsync (a_Class,
						 a_Flags,
						 a_Context,
						 a_Sink);
}


/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT 
DCProxy::ExecMethodAsync (const BSTR a_ObjectPath,
			    const BSTR a_MethodName,
			    long a_Flags,
			    IWbemContext *a_Context,
			    IWbemClassObject *a_InParams,
			    IWbemObjectSink *a_Sink) 
{
  HRESULT t_Result = initialize (a_ObjectPath);
  
  if (FAILED (t_Result))
    return t_Result;

  return m_aggregator_->ExecMethodAsync (a_ObjectPath,
					 a_MethodName,
					 a_Flags  , 
					 a_Context,
					 a_InParams,
					 a_Sink);
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT 
DCProxy::ProvideEvents (IWbemObjectSink *a_Sink ,
			long a_Flags)
{
  if (m_aggregator_)
    return m_aggregator_->ProvideEvents (a_Sink, a_Flags);
  else
    return WBEM_E_FAILED;
}


bool 
DCProxy::initialized ()
{
  return m_aggregator_;
};


HRESULT 
DCProxy::_initialize ()
{
  DC_DBkey key( m_User, m_Locale, m_Namespace, m_ProviderName);

	auto_ref<DCProxyAggr> tmp = DC_registrar::instance()->GetAggregator( key );
	//	The aggregator is not registered yet for lifetime control

	if( tmp )
	{
		if ( tmp->initialized() )
		{
			m_aggregator_ = tmp;
			return S_OK;
		}


		CServerObject_ProviderInitSink *t_ProviderInitSink = new CServerObject_ProviderInitSink ; 
		if (t_ProviderInitSink)
		{
		  t_ProviderInitSink->AddRef();
		
		HRESULT hr = tmp ->Initialize
			( 
				(wchar_t *)m_User,
				m_Flags,
				(wchar_t *)m_Namespace,
				(wchar_t *)m_Locale,
				(wchar_t *)m_ProviderName,
				m_CoreService.GetInterfacePtr(),         // For anybody
				m_Context.GetInterfacePtr(),
				t_ProviderInitSink     // For init signals
			);

		t_ProviderInitSink->Release();
		if( SUCCEEDED ( hr) )
		{
			m_aggregator_ = tmp;
			DC_registrar::instance()->RegisterAggregator(key, tmp);
		};
		return hr;
		}
		else
		  return WBEM_E_OUT_OF_MEMORY ;
	}
	else
		return WBEM_E_OUT_OF_MEMORY ;

};

HRESULT 
DCProxy ::initialize (IWbemClassObject * pObj)
{
  if (initialized())
    return S_OK;

  _variant_t v;
  HRESULT hr = pObj->Get(L"__CLASS", 0, &v, 0, 0);

  // check the HRESULT to see if the action succeeded
  if (SUCCEEDED (hr))
    {
    return initialize ( _bstr_t (v)); 
    }
  else
    return WBEM_E_FAILED;
};

HRESULT 
DCProxy::initialize (const BSTR _name)
{
  if (initialized ())
    return S_OK;
  
  LockGuard<CriticalSection> t_guard( DC_registrar::instance()->GetLock());
  if (t_guard.locked()==false)
    return WBEM_E_OUT_OF_MEMORY;
  
  // Double checked looking variant
  if (initialized ())
    return S_OK;

  IWbemClassObject * t_ObjectPath = NULL ;
  IWbemClassObject *Identity ;
  
  HRESULT t_Result = m_CoreService->GetObject (_name ,
					       0 ,
					       m_Context , 
					       & Identity , 
					       NULL) ;
  if (FAILED (t_Result))
    return t_Result;

  IWbemQualifierSet *t_QualifierObject = NULL ;

  t_Result = Identity->GetQualifierSet (&t_QualifierObject);

  if (SUCCEEDED (t_Result))
    {
    _variant_t prov_name;
    t_Result  = t_QualifierObject->Get (L"provider", 0, & prov_name, NULL);
    if (SUCCEEDED (t_Result))
      {
      m_ProviderName = (_bstr_t)prov_name;
      };
    t_QualifierObject->Release();
    }
  return _initialize();	
}


HRESULT 
DCProxy::initialize_from_instance (const BSTR _path)
{
  if (initialized ())
    return S_OK;
  wchar_t * pszClassName = NULL;

  IWbemPathPtr pPath;
  HRESULT t_Result = pPath.CreateInstance (CLSID_WbemDefPath, NULL, CLSCTX_INPROC_SERVER);
  
  if (SUCCEEDED (t_Result))
    {
    t_Result = pPath->SetText (WBEMPATH_CREATE_ACCEPT_ALL , _path) ;
    if (SUCCEEDED (t_Result))
      {
      ULONG uBuf = 0;
      t_Result = pPath->GetClassName(&uBuf, 0);
      if (SUCCEEDED (t_Result))
	{
	pszClassName = new wchar_t[uBuf+1];
	if (pszClassName == 0)
	  return WBEM_E_OUT_OF_MEMORY;

	t_Result = pPath->GetClassName(&uBuf, pszClassName);
        if (FAILED(t_Result))
	  {
	  delete[] pszClassName;
	  return WBEM_E_FAILED;
	  }
        t_Result = initialize (pszClassName);
        delete[] pszClassName;
	}
      }
    }
  return t_Result;  // The return code is used internally
}


HRESULT DCProxy ::AccessCheck (

	WBEM_CWSTR a_QueryLanguage ,
	WBEM_CWSTR a_Query ,
	long a_SidLength ,
	const BYTE *a_Sid
)
{
	if( m_aggregator_ )
		return m_aggregator_ ->AccessCheck ( a_QueryLanguage, a_Query, a_SidLength, a_Sid);
	else
		return WBEM_E_FAILED;
}


HRESULT 
DCProxy::SetRegistrationObject(
  long lFlags,
  IWbemClassObject* pProvReg
  )
{
	HRESULT t_Result = WBEM_E_FAILED;

	_variant_t v;
	t_Result = pProvReg->Get(L"NAME", 0, &v, 0, 0);

	// check the HRESULT to see if the action succeeded
	if ( SUCCEEDED( t_Result) )
	{
		m_ProviderName = (_bstr_t)v;
		event_only_ = true;
		return WBEM_S_NO_ERROR;
	}
	else
	{
		return WBEM_E_FAILED;
	}
};

HRESULT 
DCProxy::NewQuery(
		unsigned long dwId,
		WBEM_WSTR wszQueryLanguage,
		WBEM_WSTR wszQuery
)
{
	if( !initialized() )
		return WBEM_E_FAILED;

	return m_aggregator_->NewQuery( dwId, wszQueryLanguage, wszQuery );
}

HRESULT 
DCProxy::CancelQuery( unsigned long dwId )
{
	if( !initialized() )
		return WBEM_E_FAILED;
	return m_aggregator_->CancelQuery( dwId );
};


HRESULT 
DCProxy::ExecQueryAsync(
  const BSTR strQueryLanguage,                
  const BSTR strQuery,                        
  long lFlags,                       
  IWbemContext *pCtx,              
  IWbemObjectSink *pResponseHandler  
)
{

    // Try to parse it
    // ===============

    CTextLexSource src(strQuery);
    CWQLScanner Parser(&src);
    int nRes = Parser.Parse();
    if(nRes != CWQLScanner::SUCCESS)
    {
        return WBEM_E_INVALID_QUERY;
    }

    // Successfully parsed. Go to the first tables involved
    // ======================================================

    CWStringArray awsTables;
    Parser.GetReferencedTables(awsTables);

    if (awsTables.Size()>0)
      {
      HRESULT t_Result = initialize( awsTables[0] );
      if (SUCCEEDED(t_Result))
	{
	return m_aggregator_->ExecQueryAsync( strQueryLanguage, strQuery, lFlags, pCtx, pResponseHandler );
	}
      else
	return t_Result;

      }
    else
      {
	return WBEM_E_FAILED;
      }
};

STDMETHODIMP 
DCProxy::GetProperty( long lFlags, const BSTR strLocale, const BSTR strClassMapping, 
		      const BSTR strInstMapping, const BSTR strPropMapping, VARIANT *pvValue )
  {

  return WBEM_S_FALSE;
  };


STDMETHODIMP 
DCProxy::PutProperty( long lFlags, const BSTR strLocale, const BSTR strClassMapping, 
		      const BSTR strInstMapping, const BSTR strPropMapping,  const VARIANT *pvValue )
  {


  return WBEM_S_FALSE;
  }
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\provsubsys\decoupledadaptor\include\aggregator.h ===
/*++

Copyright (C) 1996-2001 Microsoft Corporation

Module Name:

	ProvResv.H

Abstract:


History:

--*/

#ifndef _ClassProvider_IWbemServices_H
#define _ClassProvider_IWbemServices_H

#include "ProvRegDeCoupled.h"
#include <comdef.h>
#include <list>
#include "provcache.h"
#include <string>
#include <list>
#include <pssutils.h>
#include <AssertBreak.h>
#include <comdef.h>
#include <null_wmi.h>
#include <locksT.h>
using namespace provsubsys;

_COM_SMARTPTR_TYPEDEF(IWbemServices, __uuidof(IWbemServices));
_COM_SMARTPTR_TYPEDEF(IWbemObjectSink, __uuidof(IWbemObjectSink));
_COM_SMARTPTR_TYPEDEF(IWbemPath, __uuidof(IWbemPath));
_COM_SMARTPTR_TYPEDEF(IWbemObjectSink, __uuidof(IWbemObjectSink));
_COM_SMARTPTR_TYPEDEF(IWbemClassObject, __uuidof(IWbemClassObject));
_COM_SMARTPTR_TYPEDEF(IWbemContext, __uuidof(IWbemContext));
_COM_SMARTPTR_TYPEDEF(_IWmiProviderSubsystemRegistrar,__uuidof(_IWmiProviderSubsystemRegistrar));
_COM_SMARTPTR_TYPEDEF(IWbemQuery,__uuidof(IWbemQuery));


class DC_reg : public CServerObject_DecoupledClientRegistration_Element
{
	IWbemContextPtr context_;
	IUnknownPtr		service_;
	long	flags_;

public:
	DC_reg(): CServerObject_DecoupledClientRegistration_Element(), flags_(0) { };

	DC_reg( const DC_reg& _R );
	DC_reg( CServerObject_DecoupledClientRegistration_Element& _R)
	{
		*(CServerObject_DecoupledClientRegistration_Element*)(this) = _R;	
	};

	HRESULT Load(	
		long a_Flags,
		IWbemContext *a_Context ,
		LPCWSTR a_User ,
		LPCWSTR a_Locale ,
		LPCWSTR a_Scope ,
		LPCWSTR a_Registration ,
		IUnknown *a_Unknown ,
		GUID a_Identity ) ;


	const DC_reg& operator=(const DC_reg& _R);

	~DC_reg() {  	};

	GUID identity();

	IWbemContextPtr context() { return context_; };

	IUnknownPtr service();
	
	HRESULT SetUser ( const BSTR a_User )
	{ 
		HRESULT res = CServerObject_DecoupledClientRegistration_Element::SetUser( const_cast<BSTR>(a_User) );
		if ( a_User == NULL )
			return S_OK;
		return res;
	}

	HRESULT SetLocale ( const BSTR a_User )
	{ 
		HRESULT res = CServerObject_DecoupledClientRegistration_Element::SetLocale ( const_cast<BSTR>(a_User) );
		if ( a_User == NULL )
			return S_OK;
		return res;
	}

	HRESULT SetScope  ( const BSTR a_User )
	{ 
		HRESULT res = CServerObject_DecoupledClientRegistration_Element::SetScope ( const_cast<BSTR>(a_User) );
		if ( a_User == NULL )
			return S_OK;
		return res;
	}

	long flags() { return flags_; };
};



// Forward declaration
class DCProxyAggr;

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/


struct DC_DBkey
{
	_bstr_t	scope_;
	_bstr_t	locale_;
	_bstr_t user_;
	_bstr_t name_;

	DC_DBkey( 
		const _bstr_t& user,
		const _bstr_t& locale, 
		const _bstr_t& scope,
		const _bstr_t& name 
		): scope_( scope ), locale_( locale ), user_( user ), name_( name )
	{  	};

	DC_DBkey(const DC_DBkey& _R):scope_(_R.scope_), locale_(_R.locale_), user_(_R.user_), name_(_R.name_)
	{  };

	bool operator==(const DC_DBkey& _R) const
	{
		return ( 
			equal_no_case( scope_ , _R.scope_) && 
			equal_no_case( user_ , _R.user_) && 
			equal_no_case( locale_ , _R.locale_) &&
			equal_no_case( name_ , _R.name_)
			);
	};
	bool operator!=(const DC_DBkey& _R) const 
	{
		return !(*this==_R);
	};

	bool equal_no_case( const _bstr_t& _L, const _bstr_t& _R) const
	{
		if( _L.length() != _R.length() )
			return false;

		if( _L.length() == 0 )
			return true;

		return _wcsnicmp( _L, _R, _L.length() ) == 0;
	};

	bool equal_no_case( const _bstr_t& _L, const BSTR _R) const
	{
		const wchar_t null[] = L"";
		if( _L.length() != ::SysStringLen(_R) )
			return false;

		if( _L.length() == 0 )
			return true;

		return _wcsnicmp( _L, _R, _L.length() ) == 0;
	};

	bool equal(CServerObject_DecoupledClientRegistration_Element& el) const {

		bool result = equal_no_case( scope_, el.GetScope());
		result = result && equal_no_case( locale_, el.GetLocale() );
		result = result && equal_no_case( user_, el.GetUser() );
		result = result && equal_no_case( name_, el.GetProvider() );
		return result;		
	};

protected:
	DC_DBkey& operator=(const DC_DBkey&);
};



struct requested_entry
{
	DC_DBkey	key_;
	auto_ref<DCProxyAggr>	client_; 
	requested_entry(
		const DC_DBkey& key, 
		auto_ref<DCProxyAggr>& ptr
		): client_(ptr), key_(key)
	{ };
};




class requested_providers: public std::list<requested_entry>{

public:
	void regist(auto_ref<DCProxyAggr>& ptr, const DC_DBkey& key)
	{
		push_back(requested_entry(key,ptr));
	}

	void unregist(auto_ref<DCProxyAggr>& ptr)
	{
		for(iterator it=begin(); it!=end(); ++it)
		{
			if(	(*it).client_ ==  ptr )
				erase(it);
			else
				continue;
			break;
		};
	}
};



class DC_DBReg{
  mutable CriticalSection m_Mutex;
public:

	DC_DBReg():m_Mutex(THROW_LOCK) { };

	// Register a Pseudo Provider waiting for the decoupled partner
	void Register( const DC_DBkey&, auto_ref<DCProxyAggr>& );

	// UnRegister a Pseudo Provider
	void UnRegister( auto_ref<DCProxyAggr>& );

	// Register a Decoupled provider
	HRESULT Register( DC_reg& reg_ );

	// Unregister a Decoupled provider
	HRESULT UnRegister( const DC_DBkey&, const GUID a_Identity );

	auto_ref<DCProxyAggr> find(const DC_DBkey&) const;
	auto_ref<DCProxyAggr> GetAggregator(const DC_DBkey&) const;

private:
	requested_providers	aggregators_;
};



class DC_registrar : public _IWmiProviderSubsystemRegistrar 
					 
{
  static CriticalSection m_Mutex ;
  DC_DBReg mapping_database_;
private:



	LONG m_ReferenceCount ;         
	IWbemServicesPtr m_SubSystem ;

	DCProxyAggr&	m_cont();

	HRESULT CacheProvider (
		auto_ref<DCProxyAggr>& ,
		IWbemContext *a_Context ,
		CServerObject_DecoupledClientRegistration_Element &a_Element ,
		IUnknown *a_Unknown 
	) ;
public:

	CriticalSection& GetLock() { return m_Mutex; };
	void RegisterAggregator(const DC_DBkey& key, auto_ref<DCProxyAggr>& aggr){ return mapping_database_.Register(key,aggr);}
	void UnRegisterAggregator(auto_ref<DCProxyAggr>& aggr){ return mapping_database_.UnRegister(aggr);}
	auto_ref<DCProxyAggr> GetAggregator(const DC_DBkey& key) const { return mapping_database_.GetAggregator(key);}

	HRESULT Load (
		auto_ref<DCProxyAggr>& ,
		CServerObject_DecoupledClientRegistration_Element &a_Element
	) ;

	HRESULT MarshalRegistration (

		IUnknown *a_Unknown ,
		BYTE *&a_MarshaledProxy ,
		DWORD &a_MarshaledProxyLength
	) ;

	HRESULT SaveToRegistry (

		IUnknown *a_Unknown ,
		BYTE *a_MarshaledProxy ,
		DWORD a_MarshaledProxyLength
	) ;

public:

	DC_registrar () ;
	~DC_registrar () ;


	HRESULT Save () ;
	HRESULT Delete () ;

public:

	//Non-delegating object IUnknown

    STDMETHODIMP QueryInterface ( REFIID , LPVOID FAR * ) ;
    STDMETHODIMP_( ULONG ) AddRef () ;
    STDMETHODIMP_( ULONG ) Release () ;

	STDMETHODIMP Register (
		long a_Flags ,
		IWbemContext *a_Context ,
		LPCWSTR a_User ,
		LPCWSTR a_Locale ,
		LPCWSTR a_Registration ,
		LPCWSTR a_Scope ,
		DWORD a_ProcessIdentifier ,
		IUnknown *a_Unknown ,
		GUID a_Identity
	) ;

	STDMETHODIMP UnRegister (
		long a_Flags ,
		IWbemContext *a_Context ,
		LPCWSTR a_User ,
		LPCWSTR a_Locale ,
		LPCWSTR a_Scope ,
		LPCWSTR a_Registration ,
		GUID a_Identity
	) ;

	
	static DC_registrar * instance()
	{
			if (!instance_)
			{
			LockGuard<CriticalSection> lock(m_Mutex);
				if (!instance_)
					instance_ = new DC_registrar();
			}
			return instance_;
	}

	static DC_registrar * instance_;
};



class Dec_Delegate : public IWbemServices , public IWbemProviderInit , public IWbemShutdown
{
	Dec_Delegate( IUnknown * target);
};


class CInterceptor_IWbemDecoupledProvider;

class DCProxyAggr : public ServiceCacheElement ,
		    public CWbemGlobal_IWmiObjectSinkController
{
private:

	IWbemObjectSinkPtr m_Sink ;
	IWbemPathPtr m_NamespacePath ;


	LONG m_ReferenceCount ;         //Object reference count
	LONG m_UnRegistered ;         //Object reference count

	WmiAllocator &m_Allocator ;

	CriticalSection m_CriticalSection ;

	IWbemServicesPtr m_CoreService ;
	IWbemContextPtr m_context;

	IWbemClassObjectPtr m_Empty ;
	CWbemGlobal_IWbemSyncProviderController *m_Controller ;

	_bstr_t m_Namespace ;
	_bstr_t m_Locale ;
	_bstr_t m_User ;
	_bstr_t m_ProviderName ;
	LONG m_Flags;
	bool initialized_;

public:

	DCProxyAggr () ;
    ~DCProxyAggr () ;

public:

	//Non-delegating object IUnknown

    STDMETHODIMP_( ULONG ) AddRef () ;
    STDMETHODIMP_( ULONG ) Release () ;

    /* IWbemServices methods */

    
    
    
    
    HRESULT STDMETHODCALLTYPE GetObjectAsync (
        
		const BSTR a_ObjectPath ,
        long a_Flags ,
        IWbemContext *a_Context ,
        IWbemObjectSink *a_Sink
	) ;

    
    HRESULT STDMETHODCALLTYPE PutClassAsync ( 

        IWbemClassObject *a_Object ,
        long a_Flags ,
        IWbemContext *a_Context ,
        IWbemObjectSink *a_Sink
	) ;
    
    
    HRESULT STDMETHODCALLTYPE DeleteClassAsync ( 

        const BSTR a_Class ,
        long a_Flags ,
        IWbemContext *a_Context ,
        IWbemObjectSink *a_Sink
	) ;
    
    
    HRESULT STDMETHODCALLTYPE CreateClassEnumAsync ( 

		const BSTR a_Superclass ,
		long a_Flags ,
		IWbemContext *a_Context ,
		IWbemObjectSink *a_Sink
	) ;
    
    
    HRESULT STDMETHODCALLTYPE PutInstanceAsync (

		IWbemClassObject *a_Instance ,
		long a_Flags ,
		IWbemContext *a_Context ,
		IWbemObjectSink *a_Sink 
	) ;
    
    
    HRESULT STDMETHODCALLTYPE DeleteInstanceAsync ( 

		const BSTR a_ObjectPath,
		long a_Flags,
		IWbemContext *a_Context ,
		IWbemObjectSink *a_Sink
	) ;
    
    
    HRESULT STDMETHODCALLTYPE CreateInstanceEnumAsync (

		const BSTR a_Class ,
		long a_Flags ,
		IWbemContext *a_Context ,
		IWbemObjectSink *a_Sink
	) ;
    
    
    HRESULT STDMETHODCALLTYPE ExecQueryAsync (

		const BSTR a_QueryLanguage ,
		const BSTR a_Query ,
		long a_Flags ,
		IWbemContext *a_Context ,
		IWbemObjectSink *a_Sink
	) ;
    
    
    HRESULT STDMETHODCALLTYPE ExecMethodAsync ( 

		const BSTR a_ObjectPath ,
		const BSTR a_MethodName ,
		long a_Flags ,
		IWbemContext *a_Context ,
		IWbemClassObject *a_InParams ,
		IWbemObjectSink *a_Sink
	) ;

	/* IWbemProviderInit methods */

	HRESULT STDMETHODCALLTYPE Initialize (
	
		LPWSTR a_User ,
		LONG a_Flags ,
		LPWSTR a_Namespace ,
		LPWSTR a_Locale ,
		LPWSTR a_Name,
		IWbemServices *a_Core ,
		IWbemContext *a_Context ,
		IWbemProviderInitSink *a_Sink
	) ;

	// IWmi_UnInitialize members

	bool initialized() { return initialized_; };
	HRESULT LoadAll ( void );
	HRESULT Register ( DC_reg& ) ;

	HRESULT UnRegister ( GUID a_Identity ) ;
	HRESULT UnRegister(const CInterceptor_IWbemDecoupledProvider &);
	HRESULT InitializeProvider ( 

		IUnknown *a_Unknown ,
		IWbemServices *a_Stub ,
		wchar_t *a_NamespacePath ,
		LONG a_Flags ,
		IWbemContext *a_Context ,
		LPCWSTR a_User ,
		LPCWSTR a_Locale ,
		LPCWSTR a_Scope ,
		CServerObject_ProviderRegistrationV1 &a_Registration
	) ;

	HRESULT CreateSyncProvider ( 

		IUnknown *a_ServerSideProvider ,
		IWbemServices *a_Stub ,
		wchar_t *a_NamespacePath ,
		LONG a_Flags ,
		IWbemContext *a_Context ,
		LPCWSTR a_User ,
		LPCWSTR a_Locale ,
		LPCWSTR a_Scope ,
		CServerObject_ProviderRegistrationV1 &a_Registration ,
		GUID a_Identity ,
		CInterceptor_IWbemDecoupledProvider *&a_Interceptor 
	) ;

	HRESULT STDMETHODCALLTYPE ProvideEvents (
		IWbemObjectSink *a_Sink ,
		long a_Flags
	) ;

	HRESULT STDMETHODCALLTYPE AccessCheck (
		WBEM_CWSTR a_QueryLanguage ,
		WBEM_CWSTR a_Query ,
		long a_SidLength ,
		const BYTE *a_Sid
	);

	HRESULT STDMETHODCALLTYPE 
	NewQuery(
		unsigned long dwId,
		WBEM_WSTR wszQueryLanguage,
		WBEM_WSTR wszQuery
	);
	HRESULT STDMETHODCALLTYPE 
	CancelQuery(
		unsigned long dwId
	);

} ;

class DCProxy : public NULL_IWbemServices , 
		public IWbemProviderInit , 
		public IWbemEventProvider,
		public IWbemPropertyProvider,
		public IWbemEventProviderSecurity ,
		public IWbemProviderIdentity,
		public IWbemEventProviderQuerySink
{
private:
	enum { EVENT_PROVIDER, INSTANCE_PROVIDER } PROVIDER_MODE;
	
	auto_ref<DCProxyAggr> m_aggregator_;	

	
	IWbemObjectSink *m_Sink ;
	IWbemPath *m_NamespacePath ;


	LONG m_ReferenceCount ;         //Object reference count

	IWbemServicesPtr m_CoreService ;
	IWbemContextPtr m_Context;

	IWbemClassObjectPtr m_Empty ;
	CWbemGlobal_IWbemSyncProviderController *m_Controller ;

	_bstr_t m_Namespace ;
	_bstr_t m_Locale ;
	_bstr_t m_User ;
	_bstr_t m_ProviderName;

	long m_Flags;
	bool event_only_;

public:
  DCProxy ( ) ;
  ~DCProxy () ;

public:

	HRESULT Initialize(void ){ return S_OK;}
	//Non-delegating object IUnknown

    STDMETHODIMP QueryInterface ( REFIID , LPVOID FAR * ) ;
    STDMETHODIMP_( ULONG ) AddRef () ;
    STDMETHODIMP_( ULONG ) Release () ;

    /* IWbemServices methods */

    
    
    
    
    HRESULT STDMETHODCALLTYPE GetObjectAsync (
        
		const BSTR a_ObjectPath ,
        long a_Flags ,
        IWbemContext *a_Context ,
        IWbemObjectSink *a_Sink
	) ;

    
    HRESULT STDMETHODCALLTYPE PutInstanceAsync (

		IWbemClassObject *a_Instance ,
		long a_Flags ,
		IWbemContext *a_Context ,
		IWbemObjectSink *a_Sink 
	) ;
    
    
    HRESULT STDMETHODCALLTYPE DeleteInstanceAsync ( 

		const BSTR a_ObjectPath,
		long a_Flags,
		IWbemContext *a_Context ,
		IWbemObjectSink *a_Sink
	) ;
    
    
    HRESULT STDMETHODCALLTYPE CreateInstanceEnumAsync (

		const BSTR a_Class ,
		long a_Flags ,
		IWbemContext *a_Context ,
		IWbemObjectSink *a_Sink
	) ;
    
    
    HRESULT STDMETHODCALLTYPE ExecMethodAsync ( 

		const BSTR a_ObjectPath ,
		const BSTR a_MethodName ,
		long a_Flags ,
		IWbemContext *a_Context ,
		IWbemClassObject *a_InParams ,
		IWbemObjectSink *a_Sink
	) ;

	/* IWbemProviderInit methods */

	HRESULT STDMETHODCALLTYPE Initialize (

		LPWSTR a_User ,
		LONG a_Flags ,
		LPWSTR a_Namespace ,
		LPWSTR a_Locale ,
		IWbemServices *a_Core ,
		IWbemContext *a_Context ,
		IWbemProviderInitSink *a_Sink
	) ;


	HRESULT STDMETHODCALLTYPE ProvideEvents (
		IWbemObjectSink *a_Sink ,
		long a_Flags
	) ;

	HRESULT STDMETHODCALLTYPE SetRegistrationObject(
		long lFlags,
		IWbemClassObject* pProvReg
	);

	HRESULT STDMETHODCALLTYPE AccessCheck (
		WBEM_CWSTR a_QueryLanguage ,
		WBEM_CWSTR a_Query ,
		long a_SidLength ,
		const BYTE *a_Sid
	);
	
	HRESULT STDMETHODCALLTYPE 
	NewQuery(
		unsigned long dwId,
		WBEM_WSTR wszQueryLanguage,
		WBEM_WSTR wszQuery
	);
	HRESULT STDMETHODCALLTYPE 
	CancelQuery(
		unsigned long dwId
	);

	STDMETHODIMP
	ExecQueryAsync(
		const BSTR strQueryLanguage,                
		const BSTR strQuery,                        
		long lFlags,                       
		IWbemContext *pCtx,              
		IWbemObjectSink *pResponseHandler  
	);


	STDMETHODIMP GetProperty( long lFlags, const BSTR strLocale, const BSTR strClassMapping, 
				  const BSTR strInstMapping, const BSTR strPropMapping,  VARIANT *pvValue );
	STDMETHODIMP PutProperty( long lFlags, const BSTR strLocale, const BSTR strClassMapping, 
				  const BSTR strInstMapping, const BSTR strPropMapping,  const VARIANT *pvValue );


	bool initialized();
	HRESULT initialize_from_instance (const BSTR _path);
	HRESULT initialize( const BSTR);
	HRESULT initialize( IWbemClassObject * pObj);
	HRESULT _initialize( );	//real initialization
} ;



#endif // _ClassProvider_IWbemServices_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\provsubsys\decoupledadaptor\provdnf.cpp ===
/*++

Copyright (C) 1996-2001 Microsoft Corporation

Module Name:

	ProvTree.cpp

Abstract:


History:

--*/

#include <precomp.h>
#include <wbemint.h>
#include <typeinfo.h>
#include <stdio.h>

#include <HelperFuncs.h>
#include <Logging.h>

#include "ProvDnf.h"

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

WmiOrNode :: ~WmiOrNode ()
{
	delete m_Left ;
	delete m_Right ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

WmiAndNode :: ~WmiAndNode ()
{
	delete m_Left ;
	delete m_Right ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

WmiNotNode :: ~WmiNotNode ()
{
	delete m_Left ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

WmiOperatorEqualNode :: ~WmiOperatorEqualNode ()
{
	delete m_Left ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

WmiOperatorNotEqualNode :: ~WmiOperatorNotEqualNode ()
{
	delete m_Left ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

WmiOperatorEqualOrGreaterNode :: ~WmiOperatorEqualOrGreaterNode ()
{
	delete m_Left ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

WmiOperatorEqualOrLessNode :: ~WmiOperatorEqualOrLessNode ()
{
	delete m_Left ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

WmiOperatorGreaterNode :: ~WmiOperatorGreaterNode ()
{
	delete m_Left ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

WmiOperatorLessNode :: ~WmiOperatorLessNode ()
{
	delete m_Left ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

WmiOperatorLikeNode :: ~WmiOperatorLikeNode ()
{
	delete m_Left ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

WmiOperatorNotLikeNode :: ~WmiOperatorNotLikeNode ()
{
	delete m_Left ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

WmiOperatorIsANode :: ~WmiOperatorIsANode ()
{
	delete m_Left ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

WmiOperatorNotIsANode :: ~WmiOperatorNotIsANode ()
{
	delete m_Left ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

WmiTreeNode *WmiOrNode :: Copy () 
{
	WmiTreeNode *t_LeftCopy = NULL ;
	if ( m_Left )
	{
		t_LeftCopy = m_Left->Copy () ;
		if ( t_LeftCopy == NULL )
		{
			return NULL ;
		}
	}

	WmiTreeNode *t_RightCopy = NULL ;
	if ( m_Right )
	{
		t_RightCopy = m_Right->Copy () ;
		if ( t_RightCopy == NULL )
		{
			delete t_LeftCopy ;

			return NULL ;
		}
	}

	void *t_DataCopy = m_Data ;
	WmiTreeNode *t_Parent = m_Parent ;
	WmiTreeNode *t_Node = new WmiOrNode ( t_LeftCopy , t_RightCopy , t_Parent ) ;
	if ( t_Node )
	{
		if ( t_LeftCopy )
		{
			t_LeftCopy->SetParent ( t_Node ) ;
		}

		if ( t_RightCopy )
		{
			t_RightCopy->SetParent ( t_Node ) ;
		}
	}
	else
	{
		delete t_LeftCopy ;
		delete t_RightCopy ;
	}

	return t_Node ;
} ;

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

WmiTreeNode *WmiAndNode :: Copy () 
{
	WmiTreeNode *t_LeftCopy = NULL ;
	if ( m_Left )
	{
		t_LeftCopy = m_Left->Copy () ;
		if ( t_LeftCopy == NULL )
		{
			return NULL ;
		}
	}

	WmiTreeNode *t_RightCopy = NULL ;
	if ( m_Right )
	{
		t_RightCopy = m_Right->Copy () ;
		if ( t_RightCopy == NULL )
		{
			delete t_LeftCopy ;

			return NULL ;
		}
	}

	void *t_DataCopy = m_Data ;
	WmiTreeNode *t_Parent = m_Parent ;
	WmiTreeNode *t_Node = new WmiAndNode ( t_LeftCopy , t_RightCopy , t_Parent ) ;
	if ( t_Node )
	{
		if ( t_LeftCopy )
		{
			t_LeftCopy->SetParent ( t_Node ) ;
		}

		if ( t_RightCopy )
		{
			t_RightCopy->SetParent ( t_Node ) ;
		}
	}
	else
	{
		delete t_LeftCopy ;
		delete t_RightCopy ;
	}

	return t_Node ;
} ;

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

WmiTreeNode *WmiNotNode :: Copy () 
{
	WmiTreeNode *t_LeftCopy = NULL ;
	if ( m_Left )
	{
		t_LeftCopy = m_Left->Copy () ;
		if ( t_LeftCopy == NULL )
		{
			return NULL ;
		}
	}

	WmiTreeNode *t_Parent = m_Parent ;
	WmiTreeNode *t_Node = new WmiNotNode ( t_LeftCopy , t_Parent ) ;
	if ( t_Node )
	{
		if ( t_LeftCopy )
		{
			t_LeftCopy->SetParent ( t_Node ) ;
		}
	}
	else
	{
		delete t_LeftCopy ;
	}

	return t_Node ;
} ;

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

WmiTreeNode *WmiOperatorEqualNode :: Copy ()
{
	WmiTreeNode *t_LeftCopy = NULL ;
	if ( m_Left )
	{
		t_LeftCopy = m_Left->Copy () ;
		if ( t_LeftCopy == NULL )
		{
			return NULL ;
		}
	}

	WmiTreeNode *t_Parent = m_Parent ;
	WmiTreeNode *t_Node = new WmiOperatorEqualNode ( t_LeftCopy , t_Parent ) ;
	if ( t_Node )
	{
		if ( t_LeftCopy )
		{
			t_LeftCopy->SetParent ( t_Node ) ;
		}
	}
	else
	{
		delete t_LeftCopy ;
	}

	return t_Node ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

WmiTreeNode *WmiOperatorNotEqualNode :: Copy ()
{
	WmiTreeNode *t_LeftCopy = NULL ;
	if ( m_Left )
	{
		t_LeftCopy = m_Left->Copy () ;
		if ( t_LeftCopy == NULL )
		{
			return NULL ;
		}
	}

	WmiTreeNode *t_Parent = m_Parent ;
	WmiTreeNode *t_Node = new WmiOperatorNotEqualNode ( t_LeftCopy , t_Parent ) ;
	if ( t_Node )
	{
		if ( t_LeftCopy )
		{
			t_LeftCopy->SetParent ( t_Node ) ;
		}
	}
	else
	{
		delete t_LeftCopy ;
	}

	return t_Node ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

WmiTreeNode *WmiOperatorEqualOrGreaterNode :: Copy ()
{
	WmiTreeNode *t_LeftCopy = NULL ;
	if ( m_Left )
	{
		t_LeftCopy = m_Left->Copy () ;
		if ( t_LeftCopy == NULL )
		{
			return NULL ;
		}
	}

	WmiTreeNode *t_Parent = m_Parent ;
	WmiTreeNode *t_Node = new WmiOperatorEqualOrGreaterNode ( t_LeftCopy , t_Parent ) ;
	if ( t_Node )
	{
		if ( t_LeftCopy )
		{
			t_LeftCopy->SetParent ( t_Node ) ;
		}
	}
	else
	{
		delete t_LeftCopy ;
	}

	return t_Node ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

WmiTreeNode *WmiOperatorEqualOrLessNode :: Copy ()
{
	WmiTreeNode *t_LeftCopy = NULL ;
	if ( m_Left )
	{
		t_LeftCopy = m_Left->Copy () ;
		if ( t_LeftCopy == NULL )
		{
			return NULL ;
		}
	}

	WmiTreeNode *t_Parent = m_Parent ;
	WmiTreeNode *t_Node = new WmiOperatorEqualOrLessNode ( t_LeftCopy , t_Parent ) ;
	if ( t_Node )
	{
		if ( t_LeftCopy )
		{
			t_LeftCopy->SetParent ( t_Node ) ;
		}
	}
	else
	{
		delete t_LeftCopy ;
	}

	return t_Node ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

WmiTreeNode *WmiOperatorGreaterNode :: Copy ()
{
	WmiTreeNode *t_LeftCopy = NULL ;
	if ( m_Left )
	{
		t_LeftCopy = m_Left->Copy () ;
		if ( t_LeftCopy == NULL )
		{
			return NULL ;
		}
	}

	WmiTreeNode *t_Parent = m_Parent ;
	WmiTreeNode *t_Node = new WmiOperatorGreaterNode ( t_LeftCopy , t_Parent ) ;
	if ( t_Node )
	{
		if ( t_LeftCopy )
		{
			t_LeftCopy->SetParent ( t_Node ) ;
		}
	}
	else
	{
		delete t_LeftCopy ;
	}

	return t_Node ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

WmiTreeNode *WmiOperatorLessNode :: Copy ()
{
	WmiTreeNode *t_LeftCopy = NULL ;
	if ( m_Left )
	{
		t_LeftCopy = m_Left->Copy () ;
		if ( t_LeftCopy == NULL )
		{
			return NULL ;
		}
	}

	WmiTreeNode *t_Parent = m_Parent ;
	WmiTreeNode *t_Node = new WmiOperatorLessNode ( t_LeftCopy , t_Parent ) ;
	if ( t_Node )
	{
		if ( t_LeftCopy )
		{
			t_LeftCopy->SetParent ( t_Node ) ;
		}
	}
	else
	{
		delete t_LeftCopy ;
	}

	return t_Node ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

WmiTreeNode *WmiOperatorLikeNode :: Copy ()
{
	WmiTreeNode *t_LeftCopy = NULL ;
	if ( m_Left )
	{
		t_LeftCopy = m_Left->Copy () ;
		if ( t_LeftCopy == NULL )
		{
			return NULL ;
		}
	}

	WmiTreeNode *t_Parent = m_Parent ;
	WmiTreeNode *t_Node = new WmiOperatorLikeNode ( t_LeftCopy , t_Parent ) ;
	if ( t_Node )
	{
		if ( t_LeftCopy )
		{
			t_LeftCopy->SetParent ( t_Node ) ;
		}
	}
	else
	{
		delete t_LeftCopy ;
	}

	return t_Node ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

WmiTreeNode *WmiOperatorNotLikeNode :: Copy ()
{
	WmiTreeNode *t_LeftCopy = NULL ;
	if ( m_Left )
	{
		t_LeftCopy = m_Left->Copy () ;
		if ( t_LeftCopy == NULL )
		{
			return NULL ;
		}
	}

	WmiTreeNode *t_Parent = m_Parent ;
	WmiTreeNode *t_Node = new WmiOperatorNotLikeNode ( t_LeftCopy , t_Parent ) ;
	if ( t_Node )
	{
		if ( t_LeftCopy )
		{
			t_LeftCopy->SetParent ( t_Node ) ;
		}
	}
	else
	{
		delete t_LeftCopy ;
	}

	return t_Node ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

WmiTreeNode *WmiOperatorIsANode :: Copy ()
{
	WmiTreeNode *t_LeftCopy = NULL ;
	if ( m_Left )
	{
		t_LeftCopy = m_Left->Copy () ;
		if ( t_LeftCopy == NULL )
		{
			return NULL ;
		}
	}

	WmiTreeNode *t_Parent = m_Parent ;
	WmiTreeNode *t_Node = new WmiOperatorIsANode ( t_LeftCopy , t_Parent ) ;
	if ( t_Node )
	{
		if ( t_LeftCopy )
		{
			t_LeftCopy->SetParent ( t_Node ) ;
		}
	}
	else
	{
		delete t_LeftCopy ;
	}

	return t_Node ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

WmiTreeNode *WmiOperatorNotIsANode :: Copy ()
{
	WmiTreeNode *t_LeftCopy = NULL ;
	if ( m_Left )
	{
		t_LeftCopy = m_Left->Copy () ;
		if ( t_LeftCopy == NULL )
		{
			return NULL ;
		}
	}

	WmiTreeNode *t_Parent = m_Parent ;
	WmiTreeNode *t_Node = new WmiOperatorNotIsANode ( t_LeftCopy , t_Parent ) ;
	if ( t_Node )
	{	
		if ( t_LeftCopy )
		{
			t_LeftCopy->SetParent ( t_Node ) ;
		}
	}
	else
	{
		delete t_LeftCopy ;
	}

	return t_Node ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

WmiTreeNode *WmiSignedIntegerNode :: Copy ()
{
	WmiTreeNode *t_Parent = m_Parent ;
	WmiTreeNode *t_Node = new WmiSignedIntegerNode ( m_PropertyName , m_Integer , m_Index , t_Parent ) ;

	return t_Node ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

WmiTreeNode *WmiUnsignedIntegerNode :: Copy ()
{
	WmiTreeNode *t_Parent = m_Parent ;
	WmiTreeNode *t_Node = new WmiUnsignedIntegerNode ( m_PropertyName , m_Integer , m_Index , t_Parent ) ;

	return t_Node ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

WmiTreeNode *WmiStringNode :: Copy ()
{
	WmiTreeNode *t_Parent = m_Parent ;
	WmiTreeNode *t_Node = new WmiStringNode ( m_PropertyName , m_String , m_PropertyFunction , m_ConstantFunction , m_Index , t_Parent ) ;

	return t_Node ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

WmiTreeNode *WmiNullNode :: Copy ()
{
	WmiTreeNode *t_Parent = m_Parent ;
	WmiTreeNode *t_Node = new WmiNullNode ( m_PropertyName , m_Index , t_Parent ) ;

	return t_Node ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

WmiTreeNode *WmiSignedIntegerRangeNode :: Copy ()
{
	WmiTreeNode *t_Node = new WmiSignedIntegerRangeNode ( 

		m_PropertyName , 
		m_Index , 
		m_InfiniteLowerBound ,
		m_InfiniteUpperBound ,
		m_LowerBoundClosed ,
		m_UpperBoundClosed ,
		m_LowerBound ,
		m_UpperBound ,
		NULL , 
		NULL 
	) ;

	return t_Node ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

WmiTreeNode *WmiUnsignedIntegerRangeNode :: Copy ()
{
	WmiTreeNode *t_Node = new WmiUnsignedIntegerRangeNode ( 

		m_PropertyName , 
		m_Index , 
		m_InfiniteLowerBound ,
		m_InfiniteUpperBound ,
		m_LowerBoundClosed ,
		m_UpperBoundClosed ,
		m_LowerBound ,
		m_UpperBound ,
		NULL , 
		NULL 
	) ;

	return t_Node ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

WmiTreeNode *WmiStringRangeNode :: Copy ()
{
	WmiTreeNode *t_Node = new WmiStringRangeNode ( 

		m_PropertyName , 
		m_Index , 
		m_InfiniteLowerBound ,
		m_InfiniteUpperBound ,
		m_LowerBoundClosed ,
		m_UpperBoundClosed ,
		m_LowerBound ,
		m_UpperBound ,
		NULL , 
		NULL 
	) ;

	return t_Node ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

WmiTreeNode *WmiNullRangeNode :: Copy ()
{
	WmiTreeNode *t_Node = new WmiNullRangeNode ( m_PropertyName , m_Index , NULL , NULL ) ;

	return t_Node ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

void WmiOrNode :: Print ()
{
DebugMacro3( 

	WmiDebugLog :: s_WmiDebugLog->Write (  

		L" ( "
	) ;
)

	if ( GetLeft () )
		GetLeft ()->Print () ;

DebugMacro3( 

	WmiDebugLog :: s_WmiDebugLog->Write (  

		L" ) "
	) ;
)

DebugMacro3( 

	WmiDebugLog :: s_WmiDebugLog->Write (  

		L" Or "
	) ;
)

DebugMacro3( 

	WmiDebugLog :: s_WmiDebugLog->Write (  

		L" ( "
	) ;
)

	if ( GetRight () )
		GetRight ()->Print () ;

DebugMacro3( 

	WmiDebugLog :: s_WmiDebugLog->Write (  

		L" ) "
	) ;
)

}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

void WmiAndNode :: Print ()
{
DebugMacro3( 

	WmiDebugLog :: s_WmiDebugLog->Write (  

		L" ( "
	) ;
)

	if ( GetLeft () )
		GetLeft ()->Print () ;

DebugMacro3( 

	WmiDebugLog :: s_WmiDebugLog->Write (  

		L" ) "
	) ;
)

DebugMacro3( 

	WmiDebugLog :: s_WmiDebugLog->Write (  

		L" And "
	) ;
)

DebugMacro3( 

	WmiDebugLog :: s_WmiDebugLog->Write (  

		L" ( "
	) ;
)

	if ( GetRight () )
		GetRight ()->Print () ;

DebugMacro3( 

	WmiDebugLog :: s_WmiDebugLog->Write (  

		L" ) "
	) ;
)
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

void WmiNotNode :: Print ()
{
DebugMacro3( 

	WmiDebugLog :: s_WmiDebugLog->Write (  

		L"Not"
	) ;
)

DebugMacro3( 

	WmiDebugLog :: s_WmiDebugLog->Write (  

		L" ( "
	) ;
)

	if ( GetLeft () )
		GetLeft ()->Print () ;

DebugMacro3( 

	WmiDebugLog :: s_WmiDebugLog->Write (  

		L" ) "
	) ;
)
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

void WmiOperatorEqualNode :: Print ()
{
DebugMacro3( 

	WmiDebugLog :: s_WmiDebugLog->Write (  

		L" = "
	) ;
)
	if ( GetLeft () )
		GetLeft ()->Print () ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

void WmiOperatorNotEqualNode :: Print ()
{
DebugMacro3( 

	WmiDebugLog :: s_WmiDebugLog->Write (  

		L" != "
	) ;
)

	if ( GetLeft () )
		GetLeft ()->Print () ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

void WmiOperatorEqualOrGreaterNode :: Print ()
{
DebugMacro3( 

	WmiDebugLog :: s_WmiDebugLog->Write (  

		L" >= "
	) ;
)
	if ( GetLeft () )
		GetLeft ()->Print () ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

void WmiOperatorEqualOrLessNode :: Print () 
{
DebugMacro3( 

	WmiDebugLog :: s_WmiDebugLog->Write (  

		L" <= "
	) ;
)

	if ( GetLeft () )
		GetLeft ()->Print () ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

void WmiOperatorLessNode :: Print () 
{
DebugMacro3( 

	WmiDebugLog :: s_WmiDebugLog->Write (  

		L" < "
	) ;
)

	if ( GetLeft () )
		GetLeft ()->Print () ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

void WmiOperatorGreaterNode :: Print ()
{
DebugMacro3( 

	WmiDebugLog :: s_WmiDebugLog->Write (  

		L" > "
	) ;
)

	if ( GetLeft () )
		GetLeft ()->Print () ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

void WmiOperatorLikeNode :: Print ()
{
DebugMacro3( 

	WmiDebugLog :: s_WmiDebugLog->Write (  

		L" Like "
	) ;
)

	if ( GetLeft () )
		GetLeft ()->Print () ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

void WmiOperatorNotLikeNode :: Print ()
{
DebugMacro3( 

	WmiDebugLog :: s_WmiDebugLog->Write (  

		L" NotLike "
	) ;
)

	if ( GetLeft () )
		GetLeft ()->Print () ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

void WmiOperatorIsANode :: Print ()
{
DebugMacro3( 

	WmiDebugLog :: s_WmiDebugLog->Write (  

		L" IsA "
	) ;
)

	if ( GetLeft () )
		GetLeft ()->Print () ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

void WmiOperatorNotIsANode :: Print ()
{
DebugMacro3( 

	WmiDebugLog :: s_WmiDebugLog->Write (  

		L" Not IsA "
	) ;
)

	if ( GetLeft () )
		GetLeft ()->Print () ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

void WmiStringNode :: Print ()
{
DebugMacro3( 

	WmiDebugLog :: s_WmiDebugLog->Write (  

		L" ( %s , %s ) " ,
		GetPropertyName () ,
		GetValue ()
	) ;
)

}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

void WmiUnsignedIntegerNode :: Print ()
{
DebugMacro3( 

	WmiDebugLog :: s_WmiDebugLog->Write (  

		L" ( %s , %ld ) " ,
		GetPropertyName () ,
		GetValue ()
	) ;
)
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

void WmiSignedIntegerNode :: Print ()
{
DebugMacro3( 

	WmiDebugLog :: s_WmiDebugLog->Write (  

		L" ( %s , %d ) " ,
		GetPropertyName () ,
		GetValue ()
	) ;
)
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

void WmiNullNode :: Print ()
{
DebugMacro3( 

	WmiDebugLog :: s_WmiDebugLog->Write (  

		L" ( %s , NULL ) " ,
		GetPropertyName ()
	) ;
)
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

void WmiStringRangeNode :: Print ()
{
DebugMacro3( 

	WmiDebugLog :: s_WmiDebugLog->Write (  

		L" ( %s , %s , %s , %s , %s , %s , %s ) " ,
		GetPropertyName () ,
		m_InfiniteLowerBound ? L"Infinite" : L"Finite",
		m_InfiniteUpperBound ? L"Infinite" : L"Finite",
		m_LowerBoundClosed ? L"Closed" : L"Open" ,
		m_UpperBoundClosed ? L"Closed" : L"Open",
		m_InfiniteLowerBound ? L"" : m_LowerBound ,
		m_InfiniteUpperBound ? L"" : m_UpperBound 
	) ;
)

}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

void WmiUnsignedIntegerRangeNode :: Print ()
{
DebugMacro3( 

	WmiDebugLog :: s_WmiDebugLog->Write (  

		L" ( %s , %s , %s , %s , %s , %lu , %lu ) " ,
		GetPropertyName () ,
		m_InfiniteLowerBound ? L"Infinite" : L"Finite",
		m_InfiniteUpperBound ? L"Infinite" : L"Finite",
		m_LowerBoundClosed ? L"Closed" : L"Open" ,
		m_UpperBoundClosed ? L"Closed" : L"Open",
		m_InfiniteLowerBound ? 0 : m_LowerBound ,
		m_InfiniteUpperBound ? 0 : m_UpperBound  
	) ;
)
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

void WmiSignedIntegerRangeNode :: Print ()
{
DebugMacro3( 

	WmiDebugLog :: s_WmiDebugLog->Write (  

		L" ( %s , %s , %s , %s , %s , %ld , %ld ) " ,
		GetPropertyName () ,
		m_InfiniteLowerBound ? L"Infinite" : L"Finite",
		m_InfiniteUpperBound ? L"Infinite" : L"Finite",
		m_LowerBoundClosed ? L"Closed" : L"Open" ,
		m_UpperBoundClosed ? L"Closed" : L"Open",
		m_InfiniteLowerBound ? 0 : m_LowerBound ,
		m_InfiniteUpperBound ? 0 : m_UpperBound  
	) ;
)
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

void WmiNullRangeNode :: Print ()
{
DebugMacro3( 

	WmiDebugLog :: s_WmiDebugLog->Write (  

		L" ( %s , NULL ) " ,
		GetPropertyName ()
	) ;
)
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

BOOL CompareUnsignedIntegerLess (

	ULONG X ,
	LONG X_INFINITE ,
	ULONG Y ,
	LONG Y_INFINITE
) 
{
	if ( X_INFINITE < 0 )
	{
		if ( Y_INFINITE < 0 )
		{
			return FALSE ;
		}
		else if ( Y_INFINITE == 0 )
		{
			return TRUE ;
		}
		else
		{
			return TRUE ;
		}
	}
	else if ( X_INFINITE == 0 )
	{
		if ( Y_INFINITE < 0 )
		{
			return FALSE ;
		}
		else if ( Y_INFINITE == 0 )
		{
			return X < Y ;
		}
		else
		{
			return TRUE ;
		}
	}
	else
	{
		return FALSE ;
	}
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

BOOL CompareUnsignedIntegerLessOrEqual (

	ULONG X ,
	LONG X_INFINITE ,
	ULONG Y ,
	LONG Y_INFINITE
) 
{
	if ( X_INFINITE < 0 )
	{
		if ( Y_INFINITE < 0 )
		{
			return TRUE ;
		}
		else if ( Y_INFINITE == 0 )
		{
			return TRUE ;
		}
		else
		{
			return TRUE ;
		}
	}
	else if ( X_INFINITE == 0 )
	{
		if ( Y_INFINITE < 0 )
		{
			return FALSE ;
		}
		else if ( Y_INFINITE == 0 )
		{
			return X <= Y ;
		}
		else
		{
			return TRUE ;
		}
	}
	else
	{
   		if ( Y_INFINITE > 0 )
		{
			return TRUE ;
		}
		else
		{
			return FALSE ;
		}
	}
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

BOOL CompareUnsignedIntegerGreater (

	ULONG X ,
	LONG X_INFINITE ,
	ULONG Y ,
	LONG Y_INFINITE
) 
{
	if ( X_INFINITE < 0 )
	{
		return FALSE ;
	}
	else if ( X_INFINITE == 0 )
	{
		if ( Y_INFINITE < 0 )
		{
			return TRUE ;
		}
		else if ( Y_INFINITE == 0 )
		{
			return X > Y ;
		}
		else
		{
			return FALSE ;
		}
	}
	else
	{
		if ( Y_INFINITE < 0 )
		{
			return TRUE ;
		}
		else if ( Y_INFINITE == 0 )
		{
			return TRUE ;
		}
		else
		{
			return FALSE ;
		}
	}
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

BOOL CompareUnsignedIntegerEqual (

	ULONG X ,
	LONG X_INFINITE ,
	ULONG Y ,
	LONG Y_INFINITE
) 
{
	if ( X_INFINITE < 0 && Y_INFINITE < 0 )
	{
		return TRUE ;
	}
	else if ( X_INFINITE == 0 && Y_INFINITE == 0 )
	{
		return X == Y ;
	}
	else if ( X_INFINITE > 0 && Y_INFINITE > 0 )
	{
		return TRUE ;
	}
	else
	{
		return FALSE ;
	}
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

BOOL CompareSignedIntegerLess (

	LONG X ,
	LONG X_INFINITE ,
	LONG Y ,
	LONG Y_INFINITE
) 
{
	if ( X_INFINITE < 0 )
	{
		if ( Y_INFINITE < 0 )
		{
			return FALSE ;
		}
		else if ( Y_INFINITE == 0 )
		{
			return TRUE ;
		}
		else
		{
			return TRUE ;
		}
	}
	else if ( X_INFINITE == 0 )
	{
		if ( Y_INFINITE < 0 )
		{
			return FALSE ;
		}
		else if ( Y_INFINITE == 0 )
		{
			return X < Y ;
		}
		else
		{
			return TRUE ;
		}
	}
	else
	{
		return FALSE ;
	}
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

BOOL CompareSignedIntegerLessOrEqual (

	LONG X ,
	LONG X_INFINITE ,
	LONG Y ,
	LONG Y_INFINITE
) 
{
	if ( X_INFINITE < 0 )
	{
		if ( Y_INFINITE < 0 )
		{
			return TRUE ;
		}
		else if ( Y_INFINITE == 0 )
		{
			return TRUE ;
		}
		else
		{
			return TRUE ;
		}
	}
	else if ( X_INFINITE == 0 )
	{
		if ( Y_INFINITE < 0 )
		{
			return FALSE ;
		}
		else if ( Y_INFINITE == 0 )
		{
			return X <= Y ;
		}
		else
		{
			return TRUE ;
		}
	}
	else
	{
   		if ( Y_INFINITE > 0 )
		{
			return TRUE ;
		}
		else
		{
			return FALSE ;
		}
	}
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

BOOL CompareSignedIntegerGreater (

	LONG X ,
	LONG X_INFINITE ,
	LONG Y ,
	LONG Y_INFINITE
) 
{
	if ( X_INFINITE < 0 )
	{
		return FALSE ;
	}
	else if ( X_INFINITE == 0 )
	{
		if ( Y_INFINITE < 0 )
		{
			return TRUE ;
		}
		else if ( Y_INFINITE == 0 )
		{
			return X > Y ;
		}
		else
		{
			return FALSE ;
		}
	}
	else
	{
		if ( Y_INFINITE < 0 )
		{
			return TRUE ;
		}
		else if ( Y_INFINITE == 0 )
		{
			return TRUE ;
		}
		else
		{
			return FALSE ;
		}
	}
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

BOOL CompareSignedIntegerEqual (

	LONG X ,
	LONG X_INFINITE ,
	LONG Y ,
	LONG Y_INFINITE
) 
{
	if ( X_INFINITE < 0 && Y_INFINITE < 0 )
	{
		return TRUE ;
	}
	else if ( X_INFINITE == 0 && Y_INFINITE == 0 )
	{
		return X == Y ;
	}
	else if ( X_INFINITE > 0 && Y_INFINITE > 0 )
	{
		return TRUE ;
	}
	else
	{
		return FALSE ;
	}
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

BOOL CompareStringLess (

	BSTR X ,
	LONG X_INFINITE ,
	BSTR Y ,
	LONG Y_INFINITE
) 
{
	if ( X_INFINITE < 0 )
	{
		if ( Y_INFINITE < 0 )
		{
			return FALSE ;
		}
		else if ( Y_INFINITE == 0 )
		{
			return TRUE ;
		}
		else
		{
			return TRUE ;
		}
	}
	else if ( X_INFINITE == 0 )
	{
		if ( Y_INFINITE < 0 )
		{
			return FALSE ;
		}
		else if ( Y_INFINITE == 0 )
		{
			return wcscmp ( X , Y ) < 0 ;
		}
		else
		{
			return TRUE ;
		}
	}
	else
	{
  		return FALSE ;
	}
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

BOOL CompareStringLessOrEqual (

	BSTR X ,
	LONG X_INFINITE ,
	BSTR Y ,
	LONG Y_INFINITE
) 
{
	if ( X_INFINITE < 0 )
	{
		if ( Y_INFINITE < 0 )
		{
			return TRUE ;
		}
		else if ( Y_INFINITE == 0 )
		{
			return TRUE ;
		}
		else
		{
			return TRUE ;
		}
	}
	else if ( X_INFINITE == 0 )
	{
		if ( Y_INFINITE < 0 )
		{
			return FALSE ;
		}
		else if ( Y_INFINITE == 0 )
		{
			return wcscmp ( X , Y ) <= 0 ;
		}
		else
		{
			return TRUE ;
		}
	}
	else
	{
   		if ( Y_INFINITE > 0 )
		{
			return TRUE ;
		}
		else
		{
			return FALSE ;
		}
	}
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

BOOL CompareStringGreater (

	BSTR X ,
	LONG X_INFINITE ,
	BSTR Y ,
	LONG Y_INFINITE
) 
{
	if ( X_INFINITE < 0 )
	{
		return FALSE ;
	}
	else if ( X_INFINITE == 0 )
	{
		if ( Y_INFINITE < 0 )
		{
			return TRUE ;
		}
		else if ( Y_INFINITE == 0 )
		{
			return wcscmp ( X , Y ) > 0 ;
		}
		else
		{
			return FALSE ;
		}
	}
	else
	{
		if ( Y_INFINITE < 0 )
		{
			return TRUE ;
		}
		else if ( Y_INFINITE == 0 )
		{
			return TRUE ;
		}
		else
		{
			return FALSE ;
		}
	}
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

BOOL CompareStringEqual (

	BSTR X ,
	LONG X_INFINITE ,
	BSTR Y ,
	LONG Y_INFINITE
) 
{
	if ( X_INFINITE < 0 && Y_INFINITE < 0 )
	{
		return TRUE ;
	}
	else if ( X_INFINITE == 0 && Y_INFINITE == 0 )
	{
		return wcscmp ( X , Y ) == 0 ;
	}
	else if ( X_INFINITE > 0 && Y_INFINITE > 0 )
	{
		return TRUE ;
	}
	else
	{
		return FALSE ;
	}
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

BOOL CompareLessRangeNode ( 

	WmiRangeNode *a_LeftRange ,
	WmiRangeNode *a_RightRange
) 
{
	LONG t_State = 0 ;

	if ( ( a_LeftRange->GetType () == TypeId_WmiStringRangeNode ) && ( a_RightRange->GetType () == TypeId_WmiStringRangeNode ) )
	{
		WmiStringRangeNode *t_LeftString = ( WmiStringRangeNode * ) a_LeftRange ;
		WmiStringRangeNode *t_RightString = ( WmiStringRangeNode * ) a_RightRange ;

		t_State = CompareStringLess ( 

			t_LeftString->LowerBound () , 
			t_LeftString->InfiniteLowerBound () ? -1 : 0 ,
			t_RightString->LowerBound () ,
			t_RightString->InfiniteLowerBound () ? -1 : 0
		) ;
	}
	else if ( ( a_LeftRange->GetType () == TypeId_WmiSignedIntegerRangeNode ) && ( a_RightRange->GetType () == TypeId_WmiSignedIntegerRangeNode ) )
	{
		WmiSignedIntegerRangeNode *t_LeftInteger = ( WmiSignedIntegerRangeNode * ) a_LeftRange ;
		WmiSignedIntegerRangeNode *t_RightInteger = ( WmiSignedIntegerRangeNode * ) a_RightRange ;

		t_State = CompareSignedIntegerLess ( 

			t_LeftInteger->LowerBound () , 
			t_LeftInteger->InfiniteLowerBound () ? -1 : 0 ,
			t_RightInteger->LowerBound () ,
			t_RightInteger->InfiniteLowerBound () ? -1 : 0
		) ;
	}
	else if ( ( a_LeftRange->GetType () == TypeId_WmiUnsignedIntegerRangeNode ) && ( a_RightRange->GetType () == TypeId_WmiUnsignedIntegerRangeNode ) )
	{
		WmiUnsignedIntegerRangeNode *t_LeftInteger = ( WmiUnsignedIntegerRangeNode * ) a_LeftRange ;
		WmiUnsignedIntegerRangeNode *t_RightInteger = ( WmiUnsignedIntegerRangeNode * ) a_RightRange ;

		t_State = CompareUnsignedIntegerLess ( 

			t_LeftInteger->LowerBound () , 
			t_LeftInteger->InfiniteLowerBound () ? -1 : 0 ,
			t_RightInteger->LowerBound () ,
			t_RightInteger->InfiniteLowerBound () ? -1 : 0
		) ;
	}
	else if ( ( a_LeftRange->GetType () == TypeId_WmiNullRangeNode ) && ( a_RightRange->GetType () == TypeId_WmiNullRangeNode ) )
	{
		t_State = TRUE ;
	}

	return t_State ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

BOOL CompareLessOrEqualRangeNode ( 

	WmiRangeNode *a_LeftRange ,
	WmiRangeNode *a_RightRange
) 
{
	LONG t_State = 0 ;

	if ( ( a_LeftRange->GetType () == TypeId_WmiStringRangeNode ) && ( a_RightRange->GetType () == TypeId_WmiStringRangeNode ) )
	{
		WmiStringRangeNode *t_LeftString = ( WmiStringRangeNode * ) a_LeftRange ;
		WmiStringRangeNode *t_RightString = ( WmiStringRangeNode * ) a_RightRange ;

		t_State = CompareStringLessOrEqual ( 

			t_LeftString->LowerBound () , 
			t_LeftString->InfiniteLowerBound () ? -1 : 0 ,
			t_RightString->LowerBound () ,
			t_RightString->InfiniteLowerBound () ? -1 : 0
		) ;
	}
	else if ( ( a_LeftRange->GetType () == TypeId_WmiSignedIntegerRangeNode ) && ( a_RightRange->GetType () == TypeId_WmiSignedIntegerRangeNode ) )
	{
		WmiSignedIntegerRangeNode *t_LeftInteger = ( WmiSignedIntegerRangeNode * ) a_LeftRange ;
		WmiSignedIntegerRangeNode *t_RightInteger = ( WmiSignedIntegerRangeNode * ) a_RightRange ;

		t_State = CompareSignedIntegerLessOrEqual ( 

			t_LeftInteger->LowerBound () , 
			t_LeftInteger->InfiniteLowerBound () ? -1 : 0 ,
			t_RightInteger->LowerBound () ,
			t_RightInteger->InfiniteLowerBound () ? -1 : 0
		) ;
	}
	else if ( ( a_LeftRange->GetType () == TypeId_WmiUnsignedIntegerRangeNode ) && ( a_RightRange->GetType () == TypeId_WmiUnsignedIntegerRangeNode ) )
	{
		WmiUnsignedIntegerRangeNode *t_LeftInteger = ( WmiUnsignedIntegerRangeNode * ) a_LeftRange ;
		WmiUnsignedIntegerRangeNode *t_RightInteger = ( WmiUnsignedIntegerRangeNode * ) a_RightRange ;

		t_State = CompareUnsignedIntegerLessOrEqual ( 

			t_LeftInteger->LowerBound () , 
			t_LeftInteger->InfiniteLowerBound () ? -1 : 0 ,
			t_RightInteger->LowerBound () ,
			t_RightInteger->InfiniteLowerBound () ? -1 : 0
		) ;
	}
	else if ( ( a_LeftRange->GetType () == TypeId_WmiNullRangeNode ) && ( a_RightRange->GetType () == TypeId_WmiNullRangeNode ) )
	{
		t_State = TRUE ;
	}

	return t_State ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

WmiTriState WmiUnsignedIntegerRangeNode :: GetIntersectingRange ( 

	WmiUnsignedIntegerRangeNode &a_UnsignedInteger ,
	WmiUnsignedIntegerRangeNode *&a_Intersection 
)
{
	WmiTriState t_Status = WmiTriState :: State_False ;

// A weak ( open ) relationship is ( < , > ) 
// A strong ( closed ) relationship is ( == , <= , >= )

	a_Intersection = NULL ;

	ULONG X_S = m_LowerBound ;
	ULONG X_E = m_UpperBound ;
	ULONG Y_S = a_UnsignedInteger.m_LowerBound ;
	ULONG Y_E = a_UnsignedInteger.m_UpperBound ;

	BOOL X_S_CLOSED = m_LowerBoundClosed ;
	BOOL X_E_CLOSED = m_UpperBoundClosed ;
	BOOL Y_S_CLOSED = a_UnsignedInteger.m_LowerBoundClosed ;
	BOOL Y_E_CLOSED = a_UnsignedInteger.m_UpperBoundClosed ;

	BOOL X_S_INFINITE = m_InfiniteLowerBound ;
	BOOL X_E_INFINITE = m_InfiniteUpperBound ;
	BOOL Y_S_INFINITE = a_UnsignedInteger.m_InfiniteLowerBound ;
	BOOL Y_E_INFINITE = a_UnsignedInteger.m_InfiniteUpperBound ;

	if ( CompareUnsignedIntegerLess ( X_S ,  X_S_INFINITE ? - 1 : 0 , Y_S , Y_S_INFINITE ? -1 : 0 ) ) // ( X_S < Y_S )
	{
		if ( CompareUnsignedIntegerLess ( Y_S ,  Y_S_INFINITE ? -1 : 0 , X_E , X_E_INFINITE ? 1 : 0 ) ) // ( Y_S < X_E )
		{
			if ( CompareUnsignedIntegerLess ( X_E ,  X_E_INFINITE ? 1 : 0 , Y_E , Y_E_INFINITE ? 1 : 0 ) ) // ( X_E < Y_E )
			{
//				Order ( X_S < Y_S < X_E < Y_E )
//				Range ( Y_S , X_E ) 

				a_Intersection = new WmiUnsignedIntegerRangeNode (

					m_PropertyName ,
					m_Index ,
					Y_S_INFINITE ,
					X_E_INFINITE ,
					Y_S_CLOSED ,						// Relationship is as strong as ordering 
					X_E_CLOSED ,						// Relationship is as strong as ordering 
					Y_S ,
					X_E ,
					NULL ,
					NULL
				) ;

				t_Status = ( a_Intersection ) ? ( WmiTriState :: State_True ) : ( WmiTriState :: State_Error ) ;
			}
			else if ( CompareUnsignedIntegerEqual ( X_E ,  X_E_INFINITE ? 1 : 0 , Y_E , Y_E_INFINITE ? 1 : 0 ) ) // ( X_E == Y_E )
			{
//				Order ( X_S < Y_S < X_E == Y_E )
//				Range ( Y_S , X_E ) 

				a_Intersection = new WmiUnsignedIntegerRangeNode (

					m_PropertyName ,
					m_Index ,
					Y_S_INFINITE ,
					X_E_INFINITE ,
					Y_S_CLOSED  ,						// Relationship is as strong as ordering 
					X_E_CLOSED && Y_E_CLOSED ,			// Check for weak relationship ( < , > ) 
					Y_S ,
					X_E ,
					NULL ,
					NULL
				) ;

				t_Status = ( a_Intersection ) ? ( WmiTriState :: State_True ) : ( WmiTriState :: State_Error ) ;
			}
			else if ( CompareUnsignedIntegerGreater ( X_E ,  X_E_INFINITE ? 1 : 0 , Y_E , Y_E_INFINITE ? 1 : 0 ) ) // ( X_E > Y_E ) 
			{
//				Order ( X_S < Y_S < Y_E < X_E )
//				Range ( Y_S , Y_E )

				a_Intersection = new WmiUnsignedIntegerRangeNode (

					m_PropertyName ,
					m_Index ,
					Y_S_INFINITE ,
					Y_E_INFINITE ,
					Y_S_CLOSED ,						// Relationship is as strong as ordering 
					Y_E_CLOSED ,						// Relationship is as strong as ordering 
					Y_S ,
					Y_E ,
					NULL ,
					NULL
				) ;

				t_Status = ( a_Intersection ) ? ( WmiTriState :: State_True ) : ( WmiTriState :: State_Error ) ;
			}
		}
		else if ( CompareUnsignedIntegerEqual ( Y_S ,  Y_S_INFINITE ? -1 : 0 , X_E , X_E_INFINITE ? 1 : 0 ) )  // ( Y_S == X_E ), Start of Y and End Of X overlap
		{
			if ( Y_S_CLOSED && X_E_CLOSED )
			{
//				Order ( X_S < Y_S == X_E )
//				Range ( Y_S , X_E ) 

				a_Intersection = new WmiUnsignedIntegerRangeNode (

					m_PropertyName ,
					m_Index ,
					FALSE ,
					FALSE  ,
					TRUE ,
					TRUE ,
					Y_S ,
					Y_S ,
					NULL ,
					NULL
				) ;

				t_Status = ( a_Intersection ) ? ( WmiTriState :: State_True ) : ( WmiTriState :: State_Error ) ;
			}
			else
			{
// Empty set
			}
		}
		else if ( CompareUnsignedIntegerGreater ( Y_S ,  Y_S_INFINITE ? -1 : 0 , X_E , X_E_INFINITE ? 1 : 0 ) ) // ( Y_S > X_E )
		{
//				Order ( X_S < Y_S , X_E < Y_S )
//				Non overlapping regions therefore empty set
		}
	}
	else if ( CompareUnsignedIntegerEqual ( X_S ,  X_S_INFINITE ? -1 : 0 , Y_S , Y_S_INFINITE ? -1 : 0 ) ) // ( X_S == Y_S ) 
	{
		if ( CompareUnsignedIntegerLess ( Y_S ,  Y_S_INFINITE ? -1 : 0 , X_E , X_E_INFINITE ? 1 : 0 ) ) // ( Y_S < X_E )
		{
			if ( CompareUnsignedIntegerLess ( X_E ,  X_E_INFINITE ? 1 : 0 , Y_E , Y_E_INFINITE ? 1 : 0 ) ) // ( X_E < Y_E )
			{
//				Order ( X_S == Y_S < X_E < Y_E )
//				Range ( Y_S , X_E )

				a_Intersection = new WmiUnsignedIntegerRangeNode (

					m_PropertyName ,
					m_Index ,
					Y_S_INFINITE ,
					Y_E_INFINITE ,
					X_S_CLOSED && Y_S_CLOSED ,		// Check for weak relationship ( < , > ) 
					X_E_CLOSED ,					// Relationship is as strong as ordering 
					Y_S ,
					X_E ,
					NULL ,
					NULL
				) ;

				t_Status = ( a_Intersection ) ? ( WmiTriState :: State_True ) : ( WmiTriState :: State_Error ) ;
			}
			else if ( CompareUnsignedIntegerEqual ( X_E ,  X_E_INFINITE ? 1 : 0 , Y_E , Y_E_INFINITE ? 1 : 0 ) ) // ( X_E == Y_E )
			{
//				Order ( X_S == Y_S < X_E == Y_E )
//				Range ( X_S , X_E )

				a_Intersection = new WmiUnsignedIntegerRangeNode (

					m_PropertyName ,
					m_Index ,
					Y_S_INFINITE ,
					Y_E_INFINITE ,
					X_S_CLOSED && Y_S_CLOSED ,		// Check for weak relationship ( < , > ) 
					Y_E_CLOSED && X_E_CLOSED ,		// Check for weak relationship ( < , > ) 
					X_S ,
					X_E ,
					NULL ,
					NULL
				) ;

				t_Status = ( a_Intersection ) ? ( WmiTriState :: State_True ) : ( WmiTriState :: State_Error ) ;
			}
			else if ( CompareUnsignedIntegerGreater ( X_E ,  X_E_INFINITE ? 1 : 0 , Y_E , Y_E_INFINITE ? 1 : 0 ) ) // ( X_E > Y_E )
			{
//				Order ( X_S == Y_S < Y_E < X_E )
//				Range ( X_S , Y_E )

				a_Intersection = new WmiUnsignedIntegerRangeNode (

					m_PropertyName ,
					m_Index ,
					Y_S_INFINITE ,
					Y_E_INFINITE ,
					X_S_CLOSED && Y_S_CLOSED ,		// Check for weak relationship ( < , > ) 
					Y_E_CLOSED ,					// Relationship is as strong as ordering 
					X_S ,
					Y_E ,
					NULL ,
					NULL
				) ;

				t_Status = ( a_Intersection ) ? ( WmiTriState :: State_True ) : ( WmiTriState :: State_Error ) ;
			}
		}
		else if ( CompareUnsignedIntegerEqual ( Y_S ,  Y_S_INFINITE ? -1 : 0 , X_E , X_E_INFINITE ? 1 : 0 ) ) // ( Y_S == X_E ), Start of Y and End Of X overlap
		{
			if ( Y_S_CLOSED && X_E_CLOSED )
			{
//				Order ( X_S == Y_S == X_E )
//				Range ( Y_S , Y_E ) 

				a_Intersection = new WmiUnsignedIntegerRangeNode (

					m_PropertyName ,
					m_Index ,
					FALSE ,
					FALSE  ,
					TRUE ,
					TRUE ,
					Y_S ,
					Y_S ,
					NULL ,
					NULL
				) ;

				t_Status = ( a_Intersection ) ? ( WmiTriState :: State_True ) : ( WmiTriState :: State_Error ) ;
			}
			else
			{
// Empty set
			}
		}
		else if ( CompareUnsignedIntegerGreater ( Y_S ,  Y_S_INFINITE ? -1 : 0 , X_E , X_E_INFINITE ? 1 : 0 ) )  // ( Y_S > X_E )
		{
// Can never happen
DebugBreak () ;
		}
	}
	else if ( CompareUnsignedIntegerGreater ( X_S ,  X_S_INFINITE ? -1 : 0 , Y_S , Y_S_INFINITE ? -1 : 0 ) ) // ( X_S > Y_S )
	{
		if ( CompareUnsignedIntegerLess ( X_S ,  X_S_INFINITE ? -1 : 0 , Y_E , Y_E_INFINITE ? 1 : 0 ) ) // ( X_S < Y_E )
		{
			if ( CompareUnsignedIntegerLess ( Y_E ,  Y_E_INFINITE ? 1 : 0 , X_E , X_E_INFINITE ? 1 : 0 ) ) // ( Y_E < X_E )
			{
//				Order ( Y_S < X_S < Y_E < X_E )
//				Range ( X_S , Y_E ) 

				a_Intersection = new WmiUnsignedIntegerRangeNode (

					m_PropertyName ,
					m_Index ,
					X_S_INFINITE ,
					Y_E_INFINITE ,
					X_S_CLOSED ,						// Relationship is as strong as ordering 
					Y_E_CLOSED ,						// Relationship is as strong as ordering 
					X_S ,
					Y_E ,
					NULL ,
					NULL
				) ;

				t_Status = ( a_Intersection ) ? ( WmiTriState :: State_True ) : ( WmiTriState :: State_Error ) ;
			}
			else if ( CompareUnsignedIntegerEqual ( Y_E ,  Y_E_INFINITE ? 1 : 0 , X_E , X_E_INFINITE ? 1 : 0 ) ) // ( Y_E == X_E )
			{
//				Order ( Y_S < X_S < Y_E == X_E )
//				Range ( X_S , Y_E ) 

				a_Intersection = new WmiUnsignedIntegerRangeNode (

					m_PropertyName ,
					m_Index ,
					X_S_INFINITE ,
					Y_E_INFINITE ,
					X_S_CLOSED ,						// Relationship is as strong as ordering 
					Y_E_CLOSED && X_E_CLOSED ,			// Check for weak relationship ( < , > ) 
					X_S ,
					Y_E ,
					NULL ,
					NULL
				) ;

				t_Status = ( a_Intersection ) ? ( WmiTriState :: State_True ) : ( WmiTriState :: State_Error ) ;
			}
			else if ( CompareUnsignedIntegerGreater ( Y_E ,  Y_E_INFINITE ? 1 : 0 , X_E , X_E_INFINITE ? 1 : 0 ) ) // ( Y_E > X_E )
			{
//				Order ( Y_S < X_S < X_E < Y_E )
//				Range ( X_S , X_E ) 

				a_Intersection = new WmiUnsignedIntegerRangeNode (

					m_PropertyName ,
					m_Index ,
					X_S_INFINITE ,
					X_E_INFINITE ,
					X_S_CLOSED ,						// Relationship is as strong as ordering 
					X_E_CLOSED ,						// Relationship is as strong as ordering 
					X_S ,
					X_E ,
					NULL ,
					NULL
				) ;

				t_Status = ( a_Intersection ) ? ( WmiTriState :: State_True ) : ( WmiTriState :: State_Error ) ;
			}
		}
		else if ( CompareUnsignedIntegerEqual ( X_S ,  X_S_INFINITE ? -1 : 0 , Y_E , Y_E_INFINITE ? 1 : 0 ) ) // ( X_S == Y_E ), Start of X and End Of Y overlap
		{
			if ( X_S_CLOSED && Y_E_CLOSED )
			{
//				Order ( Y_S < X_S == X_E )
//				Range ( X_S , Y_E ) 

				a_Intersection = new WmiUnsignedIntegerRangeNode (

					m_PropertyName ,
					m_Index ,
					FALSE ,
					FALSE  ,
					TRUE ,
					TRUE ,
					X_S ,
					X_S ,
					NULL ,
					NULL
				) ;

				t_Status = ( a_Intersection ) ? ( WmiTriState :: State_True ) : ( WmiTriState :: State_Error ) ;
			}
			else
			{
// Empty set
			}
		}
		else if ( CompareUnsignedIntegerGreater ( X_S ,  X_S_INFINITE ? -1 : 0 , Y_E , Y_E_INFINITE ? 1 : 0 ) ) // ( X_S > Y_E )
		{
// Empty
		}
	}

	return t_Status ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

WmiTriState WmiSignedIntegerRangeNode :: GetIntersectingRange ( 

	WmiSignedIntegerRangeNode &a_SignedInteger ,
	WmiSignedIntegerRangeNode *&a_Intersection 
)
{
	WmiTriState t_Status = WmiTriState :: State_False ;

// A weak ( open ) relationship is ( < , > ) 
// A strong ( closed ) relationship is ( == , <= , >= )

	a_Intersection = NULL ;

	LONG X_S = m_LowerBound ;
	LONG X_E = m_UpperBound ;
	LONG Y_S = a_SignedInteger.m_LowerBound ;
	LONG Y_E = a_SignedInteger.m_UpperBound ;

	BOOL X_S_CLOSED = m_LowerBoundClosed ;
	BOOL X_E_CLOSED = m_UpperBoundClosed ;
	BOOL Y_S_CLOSED = a_SignedInteger.m_LowerBoundClosed ;
	BOOL Y_E_CLOSED = a_SignedInteger.m_UpperBoundClosed ;

	BOOL X_S_INFINITE = m_InfiniteLowerBound ;
	BOOL X_E_INFINITE = m_InfiniteUpperBound ;
	BOOL Y_S_INFINITE = a_SignedInteger.m_InfiniteLowerBound ;
	BOOL Y_E_INFINITE = a_SignedInteger.m_InfiniteUpperBound ;

	if ( CompareSignedIntegerLess ( X_S ,  X_S_INFINITE ? - 1 : 0 , Y_S , Y_S_INFINITE ? -1 : 0 ) ) // ( X_S < Y_S )
	{
		if ( CompareSignedIntegerLess ( Y_S ,  Y_S_INFINITE ? -1 : 0 , X_E , X_E_INFINITE ? 1 : 0 ) ) // ( Y_S < X_E )
		{
			if ( CompareSignedIntegerLess ( X_E ,  X_E_INFINITE ? 1 : 0 , Y_E , Y_E_INFINITE ? 1 : 0 ) ) // ( X_E < Y_E )
			{
//				Order ( X_S < Y_S < X_E < Y_E )
//				Range ( Y_S , X_E ) 

				a_Intersection = new WmiSignedIntegerRangeNode (

					m_PropertyName ,
					m_Index ,
					Y_S_INFINITE ,
					X_E_INFINITE ,
					Y_S_CLOSED ,						// Relationship is as strong as ordering 
					X_E_CLOSED ,						// Relationship is as strong as ordering 
					Y_S ,
					X_E ,
					NULL ,
					NULL
				) ;

				t_Status = ( a_Intersection ) ? ( WmiTriState :: State_True ) : ( WmiTriState :: State_Error ) ;
			}
			else if ( CompareSignedIntegerEqual ( X_E ,  X_E_INFINITE ? 1 : 0 , Y_E , Y_E_INFINITE ? 1 : 0 ) ) // ( X_E == Y_E )
			{
//				Order ( X_S < Y_S < X_E == Y_E )
//				Range ( Y_S , X_E ) 

				a_Intersection = new WmiSignedIntegerRangeNode (

					m_PropertyName ,
					m_Index ,
					Y_S_INFINITE ,
					X_E_INFINITE ,
					Y_S_CLOSED  ,						// Relationship is as strong as ordering 
					X_E_CLOSED && Y_E_CLOSED ,			// Check for weak relationship ( < , > ) 
					Y_S ,
					X_E ,
					NULL ,
					NULL
				) ;

				t_Status = ( a_Intersection ) ? ( WmiTriState :: State_True ) : ( WmiTriState :: State_Error ) ;
			}
			else if ( CompareSignedIntegerGreater ( X_E ,  X_E_INFINITE ? 1 : 0 , Y_E , Y_E_INFINITE ? 1 : 0 ) ) // ( X_E > Y_E ) 
			{
//				Order ( X_S < Y_S < Y_E < X_E )
//				Range ( Y_S , Y_E )

				a_Intersection = new WmiSignedIntegerRangeNode (

					m_PropertyName ,
					m_Index ,
					Y_S_INFINITE ,
					Y_E_INFINITE ,
					Y_S_CLOSED ,						// Relationship is as strong as ordering 
					Y_E_CLOSED ,						// Relationship is as strong as ordering 
					Y_S ,
					Y_E ,
					NULL ,
					NULL
				) ;

				t_Status = ( a_Intersection ) ? ( WmiTriState :: State_True ) : ( WmiTriState :: State_Error ) ;
			}
		}
		else if ( CompareSignedIntegerEqual ( Y_S ,  Y_S_INFINITE ? -1 : 0 , X_E , X_E_INFINITE ? 1 : 0 ) )  // ( Y_S == X_E ), Start of Y and End Of X overlap
		{
			if ( Y_S_CLOSED && X_E_CLOSED )
			{
//				Order ( X_S < Y_S == X_E )
//				Range ( Y_S , X_E ) 

				a_Intersection = new WmiSignedIntegerRangeNode (

					m_PropertyName ,
					m_Index ,
					FALSE ,
					FALSE  ,
					TRUE ,
					TRUE ,
					Y_S ,
					Y_S ,
					NULL ,
					NULL
				) ;

				t_Status = ( a_Intersection ) ? ( WmiTriState :: State_True ) : ( WmiTriState :: State_Error ) ;
			}
			else
			{
// Empty set
			}
		}
		else if ( CompareSignedIntegerGreater ( Y_S ,  Y_S_INFINITE ? -1 : 0 , X_E , X_E_INFINITE ? 1 : 0 ) ) // ( Y_S > X_E )
		{
//				Order ( X_S < Y_S , X_E < Y_S )
//				Non overlapping regions therefore empty set
		}
	}
	else if ( CompareSignedIntegerEqual ( X_S ,  X_S_INFINITE ? -1 : 0 , Y_S , Y_S_INFINITE ? -1 : 0 ) ) // ( X_S == Y_S ) 
	{
		if ( CompareSignedIntegerLess ( Y_S ,  Y_S_INFINITE ? -1 : 0 , X_E , X_E_INFINITE ? 1 : 0 ) ) // ( Y_S < X_E )
		{
			if ( CompareSignedIntegerLess ( X_E ,  X_E_INFINITE ? 1 : 0 , Y_E , Y_E_INFINITE ? 1 : 0 ) ) // ( X_E < Y_E )
			{
//				Order ( X_S == Y_S < X_E < Y_E )
//				Range ( Y_S , X_E )

				a_Intersection = new WmiSignedIntegerRangeNode (

					m_PropertyName ,
					m_Index ,
					Y_S_INFINITE ,
					Y_E_INFINITE ,
					X_S_CLOSED && Y_S_CLOSED ,		// Check for weak relationship ( < , > ) 
					X_E_CLOSED ,					// Relationship is as strong as ordering 
					Y_S ,
					X_E ,
					NULL ,
					NULL
				) ;

				t_Status = ( a_Intersection ) ? ( WmiTriState :: State_True ) : ( WmiTriState :: State_Error ) ;
			}
			else if ( CompareSignedIntegerEqual ( X_E ,  X_E_INFINITE ? 1 : 0 , Y_E , Y_E_INFINITE ? 1 : 0 ) ) // ( X_E == Y_E )
			{
//				Order ( X_S == Y_S < X_E == Y_E )
//				Range ( X_S , X_E )

				a_Intersection = new WmiSignedIntegerRangeNode (

					m_PropertyName ,
					m_Index ,
					Y_S_INFINITE ,
					Y_E_INFINITE ,
					X_S_CLOSED && Y_S_CLOSED ,		// Check for weak relationship ( < , > ) 
					Y_E_CLOSED && X_E_CLOSED ,		// Check for weak relationship ( < , > ) 
					X_S ,
					X_E ,
					NULL ,
					NULL
				) ;

				t_Status = ( a_Intersection ) ? ( WmiTriState :: State_True ) : ( WmiTriState :: State_Error ) ;
			}
			else if ( CompareSignedIntegerGreater ( X_E ,  X_E_INFINITE ? 1 : 0 , Y_E , Y_E_INFINITE ? 1 : 0 ) ) // ( X_E > Y_E )
			{
//				Order ( X_S == Y_S < Y_E < X_E )
//				Range ( X_S , Y_E )

				a_Intersection = new WmiSignedIntegerRangeNode (

					m_PropertyName ,
					m_Index ,
					Y_S_INFINITE ,
					Y_E_INFINITE ,
					X_S_CLOSED && Y_S_CLOSED ,		// Check for weak relationship ( < , > ) 
					Y_E_CLOSED ,					// Relationship is as strong as ordering 
					X_S ,
					Y_E ,
					NULL ,
					NULL
				) ;

				t_Status = ( a_Intersection ) ? ( WmiTriState :: State_True ) : ( WmiTriState :: State_Error ) ;
			}
		}
		else if ( CompareSignedIntegerEqual ( Y_S ,  Y_S_INFINITE ? -1 : 0 , X_E , X_E_INFINITE ? 1 : 0 ) ) // ( Y_S == X_E ), Start of Y and End Of X overlap
		{
			if ( Y_S_CLOSED && X_E_CLOSED )
			{
//				Order ( X_S == Y_S == X_E )
//				Range ( Y_S , Y_E ) 

				a_Intersection = new WmiSignedIntegerRangeNode (

					m_PropertyName ,
					m_Index ,
					FALSE ,
					FALSE  ,
					TRUE ,
					TRUE ,
					Y_S ,
					Y_S ,
					NULL ,
					NULL
				) ;

				t_Status = ( a_Intersection ) ? ( WmiTriState :: State_True ) : ( WmiTriState :: State_Error ) ;
			}
			else
			{
// Empty set
			}
		}
		else if ( CompareSignedIntegerGreater ( Y_S ,  Y_S_INFINITE ? -1 : 0 , X_E , X_E_INFINITE ? 1 : 0 ) )  // ( Y_S > Y_E )
		{
// Can never happen
DebugBreak () ;
		}
	}
	else if ( CompareSignedIntegerGreater ( X_S ,  X_S_INFINITE ? -1 : 0 , Y_S , Y_S_INFINITE ? -1 : 0 ) ) // ( X_S > Y_S )
	{
		if ( CompareSignedIntegerLess ( X_S ,  X_S_INFINITE ? -1 : 0 , Y_E , Y_E_INFINITE ? 1 : 0 ) ) // ( X_S < Y_E )
		{
			if ( CompareSignedIntegerLess ( Y_E ,  Y_E_INFINITE ? 1 : 0 , X_E , X_E_INFINITE ? 1 : 0 ) ) // ( Y_E < X_E )
			{
//				Order ( Y_S < X_S < Y_E < X_E )
//				Range ( X_S , Y_E ) 

				a_Intersection = new WmiSignedIntegerRangeNode (

					m_PropertyName ,
					m_Index ,
					X_S_INFINITE ,
					Y_E_INFINITE ,
					X_S_CLOSED ,						// Relationship is as strong as ordering 
					Y_E_CLOSED ,						// Relationship is as strong as ordering 
					X_S ,
					Y_E ,
					NULL ,
					NULL
				) ;

				t_Status = ( a_Intersection ) ? ( WmiTriState :: State_True ) : ( WmiTriState :: State_Error ) ;
			}
			else if ( CompareSignedIntegerEqual ( Y_E ,  Y_E_INFINITE ? 1 : 0 , X_E , X_E_INFINITE ? 1 : 0 ) ) // ( Y_E == X_E )
			{
//				Order ( Y_S < X_S < Y_E == X_E )
//				Range ( X_S , Y_E ) 

				a_Intersection = new WmiSignedIntegerRangeNode (

					m_PropertyName ,
					m_Index ,
					X_S_INFINITE ,
					Y_E_INFINITE ,
					X_S_CLOSED ,						// Relationship is as strong as ordering 
					Y_E_CLOSED && X_E_CLOSED ,			// Check for weak relationship ( < , > ) 
					X_S ,
					Y_E ,
					NULL ,
					NULL
				) ;

				t_Status = ( a_Intersection ) ? ( WmiTriState :: State_True ) : ( WmiTriState :: State_Error ) ;
			}
			else if ( CompareSignedIntegerGreater ( Y_E ,  Y_E_INFINITE ? 1 : 0 , X_E , X_E_INFINITE ? 1 : 0 ) ) // ( Y_E > X_E )
			{
//				Order ( Y_S < X_S < X_E < Y_E )
//				Range ( X_S , X_E ) 

				a_Intersection = new WmiSignedIntegerRangeNode (

					m_PropertyName ,
					m_Index ,
					X_S_INFINITE ,
					X_E_INFINITE ,
					X_S_CLOSED ,						// Relationship is as strong as ordering 
					X_E_CLOSED ,						// Relationship is as strong as ordering 
					X_S ,
					X_E ,
					NULL ,
					NULL
				) ;

				t_Status = ( a_Intersection ) ? ( WmiTriState :: State_True ) : ( WmiTriState :: State_Error ) ;
			}
		}
		else if ( CompareSignedIntegerEqual ( X_S ,  X_S_INFINITE ? -1 : 0 , Y_E , Y_E_INFINITE ? 1 : 0 ) ) // ( X_S == Y_E ), Start of X and End Of Y overlap
		{
			if ( X_S_CLOSED && Y_E_CLOSED )
			{
//				Order ( Y_S < X_S == X_E )
//				Range ( X_S , Y_E ) 

				a_Intersection = new WmiSignedIntegerRangeNode (

					m_PropertyName ,
					m_Index ,
					FALSE ,
					FALSE  ,
					TRUE ,
					TRUE ,
					X_S ,
					X_S ,
					NULL ,
					NULL
				) ;

				t_Status = ( a_Intersection ) ? ( WmiTriState :: State_True ) : ( WmiTriState :: State_Error ) ;
			}
			else
			{
// Empty set
			}
		}
		else if ( CompareSignedIntegerGreater ( X_S ,  X_S_INFINITE ? -1 : 0 , Y_E , Y_E_INFINITE ? 1 : 0 ) ) // ( X_S > Y_E )
		{
// Empty
		}
	}

	return t_Status ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

WmiTriState WmiStringRangeNode :: GetIntersectingRange ( 

	WmiStringRangeNode &a_String ,
	WmiStringRangeNode *&a_Intersection 
)
{
	WmiTriState t_Status = WmiTriState :: State_False ;

// A weak ( open ) relationship is ( < , > ) 
// A strong ( closed ) relationship is ( == , <= , >= )

	a_Intersection = NULL ;

	BSTR X_S = m_LowerBound ;
	BSTR X_E = m_UpperBound ;
	BSTR Y_S = a_String.m_LowerBound ;
	BSTR Y_E = a_String.m_UpperBound ;

	BOOL X_S_CLOSED = m_LowerBoundClosed ;
	BOOL X_E_CLOSED = m_UpperBoundClosed ;
	BOOL Y_S_CLOSED = a_String.m_LowerBoundClosed ;
	BOOL Y_E_CLOSED = a_String.m_UpperBoundClosed ;

	BOOL X_S_INFINITE = m_InfiniteLowerBound ;
	BOOL X_E_INFINITE = m_InfiniteUpperBound ;
	BOOL Y_S_INFINITE = a_String.m_InfiniteLowerBound ;
	BOOL Y_E_INFINITE = a_String.m_InfiniteUpperBound ;

	if ( CompareStringLess ( X_S ,  X_S_INFINITE ? - 1 : 0 , Y_S , Y_S_INFINITE ? -1 : 0 ) ) // ( X_S < Y_S )
	{
		if ( CompareStringLess ( Y_S ,  Y_S_INFINITE ? -1 : 0 , X_E , X_E_INFINITE ? 1 : 0 ) ) // ( Y_S < X_E )
		{
			if ( CompareStringLess ( X_E ,  X_E_INFINITE ? 1 : 0 , Y_E , Y_E_INFINITE ? 1 : 0 ) ) // ( X_E < Y_E )
			{
//				Order ( X_S < Y_S < X_E < Y_E )
//				Range ( Y_S , X_E ) 

				a_Intersection = new WmiStringRangeNode (

					m_PropertyName ,
					m_Index ,
					Y_S_INFINITE ,
					X_E_INFINITE ,
					Y_S_CLOSED ,						// Relationship is as strong as ordering 
					X_E_CLOSED ,						// Relationship is as strong as ordering 
					Y_S ,
					X_E ,
					NULL ,
					NULL
				) ;

				t_Status = ( a_Intersection ) ? ( WmiTriState :: State_True ) : ( WmiTriState :: State_Error ) ;
			}
			else if ( CompareStringEqual ( X_E ,  X_E_INFINITE ? 1 : 0 , Y_E , Y_E_INFINITE ? 1 : 0 ) ) // ( X_E == Y_E )
			{
//				Order ( X_S < Y_S < X_E == Y_E )
//				Range ( Y_S , X_E ) 

				a_Intersection = new WmiStringRangeNode (

					m_PropertyName ,
					m_Index ,
					Y_S_INFINITE ,
					X_E_INFINITE ,
					Y_S_CLOSED  ,						// Relationship is as strong as ordering 
					X_E_CLOSED && Y_E_CLOSED ,			// Check for weak relationship ( < , > ) 
					Y_S ,
					X_E ,
					NULL ,
					NULL
				) ;

				t_Status = ( a_Intersection ) ? ( WmiTriState :: State_True ) : ( WmiTriState :: State_Error ) ;
			}
			else if ( CompareStringGreater ( X_E ,  X_E_INFINITE ? 1 : 0 , Y_E , Y_E_INFINITE ? 1 : 0 ) ) // ( X_E > Y_E ) 
			{
//				Order ( X_S < Y_S < Y_E < X_E )
//				Range ( Y_S , Y_E )

				a_Intersection = new WmiStringRangeNode (

					m_PropertyName ,
					m_Index ,
					Y_S_INFINITE ,
					Y_E_INFINITE ,
					Y_S_CLOSED ,						// Relationship is as strong as ordering 
					Y_E_CLOSED ,						// Relationship is as strong as ordering 
					Y_S ,
					Y_E ,
					NULL ,
					NULL
				) ;

				t_Status = ( a_Intersection ) ? ( WmiTriState :: State_True ) : ( WmiTriState :: State_Error ) ;
			}
		}
		else if ( CompareStringEqual ( Y_S ,  Y_S_INFINITE ? -1 : 0 , X_E , X_E_INFINITE ? 1 : 0 ) )  // ( Y_S == X_E ), Start of Y and End Of X overlap
		{
			if ( Y_S_CLOSED && X_E_CLOSED )
			{
//				Order ( X_S < Y_S == X_E )
//				Range ( Y_S , X_E ) 

				a_Intersection = new WmiStringRangeNode (

					m_PropertyName ,
					m_Index ,
					FALSE ,
					FALSE  ,
					TRUE ,
					TRUE ,
					Y_S ,
					Y_S ,
					NULL ,
					NULL
				) ;

				t_Status = ( a_Intersection ) ? ( WmiTriState :: State_True ) : ( WmiTriState :: State_Error ) ;
			}
			else
			{
// Empty set
			}
		}
		else if ( CompareStringGreater ( Y_S ,  Y_S_INFINITE ? -1 : 0 , X_E , X_E_INFINITE ? 1 : 0 ) ) // ( Y_S > X_E )
		{
//				Order ( X_S < Y_S , X_E < Y_S )
//				Non overlapping regions therefore empty set
		}
	}
	else if ( CompareStringEqual ( X_S ,  X_S_INFINITE ? -1 : 0 , Y_S , Y_S_INFINITE ? -1 : 0 ) ) // ( X_S == Y_S ) 
	{
		if ( CompareStringLess ( Y_S ,  Y_S_INFINITE ? -1 : 0 , X_E , X_E_INFINITE ? 1 : 0 ) ) // ( Y_S < X_E )
		{
			if ( CompareStringLess ( X_E ,  X_E_INFINITE ? 1 : 0 , Y_E , Y_E_INFINITE ? 1 : 0 ) ) // ( X_E < Y_E )
			{
//				Order ( X_S == Y_S < X_E < Y_E )
//				Range ( Y_S , X_E )

				a_Intersection = new WmiStringRangeNode (

					m_PropertyName ,
					m_Index ,
					Y_S_INFINITE ,
					Y_E_INFINITE ,
					X_S_CLOSED && Y_S_CLOSED ,		// Check for weak relationship ( < , > ) 
					X_E_CLOSED ,					// Relationship is as strong as ordering 
					Y_S ,
					X_E ,
					NULL ,
					NULL 
				) ;

				t_Status = ( a_Intersection ) ? ( WmiTriState :: State_True ) : ( WmiTriState :: State_Error ) ;
			}
			else if ( CompareStringEqual ( X_E ,  X_E_INFINITE ? 1 : 0 , Y_E , Y_E_INFINITE ? 1 : 0 ) ) // ( X_E == Y_E )
			{
//				Order ( X_S == Y_S < X_E == Y_E )
//				Range ( X_S , X_E )

				a_Intersection = new WmiStringRangeNode (

					m_PropertyName ,
					m_Index ,
					Y_S_INFINITE ,
					Y_E_INFINITE ,
					X_S_CLOSED && Y_S_CLOSED ,		// Check for weak relationship ( < , > ) 
					Y_E_CLOSED && X_E_CLOSED ,		// Check for weak relationship ( < , > ) 
					X_S ,
					X_E ,
					NULL ,
					NULL
				) ;

				t_Status = ( a_Intersection ) ? ( WmiTriState :: State_True ) : ( WmiTriState :: State_Error ) ;
			}
			else if ( CompareStringGreater ( X_E ,  X_E_INFINITE ? 1 : 0 , Y_E , Y_E_INFINITE ? 1 : 0 ) ) // ( X_E > Y_E )
			{
//				Order ( X_S == Y_S < Y_E < X_E )
//				Range ( X_S , Y_E )

				a_Intersection = new WmiStringRangeNode (

					m_PropertyName ,
					m_Index ,
					Y_S_INFINITE ,
					Y_E_INFINITE ,
					X_S_CLOSED && Y_S_CLOSED ,		// Check for weak relationship ( < , > ) 
					Y_E_CLOSED ,					// Relationship is as strong as ordering 
					X_S ,
					Y_E ,
					NULL ,
					NULL
				) ;

				t_Status = ( a_Intersection ) ? ( WmiTriState :: State_True ) : ( WmiTriState :: State_Error ) ;
			}
		}
		else if ( CompareStringEqual ( Y_S ,  Y_S_INFINITE ? -1 : 0 , X_E , X_E_INFINITE ? 1 : 0 ) ) // ( Y_S == X_E ), Start of Y and End Of X overlap
		{
			if ( Y_S_CLOSED && X_E_CLOSED )
			{
//				Order ( X_S == Y_S == X_E )
//				Range ( Y_S , Y_E ) 

				a_Intersection = new WmiStringRangeNode (

					m_PropertyName ,
					m_Index ,
					FALSE ,
					FALSE  ,
					TRUE ,
					TRUE ,
					Y_S ,
					Y_S ,
					NULL ,
					NULL 
				) ;

				t_Status = ( a_Intersection ) ? ( WmiTriState :: State_True ) : ( WmiTriState :: State_Error ) ;
			}
			else
			{
// Empty set
			}
		}
		else if ( CompareStringGreater ( Y_S ,  Y_S_INFINITE ? -1 : 0 , X_E , X_E_INFINITE ? 1 : 0 ) )  // ( Y_S > Y_E )
		{
// Can never happen
DebugBreak () ;
		}
	}
	else if ( CompareStringGreater ( X_S ,  X_S_INFINITE ? -1 : 0 , Y_S , Y_S_INFINITE ? -1 : 0 ) ) // ( X_S > Y_S )
	{
		if ( CompareStringLess ( X_S ,  X_S_INFINITE ? -1 : 0 , Y_E , Y_E_INFINITE ? 1 : 0 ) ) // ( X_S < Y_E )
		{
			if ( CompareStringLess ( Y_E ,  Y_E_INFINITE ? 1 : 0 , X_E , X_E_INFINITE ? 1 : 0 ) ) // ( Y_E < X_E )
			{
//				Order ( Y_S < X_S < Y_E < X_E )
//				Range ( X_S , Y_E ) 

				a_Intersection = new WmiStringRangeNode (

					m_PropertyName ,
					m_Index ,
					X_S_INFINITE ,
					Y_E_INFINITE ,
					X_S_CLOSED ,						// Relationship is as strong as ordering 
					Y_E_CLOSED ,						// Relationship is as strong as ordering 
					X_S ,
					Y_E ,
					NULL ,
					NULL
				) ;

				t_Status = ( a_Intersection ) ? ( WmiTriState :: State_True ) : ( WmiTriState :: State_Error ) ;
			}
			else if ( CompareStringEqual ( Y_E ,  Y_E_INFINITE ? 1 : 0 , X_E , X_E_INFINITE ? 1 : 0 ) ) // ( Y_E == X_E )
			{
//				Order ( Y_S < X_S < Y_E == X_E )
//				Range ( X_S , Y_E ) 

				a_Intersection = new WmiStringRangeNode (

					m_PropertyName ,
					m_Index ,
					X_S_INFINITE ,
					Y_E_INFINITE ,
					X_S_CLOSED ,						// Relationship is as strong as ordering 
					Y_E_CLOSED && X_E_CLOSED ,			// Check for weak relationship ( < , > ) 
					X_S ,
					Y_E ,
					NULL ,
					NULL
				) ;

				t_Status = ( a_Intersection ) ? ( WmiTriState :: State_True ) : ( WmiTriState :: State_Error ) ;
			}
			else if ( CompareStringGreater ( Y_E ,  Y_E_INFINITE ? 1 : 0 , X_E , X_E_INFINITE ? 1 : 0 ) ) // ( Y_E > X_E )
			{
//				Order ( Y_S < X_S < X_E < Y_E )
//				Range ( X_S , X_E ) 

				a_Intersection = new WmiStringRangeNode (

					m_PropertyName ,
					m_Index ,
					X_S_INFINITE ,
					X_E_INFINITE ,
					X_S_CLOSED ,						// Relationship is as strong as ordering 
					X_E_CLOSED ,						// Relationship is as strong as ordering 
					X_S ,
					X_E ,
					NULL ,
					NULL
				) ;

				t_Status = ( a_Intersection ) ? ( WmiTriState :: State_True ) : ( WmiTriState :: State_Error ) ;
			}
		}
		else if ( CompareStringEqual ( X_S ,  X_S_INFINITE ? -1 : 0 , Y_E , Y_E_INFINITE ? 1 : 0 ) ) // ( X_S == Y_E ), Start of X and End Of Y overlap
		{
			if ( X_S_CLOSED && Y_E_CLOSED )
			{
//				Order ( Y_S < X_S == X_E )
//				Range ( X_S , Y_E ) 

				a_Intersection = new WmiStringRangeNode (

					m_PropertyName ,
					m_Index ,
					FALSE ,
					FALSE  ,
					TRUE ,
					TRUE ,
					X_S ,
					X_S ,
					NULL ,
					NULL 
				) ;

				t_Status = ( a_Intersection ) ? ( WmiTriState :: State_True ) : ( WmiTriState :: State_Error ) ;
			}
			else
			{
// Empty set
			}
		}
		else if ( CompareStringGreater ( X_S ,  X_S_INFINITE ? -1 : 0 , Y_E , Y_E_INFINITE ? 1 : 0 ) ) // ( X_S > Y_E )
		{
// empty
		}
	}

	return t_Status ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

WmiTriState WmiSignedIntegerRangeNode :: GetNonIntersectingRange ( 

	WmiSignedIntegerRangeNode &a_SignedInteger ,
	WmiSignedIntegerRangeNode *&a_Before ,
	WmiSignedIntegerRangeNode *&a_Intersection ,
	WmiSignedIntegerRangeNode *&a_After
)
{
	WmiTriState t_Status = WmiTriState :: State_True ;

// A weak ( open ) relationship is ( < , > ) 
// A strong ( closed ) relationship is ( == , <= , >= )

	a_Before = NULL ;
	a_Intersection = NULL ;
	a_After = NULL ;

	LONG X_S = m_LowerBound ;
	LONG X_E = m_UpperBound ;
	LONG Y_S = a_SignedInteger.m_LowerBound ;
	LONG Y_E = a_SignedInteger.m_UpperBound ;

	BOOL X_S_CLOSED = m_LowerBoundClosed ;
	BOOL X_E_CLOSED = m_UpperBoundClosed ;
	BOOL Y_S_CLOSED = a_SignedInteger.m_LowerBoundClosed ;
	BOOL Y_E_CLOSED = a_SignedInteger.m_UpperBoundClosed ;

	BOOL X_S_INFINITE = m_InfiniteLowerBound ;
	BOOL X_E_INFINITE = m_InfiniteUpperBound ;
	BOOL Y_S_INFINITE = a_SignedInteger.m_InfiniteLowerBound ;
	BOOL Y_E_INFINITE = a_SignedInteger.m_InfiniteUpperBound ;

	if ( CompareSignedIntegerLess ( X_S ,  X_S_INFINITE ? - 1 : 0 , Y_S , Y_S_INFINITE ? -1 : 0 ) ) // ( X_S < Y_S )
	{
		if ( CompareSignedIntegerLess ( Y_S ,  Y_S_INFINITE ? -1 : 0 , X_E , X_E_INFINITE ? 1 : 0 ) ) // ( Y_S < X_E )
		{
			if ( CompareSignedIntegerLess ( X_E ,  X_E_INFINITE ? 1 : 0 , Y_E , Y_E_INFINITE ? 1 : 0 ) ) // ( X_E < Y_E )
			{
//				Order ( X_S < Y_S < X_E < Y_E )
//				Range ( Y_S , X_E ) 

				a_Before = new WmiSignedIntegerRangeNode (

					m_PropertyName ,
					m_Index ,
					X_S_INFINITE ,
					Y_S_INFINITE ,
					X_S_CLOSED ,						// Relationship is as strong as ordering 
					! Y_S_CLOSED ,						// Relationship is as strong as ordering 
					X_S ,
					Y_S ,
					NULL ,
					NULL
				) ;

				a_Intersection = new WmiSignedIntegerRangeNode (

					m_PropertyName ,
					m_Index ,
					Y_S_INFINITE ,
					X_E_INFINITE ,
					Y_S_CLOSED ,						// Relationship is as strong as ordering 
					X_E_CLOSED ,						// Relationship is as strong as ordering 
					Y_S ,
					X_E ,
					NULL ,
					NULL
				) ;

				a_After = new WmiSignedIntegerRangeNode (

					m_PropertyName ,
					m_Index ,
					X_E_INFINITE ,
					Y_E_INFINITE ,
					! X_E_CLOSED ,						// Relationship is as strong as ordering 
					Y_E_CLOSED ,						// Relationship is as strong as ordering 
					X_E ,
					Y_E ,
					NULL ,
					NULL
				) ;

				if ( ! ( a_Before && a_Intersection && a_After ) )
				{
					t_Status = WmiTriState :: State_Error ;
				}
			}
			else if ( CompareSignedIntegerEqual ( X_E ,  X_E_INFINITE ? 1 : 0 , Y_E , Y_E_INFINITE ? 1 : 0 ) ) // ( X_E == Y_E )
			{
//				Order ( X_S < Y_S < X_E == Y_E )
//				Range ( Y_S , X_E ) 

				a_Before = new WmiSignedIntegerRangeNode (

					m_PropertyName ,
					m_Index ,
					X_S_INFINITE ,
					Y_S_INFINITE ,
					X_S_CLOSED  ,						// Relationship is as strong as ordering 
					! Y_S_CLOSED ,			
					X_S ,
					Y_S ,
					NULL ,
					NULL
				) ;

				a_Intersection = new WmiSignedIntegerRangeNode (

					m_PropertyName ,
					m_Index ,
					Y_S_INFINITE ,
					X_E_INFINITE ,
					Y_S_CLOSED  ,						// Relationship is as strong as ordering 
					X_E_CLOSED && Y_E_CLOSED ,			// Check for weak relationship ( < , > ) 
					Y_S ,
					X_E ,
					NULL ,
					NULL
				) ;

				if ( ! ( a_Before && a_Intersection ) )
				{
					t_Status = WmiTriState :: State_Error ;
				}

				if ( ( X_E_CLOSED && ! Y_E_CLOSED ) || ( ! X_E_CLOSED && Y_E_CLOSED ) )
				{
					a_After = new WmiSignedIntegerRangeNode (

						m_PropertyName ,
						m_Index ,
						X_E_INFINITE ,
						X_E_INFINITE ,
						TRUE ,						
						TRUE ,			
						X_E ,
						X_E ,
						NULL ,
						NULL
					) ;

					if ( ! ( a_After ) )
					{
						t_Status = WmiTriState :: State_Error ;
					}
				}
			}
			else if ( CompareSignedIntegerGreater ( X_E ,  X_E_INFINITE ? 1 : 0 , Y_E , Y_E_INFINITE ? 1 : 0 ) ) // ( X_E > Y_E ) 
			{
//				Order ( X_S < Y_S < Y_E < X_E )
//				Range ( Y_S , Y_E )

				a_Before = new WmiSignedIntegerRangeNode (

					m_PropertyName ,
					m_Index ,
					X_S_INFINITE ,
					Y_S_INFINITE ,
					X_S_CLOSED ,						// Relationship is as strong as ordering 
					! Y_S_CLOSED ,						// Relationship is as strong as ordering 
					X_S ,
					Y_S ,
					NULL ,
					NULL
				) ;

				a_Intersection = new WmiSignedIntegerRangeNode (

					m_PropertyName ,
					m_Index ,
					Y_S_INFINITE ,
					Y_E_INFINITE ,
					Y_S_CLOSED ,						// Relationship is as strong as ordering 
					Y_E_CLOSED ,						// Relationship is as strong as ordering 
					Y_S ,
					Y_E ,
					NULL ,
					NULL
				) ;

				a_After = new WmiSignedIntegerRangeNode (

					m_PropertyName ,
					m_Index ,
					Y_E_INFINITE ,
					X_E_INFINITE ,
					! Y_E_CLOSED ,						// Relationship is as strong as ordering 
					X_E_CLOSED ,						// Relationship is as strong as ordering 
					Y_E ,
					X_E ,
					NULL ,
					NULL
				) ;

				if ( ! ( a_Before && a_Intersection && a_After ) )
				{
					t_Status = WmiTriState :: State_Error ;
				}
			}
		}
		else if ( CompareSignedIntegerEqual ( Y_S ,  Y_S_INFINITE ? -1 : 0 , X_E , X_E_INFINITE ? 1 : 0 ) )  // ( Y_S == X_E ), Start of Y and End Of X overlap
		{
			if ( CompareSignedIntegerLess ( X_E ,  X_E_INFINITE ? 1 : 0 , Y_E , Y_E_INFINITE ? 1 : 0 ) ) // ( X_E < Y_E )
			{
			// Order ( X_S < Y_S == X_E < Y_E )

				if ( X_E_CLOSED && Y_S_CLOSED )
				{
					a_Before = new WmiSignedIntegerRangeNode (

						m_PropertyName ,
						m_Index ,
						X_S_INFINITE ,
						FALSE ,
						X_S_CLOSED ,
						FALSE ,
						X_S ,
						X_E ,
						NULL ,
						NULL
					) ;

					a_Intersection = new WmiSignedIntegerRangeNode (

						m_PropertyName ,
						m_Index ,
						FALSE ,
						FALSE  ,
						TRUE ,
						TRUE ,
						Y_S ,
						Y_S ,
						NULL ,
						NULL
					) ;

					a_After = new WmiSignedIntegerRangeNode (

						m_PropertyName ,
						m_Index ,
						FALSE ,
						Y_E_INFINITE ,
						FALSE ,
						Y_E_CLOSED ,
						Y_S ,
						Y_E ,
						NULL ,
						NULL
					) ;

					if ( ! ( a_Before && a_Intersection && a_After ) )
					{
						t_Status = WmiTriState :: State_Error ;
					}
				}
				else
				{
					a_Before = new WmiSignedIntegerRangeNode (

						m_PropertyName ,
						m_Index ,
						X_S_INFINITE ,
						FALSE ,
						X_S_CLOSED ,
						X_E_CLOSED,
						X_S ,
						X_E ,
						NULL ,
						NULL
					) ;

					a_After = new WmiSignedIntegerRangeNode (

						m_PropertyName ,
						m_Index ,
						FALSE ,
						Y_E_INFINITE ,
						Y_S_CLOSED ,
						Y_E_CLOSED ,
						Y_S ,
						Y_E ,
						NULL ,
						NULL
					) ;

					if ( ! ( a_Before && a_After ) )
					{
						t_Status = WmiTriState :: State_Error ;
					}
				}
			}
			else if ( CompareSignedIntegerEqual ( X_E ,  X_E_INFINITE ? 1 : 0 , Y_E , Y_E_INFINITE ? 1 : 0 ) ) // ( X_E == Y_E )
			{
// Order ( X_S < Y_S == X_E == Y_E )

				if ( X_E_CLOSED )
				{
					a_Before = new WmiSignedIntegerRangeNode (

						m_PropertyName ,
						m_Index ,
						X_S_INFINITE ,
						FALSE ,
						X_S_CLOSED ,
						FALSE ,
						X_S ,
						X_E ,
						NULL ,
						NULL
					) ;

					a_Intersection = new WmiSignedIntegerRangeNode (

						m_PropertyName ,
						m_Index ,
						FALSE ,
						FALSE  ,
						TRUE ,
						TRUE ,
						Y_S ,
						Y_S ,
						NULL ,
						NULL
					) ;

					if ( ! ( a_Before && a_Intersection ) )
					{
						t_Status = WmiTriState :: State_Error ;
					}
				}
				else
				{
					a_Before = new WmiSignedIntegerRangeNode (

						m_PropertyName ,
						m_Index ,
						X_S_INFINITE ,
						FALSE ,
						X_S_CLOSED ,
						X_E_CLOSED,
						X_S ,
						X_E ,
						NULL ,
						NULL
					) ;

					a_After = new WmiSignedIntegerRangeNode (

						m_PropertyName ,
						m_Index ,
						FALSE ,
						Y_S_INFINITE ,
						TRUE ,
						TRUE,
						Y_S ,
						Y_S ,
						NULL ,
						NULL
					) ;

					if ( ! ( a_Before && a_After ) )
					{
						t_Status = WmiTriState :: State_Error ;
					}
				}
			}
			else if ( CompareSignedIntegerGreater ( X_E ,  X_E_INFINITE ? 1 : 0 , Y_E , Y_E_INFINITE ? 1 : 0 ) ) // ( X_E > Y_E )
			{
// Order ( X_S < Y_E < Y_S == X_E ) Can never happen
DebugBreak () ;
			}
		}
		else if ( CompareSignedIntegerGreater ( Y_S ,  Y_S_INFINITE ? -1 : 0 , X_E , X_E_INFINITE ? 1 : 0 ) ) // ( Y_S > X_E )
		{
//				Order ( X_S < Y_S , X_E < Y_S )

			a_Before = ( WmiSignedIntegerRangeNode * ) ( this->Copy () ) ;
			a_After = ( WmiSignedIntegerRangeNode * ) ( a_SignedInteger.Copy () ) ;

			if ( ! ( a_Before && a_After ) )
			{
				t_Status = WmiTriState :: State_Error ;
			}
		}
	}
	else if ( CompareSignedIntegerEqual ( X_S ,  X_S_INFINITE ? -1 : 0 , Y_S , Y_S_INFINITE ? -1 : 0 ) ) // ( X_S == Y_S ) 
	{
		if ( CompareSignedIntegerLess ( Y_S ,  Y_S_INFINITE ? -1 : 0 , X_E , X_E_INFINITE ? 1 : 0 ) ) // ( Y_S < X_E )
		{
			if ( CompareSignedIntegerLess ( X_E ,  X_E_INFINITE ? 1 : 0 , Y_E , Y_E_INFINITE ? 1 : 0 ) ) // ( X_E < Y_E )
			{
//				Order ( X_S == Y_S < X_E < Y_E )
//				Range ( Y_S , X_E )

				if ( ( X_S_CLOSED && ! Y_S_CLOSED ) || ( ! X_S_CLOSED && Y_S_CLOSED ) )
				{				
					a_Before = new WmiSignedIntegerRangeNode (

						m_PropertyName ,
						m_Index ,
						Y_S_INFINITE ,
						Y_E_INFINITE ,
						TRUE ,
						TRUE ,
						X_S ,
						X_S ,
						NULL ,
						NULL
					) ;

					if ( ! ( a_Before ) )
					{
						t_Status = WmiTriState :: State_Error ;
					}
				}

				a_Intersection = new WmiSignedIntegerRangeNode (

					m_PropertyName ,
					m_Index ,
					Y_S_INFINITE ,
					Y_E_INFINITE ,
					X_S_CLOSED && Y_S_CLOSED ,		// Check for weak relationship ( < , > ) 
					X_E_CLOSED ,					// Relationship is as strong as ordering 
					Y_S ,
					X_E ,
					NULL ,
					NULL
				) ;

				a_After = new WmiSignedIntegerRangeNode (

					m_PropertyName ,
					m_Index ,
					X_E_INFINITE ,
					Y_E_INFINITE ,
					! X_E_CLOSED ,		
					Y_E_CLOSED ,		
					X_E ,
					Y_E ,
					NULL ,
					NULL
				) ;

				if ( ! ( a_Intersection && a_After ) )
				{
					t_Status = WmiTriState :: State_Error ;
				}
			}
			else if ( CompareSignedIntegerEqual ( X_E ,  X_E_INFINITE ? 1 : 0 , Y_E , Y_E_INFINITE ? 1 : 0 ) ) // ( X_E == Y_E )
			{
//				Order ( X_S == Y_S < X_E == Y_E )
//				Range ( X_S , X_E )

				if ( ( X_S_CLOSED && ! Y_S_CLOSED ) || ( ! X_S_CLOSED && Y_S_CLOSED ) )
				{				
					a_Before = new WmiSignedIntegerRangeNode (

						m_PropertyName ,
						m_Index ,
						Y_S_INFINITE ,
						Y_E_INFINITE ,
						TRUE ,
						TRUE ,
						X_S ,
						X_S ,
						NULL ,
						NULL
					) ;

					if ( ! ( a_Before ) )
					{
						t_Status = WmiTriState :: State_Error ;
					}
				}

				a_Intersection = new WmiSignedIntegerRangeNode (

					m_PropertyName ,
					m_Index ,
					Y_S_INFINITE ,
					Y_E_INFINITE ,
					X_S_CLOSED && Y_S_CLOSED ,		// Check for weak relationship ( < , > ) 
					Y_E_CLOSED && X_E_CLOSED ,		// Check for weak relationship ( < , > ) 
					X_S ,
					X_E ,
					NULL ,
					NULL
				) ;

				if ( ! ( a_Intersection ) )
				{
					t_Status = WmiTriState :: State_Error ;
				}

				if ( ( X_E_CLOSED && ! Y_E_CLOSED ) || ( ! X_E_CLOSED && Y_E_CLOSED ) )
				{				
					a_After = new WmiSignedIntegerRangeNode (

						m_PropertyName ,
						m_Index ,
						X_E_INFINITE ,
						X_E_INFINITE ,
						TRUE ,
						TRUE ,
						X_E ,
						X_E ,
						NULL ,
						NULL
					) ;

					if ( ! ( a_After ) )
					{
						t_Status = WmiTriState :: State_Error ;
					}
				}
			}
			else if ( CompareSignedIntegerGreater ( X_E ,  X_E_INFINITE ? 1 : 0 , Y_E , Y_E_INFINITE ? 1 : 0 ) ) // ( X_E > Y_E )
			{
//				Order ( X_S == Y_S < Y_E < X_E )
//				Range ( X_S , Y_E )

				if ( ( X_S_CLOSED && ! Y_S_CLOSED ) || ( ! X_S_CLOSED && Y_S_CLOSED ) )
				{				
					a_Before = new WmiSignedIntegerRangeNode (

						m_PropertyName ,
						m_Index ,
						Y_S_INFINITE ,
						Y_E_INFINITE ,
						TRUE ,		
						TRUE ,					
						X_S ,
						X_S ,
						NULL ,
						NULL
					) ;

					if ( ! ( a_Before ) )
					{
						t_Status = WmiTriState :: State_Error ;
					}
				}

				a_Intersection = new WmiSignedIntegerRangeNode (

					m_PropertyName ,
					m_Index ,
					Y_S_INFINITE ,
					Y_E_INFINITE ,
					X_S_CLOSED && Y_S_CLOSED ,		// Check for weak relationship ( < , > ) 
					Y_E_CLOSED ,					// Relationship is as strong as ordering 
					X_S ,
					Y_E ,
					NULL ,
					NULL
				) ;

				a_After = new WmiSignedIntegerRangeNode (

					m_PropertyName ,
					m_Index ,
					Y_E_INFINITE ,
					X_E_INFINITE ,
					! Y_E_CLOSED ,
					X_E_CLOSED ,
					Y_E ,
					X_E ,
					NULL ,
					NULL
				) ;

				if ( ! ( a_Intersection && a_After ) )
				{
					t_Status = WmiTriState :: State_Error ;
				}
			}
		}
		else if ( CompareSignedIntegerEqual ( Y_S ,  Y_S_INFINITE ? -1 : 0 , X_E , X_E_INFINITE ? 1 : 0 ) ) // ( Y_S == X_E ), Start of Y and End Of X overlap
		{
			if ( CompareSignedIntegerLess ( X_E ,  X_E_INFINITE ? 1 : 0 , Y_E , Y_E_INFINITE ? 1 : 0 ) ) // ( X_E < Y_E )
			{
//				Order ( X_S == Y_S == X_E < Y_E )

				if ( Y_S_CLOSED )
				{
					a_Intersection = new WmiSignedIntegerRangeNode (

						m_PropertyName ,
						m_Index ,
						FALSE ,
						FALSE  ,
						TRUE ,
						TRUE ,
						Y_S ,
						Y_S ,
						NULL ,
						NULL
					) ;

					a_After = new WmiSignedIntegerRangeNode (

						m_PropertyName ,
						m_Index ,
						FALSE ,
						Y_E_INFINITE,
						FALSE ,
						Y_E_CLOSED ,
						Y_S ,
						Y_E ,
						NULL ,
						NULL
					) ;

					if ( ! ( a_Intersection && a_After ) )
					{
						t_Status = WmiTriState :: State_Error ;
					}
				}
				else
				{
					a_Before = new WmiSignedIntegerRangeNode (

						m_PropertyName ,
						m_Index ,
						FALSE ,
						FALSE  ,
						TRUE ,
						TRUE ,
						X_S ,
						X_S ,
						NULL ,
						NULL
					) ;

					a_After = new WmiSignedIntegerRangeNode (

						m_PropertyName ,
						m_Index ,
						FALSE ,
						Y_E_INFINITE,
						FALSE ,
						Y_E_CLOSED ,
						Y_S ,
						Y_E ,
						NULL ,
						NULL
					) ;

					if ( ! ( a_Before && a_After ) )
					{
						t_Status = WmiTriState :: State_Error ;
					}
				}
			}
			else if ( CompareSignedIntegerEqual ( X_E ,  X_E_INFINITE ? 1 : 0 , Y_E , Y_E_INFINITE ? 1 : 0 ) ) // ( X_E == Y_E )
			{
//				Order ( X_S == Y_S == X_E == Y_E )

				a_Intersection = new WmiSignedIntegerRangeNode (

					m_PropertyName ,
					m_Index ,
					FALSE ,
					FALSE  ,
					TRUE ,
					TRUE ,
					Y_S ,
					Y_S ,
					NULL ,
					NULL
				) ;

				if ( ! ( a_Intersection ) )
				{
					t_Status = WmiTriState :: State_Error ;
				}
			}
			else if ( CompareSignedIntegerGreater ( X_E ,  X_E_INFINITE ? 1 : 0 , Y_E , Y_E_INFINITE ? 1 : 0 ) ) // ( X_E > Y_E )
			{
// Can never happen
DebugBreak () ;
			}
		}
		else if ( CompareSignedIntegerGreater ( Y_S ,  Y_S_INFINITE ? -1 : 0 , X_E , X_E_INFINITE ? 1 : 0 ) )  // ( Y_S > X_E )
		{
// Can never happen
DebugBreak () ;
		}
	}
	else if ( CompareSignedIntegerGreater ( X_S ,  X_S_INFINITE ? -1 : 0 , Y_S , Y_S_INFINITE ? -1 : 0 ) ) // ( X_S > Y_S )
	{
		if ( CompareSignedIntegerLess ( X_S ,  X_S_INFINITE ? -1 : 0 , Y_E , Y_E_INFINITE ? 1 : 0 ) ) // ( X_S < Y_E )
		{
			if ( CompareSignedIntegerLess ( Y_E ,  Y_E_INFINITE ? 1 : 0 , X_E , X_E_INFINITE ? 1 : 0 ) ) // ( Y_E < X_E )
			{
//				Order ( Y_S < X_S < Y_E < X_E )
//				Range ( X_S , Y_E ) 

				a_Before = new WmiSignedIntegerRangeNode (

					m_PropertyName ,
					m_Index ,
					Y_S_INFINITE ,
					X_S_INFINITE ,
					Y_S_CLOSED ,						// Relationship is as strong as ordering 
					! X_S_CLOSED ,						// Relationship is as strong as ordering 
					X_S ,
					Y_E ,
					NULL ,
					NULL
				) ;

				a_Intersection = new WmiSignedIntegerRangeNode (

					m_PropertyName ,
					m_Index ,
					X_S_INFINITE ,
					Y_E_INFINITE ,
					X_S_CLOSED ,						// Relationship is as strong as ordering 
					Y_E_CLOSED ,						// Relationship is as strong as ordering 
					X_S ,
					Y_E ,
					NULL ,
					NULL
				) ;

				a_After = new WmiSignedIntegerRangeNode (

					m_PropertyName ,
					m_Index ,
					Y_E_INFINITE ,
					X_E_INFINITE ,
					! Y_E_CLOSED ,						// Relationship is as strong as ordering 
					X_E_CLOSED ,						// Relationship is as strong as ordering 
					X_S ,
					Y_E ,
					NULL ,
					NULL
				) ;

				if ( ! ( a_Before && a_Intersection && a_After ) )
				{
					t_Status = WmiTriState :: State_Error ;
				}
			}
			else if ( CompareSignedIntegerEqual ( Y_E ,  Y_E_INFINITE ? 1 : 0 , X_E , X_E_INFINITE ? 1 : 0 ) ) // ( Y_E == X_E )
			{
//				Order ( Y_S < X_S < Y_E == X_E )
//				Range ( X_S , Y_E ) 

				a_Before = new WmiSignedIntegerRangeNode (

					m_PropertyName ,
					m_Index ,
					Y_S_INFINITE ,
					X_S_INFINITE ,
					Y_S_CLOSED ,						// Relationship is as strong as ordering 
					! X_S_CLOSED ,						// Relationship is as strong as ordering 
					X_S ,
					Y_E ,
					NULL ,
					NULL
				) ;

				a_Intersection = new WmiSignedIntegerRangeNode (

					m_PropertyName ,
					m_Index ,
					X_S_INFINITE ,
					Y_E_INFINITE ,
					X_S_CLOSED ,						// Relationship is as strong as ordering 
					Y_E_CLOSED && X_E_CLOSED ,			// Check for weak relationship ( < , > ) 
					X_S ,
					Y_E ,
					NULL ,
					NULL
				) ;

				if ( ! ( a_Before && a_Intersection ) )
				{
					t_Status = WmiTriState :: State_Error ;
				}

				if ( ( X_E_CLOSED && ! Y_E_CLOSED ) || ( ! X_E_CLOSED && Y_E_CLOSED ) )
				{
					a_After = new WmiSignedIntegerRangeNode (

						m_PropertyName ,
						m_Index ,
						X_E_INFINITE ,
						X_E_INFINITE ,
						TRUE ,						
						TRUE ,			
						X_E ,
						X_E ,
						NULL ,
						NULL
					) ;

					if ( ! ( a_After ) )
					{
						t_Status = WmiTriState :: State_Error ;
					}
				}
			}
			else if ( CompareSignedIntegerGreater ( Y_E ,  Y_E_INFINITE ? 1 : 0 , X_E , X_E_INFINITE ? 1 : 0 ) ) // ( Y_E > X_E )
			{
//				Order ( Y_S < X_S < X_E < Y_E )
//				Range ( X_S , X_E ) 

				a_Before = new WmiSignedIntegerRangeNode (

					m_PropertyName ,
					m_Index ,
					Y_S_INFINITE ,
					X_S_INFINITE ,
					Y_S_CLOSED ,						// Relationship is as strong as ordering 
					! X_S_CLOSED ,						// Relationship is as strong as ordering 
					Y_S ,
					X_S ,
					NULL ,
					NULL
				) ;

				a_Intersection = new WmiSignedIntegerRangeNode (

					m_PropertyName ,
					m_Index ,
					X_S_INFINITE ,
					X_E_INFINITE ,
					X_S_CLOSED ,						// Relationship is as strong as ordering 
					X_E_CLOSED ,						// Relationship is as strong as ordering 
					X_S ,
					X_E ,
					NULL ,
					NULL
				) ;

				a_After = new WmiSignedIntegerRangeNode (

					m_PropertyName ,
					m_Index ,
					X_E_INFINITE ,
					Y_E_INFINITE ,
					! X_E_CLOSED ,						// Relationship is as strong as ordering 
					Y_E_CLOSED ,						// Relationship is as strong as ordering 
					X_E ,
					Y_E ,
					NULL ,
					NULL
				) ;

				if ( ! ( a_Before && a_Intersection && a_After ) )
				{
					t_Status = WmiTriState :: State_Error ;
				}
			}
		}
		else if ( CompareSignedIntegerEqual ( X_S ,  X_S_INFINITE ? -1 : 0 , Y_E , Y_E_INFINITE ? 1 : 0 ) ) // ( X_S == Y_E ), Start of X and End Of Y overlap
		{
			if ( CompareSignedIntegerLess ( Y_E ,  Y_E_INFINITE ? 1 : 0 , X_E , X_E_INFINITE ? 1 : 0 ) ) // ( Y_E < X_E )
			{
// Can never happen
DebugBreak () ;
			}
			else if ( CompareSignedIntegerEqual ( Y_E ,  Y_E_INFINITE ? 1 : 0 , X_E , X_E_INFINITE ? 1 : 0 ) ) // ( Y_E == X_E )
			{
//				Order ( Y_S < X_S == Y_E == X_E )

				if ( Y_E_CLOSED )
				{
					a_Before = new WmiSignedIntegerRangeNode (

						m_PropertyName ,
						m_Index ,
						Y_S_INFINITE ,
						FALSE,
						Y_S_CLOSED ,
						FALSE,
						Y_S ,
						Y_E ,
						NULL ,
						NULL
					) ;

					a_Intersection = new WmiSignedIntegerRangeNode (

						m_PropertyName ,
						m_Index ,
						FALSE ,
						FALSE  ,
						TRUE ,
						TRUE ,
						Y_E ,
						Y_E ,
						NULL ,
						NULL
					) ;

					if ( ! ( a_Before && a_Intersection ) )
					{
						t_Status = WmiTriState :: State_Error ;
					}
				}
				else
				{
					a_Before = new WmiSignedIntegerRangeNode (

						m_PropertyName ,
						m_Index ,
						FALSE ,
						FALSE  ,
						TRUE ,
						FALSE ,
						Y_S ,
						Y_E ,
						NULL ,
						NULL
					) ;

					a_After = new WmiSignedIntegerRangeNode (

						m_PropertyName ,
						m_Index ,
						FALSE ,
						FALSE,
						TRUE ,
						TRUE ,
						X_S ,
						X_S ,
						NULL ,
						NULL
					) ;

					if ( ! ( a_Before && a_After ) )
					{
						t_Status = WmiTriState :: State_Error ;
					}
				}
			}
			else if ( CompareSignedIntegerGreater ( Y_E ,  Y_E_INFINITE ? 1 : 0 , X_E , X_E_INFINITE ? 1 : 0 ) ) // ( Y_E > X_E )
			{
//				Order ( Y_S < X_S == X_E < Y_E )

				a_Before = new WmiSignedIntegerRangeNode (

					m_PropertyName ,
					m_Index ,
					Y_S_INFINITE ,
					FALSE  ,
					Y_S_CLOSED ,
					FALSE ,
					Y_S ,
					X_S ,
					NULL ,
					NULL
				) ;

				a_Intersection = new WmiSignedIntegerRangeNode (

					m_PropertyName ,
					m_Index ,
					FALSE ,
					FALSE  ,
					TRUE ,
					TRUE ,
					X_S ,
					X_S ,
					NULL ,
					NULL
				) ;

				a_After = new WmiSignedIntegerRangeNode (

					m_PropertyName ,
					m_Index ,
					FALSE ,
					Y_E_INFINITE  ,
					FALSE ,
					Y_E_CLOSED ,
					X_S ,
					Y_E ,
					NULL ,
					NULL
				) ;

				if ( ! ( a_Before && a_Intersection && a_After ) )
				{
					t_Status = WmiTriState :: State_Error ;
				}
			}
		}
		else if ( CompareSignedIntegerGreater ( X_S ,  X_S_INFINITE ? -1 : 0 , Y_E , Y_E_INFINITE ? 1 : 0 ) ) // ( X_S > Y_E )
		{
			a_Before = ( WmiSignedIntegerRangeNode * ) ( a_SignedInteger.Copy () ) ;
			a_After = ( WmiSignedIntegerRangeNode * ) ( this->Copy () ) ;

			if ( ! ( a_Before && a_After ) )
			{
				t_Status = WmiTriState :: State_Error ;
			}
		}
	}

	if ( t_Status != WmiTriState :: State_True )
	{
		delete a_Before ;
		delete a_Intersection ;
		delete a_After ;

		a_Before = NULL ;
		a_Intersection = NULL ;
		a_After = NULL ;
	}

	return t_Status ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

WmiTriState WmiUnsignedIntegerRangeNode :: GetNonIntersectingRange ( 

	WmiUnsignedIntegerRangeNode &a_UnsignedInteger ,
	WmiUnsignedIntegerRangeNode *&a_Before ,
	WmiUnsignedIntegerRangeNode *&a_Intersection ,
	WmiUnsignedIntegerRangeNode *&a_After
)
{
	WmiTriState t_Status = WmiTriState :: State_True ;

// A weak ( open ) relationship is ( < , > ) 
// A strong ( closed ) relationship is ( == , <= , >= )

	a_Before = NULL ;
	a_Intersection = NULL ;
	a_After = NULL ;

	ULONG X_S = m_LowerBound ;
	ULONG X_E = m_UpperBound ;
	ULONG Y_S = a_UnsignedInteger.m_LowerBound ;
	ULONG Y_E = a_UnsignedInteger.m_UpperBound ;

	BOOL X_S_CLOSED = m_LowerBoundClosed ;
	BOOL X_E_CLOSED = m_UpperBoundClosed ;
	BOOL Y_S_CLOSED = a_UnsignedInteger.m_LowerBoundClosed ;
	BOOL Y_E_CLOSED = a_UnsignedInteger.m_UpperBoundClosed ;

	BOOL X_S_INFINITE = m_InfiniteLowerBound ;
	BOOL X_E_INFINITE = m_InfiniteUpperBound ;
	BOOL Y_S_INFINITE = a_UnsignedInteger.m_InfiniteLowerBound ;
	BOOL Y_E_INFINITE = a_UnsignedInteger.m_InfiniteUpperBound ;

	if ( CompareUnsignedIntegerLess ( X_S ,  X_S_INFINITE ? - 1 : 0 , Y_S , Y_S_INFINITE ? -1 : 0 ) ) // ( X_S < Y_S )
	{
		if ( CompareUnsignedIntegerLess ( Y_S ,  Y_S_INFINITE ? -1 : 0 , X_E , X_E_INFINITE ? 1 : 0 ) ) // ( Y_S < X_E )
		{
			if ( CompareUnsignedIntegerLess ( X_E ,  X_E_INFINITE ? 1 : 0 , Y_E , Y_E_INFINITE ? 1 : 0 ) ) // ( X_E < Y_E )
			{
//				Order ( X_S < Y_S < X_E < Y_E )
//				Range ( Y_S , X_E ) 

				a_Before = new WmiUnsignedIntegerRangeNode (

					m_PropertyName ,
					m_Index ,
					X_S_INFINITE ,
					Y_S_INFINITE ,
					X_S_CLOSED ,						// Relationship is as strong as ordering 
					! Y_S_CLOSED ,						// Relationship is as strong as ordering 
					X_S ,
					Y_S ,
					NULL ,
					NULL
				) ;

				a_Intersection = new WmiUnsignedIntegerRangeNode (

					m_PropertyName ,
					m_Index ,
					Y_S_INFINITE ,
					X_E_INFINITE ,
					Y_S_CLOSED ,						// Relationship is as strong as ordering 
					X_E_CLOSED ,						// Relationship is as strong as ordering 
					Y_S ,
					X_E ,
					NULL ,
					NULL
				) ;

				a_After = new WmiUnsignedIntegerRangeNode (

					m_PropertyName ,
					m_Index ,
					X_E_INFINITE ,
					Y_E_INFINITE ,
					! X_E_CLOSED ,						// Relationship is as strong as ordering 
					Y_E_CLOSED ,						// Relationship is as strong as ordering 
					X_E ,
					Y_E ,
					NULL ,
					NULL
				) ;

				if ( ! ( a_Before && a_Intersection && a_After ) )
				{
					t_Status = WmiTriState :: State_Error ;
				}
			}
			else if ( CompareUnsignedIntegerEqual ( X_E ,  X_E_INFINITE ? 1 : 0 , Y_E , Y_E_INFINITE ? 1 : 0 ) ) // ( X_E == Y_E )
			{
//				Order ( X_S < Y_S < X_E == Y_E )
//				Range ( Y_S , X_E ) 

				a_Before = new WmiUnsignedIntegerRangeNode (

					m_PropertyName ,
					m_Index ,
					X_S_INFINITE ,
					Y_S_INFINITE ,
					X_S_CLOSED  ,						// Relationship is as strong as ordering 
					! Y_S_CLOSED ,			
					X_S ,
					Y_S ,
					NULL ,
					NULL
				) ;

				a_Intersection = new WmiUnsignedIntegerRangeNode (

					m_PropertyName ,
					m_Index ,
					Y_S_INFINITE ,
					X_E_INFINITE ,
					Y_S_CLOSED  ,						// Relationship is as strong as ordering 
					X_E_CLOSED && Y_E_CLOSED ,			// Check for weak relationship ( < , > ) 
					Y_S ,
					X_E ,
					NULL ,
					NULL
				) ;

				if ( ! ( a_Before && a_Intersection ) )
				{
					t_Status = WmiTriState :: State_Error ;
				}

				if ( ( X_E_CLOSED && ! Y_E_CLOSED ) || ( ! X_E_CLOSED && Y_E_CLOSED ) )
				{
					a_After = new WmiUnsignedIntegerRangeNode (

						m_PropertyName ,
						m_Index ,
						X_E_INFINITE ,
						X_E_INFINITE ,
						TRUE ,						
						TRUE ,			
						X_E ,
						X_E ,
						NULL ,
						NULL
					) ;

					if ( ! ( a_After ) )
					{
						t_Status = WmiTriState :: State_Error ;
					}
				}
			}
			else if ( CompareUnsignedIntegerGreater ( X_E ,  X_E_INFINITE ? 1 : 0 , Y_E , Y_E_INFINITE ? 1 : 0 ) ) // ( X_E > Y_E ) 
			{
//				Order ( X_S < Y_S < Y_E < X_E )
//				Range ( Y_S , Y_E )

				a_Before = new WmiUnsignedIntegerRangeNode (

					m_PropertyName ,
					m_Index ,
					X_S_INFINITE ,
					Y_S_INFINITE ,
					X_S_CLOSED ,						// Relationship is as strong as ordering 
					! Y_S_CLOSED ,						// Relationship is as strong as ordering 
					X_S ,
					Y_S ,
					NULL ,
					NULL
				) ;

				a_Intersection = new WmiUnsignedIntegerRangeNode (

					m_PropertyName ,
					m_Index ,
					Y_S_INFINITE ,
					Y_E_INFINITE ,
					Y_S_CLOSED ,						// Relationship is as strong as ordering 
					Y_E_CLOSED ,						// Relationship is as strong as ordering 
					Y_S ,
					Y_E ,
					NULL ,
					NULL
				) ;

				a_After = new WmiUnsignedIntegerRangeNode (

					m_PropertyName ,
					m_Index ,
					Y_E_INFINITE ,
					X_E_INFINITE ,
					! Y_E_CLOSED ,						// Relationship is as strong as ordering 
					X_E_CLOSED ,						// Relationship is as strong as ordering 
					Y_E ,
					X_E ,
					NULL ,
					NULL
				) ;

				if ( ! ( a_Before && a_Intersection && a_After ) )
				{
					t_Status = WmiTriState :: State_Error ;
				}
			}
		}
		else if ( CompareUnsignedIntegerEqual ( Y_S ,  Y_S_INFINITE ? -1 : 0 , X_E , X_E_INFINITE ? 1 : 0 ) )  // ( Y_S == X_E ), Start of Y and End Of X overlap
		{
			if ( CompareUnsignedIntegerLess ( X_E ,  X_E_INFINITE ? 1 : 0 , Y_E , Y_E_INFINITE ? 1 : 0 ) ) // ( X_E < Y_E )
			{
			// Order ( X_S < Y_S == X_E < Y_E )

				if ( X_E_CLOSED && Y_S_CLOSED )
				{
					a_Before = new WmiUnsignedIntegerRangeNode (

						m_PropertyName ,
						m_Index ,
						X_S_INFINITE ,
						FALSE ,
						X_S_CLOSED ,
						FALSE ,
						X_S ,
						X_E ,
						NULL ,
						NULL
					) ;

					a_Intersection = new WmiUnsignedIntegerRangeNode (

						m_PropertyName ,
						m_Index ,
						FALSE ,
						FALSE  ,
						TRUE ,
						TRUE ,
						Y_S ,
						Y_S ,
						NULL ,
						NULL
					) ;

					a_After = new WmiUnsignedIntegerRangeNode (

						m_PropertyName ,
						m_Index ,
						FALSE ,
						Y_E_INFINITE ,
						FALSE ,
						Y_E_CLOSED ,
						Y_S ,
						Y_E ,
						NULL ,
						NULL
					) ;

					if ( ! ( a_Before && a_Intersection && a_After ) )
					{
						t_Status = WmiTriState :: State_Error ;
					}
				}
				else
				{
					a_Before = new WmiUnsignedIntegerRangeNode (

						m_PropertyName ,
						m_Index ,
						X_S_INFINITE ,
						FALSE ,
						X_S_CLOSED ,
						X_E_CLOSED,
						X_S ,
						X_E ,
						NULL ,
						NULL
					) ;

					a_After = new WmiUnsignedIntegerRangeNode (

						m_PropertyName ,
						m_Index ,
						FALSE ,
						Y_E_INFINITE ,
						Y_S_CLOSED ,
						Y_E_CLOSED ,
						Y_S ,
						Y_E ,
						NULL ,
						NULL
					) ;

					if ( ! ( a_Before && a_After ) )
					{
						t_Status = WmiTriState :: State_Error ;
					}

				}
			}
			else if ( CompareUnsignedIntegerEqual ( X_E ,  X_E_INFINITE ? 1 : 0 , Y_E , Y_E_INFINITE ? 1 : 0 ) ) // ( X_E == Y_E )
			{
// Order ( X_S < Y_S == X_E == Y_E )

				if ( X_E_CLOSED )
				{
					a_Before = new WmiUnsignedIntegerRangeNode (

						m_PropertyName ,
						m_Index ,
						X_S_INFINITE ,
						FALSE ,
						X_S_CLOSED ,
						FALSE ,
						X_S ,
						X_E ,
						NULL ,
						NULL
					) ;

					a_Intersection = new WmiUnsignedIntegerRangeNode (

						m_PropertyName ,
						m_Index ,
						FALSE ,
						FALSE  ,
						TRUE ,
						TRUE ,
						Y_S ,
						Y_S ,
						NULL ,
						NULL
					) ;

					if ( ! ( a_Before && a_Intersection ) )
					{
						t_Status = WmiTriState :: State_Error ;
					}
				}
				else
				{
					a_Before = new WmiUnsignedIntegerRangeNode (

						m_PropertyName ,
						m_Index ,
						X_S_INFINITE ,
						FALSE ,
						X_S_CLOSED ,
						X_E_CLOSED,
						X_S ,
						X_E ,
						NULL ,
						NULL
					) ;

					a_After = new WmiUnsignedIntegerRangeNode (

						m_PropertyName ,
						m_Index ,
						FALSE ,
						Y_S_INFINITE ,
						TRUE ,
						TRUE,
						Y_S ,
						Y_S ,
						NULL ,
						NULL
					) ;

					if ( ! ( a_Before && a_After ) )
					{
						t_Status = WmiTriState :: State_Error ;
					}
				}
			}
			else if ( CompareUnsignedIntegerGreater ( X_E ,  X_E_INFINITE ? 1 : 0 , Y_E , Y_E_INFINITE ? 1 : 0 ) ) // ( X_E > Y_E )
			{
// Order ( X_S < Y_E < Y_S == X_E ) Can never happen
DebugBreak () ;
			}
		}
		else if ( CompareUnsignedIntegerGreater ( Y_S ,  Y_S_INFINITE ? -1 : 0 , X_E , X_E_INFINITE ? 1 : 0 ) ) // ( Y_S > X_E )
		{
//				Order ( X_S < Y_S , X_E < Y_S )

			a_Before = ( WmiUnsignedIntegerRangeNode * ) ( this->Copy () ) ;
			a_After = ( WmiUnsignedIntegerRangeNode * ) ( a_UnsignedInteger.Copy () ) ;

			if ( ! ( a_Before && a_After ) )
			{
				t_Status = WmiTriState :: State_Error ;
			}
		}
	}
	else if ( CompareUnsignedIntegerEqual ( X_S ,  X_S_INFINITE ? -1 : 0 , Y_S , Y_S_INFINITE ? -1 : 0 ) ) // ( X_S == Y_S ) 
	{
		if ( CompareUnsignedIntegerLess ( Y_S ,  Y_S_INFINITE ? -1 : 0 , X_E , X_E_INFINITE ? 1 : 0 ) ) // ( Y_S < X_E )
		{
			if ( CompareUnsignedIntegerLess ( X_E ,  X_E_INFINITE ? 1 : 0 , Y_E , Y_E_INFINITE ? 1 : 0 ) ) // ( X_E < Y_E )
			{
//				Order ( X_S == Y_S < X_E < Y_E )
//				Range ( Y_S , X_E )

				if ( ( X_S_CLOSED && ! Y_S_CLOSED ) || ( ! X_S_CLOSED && Y_S_CLOSED ) )
				{				
					a_Before = new WmiUnsignedIntegerRangeNode (

						m_PropertyName ,
						m_Index ,
						Y_S_INFINITE ,
						Y_E_INFINITE ,
						TRUE ,
						TRUE ,
						X_S ,
						X_S ,
						NULL ,
						NULL
					) ;

					if ( ! ( a_Before ) )
					{
						t_Status = WmiTriState :: State_Error ;
					}
				}

				a_Intersection = new WmiUnsignedIntegerRangeNode (

					m_PropertyName ,
					m_Index ,
					Y_S_INFINITE ,
					Y_E_INFINITE ,
					X_S_CLOSED && Y_S_CLOSED ,		// Check for weak relationship ( < , > ) 
					X_E_CLOSED ,					// Relationship is as strong as ordering 
					Y_S ,
					X_E ,
					NULL ,
					NULL
				) ;

				a_After = new WmiUnsignedIntegerRangeNode (

					m_PropertyName ,
					m_Index ,
					X_E_INFINITE ,
					Y_E_INFINITE ,
					! X_E_CLOSED ,		
					Y_E_CLOSED ,		
					X_E ,
					Y_E ,
					NULL ,
					NULL
				) ;

				if ( ! ( a_Intersection && a_After ) )
				{
					t_Status = WmiTriState :: State_Error ;
				}
			}
			else if ( CompareUnsignedIntegerEqual ( X_E ,  X_E_INFINITE ? 1 : 0 , Y_E , Y_E_INFINITE ? 1 : 0 ) ) // ( X_E == Y_E )
			{
//				Order ( X_S == Y_S < X_E == Y_E )
//				Range ( X_S , X_E )

				if ( ( X_S_CLOSED && ! Y_S_CLOSED ) || ( ! X_S_CLOSED && Y_S_CLOSED ) )
				{				
					a_Before = new WmiUnsignedIntegerRangeNode (

						m_PropertyName ,
						m_Index ,
						Y_S_INFINITE ,
						Y_E_INFINITE ,
						TRUE ,
						TRUE ,
						X_S ,
						X_S ,
						NULL ,
						NULL
					) ;

					if ( ! ( a_Before ) )
					{
						t_Status = WmiTriState :: State_Error ;
					}
				}

				a_Intersection = new WmiUnsignedIntegerRangeNode (

					m_PropertyName ,
					m_Index ,
					Y_S_INFINITE ,
					Y_E_INFINITE ,
					X_S_CLOSED && Y_S_CLOSED ,		// Check for weak relationship ( < , > ) 
					Y_E_CLOSED && X_E_CLOSED ,		// Check for weak relationship ( < , > ) 
					X_S ,
					X_E ,
					NULL ,
					NULL
				) ;

				if ( ! ( a_Intersection ) )
				{
					t_Status = WmiTriState :: State_Error ;
				}

				if ( ( X_E_CLOSED && ! Y_E_CLOSED ) || ( ! X_E_CLOSED && Y_E_CLOSED ) )
				{				
					a_After = new WmiUnsignedIntegerRangeNode (

						m_PropertyName ,
						m_Index ,
						X_E_INFINITE ,
						X_E_INFINITE ,
						TRUE ,
						TRUE ,
						X_E ,
						X_E ,
						NULL ,
						NULL
					) ;

					if ( ! ( a_After ) )
					{
						t_Status = WmiTriState :: State_Error ;
					}
				}
			}
			else if ( CompareUnsignedIntegerGreater ( X_E ,  X_E_INFINITE ? 1 : 0 , Y_E , Y_E_INFINITE ? 1 : 0 ) ) // ( X_E > Y_E )
			{
//				Order ( X_S == Y_S < Y_E < X_E )
//				Range ( X_S , Y_E )

				if ( ( X_S_CLOSED && ! Y_S_CLOSED ) || ( ! X_S_CLOSED && Y_S_CLOSED ) )
				{				
					a_Before = new WmiUnsignedIntegerRangeNode (

						m_PropertyName ,
						m_Index ,
						Y_S_INFINITE ,
						Y_E_INFINITE ,
						TRUE ,		
						TRUE ,					
						X_S ,
						X_S ,
						NULL ,
						NULL
					) ;

					if ( ! ( a_Before ) )
					{
						t_Status = WmiTriState :: State_Error ;
					}
				}

				a_Intersection = new WmiUnsignedIntegerRangeNode (

					m_PropertyName ,
					m_Index ,
					Y_S_INFINITE ,
					Y_E_INFINITE ,
					X_S_CLOSED && Y_S_CLOSED ,		// Check for weak relationship ( < , > ) 
					Y_E_CLOSED ,					// Relationship is as strong as ordering 
					X_S ,
					Y_E ,
					NULL ,
					NULL
				) ;

				a_After = new WmiUnsignedIntegerRangeNode (

					m_PropertyName ,
					m_Index ,
					Y_E_INFINITE ,
					X_E_INFINITE ,
					! Y_E_CLOSED ,
					X_E_CLOSED ,
					Y_E ,
					X_E ,
					NULL ,
					NULL
				) ;

				if ( ! ( a_Intersection && a_After ) )
				{
					t_Status = WmiTriState :: State_Error ;
				}
			}
		}
		else if ( CompareUnsignedIntegerEqual ( Y_S ,  Y_S_INFINITE ? -1 : 0 , X_E , X_E_INFINITE ? 1 : 0 ) ) // ( Y_S == X_E ), Start of Y and End Of X overlap
		{
			if ( CompareUnsignedIntegerLess ( X_E ,  X_E_INFINITE ? 1 : 0 , Y_E , Y_E_INFINITE ? 1 : 0 ) ) // ( X_E < Y_E )
			{
//				Order ( X_S == Y_S == X_E < Y_E )

				if ( Y_S_CLOSED )
				{
					a_Intersection = new WmiUnsignedIntegerRangeNode (

						m_PropertyName ,
						m_Index ,
						FALSE ,
						FALSE  ,
						TRUE ,
						TRUE ,
						Y_S ,
						Y_S ,
						NULL ,
						NULL
					) ;

					a_After = new WmiUnsignedIntegerRangeNode (

						m_PropertyName ,
						m_Index ,
						FALSE ,
						Y_E_INFINITE,
						FALSE ,
						Y_E_CLOSED ,
						Y_S ,
						Y_E ,
						NULL ,
						NULL
					) ;

					if ( ! ( a_Intersection && a_After ) )
					{
						t_Status = WmiTriState :: State_Error ;
					}
				}
				else
				{
					a_Before = new WmiUnsignedIntegerRangeNode (

						m_PropertyName ,
						m_Index ,
						FALSE ,
						FALSE  ,
						TRUE ,
						TRUE ,
						X_S ,
						X_S ,
						NULL ,
						NULL
					) ;

					a_After = new WmiUnsignedIntegerRangeNode (

						m_PropertyName ,
						m_Index ,
						FALSE ,
						Y_E_INFINITE,
						FALSE ,
						Y_E_CLOSED ,
						Y_S ,
						Y_E ,
						NULL ,
						NULL
					) ;

					if ( ! ( a_Before && a_After ) )
					{
						t_Status = WmiTriState :: State_Error ;
					}
				}
			}
			else if ( CompareUnsignedIntegerEqual ( X_E ,  X_E_INFINITE ? 1 : 0 , Y_E , Y_E_INFINITE ? 1 : 0 ) ) // ( X_E == Y_E )
			{
//				Order ( X_S == Y_S == X_E == Y_E )

				a_Intersection = new WmiUnsignedIntegerRangeNode (

					m_PropertyName ,
					m_Index ,
					FALSE ,
					FALSE  ,
					TRUE ,
					TRUE ,
					Y_S ,
					Y_S ,
					NULL ,
					NULL
				) ;

				if ( ! ( a_Intersection ) )
				{
					t_Status = WmiTriState :: State_Error ;
				}
			}
			else if ( CompareUnsignedIntegerGreater ( X_E ,  X_E_INFINITE ? 1 : 0 , Y_E , Y_E_INFINITE ? 1 : 0 ) ) // ( X_E > Y_E )
			{
// Can never happen
DebugBreak () ;
			}
		}
		else if ( CompareUnsignedIntegerGreater ( Y_S ,  Y_S_INFINITE ? -1 : 0 , X_E , X_E_INFINITE ? 1 : 0 ) )  // ( Y_S > X_E )
		{
// Can never happen
DebugBreak () ;
		}
	}
	else if ( CompareUnsignedIntegerGreater ( X_S ,  X_S_INFINITE ? -1 : 0 , Y_S , Y_S_INFINITE ? -1 : 0 ) ) // ( X_S > Y_S )
	{
		if ( CompareUnsignedIntegerLess ( X_S ,  X_S_INFINITE ? -1 : 0 , Y_E , Y_E_INFINITE ? 1 : 0 ) ) // ( X_S < Y_E )
		{
			if ( CompareUnsignedIntegerLess ( Y_E ,  Y_E_INFINITE ? 1 : 0 , X_E , X_E_INFINITE ? 1 : 0 ) ) // ( Y_E < X_E )
			{
//				Order ( Y_S < X_S < Y_E < X_E )
//				Range ( X_S , Y_E ) 

				a_Before = new WmiUnsignedIntegerRangeNode (

					m_PropertyName ,
					m_Index ,
					Y_S_INFINITE ,
					X_S_INFINITE ,
					Y_S_CLOSED ,						// Relationship is as strong as ordering 
					! X_S_CLOSED ,						// Relationship is as strong as ordering 
					X_S ,
					Y_E ,
					NULL ,
					NULL
				) ;

				a_Intersection = new WmiUnsignedIntegerRangeNode (

					m_PropertyName ,
					m_Index ,
					X_S_INFINITE ,
					Y_E_INFINITE ,
					X_S_CLOSED ,						// Relationship is as strong as ordering 
					Y_E_CLOSED ,						// Relationship is as strong as ordering 
					X_S ,
					Y_E ,
					NULL ,
					NULL
				) ;

				a_After = new WmiUnsignedIntegerRangeNode (

					m_PropertyName ,
					m_Index ,
					Y_E_INFINITE ,
					X_E_INFINITE ,
					! Y_E_CLOSED ,						// Relationship is as strong as ordering 
					X_E_CLOSED ,						// Relationship is as strong as ordering 
					X_S ,
					Y_E ,
					NULL ,
					NULL
				) ;

				if ( ! ( a_Before && a_Intersection && a_After ) )
				{
					t_Status = WmiTriState :: State_Error ;
				}
			}
			else if ( CompareUnsignedIntegerEqual ( Y_E ,  Y_E_INFINITE ? 1 : 0 , X_E , X_E_INFINITE ? 1 : 0 ) ) // ( Y_E == X_E )
			{
//				Order ( Y_S < X_S < Y_E == X_E )
//				Range ( X_S , Y_E ) 

				a_Before = new WmiUnsignedIntegerRangeNode (

					m_PropertyName ,
					m_Index ,
					Y_S_INFINITE ,
					X_S_INFINITE ,
					Y_S_CLOSED ,						// Relationship is as strong as ordering 
					! X_S_CLOSED ,						// Relationship is as strong as ordering 
					X_S ,
					Y_E ,
					NULL ,
					NULL
				) ;

				a_Intersection = new WmiUnsignedIntegerRangeNode (

					m_PropertyName ,
					m_Index ,
					X_S_INFINITE ,
					Y_E_INFINITE ,
					X_S_CLOSED ,						// Relationship is as strong as ordering 
					Y_E_CLOSED && X_E_CLOSED ,			// Check for weak relationship ( < , > ) 
					X_S ,
					Y_E ,
					NULL ,
					NULL
				) ;

				if ( ! ( a_Before && a_Intersection ) )
				{
					t_Status = WmiTriState :: State_Error ;
				}

				if ( ( X_E_CLOSED && ! Y_E_CLOSED ) || ( ! X_E_CLOSED && Y_E_CLOSED ) )
				{
					a_After = new WmiUnsignedIntegerRangeNode (

						m_PropertyName ,
						m_Index ,
						X_E_INFINITE ,
						X_E_INFINITE ,
						TRUE ,						
						TRUE ,			
						X_E ,
						X_E ,
						NULL ,
						NULL
					) ;

					if ( ! ( a_After ) )
					{
						t_Status = WmiTriState :: State_Error ;
					}
				}
			}
			else if ( CompareUnsignedIntegerGreater ( Y_E ,  Y_E_INFINITE ? 1 : 0 , X_E , X_E_INFINITE ? 1 : 0 ) ) // ( Y_E > X_E )
			{
//				Order ( Y_S < X_S < X_E < Y_E )
//				Range ( X_S , X_E ) 

				a_Before = new WmiUnsignedIntegerRangeNode (

					m_PropertyName ,
					m_Index ,
					Y_S_INFINITE ,
					X_S_INFINITE ,
					Y_S_CLOSED ,						// Relationship is as strong as ordering 
					! X_S_CLOSED ,						// Relationship is as strong as ordering 
					Y_S ,
					X_S ,
					NULL ,
					NULL
				) ;

				a_Intersection = new WmiUnsignedIntegerRangeNode (

					m_PropertyName ,
					m_Index ,
					X_S_INFINITE ,
					X_E_INFINITE ,
					X_S_CLOSED ,						// Relationship is as strong as ordering 
					X_E_CLOSED ,						// Relationship is as strong as ordering 
					X_S ,
					X_E ,
					NULL ,
					NULL
				) ;

				a_After = new WmiUnsignedIntegerRangeNode (

					m_PropertyName ,
					m_Index ,
					X_E_INFINITE ,
					Y_E_INFINITE ,
					! X_E_CLOSED ,						// Relationship is as strong as ordering 
					Y_E_CLOSED ,						// Relationship is as strong as ordering 
					X_E ,
					Y_E ,
					NULL ,
					NULL
				) ;

				if ( ! ( a_Before && a_Intersection && a_After ) )
				{
					t_Status = WmiTriState :: State_Error ;
				}
			}
		}
		else if ( CompareUnsignedIntegerEqual ( X_S ,  X_S_INFINITE ? -1 : 0 , Y_E , Y_E_INFINITE ? 1 : 0 ) ) // ( X_S == Y_E ), Start of X and End Of Y overlap
		{
			if ( CompareUnsignedIntegerLess ( Y_E ,  Y_E_INFINITE ? 1 : 0 , X_E , X_E_INFINITE ? 1 : 0 ) ) // ( Y_E < X_E )
			{
// Can never happen
DebugBreak () ;
			}
			else if ( CompareUnsignedIntegerEqual ( Y_E ,  Y_E_INFINITE ? 1 : 0 , X_E , X_E_INFINITE ? 1 : 0 ) ) // ( Y_E == X_E )
			{
//				Order ( Y_S < X_S == Y_E == X_E )

				if ( Y_E_CLOSED )
				{
					a_Before = new WmiUnsignedIntegerRangeNode (

						m_PropertyName ,
						m_Index ,
						Y_S_INFINITE ,
						FALSE,
						Y_S_CLOSED ,
						FALSE,
						Y_S ,
						Y_E ,
						NULL ,
						NULL
					) ;

					a_Intersection = new WmiUnsignedIntegerRangeNode (

						m_PropertyName ,
						m_Index ,
						FALSE ,
						FALSE  ,
						TRUE ,
						TRUE ,
						Y_E ,
						Y_E ,
						NULL ,
						NULL
					) ;

					if ( ! ( a_Before && a_Intersection ) )
					{
						t_Status = WmiTriState :: State_Error ;
					}
				}
				else
				{
					a_Before = new WmiUnsignedIntegerRangeNode (

						m_PropertyName ,
						m_Index ,
						FALSE ,
						FALSE  ,
						TRUE ,
						FALSE ,
						Y_S ,
						Y_E ,
						NULL ,
						NULL
					) ;

					a_After = new WmiUnsignedIntegerRangeNode (

						m_PropertyName ,
						m_Index ,
						FALSE ,
						FALSE,
						TRUE ,
						TRUE ,
						X_S ,
						X_S ,
						NULL ,
						NULL
					) ;

					if ( ! ( a_Before && a_After ) )
					{
						t_Status = WmiTriState :: State_Error ;
					}
				}
			}
			else if ( CompareUnsignedIntegerGreater ( Y_E ,  Y_E_INFINITE ? 1 : 0 , X_E , X_E_INFINITE ? 1 : 0 ) ) // ( Y_E > X_E )
			{
//				Order ( Y_S < X_S == X_E < Y_E )

				a_Before = new WmiUnsignedIntegerRangeNode (

					m_PropertyName ,
					m_Index ,
					Y_S_INFINITE ,
					FALSE  ,
					Y_S_CLOSED ,
					FALSE ,
					Y_S ,
					X_S ,
					NULL ,
					NULL
				) ;

				a_Intersection = new WmiUnsignedIntegerRangeNode (

					m_PropertyName ,
					m_Index ,
					FALSE ,
					FALSE  ,
					TRUE ,
					TRUE ,
					X_S ,
					X_S ,
					NULL ,
					NULL
				) ;

				a_After = new WmiUnsignedIntegerRangeNode (

					m_PropertyName ,
					m_Index ,
					FALSE ,
					Y_E_INFINITE  ,
					FALSE ,
					Y_E_CLOSED ,
					X_S ,
					Y_E ,
					NULL ,
					NULL
				) ;

				if ( ! ( a_Before && a_Intersection && a_After ) )
				{
					t_Status = WmiTriState :: State_Error ;
				}
			}
		}
		else if ( CompareUnsignedIntegerGreater ( X_S ,  X_S_INFINITE ? -1 : 0 , Y_E , Y_E_INFINITE ? 1 : 0 ) ) // ( X_S > Y_E )
		{
			a_Before = ( WmiUnsignedIntegerRangeNode * ) ( a_UnsignedInteger.Copy () ) ;
			a_After = ( WmiUnsignedIntegerRangeNode * ) ( this->Copy () ) ;

			if ( ! ( a_Before && a_After ) )
			{
				t_Status = WmiTriState :: State_Error ;
			}
		}
	}

	if ( t_Status != WmiTriState :: State_True )
	{
		delete a_Before ;
		delete a_Intersection ;
		delete a_After ;

		a_Before = NULL ;
		a_Intersection = NULL ;
		a_After = NULL ;
	}

	return t_Status ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

WmiTriState WmiStringRangeNode :: GetNonIntersectingRange ( 

	WmiStringRangeNode &a_String ,
	WmiStringRangeNode *&a_Before ,
	WmiStringRangeNode *&a_Intersection ,
	WmiStringRangeNode *&a_After
)
{
	WmiTriState t_Status = WmiTriState :: State_True ;

// A weak ( open ) relationship is ( < , > ) 
// A strong ( closed ) relationship is ( == , <= , >= )

	a_Before = NULL ;
	a_Intersection = NULL ;
	a_After = NULL ;

	BSTR X_S = m_LowerBound ;
	BSTR X_E = m_UpperBound ;
	BSTR Y_S = a_String.m_LowerBound ;
	BSTR Y_E = a_String.m_UpperBound ;

	BOOL X_S_CLOSED = m_LowerBoundClosed ;
	BOOL X_E_CLOSED = m_UpperBoundClosed ;
	BOOL Y_S_CLOSED = a_String.m_LowerBoundClosed ;
	BOOL Y_E_CLOSED = a_String.m_UpperBoundClosed ;

	BOOL X_S_INFINITE = m_InfiniteLowerBound ;
	BOOL X_E_INFINITE = m_InfiniteUpperBound ;
	BOOL Y_S_INFINITE = a_String.m_InfiniteLowerBound ;
	BOOL Y_E_INFINITE = a_String.m_InfiniteUpperBound ;

	if ( CompareStringLess ( X_S ,  X_S_INFINITE ? - 1 : 0 , Y_S , Y_S_INFINITE ? -1 : 0 ) ) // ( X_S < Y_S )
	{
		if ( CompareStringLess ( Y_S ,  Y_S_INFINITE ? -1 : 0 , X_E , X_E_INFINITE ? 1 : 0 ) ) // ( Y_S < X_E )
		{
			if ( CompareStringLess ( X_E ,  X_E_INFINITE ? 1 : 0 , Y_E , Y_E_INFINITE ? 1 : 0 ) ) // ( X_E < Y_E )
			{
//				Order ( X_S < Y_S < X_E < Y_E )
//				Range ( Y_S , X_E ) 

				a_Before = new WmiStringRangeNode (

					m_PropertyName ,
					m_Index ,
					X_S_INFINITE ,
					Y_S_INFINITE ,
					X_S_CLOSED ,						// Relationship is as strong as ordering 
					! Y_S_CLOSED ,						// Relationship is as strong as ordering 
					X_S ,
					Y_S ,
					NULL ,
					NULL
				) ;

				a_Intersection = new WmiStringRangeNode (

					m_PropertyName ,
					m_Index ,
					Y_S_INFINITE ,
					X_E_INFINITE ,
					Y_S_CLOSED ,						// Relationship is as strong as ordering 
					X_E_CLOSED ,						// Relationship is as strong as ordering 
					Y_S ,
					X_E ,
					NULL ,
					NULL
				) ;

				a_After = new WmiStringRangeNode (

					m_PropertyName ,
					m_Index ,
					X_E_INFINITE ,
					Y_E_INFINITE ,
					! X_E_CLOSED ,						// Relationship is as strong as ordering 
					Y_E_CLOSED ,						// Relationship is as strong as ordering 
					X_E ,
					Y_E ,
					NULL ,
					NULL
				) ;

				if ( ! ( a_Before && a_Intersection && a_After ) )
				{
					t_Status = WmiTriState :: State_Error ;
				}
			}
			else if ( CompareStringEqual ( X_E ,  X_E_INFINITE ? 1 : 0 , Y_E , Y_E_INFINITE ? 1 : 0 ) ) // ( X_E == Y_E )
			{
//				Order ( X_S < Y_S < X_E == Y_E )
//				Range ( Y_S , X_E ) 

				a_Before = new WmiStringRangeNode (

					m_PropertyName ,
					m_Index ,
					X_S_INFINITE ,
					Y_S_INFINITE ,
					X_S_CLOSED  ,						// Relationship is as strong as ordering 
					! Y_S_CLOSED ,			
					X_S ,
					Y_S ,
					NULL ,
					NULL
				) ;

				a_Intersection = new WmiStringRangeNode (

					m_PropertyName ,
					m_Index ,
					Y_S_INFINITE ,
					X_E_INFINITE ,
					Y_S_CLOSED  ,						// Relationship is as strong as ordering 
					X_E_CLOSED && Y_E_CLOSED ,			// Check for weak relationship ( < , > ) 
					Y_S ,
					X_E ,
					NULL ,
					NULL
				) ;

				if ( ! ( a_Before && a_Intersection ) )
				{
					t_Status = WmiTriState :: State_Error ;
				}

				if ( ( X_E_CLOSED && ! Y_E_CLOSED ) || ( ! X_E_CLOSED && Y_E_CLOSED ) )
				{
					a_After = new WmiStringRangeNode (

						m_PropertyName ,
						m_Index ,
						X_E_INFINITE ,
						X_E_INFINITE ,
						TRUE ,						
						TRUE ,			
						X_E ,
						X_E ,
						NULL ,
						NULL
					) ;

					if ( ! ( a_After ) )
					{
						t_Status = WmiTriState :: State_Error ;
					}
				}
			}
			else if ( CompareStringGreater ( X_E ,  X_E_INFINITE ? 1 : 0 , Y_E , Y_E_INFINITE ? 1 : 0 ) ) // ( X_E > Y_E ) 
			{
//				Order ( X_S < Y_S < Y_E < X_E )
//				Range ( Y_S , Y_E )

				a_Before = new WmiStringRangeNode (

					m_PropertyName ,
					m_Index ,
					X_S_INFINITE ,
					Y_S_INFINITE ,
					X_S_CLOSED ,						// Relationship is as strong as ordering 
					! Y_S_CLOSED ,						// Relationship is as strong as ordering 
					X_S ,
					Y_S ,
					NULL ,
					NULL
				) ;

				a_Intersection = new WmiStringRangeNode (

					m_PropertyName ,
					m_Index ,
					Y_S_INFINITE ,
					Y_E_INFINITE ,
					Y_S_CLOSED ,						// Relationship is as strong as ordering 
					Y_E_CLOSED ,						// Relationship is as strong as ordering 
					Y_S ,
					Y_E ,
					NULL ,
					NULL
				) ;

				a_After = new WmiStringRangeNode (

					m_PropertyName ,
					m_Index ,
					Y_E_INFINITE ,
					X_E_INFINITE ,
					! Y_E_CLOSED ,						// Relationship is as strong as ordering 
					X_E_CLOSED ,						// Relationship is as strong as ordering 
					Y_E ,
					X_E ,
					NULL ,
					NULL
				) ;

				if ( ! ( a_Before && a_Intersection && a_After ) )
				{
					t_Status = WmiTriState :: State_Error ;
				}
			}
		}
		else if ( CompareStringEqual ( Y_S ,  Y_S_INFINITE ? -1 : 0 , X_E , X_E_INFINITE ? 1 : 0 ) )  // ( Y_S == X_E ), Start of Y and End Of X overlap
		{
			if ( CompareStringLess ( X_E ,  X_E_INFINITE ? 1 : 0 , Y_E , Y_E_INFINITE ? 1 : 0 ) ) // ( X_E < Y_E )
			{
			// Order ( X_S < Y_S == X_E < Y_E )

				if ( X_E_CLOSED && Y_S_CLOSED )
				{
					a_Before = new WmiStringRangeNode (

						m_PropertyName ,
						m_Index ,
						X_S_INFINITE ,
						FALSE ,
						X_S_CLOSED ,
						FALSE ,
						X_S ,
						X_E ,
						NULL ,
						NULL
					) ;

					a_Intersection = new WmiStringRangeNode (

						m_PropertyName ,
						m_Index ,
						FALSE ,
						FALSE  ,
						TRUE ,
						TRUE ,
						Y_S ,
						Y_S ,
						NULL ,
						NULL
					) ;

					a_After = new WmiStringRangeNode (

						m_PropertyName ,
						m_Index ,
						FALSE ,
						Y_E_INFINITE ,
						FALSE ,
						Y_E_CLOSED ,
						Y_S ,
						Y_E ,
						NULL ,
						NULL
					) ;

					if ( ! ( a_Before && a_Intersection && a_After ) )
					{
						t_Status = WmiTriState :: State_Error ;
					}
				}
				else
				{
					a_Before = new WmiStringRangeNode (

						m_PropertyName ,
						m_Index ,
						X_S_INFINITE ,
						FALSE ,
						X_S_CLOSED ,
						X_E_CLOSED,
						X_S ,
						X_E ,
						NULL ,
						NULL
					) ;

					a_After = new WmiStringRangeNode (

						m_PropertyName ,
						m_Index ,
						FALSE ,
						Y_E_INFINITE ,
						Y_S_CLOSED ,
						Y_E_CLOSED ,
						Y_S ,
						Y_E ,
						NULL ,
						NULL
					) ;

					if ( ! ( a_Before && a_After ) )
					{
						t_Status = WmiTriState :: State_Error ;
					}
				}
			}
			else if ( CompareStringEqual ( X_E ,  X_E_INFINITE ? 1 : 0 , Y_E , Y_E_INFINITE ? 1 : 0 ) ) // ( X_E == Y_E )
			{
// Order ( X_S < Y_S == X_E == Y_E )

				if ( X_E_CLOSED )
				{
					a_Before = new WmiStringRangeNode (

						m_PropertyName ,
						m_Index ,
						X_S_INFINITE ,
						FALSE ,
						X_S_CLOSED ,
						FALSE ,
						X_S ,
						X_E ,
						NULL ,
						NULL
					) ;

					a_Intersection = new WmiStringRangeNode (

						m_PropertyName ,
						m_Index ,
						FALSE ,
						FALSE  ,
						TRUE ,
						TRUE ,
						Y_S ,
						Y_S ,
						NULL ,
						NULL
					) ;

					if ( ! ( a_Before && a_Intersection ) )
					{
						t_Status = WmiTriState :: State_Error ;
					}
				}
				else
				{
					a_Before = new WmiStringRangeNode (

						m_PropertyName ,
						m_Index ,
						X_S_INFINITE ,
						FALSE ,
						X_S_CLOSED ,
						X_E_CLOSED,
						X_S ,
						X_E ,
						NULL ,
						NULL
					) ;

					a_After = new WmiStringRangeNode (

						m_PropertyName ,
						m_Index ,
						FALSE ,
						Y_S_INFINITE ,
						TRUE ,
						TRUE,
						Y_S ,
						Y_S ,
						NULL ,
						NULL
					) ;

					if ( ! ( a_Before && a_After ) )
					{
						t_Status = WmiTriState :: State_Error ;
					}
				}
			}
			else if ( CompareStringGreater ( X_E ,  X_E_INFINITE ? 1 : 0 , Y_E , Y_E_INFINITE ? 1 : 0 ) ) // ( X_E > Y_E )
			{
// Order ( X_S < Y_E < Y_S == X_E ) Can never happen
DebugBreak () ;
			}
		}
		else if ( CompareStringGreater ( Y_S ,  Y_S_INFINITE ? -1 : 0 , X_E , X_E_INFINITE ? 1 : 0 ) ) // ( Y_S > X_E )
		{
//				Order ( X_S < Y_S , X_E < Y_S )

			a_Before = ( WmiStringRangeNode * ) ( this->Copy () ) ;
			a_After = ( WmiStringRangeNode * ) ( a_String.Copy () ) ;

			if ( ! ( a_Before && a_After ) )
			{
				t_Status = WmiTriState :: State_Error ;
			}
		}
	}
	else if ( CompareStringEqual ( X_S ,  X_S_INFINITE ? -1 : 0 , Y_S , Y_S_INFINITE ? -1 : 0 ) ) // ( X_S == Y_S ) 
	{
		if ( CompareStringLess ( Y_S ,  Y_S_INFINITE ? -1 : 0 , X_E , X_E_INFINITE ? 1 : 0 ) ) // ( Y_S < X_E )
		{
			if ( CompareStringLess ( X_E ,  X_E_INFINITE ? 1 : 0 , Y_E , Y_E_INFINITE ? 1 : 0 ) ) // ( X_E < Y_E )
			{
//				Order ( X_S == Y_S < X_E < Y_E )
//				Range ( Y_S , X_E )

				if ( ( X_S_CLOSED && ! Y_S_CLOSED ) || ( ! X_S_CLOSED && Y_S_CLOSED ) )
				{				
					a_Before = new WmiStringRangeNode (

						m_PropertyName ,
						m_Index ,
						Y_S_INFINITE ,
						Y_E_INFINITE ,
						TRUE ,
						TRUE ,
						X_S ,
						X_S ,
						NULL ,
						NULL
					) ;

					if ( ! ( a_Before ) )
					{
						t_Status = WmiTriState :: State_Error ;
					}
				}

				a_Intersection = new WmiStringRangeNode (

					m_PropertyName ,
					m_Index ,
					Y_S_INFINITE ,
					Y_E_INFINITE ,
					X_S_CLOSED && Y_S_CLOSED ,		// Check for weak relationship ( < , > ) 
					X_E_CLOSED ,					// Relationship is as strong as ordering 
					Y_S ,
					X_E ,
					NULL ,
					NULL
				) ;

				a_After = new WmiStringRangeNode (

					m_PropertyName ,
					m_Index ,
					X_E_INFINITE ,
					Y_E_INFINITE ,
					! X_E_CLOSED ,		
					Y_E_CLOSED ,		
					X_E ,
					Y_E ,
					NULL ,
					NULL
				) ;

				if ( ! ( a_Intersection && a_After ) )
				{
					t_Status = WmiTriState :: State_Error ;
				}
			}
			else if ( CompareStringEqual ( X_E ,  X_E_INFINITE ? 1 : 0 , Y_E , Y_E_INFINITE ? 1 : 0 ) ) // ( X_E == Y_E )
			{
//				Order ( X_S == Y_S < X_E == Y_E )
//				Range ( X_S , X_E )

				if ( ( X_S_CLOSED && ! Y_S_CLOSED ) || ( ! X_S_CLOSED && Y_S_CLOSED ) )
				{				
					a_Before = new WmiStringRangeNode (

						m_PropertyName ,
						m_Index ,
						Y_S_INFINITE ,
						Y_E_INFINITE ,
						TRUE ,
						TRUE ,
						X_S ,
						X_S ,
						NULL ,
						NULL
					) ;

					if ( ! ( a_Before ) )
					{
						t_Status = WmiTriState :: State_Error ;
					}
				}

				a_Intersection = new WmiStringRangeNode (

					m_PropertyName ,
					m_Index ,
					Y_S_INFINITE ,
					Y_E_INFINITE ,
					X_S_CLOSED && Y_S_CLOSED ,		// Check for weak relationship ( < , > ) 
					Y_E_CLOSED && X_E_CLOSED ,		// Check for weak relationship ( < , > ) 
					X_S ,
					X_E ,
					NULL ,
					NULL
				) ;

				if ( ! ( a_Intersection ) )
				{
					t_Status = WmiTriState :: State_Error ;
				}

				if ( ( X_E_CLOSED && ! Y_E_CLOSED ) || ( ! X_E_CLOSED && Y_E_CLOSED ) )
				{				
					a_After = new WmiStringRangeNode (

						m_PropertyName ,
						m_Index ,
						X_E_INFINITE ,
						X_E_INFINITE ,
						TRUE ,
						TRUE ,
						X_E ,
						X_E ,
						NULL ,
						NULL
					) ;

					if ( ! ( a_After ) )
					{
						t_Status = WmiTriState :: State_Error ;
					}
				}
			}
			else if ( CompareStringGreater ( X_E ,  X_E_INFINITE ? 1 : 0 , Y_E , Y_E_INFINITE ? 1 : 0 ) ) // ( X_E > Y_E )
			{
//				Order ( X_S == Y_S < Y_E < X_E )
//				Range ( X_S , Y_E )

				if ( ( X_S_CLOSED && ! Y_S_CLOSED ) || ( ! X_S_CLOSED && Y_S_CLOSED ) )
				{				
					a_Before = new WmiStringRangeNode (

						m_PropertyName ,
						m_Index ,
						Y_S_INFINITE ,
						Y_E_INFINITE ,
						TRUE ,		
						TRUE ,					
						X_S ,
						X_S ,
						NULL ,
						NULL
					) ;

					if ( ! ( a_Before ) )
					{
						t_Status = WmiTriState :: State_Error ;
					}
				}

				a_Intersection = new WmiStringRangeNode (

					m_PropertyName ,
					m_Index ,
					Y_S_INFINITE ,
					Y_E_INFINITE ,
					X_S_CLOSED && Y_S_CLOSED ,		// Check for weak relationship ( < , > ) 
					Y_E_CLOSED ,					// Relationship is as strong as ordering 
					X_S ,
					Y_E ,
					NULL ,
					NULL
				) ;

				a_After = new WmiStringRangeNode (

					m_PropertyName ,
					m_Index ,
					Y_E_INFINITE ,
					X_E_INFINITE ,
					! Y_E_CLOSED ,
					X_E_CLOSED ,
					Y_E ,
					X_E ,
					NULL ,
					NULL
				) ;

				if ( ! ( a_Intersection && a_After ) )
				{
					t_Status = WmiTriState :: State_Error ;
				}
			}
		}
		else if ( CompareStringEqual ( Y_S ,  Y_S_INFINITE ? -1 : 0 , X_E , X_E_INFINITE ? 1 : 0 ) ) // ( Y_S == X_E ), Start of Y and End Of X overlap
		{
			if ( CompareStringLess ( X_E ,  X_E_INFINITE ? 1 : 0 , Y_E , Y_E_INFINITE ? 1 : 0 ) ) // ( X_E < Y_E )
			{
//				Order ( X_S == Y_S == X_E < Y_E )

				if ( Y_S_CLOSED )
				{
					a_Intersection = new WmiStringRangeNode (

						m_PropertyName ,
						m_Index ,
						FALSE ,
						FALSE  ,
						TRUE ,
						TRUE ,
						Y_S ,
						Y_S ,
						NULL ,
						NULL
					) ;

					a_After = new WmiStringRangeNode (

						m_PropertyName ,
						m_Index ,
						FALSE ,
						Y_E_INFINITE,
						FALSE ,
						Y_E_CLOSED ,
						Y_S ,
						Y_E ,
						NULL ,
						NULL
					) ;

					if ( ! ( a_Intersection && a_After ) )
					{
						t_Status = WmiTriState :: State_Error ;
					}
				}
				else
				{
					a_Before = new WmiStringRangeNode (

						m_PropertyName ,
						m_Index ,
						FALSE ,
						FALSE  ,
						TRUE ,
						TRUE ,
						X_S ,
						X_S ,
						NULL ,
						NULL
					) ;

					a_After = new WmiStringRangeNode (

						m_PropertyName ,
						m_Index ,
						FALSE ,
						Y_E_INFINITE,
						FALSE ,
						Y_E_CLOSED ,
						Y_S ,
						Y_E ,
						NULL ,
						NULL
					) ;

					if ( ! ( a_Before && a_After ) )
					{
						t_Status = WmiTriState :: State_Error ;
					}
				}
			}
			else if ( CompareStringEqual ( X_E ,  X_E_INFINITE ? 1 : 0 , Y_E , Y_E_INFINITE ? 1 : 0 ) ) // ( X_E == Y_E )
			{
//				Order ( X_S == Y_S == X_E == Y_E )

				a_Intersection = new WmiStringRangeNode (

					m_PropertyName ,
					m_Index ,
					FALSE ,
					FALSE  ,
					TRUE ,
					TRUE ,
					Y_S ,
					Y_S ,
					NULL ,
					NULL
				) ;

				if ( ! ( a_Intersection ) )
				{
					t_Status = WmiTriState :: State_Error ;
				}
			}
			else if ( CompareStringGreater ( X_E ,  X_E_INFINITE ? 1 : 0 , Y_E , Y_E_INFINITE ? 1 : 0 ) ) // ( X_E > Y_E )
			{
// Can never happen
DebugBreak () ;
			}
		}
		else if ( CompareStringGreater ( Y_S ,  Y_S_INFINITE ? -1 : 0 , X_E , X_E_INFINITE ? 1 : 0 ) )  // ( Y_S > X_E )
		{
// Can never happen
DebugBreak () ;
		}
	}
	else if ( CompareStringGreater ( X_S ,  X_S_INFINITE ? -1 : 0 , Y_S , Y_S_INFINITE ? -1 : 0 ) ) // ( X_S > Y_S )
	{
		if ( CompareStringLess ( X_S ,  X_S_INFINITE ? -1 : 0 , Y_E , Y_E_INFINITE ? 1 : 0 ) ) // ( X_S < Y_E )
		{
			if ( CompareStringLess ( Y_E ,  Y_E_INFINITE ? 1 : 0 , X_E , X_E_INFINITE ? 1 : 0 ) ) // ( Y_E < X_E )
			{
//				Order ( Y_S < X_S < Y_E < X_E )
//				Range ( X_S , Y_E ) 

				a_Before = new WmiStringRangeNode (

					m_PropertyName ,
					m_Index ,
					Y_S_INFINITE ,
					X_S_INFINITE ,
					Y_S_CLOSED ,						// Relationship is as strong as ordering 
					! X_S_CLOSED ,						// Relationship is as strong as ordering 
					X_S ,
					Y_E ,
					NULL ,
					NULL
				) ;

				a_Intersection = new WmiStringRangeNode (

					m_PropertyName ,
					m_Index ,
					X_S_INFINITE ,
					Y_E_INFINITE ,
					X_S_CLOSED ,						// Relationship is as strong as ordering 
					Y_E_CLOSED ,						// Relationship is as strong as ordering 
					X_S ,
					Y_E ,
					NULL ,
					NULL
				) ;

				a_After = new WmiStringRangeNode (

					m_PropertyName ,
					m_Index ,
					Y_E_INFINITE ,
					X_E_INFINITE ,
					! Y_E_CLOSED ,						// Relationship is as strong as ordering 
					X_E_CLOSED ,						// Relationship is as strong as ordering 
					X_S ,
					Y_E ,
					NULL ,
					NULL
				) ;

				if ( ! ( a_Before && a_Intersection && a_After ) )
				{
					t_Status = WmiTriState :: State_Error ;
				}
			}
			else if ( CompareStringEqual ( Y_E ,  Y_E_INFINITE ? 1 : 0 , X_E , X_E_INFINITE ? 1 : 0 ) ) // ( Y_E == X_E )
			{
//				Order ( Y_S < X_S < Y_E == X_E )
//				Range ( X_S , Y_E ) 

				a_Before = new WmiStringRangeNode (

					m_PropertyName ,
					m_Index ,
					Y_S_INFINITE ,
					X_S_INFINITE ,
					Y_S_CLOSED ,						// Relationship is as strong as ordering 
					! X_S_CLOSED ,						// Relationship is as strong as ordering 
					X_S ,
					Y_E ,
					NULL ,
					NULL
				) ;

				a_Intersection = new WmiStringRangeNode (

					m_PropertyName ,
					m_Index ,
					X_S_INFINITE ,
					Y_E_INFINITE ,
					X_S_CLOSED ,						// Relationship is as strong as ordering 
					Y_E_CLOSED && X_E_CLOSED ,			// Check for weak relationship ( < , > ) 
					X_S ,
					Y_E ,
					NULL ,
					NULL
				) ;

				if ( ! ( a_Before && a_Intersection ) )
				{
					t_Status = WmiTriState :: State_Error ;
				}

				if ( ( X_E_CLOSED && ! Y_E_CLOSED ) || ( ! X_E_CLOSED && Y_E_CLOSED ) )
				{
					a_After = new WmiStringRangeNode (

						m_PropertyName ,
						m_Index ,
						X_E_INFINITE ,
						X_E_INFINITE ,
						TRUE ,						
						TRUE ,			
						X_E ,
						X_E ,
						NULL ,
						NULL
					) ;

					if ( ! ( a_After ) )
					{
						t_Status = WmiTriState :: State_Error ;
					}
				}
			}
			else if ( CompareStringGreater ( Y_E ,  Y_E_INFINITE ? 1 : 0 , X_E , X_E_INFINITE ? 1 : 0 ) ) // ( Y_E > X_E )
			{
//				Order ( Y_S < X_S < X_E < Y_E )
//				Range ( X_S , X_E ) 

				a_Before = new WmiStringRangeNode (

					m_PropertyName ,
					m_Index ,
					Y_S_INFINITE ,
					X_S_INFINITE ,
					Y_S_CLOSED ,						// Relationship is as strong as ordering 
					! X_S_CLOSED ,						// Relationship is as strong as ordering 
					Y_S ,
					X_S ,
					NULL ,
					NULL
				) ;

				a_Intersection = new WmiStringRangeNode (

					m_PropertyName ,
					m_Index ,
					X_S_INFINITE ,
					X_E_INFINITE ,
					X_S_CLOSED ,						// Relationship is as strong as ordering 
					X_E_CLOSED ,						// Relationship is as strong as ordering 
					X_S ,
					X_E ,
					NULL ,
					NULL
				) ;

				a_After = new WmiStringRangeNode (

					m_PropertyName ,
					m_Index ,
					X_E_INFINITE ,
					Y_E_INFINITE ,
					! X_E_CLOSED ,						// Relationship is as strong as ordering 
					Y_E_CLOSED ,						// Relationship is as strong as ordering 
					X_E ,
					Y_E ,
					NULL ,
					NULL
				) ;

				if ( ! ( a_Before && a_Intersection && a_After ) )
				{
					t_Status = WmiTriState :: State_Error ;
				}
			}
		}
		else if ( CompareStringEqual ( X_S ,  X_S_INFINITE ? -1 : 0 , Y_E , Y_E_INFINITE ? 1 : 0 ) ) // ( X_S == Y_E ), Start of X and End Of Y overlap
		{
			if ( CompareStringLess ( Y_E ,  Y_E_INFINITE ? 1 : 0 , X_E , X_E_INFINITE ? 1 : 0 ) ) // ( Y_E < X_E )
			{
// Can never happen
DebugBreak () ;
			}
			else if ( CompareStringEqual ( Y_E ,  Y_E_INFINITE ? 1 : 0 , X_E , X_E_INFINITE ? 1 : 0 ) ) // ( Y_E == X_E )
			{
//				Order ( Y_S < X_S == Y_E == X_E )

				if ( Y_E_CLOSED )
				{
					a_Before = new WmiStringRangeNode (

						m_PropertyName ,
						m_Index ,
						Y_S_INFINITE ,
						FALSE,
						Y_S_CLOSED ,
						FALSE,
						Y_S ,
						Y_E ,
						NULL ,
						NULL
					) ;

					a_Intersection = new WmiStringRangeNode (

						m_PropertyName ,
						m_Index ,
						FALSE ,
						FALSE  ,
						TRUE ,
						TRUE ,
						Y_E ,
						Y_E ,
						NULL ,
						NULL
					) ;

					if ( ! ( a_Before && a_Intersection ) )
					{
						t_Status = WmiTriState :: State_Error ;
					}
				}
				else
				{
					a_Before = new WmiStringRangeNode (

						m_PropertyName ,
						m_Index ,
						FALSE ,
						FALSE  ,
						TRUE ,
						FALSE ,
						Y_S ,
						Y_E ,
						NULL ,
						NULL
					) ;

					a_After = new WmiStringRangeNode (

						m_PropertyName ,
						m_Index ,
						FALSE ,
						FALSE,
						TRUE ,
						TRUE ,
						X_S ,
						X_S ,
						NULL ,
						NULL
					) ;

					if ( ! ( a_Before && a_After ) )
					{
						t_Status = WmiTriState :: State_Error ;
					}
				}
			}
			else if ( CompareStringGreater ( Y_E ,  Y_E_INFINITE ? 1 : 0 , X_E , X_E_INFINITE ? 1 : 0 ) ) // ( Y_E > X_E )
			{
//				Order ( Y_S < X_S == X_E < Y_E )

				a_Before = new WmiStringRangeNode (

					m_PropertyName ,
					m_Index ,
					Y_S_INFINITE ,
					FALSE  ,
					Y_S_CLOSED ,
					FALSE ,
					Y_S ,
					X_S ,
					NULL ,
					NULL
				) ;

				a_Intersection = new WmiStringRangeNode (

					m_PropertyName ,
					m_Index ,
					FALSE ,
					FALSE  ,
					TRUE ,
					TRUE ,
					X_S ,
					X_S ,
					NULL ,
					NULL
				) ;

				a_After = new WmiStringRangeNode (

					m_PropertyName ,
					m_Index ,
					FALSE ,
					Y_E_INFINITE  ,
					FALSE ,
					Y_E_CLOSED ,
					X_S ,
					Y_E ,
					NULL ,
					NULL
				) ;

				if ( ! ( a_Before && a_Intersection && a_After ) )
				{
					t_Status = WmiTriState :: State_Error ;
				}
			}
		}
		else if ( CompareStringGreater ( X_S ,  X_S_INFINITE ? -1 : 0 , Y_E , Y_E_INFINITE ? 1 : 0 ) ) // ( X_S > Y_E )
		{
			a_Before = ( WmiStringRangeNode * ) ( a_String.Copy () ) ;
			a_After = ( WmiStringRangeNode * ) ( this->Copy () ) ;

			if ( ! ( a_Before && a_After ) )
			{
				t_Status = WmiTriState :: State_Error ;
			}
		}
	}

	if ( t_Status != WmiTriState :: State_True )
	{
		delete a_Before ;
		delete a_Intersection ;
		delete a_After ;

		a_Before = NULL ;
		a_Intersection = NULL ;
		a_After = NULL ;
	}

	return t_Status ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

WmiTriState WmiSignedIntegerRangeNode :: GetOverlappingRange ( 

	WmiSignedIntegerRangeNode &a_SignedInteger ,
	WmiSignedIntegerRangeNode *&a_Overlap
)
{
	WmiTriState t_Status = WmiTriState :: State_False ;

// A weak ( open ) relationship is ( < , > ) 
// A strong ( closed ) relationship is ( == , <= , >= )

	a_Overlap = NULL ;

	LONG X_S = m_LowerBound ;
	LONG X_E = m_UpperBound ;
	LONG Y_S = a_SignedInteger.m_LowerBound ;
	LONG Y_E = a_SignedInteger.m_UpperBound ;

	BOOL X_S_CLOSED = m_LowerBoundClosed ;
	BOOL X_E_CLOSED = m_UpperBoundClosed ;
	BOOL Y_S_CLOSED = a_SignedInteger.m_LowerBoundClosed ;
	BOOL Y_E_CLOSED = a_SignedInteger.m_UpperBoundClosed ;

	BOOL X_S_INFINITE = m_InfiniteLowerBound ;
	BOOL X_E_INFINITE = m_InfiniteUpperBound ;
	BOOL Y_S_INFINITE = a_SignedInteger.m_InfiniteLowerBound ;
	BOOL Y_E_INFINITE = a_SignedInteger.m_InfiniteUpperBound ;

	if ( CompareSignedIntegerLess ( X_S ,  X_S_INFINITE ? - 1 : 0 , Y_S , Y_S_INFINITE ? -1 : 0 ) ) // ( X_S < Y_S )
	{
		if ( CompareSignedIntegerLess ( Y_S ,  Y_S_INFINITE ? -1 : 0 , X_E , X_E_INFINITE ? 1 : 0 ) ) // ( Y_S < X_E )
		{
			if ( CompareSignedIntegerLess ( X_E ,  X_E_INFINITE ? 1 : 0 , Y_E , Y_E_INFINITE ? 1 : 0 ) ) // ( X_E < Y_E )
			{
//				Order ( X_S < Y_S < X_E < Y_E )
//				Range ( X_S , Y_E ) 

				a_Overlap = new WmiSignedIntegerRangeNode (

					m_PropertyName ,
					m_Index ,
					X_S_INFINITE ,
					Y_E_INFINITE ,
					X_S_CLOSED ,						// Relationship is as strong as ordering 
					Y_E_CLOSED ,						// Relationship is as strong as ordering 
					X_S ,
					Y_E ,
					NULL ,
					NULL
				) ;

				t_Status = ( a_Overlap ) ? ( WmiTriState :: State_True ) : ( WmiTriState :: State_Error ) ;
			}
			else if ( CompareSignedIntegerEqual ( X_E ,  X_E_INFINITE ? 1 : 0 , Y_E , Y_E_INFINITE ? 1 : 0 ) ) // ( X_E == Y_E )
			{
//				Order ( X_S < Y_S < X_E == Y_E )
//				Range ( X_S , X_E ) 

				a_Overlap = new WmiSignedIntegerRangeNode (

					m_PropertyName ,
					m_Index ,
					X_S_INFINITE ,
					X_E_INFINITE ,
					X_S_CLOSED  ,						// Relationship is as strong as ordering 
					X_E_CLOSED || Y_E_CLOSED ,			// Check for weak relationship ( < , > ) 
					X_S ,
					X_E ,
					NULL ,
					NULL
				) ;

				t_Status = ( a_Overlap ) ? ( WmiTriState :: State_True ) : ( WmiTriState :: State_Error ) ;
			}
			else if ( CompareSignedIntegerGreater ( X_E ,  X_E_INFINITE ? 1 : 0 , Y_E , Y_E_INFINITE ? 1 : 0 ) ) // ( X_E > Y_E ) 
			{
//				Order ( X_S < Y_S < Y_E < X_E )
//				Range ( X_S , X_E )

				a_Overlap = new WmiSignedIntegerRangeNode (

					m_PropertyName ,
					m_Index ,
					X_S_INFINITE ,
					X_E_INFINITE ,
					X_S_CLOSED ,						// Relationship is as strong as ordering 
					X_E_CLOSED ,						// Relationship is as strong as ordering 
					X_S ,
					X_E ,
					NULL ,
					NULL
				) ;

				t_Status = ( a_Overlap ) ? ( WmiTriState :: State_True ) : ( WmiTriState :: State_Error ) ;
			}
		}
		else if ( CompareSignedIntegerEqual ( Y_S ,  Y_S_INFINITE ? -1 : 0 , X_E , X_E_INFINITE ? 1 : 0 ) )  // ( Y_S == X_E ), Start of Y and End Of X overlap
		{
			if ( CompareSignedIntegerLess ( X_E ,  X_E_INFINITE ? 1 : 0 , Y_E , Y_E_INFINITE ? 1 : 0 ) ) // ( X_E < Y_E )
			{
// Order ( X_S < Y_S == X_E < Y_E )


				if ( X_E_CLOSED || Y_S_CLOSED )
				{
				    a_Overlap = new WmiSignedIntegerRangeNode (

					    m_PropertyName ,
					    m_Index ,
					    X_S_INFINITE,
					    Y_E_INFINITE  ,
					    X_S_CLOSED ,
					    Y_E_CLOSED ,
					    X_S ,
					    Y_E ,
					    NULL ,
					    NULL
				    ) ;

					t_Status = ( a_Overlap ) ? ( WmiTriState :: State_True ) : ( WmiTriState :: State_Error ) ;
                }
			}
			else if ( CompareSignedIntegerEqual ( X_E ,  X_E_INFINITE ? 1 : 0 , Y_E , Y_E_INFINITE ? 1 : 0 ) ) // ( X_E == Y_E )
			{
// Order ( X_S < Y_S == X_E == Y_E )

				if ( X_E_CLOSED || Y_S_CLOSED )
				{
				    a_Overlap = new WmiSignedIntegerRangeNode (

					    m_PropertyName ,
					    m_Index ,
					    X_S_INFINITE ,
					    Y_E_INFINITE,
					    X_S_CLOSED ,
					    X_E_CLOSED || Y_E_CLOSED || Y_S_CLOSED   ,
					    X_S ,
					    Y_E ,
					    NULL ,
					    NULL
				    ) ;

					t_Status = ( a_Overlap ) ? ( WmiTriState :: State_True ) : ( WmiTriState :: State_Error ) ;
                }
			}
			else if ( CompareSignedIntegerGreater ( X_E ,  X_E_INFINITE ? 1 : 0 , Y_E , Y_E_INFINITE ? 1 : 0 ) ) // ( X_E > Y_E )
			{
// Order ( X_S < Y_E < Y_S == X_E ) Can never happen
DebugBreak () ;
			}
		}
		else if ( CompareSignedIntegerGreater ( Y_S ,  Y_S_INFINITE ? -1 : 0 , X_E , X_E_INFINITE ? 1 : 0 ) ) // ( Y_S > X_E )
		{
//				Order ( X_S < Y_S , X_E < Y_S ) Non overlapping
			if ( X_E_CLOSED && Y_S_CLOSED )
			{
				if ( Y_S - X_E == 1 )
				{
				    a_Overlap = new WmiSignedIntegerRangeNode (

					    m_PropertyName ,
					    m_Index ,
					    X_S_INFINITE,
					    Y_E_INFINITE  ,
					    X_S_CLOSED ,
					    Y_E_CLOSED ,
					    X_S ,
					    Y_S ,
					    NULL ,
					    NULL
				    ) ;

					t_Status = ( a_Overlap ) ? ( WmiTriState :: State_True ) : ( WmiTriState :: State_Error ) ;
				}
			}
		}
	}
	else if ( CompareSignedIntegerEqual ( X_S ,  X_S_INFINITE ? -1 : 0 , Y_S , Y_S_INFINITE ? -1 : 0 ) ) // ( X_S == Y_S ) 
	{
		if ( CompareSignedIntegerLess ( Y_S ,  Y_S_INFINITE ? -1 : 0 , X_E , X_E_INFINITE ? 1 : 0 ) ) // ( Y_S < X_E )
		{
			if ( CompareSignedIntegerLess ( X_E ,  X_E_INFINITE ? 1 : 0 , Y_E , Y_E_INFINITE ? 1 : 0 ) ) // ( X_E < Y_E )
			{
//				Order ( X_S == Y_S < X_E < Y_E )
//				Range ( X_S , Y_E )

				a_Overlap = new WmiSignedIntegerRangeNode (

					m_PropertyName ,
					m_Index ,
					X_S_INFINITE ,
					Y_E_INFINITE ,
					X_S_CLOSED || Y_S_CLOSED ,		// Check for weak relationship ( < , > ) 
					Y_E_CLOSED ,					// Relationship is as strong as ordering 
					X_S ,
					Y_E ,
					NULL ,
					NULL
				) ;

				t_Status = ( a_Overlap ) ? ( WmiTriState :: State_True ) : ( WmiTriState :: State_Error ) ;
			}
			else if ( CompareSignedIntegerEqual ( X_E ,  X_E_INFINITE ? 1 : 0 , Y_E , Y_E_INFINITE ? 1 : 0 ) ) // ( X_E == Y_E )
			{
//				Order ( X_S == Y_S < X_E == Y_E )
//				Range ( X_S , Y_E )

				a_Overlap = new WmiSignedIntegerRangeNode (

					m_PropertyName ,
					m_Index ,
					X_S_INFINITE ,
					Y_E_INFINITE ,
					X_S_CLOSED || Y_S_CLOSED ,		// Check for weak relationship ( < , > ) 
					X_E_CLOSED || Y_E_CLOSED ,		// Check for weak relationship ( < , > ) 
					X_S ,
					Y_E ,
					NULL ,
					NULL
				) ;

				t_Status = ( a_Overlap ) ? ( WmiTriState :: State_True ) : ( WmiTriState :: State_Error ) ;
			}
			else if ( CompareSignedIntegerGreater ( X_E ,  X_E_INFINITE ? 1 : 0 , Y_E , Y_E_INFINITE ? 1 : 0 ) ) // ( X_E > Y_E )
			{
//				Order ( X_S == Y_S < Y_E < X_E )
//				Range ( X_S , X_E )

				a_Overlap = new WmiSignedIntegerRangeNode (

					m_PropertyName ,
					m_Index ,
					X_S_INFINITE ,
					X_E_INFINITE ,
					X_S_CLOSED || Y_S_CLOSED ,		// Check for weak relationship ( < , > ) 
					X_E_CLOSED ,					// Relationship is as strong as ordering 
					X_S ,
					X_E ,
					NULL ,
					NULL
				) ;

				t_Status = ( a_Overlap ) ? ( WmiTriState :: State_True ) : ( WmiTriState :: State_Error ) ;
			}
		}
		else if ( CompareSignedIntegerEqual ( Y_S ,  Y_S_INFINITE ? -1 : 0 , X_E , X_E_INFINITE ? 1 : 0 ) ) // ( Y_S == X_E ), Start of Y and End Of X overlap
		{
			if ( CompareSignedIntegerLess ( X_E ,  X_E_INFINITE ? 1 : 0 , Y_E , Y_E_INFINITE ? 1 : 0 ) ) // ( X_E < Y_E )
			{
//				Order ( X_S == Y_S == X_E < Y_E )

				a_Overlap = new WmiSignedIntegerRangeNode (

					m_PropertyName ,
					m_Index ,
					X_S_INFINITE ,
					Y_E_INFINITE ,
					X_S_CLOSED || Y_S_CLOSED || X_E_CLOSED ,
					Y_E_CLOSED ,
					Y_S ,
					Y_E ,
					NULL ,
					NULL
				) ;

				t_Status = ( a_Overlap ) ? ( WmiTriState :: State_True ) : ( WmiTriState :: State_Error ) ;
			}
			else if ( CompareSignedIntegerEqual ( X_E ,  X_E_INFINITE ? 1 : 0 , Y_E , Y_E_INFINITE ? 1 : 0 ) ) // ( X_E == Y_E )
			{
//				Order ( X_S == Y_S == X_E == Y_E )

				a_Overlap = new WmiSignedIntegerRangeNode (

					m_PropertyName ,
					m_Index ,
					X_S_INFINITE ,
					X_S_INFINITE  ,
					TRUE ,
					TRUE ,
					X_S ,
					X_S ,
					NULL ,
					NULL
				) ;

				t_Status = ( a_Overlap ) ? ( WmiTriState :: State_True ) : ( WmiTriState :: State_Error ) ;
			}
			else if ( CompareSignedIntegerGreater ( X_E ,  X_E_INFINITE ? 1 : 0 , Y_E , Y_E_INFINITE ? 1 : 0 ) ) // ( X_E > Y_E )
			{
// Can never happen
DebugBreak () ;
			}
		}
		else if ( CompareSignedIntegerGreater ( Y_S ,  Y_S_INFINITE ? -1 : 0 , X_E , X_E_INFINITE ? 1 : 0 ) )  // ( Y_S > X_E )
		{
// Can never happen
DebugBreak () ;
		}
	}
	else if ( CompareSignedIntegerGreater ( X_S ,  X_S_INFINITE ? -1 : 0 , Y_S , Y_S_INFINITE ? -1 : 0 ) ) // ( X_S > Y_S )
	{
		if ( CompareSignedIntegerLess ( X_S ,  X_S_INFINITE ? -1 : 0 , Y_E , Y_E_INFINITE ? 1 : 0 ) ) // ( X_S < Y_E )
		{
			if ( CompareSignedIntegerLess ( Y_E ,  Y_E_INFINITE ? 1 : 0 , X_E , X_E_INFINITE ? 1 : 0 ) ) // ( Y_E < X_E )
			{
//				Order ( Y_S < X_S < Y_E < X_E )
//				Range ( Y_S , X_E ) 

				a_Overlap = new WmiSignedIntegerRangeNode (

					m_PropertyName ,
					m_Index ,
					Y_S_INFINITE ,
					X_E_INFINITE ,
					Y_S_CLOSED ,						// Relationship is as strong as ordering 
					X_E_CLOSED ,						// Relationship is as strong as ordering 
					Y_S ,
					X_E ,
					NULL ,
					NULL
				) ;

				t_Status = ( a_Overlap ) ? ( WmiTriState :: State_True ) : ( WmiTriState :: State_Error ) ;
			}
			else if ( CompareSignedIntegerEqual ( Y_E ,  Y_E_INFINITE ? 1 : 0 , X_E , X_E_INFINITE ? 1 : 0 ) ) // ( Y_E == X_E )
			{
//				Order ( Y_S < X_S < Y_E == X_E )
//				Range ( Y_S , X_E ) 

				a_Overlap = new WmiSignedIntegerRangeNode (

					m_PropertyName ,
					m_Index ,
					Y_S_INFINITE ,
					Y_E_INFINITE ,
					Y_S_CLOSED ,						// Relationship is as strong as ordering 
					Y_E_CLOSED || X_E_CLOSED ,			// Check for weak relationship ( < , > ) 
					Y_S ,
					Y_E ,
					NULL ,
					NULL
				) ;

				t_Status = ( a_Overlap ) ? ( WmiTriState :: State_True ) : ( WmiTriState :: State_Error ) ;
			}
			else if ( CompareSignedIntegerGreater ( Y_E ,  Y_E_INFINITE ? 1 : 0 , X_E , X_E_INFINITE ? 1 : 0 ) ) // ( Y_E > X_E )
			{
//				Order ( Y_S < X_S < X_E < Y_E )
//				Range ( Y_S , Y_E ) 

				a_Overlap = new WmiSignedIntegerRangeNode (

					m_PropertyName ,
					m_Index ,
					Y_S_INFINITE ,
					Y_E_INFINITE ,
					Y_S_CLOSED ,						// Relationship is as strong as ordering 
					Y_E_CLOSED ,						// Relationship is as strong as ordering 
					Y_S ,
					Y_E ,
					NULL ,
					NULL
				) ;

				t_Status = ( a_Overlap ) ? ( WmiTriState :: State_True ) : ( WmiTriState :: State_Error ) ;
			}
		}
		else if ( CompareSignedIntegerEqual ( X_S ,  X_S_INFINITE ? -1 : 0 , Y_E , Y_E_INFINITE ? 1 : 0 ) ) // ( X_S == Y_E ), Start of X and End Of Y overlap
		{
			if ( CompareSignedIntegerLess ( Y_E ,  Y_E_INFINITE ? 1 : 0 , X_E , X_E_INFINITE ? 1 : 0 ) ) // ( Y_E < X_E )
			{
   				if ( X_S_CLOSED || Y_E_CLOSED )
				{
				    a_Overlap = new WmiSignedIntegerRangeNode (

					    m_PropertyName ,
					    m_Index ,
					    Y_S_INFINITE  ,
					    X_E_INFINITE,
					    Y_S_CLOSED ,
					    X_E_CLOSED ,
					    Y_S ,
					    X_E ,
					    NULL ,
					    NULL
				    ) ;

					t_Status = ( a_Overlap ) ? ( WmiTriState :: State_True ) : ( WmiTriState :: State_Error ) ;
				}
			}
			else if ( CompareSignedIntegerEqual ( Y_E ,  Y_E_INFINITE ? 1 : 0 , X_E , X_E_INFINITE ? 1 : 0 ) ) // ( Y_E == X_E )
			{
//				Order ( Y_S < X_S == Y_E == X_E )

				a_Overlap = new WmiSignedIntegerRangeNode (

					m_PropertyName ,
					m_Index ,
					Y_S_INFINITE ,
					X_E_INFINITE  ,
					Y_S_CLOSED ,
					TRUE ,
					Y_S ,
					X_E ,
					NULL ,
					NULL
				) ;

				t_Status = ( a_Overlap ) ? ( WmiTriState :: State_True ) : ( WmiTriState :: State_Error ) ;
			}
			else if ( CompareSignedIntegerGreater ( Y_E ,  Y_E_INFINITE ? 1 : 0 , X_E , X_E_INFINITE ? 1 : 0 ) ) // ( Y_E > X_E )
			{
//				Order ( Y_S < X_S == X_E < Y_E )

				a_Overlap = new WmiSignedIntegerRangeNode (

					m_PropertyName ,
					m_Index ,
					Y_S_INFINITE ,
					Y_E_INFINITE ,
					Y_S_CLOSED ,
					Y_E_CLOSED ,
					Y_S ,
					Y_E ,
					NULL ,
					NULL
				) ;

				t_Status = ( a_Overlap ) ? ( WmiTriState :: State_True ) : ( WmiTriState :: State_Error ) ;
			}
		}
		else if ( CompareSignedIntegerGreater ( X_S ,  X_S_INFINITE ? -1 : 0 , Y_E , Y_E_INFINITE ? 1 : 0 ) ) // ( X_S > Y_E )
		{
//				Order ( Y_S < Y_E < X_S ) Non Overlapping

			if ( Y_E_CLOSED && X_S_CLOSED )
			{
				if ( X_S - Y_E == - 1 )
				{
				    a_Overlap = new WmiSignedIntegerRangeNode (

					    m_PropertyName ,
					    m_Index ,
					    Y_S_INFINITE,
					    X_E_INFINITE  ,
					    Y_S_CLOSED ,
					    X_E_CLOSED ,
					    Y_S ,
					    X_S ,
					    NULL ,
					    NULL
				    ) ;

					t_Status = ( a_Overlap ) ? ( WmiTriState :: State_True ) : ( WmiTriState :: State_Error ) ;
				}
			}
		}
	}

	return t_Status ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

WmiTriState WmiUnsignedIntegerRangeNode :: GetOverlappingRange ( 

	WmiUnsignedIntegerRangeNode &a_UnsignedInteger ,
	WmiUnsignedIntegerRangeNode *&a_Overlap
)
{
	WmiTriState t_Status = WmiTriState :: State_False ;

// A weak ( open ) relationship is ( < , > ) 
// A strong ( closed ) relationship is ( == , <= , >= )

	a_Overlap = NULL ;

	ULONG X_S = m_LowerBound ;
	ULONG X_E = m_UpperBound ;
	ULONG Y_S = a_UnsignedInteger.m_LowerBound ;
	ULONG Y_E = a_UnsignedInteger.m_UpperBound ;

	BOOL X_S_CLOSED = m_LowerBoundClosed ;
	BOOL X_E_CLOSED = m_UpperBoundClosed ;
	BOOL Y_S_CLOSED = a_UnsignedInteger.m_LowerBoundClosed ;
	BOOL Y_E_CLOSED = a_UnsignedInteger.m_UpperBoundClosed ;

	BOOL X_S_INFINITE = m_InfiniteLowerBound ;
	BOOL X_E_INFINITE = m_InfiniteUpperBound ;
	BOOL Y_S_INFINITE = a_UnsignedInteger.m_InfiniteLowerBound ;
	BOOL Y_E_INFINITE = a_UnsignedInteger.m_InfiniteUpperBound ;

	if ( CompareUnsignedIntegerLess ( X_S ,  X_S_INFINITE ? - 1 : 0 , Y_S , Y_S_INFINITE ? -1 : 0 ) ) // ( X_S < Y_S )
	{
		if ( CompareUnsignedIntegerLess ( Y_S ,  Y_S_INFINITE ? -1 : 0 , X_E , X_E_INFINITE ? 1 : 0 ) ) // ( Y_S < X_E )
		{
			if ( CompareUnsignedIntegerLess ( X_E ,  X_E_INFINITE ? 1 : 0 , Y_E , Y_E_INFINITE ? 1 : 0 ) ) // ( X_E < Y_E )
			{
//				Order ( X_S < Y_S < X_E < Y_E )
//				Range ( X_S , Y_E ) 

				a_Overlap = new WmiUnsignedIntegerRangeNode (

					m_PropertyName ,
					m_Index ,
					X_S_INFINITE ,
					Y_E_INFINITE ,
					X_S_CLOSED ,						// Relationship is as strong as ordering 
					Y_E_CLOSED ,						// Relationship is as strong as ordering 
					X_S ,
					Y_E ,
					NULL ,
					NULL
				) ;

				t_Status = ( a_Overlap ) ? ( WmiTriState :: State_True ) : ( WmiTriState :: State_Error ) ;
			}
			else if ( CompareUnsignedIntegerEqual ( X_E ,  X_E_INFINITE ? 1 : 0 , Y_E , Y_E_INFINITE ? 1 : 0 ) ) // ( X_E == Y_E )
			{
//				Order ( X_S < Y_S < X_E == Y_E )
//				Range ( X_S , X_E ) 

				a_Overlap = new WmiUnsignedIntegerRangeNode (

					m_PropertyName ,
					m_Index ,
					X_S_INFINITE ,
					X_E_INFINITE ,
					X_S_CLOSED  ,						// Relationship is as strong as ordering 
					X_E_CLOSED || Y_E_CLOSED ,			// Check for weak relationship ( < , > ) 
					X_S ,
					X_E ,
					NULL ,
					NULL
				) ;

				t_Status = ( a_Overlap ) ? ( WmiTriState :: State_True ) : ( WmiTriState :: State_Error ) ;
			}
			else if ( CompareUnsignedIntegerGreater ( X_E ,  X_E_INFINITE ? 1 : 0 , Y_E , Y_E_INFINITE ? 1 : 0 ) ) // ( X_E > Y_E ) 
			{
//				Order ( X_S < Y_S < Y_E < X_E )
//				Range ( X_S , X_E )

				a_Overlap = new WmiUnsignedIntegerRangeNode (

					m_PropertyName ,
					m_Index ,
					X_S_INFINITE ,
					X_E_INFINITE ,
					X_S_CLOSED ,						// Relationship is as strong as ordering 
					X_E_CLOSED ,						// Relationship is as strong as ordering 
					X_S ,
					X_E ,
					NULL ,
					NULL
				) ;

				t_Status = ( a_Overlap ) ? ( WmiTriState :: State_True ) : ( WmiTriState :: State_Error ) ;
			}
		}
		else if ( CompareUnsignedIntegerEqual ( Y_S ,  Y_S_INFINITE ? -1 : 0 , X_E , X_E_INFINITE ? 1 : 0 ) )  // ( Y_S == X_E ), Start of Y and End Of X overlap
		{
			if ( CompareUnsignedIntegerLess ( X_E ,  X_E_INFINITE ? 1 : 0 , Y_E , Y_E_INFINITE ? 1 : 0 ) ) // ( X_E < Y_E )
			{
// Order ( X_S < Y_S == X_E < Y_E )

   				if ( X_E_CLOSED || Y_S_CLOSED )
				{
				    a_Overlap = new WmiUnsignedIntegerRangeNode (

					    m_PropertyName ,
					    m_Index ,
					    X_S_INFINITE,
					    Y_E_INFINITE  ,
					    X_S_CLOSED ,
					    Y_E_CLOSED ,
					    X_S ,
					    Y_E ,
					    NULL ,
					    NULL
				    ) ;

					t_Status = ( a_Overlap ) ? ( WmiTriState :: State_True ) : ( WmiTriState :: State_Error ) ;
                }
			}
			else if ( CompareUnsignedIntegerEqual ( X_E ,  X_E_INFINITE ? 1 : 0 , Y_E , Y_E_INFINITE ? 1 : 0 ) ) // ( X_E == Y_E )
			{
// Order ( X_S < Y_S == X_E == Y_E )

				if ( X_E_CLOSED || Y_S_CLOSED )
				{
				    a_Overlap = new WmiUnsignedIntegerRangeNode (

					    m_PropertyName ,
					    m_Index ,
					    X_S_INFINITE ,
					    Y_E_INFINITE,
					    X_S_CLOSED ,
					    X_E_CLOSED || Y_E_CLOSED || Y_S_CLOSED   ,
					    X_S ,
					    Y_E ,
					    NULL ,
					    NULL
				    ) ;

					t_Status = ( a_Overlap ) ? ( WmiTriState :: State_True ) : ( WmiTriState :: State_Error ) ;
                }
			}
			else if ( CompareUnsignedIntegerGreater ( X_E ,  X_E_INFINITE ? 1 : 0 , Y_E , Y_E_INFINITE ? 1 : 0 ) ) // ( X_E > Y_E )
			{
// Order ( X_S < Y_E < Y_S == X_E ) Can never happen
DebugBreak () ;
			}
		}
		else if ( CompareUnsignedIntegerGreater ( Y_S ,  Y_S_INFINITE ? -1 : 0 , X_E , X_E_INFINITE ? 1 : 0 ) ) // ( Y_S > X_E )
		{
//				Order ( X_S < Y_S , X_E < Y_S ) Non overlapping
			if ( X_E_CLOSED && Y_S_CLOSED )
			{
				if ( Y_S - X_E == 1 )
				{
				    a_Overlap = new WmiUnsignedIntegerRangeNode (

					    m_PropertyName ,
					    m_Index ,
					    X_S_INFINITE,
					    Y_E_INFINITE  ,
					    X_S_CLOSED ,
					    Y_E_CLOSED ,
					    X_S ,
					    Y_S ,
					    NULL ,
					    NULL
				    ) ;

					t_Status = ( a_Overlap ) ? ( WmiTriState :: State_True ) : ( WmiTriState :: State_Error ) ;
				}
			}
		}
	}
	else if ( CompareUnsignedIntegerEqual ( X_S ,  X_S_INFINITE ? -1 : 0 , Y_S , Y_S_INFINITE ? -1 : 0 ) ) // ( X_S == Y_S ) 
	{
		if ( CompareUnsignedIntegerLess ( Y_S ,  Y_S_INFINITE ? -1 : 0 , X_E , X_E_INFINITE ? 1 : 0 ) ) // ( Y_S < X_E )
		{
			if ( CompareUnsignedIntegerLess ( X_E ,  X_E_INFINITE ? 1 : 0 , Y_E , Y_E_INFINITE ? 1 : 0 ) ) // ( X_E < Y_E )
			{
//				Order ( X_S == Y_S < X_E < Y_E )
//				Range ( X_S , Y_E )

				a_Overlap = new WmiUnsignedIntegerRangeNode (

					m_PropertyName ,
					m_Index ,
					X_S_INFINITE ,
					Y_E_INFINITE ,
					X_S_CLOSED || Y_S_CLOSED ,		// Check for weak relationship ( < , > ) 
					Y_E_CLOSED ,					// Relationship is as strong as ordering 
					X_S ,
					Y_E ,
					NULL ,
					NULL
				) ;

				t_Status = ( a_Overlap ) ? ( WmiTriState :: State_True ) : ( WmiTriState :: State_Error ) ;
			}
			else if ( CompareUnsignedIntegerEqual ( X_E ,  X_E_INFINITE ? 1 : 0 , Y_E , Y_E_INFINITE ? 1 : 0 ) ) // ( X_E == Y_E )
			{
//				Order ( X_S == Y_S < X_E == Y_E )
//				Range ( X_S , Y_E )

				a_Overlap = new WmiUnsignedIntegerRangeNode (

					m_PropertyName ,
					m_Index ,
					X_S_INFINITE ,
					Y_E_INFINITE ,
					X_S_CLOSED || Y_S_CLOSED ,		// Check for weak relationship ( < , > ) 
					X_E_CLOSED || Y_E_CLOSED ,		// Check for weak relationship ( < , > ) 
					X_S ,
					Y_E ,
					NULL ,
					NULL
				) ;

				t_Status = ( a_Overlap ) ? ( WmiTriState :: State_True ) : ( WmiTriState :: State_Error ) ;
			}
			else if ( CompareUnsignedIntegerGreater ( X_E ,  X_E_INFINITE ? 1 : 0 , Y_E , Y_E_INFINITE ? 1 : 0 ) ) // ( X_E > Y_E )
			{
//				Order ( X_S == Y_S < Y_E < X_E )
//				Range ( X_S , X_E )

				a_Overlap = new WmiUnsignedIntegerRangeNode (

					m_PropertyName ,
					m_Index ,
					X_S_INFINITE ,
					X_E_INFINITE ,
					X_S_CLOSED || Y_S_CLOSED ,		// Check for weak relationship ( < , > ) 
					X_E_CLOSED ,					// Relationship is as strong as ordering 
					X_S ,
					X_E ,
					NULL ,
					NULL
				) ;

				t_Status = ( a_Overlap ) ? ( WmiTriState :: State_True ) : ( WmiTriState :: State_Error ) ;
			}
		}
		else if ( CompareUnsignedIntegerEqual ( Y_S ,  Y_S_INFINITE ? -1 : 0 , X_E , X_E_INFINITE ? 1 : 0 ) ) // ( Y_S == X_E ), Start of Y and End Of X overlap
		{
			if ( CompareUnsignedIntegerLess ( X_E ,  X_E_INFINITE ? 1 : 0 , Y_E , Y_E_INFINITE ? 1 : 0 ) ) // ( X_E < Y_E )
			{
//				Order ( X_S == Y_S == X_E < Y_E )

				a_Overlap = new WmiUnsignedIntegerRangeNode (

					m_PropertyName ,
					m_Index ,
					X_S_INFINITE ,
					Y_E_INFINITE ,
					X_S_CLOSED || Y_S_CLOSED || X_E_CLOSED ,
					Y_E_CLOSED ,
					Y_S ,
					Y_E ,
					NULL ,
					NULL
				) ;

				t_Status = ( a_Overlap ) ? ( WmiTriState :: State_True ) : ( WmiTriState :: State_Error ) ;
			}
			else if ( CompareUnsignedIntegerEqual ( X_E ,  X_E_INFINITE ? 1 : 0 , Y_E , Y_E_INFINITE ? 1 : 0 ) ) // ( X_E == Y_E )
			{
//				Order ( X_S == Y_S == X_E == Y_E )

				a_Overlap = new WmiUnsignedIntegerRangeNode (

					m_PropertyName ,
					m_Index ,
					X_S_INFINITE ,
					X_S_INFINITE  ,
					TRUE ,
					TRUE ,
					X_S ,
					X_S ,
					NULL ,
					NULL
				) ;

				t_Status = ( a_Overlap ) ? ( WmiTriState :: State_True ) : ( WmiTriState :: State_Error ) ;
			}
			else if ( CompareUnsignedIntegerGreater ( X_E ,  X_E_INFINITE ? 1 : 0 , Y_E , Y_E_INFINITE ? 1 : 0 ) ) // ( X_E > Y_E )
			{
// Can never happen
DebugBreak () ;
			}
		}
		else if ( CompareUnsignedIntegerGreater ( Y_S ,  Y_S_INFINITE ? -1 : 0 , X_E , X_E_INFINITE ? 1 : 0 ) )  // ( Y_S > X_E )
		{
// Can never happen
DebugBreak () ;
		}
	}
	else if ( CompareUnsignedIntegerGreater ( X_S ,  X_S_INFINITE ? -1 : 0 , Y_S , Y_S_INFINITE ? -1 : 0 ) ) // ( X_S > Y_S )
	{
		if ( CompareUnsignedIntegerLess ( X_S ,  X_S_INFINITE ? -1 : 0 , Y_E , Y_E_INFINITE ? 1 : 0 ) ) // ( X_S < Y_E )
		{
			if ( CompareUnsignedIntegerLess ( Y_E ,  Y_E_INFINITE ? 1 : 0 , X_E , X_E_INFINITE ? 1 : 0 ) ) // ( Y_E < X_E )
			{
//				Order ( Y_S < X_S < Y_E < X_E )
//				Range ( Y_S , X_E ) 

				a_Overlap = new WmiUnsignedIntegerRangeNode (

					m_PropertyName ,
					m_Index ,
					Y_S_INFINITE ,
					X_E_INFINITE ,
					Y_S_CLOSED ,						// Relationship is as strong as ordering 
					X_E_CLOSED ,						// Relationship is as strong as ordering 
					Y_S ,
					X_E ,
					NULL ,
					NULL
				) ;

				t_Status = ( a_Overlap ) ? ( WmiTriState :: State_True ) : ( WmiTriState :: State_Error ) ;
			}
			else if ( CompareUnsignedIntegerEqual ( Y_E ,  Y_E_INFINITE ? 1 : 0 , X_E , X_E_INFINITE ? 1 : 0 ) ) // ( Y_E == X_E )
			{
//				Order ( Y_S < X_S < Y_E == X_E )
//				Range ( Y_S , X_E ) 

				a_Overlap = new WmiUnsignedIntegerRangeNode (

					m_PropertyName ,
					m_Index ,
					Y_S_INFINITE ,
					Y_E_INFINITE ,
					Y_S_CLOSED ,						// Relationship is as strong as ordering 
					Y_E_CLOSED || X_E_CLOSED ,			// Check for weak relationship ( < , > ) 
					Y_S ,
					Y_E ,
					NULL ,
					NULL
				) ;

				t_Status = ( a_Overlap ) ? ( WmiTriState :: State_True ) : ( WmiTriState :: State_Error ) ;
			}
			else if ( CompareUnsignedIntegerGreater ( Y_E ,  Y_E_INFINITE ? 1 : 0 , X_E , X_E_INFINITE ? 1 : 0 ) ) // ( Y_E > X_E )
			{
//				Order ( Y_S < X_S < X_E < Y_E )
//				Range ( Y_S , Y_E ) 

				a_Overlap = new WmiUnsignedIntegerRangeNode (

					m_PropertyName ,
					m_Index ,
					Y_S_INFINITE ,
					Y_E_INFINITE ,
					Y_S_CLOSED ,						// Relationship is as strong as ordering 
					Y_E_CLOSED ,						// Relationship is as strong as ordering 
					Y_S ,
					Y_E ,
					NULL ,
					NULL
				) ;

				t_Status = ( a_Overlap ) ? ( WmiTriState :: State_True ) : ( WmiTriState :: State_Error ) ;
			}
		}
		else if ( CompareUnsignedIntegerEqual ( X_S ,  X_S_INFINITE ? -1 : 0 , Y_E , Y_E_INFINITE ? 1 : 0 ) ) // ( X_S == Y_E ), Start of X and End Of Y overlap
		{
			if ( CompareUnsignedIntegerLess ( Y_E ,  Y_E_INFINITE ? 1 : 0 , X_E , X_E_INFINITE ? 1 : 0 ) ) // ( Y_E < X_E )
			{
   				if ( X_S_CLOSED || Y_E_CLOSED )
				{
				    a_Overlap = new WmiUnsignedIntegerRangeNode (

					    m_PropertyName ,
					    m_Index ,
					    Y_S_INFINITE  ,
					    X_E_INFINITE,
					    Y_S_CLOSED ,
					    X_E_CLOSED ,
					    Y_S ,
					    X_E ,
					    NULL ,
					    NULL
				    ) ;

					t_Status = ( a_Overlap ) ? ( WmiTriState :: State_True ) : ( WmiTriState :: State_Error ) ;
				}
			}
			else if ( CompareUnsignedIntegerEqual ( Y_E ,  Y_E_INFINITE ? 1 : 0 , X_E , X_E_INFINITE ? 1 : 0 ) ) // ( Y_E == X_E )
			{
//				Order ( Y_S < X_S == Y_E == X_E )

				a_Overlap = new WmiUnsignedIntegerRangeNode (

					m_PropertyName ,
					m_Index ,
					Y_S_INFINITE ,
					X_E_INFINITE  ,
					Y_S_CLOSED ,
					TRUE ,
					Y_S ,
					X_E ,
					NULL ,
					NULL
				) ;

				t_Status = ( a_Overlap ) ? ( WmiTriState :: State_True ) : ( WmiTriState :: State_Error ) ;
			}
			else if ( CompareUnsignedIntegerGreater ( Y_E ,  Y_E_INFINITE ? 1 : 0 , X_E , X_E_INFINITE ? 1 : 0 ) ) // ( Y_E > X_E )
			{
//				Order ( Y_S < X_S == X_E < Y_E )

				a_Overlap = new WmiUnsignedIntegerRangeNode (

					m_PropertyName ,
					m_Index ,
					Y_S_INFINITE ,
					Y_E_INFINITE ,
					Y_S_CLOSED ,
					Y_E_CLOSED ,
					Y_S ,
					Y_E ,
					NULL ,
					NULL
				) ;

				t_Status = ( a_Overlap ) ? ( WmiTriState :: State_True ) : ( WmiTriState :: State_Error ) ;
			}
		}
		else if ( CompareUnsignedIntegerGreater ( X_S ,  X_S_INFINITE ? -1 : 0 , Y_E , Y_E_INFINITE ? 1 : 0 ) ) // ( X_S > Y_E )
		{
//				Order ( Y_S < Y_E < X_S ) Non Overlapping

			if ( Y_E_CLOSED && X_S_CLOSED )
			{
				if ( X_S - Y_E == -1 )
				{
				    a_Overlap = new WmiUnsignedIntegerRangeNode (

					    m_PropertyName ,
					    m_Index ,
					    Y_S_INFINITE,
					    X_E_INFINITE  ,
					    Y_S_CLOSED ,
					    X_E_CLOSED ,
					    Y_S ,
					    X_S ,
					    NULL ,
					    NULL
				    ) ;

					t_Status = ( a_Overlap ) ? ( WmiTriState :: State_True ) : ( WmiTriState :: State_Error ) ;
				}
			}
		}
	}

	return t_Status ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

WmiTriState WmiStringRangeNode :: GetOverlappingRange ( 

	WmiStringRangeNode &a_String ,
	WmiStringRangeNode *&a_Overlap
)
{
	WmiTriState t_Status = WmiTriState :: State_False ;

// A weak ( open ) relationship is ( < , > ) 
// A strong ( closed ) relationship is ( == , <= , >= )

	a_Overlap = NULL ;

	BSTR X_S = m_LowerBound ;
	BSTR X_E = m_UpperBound ;
	BSTR Y_S = a_String.m_LowerBound ;
	BSTR Y_E = a_String.m_UpperBound ;

	BOOL X_S_CLOSED = m_LowerBoundClosed ;
	BOOL X_E_CLOSED = m_UpperBoundClosed ;
	BOOL Y_S_CLOSED = a_String.m_LowerBoundClosed ;
	BOOL Y_E_CLOSED = a_String.m_UpperBoundClosed ;

	BOOL X_S_INFINITE = m_InfiniteLowerBound ;
	BOOL X_E_INFINITE = m_InfiniteUpperBound ;
	BOOL Y_S_INFINITE = a_String.m_InfiniteLowerBound ;
	BOOL Y_E_INFINITE = a_String.m_InfiniteUpperBound ;

	if ( CompareStringLess ( X_S ,  X_S_INFINITE ? - 1 : 0 , Y_S , Y_S_INFINITE ? -1 : 0 ) ) // ( X_S < Y_S )
	{
		if ( CompareStringLess ( Y_S ,  Y_S_INFINITE ? -1 : 0 , X_E , X_E_INFINITE ? 1 : 0 ) ) // ( Y_S < X_E )
		{
			if ( CompareStringLess ( X_E ,  X_E_INFINITE ? 1 : 0 , Y_E , Y_E_INFINITE ? 1 : 0 ) ) // ( X_E < Y_E )
			{
//				Order ( X_S < Y_S < X_E < Y_E )
//				Range ( X_S , Y_E ) 

				a_Overlap = new WmiStringRangeNode (

					m_PropertyName ,
					m_Index ,
					X_S_INFINITE ,
					Y_E_INFINITE ,
					X_S_CLOSED ,						// Relationship is as strong as ordering 
					Y_E_CLOSED ,						// Relationship is as strong as ordering 
					X_S ,
					Y_E ,
					NULL ,
					NULL
				) ;

				t_Status = ( a_Overlap ) ? ( WmiTriState :: State_True ) : ( WmiTriState :: State_Error ) ;
			}
			else if ( CompareStringEqual ( X_E ,  X_E_INFINITE ? 1 : 0 , Y_E , Y_E_INFINITE ? 1 : 0 ) ) // ( X_E == Y_E )
			{
//				Order ( X_S < Y_S < X_E == Y_E )
//				Range ( X_S , X_E ) 

				a_Overlap = new WmiStringRangeNode (

					m_PropertyName ,
					m_Index ,
					X_S_INFINITE ,
					X_E_INFINITE ,
					X_S_CLOSED  ,						// Relationship is as strong as ordering 
					X_E_CLOSED || Y_E_CLOSED ,			// Check for weak relationship ( < , > ) 
					X_S ,
					X_E ,
					NULL ,
					NULL
				) ;

				t_Status = ( a_Overlap ) ? ( WmiTriState :: State_True ) : ( WmiTriState :: State_Error ) ;
			}
			else if ( CompareStringGreater ( X_E ,  X_E_INFINITE ? 1 : 0 , Y_E , Y_E_INFINITE ? 1 : 0 ) ) // ( X_E > Y_E ) 
			{
//				Order ( X_S < Y_S < Y_E < X_E )
//				Range ( X_S , X_E )

				a_Overlap = new WmiStringRangeNode (

					m_PropertyName ,
					m_Index ,
					X_S_INFINITE ,
					X_E_INFINITE ,
					X_S_CLOSED ,						// Relationship is as strong as ordering 
					X_E_CLOSED ,						// Relationship is as strong as ordering 
					X_S ,
					X_E ,
					NULL ,
					NULL
				) ;

				t_Status = ( a_Overlap ) ? ( WmiTriState :: State_True ) : ( WmiTriState :: State_Error ) ;
			}
		}
		else if ( CompareStringEqual ( Y_S ,  Y_S_INFINITE ? -1 : 0 , X_E , X_E_INFINITE ? 1 : 0 ) )  // ( Y_S == X_E ), Start of Y and End Of X overlap
		{
			if ( CompareStringLess ( X_E ,  X_E_INFINITE ? 1 : 0 , Y_E , Y_E_INFINITE ? 1 : 0 ) ) // ( X_E < Y_E )
			{
// Order ( X_S < Y_S == X_E < Y_E )

				if ( X_E_CLOSED || Y_S_CLOSED )
				{
				    a_Overlap = new WmiStringRangeNode (

					    m_PropertyName ,
					    m_Index ,
					    X_S_INFINITE,
					    Y_E_INFINITE  ,
					    X_S_CLOSED ,
					    Y_E_CLOSED ,
					    X_S ,
					    Y_E ,
					    NULL ,
					    NULL
				    ) ;

					t_Status = ( a_Overlap ) ? ( WmiTriState :: State_True ) : ( WmiTriState :: State_Error ) ;
                }
			}
			else if ( CompareStringEqual ( X_E ,  X_E_INFINITE ? 1 : 0 , Y_E , Y_E_INFINITE ? 1 : 0 ) ) // ( X_E == Y_E )
			{
// Order ( X_S < Y_S == X_E == Y_E )

				if ( X_E_CLOSED || Y_S_CLOSED )
				{
				    a_Overlap = new WmiStringRangeNode (

					    m_PropertyName ,
					    m_Index ,
					    X_S_INFINITE ,
					    Y_E_INFINITE,
					    X_S_CLOSED ,
					    X_E_CLOSED || Y_E_CLOSED || Y_S_CLOSED   ,
					    X_S ,
					    Y_E ,
					    NULL ,
					    NULL
				    ) ;

					t_Status = ( a_Overlap ) ? ( WmiTriState :: State_True ) : ( WmiTriState :: State_Error ) ;
                }
			}
			else if ( CompareStringGreater ( X_E ,  X_E_INFINITE ? 1 : 0 , Y_E , Y_E_INFINITE ? 1 : 0 ) ) // ( X_E > Y_E )
			{
// Order ( X_S < Y_E < Y_S == X_E ) Can never happen
DebugBreak () ;
			}
		}
		else if ( CompareStringGreater ( Y_S ,  Y_S_INFINITE ? -1 : 0 , X_E , X_E_INFINITE ? 1 : 0 ) ) // ( Y_S > X_E )
		{
//				Order ( X_S < Y_S , X_E < Y_S ) Non overlapping
		}
	}
	else if ( CompareStringEqual ( X_S ,  X_S_INFINITE ? -1 : 0 , Y_S , Y_S_INFINITE ? -1 : 0 ) ) // ( X_S == Y_S ) 
	{
		if ( CompareStringLess ( Y_S ,  Y_S_INFINITE ? -1 : 0 , X_E , X_E_INFINITE ? 1 : 0 ) ) // ( Y_S < X_E )
		{
			if ( CompareStringLess ( X_E ,  X_E_INFINITE ? 1 : 0 , Y_E , Y_E_INFINITE ? 1 : 0 ) ) // ( X_E < Y_E )
			{
//				Order ( X_S == Y_S < X_E < Y_E )
//				Range ( X_S , Y_E )

				a_Overlap = new WmiStringRangeNode (

					m_PropertyName ,
					m_Index ,
					X_S_INFINITE ,
					Y_E_INFINITE ,
					X_S_CLOSED || Y_S_CLOSED ,		// Check for weak relationship ( < , > ) 
					Y_E_CLOSED ,					// Relationship is as strong as ordering 
					X_S ,
					Y_E ,
					NULL ,
					NULL
				) ;

				t_Status = ( a_Overlap ) ? ( WmiTriState :: State_True ) : ( WmiTriState :: State_Error ) ;
			}
			else if ( CompareStringEqual ( X_E ,  X_E_INFINITE ? 1 : 0 , Y_E , Y_E_INFINITE ? 1 : 0 ) ) // ( X_E == Y_E )
			{
//				Order ( X_S == Y_S < X_E == Y_E )
//				Range ( X_S , Y_E )

				a_Overlap = new WmiStringRangeNode (

					m_PropertyName ,
					m_Index ,
					X_S_INFINITE ,
					Y_E_INFINITE ,
					X_S_CLOSED || Y_S_CLOSED ,		// Check for weak relationship ( < , > ) 
					X_E_CLOSED || Y_E_CLOSED ,		// Check for weak relationship ( < , > ) 
					X_S ,
					Y_E ,
					NULL ,
					NULL
				) ;

				t_Status = ( a_Overlap ) ? ( WmiTriState :: State_True ) : ( WmiTriState :: State_Error ) ;
			}
			else if ( CompareStringGreater ( X_E ,  X_E_INFINITE ? 1 : 0 , Y_E , Y_E_INFINITE ? 1 : 0 ) ) // ( X_E > Y_E )
			{
//				Order ( X_S == Y_S < Y_E < X_E )
//				Range ( X_S , X_E )

				a_Overlap = new WmiStringRangeNode (

					m_PropertyName ,
					m_Index ,
					X_S_INFINITE ,
					X_E_INFINITE ,
					X_S_CLOSED || Y_S_CLOSED ,		// Check for weak relationship ( < , > ) 
					X_E_CLOSED ,					// Relationship is as strong as ordering 
					X_S ,
					X_E ,
					NULL ,
					NULL
				) ;

				t_Status = ( a_Overlap ) ? ( WmiTriState :: State_True ) : ( WmiTriState :: State_Error ) ;
			}
		}
		else if ( CompareStringEqual ( Y_S ,  Y_S_INFINITE ? -1 : 0 , X_E , X_E_INFINITE ? 1 : 0 ) ) // ( Y_S == X_E ), Start of Y and End Of X overlap
		{
			if ( CompareStringLess ( X_E ,  X_E_INFINITE ? 1 : 0 , Y_E , Y_E_INFINITE ? 1 : 0 ) ) // ( X_E < Y_E )
			{
//				Order ( X_S == Y_S == X_E < Y_E )

				if ( X_E_CLOSED || Y_S_CLOSED )
				{
				    a_Overlap = new WmiStringRangeNode (

					    m_PropertyName ,
					    m_Index ,
					    X_S_INFINITE ,
					    Y_E_INFINITE ,
					    X_S_CLOSED || Y_S_CLOSED || X_E_CLOSED ,
					    Y_E_CLOSED ,
					    Y_S ,
					    Y_E ,
					    NULL ,
					    NULL
				    ) ;

					t_Status = ( a_Overlap ) ? ( WmiTriState :: State_True ) : ( WmiTriState :: State_Error ) ;
                }
			}
			else if ( CompareStringEqual ( X_E ,  X_E_INFINITE ? 1 : 0 , Y_E , Y_E_INFINITE ? 1 : 0 ) ) // ( X_E == Y_E )
			{
//				Order ( X_S == Y_S == X_E == Y_E )

				a_Overlap = new WmiStringRangeNode (

					m_PropertyName ,
					m_Index ,
					X_S_INFINITE ,
					X_S_INFINITE  ,
					TRUE ,
					TRUE ,
					X_S ,
					X_S ,
					NULL ,
					NULL
				) ;

				t_Status = ( a_Overlap ) ? ( WmiTriState :: State_True ) : ( WmiTriState :: State_Error ) ;
			}
			else if ( CompareStringGreater ( X_E ,  X_E_INFINITE ? 1 : 0 , Y_E , Y_E_INFINITE ? 1 : 0 ) ) // ( X_E > Y_E )
			{
// Can never happen
DebugBreak () ;
			}
		}
		else if ( CompareStringGreater ( Y_S ,  Y_S_INFINITE ? -1 : 0 , X_E , X_E_INFINITE ? 1 : 0 ) )  // ( Y_S > X_E )
		{
// Can never happen
DebugBreak () ;
		}
	}
	else if ( CompareStringGreater ( X_S ,  X_S_INFINITE ? -1 : 0 , Y_S , Y_S_INFINITE ? -1 : 0 ) ) // ( X_S > Y_S )
	{
		if ( CompareStringLess ( X_S ,  X_S_INFINITE ? -1 : 0 , Y_E , Y_E_INFINITE ? 1 : 0 ) ) // ( X_S < Y_E )
		{
			if ( CompareStringLess ( Y_E ,  Y_E_INFINITE ? 1 : 0 , X_E , X_E_INFINITE ? 1 : 0 ) ) // ( Y_E < X_E )
			{
//				Order ( Y_S < X_S < Y_E < X_E )
//				Range ( Y_S , X_E ) 

				a_Overlap = new WmiStringRangeNode (

					m_PropertyName ,
					m_Index ,
					Y_S_INFINITE ,
					X_E_INFINITE ,
					Y_S_CLOSED ,						// Relationship is as strong as ordering 
					X_E_CLOSED ,						// Relationship is as strong as ordering 
					Y_S ,
					X_E ,
					NULL ,
					NULL
				) ;

				t_Status = ( a_Overlap ) ? ( WmiTriState :: State_True ) : ( WmiTriState :: State_Error ) ;
			}
			else if ( CompareStringEqual ( Y_E ,  Y_E_INFINITE ? 1 : 0 , X_E , X_E_INFINITE ? 1 : 0 ) ) // ( Y_E == X_E )
			{
//				Order ( Y_S < X_S < Y_E == X_E )
//				Range ( Y_S , X_E ) 

				a_Overlap = new WmiStringRangeNode (

					m_PropertyName ,
					m_Index ,
					Y_S_INFINITE ,
					Y_E_INFINITE ,
					Y_S_CLOSED ,						// Relationship is as strong as ordering 
					Y_E_CLOSED || X_E_CLOSED ,			// Check for weak relationship ( < , > ) 
					Y_S ,
					Y_E ,
					NULL ,
					NULL
				) ;

				t_Status = ( a_Overlap ) ? ( WmiTriState :: State_True ) : ( WmiTriState :: State_Error ) ;
			}
			else if ( CompareStringGreater ( Y_E ,  Y_E_INFINITE ? 1 : 0 , X_E , X_E_INFINITE ? 1 : 0 ) ) // ( Y_E > X_E )
			{
//				Order ( Y_S < X_S < X_E < Y_E )
//				Range ( Y_S , Y_E ) 

				a_Overlap = new WmiStringRangeNode (

					m_PropertyName ,
					m_Index ,
					Y_S_INFINITE ,
					Y_E_INFINITE ,
					Y_S_CLOSED ,						// Relationship is as strong as ordering 
					Y_E_CLOSED ,						// Relationship is as strong as ordering 
					Y_S ,
					Y_E ,
					NULL ,
					NULL
				) ;

				t_Status = ( a_Overlap ) ? ( WmiTriState :: State_True ) : ( WmiTriState :: State_Error ) ;
			}
		}
		else if ( CompareStringEqual ( X_S ,  X_S_INFINITE ? -1 : 0 , Y_E , Y_E_INFINITE ? 1 : 0 ) ) // ( X_S == Y_E ), Start of X and End Of Y overlap
		{
			if ( CompareStringLess ( Y_E ,  Y_E_INFINITE ? 1 : 0 , X_E , X_E_INFINITE ? 1 : 0 ) ) // ( Y_E < X_E )
			{
   				if ( X_S_CLOSED || Y_E_CLOSED )
				{
				    a_Overlap = new WmiStringRangeNode (

					    m_PropertyName ,
					    m_Index ,
					    Y_S_INFINITE  ,
					    X_E_INFINITE,
					    Y_S_CLOSED ,
					    X_E_CLOSED ,
					    Y_S ,
					    X_E ,
					    NULL ,
					    NULL
				    ) ;

					t_Status = ( a_Overlap ) ? ( WmiTriState :: State_True ) : ( WmiTriState :: State_Error ) ;
				}
			}
			else if ( CompareStringEqual ( Y_E ,  Y_E_INFINITE ? 1 : 0 , X_E , X_E_INFINITE ? 1 : 0 ) ) // ( Y_E == X_E )
			{
//				Order ( Y_S < X_S == Y_E == X_E )

				a_Overlap = new WmiStringRangeNode (

					m_PropertyName ,
					m_Index ,
					Y_S_INFINITE ,
					X_E_INFINITE  ,
					Y_S_CLOSED ,
					TRUE ,
					Y_S ,
					X_E ,
					NULL ,
					NULL
				) ;

				t_Status = ( a_Overlap ) ? ( WmiTriState :: State_True ) : ( WmiTriState :: State_Error ) ;
			}
			else if ( CompareStringGreater ( Y_E ,  Y_E_INFINITE ? 1 : 0 , X_E , X_E_INFINITE ? 1 : 0 ) ) // ( Y_E > X_E )
			{
//				Order ( Y_S < X_S == X_E < Y_E )

				a_Overlap = new WmiStringRangeNode (

					m_PropertyName ,
					m_Index ,
					Y_S_INFINITE ,
					Y_E_INFINITE ,
					Y_S_CLOSED ,
					Y_E_CLOSED ,
					Y_S ,
					Y_E ,
					NULL ,
					NULL
				) ;

				t_Status = ( a_Overlap ) ? ( WmiTriState :: State_True ) : ( WmiTriState :: State_Error ) ;
			}
		}
		else if ( CompareStringGreater ( X_S ,  X_S_INFINITE ? -1 : 0 , Y_E , Y_E_INFINITE ? 1 : 0 ) ) // ( X_S > Y_E )
		{
//				Order ( Y_S < Y_E < X_S ) Non Overlapping
		}
	}

	return t_Status ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

WmiRangeNode *WmiOperatorEqualNode :: GetRange ()
{
	WmiRangeNode *t_Range = NULL ;

	WmiTreeNode *t_Value = GetLeft () ;
	if ( t_Value ) 
	{
		if ( t_Value->GetType () == TypeId_WmiUnsignedIntegerNode ) 
		{
			WmiUnsignedIntegerNode *t_Integer = ( WmiUnsignedIntegerNode * ) t_Value ;

			t_Range = new WmiUnsignedIntegerRangeNode (

				t_Integer->GetPropertyName () , 
				t_Integer->GetIndex () , 
				FALSE ,
				FALSE ,
				TRUE ,
				TRUE ,
				t_Integer->GetValue () ,
				t_Integer->GetValue () ,
				NULL , 
				NULL 
			) ;
		}
		else if ( t_Value->GetType () == TypeId_WmiSignedIntegerNode ) 
		{
			WmiSignedIntegerNode *t_Integer = ( WmiSignedIntegerNode * ) t_Value ;
			t_Range = new WmiSignedIntegerRangeNode (

				t_Integer->GetPropertyName () , 
				t_Integer->GetIndex () , 
				FALSE ,
				FALSE ,
				TRUE ,
				TRUE ,
				t_Integer->GetValue () ,
				t_Integer->GetValue () ,
				NULL , 
				NULL 
			) ;
		}
		else if ( t_Value->GetType () == TypeId_WmiStringNode ) 
		{
			WmiStringNode *t_String = ( WmiStringNode * ) t_Value ;

			if ( t_String->GetPropertyFunction () == WmiValueNode :: WmiValueFunction :: Function_None )
			{
				t_Range = new WmiStringRangeNode (

					t_String->GetPropertyName () , 
					t_String->GetIndex () , 
					FALSE ,
					FALSE ,
					TRUE ,
					TRUE ,
					t_String->GetValue () ,
					t_String->GetValue () ,
					NULL , 
					NULL 
				) ;
			}
			else
			{
				t_Range = new WmiStringRangeNode (

					t_String->GetPropertyName () , 
					t_String->GetIndex () , 
					TRUE ,
					TRUE ,
					FALSE ,
					FALSE ,
					NULL,
					NULL,
					NULL , 
					NULL 
				) ;
			}
		}
		else if ( t_Value->GetType () == TypeId_WmiNullNode ) 
		{
			WmiNullNode *t_Null = ( WmiNullNode * ) t_Value ;
			t_Range = new WmiNullRangeNode (

				t_Null->GetPropertyName () ,
				t_Null->GetIndex () ,
				NULL ,
				NULL
			) ;
		}
		else
		{
// Can never happen
DebugBreak () ;
		}
	}

	return t_Range ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

WmiRangeNode *WmiOperatorEqualOrGreaterNode :: GetRange ()
{
	WmiRangeNode *t_Range = NULL ;

	WmiTreeNode *t_Value = GetLeft () ;
	if ( t_Value ) 
	{
		if ( t_Value->GetType () == TypeId_WmiUnsignedIntegerNode ) 
		{
			WmiUnsignedIntegerNode *t_Integer = ( WmiUnsignedIntegerNode * ) t_Value ;

			t_Range = new WmiUnsignedIntegerRangeNode (

				t_Integer->GetPropertyName () , 
				t_Integer->GetIndex () , 
				FALSE ,
				TRUE ,
				TRUE ,
				FALSE ,
				t_Integer->GetValue () ,
				0 ,
				NULL , 
				NULL 
			) ;
		}
		else if ( t_Value->GetType () == TypeId_WmiSignedIntegerNode ) 
		{
			WmiSignedIntegerNode *t_Integer = ( WmiSignedIntegerNode * ) t_Value ;
			t_Range = new WmiSignedIntegerRangeNode (

				t_Integer->GetPropertyName () , 
				t_Integer->GetIndex () , 
				FALSE ,
				TRUE ,
				TRUE ,
				FALSE ,
				t_Integer->GetValue () ,
				0 ,
				NULL , 
				NULL 
			) ;
		}
		else if ( t_Value->GetType () == TypeId_WmiStringNode ) 
		{
			WmiStringNode *t_String = ( WmiStringNode * ) t_Value ;

			if ( t_String->GetPropertyFunction () == WmiValueNode :: WmiValueFunction :: Function_None )
			{
				t_Range = new WmiStringRangeNode (

					t_String->GetPropertyName () , 
					t_String->GetIndex () , 
					FALSE ,
					TRUE ,
					TRUE ,
					FALSE ,
					t_String->GetValue () ,
					NULL ,
					NULL , 
					NULL 
				) ;
			}
			else
			{
				t_Range = new WmiStringRangeNode (

					t_String->GetPropertyName () , 
					t_String->GetIndex () , 
					TRUE ,
					TRUE ,
					FALSE ,
					FALSE ,
					NULL,
					NULL,
					NULL , 
					NULL 
				) ;
			}
		}
		else if ( t_Value->GetType () == TypeId_WmiNullNode ) 
		{
			WmiNullNode *t_Null = ( WmiNullNode * ) t_Value ;
			t_Range = new WmiNullRangeNode (

				t_Null->GetPropertyName () ,
				t_Null->GetIndex () ,
				NULL ,
				NULL
			) ;
		}
		else
		{
// Can never happen
DebugBreak () ;
		}
	}

	return t_Range ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

WmiRangeNode *WmiOperatorEqualOrLessNode :: GetRange ()
{
	WmiRangeNode *t_Range = NULL ;

	WmiTreeNode *t_Value = GetLeft () ;
	if ( t_Value ) 
	{
		if ( t_Value->GetType () == TypeId_WmiUnsignedIntegerNode ) 
		{
			WmiUnsignedIntegerNode *t_Integer = ( WmiUnsignedIntegerNode * ) t_Value ;

			t_Range = new WmiUnsignedIntegerRangeNode (

				t_Integer->GetPropertyName () , 
				t_Integer->GetIndex () , 
				TRUE ,
				FALSE ,
				FALSE ,
				TRUE ,
				0 ,
				t_Integer->GetValue () ,
				NULL , 
				NULL 
			) ;
		}
		else if ( t_Value->GetType () == TypeId_WmiSignedIntegerNode ) 
		{
			WmiSignedIntegerNode *t_Integer = ( WmiSignedIntegerNode * ) t_Value ;
			t_Range = new WmiSignedIntegerRangeNode (

				t_Integer->GetPropertyName () , 
				t_Integer->GetIndex () , 
				TRUE ,
				FALSE ,
				FALSE ,
				TRUE ,
				0 ,
				t_Integer->GetValue () ,
				NULL , 
				NULL 
			) ;
		}
		else if ( t_Value->GetType () == TypeId_WmiStringNode ) 
		{
			WmiStringNode *t_String = ( WmiStringNode * ) t_Value ;

			if ( t_String->GetPropertyFunction () == WmiValueNode :: WmiValueFunction :: Function_None )
			{
				t_Range = new WmiStringRangeNode (

					t_String->GetPropertyName () , 
					t_String->GetIndex () , 
					TRUE ,
					FALSE ,
					FALSE ,
					TRUE ,
					NULL ,
					t_String->GetValue () ,
					NULL , 
					NULL 
				) ;
			}
			else
			{
				t_Range = new WmiStringRangeNode (

					t_String->GetPropertyName () , 
					t_String->GetIndex () , 
					TRUE ,
					TRUE ,
					FALSE ,
					FALSE ,
					NULL,
					NULL,
					NULL , 
					NULL 
				) ;
			}
		}
		else if ( t_Value->GetType () == TypeId_WmiNullNode ) 
		{
			WmiNullNode *t_Null = ( WmiNullNode * ) t_Value ;
			t_Range = new WmiNullRangeNode (

				t_Null->GetPropertyName () ,
				t_Null->GetIndex () ,
				NULL ,
				NULL
			) ;
		}
		else
		{
// Can never happen
DebugBreak () ;
		}
	}

	return t_Range ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

WmiRangeNode *WmiOperatorLessNode :: GetRange ()
{
	WmiRangeNode *t_Range = NULL ;

	WmiTreeNode *t_Value = GetLeft () ;
	if ( t_Value ) 
	{
		if ( t_Value->GetType () == TypeId_WmiUnsignedIntegerNode ) 
		{
			WmiUnsignedIntegerNode *t_Integer = ( WmiUnsignedIntegerNode * ) t_Value ;

			t_Range = new WmiUnsignedIntegerRangeNode (

				t_Integer->GetPropertyName () , 
				t_Integer->GetIndex () , 
				TRUE ,
				FALSE ,
				FALSE ,
				FALSE ,
				0 ,
				t_Integer->GetValue () ,
				NULL , 
				NULL 
			) ;
		}
		else if ( t_Value->GetType () == TypeId_WmiSignedIntegerNode ) 
		{
			WmiSignedIntegerNode *t_Integer = ( WmiSignedIntegerNode * ) t_Value ;

			t_Range = new WmiSignedIntegerRangeNode (

				t_Integer->GetPropertyName () , 
				t_Integer->GetIndex () , 
				TRUE ,
				FALSE ,
				FALSE ,
				FALSE ,
				0 ,
				t_Integer->GetValue ()  ,
				NULL , 
				NULL 
			) ;
		}
		else if ( t_Value->GetType () == TypeId_WmiStringNode ) 
		{
			WmiStringNode *t_String = ( WmiStringNode * ) t_Value ;

			if ( t_String->GetPropertyFunction () == WmiValueNode :: WmiValueFunction :: Function_None )
			{
				t_Range = new WmiStringRangeNode (

					t_String->GetPropertyName () , 
					t_String->GetIndex () , 
					TRUE ,
					FALSE ,
					FALSE ,
					FALSE ,
					NULL ,
					t_String->GetValue () ,
					NULL , 
					NULL 
				) ;
			}
			else
			{
				t_Range = new WmiStringRangeNode (

					t_String->GetPropertyName () , 
					t_String->GetIndex () , 
					TRUE ,
					TRUE ,
					FALSE ,
					FALSE ,
					NULL,
					NULL,
					NULL , 
					NULL 
				) ;
			}
		}
		else if ( t_Value->GetType () == TypeId_WmiNullNode ) 
		{
			WmiNullNode *t_Null = ( WmiNullNode * ) t_Value ;
			t_Range = new WmiNullRangeNode (

				t_Null->GetPropertyName () ,
				t_Null->GetIndex () ,
				NULL ,
				NULL
			) ;
		}
		else
		{
// Can never happen
DebugBreak () ;
		}
	}

	return t_Range ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

WmiRangeNode *WmiOperatorGreaterNode :: GetRange ()
{
	WmiRangeNode *t_Range = NULL ;

	WmiTreeNode *t_Value = GetLeft () ;
	if ( t_Value ) 
	{
		if ( t_Value->GetType () == TypeId_WmiUnsignedIntegerNode ) 
		{
			WmiUnsignedIntegerNode *t_Integer = ( WmiUnsignedIntegerNode * ) t_Value ;

			t_Range = new WmiUnsignedIntegerRangeNode (

				t_Integer->GetPropertyName () , 
				t_Integer->GetIndex () , 
				FALSE ,
				TRUE ,
				FALSE ,
				FALSE ,
				t_Integer->GetValue () ,
				0 ,
				NULL , 
				NULL 
			) ;
		}
		else if ( t_Value->GetType () == TypeId_WmiSignedIntegerNode ) 
		{
			WmiSignedIntegerNode *t_Integer = ( WmiSignedIntegerNode * ) t_Value ;

			t_Range = new WmiSignedIntegerRangeNode (

				t_Integer->GetPropertyName () , 
				t_Integer->GetIndex () , 
				FALSE ,
				TRUE ,
				FALSE ,
				FALSE , 
				t_Integer->GetValue (),
				0 ,
				NULL , 
				NULL 
			) ;
		}
		else if ( t_Value->GetType () == TypeId_WmiStringNode ) 
		{
			WmiStringNode *t_String = ( WmiStringNode * ) t_Value ;

			if ( t_String->GetPropertyFunction () == WmiValueNode :: WmiValueFunction :: Function_None )
			{
				t_Range = new WmiStringRangeNode (

					t_String->GetPropertyName () , 
					t_String->GetIndex () , 
					FALSE ,
					TRUE ,
					FALSE ,
					FALSE ,
					t_String->GetValue () ,
					NULL ,
					NULL , 
					NULL 
				) ;
			}
			else
			{
				t_Range = new WmiStringRangeNode (

					t_String->GetPropertyName () , 
					t_String->GetIndex () , 
					TRUE ,
					TRUE ,
					FALSE ,
					FALSE ,
					NULL,
					NULL,
					NULL , 
					NULL 
				) ;
			}
		}
		else if ( t_Value->GetType () == TypeId_WmiNullNode ) 
		{
			WmiNullNode *t_Null = ( WmiNullNode * ) t_Value ;
			t_Range = new WmiNullRangeNode (

				t_Null->GetPropertyName () ,
				t_Null->GetIndex () ,
				NULL ,
				NULL
			) ;
		}
		else
		{
// Can never happen
DebugBreak () ;
		}
	}

	return t_Range ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

WmiRangeNode *WmiOperatorLikeNode :: GetRange ()
{
	WmiRangeNode *t_Range = NULL ;

	WmiTreeNode *t_Value = GetLeft () ;
	if ( t_Value ) 
	{
		if ( t_Value->GetType () == TypeId_WmiUnsignedIntegerNode ) 
		{
		}
		else if ( t_Value->GetType () == TypeId_WmiSignedIntegerNode ) 
		{
		}
		else if ( t_Value->GetType () == TypeId_WmiStringNode ) 
		{
			WmiStringNode *t_String = ( WmiStringNode * ) t_Value ;

			if ( t_String->GetPropertyFunction () == WmiValueNode :: WmiValueFunction :: Function_None )
			{
				t_Range = new WmiStringRangeNode (

					t_String->GetPropertyName () , 
					t_String->GetIndex () , 
					TRUE ,
					TRUE ,
					FALSE ,
					FALSE ,
					NULL ,
					NULL ,
					NULL , 
					NULL 
				) ;
			}
			else
			{
				t_Range = new WmiStringRangeNode (

					t_String->GetPropertyName () , 
					t_String->GetIndex () , 
					TRUE ,
					TRUE ,
					FALSE ,
					FALSE ,
					NULL ,
					NULL ,
					NULL , 
					NULL 
				) ;
			}
		}
		else if ( t_Value->GetType () == TypeId_WmiNullNode ) 
		{
		}
		else
		{
// Can never happen
DebugBreak () ;
		}
	}

	return t_Range ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

WmiRangeNode *WmiOperatorNotLikeNode :: GetRange ()
{
	WmiRangeNode *t_Range = NULL ;

	WmiTreeNode *t_Value = GetLeft () ;
	if ( t_Value ) 
	{
		if ( t_Value->GetType () == TypeId_WmiUnsignedIntegerNode ) 
		{
		}
		else if ( t_Value->GetType () == TypeId_WmiSignedIntegerNode ) 
		{
		}
		else if ( t_Value->GetType () == TypeId_WmiStringNode ) 
		{
			WmiStringNode *t_String = ( WmiStringNode * ) t_Value ;

			if ( t_String->GetPropertyFunction () == WmiValueNode :: WmiValueFunction :: Function_None )
			{
				t_Range = new WmiStringRangeNode (

					t_String->GetPropertyName () , 
					t_String->GetIndex () , 
					TRUE ,
					TRUE ,
					FALSE ,
					FALSE ,
					NULL ,
					NULL ,
					NULL , 
					NULL 
				) ;
			}
			else
			{
				t_Range = new WmiStringRangeNode (

					t_String->GetPropertyName () , 
					t_String->GetIndex () , 
					TRUE ,
					TRUE ,
					FALSE ,
					FALSE ,
					NULL,
					NULL,
					NULL , 
					NULL 
				) ;
			}
		}
		else if ( t_Value->GetType () == TypeId_WmiNullNode ) 
		{
		}
		else
		{
// Can never happen
DebugBreak () ;
		}
	}

	return t_Range ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

WmiRangeNode *WmiOperatorIsANode :: GetRange ()
{
	WmiRangeNode *t_Range = NULL ;

	WmiTreeNode *t_Value = GetLeft () ;
	if ( t_Value ) 
	{
		if ( t_Value->GetType () == TypeId_WmiUnsignedIntegerNode ) 
		{
		}
		else if ( t_Value->GetType () == TypeId_WmiSignedIntegerNode ) 
		{
		}
		else if ( t_Value->GetType () == TypeId_WmiStringNode ) 
		{
			WmiStringNode *t_String = ( WmiStringNode * ) t_Value ;

			if ( t_String->GetPropertyFunction () == WmiValueNode :: WmiValueFunction :: Function_None )
			{
				t_Range = new WmiStringRangeNode (

					t_String->GetPropertyName () , 
					t_String->GetIndex () , 
					TRUE ,
					TRUE ,
					FALSE ,
					FALSE ,
					NULL ,
					NULL ,
					NULL , 
					NULL 
				) ;
			}
			else
			{
				t_Range = new WmiStringRangeNode (

					t_String->GetPropertyName () , 
					t_String->GetIndex () , 
					TRUE ,
					TRUE ,
					FALSE ,
					FALSE ,
					NULL ,
					NULL ,
					NULL , 
					NULL 
				) ;
			}
		}
		else if ( t_Value->GetType () == TypeId_WmiNullNode ) 
		{
		}
		else
		{
// Can never happen
DebugBreak () ;
		}
	}

	return t_Range ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

WmiRangeNode *WmiOperatorNotIsANode :: GetRange ()
{
	WmiRangeNode *t_Range = NULL ;

	WmiTreeNode *t_Value = GetLeft () ;
	if ( t_Value ) 
	{
		if ( t_Value->GetType () == TypeId_WmiUnsignedIntegerNode ) 
		{
		}
		else if ( t_Value->GetType () == TypeId_WmiSignedIntegerNode ) 
		{
		}
		else if ( t_Value->GetType () == TypeId_WmiStringNode ) 
		{
			WmiStringNode *t_String = ( WmiStringNode * ) t_Value ;

			if ( t_String->GetPropertyFunction () == WmiValueNode :: WmiValueFunction :: Function_None )
			{
				t_Range = new WmiStringRangeNode (

					t_String->GetPropertyName () , 
					t_String->GetIndex () , 
					TRUE ,
					TRUE ,
					FALSE ,
					FALSE ,
					NULL ,
					NULL ,
					NULL , 
					NULL 
				) ;
			}
			else
			{
				t_Range = new WmiStringRangeNode (

					t_String->GetPropertyName () , 
					t_String->GetIndex () , 
					TRUE ,
					TRUE ,
					FALSE ,
					FALSE ,
					NULL ,
					NULL ,
					NULL , 
					NULL 
				) ;
			}
		}
		else if ( t_Value->GetType () == TypeId_WmiNullNode ) 
		{
		}
		else
		{
// Can never happen
DebugBreak () ;
		}
	}

	return t_Range ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

BOOL QueryPreprocessor :: RecursiveEvaluate ( 

	void *a_Context ,
	SWbemRpnQueryToken **a_Expression , 
	WmiTreeNode *a_Parent , 
	WmiTreeNode **a_Node ,
	int &a_Index 
)
{
DebugMacro3( 

	WmiDebugLog :: s_WmiDebugLog->Write (  

		L"RecursiveEvaluate ( int &a_Index )"
	) ;
)

	BOOL t_Status = TRUE ;

	SWbemRpnQueryToken *t_Token = a_Expression [ a_Index ] ;
	a_Index -- ;

	switch ( t_Token->m_uTokenType )
	{
		case WMIQ_RPN_TOKEN_EXPRESSION:
		{
DebugMacro3( 

	WmiDebugLog :: s_WmiDebugLog->Write (  

		L"Operation = OP_EXPESSION"
	) ;
)
			WmiTreeNode *t_ParentNode = a_Parent ;
			WmiTreeNode **t_Node = a_Node ;
			WmiTreeNode *t_OperatorNode = NULL ;

			if ( t_Token->m_uSubexpressionShape & WMIQ_RPN_RELOP )
			{
				switch ( t_Token->m_uOperator )
				{
					case WMIQ_RPN_OP_EQ:
					{
						t_OperatorNode = new WmiOperatorEqualNode ( NULL , t_ParentNode ) ;
					}
					break ;

					case WMIQ_RPN_OP_NE:
					{
						t_OperatorNode = new WmiOperatorNotEqualNode ( NULL , t_ParentNode ) ;
					}
					break ;

					case WMIQ_RPN_OP_GE:
					{
						t_OperatorNode = new WmiOperatorEqualOrGreaterNode ( NULL , t_ParentNode ) ;
					}
					break ;

					case WMIQ_RPN_OP_LE: 
					{
						t_OperatorNode = new WmiOperatorEqualOrLessNode ( NULL , t_ParentNode ) ;
					}
					break ;

					case WMIQ_RPN_OP_LT:
					{
						t_OperatorNode = new WmiOperatorLessNode ( NULL , t_ParentNode ) ;
					}
					break ;

					case WMIQ_RPN_OP_GT:
					{
						t_OperatorNode = new WmiOperatorGreaterNode ( NULL , t_ParentNode ) ;
					}
					break ;

					case WMIQ_RPN_OP_LIKE:
					{
						t_OperatorNode = new WmiOperatorLikeNode ( NULL , t_ParentNode ) ;
					}
					break ;

					case WMIQ_RPN_OP_ISA:
					{
						t_OperatorNode = new WmiOperatorIsANode ( NULL , t_ParentNode ) ;
					}
					break ;

					default:
					{
						t_Status = FALSE ;
					}
					break ;
				}

				if ( t_OperatorNode == NULL )
				{
					t_Status = FALSE ;
				}
			}
			else
			{
				t_Status = FALSE ;
			}

			if ( t_Status ) 
			{
				*t_Node = t_OperatorNode ;
				t_ParentNode = t_OperatorNode ;
				(*t_Node)->GetLeft ( t_Node ) ;

				t_Status = TRUE ;

				WmiValueNode :: WmiValueFunction t_PropertyFunction = WmiValueNode :: WmiValueFunction :: Function_None ;

				if ( t_Token->m_uSubexpressionShape & WMIQ_RPN_LEFT_FUNCTION )
				{
					if ( _wcsicmp ( t_Token->m_pszLeftFunc , L"Upper" ) == 0 )
					{
						t_PropertyFunction = WmiValueNode :: WmiValueFunction :: Function_Upper ;
					}
					else if ( _wcsicmp ( t_Token->m_pszLeftFunc , L"Lower" ) == 0 )
					{
						t_PropertyFunction = WmiValueNode :: WmiValueFunction :: Function_Lower ;
					}
					else
					{
						t_Status = FALSE ;
					}
				}

				WmiValueNode :: WmiValueFunction t_ConstantFunction = WmiValueNode :: WmiValueFunction :: Function_None ;

				if ( t_Token->m_uSubexpressionShape & WMIQ_RPN_RIGHT_FUNCTION )
				{
					if ( _wcsicmp ( t_Token->m_pszRightFunc , L"Upper" ) == 0 )
					{
						t_ConstantFunction = WmiValueNode :: WmiValueFunction :: Function_Upper ;
					}
					else if ( _wcsicmp ( t_Token->m_pszRightFunc , L"Lower" ) == 0 )
					{
						t_ConstantFunction = WmiValueNode :: WmiValueFunction :: Function_Lower ;
					}
					else
					{
						t_Status = FALSE ;
					}
				}

				if ( t_Status ) 
				{
					BOOL t_LeftProperty = t_Token->m_uSubexpressionShape & WMIQ_RPN_LEFT_PROPERTY_NAME ;
					BOOL t_RightProperty = t_Token->m_uSubexpressionShape & WMIQ_RPN_RIGHT_PROPERTY_NAME ;
					BOOL t_Const = t_Token->m_uSubexpressionShape & WMIQ_RPN_CONST ;
					BOOL t_Const2 = t_Token->m_uSubexpressionShape & WMIQ_RPN_CONST2 ;

					BOOL t_Validity = ( t_LeftProperty != 0 ) ? TRUE : FALSE ;
					t_Validity = t_Validity && ( ( t_RightProperty != 0 ) ? FALSE : TRUE ) ;
					t_Validity = t_Validity && ( ( t_Const != 0 ) ? TRUE : FALSE ) ;
					t_Validity = t_Validity && ( ( t_Const2 != 0 ) ? FALSE : TRUE ) ;

					if ( t_Validity ) 
					{
						VARIANT t_Variant ;
						VariantInit ( & t_Variant ) ;

						switch ( t_Token->m_uConstApparentType )
						{
							case VT_I8:
							{
								t_Variant.vt = VT_R8 ;
								t_Variant.dblVal = t_Token->m_Const.m_dblVal ;
							}
							break ;

							case VT_I4:
							{
								t_Variant.vt = VT_I4 ;
								t_Variant.lVal = t_Token->m_Const.m_lLongVal ;
							}
							break ;

							case VT_LPWSTR:
							{
								t_Variant.vt = VT_BSTR ;
								t_Variant.bstrVal = SysAllocString ( t_Token->m_Const.m_pszStrVal ) ;
							}
							break ;

							case CIM_EMPTY:
							{
								t_Variant.vt = VT_NULL ;
							}
							break ;
						}

						BSTR t_PropertyName = SysAllocString ( t_Token->m_pLeftIdent->m_ppszNameList [ 0 ] ) ;
						if ( t_PropertyName ) 
						{
							WmiTreeNode *t_ValueNode = AllocTypeNode ( 

								a_Context ,
								t_PropertyName , 
								t_Variant , 
								t_PropertyFunction ,
								t_ConstantFunction ,
								t_ParentNode 
							) ;

							if ( t_ValueNode )
							{
								*t_Node = t_ValueNode ;

								t_Status = TRUE ;
							}
							else
							{				
								t_Status = FALSE ;
							}

							SysFreeString ( t_PropertyName ) ;
						}
						else
						{
							t_Status = FALSE ;
						}

						VariantClear ( & t_Variant ) ;
					}
					else
					{
						t_Status = FALSE ;
					}
				}
			}
		}
		break ;

		case WMIQ_RPN_TOKEN_AND:
		{
			*a_Node = new WmiAndNode ( NULL , NULL , a_Parent ) ;
			if ( *a_Node ) 
			{
				WmiTreeNode **t_Left = NULL ;
				WmiTreeNode **t_Right = NULL ;
				(*a_Node)->GetLeft ( t_Left ) ;
				(*a_Node)->GetRight ( t_Right ) ;

				t_Status =	RecursiveEvaluate ( a_Context , a_Expression , *a_Node , t_Left , a_Index ) &&
							RecursiveEvaluate ( a_Context , a_Expression , *a_Node , t_Right , a_Index ) ;

			}
			else
			{
				t_Status = FALSE ;
			}

DebugMacro3( 

	WmiDebugLog :: s_WmiDebugLog->Write (  

		L"Operation = TOKEN_AND"
	) ;
)

		}
		break ;

		case WMIQ_RPN_TOKEN_OR:
		{
			*a_Node = new WmiOrNode ( NULL , NULL , a_Parent ) ;
			if ( *a_Node )
			{
				WmiTreeNode **t_Left = NULL ;
				WmiTreeNode **t_Right = NULL ;
				(*a_Node)->GetLeft ( t_Left ) ;
				(*a_Node)->GetRight ( t_Right ) ;

				t_Status =	RecursiveEvaluate ( a_Context , a_Expression , *a_Node , t_Left , a_Index ) &&
							RecursiveEvaluate ( a_Context , a_Expression , *a_Node , t_Right , a_Index ) ;
			}
			else
			{
				t_Status = FALSE ;
			}

DebugMacro3( 

	WmiDebugLog :: s_WmiDebugLog->Write (  


		L"Operation = TOKEN_OR"
	) ;
)

		}
		break ;

		case WMIQ_RPN_TOKEN_NOT:
		{
			*a_Node = new WmiNotNode ( NULL , a_Parent ) ;
			if ( *a_Node )
			{
				WmiTreeNode **t_Left = NULL ;
				(*a_Node)->GetLeft ( t_Left ) ;

				t_Status = RecursiveEvaluate ( a_Context , a_Expression , *a_Node , t_Left , a_Index ) ;
			}
			else
			{
				t_Status = FALSE ;
			}

DebugMacro3( 

	WmiDebugLog :: s_WmiDebugLog->Write (  

		L"Operation = TOKEN_NOT"
	) ;
)

		}
		break ;
	}

DebugMacro3( 

	WmiDebugLog :: s_WmiDebugLog->Write (  

		L"RecursiveEvaluation t_Status = (%lu)" ,
		( ULONG ) t_Status
	) ;
)
	return t_Status ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

BOOL QueryPreprocessor :: Evaluate ( 

	void *a_Context ,
	SWbemRpnQueryToken **a_Expression , 
	int a_Count ,
	WmiTreeNode **a_Root 
)
{
	BOOL t_Status = TRUE ;

	if ( a_Count )
	{
		int t_Index = a_Count - 1 ; ;  
		t_Status = RecursiveEvaluate ( a_Context , a_Expression , NULL , a_Root , t_Index ) ;
	}

DebugMacro3( 

	WmiDebugLog :: s_WmiDebugLog->Write (  

		L"PostEvaluation Status = (%lu)\n" ,
		( ULONG ) t_Status
	) ;
)

	return t_Status ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

void QueryPreprocessor :: PrintTree ( WmiTreeNode *a_Root )
{
DebugMacro3( 

	WmiDebugLog :: s_WmiDebugLog->Write (  

		L"Expression = "
	) ;

	if ( a_Root ) 
		a_Root->Print () ;

	WmiDebugLog :: s_WmiDebugLog->Write (  

		L"\n"
	) ;
)

}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

void QueryPreprocessor :: TransformAndOrExpression ( 

	WmiTreeNode *&a_Node , 
	WmiTreeNode *a_AndChild , 
	WmiTreeNode *a_OrChild 
)
{
	WmiTriState t_Status = WmiTriState :: State_True ;

	WmiTreeNode *t_OrLeftChild = a_OrChild->GetLeft () ;
	WmiTreeNode *t_OrRightChild = a_OrChild->GetRight () ;
	WmiTreeNode *t_Parent = a_Node->GetParent () ;

	WmiTreeNode *t_NewOrNode = new WmiOrNode ( NULL , NULL , t_Parent ) ;
	if ( t_NewOrNode )
	{
		WmiTreeNode *t_NewOrNodeLeft = new WmiAndNode ( a_AndChild , t_OrLeftChild , t_NewOrNode ) ;
		if ( t_NewOrNodeLeft )
		{
			t_NewOrNode->SetLeft ( t_NewOrNodeLeft ) ;
		}
		else
		{
			t_Status = WmiTriState :: State_Error ;
		}

		WmiTreeNode *t_AndChildCopy = a_AndChild->Copy () ;
		if ( t_AndChildCopy )
		{
			WmiTreeNode *t_NewOrNodeRight = new WmiAndNode ( t_AndChildCopy , t_OrRightChild , t_NewOrNode ) ;
			if ( t_NewOrNodeRight )
			{
				t_NewOrNode->SetRight ( t_NewOrNodeRight ) ;
			}
			else
			{
				t_Status = WmiTriState :: State_Error ;
			}
		}
		else
		{
			t_Status = WmiTriState :: State_Error ;
		}

		if ( t_Parent )
		{
			if ( t_Parent->GetLeft () == a_Node )
			{
				t_Parent->SetLeft ( t_NewOrNode ) ;
			}
			else 
			{
				t_Parent->SetRight ( t_NewOrNode ) ;
			}	
		}

		a_Node->SetLeft ( NULL ) ;
		a_Node->SetRight ( NULL ) ;
		a_Node->SetData ( NULL ) ;

		a_OrChild->SetLeft ( NULL ) ;
		a_OrChild->SetRight ( NULL ) ;
		a_OrChild->SetData ( NULL ) ;

		delete a_Node ; 
		a_Node = NULL ;

		delete a_OrChild ; 
		a_OrChild = NULL ;
	}

	if ( t_Status == WmiTriState :: State_True )
	{
		a_Node = t_NewOrNode ;
	}
	else
	{
		delete t_NewOrNode ;
		a_Node = NULL ;
	}
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

void QueryPreprocessor :: TransformNotNotExpression ( 

	WmiTreeNode *&a_Node , 
	WmiTreeNode *a_Child 
)
{
	WmiTreeNode *t_Leaf = a_Child->GetLeft () ;
	WmiTreeNode *t_Parent = a_Node->GetParent () ;

	t_Leaf->SetParent ( t_Parent ) ;

	if ( t_Parent )
	{
		if ( t_Parent->GetLeft () == a_Node )
		{
			t_Parent->SetLeft ( t_Leaf ) ;
		}
		else 
		{
			t_Parent->SetRight ( t_Leaf ) ;
		}	
	}

	a_Node->SetLeft ( NULL ) ;
	a_Node->SetRight ( NULL ) ;
	a_Node->SetData ( NULL ) ;

	a_Child->SetLeft ( NULL ) ;
	a_Child->SetRight ( NULL ) ;
	a_Child->SetData ( NULL ) ;

	delete a_Node ; 
	a_Node = NULL ;
	delete a_Child ; 
	a_Child = NULL ;

	a_Node = t_Leaf ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

void QueryPreprocessor :: TransformNotAndExpression ( 

	WmiTreeNode *&a_Node , 
	WmiTreeNode *a_Child 
)
{
	WmiTriState t_Status = WmiTriState :: State_True ;

	WmiTreeNode *t_AndLeftChild = a_Child->GetLeft () ;
	WmiTreeNode *t_AndRightChild = a_Child->GetRight () ;
	WmiTreeNode *t_Parent = a_Node->GetParent () ;

	WmiTreeNode *t_NewOrNode = new WmiOrNode ( NULL , NULL , t_Parent ) ;
	if ( t_NewOrNode )
	{
		WmiTreeNode *t_LeftNot = new WmiNotNode ( t_AndLeftChild , t_NewOrNode ) ;
		if ( t_LeftNot )
		{
			t_NewOrNode->SetLeft ( t_LeftNot ) ;
		}
		else
		{
			t_Status = WmiTriState :: State_Error ;
		}

		WmiTreeNode *t_RightNot = new WmiNotNode ( t_AndRightChild , t_NewOrNode ) ;
		if ( t_RightNot )
		{
			t_NewOrNode->SetRight ( t_RightNot ) ;
		}
		else
		{
			t_Status = WmiTriState :: State_Error ;
		}
	}

	if ( t_Parent )
	{
		if ( t_Parent->GetLeft () == a_Node )
		{
			t_Parent->SetLeft ( t_NewOrNode ) ;
		}
		else 
		{
			t_Parent->SetRight ( t_NewOrNode ) ;
		}	
	}

	a_Node->SetLeft ( NULL ) ;
	a_Node->SetRight ( NULL ) ;
	a_Node->SetData ( NULL ) ;

	a_Child->SetLeft ( NULL ) ;
	a_Child->SetRight ( NULL ) ;
	a_Child->SetData ( NULL ) ;

	delete a_Node ; 
	a_Node = NULL ;
	delete a_Child ; 
	a_Child = NULL ;

	if ( t_Status == WmiTriState :: State_True )
	{
		a_Node = t_NewOrNode ;
	}
	else
	{
		delete t_NewOrNode ;
	}
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

void QueryPreprocessor :: TransformNotOrExpression ( 

	WmiTreeNode *&a_Node , 
	WmiTreeNode *a_Child 
)
{
	WmiTriState t_Status = WmiTriState :: State_True ;

	WmiTreeNode *t_OrLeftChild = a_Child->GetLeft () ;
	WmiTreeNode *t_OrRightChild = a_Child->GetRight () ;
	WmiTreeNode *t_Parent = a_Node->GetParent () ;

	WmiTreeNode *t_NewAndNode = new WmiAndNode ( NULL , NULL , t_Parent ) ;
	if ( t_NewAndNode )
	{
		WmiTreeNode *t_LeftNot = new WmiNotNode ( t_OrLeftChild , t_NewAndNode ) ;
		if ( t_LeftNot )
		{
			t_NewAndNode->SetLeft ( t_LeftNot ) ;
		}
		else
		{
			t_Status = WmiTriState :: State_Error ;
		}

		WmiTreeNode *t_RightNot = new WmiNotNode ( t_OrRightChild , t_NewAndNode ) ;
		if ( t_RightNot )
		{
			t_NewAndNode->SetRight ( t_RightNot ) ;
		}
		else
		{
			t_Status = WmiTriState :: State_Error ;
		}
	}

	if ( t_Parent )
	{
		if ( t_Parent->GetLeft () == a_Node )
		{
			t_Parent->SetLeft ( t_NewAndNode ) ;
		}
		else 
		{
			t_Parent->SetRight ( t_NewAndNode ) ;
		}	
	}

	a_Node->SetLeft ( NULL ) ;
	a_Node->SetRight ( NULL ) ;
	a_Node->SetData ( NULL ) ;

	a_Child->SetLeft ( NULL ) ;
	a_Child->SetRight ( NULL ) ;
	a_Child->SetData ( NULL ) ;

	delete a_Node ; 
	a_Node = NULL ;
	delete a_Child ; 
	a_Child = NULL ;

	if ( t_Status == WmiTriState :: State_True )
	{
		a_Node = t_NewAndNode ;
	}
	else
	{
		delete t_NewAndNode ;
	}
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

void QueryPreprocessor :: TransformNotEqualExpression ( 

	WmiTreeNode *&a_Node , 
	WmiTreeNode *a_Child 
)
{
	WmiTriState t_Status = WmiTriState :: State_True ;

	WmiTreeNode *t_Parent = a_Node->GetParent () ;

	WmiTreeNode *t_NewOrNode = new WmiOrNode ( NULL , NULL , t_Parent ) ;
	if ( t_NewOrNode )
	{
		WmiTreeNode *t_LessNode = new WmiOperatorLessNode  ( a_Child , t_NewOrNode ) ;
		if ( t_LessNode )
		{
			t_NewOrNode->SetLeft ( t_LessNode ) ;
		}
		else
		{
			t_Status = WmiTriState :: State_Error ;
		}

		WmiTreeNode *t_CopyGreaterChild = a_Child->Copy () ;
		if ( t_CopyGreaterChild )
		{
			WmiTreeNode *t_GreatorNode = new WmiOperatorGreaterNode  ( t_CopyGreaterChild , t_NewOrNode ) ;
			if ( t_GreatorNode )
			{
				t_NewOrNode->SetRight ( t_GreatorNode ) ;
			}
			else
			{
				t_Status = WmiTriState :: State_Error ;
			}
		}
		else
		{
			t_Status = WmiTriState :: State_Error ;
		}
	}

	if ( t_Parent )
	{
		if ( t_Parent->GetLeft () == a_Node )
		{
			t_Parent->SetLeft ( t_NewOrNode ) ;
		}
		else 
		{
			t_Parent->SetRight ( t_NewOrNode ) ;
		}	
	}

	a_Node->SetLeft ( NULL ) ;
	a_Node->SetRight ( NULL ) ;
	a_Node->SetData ( NULL ) ;

	delete a_Node ;

	if ( t_Status == WmiTriState :: State_True )
	{
		a_Node = t_NewOrNode ;
	}
	else
	{
		delete t_NewOrNode ;
	}
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

void QueryPreprocessor :: TransformNotOperatorEqualExpression ( 

	WmiTreeNode *&a_Node , 
	WmiTreeNode *a_Child 
)
{
	WmiTriState t_Status = WmiTriState :: State_True ;

	WmiTreeNode *t_Leaf = a_Child->GetLeft () ;
	WmiTreeNode *t_Parent = a_Node->GetParent () ;

	WmiTreeNode *t_NewNode = new WmiOperatorNotEqualNode ( t_Leaf , t_Parent ) ;
	if ( ! t_NewNode )
	{
		t_Status = WmiTriState :: State_Error ;
	}

	if ( t_Parent )
	{
		if ( t_Parent->GetLeft () == a_Node )
		{
			t_Parent->SetLeft ( t_NewNode ) ;
		}
		else 
		{
			t_Parent->SetRight ( t_NewNode ) ;
		}	
	}

	a_Child->SetLeft ( NULL ) ;
	a_Child->SetRight ( NULL ) ;
	a_Child->SetData ( NULL ) ;

	delete a_Node ;

	if ( t_Status == WmiTriState :: State_True )
	{
		a_Node = t_NewNode ;
	}
	else
	{
		delete t_NewNode ;
	}
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

void QueryPreprocessor :: TransformNotOperatorNotEqualExpression ( 

	WmiTreeNode *&a_Node , 
	WmiTreeNode *a_Child 
)
{
	WmiTriState t_Status = WmiTriState :: State_True ;

	WmiTreeNode *t_Leaf = a_Child->GetLeft () ;
	WmiTreeNode *t_Parent = a_Node->GetParent () ;

	WmiTreeNode *t_NewNode = new WmiOperatorEqualNode ( t_Leaf , t_Parent ) ;
	if ( ! t_NewNode )
	{
		t_Status = WmiTriState :: State_Error ;
	}

	if ( t_Parent )
	{
		if ( t_Parent->GetLeft () == a_Node )
		{
			t_Parent->SetLeft ( t_NewNode ) ;
		}
		else 
		{
			t_Parent->SetRight ( t_NewNode ) ;
		}	
	}

	a_Child->SetLeft ( NULL ) ;
	a_Child->SetRight ( NULL ) ;
	a_Child->SetData ( NULL ) ;

	delete a_Node ;

	if ( t_Status == WmiTriState :: State_True )
	{
		a_Node = t_NewNode ;
	}
	else
	{
		delete t_NewNode ;
	}
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

void QueryPreprocessor :: TransformNotOperatorEqualOrGreaterExpression ( 

	WmiTreeNode *&a_Node , 
	WmiTreeNode *a_Child 
)
{
	WmiTriState t_Status = WmiTriState :: State_True ;

	WmiTreeNode *t_Leaf = a_Child->GetLeft () ;
	WmiTreeNode *t_Parent = a_Node->GetParent () ;

	WmiTreeNode *t_NewNode = new WmiOperatorEqualOrLessNode ( t_Leaf , t_Parent ) ;
	if ( ! t_NewNode )
	{
		t_Status = WmiTriState :: State_Error ;
	}

	if ( t_Parent )
	{
		if ( t_Parent->GetLeft () == a_Node )
		{
			t_Parent->SetLeft ( t_NewNode ) ;
		}
		else 
		{
			t_Parent->SetRight ( t_NewNode ) ;
		}	
	}

	a_Child->SetLeft ( NULL ) ;
	a_Child->SetRight ( NULL ) ;
	a_Child->SetData ( NULL ) ;

	delete a_Node ;

	if ( t_Status == WmiTriState :: State_True )
	{
		a_Node = t_NewNode ;
	}
	else
	{
		delete t_NewNode ;
	}
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

void QueryPreprocessor :: TransformNotOperatorEqualOrLessExpression ( 

	WmiTreeNode *&a_Node , 
	WmiTreeNode *a_Child 
)
{
	WmiTriState t_Status = WmiTriState :: State_True ;

	WmiTreeNode *t_Leaf = a_Child->GetLeft () ;
	WmiTreeNode *t_Parent = a_Node->GetParent () ;

	WmiTreeNode *t_NewNode = new WmiOperatorEqualOrGreaterNode ( t_Leaf , t_Parent ) ;
	if ( ! t_NewNode )
	{
		t_Status = WmiTriState :: State_Error ;
	}

	if ( t_Parent )
	{
		if ( t_Parent->GetLeft () == a_Node )
		{
			t_Parent->SetLeft ( t_NewNode ) ;
		}
		else 
		{
			t_Parent->SetRight ( t_NewNode ) ;
		}	
	}

	a_Child->SetLeft ( NULL ) ;
	a_Child->SetRight ( NULL ) ;
	a_Child->SetData ( NULL ) ;

	delete a_Node ;

	if ( t_Status == WmiTriState :: State_True )
	{
		a_Node = t_NewNode ;
	}
	else
	{
		delete t_NewNode ;
	}
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

void QueryPreprocessor :: TransformNotOperatorGreaterExpression ( 

	WmiTreeNode *&a_Node , 
	WmiTreeNode *a_Child 
)
{
	WmiTriState t_Status = WmiTriState :: State_True ;

	WmiTreeNode *t_Leaf = a_Child->GetLeft () ;
	WmiTreeNode *t_Parent = a_Node->GetParent () ;

	WmiTreeNode *t_NewNode = new WmiOperatorEqualOrLessNode ( t_Leaf , t_Parent ) ;
	if ( ! t_NewNode )
	{
		t_Status = WmiTriState :: State_Error ;
	}

	if ( t_Parent )
	{
		if ( t_Parent->GetLeft () == a_Node )
		{
			t_Parent->SetLeft ( t_NewNode ) ;
		}
		else 
		{
			t_Parent->SetRight ( t_NewNode ) ;
		}	
	}

	a_Child->SetLeft ( NULL ) ;
	a_Child->SetRight ( NULL ) ;
	a_Child->SetData ( NULL ) ;

	delete a_Node ;

	if ( t_Status == WmiTriState :: State_True )
	{
		a_Node = t_NewNode ;
	}
	else
	{
		delete t_NewNode ;
	}
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

void QueryPreprocessor :: TransformNotOperatorLessExpression ( 

	WmiTreeNode *&a_Node , 
	WmiTreeNode *a_Child 
)
{
	WmiTriState t_Status = WmiTriState :: State_True ;

	WmiTreeNode *t_Leaf = a_Child->GetLeft () ;
	WmiTreeNode *t_Parent = a_Node->GetParent () ;

	WmiTreeNode *t_NewNode = new WmiOperatorEqualOrGreaterNode ( t_Leaf , t_Parent ) ;
	if ( ! t_NewNode )
	{
		t_Status = WmiTriState :: State_Error ;
	}

	if ( t_Parent )
	{
		if ( t_Parent->GetLeft () == a_Node )
		{
			t_Parent->SetLeft ( t_NewNode ) ;
		}
		else 
		{
			t_Parent->SetRight ( t_NewNode ) ;
		}	
	}

	a_Child->SetLeft ( NULL ) ;
	a_Child->SetRight ( NULL ) ;
	a_Child->SetData ( NULL ) ;

	delete a_Node ;

	if ( t_Status == WmiTriState :: State_True )
	{
		a_Node = t_NewNode ;
	}
	else
	{
		delete t_NewNode ;
	}
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

void QueryPreprocessor :: TransformNotOperatorLikeExpression ( 

	WmiTreeNode *&a_Node , 
	WmiTreeNode *a_Child 
)
{
	WmiTriState t_Status = WmiTriState :: State_True ;

	WmiTreeNode *t_Leaf = a_Child->GetLeft () ;
	WmiTreeNode *t_Parent = a_Node->GetParent () ;

	WmiTreeNode *t_NewNode = new WmiOperatorNotLikeNode ( t_Leaf , t_Parent ) ;
	if ( ! t_NewNode )
	{
		t_Status = WmiTriState :: State_Error ;
	}

	if ( t_Parent )
	{
		if ( t_Parent->GetLeft () == a_Node )
		{
			t_Parent->SetLeft ( t_NewNode ) ;
		}
		else 
		{
			t_Parent->SetRight ( t_NewNode ) ;
		}	
	}

	a_Child->SetLeft ( NULL ) ;
	a_Child->SetRight ( NULL ) ;
	a_Child->SetData ( NULL ) ;

	delete a_Node ;

	if ( t_Status == WmiTriState :: State_True )
	{
		a_Node = t_NewNode ;
	}
	else
	{
		delete t_NewNode ;
	}
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

void QueryPreprocessor :: TransformNotOperatorNotLikeExpression ( 

	WmiTreeNode *&a_Node , 
	WmiTreeNode *a_Child 
)
{
	WmiTriState t_Status = WmiTriState :: State_True ;

	WmiTreeNode *t_Leaf = a_Child->GetLeft () ;
	WmiTreeNode *t_Parent = a_Node->GetParent () ;

	WmiTreeNode *t_NewNode = new WmiOperatorLikeNode ( t_Leaf , t_Parent ) ;
	if ( ! t_NewNode )
	{
		t_Status = WmiTriState :: State_Error ;
	}

	if ( t_Parent )
	{
		if ( t_Parent->GetLeft () == a_Node )
		{
			t_Parent->SetLeft ( t_NewNode ) ;
		}
		else 
		{
			t_Parent->SetRight ( t_NewNode ) ;
		}	
	}

	a_Child->SetLeft ( NULL ) ;
	a_Child->SetRight ( NULL ) ;
	a_Child->SetData ( NULL ) ;

	delete a_Node ;

	if ( t_Status == WmiTriState :: State_True )
	{
		a_Node = t_NewNode ;
	}
	else
	{
		delete t_NewNode ;
	}
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

void QueryPreprocessor :: TransformNotOperatorIsAExpression ( 

	WmiTreeNode *&a_Node , 
	WmiTreeNode *a_Child 
)
{
	WmiTriState t_Status = WmiTriState :: State_True ;

	WmiTreeNode *t_Leaf = a_Child->GetLeft () ;
	WmiTreeNode *t_Parent = a_Node->GetParent () ;

	WmiTreeNode *t_NewNode = new WmiOperatorNotIsANode ( t_Leaf , t_Parent ) ;
	if ( ! t_NewNode )
	{
		t_Status = WmiTriState :: State_Error ;
	}

	if ( t_Parent )
	{
		if ( t_Parent->GetLeft () == a_Node )
		{
			t_Parent->SetLeft ( t_NewNode ) ;
		}
		else 
		{
			t_Parent->SetRight ( t_NewNode ) ;
		}	
	}

	a_Child->SetLeft ( NULL ) ;
	a_Child->SetRight ( NULL ) ;
	a_Child->SetData ( NULL ) ;

	delete a_Node ;

	if ( t_Status == WmiTriState :: State_True )
	{
		a_Node = t_NewNode ;
	}
	else
	{
		delete t_NewNode ;
	}
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

void QueryPreprocessor :: TransformNotOperatorNotIsAExpression ( 

	WmiTreeNode *&a_Node , 
	WmiTreeNode *a_Child 
)
{
	WmiTriState t_Status = WmiTriState :: State_True ;

	WmiTreeNode *t_Leaf = a_Child->GetLeft () ;
	WmiTreeNode *t_Parent = a_Node->GetParent () ;

	WmiTreeNode *t_NewNode = new WmiOperatorIsANode ( t_Leaf , t_Parent ) ;
	if ( ! t_NewNode )
	{
		t_Status = WmiTriState :: State_Error ;
	}

	if ( t_Parent )
	{
		if ( t_Parent->GetLeft () == a_Node )
		{
			t_Parent->SetLeft ( t_NewNode ) ;
		}
		else 
		{
			t_Parent->SetRight ( t_NewNode ) ;
		}	
	}

	a_Child->SetLeft ( NULL ) ;
	a_Child->SetRight ( NULL ) ;
	a_Child->SetData ( NULL ) ;

	delete a_Node ;

	if ( t_Status == WmiTriState :: State_True )
	{
		a_Node = t_NewNode ;
	}
	else
	{
		delete t_NewNode ;
	}
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

void QueryPreprocessor :: TransformAndTrueEvaluation ( 

	WmiTreeNode *&a_Node , 
	WmiTreeNode *a_Child 
)
{
	if ( a_Node->GetLeft () == a_Child )
	{
		a_Node->SetLeft ( NULL ) ;
	}
	else
	{
		a_Node->SetRight ( NULL ) ;
	}

	WmiTreeNode *t_Parent = a_Node->GetParent () ;
	if ( t_Parent )
	{
		if ( t_Parent->GetLeft () == a_Node )
		{
			t_Parent->SetLeft ( a_Child ) ;
		}
		else 
		{
			t_Parent->SetRight ( a_Child ) ;
		}	
	}

	a_Child->SetParent ( t_Parent ) ;

	delete a_Node ;
	a_Node = a_Child ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

void QueryPreprocessor :: TransformOrFalseEvaluation ( 

	WmiTreeNode *&a_Node , 
	WmiTreeNode *a_Child 
)
{
	if ( a_Node->GetLeft () == a_Child )
	{
		a_Node->SetLeft ( NULL ) ;
	}
	else
	{
		a_Node->SetRight ( NULL ) ;
	}

	WmiTreeNode *t_Parent = a_Node->GetParent () ;
	if ( t_Parent )
	{
		if ( t_Parent->GetLeft () == a_Node )
		{
			t_Parent->SetLeft ( a_Child ) ;
		}
		else 
		{
			t_Parent->SetRight ( a_Child ) ;
		}	

	}

	a_Child->SetParent ( t_Parent ) ;

	delete a_Node ;

	a_Node = a_Child ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

void QueryPreprocessor :: TransformOperatorToRange ( 

	WmiTreeNode *&a_Node 
)
{
	WmiTreeNode *t_Parent = a_Node->GetParent () ;

	WmiOperatorNode *t_OperatorNode = ( WmiOperatorNode * ) a_Node ;
	WmiTreeNode *t_Range = t_OperatorNode->GetRange () ;
	if ( t_Range )
	{
		if ( t_Parent )
		{
			if ( t_Parent->GetLeft () == a_Node )
			{
				t_Parent->SetLeft ( t_Range ) ;
			}
			else 
			{
				t_Parent->SetRight ( t_Range ) ;
			}	
		}

		t_Range->SetParent ( t_Parent ) ;
	}

	delete a_Node ;

	a_Node = t_Range ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

WmiTriState QueryPreprocessor :: EvaluateNotExpression ( WmiTreeNode *&a_Node )
{
	if ( a_Node->GetLeft () )
	{
		WmiTreeNode *t_Left = a_Node->GetLeft () ;
		if ( t_Left->GetType () == TypeId_WmiAndNode ) 
		{
			TransformNotAndExpression ( a_Node , t_Left ) ;
			return a_Node ? WmiTriState :: State_True : WmiTriState :: State_Error ;
		}
		else if ( t_Left->GetType () == TypeId_WmiOrNode ) 
		{
			TransformNotOrExpression ( a_Node , t_Left ) ;
			return a_Node ? WmiTriState :: State_True : WmiTriState :: State_Error ;
		}
		else if ( t_Left->GetType () == TypeId_WmiNotNode ) 
		{
			TransformNotNotExpression ( a_Node , t_Left ) ;
			return a_Node ? WmiTriState :: State_True : WmiTriState :: State_Error ;
		}
		else if ( t_Left->GetType () == TypeId_WmiOperatorEqualNode ) 
		{
			TransformNotOperatorEqualExpression ( a_Node , t_Left ) ;
			return a_Node ? WmiTriState :: State_True : WmiTriState :: State_Error ;
		}
		else if ( t_Left->GetType () == TypeId_WmiOperatorNotEqualNode ) 
		{
			TransformNotOperatorNotEqualExpression ( a_Node , t_Left ) ;
			return a_Node ? WmiTriState :: State_True : WmiTriState :: State_Error ;
		}
		else if ( t_Left->GetType () == TypeId_WmiOperatorEqualOrGreaterNode ) 
		{
			TransformNotOperatorEqualOrGreaterExpression ( a_Node , t_Left ) ;
			return a_Node ? WmiTriState :: State_True : WmiTriState :: State_Error ;
		}
		else if ( t_Left->GetType () == TypeId_WmiOperatorEqualOrLessNode ) 
		{
			TransformNotOperatorEqualOrLessExpression ( a_Node , t_Left ) ;
			return a_Node ? WmiTriState :: State_True : WmiTriState :: State_Error ;
		}
		else if ( t_Left->GetType () == TypeId_WmiOperatorLessNode ) 
		{
			TransformNotOperatorLessExpression ( a_Node , t_Left ) ;
			return a_Node ? WmiTriState :: State_True : WmiTriState :: State_Error ;
		}
		else if ( t_Left->GetType () == TypeId_WmiOperatorGreaterNode ) 
		{
			TransformNotOperatorGreaterExpression ( a_Node , t_Left ) ;
			return a_Node ? WmiTriState :: State_True : WmiTriState :: State_Error ;
		}
		else if ( t_Left->GetType () == TypeId_WmiOperatorLikeNode ) 
		{
			TransformNotOperatorLikeExpression ( a_Node , t_Left ) ;
			return a_Node ? WmiTriState :: State_True : WmiTriState :: State_Error ;
		}
		else if ( t_Left->GetType () == TypeId_WmiOperatorNotLikeNode ) 
		{
			TransformNotOperatorNotLikeExpression ( a_Node , t_Left ) ;
			return a_Node ? WmiTriState :: State_True : WmiTriState :: State_Error ;
		}
		else if ( t_Left->GetType () == TypeId_WmiOperatorIsANode ) 
		{
			TransformNotOperatorIsAExpression ( a_Node , t_Left ) ;
			return a_Node ? WmiTriState :: State_True : WmiTriState :: State_Error ;
		}
		else if ( t_Left->GetType () == TypeId_WmiOperatorNotIsANode ) 
		{
			TransformNotOperatorNotIsAExpression ( a_Node , t_Left ) ;
			return a_Node ? WmiTriState :: State_True : WmiTriState :: State_Error ;
		}
		else
		{
			return WmiTriState :: State_False ; 
		}
	}

	return WmiTriState :: State_Error ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

WmiTriState QueryPreprocessor :: EvaluateNotEqualExpression ( WmiTreeNode *&a_Node )
{
	WmiTreeNode *t_Left = a_Node->GetLeft () ;

	TransformNotEqualExpression ( a_Node , t_Left ) ;
	return a_Node ? WmiTriState :: State_True : WmiTriState :: State_Error ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

WmiTriState QueryPreprocessor :: EvaluateAndExpression ( WmiTreeNode *&a_Node )
{
	WmiTreeNode *t_Left = a_Node->GetLeft () ;
	WmiTreeNode *t_Right = a_Node->GetRight () ;
	
	if ( t_Left )
	{
		if ( t_Left->GetType () == TypeId_WmiOrNode ) 
		{
			TransformAndOrExpression ( a_Node , t_Right , t_Left ) ;
			return a_Node ? WmiTriState :: State_True : WmiTriState :: State_Error ;
		}
	}

	if ( t_Right )
	{
		if ( t_Right->GetType () == TypeId_WmiOrNode ) 
		{
			TransformAndOrExpression ( a_Node , t_Left , t_Right ) ;
			return a_Node ? WmiTriState :: State_True : WmiTriState :: State_Error ;
		}
	}

	return WmiTriState :: State_False ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

WmiTriState QueryPreprocessor :: EvaluateOrExpression ( WmiTreeNode *&a_Node )
{
	return WmiTriState :: State_False  ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

QueryPreprocessor :: QuadState QueryPreprocessor :: RecursiveDisjunctiveNormalForm ( WmiTreeNode *&a_Node )
{
	QueryPreprocessor :: QuadState t_Status = State_True ;

	if ( a_Node ) 
	{
		if ( a_Node->GetType () == TypeId_WmiAndNode ) 
		{
			if ( EvaluateAndExpression ( a_Node ) == WmiTriState :: State_True )
			{
				t_Status = QuadState :: State_ReEvaluate ;
			}
			else
			{
				WmiTreeNode *t_Left = a_Node->GetLeft () ;
				WmiTreeNode *t_Right = a_Node->GetRight () ;

				if ( t_Left )
				{
					t_Status = RecursiveDisjunctiveNormalForm ( t_Left ) ;
					if ( t_Status == QuadState :: State_ReEvaluate )
					{
						t_Status = RecursiveDisjunctiveNormalForm ( a_Node ) ;
						return t_Status ;
					}
				}

				if ( t_Right )
				{
					t_Status = RecursiveDisjunctiveNormalForm ( t_Right ) ;
					if ( t_Status == QuadState :: State_ReEvaluate )
					{
						t_Status = RecursiveDisjunctiveNormalForm ( a_Node ) ;
						return t_Status ;
					}
				}
			}
		}
		else if ( a_Node->GetType () == TypeId_WmiOrNode ) 
		{
			if ( EvaluateOrExpression ( a_Node ) == WmiTriState :: State_True )
			{
				t_Status = QuadState :: State_ReEvaluate ;
			}
			else
			{
				WmiTreeNode *t_Left = a_Node->GetLeft () ;
				WmiTreeNode *t_Right = a_Node->GetRight () ;

				if ( t_Left )
				{
					t_Status = RecursiveDisjunctiveNormalForm ( t_Left ) ;
					if ( t_Status == QuadState :: State_ReEvaluate )
					{
						t_Status = RecursiveDisjunctiveNormalForm ( a_Node ) ;
						return t_Status ;
					}
				}

				if ( t_Right )
				{
					t_Status = RecursiveDisjunctiveNormalForm ( t_Right ) ;
					if ( t_Status == QuadState :: State_ReEvaluate )
					{
						t_Status = RecursiveDisjunctiveNormalForm ( a_Node ) ;
						return t_Status ;
					}
				}
			}
		}
		else if ( a_Node->GetType () == TypeId_WmiNotNode ) 
		{
			if ( EvaluateNotExpression ( a_Node ) == WmiTriState :: State_True )
			{
				t_Status = QuadState :: State_ReEvaluate ;
			}
			else
			{
				WmiTreeNode *t_Left = a_Node->GetLeft () ;
				if ( t_Left )
				{
					t_Status = RecursiveDisjunctiveNormalForm ( t_Left ) ;
					if ( t_Status == QuadState :: State_ReEvaluate )
					{
						t_Status = RecursiveDisjunctiveNormalForm ( a_Node ) ;
						return t_Status ;
					}
				}
			}
		}
		else if ( a_Node->GetType () == TypeId_WmiOperatorNotEqualNode ) 
		{
			if ( EvaluateNotEqualExpression ( a_Node ) == WmiTriState :: State_True )
			{
				t_Status = QuadState :: State_ReEvaluate ;
			}
			else
			{
				WmiTreeNode *t_Left = a_Node->GetLeft () ;
				if ( t_Left )
				{
					t_Status = RecursiveDisjunctiveNormalForm ( t_Left ) ;
					if ( t_Status == QuadState :: State_ReEvaluate )
					{
						t_Status = RecursiveDisjunctiveNormalForm ( a_Node ) ;
						return t_Status ;
					}
				}
			}
		}
	}

	return t_Status ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

QueryPreprocessor :: QuadState QueryPreprocessor :: DisjunctiveNormalForm ( WmiTreeNode *&a_Root ) 
{
	QueryPreprocessor :: QuadState t_Status = RecursiveDisjunctiveNormalForm ( a_Root ) ;
	if ( t_Status == QuadState :: State_ReEvaluate )
	{
		t_Status = DisjunctiveNormalForm ( a_Root ) ;
	}

	return t_Status ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

QueryPreprocessor :: QuadState QueryPreprocessor :: RecursiveRemoveInvariants ( 

	void *a_Context , 
	WmiTreeNode *&a_Node
)
{
	QueryPreprocessor :: QuadState t_Status = State_Undefined ;

	if ( a_Node ) 
	{
		if ( a_Node->GetType () == TypeId_WmiOrNode ) 
		{
			WmiTreeNode *t_Left = a_Node->GetLeft () ;
			WmiTreeNode *t_Right = a_Node->GetRight () ;

			if ( t_Left )
			{
				t_Status = RecursiveRemoveInvariants ( a_Context , t_Left ) ;

				if ( t_Status == State_False )
				{
					TransformOrFalseEvaluation ( 

						a_Node , 
						t_Right
					) ;

					t_Status = QueryPreprocessor :: QuadState :: State_ReEvaluate ;
					return t_Status ;
				}
				else if ( t_Status == State_True )
				{
					return t_Status ;
				}
				else if ( t_Status == State_ReEvaluate )
				{
					t_Status = RecursiveRemoveInvariants ( a_Context, a_Node ) ;
					return t_Status ;
				}
			}

			if ( t_Right )
			{
				t_Status = RecursiveRemoveInvariants ( a_Context , t_Right ) ;

				if ( t_Status == State_False )
				{
					TransformOrFalseEvaluation ( 

						a_Node , 
						t_Left
					) ;

					t_Status = QueryPreprocessor :: QuadState :: State_ReEvaluate ;
					return t_Status ;
				}
				else if ( t_Status == State_True )
				{
					return t_Status ;
				}
				else if ( t_Status == State_ReEvaluate )
				{
					t_Status = RecursiveRemoveInvariants ( a_Context , a_Node ) ;
					return t_Status ;
				}
			}
		}
		else if ( a_Node->GetType () == TypeId_WmiAndNode ) 
		{
			WmiTreeNode *t_Left = a_Node->GetLeft () ;
			WmiTreeNode *t_Right = a_Node->GetRight () ;

			if ( t_Left )
			{
				t_Status = RecursiveRemoveInvariants ( a_Context , t_Left ) ;
				if ( t_Status == State_False )
				{
					return t_Status ;
				}
				else if ( t_Status == State_True )
				{
					TransformAndTrueEvaluation ( 

						a_Node , 
						t_Right
					) ;

					t_Status = QueryPreprocessor :: QuadState :: State_ReEvaluate ;
					return t_Status ;
				}
				else if ( t_Status == State_ReEvaluate )
				{
					t_Status = RecursiveRemoveInvariants ( a_Context , a_Node ) ;
					return t_Status ;
				}
			}

			if ( t_Right )
			{
				t_Status = RecursiveRemoveInvariants ( a_Context , t_Right ) ;

				if ( t_Status == State_False )
				{
					return t_Status ;
				}
				else if ( t_Status == State_True )
				{
					TransformAndTrueEvaluation ( 

						a_Node , 
						t_Left
					) ;

					t_Status = QueryPreprocessor :: QuadState :: State_ReEvaluate ;
					return t_Status ;
				}
				else if ( t_Status == State_ReEvaluate )
				{
					t_Status = RecursiveRemoveInvariants ( a_Context , a_Node ) ;
					return t_Status ;
				}
			}
		}
		else if ( a_Node->GetType () == TypeId_WmiNotNode ) 
		{
// Should never happen, failure in DFN evaluation otherwise
DebugBreak () ;
		}
		else if ( a_Node->GetType () == TypeId_WmiOperatorEqualNode ) 
		{
			WmiTreeNode *t_Left = a_Node->GetLeft () ;
			if ( t_Left )
			{
				t_Status = InvariantEvaluate ( 

					a_Context , 
					a_Node ,
					t_Left
				) ;
			}
			else
			{
// Should never happen, failure in DFN evaluation otherwise
DebugBreak () ;
			}
		}
		else if ( a_Node->GetType () == TypeId_WmiOperatorNotEqualNode ) 
		{
			WmiTreeNode *t_Left = a_Node->GetLeft () ;
			if ( t_Left )
			{
				t_Status = InvariantEvaluate ( 

					a_Context , 
					a_Node ,
					t_Left
				) ;
			}
			else
			{
// Should never happen, failure in DFN evaluation otherwise
DebugBreak () ;
			}
		}
		else if ( a_Node->GetType () == TypeId_WmiOperatorEqualOrGreaterNode ) 
		{
			WmiTreeNode *t_Left = a_Node->GetLeft () ;
			if ( t_Left )
			{
				t_Status = InvariantEvaluate ( 

					a_Context , 
					a_Node ,
					t_Left
				) ;
			}
			else
			{
// Should never happen, failure in DFN evaluation otherwise
DebugBreak () ;
			}
		}
		else if ( a_Node->GetType () == TypeId_WmiOperatorEqualOrLessNode ) 
		{
			WmiTreeNode *t_Left = a_Node->GetLeft () ;
			if ( t_Left )
			{
				t_Status = InvariantEvaluate ( 

					a_Context , 
					a_Node ,
					t_Left
				) ;
			}
			else
			{
// Should never happen, failure in DFN evaluation otherwise
DebugBreak () ;
			}
		}
		else if ( a_Node->GetType () == TypeId_WmiOperatorLessNode ) 
		{
			WmiTreeNode *t_Left = a_Node->GetLeft () ;
			if ( t_Left )
			{
				t_Status = InvariantEvaluate ( 

					a_Context , 
					a_Node ,
					t_Left
				) ;
			}
			else
			{
// Should never happen, failure in DFN evaluation otherwise
DebugBreak () ;
			}
		}
		else if ( a_Node->GetType () == TypeId_WmiOperatorGreaterNode ) 
		{
			WmiTreeNode *t_Left = a_Node->GetLeft () ;
			if ( t_Left )
			{
				t_Status = InvariantEvaluate ( 

					a_Context , 
					a_Node ,
					t_Left
				) ;
			}
			else
			{
// Should never happen, failure in DFN evaluation otherwise
DebugBreak () ;
			}
		}
		else if ( a_Node->GetType () == TypeId_WmiOperatorLikeNode ) 
		{
			WmiTreeNode *t_Left = a_Node->GetLeft () ;
			if ( t_Left )
			{
				t_Status = InvariantEvaluate ( 

					a_Context , 
					a_Node ,
					t_Left
				) ;
			}
			else
			{
// Should never happen, failure in DFN evaluation otherwise
DebugBreak () ;
			}
		}
		else if ( a_Node->GetType () == TypeId_WmiOperatorNotLikeNode ) 
		{
			WmiTreeNode *t_Left = a_Node->GetLeft () ;
			if ( t_Left )
			{
				t_Status = InvariantEvaluate ( 

					a_Context , 
					a_Node ,
					t_Left
				) ;
			}
			else
			{
// Should never happen, failure in DFN evaluation otherwise
DebugBreak () ;
			}
		}
		else if ( a_Node->GetType () == TypeId_WmiOperatorIsANode ) 
		{
			WmiTreeNode *t_Left = a_Node->GetLeft () ;
			if ( t_Left )
			{
				t_Status = InvariantEvaluate ( 

					a_Context , 
					a_Node ,
					t_Left
				) ;
			}
			else
			{
// Should never happen, failure in DFN evaluation otherwise
DebugBreak () ;
			}
		}
		else if ( a_Node->GetType () == TypeId_WmiOperatorNotIsANode ) 
		{
			WmiTreeNode *t_Left = a_Node->GetLeft () ;
			if ( t_Left )
			{
				t_Status = InvariantEvaluate ( 

					a_Context , 
					a_Node ,
					t_Left
				) ;
			}
			else
			{
// Should never happen, failure in DFN evaluation otherwise
DebugBreak () ;
			}
		}
		else
		{
// Should never happen, failure in DFN evaluation otherwise
DebugBreak () ;
		}
	}

	return t_Status ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

QueryPreprocessor :: QuadState QueryPreprocessor :: RemoveInvariants (

	void *a_Context , 
	WmiTreeNode *&a_Root
)
{
	QuadState t_Status = RecursiveRemoveInvariants ( a_Context , a_Root ) ;
	if ( t_Status == State_ReEvaluate )
	{
		t_Status = RemoveInvariants ( a_Context , a_Root ) ;
		if ( t_Status == State_False || t_Status == State_True )
		{
			delete a_Root ;
			a_Root = NULL ;
		}
	}

	return t_Status ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

WmiTriState QueryPreprocessor :: RecursiveInsertNode ( WmiTreeNode *&a_Node , WmiTreeNode *&a_Insertion )
{
	WmiTriState t_Status = WmiTriState :: State_False ;

	if ( a_Node ) 
	{
		if ( a_Node->GetType () == TypeId_WmiAndNode ) 
		{
			WmiTreeNode *t_Left = a_Node->GetLeft () ;

			if ( t_Left )
			{
				t_Status = RecursiveInsertNode ( t_Left , a_Insertion ) ;
				if ( t_Status != WmiTriState :: State_False )
				{
					return t_Status ;
				}
			}

			WmiTreeNode *t_Right = a_Node->GetRight () ;

			if ( t_Right  )
			{
				t_Status = RecursiveInsertNode ( t_Right , a_Insertion ) ;
				if ( t_Status != WmiTriState :: State_False )
				{
					return t_Status ;
				}
			}
		}
		else if ( a_Node->GetType () == TypeId_WmiOrNode ) 
		{
// Should never happen, failure in DFN evaluation otherwise
DebugBreak () ;
		}
		else if ( a_Node->GetType () == TypeId_WmiNotNode ) 
		{
// Should never happen, failure in DFN evaluation otherwise
DebugBreak () ;
		}
		else
		{
// Operator

			WmiValueNode *t_CompareValue = ( WmiValueNode * ) a_Node->GetLeft () ;
			WmiValueNode *t_InsertionValue = ( WmiValueNode * ) a_Insertion->GetLeft () ;
			LONG t_Compare = t_InsertionValue ->ComparePropertyName ( *t_CompareValue ) ;
			if ( t_Compare < 0 )
			{
// Insert to left

				WmiTreeNode *t_Parent = a_Node->GetParent () ;
				WmiTreeNode *t_NewAndNode = new WmiAndNode ( a_Insertion , a_Node , t_Parent ) ;
				if ( t_NewAndNode )
				{
					a_Node->SetParent ( t_NewAndNode ) ;
					a_Insertion->SetParent ( t_NewAndNode ) ;

					if ( t_Parent )
					{
						if ( t_Parent->GetLeft () == a_Node )
						{
							t_Parent->SetLeft ( t_NewAndNode ) ;
						}
						else
						{
							t_Parent->SetRight ( t_NewAndNode ) ;
						}
					}

					a_Node = t_NewAndNode ;

					t_Status = WmiTriState :: State_True ;
				}
				else
				{
					t_Status = WmiTriState :: State_Error ; 
				}
			}
			else
			{
				t_Status = WmiTriState :: State_False  ;
			}
		}
	}
	else
	{
		a_Node = a_Insertion ;

		t_Status = WmiTriState :: State_True ;
	}

	return t_Status ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

WmiTriState  QueryPreprocessor :: InsertNode ( WmiTreeNode *&a_NewRoot , WmiTreeNode *&a_Insertion )
{
	WmiTriState t_Status = RecursiveInsertNode ( a_NewRoot , a_Insertion ) ;
	if ( t_Status == WmiTriState :: State_False  )
	{
// Insert to right

		WmiTreeNode *t_Parent = a_NewRoot->GetParent () ;
		WmiTreeNode *t_NewAndNode = new WmiAndNode ( a_NewRoot , a_Insertion , t_Parent ) ;
		if ( t_NewAndNode )
		{
			a_NewRoot->SetParent ( t_NewAndNode ) ;
			a_Insertion->SetParent ( t_NewAndNode ) ;

			if ( t_Parent )
			{
				if ( t_Parent->GetLeft () == a_NewRoot )
				{
					t_Parent->SetLeft ( t_NewAndNode ) ;
				}
				else
				{
					t_Parent->SetRight ( t_NewAndNode ) ;
				}
			}

			a_NewRoot = t_NewAndNode ;
		}
		else
		{
			return WmiTriState :: State_Error ;
		}
	}

	return WmiTriState :: State_True ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

WmiTriState QueryPreprocessor :: RecursiveSortConditionals ( WmiTreeNode *&a_NewRoot , WmiTreeNode *&a_Node )
{
	WmiTriState t_Status = WmiTriState :: State_False ;

	if ( a_Node ) 
	{
		if ( a_Node->GetType () == TypeId_WmiAndNode ) 
		{
			WmiTreeNode *t_Left = a_Node->GetLeft () ;
			WmiTreeNode *t_Right = a_Node->GetRight () ;

			if ( t_Left )
			{
				t_Status = RecursiveSortConditionals ( a_NewRoot , t_Left  ) ;
				a_Node->SetLeft ( NULL ) ;
				delete t_Left ;
			}

			if ( t_Right  )
			{
				t_Status = RecursiveSortConditionals ( a_NewRoot , t_Right ) ;
				a_Node->SetRight ( NULL ) ;
				delete t_Right ;
			}
		}
		else if ( a_Node->GetType () == TypeId_WmiOrNode ) 
		{
// Should never happen, failure in DFN evaluation otherwise
DebugBreak () ;
		}
		else if ( a_Node->GetType () == TypeId_WmiNotNode ) 
		{
// Should never happen, failure in DFN evaluation otherwise
DebugBreak () ;
		}
		else
		{
// Operator

			WmiTreeNode *t_Parent = a_Node->GetParent () ;
			if ( t_Parent ) 
			{
				if ( t_Parent->GetLeft () == a_Node )
				{
					t_Parent->SetLeft ( NULL ) ;
				}
				else
				{
					t_Parent->SetRight ( NULL ) ;
				}
			}

			a_Node->SetParent ( NULL ) ;

			t_Status = InsertNode ( a_NewRoot , a_Node ) ;

			a_Node = NULL ;
		}		
	}

	return t_Status ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

WmiTriState QueryPreprocessor :: SortConditionals ( WmiTreeNode *&a_Root )
{
	WmiTreeNode *t_NewRoot = NULL ;
	WmiTriState t_Status = RecursiveSortConditionals ( t_NewRoot , a_Root ) ;

    if ( a_Root )
    {
	    WmiTreeNode *t_Parent = a_Root->GetParent () ;
	    if ( t_Parent ) 
	    {
		    if ( t_Parent->GetLeft () == a_Root )
		    {
			    t_Parent->SetLeft ( t_NewRoot ) ;
		    }
		    else
		    {
			    t_Parent->SetRight ( t_NewRoot ) ;
		    }
	    }

	    t_NewRoot->SetParent ( t_Parent ) ;

	    delete a_Root ;
    }

	a_Root = t_NewRoot ;

	return t_Status ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

WmiTriState QueryPreprocessor :: RecursiveSort ( WmiTreeNode *&a_Node )
{
	WmiTriState t_Status = WmiTriState :: State_False ;

	if ( a_Node ) 
	{
		if ( a_Node->GetType () == TypeId_WmiOrNode ) 
		{
			WmiTreeNode *t_Left = a_Node->GetLeft () ;
			WmiTreeNode *t_Right = a_Node->GetRight () ;

			if ( t_Left )
			{
				t_Status = RecursiveSort ( t_Left ) ;
			}

			if ( t_Status == WmiTriState :: State_True )
			{
				if ( t_Right  )
				{
					t_Status = RecursiveSort ( t_Right ) ;
				}
			}
		}
		else if ( a_Node->GetType () == TypeId_WmiAndNode ) 
		{
			t_Status = SortConditionals ( a_Node ) ;
		}
		else if ( a_Node->GetType () == TypeId_WmiNotNode ) 
		{
// Should never happen, failure in DFN evaluation otherwise
DebugBreak () ;
		}
		else
		{
// Single operand
			t_Status = WmiTriState :: State_True ;
		}
	}

	return t_Status ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

WmiTriState QueryPreprocessor :: Sort ( WmiTreeNode *&a_Root )
{
	WmiTriState t_Status = RecursiveSort ( a_Root ) ;
	return t_Status ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

WmiTriState QueryPreprocessor :: RecursiveConvertToRanges ( WmiTreeNode *&a_Node )
{
	WmiTriState t_Status = WmiTriState :: State_True ;

	if ( a_Node ) 
	{
		if ( a_Node->GetType () == TypeId_WmiOrNode ) 
		{
			WmiTreeNode *t_Left = a_Node->GetLeft () ;
			WmiTreeNode *t_Right = a_Node->GetRight () ;

			if ( t_Left )
			{
				t_Status = RecursiveConvertToRanges ( t_Left ) ;
			}

			if ( t_Right  )
			{
				t_Status = RecursiveConvertToRanges ( t_Right ) ;
			}
		}
		else if ( a_Node->GetType () == TypeId_WmiAndNode ) 
		{
			WmiTreeNode *t_Left = a_Node->GetLeft () ;
			WmiTreeNode *t_Right = a_Node->GetRight () ;

			if ( t_Left )
			{
				t_Status = RecursiveConvertToRanges ( t_Left ) ;
			}

			if ( t_Right  )
			{
				t_Status = RecursiveConvertToRanges ( t_Right ) ;
			}
		}
		else if ( a_Node->GetType () == TypeId_WmiNotNode ) 
		{
// Should never happen, failure in DFN evaluation otherwise
DebugBreak () ;
		}
		else if ( a_Node->GetType () == TypeId_WmiOperatorEqualNode ) 
		{
			TransformOperatorToRange ( a_Node ) ; 
			return a_Node ? WmiTriState :: State_True : WmiTriState :: State_Error ;
		}
		else if ( a_Node->GetType () == TypeId_WmiOperatorEqualOrGreaterNode ) 
		{
			TransformOperatorToRange ( a_Node ) ; 
			return a_Node ? WmiTriState :: State_True : WmiTriState :: State_Error ;
		}
		else if ( a_Node->GetType () == TypeId_WmiOperatorEqualOrLessNode ) 
		{
			TransformOperatorToRange ( a_Node ) ; 
			return a_Node ? WmiTriState :: State_True : WmiTriState :: State_Error ;
		}
		else if ( a_Node->GetType () == TypeId_WmiOperatorLessNode ) 
		{
			TransformOperatorToRange ( a_Node ) ; 
			return a_Node ? WmiTriState :: State_True : WmiTriState :: State_Error ;
		}
		else if ( a_Node->GetType () == TypeId_WmiOperatorGreaterNode ) 
		{
			TransformOperatorToRange ( a_Node ) ; 
			return a_Node ? WmiTriState :: State_True : WmiTriState :: State_Error ;
		}
		else if ( a_Node->GetType () == TypeId_WmiOperatorLikeNode ) 
		{
			TransformOperatorToRange ( a_Node ) ; 
			return a_Node ? WmiTriState :: State_True : WmiTriState :: State_Error ;
		}
		else if ( a_Node->GetType () == TypeId_WmiOperatorNotLikeNode ) 
		{
			TransformOperatorToRange ( a_Node ) ; 
			return a_Node ? WmiTriState :: State_True : WmiTriState :: State_Error ;
		}
		else if ( a_Node->GetType () == TypeId_WmiOperatorIsANode ) 
		{
			TransformOperatorToRange ( a_Node ) ; 
			return a_Node ? WmiTriState :: State_True : WmiTriState :: State_Error ;
		}
		else if ( a_Node->GetType () == TypeId_WmiOperatorNotIsANode ) 
		{
			TransformOperatorToRange ( a_Node ) ; 
			return a_Node ? WmiTriState :: State_True : WmiTriState :: State_Error ;
		}
		else
		{
// Should never happen, failure in DFN evaluation otherwise
DebugBreak () ;
		}
	}

	return t_Status ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

WmiTriState QueryPreprocessor :: ConvertToRanges ( WmiTreeNode *&a_Root )
{
	return RecursiveConvertToRanges ( a_Root ) ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

void QueryPreprocessor :: TransformIntersectingRange (

	WmiTreeNode *&a_Node ,
	WmiTreeNode *a_Compare ,
	WmiTreeNode *a_Intersection
)
{
	WmiTreeNode *t_CompareParent = a_Compare->GetParent () ;
	if ( t_CompareParent )
	{
		if ( t_CompareParent->GetLeft () == a_Compare )
		{
			t_CompareParent->SetLeft ( a_Intersection ) ;
		}
		else
		{
			t_CompareParent->SetRight ( a_Intersection ) ;
		}

		a_Intersection->SetParent ( t_CompareParent ) ;

		delete a_Compare ; 
		a_Compare = NULL ;
	}
	else
	{
// Should never happen
DebugBreak () ;
	}
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

void QueryPreprocessor :: TransformNonIntersectingRange (

	WmiTreeNode *&a_Node ,
	WmiTreeNode *a_Compare
) 
{
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

QueryPreprocessor :: QuadState QueryPreprocessor :: RecursiveRemoveNonOverlappingRanges ( WmiTreeNode *&a_Node , WmiTreeNode *&a_Compare )
{
	QueryPreprocessor :: QuadState t_Status = QueryPreprocessor :: QuadState :: State_Undefined ;

	if ( a_Node ) 
	{
		if ( a_Node->GetType () == TypeId_WmiOrNode ) 
		{
			WmiTreeNode *t_Left = a_Node->GetLeft () ;
			if ( t_Left )
			{
				a_Compare = NULL ;
				t_Status = RecursiveRemoveNonOverlappingRanges  ( t_Left , a_Compare ) ;
				if ( t_Status == State_False )
				{
					WmiTreeNode *t_Right = a_Node->GetRight () ;

					TransformOrFalseEvaluation ( 

						a_Node , 
						t_Right
					) ;

					return QueryPreprocessor :: QuadState :: State_ReEvaluate ;
				}
				else if ( t_Status == State_True )
				{
					return t_Status ;
				}
				else if ( t_Status == State_ReEvaluate )
				{
					t_Status = RecursiveRemoveNonOverlappingRanges ( a_Node , a_Compare ) ;
					return t_Status ;
				}
			}

			WmiTreeNode *t_Right = a_Node->GetRight () ;
			if ( t_Right  )
			{
				a_Compare = NULL ;
				t_Status = RecursiveRemoveNonOverlappingRanges  ( t_Right , a_Compare ) ;
				if ( t_Status == State_False )
				{
					WmiTreeNode *t_Left = a_Node->GetLeft () ;

					TransformOrFalseEvaluation ( 

						a_Node , 
						t_Left
					) ;

					return QueryPreprocessor :: QuadState :: State_ReEvaluate ;
				}
				else if ( t_Status == State_True )
				{
					return t_Status ;
				}
				else if ( t_Status == State_ReEvaluate )
				{
					t_Status = RecursiveRemoveNonOverlappingRanges ( a_Node , a_Compare ) ;
					return t_Status ;
				}
			}
		}
		else if ( a_Node->GetType () == TypeId_WmiAndNode ) 
		{
			WmiTreeNode *t_Left = a_Node->GetLeft () ;
			if ( t_Left )
			{
				t_Status = RecursiveRemoveNonOverlappingRanges  ( t_Left , a_Compare ) ;
				if ( t_Status == State_True )
				{
					WmiTreeNode *t_Right = a_Node->GetRight () ;

					TransformAndTrueEvaluation ( 

						a_Node , 
						t_Right
					) ;

					a_Compare = NULL ;

					return QueryPreprocessor :: QuadState :: State_ReEvaluate ;
				}
				else if ( t_Status == State_False )
				{
					return t_Status ;
				}
				else if ( t_Status == State_ReEvaluate )
				{
					t_Status = RecursiveRemoveNonOverlappingRanges ( a_Node , a_Compare ) ;
					return t_Status ;
				}
			}

			WmiTreeNode *t_Right = a_Node->GetRight () ;
			if ( t_Right  )
			{
				t_Status = RecursiveRemoveNonOverlappingRanges  ( t_Right , a_Compare ) ;

				if ( t_Status == State_True )
				{
					WmiTreeNode *t_Left = a_Node->GetLeft () ;

					TransformAndTrueEvaluation ( 

						a_Node , 
						t_Left
					) ;

                    a_Compare = NULL;

					return QueryPreprocessor :: QuadState :: State_ReEvaluate ;
				}
				else if ( t_Status == State_False )
				{
					return t_Status ;
				}
				else if ( t_Status == State_ReEvaluate )
				{
					t_Status = RecursiveRemoveNonOverlappingRanges ( a_Node , a_Compare ) ;
					return t_Status ;
				}
			}
		}
		else if ( a_Node->GetType () == TypeId_WmiNullRangeNode ) 
		{
			WmiRangeNode *t_Node = ( WmiRangeNode * ) a_Node ;

			if ( a_Compare )
			{
				WmiRangeNode *t_Range = ( WmiRangeNode * ) a_Compare ;
				LONG t_Result = t_Node->ComparePropertyName ( *t_Range ) ;
				if ( t_Result == 0 )
				{
					if ( t_Range->GetType () == TypeId_WmiNullRangeNode ) 
					{
						WmiTreeNode *t_Intersection = a_Node->Copy () ;

						TransformIntersectingRange (

							a_Node ,
							a_Compare ,
							t_Intersection
						) ;

						a_Compare = t_Intersection ;

						t_Status = QueryPreprocessor :: QuadState :: State_True ;
					}
					else
					{
// Failure, incompatible types
					}
				}
				else
				{
					a_Compare = a_Node ;
				}
			}
			else
			{
				a_Compare = a_Node ;
			}
		}
		else if ( a_Node->GetType () == TypeId_WmiStringRangeNode ) 
		{
			WmiStringRangeNode *t_Node = ( WmiStringRangeNode * ) a_Node ;

			if ( a_Compare )
			{
				WmiRangeNode *t_Range = ( WmiRangeNode * ) a_Compare ;
				LONG t_Result = t_Node->ComparePropertyName ( *t_Range ) ;
				if ( t_Result == 0 )
				{
					if ( t_Range->GetType () == TypeId_WmiStringRangeNode ) 
					{
						WmiStringRangeNode *t_StringRange = ( WmiStringRangeNode * ) t_Range ;

						WmiStringRangeNode *t_Intersection = NULL ;
						WmiTriState t_Intersected = t_StringRange->GetIntersectingRange (

							*t_Node ,
							t_Intersection
						) ;

						switch ( t_Intersected )
						{
							case WmiTriState :: State_True:
							{
								TransformIntersectingRange (

									a_Node ,
									a_Compare ,
									t_Intersection
								) ;

								a_Compare = t_Intersection ;

								t_Status = QueryPreprocessor :: QuadState :: State_True ;
							}
							break ;

							case WmiTriState :: State_False:
							{
								TransformNonIntersectingRange (

									a_Node ,
									a_Compare
								) ;

								a_Compare = NULL ;

								t_Status = QueryPreprocessor :: QuadState :: State_False ;
							}
							break ;

							default:
							{
								t_Status = QueryPreprocessor :: QuadState :: State_Error ;
							}
							break ;
						}
					}
					else
					{
// Failure, incompatible types
					}
				}
				else
				{
					a_Compare = a_Node ;
				}
			}
			else
			{
				a_Compare = a_Node ;
			}
		}
		else if ( a_Node->GetType () == TypeId_WmiUnsignedIntegerRangeNode ) 
		{
			WmiUnsignedIntegerRangeNode *t_Node = ( WmiUnsignedIntegerRangeNode * ) a_Node ;

			if ( a_Compare )
			{
				WmiRangeNode *t_Range = ( WmiRangeNode * ) a_Compare ;
				LONG t_Result = t_Node->ComparePropertyName ( *t_Range ) ;
				if ( t_Result == 0 )
				{
					if ( t_Range->GetType () == TypeId_WmiUnsignedIntegerRangeNode ) 
					{
						WmiUnsignedIntegerRangeNode *t_IntegerRange = ( WmiUnsignedIntegerRangeNode * ) t_Range ;

						WmiUnsignedIntegerRangeNode *t_Intersection = NULL ;
						WmiTriState t_Intersected = t_IntegerRange->GetIntersectingRange (

							*t_Node ,
							t_Intersection
						) ;

						switch ( t_Intersected )
						{
							case WmiTriState :: State_True:
							{
								TransformIntersectingRange (

									a_Node ,
									a_Compare ,
									t_Intersection
								) ;

								a_Compare = t_Intersection ;

								t_Status = QueryPreprocessor :: QuadState :: State_True ;
							}
							break ;

							case WmiTriState :: State_False:
							{
								TransformNonIntersectingRange (

									a_Node ,
									a_Compare
								) ;

								a_Compare = NULL ;

								t_Status = QueryPreprocessor :: QuadState :: State_False ;
							}
							break; 

							default:
							{
								t_Status = QueryPreprocessor :: QuadState :: State_Error ;
							}
							break ;
						}
					}
					else
					{
// Failure, incompatible types
					}
				}
				else
				{
					a_Compare = a_Node ;
				}
			}
			else
			{
				a_Compare = a_Node ;
			}
		}
		else if ( a_Node->GetType () == TypeId_WmiSignedIntegerRangeNode ) 
		{
			WmiSignedIntegerRangeNode *t_Node = ( WmiSignedIntegerRangeNode * ) a_Node ;

			if ( a_Compare )
			{
				WmiRangeNode *t_Range = ( WmiRangeNode * ) a_Compare ;
				LONG t_Result = t_Node->ComparePropertyName ( *t_Range ) ;
				if ( t_Result == 0 )
				{
					if ( t_Range->GetType () == TypeId_WmiSignedIntegerRangeNode ) 
					{
						WmiSignedIntegerRangeNode *t_IntegerRange = ( WmiSignedIntegerRangeNode * ) t_Range ;

						WmiSignedIntegerRangeNode *t_Intersection = NULL ;
						WmiTriState t_Intersected = t_IntegerRange->GetIntersectingRange (

							*t_Node ,
							t_Intersection
						) ;

						switch ( t_Intersected )
						{
							case WmiTriState :: State_True:
							{
								TransformIntersectingRange (

									a_Node ,
									a_Compare ,
									t_Intersection
								) ;

								a_Compare = t_Intersection ;

								t_Status = QueryPreprocessor :: QuadState :: State_True ;
							}
							break ;

							case WmiTriState :: State_False:
							{
								TransformNonIntersectingRange (

									a_Node ,
									a_Compare
								) ;

								a_Compare = NULL ;

								t_Status = QueryPreprocessor :: QuadState :: State_False ;
							}
							break ;

							default:
							{
								t_Status = QueryPreprocessor :: QuadState :: State_Error ;
							}
							break ;
						}
					}
					else
					{
// Failure, incompatible types
					}
				}
				else
				{
					a_Compare = a_Node ;
				}
			}
			else
			{
				a_Compare = a_Node ;
			}
		}
		else
		{
// Should never happen, failure in DNF evaluation otherwise
DebugBreak () ;
		}
	}

	return t_Status ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

QueryPreprocessor :: QuadState QueryPreprocessor :: RemoveNonOverlappingRanges  ( WmiTreeNode *&a_Root )
{
	WmiTreeNode *t_Compare = NULL ;

	QueryPreprocessor :: QuadState t_Status = RecursiveRemoveNonOverlappingRanges ( a_Root , t_Compare ) ;
	if ( t_Status == State_ReEvaluate )
	{
		t_Status = RemoveNonOverlappingRanges ( a_Root ) ;
		if ( t_Status == State_False || t_Status == State_True )
		{
			delete a_Root ;
			a_Root = NULL ;
		}
	}

	return t_Status ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

void QueryPreprocessor :: CountDisjunctions ( WmiTreeNode *a_Node , ULONG &a_Count ) 
{
	if ( a_Node ) 
	{
		if ( a_Node->GetType () == TypeId_WmiOrNode ) 
		{
			a_Count ++ ;

			WmiTreeNode *t_Left = a_Node->GetLeft () ;
			if ( t_Left )
			{
				CountDisjunctions ( t_Left , a_Count ) ;
			}

			WmiTreeNode *t_Right = a_Node->GetRight () ;
			if ( t_Right  )
			{
				CountDisjunctions ( t_Right , a_Count ) ;
			}
		}
	}
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

WmiTriState QueryPreprocessor :: CreateDisjunctions ( 

	void *a_Context , 
	WmiTreeNode *a_Node , 
	Disjunctions *a_Disjunctions , 
	ULONG a_PropertiesToPartitionCount ,
	BSTR *a_PropertiesToPartition ,
	ULONG &a_DisjunctionIndex
) 
{
	WmiTriState t_Status = WmiTriState :: State_True ;

	if ( a_Node ) 
	{
		if ( a_Node->GetType () == TypeId_WmiOrNode ) 
		{
			WmiTreeNode *t_Left = a_Node->GetLeft () ;
			if ( t_Left )
			{
				t_Status = CreateDisjunctions ( 

					a_Context , 
					t_Left , 
					a_Disjunctions ,
					a_PropertiesToPartitionCount ,
					a_PropertiesToPartition ,
					a_DisjunctionIndex 
				) ;
			}

			if ( t_Status == WmiTriState :: State_True )
			{
				Conjunctions *t_Disjunction = a_Disjunctions->GetDisjunction ( a_DisjunctionIndex ) ;

				for ( ULONG t_Index = 0 ; t_Index < a_PropertiesToPartitionCount ; t_Index ++ )
				{
					if ( t_Disjunction->GetRange ( t_Index ) == NULL )
					{
						WmiRangeNode *t_RangeNode = AllocInfiniteRangeNode ( 

							a_Context ,
							a_PropertiesToPartition [ t_Index ] 
						) ;

						if ( t_RangeNode )
						{
							t_Disjunction->SetRange ( t_Index , t_RangeNode ) ;
						}
						else
						{
							t_Status = WmiTriState :: State_Error ;
							break ;
						}
					}
				}
			}

			a_DisjunctionIndex ++ ;

			if ( t_Status == WmiTriState :: State_True )
			{
				WmiTreeNode *t_Right = a_Node->GetRight () ;
				if ( t_Right )
				{
					t_Status = CreateDisjunctions ( 

						a_Context ,
						t_Right , 
						a_Disjunctions ,
						a_PropertiesToPartitionCount ,
						a_PropertiesToPartition ,
						a_DisjunctionIndex
					) ;
				}

				if ( t_Status == WmiTriState :: State_True )
				{
					Conjunctions *t_Disjunction = a_Disjunctions->GetDisjunction ( a_DisjunctionIndex ) ;

					for ( ULONG t_Index = 0 ; t_Index < a_PropertiesToPartitionCount ; t_Index ++ )
					{
						if ( t_Disjunction->GetRange ( t_Index ) == NULL )
						{
							WmiRangeNode *t_RangeNode = AllocInfiniteRangeNode ( 

								a_Context ,
								a_PropertiesToPartition [ t_Index ] 
							) ;

							if ( t_RangeNode )
							{
								t_Disjunction->SetRange ( t_Index , t_RangeNode ) ;
							}
							else
							{
								t_Status = WmiTriState :: State_Error ; 
							}
						}
					}
				}
			}
		}
		else if ( a_Node->GetType () == TypeId_WmiAndNode ) 
		{
			WmiTreeNode *t_Left = a_Node->GetLeft () ;
			if ( t_Left )
			{
				t_Status = CreateDisjunctions ( 

					a_Context ,
					t_Left , 
					a_Disjunctions ,
					a_PropertiesToPartitionCount ,
					a_PropertiesToPartition ,
					a_DisjunctionIndex
				) ;
			}

			if ( t_Status == WmiTriState :: State_True )
			{
				WmiTreeNode *t_Right = a_Node->GetRight () ;
				if ( t_Right )
				{
					t_Status = CreateDisjunctions ( 

						a_Context , 
						t_Right , 
						a_Disjunctions ,
						a_PropertiesToPartitionCount ,
						a_PropertiesToPartition ,
						a_DisjunctionIndex
					) ;
				}
			}
		}
		else
		{
			Conjunctions *t_Disjunction = a_Disjunctions->GetDisjunction ( a_DisjunctionIndex ) ;
			WmiRangeNode *t_Node = ( WmiRangeNode * ) a_Node ;
			BSTR t_PropertyName = t_Node->GetPropertyName () ;
			for ( ULONG t_Index = 0 ; t_Index < a_PropertiesToPartitionCount ; t_Index ++ )
			{
				if ( _wcsicmp ( t_PropertyName , a_PropertiesToPartition [ t_Index ] ) == 0 )
				{
					WmiRangeNode *t_NodeCopy = ( WmiRangeNode * ) t_Node->Copy () ;
					if ( t_NodeCopy )
					{
						t_Disjunction->SetRange ( t_Index , t_NodeCopy ) ;
					}
					else
					{
						t_Status = WmiTriState :: State_Error ;
					}

					break ;
				}
			}			
		}
	}

	return t_Status ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

WmiTriState QueryPreprocessor :: CreateDisjunctionContainer ( 

	void *a_Context , 
	WmiTreeNode *a_Root , 
	ULONG a_Count , 
	BSTR *a_Container , 
	Disjunctions *&a_Disjunctions
)
{
	WmiTriState t_Status = WmiTriState :: State_True ;

	if ( a_Count && a_Container )
	{
		ULONG t_PropertiesToPartitionCount = a_Count ;
		BSTR *t_PropertiesToPartition = a_Container ;

		ULONG t_Count = 1 ;
		CountDisjunctions ( a_Root , t_Count ) ;
		a_Disjunctions = new Disjunctions ( t_Count , t_PropertiesToPartitionCount ) ;
		if ( a_Disjunctions )
		{
			t_Status = a_Disjunctions->Initialize () ;
			if ( t_Status == WmiTriState :: State_True )
			{
				t_Count = 0 ; 
				t_Status = CreateDisjunctions ( 

					a_Context , 
					a_Root , 
					a_Disjunctions ,
					t_PropertiesToPartitionCount ,
					t_PropertiesToPartition ,
					t_Count
				) ;

				if ( t_Status == WmiTriState :: State_True )
				{
					Conjunctions *t_Disjunction = a_Disjunctions->GetDisjunction ( 0 ) ;

					for ( ULONG t_Index = 0 ; t_Index < t_PropertiesToPartitionCount ; t_Index ++ )
					{
						if ( t_Disjunction->GetRange ( t_Index ) == NULL )
						{
							WmiRangeNode *t_RangeNode = AllocInfiniteRangeNode ( 

								a_Context ,
								t_PropertiesToPartition [ t_Index ] 
							) ;

							if ( t_RangeNode )
							{
								t_Disjunction->SetRange ( t_Index , t_RangeNode ) ;
							}
							else
							{
								t_Status = WmiTriState :: State_Error ;
								break ;
							}
						}
					}
				}
			}
		}
		else
		{
			t_Status = WmiTriState :: State_Error ;
		}
	}

	return t_Status ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

void PrintInit (

	Disjunctions *a_Disjunctions , 
	ULONG a_DisjunctionSetToTestCount ,
	ULONG *a_DisjunctionSetToTest ,
	ULONG a_KeyIndex 
)
{
   	for ( ULONG t_Index = 0 ; t_Index < a_KeyIndex ; t_Index ++ )
    {
        DebugMacro3( 

            WmiDebugLog :: s_WmiDebugLog->Write (  

	            L"    "
            ) ;
        )
    }

	for ( t_Index = 0 ; t_Index < a_DisjunctionSetToTestCount ; t_Index ++ )
    {
        DebugMacro3( 

            WmiDebugLog :: s_WmiDebugLog->Write (  

	            L"%lu", a_DisjunctionSetToTest [ t_Index ] ? 1 : 0
            ) ;
        )
    }

    DebugMacro3( 

        WmiDebugLog :: s_WmiDebugLog->Write (  

	        L"\n"
        ) ;
    )

	for ( t_Index = 0 ; t_Index < a_DisjunctionSetToTestCount ; t_Index ++ )
	{
    	for ( ULONG t_InnerIndex = 0 ; t_InnerIndex < a_KeyIndex ; t_InnerIndex ++ )
        {
            DebugMacro3( 

                WmiDebugLog :: s_WmiDebugLog->Write (  

	                L"    "
                ) ;
            )
        }

		Conjunctions *t_Disjunction = a_Disjunctions->GetDisjunction ( t_Index ) ;
		if ( t_Disjunction )
		{
			t_Disjunction->GetRange ( a_KeyIndex )->Print () ;

			DebugMacro3( 

				WmiDebugLog :: s_WmiDebugLog->Write (  

					L"\n"
				) ;
			)
		}
	}
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

void PrintSortedRange (

	Disjunctions *a_Disjunctions , 
	ULONG a_DisjunctionSetToTestCount ,
	ULONG *a_DisjunctionSetToTest ,
    ULONG *a_OriginToSorted ,
	ULONG a_KeyIndex ,
    WmiRangeNode **a_RangeTable
)
{
	for ( ULONG t_Index = 0 ; t_Index < a_DisjunctionSetToTestCount ; t_Index ++ )
	{
   		if ( a_RangeTable [ t_Index ] )
        {
    	    for ( ULONG t_InnerIndex = 0 ; t_InnerIndex < a_KeyIndex ; t_InnerIndex ++ )
            {
                DebugMacro3( 

                    WmiDebugLog :: s_WmiDebugLog->Write (  

	                    L"%lu    ", t_Index
                    ) ;
                )
            }

            if ( a_DisjunctionSetToTest [ a_OriginToSorted [ t_Index ] ] )
            {
                DebugMacro3( 

                    WmiDebugLog :: s_WmiDebugLog->Write (  

	                    L"In "
                    ) ;
				)
            }
            else
            {
                DebugMacro3( 

                    WmiDebugLog :: s_WmiDebugLog->Write (  

	                    L"Out "
                    ) ;
				)
            }

		    a_RangeTable [ t_Index ]->Print () ;

            DebugMacro3( 

                WmiDebugLog :: s_WmiDebugLog->Write (  

	                L"\n"
                ) ;
            )
        }
	}
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

void PrintOverlap (

	ULONG a_DisjunctionSetToTestCount ,
   	ULONG *a_DisjunctionSetToTest ,
	ULONG *a_SortedDisjunctionSetToTest ,
    ULONG *a_OverlappingIndex ,
  	ULONG a_KeyIndex 
)
{
	for ( ULONG t_Index = 0 ; t_Index < a_KeyIndex ; t_Index ++ )
    {
DebugMacro3( 

    WmiDebugLog :: s_WmiDebugLog->Write (  

	    L"    "
    ) ;
)
    }

	for ( t_Index = 0 ; t_Index < a_DisjunctionSetToTestCount ; t_Index ++ )
    {
DebugMacro3( 

    if ( a_DisjunctionSetToTest [ t_Index ] )
    {
        WmiDebugLog :: s_WmiDebugLog->Write (  

	        L"%lu ",  a_OverlappingIndex [ t_Index ]
        ) ;
    }
    else
    {
        WmiDebugLog :: s_WmiDebugLog->Write (  

	        L"X "
        ) ;
    }
)
    }

DebugMacro3( 

    WmiDebugLog :: s_WmiDebugLog->Write (  

	    L"\n"
    ) ;
)
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

void QueryPreprocessor :: RecursiveQuickSort (

	WmiRangeNode **a_Array , 
    ULONG *a_UnsortedOrder ,
	ULONG a_Lower , 
	ULONG a_Upper
)
{
	if ( a_Lower <= a_Upper )
	{
		ULONG t_LeftIndex = a_Lower ; 
		ULONG t_RightIndex = a_Upper ;

		while ( true )
		{
			while ( ( t_LeftIndex < t_RightIndex ) && CompareLessOrEqualRangeNode ( a_Array [ t_LeftIndex ]  , a_Array [ a_Lower - 1 ] ) )
			{
				t_LeftIndex ++ ;
			}

			while ( ( t_LeftIndex < t_RightIndex ) && CompareLessOrEqualRangeNode ( a_Array [ a_Lower - 1 ]  , a_Array [ t_RightIndex ] ) )
			{
				t_RightIndex -- ;
			}

			if ( t_LeftIndex < t_RightIndex ) 
			{
				WmiRangeNode *t_Temp = a_Array [ t_LeftIndex ] ;
				a_Array [ t_LeftIndex ] = a_Array [ t_RightIndex ] ;
				a_Array [ t_RightIndex ] = t_Temp ;

				ULONG t_Val = a_UnsortedOrder [ t_LeftIndex ] ;
				a_UnsortedOrder [ t_LeftIndex ] = a_UnsortedOrder [ t_RightIndex ];
				a_UnsortedOrder [ t_RightIndex ] = t_Val ;
			}
			else
			{
				break ;
			}
		}

		LONG t_Compare = CompareLessOrEqualRangeNode ( a_Array [ t_LeftIndex ] , a_Array [ a_Lower - 1 ] ) ;
		if ( t_Compare )
		{
			WmiRangeNode *t_Temp = a_Array [ t_LeftIndex ] ;
			a_Array [ t_LeftIndex ] = a_Array [ a_Lower - 1 ] ;
			a_Array [ a_Lower - 1 ] = t_Temp ;

			ULONG t_Val = a_UnsortedOrder [ t_LeftIndex ] ;
			a_UnsortedOrder [ t_LeftIndex ] = a_UnsortedOrder [ a_Lower - 1 ];
			a_UnsortedOrder [ a_Lower - 1 ] = t_Val ;
		}

		RecursiveQuickSort ( 

			a_Array , 
			a_UnsortedOrder ,
			a_Lower , 
			t_LeftIndex - 1 
		) ;

 		RecursiveQuickSort ( 

			a_Array  , 
			a_UnsortedOrder ,
			t_LeftIndex + 1 , 
			a_Upper
		) ;
	}
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

void QueryPreprocessor :: QuickSort (

	WmiRangeNode **a_Array , 
    ULONG *a_UnsortedOrder ,
	ULONG a_Size
)
{
	RecursiveQuickSort ( a_Array , a_UnsortedOrder , 1 , a_Size - 1 ) ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

void QueryPreprocessor :: SortRanges (

	ULONG t_DisjunctionCount ,
    ULONG *t_OriginToSorted ,
	WmiRangeNode **t_RangeTable 
)
{
	QuickSort (	t_RangeTable , t_OriginToSorted , t_DisjunctionCount ) ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

WmiTriState QueryPreprocessor :: RemoveOverlaps (

	ULONG *a_DisjunctionSetToTest ,
	ULONG a_DisjunctionCount ,
	ULONG *a_OverlappingIndex ,
    ULONG *a_OriginToSorted ,
	WmiRangeNode **a_RangeTable 
)
{
	WmiTriState t_Status = WmiTriState :: State_True ;

/*
 *  Remove Overlaps
 */

	ULONG t_InnerIndex = 0 ;
	ULONG t_OuterIndex = 1 ;

	while ( ( t_Status != WmiTriState :: State_Error ) && ( t_OuterIndex < a_DisjunctionCount ) )
	{
		WmiRangeNode *t_LeftRange = a_RangeTable [ t_OuterIndex ] ;
		WmiRangeNode *t_RightRange = a_RangeTable [ t_InnerIndex ] ;

		if ( a_OverlappingIndex [ t_OuterIndex ] != a_OverlappingIndex [ t_InnerIndex ] )
		{
			if ( t_LeftRange && t_RightRange )
			{
				if ( ( t_LeftRange->GetType () == TypeId_WmiStringRangeNode ) && ( t_RightRange->GetType () == TypeId_WmiStringRangeNode ) )
				{
					WmiStringRangeNode *t_LeftString = ( WmiStringRangeNode * ) t_LeftRange ;
					WmiStringRangeNode *t_RightString = ( WmiStringRangeNode * ) t_RightRange ;
    				WmiStringRangeNode *t_OverLap = NULL ;

					t_Status = t_LeftString->GetOverlappingRange ( *t_RightString , t_OverLap ) ;
					if ( t_Status == WmiTriState :: State_True )
					{
DebugMacro3( 

	WmiDebugLog :: s_WmiDebugLog->Write (  

		L"Overlap\n"
	) ;
)

						delete a_RangeTable [ t_OuterIndex ] ;
						a_RangeTable [ t_OuterIndex ] = t_OverLap ;

						delete a_RangeTable [ t_InnerIndex ] ;
						a_RangeTable [ t_InnerIndex ] = NULL ;

						a_OverlappingIndex [ t_InnerIndex ] = t_OuterIndex ;
					}
					else
					{
DebugMacro3( 

	WmiDebugLog :: s_WmiDebugLog->Write (  

		L"Non Overlap\n"
	) ;
)
					}
				}
				else if ( ( t_LeftRange->GetType () == TypeId_WmiUnsignedIntegerRangeNode ) && ( t_RightRange->GetType () == TypeId_WmiUnsignedIntegerRangeNode ) )
				{
					WmiUnsignedIntegerRangeNode *t_LeftInteger = ( WmiUnsignedIntegerRangeNode * ) t_LeftRange ;
					WmiUnsignedIntegerRangeNode *t_RightInteger = ( WmiUnsignedIntegerRangeNode * ) t_RightRange ;
    				WmiUnsignedIntegerRangeNode *t_OverLap = NULL ;

					t_Status = t_LeftInteger->GetOverlappingRange ( *t_RightInteger , t_OverLap ) ;
					if ( t_Status == WmiTriState :: State_True )
					{
DebugMacro3( 

	WmiDebugLog :: s_WmiDebugLog->Write (  

		L"Overlap\n"
	) ;
)
						delete a_RangeTable [ t_OuterIndex ] ;
						a_RangeTable [ t_OuterIndex ] = t_OverLap ;

						delete a_RangeTable [ t_InnerIndex ] ;
						a_RangeTable [ t_InnerIndex ] = NULL ;
						
						a_OverlappingIndex [ t_InnerIndex ] = t_OuterIndex ;
                    }
					else
					{
DebugMacro3( 

	WmiDebugLog :: s_WmiDebugLog->Write (  

		L"Non Overlap\n"
	) ;
)
					}
				}
				else if ( ( t_LeftRange->GetType () == TypeId_WmiSignedIntegerRangeNode ) && ( t_RightRange->GetType () == TypeId_WmiSignedIntegerRangeNode ) )
				{
					WmiSignedIntegerRangeNode *t_LeftInteger = ( WmiSignedIntegerRangeNode * ) t_LeftRange ;
					WmiSignedIntegerRangeNode *t_RightInteger = ( WmiSignedIntegerRangeNode * ) t_RightRange ;
    				WmiSignedIntegerRangeNode *t_OverLap = NULL ;

					t_Status = t_LeftInteger->GetOverlappingRange ( *t_RightInteger , t_OverLap ) ;
					if ( t_Status == WmiTriState :: State_True )
					{
DebugMacro3( 

	WmiDebugLog :: s_WmiDebugLog->Write (  

		L"Overlap\n"
	) ;
)
						delete a_RangeTable [ t_OuterIndex ] ;
						a_RangeTable [ t_OuterIndex ] = t_OverLap ;

						delete a_RangeTable [ t_InnerIndex ] ;
						a_RangeTable [ t_InnerIndex ] = NULL ;
						
						a_OverlappingIndex [ t_InnerIndex ] = t_OuterIndex ;
                    }
					else
					{
DebugMacro3( 

	WmiDebugLog :: s_WmiDebugLog->Write (  

		L"Non Overlap\n"
	) ;
)
					}
				}
				else
				{
// Failure
					t_Status = WmiTriState :: State_Error ;  
				}
			}
		}

		t_InnerIndex ++ ;
		t_OuterIndex ++ ;
	}

	for ( LONG t_Index = a_DisjunctionCount - 1 ; t_Index >= 0 ; t_Index -- )
	{
		if ( t_Index < a_OverlappingIndex [ t_Index ] )
		{
			a_OverlappingIndex [ t_Index ] = a_OverlappingIndex [ a_OverlappingIndex [ t_Index ] ] ;
		}
	}

	return t_Status ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

WmiTriState QueryPreprocessor :: RecursivePartitionSet ( 

	Disjunctions *a_Disjunctions , 
	PartitionSet *&a_Partition , 
	ULONG a_DisjunctionSetToTestCount ,
	ULONG *a_DisjunctionSetToTest ,
	ULONG a_KeyIndex 
)
{
	WmiTriState t_Status = WmiTriState :: State_True ;

	if ( a_KeyIndex < a_Disjunctions->GetConjunctionCount () )
	{
		ULONG *t_OverlappingIndex = new ULONG [ a_DisjunctionSetToTestCount ] ;
        ULONG *t_OriginToSorted = new ULONG [ a_DisjunctionSetToTestCount ] ;
		WmiRangeNode **t_RangeTable = new WmiRangeNode * [ a_DisjunctionSetToTestCount ] ;

		if ( t_OverlappingIndex && t_OriginToSorted && t_RangeTable )
		{
			for ( ULONG t_Index = 0 ; t_Index < a_DisjunctionSetToTestCount ; t_Index ++ )
			{
				Conjunctions *t_Disjunction = a_Disjunctions->GetDisjunction ( a_DisjunctionSetToTest [ t_Index ] ) ;
				t_RangeTable [ t_Index ] = ( WmiRangeNode * ) t_Disjunction->GetRange ( a_KeyIndex )->Copy () ;
				t_OverlappingIndex [ t_Index ] = t_Index ;
				t_OriginToSorted [ t_Index ] = t_Index ;
			}

// Sort Partitions

			SortRanges (

				a_DisjunctionSetToTestCount ,
				t_OriginToSorted ,
				t_RangeTable 
			) ;

			t_Status = RemoveOverlaps (

				a_DisjunctionSetToTest ,
				a_DisjunctionSetToTestCount ,
				t_OverlappingIndex ,
				t_OriginToSorted ,
				t_RangeTable 
			) ;

			if ( t_Status != WmiTriState :: State_Error )
			{
				ULONG t_PartitionCount = 0 ;
				for ( t_Index = 0 ; t_Index < a_DisjunctionSetToTestCount ; t_Index ++ )
				{
					if ( t_RangeTable [ t_Index ] )
					{
						t_PartitionCount ++ ;
					}
				}

				t_Status = a_Partition->Initialize ( t_PartitionCount ) ;
				if ( t_Status == WmiTriState :: State_True )
				{
					ULONG t_PartitionIndex = 0 ;
					for ( t_Index = 0 ; t_Index < a_DisjunctionSetToTestCount; t_Index ++ )
					{
						WmiRangeNode *t_Range = t_RangeTable [ t_Index ] ;
						if ( t_Range )
						{
							PartitionSet *t_Partition = new PartitionSet ;
							if ( t_Partition )
							{
								a_Partition->SetPartition ( t_PartitionIndex , t_Partition ) ;

								WmiRangeNode *t_Copy = ( WmiRangeNode * ) t_Range->Copy () ;
								if ( t_Copy )
								{
									t_Partition->SetRange ( t_Copy ) ;
									t_Partition->SetKeyIndex ( a_KeyIndex ) ;
									t_PartitionIndex ++ ;
								}
								else
								{
									t_Status = WmiTriState :: State_Error ; 
									break ;
								}
							}
							else
							{
								t_Status = WmiTriState :: State_Error ; 
								break ;
							}
						}
					}
				}

				if ( t_Status == WmiTriState :: State_True )
				{
/*
 *  Outer Index is the range order
 */
					ULONG t_PartitionIndex = 0 ;

/*
 *	Array allocation has max defined by function arg.
 */

					ULONG *t_DisjunctionSetToTest = new ULONG [ a_DisjunctionSetToTestCount ] ;
					if ( t_DisjunctionSetToTest )
					{
						ULONG t_OuterIndex = 0 ;
						while ( t_Status && ( t_OuterIndex < a_DisjunctionSetToTestCount ) )
						{
							BOOL t_Found = FALSE ;

							ULONG t_DisjunctionSetToTestCount = 0 ;

							if ( t_RangeTable [ t_OuterIndex ] )
							{
/*
 * Inner index matches the overlaps
 */

								LONG t_InnerIndex = t_OuterIndex ;
								while ( t_InnerIndex >= 0 )
								{
									if ( t_OverlappingIndex [ t_OuterIndex ] == t_OverlappingIndex [ t_InnerIndex ] )
									{
										t_DisjunctionSetToTest [ t_DisjunctionSetToTestCount ] = a_DisjunctionSetToTest [ t_OriginToSorted [ t_InnerIndex ] ] ;
										t_DisjunctionSetToTestCount ++ ;
										t_Found = TRUE ;
									}
									else
									{
										break ;
									}

									t_InnerIndex -- ;
								}
							}

    						if ( t_Found )
							{
								PartitionSet *t_Partition = a_Partition->GetPartition ( t_PartitionIndex ) ;
								if ( t_Partition )
								{
									t_Status = RecursivePartitionSet (

										a_Disjunctions ,
										t_Partition ,
										t_DisjunctionSetToTestCount ,
										t_DisjunctionSetToTest ,
										a_KeyIndex + 1
									) ;

									t_PartitionIndex ++ ;
								}
							}

							t_OuterIndex ++ ;
						}

						delete [] t_DisjunctionSetToTest ;
					}
					else
					{
						t_Status = WmiTriState :: State_Error ; 
					}
				}
			}
			else
			{
				t_Status = WmiTriState :: State_Error ; 
			}

			for ( t_Index = 0 ; t_Index < a_DisjunctionSetToTestCount ; t_Index ++ )
			{
				if ( t_RangeTable [ t_Index ] )
				{
					delete t_RangeTable [ t_Index ] ;
				}
			}
		}
		else
		{
			t_Status = WmiTriState :: State_Error ; 
		}

		delete [] t_RangeTable ;
		delete [] t_OverlappingIndex ;
		delete [] t_OriginToSorted ;
	}

	return t_Status ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

WmiTriState QueryPreprocessor :: CreatePartitionSet ( Disjunctions *a_Disjunctions , PartitionSet *&a_Partition )
{
	WmiTriState t_Status = WmiTriState :: State_False ;

	a_Partition = NULL ;

	ULONG t_DisjunctionCount = a_Disjunctions->GetDisjunctionCount () ;
	ULONG *t_DisjunctionSetToTest = new ULONG [ t_DisjunctionCount ] ;
	if ( t_DisjunctionSetToTest )
	{
		for ( ULONG t_Index = 0 ; t_Index < t_DisjunctionCount ; t_Index ++ )
		{
			t_DisjunctionSetToTest [ t_Index ] = t_Index ;
		}

		a_Partition = new PartitionSet ;
		if ( a_Partition )
		{
			t_Status = RecursivePartitionSet (

				a_Disjunctions ,
				a_Partition ,
				t_DisjunctionCount ,
				t_DisjunctionSetToTest ,
				0
			) ;
		}
		else
		{
			t_Status = WmiTriState :: State_Error ;
		}

		delete [] t_DisjunctionSetToTest ;
	}
	else
	{
		t_Status = WmiTriState :: State_Error ;
	}

	return t_Status;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

QueryPreprocessor :: QuadState QueryPreprocessor :: PreProcess ( 

	void *a_Context , 
	IWbemQuery *a_QueryAnalysis , 
	WmiTreeNode *a_Root ,
	ULONG a_Count , 
	BSTR *a_Container , 
	PartitionSet *&a_Partition
)
{
	QuadState t_State = State_True ;

    if ( a_Root != NULL )
    {
        WmiTreeNode *t_Root = a_Root->Copy () ;
		if ( t_Root )
		{
			t_State = RemoveInvariants ( a_Context , t_Root ) ;

			switch ( t_State )
			{
				case QueryPreprocessor :: QuadState :: State_True:
				{		
DebugMacro3( 

	WmiDebugLog :: s_WmiDebugLog->Write (  

		L"Expression = TRUE "
	) ;
)
				}
				break ;

				case QueryPreprocessor :: QuadState :: State_False:
				{
DebugMacro3( 

	WmiDebugLog :: s_WmiDebugLog->Write (  

		L"Expression = FALSE "
	) ;
)
				}
				break ;

				case QueryPreprocessor :: QuadState :: State_Undefined:
				{
					PrintTree ( t_Root ) ;
						
					WmiTriState t_Status = Sort ( t_Root ) ;
					if ( t_Status == WmiTriState :: State_True )
					{
						PrintTree ( t_Root ) ;

						t_Status = ConvertToRanges ( t_Root ) ;
					}

					if ( t_Status == WmiTriState :: State_True )
					{
						PrintTree ( t_Root ) ;

						switch ( t_State = RemoveNonOverlappingRanges ( t_Root ) )
						{
							case QueryPreprocessor :: QuadState :: State_True :
							{		
DebugMacro3( 

	WmiDebugLog :: s_WmiDebugLog->Write (  

		L"Expression = TRUE"
	) ;
)
							}
							break ;

							case QueryPreprocessor :: QuadState :: State_False:
							{
DebugMacro3( 

	WmiDebugLog :: s_WmiDebugLog->Write (  

		L"Expression = FALSE"
	) ;
)
							}
							break ;

							case QueryPreprocessor :: QuadState :: State_Undefined:
							{
								PrintTree ( t_Root ) ;

								t_State =  State_Error ;

								Disjunctions *t_Disjunctions = NULL ;

								t_Status = CreateDisjunctionContainer ( a_Context , t_Root , a_Count , a_Container , t_Disjunctions ) ;
								if ( t_Status == WmiTriState :: State_True )
								{
									PartitionSet *t_Partition = NULL ;
									t_Status = CreatePartitionSet ( t_Disjunctions , t_Partition ) ;
									if ( t_Status == WmiTriState :: State_True )
									{
										t_State =  State_Undefined ; 
										a_Partition = t_Partition ;
									}
									else
									{
										delete t_Partition ;
									}

									delete t_Disjunctions ;
								}
								else
								{
									t_State = QueryPreprocessor :: QuadState :: State_Error ;
								}
							}
							break ;

							case QueryPreprocessor :: QuadState :: State_ReEvaluate:
							default:
							{
							}
							break ;
						}
					}
				}
				break ;

				case QueryPreprocessor :: QuadState :: State_ReEvaluate:
				default:
				{
				}
				break ;
			}

			delete t_Root ;
		}
		else
		{
			t_State = State_Error ;
		}
    }

	return t_State ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

QueryPreprocessor :: QuadState QueryPreprocessor :: PreProcess (

	void *a_Context ,																
	IWbemQuery *a_QueryAnalysis ,
	WmiTreeNode *&a_Root 
)
{
	QuadState t_State = State_Error ;

	SWbemRpnEncodedQuery *t_Expression = NULL ;

	HRESULT t_Result = a_QueryAnalysis->GetAnalysis (

		WMIQ_ANALYSIS_RPN_SEQUENCE ,
        0 ,
        ( void ** ) & t_Expression
	) ;

	if ( SUCCEEDED ( t_Result ) )
	{
		BOOL t_Status = Evaluate ( 
		
			a_Context , 
			( t_Expression->m_ppRpnWhereClause ) , 
			( t_Expression->m_uWhereClauseSize ) , 
			& a_Root
		) ;

		if ( t_Status )
		{
			t_State = State_True ;

			PrintTree ( a_Root ) ;
        
			t_State = DisjunctiveNormalForm ( a_Root ) ;

			PrintTree ( a_Root ) ;
		}

		a_QueryAnalysis->FreeMemory ( t_Expression ) ;
	}

	return t_State ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

QueryPreprocessor :: QuadState QueryPreprocessor :: Query ( 

	BSTR a_Query ,
	IWbemQuery *a_QueryAnalysis
)
{
	QuadState t_State = State_Error ;

	ULONG t_Array [] = { 

		WMIQ_LF1_BASIC_SELECT ,
		WMIQ_LF2_CLASS_NAME_IN_QUERY ,
		WMIQ_LF3_STRING_CASE_FUNCTIONS ,
		WMIQ_LF4_PROP_TO_PROP_TESTS ,
		WMIQ_LF8_ISA ,
		WMIQ_LF9_THIS ,
		WMIQ_LF26_LIKE
	} ;
 
	ULONG t_ArraySize = sizeof ( t_Array ) / sizeof ( ULONG ) ;

    HRESULT t_Result = a_QueryAnalysis->SetLanguageFeatures (

        0 ,
        t_ArraySize ,
        t_Array
	) ;

	if ( SUCCEEDED ( t_Result ) )
	{
		t_Result = a_QueryAnalysis->Parse ( L"WQL" , a_Query , 0 ) ;
		if ( SUCCEEDED ( t_Result ) )
		{
			t_State = State_True ;
		}
	}

	return t_State ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

QueryPreprocessor :: QueryPreprocessor () 
{
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

QueryPreprocessor :: ~QueryPreprocessor () 
{
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

#define SYSTEM_PROPERTY_DYNASTY				L"__DYNASTY"
#define SYSTEM_PROPERTY_DERIVATION			L"__DERIVATION"
#define SYSTEM_PROPERTY_GENUS				L"__GENUS"
#define SYSTEM_PROPERTY_NAMESPACE			L"__NAMESPACE"
#define SYSTEM_PROPERTY_PROPERTY_COUNT		L"__PROPERTY_COUNT"
#define SYSTEM_PROPERTY_SERVER				L"__SERVER"
#define SYSTEM_PROPERTY_RELPATH				L"__RELPATH"
#define SYSTEM_PROPERTY_PATH				L"__PATH"

#define SYSTEM_PROPERTY_CLASS				L"__CLASS"
#define SYSTEM_PROPERTY_SUPERCLASS			L"__SUPERCLASS"
#define SYSTEM_PROPERTY_THIS				L"__THIS"

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

WmiTreeNode *QueryPreprocessor :: AllocTypeNode ( 

	void *a_Context ,
	BSTR a_PropertyName , 
	VARIANT &a_Variant , 
	WmiValueNode :: WmiValueFunction a_PropertyFunction ,
	WmiValueNode :: WmiValueFunction a_ConstantFunction ,
	WmiTreeNode *a_Parent 
)
{
	WmiTreeNode *t_Node = NULL ;

	VARTYPE t_VarType = VT_NULL ;

	if ( *a_PropertyName == L'_' )
	{
// System property

		if ( _wcsicmp ( a_PropertyName , SYSTEM_PROPERTY_SUPERCLASS ) == 0 )
		{
			t_Node = new WmiStringNode ( 

				a_PropertyName , 
				a_Variant.bstrVal , 
				a_PropertyFunction ,
				a_ConstantFunction ,
				0xFFFFFFFF ,
				a_Parent 
			) ;
		}
		else if ( _wcsicmp ( a_PropertyName , SYSTEM_PROPERTY_THIS ) == 0 )
		{
			t_Node = new WmiStringNode ( 

				a_PropertyName , 
				a_Variant.bstrVal , 
				a_PropertyFunction ,
				a_ConstantFunction ,
				0xFFFFFFFF ,
				a_Parent 
			) ;
		}
		else if ( _wcsicmp ( a_PropertyName , SYSTEM_PROPERTY_CLASS ) == 0 )
		{
			t_Node = new WmiStringNode ( 

				a_PropertyName , 
				a_Variant.bstrVal , 
				a_PropertyFunction ,
				a_ConstantFunction ,
				0xFFFFFFFF ,
				a_Parent 
			) ;
		}
	}

	return t_Node ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\provsubsys\decoupledadaptor\include\cglobals.h ===
/*++

Copyright (C) 1996-2001 Microsoft Corporation

Module Name:

	Globals.h

Abstract:


History:

--*/

#ifndef _CommonGlobals_H
#define _CommonGlobals_H

#include <pssException.h>
#include <HelperFuncs.h>
#include <Allocator.h>
#include <BasicTree.h>
#include <Queue.h>
#include <PQueue.h>
#include <ReaderWriter.h>
#include <Cache.h>
#include <locks.h>
/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

#define SYNCPROV_BATCH_TRANSMIT_SIZE 0x40000

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

typedef WmiContainerController <void *>										CWbemGlobal_VoidPointerController ;
typedef CWbemGlobal_VoidPointerController :: Container						CWbemGlobal_VoidPointerController_Container ;
typedef CWbemGlobal_VoidPointerController :: Container_Iterator				CWbemGlobal_VoidPointerController_Container_Iterator ;
typedef CWbemGlobal_VoidPointerController :: WmiContainerElement			VoidPointerContainerElement ;

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

#define CWbemGlobal_IWmiObjectSinkController						CWbemGlobal_VoidPointerController
#define CWbemGlobal_IWmiObjectSinkController_Container				CWbemGlobal_VoidPointerController_Container
#define CWbemGlobal_IWmiObjectSinkController_Container_Iterator		CWbemGlobal_VoidPointerController_Container_Iterator
#define ObjectSinkContainerElement									VoidPointerContainerElement

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

#define MASK_PROVIDER_BINDING_BIND 1

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

extern void DumpThreadTokenSecurityDescriptor () ;

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

#define HRESULT_ERROR_MASK (0x0000FFFF)
#define HRESULT_ERROR_FUNC(X) (X&HRESULT_ERROR_MASK)
#define HRESULT_FACILITY_MASK (0x0FFF0000)
#define HRESULT_FACILITY_FUNC(X) ((X&HRESULT_FACILITY_MASK)>>16)
#define HRESULT_SEVERITY_MASK (0xC0000000)
#define HRESULT_SEVERITY_FUNC(X) ((X&HRESULT_SEVERITY_MASK)>>30)

#define HRESULT_ERROR_SERVER_UNAVAILABLE	1722L
#define HRESULT_ERROR_CALL_FAILED_DNE		1727L

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

#define MAX_PROXIES 512

class ProxyContainer
{
private:

	WmiAllocator &m_Allocator ;
#if 1
	WmiStack <IUnknown *,8> **m_ContainerArray ;
#else
	WmiQueue <IUnknown *,8> **m_ContainerArray ;
#endif
	CriticalSection m_CriticalSection ;
	ULONG m_TopSize ;
	ULONG m_CurrentSize ;
	ULONG m_ProxyCount ;
	BOOL m_Initialized ;

public:

	ProxyContainer ( 

		WmiAllocator &a_Allocator ,
		ULONG a_ProxyCount ,
		ULONG a_TopSize 

	) : m_Allocator ( a_Allocator ) ,
		m_ContainerArray ( NULL ) ,
		m_TopSize ( a_TopSize ) ,
		m_CurrentSize ( 0 ) ,
		m_ProxyCount ( a_ProxyCount ) ,
		m_Initialized ( FALSE ) ,
		m_CriticalSection(NOTHROW_LOCK)
	{
	}

	~ProxyContainer ()
	{
		UnInitialize () ;
	}

	WmiStatusCode Initialize () 
	{
		WmiStatusCode t_StatusCode = e_StatusCode_Success ;

#if 1
		m_ContainerArray = new WmiStack <IUnknown *,8> * [ m_ProxyCount ] ;
#else
		m_ContainerArray = new WmiQueue <IUnknown *,8> * [ m_ProxyCount ] ;
#endif
		if ( m_ContainerArray )
		{
			t_StatusCode = WmiHelper :: InitializeCriticalSection ( & m_CriticalSection ) ;
			if ( t_StatusCode == e_StatusCode_Success ) 
			{
				m_Initialized = TRUE ;

 				for ( ULONG t_Index = 0 ; t_Index < m_ProxyCount ; t_Index ++ )
				{
					m_ContainerArray [ t_Index ] = NULL ;
				}

				for ( t_Index = 0 ; t_Index < m_ProxyCount ; t_Index ++ )
				{
#if 1
					WmiStack <IUnknown *,8> *t_Container = m_ContainerArray [ t_Index ] = new WmiStack <IUnknown *,8> ( m_Allocator ) ;
#else
					WmiQueue <IUnknown *,8> *t_Container = m_ContainerArray [ t_Index ] = new WmiQueue <IUnknown *,8> ( m_Allocator ) ;
#endif

					if ( t_Container )
					{
						t_StatusCode = t_Container->Initialize () ;
						if ( t_StatusCode != e_StatusCode_Success )
						{
							break ;
						}
					}
					else
					{
						t_StatusCode = e_StatusCode_OutOfMemory ;

						break ;
					}
				}
			}
		}
		else
		{
			t_StatusCode = e_StatusCode_OutOfMemory ;
		}

		return t_StatusCode ;
	}

	WmiStatusCode UnInitialize ()
	{
		WmiStatusCode t_StatusCode = e_StatusCode_Success ;

		if ( m_ContainerArray )
		{
			for ( ULONG t_Index = 0 ; t_Index < m_ProxyCount ; t_Index ++ )
			{
#if 1
				WmiStack <IUnknown *,8> *t_Container = m_ContainerArray [ t_Index ] ;
#else
				WmiQueue <IUnknown *,8> *t_Container = m_ContainerArray [ t_Index ] ;
#endif
				if ( t_Container )
				{
					IUnknown *t_Top = NULL ;
					WmiStatusCode t_StatusCode ;
					while ( ( t_StatusCode = t_Container->Top ( t_Top ) ) == e_StatusCode_Success )
					{
						t_Top->Release () ;
#if 1
						t_StatusCode = t_Container->Pop () ;
#else
						t_StatusCode = t_Container->DeQueue () ;
#endif
					}

					t_StatusCode = t_Container->UnInitialize () ;

					delete t_Container ;
				}
			}

			delete [] m_ContainerArray ;

			m_ContainerArray = NULL ;
		}

		if ( m_Initialized )
		{
			WmiHelper :: DeleteCriticalSection ( & m_CriticalSection ) ;
			m_Initialized = FALSE ;
		}

		return t_StatusCode ;
	}

	WmiStatusCode Return ( 

		IUnknown *a_Element ,
		ULONG a_Index
	)
	{
#if 1
		WmiStack <IUnknown *,8> *t_Container = m_ContainerArray [ a_Index ] ;
		return t_Container->Push ( a_Element ) ;
#else
		WmiQueue <IUnknown *,8> *t_Container = m_ContainerArray [ a_Index ] ;
		return t_Container->EnQueue ( a_Element ) ;
#endif
	}

	WmiStatusCode Top ( 

		IUnknown *&a_Element ,
		ULONG a_Index
	)
	{
#if 1
		WmiStack <IUnknown *,8> *t_Container = m_ContainerArray [ a_Index ] ;
		return t_Container->Top ( a_Element ) ;
#else
		WmiQueue <IUnknown *,8> *t_Container = m_ContainerArray [ a_Index ] ;
		return t_Container->Top ( a_Element ) ;
#endif
	}

	WmiStatusCode Reserve ( ULONG a_Index )
	{
#if 1
		WmiStack <IUnknown *,8> *t_Container = m_ContainerArray [ a_Index ] ;
		return t_Container->Pop () ;
#else
		WmiQueue <IUnknown *,8> *t_Container = m_ContainerArray [ a_Index ] ;
		return t_Container->DeQueue () ;
#endif
	}
	
	ULONG GetTopSize () { return m_TopSize ; } ;
	ULONG GetCurrentSize () { return m_CurrentSize ; } ;
	BOOL GetInitialized () { return m_Initialized ; }

	void SetCurrentSize ( ULONG a_CurrentSize ) { m_CurrentSize = a_CurrentSize ; }

	CriticalSection &GetCriticalSection () { return m_CriticalSection ; }
} ;

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

class ProviderSubSystem_Common_Globals
{
public:

	static LPCWSTR s_Wql ;
	static LPCWSTR s_Provider ;

	static WORD s_System_ACESize ;
	static WORD s_LocalService_ACESize ;
	static WORD s_NetworkService_ACESize ;
	static WORD s_LocalAdmins_ACESize ;

	static ACCESS_ALLOWED_ACE *s_Provider_System_ACE ;
	static ACCESS_ALLOWED_ACE *s_Provider_LocalService_ACE ;
	static ACCESS_ALLOWED_ACE *s_Provider_NetworkService_ACE ;
	static ACCESS_ALLOWED_ACE *s_Provider_LocalAdmins_ACE ;

	static ACCESS_ALLOWED_ACE *s_Token_All_Access_System_ACE ;
	static ACCESS_ALLOWED_ACE *s_Token_All_Access_LocalService_ACE ;
	static ACCESS_ALLOWED_ACE *s_Token_All_Access_NetworkService_ACE ;
	static ACCESS_ALLOWED_ACE *s_Token_All_Access_LocalAdmins_ACE ;

	static SECURITY_DESCRIPTOR *s_MethodSecurityDescriptor ;

	static ULONG s_TransmitBufferSize ;
	static ULONG s_DefaultStackSize ;

public:

	static HRESULT CreateInstance ( 

		const CLSID &a_ReferenceClsid ,
		LPUNKNOWN a_OuterUnknown ,
		const DWORD &a_ClassContext ,
		const UUID &a_ReferenceInterfaceId ,
		void **a_ObjectInterface
	) ;

	static HRESULT CreateRemoteInstance ( 

		LPCWSTR a_Server ,
		const CLSID &a_ReferenceClsid ,
		LPUNKNOWN a_OuterUnknown ,
		const DWORD &a_ClassContext ,
		const UUID &a_ReferenceInterfaceId ,
		void **a_ObjectInterface
	) ;

	static HRESULT GetNamespaceServerPath (

		IWbemPath *a_Namespace ,
		wchar_t *&a_ServerNamespacePath
	) ;

	static HRESULT GetNamespacePath (

		IWbemPath *a_Namespace ,
		wchar_t *&a_NamespacePath
	) ;

	static HRESULT GetPathText (

		IWbemPath *a_Path ,
		wchar_t *&a_ObjectPath
	) ;

	static HRESULT BeginCallbackImpersonation (

		IUnknown *&a_OldContext ,
		IServerSecurity *&a_OldSecurity ,
		BOOL &a_Impersonating
	) ;

	static HRESULT BeginImpersonation (

		IUnknown *&a_OldContext ,
		IServerSecurity *&a_OldSecurity ,
		BOOL &a_Impersonating ,
		DWORD *a_AuthenticationLevel = NULL
	) ;

	static HRESULT EndImpersonation (

		IUnknown *a_OldContext ,
		IServerSecurity *a_OldSecurity ,
		BOOL a_Impersonating 
	) ;

	static HRESULT GetProxy (

		REFIID a_InterfaceId ,
		IUnknown *a_Interface ,
		IUnknown *&a_Proxy 
	) ;

	static HRESULT GetProxy (

		ProxyContainer &a_Container , 
		ULONG a_ProxyIndex ,
		REFIID a_InterfaceId ,
		IUnknown *a_Interface ,
		IUnknown *&a_Proxy 
	) ;

	static HRESULT SetCloaking ( 

		IUnknown *a_Unknown
	) ;

	static HRESULT SetCloaking ( 

		IUnknown *a_Unknown ,
		DWORD a_AuthenticationLevel ,
		DWORD a_ImpersonationLevel
	) ;

	static BOOL IsProxy ( IUnknown *a_Unknown ) ;

	static DWORD GetCurrentImpersonationLevel () ;

	static HRESULT EnableAllPrivileges () ;

	static HRESULT EnableAllPrivileges ( HANDLE a_Token ) ;

	static HRESULT SetAnonymous ( IUnknown *a_Proxy ) ;

	static HRESULT SetCallState (

		IUnknown *a_Interface ,
		BOOL &a_Revert
	) ;

	static HRESULT RevertCallState ( 

		BOOL a_Revert
	) ;

	static HRESULT SetProxyState (

		ProxyContainer &a_Container , 
		ULONG a_ProxyIndex ,
		REFIID a_InterfaceId ,
		IUnknown *a_Interface ,
		IUnknown *&a_Proxy , 
		BOOL &a_Revert
	) ;

	static HRESULT RevertProxyState ( 

		ProxyContainer &a_Container , 
		ULONG a_ProxyIndex ,
		IUnknown *a_Proxy , 
		BOOL a_Revert
	) ;

	static HRESULT SetProxyState_SvcHost (

		ProxyContainer &a_Container , 
		ULONG a_ProxyIndex ,
		REFIID a_InterfaceId ,
		IUnknown *a_Interface ,
		IUnknown *&a_Proxy , 
		BOOL &a_Revert ,
		DWORD a_ProcessIdentifier ,
		HANDLE &a_IdentifyToken ,
		ACCESS_ALLOWED_ACE *a_Ace ,
		WORD a_AceSize
	) ;

	static HRESULT RevertProxyState_SvcHost ( 

		ProxyContainer &a_Container , 
		ULONG a_ProxyIndex ,
		IUnknown *a_Proxy , 
		BOOL a_Revert ,
		DWORD a_ProcessIdentifier ,
		HANDLE a_IdentifyToken
	) ;

	static HRESULT SetProxyState_PrvHost (

		ProxyContainer &a_Container , 
		ULONG a_ProxyIndex ,
		REFIID a_InterfaceId ,
		IUnknown *a_Interface ,
		IUnknown *&a_Proxy , 
		BOOL &a_Revert ,
		DWORD a_ProcessIdentifier ,
		HANDLE &a_IdentifyToken
	) ;

	static HRESULT RevertProxyState_PrvHost ( 

		ProxyContainer &a_Container , 
		ULONG a_ProxyIndex ,
		IUnknown *a_Proxy , 
		BOOL a_Revert ,
		DWORD a_ProcessIdentifier ,
		HANDLE a_IdentifyToken
	) ;

	static HRESULT SetProxyState_SvcHost (

		REFIID a_InterfaceId ,
		IUnknown *a_Interface ,
		IUnknown *&a_Proxy , 
		BOOL &a_Revert ,
		DWORD a_ProcessIdentifier ,
		HANDLE &a_IdentifyToken ,
		ACCESS_ALLOWED_ACE *a_Ace ,
		WORD a_AceSize,
		SECURITY_IMPERSONATION_LEVEL impersonationLevel
	) ;

	static HRESULT RevertProxyState_SvcHost ( 

		IUnknown *a_Proxy , 
		BOOL a_Revert ,
		DWORD a_ProcessIdentifier ,
		HANDLE a_IdentifyToken
	) ;

	static HRESULT SetProxyState_PrvHost (

		REFIID a_InterfaceId ,
		IUnknown *a_Interface ,
		IUnknown *&a_Proxy , 
		BOOL &a_Revert ,
		DWORD a_ProcessIdentifier ,
		HANDLE &a_IdentifyToken
	) ;

	static HRESULT RevertProxyState_PrvHost ( 

		IUnknown *a_Proxy , 
		BOOL a_Revert ,
		DWORD a_ProcessIdentifier ,
		HANDLE a_IdentifyToken
	) ;

	static HRESULT SetProxyState (

		REFIID a_InterfaceId ,
		IUnknown *a_Interface ,
		IUnknown *&a_Proxy , 
		BOOL &a_Revert
	) ;

	static HRESULT RevertProxyState ( 

		IUnknown *a_Proxy , 
		BOOL a_Revert
	) ;

	static HRESULT Load_DWORD ( HKEY a_Key , LPCWSTR a_Name , DWORD &a_Value ) ;
	static HRESULT Load_String ( HKEY a_Key , LPCWSTR a_Name , BSTR &a_Value ) ;
	static HRESULT Load_ByteArray ( HKEY a_Key , LPCWSTR a_Name , BYTE *&a_Value , DWORD &a_ValueLength ) ;

	static HRESULT Save_DWORD ( HKEY a_Key , LPCWSTR a_Name , DWORD a_Value ) ;
	static HRESULT Save_String ( HKEY a_Key , LPCWSTR a_Name , BSTR a_Value ) ;
	static HRESULT Save_ByteArray ( HKEY a_Key , LPCWSTR a_Name , BYTE *a_Value , DWORD a_ValueLength ) ;

	static HRESULT UnMarshalRegistration (

		IUnknown **a_Unknown ,
		BYTE *a_MarshaledProxy ,
		DWORD a_MarshaledProxyLength
	) ;

	static HRESULT MarshalRegistration (

		IUnknown *a_Unknown ,
		BYTE *&a_MarshaledProxy ,
		DWORD &a_MarshaledProxyLength
	) ;

	static HRESULT ReleaseRegistration (

		BYTE *a_MarshaledProxy ,
		DWORD a_MarshaledProxyLength
	) ;

	static HRESULT IsDependantCall ( IWbemContext *a_Parent , IWbemContext *a_ChildContext , BOOL &a_DependantCall ) ;

	static HRESULT Set_Uint64 (

		_IWmiObject *a_Instance ,
		wchar_t *a_Name ,
		const UINT64 &a_Uint64
	) ;

	static HRESULT Set_Uint32 ( 

		_IWmiObject *a_Instance , 
		wchar_t *a_Name ,
		const DWORD &a_Uint32
	) ;

	static HRESULT Set_Uint16 ( 

		_IWmiObject *a_Instance , 
		wchar_t *a_Name ,
		const WORD &a_Uint16
	) ;

	static HRESULT Set_Bool ( 

		_IWmiObject *a_Instance , 
		wchar_t *a_Name ,
		const BOOL &a_Bool
	) ;

	static HRESULT Set_String ( 

		IWbemClassObject *a_Instance , 
		wchar_t *a_Name ,
		wchar_t *a_String
	) ;

	static HRESULT Set_DateTime ( 

		IWbemClassObject *a_Instance , 
		wchar_t *a_Name ,
		FILETIME a_Time
	) ;

	static HRESULT Set_Byte_Array ( 

		IWbemClassObject *a_Instance , 
		wchar_t *a_Name ,
		BYTE *a_Bytes ,
		WORD a_BytesCount 
	) ;

	static HRESULT Get_Uint64 (

		_IWmiObject *a_Instance ,
		wchar_t *a_Name ,
		UINT64 &a_Uint64 ,
		BOOL &a_Null
	) ;

	static HRESULT Get_Uint32 ( 

		_IWmiObject *a_Instance , 
		wchar_t *a_Name ,
		DWORD &a_Uint32 ,
		BOOL &a_Null
	) ;

	static HRESULT Get_Uint16 ( 

		_IWmiObject *a_Instance , 
		wchar_t *a_Name ,
		WORD &a_Uint16 ,
		BOOL &a_Null 
	) ;

	static HRESULT Get_Bool ( 

		_IWmiObject *a_Instance , 
		wchar_t *a_Name ,
		BOOL &a_Bool ,
		BOOL &a_Null
	) ;

	static HRESULT Get_String ( 

		IWbemClassObject *a_Instance , 
		wchar_t *a_Name ,
		wchar_t *&a_String ,
		BOOL &a_Null
	) ;

	static HRESULT Get_DateTime ( 

		IWbemClassObject *a_Instance , 
		wchar_t *a_Name ,
		FILETIME &a_Time ,
		BOOL &a_Null
	) ;

	static HRESULT Check_SecurityDescriptor_CallIdentity ( 

		SECURITY_DESCRIPTOR *a_SecurityDescriptor ,
		DWORD a_Access , 
		GENERIC_MAPPING *a_Mapping
	) ;

	static HRESULT AdjustSecurityDescriptorWithSid ( 

		SID *a_OwnerSid , 
		SID *a_GroupSid , 
		DWORD a_Access ,
		SECURITY_DESCRIPTOR *&a_SecurityDescriptor , 
		SECURITY_DESCRIPTOR *&a_AlteredSecurityDescriptor
	) ;

	static HRESULT CreateSystemAces () ;

	static HRESULT DeleteSystemAces () ;

	static HRESULT ConstructIdentifyToken_SvcHost (

		BOOL &a_Revert ,
		DWORD a_ProcessIdentifier ,
		HANDLE &a_IdentifyToken ,
		ACCESS_ALLOWED_ACE *a_Ace ,
		WORD a_AceSize,
		SECURITY_IMPERSONATION_LEVEL impersonationLevel
	) ;

	static HRESULT ConstructIdentifyToken_PrvHost (

		BOOL &a_Revert ,
		DWORD a_ProcessIdentifier ,
		HANDLE &a_IdentifyToken ,
		ACCESS_ALLOWED_ACE *a_Ace ,
		WORD a_AceSize
	) ;

	static HRESULT CheckAccess (
	
		SECURITY_DESCRIPTOR *a_SecurityDescriptor ,
		DWORD a_Access , 
		GENERIC_MAPPING *a_Mapping
	) ;

	static HRESULT GetUserSid (

		HANDLE a_Token ,
		ULONG *a_Size ,
		PSID &a_Sid
	) ;

	static HRESULT GetGroupSid (

		HANDLE a_Token ,
		ULONG *a_Size ,
		PSID &a_Sid
	) ;

	static HRESULT GetAceWithProcessTokenUser ( 
					
		DWORD a_ProcessIdentifier ,
		WORD &a_AceSize ,
		ACCESS_ALLOWED_ACE *&a_Ace 
	) ;

	static HRESULT SinkAccessInitialize (

		SECURITY_DESCRIPTOR *a_RegistrationSecurityDescriptor ,
		SECURITY_DESCRIPTOR *&a_SinkSecurityDescriptor
	) ;

	static HRESULT CreateMethodSecurityDescriptor () ;

	static HRESULT DeleteMethodSecurityDescriptor () ;

	static SECURITY_DESCRIPTOR *GetMethodSecurityDescriptor () 
	{
		return s_MethodSecurityDescriptor ;
	}

	static DWORD InitializeTransmitSize () ;
	static DWORD GetTransmitSize () { return s_TransmitBufferSize ; }

	static DWORD InitializeDefaultStackSize () ;
	static DWORD GetDefaultStackSize () { return s_DefaultStackSize ; }

} ;

#endif // _CommonGlobals_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\provsubsys\decoupledadaptor\include\classfac.h ===
/*++

Copyright (C) 1996-2001 Microsoft Corporation

Module Name:

	ClassFac.h

Abstract:


History:

--*/

#ifndef _ServerClassFactory_H
#define _ServerClassFactory_H

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/


class ClassFactoryBase : public IClassFactory
  {
  long m_ReferenceCount ;
  public:
    ClassFactoryBase () ;
    virtual ~ClassFactoryBase () ;

    	//IUnknown members

    STDMETHODIMP QueryInterface ( REFIID , LPVOID FAR * ) ;
    STDMETHODIMP_( ULONG ) AddRef () ;
    STDMETHODIMP_( ULONG ) Release () ;

	//IClassFactory members
    STDMETHODIMP LockServer ( BOOL ) ;
  };

template <class Object,class ObjectInterface>
class CServerClassFactory : public ClassFactoryBase
{
	//IClassFactory members
    STDMETHODIMP CreateInstance ( LPUNKNOWN , REFIID , LPVOID FAR * ) ;
};

#include <classfac.cpp>

#endif // _ServerClassFactory_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\provsubsys\decoupledadaptor\include\exclusion.h ===
/*++

Copyright (C) 1996-2001 Microsoft Corporation

Module Name:

	Exclusion.h

Abstract:


History:

--*/

#ifndef _Exclusion_H
#define _Exclusion_H

#include <pssException.h>

#include "ProvCache.h"

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

class Exclusion : public ExclusionCacheElement
{
private:

	WmiMultiReaderMultiWriter m_Exclusion ;

public:

	Exclusion (

		const ULONG &a_ReaderSize ,
		const ULONG &a_WriterSize ,
		const GUID &a_Guid ,
		const ULONG &a_Period ,
		CWbemGlobal_ExclusionController *a_Controller
	)  ;

	~Exclusion () ;

    STDMETHODIMP QueryInterface ( REFIID , LPVOID FAR * ) ;
	STDMETHODIMP_( ULONG ) AddRef () ;
	STDMETHODIMP_( ULONG ) Release () ;

	WmiMultiReaderMultiWriter &GetExclusion () { return m_Exclusion ; }

	static HRESULT CreateAndCache (

		const GUID &a_Clsid ,
		Exclusion *&a_Exclusion 
	) ;

} ;

#endif _Exclusion_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\provsubsys\decoupledadaptor\include\datetime.h ===
//***************************************************************************
//
//  Copyright (c) 2000-2001 Microsoft Corporation
//
//  datetime.h
//
//  alanbos  20-Jan-00   Created.
//
//  Datetime helper implementation.
//
//***************************************************************************

#ifndef _DATETIME_H_
#define _DATETIME_H_

#define WBEMDT_DMTF_LEN		25
#define WBEMDT_DMTF_SPOS	14
#define WBEMDT_DMTF_UPOS	21

#define	WBEMDT_MIN_YEAR		0
#define	WBEMDT_MAX_YEAR		9999
#define WBEMDT_MIN_MONTH	1
#define WBEMDT_MAX_MONTH	12
#define WBEMDT_MIN_DAY		1
#define WBEMDT_MAX_DAY		31
#define WBEMDT_MIN_DAYINT	0
#define WBEMDT_MAX_DAYINT	999999
#define	WBEMDT_MIN_HOURS	0
#define	WBEMDT_MAX_HOURS	23
#define	WBEMDT_MIN_MINUTES	0
#define	WBEMDT_MAX_MINUTES	59
#define	WBEMDT_MIN_SECONDS	0
#define	WBEMDT_MAX_SECONDS	59
#define	WBEMDT_MIN_MICROSEC	0
#define	WBEMDT_MAX_MICROSEC	999999
#define	WBEMDT_MIN_UTC		-720
#define	WBEMDT_MAX_UTC		720

#define INVALID_TIME 0xffffffffffffffff

//***************************************************************************
//
//  CLASS NAME:
//
//  CWbemDateTime
//
//  DESCRIPTION:
//
//  Implements the ISWbemDateTime interface.  
//
//***************************************************************************

class CWbemDateTime 
{
private:
	// Private helper class for all the messy business
	class WBEMTime 
	{
		private:
			class WBEMTimeSpan 
			{
				private:

					ULONGLONG m_Time;
					friend class WBEMTime;

				public:

					WBEMTimeSpan ( 
						int iMinutes 
					) 
					{
						m_Time = iMinutes * 60;
						m_Time *= 10000000;
				}
			};

		public:

			WBEMTime ()													{ m_uTime = INVALID_TIME ; }
			WBEMTime ( const SYSTEMTIME &st )							{ *this = st ; }
			WBEMTime ( const FILETIME &ft )	;

			const WBEMTime &operator= ( const SYSTEMTIME &st ) ;
			const WBEMTime &operator= ( const FILETIME &ft ) ;

			WBEMTime    operator+ ( const WBEMTimeSpan &ts ) const;
			WBEMTime    operator- ( const WBEMTimeSpan &sub ) const;

			BOOL GetSYSTEMTIME ( SYSTEMTIME *pst ) const;
			BOOL GetFILETIME ( FILETIME *pst ) const;

			BOOL GetDMTF ( SYSTEMTIME &st, long &offset ) const;
			BOOL GetDMTF ( SYSTEMTIME &st ) const;

			void Clear ( void )											{ m_uTime = INVALID_TIME ; }

			bool IsOk () const											{ return m_uTime != INVALID_TIME ? true : false; }
			
			static LONG WINAPI GetLocalOffsetForDate(const SYSTEMTIME *pst);

		private:
			ULONGLONG m_uTime;
	};

	VARIANT_BOOL		m_bYearSpecified;
	VARIANT_BOOL		m_bMonthSpecified;
	VARIANT_BOOL		m_bDaySpecified;
	VARIANT_BOOL		m_bHoursSpecified;
	VARIANT_BOOL		m_bMinutesSpecified;
	VARIANT_BOOL		m_bSecondsSpecified;
	VARIANT_BOOL		m_bMicrosecondsSpecified;
	VARIANT_BOOL		m_bUTCSpecified;
	VARIANT_BOOL		m_bIsInterval;
	
	long				m_iYear;
	long				m_iMonth;
	long				m_iDay;
	long				m_iHours;
	long				m_iMinutes;
	long				m_iSeconds;
	long				m_iMicroseconds;
	long				m_iUTC;

	bool				CheckField (
								LPWSTR			pValue,
								ULONG			len,
								VARIANT_BOOL	&bIsSpecified,
								long			&iValue,
								long			maxValue,
								long			minValue
						);

	bool				CheckUTC (
								LPWSTR			pValue,
								VARIANT_BOOL	&bIsSpecified,
								long			&iValue,
								bool			bParseSign = true
						);

protected:
public:
    
    CWbemDateTime(void);
    virtual ~CWbemDateTime(void);

	// ISWbemDateTime methods

    HRESULT GetValue ( BSTR *value ) ;
    
    HRESULT PutValue ( BSTR value ) ;

    HRESULT GetYear ( long *value ) 
	{
		*value = m_iYear;

		return S_OK;
	}
    
    HRESULT PutYear ( long value ) 
	{
		HRESULT hr = WBEM_S_NO_ERROR;

		if ((value > WBEMDT_MAX_YEAR) || (value < WBEMDT_MIN_YEAR))
			hr = WBEM_E_VALUE_OUT_OF_RANGE;
		else
			m_iYear = value;

		return hr;
	}		

    HRESULT GetMonth ( long *value ) 
	{
		*value = m_iMonth;

		return S_OK;
	}
    
    HRESULT PutMonth ( long value ) 
	{
		HRESULT hr = WBEM_S_NO_ERROR;

		if ((value > WBEMDT_MAX_MONTH) || (value < WBEMDT_MIN_MONTH))
			hr = WBEM_E_VALUE_OUT_OF_RANGE;
		else
			m_iMonth = value;

		return hr;
	}		

	HRESULT GetDay ( long *value ) 
	{
		*value = m_iDay;

		return S_OK;
	}
    
    HRESULT PutDay ( long value ) 
	{
		HRESULT hr = S_OK ;

		if (((VARIANT_TRUE == m_bIsInterval) && ((value > WBEMDT_MAX_DAYINT) || (value < WBEMDT_MIN_DAYINT))) ||
			((VARIANT_FALSE == m_bIsInterval) &&((value > WBEMDT_MAX_DAY) || (value < WBEMDT_MIN_DAY))))
			hr = WBEM_E_VALUE_OUT_OF_RANGE;
		else
			m_iDay = value;

		return hr;
	}		

	HRESULT GetHours ( long *value ) 
	{
		*value = m_iHours;

		return S_OK;
	}
    
    HRESULT PutHours ( long value ) 
	{
		HRESULT hr = S_OK;

		if ((value > WBEMDT_MAX_HOURS) || (value < WBEMDT_MIN_HOURS))
			hr = WBEM_E_VALUE_OUT_OF_RANGE;
		else
			m_iHours = value;

		return hr;
	}		

		
	HRESULT GetMinutes ( long *value ) 
	{
		*value = m_iMinutes;

		return S_OK;
	}
    
    HRESULT PutMinutes ( long value ) 
	{
		HRESULT hr = S_OK;

		if ((value > WBEMDT_MAX_MINUTES) || (value < WBEMDT_MIN_MINUTES))
			hr = WBEM_E_VALUE_OUT_OF_RANGE;
		else
			m_iMinutes = value;

		return hr;
	}		

	HRESULT GetSeconds ( long *value ) 
	{
		*value = m_iSeconds;

		return S_OK;
	}
        
    HRESULT PutSeconds ( long value ) 
	{
		HRESULT hr = S_OK;

		if ((value > WBEMDT_MAX_SECONDS) || (value < WBEMDT_MIN_SECONDS))
			hr = WBEM_E_VALUE_OUT_OF_RANGE;
		else
			m_iSeconds = value;

		return hr;
	}		


	HRESULT GetMicroseconds ( long *value ) 
	{
		*value = m_iMicroseconds;

		return S_OK;
	}
    
    HRESULT PutMicroseconds ( long value ) 
	{
		HRESULT hr = S_OK;

		if ((value > WBEMDT_MAX_MICROSEC) || (value < WBEMDT_MIN_MICROSEC))
			hr = WBEM_E_VALUE_OUT_OF_RANGE;
		else
			m_iMicroseconds = value;

		return hr;
	}		

	HRESULT GetUTC ( long *value ) 
	{
		*value = m_iUTC;

		return S_OK;
	}
    
    HRESULT PutUTC( long value ) 
	{
		HRESULT hr = S_OK;

		if ((value > WBEMDT_MAX_UTC) || (value < WBEMDT_MIN_UTC))
			hr = WBEM_E_VALUE_OUT_OF_RANGE;
		else
			m_iUTC = value;

		return hr;
	}		

	HRESULT GetYearSpecified ( VARIANT_BOOL *value ) 
	{ 
		*value = m_bYearSpecified; 

		return S_OK;
	}
    
    HRESULT PutYearSpecified ( VARIANT_BOOL value ) 
	{ 
		HRESULT hr = S_OK;

		if ((VARIANT_TRUE == m_bIsInterval) && (VARIANT_TRUE == value))
			hr = WBEM_E_FAILED ;
		else
			m_bYearSpecified = value;

		return hr;
	}
    
    HRESULT GetMonthSpecified ( VARIANT_BOOL *value ) 
	{ 
		*value = m_bMonthSpecified; 

		return S_OK;
	}
    
    HRESULT PutMonthSpecified ( VARIANT_BOOL value ) 
	{ 
		HRESULT hr = S_OK;

		if ((VARIANT_TRUE == m_bIsInterval) && (VARIANT_TRUE == value))
			hr = WBEM_E_FAILED;
		else
			m_bMonthSpecified = value;
		
		return hr;
	}

	HRESULT GetDaySpecified ( VARIANT_BOOL *value ) 
	{ 
		*value = m_bDaySpecified; 

		return S_OK;
	}
    
    HRESULT PutDaySpecified ( VARIANT_BOOL value ) 
	{ 
		m_bDaySpecified = value;

		return S_OK;
	}

	HRESULT GetHoursSpecified ( VARIANT_BOOL *value ) 
	{ 
		*value = m_bHoursSpecified; 

		return S_OK;
	}
    
    HRESULT PutHoursSpecified ( VARIANT_BOOL value ) 
	{ 
		m_bHoursSpecified = value;

		return S_OK;
	}
		
	HRESULT GetMinutesSpecified ( VARIANT_BOOL *value ) 
	{ 
		*value = m_bMinutesSpecified; 

		return S_OK;
	}
        
    HRESULT PutMinutesSpecified ( VARIANT_BOOL value ) 
	{ 
		m_bMinutesSpecified = value;

		return S_OK;
	}

	HRESULT GetSecondsSpecified ( VARIANT_BOOL *value ) 
	{ 
		*value = m_bSecondsSpecified; 

		return S_OK;
	}
    
    HRESULT PutSecondsSpecified ( VARIANT_BOOL value ) 
	{ 
		m_bSecondsSpecified = value;

		return S_OK;
	}

	HRESULT GetMicrosecondsSpecified ( VARIANT_BOOL *value ) 
	{ 
		*value = m_bMicrosecondsSpecified; 

		return S_OK;
	}
    
    HRESULT PutMicrosecondsSpecified ( VARIANT_BOOL value ) 
	{ 
		m_bMicrosecondsSpecified = value;

		return S_OK;
	}

	HRESULT GetUTCSpecified ( VARIANT_BOOL *value ) 
	{ 
		*value = m_bUTCSpecified; 

		return S_OK;
	}
    
    HRESULT PutUTCSpecified ( VARIANT_BOOL value ) 
	{ 
		HRESULT hr = S_OK;

		if ((VARIANT_TRUE == m_bIsInterval) && (VARIANT_TRUE == value))
			hr = WBEM_E_FAILED;
		else
			m_bUTCSpecified = value;
	
		return hr;
	}

	HRESULT GetIsInterval ( VARIANT_BOOL *value ) 
	{ 
		*value = m_bIsInterval; 

		return S_OK;
	}
    
    HRESULT PutIsInterval( VARIANT_BOOL value ) 
	{ 
		if ((VARIANT_TRUE == m_bIsInterval) && (VARIANT_FALSE == value))
		{
			if (0 == m_iDay)
				m_iDay = 1;
			else if (WBEMDT_MAX_DAY < m_iDay)
				m_iDay = WBEMDT_MAX_DAY;
		}
		else if ((VARIANT_TRUE == value) && (VARIANT_FALSE == m_bIsInterval))
		{
			m_bDaySpecified = VARIANT_TRUE; 
			m_bHoursSpecified = VARIANT_TRUE;
			m_bMinutesSpecified = VARIANT_TRUE;
			m_bSecondsSpecified = VARIANT_TRUE;
			m_bMicrosecondsSpecified = VARIANT_TRUE;
		}

		m_bIsInterval = value;

		return S_OK;
	}

	HRESULT GetVarDate (
 
        VARIANT_BOOL bIsLocal,
		DATE *dVarDate
	) ;
    
    HRESULT SetVarDate ( 

        DATE dVarDate,
		VARIANT_BOOL bIsLocal
	) ;

	HRESULT GetSystemTimeDate (

		SYSTEMTIME &fSystemTime
	) ;

	HRESULT GetFileTimeDate (

		FILETIME &fFileTime
	) ;

	HRESULT SetFileTimeDate ( 

		FILETIME fFileTime,
		VARIANT_BOOL bIsLocal
	) ;

	BOOL Preceeds ( CWbemDateTime &a_Time ) ;
};

#endif // _DATETIME_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\provsubsys\decoupledadaptor\include\guids.h ===
/*++

Copyright (C) 1996-2001 Microsoft Corporation

Module Name:

	Guids.h

Abstract:


History:

--*/


// {54D8502C-527D-43f7-A506-A9DA075E229C}
DEFINE_GUID(CLSID_WmiDCProxyProvider, 
0x54d8502c, 0x527d, 0x43f7, 0xa5, 0x6, 0xa9, 0xda, 0x7, 0x5e, 0x22, 0x9c);

// {8D955AC7-AF43-407a-A838-C26080B6671B}
DEFINE_GUID(IID_CacheElement, 
0x8d955ac7, 0xaf43, 0x407a, 0xa8, 0x38, 0xc2, 0x60, 0x80, 0xb6, 0x67, 0x1b);

// {F7BF10E6-A310-4530-8B63-B3354C485E2D}
DEFINE_GUID(IID_CWbemGlobal_IWmiObjectSinkController, 
0xf7bf10e6, 0xa310, 0x4530, 0x8b, 0x63, 0xb3, 0x35, 0x4c, 0x48, 0x5e, 0x2d);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\provsubsys\decoupledadaptor\include\null_wmi.h ===
class NULL_IWbemServices: public IWbemServices{
public:
	NULL_IWbemServices ( HRESULT hr ) : ret_ ( hr) { };


    /* IUnk not implemented */
	// STDMETHODIMP QueryInterface ( REFIID , LPVOID FAR * );
    // STDMETHODIMP_( ULONG ) AddRef ();
    // STDMETHODIMP_( ULONG ) Release ();

    /* IWbemServices methods */

    HRESULT STDMETHODCALLTYPE 
	OpenNamespace ( const BSTR, long, IWbemContext *, IWbemServices **, IWbemCallResult ** )
	{ return ret_; };
    
    HRESULT STDMETHODCALLTYPE 
	CancelAsyncCall ( IWbemObjectSink *a_Sink )
	{ return ret_; };

    
    HRESULT STDMETHODCALLTYPE 
	QueryObjectSink ( long, IWbemObjectSink ** )
	{ return ret_; };

    
    HRESULT STDMETHODCALLTYPE 
	GetObject ( const BSTR , long , IWbemContext *, IWbemClassObject **, IWbemCallResult **)
	{ return ret_; };
    
    HRESULT STDMETHODCALLTYPE GetObjectAsync (
        
		const BSTR a_ObjectPath ,
        long a_Flags ,
        IWbemContext *a_Context ,
        IWbemObjectSink *a_Sink
	) 	{ return ret_; };

    HRESULT STDMETHODCALLTYPE PutClass (IWbemClassObject *, long , IWbemContext *, IWbemCallResult **)
	{ return ret_; };

    
    HRESULT STDMETHODCALLTYPE PutClassAsync ( 

        IWbemClassObject *a_Object ,
        long a_Flags ,
        IWbemContext *a_Context ,
        IWbemObjectSink *a_Sink
	) 	{ return ret_; };

    HRESULT STDMETHODCALLTYPE DeleteClass ( 

        const BSTR a_Class ,
        long a_Flags ,
        IWbemContext *a_Context ,
        IWbemCallResult **a_CallResult
	) 	{ return ret_; };

    HRESULT STDMETHODCALLTYPE DeleteClassAsync ( 

        const BSTR a_Class ,
        long a_Flags ,
        IWbemContext *a_Context ,
        IWbemObjectSink *a_Sink
	) 	{ return ret_; };

    HRESULT STDMETHODCALLTYPE CreateClassEnum ( 

        const BSTR a_Superclass ,
        long a_Flags ,
        IWbemContext *a_Context ,
        IEnumWbemClassObject **a_Enum
	) 	{ return ret_; };

    HRESULT STDMETHODCALLTYPE CreateClassEnumAsync ( 

		const BSTR a_Superclass ,
		long a_Flags ,
		IWbemContext *a_Context ,
		IWbemObjectSink *a_Sink
	) 	{ return ret_; };

    HRESULT STDMETHODCALLTYPE PutInstance (

		IWbemClassObject *a_Instance ,
		long a_Flags , 
		IWbemContext *a_Context ,
		IWbemCallResult **a_CallResult
	) 	{ return ret_; };

    HRESULT STDMETHODCALLTYPE PutInstanceAsync (

		IWbemClassObject *a_Instance ,
		long a_Flags ,
		IWbemContext *a_Context ,
		IWbemObjectSink *a_Sink 
	) 	{ return ret_; };
    
    HRESULT STDMETHODCALLTYPE DeleteInstance ( 

		const BSTR a_ObjectPath ,
		long a_Flags ,
		IWbemContext *a_Context ,
		IWbemCallResult **a_CallResult
	) 	{ return ret_; };

    HRESULT STDMETHODCALLTYPE DeleteInstanceAsync ( 

		const BSTR a_ObjectPath,
		long a_Flags,
		IWbemContext *a_Context ,
		IWbemObjectSink *a_Sink
	) 	{ return ret_; };

    HRESULT STDMETHODCALLTYPE CreateInstanceEnum (

		const BSTR a_Class ,
		long a_Flags ,
		IWbemContext *a_Context ,
		IEnumWbemClassObject **a_Enum
	) 	{ return ret_; };

    HRESULT STDMETHODCALLTYPE CreateInstanceEnumAsync (

		const BSTR a_Class ,
		long a_Flags ,
		IWbemContext *a_Context ,
		IWbemObjectSink *a_Sink
	) 	{ return ret_; };

    HRESULT STDMETHODCALLTYPE ExecQuery ( 

		const BSTR a_QueryLanguage,
		const BSTR a_Query,
		long a_Flags ,
		IWbemContext *a_Context ,
		IEnumWbemClassObject **a_Enum
	) 	{ return ret_; };

    HRESULT STDMETHODCALLTYPE ExecQueryAsync (

		const BSTR a_QueryLanguage ,
		const BSTR a_Query ,
		long a_Flags ,
		IWbemContext *a_Context ,
		IWbemObjectSink *a_Sink
	) 	{ return ret_; };

    HRESULT STDMETHODCALLTYPE ExecNotificationQuery (

		const BSTR a_QueryLanguage ,
		const BSTR a_Query ,
		long a_Flags ,
		IWbemContext *a_Context ,
		IEnumWbemClassObject **a_Enum
	) 	{ return ret_; };

    HRESULT STDMETHODCALLTYPE 
	ExecNotificationQueryAsync ( const BSTR, const BSTR, long, IWbemContext *, IWbemObjectSink *)
	{ return ret_; };
    
    HRESULT STDMETHODCALLTYPE 
	ExecMethod ( const BSTR, const BSTR, long, IWbemContext *, IWbemClassObject *, IWbemClassObject **, IWbemCallResult **)
	{ return ret_; };
    
    HRESULT STDMETHODCALLTYPE 
	ExecMethodAsync ( const BSTR, const BSTR, long, IWbemContext *, IWbemClassObject *, IWbemObjectSink *)
	{ return ret_; };

private:
	HRESULT	ret_;
	NULL_IWbemServices(const NULL_IWbemServices&);
	const NULL_IWbemServices& operator=(const NULL_IWbemServices&);
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\provsubsys\decoupledadaptor\include\os.h ===
#ifndef __OS_H__
#define __OS_H__

namespace OS
{
	enum { NT4 = 4 };
	bool unicodeOS();
	extern bool unicodeOS_;
	extern bool secureOS_;
	extern int osVer_;
	
	LONG RegOpenKeyExW (HKEY hKey, LPCTSTR lpSubKey, DWORD ulOptions, REGSAM samDesired, PHKEY phkResult);
	LONG RegCreateKeyExW (HKEY hKey, LPCTSTR lpSubKey,DWORD Reserved, LPTSTR lpClass,DWORD dwOptions,REGSAM samDesired,LPSECURITY_ATTRIBUTES lpSecurityAttributes, PHKEY phkResult, LPDWORD lpdwDisposition);
	LONG RegEnumKeyExW (HKEY hKey,DWORD dwIndex,LPTSTR lpName,LPDWORD lpcName,LPDWORD lpReserved,LPTSTR lpClass,LPDWORD lpcClass,PFILETIME lpftLastWriteTime);
	LONG RegDeleteKeyW (HKEY hKey, LPCTSTR lpSubKey);
	LONG RegQueryValueExW(
  HKEY hKey,            // handle to key
  LPCTSTR lpValueName,  // value name
  LPDWORD lpReserved,   // reserved
  LPDWORD lpType,       // type buffer
  LPBYTE lpData,        // data buffer
  LPDWORD lpcbData      // size of data buffer
);

LONG RegSetValueExW(
  HKEY hKey,           // handle to key
  LPCTSTR lpValueName, // value name
  DWORD Reserved,      // reserved
  DWORD dwType,        // value type
  CONST BYTE *lpData,  // value data
  DWORD cbData         // size of value data
);

	HRESULT CoImpersonateClient();

	BOOL GetProcessTimes(
  HANDLE hProcess,           // handle to process
  LPFILETIME lpCreationTime, // process creation time
  LPFILETIME lpExitTime,     // process exit time
  LPFILETIME lpKernelTime,   // process kernel-mode time
  LPFILETIME lpUserTime      // process user-mode time
);
  
  HANDLE CreateEventW(LPSECURITY_ATTRIBUTES lpEventAttributes, BOOL bManualReset, BOOL bInitialState, LPCWSTR lpName );
  HANDLE CreateMutexW(LPSECURITY_ATTRIBUTES lpEventAttributes, BOOL bInitialOwner, LPCWSTR lpName );
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\provsubsys\decoupledadaptor\include\provcache.h ===
/*++

Copyright (C) 1996-2001 Microsoft Corporation

Module Name:

	Cache.H

Abstract:


History:

--*/

#ifndef _Server_Cache_H
#define _Server_Cache_H

#include <Allocator.h>
#include <Algorithms.h>
#include <PQueue.h>
#include <TPQueue.h>
#include <BasicTree.h>
#include <Cache.h>

#include "ProvRegInfo.h"

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

class BindingFactoryCacheKey 
{
public:

	BSTR m_Namespace ;

public:

	BindingFactoryCacheKey () :

		m_Namespace ( NULL )
	{
	}

	BindingFactoryCacheKey ( 

		const BindingFactoryCacheKey &a_Key 

	) :	m_Namespace ( NULL )
	{
		if ( a_Key.m_Namespace )
		{
			m_Namespace = SysAllocString ( a_Key.m_Namespace ) ;
		}
	}

	BindingFactoryCacheKey ( 

		const wchar_t *a_Namespace 

	) :	m_Namespace ( NULL )
	{
		if ( a_Namespace )
		{
			m_Namespace = SysAllocString ( a_Namespace ) ;
		}
	}

	~BindingFactoryCacheKey ()
	{
		if ( m_Namespace )
		{
			SysFreeString ( m_Namespace ) ;
		}
	}

	BindingFactoryCacheKey &operator= ( const BindingFactoryCacheKey &a_Key ) 
	{
		if ( m_Namespace )
		{
			SysFreeString ( m_Namespace ) ;
		}

		if ( a_Key.m_Namespace )
		{
			m_Namespace = SysAllocString ( a_Key.m_Namespace ) ;
		}
		
		return *this ;
	}

	LONG CompareNamespace ( const BSTR a_Namespace ) const
	{
		if ( m_Namespace && a_Namespace )
		{
			return _wcsicmp ( m_Namespace , a_Namespace ) ;
		}	
		else
		{
			return m_Namespace == a_Namespace ? 0 : ( m_Namespace < a_Namespace ) ? -1 : 1 ;
		}
	}

	LONG Compare ( const BindingFactoryCacheKey &a_Key ) const
	{
		return CompareNamespace ( a_Key.m_Namespace ) ;
	}
} ;

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

extern LONG CompareElement ( const BindingFactoryCacheKey &a_Arg1 , const BindingFactoryCacheKey &a_Arg2 ) ;

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

extern LONG CompareElement ( const GUID &a_Arg1 , const GUID &a_Arg2 ) ;

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

class ProviderCacheKey 
{
public:

	BSTR m_User ;
	BSTR m_Locale ;
	Enum_Hosting m_HostingSpecification ;
	BSTR m_Provider ;
	bool m_Raw ;
	GUID *m_TransactionIdentifier ;	

public:

	ProviderCacheKey () :

		m_User ( NULL ) ,
		m_Locale ( NULL ) ,
		m_Raw ( false ) ,
		m_Provider ( NULL ) ,
		m_TransactionIdentifier ( NULL ) ,
		m_HostingSpecification ( e_Hosting_Undefined )
	{
	}

	ProviderCacheKey ( 

		const ProviderCacheKey &a_Key

	) : m_User ( NULL ) ,
		m_Locale ( NULL ) ,
		m_TransactionIdentifier ( NULL ) ,
		m_Raw ( a_Key.m_Raw ) ,
		m_HostingSpecification ( a_Key.m_HostingSpecification ) ,
		m_Provider ( NULL )
	{
		if ( a_Key.m_User )
		{
			m_User = SysAllocString ( a_Key.m_User ) ;
		}

		if ( a_Key.m_Locale )
		{
			m_Locale = SysAllocString ( a_Key.m_Locale ) ;
		}

		if ( a_Key.m_Provider ) 
		{
			m_Provider = SysAllocString ( a_Key.m_Provider ) ;
		}

		if ( a_Key.m_TransactionIdentifier )
		{
			m_TransactionIdentifier = new GUID ;
			*m_TransactionIdentifier = *a_Key.m_TransactionIdentifier ;
		}
	}	
	
	ProviderCacheKey ( 

		const wchar_t *a_Provider ,
		const Enum_Hosting &a_HostingSpecification ,
		const bool a_Raw ,
		GUID *a_TransactionIdentifier ,
		const wchar_t *a_User ,
		const wchar_t *a_Locale
	) :
		m_Raw ( a_Raw ) ,
		m_Provider ( NULL ) ,
		m_HostingSpecification ( a_HostingSpecification ),
		m_TransactionIdentifier ( NULL ) ,
		m_User ( NULL ) ,
		m_Locale ( NULL )
	{
		if ( a_User )
		{
			m_User = SysAllocString ( a_User ) ;
		}

		if ( a_Locale )
		{
			m_Locale = SysAllocString ( a_Locale ) ;
		}

		if ( a_Provider ) 
		{
			m_Provider = SysAllocString ( a_Provider ) ;
		}

		if ( a_TransactionIdentifier )
		{
			m_TransactionIdentifier = new GUID ;
			*m_TransactionIdentifier = *a_TransactionIdentifier ;
		}
	}

	~ProviderCacheKey ()
	{
		if ( m_User )
		{
			SysFreeString ( m_User ) ;
		}

		if ( m_Locale )
		{
			SysFreeString ( m_Locale ) ;
		}

		if ( m_Provider ) 
		{
			SysFreeString ( m_Provider ) ;
		}

		if ( m_TransactionIdentifier )
		{
			delete m_TransactionIdentifier ;
		}
	}

	ProviderCacheKey &operator= ( const ProviderCacheKey &a_Key ) 
	{
		m_Raw = a_Key.m_Raw ;
		m_HostingSpecification = a_Key.m_HostingSpecification ;

		if ( m_User )
		{
			SysFreeString ( m_User ) ;
		}

		if ( m_Locale )
		{
			SysFreeString ( m_Locale ) ;
		}

		if ( m_Provider ) 
		{
			SysFreeString ( m_Provider ) ;
		}

		if ( m_TransactionIdentifier )
		{
			delete m_TransactionIdentifier ;
		}
	
		if ( a_Key.m_User )
		{
			m_User = SysAllocString ( a_Key.m_User ) ;
		}

		if ( a_Key.m_Locale )
		{
			m_Locale = SysAllocString ( a_Key.m_Locale ) ;
		}

		if ( a_Key.m_Provider ) 
		{
			m_Provider = SysAllocString ( a_Key.m_Provider ) ;
		}

		if ( a_Key.m_TransactionIdentifier )
		{
			m_TransactionIdentifier = new GUID ;
			*m_TransactionIdentifier = *a_Key.m_TransactionIdentifier ;
		}

		return *this ;
	}

	LONG CompareUser ( const BSTR a_User ) const
	{
		if ( m_User && a_User )
		{
			return _wcsicmp ( m_User , a_User ) ;
		}	
		else
		{
			return m_User == a_User ? 0 : ( m_User < a_User ) ? -1 : 1 ;
		}
	}

	LONG CompareLocale ( const BSTR a_Locale ) const
	{
		if ( m_Locale && a_Locale )
		{
			return _wcsicmp ( m_Locale , a_Locale ) ;
		}	
		else
		{
			return m_Locale == a_Locale ? 0 : ( m_Locale < a_Locale ) ? -1 : 1 ;
		}
	}

	LONG CompareProvider ( const BSTR a_Provider ) const
	{
		if ( m_Provider && a_Provider )
		{
			return _wcsicmp ( m_Provider , a_Provider ) ;
		}	
		else
		{
			return m_Provider == a_Provider ? 0 : ( m_Provider < a_Provider ) ? -1 : 1 ;
		}
	}

	LONG CompareTransaction ( const GUID *a_TransactionIdentifier ) const 
	{
		if ( m_TransactionIdentifier && a_TransactionIdentifier )
		{
			return CompareElement ( *m_TransactionIdentifier , *a_TransactionIdentifier ) ;
		}	
		else
		{
			return m_TransactionIdentifier == a_TransactionIdentifier ? 0 : ( m_TransactionIdentifier < a_TransactionIdentifier ) ? -1 : 1 ;
		}
	}

	LONG Compare ( const ProviderCacheKey &a_Key ) const
	{
		LONG t_CompareUser = CompareUser ( a_Key.m_User ) ;
		if ( t_CompareUser == 0 )
		{
			LONG t_CompareLocale = CompareLocale ( a_Key.m_Locale ) ;
			if ( t_CompareLocale == 0 )
			{
				if ( m_Raw == a_Key.m_Raw ) 
				{
					LONG t_CompareProvider = CompareProvider ( a_Key.m_Provider ) ;
					if ( t_CompareProvider == 0 )
					{
						if ( CompareTransaction ( a_Key.m_TransactionIdentifier ) == 0 )
						{
							return m_HostingSpecification - a_Key.m_HostingSpecification ;
						}
						else
						{
							return CompareElement ( m_TransactionIdentifier , a_Key.m_TransactionIdentifier ) ;
						}
					}
					else
					{
						return t_CompareProvider ;
					}
				}
				else
				{
					return m_Raw - a_Key.m_Raw ;
				}
			}	
			else
			{
				return t_CompareLocale ;
			}
		}	
		else
		{
			return t_CompareUser ;
		}
	}
} ;

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

extern LONG CompareElement ( const ProviderCacheKey &a_Arg1 , const ProviderCacheKey &a_Arg2 ) ;

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

class CServerObject_BindingFactory ;

typedef WmiCacheController <BindingFactoryCacheKey>				CWbemGlobal_IWmiFactoryController ;
typedef CWbemGlobal_IWmiFactoryController :: Cache				CWbemGlobal_IWmiFactoryController_Cache ;
typedef CWbemGlobal_IWmiFactoryController :: Cache_Iterator		CWbemGlobal_IWmiFactoryController_Cache_Iterator ;
typedef CWbemGlobal_IWmiFactoryController :: WmiCacheElement	BindingFactoryCacheElement ;

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

class CInterceptor_IWbemProvider ;

typedef WmiCacheController <ProviderCacheKey>					CWbemGlobal_IWmiProviderController ;
typedef CWbemGlobal_IWmiProviderController :: Cache				CWbemGlobal_IWmiProviderController_Cache ;
typedef CWbemGlobal_IWmiProviderController :: Cache_Iterator		CWbemGlobal_IWmiProviderController_Cache_Iterator ;
typedef CWbemGlobal_IWmiProviderController :: WmiCacheElement	ServiceCacheElement ;

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

class CInterceptor_IWbemObjectSink ;

typedef WmiContainerController <void *>										CWbemGlobal_IWmiObjectSinkController ;
typedef CWbemGlobal_IWmiObjectSinkController :: Container					CWbemGlobal_IWmiObjectSinkController_Container ;
typedef CWbemGlobal_IWmiObjectSinkController :: Container_Iterator			CWbemGlobal_IWmiObjectSinkController_Container_Iterator ;
typedef CWbemGlobal_IWmiObjectSinkController :: WmiContainerElement			ObjectSinkContainerElement ;

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

class Exclusion ;

typedef WmiCacheController <GUID>								CWbemGlobal_ExclusionController ;
typedef CWbemGlobal_ExclusionController :: Cache				CWbemGlobal_ExclusionController_Cache ;
typedef CWbemGlobal_ExclusionController :: Cache_Iterator		CWbemGlobal_ExclusionController_Cache_Iterator ;
typedef CWbemGlobal_ExclusionController :: WmiCacheElement		ExclusionCacheElement ;

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

class CServerObject_ProviderSubSystem ;

typedef WmiContainerController <void *>										CWbemGlobal_IWmiProvSubSysController ;
typedef CWbemGlobal_IWmiProvSubSysController :: Container					CWbemGlobal_IWmiProvSubSysController_Container ;
typedef CWbemGlobal_IWmiProvSubSysController :: Container_Iterator			CWbemGlobal_IWmiProvSubSysController_Container_Iterator ;
typedef CWbemGlobal_IWmiProvSubSysController :: WmiContainerElement			ProvSubSysContainerElement ;

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

class CInterceptor_IWbemSyncProvider ;

typedef WmiContainerController <GUID>										CWbemGlobal_IWbemSyncProviderController ;
typedef CWbemGlobal_IWbemSyncProviderController :: Container				CWbemGlobal_IWbemSyncProvider_Container ;
typedef CWbemGlobal_IWbemSyncProviderController :: Container_Iterator		CWbemGlobal_IWbemSyncProvider_Container_Iterator ;
typedef CWbemGlobal_IWbemSyncProviderController :: WmiContainerElement		SyncProviderContainerElement ;

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

typedef WmiContainerController <DWORD>										CWbemGlobal_HostedProviderController ;
typedef CWbemGlobal_HostedProviderController :: Container					CWbemGlobal_HostedProviderController_Container ;
typedef CWbemGlobal_HostedProviderController :: Container_Iterator			CWbemGlobal_HostedProviderController_Container_Iterator ;
typedef CWbemGlobal_HostedProviderController :: WmiContainerElement			HostedProviderContainerElement ;

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/


#endif _Server_Cache_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\provsubsys\decoupledadaptor\include\globals.h ===
/*++

Copyright (C) 1996-2001 Microsoft Corporation

Module Name:

	Globals.h

Abstract:


History:

--*/

#ifndef _Globals_H
#define _Globals_H

#include <pssException.h>
#include <Allocator.h>
#include <BasicTree.h>
#include <PQueue.h>
#include <ReaderWriter.h>
#include "cglobals.h"
#include "os.h"
/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/


class DecoupledProviderSubSystem_Globals
{
public:

	static WmiAllocator *s_Allocator ;

	static LONG s_LocksInProgress ;
	static LONG s_ObjectsInProgress ;
	static LONG s_RegistrarUsers;

    static LONG s_CServerClassFactory_ObjectsInProgress ;
	static LONG s_CServerObject_ProviderRegistrar_ObjectsInProgress  ;
	static LONG s_CServerObject_ProviderEvents_ObjectsInProgress ;
	static LONG s_CInterceptor_IWbemSyncProvider_ObjectsInProgress;
	static LONG s_CInterceptor_IWbemServices_Stub_ObjectsInProgress;
	static LONG s_CInterceptor_IWbemProviderInitSink_ObjectsInProgress;
	static LONG s_CInterceptor_IWbemWaitingObjectSink_ObjectsInProgress;
	static LONG s_CInterceptor_IWbemObjectSink_ObjectsInProgress;
	static LONG s_CInterceptor_IWbemSyncObjectSink_ObjectsInProgress;
	static LONG s_CInterceptor_IWbemFilteringObjectSink_ObjectsInProgress;
	static LONG s_CInterceptor_IWbemSyncFilteringObjectSink_ObjectsInProgress;
	static LONG s_CInterceptor_IWbemObjectSinkEx_ObjectsInProgress;
	static LONG s_CInterceptor_IWbemSyncObjectSinkEx_ObjectsInProgress;
	static LONG s_CInterceptor_IWbemCombiningObjectSink_ObjectsInProgress;
	static LONG s_CDecoupledAggregator_IWbemProvider_ObjectsInProgress;
	static LONG s_CInterceptor_IWbemDecoupledUnboundObjectSink_ObjectsInProgress;
	static LONG s_CDecoupled_Batching_IWbemSyncObjectSink_ObjectsInProgress;
	static LONG s_CDecoupled_IWbemSyncObjectSink_ObjectsInProgress;
	static LONG s_CInterceptor_DecoupledClient_ObjectsInProgress;
	static LONG s_CInterceptor_IWbemDecoupledProvider_ObjectsInProgress;
	static LONG s_CDecoupled_IWbemUnboundObjectSink_ObjectsInProgress;

	static HRESULT Global_Startup () ;
	static HRESULT Global_Shutdown () ;


	static HRESULT CreateSystemAces(void);
	static HRESULT DeleteSystemAces(void);

	static HRESULT CreateInstance ( 

		const CLSID &a_ReferenceClsid ,
		LPUNKNOWN a_OuterUnknown ,
		const DWORD &a_ClassContext ,
		const UUID &a_ReferenceInterfaceId ,
		void **a_ObjectInterface
	) 
	{
		return ProviderSubSystem_Common_Globals::CreateInstance( a_ReferenceClsid, a_OuterUnknown, a_ClassContext, a_ReferenceInterfaceId, a_ObjectInterface);
	};
	static HRESULT IsDependantCall ( IWbemContext *a_Parent , IWbemContext *a_ChildContext , BOOL &a_DependantCall )
	{
		return ProviderSubSystem_Common_Globals::IsDependantCall ( a_Parent , a_ChildContext , a_DependantCall );
	} ;

	static HRESULT SetProxyState_SvcHost (

		ProxyContainer &a_Container , 
		ULONG a_ProxyIndex ,
		REFIID a_InterfaceId ,
		IUnknown *a_Interface ,
		IUnknown *&a_Proxy , 
		BOOL &a_Revert ,
		DWORD a_ProcessIdentifier ,
		HANDLE &a_IdentifyToken ,
		ACCESS_ALLOWED_ACE *a_Ace ,
		WORD a_AceSize,
		SECURITY_IMPERSONATION_LEVEL t_ImpersonationLevel
	) ;

	static HRESULT RevertProxyState_SvcHost ( 

		ProxyContainer &a_Container , 
		ULONG a_ProxyIndex ,
		IUnknown *a_Proxy , 
		BOOL a_Revert ,
		DWORD a_ProcessIdentifier ,
		HANDLE a_IdentifyToken
	) ;


	static HRESULT RevertProxyState_SvcHost ( 

		IUnknown *a_Proxy , 
		BOOL a_Revert ,
		DWORD a_ProcessIdentifier ,
		HANDLE a_IdentifyToken
	) ;


	static HRESULT SetProxyState (
		REFIID a_InterfaceId ,
		IUnknown *a_Interface ,
		IUnknown *&a_Proxy , 
		BOOL &a_Revert
	) 
	{
		if (OS::secureOS_)
			return ProviderSubSystem_Common_Globals::SetProxyState(a_InterfaceId, a_Interface, a_Proxy, a_Revert);
		else
			return WBEM_E_NOT_FOUND;
	}

	static HRESULT SinkAccessInitialize (SECURITY_DESCRIPTOR *a_RegistrationSecurityDescriptor ,
					SECURITY_DESCRIPTOR *&a_SinkSecurityDescriptor)
	{
		if (OS::secureOS_) return ProviderSubSystem_Common_Globals::SinkAccessInitialize(a_RegistrationSecurityDescriptor, a_SinkSecurityDescriptor);
		else
		{
		  a_SinkSecurityDescriptor = 0;
		  return S_OK;	
		}
	}


	static HRESULT RevertProxyState ( 
		IUnknown *a_Proxy , 
		BOOL a_Revert
	) 
	{
		if (OS::secureOS_)
			return ProviderSubSystem_Common_Globals::RevertProxyState(a_Proxy, a_Revert);
		else
			return S_OK;
	}

	static HRESULT Check_SecurityDescriptor_CallIdentity ( 
		SECURITY_DESCRIPTOR *a_SecurityDescriptor ,
		DWORD a_Access , 
		GENERIC_MAPPING *a_Mapping
	) 
	{
		if (OS::secureOS_)
			return ProviderSubSystem_Common_Globals::Check_SecurityDescriptor_CallIdentity(a_SecurityDescriptor, a_Access, a_Mapping);
		else
			return S_OK;
	}

	static HRESULT UnMarshalRegistration (

		IUnknown **a_Unknown ,
		BYTE *a_MarshaledProxy ,
		DWORD a_MarshaledProxyLength
	) 
	{
		return ProviderSubSystem_Common_Globals::UnMarshalRegistration(a_Unknown, a_MarshaledProxy, a_MarshaledProxyLength);
	};

	static HRESULT MarshalRegistration (

		IUnknown *a_Unknown ,
		BYTE *&a_MarshaledProxy ,
		DWORD &a_MarshaledProxyLength
	) 
	{
		return ProviderSubSystem_Common_Globals::MarshalRegistration(a_Unknown, a_MarshaledProxy, a_MarshaledProxyLength);
	}

	static HRESULT SetCloaking ( IUnknown * proxy , DWORD authenticationLevel , DWORD impersonationLevel ) ;

	static HRESULT RevertProxyState ( 

		ProxyContainer &a_Container , 
		ULONG a_ProxyIndex ,
		IUnknown *a_Proxy , 
		BOOL a_Revert
	) 
	{
		if (OS::secureOS_)
			return ProviderSubSystem_Common_Globals::RevertProxyState(a_Container, a_ProxyIndex, a_Proxy, a_Revert);
		else
            return S_OK;
	};

	static HRESULT BeginImpersonation (

		IUnknown *&a_OldContext ,
		IServerSecurity *&a_OldSecurity ,
		BOOL &a_Impersonating,
		DWORD *a_AuthenticationLevel = NULL
	) ;

	static HRESULT EndImpersonation (
		IUnknown *a_OldContext ,
		IServerSecurity *a_OldSecurity ,
		BOOL a_Impersonating
	)
	{
		if (OS::secureOS_)
			return ProviderSubSystem_Common_Globals::EndImpersonation(a_OldContext, a_OldSecurity, a_Impersonating);
		else
            return S_OK;
	};

	static HRESULT SetProxyState (

		ProxyContainer &a_Container , 
		ULONG a_ProxyIndex ,
		REFIID a_InterfaceId ,
		IUnknown *a_Interface ,
		IUnknown *&a_Proxy , 
		BOOL &a_Revert
	) 
	{
		if (OS::secureOS_)
			return ProviderSubSystem_Common_Globals::SetProxyState(a_Container, a_ProxyIndex, a_InterfaceId, a_Interface, a_Proxy, a_Revert);
		else
			return WBEM_E_NOT_FOUND;
	}

	static HRESULT GetAceWithProcessTokenUser ( 
					
		DWORD a_ProcessIdentifier ,
		WORD &a_AceSize ,
		ACCESS_ALLOWED_ACE *&a_Ace 
	) ;

	static HRESULT GetUserSid (

		HANDLE a_Token ,
		ULONG *a_Size ,
		PSID &a_Sid
	) ;

	static DWORD GetCurrentImpersonationLevel ()
	{
		if (OS::secureOS_)
			return ProviderSubSystem_Common_Globals:: GetCurrentImpersonationLevel();
		else
			return RPC_C_IMP_LEVEL_ANONYMOUS;
	}


	static HRESULT BeginCallbackImpersonation (

		IUnknown *&a_OldContext ,
		IServerSecurity *&a_OldSecurity ,
		BOOL &a_Impersonating
	);
	
	static HRESULT CheckAccess ( 
		SECURITY_DESCRIPTOR *a_SecurityDescriptor ,
		DWORD a_Access , 
		GENERIC_MAPPING *a_Mapping)
	{
		if (OS::secureOS_)
			return ProviderSubSystem_Common_Globals::CheckAccess(a_SecurityDescriptor, a_Access, a_Mapping);
		else
            return S_OK;

	}

	static HRESULT BeginThreadImpersonation (

		IUnknown *&a_OldContext ,
		IServerSecurity *&a_OldSecurity ,
		BOOL &a_Impersonating
	) ;

	static HRESULT EndThreadImpersonation (

		IUnknown *a_OldContext ,
		IServerSecurity *a_OldSecurity ,
		BOOL a_Impersonating 
	) ;

	static HRESULT Begin_IdentifyCall_PrvHost (

		WmiInternalContext a_InternalContext ,
		BOOL &a_Impersonating ,
		IUnknown *&a_OldContext ,
		IServerSecurity *&a_OldSecurity
	) ;

	static HRESULT End_IdentifyCall_PrvHost (

		WmiInternalContext a_InternalContext ,
		IUnknown *&a_OldContext ,
		IServerSecurity *&a_OldSecurity ,
		BOOL &a_Impersonating 
	) ;

	static HRESULT Begin_IdentifyCall_SvcHost (

		WmiInternalContext a_InternalContext ,
		BOOL &a_Impersonating ,
		IUnknown *&a_OldContext ,
		IServerSecurity *&a_OldSecurity
	) ;

	static HRESULT End_IdentifyCall_SvcHost (

		WmiInternalContext a_InternalContext ,
		IUnknown *&a_OldContext ,
		IServerSecurity *&a_OldSecurity ,
		BOOL &a_Impersonating
	) ;



} ;

#endif // _Globals_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\provsubsys\decoupledadaptor\include\provobjectsink.h ===
#ifndef _Common_IWbemObjectSink_H
#define _Common_IWbemObjectSink_H

/*++

Copyright (C) 1996-2001 Microsoft Corporation

Module Name:

	ProvObSk.H

Abstract:


History:

--*/

#include "Queue.h"
#include "CGlobals.h"

#define SYNCPROV_USEBATCH

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

#define ProxyIndex_IWbemObjectSink					0
#define ProxyIndex_Internal_IWbemObjectSink			1
#define ProxyIndex_ObjectSink_Size					2

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

class CCommon_IWbemSyncObjectSink :			public IWbemObjectSink , 
											public IWbemShutdown ,
											public ObjectSinkContainerElement
{
private:

	LONG m_InProgress ;
	LONG m_StatusCalled ;

	ULONG m_Dependant ;
	IWbemObjectSink *m_InterceptedSink ;

#ifdef INTERNAL_IDENTIFY
	Internal_IWbemObjectSink *m_Internal_InterceptedSink ;

	ProxyContainer m_ProxyContainer ;
#endif
	IUnknown *m_Unknown ;

protected:

	LONG m_GateClosed ;

protected:

#ifdef INTERNAL_IDENTIFY

	HRESULT Begin_IWbemObjectSink (

		DWORD a_ProcessIdentifier ,
		HANDLE &a_IdentifyToken ,
		BOOL &a_Impersonating ,
		IUnknown *&a_OldContext ,
		IServerSecurity *&a_OldSecurity ,
		BOOL &a_IsProxy ,
		IUnknown *&a_Interface ,
		BOOL &a_Revert ,
		IUnknown *&a_Proxy
	) ;

	HRESULT End_IWbemObjectSink (

		DWORD a_ProcessIdentifier ,
		HANDLE a_IdentifyToken ,
		BOOL a_Impersonating ,
		IUnknown *a_OldContext ,
		IServerSecurity *a_OldSecurity ,
		BOOL a_IsProxy ,
		IUnknown *a_Interface ,
		BOOL a_Revert ,
		IUnknown *a_Proxy
	) ;
#endif

    HRESULT STDMETHODCALLTYPE Helper_Indicate (

		long a_ObjectCount ,
		IWbemClassObject **a_ObjectArray
	) ;

    HRESULT STDMETHODCALLTYPE Helper_SetStatus (

		long a_Flags ,
		HRESULT a_Result ,
		BSTR a_StringParamater ,
		IWbemClassObject *a_ObjectParameter
	) ;

public:

	CCommon_IWbemSyncObjectSink (

		WmiAllocator &a_Allocator ,
		IWbemObjectSink *a_InterceptedSink ,
		IUnknown *a_Unknown ,
		CWbemGlobal_IWmiObjectSinkController *a_Controller ,
		ULONG a_Dependant = FALSE
	) ;

	~CCommon_IWbemSyncObjectSink() ;

	void CallBackInternalRelease () ;

	virtual HRESULT SinkInitialize () ;

	//Non-delegating object IUnknown

    STDMETHODIMP QueryInterface ( REFIID , LPVOID FAR * ) ;
    STDMETHODIMP_( ULONG ) AddRef () ;
    STDMETHODIMP_( ULONG ) Release () ;

    HRESULT STDMETHODCALLTYPE Indicate (

		long a_ObjectCount ,
		IWbemClassObject **a_ObjectArray
	) ;

    HRESULT STDMETHODCALLTYPE SetStatus (

		long a_Flags ,
		HRESULT a_Result ,
		BSTR a_StringParamater ,
		IWbemClassObject *a_ObjectParameter
	) ;

	HRESULT STDMETHODCALLTYPE Shutdown (

		LONG a_Flags ,
		ULONG a_MaxMilliSeconds ,
		IWbemContext *a_Context
	) ; 
} ;

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

class CCommon_Batching_IWbemSyncObjectSink :	public CCommon_IWbemSyncObjectSink
{
private:

	DWORD m_Size ;
	WmiQueue <IWbemClassObject *,8> m_Queue ;
	CriticalSection m_CriticalSection ;

protected:
public:

	CCommon_Batching_IWbemSyncObjectSink (

		WmiAllocator &a_Allocator ,
		IWbemObjectSink *a_InterceptedSink ,
		IUnknown *a_Unknown ,
		CWbemGlobal_IWmiObjectSinkController *a_Controller ,
		ULONG a_Dependant = FALSE
	) ;

	~CCommon_Batching_IWbemSyncObjectSink () ;

	HRESULT SinkInitialize () ;

    HRESULT STDMETHODCALLTYPE Indicate (

		long a_ObjectCount ,
		IWbemClassObject **a_ObjectArray
	) ;

    HRESULT STDMETHODCALLTYPE SetStatus (

		long a_Flags ,
		HRESULT a_Result ,
		BSTR a_StringParamater ,
		IWbemClassObject *a_ObjectParameter
	) ;
} ;

#endif _Common_IWbemObjectSink_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\provsubsys\decoupledadaptor\include\provdnf.h ===
// (C) 1999-2001 Microsoft Corporation 

#ifndef __DNF_TREE_H
#define __DNF_TREE_H

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

#include <stdio.h>
#include <wmiutils.h>

#include "ProvTree.h"

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

enum WmiTriState
{
	State_False		= 0 ,
	State_True		= 1 ,
	State_Error		= 0xFFFFFFFF
} ;

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

#define TypeId_WmiOrNode						1
#define TypeId_WmiAndNode						2
#define TypeId_WmiNotNode						3
#define TypeId_WmiOperatorNode					4
#define TypeId_WmiOperatorEqualNode				5
#define TypeId_WmiOperatorNotEqualNode			6
#define TypeId_WmiOperatorEqualOrGreaterNode	7
#define TypeId_WmiOperatorEqualOrLessNode		8
#define TypeId_WmiOperatorGreaterNode			9
#define TypeId_WmiOperatorLessNode				10
#define TypeId_WmiOperatorLikeNode				11
#define TypeId_WmiOperatorNotLikeNode			12
#define TypeId_WmiOperatorIsANode				13
#define TypeId_WmiOperatorNotIsANode			14
#define TypeId_WmiValueNode						15
#define TypeId_WmiSignedIntegerNode				16	
#define TypeId_WmiUnsignedIntegerNode			17
#define TypeId_WmiStringNode					18
#define TypeId_WmiNullNode						19
#define TypeId_WmiRangeNode						20
#define TypeId_WmiUnsignedIntegerRangeNode		21
#define TypeId_WmiSignedIntegerRangeNode		22
#define TypeId_WmiStringRangeNode				23
#define TypeId_WmiNullRangeNode					24

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

class WmiOrNode : public WmiTreeNode
{
private:
protected:
public:

	WmiOrNode ( 

		WmiTreeNode *a_Left = NULL , 
		WmiTreeNode *a_Right = NULL ,
		WmiTreeNode *a_Parent = NULL 

	) : WmiTreeNode ( TypeId_WmiOrNode , NULL , a_Left , a_Right , a_Parent ) {}

	~WmiOrNode () ;

	WmiTreeNode *Copy () ;

	void Print () ;
} ;

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

class WmiAndNode : public WmiTreeNode
{
private:
protected:
public:

	WmiAndNode ( 

		WmiTreeNode *a_Left = NULL , 
		WmiTreeNode *a_Right = NULL ,
		WmiTreeNode *a_Parent = NULL 

	) : WmiTreeNode ( TypeId_WmiAndNode , NULL , a_Left , a_Right , a_Parent ) {}

	~WmiAndNode () ;

	WmiTreeNode *Copy () ;

	void Print () ;
} ;

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

class WmiNotNode : public WmiTreeNode
{
private:
protected:
public:

	WmiNotNode ( 

		WmiTreeNode *a_Node = NULL ,
		WmiTreeNode *a_Parent = NULL 

	) : WmiTreeNode ( TypeId_WmiNotNode , NULL , a_Node , NULL , a_Parent ) {}

	~WmiNotNode () ;

	WmiTreeNode *Copy () ;

	void Print () ;
} ;

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

class WmiRangeNode ;

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

class WmiOperatorNode : public WmiTreeNode
{
private:
protected:
public:

	WmiOperatorNode ( 

		TypeId_TreeNode a_Type , 
		WmiTreeNode *a_Node = NULL ,
		WmiTreeNode *a_Parent = NULL 

	) : WmiTreeNode ( a_Type , NULL , a_Node , NULL , a_Parent ) {}

	~WmiOperatorNode () {} ;

	virtual WmiRangeNode *GetRange () = 0 ;
} ;

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

class WmiOperatorEqualNode : public WmiOperatorNode
{
private:
protected:
public:

	WmiOperatorEqualNode ( 

		WmiTreeNode *a_Node = NULL ,
		WmiTreeNode *a_Parent = NULL 

	) : WmiOperatorNode ( TypeId_WmiOperatorEqualNode , a_Node , a_Parent ) {}

	~WmiOperatorEqualNode () ;

	WmiTreeNode *Copy () ;

	WmiRangeNode *GetRange () ;

	void Print () ;
} ;

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

class WmiOperatorNotEqualNode : public WmiOperatorNode
{
private:
protected:
public:

	WmiOperatorNotEqualNode ( 

		WmiTreeNode *a_Node = NULL ,
		WmiTreeNode *a_Parent = NULL 

	) : WmiOperatorNode ( TypeId_WmiOperatorNotEqualNode , a_Node , a_Parent ) {}

	~WmiOperatorNotEqualNode () ;

	WmiTreeNode *Copy () ;

	WmiRangeNode *GetRange () { return NULL ; }

	void Print () ;
} ;

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

class WmiOperatorEqualOrGreaterNode : public WmiOperatorNode
{
private:
protected:
public:

	WmiOperatorEqualOrGreaterNode ( 

		WmiTreeNode *a_Node = NULL ,
		WmiTreeNode *a_Parent = NULL 

	) : WmiOperatorNode ( TypeId_WmiOperatorEqualOrGreaterNode , a_Node , a_Parent ) {}

	~WmiOperatorEqualOrGreaterNode () ;

	WmiTreeNode *Copy () ;

	WmiRangeNode *GetRange () ;

	void Print () ;
} ;

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

class WmiOperatorEqualOrLessNode : public WmiOperatorNode
{
private:
protected:
public:

	WmiOperatorEqualOrLessNode ( 

		WmiTreeNode *a_Node = NULL ,
		WmiTreeNode *a_Parent = NULL 

	) : WmiOperatorNode ( TypeId_WmiOperatorEqualOrLessNode , a_Node , a_Parent ) {}

	~WmiOperatorEqualOrLessNode () ;

	WmiTreeNode *Copy () ;

	WmiRangeNode *GetRange () ;

	void Print () ;
} ;

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

class WmiOperatorGreaterNode : public WmiOperatorNode
{
private:
protected:
public:

	WmiOperatorGreaterNode ( 

		WmiTreeNode *a_Node = NULL ,
		WmiTreeNode *a_Parent = NULL 

	) : WmiOperatorNode ( TypeId_WmiOperatorGreaterNode , a_Node , a_Parent ) {}

	~WmiOperatorGreaterNode () ;

	WmiTreeNode *Copy () ;

	WmiRangeNode *GetRange () ;

	void Print () ;
} ;

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

class WmiOperatorLessNode : public WmiOperatorNode
{
private:
protected:
public:

	WmiOperatorLessNode ( 

		WmiTreeNode *a_Node = NULL ,
		WmiTreeNode *a_Parent = NULL 

	) : WmiOperatorNode ( TypeId_WmiOperatorLessNode , a_Node , a_Parent ) {}

	~WmiOperatorLessNode () ;

	WmiTreeNode *Copy () ;

	WmiRangeNode *GetRange () ;

	void Print () ;
} ;

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

class WmiOperatorLikeNode : public WmiOperatorNode
{
private:
protected:
public:

	WmiOperatorLikeNode ( 

		WmiTreeNode *a_Node = NULL ,
		WmiTreeNode *a_Parent = NULL 

	) : WmiOperatorNode ( TypeId_WmiOperatorLikeNode , a_Node , a_Parent ) {}

	~WmiOperatorLikeNode () ;

	WmiTreeNode *Copy () ;

	WmiRangeNode *GetRange () ;

	void Print () ;
} ;

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/
 
class WmiOperatorNotLikeNode : public WmiOperatorNode
{
private:
protected:
public:

	WmiOperatorNotLikeNode ( 

		WmiTreeNode *a_Node = NULL ,
		WmiTreeNode *a_Parent = NULL 

	) : WmiOperatorNode ( TypeId_WmiOperatorNotLikeNode , a_Node , a_Parent ) {}

	~WmiOperatorNotLikeNode () ;

	WmiTreeNode *Copy () ;

	WmiRangeNode *GetRange () ;

	void Print () ;
} ;

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

class WmiOperatorIsANode : public WmiOperatorNode
{
private:
protected:
public:

	WmiOperatorIsANode ( 

		WmiTreeNode *a_Node = NULL ,
		WmiTreeNode *a_Parent = NULL 

	) : WmiOperatorNode ( TypeId_WmiOperatorIsANode , a_Node , a_Parent ) {}

	~WmiOperatorIsANode () ;

	WmiTreeNode *Copy () ;

	WmiRangeNode *GetRange () ;

	void Print () ;
} ;

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

class WmiOperatorNotIsANode : public WmiOperatorNode
{
private:
protected:
public:

	WmiOperatorNotIsANode ( 

		WmiTreeNode *a_Node = NULL ,
		WmiTreeNode *a_Parent = NULL 

	) : WmiOperatorNode ( TypeId_WmiOperatorNotIsANode , a_Node , a_Parent ) {}

	~WmiOperatorNotIsANode () ;

	WmiTreeNode *Copy () ;

	WmiRangeNode *GetRange () ;

	void Print () ;
} ;

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

class WmiValueNode : public WmiTreeNode
{
public:

	enum WmiValueFunction
	{
		Function_None = 0 ,
		Function_Upper = 1 ,
		Function_Lower = 2
	} ;

private:
protected:

	BSTR m_PropertyName ;
	ULONG m_Index ;
	WmiValueFunction m_PropertyFunction ;
	WmiValueFunction m_ConstantFunction ;

public:

	WmiValueNode ( 

		TypeId_TreeNode a_Type ,
		BSTR a_PropertyName ,
		WmiValueFunction a_PropertyFunction ,
		WmiValueFunction a_ConstantFunction ,
		ULONG a_Index ,
		WmiTreeNode *a_Parent = NULL 

	) : WmiTreeNode ( a_Type , NULL , NULL , NULL , a_Parent ) ,
		m_PropertyFunction ( a_PropertyFunction ) ,
		m_ConstantFunction ( a_ConstantFunction ) ,
		m_Index ( a_Index )
	{
		if ( a_PropertyName )
		{
			m_PropertyName = SysAllocString ( a_PropertyName ) ;
		}
		else
		{
			m_PropertyName = NULL ;
		}
	}

	~WmiValueNode ()
	{
		if ( m_PropertyName )
			SysFreeString ( m_PropertyName ) ;
	}

	BSTR GetPropertyName ()
	{
		return m_PropertyName ;
	}

	ULONG GetIndex () { return m_Index ; }

	WmiValueNode :: WmiValueFunction GetPropertyFunction ()
	{
		return m_PropertyFunction ;
	}

	WmiValueNode :: WmiValueFunction GetConstantFunction ()
	{
		return m_ConstantFunction ;
	}

	LONG ComparePropertyName ( WmiValueNode &a_ValueNode ) 
	{
		if ( m_Index < a_ValueNode.m_Index )
		{
			return -1 ;
		}
		else if ( m_Index > a_ValueNode.m_Index )
		{
			return 1 ;
		}
		else
		{
			return _wcsicmp ( m_PropertyName , a_ValueNode.m_PropertyName ) ;
		}
	}
} ;

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

class WmiSignedIntegerNode : public WmiValueNode
{
private:
protected:

	LONG m_Integer ;

public:

	WmiSignedIntegerNode ( 

		BSTR a_PropertyName ,
		LONG a_Integer ,
		ULONG a_Index ,
		WmiTreeNode *a_Parent = NULL 

	) : WmiValueNode ( 

			TypeId_WmiSignedIntegerNode ,
			a_PropertyName , 
			Function_None , 
			Function_None ,
			a_Index ,
			a_Parent 
		) , m_Integer ( a_Integer ) 
	{
	}

	WmiTreeNode *Copy () ;

	BOOL LexicographicallyBefore ( LONG &a_Integer )
	{
		if ( m_Integer == 0x80000000 )
		{
			return FALSE ;
		}
		else
		{
			a_Integer = m_Integer - 1 ;
			return TRUE ;
		}
	}

	BOOL LexicographicallyAfter ( LONG &a_Integer )
	{
		if ( m_Integer == 0x7FFFFFFF )
		{
			return FALSE ;
		}
		else
		{
			a_Integer = m_Integer + 1 ;
			return TRUE ;
		}
	}

	LONG GetValue ()
	{
		return m_Integer ;
	}

	void Print () ;
} ;

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

class WmiUnsignedIntegerNode : public WmiValueNode
{
private:
protected:

	ULONG m_Integer ;

public:

	WmiUnsignedIntegerNode ( 

		BSTR a_PropertyName ,
		ULONG a_Integer ,
		ULONG a_Index ,
		WmiTreeNode *a_Parent = NULL 

	) : WmiValueNode ( 

			TypeId_WmiUnsignedIntegerNode ,
			a_PropertyName , 
			Function_None , 
			Function_None ,
			a_Index ,
			a_Parent 

		) , m_Integer ( a_Integer ) 
	{
	}

	WmiTreeNode *Copy () ;

	BOOL LexicographicallyBefore ( ULONG &a_Integer )
	{
		if ( m_Integer == 0 )
		{
			return FALSE ;
		}
		else
		{
			a_Integer = m_Integer - 1 ;
			return TRUE ;
		}
	}

	BOOL LexicographicallyAfter ( ULONG &a_Integer )
	{
		if ( m_Integer == 0xFFFFFFFF )
		{
			return FALSE ;
		}
		else
		{
			a_Integer = m_Integer + 1 ;
			return TRUE ;
		}
	}

	ULONG GetValue ()
	{
		return m_Integer ;
	}

	void Print () ;
} ;

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

class WmiStringNode : public WmiValueNode
{
private:
protected:

	BSTR m_String ;

public:

	WmiStringNode ( 

		BSTR a_PropertyName ,
		BSTR a_String ,
		WmiValueNode :: WmiValueFunction a_PropertyFunction ,
		WmiValueNode :: WmiValueFunction a_ConstantFunction ,
		ULONG a_Index ,
		WmiTreeNode *a_Parent = NULL 

	) : WmiValueNode ( 

			TypeId_WmiStringNode ,
			a_PropertyName , 
			a_PropertyFunction , 
			Function_None ,
			a_Index ,
			a_Parent 
		) 
	{
		if ( a_String ) 
		{
			if ( a_ConstantFunction == Function_Upper )
			{
				ULONG t_StringLength = wcslen ( a_String ) ;
				wchar_t *t_String = new wchar_t [ t_StringLength + 1 ] ;
				for ( ULONG t_Index = 0 ; t_Index < t_StringLength ; t_Index ++ )
				{
					t_String [ t_Index ] = towlower ( a_String [ t_Index ] ) ;
				}

				m_String = SysAllocString ( t_String ) ;
				delete [] t_String ;
			}
			else if ( a_ConstantFunction == Function_Upper )
			{
				ULONG t_StringLength = wcslen ( a_String ) ;
				wchar_t *t_String = new wchar_t [ t_StringLength + 1 ] ;
				for ( ULONG t_Index = 0 ; t_Index < t_StringLength ; t_Index ++ )
				{
					t_String [ t_Index ] = towupper ( a_String [ t_Index ] ) ;
				}

				m_String = SysAllocString ( t_String ) ;
				delete [] t_String ;
			}
			else
			{
				m_String = SysAllocString ( a_String ) ;
			}
		}
		else
		{
			m_String = NULL ;
		}
	}

	~WmiStringNode ()
	{
		if ( m_String )
		{
			SysFreeString ( m_String ) ;
		}
	} ;

	WmiTreeNode *Copy () ;

	BOOL LexicographicallyBefore ( BSTR &a_String )
	{
		if ( wcscmp ( L"" , m_String ) == 0 )
		{
			return FALSE ;
		}
		else
		{
			ULONG t_StringLen = wcslen ( m_String ) ;
			wchar_t *t_String = NULL ;

			if ( m_String [ t_StringLen - 1 ] == 0x01 )
			{
				t_String = new wchar_t [ t_StringLen ] ;
				wcsncpy ( t_String , m_String , t_StringLen - 1 ) ;
				t_String [ t_StringLen ] = 0 ;
			}
			else
			{
				t_String = new wchar_t [ t_StringLen + 1 ] ;
				wcscpy ( t_String , m_String ) ;
				t_String [ t_StringLen - 1 ] = t_String [ t_StringLen - 1 ] - 1 ;
			}			
			
			a_String = SysAllocString ( t_String ) ;
			delete [] t_String ;

			return TRUE ;
		}
	}

	BOOL LexicographicallyAfter ( BSTR &a_String )
	{
		ULONG t_StringLen = wcslen ( m_String ) ;
		wchar_t *t_String = new wchar_t [ t_StringLen + 2 ] ;
		wcscpy ( t_String , m_String ) ;
		t_String [ t_StringLen ] = 0x01 ;
		t_String [ t_StringLen ] = 0x00 ;

		a_String = SysAllocString ( t_String ) ;

		delete [] t_String ;

		return TRUE ;
	}

	BSTR GetValue ()
	{
		return m_String ;
	}

	void Print () ;
} ;

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

class WmiNullNode : public WmiValueNode
{
private:
protected:
public:

	WmiNullNode ( 

		BSTR a_PropertyName ,
		ULONG a_Index ,
		WmiTreeNode *a_Parent = NULL 

	) : WmiValueNode ( 

			TypeId_WmiNullNode ,
			a_PropertyName , 
			Function_None , 
			Function_None ,
			a_Index ,
			a_Parent 
		) 
	{
	}

	WmiTreeNode *Copy () ;

	void Print () ;
} ;

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

class WmiRangeNode : public WmiTreeNode
{
private:
protected:

	BSTR m_PropertyName ;
	ULONG m_Index ;

	BOOL m_InfiniteLowerBound ;
	BOOL m_InfiniteUpperBound ;

	BOOL m_LowerBoundClosed;
	BOOL m_UpperBoundClosed;

public:

	LONG ComparePropertyName ( WmiRangeNode &a_RangeNode ) 
	{
		if ( m_Index < a_RangeNode.m_Index )
		{
			return -1 ;
		}
		else if ( m_Index > a_RangeNode.m_Index )
		{
			return 1 ;
		}
		else
		{
			return _wcsicmp ( m_PropertyName , a_RangeNode.m_PropertyName ) ;
		}
	}

public:

	WmiRangeNode ( 

		TypeId_TreeNode a_Type ,
		BSTR a_PropertyName ,
		ULONG a_Index ,
		BOOL a_InfiniteLowerBound ,
		BOOL a_InfiniteUpperBound ,
		BOOL a_LowerBoundClosed ,
		BOOL a_UpperBoundClosed ,
		WmiTreeNode *a_NextNode = NULL ,
		WmiTreeNode *a_Parent = NULL 
		
	) : WmiTreeNode ( a_Type , NULL , NULL , a_NextNode , a_Parent ),
		m_InfiniteLowerBound ( a_InfiniteLowerBound ) , 
		m_InfiniteUpperBound ( a_InfiniteUpperBound ) ,
		m_LowerBoundClosed ( a_LowerBoundClosed ) ,
		m_UpperBoundClosed ( a_UpperBoundClosed ) ,
		m_Index ( a_Index )
	{
		if ( a_PropertyName )
		{
			m_PropertyName = SysAllocString ( a_PropertyName ) ;
		}
		else
		{
			m_PropertyName = NULL ;
		}
	} ;

	~WmiRangeNode () 
	{
		if ( m_PropertyName )
		{
			SysFreeString ( m_PropertyName ) ;
		}
	} ;

	BSTR GetPropertyName ()
	{
		return m_PropertyName ;
	}

	ULONG GetIndex () { return m_Index ; }

	BOOL InfiniteLowerBound () { return m_InfiniteLowerBound ; }
	BOOL InfiniteUpperBound () { return m_InfiniteUpperBound ; }

	BOOL ClosedLowerBound () { return m_LowerBoundClosed ; }
	BOOL ClosedUpperBound () { return m_UpperBoundClosed ; }
} ;

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

class WmiUnsignedIntegerRangeNode : public WmiRangeNode
{
private:
protected:

	ULONG m_LowerBound ;
	ULONG m_UpperBound ;

public:

	WmiTreeNode *Copy () ;
	
	WmiTriState GetIntersectingRange (

		WmiUnsignedIntegerRangeNode &a_Range ,
		WmiUnsignedIntegerRangeNode *&a_Intersection
	) ;

	WmiTriState GetOverlappingRange (

		WmiUnsignedIntegerRangeNode &a_Range ,
		WmiUnsignedIntegerRangeNode *&a_Intersection
	) ;

	WmiTriState GetNonIntersectingRange (

		WmiUnsignedIntegerRangeNode &a_Range ,
		WmiUnsignedIntegerRangeNode *&a_Before ,
		WmiUnsignedIntegerRangeNode *&a_Intersection ,
		WmiUnsignedIntegerRangeNode *&a_After 
	) ;

public:

	WmiUnsignedIntegerRangeNode (

		BSTR a_PropertyName ,
		ULONG a_Index ,
		BOOL a_InfiniteLowerBound ,
		BOOL a_InfiniteUpperBound ,
		BOOL a_LowerBoundClosed ,
		BOOL a_UpperBoundClosed ,
		ULONG a_LowerBound ,
		ULONG a_UpperBound ,
		WmiTreeNode *a_NextNode = NULL ,
		WmiTreeNode *a_Parent = NULL 

	) : WmiRangeNode ( 

			TypeId_WmiUnsignedIntegerRangeNode ,
			a_PropertyName , 
			a_Index , 
			a_InfiniteLowerBound , 
			a_InfiniteUpperBound ,
			a_LowerBoundClosed ,
			a_UpperBoundClosed ,
			a_NextNode ,
			a_Parent 
		) , 
		m_LowerBound ( a_LowerBound ) , 
		m_UpperBound ( a_UpperBound ) 
	{
	}

	ULONG LowerBound () { return m_LowerBound ; }
	ULONG UpperBound () { return m_UpperBound ; }

	void Print () ;
} ;

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

class WmiSignedIntegerRangeNode : public WmiRangeNode
{
private:
protected:

	LONG m_LowerBound ;
	LONG m_UpperBound ;

public:

	WmiTreeNode *Copy () ;

	WmiTriState GetIntersectingRange (

		WmiSignedIntegerRangeNode &a_Range ,
		WmiSignedIntegerRangeNode *&a_Intersection
	) ;

	WmiTriState GetOverlappingRange (

		WmiSignedIntegerRangeNode &a_Range ,
		WmiSignedIntegerRangeNode *&a_Intersection
	) ;

	WmiTriState GetNonIntersectingRange (

		WmiSignedIntegerRangeNode &a_Range ,
		WmiSignedIntegerRangeNode *&a_Before ,
		WmiSignedIntegerRangeNode *&a_Intersection ,
		WmiSignedIntegerRangeNode *&a_After 
	) ;

public:

	WmiSignedIntegerRangeNode (

		BSTR a_PropertyName ,
		ULONG a_Index ,
		BOOL a_InfiniteLowerBound ,
		BOOL a_InfiniteUpperBound ,
		BOOL a_LowerBoundClosed ,
		BOOL a_UpperBoundClosed ,
		LONG a_LowerBound ,
		LONG a_UpperBound ,
		WmiTreeNode *a_NextNode = NULL ,
		WmiTreeNode *a_Parent = NULL 

	) : WmiRangeNode ( 

			TypeId_WmiSignedIntegerRangeNode ,
			a_PropertyName , 
			a_Index , 
			a_InfiniteLowerBound , 
			a_InfiniteUpperBound ,
			a_LowerBoundClosed ,
			a_UpperBoundClosed ,
			a_NextNode ,
			a_Parent 
		) , 
		m_LowerBound ( a_LowerBound ) , 
		m_UpperBound ( a_UpperBound ) 
	{
	}

	LONG LowerBound () { return m_LowerBound ; }
	LONG UpperBound () { return m_UpperBound ; }

	void Print () ;
} ;

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/
 
class WmiStringRangeNode : public WmiRangeNode
{
private:
protected:

	BSTR m_LowerBound ;
	BSTR m_UpperBound ;

public:

	WmiTreeNode *Copy () ;

	WmiTriState GetIntersectingRange (

		WmiStringRangeNode &a_Range ,
		WmiStringRangeNode *&a_Intersection
	) ;

	WmiTriState GetOverlappingRange (

		WmiStringRangeNode &a_Range ,
		WmiStringRangeNode *&a_Intersection
	) ;

	WmiTriState GetNonIntersectingRange (

		WmiStringRangeNode &a_Range ,
		WmiStringRangeNode *&a_Before ,
		WmiStringRangeNode *&a_Intersection ,
		WmiStringRangeNode *&a_After 
	) ;

public:

	WmiStringRangeNode ( 

		BSTR a_PropertyName ,
		ULONG a_Index ,
		BOOL a_InfiniteLowerBound ,
		BOOL a_InfiniteUpperBound ,
		BOOL a_LowerBoundClosed ,
		BOOL a_UpperBoundClosed ,
		BSTR a_LowerBound ,
		BSTR a_UpperBound ,
		WmiTreeNode *a_NextNode = NULL ,
		WmiTreeNode *a_Parent = NULL 

	) : WmiRangeNode ( 

			TypeId_WmiStringRangeNode ,
			a_PropertyName , 
			a_Index , 
			a_InfiniteLowerBound , 
			a_InfiniteUpperBound ,
			a_LowerBoundClosed ,
			a_UpperBoundClosed ,
			a_NextNode ,
			a_Parent 
		) 
	{
		if ( a_LowerBound )
		{
			m_LowerBound = SysAllocString ( a_LowerBound ) ;
		}
		else
		{
			m_LowerBound = NULL ;
		}

		if ( a_UpperBound )
		{
			m_UpperBound = SysAllocString ( a_UpperBound ) ;
		}
		else
		{
			m_UpperBound = NULL ;
		}
	}

	~WmiStringRangeNode ()
	{
		if ( m_LowerBound )
		{
			SysFreeString ( m_LowerBound ) ;
		}

		if ( m_UpperBound )
		{
			SysFreeString ( m_UpperBound ) ;
		}
	} ;

	BSTR LowerBound () { return m_LowerBound ; }
	BSTR UpperBound () { return m_UpperBound ; }

	void Print () ;
} ;

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

class WmiNullRangeNode : public WmiRangeNode
{
private:
protected:
public:

	WmiNullRangeNode ( 

		BSTR a_PropertyName ,
		ULONG a_Index ,
		WmiTreeNode *a_NextNode = NULL ,
		WmiTreeNode *a_Parent = NULL 

	) : WmiRangeNode ( 

			TypeId_WmiNullRangeNode ,
			a_PropertyName , 
			a_Index , 
			TRUE ,
			TRUE ,
			FALSE ,
			FALSE ,
			a_NextNode ,
			a_Parent 
		) 
	{
	}

	~WmiNullRangeNode ()
	{
	} ;

	WmiTreeNode *Copy () ;

	void Print () ;
} ;

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

class Conjunctions
{
private:
protected:

/* 
 *	Range values for the set of properties in a disjunction.
 *	Array index is ordered in property order.
 */

	ULONG m_RangeContainerCount ;
	WmiRangeNode **m_RangeContainer ;
	
public:

	Conjunctions (

		ULONG a_RangeContainerCount 

	) :	m_RangeContainerCount ( a_RangeContainerCount ) ,
		m_RangeContainer ( NULL )
	{
	}

	~Conjunctions () 
	{
		if ( m_RangeContainer )
		{
			for ( ULONG t_Index = 0 ; t_Index < m_RangeContainerCount ; t_Index ++ )
			{
				delete m_RangeContainer [ t_Index ] ;
			}

			delete [] m_RangeContainer ;
		}
	} ;	

	WmiTriState Initialize ()
	{
		WmiTriState t_Status = State_True ;

		m_RangeContainer = new WmiRangeNode * [ m_RangeContainerCount ] ;
		if ( m_RangeContainer )
		{
			for ( ULONG t_Index = 0 ; t_Index < m_RangeContainerCount ; t_Index ++ )
			{
				m_RangeContainer [ t_Index ] = NULL ;
			}
		}
		else
		{
			t_Status = State_Error ; 
		}

		return t_Status ;
	}

	ULONG GetRangeCount () 
	{
		return m_RangeContainerCount ;
	}

	WmiRangeNode *GetRange ( ULONG a_Index ) 
	{
		if ( m_RangeContainerCount > a_Index ) 
		{
			return m_RangeContainer [ a_Index ] ;
		}
		else
		{
			return NULL ;
		}
	}

	void SetRange ( ULONG a_Index , WmiRangeNode *a_Range ) 
	{
		if ( m_RangeContainerCount > a_Index ) 
		{
			if ( m_RangeContainer [ a_Index ] )
			{
				delete m_RangeContainer [ a_Index ] ;
			}

			m_RangeContainer [ a_Index ] = a_Range ;
		}		
	}
} ;

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

class Disjunctions 
{
private:
protected:

/* 
 *	Range values for the set of properties in a disjunction.
 *	Array index is ordered in property order.
 */

	ULONG m_ConjunctionCount ;
	ULONG m_DisjunctionCount ;
	Conjunctions **m_Disjunction ;
	
public:

	Disjunctions (

		ULONG a_DisjunctionCount ,
		ULONG a_ConjunctionCount 

	) :	m_DisjunctionCount ( a_DisjunctionCount ) ,
		m_ConjunctionCount ( a_ConjunctionCount ) ,
		m_Disjunction ( NULL )
	{
	}

	WmiTriState Initialize ()
	{
		WmiTriState t_Status = State_True ;

		m_Disjunction = new Conjunctions * [ m_DisjunctionCount ] ;
		if ( m_Disjunction )
		{
			for ( ULONG t_Index = 0 ; t_Index < m_DisjunctionCount ; t_Index ++ )
			{
				m_Disjunction [ t_Index ] = NULL ;
			}

			for ( t_Index = 0 ; t_Index < m_DisjunctionCount ; t_Index ++ )
			{
				Conjunctions *t_Disjunction = new Conjunctions ( m_ConjunctionCount ) ;
				if ( t_Disjunction )
				{
					t_Status = t_Disjunction->Initialize () ;
					if ( t_Status != State_True )
					{
						break ;
					}
				}
				else
				{
					t_Status = State_Error ;
					break ;
				}

				m_Disjunction [ t_Index ] = t_Disjunction ;
			}
		}
		else
		{
			t_Status = State_Error ;
		}

		return t_Status ;
	}

	~Disjunctions () 
	{
		if ( m_Disjunction )
		{
			for ( ULONG t_Index = 0 ; t_Index < m_DisjunctionCount ; t_Index ++ )
			{
				Conjunctions *t_Disjunction = m_Disjunction [ t_Index ] ;
				delete t_Disjunction ;
			}
			
			delete [] m_Disjunction ;
		}
	} ;	

	ULONG GetDisjunctionCount () 
	{
		return m_DisjunctionCount ;
	}

	ULONG GetConjunctionCount () 
	{
		return m_ConjunctionCount ;
	}

	Conjunctions *GetDisjunction ( ULONG a_Index ) 
	{
		if ( m_DisjunctionCount > a_Index ) 
		{
			return m_Disjunction [ a_Index ] ;
		}
		else
		{
			return NULL ;
		}
	}
} ;

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

class PartitionSet
{
private:
protected:

/*
 *	Null for top level
 */
	ULONG m_KeyIndex ;
	WmiRangeNode *m_Range ;

/*
 *	Number of non overlapping partitions, zero when all keys have been partitioned
 */

	ULONG m_NumberOfNonOverlappingPartitions ;
	PartitionSet **m_NonOverlappingPartitions ;

public:

	PartitionSet ()	:	m_Range ( NULL ) ,
						m_KeyIndex ( 0 ) ,
						m_NumberOfNonOverlappingPartitions ( 0 ) ,
						m_NonOverlappingPartitions ( NULL )
	{
	}

	virtual ~PartitionSet () 
	{
		delete m_Range ;

		if ( m_NonOverlappingPartitions )
		{
			for ( ULONG t_Index = 0 ; t_Index < m_NumberOfNonOverlappingPartitions ; t_Index ++ )
			{
				delete m_NonOverlappingPartitions [ t_Index ] ;
			}

			delete [] m_NonOverlappingPartitions ;
		}
	}

public:

	WmiTriState Initialize ( ULONG a_Count ) 
	{
		WmiTriState t_Status = State_True ;

		m_NumberOfNonOverlappingPartitions = a_Count ;
		m_NonOverlappingPartitions = new PartitionSet * [ a_Count ] ;
		if ( m_NonOverlappingPartitions )
		{
			for ( ULONG t_Index = 0 ; t_Index < a_Count ; t_Index ++ )
			{
				m_NonOverlappingPartitions [ t_Index ] = NULL ;
			}
		}
		else
		{
			t_Status = State_Error ;
		}

		return t_Status ;
	}
	
	void SetPartition ( ULONG a_Index , PartitionSet *a_Partition )
	{
		if ( a_Index < m_NumberOfNonOverlappingPartitions ) 
		{
			m_NonOverlappingPartitions [ a_Index ] = a_Partition ;
		}
	}

public:

	ULONG GetKeyIndex () { return m_KeyIndex ; }
	void SetKeyIndex ( ULONG a_KeyIndex ) { m_KeyIndex = a_KeyIndex ; }

	BOOL Root () { return m_Range == NULL ; }
	BOOL Leaf () { return m_NonOverlappingPartitions == NULL ; }

	void SetRange ( WmiRangeNode *a_Range ) { m_Range = a_Range ; }
	WmiRangeNode *GetRange () { return m_Range ; }

	ULONG GetPartitionCount () { return m_NumberOfNonOverlappingPartitions ; }

	PartitionSet *GetPartition ( ULONG a_Index )
	{
		if ( a_Index < m_NumberOfNonOverlappingPartitions ) 
		{
			return m_NonOverlappingPartitions [ a_Index ] ;
		}
		else
		{
			return NULL ;
		}
	}
} ;

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

class QueryPreprocessor 
{
public:

	enum QuadState {

		State_True ,
		State_False ,
		State_ReEvaluate ,
		State_Undefined ,
		State_Error 
	} ;

private:
protected:

	BOOL RecursiveEvaluate ( 

		void *a_Context ,
		SWbemRpnQueryToken ** a_Expression , 
		WmiTreeNode *a_Parent , 
		WmiTreeNode **a_Node ,
		int &a_Index 
	) ;

	void TransformAndOrExpression ( 

		WmiTreeNode *&a_Node , 
		WmiTreeNode *a_AndChild , 
		WmiTreeNode *a_OrChild 
	) ;

	void TransformNotNotExpression ( 

		WmiTreeNode *&a_Node , 
		WmiTreeNode *a_Child 
	) ;

	void TransformNotAndExpression ( 

		WmiTreeNode *&a_Node , 
		WmiTreeNode *a_Child 
	) ;

	void TransformNotOperatorEqualExpression ( 

		WmiTreeNode *&a_Node , 
		WmiTreeNode *a_Child 
	) ;

	void TransformNotOperatorNotEqualExpression ( 

		WmiTreeNode *&a_Node , 
		WmiTreeNode *a_Child 
	) ;

	void TransformNotOperatorEqualOrGreaterExpression ( 

		WmiTreeNode *&a_Node , 
		WmiTreeNode *a_Child 
	) ;

	void TransformNotOperatorEqualOrLessExpression ( 

		WmiTreeNode *&a_Node , 
		WmiTreeNode *a_Child 
	) ;

	void TransformNotOperatorGreaterExpression ( 

		WmiTreeNode *&a_Node , 
		WmiTreeNode *a_Child 
	) ;

	void TransformNotOperatorLessExpression ( 

		WmiTreeNode *&a_Node , 
		WmiTreeNode *a_Child 
	) ;

	void TransformNotOperatorLikeExpression ( 

		WmiTreeNode *&a_Node , 
		WmiTreeNode *a_Child 
	) ;

	void TransformNotOperatorNotLikeExpression ( 

		WmiTreeNode *&a_Node , 
		WmiTreeNode *a_Child 
	) ;

	void TransformNotOperatorIsAExpression ( 

		WmiTreeNode *&a_Node , 
		WmiTreeNode *a_Child 
	) ;

	void TransformNotOperatorNotIsAExpression ( 

		WmiTreeNode *&a_Node , 
		WmiTreeNode *a_Child 
	) ;

	void TransformNotOrExpression ( 

		WmiTreeNode *&a_Node , 
		WmiTreeNode *a_Child 
	) ;

	void TransformNotEqualExpression ( 

		WmiTreeNode *&a_Node , 
		WmiTreeNode *a_Child 
	) ;

	void TransformAndTrueEvaluation ( 

		WmiTreeNode *&a_Node , 
		WmiTreeNode *a_Child 
	) ;

	void TransformOrFalseEvaluation ( 

		WmiTreeNode *&a_Node , 
		WmiTreeNode *a_Child 
	) ;

	void TransformOperatorToRange ( 

		WmiTreeNode *&a_Node
	) ;

	void TransformIntersectingRange (

		WmiTreeNode *&a_Node ,
		WmiTreeNode *a_Compare ,
		WmiTreeNode *a_Intersection
	) ;

	void TransformNonIntersectingRange (

		WmiTreeNode *&a_Node ,
		WmiTreeNode *a_Compare
	) ;

	WmiTriState EvaluateNotEqualExpression ( WmiTreeNode *&a_Node ) ;

	WmiTriState EvaluateNotExpression ( WmiTreeNode *&a_Node ) ;

	WmiTriState EvaluateAndExpression ( WmiTreeNode *&a_Node ) ;

	WmiTriState EvaluateOrExpression ( WmiTreeNode *&a_Node ) ;

	QuadState RecursiveDisjunctiveNormalForm ( WmiTreeNode *&a_Node ) ;

	QuadState RecursiveRemoveInvariants ( void *a_Context , WmiTreeNode *&a_Root ) ;

	WmiTriState RecursiveInsertNode ( WmiTreeNode *&a_Root , WmiTreeNode *&a_Node ) ;
	WmiTriState InsertNode ( WmiTreeNode *&a_Root , WmiTreeNode *&a_Node ) ;

	WmiTriState RecursiveSortConditionals ( WmiTreeNode *&a_Root , WmiTreeNode *&a_NewRoot ) ;
	WmiTriState SortConditionals ( WmiTreeNode *&a_Root ) ;
	WmiTriState RecursiveSort ( WmiTreeNode *&a_Root ) ;

	WmiTriState RecursiveConvertToRanges ( WmiTreeNode *&a_Root ) ;
	
	QuadState RecursiveRemoveNonOverlappingRanges ( WmiTreeNode *&a_Root , WmiTreeNode *&a_Compare ) ;

	void CountDisjunctions ( WmiTreeNode *a_Root , ULONG &a_Count ) ;

	WmiTriState CreateDisjunctions ( 

		void *a_Context ,
		WmiTreeNode *a_Node , 
		Disjunctions *a_Disjunctions , 
		ULONG a_PropertiesToPartitionCount ,
		BSTR *a_PropertiesToPartition ,
		ULONG &a_DisjunctionIndex 
	) ;

	WmiTriState RecursivePartitionSet ( 

		Disjunctions *a_Disjunctions , 
		PartitionSet *&a_Partition , 
		ULONG a_DisjunctionSetToTestCount ,
		ULONG *a_DisjunctionSetToTest ,
		ULONG a_KeyIndex 
	) ;

protected:

/*
 *	Given a property name and it's value convert to it's correct type.
 *	e.g. if the CIMType of a_PropertyName is uint32 then create an WmiUnsignedIntegerNode
 *	return NULL if error.
 */

	virtual WmiTreeNode *AllocTypeNode ( 

		void *a_Context ,
		BSTR a_PropertyName , 
		VARIANT &a_Variant , 
		WmiValueNode :: WmiValueFunction a_PropertyFunction ,
		WmiValueNode :: WmiValueFunction a_ConstantFunction ,
		WmiTreeNode *a_Parent 

	) ;

	virtual QuadState InvariantEvaluate ( 

		void *a_Context ,
		WmiTreeNode *a_Operator ,
		WmiTreeNode *a_Operand 

	) { return State_Undefined ; }

	virtual WmiRangeNode *AllocInfiniteRangeNode (

		void *a_Context ,
		BSTR a_PropertyName 

	) { return NULL ; }

protected:

	BOOL Evaluate (

		void *a_Context ,
		SWbemRpnQueryToken **a_Expression , 
		int a_Count ,
		WmiTreeNode **a_Root
	) ;

	QuadState DisjunctiveNormalForm ( WmiTreeNode *&a_Root ) ;

	void RecursiveQuickSort (

		WmiRangeNode **a_Array , 
		ULONG *a_UnsortedOrder ,
		ULONG a_Lower , 
		ULONG a_Upper
	) ;

	void QuickSort (

		WmiRangeNode **a_Array , 
		ULONG *a_UnsortedOrder ,
		ULONG a_Size
	) ;

	void SortRanges (

		ULONG a_DisjunctionCount ,
		ULONG *a_OriginToSorted ,
		WmiRangeNode **a_RangeTable 
	) ;

	WmiTriState RemoveOverlaps (

		ULONG *a_DisjunctionSetToTest ,
		ULONG a_DisjunctionCount ,
		ULONG *a_OverlappingIndex ,
		ULONG *a_OriginToSorted ,
		WmiRangeNode **a_RangeTable 
	) ;

	QuadState RemoveInvariants ( void *a_Context , WmiTreeNode *&a_Root ) ;

	WmiTriState Sort ( WmiTreeNode *&a_Root ) ;

	WmiTriState ConvertToRanges ( WmiTreeNode *&a_Root ) ;

	QuadState RemoveNonOverlappingRanges ( WmiTreeNode *&a_Root ) ;

	WmiTriState CreateDisjunctionContainer (

		void *a_Context , 
		WmiTreeNode *a_Root , 
		ULONG a_Count , 
		BSTR *a_Container , 
		Disjunctions *&a_Disjunctions
	) ;

	WmiTriState CreatePartitionSet ( 

		Disjunctions *a_Disjunctions , 
		PartitionSet *&a_Partition
	) ;

	void PrintTree ( WmiTreeNode *a_Root ) ;

public:

	QueryPreprocessor () ;
	virtual ~QueryPreprocessor () ;

	QuadState PreProcess (

		void *a_Context , 
		IWbemQuery *a_QueryAnalysis , 
		WmiTreeNode *&a_Root
	) ;

	QuadState PreProcess ( 

		void *a_Context ,
		IWbemQuery *a_QueryAnalysis ,
		WmiTreeNode *a_Root ,
		ULONG a_Count , 
		BSTR *a_Container , 
		PartitionSet *&a_Partition
	) ;

	QuadState Query ( 

		BSTR a_Query ,
		IWbemQuery *a_QueryAnalysis
	) ;
} ;

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\provsubsys\decoupledadaptor\include\provinsk.h ===
#ifndef _Server_Interceptor_IWbemProviderInitSink_H
#define _Server_Interceptor_IWbemProviderInitSink_H

/*++

Copyright (C) 1996-2001 Microsoft Corporation

Module Name:

	ProvObSk.H

Abstract:


History:

--*/


/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

class CServerObject_ProviderInitSink : public IWbemProviderInitSink 
{
private:

	LONG m_ReferenceCount ;

	BOOL m_StatusCalled ;

	HANDLE m_Event ;

	HRESULT m_Result ;

	SECURITY_DESCRIPTOR *m_SecurityDescriptor ;

protected:

public:

	CServerObject_ProviderInitSink ( SECURITY_DESCRIPTOR *a_SecurityDescriptor = 
NULL ) ;
	virtual ~CServerObject_ProviderInitSink () ;

	HRESULT SinkInitialize ( SECURITY_DESCRIPTOR *a_SecurityDescriptor = NULL ) ;

	STDMETHODIMP QueryInterface (

		REFIID iid , 
		LPVOID FAR *iplpv 
	) ;

	STDMETHODIMP_( ULONG ) AddRef () ;

	STDMETHODIMP_(ULONG) Release () ;

    HRESULT STDMETHODCALLTYPE SetStatus (

        LONG a_Status,
        LONG a_Flags 
	) ;

	void Wait ( DWORD a_Timeout = 300000 ) 
	{
		if ( WaitForSingleObject ( m_Event , a_Timeout ) == WAIT_TIMEOUT )
		{
			m_Result = WBEM_E_PROVIDER_LOAD_FAILURE ;
		}
	}

	void Reset () 
	{
		ResetEvent ( m_Event ) ;
		m_Result = S_OK ;
	}

	HRESULT GetResult () { return m_Result ; }
} ;


/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

class CInterceptor_IWbemProviderInitSink : public IWbemProviderInitSink
{
private:

	LONG m_ReferenceCount ;

	LONG m_GateClosed ;
	LONG m_InProgress ;

	BOOL m_StatusCalled ;

	IWbemProviderInitSink *m_InterceptedSink ;

protected:
public:

	CInterceptor_IWbemProviderInitSink (

		IWbemProviderInitSink *a_InterceptedSink
	) ;

	~CInterceptor_IWbemProviderInitSink () ;

	//Non-delegating object IUnknown

    STDMETHODIMP QueryInterface ( REFIID , LPVOID FAR * ) ;
    STDMETHODIMP_( ULONG ) AddRef () ;
    STDMETHODIMP_( ULONG ) Release () ;

    HRESULT STDMETHODCALLTYPE SetStatus (

        LONG a_Status,
        LONG a_Flags 
	) ;

	HRESULT STDMETHODCALLTYPE Shutdown () ;
} ;

#endif _Server_Interceptor_IWbemProviderInitSink_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\provsubsys\decoupledadaptor\include\provevt.h ===
/*++

Copyright (C) 1996-2001 Microsoft Corporation

Module Name:

	ProvWsv.H

Abstract:


History:

--*/

#ifndef _Server_EventProvider_H
#define _Server_EventProvider_H

#include "Globals.h"
#include "CGlobals.h"

class CServerObject_ProviderEvents ;

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

class CEventProvider :					public IWbemEventProvider ,
										public IWbemEventProviderQuerySink ,
										public IWbemEventProviderSecurity ,
										public IWbemProviderIdentity ,
										public IWbemEventConsumerProviderEx ,
										public IWbemProviderInit , 
										public IWbemShutdown 
{
private:

	LONG m_ReferenceCount ;
    LONG m_InternalReferenceCount ;

	CriticalSection m_CriticalSection ;

	IUnknown *m_Unknown ;
	IWbemEventProvider *m_Provider_IWbemEventProvider ;
	IWbemEventProviderQuerySink *m_Provider_IWbemEventProviderQuerySink ;
	IWbemEventProviderSecurity *m_Provider_IWbemEventProviderSecurity ;
	IWbemProviderIdentity *m_Provider_IWbemProviderIdentity ;
	IWbemEventConsumerProvider *m_Provider_IWbemEventConsumerProvider ;
	IWbemEventConsumerProviderEx *m_Provider_IWbemEventConsumerProviderEx ;

	IWbemServices *m_CoreService ;
	IUnknown *m_Provider ;
	CServerObject_ProviderEvents *m_EventRegistrar ;

public:

	BSTR m_Locale ;
	BSTR m_User ;
	BSTR m_Namespace ;

private:

public:

	CEventProvider ( 

		WmiAllocator &a_Allocator ,
		CServerObject_ProviderEvents *a_EventRegistrar ,
		IUnknown *a_Unknown
	) ;

    ~CEventProvider () ;

	HRESULT Initialize () ;

	HRESULT UnRegister () ;

public:

	//Non-delegating object IUnknown

    STDMETHODIMP QueryInterface ( REFIID , LPVOID FAR * ) ;
    STDMETHODIMP_( ULONG ) AddRef () ;
    STDMETHODIMP_( ULONG ) Release () ;

    STDMETHODIMP_( ULONG ) InternalAddRef () ;
    STDMETHODIMP_( ULONG ) InternalRelease () ;

	/* IWbemEventProvider */

	HRESULT STDMETHODCALLTYPE ProvideEvents (

		IWbemObjectSink *a_Sink ,
		long a_Flags
	) ;

	/* IWbemEventProviderQuerySink */

	HRESULT STDMETHODCALLTYPE NewQuery (

		unsigned long a_Id ,
		WBEM_WSTR a_QueryLanguage ,
		WBEM_WSTR a_Query
	);

	HRESULT STDMETHODCALLTYPE CancelQuery (

		unsigned long a_Id
	) ;

	/* IWbemEventProviderSecurity */

	HRESULT STDMETHODCALLTYPE AccessCheck (

		WBEM_CWSTR a_QueryLanguage ,
		WBEM_CWSTR a_Query ,
		long a_SidLength ,
		const BYTE *a_Sid
	) ;

	/* IWbemProviderIdentity */

	HRESULT STDMETHODCALLTYPE SetRegistrationObject (

		long a_Flags ,
		IWbemClassObject *a_ProviderRegistration
	) ;

	/* IWbemEventConsumerProvider */

	HRESULT STDMETHODCALLTYPE FindConsumer (

		IWbemClassObject *a_LogicalConsumer ,
		IWbemUnboundObjectSink **a_Consumer
	);

	/* IWbemEventConsumerProviderEx */

	HRESULT STDMETHODCALLTYPE ValidateSubscription (

		IWbemClassObject *a_LogicalConsumer
	) ;

	/* IWbemProviderInit methods */

	HRESULT STDMETHODCALLTYPE Initialize (

		LPWSTR a_User,
		LONG a_Flags,
		LPWSTR a_Namespace,
		LPWSTR a_Locale,
		IWbemServices *a_CoreService,         // For anybody
		IWbemContext *a_Context,
		IWbemProviderInitSink *a_Sink     // For init signals
	) ;

	// IWbemShutdown members

	HRESULT STDMETHODCALLTYPE Shutdown (

		LONG a_Flags ,
		ULONG a_MaxMilliSeconds ,
		IWbemContext *a_Context
	) ; 
} ;

#endif // _Server_EventProvider_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\provsubsys\decoupledadaptor\include\provtree.h ===
// (C) 1999-2001 Microsoft Corporation 
#ifndef WMI_TREE
#define WMI_TREE

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

typedef DWORD TypeId_TreeNode ;

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

class WmiTreeNode 
{
protected:

	TypeId_TreeNode m_Type ;

	void *m_Data ;
	WmiTreeNode *m_Left ;
	WmiTreeNode *m_Right ;
	WmiTreeNode *m_Parent ;
	
public:

	WmiTreeNode ( 

		WmiTreeNode *a_Node 
	) 
	{
		m_Type = a_Node->m_Type ;
		m_Data = a_Node->m_Data ;
		m_Left = a_Node->m_Left ;
		m_Right = a_Node->m_Right ;
		m_Parent = a_Node->m_Parent ;
	}

	WmiTreeNode ( 

		TypeId_TreeNode a_Type = 0 ,
		void *a_Data = NULL ,
		WmiTreeNode *a_Left = NULL ,
		WmiTreeNode *a_Right = NULL ,
		WmiTreeNode *a_Parent = NULL 
	) 
	{
		m_Type = a_Type ;
		m_Parent = a_Parent ;
		m_Data = a_Data ;
		m_Left = a_Left ;
		m_Right = a_Right ;

		if ( m_Left )
			m_Left->SetParent ( this ) ;

		if ( m_Right )
			m_Right->SetParent ( this ) ;
	}

	virtual ~WmiTreeNode () {}

	TypeId_TreeNode GetType ()
	{
		return m_Type ;
	}

	void *GetData () 
	{
		return m_Data ; 
	}

	WmiTreeNode *GetLeft () 
	{ 
		return m_Left ; 
	}

	WmiTreeNode *GetRight () 
	{
		return m_Right ; 
	}

	WmiTreeNode *GetParent () 
	{
		return m_Parent ; 
	}

	void GetData ( void **a_Data ) 
	{
		*a_Data = & m_Data ; 
	}

	void GetLeft ( WmiTreeNode **&a_Left ) 
	{ 
		a_Left = &m_Left ; 
	}

	void GetRight ( WmiTreeNode **&a_Right ) 
	{
		a_Right = &m_Right ; 
	}

	void GetParent ( WmiTreeNode **&a_Parent ) 
	{
		a_Parent = &m_Parent ; 
	}

	void SetType ( TypeId_TreeNode a_Type )
	{
		m_Type = a_Type ;
	}

	void *SetData ( void *a_Data )
	{
		void *t_Data = m_Data ;
		m_Data = a_Data ;
		return t_Data ;
	}

	WmiTreeNode *SetLeft ( WmiTreeNode *a_Left )
	{
		WmiTreeNode *t_Left = m_Left ;
		m_Left = a_Left ;
		return t_Left ;
	}

	WmiTreeNode *SetRight ( WmiTreeNode *a_Right ) 
	{
		WmiTreeNode *t_Right = m_Right ;
		m_Right = a_Right ;
		return t_Right ;
	}

	WmiTreeNode *SetParent ( WmiTreeNode *a_Parent ) 
	{
		WmiTreeNode *t_Parent = m_Parent ;
		m_Parent = a_Parent ;
		return t_Parent ;
	}

	virtual WmiTreeNode *Copy () ;	// Copy node, not allocating copies of data and allocating copies of sub tree

	virtual WmiTreeNode *CopyNode () ; // Copy node, not allocating copies of data and subtree

	virtual void Print () {} ;
} ;

class WmiTreeNodeIterator 
{
protected:

	WmiTreeNode *m_Iterator ;

public:

	WmiTreeNodeIterator ( WmiTreeNodeIterator *a_WmiTreeNodeIterator )
	{
		m_Iterator = a_WmiTreeNodeIterator->m_Iterator ; 
	}

	WmiTreeNodeIterator ( WmiTreeNode *a_Root ) 
	{
		m_Iterator = a_Root ; 
	}

	virtual ~WmiTreeNodeIterator () {}

	WmiTreeNode *GetIterator () 
	{
		return m_Iterator ; 
	}

	WmiTreeNode *SetIterator ( WmiTreeNode *a_Iterator ) 
	{ 
		WmiTreeNode *t_Iterator = m_Iterator ;
		m_Iterator = a_Iterator ;
		return t_Iterator ;
	}

	virtual WmiTreeNodeIterator *Copy ()	
	{
		WmiTreeNodeIterator *t_Iterator = new WmiTreeNodeIterator ( m_Iterator ) ;
		return t_Iterator ;
	}

	void InOrder () ;
	void PreOrder () ;
	void PostOrder () ;
} ;

#endif // WMI_TREE
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\provsubsys\decoupledadaptor\include\provobsk.h ===
#ifndef _Server_Interceptor_IWbemObjectSink_H
#define _Server_Interceptor_IWbemObjectSink_H

/*++

Copyright (C) 1996-2001 Microsoft Corporation

Module Name:

	ProvObSk.H

Abstract:


History:

--*/

#include "ProvCache.h"
#include "Queue.h"

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

class CInterceptor_IWbemObjectSink :	public IWbemObjectSink , 
										public IWbemShutdown ,
#ifdef INTERNAL_IDENTIFY
										public Internal_IWbemObjectSink , 
#endif
										public ObjectSinkContainerElement
{
private:

	LONG m_GateClosed ;
	LONG m_InProgress ;
	LONG m_StatusCalled ;

	IWbemObjectSink *m_InterceptedSink ;
	IUnknown *m_Unknown ;
	SECURITY_DESCRIPTOR *m_SecurityDescriptor ;


protected:
public:

	CInterceptor_IWbemObjectSink (

		IWbemObjectSink *a_InterceptedSink ,
		IUnknown *a_Unknown ,
		CWbemGlobal_IWmiObjectSinkController *a_Controller 
	) ;

	~CInterceptor_IWbemObjectSink () ;
	HRESULT Initialize ( SECURITY_DESCRIPTOR *a_SecurityDescriptor ) ;

	void CallBackRelease () ;

	//Non-delegating object IUnknown

    STDMETHODIMP QueryInterface ( REFIID , LPVOID FAR * ) ;
    STDMETHODIMP_( ULONG ) AddRef () ;
    STDMETHODIMP_( ULONG ) Release () ;

    HRESULT STDMETHODCALLTYPE Indicate (

		long a_ObjectCount ,
		IWbemClassObject **a_ObjectArray
	) ;

    HRESULT STDMETHODCALLTYPE SetStatus (

		long a_Flags ,
		HRESULT a_Result ,
		BSTR a_StringParamater ,
		IWbemClassObject *a_ObjectParameter
	) ;

	HRESULT STDMETHODCALLTYPE Shutdown (

		LONG a_Flags ,
		ULONG a_MaxMilliSeconds ,
		IWbemContext *a_Context
	) ; 
} ;

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

class CInterceptor_DecoupledIWbemObjectSink :	public IWbemObjectSink , 
												public IWbemShutdown ,
												public ObjectSinkContainerElement
{
private:

	LONG m_GateClosed ;
	LONG m_InProgress ;
	LONG m_StatusCalled ;

	IWbemObjectSink *m_InterceptedSink ;
	IUnknown *m_Unknown ;

protected:
public:

	CInterceptor_DecoupledIWbemObjectSink (

		IWbemObjectSink *a_InterceptedSink ,
		IUnknown *a_Unknown ,
		CWbemGlobal_IWmiObjectSinkController *a_Controller 
	) ;

	~CInterceptor_DecoupledIWbemObjectSink () ;

	void CallBackRelease () ;

	//Non-delegating object IUnknown

    STDMETHODIMP QueryInterface ( REFIID , LPVOID FAR * ) ;
    STDMETHODIMP_( ULONG ) AddRef () ;
    STDMETHODIMP_( ULONG ) Release () ;

    HRESULT STDMETHODCALLTYPE Indicate (

		long a_ObjectCount ,
		IWbemClassObject **a_ObjectArray
	) ;

    HRESULT STDMETHODCALLTYPE SetStatus (

		long a_Flags ,
		HRESULT a_Result ,
		BSTR a_StringParamater ,
		IWbemClassObject *a_ObjectParameter
	) ;

	HRESULT STDMETHODCALLTYPE Shutdown (

		LONG a_Flags ,
		ULONG a_MaxMilliSeconds ,
		IWbemContext *a_Context
	) ; 
} ;

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

class CInterceptor_IWbemSyncObjectSink :	public IWbemObjectSink , 
											public IWbemShutdown ,
											public ObjectSinkContainerElement
{
private:

	LONG m_GateClosed ;
	LONG m_InProgress ;
	LONG m_StatusCalled ;

	Exclusion *m_Exclusion ;
	ULONG m_Dependant ;
	IWbemObjectSink *m_InterceptedSink ;
	IUnknown *m_Unknown ;

protected:
public:

	CInterceptor_IWbemSyncObjectSink (

		IWbemObjectSink *a_InterceptedSink ,
		IUnknown *a_Unknown ,
		CWbemGlobal_IWmiObjectSinkController *a_Controller ,
		Exclusion *a_Exclusion = NULL ,
		ULONG a_Dependant = FALSE
	) ;

	~CInterceptor_IWbemSyncObjectSink() ;

	void CallBackRelease () ;

	//Non-delegating object IUnknown

    STDMETHODIMP QueryInterface ( REFIID , LPVOID FAR * ) ;
    STDMETHODIMP_( ULONG ) AddRef () ;
    STDMETHODIMP_( ULONG ) Release () ;

    HRESULT STDMETHODCALLTYPE Indicate (

		long a_ObjectCount ,
		IWbemClassObject **a_ObjectArray
	) ;

    HRESULT STDMETHODCALLTYPE SetStatus (

		long a_Flags ,
		HRESULT a_Result ,
		BSTR a_StringParamater ,
		IWbemClassObject *a_ObjectParameter
	) ;

	HRESULT STDMETHODCALLTYPE Shutdown (

		LONG a_Flags ,
		ULONG a_MaxMilliSeconds ,
		IWbemContext *a_Context
	) ; 
} ;

/*****************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

class CInterceptor_IWbemSyncObjectSink_GetObjectAsync : public CInterceptor_IWbemSyncObjectSink
{
private:

	long m_Flags ;
	BSTR m_ObjectPath ;
	CInterceptor_IWbemSyncProvider *m_Interceptor ;

protected:
public:

	CInterceptor_IWbemSyncObjectSink_GetObjectAsync (

		long a_Flags ,
		BSTR a_ObjectPath ,
		CInterceptor_IWbemSyncProvider *a_Interceptor ,
		IWbemObjectSink *a_InterceptedSink ,
		IUnknown *a_Unknown ,
		CWbemGlobal_IWmiObjectSinkController *a_Controller ,
		Exclusion *a_Exclusion = NULL ,
		ULONG a_Dependant = FALSE
	) ;

	~CInterceptor_IWbemSyncObjectSink_GetObjectAsync () ;

    HRESULT STDMETHODCALLTYPE SetStatus (

		long a_Flags ,
		HRESULT a_Result ,
		BSTR a_StringParamater ,
		IWbemClassObject *a_ObjectParameter
	) ;
} ;

/*****************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

class CInterceptor_IWbemSyncObjectSink_DeleteInstanceAsync : public CInterceptor_IWbemSyncObjectSink
{
private:

	long m_Flags ;
	BSTR m_ObjectPath ;
	CInterceptor_IWbemSyncProvider *m_Interceptor ;

protected:
public:

	CInterceptor_IWbemSyncObjectSink_DeleteInstanceAsync (

		long a_Flags ,
		BSTR a_ObjectPath ,
		CInterceptor_IWbemSyncProvider *a_Interceptor ,
		IWbemObjectSink *a_InterceptedSink ,
		IUnknown *a_Unknown ,
		CWbemGlobal_IWmiObjectSinkController *a_Controller ,
		Exclusion *a_Exclusion = NULL ,
		ULONG a_Dependant = FALSE
	) ;

	~CInterceptor_IWbemSyncObjectSink_DeleteInstanceAsync () ;

    HRESULT STDMETHODCALLTYPE SetStatus (

		long a_Flags ,
		HRESULT a_Result ,
		BSTR a_StringParamater ,
		IWbemClassObject *a_ObjectParameter
	) ;
} ;

/*****************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

class CInterceptor_IWbemSyncObjectSink_DeleteClassAsync : public CInterceptor_IWbemSyncObjectSink
{
private:

	long m_Flags ;
	BSTR m_Class ;
	CInterceptor_IWbemSyncProvider *m_Interceptor ;

protected:
public:

	CInterceptor_IWbemSyncObjectSink_DeleteClassAsync (

		long a_Flags ,
		BSTR a_Class ,
		CInterceptor_IWbemSyncProvider *a_Interceptor ,
		IWbemObjectSink *a_InterceptedSink ,
		IUnknown *a_Unknown ,
		CWbemGlobal_IWmiObjectSinkController *a_Controller ,
		Exclusion *a_Exclusion = NULL ,
		ULONG a_Dependant = FALSE
	) ;

	~CInterceptor_IWbemSyncObjectSink_DeleteClassAsync () ;

    HRESULT STDMETHODCALLTYPE SetStatus (

		long a_Flags ,
		HRESULT a_Result ,
		BSTR a_StringParamater ,
		IWbemClassObject *a_ObjectParameter
	) ;
} ;

/*****************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

class CInterceptor_IWbemSyncObjectSink_PutInstanceAsync : public CInterceptor_IWbemSyncObjectSink
{
private:

	long m_Flags ;
	IWbemClassObject *m_Instance ;
	CInterceptor_IWbemSyncProvider *m_Interceptor ;

protected:
public:

	CInterceptor_IWbemSyncObjectSink_PutInstanceAsync (

		long a_Flags ,
		IWbemClassObject *a_Class ,
		CInterceptor_IWbemSyncProvider *a_Interceptor ,
		IWbemObjectSink *a_InterceptedSink ,
		IUnknown *a_Unknown ,
		CWbemGlobal_IWmiObjectSinkController *a_Controller ,
		Exclusion *a_Exclusion = NULL ,
		ULONG a_Dependant = FALSE
	) ;

	~CInterceptor_IWbemSyncObjectSink_PutInstanceAsync () ;

    HRESULT STDMETHODCALLTYPE SetStatus (

		long a_Flags ,
		HRESULT a_Result ,
		BSTR a_StringParamater ,
		IWbemClassObject *a_ObjectParameter
	) ;
} ;

/*****************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

class CInterceptor_IWbemSyncObjectSink_PutClassAsync : public CInterceptor_IWbemSyncObjectSink
{
private:

	long m_Flags ;
	IWbemClassObject *m_Class ;
	CInterceptor_IWbemSyncProvider *m_Interceptor ;

protected:
public:

	CInterceptor_IWbemSyncObjectSink_PutClassAsync (

		long a_Flags ,
		IWbemClassObject *a_Class ,
		CInterceptor_IWbemSyncProvider *a_Interceptor ,
		IWbemObjectSink *a_InterceptedSink ,
		IUnknown *a_Unknown ,
		CWbemGlobal_IWmiObjectSinkController *a_Controller ,
		Exclusion *a_Exclusion = NULL ,
		ULONG a_Dependant = FALSE
	) ;

	~CInterceptor_IWbemSyncObjectSink_PutClassAsync () ;

    HRESULT STDMETHODCALLTYPE SetStatus (

		long a_Flags ,
		HRESULT a_Result ,
		BSTR a_StringParamater ,
		IWbemClassObject *a_ObjectParameter
	) ;
} ;

/*****************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

class CInterceptor_IWbemSyncObjectSink_CreateInstanceEnumAsync : public CInterceptor_IWbemSyncObjectSink
{
private:

	long m_Flags ;
	BSTR m_Class ;
	CInterceptor_IWbemSyncProvider *m_Interceptor ;

protected:
public:

	CInterceptor_IWbemSyncObjectSink_CreateInstanceEnumAsync (

		long a_Flags ,
		BSTR a_Class ,
		CInterceptor_IWbemSyncProvider *a_Interceptor ,
		IWbemObjectSink *a_InterceptedSink ,
		IUnknown *a_Unknown ,
		CWbemGlobal_IWmiObjectSinkController *a_Controller ,
		Exclusion *a_Exclusion = NULL ,
		ULONG a_Dependant = FALSE
	) ;

	~CInterceptor_IWbemSyncObjectSink_CreateInstanceEnumAsync () ;

    HRESULT STDMETHODCALLTYPE SetStatus (

		long a_Flags ,
		HRESULT a_Result ,
		BSTR a_StringParamater ,
		IWbemClassObject *a_ObjectParameter
	) ;
} ;

/*****************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

class CInterceptor_IWbemSyncObjectSink_CreateClassEnumAsync : public CInterceptor_IWbemSyncObjectSink
{
private:

	long m_Flags ;
	BSTR m_SuperClass ;
	CInterceptor_IWbemSyncProvider *m_Interceptor ;

protected:
public:

	CInterceptor_IWbemSyncObjectSink_CreateClassEnumAsync (

		long a_Flags ,
		BSTR a_SuperClass ,
		CInterceptor_IWbemSyncProvider *a_Interceptor ,
		IWbemObjectSink *a_InterceptedSink ,
		IUnknown *a_Unknown ,
		CWbemGlobal_IWmiObjectSinkController *a_Controller ,
		Exclusion *a_Exclusion = NULL ,
		ULONG a_Dependant = FALSE
	) ;

	~CInterceptor_IWbemSyncObjectSink_CreateClassEnumAsync () ;

    HRESULT STDMETHODCALLTYPE SetStatus (

		long a_Flags ,
		HRESULT a_Result ,
		BSTR a_StringParamater ,
		IWbemClassObject *a_ObjectParameter
	) ;
} ;

/*****************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

class CInterceptor_IWbemSyncObjectSink_ExecQueryAsync : public CInterceptor_IWbemSyncObjectSink
{
private:

	long m_Flags ;
	BSTR m_QueryLanguage ;
	BSTR m_Query ;
	CInterceptor_IWbemSyncProvider *m_Interceptor ;

protected:
public:

	CInterceptor_IWbemSyncObjectSink_ExecQueryAsync (

		long a_Flags ,
		BSTR a_QueryLanguage ,
		BSTR a_Query ,
		CInterceptor_IWbemSyncProvider *a_Interceptor ,
		IWbemObjectSink *a_InterceptedSink ,
		IUnknown *a_Unknown ,
		CWbemGlobal_IWmiObjectSinkController *a_Controller ,
		Exclusion *a_Exclusion = NULL ,
		ULONG a_Dependant = FALSE
	) ;

	~CInterceptor_IWbemSyncObjectSink_ExecQueryAsync () ;

    HRESULT STDMETHODCALLTYPE SetStatus (

		long a_Flags ,
		HRESULT a_Result ,
		BSTR a_StringParamater ,
		IWbemClassObject *a_ObjectParameter
	) ;
} ;

/*****************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

class CInterceptor_IWbemSyncObjectSink_ExecMethodAsync : public CInterceptor_IWbemSyncObjectSink
{
private:

	long m_Flags ;
	BSTR m_ObjectPath ;
	BSTR m_MethodName ;
	IWbemClassObject *m_InParameters ;
	CInterceptor_IWbemSyncProvider *m_Interceptor ;

protected:
public:

	CInterceptor_IWbemSyncObjectSink_ExecMethodAsync (

		long a_Flags ,
		BSTR a_ObjectPath ,
		BSTR a_MethodName ,
		IWbemClassObject *a_InParameters ,
		CInterceptor_IWbemSyncProvider *a_Interceptor ,
		IWbemObjectSink *a_InterceptedSink ,
		IUnknown *a_Unknown ,
		CWbemGlobal_IWmiObjectSinkController *a_Controller ,
		Exclusion *a_Exclusion = NULL ,
		ULONG a_Dependant = FALSE
	) ;

	~CInterceptor_IWbemSyncObjectSink_ExecMethodAsync () ;

    HRESULT STDMETHODCALLTYPE SetStatus (

		long a_Flags ,
		HRESULT a_Result ,
		BSTR a_StringParamater ,
		IWbemClassObject *a_ObjectParameter
	) ;
} ;

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

class CInterceptor_IWbemFilteringObjectSink :	public CInterceptor_IWbemObjectSink
{
private:
	LONG m_Filtering ;

	BSTR m_QueryLanguage ;
	BSTR m_Query ;

	IWbemQuery *m_QueryFilter ;

protected:
public:

	CInterceptor_IWbemFilteringObjectSink (

		IWbemObjectSink *a_InterceptedSink ,
		IUnknown *a_Unknown ,
		CWbemGlobal_IWmiObjectSinkController *a_Controller ,
		const BSTR a_QueryLanguage ,
		const BSTR a_Query
	) ;

	~CInterceptor_IWbemFilteringObjectSink () ;

	//Non-delegating object IUnknown

    HRESULT STDMETHODCALLTYPE Indicate (

		long a_ObjectCount ,
		IWbemClassObject **a_ObjectArray
	) ;

    HRESULT STDMETHODCALLTYPE SetStatus (

		long a_Flags ,
		HRESULT a_Result ,
		BSTR a_StringParamater ,
		IWbemClassObject *a_ObjectParameter
	) ;

} ;

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

class CInterceptor_IWbemSyncFilteringObjectSink :	public IWbemObjectSink , 
													public IWbemShutdown ,
													public ObjectSinkContainerElement
{
private:

	LONG m_GateClosed ;
	LONG m_InProgress ;
	LONG m_StatusCalled ;
	LONG m_Filtering ;

	BSTR m_QueryLanguage ;
	BSTR m_Query ;

	Exclusion *m_Exclusion ;
	ULONG m_Dependant ;

	IWbemObjectSink *m_InterceptedSink ;
	IWbemQuery *m_QueryFilter ;
	IUnknown *m_Unknown ;

protected:
public:

	CInterceptor_IWbemSyncFilteringObjectSink (

		IWbemObjectSink *a_InterceptedSink ,
		IUnknown *a_Unknown ,
		CWbemGlobal_IWmiObjectSinkController *a_Controller ,
		const BSTR a_QueryLanguage ,
		const BSTR a_Query ,
		Exclusion *a_Exclusion = NULL ,
		ULONG a_Dependant = FALSE
	) ;

	~CInterceptor_IWbemSyncFilteringObjectSink() ;

	void CallBackRelease () ;

	//Non-delegating object IUnknown

    STDMETHODIMP QueryInterface ( REFIID , LPVOID FAR * ) ;
    STDMETHODIMP_( ULONG ) AddRef () ;
    STDMETHODIMP_( ULONG ) Release () ;

    HRESULT STDMETHODCALLTYPE Indicate (

		long a_ObjectCount ,
		IWbemClassObject **a_ObjectArray
	) ;

    HRESULT STDMETHODCALLTYPE SetStatus (

		long a_Flags ,
		HRESULT a_Result ,
		BSTR a_StringParamater ,
		IWbemClassObject *a_ObjectParameter
	) ;

	HRESULT STDMETHODCALLTYPE Shutdown (

		LONG a_Flags ,
		ULONG a_MaxMilliSeconds ,
		IWbemContext *a_Context
	) ; 
} ;


/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

class CInterceptor_IWbemCombiningObjectSink :	public IWbemObjectSink , 
												public IWbemShutdown ,
												public ObjectSinkContainerElement ,
												public CWbemGlobal_IWmiObjectSinkController 
{
private:

	LONG m_GateClosed ;
	LONG m_InProgress ;
	LONG m_StatusCalled ;

	LONG m_SinkCount ;
	HANDLE m_Event ;

	IWbemObjectSink *m_InterceptedSink ;

#if 0
	class InternalInterface : public IWbemObjectSink , public IWbemShutdown
	{
	private:

		CInterceptor_IWbemCombiningObjectSink *m_This ;

	public:

		InternalInterface ( CInterceptor_IWbemCombiningObjectSink *a_This ) : m_This ( a_This ) 
		{
		}

		STDMETHODIMP QueryInterface ( 

			REFIID iid , 
			LPVOID FAR *iplpv 
		)
		{
			*iplpv = NULL ;

			if ( iid == IID_IUnknown )
			{
				*iplpv = ( LPVOID ) this ;
			}
			else if ( iid == IID_IWbemObjectSink )
			{
				*iplpv = ( LPVOID ) ( IWbemObjectSink * ) this ;		
			}	
			else if ( iid == IID_IWbemShutdown )
			{
				*iplpv = ( LPVOID ) ( IWbemShutdown * ) this ;		
			}	

			if ( *iplpv )
			{
				( ( LPUNKNOWN ) *iplpv )->AddRef () ;

				return ResultFromScode ( S_OK ) ;
			}
			else
			{
				return ResultFromScode ( E_NOINTERFACE ) ;
			}
		}

		STDMETHODIMP_( ULONG ) AddRef ()
		{
			return m_This->NonCyclicAddRef () ; 
		}

		STDMETHODIMP_( ULONG ) Release ()
		{
			return m_This->NonCyclicRelease () ;
		}

		HRESULT STDMETHODCALLTYPE Indicate (

			long a_ObjectCount ,
			IWbemClassObject **a_ObjectArray
		)
		{
			return m_This->Indicate (

				a_ObjectCount ,
				a_ObjectArray
			) ;
		}

		HRESULT STDMETHODCALLTYPE SetStatus (

			long a_Flags ,
			HRESULT a_Result ,
			BSTR a_StringParamater ,
			IWbemClassObject *a_ObjectParameter
		)
		{
			return m_This->SetStatus (

				a_Flags ,
				a_Result ,
				a_StringParamater ,
				a_ObjectParameter
			) ;
		}

		HRESULT STDMETHODCALLTYPE Shutdown (

			LONG a_Flags ,
			ULONG a_MaxMilliSeconds ,
			IWbemContext *a_Context
		)
		{
			return m_This->Shutdown (

				a_Flags ,
				a_MaxMilliSeconds ,
				a_Context
			) ;
		}
	} ;

	InternalInterface m_Internal ;
#endif

	void CallBackRelease () ;

protected:
public:

	CInterceptor_IWbemCombiningObjectSink (

		WmiAllocator &m_Allocator ,
		IWbemObjectSink *a_InterceptedSink ,
		CWbemGlobal_IWmiObjectSinkController *a_Controller
	) ;

	~CInterceptor_IWbemCombiningObjectSink () ;

	//Non-delegating object IUnknown

    STDMETHODIMP QueryInterface ( REFIID , LPVOID FAR * ) ;
    STDMETHODIMP_( ULONG ) AddRef () ;
    STDMETHODIMP_( ULONG ) Release () ;

    HRESULT STDMETHODCALLTYPE Indicate (

		long a_ObjectCount ,
		IWbemClassObject **a_ObjectArray
	) ;

    HRESULT STDMETHODCALLTYPE SetStatus (

		long a_Flags ,
		HRESULT a_Result ,
		BSTR a_StringParamater ,
		IWbemClassObject *a_ObjectParameter
	) ;

	HRESULT STDMETHODCALLTYPE Shutdown (

		LONG a_Flags ,
		ULONG a_MaxMilliSeconds ,
		IWbemContext *a_Context
	) ; 

	HRESULT Wait ( ULONG a_Timeout ) ;

	HRESULT EnQueue ( CInterceptor_IWbemObjectSink *a_Sink ) ;

	void Suspend () ;

	void Resume () ;
} ;

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

class CInterceptor_DecoupledIWbemCombiningObjectSink :	public IWbemObjectSink , 
														public IWbemShutdown ,
														public ObjectSinkContainerElement ,
														public CWbemGlobal_IWmiObjectSinkController 
{
private:

	LONG m_GateClosed ;
	LONG m_InProgress ;
	LONG m_StatusCalled ;

	LONG m_SinkCount ;
	HANDLE m_Event ;

	IWbemObjectSink *m_InterceptedSink ;

#if 0
	class InternalInterface : public IWbemObjectSink , public IWbemShutdown
	{
	private:

		CInterceptor_DecoupledIWbemCombiningObjectSink *m_This ;

	public:

		InternalInterface ( CInterceptor_DecoupledIWbemCombiningObjectSink *a_This ) : m_This ( a_This ) 
		{
		}

		STDMETHODIMP QueryInterface ( 

			REFIID iid , 
			LPVOID FAR *iplpv 
		)
		{
			*iplpv = NULL ;

			if ( iid == IID_IUnknown )
			{
				*iplpv = ( LPVOID ) this ;
			}
			else if ( iid == IID_IWbemObjectSink )
			{
				*iplpv = ( LPVOID ) ( IWbemObjectSink * ) this ;		
			}	
			else if ( iid == IID_IWbemShutdown )
			{
				*iplpv = ( LPVOID ) ( IWbemShutdown * ) this ;		
			}	

			if ( *iplpv )
			{
				( ( LPUNKNOWN ) *iplpv )->AddRef () ;

				return ResultFromScode ( S_OK ) ;
			}
			else
			{
				return ResultFromScode ( E_NOINTERFACE ) ;
			}
		}

		STDMETHODIMP_( ULONG ) AddRef ()
		{
			return m_This->NonCyclicAddRef () ; 
		}

		STDMETHODIMP_( ULONG ) Release ()
		{
			return m_This->NonCyclicRelease () ;
		}

		HRESULT STDMETHODCALLTYPE Indicate (

			long a_ObjectCount ,
			IWbemClassObject **a_ObjectArray
		)
		{
			return m_This->Indicate (

				a_ObjectCount ,
				a_ObjectArray
			) ;
		}

		HRESULT STDMETHODCALLTYPE SetStatus (

			long a_Flags ,
			HRESULT a_Result ,
			BSTR a_StringParamater ,
			IWbemClassObject *a_ObjectParameter
		)
		{
			return m_This->SetStatus (

				a_Flags ,
				a_Result ,
				a_StringParamater ,
				a_ObjectParameter
			) ;
		}

		HRESULT STDMETHODCALLTYPE Shutdown (

			LONG a_Flags ,
			ULONG a_MaxMilliSeconds ,
			IWbemContext *a_Context
		)
		{
			return m_This->Shutdown (

				a_Flags ,
				a_MaxMilliSeconds ,
				a_Context
			) ;
		}
	} ;

	InternalInterface m_Internal ;
#endif

	void CallBackRelease () ;

protected:
public:

	CInterceptor_DecoupledIWbemCombiningObjectSink (

		WmiAllocator &m_Allocator ,
		IWbemObjectSink *a_InterceptedSink ,
		CWbemGlobal_IWmiObjectSinkController *a_Controller
	) ;

	~CInterceptor_DecoupledIWbemCombiningObjectSink () ;

	//Non-delegating object IUnknown

    STDMETHODIMP QueryInterface ( REFIID , LPVOID FAR * ) ;
    STDMETHODIMP_( ULONG ) AddRef () ;
    STDMETHODIMP_( ULONG ) Release () ;

    HRESULT STDMETHODCALLTYPE Indicate (

		long a_ObjectCount ,
		IWbemClassObject **a_ObjectArray
	) ;

    HRESULT STDMETHODCALLTYPE SetStatus (

		long a_Flags ,
		HRESULT a_Result ,
		BSTR a_StringParamater ,
		IWbemClassObject *a_ObjectParameter
	) ;

	HRESULT STDMETHODCALLTYPE Shutdown (

		LONG a_Flags ,
		ULONG a_MaxMilliSeconds ,
		IWbemContext *a_Context
	) ; 

	HRESULT Wait ( ULONG a_Timeout ) ;

	HRESULT EnQueue ( CInterceptor_DecoupledIWbemObjectSink *a_Sink ) ;

	void Suspend () ;

	void Resume () ;
} ;

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

class CInterceptor_IWbemWaitingObjectSink :		public IWbemObjectSink , 
												public IWbemShutdown ,
												public ObjectSinkContainerElement ,
												public CWbemGlobal_IWmiObjectSinkController 
{
private:

	LONG m_GateClosed ;
	LONG m_InProgress ;
	LONG m_StatusCalled ;

	WmiQueue <IWbemClassObject *,8> m_Queue ;
	CriticalSection m_CriticalSection ;

	HANDLE m_Event ;

	HRESULT m_Result ;

protected:
public:

	CInterceptor_IWbemWaitingObjectSink (

		WmiAllocator &m_Allocator ,
		CWbemGlobal_IWmiObjectSinkController *a_Controller
	) ;

	~CInterceptor_IWbemWaitingObjectSink () ;

	//Non-delegating object IUnknown

    STDMETHODIMP QueryInterface ( REFIID , LPVOID FAR * ) ;
    STDMETHODIMP_( ULONG ) AddRef () ;
    STDMETHODIMP_( ULONG ) Release () ;

    HRESULT STDMETHODCALLTYPE Indicate (

		long a_ObjectCount ,
		IWbemClassObject **a_ObjectArray
	) ;

    HRESULT STDMETHODCALLTYPE SetStatus (

		long a_Flags ,
		HRESULT a_Result ,
		BSTR a_StringParamater ,
		IWbemClassObject *a_ObjectParameter
	) ;

	HRESULT STDMETHODCALLTYPE Shutdown (

		LONG a_Flags ,
		ULONG a_MaxMilliSeconds ,
		IWbemContext *a_Context
	) ; 

	HRESULT Wait ( ULONG a_Timeout = INFINITE ) ;

	WmiQueue <IWbemClassObject *,8> & GetQueue () { return m_Queue ; }
	CriticalSection &GetQueueCriticalSection () { return m_CriticalSection ; }

	HRESULT GetResult () { return m_Result ; }
} ;

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

class CWaitingObjectSink :	public IWbemObjectSink ,
							public IWbemShutdown ,
							public ObjectSinkContainerElement
{
private:

	LONG m_GateClosed ;
	LONG m_InProgress ;
	LONG m_StatusCalled ;

	HRESULT m_Result ;

	LONG m_ReferenceCount ;

	HANDLE m_Event ;

	WmiQueue <IWbemClassObject *,8> m_Queue ;
	CriticalSection m_CriticalSection ;

protected:

public:

	CWaitingObjectSink ( WmiAllocator &a_Allocator ) ;

	~CWaitingObjectSink () ;

    STDMETHODIMP QueryInterface ( REFIID , LPVOID FAR * ) ;

	STDMETHODIMP_( ULONG ) AddRef () ;

	STDMETHODIMP_(ULONG) Release () ;

    HRESULT STDMETHODCALLTYPE SetStatus (

        long a_Flags ,
        HRESULT a_Result ,
        BSTR a_StringParameter ,
        IWbemClassObject *a_ObjectParameter
	) ;

    HRESULT STDMETHODCALLTYPE Indicate (

        LONG a_ObjectCount,
        IWbemClassObject **a_ObjectArray
	) ;

	HRESULT Wait ( DWORD a_Timeout = INFINITE ) ;

	HRESULT STDMETHODCALLTYPE Shutdown (

		LONG a_Flags ,
		ULONG a_MaxMilliSeconds ,
		IWbemContext *a_Context
	) ; 

	WmiQueue <IWbemClassObject *,8> & GetQueue () { return m_Queue ; }
	CriticalSection &GetQueueCriticalSection () { return m_CriticalSection ; }

	HRESULT GetResult () { return m_Result ; }
} ;

#endif _Server_Interceptor_IWbemObjectSink_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\provsubsys\decoupledadaptor\include\provregdecoupled.h ===
/*++

Copyright (C) 1996-2001 Microsoft Corporation

Module Name:

	ProvRegInfo.h

Abstract:


History:

--*/

#ifndef _Server_ProviderRegistrationDecoupled_H
#define _Server_ProviderRegistrationDecoupled_H

#include "Queue.h"
#include "DateTime.h"

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

class CServerObject_DecoupledClientRegistration_Element
{
private:

	LONG m_ReferenceCount ;

private:

protected:

	HRESULT m_Result ;

	DWORD m_ProcessIdentifier ;
	BSTR m_Provider ;
	BSTR m_Locale ;
	BSTR m_User ;
	BSTR m_Scope ;
	BSTR m_CreationTime ;
	BSTR m_Clsid ;
	BYTE *m_MarshaledProxy ;
	DWORD m_MarshaledProxyLength ;

protected:

	static LPCWSTR s_Strings_Reg_Null ;
	static LPCWSTR s_Strings_Reg_Home ;
	static LPCWSTR s_Strings_Reg_HomeClient ;

	static LPCWSTR s_Strings_Reg_CreationTime ;
	static LPCWSTR s_Strings_Reg_User ;
	static LPCWSTR s_Strings_Reg_Locale ;
	static LPCWSTR s_Strings_Reg_Scope ;
	static LPCWSTR s_Strings_Reg_Provider;
	static LPCWSTR s_Strings_Reg_MarshaledProxy ;
	static LPCWSTR s_Strings_Reg_ProcessIdentifier ;

	void Clear () ;

	HRESULT Validate () ;

public:	/* Internal */

    CServerObject_DecoupledClientRegistration_Element () ;
    ~CServerObject_DecoupledClientRegistration_Element () ;

	CServerObject_DecoupledClientRegistration_Element &operator= ( const CServerObject_DecoupledClientRegistration_Element &a_Key ) ;

	ULONG AddRef () ;
	ULONG Release () ;

	HRESULT Load ( BSTR a_Clsid ) ;
	HRESULT Save ( BSTR a_Clsid ) ;
	HRESULT Delete ( BSTR a_Clsid ) ;

	HRESULT GetResult () { return m_Result ; }

	DWORD GetProcessIdentifier () { return m_ProcessIdentifier ; }
	BSTR GetProvider () { return m_Provider ; }
	BSTR GetLocale () { return m_Locale ; }
	BSTR GetUser () { return m_User ; }
	BSTR GetScope () { return m_Scope ; }
	BSTR GetCreationTime () { return m_CreationTime ; }
	BSTR GetClsid () { return m_Clsid ; }
	BYTE *GetMarshaledProxy () { return m_MarshaledProxy ; }
	DWORD GetMarshaledProxyLength () { return m_MarshaledProxyLength ; }

	HRESULT SetProcessIdentifier ( DWORD a_ProcessIdentifier ) ;
	HRESULT SetProvider ( BSTR a_Provider ) ;
	HRESULT SetLocale ( BSTR a_Locale ) ;
	HRESULT SetUser ( BSTR a_User ) ;
	HRESULT SetScope ( BSTR a_Scope ) ;
	HRESULT SetCreationTime ( BSTR a_CreationTime ) ;
	HRESULT SetClsid ( const BSTR a_Clsid ) ;
	HRESULT SetMarshaledProxy ( BYTE *a_MarshaledProxy , DWORD a_MarshaledProxyLength ) ;
} ;

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

class CServerObject_DecoupledClientRegistration
{
private:

	LONG m_ReferenceCount ;

private:

	WmiQueue < CServerObject_DecoupledClientRegistration_Element , 8 > m_Queue ;

protected:

	HRESULT m_Result ;

protected:

	static LPCWSTR s_Strings_Reg_Null ;
	static LPCWSTR s_Strings_Reg_Home ;
	static LPCWSTR s_Strings_Reg_HomeClient ;

public:	/* Internal */

    CServerObject_DecoupledClientRegistration ( WmiAllocator &a_Allocator ) ;
    ~CServerObject_DecoupledClientRegistration () ;

	ULONG AddRef () ;
	ULONG Release () ;

	HRESULT Load () ;

	HRESULT Load (

		BSTR a_Provider ,
		BSTR a_User ,
		BSTR a_Locale ,
		BSTR a_Scope
	) ;

	WmiQueue < CServerObject_DecoupledClientRegistration_Element , 8 > &GetQueue () { return m_Queue ; }
} ;

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

class CServerObject_DecoupledServerRegistration
{
private:

	LONG m_ReferenceCount ;

private:

protected:

	HRESULT m_Result ;

	DWORD m_ProcessIdentifier ;
	BSTR m_CreationTime ;
	BYTE *m_MarshaledProxy ;
	DWORD m_MarshaledProxyLength ;

protected:

	static LPCWSTR s_Strings_Reg_Null ;
	static LPCWSTR s_Strings_Reg_Home ;
	static LPCWSTR s_Strings_Reg_HomeServer ;

	static LPCWSTR s_Strings_Reg_CreationTime ;
	static LPCWSTR s_Strings_Reg_ProcessIdentifier ;
	static LPCWSTR s_Strings_Reg_MarshaledProxy ;

	void Clear () ;

	HRESULT Validate () ;

public:	/* Internal */

    CServerObject_DecoupledServerRegistration ( WmiAllocator &a_Allocator ) ;
    ~CServerObject_DecoupledServerRegistration () ;

	ULONG AddRef () ;
	ULONG Release () ;

	HRESULT Load () ;
	HRESULT Save () ;
	HRESULT Delete () ;

	HRESULT GetResult () { return m_Result ; }

	DWORD GetProcessIdentifier () { return m_ProcessIdentifier ; }
	BSTR GetCreationTime () { return m_CreationTime ; }
	BYTE *GetMarshaledProxy () { return m_MarshaledProxy ; }
	DWORD GetMarshaledProxyLength () { return m_MarshaledProxyLength ; }

	HRESULT SetProcessIdentifier ( DWORD a_ProcessIdentifier ) ;
	HRESULT SetCreationTime ( BSTR a_CreationTime ) ;
	HRESULT SetMarshaledProxy ( BYTE *a_MarshaledProxy , DWORD a_MarshaledProxyLength ) ;

};


#endif // _Server_ProviderRegistrationDecoupled_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\provsubsys\decoupledadaptor\include\provevents.h ===
/*++

Copyright (C) 1996-2001 Microsoft Corporation

Module Name:

	ProvFact.h

Abstract:


History:

--*/

#ifndef _Server_ProviderEvent_H
#define _Server_ProviderEvent_H

#include "Globals.h"
#include "provcache.h"
#include "ProvRegistrar.h"
#include "ProvEvt.h"
#include <lockst.h>
/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

class CDecoupledChild_IWbemObjectSink ;
class CDecoupledRoot_IWbemObjectSink ;

typedef WmiContainerController <CDecoupledChild_IWbemObjectSink *>			CWbemGlobal_DecoupledIWmiObjectSinkController ;
typedef CWbemGlobal_DecoupledIWmiObjectSinkController :: Container					CWbemGlobal_DecoupledIWmiObjectSinkController_Container ;
typedef CWbemGlobal_DecoupledIWmiObjectSinkController :: Container_Iterator			CWbemGlobal_DecoupledIWmiObjectSinkController_Container_Iterator ;
typedef CWbemGlobal_DecoupledIWmiObjectSinkController :: WmiContainerElement			DecoupledObjectSinkContainerElement ;

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

class CDecoupled_IWbemObjectSink :		public IWbemEventSink , 
										public IWbemShutdown
{
private:
protected:

	long m_SecurityDescriptorLength ;
	BYTE *m_SecurityDescriptor ;

	CriticalSection m_CriticalSection ;

	IWbemObjectSink *m_InterceptedSink ;
	IWbemEventSink *m_EventSink ;

	LONG m_GateClosed ;
	LONG m_InProgress ;
	LONG m_StatusCalled ;

public:

	CDecoupled_IWbemObjectSink () ;

	~CDecoupled_IWbemObjectSink () ;

	//Non-delegating object IUnknown

    STDMETHODIMP QueryInterface ( REFIID , LPVOID FAR * ) ;

    HRESULT STDMETHODCALLTYPE Indicate (

		long a_ObjectCount ,
		IWbemClassObject **a_ObjectArray
	) ;

    HRESULT STDMETHODCALLTYPE SetStatus (

		long a_Flags ,
		HRESULT a_Result ,
		BSTR a_StringParamater ,
		IWbemClassObject *a_ObjectParameter
	) ;

    HRESULT STDMETHODCALLTYPE IndicateWithSD (

		long a_ObjectsCount ,
		IUnknown **a_Objects ,
		long a_SecurityDescriptorLength ,
		BYTE *a_SecurityDescriptor
	) ;

    HRESULT STDMETHODCALLTYPE SetSinkSecurity (

		long a_SecurityDescriptorLength ,
		BYTE *a_SecurityDescriptor
	) ;

    HRESULT STDMETHODCALLTYPE IsActive () ;

    HRESULT STDMETHODCALLTYPE SetBatchingParameters (

		LONG a_Flags,
		DWORD a_MaxBufferSize,
		DWORD a_MaxSendLatency
	) ;

	HRESULT STDMETHODCALLTYPE Shutdown (

		LONG a_Flags ,
		ULONG a_MaxMilliSeconds ,
		IWbemContext *a_Context
	) ; 
} ;

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

class CDecoupledRoot_IWbemObjectSink :		public CDecoupled_IWbemObjectSink ,
											public CWbemGlobal_DecoupledIWmiObjectSinkController
{
private:

	LONG m_ReferenceCount ;

	WmiAllocator &m_Allocator ;

public:

	CDecoupledRoot_IWbemObjectSink (
	
		WmiAllocator &a_Allocator 

	) : CWbemGlobal_DecoupledIWmiObjectSinkController ( a_Allocator ) , 
		m_Allocator ( a_Allocator ) ,
		m_ReferenceCount ( 0 )
	{ ; }

	~CDecoupledRoot_IWbemObjectSink ()
	{
		CWbemGlobal_DecoupledIWmiObjectSinkController :: UnInitialize () ;
	}

    STDMETHODIMP_( ULONG ) AddRef () ;
    STDMETHODIMP_( ULONG ) Release () ;

	HRESULT SinkInitialize () ;

	HRESULT SetSink ( IWbemObjectSink *a_Sink ) ;

    HRESULT STDMETHODCALLTYPE GetRestrictedSink (

		long a_QueryCount ,
        const LPCWSTR *a_Queries ,
        IUnknown *a_Callback ,
        IWbemEventSink **a_Sink
	) ;
} ;

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

class CDecoupledChild_IWbemObjectSink :		public CDecoupled_IWbemObjectSink ,
											public DecoupledObjectSinkContainerElement
{
private:

	CDecoupledRoot_IWbemObjectSink *m_RootSink ;
	long m_QueryCount ;
    LPWSTR *m_Queries ;
    IUnknown *m_Callback ;

public:

	CDecoupledChild_IWbemObjectSink (
	
		CDecoupledRoot_IWbemObjectSink *a_RootSink
	) ;

	~CDecoupledChild_IWbemObjectSink () ;

    STDMETHODIMP_( ULONG ) AddRef () ;
    STDMETHODIMP_( ULONG ) Release () ;

	HRESULT SinkInitialize (

		long a_QueryCount ,
		const LPCWSTR *a_Queries ,
		IUnknown *a_Callback
	) ;

    HRESULT STDMETHODCALLTYPE GetRestrictedSink (

		long a_QueryCount ,
        const LPCWSTR *a_Queries ,
        IUnknown *a_Callback ,
        IWbemEventSink **a_Sink
	) ;

	HRESULT SetSink ( IWbemObjectSink *a_Sink ) ;
} ;

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

class CServerObject_ProviderEvents :	public CServerObject_ProviderRegistrar_Base ,
										public IWbemDecoupledBasicEventProvider
{
private:

	WmiAllocator &m_Allocator ;

	CriticalSection m_SinkCriticalSection ;

    long m_ReferenceCount ;

	CDecoupledRoot_IWbemObjectSink *m_ObjectSink ;
	CEventProvider *m_Provider ;
	IWbemServices *m_Service ;

protected:

public: /* Internal */

	HRESULT SetSink ( IWbemObjectSink *a_Sink ) 
	{
		WmiHelper :: EnterCriticalSection ( & m_SinkCriticalSection ) ;

		if ( m_ObjectSink )
		{
			CDecoupledRoot_IWbemObjectSink *t_Sink = m_ObjectSink ;

			t_Sink->AddRef () ;
		
			WmiHelper :: LeaveCriticalSection ( & m_SinkCriticalSection ) ;

			HRESULT t_Result = t_Sink->SetSink ( a_Sink ) ;

			t_Sink->Release () ;

			return t_Result ;
		}
		else
		{
			WmiHelper :: LeaveCriticalSection ( & m_SinkCriticalSection ) ;

			return WBEM_E_NOT_AVAILABLE ;
		}
	}

public:	/* External */

	CServerObject_ProviderEvents ( WmiAllocator &a_Allocator = *DecoupledProviderSubSystem_Globals::s_Allocator) ;
	~CServerObject_ProviderEvents () ;

	//IUnknown members

	STDMETHODIMP QueryInterface ( REFIID , LPVOID FAR * ) ;
    STDMETHODIMP_( ULONG ) AddRef () ;
    STDMETHODIMP_( ULONG ) Release () ;

	HRESULT STDMETHODCALLTYPE Register (

		long a_Flags ,
		IWbemContext *a_Context ,
		LPCWSTR a_User ,
		LPCWSTR a_Locale ,
		LPCWSTR a_Scope ,
		LPCWSTR a_Registration ,
		IUnknown *a_Unknown 
	) ;

	HRESULT STDMETHODCALLTYPE UnRegister () ;

	HRESULT STDMETHODCALLTYPE GetSink (

		long a_Flags ,
		IWbemContext *a_Context ,
		IWbemObjectSink **a_Sink
	) ;

	HRESULT STDMETHODCALLTYPE GetService (

		long a_Flags ,
		IWbemContext *a_Context ,
		IWbemServices **a_Service
	) ;
};

#endif // _Server_ProviderEvent_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\provsubsys\decoupledadaptor\include\provreginfo.h ===
/*++

Copyright (C) 1996-2001 Microsoft Corporation

Module Name:

	ProvRegInfo.h

Abstract:


History:

--*/

#ifndef _Server_ProviderRegistrationInfo_H
#define _Server_ProviderRegistrationInfo_H

#include "ProvDnf.h"

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT VerifySecureLocalSystemProviders ( wchar_t *a_Clsid ) ;
HRESULT VerifySecureSvcHostProviders ( wchar_t *a_Clsid ) ;

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

extern GENERIC_MAPPING g_ProviderBindingMapping ; 

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

#define DEFAULT_PROVIDER_TIMEOUT 120000
#define DEFAULT_PROVIDER_LOAD_TIMEOUT 120000

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

enum Enum_ThreadingModel
{
	e_Apartment = 0 ,
	e_Both ,
	e_Free ,
	e_Neutral ,
	e_ThreadingModel_Unknown
} ;

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

enum Enum_Synchronization
{
	e_Ignored = 0 ,
	e_None ,
	e_Supported ,
	e_Required ,
	e_RequiresNew ,
	e_Synchronization_Unknown 
} ;

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

enum Enum_Boolean
{
	e_False = 0 ,
	e_True ,
	e_Boolean_Unknown
} ;

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

enum Enum_ImpersonationLevel
{
	e_Impersonate_None = 0 ,
	e_Impersonate ,
	e_ImpersonationLevel_Unknown
} ;

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

enum Enum_InitializationReentrancy
{
	e_InitializationReentrancy_Clsid = 0 ,
	e_InitializationReentrancy_Namespace ,
	e_InitializationReentrancy_None ,
	e_InitializationReentrancy_Unknown
} ;

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

enum Enum_InteractionType
{
	e_InteractionType_Pull = 0 ,
	e_InteractionType_Push ,
	e_InteractionType_PushVerify ,
	e_InteractionType_Unknown
} ;

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

enum Enum_Hosting
{
	e_Hosting_Undefined = 0 ,
	e_Hosting_WmiCore  ,
	e_Hosting_WmiCoreOrSelfHost ,
	e_Hosting_SelfHost ,
	e_Hosting_ClientHost ,
	e_Hosting_Decoupled ,
	e_Hosting_SharedLocalSystemHost ,
	e_Hosting_SharedLocalSystemHostOrSelfHost ,
	e_Hosting_SharedLocalServiceHost ,
	e_Hosting_SharedNetworkServiceHost ,
	e_Hosting_SharedUserHost ,
	e_Hosting_NonCom
} ;

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

#define e_QuerySupportLevels_UnarySelect ( 1 )
#define e_QuerySupportLevels_References ( e_QuerySupportLevels_UnarySelect << 1 )
#define e_QuerySupportLevels_Associators ( e_QuerySupportLevels_References << 1 )
#define e_QuerySupportLevels_V1ProviderDefined ( e_QuerySupportLevels_Associators << 1 )
#define e_QuerySupportLevels_None ( e_QuerySupportLevels_V1ProviderDefined << 1 )
#define e_QuerySupportLevels_Unknown ( 0 )


/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

typedef ULONGLONG Enum_PropertyMask ;

#define	e_ThreadingModel 0x1 
#define	e_Synchronization 0x2
#define	e_Clsid 0x4
#define	e_ClientClsid 0x8
#define	e_DefaultMachineName 0x10
#define	e_UnloadTimeout 0x20
#define	e_ImpersonationLevel 0x40
#define	e_InitializationReentrancy 0x80
#define	e_InitializeAsAdminFirst 0x100
#define	e_PerUserInitialization 0x200
#define	e_PerLocaleInitialization 0x400
#define	e_Pure 0x800
#define	e_Hosting 0x1000
#define	e_HostingGroup 0x2000
#define	e_SupportsPut 0x4000
#define	e_SupportsGet 0x8000
#define	e_SupportsDelete 0x10000
#define	e_SupportsEnumeration 0x20000
#define	e_QuerySupportLevels 0x40000
#define	e_InteractionType 0x80000
#define	e_ResultSetQueries 0x100000
#define	e_UnSupportedQueries 0x200000
#define	e_ReferencedSetQueries 0x400000
#define	e_ClearAfter 0x800000
#define	e_SupportsThrottling 0x1000000
#define	e_ConcurrentIndependantRequests 0x2000000
#define	e_SupportsSendStatus 0x4000000
#define	e_OperationTimeoutInterval 0x8000000
#define	e_InitializationTimeoutInterval 0x10000000
#define	e_SupportsQuotas 0x20000000
#define	e_Enabled 0x40000000
#define	e_SupportsShutdown 0x80000000
#define	e_SupportsBatching 0x100000000
#define	e_SupportsTransactions 0x200000000
#define	e_CacheRefreshInterval 0x400000000
#define	e_PerUserSchema 0x800000000
#define	e_ReSynchroniseOnNamespaceOpen 0x1000000000
#define	e_MemoryPerHost 0x2000000000
#define	e_MemoryAllHosts 0x4000000000
#define	e_ThreadsPerHost 0x8000000000
#define	e_HandlesPerHost 0x10000000000
#define	e_ProcessLimitAllHosts 0x20000000000
#define	e_Version 0x40000000000
#define	e_SecurityDescriptor 0x80000000000
#define	e_Name 0x100000000000

#define	e_All 0xFFFFFFFFFFFFFFFF

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

class CServerObject_GlobalRegistration 
{
private:

	LONG m_ReferenceCount ;

protected:

	HRESULT m_Result ;

	LPWSTR m_Object_UnloadTimeout ;
	ULONG m_Object_UnloadTimeoutMilliSeconds ;

	LPWSTR m_Event_UnloadTimeout ;
	ULONG m_Event_UnloadTimeoutMilliSeconds ;

	IWbemContext *m_Context ;
	IWbemPath *m_Namespace ;
	IWbemServices *m_Repository ;

protected:

	static LPCWSTR s_Strings_Wmi_ClearAfter ;
	static LPCWSTR s_Strings_Wmi___ObjectProviderCacheControl ;
	static LPCWSTR s_Strings_Wmi___EventProviderCacheControl ;
	static LPCWSTR s_Strings_Wmi_Class ;
	static LPCWSTR s_Strings_Wmi_s_Strings_Query_Object ;
	static LPCWSTR s_Strings_Wmi_s_Strings_Path_Object ;
	static LPCWSTR s_Strings_Wmi_s_Strings_Query_Event ;
	static LPCWSTR s_Strings_Wmi_s_Strings_Path_Event ;

protected:
public:	/* Internal */

    CServerObject_GlobalRegistration () ;
    ~CServerObject_GlobalRegistration () ;

	ULONG AddRef () ;
	ULONG Release () ;

	HRESULT SetContext (

		IWbemContext *a_Context ,
		IWbemPath *a_Namespace ,
		IWbemServices *a_Repository
	) ;

	HRESULT QueryProperties ( 

		Enum_PropertyMask a_Mask ,
		IWbemClassObject *a_Object ,
		LPWSTR &a_UnloadTimeout ,
		ULONG &a_UnloadTimeoutMilliSeconds 
	) ;

	HRESULT QueryRepository ( 

		Enum_PropertyMask a_Mask
	) ;

	HRESULT Load ( 

		Enum_PropertyMask a_Mask
	) ;

	wchar_t *GetUnloadTimeout () { return m_Object_UnloadTimeout ; }
	ULONG GetUnloadTimeoutMilliSeconds () { return m_Object_UnloadTimeoutMilliSeconds ; }

	wchar_t *GetObjectUnloadTimeout () { return m_Object_UnloadTimeout ; }
	ULONG GetObjectUnloadTimeoutMilliSeconds () { return m_Object_UnloadTimeoutMilliSeconds ; }

	wchar_t *GetEventUnloadTimeout () { return m_Event_UnloadTimeout ; }
	ULONG GetEventUnloadTimeoutMilliSeconds () { return m_Event_UnloadTimeoutMilliSeconds ; }

	HRESULT GetResult () { return m_Result ; }
};

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

class CServerObject_HostQuotaRegistration 
{
private:

	LONG m_ReferenceCount ;

protected:

	HRESULT m_Result ;

	SIZE_T m_MemoryPerHost ;
	SIZE_T m_MemoryAllHosts ;
	ULONG m_ThreadsPerHost ;
	ULONG m_HandlesPerHost ;
	ULONG m_ProcessLimitAllHosts ;

	IWbemContext *m_Context ;
	IWbemPath *m_Namespace ;
	IWbemServices *m_Repository ;

protected:

	static LPCWSTR s_Strings_Wmi_HostQuotas_Query ;
	static LPCWSTR s_Strings_Wmi_HostQuotas_Path ;
	static LPCWSTR s_Strings_Wmi_MemoryPerHost ;
	static LPCWSTR s_Strings_Wmi_MemoryAllHosts ;
	static LPCWSTR s_Strings_Wmi_ThreadsPerHost ;
	static LPCWSTR s_Strings_Wmi_HandlesPerHost ;
	static LPCWSTR s_Strings_Wmi_ProcessLimitAllHosts ;

protected:
public:	/* Internal */

    CServerObject_HostQuotaRegistration () ;
    ~CServerObject_HostQuotaRegistration () ;

	ULONG AddRef () ;
	ULONG Release () ;

	HRESULT SetContext (

		IWbemContext *a_Context ,
		IWbemPath *a_Namespace ,
		IWbemServices *a_Repository
	) ;

	HRESULT QueryProperties ( 

		Enum_PropertyMask a_Mask ,
		IWbemClassObject *a_Object
	) ;

	HRESULT QueryRepository ( 

		Enum_PropertyMask a_Mask
	) ;

	HRESULT Load ( 

		Enum_PropertyMask a_Mask
	) ;

	SIZE_T GetMemoryPerHost () { return m_MemoryPerHost ; }
	SIZE_T GetMemoryAllHosts () { return m_MemoryAllHosts ; }
	ULONG GetThreadsPerHost () { return m_ThreadsPerHost; }
	ULONG GetHandlesPerHost () { return m_HandlesPerHost; }
	ULONG GetProcessLimitAllHosts () { return m_ProcessLimitAllHosts ; }

	HRESULT GetResult () { return m_Result ; }
};

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

class CServerObject_ComRegistration 
{
private:

	LONG m_ReferenceCount ;

private:

	HRESULT Load_ThreadingModel ( HKEY a_Clsid ) ;
	HRESULT Load_Synchronization ( HKEY a_ClsidKey ) ;

	HRESULT Load_InProcServer32 ( LPCWSTR a_ClsidStringKey ) ;
	HRESULT Load_LocalServer32 ( LPCWSTR a_ClsidStringKey ) ;

	HRESULT Load_AppId ( HKEY a_Clsid_Key ) ;
	HRESULT Load_ServerTypes ( LPCWSTR a_ClsidString ) ;

protected:

	HRESULT m_Result ;

	Enum_ThreadingModel m_ThreadingModel ;
	Enum_Synchronization m_Synchronization ;

	Enum_Boolean m_InProcServer32 ;
	Enum_Boolean m_LocalServer32 ;
	Enum_Boolean m_Service ;
	Enum_Boolean m_Loaded ;
	BSTR m_Clsid ;
	BSTR m_AppId ;
	BSTR m_ProviderName ;
	wchar_t m_InProcServer32_Path [ MAX_PATH ] ;
	wchar_t m_LocalServer32_Path [ MAX_PATH ] ;
	wchar_t m_Server_Name [ MAX_PATH ] ;

protected:

	static LPCWSTR s_Strings_Reg_Null ;

	static LPCWSTR s_Strings_Reg_ThreadingModel ;
	static LPCWSTR s_Strings_Reg_InProcServer32 ;
	static LPCWSTR s_Strings_Reg_LocalServer32 ;
	static LPCWSTR s_Strings_Reg_Synchronization ;
	static LPCWSTR s_Strings_Reg_AppId ;

	static LPCWSTR s_Strings_Reg_Apartment_Apartment ;
	static LPCWSTR s_Strings_Reg_Apartment_Both ;
	static LPCWSTR s_Strings_Reg_Apartment_Free ;
	static LPCWSTR s_Strings_Reg_Apartment_Neutral ;

	static LPCWSTR s_Strings_Reg_Apartment_Required ;
	static LPCWSTR s_Strings_Reg_Synchronization_Ignored ; 
	static LPCWSTR s_Strings_Reg_Synchronization_None ;
	static LPCWSTR s_Strings_Reg_Synchronization_Supported ;
	static LPCWSTR s_Strings_Reg_Synchronization_Required ;
	static LPCWSTR s_Strings_Reg_Synchronization_RequiresNew ;

	static LPCWSTR s_Strings_Reg_ClsidKeyStr ;

public:	/* Internal */

    CServerObject_ComRegistration () ;
    ~CServerObject_ComRegistration () ;

	ULONG AddRef () ;
	ULONG Release () ;

	HRESULT Load ( LPCWSTR a_Clsid , LPCWSTR a_ProviderName ) ;

	Enum_ThreadingModel GetThreadingModel () { return m_ThreadingModel ; }
	Enum_Synchronization GetSynchronization () { return m_Synchronization ; }

	Enum_Boolean InProcServer32 () { return m_InProcServer32 ; }
	Enum_Boolean LocalServer32 () { return m_LocalServer32 ; }
	Enum_Boolean Loaded () { return m_Loaded ; }

	wchar_t *GetInProcServer32_Path () { return m_InProcServer32_Path ; }
	wchar_t *GetLocalServer32_Path () { return m_LocalServer32_Path ; }
	wchar_t *GetServer_Name () { return m_Server_Name ; }
	wchar_t *GetProviderName () { return m_ProviderName ; }
	wchar_t *GetProviderClsid () { return m_Clsid ; }

	HRESULT GetResult () { return m_Result ; }
};

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

class CServerObject_ComProviderRegistrationV1 
{
private:

	LONG m_ReferenceCount ;

protected:

	HRESULT m_Result ;

	CServerObject_ComRegistration m_ClsidServer ;

	ULONG m_Version ;
	Enum_ImpersonationLevel m_ImpersonationLevel ;
	Enum_InitializationReentrancy m_InitializationReentrancy ;
	BOOL m_InitializeAsAdminFirst ;
	BOOL m_PerUserInitialization ;
	BOOL m_PerLocaleInitialization ;
	BOOL m_SupportsQuotas ;
	BOOL m_Enabled ;
	BOOL m_SupportsShutdown ;
	BOOL m_Pure ;
	Enum_Hosting m_Hosting ;
	LPWSTR m_HostingGroup ;
	LPWSTR m_DefaultMachineName ;
	BOOL m_DecoupledImpersonationRestriction ;

	LPWSTR m_InitializationTimeout ;
	ULONG m_InitializationTimeoutMilliSeconds ;

	LPWSTR m_UnloadTimeout ;
	ULONG m_UnloadTimeoutMilliSeconds ;

	BOOL m_SupportsSendStatus ;
	LPWSTR m_OperationTimeout ;
	ULONG m_OperationTimeoutMilliSeconds ;

	BOOL m_SupportsThrottling ;
	ULONG m_ConcurrentIndependantRequests ;

	BSTR m_ProviderName ;

	GUID m_CLSID ;
	GUID m_ClientCLSID ;

	IWbemClassObject *m_Identity ;
	IWbemContext *m_Context ;
	IWbemPath *m_Namespace ;
	IWbemServices *m_Repository ;
	SECURITY_DESCRIPTOR *m_SecurityDescriptor ;

public:

	static LPCWSTR s_Strings_Wmi_Clsid ;
	static LPCWSTR s_Strings_Wmi_ClientClsid ;
	static LPCWSTR s_Strings_Wmi_Name ;
	static LPCWSTR s_Strings_Wmi_Version ;
	static LPCWSTR s_Strings_Wmi_DefaultMachineName ;
	static LPCWSTR s_Strings_Wmi_UnloadTimeout ;
	static LPCWSTR s_Strings_Wmi_ImpersonationLevel ;
	static LPCWSTR s_Strings_Wmi_InitializationReentrancy ;
	static LPCWSTR s_Strings_Wmi_InitializeAsAdminFirst ;
	static LPCWSTR s_Strings_Wmi_PerUserInitialization ;
	static LPCWSTR s_Strings_Wmi_PerLocaleInitialization ;
	static LPCWSTR s_Strings_Wmi_Pure ;
	static LPCWSTR s_Strings_Wmi_Hosting ;
	static LPCWSTR s_Strings_Wmi_HostingGroup ;
	static LPCWSTR s_Strings_Wmi_SupportsThrottling ;
	static LPCWSTR s_Strings_Wmi_SupportsQuotas ;
	static LPCWSTR s_Strings_Wmi_SupportsShutdown ;
	static LPCWSTR s_Strings_Wmi_Enabled ;
	static LPCWSTR s_Strings_Wmi_ConcurrentIndependantRequests ;
	static LPCWSTR s_Strings_Wmi_SupportsSendStatus ;
	static LPCWSTR s_Strings_Wmi_OperationTimeoutInterval ;
	static LPCWSTR s_Strings_Wmi_InitializationTimeoutInterval ;
	static LPCWSTR s_Strings_Wmi_SecurityDescriptor ;

	static WCHAR s_Strings_Wmi_WmiCore [] ;
	static WCHAR s_Strings_Wmi_SelfHost [] ;
	static WCHAR s_Strings_Wmi_WmiCoreOrSelfHost [] ;
	static WCHAR s_Strings_Wmi_ClientHost [] ;
	static WCHAR s_Strings_Wmi_Decoupled [] ;
	static WCHAR s_Strings_Wmi_DecoupledColon [] ;
	static WCHAR s_Strings_Wmi_SharedLocalSystemHost [] ;
	static WCHAR s_Strings_Wmi_SharedLocalSystemHostOrSelfHost [] ;
	static WCHAR s_Strings_Wmi_SharedLocalServiceHost [] ;
	static WCHAR s_Strings_Wmi_SharedNetworkServiceHost [] ;
	static WCHAR s_Strings_Wmi_SharedUserHost [] ;
	static WCHAR s_Strings_Wmi_NonCom [] ;

	static WCHAR s_Strings_Wmi_DefaultSharedLocalSystemHost [] ;
	static WCHAR s_Strings_Wmi_DefaultSharedLocalSystemHostOrSelfHost [] ;
	static WCHAR s_Strings_Wmi_DefaultSharedLocalServiceHost [] ;
	static WCHAR s_Strings_Wmi_DefaultSharedNetworkServiceHost [] ;
	static WCHAR s_Strings_Wmi_DefaultSharedUserHost [] ;

	static LPCWSTR s_Strings_Wmi_DefaultHostingRegistryKey ;

protected:
public:	/* Internal */

    CServerObject_ComProviderRegistrationV1 () ;
    ~CServerObject_ComProviderRegistrationV1 () ;

	ULONG AddRef () ;
	ULONG Release () ;

	HRESULT SetContext (

		IWbemContext *a_Context ,
		IWbemPath *a_Namespace ,
		IWbemServices *a_Repository
	) ;

	HRESULT QueryProperties ( 

		Enum_PropertyMask a_Mask ,
		IWbemClassObject *a_Object ,
		LPCWSTR a_ProviderName
	) ;

	HRESULT QueryRepository ( 

		Enum_PropertyMask a_Mask ,
		IWbemPath *a_Scope,
		LPCWSTR a_ProviderName 
	) ;

	HRESULT QueryRepository ( 

		Enum_PropertyMask a_Mask ,
		IWbemPath *a_Scope,
		IWbemPath *a_Provider
	) ;

	HRESULT Load ( 

		Enum_PropertyMask a_Mask ,
		IWbemPath *a_Scope,
		IWbemClassObject *a_Class
	) ;

	HRESULT Load ( 

		Enum_PropertyMask a_Mask ,
		IWbemPath *a_Scope,
		LPCWSTR a_Provider
	) ;

	HRESULT Load ( 

		Enum_PropertyMask a_Mask ,
		IWbemPath *a_Scope,
		IWbemPath *a_Provider
	) ;

	const CLSID &GetClsid () { return m_CLSID ; }
	const CLSID &GetClientClsid () { return m_ClientCLSID ; }
	wchar_t *GetProviderName () { return m_ProviderName ; }

	ULONG GetVersion () { return m_Version ; }
	Enum_ImpersonationLevel GetImpersonationLevel () { return m_ImpersonationLevel ; }
	Enum_InitializationReentrancy GetInitializationReentrancy () { return m_InitializationReentrancy ; }
	Enum_Hosting GetHosting () { return m_Hosting ; }
	LPCWSTR GetHostingGroup () { return m_HostingGroup ; }

	BOOL InitializeAsAdminFirst () { return m_InitializeAsAdminFirst ; }
	BOOL PerUserInitialization () { return m_PerUserInitialization ; }
	BOOL PerLocaleInitialization () { return m_PerLocaleInitialization ; }
	BOOL Pure () { return m_Pure ; }
	BOOL Enabled () { return m_Enabled ; }
	BOOL SupportsQuotas () { return m_SupportsQuotas ; }

	wchar_t *GetDefaultMachineName () { return m_DefaultMachineName ; }
	wchar_t *GetUnloadTimeout () { return m_UnloadTimeout ; }
	wchar_t *GetInitializationTimeout () { return m_InitializationTimeout ; }
	wchar_t *GetOperationTimeout () { return m_OperationTimeout ; }

	void SetUnloadTimeoutMilliSeconds ( ULONG a_UnloadTimeoutMilliSeconds ) { m_UnloadTimeoutMilliSeconds = a_UnloadTimeoutMilliSeconds ; }

	ULONG GetUnloadTimeoutMilliSeconds () { return m_UnloadTimeoutMilliSeconds ; }
	ULONG GetInitializationTimeoutMilliSeconds () { return m_InitializationTimeoutMilliSeconds ; }
	ULONG GetOperationTimeoutMilliSeconds () { return m_OperationTimeoutMilliSeconds ; }

	ULONG GetConcurrentIndependantRequests () { return m_ConcurrentIndependantRequests ; }
	BOOL GetSupportsThrottling () { return m_SupportsThrottling ; }
	BOOL GetSupportsSendStatus () { return m_SupportsSendStatus ; }
	BOOL GetSupportsShutdown () { return m_SupportsShutdown ; }

	Enum_ThreadingModel GetThreadingModel () { return m_ClsidServer.GetThreadingModel () ; }	

	BOOL GetDecoupledImpersonationRestriction () { return m_DecoupledImpersonationRestriction ; }

	CServerObject_ComRegistration &GetClsidServer () { return m_ClsidServer ; }

	SECURITY_DESCRIPTOR *GetSecurityDescriptor () { return m_SecurityDescriptor ; }

	HRESULT GetResult () { return m_Result ; }

	IWbemClassObject *GetIdentity () { return m_Identity ; }

	static HRESULT GetHosting (
	
		LPCWSTR a_Hosting , 
		Enum_Hosting & a_HostingValue , 
		LPWSTR &a_HostingGroup ,
		BOOL & a_ImpersonationRestriction 
	) ;

	static HRESULT GetHostingGroup ( 

		LPCWSTR a_Hosting , 
		size_t a_Prefix ,
		Enum_Hosting a_ExpectedHostingValue ,
		Enum_Hosting & a_HostingValue ,
		BSTR & a_HostingGroup
	) ;

	static HRESULT GetDefaultHostingGroup ( 

		Enum_Hosting a_HostingValue ,
		BSTR & a_HostingGroup 
	) ;

	static HRESULT GetDecoupledImpersonationRestriction ( 

		LPCWSTR a_Hosting , 
		BOOL & a_ImpersonationRestriction 
	) ;
} ;

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

class CServerObject_InstanceProviderRegistrationV1 
{
private:

	LONG m_ReferenceCount ;

protected:

	HRESULT m_Result ;

	BOOL m_Supported ;
	BOOL m_SupportsPut ;
 	BOOL m_SupportsGet ;
	BOOL m_SupportsDelete ;
	BOOL m_SupportsEnumeration ;
	BOOL m_SupportsBatching ;
	BOOL m_SupportsTransactions ;

	Enum_InteractionType m_InteractionType ;
	ULONG m_QuerySupportLevels ;

	IWbemContext *m_Context ;
	IWbemPath *m_Namespace ;
	IWbemServices *m_Repository ;

private:

	static LPCWSTR s_Strings_Class ;
	static LPCWSTR s_Strings_InstanceProviderRegistration ;

	static LPCWSTR s_Strings_SupportsPut ;
	static LPCWSTR s_Strings_SupportsGet ;
	static LPCWSTR s_Strings_SupportsDelete ;
	static LPCWSTR s_Strings_SupportsEnumeration ;
	static LPCWSTR s_Strings_QuerySupportLevels ;
	static LPCWSTR s_Strings_InteractionType ;

	static LPCWSTR s_Strings_SupportsBatching ;
	static LPCWSTR s_Strings_SupportsTransactions ;

	static LPCWSTR s_Strings_QuerySupportLevels_UnarySelect ;
	static LPCWSTR s_Strings_QuerySupportLevels_References ;
	static LPCWSTR s_Strings_QuerySupportLevels_Associators ;
	static LPCWSTR s_Strings_QuerySupportLevels_V1ProviderDefined ;

	static LPCWSTR s_Strings_InteractionType_Pull ;
	static LPCWSTR s_Strings_InteractionType_Push ;
	static LPCWSTR s_Strings_InteractionType_PushVerify ;

protected:

	HRESULT QueryRepositoryUsingQuery ( 

		Enum_PropertyMask a_Mask ,
		IWbemPath *a_Scope,
		BSTR a_Query
	) ;

public:	/* Internal */

    CServerObject_InstanceProviderRegistrationV1 () ;
    ~CServerObject_InstanceProviderRegistrationV1 () ;

	ULONG AddRef () ;
	ULONG Release () ;

	HRESULT SetContext (

		IWbemContext *a_Context ,
		IWbemPath *a_Namespace ,
		IWbemServices *a_Repository
	) ;

	HRESULT QueryProperties ( 

		Enum_PropertyMask a_Mask ,
		IWbemClassObject *a_Object 
	) ;

	HRESULT QueryRepository ( 

		Enum_PropertyMask a_Mask ,
		IWbemPath *a_Scope,
		LPCWSTR a_ProviderName 
	) ;

	HRESULT QueryRepository ( 

		Enum_PropertyMask a_Mask ,
		IWbemPath *a_Scope,
		IWbemPath *a_Provider
	) ;
	
	HRESULT Load ( 

		Enum_PropertyMask a_Mask ,
		IWbemPath *a_Scope,
		IWbemClassObject *a_Class
	) ;

	HRESULT Load ( 

		Enum_PropertyMask a_Mask ,
		IWbemPath *a_Scope,
		LPCWSTR a_Provider
	) ;

	HRESULT Load ( 

		Enum_PropertyMask a_Mask ,
		IWbemPath *a_Scope,
		IWbemPath *a_Provider
	) ;

	BOOL SupportsPut () { return m_SupportsPut ; }
	BOOL SupportsGet () { return m_SupportsGet ; }
	BOOL SupportsDelete () { return m_SupportsDelete ; }
	BOOL SupportsEnumeration () { return m_SupportsEnumeration ; }
	BOOL SupportsTransactions () { return m_SupportsTransactions ; }
	BOOL SupportsBatching () { return m_SupportsBatching ; }

	ULONG QuerySupportLevels () { return m_QuerySupportLevels ; }
	Enum_InteractionType InteractionType () { return m_InteractionType ; }

	BOOL Supported () { return m_Supported ; }
	HRESULT GetResult () { return m_Result ; }
};

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

class CServerObject_ClassProviderRegistrationV1 
{
private:

	LONG m_ReferenceCount ;

protected:

	HRESULT m_Result ;

	BOOL m_Supported ;
	BOOL m_SupportsPut ;
 	BOOL m_SupportsGet ;
	BOOL m_SupportsDelete ;
	BOOL m_SupportsEnumeration ;
	BOOL m_SupportsBatching ;
	BOOL m_SupportsTransactions ;
	BOOL m_PerUserSchema ;
	BOOL m_ReSynchroniseOnNamespaceOpen ;
	BOOL m_HasReferencedSet;
	Enum_InteractionType m_InteractionType ;
	ULONG m_QuerySupportLevels ;
	ULONG m_Version ;
	LPWSTR m_CacheRefreshInterval ;
	ULONG m_CacheRefreshIntervalMilliSeconds ;

	LPWSTR m_ProviderName ;

	IWbemContext *m_Context ;
	IWbemPath *m_Namespace ;
	IWbemServices *m_Repository ;

	ULONG m_ResultSetQueryTreeCount ;
	WmiTreeNode **m_ResultSetQueryTree ;

	ULONG m_UnSupportedQueryTreeCount ;
	WmiTreeNode **m_UnSupportedQueryTree ;

	ULONG m_ReferencedSetQueryTreeCount ;
	WmiTreeNode **m_ReferencedSetQueryTree ;

private:

	static LPCWSTR s_Strings_Class ;
	static LPCWSTR s_Strings_ClassProviderRegistration ;

	static LPCWSTR s_Strings_Version ;

	static LPCWSTR s_Strings_SupportsPut ;
	static LPCWSTR s_Strings_SupportsGet ;
	static LPCWSTR s_Strings_SupportsDelete ;
	static LPCWSTR s_Strings_SupportsEnumeration ;
	static LPCWSTR s_Strings_QuerySupportLevels ;
	static LPCWSTR s_Strings_InteractionType ;
	static LPCWSTR s_Strings_SupportsBatching ;
	static LPCWSTR s_Strings_SupportsTransactions ;
	static LPCWSTR s_Strings_CacheRefreshInterval ;
	static LPCWSTR s_Strings_PerUserSchema ;
	static LPCWSTR s_Strings_ReSynchroniseOnNamespaceOpen ;

	static LPCWSTR s_Strings_QuerySupportLevels_UnarySelect ;
	static LPCWSTR s_Strings_QuerySupportLevels_References ;
	static LPCWSTR s_Strings_QuerySupportLevels_Associators ;
	static LPCWSTR s_Strings_QuerySupportLevels_V1ProviderDefined ;

	static LPCWSTR s_Strings_InteractionType_Pull ;
	static LPCWSTR s_Strings_InteractionType_Push ;
	static LPCWSTR s_Strings_InteractionType_PushVerify ;

	static LPCWSTR s_Strings_ResultSetQueries ;
	static LPCWSTR s_Strings_UnSupportedQueries ;
	static LPCWSTR s_Strings_ReferencedSetQueries ;

private:

	HRESULT ParseQuery (

		ULONG &a_Count ,
		WmiTreeNode **&a_Root ,
		SAFEARRAY *a_Array
	) ;

protected:

	HRESULT QueryRepositoryUsingQuery ( 

		Enum_PropertyMask a_Mask ,
		IWbemPath *a_Scope,
		BSTR a_Query
	) ;

public:	/* Internal */

    CServerObject_ClassProviderRegistrationV1 () ;
    ~CServerObject_ClassProviderRegistrationV1 () ;

	ULONG AddRef () ;
	ULONG Release () ;

	HRESULT SetContext (

		IWbemContext *a_Context ,
		IWbemPath *a_Namespace ,
		IWbemServices *a_Repository
	) ;

	HRESULT QueryProperties ( 

		Enum_PropertyMask a_Mask ,
		IWbemClassObject *a_Object 
	) ;

	HRESULT QueryRepository ( 

		Enum_PropertyMask a_Mask ,
		IWbemPath *a_Scope,
		LPCWSTR a_ProviderName 
	) ;

	HRESULT QueryRepository ( 

		Enum_PropertyMask a_Mask ,
		IWbemPath *a_Scope,
		IWbemPath *a_Provider
	) ;
	
	HRESULT Load ( 

		Enum_PropertyMask a_Mask ,
		IWbemPath *a_Scope,
		IWbemClassObject *a_Class
	) ;

	HRESULT Load ( 

		Enum_PropertyMask a_Mask ,
		IWbemPath *a_Scope,
		LPCWSTR a_Provider
	) ;

	HRESULT Load ( 

		Enum_PropertyMask a_Mask ,
		IWbemPath *a_Scope,
		IWbemPath *a_Provider
	) ;

	BOOL SupportsPut () { return m_SupportsPut ; }
	BOOL SupportsGet () { return m_SupportsGet ; }
	BOOL SupportsDelete () { return m_SupportsDelete ; }
	BOOL SupportsEnumeration () { return m_SupportsEnumeration ; }
	BOOL SupportsTransactions () { return m_SupportsTransactions ; }
	BOOL SupportsBatching () { return m_SupportsBatching ; }
	BOOL GetPerUserSchema () { return m_PerUserSchema ; }
	BOOL GetReSynchroniseOnNamespaceOpen () { return m_ReSynchroniseOnNamespaceOpen ; }
	BOOL HasReferencedSet () { return m_HasReferencedSet ; }
	ULONG QuerySupportLevels () { return m_QuerySupportLevels ; }
	Enum_InteractionType InteractionType () { return m_InteractionType ; }

	ULONG GetResultSetQueryCount () { return m_ResultSetQueryTreeCount ; }
	WmiTreeNode **GetResultSetQuery () { return m_ResultSetQueryTree ; }

	ULONG GetUnSupportedQueryCount () { return m_UnSupportedQueryTreeCount ; }
	WmiTreeNode **GetUnSupportedQuery () { return m_UnSupportedQueryTree ; }

	ULONG GetReferencedSetQueryCount () { return m_ReferencedSetQueryTreeCount ; }
	WmiTreeNode **GetReferencedSetQuery () { return m_ReferencedSetQueryTree ; }

	wchar_t *GetCacheRefreshInterval () { return m_CacheRefreshInterval ; }
	ULONG GetCacheRefreshIntervalMilliSeconds () { return m_CacheRefreshIntervalMilliSeconds ; }

	wchar_t *GetProviderName () { return m_ProviderName ; }

	BOOL Supported () { return m_Supported ; }
	HRESULT GetResult () { return m_Result ; }

	BOOL GetVersion () { return m_Version ; } 
};

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

class CServerObject_MethodProviderRegistrationV1 
{
private:

	LONG m_ReferenceCount ;

protected:

	HRESULT m_Result ;

	BOOL m_Supported ;
	BOOL m_SupportsMethods ;

	IWbemContext *m_Context ;
	IWbemPath *m_Namespace ;
	IWbemServices *m_Repository ;

private:

	static LPCWSTR s_Strings_Class ;
	static LPCWSTR s_Strings_MethodProviderRegistration ;

protected:

	HRESULT QueryRepositoryUsingQuery ( 

		Enum_PropertyMask a_Mask ,
		IWbemPath *a_Scope,
		BSTR a_Query
	) ;

public:	/* Internal */

    CServerObject_MethodProviderRegistrationV1 () ;
    ~CServerObject_MethodProviderRegistrationV1 () ;

	ULONG AddRef () ;
	ULONG Release () ;

	HRESULT SetContext (

		IWbemContext *a_Context ,
		IWbemPath *a_Namespace ,
		IWbemServices *a_Repository
	) ;

	HRESULT QueryProperties ( 

		Enum_PropertyMask a_Mask ,
		IWbemClassObject *a_Object 
	) ;

	HRESULT QueryRepository ( 

		Enum_PropertyMask a_Mask ,
		IWbemPath *a_Scope,
		LPCWSTR a_ProviderName 
	) ;

	HRESULT QueryRepository ( 

		Enum_PropertyMask a_Mask ,
		IWbemPath *a_Scope,
		IWbemPath *a_Provider
	) ;
	
	HRESULT Load ( 

		Enum_PropertyMask a_Mask ,
		IWbemPath *a_Scope,
		IWbemClassObject *a_Class
	) ;

	HRESULT Load ( 

		Enum_PropertyMask a_Mask ,
		IWbemPath *a_Scope,
		LPCWSTR a_Provider
	) ;

	HRESULT Load ( 

		Enum_PropertyMask a_Mask ,
		IWbemPath *a_Scope,
		IWbemPath *a_Provider
	) ;

	BOOL SupportsMethods () { return m_SupportsMethods ; }

	BOOL Supported () { return m_Supported ; }

	HRESULT GetResult () { return m_Result ; }
};

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

class CServerObject_EventProviderRegistrationV1 
{
private:

	LONG m_ReferenceCount ;

protected:

	HRESULT m_Result ;

	BOOL m_Supported ;

	IWbemContext *m_Context ;
	IWbemPath *m_Namespace ;
	IWbemServices *m_Repository ;

private:

	static LPCWSTR s_Strings_Class ;
	static LPCWSTR s_Strings_EventProviderRegistration ;

protected:

	HRESULT QueryRepositoryUsingQuery ( 

		Enum_PropertyMask a_Mask ,
		IWbemPath *a_Scope,
		BSTR a_Query
	) ;

public:	/* Internal */

    CServerObject_EventProviderRegistrationV1 () ;
    ~CServerObject_EventProviderRegistrationV1 () ;

	ULONG AddRef () ;
	ULONG Release () ;

	HRESULT SetContext (

		IWbemContext *a_Context ,
		IWbemPath *a_Namespace ,
		IWbemServices *a_Repository
	) ;

	HRESULT QueryProperties ( 

		Enum_PropertyMask a_Mask ,
		IWbemClassObject *a_Object 
	) ;

	HRESULT QueryRepository ( 

		Enum_PropertyMask a_Mask ,
		IWbemPath *a_Scope,
		LPCWSTR a_ProviderName 
	) ;

	HRESULT QueryRepository ( 

		Enum_PropertyMask a_Mask ,
		IWbemPath *a_Scope,
		IWbemPath *a_Provider
	) ;
	
	HRESULT Load ( 

		Enum_PropertyMask a_Mask ,
		IWbemPath *a_Scope,
		IWbemClassObject *a_Class
	) ;

	HRESULT Load ( 

		Enum_PropertyMask a_Mask ,
		IWbemPath *a_Scope,
		LPCWSTR a_Provider
	) ;

	HRESULT Load ( 

		Enum_PropertyMask a_Mask ,
		IWbemPath *a_Scope,
		IWbemPath *a_Provider
	) ;

	BOOL Supported () { return m_Supported ; }

	HRESULT GetResult () { return m_Result ; }
};

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

class CServerObject_EventConsumerProviderRegistrationV1 
{
private:

	LONG m_ReferenceCount ;

protected:

	HRESULT m_Result ;

	BOOL m_Supported ;

	IWbemContext *m_Context ;
	IWbemPath *m_Namespace ;
	IWbemServices *m_Repository ;

private:

	static LPCWSTR s_Strings_Class ;
	static LPCWSTR s_Strings_EventConsumerProviderRegistration ;

protected:

	HRESULT QueryRepositoryUsingQuery ( 

		Enum_PropertyMask a_Mask ,
		IWbemPath *a_Scope,
		BSTR a_Query
	) ;

public:	/* Internal */

    CServerObject_EventConsumerProviderRegistrationV1 () ;
    ~CServerObject_EventConsumerProviderRegistrationV1 () ;

	ULONG AddRef () ;
	ULONG Release () ;

	HRESULT SetContext (

		IWbemContext *a_Context ,
		IWbemPath *a_Namespace ,
		IWbemServices *a_Repository
	) ;

	HRESULT QueryProperties ( 

		Enum_PropertyMask a_Mask ,
		IWbemClassObject *a_Object 
	) ;

	HRESULT QueryRepository ( 

		Enum_PropertyMask a_Mask ,
		IWbemPath *a_Scope,
		LPCWSTR a_ProviderName 
	) ;

	HRESULT QueryRepository ( 

		Enum_PropertyMask a_Mask ,
		IWbemPath *a_Scope,
		IWbemPath *a_Provider
	) ;
	
	HRESULT Load ( 

		Enum_PropertyMask a_Mask ,
		IWbemPath *a_Scope,
		IWbemClassObject *a_Class
	) ;

	HRESULT Load ( 

		Enum_PropertyMask a_Mask ,
		IWbemPath *a_Scope,
		LPCWSTR a_Provider
	) ;

	HRESULT Load ( 

		Enum_PropertyMask a_Mask ,
		IWbemPath *a_Scope,
		IWbemPath *a_Provider
	) ;

	BOOL Supported () { return m_Supported ; }

	HRESULT GetResult () { return m_Result ; }
};

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

class CServerObject_DynamicPropertyProviderRegistrationV1 
{
private:

	LONG m_ReferenceCount ;

protected:

	HRESULT m_Result ;

	BOOL m_Supported ;
	BOOL m_SupportsPut ;
 	BOOL m_SupportsGet ;

	IWbemContext *m_Context ;
	IWbemPath *m_Namespace ;
	IWbemServices *m_Repository ;


private:

	static LPCWSTR s_Strings_Class ;
	static LPCWSTR s_Strings_PropertyProviderRegistration ;

	static LPCWSTR s_Strings_SupportsPut ;
	static LPCWSTR s_Strings_SupportsGet ;

protected:

	HRESULT QueryRepositoryUsingQuery ( 

		Enum_PropertyMask a_Mask ,
		IWbemPath *a_Scope,
		BSTR a_Query
	) ;

public:	/* Internal */

    CServerObject_DynamicPropertyProviderRegistrationV1 () ;
    ~CServerObject_DynamicPropertyProviderRegistrationV1 () ;

	ULONG AddRef () ;
	ULONG Release () ;

	HRESULT SetContext (

		IWbemContext *a_Context ,
		IWbemPath *a_Namespace ,
		IWbemServices *a_Repository
	) ;

	HRESULT QueryProperties ( 

		Enum_PropertyMask a_Mask ,
		IWbemClassObject *a_Object 
	) ;

	HRESULT QueryRepository ( 

		Enum_PropertyMask a_Mask ,
		IWbemPath *a_Scope,
		LPCWSTR a_ProviderName 
	) ;

	HRESULT QueryRepository ( 

		Enum_PropertyMask a_Mask ,
		IWbemPath *a_Scope,
		IWbemPath *a_Provider
	) ;
	
	HRESULT Load ( 

		Enum_PropertyMask a_Mask ,
		IWbemPath *a_Scope,
		IWbemClassObject *a_Class
	) ;

	HRESULT Load ( 

		Enum_PropertyMask a_Mask ,
		IWbemPath *a_Scope,
		LPCWSTR a_Provider
	) ;

	HRESULT Load ( 

		Enum_PropertyMask a_Mask ,
		IWbemPath *a_Scope,
		IWbemPath *a_Provider
	) ;

	BOOL SupportsPut () { return m_SupportsPut ; }
	BOOL SupportsGet () { return m_SupportsGet ; }

	BOOL Supported () { return m_Supported ; }

	HRESULT GetResult () { return m_Result ; }
};

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

class CServerObject_ProviderRegistrationV1 
{
private:

	LONG m_ReferenceCount ;

private:

	static LPCWSTR s_Strings_Class ;
	static LPCWSTR s_Strings_ClassProviderRegistration ;
	static LPCWSTR s_Strings_InstanceProviderRegistration ;
	static LPCWSTR s_Strings_MethodProviderRegistration ;
	static LPCWSTR s_Strings_PropertyProviderRegistration ;
	static LPCWSTR s_Strings_EventProviderRegistration ;
	static LPCWSTR s_Strings_EventConsumerProviderRegistration ;

protected:

	HRESULT m_Result ;

	CServerObject_ComProviderRegistrationV1 m_ComRegistration ;

	CServerObject_ClassProviderRegistrationV1 m_ClassProviderRegistration ;
	CServerObject_InstanceProviderRegistrationV1 m_InstanceProviderRegistration ;
	CServerObject_MethodProviderRegistrationV1 m_MethodProviderRegistration ;
	CServerObject_DynamicPropertyProviderRegistrationV1 m_PropertyProviderRegistration ;
	CServerObject_EventProviderRegistrationV1 m_EventProviderRegistration ;
	CServerObject_EventConsumerProviderRegistrationV1 m_EventConsumerProviderRegistration ;

	IWbemContext *m_Context ;
	IWbemPath *m_Namespace ;
	IWbemServices *m_Repository ;

protected:

	HRESULT QueryRepositoryUsingQuery ( 

		Enum_PropertyMask a_Mask ,
		IWbemPath *a_Scope,
		BSTR a_Query
	) ;

public:	/* Internal */

    CServerObject_ProviderRegistrationV1 () ;
    ~CServerObject_ProviderRegistrationV1 () ;

	ULONG AddRef () ;
	ULONG Release () ;

	HRESULT SetContext (

		IWbemContext *a_Context ,
		IWbemPath *a_Namespace ,
		IWbemServices *a_Repository
	) ;

	HRESULT QueryRepository ( 

		Enum_PropertyMask a_Mask ,
		IWbemPath *a_Scope,
		LPCWSTR a_ProviderName 
	) ;

	HRESULT QueryRepository ( 

		Enum_PropertyMask a_Mask ,
		IWbemPath *a_Scope,
		IWbemPath *a_Provider
	) ;
	
	HRESULT Load ( 

		Enum_PropertyMask a_Mask ,
		IWbemPath *a_Scope,
		IWbemClassObject *a_Class
	) ;

	HRESULT Load ( 

		Enum_PropertyMask a_Mask ,
		IWbemPath *a_Scope,
		LPCWSTR a_Provider
	) ;

	HRESULT Load ( 

		Enum_PropertyMask a_Mask ,
		IWbemPath *a_Scope,
		IWbemPath *a_Provider
	) ;

	const CLSID &GetClsid () { return m_ComRegistration.GetClsid () ; }

	BOOL PerUserInitialization () { return m_ComRegistration.PerUserInitialization () ; }
	BOOL PerLocaleInitialization () { return m_ComRegistration.PerLocaleInitialization () ; }
	Enum_InitializationReentrancy GetInitializationReentrancy () { return m_ComRegistration.GetInitializationReentrancy () ; }
	Enum_ThreadingModel GetThreadingModel () { return m_ComRegistration.GetThreadingModel () ; }	
	Enum_Hosting GetHosting () { return m_ComRegistration.GetHosting () ; }
	LPCWSTR GetHostingGroup () { return m_ComRegistration.GetHostingGroup () ; }

	ULONG GetUnloadTimeoutMilliSeconds () { return m_ComRegistration.GetUnloadTimeoutMilliSeconds () ; }
	wchar_t *GetProviderName () { return m_ComRegistration.GetProviderName () ; }
	CServerObject_ComProviderRegistrationV1 &GetComRegistration () { return m_ComRegistration ; }

	IWbemClassObject *GetIdentity () { return m_ComRegistration.GetIdentity () ; }

	CServerObject_ClassProviderRegistrationV1 &GetClassProviderRegistration () { return m_ClassProviderRegistration ; }
	CServerObject_InstanceProviderRegistrationV1 &GetInstanceProviderRegistration () { return m_InstanceProviderRegistration ; }
	CServerObject_MethodProviderRegistrationV1 &GetMethodProviderRegistration () { return m_MethodProviderRegistration ; }
	CServerObject_DynamicPropertyProviderRegistrationV1 &GetPropertyProviderRegistration () { return m_PropertyProviderRegistration ; }
	CServerObject_EventProviderRegistrationV1 &GetEventProviderRegistration () { return m_EventProviderRegistration ; }
	CServerObject_EventConsumerProviderRegistrationV1 &GetEventConsumerProviderRegistration () { return m_EventConsumerProviderRegistration ; }

	void SetUnloadTimeoutMilliSeconds ( ULONG a_UnloadTimeoutMilliSeconds ) { m_ComRegistration.SetUnloadTimeoutMilliSeconds ( a_UnloadTimeoutMilliSeconds ) ; }

	ULONG GetInitializationTimeoutMilliSeconds () { return m_ComRegistration.GetInitializationTimeoutMilliSeconds () ; }

	HRESULT GetResult () { return m_Result ; }

	BOOL ObjectProvider () ;
	BOOL EventProvider () ;
};

#endif // _Server_ProviderRegistrationInfo_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\provsubsys\decoupledadaptor\include\provinterceptor.h ===
/*++

Copyright (C) 1996-2001 Microsoft Corporation

Module Name:

	ProvWsv.H

Abstract:


History:

--*/

#ifndef _Decopled_Interceptor_IWbemServices_H
#define _Decopled_Interceptor_IWbemServices_H

#include <Allocator.h>
#include <Algorithms.h>
#include <PQueue.h>
#include <TPQueue.h>
#include <BasicTree.h>
#include <Cache.h>

#include <CGlobals.h>
#include <ProvRegInfo.h>
#include <ProvObjectSink.h>

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

typedef WmiContainerController <void *>										CWbemGlobal_VoidPointerController ;
typedef CWbemGlobal_VoidPointerController :: Container						CWbemGlobal_VoidPointerController_Container ;
typedef CWbemGlobal_VoidPointerController :: Container_Iterator				CWbemGlobal_VoidPointerController_Container_Iterator ;
typedef CWbemGlobal_VoidPointerController :: WmiContainerElement			VoidPointerContainerElement ;

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

class CInterceptor_IWbemObjectSink ;

#define CWbemGlobal_IWmiObjectSinkController						CWbemGlobal_VoidPointerController
#define CWbemGlobal_IWmiObjectSinkController_Container				CWbemGlobal_VoidPointerController_Container
#define CWbemGlobal_IWmiObjectSinkController_Container_Iterator		CWbemGlobal_VoidPointerController_Container_Iterator
#define ObjectSinkContainerElement									VoidPointerContainerElement

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

#define ProxyIndex_IWbemServices					0
#define ProxyIndex_IWbemPropertyProvider			1
#define ProxyIndex_IWbemEventProvider				2
#define ProxyIndex_IWbemEventProviderQuerySink		3
#define ProxyIndex_IWbemEventProviderSecurity		4
#define ProxyIndex_IWbemProviderIdentity			5
#define ProxyIndex_IWbemEventConsumerProvider		6
#define ProxyIndex_IWbemEventConsumerProviderEx		7
#define ProxyIndex_IWbemUnboundObjectSink			8

#define ProxyIndex_Internal_IWbemServices					9
#define ProxyIndex_Internal_IWbemPropertyProvider			10
#define ProxyIndex_Internal_IWbemEventProvider				11
#define ProxyIndex_Internal_IWbemEventProviderQuerySink		12
#define ProxyIndex_Internal_IWbemEventProviderSecurity		13
#define ProxyIndex_Internal_IWbemEventConsumerProvider		14
#define ProxyIndex_Internal_IWbemEventConsumerProviderEx	15
#define ProxyIndex_Internal_IWbemUnboundObjectSink			16

#define ProxyIndex_IWbemShutdown					17

#define ProxyIndex_Provider_Size					18

#define ProxyIndex_UnBoundSync_IWbemUnboundObjectSink			0
#define ProxyIndex_UnBoundSync_Size								1

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

class CDecoupled_IWbemSyncObjectSink :	public CCommon_IWbemSyncObjectSink
{
private:
protected:
public:

	CDecoupled_IWbemSyncObjectSink (

		WmiAllocator &a_Allocator ,
		IWbemObjectSink *a_InterceptedSink ,
		IUnknown *a_Unknown ,
		CWbemGlobal_IWmiObjectSinkController *a_Controller ,
		ULONG a_Dependant = FALSE
	) ;

	~CDecoupled_IWbemSyncObjectSink () ;
} ;

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

class CDecoupled_Batching_IWbemSyncObjectSink :	public CCommon_Batching_IWbemSyncObjectSink
{
private:
protected:
public:

	CDecoupled_Batching_IWbemSyncObjectSink (

		WmiAllocator &a_Allocator ,
		IWbemObjectSink *a_InterceptedSink ,
		IUnknown *a_Unknown ,
		CWbemGlobal_IWmiObjectSinkController *a_Controller ,
		ULONG a_Dependant = FALSE
	) ;

	~CDecoupled_Batching_IWbemSyncObjectSink () ;
} ;

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

class CInterceptor_IWbemDecoupledUnboundObjectSink : public IWbemUnboundObjectSink ,
												public Internal_IWbemUnboundObjectSink ,

												public IWbemShutdown , 
												public VoidPointerContainerElement
{
private:

	WmiAllocator &m_Allocator ;
	CServerObject_ProviderRegistrationV1 *m_Registration ;

	IUnknown *m_Unknown ;
	IWbemUnboundObjectSink *m_Provider_IWbemUnboundObjectSink ;

	ProxyContainer m_ProxyContainer ;

protected:
public:

	CInterceptor_IWbemDecoupledUnboundObjectSink (

		WmiAllocator &a_Allocator ,
		IUnknown *a_ServerSideProvider , 
		CWbemGlobal_IWmiObjectSinkController *a_Controller ,
		CServerObject_ProviderRegistrationV1 &a_Registration
	) ;

	~CInterceptor_IWbemDecoupledUnboundObjectSink () ;

	HRESULT Initialize () ;

public:

	STDMETHODIMP QueryInterface ( 

		REFIID iid , 
		LPVOID FAR *iplpv 
	) ;

	STDMETHODIMP_( ULONG ) AddRef () ;

	STDMETHODIMP_( ULONG ) Release () ;

	HRESULT STDMETHODCALLTYPE Internal_IndicateToConsumer (

		WmiInternalContext a_InternalContext ,
		IWbemClassObject *a_LogicalConsumer ,
		long a_ObjectCount ,
		IWbemClassObject **a_Objects
	) ;

	HRESULT STDMETHODCALLTYPE IndicateToConsumer (

		IWbemClassObject *a_LogicalConsumer ,
		long a_ObjectCount ,
		IWbemClassObject **a_Objects
	) ;

	/* _IWmiProviderSite */

	HRESULT STDMETHODCALLTYPE GetSite ( DWORD *a_ProcessIdentifier ) ;

	HRESULT STDMETHODCALLTYPE SetContainer ( IUnknown *a_Container ) ;

	HRESULT STDMETHODCALLTYPE Shutdown (

		LONG a_Flags ,
		ULONG a_MaxMilliSeconds ,
		IWbemContext *a_Context
	) ; 
} ;

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

class CInterceptor_DecoupledClient :	public IWbemServices , 
										public IWbemPropertyProvider ,
										public IWbemEventProvider ,
										public IWbemEventProviderQuerySink ,
										public IWbemEventProviderSecurity ,
										public IWbemProviderIdentity ,
										public IWbemEventConsumerProviderEx ,
										public IWbemUnboundObjectSink ,

										public IWbemProviderInit ,
										public Internal_IWbemProviderInit ,

										public Internal_IWbemServices , 
										public Internal_IWbemPropertyProvider ,
										public Internal_IWbemEventProvider ,
										public Internal_IWbemEventProviderQuerySink ,
										public Internal_IWbemEventProviderSecurity ,
										public Internal_IWbemEventConsumerProviderEx ,
										public Internal_IWbemUnboundObjectSink ,

										public _IWmiProviderSite ,
										public IWbemShutdown , 
										public CWbemGlobal_IWmiObjectSinkController 
{
private:

	LONG m_ReferenceCount ;

	IUnknown *m_Unknown ;
	IWbemServices *m_Provider_IWbemServices ;
	IWbemPropertyProvider *m_Provider_IWbemPropertyProvider ;
	IWbemEventProvider *m_Provider_IWbemEventProvider ;
	IWbemEventProviderQuerySink *m_Provider_IWbemEventProviderQuerySink ;
	IWbemEventProviderSecurity *m_Provider_IWbemEventProviderSecurity ;
	IWbemProviderIdentity *m_Provider_IWbemProviderIdentity ;
	IWbemEventConsumerProvider *m_Provider_IWbemEventConsumerProvider ;
	IWbemEventConsumerProviderEx *m_Provider_IWbemEventConsumerProviderEx ;
	IWbemUnboundObjectSink *m_Provider_IWbemUnboundObjectSink ;

	IWbemServices *m_CoreStub ;

	WmiAllocator &m_Allocator ;

	ProxyContainer m_ProxyContainer ;

	BSTR m_Locale ;
	BSTR m_User ;
	BSTR m_Namespace ;
	BSTR m_TransactionIdentifier ;

public:

	CServerObject_ProviderRegistrationV1 *m_Registration ;

	UINT64 m_ProviderOperation_GetObjectAsync ;
	UINT64 m_ProviderOperation_PutClassAsync ;
	UINT64 m_ProviderOperation_DeleteClassAsync ;
	UINT64 m_ProviderOperation_CreateClassEnumAsync ;
	UINT64 m_ProviderOperation_PutInstanceAsync ;
	UINT64 m_ProviderOperation_DeleteInstanceAsync ;
	UINT64 m_ProviderOperation_CreateInstanceEnumAsync ;
	UINT64 m_ProviderOperation_ExecQueryAsync ;
	UINT64 m_ProviderOperation_ExecNotificationQueryAsync ;
	UINT64 m_ProviderOperation_ExecMethodAsync ;

	UINT64 m_ProviderOperation_Begin ;
	UINT64 m_ProviderOperation_Rollback ;
	UINT64 m_ProviderOperation_Commit ;
	UINT64 m_ProviderOperation_QueryState ;

	UINT64 m_ProviderOperation_QueryInstances ;
	UINT64 m_ProviderOperation_CreateRefresher ;
	UINT64 m_ProviderOperation_CreateRefreshableObject ;
	UINT64 m_ProviderOperation_StopRefreshing ;
	UINT64 m_ProviderOperation_CreateRefreshableEnum ;
	UINT64 m_ProviderOperation_GetObjects ;

	UINT64 m_ProviderOperation_GetProperty ;
	UINT64 m_ProviderOperation_PutProperty ;

	UINT64 m_ProviderOperation_ProvideEvents ;
	UINT64 m_ProviderOperation_NewQuery ;
	UINT64 m_ProviderOperation_CancelQuery ;
	UINT64 m_ProviderOperation_AccessCheck ;
	UINT64 m_ProviderOperation_SetRegistrationObject ;
	UINT64 m_ProviderOperation_FindConsumer ;
	UINT64 m_ProviderOperation_ValidateSubscription ;

	void Increment_ProviderOperation_GetObjectAsync () { m_ProviderOperation_GetObjectAsync ++ ; }
 	void Increment_ProviderOperation_PutClassAsync () { m_ProviderOperation_PutClassAsync ++ ; }
	void Increment_ProviderOperation_DeleteClassAsync () { m_ProviderOperation_DeleteClassAsync ++ ; }
	void Increment_ProviderOperation_CreateClassEnumAsync () { m_ProviderOperation_CreateClassEnumAsync ++ ; }
	void Increment_ProviderOperation_PutInstanceAsync () { m_ProviderOperation_PutInstanceAsync ++ ; }
	void Increment_ProviderOperation_DeleteInstanceAsync () { m_ProviderOperation_DeleteInstanceAsync ++ ; }
	void Increment_ProviderOperation_CreateInstanceEnumAsync () { m_ProviderOperation_CreateInstanceEnumAsync ++ ; }
	void Increment_ProviderOperation_ExecQueryAsync () { m_ProviderOperation_ExecQueryAsync ++ ; }
	void Increment_ProviderOperation_ExecNotificationQueryAsync () { m_ProviderOperation_ExecNotificationQueryAsync ++ ; }
	void Increment_ProviderOperation_ExecMethodAsync () { m_ProviderOperation_ExecMethodAsync ++ ; }

	void Increment_ProviderOperation_Begin () { m_ProviderOperation_Begin ++ ; }
	void Increment_ProviderOperation_Rollback () { m_ProviderOperation_Rollback ++ ; }
	void Increment_ProviderOperation_Commit () { m_ProviderOperation_Commit ++ ; }
	void Increment_ProviderOperation_QueryState () { m_ProviderOperation_QueryState ++ ; }

	void Increment_ProviderOperation_QueryInstances () { m_ProviderOperation_QueryInstances ++ ; }
	void Increment_ProviderOperation_CreateRefresher () { m_ProviderOperation_CreateRefresher ++ ; }
	void Increment_ProviderOperation_CreateRefreshableObject () { m_ProviderOperation_CreateRefreshableObject ++ ; }
	void Increment_ProviderOperation_StopRefreshing () { m_ProviderOperation_StopRefreshing ++ ; }
	void Increment_ProviderOperation_CreateRefreshableEnum () { m_ProviderOperation_CreateRefreshableEnum ++ ; }
	void Increment_ProviderOperation_GetObjects () { m_ProviderOperation_GetObjects ++ ; }

	void Increment_ProviderOperation_GetProperty () { m_ProviderOperation_GetProperty ++ ; }
	void Increment_ProviderOperation_PutProperty () { m_ProviderOperation_PutProperty ++ ; }

	void Increment_ProviderOperation_ProvideEvents () { m_ProviderOperation_ProvideEvents ++ ; }
	void Increment_ProviderOperation_NewQuery () { m_ProviderOperation_NewQuery ++ ; }
	void Increment_ProviderOperation_CancelQuery () { m_ProviderOperation_CancelQuery ++ ; }
	void Increment_ProviderOperation_AccessCheck () { m_ProviderOperation_AccessCheck ++ ; }
	void Increment_ProviderOperation_SetRegistrationObject () { m_ProviderOperation_SetRegistrationObject ++ ; }
	void Increment_ProviderOperation_FindConsumer () { m_ProviderOperation_FindConsumer ++ ; }
	void Increment_ProviderOperation_ValidateSubscription () { m_ProviderOperation_ValidateSubscription ++ ; }

	UINT64 Get_ProviderOperation_GetObjectAsync () { return m_ProviderOperation_GetObjectAsync ; }
	UINT64 Get_ProviderOperation_PutClassAsync () { return m_ProviderOperation_PutClassAsync ; }
	UINT64 Get_ProviderOperation_DeleteClassAsync () { return m_ProviderOperation_DeleteClassAsync ; }
	UINT64 Get_ProviderOperation_CreateClassEnumAsync () { return m_ProviderOperation_CreateClassEnumAsync ; }
	UINT64 Get_ProviderOperation_PutInstanceAsync () { return m_ProviderOperation_PutInstanceAsync ; }
	UINT64 Get_ProviderOperation_DeleteInstanceAsync () { return m_ProviderOperation_DeleteInstanceAsync ; }
	UINT64 Get_ProviderOperation_CreateInstanceEnumAsync () { return m_ProviderOperation_CreateInstanceEnumAsync ; }
	UINT64 Get_ProviderOperation_ExecQueryAsync () { return m_ProviderOperation_ExecQueryAsync ; }
	UINT64 Get_ProviderOperation_ExecNotificationQueryAsync () { return m_ProviderOperation_ExecNotificationQueryAsync ; }
	UINT64 Get_ProviderOperation_ExecMethodAsync () { return m_ProviderOperation_ExecMethodAsync ; }

	UINT64 Get_ProviderOperation_Begin () { return m_ProviderOperation_Begin ; }
	UINT64 Get_ProviderOperation_Rollback () { return m_ProviderOperation_Rollback ; }
	UINT64 Get_ProviderOperation_Commit () { return m_ProviderOperation_Commit ; }
	UINT64 Get_ProviderOperation_QueryState () { return m_ProviderOperation_QueryState ; }

	UINT64 Get_ProviderOperation_QueryInstances () { return m_ProviderOperation_QueryInstances ; }
	UINT64 Get_ProviderOperation_CreateRefresher () { return m_ProviderOperation_CreateRefresher ; }
	UINT64 Get_ProviderOperation_CreateRefreshableObject () { return m_ProviderOperation_CreateRefreshableObject ; }
	UINT64 Get_ProviderOperation_StopRefreshing () { return m_ProviderOperation_StopRefreshing ; }
	UINT64 Get_ProviderOperation_CreateRefreshableEnum () { return m_ProviderOperation_CreateRefreshableEnum ; }
	UINT64 Get_ProviderOperation_GetObjects () { return m_ProviderOperation_GetObjects ; }

	UINT64 Get_ProviderOperation_GetProperty () { return m_ProviderOperation_GetProperty ; }
	UINT64 Get_ProviderOperation_PutProperty () { return m_ProviderOperation_PutProperty ; }

	UINT64 Get_ProviderOperation_ProvideEvents () { return m_ProviderOperation_ProvideEvents ; }
	UINT64 Get_ProviderOperation_NewQuery () { return m_ProviderOperation_NewQuery ; }
	UINT64 Get_ProviderOperation_CancelQuery () { return m_ProviderOperation_CancelQuery ; }
	UINT64 Get_ProviderOperation_AccessCheck () { return m_ProviderOperation_AccessCheck ; }
	UINT64 Get_ProviderOperation_SetRegistrationObject () { return m_ProviderOperation_SetRegistrationObject ; }
	UINT64 Get_ProviderOperation_FindConsumer () { return m_ProviderOperation_FindConsumer ; }
	UINT64 Get_ProviderOperation_ValidateSubscription () { return m_ProviderOperation_ValidateSubscription ; }

private:

	HRESULT SetStatus ( 

		LPWSTR a_Operation ,
		LPWSTR a_Parameters ,
		LPWSTR a_Description ,
		HRESULT a_Result ,
		IWbemObjectSink *a_Sink
	) ;

	HRESULT Begin_IWbemServices (

		BOOL &a_Impersonating ,
		IUnknown *&a_OldContext ,
		IServerSecurity *&a_OldSecurity ,
		BOOL &a_IsProxy ,
		IWbemServices *&a_Interface ,
		BOOL &a_Revert ,
		IUnknown *&a_Proxy
	) ;

	HRESULT End_IWbemServices (

		BOOL a_Impersonating ,
		IUnknown *a_OldContext ,
		IServerSecurity *a_OldSecurity ,
		BOOL a_IsProxy ,
		IWbemServices *a_Interface ,
		BOOL a_Revert ,
		IUnknown *a_Proxy
	) ;

	HRESULT AdjustGetContext (

		IWbemContext *a_Context
	) ;

	HRESULT Helper_GetObjectAsync (

		BOOL a_IsProxy ,
 		const BSTR a_ObjectPath ,
		long a_Flags ,
		IWbemContext *a_Context ,
		IWbemObjectSink *a_Sink ,
		IWbemServices *a_Service 
	) ;

	HRESULT Helper_PutClassAsync (

		BOOL a_IsProxy ,
		IWbemClassObject *a_Object , 
		long a_Flags ,
		IWbemContext FAR *a_Context ,
		IWbemObjectSink *a_Sink ,
		IWbemServices *a_Service 
	) ;

	HRESULT Helper_DeleteClassAsync (

		BOOL a_IsProxy ,
		const BSTR a_Class ,
		long a_Flags ,
		IWbemContext FAR *a_Context ,
		IWbemObjectSink *a_Sink ,
		IWbemServices *a_Service 
	) ;

	HRESULT Helper_CreateClassEnumAsync (

		BOOL a_IsProxy ,
		const BSTR a_SuperClass ,
		long a_Flags ,
		IWbemContext FAR *a_Context ,
		IWbemObjectSink *a_Sink ,
		IWbemServices *a_Service 
	) ;

	HRESULT Helper_PutInstanceAsync (

		BOOL a_IsProxy ,
		IWbemClassObject *a_Instance ,
		long a_Flags ,
		IWbemContext FAR *a_Context ,
		IWbemObjectSink *a_Sink ,
		IWbemServices *a_Service 
	) ;

	HRESULT Helper_DeleteInstanceAsync (

		BOOL a_IsProxy ,
		const BSTR a_ObjectPath ,
		long a_Flags ,
		IWbemContext FAR *a_Context ,
		IWbemObjectSink *a_Sink ,
		IWbemServices *a_Service 
	) ;

    HRESULT Helper_CreateInstanceEnumAsync (

		BOOL a_IsProxy ,
		const BSTR a_Class ,
		long a_Flags ,
		IWbemContext *a_Context ,
		IWbemObjectSink *a_Sink ,
		IWbemServices *a_Service
	) ;

	HRESULT Helper_ExecQueryAsync (

		BOOL a_IsProxy ,
		const BSTR a_QueryLanguage ,
		const BSTR a_Query, 
		long a_Flags ,
		IWbemContext FAR *a_Context ,
		IWbemObjectSink *a_Sink ,
		IWbemServices *a_Service 
	) ;

	HRESULT Helper_ExecMethodAsync (

		BOOL a_IsProxy ,
		const BSTR a_ObjectPath ,
		const BSTR a_MethodName ,
		long a_Flags ,
		IWbemContext *a_Context ,
		IWbemClassObject *a_InParams ,
		IWbemObjectSink *a_Sink ,
		IWbemServices *a_Service 
	) ;

public:

	CInterceptor_DecoupledClient ( 

		WmiAllocator &a_Allocator ,
		IUnknown *a_ServerSideUnknown , 
		IWbemServices *a_CoreStub ,
		CServerObject_ProviderRegistrationV1 &a_Registration
	) ;

    ~CInterceptor_DecoupledClient () ;

	HRESULT ProviderInitialize () ;

public:

	//Non-delegating object IUnknown

    STDMETHODIMP QueryInterface ( REFIID , LPVOID FAR * ) ;
    STDMETHODIMP_( ULONG ) AddRef () ;
    STDMETHODIMP_( ULONG ) Release () ;

    /* IWbemServices methods */

    HRESULT STDMETHODCALLTYPE OpenNamespace ( 

        const BSTR a_Namespace ,
        long a_Flags ,
        IWbemContext *a_Context ,
        IWbemServices **a_Service ,
        IWbemCallResult **a_CallResult
	) ;
    
    HRESULT STDMETHODCALLTYPE CancelAsyncCall ( 

        IWbemObjectSink *a_Sink
	) ;
    
    HRESULT STDMETHODCALLTYPE QueryObjectSink ( 

        long a_Flags ,
        IWbemObjectSink **a_Sink
	) ;
    
    HRESULT STDMETHODCALLTYPE GetObject ( 

		const BSTR a_ObjectPath ,
        long a_Flags ,
        IWbemContext *a_Context ,
        IWbemClassObject **ppObject ,
        IWbemCallResult **a_CallResult
	) ;
    
    HRESULT STDMETHODCALLTYPE GetObjectAsync (
        
		const BSTR a_ObjectPath ,
        long a_Flags ,
        IWbemContext *a_Context ,
        IWbemObjectSink *a_Sink
	) ;

    HRESULT STDMETHODCALLTYPE PutClass ( 

        IWbemClassObject *a_Object ,
        long a_Flags ,
        IWbemContext *a_Context ,
        IWbemCallResult **a_CallResult
	) ;
    
    HRESULT STDMETHODCALLTYPE PutClassAsync ( 

        IWbemClassObject *a_Object ,
        long a_Flags ,
        IWbemContext *a_Context ,
        IWbemObjectSink *a_Sink
	) ;
    
    HRESULT STDMETHODCALLTYPE DeleteClass ( 

        const BSTR a_Class ,
        long a_Flags ,
        IWbemContext *a_Context ,
        IWbemCallResult **a_CallResult
	) ;
    
    HRESULT STDMETHODCALLTYPE DeleteClassAsync ( 

        const BSTR a_Class ,
        long a_Flags ,
        IWbemContext *a_Context ,
        IWbemObjectSink *a_Sink
	) ;
    
    HRESULT STDMETHODCALLTYPE CreateClassEnum ( 

        const BSTR a_Superclass ,
        long a_Flags ,
        IWbemContext *a_Context ,
        IEnumWbemClassObject **a_Enum
	) ;
    
    HRESULT STDMETHODCALLTYPE CreateClassEnumAsync ( 

		const BSTR a_Superclass ,
		long a_Flags ,
		IWbemContext *a_Context ,
		IWbemObjectSink *a_Sink
	) ;
    
    HRESULT STDMETHODCALLTYPE PutInstance (

		IWbemClassObject *a_Instance ,
		long a_Flags , 
		IWbemContext *a_Context ,
		IWbemCallResult **a_CallResult
	) ;
    
    HRESULT STDMETHODCALLTYPE PutInstanceAsync (

		IWbemClassObject *a_Instance ,
		long a_Flags ,
		IWbemContext *a_Context ,
		IWbemObjectSink *a_Sink 
	) ;
    
    HRESULT STDMETHODCALLTYPE DeleteInstance ( 

		const BSTR a_ObjectPath ,
		long a_Flags ,
		IWbemContext *a_Context ,
		IWbemCallResult **a_CallResult
	) ;
    
    HRESULT STDMETHODCALLTYPE DeleteInstanceAsync ( 

		const BSTR a_ObjectPath,
		long a_Flags,
		IWbemContext *a_Context ,
		IWbemObjectSink *a_Sink
	) ;
    
    HRESULT STDMETHODCALLTYPE CreateInstanceEnum (

		const BSTR a_Class ,
		long a_Flags ,
		IWbemContext *a_Context ,
		IEnumWbemClassObject **a_Enum
	) ;
    
    HRESULT STDMETHODCALLTYPE CreateInstanceEnumAsync (

		const BSTR a_Class ,
		long a_Flags ,
		IWbemContext *a_Context ,
		IWbemObjectSink *a_Sink
	) ;
    
    HRESULT STDMETHODCALLTYPE ExecQuery ( 

		const BSTR a_QueryLanguage,
		const BSTR a_Query,
		long a_Flags ,
		IWbemContext *a_Context ,
		IEnumWbemClassObject **a_Enum
	) ;
    
    HRESULT STDMETHODCALLTYPE ExecQueryAsync (

		const BSTR a_QueryLanguage ,
		const BSTR a_Query ,
		long a_Flags ,
		IWbemContext *a_Context ,
		IWbemObjectSink *a_Sink
	) ;
    
    HRESULT STDMETHODCALLTYPE ExecNotificationQuery (

		const BSTR a_QueryLanguage ,
		const BSTR a_Query ,
		long a_Flags ,
		IWbemContext *a_Context ,
		IEnumWbemClassObject **a_Enum
	) ;
    
    HRESULT STDMETHODCALLTYPE ExecNotificationQueryAsync ( 

        const BSTR a_QueryLanguage ,
        const BSTR a_Query ,
        long a_Flags ,
        IWbemContext *a_Context ,
        IWbemObjectSink *a_Sink
	) ;
    
    HRESULT STDMETHODCALLTYPE ExecMethod (

        const BSTR a_ObjectPath ,
        const BSTR a_MethodName ,
        long a_Flags ,
        IWbemContext *a_Context ,
        IWbemClassObject *a_InParams ,
        IWbemClassObject **a_OutParams ,
        IWbemCallResult **a_CallResult
	) ;
    
    HRESULT STDMETHODCALLTYPE ExecMethodAsync ( 

		const BSTR a_ObjectPath ,
		const BSTR a_MethodName ,
		long a_Flags ,
		IWbemContext *a_Context ,
		IWbemClassObject *a_InParams ,
		IWbemObjectSink *a_Sink
	) ;

	/* IWbemPropertyProvider */

    HRESULT STDMETHODCALLTYPE GetProperty (

        long a_Flags ,
        const BSTR a_Locale ,
        const BSTR a_ClassMapping ,
        const BSTR a_InstanceMapping ,
        const BSTR a_PropertyMapping ,
        VARIANT *a_Value
	) ;
        
    HRESULT STDMETHODCALLTYPE PutProperty (

        long a_Flags ,
        const BSTR a_Locale ,
        const BSTR a_ClassMapping ,
        const BSTR a_InstanceMapping ,
        const BSTR a_PropertyMapping ,
        const VARIANT *a_Value
	) ;

	/* IWbemEventProvider */

	HRESULT STDMETHODCALLTYPE ProvideEvents (

		IWbemObjectSink *a_Sink ,
		long a_Flags
	) ;

	/* IWbemEventProviderQuerySink */

	HRESULT STDMETHODCALLTYPE NewQuery (

		unsigned long a_Id ,
		WBEM_WSTR a_QueryLanguage ,
		WBEM_WSTR a_Query
	);

	HRESULT STDMETHODCALLTYPE CancelQuery (

		unsigned long a_Id
	) ;

	/* IWbemEventProviderSecurity */

	HRESULT STDMETHODCALLTYPE AccessCheck (

		WBEM_CWSTR a_QueryLanguage ,
		WBEM_CWSTR a_Query ,
		long a_SidLength ,
		const BYTE *a_Sid
	) ;

	/* IWbemProviderIdentity */

	HRESULT STDMETHODCALLTYPE SetRegistrationObject (

		long a_Flags ,
		IWbemClassObject *a_ProviderRegistration
	) ;

	/* IWbemEventConsumerProvider */

	HRESULT STDMETHODCALLTYPE FindConsumer (

		IWbemClassObject *a_LogicalConsumer ,
		IWbemUnboundObjectSink **a_Consumer
	);

	/* IWbemEventConsumerProviderEx */

	HRESULT STDMETHODCALLTYPE ValidateSubscription (

		IWbemClassObject *a_LogicalConsumer
	) ;

	/* IWbemUnboundObjectSink */

	HRESULT STDMETHODCALLTYPE IndicateToConsumer (

		IWbemClassObject *a_LogicalConsumer ,
		long a_ObjectCount ,
		IWbemClassObject **a_Objects
	) ;

/* Internal_IWbemServices */
 
     HRESULT STDMETHODCALLTYPE Internal_OpenNamespace ( 

		WmiInternalContext a_InternalContext ,
        const BSTR a_Namespace ,
        long a_Flags ,
        IWbemContext *a_Context ,
        IWbemServices **a_Service ,
        IWbemCallResult **a_CallResult
	) ;
    
    HRESULT STDMETHODCALLTYPE Internal_CancelAsyncCall ( 

		WmiInternalContext a_InternalContext ,
        IWbemObjectSink *a_Sink
	) ;
    
    HRESULT STDMETHODCALLTYPE Internal_QueryObjectSink ( 

		WmiInternalContext a_InternalContext ,
        long a_Flags ,
        IWbemObjectSink **a_Sink
	) ;
    
    HRESULT STDMETHODCALLTYPE Internal_GetObject ( 

		WmiInternalContext a_InternalContext ,
		const BSTR a_ObjectPath ,
        long a_Flags ,
        IWbemContext *a_Context ,
        IWbemClassObject **ppObject ,
        IWbemCallResult **a_CallResult
	) ;
    
    HRESULT STDMETHODCALLTYPE Internal_GetObjectAsync (
        
		WmiInternalContext a_InternalContext ,
		const BSTR a_ObjectPath ,
        long a_Flags ,
        IWbemContext *a_Context ,
        IWbemObjectSink *a_Sink
	) ;

    HRESULT STDMETHODCALLTYPE Internal_PutClass ( 

		WmiInternalContext a_InternalContext ,
        IWbemClassObject *a_Object ,
        long a_Flags ,
        IWbemContext *a_Context ,
        IWbemCallResult **a_CallResult
	) ;
    
    HRESULT STDMETHODCALLTYPE Internal_PutClassAsync ( 

		WmiInternalContext a_InternalContext ,
        IWbemClassObject *a_Object ,
        long a_Flags ,
        IWbemContext *a_Context ,
        IWbemObjectSink *a_Sink
	) ;
    
    HRESULT STDMETHODCALLTYPE Internal_DeleteClass ( 

		WmiInternalContext a_InternalContext ,
        const BSTR a_Class ,
        long a_Flags ,
        IWbemContext *a_Context ,
        IWbemCallResult **a_CallResult
	) ;
    
    HRESULT STDMETHODCALLTYPE Internal_DeleteClassAsync ( 

		WmiInternalContext a_InternalContext ,
        const BSTR a_Class ,
        long a_Flags ,
        IWbemContext *a_Context ,
        IWbemObjectSink *a_Sink
	) ;
    
    HRESULT STDMETHODCALLTYPE Internal_CreateClassEnum ( 

		WmiInternalContext a_InternalContext ,
        const BSTR a_Superclass ,
        long a_Flags ,
        IWbemContext *a_Context ,
        IEnumWbemClassObject **a_Enum
	) ;
    
    HRESULT STDMETHODCALLTYPE Internal_CreateClassEnumAsync ( 

		WmiInternalContext a_InternalContext ,
		const BSTR a_Superclass ,
		long a_Flags ,
		IWbemContext *a_Context ,
		IWbemObjectSink *a_Sink
	) ;
    
    HRESULT STDMETHODCALLTYPE Internal_PutInstance (

		WmiInternalContext a_InternalContext ,
		IWbemClassObject *a_Instance ,
		long a_Flags , 
		IWbemContext *a_Context ,
		IWbemCallResult **a_CallResult
	) ;
    
    HRESULT STDMETHODCALLTYPE Internal_PutInstanceAsync (

		WmiInternalContext a_InternalContext ,
		IWbemClassObject *a_Instance ,
		long a_Flags ,
		IWbemContext *a_Context ,
		IWbemObjectSink *a_Sink 
	) ;
    
    HRESULT STDMETHODCALLTYPE Internal_DeleteInstance ( 

		WmiInternalContext a_InternalContext ,
		const BSTR a_ObjectPath ,
		long a_Flags ,
		IWbemContext *a_Context ,
		IWbemCallResult **a_CallResult
	) ;
    
    HRESULT STDMETHODCALLTYPE Internal_DeleteInstanceAsync ( 

		WmiInternalContext a_InternalContext ,
		const BSTR a_ObjectPath,
		long a_Flags,
		IWbemContext *a_Context ,
		IWbemObjectSink *a_Sink
	) ;
    
    HRESULT STDMETHODCALLTYPE Internal_CreateInstanceEnum (

		WmiInternalContext a_InternalContext ,
		const BSTR a_Class ,
		long a_Flags ,
		IWbemContext *a_Context ,
		IEnumWbemClassObject **a_Enum
	) ;
    
    HRESULT STDMETHODCALLTYPE Internal_CreateInstanceEnumAsync (

		WmiInternalContext a_InternalContext ,
		const BSTR a_Class ,
		long a_Flags ,
		IWbemContext *a_Context ,
		IWbemObjectSink *a_Sink
	) ;
    
    HRESULT STDMETHODCALLTYPE Internal_ExecQuery ( 

		WmiInternalContext a_InternalContext ,
		const BSTR a_QueryLanguage,
		const BSTR a_Query,
		long a_Flags ,
		IWbemContext *a_Context ,
		IEnumWbemClassObject **a_Enum
	) ;
    
    HRESULT STDMETHODCALLTYPE Internal_ExecQueryAsync (

		WmiInternalContext a_InternalContext ,
		const BSTR a_QueryLanguage ,
		const BSTR a_Query ,
		long a_Flags ,
		IWbemContext *a_Context ,
		IWbemObjectSink *a_Sink
	) ;
    
    HRESULT STDMETHODCALLTYPE Internal_ExecNotificationQuery (

		WmiInternalContext a_InternalContext ,
		const BSTR a_QueryLanguage ,
		const BSTR a_Query ,
		long a_Flags ,
		IWbemContext *a_Context ,
		IEnumWbemClassObject **a_Enum
	) ;
    
    HRESULT STDMETHODCALLTYPE Internal_ExecNotificationQueryAsync ( 

		WmiInternalContext a_InternalContext ,
        const BSTR a_QueryLanguage ,
        const BSTR a_Query ,
        long a_Flags ,
        IWbemContext *a_Context ,
        IWbemObjectSink *a_Sink
	) ;
    
    HRESULT STDMETHODCALLTYPE Internal_ExecMethod (

		WmiInternalContext a_InternalContext ,
        const BSTR a_ObjectPath ,
        const BSTR a_MethodName ,
        long a_Flags ,
        IWbemContext *a_Context ,
        IWbemClassObject *a_InParams ,
        IWbemClassObject **a_OutParams ,
        IWbemCallResult **a_CallResult
	) ;
    
    HRESULT STDMETHODCALLTYPE Internal_ExecMethodAsync ( 

		WmiInternalContext a_InternalContext ,
		const BSTR a_ObjectPath ,
		const BSTR a_MethodName ,
		long a_Flags ,
		IWbemContext *a_Context ,
		IWbemClassObject *a_InParams ,
		IWbemObjectSink *a_Sink
	) ;

	/* Internal_IWbemPropertyProvider */

    HRESULT STDMETHODCALLTYPE Internal_GetProperty (

		WmiInternalContext a_InternalContext ,
        long a_Flags ,
        const BSTR a_Locale ,
        const BSTR a_ClassMapping ,
        const BSTR a_InstanceMapping ,
        const BSTR a_PropertyMapping ,
        VARIANT *a_Value
	) ;
        
    HRESULT STDMETHODCALLTYPE Internal_PutProperty (

		WmiInternalContext a_InternalContext ,
        long a_Flags ,
        const BSTR a_Locale ,
        const BSTR a_ClassMapping ,
        const BSTR a_InstanceMapping ,
        const BSTR a_PropertyMapping ,
        const VARIANT *a_Value
	) ;

	/* Internal_IWbemEventProvider */

	HRESULT STDMETHODCALLTYPE Internal_ProvideEvents (

		WmiInternalContext a_InternalContext ,
		IWbemObjectSink *a_Sink ,
		long a_Flags
	) ;

	/* Internal_IWbemEventProviderQuerySink */

	HRESULT STDMETHODCALLTYPE Internal_NewQuery (

		WmiInternalContext a_InternalContext ,
		unsigned long a_Id ,
		WBEM_WSTR a_QueryLanguage ,
		WBEM_WSTR a_Query
	);

	HRESULT STDMETHODCALLTYPE Internal_CancelQuery (

		WmiInternalContext a_InternalContext ,
		unsigned long a_Id
	) ;

	/* Internal_IWbemEventProviderSecurity */

	HRESULT STDMETHODCALLTYPE Internal_AccessCheck (

		WmiInternalContext a_InternalContext ,
		WBEM_CWSTR a_QueryLanguage ,
		WBEM_CWSTR a_Query ,
		long a_SidLength ,
		const BYTE *a_Sid
	) ;

	/* Internal_IWbemEventConsumerProvider */

	HRESULT STDMETHODCALLTYPE Internal_FindConsumer (

		WmiInternalContext a_InternalContext ,
		IWbemClassObject *a_LogicalConsumer ,
		IWbemUnboundObjectSink **a_Consumer
	);

	/* Internal_IWbemEventConsumerProviderEx */

	HRESULT STDMETHODCALLTYPE Internal_ValidateSubscription (

		WmiInternalContext a_InternalContext ,
		IWbemClassObject *a_LogicalConsumer
	) ;

	/* Internal_IWbemUnboundObjectSink */

	HRESULT STDMETHODCALLTYPE Internal_IndicateToConsumer (

		WmiInternalContext a_InternalContext ,
		IWbemClassObject *a_LogicalConsumer ,
		long a_ObjectCount ,
		IWbemClassObject **a_Objects
	) ;


	/* IWbemProviderInit methods */

	HRESULT STDMETHODCALLTYPE Initialize (

		LPWSTR a_User ,
		LONG a_Flags ,
		LPWSTR a_Namespace ,
		LPWSTR a_Locale ,
		IWbemServices *a_CoreService ,
		IWbemContext *a_Context ,
		IWbemProviderInitSink *a_Sink
	) ;

	HRESULT STDMETHODCALLTYPE Internal_Initialize (

		WmiInternalContext a_InternalContext ,
		LPWSTR a_User ,
		LONG a_Flags ,
		LPWSTR a_Namespace ,
		LPWSTR a_Locale ,
		IWbemServices *a_CoreService ,
		IWbemContext *a_Context ,
		IWbemProviderInitSink *a_Sink
	) ;

	/* _IWmiProviderSite */

	HRESULT STDMETHODCALLTYPE GetSite ( DWORD *a_ProcessIdentifier ) ;

	HRESULT STDMETHODCALLTYPE SetContainer ( IUnknown *a_Container ) ;

	// IWmi_UnInitialize members

	HRESULT STDMETHODCALLTYPE Shutdown (

		LONG a_Flags ,
		ULONG a_MaxMilliSeconds ,
		IWbemContext *a_Context
	) ; 
} ;

#endif // _Decopled_Interceptor_IWbemServices_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\provsubsys\decoupledadaptor\include\ssdlhelper.h ===
#include "PreComp.h"
#include <locks.h>

struct SSDL_wrapper
{
  typedef BOOL (*function_type)( LPCTSTR, DWORD, PSECURITY_DESCRIPTOR *, PULONG);
  function_type current_function_; 
  CriticalSection lock_;

  SSDL_wrapper():lock_(false), current_function_(0){};
  
  static BOOL ConvertStringSecurityDescriptorToSecurityDescriptor( LPCTSTR, DWORD, PSECURITY_DESCRIPTOR *, PULONG);
  static BOOL DummyConvertStringSecurityDescriptorToSecurityDescriptor( LPCTSTR, DWORD, PSECURITY_DESCRIPTOR *, PULONG);
  function_type GetFunction(void);
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\provsubsys\decoupledadaptor\include\provregistrar.h ===
/*++

Copyright (C) 1996-2001 Microsoft Corporation

Module Name:

	ProvFact.h

Abstract:


History:

--*/

#ifndef _Server_ProviderRegistrar_H
#define _Server_ProviderRegistrar_H

#include "Globals.h"

class CInterceptor_DecoupledClient ;

class CServerObject_ProviderRegistrar_Base : public IWbemDecoupledRegistrar
{
protected:

	WmiAllocator &m_Allocator ;

	CriticalSection m_CriticalSection ;

	GUID m_Identity ;

	BSTR m_Clsid ;
	BSTR m_User ;
	BSTR m_Locale ;
	BSTR m_Scope ;
	BSTR m_Registration ;

	BOOL m_Registered ;

	CInterceptor_DecoupledClient *m_Provider ;

	HRESULT CreateInterceptor (

		IWbemContext *a_Context ,
		IUnknown *a_Unknown ,
		BYTE *&a_MarshaledProxy ,
		DWORD& a_MarshaledProxyLength ,
		IUnknown *&a_MarshaledUnknown
	) ;
	HRESULT DirectUnRegister (

		long a_Flags ,
		IWbemContext *a_Context ,
		LPCWSTR a_User ,
		LPCWSTR a_Locale ,
		LPCWSTR a_Registration ,
		LPCWSTR a_Scope ,
		GUID &a_Identity
	) ;

	HRESULT DirectRegister (

		GUID &a_Identity ,
		long a_Flags ,
		IWbemContext *a_Context ,
		LPCWSTR a_User ,
		LPCWSTR a_Locale ,
		LPCWSTR a_Registration ,
		LPCWSTR a_Scope ,
		IUnknown *a_Unknown ,
		BYTE *a_MarshaledProxy ,
		DWORD a_MarshaledProxyLength
	) ;

	HRESULT SaveToRegistry (

		long a_Flags ,
		IWbemContext *a_Context ,
		LPCWSTR a_User ,
		LPCWSTR a_Locale ,
		LPCWSTR a_Registration ,
		LPCWSTR a_Scope ,
		IUnknown *a_Unknown ,
		BYTE *a_MarshaledProxy ,
		DWORD a_MarshaledProxyLength 
	) ;

protected:

public: /* Internal */

public:	/* External */

	CServerObject_ProviderRegistrar_Base ( WmiAllocator &a_Allocator ) ;
	~CServerObject_ProviderRegistrar_Base () ;

	HRESULT STDMETHODCALLTYPE Register (

		long a_Flags ,
		IWbemContext *a_Context ,
		LPCWSTR a_User ,
		LPCWSTR a_Locale ,
		LPCWSTR a_Scope ,
		LPCWSTR a_Registration ,
		IUnknown *a_Unknown
	) ;

	HRESULT STDMETHODCALLTYPE UnRegister () ;

	HRESULT Initialize () ;
};

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

class CServerObject_ProviderRegistrar :	public CServerObject_ProviderRegistrar_Base
{
private:

    long m_ReferenceCount ;

protected:

public: /* Internal */

public:	/* External */

	CServerObject_ProviderRegistrar ( WmiAllocator &a_Allocator = *DecoupledProviderSubSystem_Globals::s_Allocator) ;
	~CServerObject_ProviderRegistrar () ;

	//IUnknown members

	STDMETHODIMP QueryInterface ( REFIID , LPVOID FAR * ) ;
    STDMETHODIMP_( ULONG ) AddRef () ;
    STDMETHODIMP_( ULONG ) Release () ;
};

#endif // _Server_ProviderRegistrar_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\provsubsys\decoupledadaptor\include\provwsvs.h ===
/*++

Copyright (C) 1996-2001 Microsoft Corporation

Module Name:

	ProvResv.H

Abstract:


History:

--*/

#ifndef _Server_Interceptor_IWbemServices_Stub_H
#define _Server_Interceptor_IWbemServices_Stub_H

#define ProxyIndex_Stub_IWbemServices					0
#define ProxyIndex_Stub_IWbemServicesEx					1
#define ProxyIndex_Stub_IWbemRefreshingServices			2

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

class CInterceptor_IWbemServices_Stub : public IWbemServices,
					public IWbemRefreshingServices ,
					public IWbemShutdown
{
private:

	LONG m_ReferenceCount ;         //Object reference count

	LONG m_GateClosed ;
	LONG m_InProgress ;

	CriticalSection m_CriticalSection ;

	WmiAllocator &m_Allocator ;

	IWbemServices *m_CoreService ;
	IWbemRefreshingServices *m_RefreshingService ;

	ProxyContainer m_ProxyContainer ;

public:

	CInterceptor_IWbemServices_Stub ( WmiAllocator &a_Allocator , IWbemServices *a_Service ) ;
    ~CInterceptor_IWbemServices_Stub () ;

public:

	//Non-delegating object IUnknown

    STDMETHODIMP QueryInterface ( REFIID , LPVOID FAR * ) ;
    STDMETHODIMP_( ULONG ) AddRef () ;
    STDMETHODIMP_( ULONG ) Release () ;

    /* IWbemServices methods */

    HRESULT STDMETHODCALLTYPE OpenNamespace ( 

        const BSTR a_Namespace ,
        long a_Flags ,
        IWbemContext *a_Context ,
        IWbemServices **a_Service ,
        IWbemCallResult **a_CallResult
	) ;
    
    HRESULT STDMETHODCALLTYPE CancelAsyncCall ( 

        IWbemObjectSink *a_Sink
	) ;
    
    HRESULT STDMETHODCALLTYPE QueryObjectSink ( 

        long a_Flags ,
        IWbemObjectSink **a_Sink
	) ;
    
    HRESULT STDMETHODCALLTYPE GetObject ( 

		const BSTR a_ObjectPath ,
        long a_Flags ,
        IWbemContext *a_Context ,
        IWbemClassObject **ppObject ,
        IWbemCallResult **a_CallResult
	) ;
    
    HRESULT STDMETHODCALLTYPE GetObjectAsync (
        
		const BSTR a_ObjectPath ,
        long a_Flags ,
        IWbemContext *a_Context ,
        IWbemObjectSink *a_Sink
	) ;

    HRESULT STDMETHODCALLTYPE PutClass ( 

        IWbemClassObject *a_Object ,
        long a_Flags ,
        IWbemContext *a_Context ,
        IWbemCallResult **a_CallResult
	) ;
    
    HRESULT STDMETHODCALLTYPE PutClassAsync ( 

        IWbemClassObject *a_Object ,
        long a_Flags ,
        IWbemContext *a_Context ,
        IWbemObjectSink *a_Sink
	) ;
    
    HRESULT STDMETHODCALLTYPE DeleteClass ( 

        const BSTR a_Class ,
        long a_Flags ,
        IWbemContext *a_Context ,
        IWbemCallResult **a_CallResult
	) ;
    
    HRESULT STDMETHODCALLTYPE DeleteClassAsync ( 

        const BSTR a_Class ,
        long a_Flags ,
        IWbemContext *a_Context ,
        IWbemObjectSink *a_Sink
	) ;
    
    HRESULT STDMETHODCALLTYPE CreateClassEnum ( 

        const BSTR a_Superclass ,
        long a_Flags ,
        IWbemContext *a_Context ,
        IEnumWbemClassObject **a_Enum
	) ;
    
    HRESULT STDMETHODCALLTYPE CreateClassEnumAsync ( 

		const BSTR a_Superclass ,
		long a_Flags ,
		IWbemContext *a_Context ,
		IWbemObjectSink *a_Sink
	) ;
    
    HRESULT STDMETHODCALLTYPE PutInstance (

		IWbemClassObject *a_Instance ,
		long a_Flags , 
		IWbemContext *a_Context ,
		IWbemCallResult **a_CallResult
	) ;
    
    HRESULT STDMETHODCALLTYPE PutInstanceAsync (

		IWbemClassObject *a_Instance ,
		long a_Flags ,
		IWbemContext *a_Context ,
		IWbemObjectSink *a_Sink 
	) ;
    
    HRESULT STDMETHODCALLTYPE DeleteInstance ( 

		const BSTR a_ObjectPath ,
		long a_Flags ,
		IWbemContext *a_Context ,
		IWbemCallResult **a_CallResult
	) ;
    
    HRESULT STDMETHODCALLTYPE DeleteInstanceAsync ( 

		const BSTR a_ObjectPath,
		long a_Flags,
		IWbemContext *a_Context ,
		IWbemObjectSink *a_Sink
	) ;
    
    HRESULT STDMETHODCALLTYPE CreateInstanceEnum (

		const BSTR a_Class ,
		long a_Flags ,
		IWbemContext *a_Context ,
		IEnumWbemClassObject **a_Enum
	) ;
    
    HRESULT STDMETHODCALLTYPE CreateInstanceEnumAsync (

		const BSTR a_Class ,
		long a_Flags ,
		IWbemContext *a_Context ,
		IWbemObjectSink *a_Sink
	) ;
    
    HRESULT STDMETHODCALLTYPE ExecQuery ( 

		const BSTR a_QueryLanguage,
		const BSTR a_Query,
		long a_Flags ,
		IWbemContext *a_Context ,
		IEnumWbemClassObject **a_Enum
	) ;
    
    HRESULT STDMETHODCALLTYPE ExecQueryAsync (

		const BSTR a_QueryLanguage ,
		const BSTR a_Query ,
		long a_Flags ,
		IWbemContext *a_Context ,
		IWbemObjectSink *a_Sink
	) ;
    
    HRESULT STDMETHODCALLTYPE ExecNotificationQuery (

		const BSTR a_QueryLanguage ,
		const BSTR a_Query ,
		long a_Flags ,
		IWbemContext *a_Context ,
		IEnumWbemClassObject **a_Enum
	) ;
    
    HRESULT STDMETHODCALLTYPE ExecNotificationQueryAsync ( 

        const BSTR a_QueryLanguage ,
        const BSTR a_Query ,
        long a_Flags ,
        IWbemContext *a_Context ,
        IWbemObjectSink *a_Sink
	) ;
    
    HRESULT STDMETHODCALLTYPE ExecMethod (

        const BSTR a_ObjectPath ,
        const BSTR a_MethodName ,
        long a_Flags ,
        IWbemContext *a_Context ,
        IWbemClassObject *a_InParams ,
        IWbemClassObject **a_OutParams ,
        IWbemCallResult **a_CallResult
	) ;
    
    HRESULT STDMETHODCALLTYPE ExecMethodAsync ( 

		const BSTR a_ObjectPath ,
		const BSTR a_MethodName ,
		long a_Flags ,
		IWbemContext *a_Context ,
		IWbemClassObject *a_InParams ,
		IWbemObjectSink *a_Sink
	) ;

	/* IWbemServicesEx */

    /*
	HRESULT STDMETHODCALLTYPE Open (

		const BSTR a_Scope ,
		const BSTR a_Selector ,
		long a_Flags ,
		IWbemContext *a_Context ,
		IWbemServicesEx **a_ScopeObject ,
		IWbemCallResultEx **a_Result
	) ;

	HRESULT STDMETHODCALLTYPE OpenAsync (

		const BSTR a_Scope,
		const BSTR a_Selector,
		long a_Flags,
		IWbemContext *a_Context,
		IWbemObjectSinkEx *a_Sink
	) ;

	HRESULT STDMETHODCALLTYPE Add (

		const BSTR a_ObjectPath ,
		long lFlags ,
		IWbemContext *a_Context ,
		IWbemCallResultEx **a_CallResult
	) ;

	HRESULT STDMETHODCALLTYPE AddAsync (

		const BSTR a_ObjectPath ,
		long a_Flags ,
		IWbemContext *a_Context ,
		IWbemObjectSink *a_Sink
	) ;

	HRESULT STDMETHODCALLTYPE Remove( 

		const BSTR a_ObjectPath ,
		long a_Flags ,
		IWbemContext __RPC_FAR *a_Context ,
		IWbemCallResultEx **a_CallResult
	) ;

	HRESULT STDMETHODCALLTYPE RemoveAsync ( 

		const BSTR strObjectPath ,
		long lFlags ,
		IWbemContext *a_Context ,
		IWbemObjectSink *a_Sink 
	) ;

	HRESULT STDMETHODCALLTYPE RefreshObject ( 

		IWbemClassObject **a_Target ,
		long a_Flags ,
		IWbemContext *a_Context ,
		IWbemCallResultEx **a_CallResult

	) ;

	HRESULT STDMETHODCALLTYPE RefreshObjectAsync ( 

		IWbemClassObject **a_Target ,
		long a_Flags ,
		IWbemContext *a_Context ,
		IWbemObjectSinkEx *a_Sink
	) ;

	HRESULT STDMETHODCALLTYPE RenameObject (

		const BSTR a_OldObjectPath ,
		const BSTR a_NewObjectPath ,
		long a_Flags ,
		IWbemContext *a_Context ,
		IWbemCallResultEx **a_CallResult
	) ;

	HRESULT STDMETHODCALLTYPE RenameObjectAsync (

		const BSTR a_OldObjectPath ,
		const BSTR a_NewObjectPath ,
		long a_Flags ,
		IWbemContext *a_Context ,
		IWbemObjectSink *a_Sink
	) ;

    HRESULT STDMETHODCALLTYPE DeleteObject (

        const BSTR a_ObjectPath ,
        long a_Flags ,
        IWbemContext *a_Context ,
        IWbemCallResult **a_CallResult
	) ;

    HRESULT STDMETHODCALLTYPE DeleteObjectAsync (

        const BSTR a_ObjectPath , 
        long a_Flags ,
        IWbemContext *a_Context ,
        IWbemObjectSink *a_Sink
	) ;

    HRESULT STDMETHODCALLTYPE PutObject (

        IWbemClassObject *a_Object ,
        long a_Flags ,
        IWbemContext *a_Context ,
        IWbemCallResult **a_CallResult
	) ;

    HRESULT STDMETHODCALLTYPE PutObjectAsync (

        IWbemClassObject *a_Object ,
        long a_Flags,
        IWbemContext *a_Context ,
		IWbemObjectSink *a_Sink
	) ;

*/    HRESULT STDMETHODCALLTYPE AddObjectToRefresher (

		WBEM_REFRESHER_ID *a_RefresherId ,
		LPCWSTR a_Path,
		long a_Flags ,
		IWbemContext *a_Context,
		DWORD a_ClientRefresherVersion ,
		WBEM_REFRESH_INFO *a_Information ,
		DWORD *a_ServerRefresherVersion
	) ;

    HRESULT STDMETHODCALLTYPE AddObjectToRefresherByTemplate (

		WBEM_REFRESHER_ID *a_RefresherId ,
		IWbemClassObject *a_Template ,
		long a_Flags ,
		IWbemContext *a_Context ,
		DWORD a_ClientRefresherVersion ,
		WBEM_REFRESH_INFO *a_Information ,
		DWORD *a_ServerRefresherVersion
	) ;

    HRESULT STDMETHODCALLTYPE AddEnumToRefresher(

		WBEM_REFRESHER_ID *a_RefresherId ,
		LPCWSTR a_Class ,
		long a_Flags ,
		IWbemContext *a_Context,
		DWORD a_ClientRefresherVersion ,
		WBEM_REFRESH_INFO *a_Information ,
		DWORD *a_ServerRefresherVersion
	) ;

    HRESULT STDMETHODCALLTYPE RemoveObjectFromRefresher (

		WBEM_REFRESHER_ID *a_RefresherId ,
		long a_Id ,
		long a_Flags ,
		DWORD a_ClientRefresherVersion ,
		DWORD *a_ServerRefresherVersion
	) ;

	HRESULT STDMETHODCALLTYPE GetRemoteRefresher (

		WBEM_REFRESHER_ID *a_RefresherId ,
		long a_Flags ,
		DWORD a_ClientRefresherVersion ,
		IWbemRemoteRefresher **a_RemoteRefresher ,
		GUID *a_Guid ,
		DWORD *a_ServerRefresherVersion
	) ;

    HRESULT STDMETHODCALLTYPE ReconnectRemoteRefresher (

		WBEM_REFRESHER_ID *a_RefresherId,
		long a_Flags,
		long a_NumberOfObjects,
		DWORD a_ClientRefresherVersion ,
		WBEM_RECONNECT_INFO *a_ReconnectInformation ,
		WBEM_RECONNECT_RESULTS *a_ReconnectResults ,
		DWORD *a_ServerRefresherVersion
	) ;

	HRESULT STDMETHODCALLTYPE Initialize (

		LPWSTR a_User ,
		LONG a_Flags ,
		LPWSTR a_Namespace ,
		LPWSTR a_Locale ,
		IWbemServices *a_Core ,
		IWbemContext *a_Context ,
		IWbemProviderInitSink *a_Sink
	) ;

	HRESULT STDMETHODCALLTYPE Shutdown (

		LONG a_Flags ,
		ULONG a_MaxMilliSeconds ,
		IWbemContext *a_Context
	) ; 
} ;


#endif // _Server_Interceptor_IWbemServices_Stub_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\provsubsys\decoupledadaptor\include\provwsv.h ===
/*++

Copyright (C) 1996-2001 Microsoft Corporation

Module Name:

	ProvWsv.H

Abstract:


History:

--*/

#ifndef _Server_Interceptor_IWbemServices_H
#define _Server_Interceptor_IWbemServices_H

#include <CGlobals.h>
#include "Exclusion.h"
#include "ProvCache.h"
#include "ProvRegInfo.h"

#define ProxyIndex_IWbemServices					0
#define ProxyIndex_IWbemPropertyProvider			1
#define ProxyIndex_IWbemHiPerfProvider				2
#define ProxyIndex_IWbemEventProvider				3
#define ProxyIndex_IWbemEventProviderQuerySink		4
#define ProxyIndex_IWbemEventProviderSecurity		5
#define ProxyIndex_IWbemProviderIdentity			6
#define ProxyIndex_IWbemEventConsumerProvider		7
#define ProxyIndex_IWbemEventConsumerProviderEx		8
#define ProxyIndex_IWbemUnboundObjectSink			9
#define ProxyIndex_IWbemProviderInit				10

#define ProxyIndex_Internal_IWbemServices					11
#define ProxyIndex_Internal_IWbemPropertyProvider			12
#define ProxyIndex_Internal_IWbemEventProvider				13
#define ProxyIndex_Internal_IWbemEventProviderQuerySink		14
#define ProxyIndex_Internal_IWbemEventProviderSecurity		15
#define ProxyIndex_Internal_IWbemEventConsumerProvider		16
#define ProxyIndex_Internal_IWbemEventConsumerProviderEx	17
#define ProxyIndex_Internal_IWbemUnboundObjectSink			18
#define ProxyIndex_Internal_IWbemProviderIdentity			19
#define ProxyIndex_Internal_IWbemProviderInit				20

#define ProxyIndex_IWbemShutdown					21
#define ProxyIndex__IWmiProviderConfiguration		22

#define ProxyIndex_Internal_IWmiProviderConfiguration		23

#define ProxyIndex_Provider_Size					23

#define ProxyIndex_UnBound_IWbemUnboundObjectSink				0
#define ProxyIndex_UnBound_Internal_IWbemUnboundObjectSink		1
#define ProxyIndex_UnBound_Size									2

#define ProxyIndex_UnBoundSync_IWbemUnboundObjectSink			0
#define ProxyIndex_UnBoundSync_Size								1


/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

class CInterceptor_IWbemSyncProvider :	public IWbemServices,
					public IWbemPropertyProvider ,
					public IWbemEventProvider ,
					public IWbemEventProviderQuerySink ,
					public IWbemEventProviderSecurity ,
					public IWbemProviderIdentity ,
					public IWbemHiPerfProvider ,
					public SyncProviderContainerElement ,
					public CWbemGlobal_IWmiObjectSinkController 
{
private:

	LONG m_ReferenceCount ;

	IUnknown *m_Unknown ;
	IWbemServices *m_Provider_IWbemServices ;
	IWbemPropertyProvider *m_Provider_IWbemPropertyProvider ;
	IWbemHiPerfProvider *m_Provider_IWbemHiPerfProvider ;
	IWbemEventProvider *m_Provider_IWbemEventProvider ;
	IWbemEventProviderQuerySink *m_Provider_IWbemEventProviderQuerySink ;
	IWbemEventProviderSecurity *m_Provider_IWbemEventProviderSecurity ;
	IWbemProviderIdentity *m_Provider_IWbemProviderIdentity ;
	IWbemEventConsumerProvider *m_Provider_IWbemEventConsumerProvider ;
	IWbemServices *m_CoreStub ;

	Exclusion *m_Exclusion ;

	ProxyContainer m_ProxyContainer ;

	LONG m_Initialized ;
	HRESULT m_InitializeResult ;
	HANDLE m_InitializedEvent ;
	IWbemContext *m_InitializationContext ;

public:

	HRESULT SetInitialized ( HRESULT a_InitializeResult ) ;

public:

	CServerObject_ProviderRegistrationV1 *m_Registration ;
	BSTR m_Locale ;
	BSTR m_User ;
	BSTR m_Namespace ;
	BSTR m_TransactionIdentifier ;

	UINT64 m_ProviderOperation_GetObjectAsync ;
	UINT64 m_ProviderOperation_PutClassAsync ;
	UINT64 m_ProviderOperation_DeleteClassAsync ;
	UINT64 m_ProviderOperation_CreateClassEnumAsync ;
	UINT64 m_ProviderOperation_PutInstanceAsync ;
	UINT64 m_ProviderOperation_DeleteInstanceAsync ;
	UINT64 m_ProviderOperation_CreateInstanceEnumAsync ;
	UINT64 m_ProviderOperation_ExecQueryAsync ;
	UINT64 m_ProviderOperation_ExecNotificationQueryAsync ;
	UINT64 m_ProviderOperation_ExecMethodAsync ;

	UINT64 m_ProviderOperation_Begin ;
	UINT64 m_ProviderOperation_Rollback ;
	UINT64 m_ProviderOperation_Commit ;
	UINT64 m_ProviderOperation_QueryState ;

	UINT64 m_ProviderOperation_QueryInstances ;
	UINT64 m_ProviderOperation_CreateRefresher ;
	UINT64 m_ProviderOperation_CreateRefreshableObject ;
	UINT64 m_ProviderOperation_StopRefreshing ;
	UINT64 m_ProviderOperation_CreateRefreshableEnum ;
	UINT64 m_ProviderOperation_GetObjects ;

	UINT64 m_ProviderOperation_GetProperty ;
	UINT64 m_ProviderOperation_PutProperty ;

	UINT64 m_ProviderOperation_ProvideEvents ;
	UINT64 m_ProviderOperation_NewQuery ;
	UINT64 m_ProviderOperation_CancelQuery ;
	UINT64 m_ProviderOperation_AccessCheck ;
	UINT64 m_ProviderOperation_SetRegistrationObject ;
	UINT64 m_ProviderOperation_FindConsumer ;
	UINT64 m_ProviderOperation_ValidateSubscription ;

	UINT64 m_ProviderOperation_OpenAsync ;
	UINT64 m_ProviderOperation_AddAsync ;
	UINT64 m_ProviderOperation_RemoveAsync ;
	UINT64 m_ProviderOperation_RefreshObjectAsync ;
	UINT64 m_ProviderOperation_RenameObjectAsync ;
	UINT64 m_ProviderOperation_DeleteObjectAsync ;
	UINT64 m_ProviderOperation_PutObjectAsync ;

	void Increment_ProviderOperation_GetObjectAsync () { m_ProviderOperation_GetObjectAsync ++ ; }
 	void Increment_ProviderOperation_PutClassAsync () { m_ProviderOperation_PutClassAsync ++ ; }
	void Increment_ProviderOperation_DeleteClassAsync () { m_ProviderOperation_DeleteClassAsync ++ ; }
	void Increment_ProviderOperation_CreateClassEnumAsync () { m_ProviderOperation_CreateClassEnumAsync ++ ; }
	void Increment_ProviderOperation_PutInstanceAsync () { m_ProviderOperation_PutInstanceAsync ++ ; }
	void Increment_ProviderOperation_DeleteInstanceAsync () { m_ProviderOperation_DeleteInstanceAsync ++ ; }
	void Increment_ProviderOperation_CreateInstanceEnumAsync () { m_ProviderOperation_CreateInstanceEnumAsync ++ ; }
	void Increment_ProviderOperation_ExecQueryAsync () { m_ProviderOperation_ExecQueryAsync ++ ; }
	void Increment_ProviderOperation_ExecNotificationQueryAsync () { m_ProviderOperation_ExecNotificationQueryAsync ++ ; }
	void Increment_ProviderOperation_ExecMethodAsync () { m_ProviderOperation_ExecMethodAsync ++ ; }

	void Increment_ProviderOperation_Begin () { m_ProviderOperation_Begin ++ ; }
	void Increment_ProviderOperation_Rollback () { m_ProviderOperation_Rollback ++ ; }
	void Increment_ProviderOperation_Commit () { m_ProviderOperation_Commit ++ ; }
	void Increment_ProviderOperation_QueryState () { m_ProviderOperation_QueryState ++ ; }

	void Increment_ProviderOperation_QueryInstances () { m_ProviderOperation_QueryInstances ++ ; }
	void Increment_ProviderOperation_CreateRefresher () { m_ProviderOperation_CreateRefresher ++ ; }
	void Increment_ProviderOperation_CreateRefreshableObject () { m_ProviderOperation_CreateRefreshableObject ++ ; }
	void Increment_ProviderOperation_StopRefreshing () { m_ProviderOperation_StopRefreshing ++ ; }
	void Increment_ProviderOperation_CreateRefreshableEnum () { m_ProviderOperation_CreateRefreshableEnum ++ ; }
	void Increment_ProviderOperation_GetObjects () { m_ProviderOperation_GetObjects ++ ; }

	void Increment_ProviderOperation_GetProperty () { m_ProviderOperation_GetProperty ++ ; }
	void Increment_ProviderOperation_PutProperty () { m_ProviderOperation_PutProperty ++ ; }

	void Increment_ProviderOperation_ProvideEvents () { m_ProviderOperation_ProvideEvents ++ ; }
	void Increment_ProviderOperation_NewQuery () { m_ProviderOperation_NewQuery ++ ; }
	void Increment_ProviderOperation_CancelQuery () { m_ProviderOperation_CancelQuery ++ ; }
	void Increment_ProviderOperation_AccessCheck () { m_ProviderOperation_AccessCheck ++ ; }
	void Increment_ProviderOperation_SetRegistrationObject () { m_ProviderOperation_SetRegistrationObject ++ ; }
	void Increment_ProviderOperation_FindConsumer () { m_ProviderOperation_FindConsumer ++ ; }
	void Increment_ProviderOperation_ValidateSubscription () { m_ProviderOperation_ValidateSubscription ++ ; }

	void Increment_ProviderOperation_OpenAsync () { m_ProviderOperation_OpenAsync ++ ; }
	void Increment_ProviderOperation_AddAsync () { m_ProviderOperation_AddAsync ++ ; }
	void Increment_ProviderOperation_RemoveAsync () { m_ProviderOperation_RemoveAsync ++ ; }
	void Increment_ProviderOperation_RefreshObjectAsync () { m_ProviderOperation_RefreshObjectAsync ++ ; }
	void Increment_ProviderOperation_RenameObjectAsync () { m_ProviderOperation_RenameObjectAsync ++ ; }
	void Increment_ProviderOperation_DeleteObjectAsync () { m_ProviderOperation_DeleteObjectAsync ++ ; }
	void Increment_ProviderOperation_PutObjectAsync () { m_ProviderOperation_PutObjectAsync ++ ; }

	UINT64 Get_ProviderOperation_GetObjectAsync () { return m_ProviderOperation_GetObjectAsync ; }
	UINT64 Get_ProviderOperation_PutClassAsync () { return m_ProviderOperation_PutClassAsync ; }
	UINT64 Get_ProviderOperation_DeleteClassAsync () { return m_ProviderOperation_DeleteClassAsync ; }
	UINT64 Get_ProviderOperation_CreateClassEnumAsync () { return m_ProviderOperation_CreateClassEnumAsync ; }
	UINT64 Get_ProviderOperation_PutInstanceAsync () { return m_ProviderOperation_PutInstanceAsync ; }
	UINT64 Get_ProviderOperation_DeleteInstanceAsync () { return m_ProviderOperation_DeleteInstanceAsync ; }
	UINT64 Get_ProviderOperation_CreateInstanceEnumAsync () { return m_ProviderOperation_CreateInstanceEnumAsync ; }
	UINT64 Get_ProviderOperation_ExecQueryAsync () { return m_ProviderOperation_ExecQueryAsync ; }
	UINT64 Get_ProviderOperation_ExecNotificationQueryAsync () { return m_ProviderOperation_ExecNotificationQueryAsync ; }
	UINT64 Get_ProviderOperation_ExecMethodAsync () { return m_ProviderOperation_ExecMethodAsync ; }

	UINT64 Get_ProviderOperation_Begin () { return m_ProviderOperation_Begin ; }
	UINT64 Get_ProviderOperation_Rollback () { return m_ProviderOperation_Rollback ; }
	UINT64 Get_ProviderOperation_Commit () { return m_ProviderOperation_Commit ; }
	UINT64 Get_ProviderOperation_QueryState () { return m_ProviderOperation_QueryState ; }

	UINT64 Get_ProviderOperation_QueryInstances () { return m_ProviderOperation_QueryInstances ; }
	UINT64 Get_ProviderOperation_CreateRefresher () { return m_ProviderOperation_CreateRefresher ; }
	UINT64 Get_ProviderOperation_CreateRefreshableObject () { return m_ProviderOperation_CreateRefreshableObject ; }
	UINT64 Get_ProviderOperation_StopRefreshing () { return m_ProviderOperation_StopRefreshing ; }
	UINT64 Get_ProviderOperation_CreateRefreshableEnum () { return m_ProviderOperation_CreateRefreshableEnum ; }
	UINT64 Get_ProviderOperation_GetObjects () { return m_ProviderOperation_GetObjects ; }

	UINT64 Get_ProviderOperation_GetProperty () { return m_ProviderOperation_GetProperty ; }
	UINT64 Get_ProviderOperation_PutProperty () { return m_ProviderOperation_PutProperty ; }

	UINT64 Get_ProviderOperation_ProvideEvents () { return m_ProviderOperation_ProvideEvents ; }
	UINT64 Get_ProviderOperation_NewQuery () { return m_ProviderOperation_NewQuery ; }
	UINT64 Get_ProviderOperation_CancelQuery () { return m_ProviderOperation_CancelQuery ; }
	UINT64 Get_ProviderOperation_AccessCheck () { return m_ProviderOperation_AccessCheck ; }
	UINT64 Get_ProviderOperation_SetRegistrationObject () { return m_ProviderOperation_SetRegistrationObject ; }
	UINT64 Get_ProviderOperation_FindConsumer () { return m_ProviderOperation_FindConsumer ; }
	UINT64 Get_ProviderOperation_ValidateSubscription () { return m_ProviderOperation_ValidateSubscription ; }

	UINT64 Get_ProviderOperation_OpenAsync () { return m_ProviderOperation_OpenAsync ; }
	UINT64 Get_ProviderOperation_AddAsync () { return m_ProviderOperation_AddAsync ; }
	UINT64 Get_ProviderOperation_RemoveAsync () { return m_ProviderOperation_RemoveAsync ; }
	UINT64 Get_ProviderOperation_RefreshObjectAsync () { return m_ProviderOperation_RefreshObjectAsync ; }
	UINT64 Get_ProviderOperation_RenameObjectAsync () { return m_ProviderOperation_RenameObjectAsync ; }
	UINT64 Get_ProviderOperation_DeleteObjectAsync () { return m_ProviderOperation_RenameObjectAsync ; }
	UINT64 Get_ProviderOperation_PutObjectAsync () { return m_ProviderOperation_PutObjectAsync ; }

private:

	HRESULT AdjustGetContext (

		IWbemContext *a_Context
	) ;

	HRESULT Helper_HiPerfGetObjectAsync (

		IWbemHiPerfProvider *a_HighPerformanceProvider ,
 		const BSTR a_ObjectPath ,
		long a_Flags ,
		IWbemContext *a_Context ,
		IWbemObjectSink *a_Sink
	) ;

	HRESULT Helper_GetObjectAsync (

		BOOL a_IsProxy ,
 		const BSTR a_ObjectPath ,
		long a_Flags ,
		IWbemContext *a_Context ,
		IWbemObjectSink *a_Sink ,
		IWbemServices *a_Service 
	) ;

	HRESULT Helper_PutClassAsync (

		BOOL a_IsProxy ,
		IWbemClassObject *a_Object , 
		long a_Flags ,
		IWbemContext FAR *a_Context ,
		IWbemObjectSink *a_Sink ,
		IWbemServices *a_Service 
	) ;

	HRESULT Helper_DeleteClassAsync (

		BOOL a_IsProxy ,
		const BSTR a_Class ,
		long a_Flags ,
		IWbemContext FAR *a_Context ,
		IWbemObjectSink *a_Sink ,
		IWbemServices *a_Service 
	) ;

	HRESULT Helper_CreateClassEnumAsync (

		BOOL a_IsProxy ,
		const BSTR a_SuperClass ,
		long a_Flags ,
		IWbemContext FAR *a_Context ,
		IWbemObjectSink *a_Sink ,
		IWbemServices *a_Service 
	) ;

	HRESULT Helper_PutInstanceAsync (

		BOOL a_IsProxy ,
		IWbemClassObject *a_Instance ,
		long a_Flags ,
		IWbemContext FAR *a_Context ,
		IWbemObjectSink *a_Sink ,
		IWbemServices *a_Service 
	) ;

	HRESULT Helper_DeleteInstanceAsync (

		BOOL a_IsProxy ,
		const BSTR a_ObjectPath ,
		long a_Flags ,
		IWbemContext FAR *a_Context ,
		IWbemObjectSink *a_Sink ,
		IWbemServices *a_Service 
	) ;

    HRESULT Helper_CreateInstanceEnumAsync (

		BOOL a_IsProxy ,
		const BSTR a_Class ,
		long a_Flags ,
		IWbemContext *a_Context ,
		IWbemObjectSink *a_Sink ,
		IWbemServices *a_Service
	) ;

	HRESULT Helper_QueryInstancesAsync (

		IWbemHiPerfProvider *a_PerformanceProvider ,
 		const BSTR a_Class ,
		long a_Flags ,
		IWbemContext *a_Context ,
		IWbemObjectSink *a_Sink 
	) ;

	HRESULT Helper_ExecQueryAsync (

		BOOL a_IsProxy ,
		const BSTR a_QueryLanguage ,
		const BSTR a_Query, 
		long a_Flags ,
		IWbemContext FAR *a_Context ,
		IWbemObjectSink *a_Sink ,
		IWbemServices *a_Service 
	) ;

	HRESULT Helper_ExecMethodAsync (

		BOOL a_IsProxy ,
		const BSTR a_ObjectPath ,
		const BSTR a_MethodName ,
		long a_Flags ,
		IWbemContext *a_Context ,
		IWbemClassObject *a_InParams ,
		IWbemObjectSink *a_Sink ,
		IWbemServices *a_Service 
	) ;

public:

	CInterceptor_IWbemSyncProvider ( 

		WmiAllocator &a_Allocator ,
		IUnknown *a_ClientSideUnknown , 
		IUnknown *a_ServerSideUnknown , 
		IWbemServices *a_CoreStub ,
		CWbemGlobal_IWbemSyncProviderController *a_Controller ,
		CServerObject_ProviderRegistrationV1 &a_Registration ,
		Exclusion *a_Exclusion ,
		GUID &a_Guid 
	) ;

    ~CInterceptor_IWbemSyncProvider () ;

public:

	//Non-delegating object IUnknown

    STDMETHODIMP QueryInterface ( REFIID , LPVOID FAR * ) ;
    STDMETHODIMP_( ULONG ) AddRef () ;
    STDMETHODIMP_( ULONG ) Release () ;

    /* IWbemServices methods */

    HRESULT STDMETHODCALLTYPE OpenNamespace ( 

        const BSTR a_Namespace ,
        long a_Flags ,
        IWbemContext *a_Context ,
        IWbemServices **a_Service ,
        IWbemCallResult **a_CallResult
	) ;
    
    HRESULT STDMETHODCALLTYPE CancelAsyncCall ( 

        IWbemObjectSink *a_Sink
	) ;
    
    HRESULT STDMETHODCALLTYPE QueryObjectSink ( 

        long a_Flags ,
        IWbemObjectSink **a_Sink
	) ;
    
    HRESULT STDMETHODCALLTYPE GetObject ( 

		const BSTR a_ObjectPath ,
        long a_Flags ,
        IWbemContext *a_Context ,
        IWbemClassObject **ppObject ,
        IWbemCallResult **a_CallResult
	) ;
    
    HRESULT STDMETHODCALLTYPE GetObjectAsync (
        
		const BSTR a_ObjectPath ,
        long a_Flags ,
        IWbemContext *a_Context ,
        IWbemObjectSink *a_Sink
	) ;

    HRESULT STDMETHODCALLTYPE PutClass ( 

        IWbemClassObject *a_Object ,
        long a_Flags ,
        IWbemContext *a_Context ,
        IWbemCallResult **a_CallResult
	) ;
    
    HRESULT STDMETHODCALLTYPE PutClassAsync ( 

        IWbemClassObject *a_Object ,
        long a_Flags ,
        IWbemContext *a_Context ,
        IWbemObjectSink *a_Sink
	) ;
    
    HRESULT STDMETHODCALLTYPE DeleteClass ( 

        const BSTR a_Class ,
        long a_Flags ,
        IWbemContext *a_Context ,
        IWbemCallResult **a_CallResult
	) ;
    
    HRESULT STDMETHODCALLTYPE DeleteClassAsync ( 

        const BSTR a_Class ,
        long a_Flags ,
        IWbemContext *a_Context ,
        IWbemObjectSink *a_Sink
	) ;
    
    HRESULT STDMETHODCALLTYPE CreateClassEnum ( 

        const BSTR a_Superclass ,
        long a_Flags ,
        IWbemContext *a_Context ,
        IEnumWbemClassObject **a_Enum
	) ;
    
    HRESULT STDMETHODCALLTYPE CreateClassEnumAsync ( 

		const BSTR a_Superclass ,
		long a_Flags ,
		IWbemContext *a_Context ,
		IWbemObjectSink *a_Sink
	) ;
    
    HRESULT STDMETHODCALLTYPE PutInstance (

		IWbemClassObject *a_Instance ,
		long a_Flags , 
		IWbemContext *a_Context ,
		IWbemCallResult **a_CallResult
	) ;
    
    HRESULT STDMETHODCALLTYPE PutInstanceAsync (

		IWbemClassObject *a_Instance ,
		long a_Flags ,
		IWbemContext *a_Context ,
		IWbemObjectSink *a_Sink 
	) ;
    
    HRESULT STDMETHODCALLTYPE DeleteInstance ( 

		const BSTR a_ObjectPath ,
		long a_Flags ,
		IWbemContext *a_Context ,
		IWbemCallResult **a_CallResult
	) ;
    
    HRESULT STDMETHODCALLTYPE DeleteInstanceAsync ( 

		const BSTR a_ObjectPath,
		long a_Flags,
		IWbemContext *a_Context ,
		IWbemObjectSink *a_Sink
	) ;
    
    HRESULT STDMETHODCALLTYPE CreateInstanceEnum (

		const BSTR a_Class ,
		long a_Flags ,
		IWbemContext *a_Context ,
		IEnumWbemClassObject **a_Enum
	) ;
    
    HRESULT STDMETHODCALLTYPE CreateInstanceEnumAsync (

		const BSTR a_Class ,
		long a_Flags ,
		IWbemContext *a_Context ,
		IWbemObjectSink *a_Sink
	) ;
    
    HRESULT STDMETHODCALLTYPE ExecQuery ( 

		const BSTR a_QueryLanguage,
		const BSTR a_Query,
		long a_Flags ,
		IWbemContext *a_Context ,
		IEnumWbemClassObject **a_Enum
	) ;
    
    HRESULT STDMETHODCALLTYPE ExecQueryAsync (

		const BSTR a_QueryLanguage ,
		const BSTR a_Query ,
		long a_Flags ,
		IWbemContext *a_Context ,
		IWbemObjectSink *a_Sink
	) ;
    
    HRESULT STDMETHODCALLTYPE ExecNotificationQuery (

		const BSTR a_QueryLanguage ,
		const BSTR a_Query ,
		long a_Flags ,
		IWbemContext *a_Context ,
		IEnumWbemClassObject **a_Enum
	) ;
    
    HRESULT STDMETHODCALLTYPE ExecNotificationQueryAsync ( 

        const BSTR a_QueryLanguage ,
        const BSTR a_Query ,
        long a_Flags ,
        IWbemContext *a_Context ,
        IWbemObjectSink *a_Sink
	) ;
    
    HRESULT STDMETHODCALLTYPE ExecMethod (

        const BSTR a_ObjectPath ,
        const BSTR a_MethodName ,
        long a_Flags ,
        IWbemContext *a_Context ,
        IWbemClassObject *a_InParams ,
        IWbemClassObject **a_OutParams ,
        IWbemCallResult **a_CallResult
	) ;
    
    HRESULT STDMETHODCALLTYPE ExecMethodAsync ( 

		const BSTR a_ObjectPath ,
		const BSTR a_MethodName ,
		long a_Flags ,
		IWbemContext *a_Context ,
		IWbemClassObject *a_InParams ,
		IWbemObjectSink *a_Sink
	) ;


	/* IWbemPropertyProvider */

    HRESULT STDMETHODCALLTYPE GetProperty (

        long a_Flags ,
        const BSTR a_Locale ,
        const BSTR a_ClassMapping ,
        const BSTR a_InstanceMapping ,
        const BSTR a_PropertyMapping ,
        VARIANT *a_Value
	) ;
        
    HRESULT STDMETHODCALLTYPE PutProperty (

        long a_Flags ,
        const BSTR a_Locale ,
        const BSTR a_ClassMapping ,
        const BSTR a_InstanceMapping ,
        const BSTR a_PropertyMapping ,
        const VARIANT *a_Value
	) ;

	/* IWbemEventProvider */

	HRESULT STDMETHODCALLTYPE ProvideEvents (

		IWbemObjectSink *a_Sink ,
		long a_Flags
	) ;

	/* IWbemEventProviderQuerySink */

	HRESULT STDMETHODCALLTYPE NewQuery (

		unsigned long a_Id ,
		WBEM_WSTR a_QueryLanguage ,
		WBEM_WSTR a_Query
	);

	HRESULT STDMETHODCALLTYPE CancelQuery (

		unsigned long a_Id
	) ;

	/* IWbemEventProviderSecurity */

	HRESULT STDMETHODCALLTYPE AccessCheck (

		WBEM_CWSTR a_QueryLanguage ,
		WBEM_CWSTR a_Query ,
		long a_SidLength ,
		const BYTE *a_Sid
	) ;

	/* IWbemProviderIdentity */

	HRESULT STDMETHODCALLTYPE SetRegistrationObject (

		long a_Flags ,
		IWbemClassObject *a_ProviderRegistration
	) ;

	/* IWbemEventConsumerProvider */

	HRESULT STDMETHODCALLTYPE FindConsumer (

		IWbemClassObject *a_LogicalConsumer ,
		IWbemUnboundObjectSink **a_Consumer
	);


	/* IWbemHiPerfProvider */

	HRESULT STDMETHODCALLTYPE QueryInstances (

		IWbemServices *a_Namespace ,
		WCHAR *a_Class ,
		long a_Flags ,
		IWbemContext *a_Context ,
		IWbemObjectSink *a_Sink
	) ;

	HRESULT STDMETHODCALLTYPE CreateRefresher (

		IWbemServices *a_Namespace ,
		long a_Flags ,
		IWbemRefresher **a_Refresher
	) ; 

	HRESULT STDMETHODCALLTYPE CreateRefreshableObject (

		IWbemServices *a_Namespace ,
		IWbemObjectAccess *a_Template ,
		IWbemRefresher *a_Refresher ,
		long a_Flags ,
		IWbemContext *a_Context ,
		IWbemObjectAccess **a_Refreshable ,
		long *a_Id
	) ;

	HRESULT STDMETHODCALLTYPE StopRefreshing (

		IWbemRefresher *a_Refresher ,
		long a_Id ,
		long a_Flags
	) ;

	HRESULT STDMETHODCALLTYPE CreateRefreshableEnum (

		IWbemServices *a_Namespace ,
		LPCWSTR a_Class ,
		IWbemRefresher *a_Refresher ,
		long a_Flags ,
		IWbemContext *a_Context ,
		IWbemHiPerfEnum *a_HiPerfEnum ,
		long *a_Id
	) ;

	HRESULT STDMETHODCALLTYPE GetObjects (

		IWbemServices *a_Namespace ,
		long a_ObjectCount ,
		IWbemObjectAccess **a_Objects ,
		long a_Flags ,
		IWbemContext *a_Context
	) ;

	HRESULT STDMETHODCALLTYPE Initialize (LPWSTR a_User ,
					     LONG a_Flags ,
					     LPWSTR a_Namespace ,
					     LPWSTR a_Locale ,
					     IWbemServices *a_Service ,
					     IWbemContext *a_Context ,
					     IWbemProviderInitSink *a_Sink) ;

	HRESULT STDMETHODCALLTYPE WaitProvider ( IWbemContext *a_Context , ULONG a_Timeout ) ;

	HRESULT STDMETHODCALLTYPE GetInitializeResult () 
	{
		return m_InitializeResult ;
	}

	HRESULT STDMETHODCALLTYPE IsPerUserInitialization ( BOOL *a_Value )
	{
		return WBEM_E_NOT_AVAILABLE ;
	}

	HRESULT STDMETHODCALLTYPE IsPerLocaleInitialization ( BOOL *a_Value )
	{
		return WBEM_E_NOT_AVAILABLE ;
	}

	// IWmi_UnInitialize members

	HRESULT STDMETHODCALLTYPE Shutdown (

		LONG a_Flags ,
		ULONG a_MaxMilliSeconds ,
		IWbemContext *a_Context
	) ; 
} ;

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

class CDecoupled_IWbemUnboundObjectSink :		public IWbemUnboundObjectSink ,
												public IWbemShutdown , 
												public VoidPointerContainerElement
{
private:

	WmiAllocator &m_Allocator ;
	CServerObject_ProviderRegistrationV1 *m_Registration ;

	_IWmiProviderAbnormalShutdown *m_Controller ;

	IUnknown *m_Unknown ;
	IWbemUnboundObjectSink *m_Provider_IWbemUnboundObjectSink ;
	Internal_IWbemUnboundObjectSink *m_Provider_Internal_IWbemUnboundObjectSink ;

	ProxyContainer m_ProxyContainer ;

	DWORD m_ProcessIdentifier ;

	HRESULT m_InitializeResult ;

protected:

	HRESULT Begin_Interface (

		IUnknown *a_ServerInterface ,
		REFIID a_InterfaceIdentifier ,
		DWORD a_ProxyIndex ,
		IUnknown *a_InternalServerInterface ,
		REFIID a_InternalInterfaceIdentifier ,
		DWORD a_InternalProxyIndex ,
		DWORD a_ProcessIdentifier ,
		HANDLE &a_IdentifyToken ,
		BOOL &a_Impersonating ,
		IUnknown *&a_OldContext ,
		IServerSecurity *&a_OldSecurity ,
		BOOL &a_IsProxy ,
		IUnknown *&a_Interface ,
		BOOL &a_Revert ,
		IUnknown *&a_Proxy ,
		IWbemContext *a_Context = NULL
	) ;

	HRESULT End_Interface (

		IUnknown *a_ServerInterface ,
		REFIID a_InterfaceIdentifier ,
		DWORD a_ProxyIndex ,
		IUnknown *a_InternalServerInterface ,
		REFIID a_InternalInterfaceIdentifier ,
		DWORD a_InternalProxyIndex ,
		DWORD a_ProcessIdentifier ,
		HANDLE a_IdentifyToken ,
		BOOL a_Impersonating ,
		IUnknown *a_OldContext ,
		IServerSecurity *a_OldSecurity ,
		BOOL a_IsProxy ,
		IUnknown *a_Interface ,
		BOOL a_Revert ,
		IUnknown *a_Proxy
	) ;

public:

	CDecoupled_IWbemUnboundObjectSink (

		WmiAllocator &a_Allocator ,
		IUnknown *a_ServerSideProvider , 
		CWbemGlobal_IWmiObjectSinkController *a_Controller , 
		CServerObject_ProviderRegistrationV1 &a_Registration
	) ;

	~CDecoupled_IWbemUnboundObjectSink () ;

	HRESULT Initialize () ;

public:

	STDMETHODIMP QueryInterface ( 

		REFIID iid , 
		LPVOID FAR *iplpv 
	) ;

	STDMETHODIMP_( ULONG ) AddRef () ;

	STDMETHODIMP_( ULONG ) Release () ;

	HRESULT STDMETHODCALLTYPE IndicateToConsumer (

		IWbemClassObject *a_LogicalConsumer ,
		long a_ObjectCount ,
		IWbemClassObject **a_Objects
	) ;

	HRESULT STDMETHODCALLTYPE Shutdown (

		LONG a_Flags ,
		ULONG a_MaxMilliSeconds ,
		IWbemContext *a_Context
	) ; 
} ;


/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

class CInterceptor_IWbemDecoupledProvider :	public IWbemServices , 
											public IWbemPropertyProvider ,
											public IWbemEventProvider ,
											public IWbemEventProviderQuerySink ,
											public IWbemEventProviderSecurity ,
											public IWbemProviderInit ,
											public IWbemProviderIdentity ,
											public IWbemEventConsumerProviderEx ,
											public IWbemUnboundObjectSink ,

											public IWbemShutdown , 
											public _IWmiProviderInitialize ,
											public _IWmiProviderAbnormalShutdown ,
											public SyncProviderContainerElement ,
											public CWbemGlobal_IWmiObjectSinkController 
{
private:

	IUnknown *m_Unknown ;
	IWbemServices *m_Provider_IWbemServices ;
	IWbemPropertyProvider *m_Provider_IWbemPropertyProvider ;
	IWbemEventProvider *m_Provider_IWbemEventProvider ;
	IWbemEventProviderQuerySink *m_Provider_IWbemEventProviderQuerySink ;
	IWbemEventProviderSecurity *m_Provider_IWbemEventProviderSecurity ;
	IWbemEventConsumerProvider *m_Provider_IWbemEventConsumerProvider ;
	IWbemEventConsumerProviderEx *m_Provider_IWbemEventConsumerProviderEx ;
	IWbemUnboundObjectSink *m_Provider_IWbemUnboundObjectSink ;
	IWbemProviderInit *m_Provider_IWbemProviderInit ;
	IWbemProviderIdentity *m_Provider_IWbemProviderIdentity ;

	Internal_IWbemServices *m_Provider_Internal_IWbemServices ;
	Internal_IWbemPropertyProvider *m_Provider_Internal_IWbemPropertyProvider ;
	Internal_IWbemEventProvider *m_Provider_Internal_IWbemEventProvider ;
	Internal_IWbemEventProviderQuerySink *m_Provider_Internal_IWbemEventProviderQuerySink ;
	Internal_IWbemEventProviderSecurity *m_Provider_Internal_IWbemEventProviderSecurity ;
	Internal_IWbemEventConsumerProvider *m_Provider_Internal_IWbemEventConsumerProvider ;
	Internal_IWbemEventConsumerProviderEx *m_Provider_Internal_IWbemEventConsumerProviderEx ;
	Internal_IWbemUnboundObjectSink *m_Provider_Internal_IWbemUnboundObjectSink ;
	Internal_IWmiProviderConfiguration *m_Provider_Internal_IWmiProviderConfiguration ;
	Internal_IWbemProviderInit *m_Provider_Internal_IWbemProviderInit ;
	Internal_IWbemProviderIdentity *m_Provider_Internal_IWbemProviderIdentity ;

	IWbemServices *m_CoreStub ;

	IWbemClassObject *m_ExtendedStatusObject ;

	WmiAllocator &m_Allocator ;

	ProxyContainer m_ProxyContainer ;

	LONG m_Initialized ;
	HRESULT m_InitializeResult ;
	HANDLE m_InitializedEvent ;
	IWbemContext *m_InitializationContext ;

	DWORD m_ProcessIdentifier ;

	HRESULT Begin_Interface (

		IUnknown *a_ServerInterface ,
		REFIID a_InterfaceIdentifier ,
		DWORD a_ProxyIndex ,
		IUnknown *a_InternalServerInterface ,
		REFIID a_InternalInterfaceIdentifier ,
		DWORD a_InternalProxyIndex ,
		DWORD a_ProcessIdentifier ,
		HANDLE &a_IdentifyToken ,
		BOOL &a_Impersonating ,
		IUnknown *&a_OldContext ,
		IServerSecurity *&a_OldSecurity ,
		BOOL &a_IsProxy ,
		IUnknown *&a_Interface ,
		BOOL &a_Revert ,
		IUnknown *&a_Proxy ,
		IWbemContext *a_Context = NULL
	) ;

	HRESULT End_Interface (

		IUnknown *a_ServerInterface ,
		REFIID a_InterfaceIdentifier ,
		DWORD a_ProxyIndex ,
		IUnknown *a_InternalServerInterface ,
		REFIID a_InternalInterfaceIdentifier ,
		DWORD a_InternalProxyIndex ,
		DWORD a_ProcessIdentifier ,
		HANDLE a_IdentifyToken ,
		BOOL a_Impersonating ,
		IUnknown *a_OldContext ,
		IServerSecurity *a_OldSecurity ,
		BOOL a_IsProxy ,
		IUnknown *a_Interface ,
		BOOL a_Revert ,
		IUnknown *a_Proxy
	) ;

public:

	HRESULT SetInitialized ( HRESULT a_InitializeResult ) ;

public:

	CServerObject_ProviderRegistrationV1 *m_Registration ;
	BSTR m_Locale ;
	BSTR m_User ;
	BSTR m_Namespace ;
	BSTR m_TransactionIdentifier ;

	UINT64 m_ProviderOperation_GetObjectAsync ;
	UINT64 m_ProviderOperation_PutClassAsync ;
	UINT64 m_ProviderOperation_DeleteClassAsync ;
	UINT64 m_ProviderOperation_CreateClassEnumAsync ;
	UINT64 m_ProviderOperation_PutInstanceAsync ;
	UINT64 m_ProviderOperation_DeleteInstanceAsync ;
	UINT64 m_ProviderOperation_CreateInstanceEnumAsync ;
	UINT64 m_ProviderOperation_ExecQueryAsync ;
	UINT64 m_ProviderOperation_ExecNotificationQueryAsync ;
	UINT64 m_ProviderOperation_ExecMethodAsync ;

	UINT64 m_ProviderOperation_Begin ;
	UINT64 m_ProviderOperation_Rollback ;
	UINT64 m_ProviderOperation_Commit ;
	UINT64 m_ProviderOperation_QueryState ;

	UINT64 m_ProviderOperation_QueryInstances ;
	UINT64 m_ProviderOperation_CreateRefresher ;
	UINT64 m_ProviderOperation_CreateRefreshableObject ;
	UINT64 m_ProviderOperation_StopRefreshing ;
	UINT64 m_ProviderOperation_CreateRefreshableEnum ;
	UINT64 m_ProviderOperation_GetObjects ;

	UINT64 m_ProviderOperation_GetProperty ;
	UINT64 m_ProviderOperation_PutProperty ;

	UINT64 m_ProviderOperation_ProvideEvents ;
	UINT64 m_ProviderOperation_NewQuery ;
	UINT64 m_ProviderOperation_CancelQuery ;
	UINT64 m_ProviderOperation_AccessCheck ;
	UINT64 m_ProviderOperation_SetRegistrationObject ;
	UINT64 m_ProviderOperation_FindConsumer ;
	UINT64 m_ProviderOperation_ValidateSubscription ;

	void Increment_ProviderOperation_GetObjectAsync () { m_ProviderOperation_GetObjectAsync ++ ; }
 	void Increment_ProviderOperation_PutClassAsync () { m_ProviderOperation_PutClassAsync ++ ; }
	void Increment_ProviderOperation_DeleteClassAsync () { m_ProviderOperation_DeleteClassAsync ++ ; }
	void Increment_ProviderOperation_CreateClassEnumAsync () { m_ProviderOperation_CreateClassEnumAsync ++ ; }
	void Increment_ProviderOperation_PutInstanceAsync () { m_ProviderOperation_PutInstanceAsync ++ ; }
	void Increment_ProviderOperation_DeleteInstanceAsync () { m_ProviderOperation_DeleteInstanceAsync ++ ; }
	void Increment_ProviderOperation_CreateInstanceEnumAsync () { m_ProviderOperation_CreateInstanceEnumAsync ++ ; }
	void Increment_ProviderOperation_ExecQueryAsync () { m_ProviderOperation_ExecQueryAsync ++ ; }
	void Increment_ProviderOperation_ExecNotificationQueryAsync () { m_ProviderOperation_ExecNotificationQueryAsync ++ ; }
	void Increment_ProviderOperation_ExecMethodAsync () { m_ProviderOperation_ExecMethodAsync ++ ; }

	void Increment_ProviderOperation_Begin () { m_ProviderOperation_Begin ++ ; }
	void Increment_ProviderOperation_Rollback () { m_ProviderOperation_Rollback ++ ; }
	void Increment_ProviderOperation_Commit () { m_ProviderOperation_Commit ++ ; }
	void Increment_ProviderOperation_QueryState () { m_ProviderOperation_QueryState ++ ; }

	void Increment_ProviderOperation_QueryInstances () { m_ProviderOperation_QueryInstances ++ ; }
	void Increment_ProviderOperation_CreateRefresher () { m_ProviderOperation_CreateRefresher ++ ; }
	void Increment_ProviderOperation_CreateRefreshableObject () { m_ProviderOperation_CreateRefreshableObject ++ ; }
	void Increment_ProviderOperation_StopRefreshing () { m_ProviderOperation_StopRefreshing ++ ; }
	void Increment_ProviderOperation_CreateRefreshableEnum () { m_ProviderOperation_CreateRefreshableEnum ++ ; }
	void Increment_ProviderOperation_GetObjects () { m_ProviderOperation_GetObjects ++ ; }

	void Increment_ProviderOperation_GetProperty () { m_ProviderOperation_GetProperty ++ ; }
	void Increment_ProviderOperation_PutProperty () { m_ProviderOperation_PutProperty ++ ; }

	void Increment_ProviderOperation_ProvideEvents () { m_ProviderOperation_ProvideEvents ++ ; }
	void Increment_ProviderOperation_NewQuery () { m_ProviderOperation_NewQuery ++ ; }
	void Increment_ProviderOperation_CancelQuery () { m_ProviderOperation_CancelQuery ++ ; }
	void Increment_ProviderOperation_AccessCheck () { m_ProviderOperation_AccessCheck ++ ; }
	void Increment_ProviderOperation_SetRegistrationObject () { m_ProviderOperation_SetRegistrationObject ++ ; }
	void Increment_ProviderOperation_FindConsumer () { m_ProviderOperation_FindConsumer ++ ; }
	void Increment_ProviderOperation_ValidateSubscription () { m_ProviderOperation_ValidateSubscription ++ ; }

	UINT64 Get_ProviderOperation_GetObjectAsync () { return m_ProviderOperation_GetObjectAsync ; }
	UINT64 Get_ProviderOperation_PutClassAsync () { return m_ProviderOperation_PutClassAsync ; }
	UINT64 Get_ProviderOperation_DeleteClassAsync () { return m_ProviderOperation_DeleteClassAsync ; }
	UINT64 Get_ProviderOperation_CreateClassEnumAsync () { return m_ProviderOperation_CreateClassEnumAsync ; }
	UINT64 Get_ProviderOperation_PutInstanceAsync () { return m_ProviderOperation_PutInstanceAsync ; }
	UINT64 Get_ProviderOperation_DeleteInstanceAsync () { return m_ProviderOperation_DeleteInstanceAsync ; }
	UINT64 Get_ProviderOperation_CreateInstanceEnumAsync () { return m_ProviderOperation_CreateInstanceEnumAsync ; }
	UINT64 Get_ProviderOperation_ExecQueryAsync () { return m_ProviderOperation_ExecQueryAsync ; }
	UINT64 Get_ProviderOperation_ExecNotificationQueryAsync () { return m_ProviderOperation_ExecNotificationQueryAsync ; }
	UINT64 Get_ProviderOperation_ExecMethodAsync () { return m_ProviderOperation_ExecMethodAsync ; }

	UINT64 Get_ProviderOperation_Begin () { return m_ProviderOperation_Begin ; }
	UINT64 Get_ProviderOperation_Rollback () { return m_ProviderOperation_Rollback ; }
	UINT64 Get_ProviderOperation_Commit () { return m_ProviderOperation_Commit ; }
	UINT64 Get_ProviderOperation_QueryState () { return m_ProviderOperation_QueryState ; }

	UINT64 Get_ProviderOperation_QueryInstances () { return m_ProviderOperation_QueryInstances ; }
	UINT64 Get_ProviderOperation_CreateRefresher () { return m_ProviderOperation_CreateRefresher ; }
	UINT64 Get_ProviderOperation_CreateRefreshableObject () { return m_ProviderOperation_CreateRefreshableObject ; }
	UINT64 Get_ProviderOperation_StopRefreshing () { return m_ProviderOperation_StopRefreshing ; }
	UINT64 Get_ProviderOperation_CreateRefreshableEnum () { return m_ProviderOperation_CreateRefreshableEnum ; }
	UINT64 Get_ProviderOperation_GetObjects () { return m_ProviderOperation_GetObjects ; }

	UINT64 Get_ProviderOperation_GetProperty () { return m_ProviderOperation_GetProperty ; }
	UINT64 Get_ProviderOperation_PutProperty () { return m_ProviderOperation_PutProperty ; }

	UINT64 Get_ProviderOperation_ProvideEvents () { return m_ProviderOperation_ProvideEvents ; }
	UINT64 Get_ProviderOperation_NewQuery () { return m_ProviderOperation_NewQuery ; }
	UINT64 Get_ProviderOperation_CancelQuery () { return m_ProviderOperation_CancelQuery ; }
	UINT64 Get_ProviderOperation_AccessCheck () { return m_ProviderOperation_AccessCheck ; }
	UINT64 Get_ProviderOperation_SetRegistrationObject () { return m_ProviderOperation_SetRegistrationObject ; }
	UINT64 Get_ProviderOperation_FindConsumer () { return m_ProviderOperation_FindConsumer ; }
	UINT64 Get_ProviderOperation_ValidateSubscription () { return m_ProviderOperation_ValidateSubscription ; }

public:

	CInterceptor_IWbemDecoupledProvider ( 

		WmiAllocator &a_Allocator ,
		IUnknown *a_ServerSideUnknown , 
		IWbemServices *a_CoreStub ,
		CWbemGlobal_IWbemSyncProviderController *a_Controller ,
		IWbemContext *a_InitializationContext ,
		CServerObject_ProviderRegistrationV1 &a_Registration ,
		GUID &a_Guid 
	) ;

    ~CInterceptor_IWbemDecoupledProvider () ;

public:

	//Non-delegating object IUnknown

    STDMETHODIMP QueryInterface ( REFIID , LPVOID FAR * ) ;
    STDMETHODIMP_( ULONG ) AddRef () ;
    STDMETHODIMP_( ULONG ) Release () ;

    /* IWbemServices methods */

    HRESULT STDMETHODCALLTYPE OpenNamespace ( 

        const BSTR a_Namespace ,
        long a_Flags ,
        IWbemContext *a_Context ,
        IWbemServices **a_Service ,
        IWbemCallResult **a_CallResult
	) ;
    
    HRESULT STDMETHODCALLTYPE CancelAsyncCall ( 

        IWbemObjectSink *a_Sink
	) ;
    
    HRESULT STDMETHODCALLTYPE QueryObjectSink ( 

        long a_Flags ,
        IWbemObjectSink **a_Sink
	) ;
    
    HRESULT STDMETHODCALLTYPE GetObject ( 

		const BSTR a_ObjectPath ,
        long a_Flags ,
        IWbemContext *a_Context ,
        IWbemClassObject **ppObject ,
        IWbemCallResult **a_CallResult
	) ;
    
    HRESULT STDMETHODCALLTYPE GetObjectAsync (
        
		const BSTR a_ObjectPath ,
        long a_Flags ,
        IWbemContext *a_Context ,
        IWbemObjectSink *a_Sink
	) ;

    HRESULT STDMETHODCALLTYPE PutClass ( 

        IWbemClassObject *a_Object ,
        long a_Flags ,
        IWbemContext *a_Context ,
        IWbemCallResult **a_CallResult
	) ;
    
    HRESULT STDMETHODCALLTYPE PutClassAsync ( 

        IWbemClassObject *a_Object ,
        long a_Flags ,
        IWbemContext *a_Context ,
        IWbemObjectSink *a_Sink
	) ;
    
    HRESULT STDMETHODCALLTYPE DeleteClass ( 

        const BSTR a_Class ,
        long a_Flags ,
        IWbemContext *a_Context ,
        IWbemCallResult **a_CallResult
	) ;
    
    HRESULT STDMETHODCALLTYPE DeleteClassAsync ( 

        const BSTR a_Class ,
        long a_Flags ,
        IWbemContext *a_Context ,
        IWbemObjectSink *a_Sink
	) ;
    
    HRESULT STDMETHODCALLTYPE CreateClassEnum ( 

        const BSTR a_Superclass ,
        long a_Flags ,
        IWbemContext *a_Context ,
        IEnumWbemClassObject **a_Enum
	) ;
    
    HRESULT STDMETHODCALLTYPE CreateClassEnumAsync ( 

		const BSTR a_Superclass ,
		long a_Flags ,
		IWbemContext *a_Context ,
		IWbemObjectSink *a_Sink
	) ;
    
    HRESULT STDMETHODCALLTYPE PutInstance (

		IWbemClassObject *a_Instance ,
		long a_Flags , 
		IWbemContext *a_Context ,
		IWbemCallResult **a_CallResult
	) ;
    
    HRESULT STDMETHODCALLTYPE PutInstanceAsync (

		IWbemClassObject *a_Instance ,
		long a_Flags ,
		IWbemContext *a_Context ,
		IWbemObjectSink *a_Sink 
	) ;
    
    HRESULT STDMETHODCALLTYPE DeleteInstance ( 

		const BSTR a_ObjectPath ,
		long a_Flags ,
		IWbemContext *a_Context ,
		IWbemCallResult **a_CallResult
	) ;
    
    HRESULT STDMETHODCALLTYPE DeleteInstanceAsync ( 

		const BSTR a_ObjectPath,
		long a_Flags,
		IWbemContext *a_Context ,
		IWbemObjectSink *a_Sink
	) ;
    
    HRESULT STDMETHODCALLTYPE CreateInstanceEnum (

		const BSTR a_Class ,
		long a_Flags ,
		IWbemContext *a_Context ,
		IEnumWbemClassObject **a_Enum
	) ;
    
    HRESULT STDMETHODCALLTYPE CreateInstanceEnumAsync (

		const BSTR a_Class ,
		long a_Flags ,
		IWbemContext *a_Context ,
		IWbemObjectSink *a_Sink
	) ;
    
    HRESULT STDMETHODCALLTYPE ExecQuery ( 

		const BSTR a_QueryLanguage,
		const BSTR a_Query,
		long a_Flags ,
		IWbemContext *a_Context ,
		IEnumWbemClassObject **a_Enum
	) ;
    
    HRESULT STDMETHODCALLTYPE ExecQueryAsync (

		const BSTR a_QueryLanguage ,
		const BSTR a_Query ,
		long a_Flags ,
		IWbemContext *a_Context ,
		IWbemObjectSink *a_Sink
	) ;
    
    HRESULT STDMETHODCALLTYPE ExecNotificationQuery (

		const BSTR a_QueryLanguage ,
		const BSTR a_Query ,
		long a_Flags ,
		IWbemContext *a_Context ,
		IEnumWbemClassObject **a_Enum
	) ;
    
    HRESULT STDMETHODCALLTYPE ExecNotificationQueryAsync ( 

        const BSTR a_QueryLanguage ,
        const BSTR a_Query ,
        long a_Flags ,
        IWbemContext *a_Context ,
        IWbemObjectSink *a_Sink
	) ;
    
    HRESULT STDMETHODCALLTYPE ExecMethod (

        const BSTR a_ObjectPath ,
        const BSTR a_MethodName ,
        long a_Flags ,
        IWbemContext *a_Context ,
        IWbemClassObject *a_InParams ,
        IWbemClassObject **a_OutParams ,
        IWbemCallResult **a_CallResult
	) ;
    
    HRESULT STDMETHODCALLTYPE ExecMethodAsync ( 

		const BSTR a_ObjectPath ,
		const BSTR a_MethodName ,
		long a_Flags ,
		IWbemContext *a_Context ,
		IWbemClassObject *a_InParams ,
		IWbemObjectSink *a_Sink
	) ;

	/* IWbemPropertyProvider */

    HRESULT STDMETHODCALLTYPE GetProperty (

        long a_Flags ,
        const BSTR a_Locale ,
        const BSTR a_ClassMapping ,
        const BSTR a_InstanceMapping ,
        const BSTR a_PropertyMapping ,
        VARIANT *a_Value
	) ;
        
    HRESULT STDMETHODCALLTYPE PutProperty (

        long a_Flags ,
        const BSTR a_Locale ,
        const BSTR a_ClassMapping ,
        const BSTR a_InstanceMapping ,
        const BSTR a_PropertyMapping ,
        const VARIANT *a_Value
	) ;

	/* IWbemEventProvider */

	HRESULT STDMETHODCALLTYPE ProvideEvents (

		IWbemObjectSink *a_Sink ,
		long a_Flags
	) ;

	/* IWbemEventProviderQuerySink */

	HRESULT STDMETHODCALLTYPE NewQuery (

		unsigned long a_Id ,
		WBEM_WSTR a_QueryLanguage ,
		WBEM_WSTR a_Query
	);

	HRESULT STDMETHODCALLTYPE CancelQuery (

		unsigned long a_Id
	) ;

	/* IWbemEventProviderSecurity */

	HRESULT STDMETHODCALLTYPE AccessCheck (

		WBEM_CWSTR a_QueryLanguage ,
		WBEM_CWSTR a_Query ,
		long a_SidLength ,
		const BYTE *a_Sid
	) ;

	/* IWbemProviderIdentity */

	HRESULT STDMETHODCALLTYPE SetRegistrationObject (

		long a_Flags ,
		IWbemClassObject *a_ProviderRegistration
	) ;

	/* IWbemEventConsumerProvider */

	HRESULT STDMETHODCALLTYPE FindConsumer (

		IWbemClassObject *a_LogicalConsumer ,
		IWbemUnboundObjectSink **a_Consumer
	);

	/* IWbemEventConsumerProviderEx */

	HRESULT STDMETHODCALLTYPE ValidateSubscription (

		IWbemClassObject *a_LogicalConsumer
	) ;

	/* IWbemUnboundObjectSink */

	HRESULT STDMETHODCALLTYPE IndicateToConsumer (

		IWbemClassObject *a_LogicalConsumer ,
		long a_ObjectCount ,
		IWbemClassObject **a_Objects
	) ;

	/* IWbemProviderInit methods */

	HRESULT STDMETHODCALLTYPE Initialize (

		LPWSTR a_User ,
		LONG a_Flags ,
		LPWSTR a_Namespace ,
		LPWSTR a_Locale ,
		IWbemServices *a_CoreService ,
		IWbemContext *a_Context ,
		IWbemProviderInitSink *a_Sink
	) ;
    
	HRESULT STDMETHODCALLTYPE Initialize (

		LONG a_Flags ,
		IWbemContext *a_Context ,
		GUID *a_TransactionIdentifier,
		LPCWSTR a_User ,
		LPCWSTR a_Locale ,
		LPCWSTR a_Namespace ,
		IWbemServices *a_Repository ,
		IWbemServices *a_Service ,
		IWbemProviderInitSink *a_Sink
	) ;

	HRESULT STDMETHODCALLTYPE WaitProvider ( IWbemContext *a_Context , ULONG a_Timeout ) ;

	HRESULT STDMETHODCALLTYPE GetInitializeResult () 
	{
		return m_InitializeResult ;
	}

	HRESULT STDMETHODCALLTYPE GetHosting ( ULONG *a_Value )
	{
		return WBEM_E_NOT_AVAILABLE ;
	}

	HRESULT STDMETHODCALLTYPE GetHostingGroup ( BSTR *a_Value )
	{
		return WBEM_E_NOT_AVAILABLE ;
	}

	HRESULT STDMETHODCALLTYPE IsInternal ( BOOL *a_Value )
	{
		return WBEM_E_NOT_AVAILABLE ;
	}

	HRESULT STDMETHODCALLTYPE IsPerUserInitialization ( BOOL *a_Value )
	{
		return WBEM_E_NOT_AVAILABLE ;
	}

	HRESULT STDMETHODCALLTYPE IsPerLocaleInitialization ( BOOL *a_Value )
	{
		return WBEM_E_NOT_AVAILABLE ;
	}

	HRESULT STDMETHODCALLTYPE AbnormalShutdown () ;

	// IWmi_UnInitialize members

	HRESULT STDMETHODCALLTYPE Shutdown (

		LONG a_Flags ,
		ULONG a_MaxMilliSeconds ,
		IWbemContext *a_Context
	) ; 
} ;
#endif // _Server_Interceptor_IWbemServices_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\provsubsys\decoupledadaptor\include\resource.h ===
/*++

Copyright (C) 1996-2001 Microsoft Corporation

Module Name:

	Resource.h

Abstract:


History:

--*/

//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by propprov.rc
//

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NO_MFC                     1
#define _APS_NEXT_RESOURCE_VALUE        101
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1000
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\provsubsys\decoupledclient\makefile.inc ===
!include $(_NTDRIVE)$(_NTROOT)\ADMIN\WMI\WBEM\COMMON\makefile.cmn
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\provsubsys\decoupledadaptor\include\pssutils.h ===
namespace provsubsys{

template<class T>
class RefCountingTraits{
	public:
	void add_ref(T * ptr){ ptr->AddRef();};
	void release(T * ptr){ ptr->Release();};
};


template<class T, class ref_traits = RefCountingTraits<T> >
class auto_ref: private ref_traits {
	T* pointee_;

	public:
		auto_ref():pointee_(NULL) 
		{ };

		explicit auto_ref(T * _P):pointee_(_P) 
		{ 
			add_ref();
		};

		explicit auto_ref(const int):pointee_(NULL)
		{ } ;

		auto_ref(const auto_ref& _S):pointee_(_S.pointee_)
		{
			add_ref();
		};

		~auto_ref()
		{ 
			release();
		};

		bool operator==(const auto_ref& _R)
		{
			return pointee_ ==  _R.pointee_;
		};

		const auto_ref& operator=( const auto_ref& _R)
		{
			if(pointee_ ==  _R.pointee_)
				return *this;
			release();
			pointee_ =  _R.pointee_;
			add_ref();
			return *this;
		};
	

		T& operator*( ) const 
		{	
			return *pointee_;

		};

		T* operator->( ) const 
		{
			return pointee_;
		};

		operator bool( ) const throw( )
		{ 
			return pointee_ != NULL; 
		};

		void Dettach()
		{
			release();
			pointee_ = NULL;
		};

protected:
	void add_ref()
	{ 
		if( pointee_ != NULL )
			ref_traits::add_ref(pointee_);
	};

	void release()
	{ 
		if( pointee_ != NULL )
			ref_traits::release(pointee_);
	};
};
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\provsubsys\decoupledclient\classfac.cpp ===
#ifndef __CLASSFACTORY_CPP
#define __CLASSFACTORY_CPP

/*++

Copyright (C) 1996-2001 Microsoft Corporation

Module Name:

	ClassFac.cpp

Abstract:


History:

--*/

#include "PreComp.h"
#include <wbemint.h>

#include "Globals.h"
#include "classfac.h"

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

template <class Object,class ObjectInterface>
CServerClassFactory <Object,ObjectInterface> :: CServerClassFactory <Object,ObjectInterface> () : m_ReferenceCount ( 0 )
{
	InterlockedIncrement ( & DecoupledProviderSubSystem_Globals :: s_CServerClassFactory_ObjectsInProgress ) ;
	InterlockedIncrement ( & DecoupledProviderSubSystem_Globals :: s_ObjectsInProgress ) ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

template <class Object,class ObjectInterface>
CServerClassFactory <Object,ObjectInterface> :: ~CServerClassFactory <Object,ObjectInterface> ()
{
	InterlockedDecrement ( & DecoupledProviderSubSystem_Globals :: s_CServerClassFactory_ObjectsInProgress ) ;
	InterlockedDecrement ( & DecoupledProviderSubSystem_Globals :: s_ObjectsInProgress ) ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

template <class Object,class ObjectInterface>
STDMETHODIMP CServerClassFactory <Object,ObjectInterface> :: QueryInterface (

	REFIID a_Riid , 
	LPVOID FAR *a_Void 
) 
{
	*a_Void = NULL ;

	if ( a_Riid == IID_IUnknown )
	{
		*a_Void = ( LPVOID ) this ;
	}
	else if ( a_Riid == IID_IClassFactory )
	{
		*a_Void = ( LPVOID ) ( IClassFactory * ) this ;		
	}	

	if ( *a_Void )
	{
		( ( LPUNKNOWN ) *a_Void )->AddRef () ;

		return ResultFromScode ( S_OK ) ;
	}
	else
	{
		return ResultFromScode ( E_NOINTERFACE ) ;
	}
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

template <class Object,class ObjectInterface>
STDMETHODIMP_( ULONG ) CServerClassFactory <Object,ObjectInterface> :: AddRef ()
{
	ULONG t_ReferenceCount = InterlockedIncrement ( & m_ReferenceCount ) ;
	return t_ReferenceCount ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

template <class Object,class ObjectInterface>
STDMETHODIMP_(ULONG) CServerClassFactory <Object,ObjectInterface> :: Release ()
{
	ULONG t_ReferenceCount = InterlockedDecrement ( & m_ReferenceCount ) ;
	if ( t_ReferenceCount == 0 )
	{
		delete this ;
		return 0 ;
	}
	else
	{
		return t_ReferenceCount ;
	}
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

template <class Object,class ObjectInterface>
STDMETHODIMP CServerClassFactory <Object,ObjectInterface> :: CreateInstance (

	LPUNKNOWN a_UnknownOuter ,
	REFIID a_Riid ,
	LPVOID *a_Object
)
{
	HRESULT t_Result = S_OK ;

	if ( a_UnknownOuter )
	{
		t_Result = CLASS_E_NOAGGREGATION ;
	}
	else
	{
		ObjectInterface *t_Unknown = ( ObjectInterface * ) new Object ( *DecoupledProviderSubSystem_Globals :: s_Allocator );
		if ( t_Unknown == NULL )
		{
			t_Result = E_OUTOFMEMORY ;
		}
		else
		{
			t_Result = t_Unknown->Initialize () ;
			if ( SUCCEEDED ( t_Result ) )
			{
				t_Result = t_Unknown->QueryInterface ( a_Riid , a_Object ) ;
				if ( FAILED ( t_Result ) )
				{
					delete t_Unknown ;
				}
			}
			else
			{
				delete t_Unknown ;
			}
		}			
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

template <class Object,class ObjectInterface>
STDMETHODIMP CServerClassFactory <Object,ObjectInterface> :: LockServer ( BOOL fLock )
{
/* 
 * Place code in critical section
 */

	if ( fLock )
	{
		InterlockedIncrement ( & DecoupledProviderSubSystem_Globals :: s_LocksInProgress ) ;
	}
	else
	{
		InterlockedDecrement ( & DecoupledProviderSubSystem_Globals :: s_LocksInProgress ) ;
	}

	return S_OK	;
}

#endif __CLASSFACTORY_CPP
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\provsubsys\decoupledadaptor\include\wqlnode.h ===
/*++

Copyright (C) 1997-2001 Microsoft Corporation

Module Name:

    WQLNODE.H

Abstract:

	WMI SQL Parse Node Definitions

History:

	raymcc      29-Sep-97       Created

--*/

#ifndef _WQLNODE_H_
#define _WQLNODE_H_


#define  WQL_FLAG_ALIAS          0x1
#define  WQL_FLAG_TABLE          0x2
#define  WQL_FLAG_ASTERISK       0x4
#define  WQL_FLAG_DISTINCT       0x8
#define  WQL_FLAG_ALL            0x10
#define  WQL_FLAG_COUNT          0x20
#define  WQL_FLAG_CONST          0x40
#define  WQL_FLAG_COLUMN         0x80
#define  WQL_FLAG_COMPLEX_NAME   0x100
#define  WQL_FLAG_FUNCTIONIZED   0x200
#define  WQL_FLAG_ARRAY_REF      0x400
#define  WQL_FLAG_UPPER          0x800
#define  WQL_FLAG_LOWER          0x1000
#define  WQL_FLAG_FIRSTROW       0x2000
#define  WQL_FLAG_CONST_RANGE    0x4000
#define  WQL_FLAG_SORT_ASC       0x8000
#define  WQL_FLAG_SORT_DESC      0x10000
#define  WQL_FLAG_AGGREGATE      0x20000
#define  WQL_FLAG_NULL           0x40000

#define WQL_FLAG_INNER_JOIN         1
#define WQL_FLAG_LEFT_OUTER_JOIN    2
#define WQL_FLAG_RIGHT_OUTER_JOIN   3
#define WQL_FLAG_FULL_OUTER_JOIN    4

#define WQL_TOK_BASE            100

#include <wmiutils.h>


class CWbemAssocQueryInf : public SWbemAssocQueryInf
{
public:
    CWbemAssocQueryInf();
   ~CWbemAssocQueryInf();
    void Empty();
    void Init();
    HRESULT CopyFrom(SWbemAssocQueryInf *pSrc);
};


//***************************************************************************
//
//  SWQLNode
//
//  Base node type for all parser output.
//
//***************************************************************************

struct SWQLNode
{
    DWORD        m_dwNodeType;
    SWQLNode    *m_pLeft;
    SWQLNode    *m_pRight;

    SWQLNode() { m_pLeft = 0; m_pRight = 0; m_dwNodeType = 0; }
    virtual ~SWQLNode() { if (m_pLeft) delete m_pLeft; if (m_pRight) delete m_pRight; }
    virtual void DebugDump() = 0;
};


//***************************************************************************
//
//   SWQLNode_QueryRoot
//
//   This is the root of the parse tree.  The child nodes are for one of
//  SELECT, INSERT, UPDATE, DELETE.
//
//                SWQLQueryRoot
//               /               \
//      SWQLNode_Select         NULL
//   or SWQLNode_Insert
//   or SWQLNode_Delete
//   or SWQLNode_Update
//   or SWQLNode_AssocQuery
//
//***************************************************************************
#define TYPE_SWQLNode_QueryRoot       (WQL_TOK_BASE + 1)

struct SWQLNode_QueryRoot : SWQLNode
{
    enum { eInvalid = 0, eSelect, eInsert, eDelete, eUpdate, eAssoc };
    DWORD m_dwQueryType;

    SWQLNode_QueryRoot() { m_dwNodeType = TYPE_SWQLNode_QueryRoot; m_dwQueryType = 0; }
   ~SWQLNode_QueryRoot() {}
    void DebugDump();
};


//***************************************************************************
//
//  SWQLTypedConst
//
//  Typed constant container (similar to OA VARIANT).
//
//***************************************************************************

union UWQLTypedConst
{
    LPWSTR m_pString;       // VT_LPWSTR for WQL_TOK_QSTRING and WQL_TOK_PROMPT
    LONG   m_lValue;        // VT_LONG
    double m_dblValue;      // VT_DOUBLE
    BOOL   m_bValue;        // VT_BOOL, use TRUE/FALSE (not VARIANT_TRUE, VARIANT_FALSE)
};

struct SWQLTypedConst
{
    DWORD m_dwType;             // A VT_ type
    UWQLTypedConst m_Value;     // One of the union fields
    bool m_bPrompt;             // Only true if token was WQL_TOK_PROMPT

    SWQLTypedConst();
    SWQLTypedConst(SWQLTypedConst &Src) { m_dwType = VT_NULL; *this = Src; }
    SWQLTypedConst & operator = (SWQLTypedConst &Src);
   ~SWQLTypedConst() { Empty(); }
    void Empty();
    void DebugDump();
};

struct SWQLConstList
{
    CFlexArray m_aValues;       // ptrs to SWQLTypedConst

    SWQLConstList() {}
    SWQLConstList(SWQLConstList &Src) { *this = Src; }
    SWQLConstList & operator = (SWQLConstList & Src);
   ~SWQLConstList() { Empty(); }
    int Add(SWQLTypedConst *pTC) { return m_aValues.Add(pTC); }
    void Empty();
};



struct SWQLQualifiedNameField
{
    LPWSTR  m_pName;         // Name
    BOOL    m_bArrayRef;     // TRUE if this is an array reference
    DWORD   m_dwArrayIndex;  // If <m_bArrayRef == TRUE> this is the array index

    SWQLQualifiedNameField() { m_pName = 0; m_bArrayRef = 0; m_dwArrayIndex = 0; }
    SWQLQualifiedNameField(SWQLQualifiedNameField &Src) { m_pName = 0; *this = Src; }
    SWQLQualifiedNameField & operator = (SWQLQualifiedNameField &Src);
   ~SWQLQualifiedNameField() { Empty(); }
    void Empty() { delete [] m_pName; }
};

struct SWQLQualifiedName
{
    CFlexArray m_aFields;       // [0] =  left most, last entry is column

    SWQLQualifiedName() {}
    SWQLQualifiedName(SWQLQualifiedName &Src) { *this = Src; }
    SWQLQualifiedName & operator = (SWQLQualifiedName &Src);
   ~SWQLQualifiedName() { Empty(); }

    int GetNumNames() { return m_aFields.Size(); }

    const LPWSTR GetName(int nIndex)
    {
        return (LPWSTR) ((SWQLQualifiedNameField*) m_aFields[nIndex])->m_pName;
    }

    int Add(SWQLQualifiedNameField *pQN) { return m_aFields.Add(pQN); }
    void Empty();
};




//***************************************************************************
//
//   SWQLNode_Select
//
//   This is the root of the parse tree or the root of a subselect.
//
//                SWQLNode_Select
//               /               \
//      SWQLNode_TableRefs     SWQLNode_WhereClause
//     /                \      /                   \
//    x                  x    x                     x
//
//***************************************************************************

#define TYPE_SWQLNode_Select        (WQL_TOK_BASE + 2)

struct SWQLNode_Select : SWQLNode
{
    // Left  Node is of type SWQLNode_TableRefs
    // Right Node is of type SWQLNode_WhereClause

    int m_nStPos;
    int m_nEndPos;

    SWQLNode_Select() : m_nStPos(-1), m_nEndPos(-1) { m_dwNodeType = TYPE_SWQLNode_Select; }
    void DebugDump();
};


//***************************************************************************
//
//   SWQLNode_TableRefs
//
//  This contains everything prior to the WHERE clause: the target
//  column list and the FROM clause.
//
//  Also contains the SELECT type, i.e., ALL vs. DISTINCT vs. COUNT.
//
//                SWQLNode_TableRefs
//               /               \
//      SWQLNode_ColumnList     SWQLNode_FromClause
//
//  In all cases, SWQLNode_ColumnList is present.  Note that if the
//  user did a "select *...", then the SWQLNode_ColumnList will only
//  have a single column in it clearly marked as an asterisk.  If
//  a "select count(...) " was done, then m_nSelectType is set to
//  WQL_FLAG_COUNT and the SWQLNode_ColumnList will have a single
//  column in it, whether an * or a qualified name.
//
//***************************************************************************

#define TYPE_SWQLNode_TableRefs      (WQL_TOK_BASE + 3)

struct SWQLNode_TableRefs : SWQLNode
{
    // Left  Node is SWQLNode_ColumnList
    // Right Node is SWQLNode_FromClause

    int m_nSelectType;       // WQL_FLAG_ALL means ALL was used.
                             // WQL_FLAG_DISTINCT means DISTINCT was used.
                             // WQL_FLAG_COUNT means COUNT was used.

    SWQLNode_TableRefs()
        { m_nSelectType = WQL_FLAG_ALL;
          m_dwNodeType = TYPE_SWQLNode_TableRefs;
        }

   ~SWQLNode_TableRefs() {}
    void DebugDump();
};


//***************************************************************************
//
//   SWQLNode_ColumnList
//
//  This contains the selected list of columns.
//
//                SWQLNode_ColumnList
//               /                 \
//              NULL               NULL
//
//***************************************************************************

#define TYPE_SWQLNode_ColumnList   (WQL_TOK_BASE + 4)

struct SWQLNode_ColumnList : SWQLNode
{
    // Left  Node is NULL
    // Right Node is NULL

    CFlexArray m_aColumnRefs ;   // Pointers to SWQLColRef entries.

    SWQLNode_ColumnList() { m_dwNodeType = TYPE_SWQLNode_ColumnList; }
   ~SWQLNode_ColumnList() { Empty(); }
    void Empty();
    void DebugDump();
};


struct SWQLColRef
{
    LPWSTR m_pColName;      // The column name or "*" or NULL
    LPWSTR m_pTableRef;     // The table/alias name or NULL if there is none
    DWORD  m_dwArrayIndex;
    DWORD  m_dwFlags;       // WQL_FLAG_TABLE bit set if m_pTableRef
                            //   is a table name
                            // WQL_FLAG_ALIAS bit set if m_pTableRef
                            //   is a table alias
                            // WQL_FLAG_ASTERISK bit set if m_pColName is
                            //   * (this is faster than to check than a
                            //   string compare on <m_pColName> for "*".
                            // WQL_FLAG_NULL if the column name was "NULL"
                            // WQL_FLAG_FUNCTIONIZED is set if the column
                            //    is wrapped in a function call.
                            //    The function bits WQL_FLAG_UPPER or
                            //    WQL_FLAG_LOWER will be set.
                            // WQL_FLAG_ARRAY_REF is set if the column
                            //    is an array column, in which case
                            //    m_dwArrayIndex is set to the array offset.
                            // WQL_FLAG_COMPLEX_NAME is set if the name
                            //  is qualified in a deeply nested way,
                            //  which requires examination of the <QName>
                            //  object.  In this case <m_pColName> is
                            //  set to the last name, but m_pTableRef
                            //  is left blank.
                            // WQL_FLAG_SORT_ASC to sort ascending (Order by only)
                            // WQL_FLAG_SORT_DESC to sort descending (Order by only)

    SWQLQualifiedName *m_pQName;    // The full qualified name

    SWQLColRef() { m_pColName = NULL; m_pTableRef = 0;
        m_dwFlags = 0; m_dwArrayIndex = 0; m_pQName = 0;
        }

   ~SWQLColRef() { delete [] m_pColName; delete [] m_pTableRef; delete m_pQName; }
    void DebugDump();
};



//***************************************************************************
//
//   SWQLNode_FromClause
//
//   The subtree containing the tables selected from and any joins.
//
//                SWQLNode_FromClause
//               /                   \
//             SWQLNode_TableRef      SWQLNode_WmiScopedSelect
//          or SWQLNode_Join
//          or SWQLNode_Sql89Join
//
//  Note that left and right nodes are mutually exclusive.  Either
//  the left side is used for traditional SQL or the right side is
//  used for the WMI scoped select.
//
//***************************************************************************

#define TYPE_SWQLNode_FromClause  (WQL_TOK_BASE + 5)

struct SWQLNode_FromClause : SWQLNode
{
    // Left is SWQLNode_TableRef or SWQLNode_Join
    // Right is NULL

    SWQLNode_FromClause() { m_dwNodeType = TYPE_SWQLNode_FromClause; }
   ~SWQLNode_FromClause() {}
    void DebugDump();
};


//***************************************************************************
//
//   SWQLNode_WmiScopedSelect
//
//                SWQLNode_WmiScopedSelect
//               /                   \
//             NULL                  NULL
//
//
//   Contains a special-case selection for WMI v2.  The syntax is
//
//      FROM '['<object path>']' <class-list>
//
//   ...where <class-list> is either a single class or a curly-bracket-delimited
//   list of classes, separated by commas:
//
//          FROM [scope.p1=2] MyClass
//          FROM [scope.p1=2] {MyClass}
//          FROM [scope.p1=2] {MyClass, MyClass2}
//
//
//***************************************************************************


#define TYPE_SWQLNode_WmiScopedSelect (WQL_TOK_BASE + 6)

struct SWQLNode_WmiScopedSelect : SWQLNode
{
    LPWSTR m_pszScope;
    CFlexArray m_aTables;

    SWQLNode_WmiScopedSelect()
        { m_dwNodeType = TYPE_SWQLNode_FromClause;
          m_pszScope = 0;
        }

   ~SWQLNode_WmiScopedSelect()
        {
            for (int i = 0; i < m_aTables.Size(); i++)
                delete LPWSTR(m_aTables[i]);
            delete m_pszScope;
        }

    void DebugDump();
};


//***************************************************************************
//
//  SWQLNode_Sql89Join
//
//  A subtree which expresses a SQL-89 join.
//
//                SWQLNode_Sql89Join
//               /             \
//             NULL             NULL
//
//***************************************************************************

#define TYPE_SWQLNode_Sql89Join     (WQL_TOK_BASE + 7)

struct SWQLNode_Sql89Join : SWQLNode
{
    CFlexArray m_aValues;           // Array of pointers to SWQLNode_TableRef
                                    // objects

    SWQLNode_Sql89Join() { m_dwNodeType = TYPE_SWQLNode_Sql89Join; }
    ~SWQLNode_Sql89Join() {Empty();};
    void DebugDump();
    void Empty();
};



//***************************************************************************
//
//  SWQLNode_Join
//
//  A subtree which expresses a join.
//
//                SWQLNode_Join
//               /              \
//       SWQLNode_JoinPair       SWQLNode_OnClause or NULL.
//
//***************************************************************************

#define TYPE_SWQLNode_Join  (WQL_TOK_BASE + 8)

struct SWQLNode_Join : SWQLNode
{
    // Left ptr is SWQLNode_JoinPair
    // Right ptr is ON clause.  If NULL, there is no ON clause
    // and the JOIN was a SQL-89 style join with the join condition
    // present in the WHERE clause.

    DWORD m_dwJoinType;
            // One of WQL_FLAG_INNER_JOIN, WQL_FLAG_LEFT_OUTER_JOIN,
            // WQL_FLAG_RIGHT_OUTER_JOIN or WQL_FLAG_FULL_OUTER_JOIN
    DWORD m_dwFlags;
        // Contains WQL_FLAG_FIRSTROW if used

    SWQLNode_Join() { m_dwNodeType = TYPE_SWQLNode_Join; m_dwJoinType = m_dwFlags = 0; }
   ~SWQLNode_Join() {}
    void DebugDump();
};


//***************************************************************************
//
//  SWQLNode_JoinPair
//
//                SWQLNode_JoinPair
//               /                 \
//        <SWQLNode_Join or SWQLNode_TableRef>
//
//***************************************************************************
#define TYPE_SWQLNode_JoinPair   (WQL_TOK_BASE + 9)

struct SWQLNode_JoinPair : SWQLNode
{
    // Left ptr is SWQLNode_Join or SWQLNode_TableRef
    // Right ptr is SWQLNodeNode_Join or SWQL_NodeTableRef

    SWQLNode_JoinPair() { m_dwNodeType = TYPE_SWQLNode_JoinPair; }
   ~SWQLNode_JoinPair() {}

    void DebugDump();
};



//***************************************************************************
//
//  SWQLNode_TableRef
//
//  A node representing a table name and its alias, if any.
//
//                SWQLNode_TableRef
//               /                 \
//             NULL               NULL
//
//***************************************************************************

#define TYPE_SWQLNode_TableRef  (WQL_TOK_BASE + 10)

struct SWQLNode_TableRef : SWQLNode
{
    LPWSTR m_pTableName;        // The table
    LPWSTR m_pAlias;            // Table alias. NULL if not used.

    SWQLNode_TableRef() { m_pTableName = 0; m_pAlias = 0; m_dwNodeType = TYPE_SWQLNode_TableRef; }
    ~SWQLNode_TableRef() { delete [] m_pTableName; delete [] m_pAlias; }
    void DebugDump();
};

//***************************************************************************
//
//  SWQLNode_OnClause
//
//                SWQLNode_OnClause
//               /                 \
//        <SWQLNode_RelExpr>        NULL
//
//***************************************************************************
#define TYPE_SWQLNode_OnClause   (WQL_TOK_BASE + 11)

struct SWQLNode_OnClause : SWQLNode
{
    // Left ptr is <SWQLNode_RelExpr> which contains the ON clause.
    // Right ptr is always NULL.

    SWQLNode_OnClause() { m_dwNodeType = TYPE_SWQLNode_OnClause; }
   ~SWQLNode_OnClause() {}
    void DebugDump();
};



//***************************************************************************
//
//  SWQLNode_WhereClause
//
//                SWQLNode_WhereClause
//               /                 \
//        SWQLNode_RelExpr         SWQLNode_WhereOptions or NULL
//        or
//        NULL if no conditions
//
//***************************************************************************

#define TYPE_SWQLNode_WhereClause  (WQL_TOK_BASE + 12)

struct SWQLNode_WhereClause : SWQLNode
{
    // Left ptr is SWQLNode_RelExpr.
    // Right ptr is SQLNode_QueryOptions or NULL if none

    SWQLNode_WhereClause() { m_dwNodeType = TYPE_SWQLNode_WhereClause; }
   ~SWQLNode_WhereClause() {}

    void DebugDump();
};

//***************************************************************************
//
//  struct SWQLTypedExpr
//
//  This represents a typed subexpression in a where clause:
//
//      mycol < 2
//      33 <= tbl1.col2
//      tbl3.col4 = tbl4.col5
//      ...etc.
//
//***************************************************************************

struct SWQLTypedExpr
{
    LPWSTR         m_pTableRef;         // For qualified column names,
                                        //   NULL if not used
    LPWSTR         m_pColRef;           // Column name

    DWORD          m_dwRelOperator;     // The operator used: WQL_TOK_LE,
                                        //  WQL_TOK_GE, WQL_TOK_LIKE etc.
                                        //  WQL_TOK_IN_CONST_LIST
                                        //  WQL_TOK_NOT_IN_CONST_LIST
                                        //  WQL_TOK_IN_SUBSELECT
                                        //  WQL_TOK_NOT_IN_SUBSELECT

    SWQLTypedConst *m_pConstValue;     // A const value
    SWQLTypedConst *m_pConstValue2;    // The other const value used with BETWEEN

    LPWSTR         m_pJoinTableRef;     // The joined table name or its alias,
                                        //   NULL if not used
    LPWSTR         m_pJoinColRef;       // The joined column name

    LPWSTR         m_pIntrinsicFuncOnColRef;
    LPWSTR         m_pIntrinsicFuncOnJoinColRef;
    LPWSTR         m_pIntrinsicFuncOnConstValue;

    SWQLNode      *m_pLeftFunction;         // More detail for DATEPART, etc.
    SWQLNode      *m_pRightFunction;        // More detail for DATEPART, etc.

    DWORD          m_dwLeftArrayIndex;
    DWORD          m_dwRightArrayIndex;

    SWQLQualifiedName *m_pQNRight;
    SWQLQualifiedName *m_pQNLeft;

    DWORD          m_dwLeftFlags;
    DWORD          m_dwRightFlags;
        // Each of the above to Flags shows the expression layout on each side
        // of the operator.
        //  WQL_FLAG_CONST        = A typed constant was used
        //  WQL_FLAG_COLUMN       = Column field was used
        //  WQL_FLAG_TABLE        = Table/Alias was used
        //  WQL_FLAG_COMPLEX      = Complex qualified name and/or array was used
        //  WQL_FLAG_FUNCTIONIZED = Function was applied over the const or col.


    // For IN and NOT IN clauses.
    // ==========================

    SWQLNode       *m_pSubSelect;

    SWQLConstList  *m_pConstList;   // For IN clause with constant-list

    /*
    (1) If a const is tested against a column, then <m_pConstValue> will
        be used to represent it, and the table+col referenced will be in
        <m_pTableRef> and <m_pColRef>.

    (2) If a join occurs, then <m_pConstValue> will be NULL.

    (3) Intrinsic functions (primarily UPPER() and LOWER()) can be applied
        to the column references  or the constant.  The function names will
        be placed in the <m_pIntrinsic...> pointers when applied.

    (4) If <m_dwRelOperator> is WQL_TOK_IN_CONST_LIST or WQL_TOK_NOT_IN_CONST_LIST
        then <m_aConstSet> is an array of pointers to SWQLTypedConst structs representing
        the set of constants that the referenced column must intersect with.

    (5) If <m_dwRelOperator> is WQL_TOK_IN_SUBSELECT or WQL_TOK_NOT_IN_SUBSELECT
        then m_pSubSelect is a pointer to an embedded subselect tree in the form
        of a SWQLNode_Select struct, beginning the root of an entirely new select
        statement.
    */

    SWQLTypedExpr();
   ~SWQLTypedExpr() { Empty(); }
    void DebugDump();
    void Empty();
};



//***************************************************************************
//
//  SWQLNode_RelExpr
//
//                SWQLNode_RelExpr
//               /                \
//        SWQLNode_RelExpr        SWQLNode_RelExpr
//        or NULL                 or NULL
//
//***************************************************************************

#define TYPE_SWQLNode_RelExpr   (WQL_TOK_BASE + 13)

struct SWQLNode_RelExpr : SWQLNode
{
    DWORD m_dwExprType;  // WQL_TOK_OR
                         // WQL_TOK_AND
                         // WQL_TOK_NOT
                         // WQL_TOK_TYPED_EXPR

    SWQLTypedExpr *m_pTypedExpr;

    /*
    (1) If the <m_dwExprType> is WQL_TOK_AND or WQL_TOK_OR, then each of
        the two subnodes are themselves SWQLNode_RelExpr nodes and
        <m_pTypedExpr> points to NULL.

    (2) If <m_dwExprType> is WQL_TOK_NOT, then <m_pLeft> points to a
        SWQLNode_RelExpr containing the subclause to which to apply the NOT
        operation and <m_pRight> points to NULL.

    (3) If <m_dwExprType> is WQL_TOK_TYPED_EXPR, then <m_pLeft> and
        <m_pRight> both point to NULL, and <m_pTypedExpr> contains a typed
        relational subexpression.

    (4) Parentheses have been removed and are implied by the nesting.
    */

    SWQLNode_RelExpr() { m_dwNodeType = TYPE_SWQLNode_RelExpr; m_pTypedExpr = 0; m_dwExprType = 0; }
   ~SWQLNode_RelExpr() { delete m_pTypedExpr; }
    void DebugDump();
};



//***************************************************************************
//
//  SWQLNode_WhereOptions
//
//                SWQLNode_WhereOptions
//               /                 \
//           SWQLNode_GroupBy      SWQLNode_OrderBy
//
//***************************************************************************

#define TYPE_SWQLNode_WhereOptions (WQL_TOK_BASE + 14)

struct SWQLNode_WhereOptions : SWQLNode
{
    // left ptr is SWQLNode_GroupBy, or NULL if not used
    // right ptr is SWQLNode_OrderBy, or NULL if not used

    SWQLNode_WhereOptions() { m_dwNodeType = TYPE_SWQLNode_WhereOptions; }
    void DebugDump();
};

//***************************************************************************
//
//  SWQLNode_GroupBy
//
//                SWQLNode_GroupBy
//               /                \
//        SWQLNode_ColumnList    SWQLNode_Having
//                               or NULL
//
//***************************************************************************

#define TYPE_SWQLNode_GroupBy (WQL_TOK_BASE + 15)

struct SWQLNode_GroupBy : SWQLNode
{
    // left ptr is SWQLNode_ColumnList of columns to group by
    // right ptr is Having clause, if any

    SWQLNode_GroupBy() { m_dwNodeType = TYPE_SWQLNode_GroupBy; }
    void DebugDump();
};

//***************************************************************************
//
//  SWQLNode_Having
//
//                SWQLNode_Having
//               /               \
//           SWQLNode_RelExpr    NULL
//
//***************************************************************************

#define TYPE_SWQLNode_Having (WQL_TOK_BASE + 16)

struct SWQLNode_Having : SWQLNode
{
    // left ptr is SQLNode_RelExpr pointing to HAVING expressions
    // right ptr is NULL

    SWQLNode_Having() { m_dwNodeType = TYPE_SWQLNode_Having; }
    void DebugDump();
};



//***************************************************************************
//
//  SWQLNode_OrderBy
//
//                SWQLNode_OrderBy
//               /                \
//      SWQLNode_ColumnList       NULL
//
//***************************************************************************

#define TYPE_SWQLNode_OrderBy (WQL_TOK_BASE + 17)

struct SWQLNode_OrderBy : SWQLNode
{
    // left ptr is SWQLNode_ColumnList
    // right ptr is NULL
    SWQLNode_OrderBy() { m_dwNodeType = TYPE_SWQLNode_OrderBy; }
    void DebugDump();
};

//***************************************************************************
//
//  SWQLNode_Datepart
//
//  Contains a datepart call.
//
//***************************************************************************
#define TYPE_SWQLNode_Datepart  (WQL_TOK_BASE + 18)

struct SWQLNode_Datepart : SWQLNode
{
    int m_nDatepart;        // One of WQL_TOK_YEAR, WQL_TOK_MONTH,
                            // WQL_TOK_DAY, WQL_TOK_HOUR, WQL_TOK_MINUTE
                            // WQL_TOK_SECOND

    SWQLColRef *m_pColRef;  // The column to which DATEPART applies

    SWQLNode_Datepart() { m_dwNodeType = TYPE_SWQLNode_Datepart; m_nDatepart = 0; }
   ~SWQLNode_Datepart() { delete m_pColRef; }

    void DebugDump();
};


//***************************************************************************
//
//   SWQLNode_Delete
//
//   This is the root of a parse tree for delete.
//
//                SWQLNode_Delete
//               /               \
//      SWQLNode_TableRef   vSWQLNode_WhereClause
//     /                \
//    x                  x
//
//***************************************************************************

#define TYPE_SWQLNode_Delete        (WQL_TOK_BASE + 19)

struct SWQLNode_Delete : SWQLNode
{
    // Left  Node is of type SWQLNode_TableRef
    // Right Node is of type SWQLNode_WhereClause

    SWQLNode_Delete() { m_dwNodeType = TYPE_SWQLNode_Delete; }
   ~SWQLNode_Delete();
    void DebugDump();
};


//***************************************************************************
//
//   SWQLNode_Insert
//
//   This is the root of an INSERT
//
//                SWQLNode_Delete
//               /               \
//      SWQLNode_TableRef       SWQLNode_InsertValues
//     /                \
//    x                  x
//
//***************************************************************************

#define TYPE_SWQLNode_Insert        (WQL_TOK_BASE + 20)

struct SWQLNode_Insert : SWQLNode
{
    SWQLNode_Insert() { m_dwNodeType = TYPE_SWQLNode_Insert; }
   ~SWQLNode_Insert();
    void DebugDump();
};


//***************************************************************************
//
//   SWQLNode_Update
//
//   This is the root of an INSERT
//
//                SWQLNode_Update
//               /               \
//      SWQLNode_SetClause      SWQLNode_WhereClause
//
//***************************************************************************

#define TYPE_SWQLNode_Update        (WQL_TOK_BASE + 21)

struct SWQLNode_Update : SWQLNode
{
    SWQLNode_Update() { m_dwNodeType = TYPE_SWQLNode_Update; }
   ~SWQLNode_Update();
    void DebugDump();
};


//***************************************************************************
//
//   SWQLNode_AssocQuery
//
//                SWQLNode_AssocQuery
//               /               \
//             NULL             NULL
//
//***************************************************************************

#define TYPE_SWQLNode_AssocQuery        (WQL_TOK_BASE + 22)

struct SWQLNode_AssocQuery : SWQLNode
{
    CWbemAssocQueryInf *m_pAQInf;

    SWQLNode_AssocQuery() { m_pAQInf = 0; m_dwNodeType = TYPE_SWQLNode_AssocQuery; }
    ~SWQLNode_AssocQuery() { delete m_pAQInf; }
    void DebugDump();
};


#endif

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\provsubsys\decoupledclient\globals.cpp ===
/*++

Copyright (C) 1996-2001 Microsoft Corporation

Module Name:

	Globals.cpp

Abstract:


History:

--*/

#include <precomp.h>
#include <windows.h>
#include <objbase.h>

#include <initguid.h>
#ifndef INITGUID
#define INITGUID
#endif

#include <wbemcli.h>
#include <wbemint.h>
#include <cominit.h>

#include <wbemcli.h>
#include <wbemint.h>
#include <winntsec.h>
#include <wbemcomn.h>
#include <callsec.h>
#include <cominit.h>

#include <Guids.h>

#include <BasicTree.h>
#include <Thread.h>
#include <Logging.h>

#include "Globals.h"

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

WmiAllocator *DecoupledProviderSubSystem_Globals :: s_Allocator = NULL ;

LONG DecoupledProviderSubSystem_Globals :: s_LocksInProgress = 0 ;
LONG DecoupledProviderSubSystem_Globals :: s_ObjectsInProgress = 0 ;

LONG DecoupledProviderSubSystem_Globals :: s_CServerClassFactory_ObjectsInProgress = 0 ;
LONG DecoupledProviderSubSystem_Globals :: s_CServerObject_ProviderRegistrar_ObjectsInProgress = 0 ;
LONG DecoupledProviderSubSystem_Globals :: s_CServerObject_ProviderEvents_ObjectsInProgress = 0 ;
LONG DecoupledProviderSubSystem_Globals :: s_CInterceptor_DecoupledClient_ObjectsInProgress = 0 ;
LONG DecoupledProviderSubSystem_Globals :: s_CDecoupled_IWbemSyncObjectSink_ObjectsInProgress = 0 ;
LONG DecoupledProviderSubSystem_Globals :: s_CDecoupled_Batching_IWbemSyncObjectSink_ObjectsInProgress = 0 ;
LONG DecoupledProviderSubSystem_Globals :: s_CInterceptor_IWbemDecoupledUnboundObjectSink_ObjectsInProgress = 0 ;
/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT DecoupledProviderSubSystem_Globals :: Global_Startup ()
{
	HRESULT t_Result = S_OK ;

	if ( ! s_Allocator )
	{
/*
 *	Use the global process heap for this particular boot operation
 */

		WmiAllocator t_Allocator ;
		WmiStatusCode t_StatusCode = t_Allocator.New (

			( void ** ) & s_Allocator ,
			sizeof ( WmiAllocator ) 
		) ;

		if ( t_StatusCode == e_StatusCode_Success )
		{
			:: new ( ( void * ) s_Allocator ) WmiAllocator ;

			t_StatusCode = s_Allocator->Initialize () ;
			if ( t_StatusCode != e_StatusCode_Success )
			{
				t_Result = WBEM_E_OUT_OF_MEMORY ;
			}
		}
		else
		{
			t_Result = WBEM_E_OUT_OF_MEMORY ;
		}
	}

	if ( SUCCEEDED ( t_Result ) )
	{
		WmiStatusCode t_StatusCode = WmiThread <ULONG> :: Static_Initialize ( *s_Allocator ) ;
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT DecoupledProviderSubSystem_Globals :: Global_Shutdown ()
{
	HRESULT t_Result = S_OK ;

	WmiStatusCode t_StatusCode = WmiThread <ULONG> :: Static_UnInitialize ( *s_Allocator ) ;

	if ( s_Allocator )
	{
/*
 *	Use the global process heap for this particular boot operation
 */

		WmiAllocator t_Allocator ;
		WmiStatusCode t_StatusCode = t_Allocator.Delete (

			( void * ) s_Allocator
		) ;

		if ( t_StatusCode != e_StatusCode_Success )
		{
			t_Result = WBEM_E_OUT_OF_MEMORY ;
		}
	}

	return t_Result ;
}


/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

void * __cdecl operator new ( size_t a_Size )
{
    void *t_Ptr ;
	WmiStatusCode t_StatusCode = DecoupledProviderSubSystem_Globals :: s_Allocator->New (

		( void ** ) & t_Ptr ,
		a_Size
	) ;

	if ( t_StatusCode != e_StatusCode_Success )
    {
        throw Wmi_Heap_Exception (

			Wmi_Heap_Exception::HEAP_ERROR::E_ALLOCATION_ERROR
		) ;
    }

    return t_Ptr ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

void __cdecl operator delete ( void *a_Ptr )
{
    if ( a_Ptr )
    {
		WmiStatusCode t_StatusCode = DecoupledProviderSubSystem_Globals :: s_Allocator->Delete (

			( void * ) a_Ptr
		) ;
    }
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT DecoupledProviderSubSystem_Globals :: BeginThreadImpersonation (

	IUnknown *&a_OldContext ,
	IServerSecurity *&a_OldSecurity ,
	BOOL &a_Impersonating
)
{
	HRESULT t_Result = S_OK ;

	IServerSecurity *t_ServerSecurity = NULL ;

	t_Result = CoGetCallContext ( IID_IUnknown , ( void ** ) & a_OldContext ) ;
	if ( SUCCEEDED ( t_Result ) )
	{
		t_Result = a_OldContext->QueryInterface ( IID_IServerSecurity , ( void ** ) & t_ServerSecurity ) ;
		if ( SUCCEEDED ( t_Result ) ) 
		{
			a_Impersonating = t_ServerSecurity->IsImpersonating () ;
		}
		else
		{
			a_Impersonating = FALSE ;
		}
	}

	CWbemCallSecurity *t_CallSecurity = CWbemCallSecurity :: New () ;
	if ( t_CallSecurity )
	{
		t_CallSecurity->AddRef () ;

		_IWmiThreadSecHandle *t_ThreadSecurity = NULL ;
		t_Result = t_CallSecurity->GetThreadSecurity ( ( WMI_THREAD_SECURITY_ORIGIN ) ( WMI_ORIGIN_THREAD ) , & t_ThreadSecurity ) ;
		if ( SUCCEEDED ( t_Result ) )
		{
			t_Result = t_CallSecurity->SetThreadSecurity ( t_ThreadSecurity ) ;
			if ( SUCCEEDED ( t_Result ) ) 
			{
				t_Result = t_CallSecurity->QueryInterface ( IID_IServerSecurity , ( void ** ) & a_OldSecurity ) ;
				if ( SUCCEEDED ( t_Result ) ) 
				{
					if ( a_Impersonating )
					{
						t_ServerSecurity->RevertToSelf () ;
					}
				}				
			}

			t_ThreadSecurity->Release () ;
		}

		t_CallSecurity->Release () ;
	}

	if ( t_ServerSecurity )
	{
		t_ServerSecurity->Release () ;
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT DecoupledProviderSubSystem_Globals :: EndThreadImpersonation (

	IUnknown *a_OldContext ,
	IServerSecurity *a_OldSecurity ,
	BOOL a_Impersonating

)
{
	HRESULT t_Result = S_OK ;

	IUnknown *t_NewContext = NULL ;

	t_Result = CoSwitchCallContext ( a_OldContext , & t_NewContext ) ;
	if ( SUCCEEDED ( t_Result ) ) 
	{
		if ( a_OldContext )
		{
			if ( a_Impersonating )
			{
				IServerSecurity *t_ServerSecurity = NULL ;
				t_Result = a_OldContext->QueryInterface ( IID_IServerSecurity , ( void ** ) & t_ServerSecurity ) ;
				if ( SUCCEEDED ( t_Result ) )
				{
					t_ServerSecurity->ImpersonateClient () ;

					t_ServerSecurity->Release () ;
				}
			}
		}

		if ( a_OldSecurity )
		{
			a_OldSecurity->Release() ;
		}
	}
	else
	{
		t_Result = WBEM_E_OUT_OF_MEMORY ;
	}

/* 
 * CoGetCallContext AddReffed this thing so now we have to release it.
 */

	if ( a_OldContext )
	{ 
        a_OldContext->Release () ;
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT DecoupledProviderSubSystem_Globals :: Begin_IdentifyCall_PrvHost (

	WmiInternalContext a_InternalContext ,
	BOOL &a_Impersonating ,
	IUnknown *&a_OldContext ,
	IServerSecurity *&a_OldSecurity
)
{
	HRESULT t_Result = WBEM_E_INVALID_PARAMETER ;

	if ( a_InternalContext.m_IdentifyHandle )
	{
		HANDLE t_IdentifyToken = ( HANDLE ) a_InternalContext.m_IdentifyHandle ;
		BOOL t_Status = SetThreadToken ( NULL , t_IdentifyToken ) ;
		if ( t_Status )
		{
			t_Result = BeginThreadImpersonation ( a_OldContext , a_OldSecurity , a_Impersonating ) ;

			RevertToSelf () ;
		}
		else
		{
			t_Result = WBEM_E_ACCESS_DENIED ;
		}

		CloseHandle ( t_IdentifyToken ) ;
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT DecoupledProviderSubSystem_Globals :: End_IdentifyCall_PrvHost (

	WmiInternalContext a_InternalContext ,
	IUnknown *&a_OldContext ,
	IServerSecurity *&a_OldSecurity ,
	BOOL &a_Impersonating
)
{
	EndThreadImpersonation ( a_OldContext , a_OldSecurity , a_Impersonating ) ;

	RevertToSelf () ;

	return S_OK ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT DecoupledProviderSubSystem_Globals :: Begin_IdentifyCall_SvcHost (

	WmiInternalContext a_InternalContext ,
	BOOL &a_Impersonating ,
	IUnknown *&a_OldContext ,
	IServerSecurity *&a_OldSecurity
)
{
	HRESULT t_Result = WBEM_E_INVALID_PARAMETER ;

	if ( a_InternalContext.m_IdentifyHandle )
	{
		HANDLE t_IdentifyToken = NULL ;

		t_Result = CoImpersonateClient () ;
		if ( SUCCEEDED ( t_Result ) )
		{
			HANDLE t_CallerIdentifyToken = ( HANDLE ) a_InternalContext.m_IdentifyHandle ;
			DWORD t_ProcessIdentifier = a_InternalContext.m_ProcessIdentifier ;

			HANDLE t_ProcessHandle = OpenProcess (

				PROCESS_DUP_HANDLE ,
				FALSE ,
				t_ProcessIdentifier 
			) ;

			if ( t_ProcessHandle )
			{
				BOOL t_Status = DuplicateHandle (

					t_ProcessHandle ,
					t_CallerIdentifyToken ,
					GetCurrentProcess () ,
					& t_IdentifyToken ,
					MAXIMUM_ALLOWED | TOKEN_DUPLICATE | TOKEN_IMPERSONATE ,
					TRUE ,
					0
				) ;

				if ( t_Status )
				{
				}
				else
				{
					t_Result = WBEM_E_ACCESS_DENIED ;
				}
								
				CloseHandle ( t_ProcessHandle ) ;
			}
			else
			{
				t_Result = WBEM_E_ACCESS_DENIED ;
			}

			CoRevertToSelf () ;
		}

		if ( SUCCEEDED ( t_Result ) )
		{
			BOOL t_Status = SetThreadToken ( NULL , t_IdentifyToken ) ;
			if ( t_Status )
			{
				t_Result = BeginThreadImpersonation ( a_OldContext , a_OldSecurity , a_Impersonating ) ;

				CoRevertToSelf () ;

				RevertToSelf () ;
			}
			else
			{
				t_Result = WBEM_E_ACCESS_DENIED ;
			}

			CloseHandle ( t_IdentifyToken ) ;
		}
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT DecoupledProviderSubSystem_Globals :: End_IdentifyCall_SvcHost (

	WmiInternalContext a_InternalContext ,
	IUnknown *&a_OldContext ,
	IServerSecurity *&a_OldSecurity ,
	BOOL &a_Impersonating
)
{
	EndThreadImpersonation ( a_OldContext , a_OldSecurity , a_Impersonating ) ;

	RevertToSelf () ;

	return S_OK ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\provsubsys\decoupledclient\maindll.cpp ===
/*++

Copyright (C) 1996-2001 Microsoft Corporation

Module Name:

	MainDll.cpp

Abstract:


History:

--*/

#include "PreComp.h"
#include <wbemint.h>
#include <comdef.h>
#include <stdio.h>

#include "Globals.h"
#include "ClassFac.h"
#include "Guids.h"
#include "ProvRegistrar.h"
#include "ProvEvents.h"
#include <lockst.h>
/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HINSTANCE g_ModuleInstance=NULL;

CriticalSection s_CriticalSection(NOTHROW_LOCK) ;

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

BOOL APIENTRY DllMain (

	HINSTANCE a_ModuleInstance, 
	ULONG a_Reason , 
	LPVOID a_Reserved
)
{
	g_ModuleInstance = a_ModuleInstance ;

	BOOL t_Status = TRUE ;

    if ( DLL_PROCESS_DETACH == a_Reason )
	{
		HRESULT t_Result = DecoupledProviderSubSystem_Globals :: Global_Shutdown () ;
		if ( SUCCEEDED ( t_Result ) )
		{
			t_Status = TRUE ;
		}
		else
		{
			t_Status = FALSE ;
		}

		WmiHelper :: DeleteCriticalSection ( & s_CriticalSection ) ;

		t_Status = TRUE ;
    }
    else if ( DLL_PROCESS_ATTACH == a_Reason )
	{
		WmiStatusCode t_StatusCode = WmiHelper :: InitializeCriticalSection ( & s_CriticalSection ) ;
		if ( t_StatusCode == e_StatusCode_Success )
		{
			HRESULT t_Result = DecoupledProviderSubSystem_Globals :: Global_Startup () ;
			if ( SUCCEEDED ( t_Result ) )
			{
				t_Status = TRUE ;
			}
			else
			{
				t_Status = FALSE ;
			}
		}
		else
		{
			t_Status = FALSE ;
		}

		DisableThreadLibraryCalls ( a_ModuleInstance ) ;
    }
    else if ( DLL_THREAD_DETACH == a_Reason )
	{
		t_Status = TRUE ;
    }
    else if ( DLL_THREAD_ATTACH == a_Reason )
	{
		t_Status = TRUE ;
    }

    return t_Status ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

STDAPI DllGetClassObject (

	REFCLSID a_Clsid , 
	REFIID a_Riid , 
	void **a_Void 
)
{
	HRESULT t_Result = S_OK ; 

	if ( a_Clsid == CLSID_WbemDecoupledRegistrar ) 
	{
		CServerClassFactory <CServerObject_ProviderRegistrar,CServerObject_ProviderRegistrar> *t_Unknown = new CServerClassFactory <CServerObject_ProviderRegistrar,CServerObject_ProviderRegistrar> ;
		if ( t_Unknown == NULL )
		{
			t_Result = E_OUTOFMEMORY ;
		}
		else
		{
			t_Result = t_Unknown->QueryInterface ( a_Riid , a_Void ) ;
			if ( FAILED ( t_Result ) )
			{
				delete t_Unknown ;				
			}
			else
			{
			}			
		}
	}
	else if ( a_Clsid == CLSID_WbemDecoupledBasicEventProvider ) 
	{
		CServerClassFactory <CServerObject_ProviderEvents,CServerObject_ProviderEvents> *t_Unknown = new CServerClassFactory <CServerObject_ProviderEvents,CServerObject_ProviderEvents> ;
		if ( t_Unknown == NULL )
		{
			t_Result = E_OUTOFMEMORY ;
		}
		else
		{
			t_Result = t_Unknown->QueryInterface ( a_Riid , a_Void ) ;
			if ( FAILED ( t_Result ) )
			{
				delete t_Unknown ;				
			}
			else
			{
			}			
		}
	}
	else
	{
		t_Result = CLASS_E_CLASSNOTAVAILABLE ;
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

STDAPI DllCanUnloadNow ()
{

/* 
 * Place code in critical section
 */

	WmiStatusCode t_StatusCode = WmiHelper :: EnterCriticalSection ( & s_CriticalSection , FALSE ) ;
	if ( t_StatusCode == e_StatusCode_Success )
	{
		BOOL t_Unload = ( 
						DecoupledProviderSubSystem_Globals :: s_LocksInProgress || DecoupledProviderSubSystem_Globals :: s_ObjectsInProgress 
					) ;
		t_Unload = ! t_Unload ;

		WmiHelper :: LeaveCriticalSection ( & s_CriticalSection ) ;

		return t_Unload ? ResultFromScode ( S_OK ) : ResultFromScode ( S_FALSE ) ;
	}
	else
	{
		return FALSE ;
	}
}


/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

//Strings used during self registeration


#define REG_FORMAT_STR			L"%s\\%s"
#define NOT_INSERT_STR			L"NotInsertable"
#define INPROC32_STR			L"InprocServer32"
#define LOCALSERVER32_STR		L"LocalServer32"
#define THREADING_MODULE_STR	L"ThreadingModel"
#define APARTMENT_STR			L"Both"
#define APPID_VALUE_STR			L"APPID"
#define APPID_STR				L"APPID\\"
#define CLSID_STR				L"CLSID\\"

#define WMI_PROVIDER_DECOUPLED_REGISTRAR				__TEXT("Microsoft WMI Provider Subsystem Decoupled Registrar")
#define WMI_PROVIDER_DECOUPLED_BASIC_EVENT_PROVIDER		__TEXT("Microsoft WMI Provider Subsystem Decoupled Basic Event Provider")

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

BOOL SetKeyAndValue ( wchar_t *pszKey , wchar_t *pszSubkey , wchar_t *pszValueName , wchar_t *pszValue )
{
    HKEY hKey;
    wchar_t szKey[256];

	wcscpy ( szKey , pszKey ) ;

    if ( NULL != pszSubkey )
    {
		wcscat ( szKey , L"\\" ) ;
        wcscat ( szKey , pszSubkey ) ;
    }

    if ( ERROR_SUCCESS != RegCreateKeyEx ( 

			HKEY_CLASSES_ROOT , 
			szKey , 
			0, 
			NULL, 
			REG_OPTION_NON_VOLATILE ,
			KEY_ALL_ACCESS, 
			NULL, 
			&hKey, 
			NULL
		)
	)
	{
        return FALSE ;
	}

    if ( NULL != pszValue )
    {
        if ( ERROR_SUCCESS != RegSetValueEx (

				hKey, 
				pszValueName, 
				0, 
				REG_SZ, 
				(BYTE *) pszValue , 
				(lstrlen(pszValue)+1)*sizeof(wchar_t)
			)
		)
		{
			return FALSE;
		}
    }

    RegCloseKey ( hKey ) ;

    return TRUE;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

STDAPI RegisterServer ( GUID a_ProviderClassId , wchar_t *a_ProviderName )
{
	wchar_t szModule[512];
	GetModuleFileName(g_ModuleInstance,(wchar_t*)szModule, sizeof(szModule)/sizeof(wchar_t));

	wchar_t szProviderClassID[128];
	wchar_t szProviderCLSIDClassID[128];

	int iRet = StringFromGUID2(a_ProviderClassId,szProviderClassID, 128);

	wcscpy(szProviderCLSIDClassID,CLSID_STR);
	wcscat(szProviderCLSIDClassID,szProviderClassID);

		//Create entries under CLSID
	if (FALSE ==SetKeyAndValue(szProviderCLSIDClassID, NULL, NULL, a_ProviderName ))
		return SELFREG_E_CLASS;

	if (FALSE ==SetKeyAndValue(szProviderCLSIDClassID, NOT_INSERT_STR, NULL, NULL))
			return SELFREG_E_CLASS;

	if (FALSE ==SetKeyAndValue(szProviderCLSIDClassID, INPROC32_STR, NULL,szModule))
		return SELFREG_E_CLASS;

	if (FALSE ==SetKeyAndValue(szProviderCLSIDClassID, INPROC32_STR,THREADING_MODULE_STR, APARTMENT_STR))
		return SELFREG_E_CLASS;

	return S_OK;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

STDAPI UnregisterServer( GUID a_ProviderClassId )
{
	wchar_t szTemp[128];

	wchar_t szProviderClassID[128];
	wchar_t szProviderCLSIDClassID[128];

	int iRet = StringFromGUID2(a_ProviderClassId ,szProviderClassID, 128);

	wcscpy(szProviderCLSIDClassID,CLSID_STR);
	wcscat(szProviderCLSIDClassID,szProviderClassID);

	//Delete entries under CLSID

	wsprintf(szTemp, REG_FORMAT_STR, szProviderCLSIDClassID, NOT_INSERT_STR);
	RegDeleteKey(HKEY_CLASSES_ROOT, szTemp);

	wsprintf(szTemp, REG_FORMAT_STR,szProviderCLSIDClassID, INPROC32_STR);
	RegDeleteKey(HKEY_CLASSES_ROOT, szTemp);

	RegDeleteKey(HKEY_CLASSES_ROOT, szProviderCLSIDClassID);

    return S_OK;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

STDAPI DllRegisterServer ()
{
	HRESULT t_Result ;

	t_Result = RegisterServer ( CLSID_WbemDecoupledRegistrar			,	WMI_PROVIDER_DECOUPLED_REGISTRAR ) ;
	t_Result = RegisterServer ( CLSID_WbemDecoupledBasicEventProvider	,	WMI_PROVIDER_DECOUPLED_BASIC_EVENT_PROVIDER ) ;

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

STDAPI DllUnregisterServer ()
{
	HRESULT t_Result ;

	t_Result = UnregisterServer ( CLSID_WbemDecoupledRegistrar ) ;
	t_Result = UnregisterServer ( CLSID_WbemDecoupledBasicEventProvider ) ;

	return t_Result ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\provsubsys\decoupledclient\precomp.h ===
/*++

Copyright (C) 1996-2001 Microsoft Corporation

Module Name:

	Precomp.h

Abstract:


History:

--*/

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <ntobapi.h>
#include <ntpsapi.h>
#include <ntexapi.h>

#define _WINNT_	// have what is needed from above

#include <ole2.h>
#include <windows.h>
#define COREPOL_HEADERFILE_IS_INCLUDED
#ifndef POLARITY
#if 1
#define POLARITY __declspec( dllimport )
#else
#define POLARITY 
#endif
#endif

#define COREPROX_POLARITY __declspec( dllimport )
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\provsubsys\decoupledclient\provevents.cpp ===
/*++

Copyright (C) 1996-2001 Microsoft Corporation

Module Name:

	ProvFact.cpp

Abstract:


History:

--*/

/*++

Copyright (C) 1996-2001 Microsoft Corporation

Module Name:

	ProvFact.cpp

Abstract:


History:

--*/

#include <PreComp.h>
#include <wbemint.h>

#include "Globals.h"
#include "Guids.h"

#include "ProvRegistrar.h"
#include "ProvEvents.h"

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

CDecoupled_IWbemObjectSink :: CDecoupled_IWbemObjectSink ()

	:	m_InterceptedSink ( NULL ) ,
		m_EventSink ( NULL ) ,
		m_GateClosed ( FALSE ) ,
		m_InProgress ( 0 ) ,
		m_StatusCalled ( FALSE ) ,
		m_SecurityDescriptorLength ( 0 ) ,
		m_SecurityDescriptor ( NULL ),
		m_CriticalSection(NOTHROW_LOCK)
{
	InterlockedIncrement ( & DecoupledProviderSubSystem_Globals :: s_ObjectsInProgress ) ;

	WmiStatusCode t_StatusCode = WmiHelper :: InitializeCriticalSection ( & m_CriticalSection ) ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

CDecoupled_IWbemObjectSink::~CDecoupled_IWbemObjectSink ()
{
	if ( ! InterlockedCompareExchange ( & m_StatusCalled , 0 , 0 ) )
	{
		WmiHelper :: EnterCriticalSection ( & ( CDecoupled_IWbemObjectSink :: m_CriticalSection ) ) ;

		IWbemObjectSink *t_ObjectSink = m_InterceptedSink ;
		if ( t_ObjectSink )
		{
			t_ObjectSink->AddRef () ;
		}

		WmiHelper :: LeaveCriticalSection ( & ( CDecoupled_IWbemObjectSink :: m_CriticalSection ) ) ;

		if ( t_ObjectSink )
		{
			t_ObjectSink->SetStatus ( 

				0 ,
				WBEM_E_UNEXPECTED ,
				NULL ,
				NULL
			) ;

			t_ObjectSink->Release () ;
		}


	}

	if ( m_InterceptedSink )
	{
		m_InterceptedSink->Release () ;
	}

	if ( m_EventSink )
	{
		m_EventSink->Release () ;
	}

	if ( m_SecurityDescriptor )
	{
		delete [] m_SecurityDescriptor ;
	}

	WmiHelper :: DeleteCriticalSection ( & m_CriticalSection ) ;

	InterlockedDecrement ( & DecoupledProviderSubSystem_Globals :: s_ObjectsInProgress ) ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

STDMETHODIMP CDecoupled_IWbemObjectSink::QueryInterface (

	REFIID a_Riid , 
	LPVOID FAR *a_Void 
) 
{
	*a_Void = NULL ;

	if ( a_Riid == IID_IUnknown )
	{
		*a_Void = ( LPVOID ) this ;
	}
	else if ( a_Riid == IID_IWbemObjectSink )
	{
		*a_Void = ( LPVOID ) ( IWbemObjectSink * ) this ;		
	}
	else if ( a_Riid == IID_IWbemEventSink )
	{
		*a_Void = ( LPVOID ) ( IWbemEventSink * ) this ;		
	}	
	else if ( a_Riid == IID_IWbemShutdown )
	{
		*a_Void = ( LPVOID ) ( IWbemShutdown * ) this ;		
	}	

	if ( *a_Void )
	{
		( ( LPUNKNOWN ) *a_Void )->AddRef () ;

		return ResultFromScode ( S_OK ) ;
	}
	else
	{
		return ResultFromScode ( E_NOINTERFACE ) ;
	}
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CDecoupled_IWbemObjectSink :: Indicate (

	long a_ObjectCount ,
	IWbemClassObject **a_ObjectArray
)
{
	HRESULT t_Result = S_OK ;

	try
	{
		InterlockedIncrement ( & m_InProgress ) ;

		try
		{
			if ( m_GateClosed == 1 )
			{
				t_Result = WBEM_E_SHUTTING_DOWN ;
			}
			else
			{
				WmiHelper :: EnterCriticalSection ( & ( CDecoupled_IWbemObjectSink :: m_CriticalSection ) ) ;

				IWbemObjectSink *t_ObjectSink = m_InterceptedSink ;
				if ( t_ObjectSink )
				{
					t_ObjectSink->AddRef () ;
				}

				WmiHelper :: LeaveCriticalSection ( & ( CDecoupled_IWbemObjectSink :: m_CriticalSection ) ) ;

				if ( t_ObjectSink )
				{
					t_Result = t_ObjectSink->Indicate ( 

						a_ObjectCount ,
						a_ObjectArray
					) ;

					t_ObjectSink->Release () ;
				}
			}
		}
		catch ( ... )
		{
			t_Result = WBEM_E_CRITICAL_ERROR ;
		}

		InterlockedDecrement ( & m_InProgress ) ;
	}
	catch ( ... )
	{
		t_Result = WBEM_E_CRITICAL_ERROR ;
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CDecoupled_IWbemObjectSink :: SetStatus (

	long a_Flags ,
	HRESULT a_Result ,
	BSTR a_StringParam ,
	IWbemClassObject *a_ObjectParam
)
{
	HRESULT t_Result = S_OK ;

	try
	{
		InterlockedIncrement ( & m_InProgress ) ;

		try
		{
			if ( m_GateClosed == 1 )
			{
				t_Result = WBEM_E_SHUTTING_DOWN ;
			}
			else
			{
				switch ( a_Flags )
				{
					case WBEM_STATUS_PROGRESS:
					{
						WmiHelper :: EnterCriticalSection ( & ( CDecoupled_IWbemObjectSink :: m_CriticalSection ) ) ;

						IWbemObjectSink *t_ObjectSink = m_InterceptedSink ;
						if ( t_ObjectSink )
						{
							t_ObjectSink->AddRef () ;
						}

						WmiHelper :: LeaveCriticalSection ( & ( CDecoupled_IWbemObjectSink :: m_CriticalSection ) ) ;

						if ( t_ObjectSink )
						{
							t_Result = t_ObjectSink->SetStatus ( 

								a_Flags ,
								a_Result ,
								a_StringParam ,
								a_ObjectParam
							) ;

							t_ObjectSink->Release () ;
						}
					}
					break ;

					case WBEM_STATUS_COMPLETE:
					{
						if ( ! InterlockedCompareExchange ( & m_StatusCalled , 1 , 0 ) )
						{
							WmiHelper :: EnterCriticalSection ( & ( CDecoupled_IWbemObjectSink :: m_CriticalSection ) ) ;

							IWbemObjectSink *t_ObjectSink = m_InterceptedSink ;
							if ( t_ObjectSink )
							{
								t_ObjectSink->AddRef () ;
							}

							WmiHelper :: LeaveCriticalSection ( & ( CDecoupled_IWbemObjectSink :: m_CriticalSection ) ) ;

							if ( t_ObjectSink )
							{
								t_Result = t_ObjectSink->SetStatus ( 

									a_Flags ,
									a_Result ,
									a_StringParam ,
									a_ObjectParam
								) ;

								t_ObjectSink->Release () ;
							}
						}
					}
					break ;

					default:
					{
						t_Result = WBEM_E_INVALID_PARAMETER ;
					}
					break ;
				}
			}
		}
		catch ( ... )
		{
			t_Result = WBEM_E_CRITICAL_ERROR ;
		}

		InterlockedDecrement ( & m_InProgress ) ;
	}
	catch ( ... )
	{
		t_Result = WBEM_E_CRITICAL_ERROR ;
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CDecoupled_IWbemObjectSink :: SetSinkSecurity (

	long a_SecurityDescriptorLength ,
	BYTE *a_SecurityDescriptor
)
{
	HRESULT t_Result = S_OK ;

	try
	{
		InterlockedIncrement ( & m_InProgress ) ;

		try
		{
			if ( m_GateClosed == 1 )
			{
				t_Result = WBEM_E_SHUTTING_DOWN ;
			}
			else
			{
				WmiHelper :: EnterCriticalSection ( & ( CDecoupled_IWbemObjectSink :: m_CriticalSection ) ) ;

				IWbemEventSink *t_ObjectSink = m_EventSink ;
				if ( t_ObjectSink )
				{
					t_ObjectSink->AddRef () ;
				}

				WmiHelper :: LeaveCriticalSection ( & ( CDecoupled_IWbemObjectSink :: m_CriticalSection ) ) ;

				if ( t_ObjectSink )
				{
					t_Result = t_ObjectSink->SetSinkSecurity ( 

							a_SecurityDescriptorLength ,
							a_SecurityDescriptor
					) ;

					t_ObjectSink->Release () ;
				}
				else
				{
					if ( a_SecurityDescriptor )
					{
						if ( a_SecurityDescriptorLength )
						{
							WmiHelper :: EnterCriticalSection ( & ( CDecoupled_IWbemObjectSink :: m_CriticalSection ) ) ;

							m_SecurityDescriptorLength = a_SecurityDescriptorLength ;
							m_SecurityDescriptor = new BYTE [ a_SecurityDescriptorLength ] ;
							if  ( m_SecurityDescriptor )
							{
								try
								{
									CopyMemory ( m_SecurityDescriptor , a_SecurityDescriptor , a_SecurityDescriptorLength ) ;
								}
								catch ( ... )
								{
									t_Result = WBEM_E_CRITICAL_ERROR ;
								}
							}
							else
							{
								t_Result = WBEM_E_OUT_OF_MEMORY ;
							}

							WmiHelper :: LeaveCriticalSection ( & ( CDecoupled_IWbemObjectSink :: m_CriticalSection ) ) ;
						}
						else
						{
							t_Result = WBEM_E_INVALID_PARAMETER ;
						}
					}
					else
					{
						WmiHelper :: EnterCriticalSection ( & ( CDecoupled_IWbemObjectSink :: m_CriticalSection ) ) ;

						if ( m_SecurityDescriptor )
						{
							delete m_SecurityDescriptor ;
							m_SecurityDescriptor = NULL ;
						}

						m_SecurityDescriptorLength = 0 ;

						WmiHelper :: LeaveCriticalSection ( & ( CDecoupled_IWbemObjectSink :: m_CriticalSection ) ) ;
					}
				}
			}
		}
		catch ( ... )
		{
			t_Result = WBEM_E_CRITICAL_ERROR ;
		}

		InterlockedDecrement ( & m_InProgress ) ;
	}
	catch ( ... )
	{
		t_Result = WBEM_E_CRITICAL_ERROR ;
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CDecoupled_IWbemObjectSink :: IsActive ()
{
	HRESULT t_Result = S_OK ;

	try
	{
		InterlockedIncrement ( & m_InProgress ) ;

		try
		{
			if ( m_GateClosed == 1 )
			{
				t_Result = WBEM_E_SHUTTING_DOWN ;
			}
			else
			{
				WmiHelper :: EnterCriticalSection ( & ( CDecoupled_IWbemObjectSink :: m_CriticalSection ) ) ;

				IWbemEventSink *t_ObjectSink = m_EventSink ;
				if ( t_ObjectSink )
				{
					t_ObjectSink->AddRef () ;
				}

				WmiHelper :: LeaveCriticalSection ( & ( CDecoupled_IWbemObjectSink :: m_CriticalSection ) ) ;

				if ( t_ObjectSink )
				{
					t_Result = t_ObjectSink->IsActive () ;

					t_ObjectSink->Release () ;
				}
				else
				{
					t_Result = WBEM_S_FALSE ;
				}
			}
		}
		catch ( ... )
		{
			t_Result = WBEM_E_CRITICAL_ERROR ;
		}

		InterlockedDecrement ( & m_InProgress ) ;
	}
	catch ( ... )
	{
		t_Result = WBEM_E_CRITICAL_ERROR ;
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CDecoupled_IWbemObjectSink :: SetBatchingParameters (

	LONG a_Flags,
	DWORD a_MaxBufferSize,
	DWORD a_MaxSendLatency
)
{
	HRESULT t_Result = S_OK ;

	try
	{
		InterlockedIncrement ( & m_InProgress ) ;

		try
		{
			if ( m_GateClosed == 1 )
			{
				t_Result = WBEM_E_SHUTTING_DOWN ;
			}
			else
			{
				WmiHelper :: EnterCriticalSection ( & ( CDecoupled_IWbemObjectSink :: m_CriticalSection ) ) ;

				IWbemEventSink *t_ObjectSink = m_EventSink ;
				if ( t_ObjectSink )
				{
					t_ObjectSink->AddRef () ;
				}

				WmiHelper :: LeaveCriticalSection ( & ( CDecoupled_IWbemObjectSink :: m_CriticalSection ) ) ;

				if ( t_ObjectSink )
				{
					t_Result = t_ObjectSink->SetBatchingParameters ( 

						a_Flags ,
						a_MaxBufferSize ,
						a_MaxSendLatency
					) ;

					t_ObjectSink->Release () ;
				}
			}
		}
		catch ( ... )
		{
			t_Result = WBEM_E_CRITICAL_ERROR ;
		}

		InterlockedDecrement ( & m_InProgress ) ;
	}
	catch ( ... )
	{
		t_Result = WBEM_E_CRITICAL_ERROR ;
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CDecoupled_IWbemObjectSink :: Shutdown (

	LONG a_Flags ,
	ULONG a_MaxMilliSeconds ,
	IWbemContext *a_Context
)
{
	HRESULT t_Result = S_OK ;

	try
	{
		if ( ! InterlockedCompareExchange ( & m_StatusCalled , 1 , 0 ) )
		{
			WmiHelper :: EnterCriticalSection ( & ( CDecoupled_IWbemObjectSink :: m_CriticalSection ) ) ;

			IWbemObjectSink *t_ObjectSink = m_InterceptedSink ;
			if ( t_ObjectSink )
			{
				t_ObjectSink->AddRef () ;
			}

			WmiHelper :: LeaveCriticalSection ( & ( CDecoupled_IWbemObjectSink :: m_CriticalSection ) ) ;

			if ( t_ObjectSink )
			{
				t_Result = t_ObjectSink->SetStatus ( 

					0 ,
					WBEM_E_SHUTTING_DOWN ,
					NULL ,
					NULL
				) ;

				t_ObjectSink->Release () ;
			}
		}

		m_GateClosed ++ ;

		try
		{
			bool t_Acquired = false ;
			while ( ! t_Acquired )
			{
				if ( m_InProgress == 0 )
				{
					t_Acquired = true ;

					break ;
				}

				if ( SwitchToThread () == FALSE ) 
				{
				}
			}
		}
		catch ( ... )
		{
			t_Result = WBEM_E_CRITICAL_ERROR ;
		}
	}
	catch ( ... )
	{
		t_Result = WBEM_E_CRITICAL_ERROR ;
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CDecoupledRoot_IWbemObjectSink :: SinkInitialize ()
{
	HRESULT t_Result = S_OK ;

	WmiStatusCode t_StatusCode = CWbemGlobal_Decoupled_IWmiObjectSinkController :: Initialize () ;
	if ( t_StatusCode != e_StatusCode_Success ) 
	{
		t_Result = WBEM_E_OUT_OF_MEMORY ;
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CDecoupledRoot_IWbemObjectSink :: SetSink ( IWbemObjectSink *a_Sink ) 
{
	Lock () ;

	CWbemGlobal_Decoupled_IWmiObjectSinkController_Container *t_Container = NULL ;
	GetContainer ( t_Container ) ;

	CWbemGlobal_Decoupled_IWmiObjectSinkController_Container_Iterator t_Iterator = t_Container->Begin ();

	while ( ! t_Iterator.Null () )
	{
		HRESULT t_Result = t_Iterator.GetKey ()->SetSink ( a_Sink ) ;

		t_Iterator.Increment () ;
	}

	UnLock () ;

	HRESULT t_Result = S_OK ;

	WmiHelper :: EnterCriticalSection ( & ( CDecoupled_IWbemObjectSink :: m_CriticalSection ) ) ;

	if ( m_InterceptedSink )
	{
		m_InterceptedSink->Release () ;
	}

	m_InterceptedSink = a_Sink ;
	m_InterceptedSink->AddRef () ;

	t_Result = a_Sink->QueryInterface ( IID_IWbemEventSink , ( void ** ) & m_EventSink ) ;

	WmiHelper :: LeaveCriticalSection ( & ( CDecoupled_IWbemObjectSink :: m_CriticalSection ) ) ;

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CDecoupledChild_IWbemObjectSink :: SetSink ( IWbemObjectSink *a_Sink ) 
{
	HRESULT t_Result = S_OK ;

	IWbemObjectSink *t_InterceptedObjectSink = NULL ;
	IWbemEventSink *t_RestrictedEventSinkObjectSink = NULL ;

	if ( SUCCEEDED ( t_Result ) )
	{
		IWbemEventSink *t_EventSink = NULL ;
		t_Result = a_Sink->QueryInterface ( IID_IWbemEventSink , ( void ** ) & t_EventSink ) ;
		if ( SUCCEEDED ( t_Result ) )
		{
			t_Result = t_EventSink->GetRestrictedSink (

				m_QueryCount ,
				m_Queries ,
				m_Callback ,
				& t_RestrictedEventSinkObjectSink
			) ;

			if ( SUCCEEDED ( t_Result ) )
			{
						t_Result = t_RestrictedEventSinkObjectSink->QueryInterface ( IID_IWbemObjectSink , ( void ** ) & t_InterceptedObjectSink ) ;
						if ( SUCCEEDED ( t_Result ) )
						{
							if ( m_SecurityDescriptor )
							{
								t_Result = t_RestrictedEventSinkObjectSink->SetSinkSecurity (

									m_SecurityDescriptorLength ,
									m_SecurityDescriptor
								) ;
							}
						}
			}

			t_EventSink->Release () ;
		}
	}

	WmiHelper :: EnterCriticalSection ( & ( CDecoupled_IWbemObjectSink :: m_CriticalSection ) ) ;

	IWbemObjectSink *t_TempInterceptedObjectSink = m_InterceptedSink ;
	IWbemEventSink *t_TempRestrictedEventSinkObjectSink = m_EventSink ;

	m_InterceptedSink = t_InterceptedObjectSink ;
	m_EventSink = t_RestrictedEventSinkObjectSink  ;

	WmiHelper :: LeaveCriticalSection ( & ( CDecoupled_IWbemObjectSink :: m_CriticalSection ) ) ;

	if ( t_TempInterceptedObjectSink )
	{
		t_TempInterceptedObjectSink->Release () ;
	}

	if ( t_TempRestrictedEventSinkObjectSink )
	{
		t_TempRestrictedEventSinkObjectSink->Release () ;
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

#pragma warning( disable : 4355 )

CDecoupledChild_IWbemObjectSink :: CDecoupledChild_IWbemObjectSink (

	CDecoupledRoot_IWbemObjectSink *a_RootSink
	
) : Decoupled_ObjectSinkContainerElement ( 

		a_RootSink ,
		this
	) ,
 	m_RootSink ( a_RootSink )
{
	m_RootSink->AddRef () ;
}

#pragma warning( default : 4355 )


/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

CDecoupledChild_IWbemObjectSink :: ~CDecoupledChild_IWbemObjectSink ()
{
	m_RootSink->Release () ;

	if ( m_Queries )
	{
		for ( long t_Index = 0 ; t_Index < m_QueryCount ; t_Index ++ )
		{
			SysFreeString ( m_Queries [ t_Index ] ) ;
		}

		delete [] m_Queries ;
		m_Queries = NULL ;
	}

	if ( m_Callback )
	{
		m_Callback->Release () ;
	}
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

STDMETHODIMP_( ULONG ) CDecoupledChild_IWbemObjectSink :: AddRef () 
{
	return Decoupled_ObjectSinkContainerElement :: AddRef () ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

STDMETHODIMP_( ULONG ) CDecoupledChild_IWbemObjectSink :: Release ()
{
	return Decoupled_ObjectSinkContainerElement :: Release () ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CDecoupledChild_IWbemObjectSink :: SinkInitialize (

	long a_QueryCount ,
	const LPCWSTR *a_Queries ,
	IUnknown *a_Callback
) 
{
	HRESULT t_Result = S_OK ;

	if ( m_Callback )
	{
		m_Callback->Release () ;
	}

	m_Callback = a_Callback ;
	if ( m_Callback )
	{
		m_Callback->AddRef () ;
	}

	if ( m_Queries )
	{
		for ( long t_Index = 0 ; t_Index < m_QueryCount ; t_Index ++ )
		{
			SysFreeString ( m_Queries [ t_Index ] ) ;
		}

		delete [] m_Queries ;
		m_Queries = NULL ;
	}

	m_QueryCount = a_QueryCount ;
	if ( a_Queries )
	{
		m_Queries = new wchar_t * [ m_QueryCount ] ;
		if ( m_Queries )
		{
			for ( long t_Index = 0 ; t_Index < m_QueryCount ; t_Index ++ )
			{
				m_Queries [ t_Index ] = NULL ;
			}

			for ( t_Index = 0 ; t_Index < m_QueryCount ; t_Index ++ )
			{
				try
				{
					m_Queries [ t_Index ] = SysAllocString ( a_Queries [ t_Index ] ) ;
					if ( m_Queries [ t_Index ] )
					{
					}
					else
					{
						t_Result = WBEM_E_OUT_OF_MEMORY ;
						break ;
					}
				}
				catch ( ... )
				{
					t_Result = WBEM_E_CRITICAL_ERROR ;
					break ;
				}
			}
		}
		else
		{
			t_Result = WBEM_E_OUT_OF_MEMORY ;
		}
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT STDMETHODCALLTYPE CDecoupledChild_IWbemObjectSink :: GetRestrictedSink (

	long a_QueryCount ,
    const LPCWSTR *a_Queries ,
    IUnknown *a_Callback ,
    IWbemEventSink **a_Sink
)
{
	return m_RootSink->GetRestrictedSink (

		a_QueryCount ,
		a_Queries ,
		a_Callback ,
		a_Sink
	) ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

STDMETHODIMP_( ULONG ) CDecoupledRoot_IWbemObjectSink :: AddRef ()
{
	ULONG t_ReferenceCount = InterlockedIncrement ( & m_ReferenceCount ) ;
	return t_ReferenceCount ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

STDMETHODIMP_(ULONG) CDecoupledRoot_IWbemObjectSink :: Release ()
{
	ULONG t_ReferenceCount = InterlockedDecrement ( & m_ReferenceCount ) ;
	if ( t_ReferenceCount == 0 )
	{
		delete this ;

		return 0 ;
	}
	else
	{
		return t_ReferenceCount ;
	}
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CDecoupledRoot_IWbemObjectSink :: GetRestrictedSink (

	long a_QueryCount ,
    const LPCWSTR *a_Queries ,
    IUnknown *a_Callback ,
    IWbemEventSink **a_Sink
)
{
	HRESULT t_Result = S_OK ;

	try
	{
		if ( a_Sink )
		{
			*a_Sink = NULL ;
		}
		else
		{
			t_Result = WBEM_E_INVALID_PARAMETER ;
		}

		if ( SUCCEEDED ( t_Result ) )
		{
			InterlockedIncrement ( & m_InProgress ) ;

			try
			{
				if ( m_GateClosed == 1 )
				{
					t_Result = WBEM_E_SHUTTING_DOWN ;
				}
				else
				{
					WmiHelper :: EnterCriticalSection ( & ( CDecoupled_IWbemObjectSink :: m_CriticalSection ) ) ;

					IWbemEventSink *t_ObjectSink = m_EventSink ;
					if ( t_ObjectSink )
					{
						t_ObjectSink->AddRef () ;
					}

					WmiHelper :: LeaveCriticalSection ( & ( CDecoupled_IWbemObjectSink :: m_CriticalSection ) ) ;

					if ( t_ObjectSink )
					{
						t_Result = t_ObjectSink->GetRestrictedSink ( 

								a_QueryCount ,
								a_Queries ,
								a_Callback ,
								a_Sink
						) ;

						t_ObjectSink->Release () ;
					}
					else
					{
						CDecoupledChild_IWbemObjectSink *t_RestrictedSink = new CDecoupledChild_IWbemObjectSink ( this ) ;
						if ( t_RestrictedSink )
						{
							t_RestrictedSink->AddRef () ;

							t_Result = t_RestrictedSink->SinkInitialize (

								a_QueryCount ,
								a_Queries ,
								a_Callback
							) ;

							if ( SUCCEEDED ( t_Result ) )
							{
								Lock () ;

								CWbemGlobal_Decoupled_IWmiObjectSinkController_Container_Iterator t_Iterator ;

								WmiStatusCode t_StatusCode = Insert (
								
									*t_RestrictedSink ,
									t_Iterator
								) ;

								if ( t_StatusCode == e_StatusCode_Success )
								{
									*a_Sink = t_RestrictedSink ;
								}
								else
								{
									t_RestrictedSink->Release () ;

									t_Result = WBEM_E_OUT_OF_MEMORY ;
								}

								UnLock () ;
							}
							else
							{
								t_RestrictedSink->Release () ;
							}
						}
						else
						{
							t_Result = WBEM_E_OUT_OF_MEMORY ;
						}
					}
				}
			}
			catch ( ... )
			{
				t_Result = WBEM_E_CRITICAL_ERROR ;
			}

			InterlockedDecrement ( & m_InProgress ) ;
		}
	}
	catch ( ... )
	{
		t_Result = WBEM_E_CRITICAL_ERROR ;
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

CServerObject_ProviderEvents :: CServerObject_ProviderEvents (

	WmiAllocator &a_Allocator 

) : CServerObject_ProviderRegistrar_Base ( a_Allocator ) ,
	m_Allocator ( a_Allocator ) ,
	m_ReferenceCount ( 0 ) ,
	m_InternalReferenceCount ( 0 ) ,
	m_ObjectSink ( NULL ) ,
	m_Service ( NULL ) ,
	m_Provider ( NULL ),
	m_SinkCriticalSection (NOTHROW_LOCK)
{
	InterlockedIncrement ( & DecoupledProviderSubSystem_Globals :: s_CServerObject_ProviderEvents_ObjectsInProgress ) ;
	InterlockedIncrement ( & DecoupledProviderSubSystem_Globals :: s_ObjectsInProgress ) ;

	WmiStatusCode t_StatusCode = WmiHelper :: InitializeCriticalSection ( & m_SinkCriticalSection ) ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

CServerObject_ProviderEvents::~CServerObject_ProviderEvents ()
{
	WmiHelper :: DeleteCriticalSection ( & m_SinkCriticalSection ) ;

	if ( m_Provider ) 
	{
		m_Provider->Release () ;
	}

	if ( m_Service ) 
	{
		m_Service->Release () ;
	}

	if ( m_ObjectSink )
	{
		m_ObjectSink->Release () ;
	}

	InterlockedDecrement ( & DecoupledProviderSubSystem_Globals :: s_CServerObject_ProviderEvents_ObjectsInProgress ) ;
	InterlockedDecrement ( & DecoupledProviderSubSystem_Globals :: s_ObjectsInProgress ) ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

STDMETHODIMP CServerObject_ProviderEvents::QueryInterface (

	REFIID a_Riid , 
	LPVOID FAR *a_Void 
) 
{
	*a_Void = NULL ;

	if ( a_Riid == IID_IUnknown )
	{
		*a_Void = ( LPVOID ) this ;
	}
	else if ( a_Riid == IID_IWbemDecoupledRegistrar )
	{
		*a_Void = ( LPVOID ) ( IWbemDecoupledRegistrar * ) ( CServerObject_ProviderRegistrar_Base * ) this ;		
	}	
	else if ( a_Riid == IID_IWbemDecoupledBasicEventProvider )
	{
		*a_Void = ( LPVOID ) ( IWbemDecoupledBasicEventProvider * ) this ;		
	}	

	if ( *a_Void )
	{
		( ( LPUNKNOWN ) *a_Void )->AddRef () ;

		return ResultFromScode ( S_OK ) ;
	}
	else
	{
		return ResultFromScode ( E_NOINTERFACE ) ;
	}
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

STDMETHODIMP_( ULONG ) CServerObject_ProviderEvents :: AddRef ()
{
	ULONG t_ReferenceCount = InterlockedIncrement ( & m_ReferenceCount ) ;
	if ( t_ReferenceCount == 1 )
	{
		InternalAddRef () ;
	}

	return t_ReferenceCount ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

STDMETHODIMP_(ULONG) CServerObject_ProviderEvents :: Release ()
{
	ULONG t_ReferenceCount = InterlockedDecrement ( & m_ReferenceCount ) ;
	if ( t_ReferenceCount == 0 )
	{
		if ( m_Provider )
		{
			m_Provider->Release () ;
			m_Provider = NULL ;
		}

		InternalRelease () ;
	}

	return t_ReferenceCount ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

STDMETHODIMP_( ULONG ) CServerObject_ProviderEvents :: InternalAddRef ()
{
	return InterlockedIncrement ( & m_InternalReferenceCount ) ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

STDMETHODIMP_(ULONG) CServerObject_ProviderEvents :: InternalRelease ()
{
	ULONG t_ReferenceCount = InterlockedDecrement ( & m_InternalReferenceCount ) ;
	if ( t_ReferenceCount == 0 )
	{
		delete this ;
	}

	return t_ReferenceCount ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CServerObject_ProviderEvents :: Register (

	long a_Flags ,
	IWbemContext *a_Context ,
	LPCWSTR a_User ,
	LPCWSTR a_Locale ,
	LPCWSTR a_Scope ,
	LPCWSTR a_Registration ,
	IUnknown *a_Unknown 
) 
{
	HRESULT t_Result = S_OK ;

	if ( a_Scope == NULL || a_Registration == NULL )
	{
		return WBEM_E_INVALID_PARAMETER ;
	}

	try
	{
		WmiHelper :: EnterCriticalSection ( & m_CriticalSection ) ;

		try 
		{
			if ( m_Registered == FALSE )
			{
				IWbemLocator *t_Locator = NULL ;

				t_Result = CoCreateInstance (

					CLSID_WbemLocator ,
					NULL ,
					CLSCTX_INPROC_SERVER | CLSCTX_LOCAL_SERVER ,
					IID_IUnknown ,
					( void ** )  & t_Locator
				);

				if ( SUCCEEDED ( t_Result ) )
				{
					IWbemServices *t_Service = NULL ;

					BSTR t_Namespace = SysAllocString ( a_Scope ) ;
					if ( t_Namespace )
					{
						t_Result = t_Locator->ConnectServer (

							t_Namespace ,
							NULL ,
							NULL,
							NULL ,
							0 ,
							NULL,
							NULL,
							&t_Service
						) ;

						if ( SUCCEEDED ( t_Result ) )
						{
							m_Service = t_Service ;
						}

						SysFreeString ( t_Namespace ) ;
					}
					else
					{
						t_Result = WBEM_E_OUT_OF_MEMORY ;
					}

					t_Locator->Release () ;
				}

				if ( SUCCEEDED ( t_Result ) ) 
				{
					WmiHelper :: EnterCriticalSection ( & m_SinkCriticalSection ) ;

					m_ObjectSink = new CDecoupledRoot_IWbemObjectSink ( m_Allocator ) ;
					if ( m_ObjectSink )
					{
						m_ObjectSink->AddRef () ;
						t_Result = m_ObjectSink->SinkInitialize () ;
						if ( SUCCEEDED ( t_Result ) ) 
						{
						}
						else
						{
							m_ObjectSink->Release ();
							m_ObjectSink = NULL ;
						}
					}
					else
					{
						t_Result = WBEM_E_OUT_OF_MEMORY ;
					}

					WmiHelper :: LeaveCriticalSection ( & m_SinkCriticalSection ) ;
				}

				if ( SUCCEEDED ( t_Result ) ) 
				{
					m_Provider = new CEventProvider (

						m_Allocator ,
						this ,
						a_Unknown 
					) ;

					if ( m_Provider )
					{
						m_Provider->AddRef () ;

						t_Result = m_Provider->Initialize () ;
						if ( SUCCEEDED ( t_Result ) )
						{
							IUnknown *t_Unknown = NULL ;
							t_Result = m_Provider->QueryInterface ( IID_IUnknown , ( void ** ) & t_Unknown ) ;
							if ( SUCCEEDED ( t_Result ) )
							{
								t_Result = CServerObject_ProviderRegistrar_Base :: Register ( 

									a_Flags ,
									a_Context ,
									a_User ,
									a_Locale ,
									a_Scope ,
									a_Registration ,
									t_Unknown
								) ;

								t_Unknown->Release () ;
							}
						}
					}
					else
					{
						t_Result = WBEM_E_OUT_OF_MEMORY ;
					}
				}

				if ( FAILED ( t_Result ) )
				{
					WmiHelper :: EnterCriticalSection ( & m_SinkCriticalSection ) ;

					if ( m_ObjectSink )
					{
						m_ObjectSink->Release () ;
						m_ObjectSink = NULL ;
					}

					WmiHelper :: LeaveCriticalSection ( & m_SinkCriticalSection ) ;

					if ( m_Provider )
					{
						m_Provider->Release () ;
						m_Provider = NULL ;
					}

					if ( m_Service ) 
					{
						m_Service->Release () ;
						m_Service = NULL ;
					}
				}
			}
			else
			{
				t_Result = WBEM_E_FAILED ;
			}
		}
		catch ( ... )
		{
			t_Result = WBEM_E_CRITICAL_ERROR ;
		}

		WmiHelper :: LeaveCriticalSection ( & m_CriticalSection ) ;
	}
	catch ( ... )
	{
		t_Result = WBEM_E_CRITICAL_ERROR ;
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CServerObject_ProviderEvents :: UnRegister ()
{
	HRESULT t_Result = S_OK ;

	try
	{
		WmiHelper :: EnterCriticalSection ( & m_CriticalSection ) ;

		try 
		{
			if ( m_Registered )
			{
				t_Result = CServerObject_ProviderRegistrar_Base :: UnRegister () ; 

				if ( m_Provider ) 
				{
					m_Provider->UnRegister () ;
					m_Provider->Release () ;
					m_Provider = NULL ;
				}

				if ( m_Service )
				{
					m_Service->Release () ;
					m_Service = NULL ;
				}

				if ( m_ObjectSink )
				{
					m_ObjectSink->Release () ;
					m_ObjectSink = NULL ;
				}
			}
			else
			{
				t_Result = WBEM_E_PROVIDER_NOT_REGISTERED ;
			}
		}
		catch ( ... )
		{
			t_Result = WBEM_E_CRITICAL_ERROR ;
		}

		WmiHelper :: LeaveCriticalSection ( & m_CriticalSection ) ;
	}
	catch ( ... )
	{
		t_Result = WBEM_E_CRITICAL_ERROR ;
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CServerObject_ProviderEvents :: GetSink (

	long a_Flags ,
	IWbemContext *a_Context ,
	IWbemObjectSink **a_Sink
) 
{
	HRESULT t_Result = S_OK ;

	try
	{
		WmiHelper :: EnterCriticalSection ( & m_CriticalSection ) ;

		try 
		{
			if ( m_Registered )
			{
				if ( a_Sink )
				{	
					*a_Sink = m_ObjectSink ;
					m_ObjectSink->AddRef () ;
				}
				else
				{
					t_Result = WBEM_E_INVALID_PARAMETER ;
				}
			}
			else
			{
				t_Result = WBEM_E_PROVIDER_NOT_REGISTERED ;
			}
		}
		catch ( ... )
		{
			t_Result = WBEM_E_CRITICAL_ERROR ;
		}

		WmiHelper :: LeaveCriticalSection ( & m_CriticalSection ) ;
	}
	catch ( ... )
	{
		t_Result = WBEM_E_CRITICAL_ERROR ;
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CServerObject_ProviderEvents :: GetService (

	long a_Flags ,
	IWbemContext *a_Context ,
	IWbemServices **a_Service
) 
{
	HRESULT t_Result = S_OK ;

	try
	{
		WmiHelper :: EnterCriticalSection ( & m_CriticalSection ) ;

		try
		{
			if ( m_Registered )
			{
				if ( a_Service )
				{	
					*a_Service = m_Service ;
					m_Service->AddRef () ;
				}
				else
				{
					t_Result = WBEM_E_INVALID_PARAMETER ;
				}
			}
			else
			{
				t_Result = WBEM_E_PROVIDER_NOT_REGISTERED ;
			}
		}
		catch ( ... )
		{
			t_Result = WBEM_E_CRITICAL_ERROR ;
		}

		WmiHelper :: LeaveCriticalSection ( & m_CriticalSection ) ;
	}
	catch ( ... )
	{
		t_Result = WBEM_E_CRITICAL_ERROR ;
	}

	return t_Result ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\provsubsys\decoupledclient\provinterceptor.cpp ===
/*++

Copyright (C) 1996-2001 Microsoft Corporation

Module Name:

	XXXX

Abstract:


History:

--*/

#include "PreComp.h"

#include <wbemint.h>
#include <stdio.h>
#include "CGlobals.h"
#include "Globals.h"
#include "ProvInterceptor.h"

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

#pragma warning( disable : 4355 )

CInterceptor_IWbemDecoupledUnboundObjectSink :: CInterceptor_IWbemDecoupledUnboundObjectSink (

	WmiAllocator &a_Allocator ,
	IUnknown *a_ServerSideProvider , 
	CWbemGlobal_IWmiObjectSinkController *a_Controller ,
	CServerObject_ProviderRegistrationV1 &a_Registration

) :	VoidPointerContainerElement (

		a_Controller ,
		this 
	) ,
	m_Allocator ( a_Allocator ) ,
	m_Unknown ( NULL ) ,
	m_Provider_IWbemUnboundObjectSink ( NULL ) ,
	m_Registration ( & a_Registration ) ,
	m_ProxyContainer ( a_Allocator , ProxyIndex_UnBoundSync_Size , MAX_PROXIES )
{
	InterlockedIncrement ( & DecoupledProviderSubSystem_Globals :: s_CInterceptor_IWbemDecoupledUnboundObjectSink_ObjectsInProgress ) ;
	InterlockedIncrement ( & DecoupledProviderSubSystem_Globals :: s_ObjectsInProgress ) ;

	if ( m_Registration )
	{
		m_Registration->AddRef () ;
	}

	if ( a_ServerSideProvider ) 
	{
		m_Unknown = a_ServerSideProvider ;
		m_Unknown->AddRef () ;

		HRESULT t_Result = a_ServerSideProvider->QueryInterface ( IID_IWbemUnboundObjectSink , ( void ** ) & m_Provider_IWbemUnboundObjectSink ) ;
	}
}

#pragma warning( default : 4355 )

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

CInterceptor_IWbemDecoupledUnboundObjectSink :: ~CInterceptor_IWbemDecoupledUnboundObjectSink ()
{
	if ( m_Unknown )
	{
		m_Unknown->Release () ;
	}

	if ( m_Provider_IWbemUnboundObjectSink )
	{
		m_Provider_IWbemUnboundObjectSink->Release () ;
	}

	if ( m_Registration )
	{
		m_Registration->Release () ;
	}

	WmiStatusCode t_StatusCode = m_ProxyContainer.UnInitialize () ;

	InterlockedDecrement ( & DecoupledProviderSubSystem_Globals :: s_CInterceptor_IWbemDecoupledUnboundObjectSink_ObjectsInProgress ) ;
	InterlockedDecrement ( & DecoupledProviderSubSystem_Globals :: s_ObjectsInProgress ) ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_IWbemDecoupledUnboundObjectSink :: Initialize ()
{
	HRESULT t_Result = S_OK ;

	WmiStatusCode t_StatusCode = m_ProxyContainer.Initialize () ;
	if ( t_StatusCode != e_StatusCode_Success ) 
	{
		t_Result = WBEM_E_OUT_OF_MEMORY ;
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

STDMETHODIMP_( ULONG ) CInterceptor_IWbemDecoupledUnboundObjectSink :: AddRef ()
{
	return VoidPointerContainerElement :: AddRef () ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

STDMETHODIMP_(ULONG) CInterceptor_IWbemDecoupledUnboundObjectSink :: Release ()
{
	return VoidPointerContainerElement :: Release () ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

STDMETHODIMP CInterceptor_IWbemDecoupledUnboundObjectSink :: QueryInterface (

	REFIID iid , 
	LPVOID FAR *iplpv 
) 
{
	*iplpv = NULL ;

	if ( iid == IID_IUnknown )
	{
		*iplpv = ( LPVOID ) this ;
	}
	else if ( iid == IID_IWbemUnboundObjectSink )
	{
		if ( m_Provider_IWbemUnboundObjectSink )
		{
			*iplpv = ( LPVOID ) ( IWbemUnboundObjectSink * ) this ;
		}
	}
	else if ( iid == IID_Internal_IWbemUnboundObjectSink )
	{
		if ( m_Provider_IWbemUnboundObjectSink )
		{
			*iplpv = ( LPVOID ) ( Internal_IWbemUnboundObjectSink * ) this ;
		}
	}
	else if ( iid == IID__IWmiProviderSite )
	{
		*iplpv = ( LPVOID ) ( _IWmiProviderSite * ) this ;		
	}
	else if ( iid == IID_IWbemShutdown )
	{
		*iplpv = ( LPVOID ) ( IWbemShutdown * ) this ;		
	}

	if ( *iplpv )
	{
		( ( LPUNKNOWN ) *iplpv )->AddRef () ;

		return ResultFromScode ( S_OK ) ;
	}
	else
	{
		return ResultFromScode ( E_NOINTERFACE ) ;
	}
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_IWbemDecoupledUnboundObjectSink :: Internal_IndicateToConsumer (

	WmiInternalContext a_InternalContext ,
	IWbemClassObject *a_LogicalConsumer ,
	long a_ObjectCount ,
	IWbemClassObject **a_Objects
)
{
	BOOL t_Impersonating = FALSE ;
	IUnknown *t_OldContext = NULL ;
	IServerSecurity *t_OldSecurity = NULL ;

	HRESULT t_Result = DecoupledProviderSubSystem_Globals :: Begin_IdentifyCall_PrvHost (

		a_InternalContext ,
		t_Impersonating ,
		t_OldContext ,
		t_OldSecurity
	) ;

	if ( SUCCEEDED ( t_Result ) )
	{
		t_Result = IndicateToConsumer (


			a_LogicalConsumer ,
			a_ObjectCount ,
			a_Objects
		) ;

		DecoupledProviderSubSystem_Globals :: End_IdentifyCall_PrvHost ( a_InternalContext , t_OldContext , t_OldSecurity , t_Impersonating ) ;
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_IWbemDecoupledUnboundObjectSink :: IndicateToConsumer (

	IWbemClassObject *a_LogicalConsumer ,
	long a_ObjectCount ,
	IWbemClassObject **a_Objects
)
{
	if ( m_Provider_IWbemUnboundObjectSink )
	{
		BOOL t_Impersonating = FALSE ;
		IUnknown *t_OldContext = NULL ;
		IServerSecurity *t_OldSecurity = NULL ;

		HRESULT t_Result = ProviderSubSystem_Common_Globals :: BeginImpersonation ( t_OldContext , t_OldSecurity , t_Impersonating ) ;
		if ( SUCCEEDED ( t_Result ) ) 
		{
			BOOL t_Revert = FALSE ;
			IUnknown *t_Proxy = NULL ;

			t_Result = ProviderSubSystem_Common_Globals :: SetProxyState ( m_ProxyContainer , ProxyIndex_UnBoundSync_IWbemUnboundObjectSink , IID_IWbemUnboundObjectSink , m_Provider_IWbemUnboundObjectSink , t_Proxy , t_Revert ) ;
			if ( t_Result == WBEM_E_NOT_FOUND )
			{
				t_Result = m_Provider_IWbemUnboundObjectSink->IndicateToConsumer (


					a_LogicalConsumer ,
					a_ObjectCount ,
					a_Objects
				) ;
			}
			else 
			{
				if ( SUCCEEDED ( t_Result ) )
				{
					IWbemUnboundObjectSink *t_Provider = ( IWbemUnboundObjectSink * ) t_Proxy ;

					// Set cloaking on the proxy
					// =========================

					DWORD t_ImpersonationLevel = ProviderSubSystem_Common_Globals :: GetCurrentImpersonationLevel () ;

					t_Result = ProviderSubSystem_Common_Globals :: SetCloaking (

						t_Provider ,
						RPC_C_AUTHN_LEVEL_CONNECT , 
						t_ImpersonationLevel
					) ;

					if ( SUCCEEDED ( t_Result ) )
					{
						t_Result = t_Provider->IndicateToConsumer (

							a_LogicalConsumer ,
							a_ObjectCount ,
							a_Objects
						) ;
					}

					HRESULT t_TempResult = ProviderSubSystem_Common_Globals :: RevertProxyState ( m_ProxyContainer , ProxyIndex_UnBoundSync_IWbemUnboundObjectSink , t_Proxy , t_Revert ) ;
				}
			}

			ProviderSubSystem_Common_Globals :: EndImpersonation ( t_OldContext , t_OldSecurity , t_Impersonating ) ;
		}

		return t_Result ;
	}

	return WBEM_E_PROVIDER_NOT_CAPABLE;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_IWbemDecoupledUnboundObjectSink :: GetSite ( DWORD *a_ProcessIdentifier )
{
	HRESULT t_Result = S_OK ;

	if ( a_ProcessIdentifier ) 
	{
		*a_ProcessIdentifier = GetCurrentProcessId () ;
	}
	else
	{
		t_Result = WBEM_E_INVALID_PARAMETER ;
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_IWbemDecoupledUnboundObjectSink :: SetContainer ( IUnknown *a_Container )
{
	return WBEM_E_NOT_AVAILABLE ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_IWbemDecoupledUnboundObjectSink :: Shutdown (

		LONG a_Flags ,
		ULONG a_MaxMilliSeconds ,
		IWbemContext *a_Context
)
{
	return S_OK ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

#pragma warning( disable : 4355 )

CDecoupled_IWbemSyncObjectSink :: CDecoupled_IWbemSyncObjectSink (

	WmiAllocator &a_Allocator ,
	IWbemObjectSink *a_InterceptedSink ,
	IUnknown *a_Unknown ,
	CWbemGlobal_IWmiObjectSinkController *a_Controller ,
	ULONG a_Dependant 

)	: CCommon_IWbemSyncObjectSink ( 

		a_Allocator ,
		a_InterceptedSink ,
		a_Unknown ,
		a_Controller ,
		a_Dependant 
	) 
{
	InterlockedIncrement ( & DecoupledProviderSubSystem_Globals :: s_CDecoupled_IWbemSyncObjectSink_ObjectsInProgress ) ;
	InterlockedIncrement ( & DecoupledProviderSubSystem_Globals :: s_ObjectsInProgress ) ;
}

#pragma warning( default : 4355 )

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

CDecoupled_IWbemSyncObjectSink :: ~CDecoupled_IWbemSyncObjectSink ()
{
	InterlockedDecrement ( & DecoupledProviderSubSystem_Globals :: s_CDecoupled_IWbemSyncObjectSink_ObjectsInProgress ) ;
	InterlockedDecrement ( & DecoupledProviderSubSystem_Globals :: s_ObjectsInProgress ) ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

#pragma warning( disable : 4355 )

CDecoupled_Batching_IWbemSyncObjectSink :: CDecoupled_Batching_IWbemSyncObjectSink (

	WmiAllocator &a_Allocator ,
	IWbemObjectSink *a_InterceptedSink ,
	IUnknown *a_Unknown ,
	CWbemGlobal_IWmiObjectSinkController *a_Controller ,
	ULONG a_Dependant 

)	: CCommon_Batching_IWbemSyncObjectSink ( 

		a_Allocator ,
		a_InterceptedSink ,
		a_Unknown ,
		a_Controller ,
		a_Dependant 
	) 
{
	InterlockedIncrement ( & DecoupledProviderSubSystem_Globals :: s_CDecoupled_Batching_IWbemSyncObjectSink_ObjectsInProgress ) ;
	InterlockedIncrement ( & DecoupledProviderSubSystem_Globals :: s_ObjectsInProgress ) ;
}

#pragma warning( default : 4355 )

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

CDecoupled_Batching_IWbemSyncObjectSink :: ~CDecoupled_Batching_IWbemSyncObjectSink ()
{
	InterlockedDecrement ( & DecoupledProviderSubSystem_Globals :: s_CDecoupled_Batching_IWbemSyncObjectSink_ObjectsInProgress ) ;
	InterlockedDecrement ( & DecoupledProviderSubSystem_Globals :: s_ObjectsInProgress ) ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

#pragma warning( disable : 4355 )

CInterceptor_DecoupledClient :: CInterceptor_DecoupledClient (

	WmiAllocator &a_Allocator ,
	IUnknown *a_ServerSideProvider , 
	IWbemServices *a_CoreStub ,
	CServerObject_ProviderRegistrationV1 &a_Registration

) :	m_ReferenceCount ( 0 ) ,
	m_Allocator ( a_Allocator ) ,
	CWbemGlobal_IWmiObjectSinkController ( a_Allocator ) ,
	m_Unknown ( NULL ) ,
	m_Provider_IWbemServices ( NULL ) ,
	m_Provider_IWbemPropertyProvider ( NULL ) ,
	m_Provider_IWbemEventProvider ( NULL ) ,
	m_Provider_IWbemEventProviderQuerySink ( NULL ) ,
	m_Provider_IWbemEventProviderSecurity ( NULL ) ,
	m_Provider_IWbemEventConsumerProvider ( NULL ) ,
	m_Provider_IWbemEventConsumerProviderEx ( NULL ) ,
	m_Provider_IWbemUnboundObjectSink ( NULL ) ,
	m_CoreStub ( a_CoreStub ) ,
	m_Registration ( & a_Registration ) ,
	m_Locale ( NULL ) ,
	m_User ( NULL ) ,
	m_Namespace ( NULL ) ,
	m_ProxyContainer ( a_Allocator , ProxyIndex_Provider_Size , MAX_PROXIES )
{
	InterlockedIncrement ( & DecoupledProviderSubSystem_Globals :: s_CInterceptor_DecoupledClient_ObjectsInProgress ) ;
	InterlockedIncrement ( & DecoupledProviderSubSystem_Globals :: s_ObjectsInProgress ) ;

	if ( m_Registration )
	{
		m_Registration->AddRef () ;
	}

	if ( a_ServerSideProvider ) 
	{
		m_Unknown = a_ServerSideProvider ;
		m_Unknown->AddRef () ;

		HRESULT t_Result = a_ServerSideProvider->QueryInterface ( IID_IWbemServices , ( void ** ) & m_Provider_IWbemServices ) ;
		t_Result = a_ServerSideProvider->QueryInterface ( IID_IWbemPropertyProvider , ( void ** ) & m_Provider_IWbemPropertyProvider ) ;
		t_Result = a_ServerSideProvider->QueryInterface ( IID_IWbemEventProvider , ( void ** ) & m_Provider_IWbemEventProvider ) ;
		t_Result = a_ServerSideProvider->QueryInterface ( IID_IWbemEventProviderQuerySink , ( void ** ) & m_Provider_IWbemEventProviderQuerySink ) ;
		t_Result = a_ServerSideProvider->QueryInterface ( IID_IWbemEventProviderSecurity , ( void ** ) & m_Provider_IWbemEventProviderSecurity ) ;
		t_Result = a_ServerSideProvider->QueryInterface ( IID_IWbemEventConsumerProviderEx , ( void ** ) & m_Provider_IWbemEventConsumerProviderEx ) ;
		t_Result = a_ServerSideProvider->QueryInterface ( IID_IWbemEventConsumerProvider , ( void ** ) & m_Provider_IWbemEventConsumerProvider ) ;
		t_Result = a_ServerSideProvider->QueryInterface ( IID_IWbemUnboundObjectSink , ( void ** ) & m_Provider_IWbemUnboundObjectSink ) ;
	}

	if ( m_CoreStub )
	{
		m_CoreStub->AddRef () ;
	}
}

#pragma warning( default : 4355 )

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

CInterceptor_DecoupledClient :: ~CInterceptor_DecoupledClient ()
{
	if ( m_Unknown )
	{
		m_Unknown->Release () ;
	}

	if ( m_Provider_IWbemServices )
	{
		m_Provider_IWbemServices->Release () ; 
	}

	if ( m_Provider_IWbemPropertyProvider )
	{
		m_Provider_IWbemPropertyProvider->Release () ; 
	}

	if ( m_Provider_IWbemEventProvider )
	{
		m_Provider_IWbemEventProvider->Release () ;
	}

	if ( m_Provider_IWbemEventProviderQuerySink )
	{
		m_Provider_IWbemEventProviderQuerySink->Release () ;
	}

	if ( m_Provider_IWbemEventProviderSecurity )
	{
		m_Provider_IWbemEventProviderSecurity->Release () ;
	}

	if ( m_Provider_IWbemEventConsumerProviderEx )
	{
		m_Provider_IWbemEventConsumerProviderEx->Release () ;
	}

	if ( m_Provider_IWbemEventConsumerProvider )
	{
		m_Provider_IWbemEventConsumerProvider->Release () ;
	}

	if ( m_Provider_IWbemUnboundObjectSink )
	{
		m_Provider_IWbemUnboundObjectSink->Release () ;
	}

	if ( m_CoreStub )
	{
		m_CoreStub->Release () ;
	}

	WmiStatusCode t_StatusCode = m_ProxyContainer.UnInitialize () ;

	t_StatusCode = CWbemGlobal_IWmiObjectSinkController :: UnInitialize () ;

	if ( m_Namespace ) 
	{
		SysFreeString ( m_Namespace ) ;
	}

	if ( m_Locale ) 
	{
		SysFreeString ( m_Locale ) ;
	}

	if ( m_User ) 
	{
		SysFreeString ( m_User ) ;
	}

	if ( m_Registration )
	{
		m_Registration->Release () ;
	}

	InterlockedDecrement ( & DecoupledProviderSubSystem_Globals :: s_CInterceptor_DecoupledClient_ObjectsInProgress ) ;
	InterlockedDecrement ( & DecoupledProviderSubSystem_Globals :: s_ObjectsInProgress ) ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

STDMETHODIMP_( ULONG ) CInterceptor_DecoupledClient :: AddRef ()
{
	return InterlockedIncrement ( & m_ReferenceCount ) ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

STDMETHODIMP_(ULONG) CInterceptor_DecoupledClient :: Release ()
{
	ULONG t_ReferenceCount = InterlockedDecrement ( & m_ReferenceCount ) ;
	if ( t_ReferenceCount == 0 )
	{
		delete this ;
	}

	return t_ReferenceCount ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

STDMETHODIMP CInterceptor_DecoupledClient :: QueryInterface (

	REFIID a_Riid , 
	LPVOID FAR *a_Void 
) 
{
	*a_Void = NULL ;

	if ( a_Riid == IID_IUnknown )
	{
		*a_Void = ( LPVOID ) this ;
	}
	if ( a_Riid == IID_IWbemProviderInit )
	{
		*a_Void = ( LPVOID ) ( IWbemProviderInit * ) this ;
	}
	if ( a_Riid == IID_Internal_IWbemProviderInit )
	{
		*a_Void = ( LPVOID ) ( Internal_IWbemProviderInit * ) this ;
	}
	else if ( a_Riid == IID_IWbemServices )
	{
		if ( m_Provider_IWbemServices )
		{
			*a_Void = ( LPVOID ) ( IWbemServices * ) this ;
		}
	}
	else if ( a_Riid == IID_IWbemPropertyProvider )
	{
		if ( m_Provider_IWbemPropertyProvider )
		{
			*a_Void = ( LPVOID ) ( IWbemPropertyProvider * ) this ;
		}
	}	
	else if ( a_Riid == IID_IWbemEventProvider )
	{
		if ( m_Provider_IWbemEventProvider )
		{
			*a_Void = ( LPVOID ) ( IWbemEventProvider * ) this ;
		}
	}
	else if ( a_Riid == IID_IWbemEventProviderQuerySink )
	{
		if ( m_Provider_IWbemEventProviderQuerySink )
		{
			*a_Void = ( LPVOID ) ( IWbemEventProviderQuerySink * ) this ;
		}
	}
	else if ( a_Riid == IID_IWbemEventProviderSecurity )
	{
		if ( m_Provider_IWbemEventProviderSecurity )
		{
			*a_Void = ( LPVOID ) ( IWbemEventProviderSecurity * ) this ;
		}
	}
	else if ( a_Riid == IID_IWbemEventConsumerProvider )
	{
		if ( m_Provider_IWbemEventConsumerProvider )
		{
			*a_Void = ( LPVOID ) ( IWbemEventConsumerProvider * ) this ;
		}
	}
	else if ( a_Riid == IID_IWbemEventConsumerProviderEx )
	{
		if ( m_Provider_IWbemEventConsumerProviderEx )
		{
			*a_Void = ( LPVOID ) ( IWbemEventConsumerProviderEx  * ) this ;
		}
	}
	else if ( a_Riid == IID_IWbemUnboundObjectSink )
	{
		if ( m_Provider_IWbemUnboundObjectSink )
		{
			*a_Void = ( LPVOID ) ( IWbemUnboundObjectSink * ) this ;
		}
	}
	else if ( a_Riid == IID__IWmiProviderInitialize )
	{
		*a_Void = ( LPVOID ) ( _IWmiProviderInitialize * ) this ;		
	}
	else if ( a_Riid == IID__IWmiProviderSite )
	{
		*a_Void = ( LPVOID ) ( _IWmiProviderSite * ) this ;		
	}
	else if ( a_Riid == IID_IWbemShutdown )
	{
		*a_Void = ( LPVOID ) ( IWbemShutdown * ) this ;		
	}
	else if ( a_Riid == IID__IWmiProviderConfiguration )
	{
		*a_Void = ( LPVOID ) ( _IWmiProviderConfiguration * ) this ;		
	}	
	else if ( a_Riid == IID_Internal_IWbemServices )
	{
		if ( m_Provider_IWbemServices )
		{
			*a_Void = ( LPVOID ) ( Internal_IWbemServices * ) this ;
		}
	}
	else if ( a_Riid == IID_Internal_IWbemPropertyProvider )
	{
		if ( m_Provider_IWbemPropertyProvider )
		{
			*a_Void = ( LPVOID ) ( Internal_IWbemPropertyProvider * ) this ;
		}
	}	
	else if ( a_Riid == IID_Internal_IWbemEventProvider )
	{
		if ( m_Provider_IWbemEventProvider )
		{
			*a_Void = ( LPVOID ) ( Internal_IWbemEventProvider * ) this ;
		}
	}
	else if ( a_Riid == IID_Internal_IWbemEventProviderQuerySink )
	{
		if ( m_Provider_IWbemEventProviderQuerySink )
		{
			*a_Void = ( LPVOID ) ( Internal_IWbemEventProviderQuerySink * ) this ;
		}
	}
	else if ( a_Riid == IID_Internal_IWbemEventProviderSecurity )
	{
		if ( m_Provider_IWbemEventProviderSecurity )
		{
			*a_Void = ( LPVOID ) ( Internal_IWbemEventProviderSecurity * ) this ;
		}
	}
	else if ( a_Riid == IID_Internal_IWbemEventConsumerProvider )
	{
		if ( m_Provider_IWbemEventConsumerProvider )
		{
			*a_Void = ( LPVOID ) ( Internal_IWbemEventConsumerProvider * ) this ;
		}
	}
	else if ( a_Riid == IID_Internal_IWbemEventConsumerProviderEx )
	{
		if ( m_Provider_IWbemEventConsumerProviderEx )
		{
			*a_Void = ( LPVOID ) ( Internal_IWbemEventConsumerProviderEx  * ) this ;
		}
	}
	else if ( a_Riid == IID_Internal_IWbemUnboundObjectSink )
	{
		if ( m_Provider_IWbemUnboundObjectSink )
		{
			*a_Void = ( LPVOID ) ( Internal_IWbemUnboundObjectSink * ) this ;
		}
	}

	if ( *a_Void )
	{
		( ( LPUNKNOWN ) *a_Void )->AddRef () ;

		return ResultFromScode ( S_OK ) ;
	}
	else
	{
		return ResultFromScode ( E_NOINTERFACE ) ;
	}
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_DecoupledClient :: Internal_OpenNamespace ( 

	WmiInternalContext a_InternalContext ,
	const BSTR a_ObjectPath ,
	long a_Flags ,
	IWbemContext *a_Context ,
	IWbemServices **a_NamespaceService ,
	IWbemCallResult **a_CallResult
)
{
	BOOL t_Impersonating = FALSE ;
	IUnknown *t_OldContext = NULL ;
	IServerSecurity *t_OldSecurity = NULL ;

	HRESULT t_Result = DecoupledProviderSubSystem_Globals :: Begin_IdentifyCall_PrvHost (

		a_InternalContext ,
		t_Impersonating ,
		t_OldContext ,
		t_OldSecurity
	) ;

	if ( SUCCEEDED ( t_Result ) )
	{
		t_Result = OpenNamespace (

			a_ObjectPath ,
			a_Flags ,
			a_Context ,
			a_NamespaceService ,
			a_CallResult
		) ;

		DecoupledProviderSubSystem_Globals :: End_IdentifyCall_PrvHost ( a_InternalContext , t_OldContext , t_OldSecurity , t_Impersonating ) ;
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_DecoupledClient :: Internal_CancelAsyncCall ( 
	
	WmiInternalContext a_InternalContext ,		
	IWbemObjectSink *a_Sink
)
{
	BOOL t_Impersonating = FALSE ;
	IUnknown *t_OldContext = NULL ;
	IServerSecurity *t_OldSecurity = NULL ;

	HRESULT t_Result = DecoupledProviderSubSystem_Globals :: Begin_IdentifyCall_PrvHost (

		a_InternalContext ,
		t_Impersonating ,
		t_OldContext ,
		t_OldSecurity
	) ;

	if ( SUCCEEDED ( t_Result ) )
	{
		t_Result = CancelAsyncCall (
		
			a_Sink
		) ;

		DecoupledProviderSubSystem_Globals :: End_IdentifyCall_PrvHost ( a_InternalContext , t_OldContext , t_OldSecurity , t_Impersonating ) ;
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_DecoupledClient :: Internal_QueryObjectSink ( 

	WmiInternalContext a_InternalContext ,
	long a_Flags ,
	IWbemObjectSink **a_Sink
) 
{
	BOOL t_Impersonating = FALSE ;
	IUnknown *t_OldContext = NULL ;
	IServerSecurity *t_OldSecurity = NULL ;

	HRESULT t_Result = DecoupledProviderSubSystem_Globals :: Begin_IdentifyCall_PrvHost (

		a_InternalContext ,
		t_Impersonating ,
		t_OldContext ,
		t_OldSecurity
	) ;

	if ( SUCCEEDED ( t_Result ) )
	{
		t_Result = QueryObjectSink (

			a_Flags ,	
			a_Sink
		) ;

		DecoupledProviderSubSystem_Globals :: End_IdentifyCall_PrvHost ( a_InternalContext , t_OldContext , t_OldSecurity , t_Impersonating ) ;
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_DecoupledClient :: Internal_GetObject ( 
		
	WmiInternalContext a_InternalContext ,
	const BSTR a_ObjectPath ,
    long a_Flags ,
    IWbemContext *a_Context ,
    IWbemClassObject **a_Object ,
    IWbemCallResult **a_CallResult
)
{
	BOOL t_Impersonating = FALSE ;
	IUnknown *t_OldContext = NULL ;
	IServerSecurity *t_OldSecurity = NULL ;

	HRESULT t_Result = DecoupledProviderSubSystem_Globals :: Begin_IdentifyCall_PrvHost (

		a_InternalContext ,
		t_Impersonating ,
		t_OldContext ,
		t_OldSecurity
	) ;

	if ( SUCCEEDED ( t_Result ) )
	{
		t_Result = GetObject (

			a_ObjectPath ,
			a_Flags ,
			a_Context ,
			a_Object ,
			a_CallResult
		) ;

		DecoupledProviderSubSystem_Globals :: End_IdentifyCall_PrvHost ( a_InternalContext , t_OldContext , t_OldSecurity , t_Impersonating ) ;
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_DecoupledClient :: Internal_GetObjectAsync ( 
		
	WmiInternalContext a_InternalContext ,
	const BSTR a_ObjectPath ,
	long a_Flags , 
	IWbemContext *a_Context ,
	IWbemObjectSink *a_Sink
) 
{
	BOOL t_Impersonating = FALSE ;
	IUnknown *t_OldContext = NULL ;
	IServerSecurity *t_OldSecurity = NULL ;

	HRESULT t_Result = DecoupledProviderSubSystem_Globals :: Begin_IdentifyCall_PrvHost (

		a_InternalContext ,
		t_Impersonating ,
		t_OldContext ,
		t_OldSecurity
	) ;

	if ( SUCCEEDED ( t_Result ) )
	{
		t_Result = GetObjectAsync (

			a_ObjectPath ,
			a_Flags , 
			a_Context ,
			a_Sink
		) ;

		DecoupledProviderSubSystem_Globals :: End_IdentifyCall_PrvHost ( a_InternalContext , t_OldContext , t_OldSecurity , t_Impersonating ) ;
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_DecoupledClient :: Internal_PutClass ( 

	WmiInternalContext a_InternalContext ,		
	IWbemClassObject *a_Object ,
	long a_Flags , 
	IWbemContext *a_Context ,
	IWbemCallResult **a_CallResult
) 
{
	BOOL t_Impersonating = FALSE ;
	IUnknown *t_OldContext = NULL ;
	IServerSecurity *t_OldSecurity = NULL ;

	HRESULT t_Result = DecoupledProviderSubSystem_Globals :: Begin_IdentifyCall_PrvHost (

		a_InternalContext ,
		t_Impersonating ,
		t_OldContext ,
		t_OldSecurity
	) ;

	if ( SUCCEEDED ( t_Result ) )
	{
		t_Result = PutClass (

			a_Object ,
			a_Flags , 
			a_Context ,
			a_CallResult
		) ;

		DecoupledProviderSubSystem_Globals :: End_IdentifyCall_PrvHost ( a_InternalContext , t_OldContext , t_OldSecurity , t_Impersonating ) ;
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_DecoupledClient :: Internal_PutClassAsync ( 
		
	WmiInternalContext a_InternalContext ,
	IWbemClassObject *a_Object , 
	long a_Flags , 
	IWbemContext *a_Context ,
	IWbemObjectSink *a_Sink
) 
{
	BOOL t_Impersonating = FALSE ;
	IUnknown *t_OldContext = NULL ;
	IServerSecurity *t_OldSecurity = NULL ;

	HRESULT t_Result = DecoupledProviderSubSystem_Globals :: Begin_IdentifyCall_PrvHost (

		a_InternalContext ,
		t_Impersonating ,
		t_OldContext ,
		t_OldSecurity
	) ;

	if ( SUCCEEDED ( t_Result ) )
	{
		t_Result = PutClassAsync (

			a_Object , 
			a_Flags , 
			a_Context ,
			a_Sink
		) ;

		DecoupledProviderSubSystem_Globals :: End_IdentifyCall_PrvHost ( a_InternalContext , t_OldContext , t_OldSecurity , t_Impersonating ) ;
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_DecoupledClient :: Internal_DeleteClass ( 
		
	WmiInternalContext a_InternalContext ,
	const BSTR a_Class , 
	long a_Flags , 
	IWbemContext *a_Context ,
	IWbemCallResult **a_CallResult
) 
{
	BOOL t_Impersonating = FALSE ;
	IUnknown *t_OldContext = NULL ;
	IServerSecurity *t_OldSecurity = NULL ;

	HRESULT t_Result = DecoupledProviderSubSystem_Globals :: Begin_IdentifyCall_PrvHost (

		a_InternalContext ,
		t_Impersonating ,
		t_OldContext ,
		t_OldSecurity
	) ;

	if ( SUCCEEDED ( t_Result ) )
	{
		t_Result = DeleteClass (

			a_Class , 
			a_Flags , 
			a_Context ,
			a_CallResult
		) ;

		DecoupledProviderSubSystem_Globals :: End_IdentifyCall_PrvHost ( a_InternalContext , t_OldContext , t_OldSecurity , t_Impersonating ) ;
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_DecoupledClient :: Internal_DeleteClassAsync ( 
		
	WmiInternalContext a_InternalContext ,
	const BSTR a_Class , 
	long a_Flags , 
	IWbemContext *a_Context ,
	IWbemObjectSink *a_Sink
) 
{
	BOOL t_Impersonating = FALSE ;
	IUnknown *t_OldContext = NULL ;
	IServerSecurity *t_OldSecurity = NULL ;

	HRESULT t_Result = DecoupledProviderSubSystem_Globals :: Begin_IdentifyCall_PrvHost (

		a_InternalContext ,
		t_Impersonating ,
		t_OldContext ,
		t_OldSecurity
	) ;

	if ( SUCCEEDED ( t_Result ) )
	{
		t_Result = DeleteClassAsync (

			a_Class , 
			a_Flags , 
			a_Context ,
			a_Sink
		) ;

		DecoupledProviderSubSystem_Globals :: End_IdentifyCall_PrvHost ( a_InternalContext , t_OldContext , t_OldSecurity , t_Impersonating ) ;
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_DecoupledClient :: Internal_CreateClassEnum ( 

	WmiInternalContext a_InternalContext ,
	const BSTR a_SuperClass ,
	long a_Flags, 
	IWbemContext *a_Context ,
	IEnumWbemClassObject **a_Enum
) 
{
	BOOL t_Impersonating = FALSE ;
	IUnknown *t_OldContext = NULL ;
	IServerSecurity *t_OldSecurity = NULL ;

	HRESULT t_Result = DecoupledProviderSubSystem_Globals :: Begin_IdentifyCall_PrvHost (

		a_InternalContext ,
		t_Impersonating ,
		t_OldContext ,
		t_OldSecurity
	) ;

	if ( SUCCEEDED ( t_Result ) )
	{
		t_Result = CreateClassEnum (

			a_SuperClass ,
			a_Flags, 
			a_Context ,
			a_Enum
		) ;

		DecoupledProviderSubSystem_Globals :: End_IdentifyCall_PrvHost ( a_InternalContext , t_OldContext , t_OldSecurity , t_Impersonating ) ;
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_DecoupledClient :: Internal_CreateClassEnumAsync ( 
		
	WmiInternalContext a_InternalContext ,
	const BSTR a_SuperClass , 
	long a_Flags , 
	IWbemContext *a_Context ,
	IWbemObjectSink *a_Sink
) 
{
	BOOL t_Impersonating = FALSE ;
	IUnknown *t_OldContext = NULL ;
	IServerSecurity *t_OldSecurity = NULL ;

	HRESULT t_Result = DecoupledProviderSubSystem_Globals :: Begin_IdentifyCall_PrvHost (

		a_InternalContext ,
		t_Impersonating ,
		t_OldContext ,
		t_OldSecurity
	) ;

	if ( SUCCEEDED ( t_Result ) )
	{
		t_Result = CreateClassEnumAsync (

			a_SuperClass ,
			a_Flags, 
			a_Context ,
			a_Sink
		) ;

		DecoupledProviderSubSystem_Globals :: End_IdentifyCall_PrvHost ( a_InternalContext , t_OldContext , t_OldSecurity , t_Impersonating ) ;
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_DecoupledClient :: Internal_PutInstance (

	WmiInternalContext a_InternalContext ,
    IWbemClassObject *a_Instance ,
    long a_Flags ,
    IWbemContext *a_Context ,
	IWbemCallResult **a_CallResult
) 
{
	BOOL t_Impersonating = FALSE ;
	IUnknown *t_OldContext = NULL ;
	IServerSecurity *t_OldSecurity = NULL ;

	HRESULT t_Result = DecoupledProviderSubSystem_Globals :: Begin_IdentifyCall_PrvHost (

		a_InternalContext ,
		t_Impersonating ,
		t_OldContext ,
		t_OldSecurity
	) ;

	if ( SUCCEEDED ( t_Result ) )
	{
		t_Result = PutInstance (

			a_Instance ,
			a_Flags ,
			a_Context ,
			a_CallResult
		) ;

		DecoupledProviderSubSystem_Globals :: End_IdentifyCall_PrvHost ( a_InternalContext , t_OldContext , t_OldSecurity , t_Impersonating ) ;
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_DecoupledClient :: Internal_PutInstanceAsync ( 

	WmiInternalContext a_InternalContext ,		
	IWbemClassObject *a_Instance , 
	long a_Flags , 
	IWbemContext *a_Context ,
	IWbemObjectSink *a_Sink
) 
{
	BOOL t_Impersonating = FALSE ;
	IUnknown *t_OldContext = NULL ;
	IServerSecurity *t_OldSecurity = NULL ;

	HRESULT t_Result = DecoupledProviderSubSystem_Globals :: Begin_IdentifyCall_PrvHost (

		a_InternalContext ,
		t_Impersonating ,
		t_OldContext ,
		t_OldSecurity
	) ;

	if ( SUCCEEDED ( t_Result ) )
	{
		t_Result = PutInstanceAsync (

			a_Instance , 
			a_Flags , 
			a_Context ,
			a_Sink
		) ;

		DecoupledProviderSubSystem_Globals :: End_IdentifyCall_PrvHost ( a_InternalContext , t_OldContext , t_OldSecurity , t_Impersonating ) ;
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_DecoupledClient :: Internal_DeleteInstance ( 

	WmiInternalContext a_InternalContext ,
	const BSTR a_ObjectPath ,
    long a_Flags ,
    IWbemContext *a_Context ,
    IWbemCallResult **a_CallResult
)
{
	BOOL t_Impersonating = FALSE ;
	IUnknown *t_OldContext = NULL ;
	IServerSecurity *t_OldSecurity = NULL ;

	HRESULT t_Result = DecoupledProviderSubSystem_Globals :: Begin_IdentifyCall_PrvHost (

		a_InternalContext ,
		t_Impersonating ,
		t_OldContext ,
		t_OldSecurity
	) ;

	if ( SUCCEEDED ( t_Result ) )
	{
		t_Result = DeleteInstance (

			a_ObjectPath ,
			a_Flags ,
			a_Context ,
			a_CallResult
		) ;

		DecoupledProviderSubSystem_Globals :: End_IdentifyCall_PrvHost ( a_InternalContext , t_OldContext , t_OldSecurity , t_Impersonating ) ;
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_DecoupledClient :: Internal_DeleteInstanceAsync ( 
		
	WmiInternalContext a_InternalContext ,
	const BSTR a_ObjectPath ,
	long a_Flags , 
	IWbemContext *a_Context ,
	IWbemObjectSink *a_Sink
) 
{
	BOOL t_Impersonating = FALSE ;
	IUnknown *t_OldContext = NULL ;
	IServerSecurity *t_OldSecurity = NULL ;

	HRESULT t_Result = DecoupledProviderSubSystem_Globals :: Begin_IdentifyCall_PrvHost (

		a_InternalContext ,
		t_Impersonating ,
		t_OldContext ,
		t_OldSecurity
	) ;

	if ( SUCCEEDED ( t_Result ) )
	{
		t_Result = DeleteInstanceAsync (

			a_ObjectPath ,
			a_Flags , 
			a_Context ,
			a_Sink
		) ;

		DecoupledProviderSubSystem_Globals :: End_IdentifyCall_PrvHost ( a_InternalContext , t_OldContext , t_OldSecurity , t_Impersonating ) ;
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_DecoupledClient :: Internal_CreateInstanceEnum ( 

	WmiInternalContext a_InternalContext ,
	const BSTR a_Class ,
	long a_Flags , 
	IWbemContext *a_Context , 
	IEnumWbemClassObject **a_Enum
)
{
	BOOL t_Impersonating = FALSE ;
	IUnknown *t_OldContext = NULL ;
	IServerSecurity *t_OldSecurity = NULL ;

	HRESULT t_Result = DecoupledProviderSubSystem_Globals :: Begin_IdentifyCall_PrvHost (

		a_InternalContext ,
		t_Impersonating ,
		t_OldContext ,
		t_OldSecurity
	) ;

	if ( SUCCEEDED ( t_Result ) )
	{
		t_Result = CreateInstanceEnum (

			a_Class ,
			a_Flags , 
			a_Context , 
			a_Enum
		) ;

		DecoupledProviderSubSystem_Globals :: End_IdentifyCall_PrvHost ( a_InternalContext , t_OldContext , t_OldSecurity , t_Impersonating ) ;
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_DecoupledClient :: Internal_CreateInstanceEnumAsync (

	WmiInternalContext a_InternalContext ,
 	const BSTR a_Class ,
	long a_Flags ,
	IWbemContext *a_Context ,
	IWbemObjectSink *a_Sink 
) 
{
	BOOL t_Impersonating = FALSE ;
	IUnknown *t_OldContext = NULL ;
	IServerSecurity *t_OldSecurity = NULL ;

	HRESULT t_Result = DecoupledProviderSubSystem_Globals :: Begin_IdentifyCall_PrvHost (

		a_InternalContext ,
		t_Impersonating ,
		t_OldContext ,
		t_OldSecurity
	) ;

	if ( SUCCEEDED ( t_Result ) )
	{
		t_Result = CreateInstanceEnumAsync (

			a_Class ,
			a_Flags ,
			a_Context ,
			a_Sink 
		) ;

		DecoupledProviderSubSystem_Globals :: End_IdentifyCall_PrvHost ( a_InternalContext , t_OldContext , t_OldSecurity , t_Impersonating ) ;
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_DecoupledClient :: Internal_ExecQuery ( 

	WmiInternalContext a_InternalContext ,
	const BSTR a_QueryLanguage ,
	const BSTR a_Query ,
	long a_Flags ,
	IWbemContext *a_Context ,
	IEnumWbemClassObject **a_Enum
)
{
	BOOL t_Impersonating = FALSE ;
	IUnknown *t_OldContext = NULL ;
	IServerSecurity *t_OldSecurity = NULL ;

	HRESULT t_Result = DecoupledProviderSubSystem_Globals :: Begin_IdentifyCall_PrvHost (

		a_InternalContext ,
		t_Impersonating ,
		t_OldContext ,
		t_OldSecurity
	) ;

	if ( SUCCEEDED ( t_Result ) )
	{
		t_Result = ExecQuery (

			a_QueryLanguage ,
			a_Query ,
			a_Flags ,
			a_Context ,
			a_Enum
		) ;

		DecoupledProviderSubSystem_Globals :: End_IdentifyCall_PrvHost ( a_InternalContext , t_OldContext , t_OldSecurity , t_Impersonating ) ;
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_DecoupledClient :: Internal_ExecQueryAsync ( 

	WmiInternalContext a_InternalContext ,		
	const BSTR a_QueryLanguage ,
	const BSTR a_Query, 
	long a_Flags , 
	IWbemContext *a_Context ,
	IWbemObjectSink *a_Sink
) 
{
	BOOL t_Impersonating = FALSE ;
	IUnknown *t_OldContext = NULL ;
	IServerSecurity *t_OldSecurity = NULL ;

	HRESULT t_Result = DecoupledProviderSubSystem_Globals :: Begin_IdentifyCall_PrvHost (

		a_InternalContext ,
		t_Impersonating ,
		t_OldContext ,
		t_OldSecurity
	) ;

	if ( SUCCEEDED ( t_Result ) )
	{
		t_Result = ExecQueryAsync (

			a_QueryLanguage ,
			a_Query, 
			a_Flags , 
			a_Context ,
			a_Sink
		) ;

		DecoupledProviderSubSystem_Globals :: End_IdentifyCall_PrvHost ( a_InternalContext , t_OldContext , t_OldSecurity , t_Impersonating ) ;
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_DecoupledClient :: Internal_ExecNotificationQuery ( 

	WmiInternalContext a_InternalContext ,
	const BSTR a_QueryLanguage ,
    const BSTR a_Query ,
    long a_Flags ,
    IWbemContext *a_Context ,
    IEnumWbemClassObject **a_Enum
)
{
	BOOL t_Impersonating = FALSE ;
	IUnknown *t_OldContext = NULL ;
	IServerSecurity *t_OldSecurity = NULL ;

	HRESULT t_Result = DecoupledProviderSubSystem_Globals :: Begin_IdentifyCall_PrvHost (

		a_InternalContext ,
		t_Impersonating ,
		t_OldContext ,
		t_OldSecurity
	) ;

	if ( SUCCEEDED ( t_Result ) )
	{
		t_Result = ExecNotificationQuery (

			a_QueryLanguage ,
			a_Query ,
			a_Flags ,
			a_Context ,
			a_Enum
		) ;

		DecoupledProviderSubSystem_Globals :: End_IdentifyCall_PrvHost ( a_InternalContext , t_OldContext , t_OldSecurity , t_Impersonating ) ;
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/
        
HRESULT CInterceptor_DecoupledClient :: Internal_ExecNotificationQueryAsync ( 

	WmiInternalContext a_InternalContext ,            
	const BSTR a_QueryLanguage ,
    const BSTR a_Query ,
    long a_Flags ,
    IWbemContext *a_Context ,
    IWbemObjectSink *a_Sink 
)
{
	BOOL t_Impersonating = FALSE ;
	IUnknown *t_OldContext = NULL ;
	IServerSecurity *t_OldSecurity = NULL ;

	HRESULT t_Result = DecoupledProviderSubSystem_Globals :: Begin_IdentifyCall_PrvHost (

		a_InternalContext ,
		t_Impersonating ,
		t_OldContext ,
		t_OldSecurity
	) ;

	if ( SUCCEEDED ( t_Result ) )
	{
		t_Result = ExecNotificationQueryAsync (

			a_QueryLanguage ,
			a_Query ,
			a_Flags ,
			a_Context ,
			a_Sink 
		) ;

		DecoupledProviderSubSystem_Globals :: End_IdentifyCall_PrvHost ( a_InternalContext , t_OldContext , t_OldSecurity , t_Impersonating ) ;
	}

	return t_Result ;
}       

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_DecoupledClient :: Internal_ExecMethod (

	WmiInternalContext a_InternalContext ,
	const BSTR a_ObjectPath ,
    const BSTR a_MethodName ,
    long a_Flags ,
    IWbemContext *a_Context ,
    IWbemClassObject *a_InParams ,
    IWbemClassObject **a_OutParams ,
    IWbemCallResult **a_CallResult
)
{
	BOOL t_Impersonating = FALSE ;
	IUnknown *t_OldContext = NULL ;
	IServerSecurity *t_OldSecurity = NULL ;

	HRESULT t_Result = DecoupledProviderSubSystem_Globals :: Begin_IdentifyCall_PrvHost (

		a_InternalContext ,
		t_Impersonating ,
		t_OldContext ,
		t_OldSecurity
	) ;

	if ( SUCCEEDED ( t_Result ) )
	{
		t_Result = ExecMethod (

			a_ObjectPath ,
			a_MethodName ,
			a_Flags ,
			a_Context ,
			a_InParams ,
			a_OutParams ,
			a_CallResult
		) ;

		DecoupledProviderSubSystem_Globals :: End_IdentifyCall_PrvHost ( a_InternalContext , t_OldContext , t_OldSecurity , t_Impersonating ) ;
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_DecoupledClient :: Internal_ExecMethodAsync ( 

	WmiInternalContext a_InternalContext ,		
    const BSTR a_ObjectPath ,
    const BSTR a_MethodName ,
    long a_Flags ,
    IWbemContext *a_Context ,
    IWbemClassObject *a_InParams ,
	IWbemObjectSink *a_Sink
) 
{
	BOOL t_Impersonating = FALSE ;
	IUnknown *t_OldContext = NULL ;
	IServerSecurity *t_OldSecurity = NULL ;

	HRESULT t_Result = DecoupledProviderSubSystem_Globals :: Begin_IdentifyCall_PrvHost (

		a_InternalContext ,
		t_Impersonating ,
		t_OldContext ,
		t_OldSecurity
	) ;

	if ( SUCCEEDED ( t_Result ) )
	{
		t_Result = ExecMethodAsync (

			a_ObjectPath ,
			a_MethodName ,
			a_Flags ,
			a_Context ,
			a_InParams ,
			a_Sink
		) ;

		DecoupledProviderSubSystem_Globals :: End_IdentifyCall_PrvHost ( a_InternalContext , t_OldContext , t_OldSecurity , t_Impersonating ) ;
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_DecoupledClient :: Internal_GetProperty (

	WmiInternalContext a_InternalContext ,
    long a_Flags ,
    const BSTR a_Locale ,
    const BSTR a_ClassMapping ,
    const BSTR a_InstanceMapping ,
    const BSTR a_PropertyMapping ,
    VARIANT *a_Value
)
{
	BOOL t_Impersonating = FALSE ;
	IUnknown *t_OldContext = NULL ;
	IServerSecurity *t_OldSecurity = NULL ;

	HRESULT t_Result = DecoupledProviderSubSystem_Globals :: Begin_IdentifyCall_PrvHost (

		a_InternalContext ,
		t_Impersonating ,
		t_OldContext ,
		t_OldSecurity
	) ;

	if ( SUCCEEDED ( t_Result ) )
	{
		t_Result = GetProperty ( 

			a_Flags ,
			a_Locale ,
			a_ClassMapping ,
			a_InstanceMapping ,
			a_PropertyMapping ,
			a_Value
		) ;

		DecoupledProviderSubSystem_Globals :: End_IdentifyCall_PrvHost ( a_InternalContext , t_OldContext , t_OldSecurity , t_Impersonating ) ;
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_DecoupledClient :: Internal_PutProperty (

	WmiInternalContext a_InternalContext ,
    long a_Flags ,
    const BSTR a_Locale ,
    const BSTR a_ClassMapping ,
    const BSTR a_InstanceMapping ,
    const BSTR a_PropertyMapping ,
    const VARIANT *a_Value
)
{
	BOOL t_Impersonating = FALSE ;
	IUnknown *t_OldContext = NULL ;
	IServerSecurity *t_OldSecurity = NULL ;

	HRESULT t_Result = DecoupledProviderSubSystem_Globals :: Begin_IdentifyCall_PrvHost (

		a_InternalContext ,
		t_Impersonating ,
		t_OldContext ,
		t_OldSecurity
	) ;

	if ( SUCCEEDED ( t_Result ) )
	{
		t_Result = PutProperty ( 

			a_Flags ,
			a_Locale ,
			a_ClassMapping ,
			a_InstanceMapping ,
			a_PropertyMapping ,
			a_Value
		) ;

		DecoupledProviderSubSystem_Globals :: End_IdentifyCall_PrvHost ( a_InternalContext , t_OldContext , t_OldSecurity , t_Impersonating ) ;
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_DecoupledClient :: Internal_ProvideEvents (

	WmiInternalContext a_InternalContext ,
	IWbemObjectSink *a_Sink ,
	long a_Flags
)
{
	BOOL t_Impersonating = FALSE ;
	IUnknown *t_OldContext = NULL ;
	IServerSecurity *t_OldSecurity = NULL ;

	HRESULT t_Result = DecoupledProviderSubSystem_Globals :: Begin_IdentifyCall_PrvHost (

		a_InternalContext ,
		t_Impersonating ,
		t_OldContext ,
		t_OldSecurity
	) ;

	if ( SUCCEEDED ( t_Result ) )
	{
		t_Result = ProvideEvents (

			a_Sink ,
			a_Flags 
		) ;

		DecoupledProviderSubSystem_Globals :: End_IdentifyCall_PrvHost ( a_InternalContext , t_OldContext , t_OldSecurity , t_Impersonating ) ;
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_DecoupledClient :: Internal_NewQuery (

	WmiInternalContext a_InternalContext ,
	unsigned long a_Id ,
	WBEM_WSTR a_QueryLanguage ,
	WBEM_WSTR a_Query
)
{
	BOOL t_Impersonating = FALSE ;
	IUnknown *t_OldContext = NULL ;
	IServerSecurity *t_OldSecurity = NULL ;

	HRESULT t_Result = DecoupledProviderSubSystem_Globals :: Begin_IdentifyCall_PrvHost (

		a_InternalContext ,
		t_Impersonating ,
		t_OldContext ,
		t_OldSecurity
	) ;

	if ( SUCCEEDED ( t_Result ) )
	{
		t_Result = NewQuery (

			a_Id ,
			a_QueryLanguage ,
			a_Query
		) ;

		DecoupledProviderSubSystem_Globals :: End_IdentifyCall_PrvHost ( a_InternalContext , t_OldContext , t_OldSecurity , t_Impersonating ) ;
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_DecoupledClient :: Internal_CancelQuery (

	WmiInternalContext a_InternalContext ,
	unsigned long a_Id
)
{
	BOOL t_Impersonating = FALSE ;
	IUnknown *t_OldContext = NULL ;
	IServerSecurity *t_OldSecurity = NULL ;

	HRESULT t_Result = DecoupledProviderSubSystem_Globals :: Begin_IdentifyCall_PrvHost (

		a_InternalContext ,
		t_Impersonating ,
		t_OldContext ,
		t_OldSecurity
	) ;

	if ( SUCCEEDED ( t_Result ) )
	{
		t_Result = CancelQuery (

			a_Id
		) ;

		DecoupledProviderSubSystem_Globals :: End_IdentifyCall_PrvHost ( a_InternalContext , t_OldContext , t_OldSecurity , t_Impersonating ) ;
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_DecoupledClient :: Internal_AccessCheck (

	WmiInternalContext a_InternalContext ,
	WBEM_CWSTR a_QueryLanguage ,
	WBEM_CWSTR a_Query ,
	long a_SidLength ,
	const BYTE *a_Sid
)
{
	BOOL t_Impersonating = FALSE ;
	IUnknown *t_OldContext = NULL ;
	IServerSecurity *t_OldSecurity = NULL ;

	HRESULT t_Result = DecoupledProviderSubSystem_Globals :: Begin_IdentifyCall_PrvHost (

		a_InternalContext ,
		t_Impersonating ,
		t_OldContext ,
		t_OldSecurity
	) ;

	if ( SUCCEEDED ( t_Result ) )
	{
		t_Result = AccessCheck (

			a_QueryLanguage ,
			a_Query ,
			a_SidLength ,
			a_Sid
		) ;

		DecoupledProviderSubSystem_Globals :: End_IdentifyCall_PrvHost ( a_InternalContext , t_OldContext , t_OldSecurity , t_Impersonating ) ;
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_DecoupledClient :: Internal_FindConsumer (

	WmiInternalContext a_InternalContext ,
	IWbemClassObject *a_LogicalConsumer ,
	IWbemUnboundObjectSink **a_Consumer
)
{
	BOOL t_Impersonating = FALSE ;
	IUnknown *t_OldContext = NULL ;
	IServerSecurity *t_OldSecurity = NULL ;

	HRESULT t_Result = DecoupledProviderSubSystem_Globals :: Begin_IdentifyCall_PrvHost (

		a_InternalContext ,
		t_Impersonating ,
		t_OldContext ,
		t_OldSecurity
	) ;

	if ( SUCCEEDED ( t_Result ) )
	{
		t_Result = FindConsumer (

			a_LogicalConsumer ,
			a_Consumer
		) ;

		DecoupledProviderSubSystem_Globals :: End_IdentifyCall_PrvHost ( a_InternalContext , t_OldContext , t_OldSecurity , t_Impersonating ) ;
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_DecoupledClient :: Internal_ValidateSubscription (

	WmiInternalContext a_InternalContext ,
	IWbemClassObject *a_LogicalConsumer
)
{
	BOOL t_Impersonating = FALSE ;
	IUnknown *t_OldContext = NULL ;
	IServerSecurity *t_OldSecurity = NULL ;

	HRESULT t_Result = DecoupledProviderSubSystem_Globals :: Begin_IdentifyCall_PrvHost (

		a_InternalContext ,
		t_Impersonating ,
		t_OldContext ,
		t_OldSecurity
	) ;

	if ( SUCCEEDED ( t_Result ) )
	{
		t_Result = ValidateSubscription (

			a_LogicalConsumer
		) ;

		DecoupledProviderSubSystem_Globals :: End_IdentifyCall_PrvHost ( a_InternalContext , t_OldContext , t_OldSecurity , t_Impersonating ) ;
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_DecoupledClient :: Internal_IndicateToConsumer (

	WmiInternalContext a_InternalContext ,
	IWbemClassObject *a_LogicalConsumer ,
	long a_ObjectCount ,
	IWbemClassObject **a_Objects
)
{
	BOOL t_Impersonating = FALSE ;
	IUnknown *t_OldContext = NULL ;
	IServerSecurity *t_OldSecurity = NULL ;

	HRESULT t_Result = DecoupledProviderSubSystem_Globals :: Begin_IdentifyCall_PrvHost (

		a_InternalContext ,
		t_Impersonating ,
		t_OldContext ,
		t_OldSecurity
	) ;

	if ( SUCCEEDED ( t_Result ) )
	{
		t_Result = IndicateToConsumer (


			a_LogicalConsumer ,
			a_ObjectCount ,
			a_Objects
		) ;

		DecoupledProviderSubSystem_Globals :: End_IdentifyCall_PrvHost ( a_InternalContext , t_OldContext , t_OldSecurity , t_Impersonating ) ;
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_DecoupledClient :: AdjustGetContext (

    IWbemContext *a_Context
)
{
    // See if per-property get are being used.
    // ========================================

    HRESULT t_Result = S_OK ;

    if ( a_Context )
	{
		VARIANT t_Variant ;
		VariantInit ( & t_Variant ) ;

		t_Result = a_Context->GetValue ( L"__GET_EXTENSIONS" , 0, & t_Variant ) ;
		if ( SUCCEEDED ( t_Result ) )
		{
			// If here, they are being used.  Next we have to check and see
			// if the reentrancy flag is set or not.
			// =============================================================

			VariantClear ( & t_Variant ) ;

			t_Result = a_Context->GetValue ( L"__GET_EXT_CLIENT_REQUEST" , 0 , & t_Variant ) ;
			if ( SUCCEEDED ( t_Result ) )
			{
				
				VariantClear ( & t_Variant ) ;

				a_Context->DeleteValue ( L"__GET_EXT_CLIENT_REQUEST" , 0 ) ;
			}
			else
			{
				// If here, we have to clear out the get extensions.
				// =================================================

				a_Context->DeleteValue ( L"__GET_EXTENSIONS" , 0 ) ;
				a_Context->DeleteValue ( L"__GET_EXT_CLIENT_REQUEST" , 0 ) ;
				a_Context->DeleteValue ( L"__GET_EXT_KEYS_ONLY" , 0 ) ;
				a_Context->DeleteValue ( L"__GET_EXT_PROPERTIES" , 0 ) ;
			}
		}
	}

    return S_OK ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_DecoupledClient :: SetStatus ( 

	LPWSTR a_Operation ,
	LPWSTR a_Parameters ,
	LPWSTR a_Description ,
	HRESULT a_Result ,
	IWbemObjectSink *a_Sink
)
{
	return a_Sink->SetStatus ( 0 , a_Result , NULL , NULL ) ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_DecoupledClient :: Begin_IWbemServices (

	BOOL &a_Impersonating ,
	IUnknown *&a_OldContext ,
	IServerSecurity *&a_OldSecurity ,
	BOOL &a_IsProxy ,
	IWbemServices *&a_Interface ,
	BOOL &a_Revert ,
	IUnknown *&a_Proxy
)
{
	HRESULT t_Result = S_OK ;

	a_Revert = FALSE ;
	a_Proxy = NULL ;
	a_Impersonating = FALSE ;
	a_OldContext = NULL ;
	a_OldSecurity = NULL ;

	switch ( m_Registration->GetHosting () )
	{
		case e_Hosting_WmiCore:
		case e_Hosting_SharedLocalSystemHost:
		case e_Hosting_SharedLocalServiceHost:
		case e_Hosting_SharedNetworkServiceHost:
		case e_Hosting_SharedUserHost:
		{
			a_Interface = m_Provider_IWbemServices ;
			a_IsProxy = FALSE ;
		}
		break ;

		default:
		{
			t_Result = ProviderSubSystem_Common_Globals :: BeginImpersonation ( a_OldContext , a_OldSecurity , a_Impersonating ) ;
			if ( SUCCEEDED ( t_Result ) ) 
			{
				t_Result = ProviderSubSystem_Common_Globals :: SetProxyState ( m_ProxyContainer , ProxyIndex_IWbemServices , IID_IWbemServices , m_Provider_IWbemServices , a_Proxy , a_Revert ) ;
				if ( t_Result == WBEM_E_NOT_FOUND )
				{
					a_Interface = m_Provider_IWbemServices ;
					a_IsProxy = FALSE ;
					t_Result = S_OK ;
				}
				else
				{
					if ( SUCCEEDED ( t_Result ) )
					{
						a_IsProxy = TRUE ;

						a_Interface = ( IWbemServices * ) a_Proxy ;

						// Set cloaking on the proxy
						// =========================

						DWORD t_ImpersonationLevel = ProviderSubSystem_Common_Globals :: GetCurrentImpersonationLevel () ;

						t_Result = ProviderSubSystem_Common_Globals :: SetCloaking (

							a_Interface ,
							RPC_C_AUTHN_LEVEL_CONNECT , 
							t_ImpersonationLevel
						) ;

						if ( SUCCEEDED ( t_Result ) )
						{
							t_Result = CoImpersonateClient () ;
							if ( SUCCEEDED ( t_Result ) )
							{
							}
							else
							{
								t_Result = WBEM_E_ACCESS_DENIED ;
							}
						}

						if ( FAILED ( t_Result ) )
						{
							HRESULT t_TempResult = ProviderSubSystem_Common_Globals :: RevertProxyState ( 

								m_ProxyContainer , 
								ProxyIndex_IWbemServices , 
								a_Proxy , 
								a_Revert
							) ;
						}
					}
				}

				if ( FAILED ( t_Result ) )
				{
					ProviderSubSystem_Common_Globals :: EndImpersonation ( a_OldContext , a_OldSecurity , a_Impersonating ) ;
				}
			}
		}
		break ;
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_DecoupledClient :: End_IWbemServices (

	BOOL a_Impersonating ,
	IUnknown *a_OldContext ,
	IServerSecurity *a_OldSecurity ,
	BOOL a_IsProxy ,
	IWbemServices *a_Interface ,
	BOOL a_Revert ,
	IUnknown *a_Proxy
)
{
	CoRevertToSelf () ;

	if ( a_Proxy )
	{
		HRESULT t_TempResult = ProviderSubSystem_Common_Globals :: RevertProxyState ( 

			m_ProxyContainer , 
			ProxyIndex_IWbemServices , 
			a_Proxy , 
			a_Revert
		) ;
	}

	switch ( m_Registration->GetHosting () )
	{
		case e_Hosting_WmiCore:
		case e_Hosting_SharedLocalSystemHost:
		case e_Hosting_SharedLocalServiceHost:
		case e_Hosting_SharedNetworkServiceHost:
		case e_Hosting_SharedUserHost:
		{
		}
		break ;

		default:
		{
			ProviderSubSystem_Common_Globals :: EndImpersonation ( a_OldContext , a_OldSecurity , a_Impersonating ) ;
		}
		break ;
	}
	
	return S_OK ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_DecoupledClient::OpenNamespace ( 

	const BSTR a_ObjectPath ,
	long a_Flags ,
	IWbemContext *a_Context ,
	IWbemServices **a_NamespaceService ,
	IWbemCallResult **a_CallResult
)
{
	return WBEM_E_NOT_AVAILABLE ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_DecoupledClient :: CancelAsyncCall ( 
		
	IWbemObjectSink *a_Sink
)
{
	HRESULT t_Result = WBEM_E_PROVIDER_NOT_CAPABLE ;

	if ( m_Provider_IWbemServices )
	{
		CWbemGlobal_IWmiObjectSinkController_Container_Iterator t_Iterator ;

		Lock () ;

		WmiStatusCode t_StatusCode = Find ( 

			a_Sink ,
			t_Iterator
		) ;

		if ( t_StatusCode == e_StatusCode_Success ) 
		{
			ObjectSinkContainerElement *t_Element = t_Iterator.GetElement () ;

			UnLock () ;

			IWbemObjectSink *t_ObjectSink = NULL ;
			t_Result = t_Element->QueryInterface ( IID_IWbemObjectSink , ( void ** ) & t_ObjectSink ) ;
			if ( SUCCEEDED ( t_Result ) )
			{
				BOOL t_Impersonating ;
				IUnknown *t_OldContext ;
				IServerSecurity *t_OldSecurity ;
				BOOL t_IsProxy ;
				IWbemServices *t_Interface ;
				BOOL t_Revert ;
				IUnknown *t_Proxy ;

				t_Result = Begin_IWbemServices (

					t_Impersonating ,
					t_OldContext ,
					t_OldSecurity ,
					t_IsProxy ,
					t_Interface ,
					t_Revert ,
					t_Proxy
				) ;

				if ( SUCCEEDED ( t_Result ) )
				{
					t_Result = t_Interface->CancelAsyncCall (

						t_ObjectSink
					) ;

					End_IWbemServices (

						t_Impersonating ,
						t_OldContext ,
						t_OldSecurity ,
						t_IsProxy ,
						t_Interface ,
						t_Revert ,
						t_Proxy
					) ;
				}

				t_ObjectSink->Release () ;
			}

			IWbemShutdown *t_Shutdown = NULL ;
			HRESULT t_TempResult = t_Element->QueryInterface ( IID_IWbemShutdown , ( void ** ) & t_Shutdown ) ;
			if ( SUCCEEDED ( t_TempResult ) )
			{
				t_TempResult = t_Shutdown->Shutdown ( 

					0 , 
					0 , 
					NULL 
				) ;

				t_Shutdown->Release () ;
			}

			t_Element->Release () ;
		}
		else
		{
			UnLock () ;

			t_Result = WBEM_E_NOT_FOUND ;
		}
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_DecoupledClient :: QueryObjectSink ( 

	long a_Flags ,
	IWbemObjectSink **a_Sink
) 
{
	return WBEM_E_NOT_AVAILABLE ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_DecoupledClient :: GetObject ( 
		
	const BSTR a_ObjectPath ,
    long a_Flags ,
    IWbemContext *a_Context ,
    IWbemClassObject **a_Object ,
    IWbemCallResult **a_CallResult
)
{
	return WBEM_E_NOT_AVAILABLE ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_DecoupledClient :: Helper_GetObjectAsync (

	BOOL a_IsProxy ,
	const BSTR a_ObjectPath ,
	long a_Flags ,
	IWbemContext *a_Context ,
	IWbemObjectSink *a_Sink ,
	IWbemServices *a_Service 
) 
{
	HRESULT t_Result = S_OK ;

	a_Flags = ( a_Flags & ~WBEM_FLAG_DIRECT_READ ) ;

	IWbemContext *t_ContextCopy = NULL ;
	if ( a_Context )
	{
		t_Result = a_Context->Clone ( & t_ContextCopy ) ;
		AdjustGetContext ( t_ContextCopy ) ;
	}
	else
	{
		t_Result = S_OK ;
	}

	if ( SUCCEEDED ( t_Result ) )
	{
		ULONG t_Dependant = 1 ;

		if ( a_Context )
		{
			_IWmiContext *t_CallContext = NULL ;
			HRESULT t_Test = a_Context->QueryInterface ( IID__IWmiContext , ( void **) & t_CallContext ) ;
			if ( SUCCEEDED ( t_Test ) )
			{
				t_Test = t_CallContext->Get (
        
					WMI_CTX_INF_DEPENDENT ,
					& t_Dependant 
				);

				if ( SUCCEEDED ( t_Test ) )
				{
				}

				t_CallContext->Release () ;
			}
		}

		CDecoupled_IWbemSyncObjectSink *t_Sink = new CDecoupled_IWbemSyncObjectSink (

			m_Allocator ,
			a_Sink , 
			( IWbemServices * ) this , 
			( CWbemGlobal_IWmiObjectSinkController * ) this ,
			FALSE
		) ;

		if ( t_Sink )
		{
			t_Sink->AddRef () ;

			t_Result = t_Sink->SinkInitialize () ;
			if ( SUCCEEDED ( t_Result ) )
			{
				CWbemGlobal_IWmiObjectSinkController_Container_Iterator t_Iterator ;

				Lock () ;

				WmiStatusCode t_StatusCode = Insert ( 

					*t_Sink ,
					t_Iterator
				) ;

				if ( t_StatusCode == e_StatusCode_Success ) 
				{
					UnLock () ;

					if ( m_Registration->GetComRegistration ().GetSupportsSendStatus () == FALSE )
					{
						a_Flags = ( a_Flags & ( ~WBEM_FLAG_SEND_STATUS ) ) ;
					}

					if ( a_IsProxy )
					{
						t_Result = CoImpersonateClient () ;
					}
					else
					{
						t_Result = S_OK ;
					}

					if ( SUCCEEDED ( t_Result ) )
					{
						Increment_ProviderOperation_GetObjectAsync () ;

						try	
						{
							t_Result = a_Service->GetObjectAsync (

 								a_ObjectPath ,
								a_Flags ,
								t_ContextCopy ,
								t_Sink 
							) ;
						}
						catch ( ... )
						{
							t_Result = WBEM_E_PROVIDER_FAILURE ;
						}

						CoRevertToSelf () ;
					}
					else
					{
						t_Result = WBEM_E_ACCESS_DENIED ;
					}

					if ( t_Result == WBEM_E_UNSUPPORTED_PARAMETER || t_Result == WBEM_E_INVALID_PARAMETER )
					{
						a_Flags = ( a_Flags & ~WBEM_FLAG_SEND_STATUS ) ;

						Increment_ProviderOperation_GetObjectAsync () ;

						if ( a_IsProxy )
						{
							t_Result = CoImpersonateClient () ;
						}
						else
						{
							t_Result = S_OK ;
						}

						if ( SUCCEEDED ( t_Result ) ) 
						{
							try
							{
								t_Result = a_Service->GetObjectAsync (

 									a_ObjectPath ,
									a_Flags ,
									t_ContextCopy ,
									t_Sink 
								) ;
							}
							catch ( ... )
							{
								t_Result = WBEM_E_PROVIDER_FAILURE ;
							}

							CoRevertToSelf () ;
						}
					}
				}
				else
				{
					UnLock () ;

					t_Result = WBEM_E_OUT_OF_MEMORY ;
				}

				if ( FAILED ( t_Result ) )
				{
					HRESULT t_TempResult = SetStatus ( L"GetObjectAsync" , NULL , NULL , t_Result , t_Sink ) ;
				}
			}

			t_Sink->Release () ;
		}
		else
		{
			t_Result = WBEM_E_OUT_OF_MEMORY ;
		}
	}
	else
	{
		t_Result = WBEM_E_OUT_OF_MEMORY ;
	}

	if ( t_ContextCopy )
	{
		t_ContextCopy->Release () ;
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_DecoupledClient :: GetObjectAsync ( 
		
	const BSTR a_ObjectPath ,
	long a_Flags , 
	IWbemContext *a_Context ,
	IWbemObjectSink *a_Sink
) 
{
	HRESULT t_Result = WBEM_E_PROVIDER_NOT_CAPABLE ;

	if ( m_Provider_IWbemServices )
	{
		if ( m_Registration->GetInstanceProviderRegistration ().SupportsGet () || m_Registration->GetClassProviderRegistration ().SupportsGet () )
		{
			BOOL t_Impersonating ;
			IUnknown *t_OldContext ;
			IServerSecurity *t_OldSecurity ;
			BOOL t_IsProxy ;
			IWbemServices *t_Interface ;
			BOOL t_Revert ;
			IUnknown *t_Proxy ;

			t_Result = Begin_IWbemServices (

				t_Impersonating ,
				t_OldContext ,
				t_OldSecurity ,
				t_IsProxy ,
				t_Interface ,
				t_Revert ,
				t_Proxy
			) ;

			if ( SUCCEEDED ( t_Result ) )
			{
				t_Result = Helper_GetObjectAsync ( 

					t_IsProxy ,
					a_ObjectPath ,
					a_Flags , 
					a_Context ,
					a_Sink ,
					t_Interface
				) ;

				End_IWbemServices (

					t_Impersonating ,
					t_OldContext ,
					t_OldSecurity ,
					t_IsProxy ,
					t_Interface ,
					t_Revert ,
					t_Proxy
				) ;
			}
		}
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_DecoupledClient :: PutClass ( 
		
	IWbemClassObject *a_Object ,
	long a_Flags , 
	IWbemContext *a_Context ,
	IWbemCallResult **a_CallResult
) 
{
	return WBEM_E_NOT_AVAILABLE ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_DecoupledClient :: Helper_PutClassAsync (

	BOOL a_IsProxy ,
	IWbemClassObject *a_Object , 
	long a_Flags ,
	IWbemContext FAR *a_Context ,
	IWbemObjectSink *a_Sink ,
	IWbemServices *a_Service 
) 
{
	HRESULT t_Result = S_OK ;

	a_Flags = ( a_Flags & ~WBEM_FLAG_DIRECT_READ ) ;

	IWbemContext *t_ContextCopy = NULL ;
	if ( a_Context )
	{
		t_Result = a_Context->Clone ( & t_ContextCopy ) ;
	}
	else
	{
		t_Result = S_OK ;
	}

	if ( SUCCEEDED ( t_Result ) )
	{
		ULONG t_Dependant = 1 ;

		if ( a_Context )
		{
			_IWmiContext *t_CallContext = NULL ;
			HRESULT t_Test = a_Context->QueryInterface ( IID__IWmiContext , ( void **) & t_CallContext ) ;
			if ( SUCCEEDED ( t_Test ) )
			{
				t_Test = t_CallContext->Get (
        
					WMI_CTX_INF_DEPENDENT ,
					& t_Dependant 
				);

				if ( SUCCEEDED ( t_Test ) )
				{
				}

				t_CallContext->Release () ;
			}
		}

		CDecoupled_IWbemSyncObjectSink *t_Sink = new CDecoupled_IWbemSyncObjectSink (

			m_Allocator ,
			a_Sink , 
			( IWbemServices * ) this , 
			( CWbemGlobal_IWmiObjectSinkController * ) this ,
			FALSE
		) ;

		if ( t_Sink )
		{
			t_Sink->AddRef () ;

			t_Result = t_Sink->SinkInitialize () ;
			if ( SUCCEEDED ( t_Result ) )
			{
				CWbemGlobal_IWmiObjectSinkController_Container_Iterator t_Iterator ;

				Lock () ;

				WmiStatusCode t_StatusCode = Insert ( 

					*t_Sink ,
					t_Iterator
				) ;

				if ( t_StatusCode == e_StatusCode_Success ) 
				{
					UnLock () ;

					if ( m_Registration->GetComRegistration ().GetSupportsSendStatus () == FALSE )
					{
						a_Flags = ( a_Flags & ( ~WBEM_FLAG_SEND_STATUS ) ) ;
					}

					if ( a_IsProxy )
					{
						t_Result = CoImpersonateClient () ;
					}
					else
					{
						t_Result = S_OK ;
					}

					if ( SUCCEEDED ( t_Result ) )
					{
						Increment_ProviderOperation_PutClassAsync () ;

						try
						{
							t_Result = a_Service->PutClassAsync (

 								a_Object ,
								a_Flags ,
								t_ContextCopy ,
								t_Sink 
							) ;
						}
						catch ( ... )
						{
							t_Result = WBEM_E_PROVIDER_FAILURE ;
						}

						CoRevertToSelf () ;
					}
					else
					{
						t_Result = WBEM_E_ACCESS_DENIED ;
					}

					if ( t_Result == WBEM_E_UNSUPPORTED_PARAMETER || t_Result == WBEM_E_INVALID_PARAMETER )
					{
						a_Flags = ( a_Flags & ~WBEM_FLAG_SEND_STATUS ) ;

						if ( a_IsProxy )
						{
							t_Result = CoImpersonateClient () ;
						}
						else
						{
							t_Result = S_OK ;
						}

						if ( SUCCEEDED ( t_Result ) ) 
						{
							Increment_ProviderOperation_PutClassAsync () ;

							try
							{
								t_Result = a_Service->PutClassAsync (

 									a_Object ,
									a_Flags ,
									t_ContextCopy ,
									t_Sink 
								) ;
							}
							catch ( ... )
							{
								t_Result = WBEM_E_PROVIDER_FAILURE ;
							}

							CoRevertToSelf () ;
						}
						else
						{
							t_Result = WBEM_E_ACCESS_DENIED ;
						}
					}
				}
				else
				{
					UnLock () ;

					t_Result = WBEM_E_OUT_OF_MEMORY ;
				}

				if ( FAILED ( t_Result ) )
				{
					HRESULT t_TempResult = SetStatus ( L"PutClassAsync" , NULL , NULL , t_Result , t_Sink ) ;
				}
			}

			t_Sink->Release () ;
		}
		else
		{
			t_Result = WBEM_E_OUT_OF_MEMORY ;
		}
	}
	else
	{
		t_Result = WBEM_E_OUT_OF_MEMORY ;
	}

	if ( t_ContextCopy )
	{
		t_ContextCopy->Release () ;
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_DecoupledClient :: PutClassAsync ( 
		
	IWbemClassObject *a_Object , 
	long a_Flags , 
	IWbemContext *a_Context ,
	IWbemObjectSink *a_Sink
) 
{
	HRESULT t_Result = WBEM_E_PROVIDER_NOT_CAPABLE ;

	if ( m_Provider_IWbemServices )
	{
		if ( m_Registration->GetClassProviderRegistration ().SupportsPut () )
		{
			BOOL t_Impersonating ;
			IUnknown *t_OldContext ;
			IServerSecurity *t_OldSecurity ;
			BOOL t_IsProxy ;
			IWbemServices *t_Interface ;
			BOOL t_Revert ;
			IUnknown *t_Proxy ;

			t_Result = Begin_IWbemServices (

				t_Impersonating ,
				t_OldContext ,
				t_OldSecurity ,
				t_IsProxy ,
				t_Interface ,
				t_Revert ,
				t_Proxy
			) ;

			if ( SUCCEEDED ( t_Result ) )
			{
				t_Result = Helper_PutClassAsync ( 

					t_IsProxy ,
					a_Object ,
					a_Flags , 
					a_Context ,
					a_Sink ,
					t_Interface
				) ;

				End_IWbemServices (

					t_Impersonating ,
					t_OldContext ,
					t_OldSecurity ,
					t_IsProxy ,
					t_Interface ,
					t_Revert ,
					t_Proxy
				) ;
			}
		}
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_DecoupledClient :: DeleteClass ( 
		
	const BSTR a_Class , 
	long a_Flags , 
	IWbemContext *a_Context ,
	IWbemCallResult **a_CallResult
) 
{
 	 return WBEM_E_NOT_AVAILABLE ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_DecoupledClient :: Helper_DeleteClassAsync (

	BOOL a_IsProxy ,
	const BSTR a_Class , 
	long a_Flags ,
	IWbemContext FAR *a_Context ,
	IWbemObjectSink *a_Sink ,
	IWbemServices *a_Service 
) 
{
	HRESULT t_Result = S_OK ;

	a_Flags = ( a_Flags & ~WBEM_FLAG_DIRECT_READ ) ;

	IWbemContext *t_ContextCopy = NULL ;
	if ( a_Context )
	{
		t_Result = a_Context->Clone ( & t_ContextCopy ) ;
	}
	else
	{
		t_Result = S_OK ;
	}

	if ( SUCCEEDED ( t_Result ) )
	{
		ULONG t_Dependant = 1 ;

		if ( a_Context )
		{
			_IWmiContext *t_CallContext = NULL ;
			HRESULT t_Test = a_Context->QueryInterface ( IID__IWmiContext , ( void **) & t_CallContext ) ;
			if ( SUCCEEDED ( t_Test ) )
			{
				t_Test = t_CallContext->Get (
        
					WMI_CTX_INF_DEPENDENT ,
					& t_Dependant 
				);

				if ( SUCCEEDED ( t_Test ) )
				{
				}

				t_CallContext->Release () ;
			}
		}

		CDecoupled_IWbemSyncObjectSink *t_Sink = new CDecoupled_IWbemSyncObjectSink (

			m_Allocator ,
			a_Sink , 
			( IWbemServices * ) this , 
			( CWbemGlobal_IWmiObjectSinkController * ) this ,
			FALSE
		) ;

		if ( t_Sink )
		{
			t_Sink->AddRef () ;

			t_Result = t_Sink->SinkInitialize () ;
			if ( SUCCEEDED ( t_Result ) )
			{
				CWbemGlobal_IWmiObjectSinkController_Container_Iterator t_Iterator ;

				Lock () ;

				WmiStatusCode t_StatusCode = Insert ( 

					*t_Sink ,
					t_Iterator
				) ;

				if ( t_StatusCode == e_StatusCode_Success ) 
				{
					UnLock () ;

					if ( m_Registration->GetComRegistration ().GetSupportsSendStatus () == FALSE )
					{
						a_Flags = ( a_Flags & ( ~WBEM_FLAG_SEND_STATUS ) ) ;
					}

					if ( a_IsProxy )
					{
						t_Result = CoImpersonateClient () ;
					}
					else
					{
						t_Result = S_OK ;
					}

					if ( SUCCEEDED ( t_Result ) )
					{
						Increment_ProviderOperation_DeleteClassAsync () ;

						try
						{
							t_Result = a_Service->DeleteClassAsync (

 								a_Class ,
								a_Flags ,
								t_ContextCopy ,
								t_Sink 
							) ;
						}
						catch ( ... )
						{
							t_Result = WBEM_E_PROVIDER_FAILURE ;
						}

						CoRevertToSelf () ;
					}
					else
					{
						t_Result = WBEM_E_ACCESS_DENIED ;
					}

					if ( t_Result == WBEM_E_UNSUPPORTED_PARAMETER || t_Result == WBEM_E_INVALID_PARAMETER )
					{
						a_Flags = ( a_Flags & ~WBEM_FLAG_SEND_STATUS ) ;

						if ( a_IsProxy )
						{
							t_Result = CoImpersonateClient () ;
						}
						else
						{
							t_Result = S_OK ;
						}

						if ( SUCCEEDED ( t_Result ) ) 
						{
							Increment_ProviderOperation_DeleteClassAsync () ;

							try
							{
								t_Result = a_Service->DeleteClassAsync (

 									a_Class ,
									a_Flags ,
									t_ContextCopy ,
									t_Sink 
								) ;
							}
							catch ( ... )
							{
								t_Result = WBEM_E_PROVIDER_FAILURE ;
							}

							CoRevertToSelf () ;
						}
						else
						{
							t_Result = WBEM_E_ACCESS_DENIED ;
						}
					}
				}
				else
				{
					UnLock () ;

					t_Result = WBEM_E_OUT_OF_MEMORY ;
				}

				if ( FAILED ( t_Result ) )
				{
					HRESULT t_TempResult = SetStatus ( L"DeleteClassAsync" , NULL , NULL , t_Result , t_Sink ) ;
				}
			}

			t_Sink->Release () ;
		}
		else
		{
			t_Result = WBEM_E_OUT_OF_MEMORY ;
		}
	}
	else
	{
		t_Result = WBEM_E_OUT_OF_MEMORY ;
	}

	if ( t_ContextCopy )
	{
		t_ContextCopy->Release () ;
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_DecoupledClient :: DeleteClassAsync ( 
		
	const BSTR a_Class , 
	long a_Flags , 
	IWbemContext *a_Context ,
	IWbemObjectSink *a_Sink
) 
{
	HRESULT t_Result = WBEM_E_PROVIDER_NOT_CAPABLE ;

	if ( m_Provider_IWbemServices )
	{
		if ( m_Registration->GetClassProviderRegistration ().SupportsDelete () )
		{
			BOOL t_Impersonating ;
			IUnknown *t_OldContext ;
			IServerSecurity *t_OldSecurity ;
			BOOL t_IsProxy ;
			IWbemServices *t_Interface ;
			BOOL t_Revert ;
			IUnknown *t_Proxy ;

			t_Result = Begin_IWbemServices (

				t_Impersonating ,
				t_OldContext ,
				t_OldSecurity ,
				t_IsProxy ,
				t_Interface ,
				t_Revert ,
				t_Proxy
			) ;

			if ( SUCCEEDED ( t_Result ) )
			{
				t_Result = Helper_DeleteClassAsync ( 

					t_IsProxy ,
					a_Class ,
					a_Flags , 
					a_Context ,
					a_Sink ,
					t_Interface
				) ;

				End_IWbemServices (

					t_Impersonating ,
					t_OldContext ,
					t_OldSecurity ,
					t_IsProxy ,
					t_Interface ,
					t_Revert ,
					t_Proxy
				) ;
			}
		}
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_DecoupledClient :: CreateClassEnum ( 

	const BSTR a_Superclass ,
	long a_Flags, 
	IWbemContext *a_Context ,
	IEnumWbemClassObject **a_Enum
) 
{
	return WBEM_E_NOT_AVAILABLE ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_DecoupledClient :: Helper_CreateClassEnumAsync (

	BOOL a_IsProxy ,
	const BSTR a_SuperClass , 
	long a_Flags ,
	IWbemContext FAR *a_Context ,
	IWbemObjectSink *a_Sink ,
	IWbemServices *a_Service 
) 
{
	HRESULT t_Result = S_OK ;

	a_Flags = ( a_Flags & ~WBEM_FLAG_DIRECT_READ ) ;

	IWbemContext *t_ContextCopy = NULL ;
	if ( a_Context )
	{
		t_Result = a_Context->Clone ( & t_ContextCopy ) ;
	}
	else
	{
		t_Result = S_OK ;
	}

	if ( SUCCEEDED ( t_Result ) )
	{
		ULONG t_Dependant = 1 ;

		if ( a_Context )
		{
			_IWmiContext *t_CallContext = NULL ;
			HRESULT t_Test = a_Context->QueryInterface ( IID__IWmiContext , ( void **) & t_CallContext ) ;
			if ( SUCCEEDED ( t_Test ) )
			{
				t_Test = t_CallContext->Get (
        
					WMI_CTX_INF_DEPENDENT ,
					& t_Dependant 
				);

				if ( SUCCEEDED ( t_Test ) )
				{
				}

				t_CallContext->Release () ;
			}
		}

		CDecoupled_Batching_IWbemSyncObjectSink *t_Sink = new CDecoupled_Batching_IWbemSyncObjectSink (

			m_Allocator ,
			a_Sink , 
			( IWbemServices * ) this , 
			( CWbemGlobal_IWmiObjectSinkController * ) this ,
			FALSE
		) ;

		if ( t_Sink )
		{
			t_Sink->AddRef () ;

			t_Result = t_Sink->SinkInitialize () ;
			if ( SUCCEEDED ( t_Result ) )
			{
				CWbemGlobal_IWmiObjectSinkController_Container_Iterator t_Iterator ;

				Lock () ;

				WmiStatusCode t_StatusCode = Insert ( 

					*t_Sink ,
					t_Iterator
				) ;

				if ( t_StatusCode == e_StatusCode_Success ) 
				{
					UnLock () ;

					if ( m_Registration->GetComRegistration ().GetSupportsSendStatus () == FALSE )
					{
						a_Flags = ( a_Flags & ( ~WBEM_FLAG_SEND_STATUS ) ) ;
					}

					if ( a_IsProxy )
					{
						t_Result = CoImpersonateClient () ;
					}
					else
					{
						t_Result = S_OK ;
					}

					if ( SUCCEEDED ( t_Result ) )
					{
						Increment_ProviderOperation_CreateClassEnumAsync () ;

						try
						{
							t_Result = a_Service->CreateClassEnumAsync (

 								a_SuperClass ,
								a_Flags ,
								t_ContextCopy ,
								t_Sink 
							) ;
						}
						catch ( ... )
						{
							t_Result = WBEM_E_PROVIDER_FAILURE ;
						}

						CoRevertToSelf () ;
					}
					else
					{
						t_Result = WBEM_E_ACCESS_DENIED ;
					}

					if ( t_Result == WBEM_E_UNSUPPORTED_PARAMETER || t_Result == WBEM_E_INVALID_PARAMETER )
					{
						a_Flags = ( a_Flags & ~WBEM_FLAG_SEND_STATUS ) ;

						if ( a_IsProxy )
						{
							t_Result = CoImpersonateClient () ;
						}
						else
						{
							t_Result = S_OK ;
						}

						if ( SUCCEEDED ( t_Result ) ) 
						{
							Increment_ProviderOperation_CreateClassEnumAsync () ;

							try
							{
								t_Result = a_Service->CreateClassEnumAsync (

 									a_SuperClass ,
									a_Flags ,
									t_ContextCopy ,
									t_Sink 
								) ;
							}
							catch ( ... )
							{
								t_Result = WBEM_E_PROVIDER_FAILURE ;
							}

							CoRevertToSelf () ;
						}
						else
						{
							t_Result = WBEM_E_ACCESS_DENIED ;
						}
					}
				}
				else
				{
					UnLock () ;

					t_Result = WBEM_E_OUT_OF_MEMORY ;
				}

				if ( FAILED ( t_Result ) )
				{
					HRESULT t_TempResult = SetStatus ( L"CreateClassEnumAsync" , NULL , NULL , t_Result , t_Sink ) ;
				}
			}

			t_Sink->Release () ;
		}
		else
		{
			t_Result = WBEM_E_OUT_OF_MEMORY ;
		}
	}
	else
	{
		t_Result = WBEM_E_OUT_OF_MEMORY ;
	}

	if ( t_ContextCopy )
	{
		t_ContextCopy->Release () ;
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_DecoupledClient :: CreateClassEnumAsync ( 
		
	const BSTR a_SuperClass , 
	long a_Flags , 
	IWbemContext *a_Context ,
	IWbemObjectSink *a_Sink
) 
{
	HRESULT t_Result = WBEM_E_PROVIDER_NOT_CAPABLE ;

	if ( m_Provider_IWbemServices )
	{
		if ( m_Registration->GetClassProviderRegistration ().SupportsEnumeration () )
		{
			BOOL t_Impersonating ;
			IUnknown *t_OldContext ;
			IServerSecurity *t_OldSecurity ;
			BOOL t_IsProxy ;
			IWbemServices *t_Interface ;
			BOOL t_Revert ;
			IUnknown *t_Proxy ;

			t_Result = Begin_IWbemServices (

				t_Impersonating ,
				t_OldContext ,
				t_OldSecurity ,
				t_IsProxy ,
				t_Interface ,
				t_Revert ,
				t_Proxy
			) ;

			if ( SUCCEEDED ( t_Result ) )
			{
				t_Result = Helper_CreateClassEnumAsync ( 

					t_IsProxy ,
					a_SuperClass ,
					a_Flags , 
					a_Context ,
					a_Sink ,
					t_Interface
				) ;

				End_IWbemServices (

					t_Impersonating ,
					t_OldContext ,
					t_OldSecurity ,
					t_IsProxy ,
					t_Interface ,
					t_Revert ,
					t_Proxy
				) ;
			}
		}
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_DecoupledClient :: PutInstance (

    IWbemClassObject *a_Instance ,
    long a_Flags ,
    IWbemContext *a_Context ,
	IWbemCallResult **a_CallResult
) 
{
	return WBEM_E_NOT_AVAILABLE ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_DecoupledClient :: Helper_PutInstanceAsync (

	BOOL a_IsProxy ,
	IWbemClassObject *a_Instance ,
	long a_Flags ,
	IWbemContext FAR *a_Context ,
	IWbemObjectSink *a_Sink ,
	IWbemServices *a_Service 
) 
{
	HRESULT t_Result = S_OK ;

	a_Flags = ( a_Flags & ~WBEM_FLAG_DIRECT_READ ) ;

	IWbemContext *t_ContextCopy = NULL ;
	if ( a_Context )
	{
		t_Result = a_Context->Clone ( & t_ContextCopy ) ;
	}
	else
	{
		t_Result = S_OK ;
	}

	if ( SUCCEEDED ( t_Result ) )
	{
		ULONG t_Dependant = 1 ;

		if ( a_Context )
		{
			_IWmiContext *t_CallContext = NULL ;
			HRESULT t_Test = a_Context->QueryInterface ( IID__IWmiContext , ( void **) & t_CallContext ) ;
			if ( SUCCEEDED ( t_Test ) )
			{
				t_Test = t_CallContext->Get (
        
					WMI_CTX_INF_DEPENDENT ,
					& t_Dependant 
				);

				if ( SUCCEEDED ( t_Test ) )
				{
				}

				t_CallContext->Release () ;
			}
		}

		CDecoupled_IWbemSyncObjectSink *t_Sink = new CDecoupled_IWbemSyncObjectSink (

			m_Allocator ,
			a_Sink , 
			( IWbemServices * ) this , 
			( CWbemGlobal_IWmiObjectSinkController * ) this ,
			FALSE
		) ;

		if ( t_Sink )
		{
			t_Sink->AddRef () ;

			t_Result = t_Sink->SinkInitialize () ;
			if ( SUCCEEDED ( t_Result ) )
			{
				CWbemGlobal_IWmiObjectSinkController_Container_Iterator t_Iterator ;

				Lock () ;

				WmiStatusCode t_StatusCode = Insert ( 

					*t_Sink ,
					t_Iterator
				) ;

				if ( t_StatusCode == e_StatusCode_Success ) 
				{
					UnLock () ;

					if ( m_Registration->GetComRegistration ().GetSupportsSendStatus () == FALSE )
					{
						a_Flags = ( a_Flags & ( ~WBEM_FLAG_SEND_STATUS ) ) ;
					}

					if ( a_IsProxy )
					{
						t_Result = CoImpersonateClient () ;
					}
					else
					{
						t_Result = S_OK ;
					}

					if ( SUCCEEDED ( t_Result ) ) 
					{
						Increment_ProviderOperation_PutInstanceAsync () ;

						try
						{
							t_Result = a_Service->PutInstanceAsync (

 								a_Instance ,
								a_Flags ,
								t_ContextCopy ,
								t_Sink 
							) ;
						}
						catch ( ... )
						{
							t_Result = WBEM_E_PROVIDER_FAILURE ;
						}

						CoRevertToSelf () ;
					}
					else
					{
						t_Result = WBEM_E_ACCESS_DENIED ;
					}

					if ( t_Result == WBEM_E_UNSUPPORTED_PARAMETER || t_Result == WBEM_E_INVALID_PARAMETER )
					{
						a_Flags = ( a_Flags & ~WBEM_FLAG_SEND_STATUS ) ;

						if ( a_IsProxy )
						{
							t_Result = CoImpersonateClient () ;
						}
						else
						{
							t_Result = S_OK ;
						}

						if ( SUCCEEDED ( t_Result ) ) 
						{
							Increment_ProviderOperation_PutInstanceAsync () ;

							try
							{
								t_Result = a_Service->PutInstanceAsync (

 									a_Instance ,
									a_Flags ,
									t_ContextCopy ,
									t_Sink 
								) ;
							}
							catch ( ... )
							{
								t_Result = WBEM_E_PROVIDER_FAILURE ;
							}

							CoRevertToSelf () ;
						}
						else
						{
							t_Result = WBEM_E_ACCESS_DENIED ;
						}
					}
				}
				else
				{
					UnLock () ;

					t_Result = WBEM_E_OUT_OF_MEMORY ;
				}

				if ( FAILED ( t_Result ) )
				{
					HRESULT t_TempResult = SetStatus ( L"PutInstanceAsync" , NULL , NULL , t_Result , t_Sink ) ;
				}
			}

			t_Sink->Release () ;
		}
		else
		{
			t_Result = WBEM_E_OUT_OF_MEMORY ;
		}
	}
	else
	{
		t_Result = WBEM_E_OUT_OF_MEMORY ;
	}

	if ( t_ContextCopy )
	{
		t_ContextCopy->Release () ;
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_DecoupledClient :: PutInstanceAsync ( 
		
	IWbemClassObject *a_Instance , 
	long a_Flags , 
	IWbemContext *a_Context ,
	IWbemObjectSink *a_Sink
) 
{
	HRESULT t_Result = WBEM_E_PROVIDER_NOT_CAPABLE ;

	if ( m_Provider_IWbemServices )
	{
		if ( m_Registration->GetInstanceProviderRegistration ().SupportsPut () )
		{
			BOOL t_Impersonating ;
			IUnknown *t_OldContext ;
			IServerSecurity *t_OldSecurity ;
			BOOL t_IsProxy ;
			IWbemServices *t_Interface ;
			BOOL t_Revert ;
			IUnknown *t_Proxy ;

			t_Result = Begin_IWbemServices (

				t_Impersonating ,
				t_OldContext ,
				t_OldSecurity ,
				t_IsProxy ,
				t_Interface ,
				t_Revert ,
				t_Proxy
			) ;

			if ( SUCCEEDED ( t_Result ) )
			{
				t_Result = Helper_PutInstanceAsync ( 

					t_IsProxy ,
					a_Instance ,
					a_Flags , 
					a_Context ,
					a_Sink ,
					t_Interface
				) ;

				End_IWbemServices (

					t_Impersonating ,
					t_OldContext ,
					t_OldSecurity ,
					t_IsProxy ,
					t_Interface ,
					t_Revert ,
					t_Proxy
				) ;
			}
		}
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_DecoupledClient :: DeleteInstance ( 

	const BSTR a_ObjectPath ,
    long a_Flags ,
    IWbemContext *a_Context ,
    IWbemCallResult **a_CallResult
)
{
	return WBEM_E_NOT_AVAILABLE ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_DecoupledClient :: Helper_DeleteInstanceAsync (

	BOOL a_IsProxy ,
	const BSTR a_ObjectPath ,
	long a_Flags ,
	IWbemContext FAR *a_Context ,
	IWbemObjectSink *a_Sink ,
	IWbemServices *a_Service 
) 
{
	HRESULT t_Result = S_OK ;

	a_Flags = ( a_Flags & ~WBEM_FLAG_DIRECT_READ ) ;

	IWbemContext *t_ContextCopy = NULL ;
	if ( a_Context )
	{
		t_Result = a_Context->Clone ( & t_ContextCopy ) ;
	}
	else
	{
		t_Result = S_OK ;
	}

	if ( SUCCEEDED ( t_Result ) )
	{
		ULONG t_Dependant = 1 ;

		if ( a_Context )
		{
			_IWmiContext *t_CallContext = NULL ;
			HRESULT t_Test = a_Context->QueryInterface ( IID__IWmiContext , ( void **) & t_CallContext ) ;
			if ( SUCCEEDED ( t_Test ) )
			{
				t_Test = t_CallContext->Get (
        
					WMI_CTX_INF_DEPENDENT ,
					& t_Dependant 
				);

				if ( SUCCEEDED ( t_Test ) )
				{
				}

				t_CallContext->Release () ;
			}
		}

		CDecoupled_IWbemSyncObjectSink *t_Sink = new CDecoupled_IWbemSyncObjectSink (

			m_Allocator ,
			a_Sink , 
			( IWbemServices * ) this , 
			( CWbemGlobal_IWmiObjectSinkController * ) this ,
			FALSE
		) ;

		if ( t_Sink )
		{
			t_Sink->AddRef () ;

			t_Result = t_Sink->SinkInitialize () ;
			if ( SUCCEEDED ( t_Result ) )
			{
				CWbemGlobal_IWmiObjectSinkController_Container_Iterator t_Iterator ;

				Lock () ;

				WmiStatusCode t_StatusCode = Insert ( 

					*t_Sink ,
					t_Iterator
				) ;

				if ( t_StatusCode == e_StatusCode_Success ) 
				{
					UnLock () ;

					if ( m_Registration->GetComRegistration ().GetSupportsSendStatus () == FALSE )
					{
						a_Flags = ( a_Flags & ( ~WBEM_FLAG_SEND_STATUS ) ) ;
					}

					if ( a_IsProxy )
					{
						t_Result = CoImpersonateClient () ;
					}
					else
					{
						t_Result = S_OK ;
					}

					if ( SUCCEEDED ( t_Result ) )
					{
						Increment_ProviderOperation_DeleteInstanceAsync () ;

						try
						{
							t_Result = a_Service->DeleteInstanceAsync (

 								a_ObjectPath ,
								a_Flags ,
								t_ContextCopy ,
								t_Sink 
							) ;
						}
						catch ( ... )
						{
							t_Result = WBEM_E_PROVIDER_FAILURE ;
						}

						CoRevertToSelf () ;
					}
					else
					{
						t_Result = WBEM_E_ACCESS_DENIED ;
					}

					if ( t_Result == WBEM_E_UNSUPPORTED_PARAMETER || t_Result == WBEM_E_INVALID_PARAMETER )
					{
						a_Flags = ( a_Flags & ~WBEM_FLAG_SEND_STATUS ) ;

						if ( a_IsProxy )
						{
							t_Result = CoImpersonateClient () ;
						}
						else
						{
							t_Result = S_OK ;
						}

						if ( SUCCEEDED ( t_Result ) ) 
						{
							Increment_ProviderOperation_DeleteInstanceAsync () ;

							try
							{
								t_Result = a_Service->DeleteInstanceAsync (

 									a_ObjectPath ,
									a_Flags ,
									t_ContextCopy ,
									t_Sink 
								) ;
							}
							catch ( ... )
							{
								t_Result = WBEM_E_PROVIDER_FAILURE ;
							}

							CoRevertToSelf () ;
						}
						else
						{
							t_Result = WBEM_E_ACCESS_DENIED ;
						}
					}
				}
				else
				{
					UnLock () ;

					t_Result = WBEM_E_OUT_OF_MEMORY ;
				}

				if ( FAILED ( t_Result ) )
				{
					HRESULT t_TempResult = SetStatus ( L"DeleteInstanceAsync" , NULL , NULL , t_Result , t_Sink ) ;
				}
			}

			t_Sink->Release () ;
		}
		else
		{
			t_Result = WBEM_E_OUT_OF_MEMORY ;
		}
	}
	else
	{
		t_Result = WBEM_E_OUT_OF_MEMORY ;
	}

	if ( t_ContextCopy )
	{
		t_ContextCopy->Release () ;
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_DecoupledClient :: DeleteInstanceAsync ( 
		
	const BSTR a_ObjectPath ,
	long a_Flags , 
	IWbemContext *a_Context ,
	IWbemObjectSink *a_Sink
) 
{
	HRESULT t_Result = WBEM_E_PROVIDER_NOT_CAPABLE ;

	if ( m_Provider_IWbemServices )
	{
		if ( m_Registration->GetInstanceProviderRegistration ().SupportsDelete () )
		{
			BOOL t_Impersonating ;
			IUnknown *t_OldContext ;
			IServerSecurity *t_OldSecurity ;
			BOOL t_IsProxy ;
			IWbemServices *t_Interface ;
			BOOL t_Revert ;
			IUnknown *t_Proxy ;

			t_Result = Begin_IWbemServices (

				t_Impersonating ,
				t_OldContext ,
				t_OldSecurity ,
				t_IsProxy ,
				t_Interface ,
				t_Revert ,
				t_Proxy
			) ;

			if ( SUCCEEDED ( t_Result ) )
			{
				t_Result = Helper_DeleteInstanceAsync ( 

					t_IsProxy ,
					a_ObjectPath ,
					a_Flags , 
					a_Context ,
					a_Sink ,
					t_Interface
				) ;

				End_IWbemServices (

					t_Impersonating ,
					t_OldContext ,
					t_OldSecurity ,
					t_IsProxy ,
					t_Interface ,
					t_Revert ,
					t_Proxy
				) ;
			}
		}
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_DecoupledClient :: CreateInstanceEnum ( 

	const BSTR a_Class ,
	long a_Flags , 
	IWbemContext *a_Context , 
	IEnumWbemClassObject **a_Enum
)
{
	return WBEM_E_NOT_AVAILABLE ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_DecoupledClient :: Helper_CreateInstanceEnumAsync (

	BOOL a_IsProxy ,
 	const BSTR a_Class ,
	long a_Flags ,
	IWbemContext *a_Context ,
	IWbemObjectSink *a_Sink ,
	IWbemServices *a_Service 
) 
{
	HRESULT t_Result = S_OK ;

	a_Flags = ( a_Flags & ~WBEM_FLAG_DIRECT_READ ) ;

	IWbemContext *t_ContextCopy = NULL ;
	if ( a_Context )
	{
		t_Result = a_Context->Clone ( & t_ContextCopy ) ;
		AdjustGetContext ( t_ContextCopy ) ;
	}
	else
	{
		t_Result = S_OK ;
	}

	if ( SUCCEEDED ( t_Result ) )
	{
		ULONG t_Dependant = 1 ;

		if ( a_Context )
		{
			_IWmiContext *t_CallContext = NULL ;

			HRESULT t_Test = a_Context->QueryInterface ( IID__IWmiContext , ( void **) & t_CallContext ) ;
			if ( SUCCEEDED ( t_Test ) )
			{
				t_Test = t_CallContext->Get (
        
					WMI_CTX_INF_DEPENDENT ,
					& t_Dependant 
				);

				if ( SUCCEEDED ( t_Test ) )
				{
				}

				t_CallContext->Release () ;
			}
		}

		CDecoupled_Batching_IWbemSyncObjectSink *t_Sink = new CDecoupled_Batching_IWbemSyncObjectSink (

			m_Allocator ,
			a_Sink , 
			( IWbemServices * ) this , 
			( CWbemGlobal_IWmiObjectSinkController * ) this ,
			FALSE
		) ;

		if ( t_Sink )
		{
			t_Sink->AddRef () ;

			t_Result = t_Sink->SinkInitialize () ;
			if ( SUCCEEDED ( t_Result ) )
			{
				CWbemGlobal_IWmiObjectSinkController_Container_Iterator t_Iterator ;

				Lock () ;

				WmiStatusCode t_StatusCode = Insert ( 

					*t_Sink ,
					t_Iterator
				) ;

				if ( t_StatusCode == e_StatusCode_Success ) 
				{
					UnLock () ;

					if ( m_Registration->GetComRegistration ().GetSupportsSendStatus () == FALSE )
					{
						a_Flags = ( a_Flags & ( ~WBEM_FLAG_SEND_STATUS ) ) ;
					}

					if ( a_IsProxy )
					{
						t_Result = CoImpersonateClient () ;
					}
					else
					{
						t_Result = S_OK ;
					}

					if ( SUCCEEDED ( t_Result ) )
					{
						Increment_ProviderOperation_CreateInstanceEnumAsync () ;

						try
						{
							t_Result = a_Service->CreateInstanceEnumAsync (

 								a_Class ,
								a_Flags ,
								t_ContextCopy ,
								t_Sink 
							) ;
						}
						catch ( ... )
						{
							t_Result = WBEM_E_PROVIDER_FAILURE ;
						}

						CoRevertToSelf () ;
					}
					else
					{
						t_Result = WBEM_E_ACCESS_DENIED ;
					}

					if ( t_Result == WBEM_E_UNSUPPORTED_PARAMETER || t_Result == WBEM_E_INVALID_PARAMETER )
					{
						if ( a_IsProxy )
						{
							t_Result = CoImpersonateClient () ;
						}
						else
						{
							t_Result = S_OK ;
						}

						if ( SUCCEEDED ( t_Result ) )
						{
							a_Flags = ( a_Flags & ~WBEM_FLAG_SEND_STATUS ) ;

							Increment_ProviderOperation_CreateInstanceEnumAsync () ;

							try
							{
								t_Result = a_Service->CreateInstanceEnumAsync (

 									a_Class ,
									a_Flags ,
									t_ContextCopy ,
									t_Sink 
								) ;
							}
							catch ( ... )
							{
								t_Result = WBEM_E_PROVIDER_FAILURE ;
							}

							CoRevertToSelf () ;
						}
					}
				}
				else
				{
					UnLock () ;

					t_Result = WBEM_E_OUT_OF_MEMORY ;
				}
			}

			if ( FAILED ( t_Result ) )
			{
				HRESULT t_TempResult = SetStatus ( L"CreateInstanceEnumAsync" , NULL , NULL , t_Result , t_Sink ) ;
			}

			t_Sink->Release () ;
		}
		else
		{
			t_Result = WBEM_E_OUT_OF_MEMORY ;
		}
	}
	else
	{
		t_Result = WBEM_E_OUT_OF_MEMORY ;
	}

	if ( t_ContextCopy )
	{
		t_ContextCopy->Release () ;
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_DecoupledClient :: CreateInstanceEnumAsync (

 	const BSTR a_Class ,
	long a_Flags ,
	IWbemContext *a_Context ,
	IWbemObjectSink *a_Sink 
) 
{
	HRESULT t_Result = WBEM_E_PROVIDER_NOT_CAPABLE ;

	if ( m_Provider_IWbemServices )
	{
		if ( m_Registration->GetInstanceProviderRegistration ().SupportsEnumeration () )
		{
			BOOL t_Impersonating ;
			IUnknown *t_OldContext ;
			IServerSecurity *t_OldSecurity ;
			BOOL t_IsProxy ;
			IWbemServices *t_Interface ;
			BOOL t_Revert ;
			IUnknown *t_Proxy ;

			t_Result = Begin_IWbemServices (

				t_Impersonating ,
				t_OldContext ,
				t_OldSecurity ,
				t_IsProxy ,
				t_Interface ,
				t_Revert ,
				t_Proxy
			) ;

			if ( SUCCEEDED ( t_Result ) )
			{
				t_Result = Helper_CreateInstanceEnumAsync ( 

					t_IsProxy ,
					a_Class ,
					a_Flags , 
					a_Context ,
					a_Sink ,
					t_Interface
				) ;

				End_IWbemServices (

					t_Impersonating ,
					t_OldContext ,
					t_OldSecurity ,
					t_IsProxy ,
					t_Interface ,
					t_Revert ,
					t_Proxy
				) ;
			}
		}
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_DecoupledClient :: ExecQuery ( 

	const BSTR a_QueryLanguage ,
	const BSTR a_Query ,
	long a_Flags ,
	IWbemContext *a_Context ,
	IEnumWbemClassObject **a_Enum
)
{
	return WBEM_E_NOT_AVAILABLE ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_DecoupledClient :: Helper_ExecQueryAsync (

	BOOL a_IsProxy ,
	const BSTR a_QueryLanguage ,
	const BSTR a_Query, 
	long a_Flags ,
	IWbemContext FAR *a_Context ,
	IWbemObjectSink *a_Sink ,
	IWbemServices *a_Service 
) 
{
	HRESULT t_Result = S_OK ;

	a_Flags = ( a_Flags & ~WBEM_FLAG_DIRECT_READ ) ;

	IWbemContext *t_ContextCopy = NULL ;

	if ( SUCCEEDED ( t_Result ) )
	{
		if ( a_Context )
		{
			t_Result = a_Context->Clone ( & t_ContextCopy ) ;
			if ( SUCCEEDED ( t_Result ) )
			{
			}
			else
			{
				t_Result = WBEM_E_OUT_OF_MEMORY ;
			}
		}
		else
		{
			t_Result = S_OK ;
		}
	}

	if ( SUCCEEDED ( t_Result ) )
	{
		ULONG t_Dependant = 1 ;

		if ( a_Context )
		{
			_IWmiContext *t_CallContext = NULL ;
			HRESULT t_Test = a_Context->QueryInterface ( IID__IWmiContext , ( void **) & t_CallContext ) ;
			if ( SUCCEEDED ( t_Test ) )
			{
				t_Test = t_CallContext->Get (
        
					WMI_CTX_INF_DEPENDENT ,
					& t_Dependant 
				);

				if ( SUCCEEDED ( t_Test ) )
				{
				}

				t_CallContext->Release () ;
			}
		}

		if ( ( m_Registration->GetInstanceProviderRegistration ().QuerySupportLevels () & e_QuerySupportLevels_UnarySelect ) ||  ( m_Registration->GetInstanceProviderRegistration ().QuerySupportLevels () & e_QuerySupportLevels_V1ProviderDefined ) ) 
		{
			CDecoupled_Batching_IWbemSyncObjectSink *t_Sink = new CDecoupled_Batching_IWbemSyncObjectSink (

				m_Allocator ,
				a_Sink , 
				( IWbemServices * ) this , 
				( CWbemGlobal_IWmiObjectSinkController * ) this ,
				FALSE
			) ;

			if ( t_Sink )
			{
				t_Sink->AddRef () ;

				t_Result = t_Sink->SinkInitialize () ;
				if ( SUCCEEDED ( t_Result ) )
				{
					CWbemGlobal_IWmiObjectSinkController_Container_Iterator t_Iterator ;

					Lock () ;

					WmiStatusCode t_StatusCode = Insert ( 

						*t_Sink ,
						t_Iterator
					) ;

					if ( t_StatusCode == e_StatusCode_Success ) 
					{
						UnLock () ;

						if ( m_Registration->GetComRegistration ().GetSupportsSendStatus () == FALSE )
						{
							a_Flags = ( a_Flags & ( ~WBEM_FLAG_SEND_STATUS ) ) ;
						}

						if ( a_IsProxy )
						{
							t_Result = CoImpersonateClient () ;
						}
						else
						{
							t_Result = S_OK ;
						}

						if ( SUCCEEDED ( t_Result ) )
						{
							Increment_ProviderOperation_ExecQueryAsync () ;

							try
							{
								t_Result = a_Service->ExecQueryAsync (

									a_QueryLanguage ,
									a_Query, 
									a_Flags ,
									t_ContextCopy ,
									t_Sink 
								) ;
							}
							catch ( ... )
							{
								t_Result = WBEM_E_PROVIDER_FAILURE ;
							}

							CoRevertToSelf () ;
						}
						else
						{
							t_Result = WBEM_E_ACCESS_DENIED ;
						}

						if ( t_Result == WBEM_E_UNSUPPORTED_PARAMETER || t_Result == WBEM_E_INVALID_PARAMETER )
						{
							a_Flags = ( a_Flags & ~WBEM_FLAG_SEND_STATUS ) ;

							if ( a_IsProxy )
							{
								t_Result = CoImpersonateClient () ;
							}
							else
							{
								t_Result = S_OK ;
							}

							if ( SUCCEEDED ( t_Result ) ) 
							{
								Increment_ProviderOperation_ExecQueryAsync () ;

								try
								{
									t_Result = a_Service->ExecQueryAsync (

										a_QueryLanguage ,
										a_Query, 
										a_Flags ,
										t_ContextCopy ,
										t_Sink 
									) ;
								}
								catch ( ... )
								{
									t_Result = WBEM_E_PROVIDER_FAILURE ;
								}

								CoRevertToSelf () ;
							}
							else
							{
								t_Result = WBEM_E_ACCESS_DENIED ;
							}
						}
					}
					else
					{
						UnLock () ;

						t_Result = WBEM_E_OUT_OF_MEMORY ;
					}

					if ( FAILED ( t_Result ) )
					{
						HRESULT t_TempResult = SetStatus ( L"ExecQueryAsync" , NULL , NULL , t_Result , t_Sink ) ;
					}
				}

				t_Sink->Release () ;
			}
			else
			{
				t_Result = WBEM_E_OUT_OF_MEMORY ;
			}
		}
		else if ( m_Registration->GetInstanceProviderRegistration ().SupportsEnumeration () )
		{
			IWbemQuery *t_QueryFilter = NULL ;
			t_Result = ProviderSubSystem_Common_Globals :: CreateInstance	(

				CLSID_WbemQuery ,
				NULL ,
				CLSCTX_INPROC_SERVER | CLSCTX_LOCAL_SERVER ,
				IID_IWbemQuery ,
				( void ** ) & t_QueryFilter
			) ;

			if ( SUCCEEDED ( t_Result ) )
			{
				t_Result = t_QueryFilter->Parse ( 

					a_QueryLanguage ,
					a_Query , 
					0 
				) ;

				if ( SUCCEEDED ( t_Result ) )
				{
					SWbemRpnEncodedQuery *t_Expression = NULL ;

					t_Result = t_QueryFilter->GetAnalysis (

						WMIQ_ANALYSIS_RPN_SEQUENCE ,
						0 ,
						( void ** ) & t_Expression
					) ;

					if ( SUCCEEDED ( t_Result ) )
					{
						if ( t_Expression->m_uFromTargetType == WMIQ_RPN_FROM_UNARY )
						{
							BSTR t_Class = SysAllocString ( t_Expression->m_ppszFromList [ 0 ] ) ;
							if ( t_Class )
							{
								CDecoupled_Batching_IWbemSyncObjectSink *t_Sink = new CDecoupled_Batching_IWbemSyncObjectSink (

									m_Allocator ,
									a_Sink , 
									( IWbemServices * ) this , 
									( CWbemGlobal_IWmiObjectSinkController * ) this ,
									FALSE
								) ;

								if ( t_Sink )
								{
									t_Sink->AddRef () ;

									t_Result = t_Sink->SinkInitialize () ;
									if ( SUCCEEDED ( t_Result ) )
									{
										a_Sink->SetStatus ( WBEM_STATUS_REQUIREMENTS , 0 , NULL , NULL ) ;

										CWbemGlobal_IWmiObjectSinkController_Container_Iterator t_Iterator ;

										Lock () ;

										WmiStatusCode t_StatusCode = Insert ( 

											*t_Sink ,
											t_Iterator
										) ;

										if ( t_StatusCode == e_StatusCode_Success ) 
										{
											UnLock () ;

											if ( m_Registration->GetComRegistration ().GetSupportsSendStatus () == FALSE )
											{
												a_Flags = ( a_Flags & ( ~WBEM_FLAG_SEND_STATUS ) ) ;
											}

											if ( a_IsProxy )
											{
												t_Result = CoImpersonateClient () ;
											}
											else
											{
												t_Result = S_OK ;
											}

											if ( SUCCEEDED ( t_Result ) )
											{
												a_Sink->SetStatus ( WBEM_STATUS_REQUIREMENTS , 0 , NULL , NULL ) ;

												Increment_ProviderOperation_CreateInstanceEnumAsync () ;

												try
												{
													t_Result = a_Service->CreateInstanceEnumAsync (

 														t_Class ,
														a_Flags ,
														t_ContextCopy ,
														t_Sink 
													) ;
												}
												catch ( ... )
												{
													t_Result = WBEM_E_PROVIDER_FAILURE ;
												}
				
												CoRevertToSelf () ;
											}
											else
											{
												t_Result = WBEM_E_ACCESS_DENIED ;
											}

											if ( t_Result == WBEM_E_UNSUPPORTED_PARAMETER || t_Result == WBEM_E_INVALID_PARAMETER )
											{
												a_Flags = ( a_Flags & ~WBEM_FLAG_SEND_STATUS ) ;

												if ( a_IsProxy )
												{
													t_Result = CoImpersonateClient () ;
												}
												else
												{
													t_Result = S_OK ;
												}

												if ( SUCCEEDED ( t_Result ) ) 
												{
													Increment_ProviderOperation_CreateInstanceEnumAsync () ;

													try
													{
														t_Result = a_Service->CreateInstanceEnumAsync (

 															t_Class ,
															a_Flags ,
															t_ContextCopy ,
															t_Sink 
														) ;
													}
													catch ( ... )
													{
														t_Result = WBEM_E_PROVIDER_FAILURE ;
													}
					
													CoRevertToSelf () ;
												}
												else
												{
													t_Result = WBEM_E_ACCESS_DENIED ;
												}
											}
										}
										else
										{
											t_Result = WBEM_E_OUT_OF_MEMORY ;
										}
									}

									if ( FAILED ( t_Result ) )
									{
										HRESULT t_TempResult = SetStatus ( L"CreateInstanceEnumAsync" , NULL , NULL , t_Result , t_Sink ) ;
									}

                                    t_Sink->Release () ;
								}
								else
								{
									SysFreeString ( t_Class ) ;

									t_Result = WBEM_E_OUT_OF_MEMORY ;
								}
							}
							else
							{
								t_Result = WBEM_E_OUT_OF_MEMORY ;
							}
						}
						else
						{
							t_Result = WBEM_E_NOT_SUPPORTED ;
						}

						t_QueryFilter->FreeMemory ( t_Expression ) ;
					}
					else
					{
						t_Result = WBEM_E_UNEXPECTED ;
					}
				}
				else
				{
					t_Result = WBEM_E_NOT_SUPPORTED ;
				}

				t_QueryFilter->Release () ;
			}
			else
			{
				t_Result = WBEM_E_CRITICAL_ERROR ;
			}
		}
		else
		{
			t_Result = WBEM_E_NOT_SUPPORTED ;
		}
	}

	if ( t_ContextCopy )
	{
		t_ContextCopy->Release () ;
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_DecoupledClient :: ExecQueryAsync ( 
		
	const BSTR a_QueryLanguage ,
	const BSTR a_Query, 
	long a_Flags , 
	IWbemContext *a_Context ,
	IWbemObjectSink *a_Sink
) 
{
	HRESULT t_Result = WBEM_E_PROVIDER_NOT_CAPABLE ;

	if ( m_Provider_IWbemServices )
	{
		if ( ( m_Registration->GetInstanceProviderRegistration ().QuerySupportLevels () & e_QuerySupportLevels_UnarySelect ) || ( m_Registration->GetInstanceProviderRegistration ().QuerySupportLevels () & e_QuerySupportLevels_V1ProviderDefined ) || ( m_Registration->GetInstanceProviderRegistration ().SupportsEnumeration () ) )
		{
			BOOL t_Impersonating ;
			IUnknown *t_OldContext ;
			IServerSecurity *t_OldSecurity ;
			BOOL t_IsProxy ;
			IWbemServices *t_Interface ;
			BOOL t_Revert ;
			IUnknown *t_Proxy ;

			t_Result = Begin_IWbemServices (

				t_Impersonating ,
				t_OldContext ,
				t_OldSecurity ,
				t_IsProxy ,
				t_Interface ,
				t_Revert ,
				t_Proxy
			) ;

			if ( SUCCEEDED ( t_Result ) )
			{
				t_Result = Helper_ExecQueryAsync ( 

					t_IsProxy ,
					a_QueryLanguage ,
					a_Query, 
					a_Flags , 
					a_Context ,
					a_Sink ,
					t_Interface
				) ;

				End_IWbemServices (

					t_Impersonating ,
					t_OldContext ,
					t_OldSecurity ,
					t_IsProxy ,
					t_Interface ,
					t_Revert ,
					t_Proxy
				) ;
			}
		}
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_DecoupledClient :: ExecNotificationQuery ( 

	const BSTR a_QueryLanguage ,
    const BSTR a_Query ,
    long a_Flags ,
    IWbemContext *a_Context ,
    IEnumWbemClassObject **a_Enum
)
{
	return WBEM_E_NOT_AVAILABLE ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/
        
HRESULT CInterceptor_DecoupledClient :: ExecNotificationQueryAsync ( 
            
	const BSTR a_QueryLanguage ,
    const BSTR a_Query ,
    long a_Flags ,
    IWbemContext *a_Context ,
    IWbemObjectSink *a_Sink 
)
{
	return WBEM_E_NOT_AVAILABLE ;
}       

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_DecoupledClient :: ExecMethod (

	const BSTR a_ObjectPath ,
    const BSTR a_MethodName ,
    long a_Flags ,
    IWbemContext *a_Context ,
    IWbemClassObject *a_InParams ,
    IWbemClassObject **a_OutParams ,
    IWbemCallResult **a_CallResult
)
{
	return WBEM_E_NOT_AVAILABLE ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_DecoupledClient :: Helper_ExecMethodAsync (

	BOOL a_IsProxy ,
    const BSTR a_ObjectPath ,
    const BSTR a_MethodName ,
    long a_Flags ,
    IWbemContext *a_Context ,
    IWbemClassObject *a_InParams ,
	IWbemObjectSink *a_Sink ,
	IWbemServices *a_Service 
) 
{
	HRESULT t_Result = S_OK ;

	a_Flags = ( a_Flags & ~WBEM_FLAG_DIRECT_READ ) ;

	IWbemContext *t_ContextCopy = NULL ;
	if ( a_Context )
	{
		t_Result = a_Context->Clone ( & t_ContextCopy ) ;
		AdjustGetContext ( t_ContextCopy ) ;
	}
	else
	{
		t_Result = S_OK ;
	}

	if ( SUCCEEDED ( t_Result ) )
	{
		ULONG t_Dependant = 1 ;

		if ( a_Context )
		{
			_IWmiContext *t_CallContext = NULL ;
			HRESULT t_Test = a_Context->QueryInterface ( IID__IWmiContext , ( void **) & t_CallContext ) ;
			if ( SUCCEEDED ( t_Test ) )
			{
				t_Test = t_CallContext->Get (
        
					WMI_CTX_INF_DEPENDENT ,
					& t_Dependant 
				);

				if ( SUCCEEDED ( t_Test ) )
				{
				}

				t_CallContext->Release () ;
			}
		}

		CDecoupled_IWbemSyncObjectSink *t_Sink = new CDecoupled_IWbemSyncObjectSink (

			m_Allocator ,
			a_Sink , 
			( IWbemServices * ) this , 
			( CWbemGlobal_IWmiObjectSinkController * ) this ,
			FALSE
		) ;

		if ( t_Sink )
		{
			t_Sink->AddRef () ;

			t_Result = t_Sink->SinkInitialize () ;
			if ( SUCCEEDED ( t_Result ) )
			{
				CWbemGlobal_IWmiObjectSinkController_Container_Iterator t_Iterator ;

				Lock () ;

				WmiStatusCode t_StatusCode = Insert ( 

					*t_Sink ,
					t_Iterator
				) ;

				if ( t_StatusCode == e_StatusCode_Success ) 
				{
					UnLock () ;

					if ( m_Registration->GetComRegistration ().GetSupportsSendStatus () == FALSE )
					{
						a_Flags = ( a_Flags & ( ~WBEM_FLAG_SEND_STATUS ) ) ;
					}

					if ( a_IsProxy )
					{
						t_Result = CoImpersonateClient () ;
					}
					else
					{
						t_Result = S_OK ;
					}

					if ( SUCCEEDED ( t_Result ) ) 
					{
						Increment_ProviderOperation_ExecMethodAsync () ;

						try
						{
							t_Result = a_Service->ExecMethodAsync (

 								a_ObjectPath ,
								a_MethodName ,
								a_Flags ,
								t_ContextCopy ,
								a_InParams ,
								t_Sink 
							) ;
						}
						catch ( ... )
						{
							t_Result = WBEM_E_PROVIDER_FAILURE ;
						}

						CoRevertToSelf () ;
					}
					else
					{
						t_Result = WBEM_E_ACCESS_DENIED ;
					}

					if ( t_Result == WBEM_E_UNSUPPORTED_PARAMETER || t_Result == WBEM_E_INVALID_PARAMETER )
					{
						a_Flags = ( a_Flags & ~WBEM_FLAG_SEND_STATUS ) ;

						if ( a_IsProxy )
						{
							t_Result = CoImpersonateClient () ;
						}
						else
						{
							t_Result = S_OK ;
						}

						if ( SUCCEEDED ( t_Result ) ) 
						{
							Increment_ProviderOperation_ExecMethodAsync () ;

							try
							{
								t_Result = a_Service->ExecMethodAsync (

 									a_ObjectPath ,
									a_MethodName ,
									a_Flags ,
									t_ContextCopy ,
									a_InParams ,
									t_Sink 
								) ;
							}
							catch ( ... )
							{
								t_Result = WBEM_E_PROVIDER_FAILURE ;
							}

							CoRevertToSelf () ;
						}
						else
						{
							t_Result = WBEM_E_ACCESS_DENIED ;
						}
					}
				}
				else
				{
					UnLock () ;

					t_Result = WBEM_E_OUT_OF_MEMORY ;
				}

				if ( FAILED ( t_Result ) )
				{
					HRESULT t_TempResult = SetStatus ( L"ExecMethodAsync" , NULL , NULL , t_Result , t_Sink ) ;
				}
			}

			t_Sink->Release () ;
		}
		else
		{
			t_Result = WBEM_E_OUT_OF_MEMORY ;
		}
	}
	else
	{
		t_Result = WBEM_E_OUT_OF_MEMORY ;
	}

	if ( t_ContextCopy )
	{
		t_ContextCopy->Release () ;
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_DecoupledClient :: ExecMethodAsync ( 
		
    const BSTR a_ObjectPath ,
    const BSTR a_MethodName ,
    long a_Flags ,
    IWbemContext *a_Context ,
    IWbemClassObject *a_InParams ,
	IWbemObjectSink *a_Sink
) 
{
	HRESULT t_Result = WBEM_E_PROVIDER_NOT_CAPABLE ;

	if ( m_Provider_IWbemServices )
	{
		if ( m_Registration->GetMethodProviderRegistration ().SupportsMethods () )
		{
			BOOL t_Impersonating ;
			IUnknown *t_OldContext ;
			IServerSecurity *t_OldSecurity ;
			BOOL t_IsProxy ;
			IWbemServices *t_Interface ;
			BOOL t_Revert ;
			IUnknown *t_Proxy ;

			t_Result = Begin_IWbemServices (

				t_Impersonating ,
				t_OldContext ,
				t_OldSecurity ,
				t_IsProxy ,
				t_Interface ,
				t_Revert ,
				t_Proxy
			) ;

			if ( SUCCEEDED ( t_Result ) )
			{
				t_Result = Helper_ExecMethodAsync ( 

					t_IsProxy ,
					a_ObjectPath ,
					a_MethodName ,
					a_Flags ,
					a_Context ,
					a_InParams ,
					a_Sink ,
					t_Interface
				) ;

				End_IWbemServices (

					t_Impersonating ,
					t_OldContext ,
					t_OldSecurity ,
					t_IsProxy ,
					t_Interface ,
					t_Revert ,
					t_Proxy
				) ;
			}
		}
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_DecoupledClient :: GetProperty (

    long a_Flags ,
    const BSTR a_Locale ,
    const BSTR a_ClassMapping ,
    const BSTR a_InstanceMapping ,
    const BSTR a_PropertyMapping ,
    VARIANT *a_Value
)
{
	if ( m_Provider_IWbemPropertyProvider )
	{
		if ( m_Registration->GetPropertyProviderRegistration ().SupportsGet () )
		{
			Increment_ProviderOperation_GetProperty () ;

			HRESULT t_Result = S_OK ;

			try
			{
				t_Result = m_Provider_IWbemPropertyProvider->GetProperty ( 

					a_Flags ,
					a_Locale ,
					a_ClassMapping ,
					a_InstanceMapping ,
					a_PropertyMapping ,
					a_Value
				) ;

				CoRevertToSelf () ;
			}
			catch ( ... )
			{
				t_Result = WBEM_E_PROVIDER_FAILURE ;

				CoRevertToSelf () ;
			}

			return t_Result ;
		}
	}

	return WBEM_E_PROVIDER_NOT_CAPABLE;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_DecoupledClient :: PutProperty (

    long a_Flags ,
    const BSTR a_Locale ,
    const BSTR a_ClassMapping ,
    const BSTR a_InstanceMapping ,
    const BSTR a_PropertyMapping ,
    const VARIANT *a_Value
)
{
	if ( m_Provider_IWbemPropertyProvider )
	{
		if ( m_Registration->GetPropertyProviderRegistration ().SupportsPut () )
		{
			Increment_ProviderOperation_PutProperty () ;

			HRESULT t_Result = S_OK ;

			try
			{
				t_Result = m_Provider_IWbemPropertyProvider->PutProperty ( 

					a_Flags ,
					a_Locale ,
					a_ClassMapping ,
					a_InstanceMapping ,
					a_PropertyMapping ,
					a_Value
				) ;

				CoRevertToSelf () ;

				return t_Result ;
			}
			catch ( ... )
			{
				t_Result = WBEM_E_PROVIDER_FAILURE ;

				CoRevertToSelf () ;
			}

			return t_Result ;
		}
	}

	return WBEM_E_PROVIDER_NOT_CAPABLE;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_DecoupledClient ::ProvideEvents (

	IWbemObjectSink *a_Sink ,
	long a_Flags
)
{
	if ( m_Provider_IWbemEventProvider )
	{
		BOOL t_Impersonating = FALSE ;
		IUnknown *t_OldContext = NULL ;
		IServerSecurity *t_OldSecurity = NULL ;

		HRESULT t_Result = ProviderSubSystem_Common_Globals :: BeginImpersonation ( t_OldContext , t_OldSecurity , t_Impersonating ) ;
		if ( SUCCEEDED ( t_Result ) ) 
		{
			BOOL t_Revert = FALSE ;
			IUnknown *t_Proxy = NULL ;

			t_Result = ProviderSubSystem_Common_Globals :: SetProxyState ( m_ProxyContainer , ProxyIndex_IWbemEventProvider , IID_IWbemEventProvider , m_Provider_IWbemEventProvider , t_Proxy , t_Revert ) ;
			if ( t_Result == WBEM_E_NOT_FOUND )
			{
				Increment_ProviderOperation_ProvideEvents () ;

				try
				{
					t_Result = m_Provider_IWbemEventProvider->ProvideEvents (

						a_Sink ,
						a_Flags 
					) ;
				}
				catch ( ... )
				{
					t_Result = WBEM_E_PROVIDER_FAILURE ;
				}

				CoRevertToSelf () ;
			}
			else 
			{
				if ( SUCCEEDED ( t_Result ) )
				{
					IWbemEventProvider *t_Provider = ( IWbemEventProvider * ) t_Proxy ;

					// Set cloaking on the proxy
					// =========================

					DWORD t_ImpersonationLevel = ProviderSubSystem_Common_Globals :: GetCurrentImpersonationLevel () ;

					t_Result = ProviderSubSystem_Common_Globals :: SetCloaking (

						t_Provider ,
						RPC_C_AUTHN_LEVEL_CONNECT , 
						t_ImpersonationLevel
					) ;

					if ( SUCCEEDED ( t_Result ) )
					{
						t_Result = CoImpersonateClient () ;
						if ( SUCCEEDED ( t_Result ) )
						{
							Increment_ProviderOperation_ProvideEvents () ;

							try
							{
								t_Result = t_Provider->ProvideEvents (

									a_Sink ,
									a_Flags 
								) ;
							}
							catch ( ... )
							{
								t_Result = WBEM_E_PROVIDER_FAILURE ;
							}

							CoRevertToSelf () ;
						}
						else
						{
							t_Result = WBEM_E_ACCESS_DENIED ;
						}
					}

					HRESULT t_TempResult = ProviderSubSystem_Common_Globals :: RevertProxyState ( m_ProxyContainer , ProxyIndex_IWbemEventProvider , t_Proxy , t_Revert ) ;
				}
			}

			ProviderSubSystem_Common_Globals :: EndImpersonation ( t_OldContext , t_OldSecurity , t_Impersonating ) ;
		}

		return t_Result ;
	}

	return WBEM_E_PROVIDER_NOT_CAPABLE;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_DecoupledClient ::NewQuery (

	unsigned long a_Id ,
	WBEM_WSTR a_QueryLanguage ,
	WBEM_WSTR a_Query
)
{
	if ( m_Provider_IWbemEventProviderQuerySink )
	{
		BOOL t_Impersonating = FALSE ;
		IUnknown *t_OldContext = NULL ;
		IServerSecurity *t_OldSecurity = NULL ;

		HRESULT t_Result = ProviderSubSystem_Common_Globals :: BeginImpersonation ( t_OldContext , t_OldSecurity , t_Impersonating ) ;
		if ( SUCCEEDED ( t_Result ) ) 
		{
			BOOL t_Revert = FALSE ;
			IUnknown *t_Proxy = NULL ;

			t_Result = ProviderSubSystem_Common_Globals :: SetProxyState ( m_ProxyContainer , ProxyIndex_IWbemEventProviderQuerySink , IID_IWbemEventProviderQuerySink , m_Provider_IWbemEventProviderQuerySink , t_Proxy , t_Revert ) ;
			if ( t_Result == WBEM_E_NOT_FOUND )
			{
				Increment_ProviderOperation_NewQuery () ;

				try
				{
					t_Result = m_Provider_IWbemEventProviderQuerySink->NewQuery (

						a_Id ,
						a_QueryLanguage ,
						a_Query
					) ;
				}
				catch ( ... )
				{
					t_Result = WBEM_E_PROVIDER_FAILURE ;
				}

				CoRevertToSelf () ;
			}
			else 
			{
				if ( SUCCEEDED ( t_Result ) )
				{
					IWbemEventProviderQuerySink *t_Provider = ( IWbemEventProviderQuerySink * ) t_Proxy ;

					// Set cloaking on the proxy
					// =========================

					DWORD t_ImpersonationLevel = ProviderSubSystem_Common_Globals :: GetCurrentImpersonationLevel () ;

					t_Result = ProviderSubSystem_Common_Globals :: SetCloaking (

						t_Provider ,
						RPC_C_AUTHN_LEVEL_CONNECT , 
						t_ImpersonationLevel
					) ;

					if ( SUCCEEDED ( t_Result ) )
					{
						t_Result = CoImpersonateClient () ;
						if ( SUCCEEDED ( t_Result ) )
						{
							Increment_ProviderOperation_NewQuery () ;

							try
							{
								t_Result = t_Provider->NewQuery (

									a_Id ,
									a_QueryLanguage ,
									a_Query
								) ;
							}
							catch ( ... )
							{
								t_Result = WBEM_E_PROVIDER_FAILURE ;
							}

							CoRevertToSelf () ;
						}
						else
						{
							t_Result = WBEM_E_ACCESS_DENIED ;
						}
					}

					HRESULT t_TempResult = ProviderSubSystem_Common_Globals :: RevertProxyState ( m_ProxyContainer , ProxyIndex_IWbemEventProviderQuerySink , t_Proxy , t_Revert ) ;
				}
			}

			ProviderSubSystem_Common_Globals :: EndImpersonation ( t_OldContext , t_OldSecurity , t_Impersonating ) ;
		}

		return t_Result ;
	}

	return WBEM_E_PROVIDER_NOT_CAPABLE;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_DecoupledClient ::CancelQuery (

	unsigned long a_Id
)
{
	if ( m_Provider_IWbemEventProviderQuerySink )
	{
		BOOL t_Impersonating = FALSE ;
		IUnknown *t_OldContext = NULL ;
		IServerSecurity *t_OldSecurity = NULL ;

		HRESULT t_Result = ProviderSubSystem_Common_Globals :: BeginImpersonation ( t_OldContext , t_OldSecurity , t_Impersonating ) ;
		if ( SUCCEEDED ( t_Result ) ) 
		{
			BOOL t_Revert = FALSE ;
			IUnknown *t_Proxy = NULL ;

			t_Result = ProviderSubSystem_Common_Globals :: SetProxyState ( m_ProxyContainer , ProxyIndex_IWbemEventProviderQuerySink , IID_IWbemEventProviderQuerySink , m_Provider_IWbemEventProviderQuerySink , t_Proxy , t_Revert ) ;
			if ( t_Result == WBEM_E_NOT_FOUND )
			{
				Increment_ProviderOperation_CancelQuery () ;

				try
				{
					t_Result = m_Provider_IWbemEventProviderQuerySink->CancelQuery (

						a_Id
					) ;
				}
				catch ( ... )
				{
					t_Result = WBEM_E_PROVIDER_FAILURE ;
				}

				CoRevertToSelf () ;
			}
			else 
			{
				if ( SUCCEEDED ( t_Result ) )
				{
					IWbemEventProviderQuerySink *t_Provider = ( IWbemEventProviderQuerySink * ) t_Proxy ;

					// Set cloaking on the proxy
					// =========================

					DWORD t_ImpersonationLevel = ProviderSubSystem_Common_Globals :: GetCurrentImpersonationLevel () ;

					t_Result = ProviderSubSystem_Common_Globals :: SetCloaking (

						t_Provider ,
						RPC_C_AUTHN_LEVEL_CONNECT , 
						t_ImpersonationLevel
					) ;

					if ( SUCCEEDED ( t_Result ) )
					{
						t_Result = CoImpersonateClient () ;
						if ( SUCCEEDED ( t_Result ) )
						{
							Increment_ProviderOperation_CancelQuery () ;

							try
							{
								t_Result = t_Provider->CancelQuery (

									a_Id
								) ;
							}
							catch ( ... )
							{
								t_Result = WBEM_E_PROVIDER_FAILURE ;
							}

							CoRevertToSelf () ;
						}
						else
						{
							t_Result = WBEM_E_ACCESS_DENIED ;
						}
					}

					HRESULT t_TempResult = ProviderSubSystem_Common_Globals :: RevertProxyState ( m_ProxyContainer , ProxyIndex_IWbemEventProviderQuerySink , t_Proxy , t_Revert ) ;
				}
			}

			ProviderSubSystem_Common_Globals :: EndImpersonation ( t_OldContext , t_OldSecurity , t_Impersonating ) ;
		}

		return t_Result ;
	}

	return WBEM_E_PROVIDER_NOT_CAPABLE;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_DecoupledClient ::AccessCheck (

	WBEM_CWSTR a_QueryLanguage ,
	WBEM_CWSTR a_Query ,
	long a_SidLength ,
	const BYTE *a_Sid
)
{
	if ( m_Provider_IWbemEventProviderSecurity )
	{
		BOOL t_Impersonating = FALSE ;
		IUnknown *t_OldContext = NULL ;
		IServerSecurity *t_OldSecurity = NULL ;

		HRESULT t_Result = ProviderSubSystem_Common_Globals :: BeginImpersonation ( t_OldContext , t_OldSecurity , t_Impersonating ) ;
		if ( SUCCEEDED ( t_Result ) ) 
		{
			BOOL t_Revert = FALSE ;
			IUnknown *t_Proxy = NULL ;

			t_Result = ProviderSubSystem_Common_Globals :: SetProxyState ( m_ProxyContainer , ProxyIndex_IWbemEventProviderSecurity , IID_IWbemEventProviderSecurity , m_Provider_IWbemEventProviderSecurity , t_Proxy , t_Revert ) ;
			if ( t_Result == WBEM_E_NOT_FOUND )
			{
				Increment_ProviderOperation_AccessCheck () ;

				try
				{
					t_Result = m_Provider_IWbemEventProviderSecurity->AccessCheck (

						a_QueryLanguage ,
						a_Query ,
						a_SidLength ,
						a_Sid
					) ;
				}
				catch ( ... )
				{
					t_Result = WBEM_E_PROVIDER_FAILURE ;
				}

				CoRevertToSelf () ;
			}
			else 
			{
				if ( SUCCEEDED ( t_Result ) )
				{
					IWbemEventProviderSecurity *t_Provider = ( IWbemEventProviderSecurity * ) t_Proxy ;

					// Set cloaking on the proxy
					// =========================

					DWORD t_ImpersonationLevel = ProviderSubSystem_Common_Globals :: GetCurrentImpersonationLevel () ;

					t_Result = ProviderSubSystem_Common_Globals :: SetCloaking (

						t_Provider ,
						RPC_C_AUTHN_LEVEL_CONNECT , 
						t_ImpersonationLevel
					) ;

					if ( SUCCEEDED ( t_Result ) )
					{
						t_Result = CoImpersonateClient () ;
						if ( SUCCEEDED ( t_Result ) )
						{
							Increment_ProviderOperation_AccessCheck () ;

							try
							{
								t_Result = t_Provider->AccessCheck (

									a_QueryLanguage ,
									a_Query ,
									a_SidLength ,
									a_Sid
								) ;
							}
							catch ( ... )
							{
								t_Result = WBEM_E_PROVIDER_FAILURE ;
							}

							CoRevertToSelf () ;
						}
						else
						{
							t_Result = WBEM_E_ACCESS_DENIED ;
						}
					}

					HRESULT t_TempResult = ProviderSubSystem_Common_Globals :: RevertProxyState ( m_ProxyContainer , ProxyIndex_IWbemEventProviderSecurity , t_Proxy , t_Revert ) ;
				}
			}

			ProviderSubSystem_Common_Globals :: EndImpersonation ( t_OldContext , t_OldSecurity , t_Impersonating ) ;
		}

		return t_Result ;
	}

	return WBEM_E_PROVIDER_NOT_CAPABLE;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_DecoupledClient ::SetRegistrationObject (

	long a_Flags ,
	IWbemClassObject *a_ProviderRegistration
)
{
	if ( m_Provider_IWbemProviderIdentity )
	{
		BOOL t_Impersonating = FALSE ;
		IUnknown *t_OldContext = NULL ;
		IServerSecurity *t_OldSecurity = NULL ;

		HRESULT t_Result = ProviderSubSystem_Common_Globals :: BeginImpersonation ( t_OldContext , t_OldSecurity , t_Impersonating ) ;
		if ( SUCCEEDED ( t_Result ) ) 
		{
			BOOL t_Revert = FALSE ;
			IUnknown *t_Proxy = NULL ;

			t_Result = ProviderSubSystem_Common_Globals :: SetProxyState ( m_ProxyContainer , ProxyIndex_IWbemProviderIdentity , IID_IWbemProviderIdentity , m_Provider_IWbemProviderIdentity , t_Proxy , t_Revert ) ;
			if ( t_Result == WBEM_E_NOT_FOUND )
			{
				Increment_ProviderOperation_SetRegistrationObject () ;

				try
				{
					t_Result = m_Provider_IWbemProviderIdentity->SetRegistrationObject (

						a_Flags ,
						a_ProviderRegistration
					) ;
				}
				catch ( ... )
				{
					t_Result = WBEM_E_PROVIDER_FAILURE ;
				}

				CoRevertToSelf () ;
			}
			else 
			{
				if ( SUCCEEDED ( t_Result ) )
				{
					IWbemProviderIdentity *t_Provider = ( IWbemProviderIdentity * ) t_Proxy ;

					// Set cloaking on the proxy
					// =========================

					DWORD t_ImpersonationLevel = ProviderSubSystem_Common_Globals :: GetCurrentImpersonationLevel () ;

					t_Result = ProviderSubSystem_Common_Globals :: SetCloaking (

						t_Provider ,
						RPC_C_AUTHN_LEVEL_CONNECT , 
						t_ImpersonationLevel
					) ;

					if ( SUCCEEDED ( t_Result ) )
					{
						t_Result = CoImpersonateClient () ;
						if ( SUCCEEDED ( t_Result ) )
						{
							Increment_ProviderOperation_SetRegistrationObject () ;

							try
							{
								t_Result = t_Provider->SetRegistrationObject (

									a_Flags ,
									a_ProviderRegistration
								) ;
							}
							catch ( ... )
							{
								t_Result = WBEM_E_PROVIDER_FAILURE ;
							}

							CoRevertToSelf () ;
						}
						else
						{
							t_Result = WBEM_E_ACCESS_DENIED ;
						}
					}

					HRESULT t_TempResult = ProviderSubSystem_Common_Globals :: RevertProxyState ( m_ProxyContainer , ProxyIndex_IWbemProviderIdentity , t_Proxy , t_Revert ) ;
				}
			}

			ProviderSubSystem_Common_Globals :: EndImpersonation ( t_OldContext , t_OldSecurity , t_Impersonating ) ;
		}

		return t_Result ;
	}

	return WBEM_E_PROVIDER_NOT_CAPABLE;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_DecoupledClient ::FindConsumer (

	IWbemClassObject *a_LogicalConsumer ,
	IWbemUnboundObjectSink **a_Consumer
)
{
	if ( m_Provider_IWbemEventConsumerProvider )
	{
		IWbemUnboundObjectSink *t_Consumer = NULL ;

		BOOL t_Impersonating = FALSE ;
		IUnknown *t_OldContext = NULL ;
		IServerSecurity *t_OldSecurity = NULL ;

		HRESULT t_Result = ProviderSubSystem_Common_Globals :: BeginImpersonation ( t_OldContext , t_OldSecurity , t_Impersonating ) ;
		if ( SUCCEEDED ( t_Result ) ) 
		{
			BOOL t_Revert = FALSE ;
			IUnknown *t_Proxy = NULL ;

			t_Result = ProviderSubSystem_Common_Globals :: SetProxyState ( m_ProxyContainer , ProxyIndex_IWbemEventConsumerProvider , IID_IWbemEventConsumerProvider , m_Provider_IWbemEventConsumerProvider , t_Proxy , t_Revert ) ;
			if ( t_Result == WBEM_E_NOT_FOUND )
			{
				Increment_ProviderOperation_FindConsumer () ;

				try
				{
					t_Result = m_Provider_IWbemEventConsumerProvider->FindConsumer (

						a_LogicalConsumer ,
						& t_Consumer
					) ;
				}
				catch ( ... )
				{
					t_Result = WBEM_E_PROVIDER_FAILURE ;
				}

				CoRevertToSelf () ;
			}
			else 
			{
				if ( SUCCEEDED ( t_Result ) )
				{
					IWbemEventConsumerProvider *t_Provider = ( IWbemEventConsumerProvider * ) t_Proxy ;

					// Set cloaking on the proxy
					// =========================

					DWORD t_ImpersonationLevel = ProviderSubSystem_Common_Globals :: GetCurrentImpersonationLevel () ;

					t_Result = ProviderSubSystem_Common_Globals :: SetCloaking (

						t_Provider ,
						RPC_C_AUTHN_LEVEL_CONNECT , 
						t_ImpersonationLevel
					) ;

					if ( SUCCEEDED ( t_Result ) )
					{
						t_Result = CoImpersonateClient () ;
						if ( SUCCEEDED ( t_Result ) )
						{
							Increment_ProviderOperation_FindConsumer () ;

							try
							{
								t_Result = t_Provider->FindConsumer (

									a_LogicalConsumer ,
									& t_Consumer
								) ;
							}
							catch ( ... )
							{
								t_Result = WBEM_E_PROVIDER_FAILURE ;
							}

							CoRevertToSelf () ;
						}
						else
						{
							t_Result = WBEM_E_ACCESS_DENIED ;
						}
					}

					HRESULT t_TempResult = ProviderSubSystem_Common_Globals :: RevertProxyState ( m_ProxyContainer , ProxyIndex_IWbemEventConsumerProvider , t_Proxy , t_Revert ) ;
				}
			}

			ProviderSubSystem_Common_Globals :: EndImpersonation ( t_OldContext , t_OldSecurity , t_Impersonating ) ;
		}

		if ( SUCCEEDED ( t_Result ) )
		{
			if ( a_Consumer )
			{
				CInterceptor_IWbemDecoupledUnboundObjectSink *t_UnboundObjectSink = new CInterceptor_IWbemDecoupledUnboundObjectSink (

						m_Allocator ,
						t_Consumer , 
						this ,
						*m_Registration
				) ;

				if ( t_UnboundObjectSink )
				{
					t_UnboundObjectSink->AddRef () ;

					t_Result = t_UnboundObjectSink->Initialize () ;
					if ( SUCCEEDED ( t_Result ) )
					{
						CWbemGlobal_VoidPointerController_Container_Iterator t_Iterator ;

						Lock () ;

						WmiStatusCode t_StatusCode = Insert ( 

							*t_UnboundObjectSink ,
							t_Iterator
						) ;

						if ( t_StatusCode == e_StatusCode_Success ) 
						{
							UnLock () ;

							*a_Consumer = t_UnboundObjectSink ;

							t_UnboundObjectSink->AddRef () ;
						}
						else
						{
							UnLock () ;

							t_Result = WBEM_E_OUT_OF_MEMORY ;
						}
					}

					t_UnboundObjectSink->Release () ;
				}
			}
		}

		if ( t_Consumer )
		{
			t_Consumer->Release () ;
		}

		return t_Result ;
	}

	return WBEM_E_PROVIDER_NOT_CAPABLE;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_DecoupledClient ::ValidateSubscription (

	IWbemClassObject *a_LogicalConsumer
)
{
	if ( m_Provider_IWbemEventConsumerProviderEx )
	{
		BOOL t_Impersonating = FALSE ;
		IUnknown *t_OldContext = NULL ;
		IServerSecurity *t_OldSecurity = NULL ;

		HRESULT t_Result = ProviderSubSystem_Common_Globals :: BeginImpersonation ( t_OldContext , t_OldSecurity , t_Impersonating ) ;
		if ( SUCCEEDED ( t_Result ) ) 
		{
			BOOL t_Revert = FALSE ;
			IUnknown *t_Proxy = NULL ;

			t_Result = ProviderSubSystem_Common_Globals :: SetProxyState ( m_ProxyContainer , ProxyIndex_IWbemEventConsumerProviderEx , IID_IWbemEventConsumerProviderEx , m_Provider_IWbemEventConsumerProviderEx , t_Proxy , t_Revert ) ;
			if ( t_Result == WBEM_E_NOT_FOUND )
			{
				Increment_ProviderOperation_ValidateSubscription () ;

				try
				{
					t_Result = m_Provider_IWbemEventConsumerProviderEx->ValidateSubscription (

						a_LogicalConsumer
					) ;
				}
				catch ( ... )
				{
					t_Result = WBEM_E_PROVIDER_FAILURE ;
				}

				CoRevertToSelf () ;
			}
			else 
			{
				if ( SUCCEEDED ( t_Result ) )
				{
					IWbemEventConsumerProviderEx *t_Provider = ( IWbemEventConsumerProviderEx * ) t_Proxy ;

					// Set cloaking on the proxy
					// =========================

					DWORD t_ImpersonationLevel = ProviderSubSystem_Common_Globals :: GetCurrentImpersonationLevel () ;

					t_Result = ProviderSubSystem_Common_Globals :: SetCloaking (

						t_Provider ,
						RPC_C_AUTHN_LEVEL_CONNECT , 
						t_ImpersonationLevel
					) ;

					if ( SUCCEEDED ( t_Result ) )
					{
						t_Result = CoImpersonateClient () ;
						if ( SUCCEEDED ( t_Result ) )
						{
							Increment_ProviderOperation_ValidateSubscription () ;

							try
							{
								t_Result = t_Provider->ValidateSubscription (

									a_LogicalConsumer
								) ;
							}
							catch ( ... )
							{
								t_Result = WBEM_E_PROVIDER_FAILURE ;
							}

							CoRevertToSelf () ;
						}
						else
						{
							t_Result = WBEM_E_ACCESS_DENIED ;
						}
					}

					HRESULT t_TempResult = ProviderSubSystem_Common_Globals :: RevertProxyState ( m_ProxyContainer , ProxyIndex_IWbemEventConsumerProviderEx , t_Proxy , t_Revert ) ;
				}
			}

			ProviderSubSystem_Common_Globals :: EndImpersonation ( t_OldContext , t_OldSecurity , t_Impersonating ) ;
		}

		return t_Result ;
	}

	return WBEM_E_PROVIDER_NOT_CAPABLE;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_DecoupledClient :: IndicateToConsumer (

	IWbemClassObject *a_LogicalConsumer ,
	long a_ObjectCount ,
	IWbemClassObject **a_Objects
)
{
	if ( m_Provider_IWbemUnboundObjectSink )
	{
		BOOL t_Impersonating = FALSE ;
		IUnknown *t_OldContext = NULL ;
		IServerSecurity *t_OldSecurity = NULL ;

		HRESULT t_Result = ProviderSubSystem_Common_Globals :: BeginImpersonation ( t_OldContext , t_OldSecurity , t_Impersonating ) ;
		if ( SUCCEEDED ( t_Result ) ) 
		{
			BOOL t_Revert = FALSE ;
			IUnknown *t_Proxy = NULL ;

			t_Result = ProviderSubSystem_Common_Globals :: SetProxyState ( m_ProxyContainer , ProxyIndex_IWbemUnboundObjectSink , IID_IWbemUnboundObjectSink , m_Provider_IWbemUnboundObjectSink , t_Proxy , t_Revert ) ;
			if ( t_Result == WBEM_E_NOT_FOUND )
			{
				t_Result = m_Provider_IWbemUnboundObjectSink->IndicateToConsumer (


					a_LogicalConsumer ,
					a_ObjectCount ,
					a_Objects
				) ;
			}
			else 
			{
				if ( SUCCEEDED ( t_Result ) )
				{
					IWbemUnboundObjectSink *t_Provider = ( IWbemUnboundObjectSink * ) t_Proxy ;

					// Set cloaking on the proxy
					// =========================

					DWORD t_ImpersonationLevel = ProviderSubSystem_Common_Globals :: GetCurrentImpersonationLevel () ;

					t_Result = ProviderSubSystem_Common_Globals :: SetCloaking (

						t_Provider ,
						RPC_C_AUTHN_LEVEL_CONNECT , 
						t_ImpersonationLevel
					) ;

					if ( SUCCEEDED ( t_Result ) )
					{
						t_Result = t_Provider->IndicateToConsumer (

							a_LogicalConsumer ,
							a_ObjectCount ,
							a_Objects
						) ;
					}

					HRESULT t_TempResult = ProviderSubSystem_Common_Globals :: RevertProxyState ( m_ProxyContainer , ProxyIndex_IWbemUnboundObjectSink , t_Proxy , t_Revert ) ;
				}
			}

			ProviderSubSystem_Common_Globals :: EndImpersonation ( t_OldContext , t_OldSecurity , t_Impersonating ) ;
		}

		return t_Result ;
	}

	return WBEM_E_PROVIDER_NOT_CAPABLE;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_DecoupledClient :: Initialize (

	LPWSTR a_User ,
	LONG a_Flags ,
	LPWSTR a_Namespace ,
	LPWSTR a_Locale ,
	IWbemServices *a_CoreService ,
	IWbemContext *a_Context ,
	IWbemProviderInitSink *a_Sink
)
{
	HRESULT t_Result = S_OK ;

	if ( m_Unknown )
	{
		IWbemProviderInit *t_Provider = NULL ;

		t_Result = m_Unknown->QueryInterface ( IID_IWbemProviderInit , ( void ** ) & t_Provider ) ;
		if ( SUCCEEDED ( t_Result ) )
		{
			try 
			{
				t_Result = t_Provider->Initialize (

					a_User,
					a_Flags,
					a_Namespace,
					a_Locale,
					a_CoreService,
					a_Context,
					a_Sink
				) ;
			}
			catch ( ... )
			{
				t_Result = WBEM_E_PROVIDER_LOAD_FAILURE ;
			}

			t_Provider->Release () ;
		}
		else
		{
			t_Result = WBEM_E_PROVIDER_LOAD_FAILURE ;
		}
	}
	else
	{
		t_Result = WBEM_E_PROVIDER_LOAD_FAILURE ;
	}

	a_Sink->SetStatus ( t_Result , 0 ) ;

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_DecoupledClient :: Internal_Initialize (

	WmiInternalContext a_InternalContext ,
	LPWSTR a_User ,
	LONG a_Flags ,
	LPWSTR a_Namespace ,
	LPWSTR a_Locale ,
	IWbemServices *a_CoreService ,
	IWbemContext *a_Context ,
	IWbemProviderInitSink *a_Sink
)
{
	BOOL t_Impersonating = FALSE ;
	IUnknown *t_OldContext = NULL ;
	IServerSecurity *t_OldSecurity = NULL ;

	HRESULT t_Result = DecoupledProviderSubSystem_Globals :: Begin_IdentifyCall_PrvHost (

		a_InternalContext ,
		t_Impersonating ,
		t_OldContext ,
		t_OldSecurity
	) ;

	if ( SUCCEEDED ( t_Result ) )
	{
		t_Result = Initialize (

			a_User ,
			a_Flags ,
			a_Namespace ,
			a_Locale ,
			a_CoreService ,
			a_Context ,
			a_Sink
		) ;

		DecoupledProviderSubSystem_Globals :: End_IdentifyCall_PrvHost ( a_InternalContext , t_OldContext , t_OldSecurity , t_Impersonating ) ;
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_DecoupledClient :: ProviderInitialize ()
{
	HRESULT t_Result = S_OK ;

	WmiStatusCode t_StatusCode = CWbemGlobal_IWmiObjectSinkController :: Initialize () ;
	if ( t_StatusCode != e_StatusCode_Success ) 
	{
		t_Result = WBEM_E_OUT_OF_MEMORY ;
	}

	if ( SUCCEEDED ( t_Result ) )
	{
		t_StatusCode = m_ProxyContainer.Initialize () ;
		if ( t_StatusCode != e_StatusCode_Success ) 
		{
			t_Result = WBEM_E_OUT_OF_MEMORY ;
		}
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_DecoupledClient :: GetSite ( DWORD *a_ProcessIdentifier )
{
	HRESULT t_Result = S_OK ;

	if ( a_ProcessIdentifier ) 
	{
		*a_ProcessIdentifier = GetCurrentProcessId () ;
	}
	else
	{
		t_Result = WBEM_E_INVALID_PARAMETER ;
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_DecoupledClient :: SetContainer ( IUnknown *a_Container )
{	
	return WBEM_E_NOT_AVAILABLE ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_DecoupledClient :: Shutdown (

	LONG a_Flags ,
	ULONG a_MaxMilliSeconds ,
	IWbemContext *a_Context
)
{
	HRESULT t_Result = S_OK ;

	IWbemShutdown *t_Shutdown = NULL ;

	if ( m_Unknown )
	{
		t_Result = m_Unknown->QueryInterface ( IID_IWbemShutdown , ( void ** ) & t_Shutdown ) ;
		if ( SUCCEEDED ( t_Result ) ) 
		{
			BOOL t_Impersonating = FALSE ;
			IUnknown *t_OldContext = NULL ;
			IServerSecurity *t_OldSecurity = NULL ;

			t_Result = ProviderSubSystem_Common_Globals :: BeginImpersonation ( t_OldContext , t_OldSecurity , t_Impersonating ) ;
			if ( SUCCEEDED ( t_Result ) ) 
			{
				BOOL t_Revert = FALSE ;
				IUnknown *t_Proxy = NULL ;

				t_Result = ProviderSubSystem_Common_Globals :: SetProxyState ( m_ProxyContainer , ProxyIndex_IWbemShutdown , IID_IWbemShutdown , t_Shutdown , t_Proxy , t_Revert ) ;
				if ( t_Result == WBEM_E_NOT_FOUND )
				{
					try
					{
						t_Result = t_Shutdown->Shutdown (

							a_Flags ,
							a_MaxMilliSeconds ,
							a_Context
						) ;
					}
					catch ( ... )
					{
						t_Result = WBEM_E_PROVIDER_FAILURE ;
					}

					CoRevertToSelf () ;
				}
				else
				{
					if ( SUCCEEDED ( t_Result ) )
					{
						IWbemShutdown *t_Provider = ( IWbemShutdown * ) t_Proxy ;

						// Set cloaking on the proxy
						// =========================

						DWORD t_ImpersonationLevel = ProviderSubSystem_Common_Globals :: GetCurrentImpersonationLevel () ;

						t_Result = ProviderSubSystem_Common_Globals :: SetCloaking (

							t_Provider ,
							RPC_C_AUTHN_LEVEL_CONNECT , 
							t_ImpersonationLevel
						) ;

						if ( SUCCEEDED ( t_Result ) )
						{
							t_Result = CoImpersonateClient () ;
							if ( SUCCEEDED ( t_Result ) )
							{
								try
								{
									t_Result = t_Provider->Shutdown (

										a_Flags ,
										a_MaxMilliSeconds ,
										a_Context
									) ;
								}
								catch ( ... )
								{
									t_Result = WBEM_E_PROVIDER_FAILURE ;
								}

								CoRevertToSelf () ;
							}
						}

						HRESULT t_TempResult = ProviderSubSystem_Common_Globals :: RevertProxyState ( m_ProxyContainer , ProxyIndex_IWbemShutdown , t_Proxy , t_Revert ) ;
					}
				}

				ProviderSubSystem_Common_Globals :: EndImpersonation ( t_OldContext , t_OldSecurity , t_Impersonating ) ;
			}

			t_Shutdown->Release () ;
		}
	}

	Lock () ;

	CWbemGlobal_IWmiObjectSinkController_Container *t_Container = NULL ;
	GetContainer ( t_Container ) ;

	IWbemShutdown **t_ShutdownElements = new IWbemShutdown * [ t_Container->Size () ] ;
	if ( t_ShutdownElements )
	{
		CWbemGlobal_IWmiObjectSinkController_Container_Iterator t_Iterator = t_Container->Begin ();

		ULONG t_Count = 0 ;
		while ( ! t_Iterator.Null () )
		{
			t_Result = t_Iterator.GetElement ()->QueryInterface ( IID_IWbemShutdown , ( void ** ) & t_ShutdownElements [ t_Count ] ) ;

			t_Iterator.Increment () ;

			t_Count ++ ;
		}

		UnLock () ;

		for ( ULONG t_Index = 0 ; t_Index < t_Count ; t_Index ++ )
		{
			if ( t_ShutdownElements [ t_Index ] ) 
			{
				t_Result = t_ShutdownElements [ t_Index ]->Shutdown ( 

					a_Flags ,
					a_MaxMilliSeconds ,
					a_Context
				) ;

				t_ShutdownElements [ t_Index ]->Release () ;
			}
		}

		delete [] t_ShutdownElements ;
	}
	else
	{	
		UnLock () ;

		t_Result = WBEM_E_OUT_OF_MEMORY ;
	}

	CWbemGlobal_IWmiObjectSinkController :: Shutdown () ;

	return t_Result ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\provsubsys\decoupledclient\provevt.cpp ===
/*++

Copyright (C) 1996-2001 Microsoft Corporation

Module Name:

	XXXX

Abstract:


History:

--*/

#include "PreComp.h"

#include <wbemint.h>
#include <stdio.h>
#include <NCObjApi.h>

#include "Globals.h"
#include "CGlobals.h"
#include "ProvEvents.h"
#include "ProvEvt.h"

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

CEventProvider :: CEventProvider (

	WmiAllocator &a_Allocator ,
	CServerObject_ProviderEvents *a_EventRegistrar ,
	IUnknown *a_Unknown

) :	m_EventRegistrar ( a_EventRegistrar ) ,
	m_Unknown ( a_Unknown ) ,
	m_Provider_IWbemEventProvider ( NULL ) ,
	m_Provider_IWbemEventProviderQuerySink ( NULL ) ,
	m_Provider_IWbemEventProviderSecurity ( NULL ) ,
	m_Provider_IWbemProviderIdentity ( NULL ) ,
	m_Provider_IWbemEventConsumerProvider ( NULL ) ,
	m_Provider_IWbemEventConsumerProviderEx ( NULL ) ,
	m_CoreService ( NULL ) ,
	m_Locale ( NULL ) ,
	m_User ( NULL ) ,
	m_Namespace ( NULL ) ,
	m_ReferenceCount ( 0 ) ,
	m_CriticalSection(NOTHROW_LOCK)
{
	InterlockedIncrement ( & DecoupledProviderSubSystem_Globals :: s_ObjectsInProgress ) ;

	if ( m_EventRegistrar )
	{
		m_EventRegistrar->InternalAddRef () ;
	}

	if ( m_Unknown ) 
	{
		m_Unknown->AddRef () ;

		HRESULT t_Result = m_Unknown->QueryInterface ( IID_IWbemEventProvider , ( void ** ) & m_Provider_IWbemEventProvider ) ;
		t_Result = m_Unknown->QueryInterface ( IID_IWbemEventProviderQuerySink , ( void ** ) & m_Provider_IWbemEventProviderQuerySink ) ;
		t_Result = m_Unknown->QueryInterface ( IID_IWbemEventProviderSecurity , ( void ** ) & m_Provider_IWbemEventProviderSecurity ) ;
		t_Result = m_Unknown->QueryInterface ( IID_IWbemProviderIdentity , ( void ** ) & m_Provider_IWbemProviderIdentity ) ;
		t_Result = m_Unknown->QueryInterface ( IID_IWbemEventConsumerProviderEx , ( void ** ) & m_Provider_IWbemEventConsumerProviderEx ) ;
		t_Result = m_Unknown->QueryInterface ( IID_IWbemEventConsumerProvider , ( void ** ) & m_Provider_IWbemEventConsumerProvider ) ;
	}
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

CEventProvider :: ~CEventProvider ()
{
	if ( m_Namespace ) 
	{
		SysFreeString ( m_Namespace ) ;
	}

	if ( m_Locale ) 
	{
		SysFreeString ( m_Locale ) ;
	}

	if ( m_User ) 
	{
		SysFreeString ( m_User ) ;
	}

	if ( m_Unknown ) 
	{
		m_Unknown->Release () ;
	}

	if ( m_EventRegistrar )
	{
		m_EventRegistrar->InternalRelease () ;
	}

	if ( m_Provider_IWbemEventProvider )
	{
		m_Provider_IWbemEventProvider->Release () ;
	}

	if ( m_Provider_IWbemEventProviderQuerySink )
	{
		m_Provider_IWbemEventProviderQuerySink->Release () ;
	}

	if ( m_Provider_IWbemEventProviderSecurity )
	{
		m_Provider_IWbemEventProviderSecurity->Release () ;
	}

	if ( m_Provider_IWbemProviderIdentity )
	{
		m_Provider_IWbemProviderIdentity->Release () ;
	}

	if ( m_Provider_IWbemEventConsumerProviderEx )
	{
		m_Provider_IWbemEventConsumerProviderEx->Release () ;
	}

	if ( m_Provider_IWbemEventConsumerProvider )
	{
		m_Provider_IWbemEventConsumerProvider->Release () ;
	}

	if ( m_CoreService )
	{
		m_CoreService->Release () ;
	}

	WmiHelper :: DeleteCriticalSection ( & m_CriticalSection ) ;

	InterlockedDecrement ( & DecoupledProviderSubSystem_Globals :: s_ObjectsInProgress ) ;
}


/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CEventProvider :: Initialize ()
{
	HRESULT t_Result = S_OK ;

	WmiStatusCode t_StatusCode = WmiHelper :: InitializeCriticalSection ( & m_CriticalSection ) ;
	if ( t_StatusCode != e_StatusCode_Success )
	{
		t_Result = WBEM_E_OUT_OF_MEMORY ;
	}
	
	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

STDMETHODIMP_( ULONG ) CEventProvider :: AddRef ()
{
	ULONG t_ReferenceCount = InterlockedIncrement ( & m_ReferenceCount ) ;

	return t_ReferenceCount ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

STDMETHODIMP_(ULONG) CEventProvider :: Release ()
{
	ULONG t_ReferenceCount = InterlockedDecrement ( & m_ReferenceCount ) ;
	if ( t_ReferenceCount == 0 )
	{
		delete this;
	}

	return t_ReferenceCount ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

STDMETHODIMP CEventProvider :: QueryInterface (

	REFIID a_Riid , 
	LPVOID FAR *a_Void 
) 
{
	*a_Void = NULL ;

	if ( a_Riid == IID_IUnknown )
	{
		*a_Void = ( LPVOID ) this ;
	}
	else if ( a_Riid == IID_IWbemEventProvider )
	{
		if ( m_Unknown )
		{
			if ( m_Provider_IWbemEventProvider )
			{
				*a_Void = ( LPVOID ) ( IWbemEventProvider * ) this ;
			}
		}
		else
		{
			*a_Void = ( LPVOID ) ( IWbemEventProvider * ) this ;
		}
	}
	else if ( a_Riid == IID_IWbemEventProviderQuerySink )
	{
		if ( m_Provider_IWbemEventProviderQuerySink )
		{
			*a_Void = ( LPVOID ) ( IWbemEventProviderQuerySink * ) this ;
		}
	}
	else if ( a_Riid == IID_IWbemEventProviderSecurity )
	{
		if ( m_Provider_IWbemEventProviderSecurity )
		{
			*a_Void = ( LPVOID ) ( IWbemEventProviderSecurity * ) this ;
		}
	}
	else if ( a_Riid == IID_IWbemProviderIdentity )
	{
		if ( m_Provider_IWbemProviderIdentity )
		{
			*a_Void = ( LPVOID ) ( IWbemProviderIdentity * ) this ;
		}
	}
	else if ( a_Riid == IID_IWbemEventConsumerProvider )
	{
		if ( m_Provider_IWbemEventConsumerProvider )
		{
			*a_Void = ( LPVOID ) ( IWbemEventConsumerProvider * ) this ;
		}
	}
	else if ( a_Riid == IID_IWbemEventConsumerProviderEx )
	{
		if ( m_Provider_IWbemEventConsumerProviderEx )
		{
			*a_Void = ( LPVOID ) ( IWbemEventConsumerProviderEx  * ) this ;
		}
	}
	else if ( a_Riid == IID_IWbemProviderInit )
	{
		*a_Void = ( LPVOID ) ( IWbemProviderInit * ) this ;		
	}
	else if ( a_Riid == IID_IWbemShutdown )
	{
		*a_Void = ( LPVOID ) ( IWbemShutdown * ) this ;		
	}

	if ( *a_Void )
	{
		( ( LPUNKNOWN ) *a_Void )->AddRef () ;

		return ResultFromScode ( S_OK ) ;
	}
	else
	{
		return ResultFromScode ( E_NOINTERFACE ) ;
	}
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CEventProvider ::ProvideEvents (

	IWbemObjectSink *a_Sink ,
	long a_Flags
)
{
	HRESULT t_Result = S_OK ;

	try 
	{
		HRESULT t_TempResult = m_EventRegistrar->SetSink ( a_Sink ) ;

		if ( SUCCEEDED ( t_TempResult ) ) 
		{
			if ( m_Provider_IWbemEventProvider )
			{

				BOOL t_Impersonating = FALSE ;
				IUnknown *t_OldContext = NULL ;
				IServerSecurity *t_OldSecurity = NULL ;

				t_Result = ProviderSubSystem_Common_Globals :: BeginImpersonation ( t_OldContext , t_OldSecurity , t_Impersonating ) ;
				if ( SUCCEEDED ( t_Result ) ) 
				{
					BOOL t_Revert = FALSE ;
					IUnknown *t_Proxy = NULL ;

					t_Result = ProviderSubSystem_Common_Globals :: SetProxyState ( IID_IWbemEventProvider , m_Provider_IWbemEventProvider , t_Proxy , t_Revert ) ;
					if ( t_Result == WBEM_E_NOT_FOUND )
					{
						try
						{
							t_Result = m_Provider_IWbemEventProvider->ProvideEvents (

								a_Sink ,
								a_Flags 
							) ;
						}
						catch ( ... )
						{
							t_Result = WBEM_E_PROVIDER_FAILURE ;
						}
					}
					else 
					{
						if ( SUCCEEDED ( t_Result ) )
						{
							IWbemEventProvider *t_Provider = ( IWbemEventProvider * ) t_Proxy ;

							// Set cloaking on the proxy
							// =========================

							DWORD t_ImpersonationLevel = ProviderSubSystem_Common_Globals :: GetCurrentImpersonationLevel () ;

							t_Result = ProviderSubSystem_Common_Globals :: SetCloaking (

								t_Provider ,
								RPC_C_AUTHN_LEVEL_CONNECT , 
								t_ImpersonationLevel
							) ;

							if ( SUCCEEDED ( t_Result ) )
							{
								t_Result = CoImpersonateClient () ;
								if ( SUCCEEDED ( t_Result ) )
								{
									t_Result = t_Provider->ProvideEvents (

										a_Sink ,
										a_Flags 
									) ;
								}
								else
								{
									t_Result = WBEM_E_ACCESS_DENIED ;
								}
							}

							ProviderSubSystem_Common_Globals :: RevertProxyState ( t_Proxy , t_Revert ) ;
						}
					}

					ProviderSubSystem_Common_Globals :: EndImpersonation ( t_OldContext , t_OldSecurity , t_Impersonating ) ;
				}
			}
		}
	}
	catch ( ... )
	{
		t_Result = WBEM_E_CRITICAL_ERROR ;
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CEventProvider ::NewQuery (

	unsigned long a_Id ,
	WBEM_WSTR a_QueryLanguage ,
	WBEM_WSTR a_Query
)
{
	HRESULT t_Result = S_OK ;

	try 
	{
		if ( m_Provider_IWbemEventProviderQuerySink )
		{
			BOOL t_Impersonating = FALSE ;
			IUnknown *t_OldContext = NULL ;
			IServerSecurity *t_OldSecurity = NULL ;

			t_Result = ProviderSubSystem_Common_Globals :: BeginImpersonation ( t_OldContext , t_OldSecurity , t_Impersonating ) ;
			if ( SUCCEEDED ( t_Result ) ) 
			{
				BOOL t_Revert = FALSE ;
				IUnknown *t_Proxy = NULL ;

				t_Result = ProviderSubSystem_Common_Globals :: SetProxyState ( IID_IWbemEventProviderQuerySink , m_Provider_IWbemEventProviderQuerySink , t_Proxy , t_Revert ) ;
				if ( t_Result == WBEM_E_NOT_FOUND )
				{
					try 
					{
						t_Result = m_Provider_IWbemEventProviderQuerySink->NewQuery (

							a_Id ,
							a_QueryLanguage ,
							a_Query
						) ;
					}
					catch ( ... )
					{
						t_Result = WBEM_E_PROVIDER_FAILURE ;
					}
				}
				else 
				{
					if ( SUCCEEDED ( t_Result ) )
					{
						IWbemEventProviderQuerySink *t_Provider = ( IWbemEventProviderQuerySink * ) t_Proxy ;

						// Set cloaking on the proxy
						// =========================

						DWORD t_ImpersonationLevel = ProviderSubSystem_Common_Globals :: GetCurrentImpersonationLevel () ;

						t_Result = ProviderSubSystem_Common_Globals :: SetCloaking (

							t_Provider ,
							RPC_C_AUTHN_LEVEL_CONNECT , 
							t_ImpersonationLevel
						) ;

						if ( SUCCEEDED ( t_Result ) )
						{
							t_Result = CoImpersonateClient () ;
							if ( SUCCEEDED ( t_Result ) )
							{
								t_Result = t_Provider->NewQuery (

									a_Id ,
									a_QueryLanguage ,
									a_Query
								) ;
							}
							else
							{
								t_Result = WBEM_E_ACCESS_DENIED ;
							}
						}

						HRESULT t_TempResult = ProviderSubSystem_Common_Globals :: RevertProxyState ( t_Proxy , t_Revert ) ;
					}
				}

				ProviderSubSystem_Common_Globals :: EndImpersonation ( t_OldContext , t_OldSecurity , t_Impersonating ) ;
			}

			return t_Result ;
		}
		else
		{
			t_Result = WBEM_E_PROVIDER_NOT_CAPABLE ;
		}
	}
	catch ( ... )
	{
		t_Result = WBEM_E_CRITICAL_ERROR ;
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CEventProvider ::CancelQuery (

	unsigned long a_Id
)
{
	HRESULT t_Result = S_OK ;

	try 
	{
		if ( m_Provider_IWbemEventProviderQuerySink )
		{
			BOOL t_Impersonating = FALSE ;
			IUnknown *t_OldContext = NULL ;
			IServerSecurity *t_OldSecurity = NULL ;

			t_Result = ProviderSubSystem_Common_Globals :: BeginImpersonation ( t_OldContext , t_OldSecurity , t_Impersonating ) ;
			if ( SUCCEEDED ( t_Result ) ) 
			{
				BOOL t_Revert = FALSE ;
				IUnknown *t_Proxy = NULL ;

				t_Result = ProviderSubSystem_Common_Globals :: SetProxyState ( IID_IWbemEventProviderQuerySink , m_Provider_IWbemEventProviderQuerySink , t_Proxy , t_Revert ) ;
				if ( t_Result == WBEM_E_NOT_FOUND )
				{
					try
					{
						t_Result = m_Provider_IWbemEventProviderQuerySink->CancelQuery (

							a_Id
						) ;
					}
					catch ( ... )
					{
						t_Result = WBEM_E_PROVIDER_FAILURE ;
					}
				}
				else 
				{
					if ( SUCCEEDED ( t_Result ) )
					{
						IWbemEventProviderQuerySink *t_Provider = NULL ;
						t_Result = t_Proxy->QueryInterface ( IID_IWbemEventProviderQuerySink , ( void ** ) & t_Provider ) ;
						if ( SUCCEEDED ( t_Result ) )
						{
							// Set cloaking on the proxy
							// =========================

							DWORD t_ImpersonationLevel = ProviderSubSystem_Common_Globals :: GetCurrentImpersonationLevel () ;

							t_Result = ProviderSubSystem_Common_Globals :: SetCloaking (

								t_Provider ,
								RPC_C_AUTHN_LEVEL_CONNECT , 
								t_ImpersonationLevel
							) ;

							if ( SUCCEEDED ( t_Result ) )
							{
								t_Result = CoImpersonateClient () ;
								if ( SUCCEEDED ( t_Result ) )
								{
									t_Result = t_Provider->CancelQuery (

										a_Id
									) ;
								}
								else
								{
									t_Result = WBEM_E_ACCESS_DENIED ;
								}
							}

							t_Provider->Release () ;
						}

						HRESULT t_TempResult = ProviderSubSystem_Common_Globals :: RevertProxyState ( t_Proxy , t_Revert ) ;
					}
				}

				ProviderSubSystem_Common_Globals :: EndImpersonation ( t_OldContext , t_OldSecurity , t_Impersonating ) ;
			}
		}
		else
		{
			t_Result = WBEM_E_PROVIDER_NOT_CAPABLE;
		}
	}
	catch ( ... )
	{
		t_Result = WBEM_E_CRITICAL_ERROR ;
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CEventProvider ::AccessCheck (

	WBEM_CWSTR a_QueryLanguage ,
	WBEM_CWSTR a_Query ,
	long a_SidLength ,
	const BYTE *a_Sid
)
{
	HRESULT t_Result = S_OK ;

	try 
	{
		if ( m_Provider_IWbemEventProviderSecurity )
		{
			BOOL t_Impersonating = FALSE ;
			IUnknown *t_OldContext = NULL ;
			IServerSecurity *t_OldSecurity = NULL ;

			t_Result = ProviderSubSystem_Common_Globals :: BeginImpersonation ( t_OldContext , t_OldSecurity , t_Impersonating ) ;
			if ( SUCCEEDED ( t_Result ) ) 
			{
				BOOL t_Revert = FALSE ;
				IUnknown *t_Proxy = NULL ;

				t_Result = ProviderSubSystem_Common_Globals :: SetProxyState ( IID_IWbemEventProviderSecurity , m_Provider_IWbemEventProviderSecurity , t_Proxy , t_Revert ) ;
				if ( t_Result == WBEM_E_NOT_FOUND )
				{
					try
					{
						t_Result = m_Provider_IWbemEventProviderSecurity->AccessCheck (

							a_QueryLanguage ,
							a_Query ,
							a_SidLength ,
							a_Sid
						) ;
					}
					catch ( ... )
					{
						t_Result = WBEM_E_PROVIDER_FAILURE ;
					}
				}
				else 
				{
					if ( SUCCEEDED ( t_Result ) )
					{
						IWbemEventProviderSecurity *t_Provider = ( IWbemEventProviderSecurity * ) t_Proxy ;

						// Set cloaking on the proxy
						// =========================

						DWORD t_ImpersonationLevel = ProviderSubSystem_Common_Globals :: GetCurrentImpersonationLevel () ;

						t_Result = ProviderSubSystem_Common_Globals :: SetCloaking (

							t_Provider ,
							RPC_C_AUTHN_LEVEL_CONNECT , 
							t_ImpersonationLevel
						) ;

						if ( SUCCEEDED ( t_Result ) )
						{
							t_Result = CoImpersonateClient () ;
							if ( SUCCEEDED ( t_Result ) )
							{
								t_Result = t_Provider->AccessCheck (

									a_QueryLanguage ,
									a_Query ,
									a_SidLength ,
									a_Sid
								) ;
							}
							else
							{
								t_Result = WBEM_E_ACCESS_DENIED ;
							}
						}

						ProviderSubSystem_Common_Globals :: RevertProxyState ( t_Proxy , t_Revert ) ;
					}
				}

				ProviderSubSystem_Common_Globals :: EndImpersonation ( t_OldContext , t_OldSecurity , t_Impersonating ) ;
			}
		}
		else
		{
			t_Result = WBEM_E_PROVIDER_NOT_CAPABLE;
		}
	}
	catch ( ... )
	{
		t_Result = WBEM_E_CRITICAL_ERROR ;
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CEventProvider ::SetRegistrationObject (

	long a_Flags ,
	IWbemClassObject *a_ProviderRegistration
)
{
	HRESULT t_Result = S_OK ;

	try 
	{
		if ( m_Provider_IWbemProviderIdentity )
		{
			BOOL t_Impersonating = FALSE ;
			IUnknown *t_OldContext = NULL ;
			IServerSecurity *t_OldSecurity = NULL ;

			t_Result = ProviderSubSystem_Common_Globals :: BeginImpersonation ( t_OldContext , t_OldSecurity , t_Impersonating ) ;
			if ( SUCCEEDED ( t_Result ) ) 
			{
				BOOL t_Revert = FALSE ;
				IUnknown *t_Proxy = NULL ;

				t_Result = ProviderSubSystem_Common_Globals :: SetProxyState ( IID_IWbemProviderIdentity , m_Provider_IWbemProviderIdentity , t_Proxy , t_Revert ) ;
				if ( t_Result == WBEM_E_NOT_FOUND )
				{
					try
					{
						t_Result = m_Provider_IWbemProviderIdentity->SetRegistrationObject (

							a_Flags ,
							a_ProviderRegistration
						) ;
					}
					catch ( ... )
					{
						t_Result = WBEM_E_PROVIDER_FAILURE ;
					}
				}
				else 
				{
					if ( SUCCEEDED ( t_Result ) )
					{
						IWbemProviderIdentity *t_Provider = ( IWbemProviderIdentity * ) t_Proxy ;

						// Set cloaking on the proxy
						// =========================

						DWORD t_ImpersonationLevel = ProviderSubSystem_Common_Globals :: GetCurrentImpersonationLevel () ;

						t_Result = ProviderSubSystem_Common_Globals :: SetCloaking (

							t_Provider ,
							RPC_C_AUTHN_LEVEL_CONNECT , 
							t_ImpersonationLevel
						) ;

						if ( SUCCEEDED ( t_Result ) )
						{
							t_Result = CoImpersonateClient () ;
							if ( SUCCEEDED ( t_Result ) )
							{
								t_Result = t_Provider->SetRegistrationObject (

									a_Flags ,
									a_ProviderRegistration
								) ;
							}
							else
							{
								t_Result = WBEM_E_ACCESS_DENIED ;
							}
						}

						ProviderSubSystem_Common_Globals :: RevertProxyState ( t_Proxy , t_Revert ) ;
					}
				}

				ProviderSubSystem_Common_Globals :: EndImpersonation ( t_OldContext , t_OldSecurity , t_Impersonating ) ;
			}
		}
		else
		{
			t_Result = WBEM_E_PROVIDER_NOT_CAPABLE;
		}
	}
	catch ( ... )
	{
		t_Result = WBEM_E_CRITICAL_ERROR ;
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CEventProvider ::FindConsumer (

	IWbemClassObject *a_LogicalConsumer ,
	IWbemUnboundObjectSink **a_Consumer
)
{
	HRESULT t_Result = S_OK ;

	try 
	{
		if ( m_Provider_IWbemEventConsumerProvider )
		{
			BOOL t_Impersonating = FALSE ;
			IUnknown *t_OldContext = NULL ;
			IServerSecurity *t_OldSecurity = NULL ;

			t_Result = ProviderSubSystem_Common_Globals :: BeginImpersonation ( t_OldContext , t_OldSecurity , t_Impersonating ) ;
			if ( SUCCEEDED ( t_Result ) ) 
			{
				BOOL t_Revert = FALSE ;
				IUnknown *t_Proxy = NULL ;

				t_Result = ProviderSubSystem_Common_Globals :: SetProxyState ( IID_IWbemEventConsumerProvider , m_Provider_IWbemEventConsumerProvider , t_Proxy , t_Revert ) ;
				if ( t_Result == WBEM_E_NOT_FOUND )
				{
					try
					{
						t_Result = m_Provider_IWbemEventConsumerProvider->FindConsumer (

							a_LogicalConsumer ,
							a_Consumer
						) ;
					}
					catch ( ... )
					{
						t_Result = WBEM_E_PROVIDER_FAILURE ;
					}
				}
				else 
				{
					if ( SUCCEEDED ( t_Result ) )
					{
						IWbemEventConsumerProvider *t_Provider = ( IWbemEventConsumerProvider * ) t_Proxy ;

						// Set cloaking on the proxy
						// =========================

						DWORD t_ImpersonationLevel = ProviderSubSystem_Common_Globals :: GetCurrentImpersonationLevel () ;

						t_Result = ProviderSubSystem_Common_Globals :: SetCloaking (

							t_Provider ,
							RPC_C_AUTHN_LEVEL_CONNECT , 
							t_ImpersonationLevel
						) ;

						if ( SUCCEEDED ( t_Result ) )
						{
							t_Result = CoImpersonateClient () ;
							if ( SUCCEEDED ( t_Result ) )
							{
								t_Result = t_Provider->FindConsumer (

									a_LogicalConsumer ,
									a_Consumer
								) ;
							}
							else
							{
								t_Result = WBEM_E_ACCESS_DENIED ;
							}
						}

						ProviderSubSystem_Common_Globals :: RevertProxyState ( t_Proxy , t_Revert ) ;
					}
				}

				ProviderSubSystem_Common_Globals :: EndImpersonation ( t_OldContext , t_OldSecurity , t_Impersonating ) ;
			}
		}
		else
		{
			t_Result = WBEM_E_PROVIDER_NOT_CAPABLE;
		}
	}
	catch ( ... )
	{
		t_Result = WBEM_E_CRITICAL_ERROR ;
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CEventProvider ::ValidateSubscription (

	IWbemClassObject *a_LogicalConsumer
)
{
	HRESULT t_Result = S_OK ;

	try 
	{
		if ( m_Provider_IWbemEventConsumerProviderEx )
		{
			BOOL t_Impersonating = FALSE ;
			IUnknown *t_OldContext = NULL ;
			IServerSecurity *t_OldSecurity = NULL ;

			t_Result = ProviderSubSystem_Common_Globals :: BeginImpersonation ( t_OldContext , t_OldSecurity , t_Impersonating ) ;
			if ( SUCCEEDED ( t_Result ) ) 
			{
				BOOL t_Revert = FALSE ;
				IUnknown *t_Proxy = NULL ;

				t_Result = ProviderSubSystem_Common_Globals :: SetProxyState ( IID_IWbemEventConsumerProviderEx , m_Provider_IWbemEventConsumerProviderEx , t_Proxy , t_Revert ) ;
				if ( t_Result == WBEM_E_NOT_FOUND )
				{
					try
					{
						t_Result = m_Provider_IWbemEventConsumerProviderEx->ValidateSubscription (

							a_LogicalConsumer
						) ;
					}
					catch ( ... )
					{
						t_Result = WBEM_E_PROVIDER_FAILURE ;
					}
				}
				else 
				{
					if ( SUCCEEDED ( t_Result ) )
					{
						IWbemEventConsumerProviderEx *t_Provider = ( IWbemEventConsumerProviderEx * ) t_Proxy ;

						// Set cloaking on the proxy
						// =========================

						DWORD t_ImpersonationLevel = ProviderSubSystem_Common_Globals :: GetCurrentImpersonationLevel () ;

						t_Result = ProviderSubSystem_Common_Globals :: SetCloaking (

							t_Provider ,
							RPC_C_AUTHN_LEVEL_CONNECT , 
							t_ImpersonationLevel
						) ;

						if ( SUCCEEDED ( t_Result ) )
						{
							t_Result = CoImpersonateClient () ;
							if ( SUCCEEDED ( t_Result ) )
							{
								t_Result = t_Provider->ValidateSubscription (

									a_LogicalConsumer
								) ;
							}
							else
							{
								t_Result = WBEM_E_ACCESS_DENIED ;
							}
						}

						ProviderSubSystem_Common_Globals :: RevertProxyState ( t_Proxy , t_Revert ) ;
					}
				}

				ProviderSubSystem_Common_Globals :: EndImpersonation ( t_OldContext , t_OldSecurity , t_Impersonating ) ;
			}
		}
		else
		{
			t_Result = WBEM_E_PROVIDER_NOT_CAPABLE;
		}
	}
	catch ( ... )
	{
		t_Result = WBEM_E_CRITICAL_ERROR ;
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CEventProvider :: UnRegister ()
{
	return S_OK ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CEventProvider :: Initialize (

	LPWSTR a_User,
	LONG a_Flags,
	LPWSTR a_Namespace,
	LPWSTR a_Locale,
	IWbemServices *a_CoreService,         // For anybody
	IWbemContext *a_Context,
	IWbemProviderInitSink *a_Sink     // For init signals
)
{
	HRESULT t_Result = S_OK ;

	if ( a_CoreService ) 
	{
		m_CoreService = a_CoreService ;
		m_CoreService->AddRef () ;
	}
	else
	{
		t_Result = WBEM_E_INVALID_PARAMETER ;
	}

	if ( SUCCEEDED ( t_Result ) )
	{
		if ( a_User ) 
		{
			m_User = SysAllocString ( a_User ) ;
			if ( m_User == NULL )
			{
				t_Result = WBEM_E_OUT_OF_MEMORY ;
			}
		}
	}

	if ( SUCCEEDED ( t_Result ) )
	{
		if ( a_Locale ) 
		{
			m_Locale = SysAllocString ( a_Locale ) ;
			if ( m_Locale == NULL )
			{
				t_Result = WBEM_E_OUT_OF_MEMORY ;
			}
		}
	}

	if ( SUCCEEDED ( t_Result ) )
	{
		if ( a_Namespace ) 
		{
			m_Namespace = SysAllocString ( a_Namespace ) ;
			if ( m_Namespace == NULL )
			{
				t_Result = WBEM_E_OUT_OF_MEMORY ;
			}
		}
	}
	
	a_Sink->SetStatus ( t_Result , 0 ) ;

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CEventProvider :: Shutdown (

	LONG a_Flags ,
	ULONG a_MaxMilliSeconds ,
	IWbemContext *a_Context
)
{
	HRESULT t_Result = S_OK ;

	IWbemShutdown *t_Shutdown = NULL ;

	if ( m_Unknown )
	{
		t_Result = m_Unknown->QueryInterface ( IID_IWbemShutdown , ( void ** ) & t_Shutdown ) ;
		if ( SUCCEEDED ( t_Result ) ) 
		{
			BOOL t_Impersonating = FALSE ;
			IUnknown *t_OldContext = NULL ;
			IServerSecurity *t_OldSecurity = NULL ;

			t_Result = ProviderSubSystem_Common_Globals :: BeginImpersonation ( t_OldContext , t_OldSecurity , t_Impersonating ) ;
			if ( SUCCEEDED ( t_Result ) ) 
			{
				BOOL t_Revert = FALSE ;
				IUnknown *t_Proxy = NULL ;

				t_Result = ProviderSubSystem_Common_Globals :: SetProxyState ( IID_IWbemShutdown , t_Shutdown , t_Proxy , t_Revert ) ;
				if ( t_Result == WBEM_E_NOT_FOUND )
				{
					try
					{
						t_Result = t_Shutdown->Shutdown (

							a_Flags ,
							a_MaxMilliSeconds ,
							a_Context
						) ;
					}
					catch ( ... )
					{
						t_Result = WBEM_E_PROVIDER_FAILURE ;
					}
				}
				else
				{
					if ( SUCCEEDED ( t_Result ) )
					{
						IWbemShutdown *t_Provider = ( IWbemShutdown * ) t_Proxy ;

						// Set cloaking on the proxy
						// =========================

						DWORD t_ImpersonationLevel = ProviderSubSystem_Common_Globals :: GetCurrentImpersonationLevel () ;

						t_Result = ProviderSubSystem_Common_Globals :: SetCloaking (

							t_Provider ,
							RPC_C_AUTHN_LEVEL_CONNECT , 
							t_ImpersonationLevel
						) ;

						if ( SUCCEEDED ( t_Result ) )
						{
							t_Result = t_Provider->Shutdown (

								a_Flags ,
								a_MaxMilliSeconds ,
								a_Context
							) ;
						}

						ProviderSubSystem_Common_Globals :: RevertProxyState ( t_Proxy , t_Revert ) ;
					}
				}

				ProviderSubSystem_Common_Globals :: EndImpersonation ( t_OldContext , t_OldSecurity , t_Impersonating ) ;
			}

			t_Shutdown->Release () ;
		}
	}

	return t_Result ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\provsubsys\decoupledclient\include\guids.h ===
/*++

Copyright (C) 1996-2001 Microsoft Corporation

Module Name:

	Guids.h

Abstract:


History:

--*/
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\provsubsys\decoupledclient\include\globals.h ===
/*++

Copyright (C) 1996-2001 Microsoft Corporation

Module Name:

	Globals.h

Abstract:


History:

--*/

#ifndef _Globals_H
#define _Globals_H

#include <pssException.h>
#include <Allocator.h>
#include <BasicTree.h>
#include <PQueue.h>
#include <Cache.h>
#include <ReaderWriter.h>

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

class DecoupledProviderSubSystem_Globals
{
public:

	static WmiAllocator *s_Allocator ;

	static LONG s_LocksInProgress ;
	static LONG s_ObjectsInProgress ;

    static LONG s_CServerClassFactory_ObjectsInProgress ;
	static LONG s_CServerObject_ProviderRegistrar_ObjectsInProgress  ;
	static LONG s_CServerObject_ProviderEvents_ObjectsInProgress ;
	static LONG s_CInterceptor_DecoupledClient_ObjectsInProgress ;
	static LONG s_CDecoupled_IWbemSyncObjectSink_ObjectsInProgress ;
	static LONG s_CDecoupled_Batching_IWbemSyncObjectSink_ObjectsInProgress ;
	static LONG s_CInterceptor_IWbemDecoupledUnboundObjectSink_ObjectsInProgress ;

	static HRESULT Global_Startup () ;
	static HRESULT Global_Shutdown () ;

	static HRESULT BeginThreadImpersonation (

		IUnknown *&a_OldContext ,
		IServerSecurity *&a_OldSecurity ,
		BOOL &a_Impersonating
	) ;

	static HRESULT EndThreadImpersonation (

		IUnknown *a_OldContext ,
		IServerSecurity *a_OldSecurity ,
		BOOL a_Impersonating 
	) ;

	static HRESULT Begin_IdentifyCall_PrvHost (

		WmiInternalContext a_InternalContext ,
		BOOL &a_Impersonating ,
		IUnknown *&a_OldContext ,
		IServerSecurity *&a_OldSecurity
	) ;

	static HRESULT End_IdentifyCall_PrvHost (

		WmiInternalContext a_InternalContext ,
		IUnknown *&a_OldContext ,
		IServerSecurity *&a_OldSecurity ,
		BOOL &a_Impersonating 
	) ;

	static HRESULT Begin_IdentifyCall_SvcHost (

		WmiInternalContext a_InternalContext ,
		BOOL &a_Impersonating ,
		IUnknown *&a_OldContext ,
		IServerSecurity *&a_OldSecurity
	) ;

	static HRESULT End_IdentifyCall_SvcHost (

		WmiInternalContext a_InternalContext ,
		IUnknown *&a_OldContext ,
		IServerSecurity *&a_OldSecurity ,
		BOOL &a_Impersonating
	) ;
} ;

#endif // _Globals_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\provsubsys\decoupledclient\include\resource.h ===
/*++

Copyright (C) 1996-2001 Microsoft Corporation

Module Name:

	Resource.h

Abstract:


History:

--*/

//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by propprov.rc
//

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NO_MFC                     1
#define _APS_NEXT_RESOURCE_VALUE        101
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1000
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\provsubsys\decoupledclient\include\classfac.h ===
/*++

Copyright (C) 1996-2001 Microsoft Corporation

Module Name:

	ClassFac.h

Abstract:


History:

--*/

#ifndef _ServerClassFactory_H
#define _ServerClassFactory_H

#include "ProvRegistrar.h"
#include "ProvEvents.h"

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

template <class Object,class ObjectInterface>
class CServerClassFactory : public IClassFactory
{
private:

    long m_ReferenceCount ;

protected:
public:

    CServerClassFactory () ;
    ~CServerClassFactory () ;

	//IUnknown members

	STDMETHODIMP QueryInterface ( REFIID , LPVOID FAR * ) ;
    STDMETHODIMP_( ULONG ) AddRef () ;
    STDMETHODIMP_( ULONG ) Release () ;

	//IClassFactory members

    STDMETHODIMP CreateInstance ( LPUNKNOWN , REFIID , LPVOID FAR * ) ;
    STDMETHODIMP LockServer ( BOOL ) ;
};

#include <classfac.cpp>

#endif // _ServerClassFactory_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\provsubsys\desktop\globals.cpp ===
/*++

Copyright (C) 1996-2001 Microsoft Corporation

Module Name:

	Globals.cpp

Abstract:


History:

--*/

#include "PreComp.h"

#include <initguid.h>
#ifndef INITGUID
#define INITGUID
#endif

#include <wbemint.h>

#include <Exception.h>
#include <Thread.h>

#include <Allocator.cpp>
#include <HelperFuncs.cpp>

#include "Globals.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\provsubsys\decoupledclient\provregistrar.cpp ===
/*++

Copyright (C) 1996-2001 Microsoft Corporation

Module Name:

	ProvFact.cpp

Abstract:


History:

--*/

#include <PreComp.h>
#include <wbemint.h>

#include <CGlobals.h>
#include <DateTime.h>
#include <ProvRegInfo.h>
#include <ProvRegDecoupled.h>

#include "Globals.h"
#include "Guids.h"

#include "ProvInterceptor.h"
#include "ProvRegistrar.h"

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

CServerObject_ProviderRegistrar_Base :: CServerObject_ProviderRegistrar_Base (

	WmiAllocator &a_Allocator 

) : 
	m_Allocator ( a_Allocator ) ,
	m_Clsid ( NULL ) ,
	m_Provider ( NULL ) ,
	m_User ( NULL ) ,
	m_Locale ( NULL ) ,
	m_Scope ( NULL ) ,
	m_Registration ( NULL ) ,
	m_Registered ( FALSE ),
	m_MarshaledProxy ( NULL ) ,
	m_MarshaledProxyLength ( 0 ) ,
	m_CriticalSection(NOTHROW_LOCK)
{
	ZeroMemory ( & m_Identity , sizeof ( m_Identity ) ) ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

CServerObject_ProviderRegistrar_Base::~CServerObject_ProviderRegistrar_Base ()
{
	if ( m_Provider )
	{
		m_Provider->Release () ;
	}
	if ( m_Clsid )
	{
		SysFreeString ( m_Clsid ) ;
	}

	if ( m_User )
	{
		SysFreeString ( m_User ) ;
	}

	if ( m_Locale ) 
	{
		SysFreeString ( m_Locale ) ;
	}

	if ( m_Scope ) 
	{
		SysFreeString ( m_Scope ) ;
	}

	if ( m_Registration )
	{
		SysFreeString ( m_Registration ) ;
	}

	if ( m_MarshaledProxy )
	{
		ProviderSubSystem_Common_Globals :: ReleaseRegistration (

			m_MarshaledProxy ,
			m_MarshaledProxyLength
		) ;

		delete [] m_MarshaledProxy ;
		m_MarshaledProxy = NULL ;
		m_MarshaledProxyLength = 0 ;
	}

	WmiHelper :: DeleteCriticalSection ( & m_CriticalSection ) ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CServerObject_ProviderRegistrar_Base :: Initialize ()
{
	WmiStatusCode t_StatusCode = WmiHelper :: InitializeCriticalSection ( & m_CriticalSection ) ;
	if ( t_StatusCode == e_StatusCode_Success )
	{
		return S_OK ;
	}
	else
	{
		return WBEM_E_OUT_OF_MEMORY ;
	}
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CServerObject_ProviderRegistrar_Base :: SaveToRegistry (

	long a_Flags ,
	IWbemContext *a_Context ,
	LPCWSTR a_User ,
	LPCWSTR a_Locale ,
	LPCWSTR a_Registration ,
	LPCWSTR a_Scope ,
	IUnknown *a_Unknown ,
	BYTE *a_MarshaledProxy ,
	DWORD a_MarshaledProxyLength
)
{
	HRESULT t_Result = S_OK ;

	CServerObject_DecoupledClientRegistration_Element t_Element ;

	BSTR t_CreationTime = NULL ;

	FILETIME t_CreationFileTime ;
	FILETIME t_ExitFileTime ;
	FILETIME t_KernelFileTime ;
	FILETIME t_UserFileTime ;

	BOOL t_Status = GetProcessTimes (

		  GetCurrentProcess (),
		  & t_CreationFileTime,
		  & t_ExitFileTime,
		  & t_KernelFileTime,
		  & t_UserFileTime
	);

	if ( t_Status ) 
	{
		CWbemDateTime t_Time ;
		t_Time.SetFileTimeDate ( t_CreationFileTime , VARIANT_FALSE ) ;

		t_Result = t_Time.GetValue ( & t_CreationTime ) ;
		if ( SUCCEEDED ( t_Result ) ) 
		{
			t_Result = t_Element.SetProcessIdentifier ( GetCurrentProcessId () ) ;

			if ( SUCCEEDED ( t_Result ) ) 
			{
				if ( a_Locale ) 
				{
					t_Result = t_Element.SetLocale ( ( BSTR ) a_Locale ) ;
				}
			}

			if ( SUCCEEDED ( t_Result ) ) 
			{
				if ( a_User ) 
				{
					t_Result = t_Element.SetUser ( ( BSTR ) a_User ) ;
				}
			}

			if ( SUCCEEDED ( t_Result ) ) 
			{
				t_Result = t_Element.SetProvider ( ( BSTR ) a_Registration ) ;
			}

			if ( SUCCEEDED ( t_Result ) ) 
			{
				t_Result = t_Element.SetScope ( ( BSTR ) a_Scope ) ;
			}

			if ( SUCCEEDED ( t_Result ) ) 
			{
				t_Result = t_Element.SetCreationTime ( ( BSTR ) t_CreationTime ) ;
			}

			if ( SUCCEEDED ( t_Result ) ) 
			{
				t_Result = t_Element.SetMarshaledProxy ( a_MarshaledProxy , a_MarshaledProxyLength ) ;
			}

			if ( SUCCEEDED ( t_Result ) )
			{
				t_Result = t_Element.Save ( m_Clsid ) ;
			}

			SysFreeString ( t_CreationTime ) ;
		}
		else
		{
			t_Result = WBEM_E_UNEXPECTED ;
		}
	}
	else
	{
		t_Result = WBEM_E_UNEXPECTED ;
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CServerObject_ProviderRegistrar_Base :: DirectRegister (

	GUID &a_Identity ,
	long a_Flags ,
	IWbemContext *a_Context ,
	LPCWSTR a_User ,
	LPCWSTR a_Locale ,
	LPCWSTR a_Registration ,
	LPCWSTR a_Scope ,
	IUnknown *a_Unknown ,
	BYTE *a_MarshaledProxy ,
	DWORD a_MarshaledProxyLength
)
{
	HRESULT t_Result = S_OK ;

	CServerObject_DecoupledServerRegistration t_Element ( m_Allocator ) ;

	BSTR t_CreationTime = NULL ;

	FILETIME t_CreationFileTime ;
	FILETIME t_ExitFileTime ;
	FILETIME t_KernelFileTime ;
	FILETIME t_UserFileTime ;

	BOOL t_Status = GetProcessTimes (

		  GetCurrentProcess (),
		  & t_CreationFileTime,
		  & t_ExitFileTime,
		  & t_KernelFileTime,
		  & t_UserFileTime
	);

	if ( t_Status ) 
	{
		CWbemDateTime t_Time ;
		t_Time.SetFileTimeDate ( t_CreationFileTime , VARIANT_FALSE ) ;

		t_Result = t_Time.GetValue ( & t_CreationTime ) ;
		if ( SUCCEEDED ( t_Result ) ) 
		{
			t_Result = t_Element.Load () ;
			if ( SUCCEEDED ( t_Result ) )
			{
				BSTR t_ServerCreationTime = t_Element.GetCreationTime () ;
				DWORD t_ProcessIdentifier = t_Element.GetProcessIdentifier () ;
				BYTE *t_MarshaledProxy = t_Element.GetMarshaledProxy () ;
				DWORD t_MarshaledProxyLength = t_Element.GetMarshaledProxyLength () ;

				IUnknown *t_Unknown = NULL ;
				HRESULT t_TempResult = ProviderSubSystem_Common_Globals :: UnMarshalRegistration ( & t_Unknown , t_MarshaledProxy , t_MarshaledProxyLength ) ;
				if ( SUCCEEDED ( t_TempResult ) )
				{
					_IWmiProviderSubsystemRegistrar *t_Registrar = NULL ;
						
					t_Result = t_Unknown->QueryInterface ( IID__IWmiProviderSubsystemRegistrar , ( void ** ) & t_Registrar ) ;
					if ( SUCCEEDED ( t_Result ) )
					{
						BOOL t_Impersonating = FALSE ;
						IUnknown *t_OldContext = NULL ;
						IServerSecurity *t_OldSecurity = NULL ;

						t_Result = ProviderSubSystem_Common_Globals :: BeginCallbackImpersonation ( t_OldContext , t_OldSecurity , t_Impersonating ) ;
						if ( SUCCEEDED ( t_Result ) )
						{
							BOOL t_Revert = FALSE ;
							IUnknown *t_Proxy = NULL ;

							t_Result = ProviderSubSystem_Common_Globals :: SetProxyState ( IID__IWmiProviderSubsystemRegistrar , t_Registrar , t_Proxy , t_Revert ) ;
							if ( t_Result == WBEM_E_NOT_FOUND )
							{
								try
								{
									t_Result = t_Registrar->Register ( 

										0 ,
										a_Context ,
										a_User ,
										a_Locale ,
										a_Scope ,
										a_Registration ,
										GetCurrentProcessId () ,
										a_Unknown ,
										a_Identity 
									) ;
								}
								catch ( ... )
								{
									t_Result = WBEM_E_PROVIDER_FAILURE ;
								}
							}
							else
							{
								if ( SUCCEEDED ( t_Result ) )
								{
									_IWmiProviderSubsystemRegistrar *t_RegistrarProxy = ( _IWmiProviderSubsystemRegistrar * ) t_Proxy ;

									// Set cloaking on the proxy
									// =========================

									DWORD t_ImpersonationLevel = ProviderSubSystem_Common_Globals :: GetCurrentImpersonationLevel () ;

									t_Result = ProviderSubSystem_Common_Globals :: SetCloaking (

										t_RegistrarProxy ,
										RPC_C_AUTHN_LEVEL_DEFAULT , 
										t_ImpersonationLevel
									) ;

									if ( SUCCEEDED ( t_Result ) )
									{
									    t_Result = CoImpersonateClient () ;
										if ( SUCCEEDED ( t_Result ) )
										{
											try
											{
												t_Result = t_RegistrarProxy->Register ( 

													0 ,
													a_Context ,
													a_User ,
													a_Locale ,
													a_Scope ,
													a_Registration ,
													GetCurrentProcessId () ,
													a_Unknown ,
													a_Identity 
												) ;
											}
											catch ( ... )
											{
												t_Result = WBEM_E_PROVIDER_FAILURE ;
											}

											CoRevertToSelf () ;
										}
										else
										{
											t_Result = WBEM_E_ACCESS_DENIED ;
										}
									}	

									ProviderSubSystem_Common_Globals :: RevertProxyState ( t_Proxy , t_Revert ) ;
								}
							}

							ProviderSubSystem_Common_Globals :: EndImpersonation ( t_OldContext , t_OldSecurity , t_Impersonating ) ;
						}

						t_Registrar->Release () ;
					}

					t_Unknown->Release () ;
				}
			}
			else
			{
				t_Result = S_OK ;
			}

			SysFreeString ( t_CreationTime ) ;
		}
		else
		{
			t_Result = WBEM_E_UNEXPECTED ;
		}
	}
	else
	{
		t_Result = WBEM_E_UNEXPECTED ;
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CServerObject_ProviderRegistrar_Base :: DirectUnRegister (

	long a_Flags ,
	IWbemContext *a_Context ,
	LPCWSTR a_User ,
	LPCWSTR a_Locale ,
	LPCWSTR a_Registration ,
	LPCWSTR a_Scope ,
	GUID &a_Identity  
)
{
	HRESULT t_Result = S_OK ;

	CServerObject_DecoupledServerRegistration t_Element ( m_Allocator ) ;

	FILETIME t_CreationFileTime ;
	FILETIME t_ExitFileTime ;
	FILETIME t_KernelFileTime ;
	FILETIME t_UserFileTime ;

	BOOL t_Status = GetProcessTimes (

		  GetCurrentProcess (),
		  & t_CreationFileTime,
		  & t_ExitFileTime,
		  & t_KernelFileTime,
		  & t_UserFileTime
	);

	if ( t_Status ) 
	{
		t_Result = t_Element.Load () ;
		if ( SUCCEEDED ( t_Result ) )
		{
			BSTR const t_CreationTime = t_Element.GetCreationTime () ;
			DWORD t_ProcessIdentifier = t_Element.GetProcessIdentifier () ;
			BYTE *t_MarshaledProxy = t_Element.GetMarshaledProxy () ;
			DWORD t_MarshaledProxyLength = t_Element.GetMarshaledProxyLength () ;

			IUnknown *t_Unknown = NULL ;
			t_Result = ProviderSubSystem_Common_Globals :: UnMarshalRegistration ( & t_Unknown , t_MarshaledProxy , t_MarshaledProxyLength ) ;
			if ( SUCCEEDED ( t_Result ) )
			{
				_IWmiProviderSubsystemRegistrar *t_Registrar = NULL ;
					
				t_Result = t_Unknown->QueryInterface ( IID__IWmiProviderSubsystemRegistrar , ( void ** ) & t_Registrar ) ;
				if ( SUCCEEDED ( t_Result ) )
				{
					BOOL t_Impersonating = FALSE ;
					IUnknown *t_OldContext = NULL ;
					IServerSecurity *t_OldSecurity = NULL ;

					t_Result = ProviderSubSystem_Common_Globals :: BeginCallbackImpersonation ( t_OldContext , t_OldSecurity , t_Impersonating ) ;
					if ( SUCCEEDED ( t_Result ) )
					{
						BOOL t_Revert = FALSE ;
						IUnknown *t_Proxy = NULL ;

						t_Result = ProviderSubSystem_Common_Globals :: SetProxyState ( IID__IWmiProviderSubsystemRegistrar , t_Registrar , t_Proxy , t_Revert ) ;
						if ( t_Result == WBEM_E_NOT_FOUND )
						{
							try
							{
								t_Result = t_Registrar->UnRegister ( 

									0 ,
									a_Context ,
									a_User ,
									a_Locale ,
									a_Scope ,
									a_Registration ,
									a_Identity 
								) ;
							}
							catch ( ... )
							{
								t_Result = WBEM_E_PROVIDER_FAILURE ;
							}
						}
						else
						{
							if ( SUCCEEDED ( t_Result ) )
							{
								_IWmiProviderSubsystemRegistrar *t_RegistrarProxy = ( _IWmiProviderSubsystemRegistrar * ) t_Proxy ;

								// Set cloaking on the proxy
								// =========================

								DWORD t_ImpersonationLevel = ProviderSubSystem_Common_Globals :: GetCurrentImpersonationLevel () ;

								t_Result = ProviderSubSystem_Common_Globals :: SetCloaking (

									t_RegistrarProxy ,
									RPC_C_AUTHN_LEVEL_CONNECT , 
									t_ImpersonationLevel
								) ;

								if ( SUCCEEDED ( t_Result ) )
								{
									t_Result = CoImpersonateClient () ;
									if ( SUCCEEDED ( t_Result ) )
									{
										try
										{
											t_Result = t_RegistrarProxy->UnRegister ( 

												0 ,
												a_Context ,
												a_User ,
												a_Locale ,
												a_Scope ,
												a_Registration ,
												a_Identity 
											) ;
										}
										catch ( ... )
										{
											t_Result = WBEM_E_PROVIDER_FAILURE ;
										}

										CoRevertToSelf () ;
									}
									else
									{
										t_Result = WBEM_E_ACCESS_DENIED ;
									}
								}	

								HRESULT t_TempResult = ProviderSubSystem_Common_Globals :: RevertProxyState ( t_Proxy , t_Revert ) ;
							}
						}

						ProviderSubSystem_Common_Globals :: EndImpersonation ( t_OldContext , t_OldSecurity , t_Impersonating ) ;
					}

					t_Registrar->Release () ;
				}

				t_Unknown->Release () ;
			}
		}

		if ( SUCCEEDED ( t_Result ) )
		{
			ProviderSubSystem_Common_Globals :: ReleaseRegistration (

				m_MarshaledProxy ,
				m_MarshaledProxyLength
			) ;

			delete [] m_MarshaledProxy ;
			m_MarshaledProxy = NULL ;
			m_MarshaledProxyLength = 0 ;
		}

	}
	else
	{
		t_Result = WBEM_E_UNEXPECTED ;
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CServerObject_ProviderRegistrar_Base :: CreateInterceptor (

	IWbemContext *a_Context ,
	IUnknown *a_Unknown ,
	BYTE *&a_MarshaledProxy ,
	DWORD& a_MarshaledProxyLength ,
	IUnknown *&a_MarshaledUnknown
)
{
	IWbemLocator *t_Locator = NULL ;
	IWbemServices *t_Service = NULL ;
	CServerObject_ProviderRegistrationV1 *t_Registration = NULL ;

	HRESULT t_Result = CoCreateInstance (

		CLSID_WbemLocator ,
		NULL ,
		CLSCTX_INPROC_SERVER | CLSCTX_LOCAL_SERVER ,
		IID_IUnknown ,
		( void ** )  & t_Locator
	);

	if ( SUCCEEDED ( t_Result ) )
	{
		t_Result = t_Locator->ConnectServer (

			m_Scope ,
			NULL ,
			NULL,
			NULL ,
			0 ,
			NULL,
			NULL,
			& t_Service
		) ;

		t_Locator->Release () ;
	}

	if ( SUCCEEDED ( t_Result ) )
	{
		t_Registration = new CServerObject_ProviderRegistrationV1 ;
		if ( t_Registration )
		{
			t_Registration->AddRef () ;

			IWbemPath *t_NamespacePath = NULL ;

			t_Result = CoCreateInstance (

				CLSID_WbemDefPath ,
				NULL ,
				CLSCTX_INPROC_SERVER ,
				IID_IWbemPath ,
				( void ** )  & t_NamespacePath
			) ;

			if ( SUCCEEDED ( t_Result ) )
			{
				t_Result = t_NamespacePath->SetText ( WBEMPATH_TREAT_SINGLE_IDENT_AS_NS | WBEMPATH_CREATE_ACCEPT_ALL , m_Scope ) ;
			}

			if ( SUCCEEDED( t_Result ) ) 
			{
				t_Result = t_Registration->SetContext ( 

					a_Context ,
					t_NamespacePath , 
					t_Service
				) ;
				
				if ( SUCCEEDED ( t_Result ) )
				{
					t_Result = t_Registration->Load ( 

						e_All ,
						NULL , 
						m_Registration
					) ;

					if ( t_Result == WBEM_E_NOT_FOUND )
					{
						t_Result = WBEM_E_PROVIDER_NOT_FOUND ;
					}
				}
			}
			if ( t_NamespacePath )
			{
				t_NamespacePath->Release () ;
			}
		}
		else
		{
			t_Result = WBEM_E_OUT_OF_MEMORY ;
		}
	}

	if ( SUCCEEDED ( t_Result ) )
	{
		CInterceptor_DecoupledClient *t_Provider = new CInterceptor_DecoupledClient ( 

			m_Allocator ,
			a_Unknown , 
			t_Service ,
			*t_Registration
		) ;
		
		if ( t_Provider )
		{
			t_Provider->AddRef () ;

			t_Result = t_Provider->ProviderInitialize () ;
			if ( SUCCEEDED ( t_Result ) ) 
			{
				t_Result = t_Provider->QueryInterface ( IID_IUnknown , ( void ** ) & a_MarshaledUnknown ) ;
				if ( SUCCEEDED ( t_Result ) )
				{
					t_Result = ProviderSubSystem_Common_Globals :: MarshalRegistration ( 

						a_MarshaledUnknown ,
						a_MarshaledProxy ,
						a_MarshaledProxyLength
					) ;

					if ( FAILED ( t_Result ) )
					{
						a_MarshaledUnknown->Release () ;
						a_MarshaledUnknown = NULL ;
					}
				}
			}

			if ( SUCCEEDED ( t_Result ) )
			{
				m_Provider = t_Provider ;
			}
			else
			{
				t_Provider->Release () ;
			}
		}
	}

	if ( t_Registration )
	{
		t_Registration->Release () ;
	}

	if ( t_Service )
	{
		t_Service->Release () ;
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CServerObject_ProviderRegistrar_Base :: Register (

	long a_Flags ,
	IWbemContext *a_Context ,
	LPCWSTR a_User ,
	LPCWSTR a_Locale ,
	LPCWSTR a_Scope ,
	LPCWSTR a_Registration ,
	IUnknown *a_Unknown
)
{
	HRESULT t_Result = S_OK ;

	if ( a_Scope == NULL || a_Registration == NULL || a_Unknown == NULL )
	{
		return WBEM_E_INVALID_PARAMETER ;
	}
		
	WmiHelper :: EnterCriticalSection ( & m_CriticalSection ) ;

	try
	{
		if ( m_Registered == FALSE )
		{
			t_Result = CoCreateGuid ( & m_Identity ) ;
			if ( SUCCEEDED ( t_Result ) )
			{
				BSTR t_Clsid = NULL ;

				t_Result = StringFromCLSID (

				  m_Identity ,
				  & t_Clsid
				) ;

				if ( SUCCEEDED ( t_Result ) )
				{
					if ( m_Clsid ) 
					{
						SysFreeString ( m_Clsid ) ;
						m_Clsid = NULL ;
					}

					if ( m_User )
					{
						SysFreeString ( m_User ) ;
						m_User = NULL ;
					}

					if ( m_Locale ) 
					{
						SysFreeString ( m_Locale ) ;
						m_Locale = NULL ;
					}

					if ( m_Scope ) 
					{
						SysFreeString ( m_Scope ) ;
						m_Scope = NULL ;
					}

					if ( m_Registration )
					{
						SysFreeString ( m_Registration ) ;
						m_Registration = NULL ;
					}

					m_Clsid = SysAllocString ( t_Clsid ) ;
					if ( m_Clsid == NULL )
					{
						t_Result = WBEM_E_OUT_OF_MEMORY ;
					}

					if ( a_User )
					{
						m_User = SysAllocString ( a_User ) ;
						if ( m_User == NULL )
						{
							t_Result = WBEM_E_OUT_OF_MEMORY ;
						}
					}

					if ( m_Locale )
					{
						m_Locale = SysAllocString ( a_Locale ) ;
						if ( m_Locale == NULL )
						{
							t_Result = WBEM_E_OUT_OF_MEMORY ;
						}
					}

					m_Scope = SysAllocString ( a_Scope ) ;
					if ( m_Scope == NULL )
					{
						t_Result = WBEM_E_OUT_OF_MEMORY ;
					}

					m_Registration = SysAllocString ( a_Registration ) ;
					if ( m_Registration == NULL )
					{
						t_Result = WBEM_E_OUT_OF_MEMORY ;
					}

					if ( SUCCEEDED ( t_Result ) )
					{
						IUnknown *t_MarshaledUnknown = NULL ;

						t_Result = CreateInterceptor (

							a_Context ,
							a_Unknown ,
							m_MarshaledProxy ,
							m_MarshaledProxyLength ,
							t_MarshaledUnknown
						) ;

						if ( SUCCEEDED ( t_Result ) ) 
						{
							t_Result = DirectRegister (

								m_Identity ,
								a_Flags ,
								a_Context ,
								a_User ,
								a_Locale ,
								a_Registration ,
								a_Scope ,
								t_MarshaledUnknown ,
								m_MarshaledProxy ,
								m_MarshaledProxyLength
							) ;
						}

#if 0
						if ( FAILED ( t_Result ) )
						{
							t_Result = SaveToRegistry ( 

								a_Flags ,
								a_Context ,
								a_User ,
								a_Locale ,
								a_Registration ,
								a_Scope ,
								t_MarshaledUnknown ,
								m_MarshaledProxy ,
								m_MarshaledProxyLength
							) ;

						}
#else

#endif
						if ( t_MarshaledUnknown )
						{
							t_MarshaledUnknown->Release () ;
						}
					}

					CoTaskMemFree ( t_Clsid ) ;
				}
				else
				{
					t_Result = WBEM_E_OUT_OF_MEMORY ;
				}
			}
			else
			{
				t_Result = WBEM_E_UNEXPECTED ;
			}
		}
		else
		{
			t_Result = WBEM_E_PROVIDER_ALREADY_REGISTERED ;
		}
	}
	catch ( ... )
	{
		t_Result = WBEM_E_PROVIDER_FAILURE ;
	}

	if ( SUCCEEDED ( t_Result ) )
	{
		m_Registered = TRUE ;
	}

	WmiHelper :: LeaveCriticalSection ( & m_CriticalSection ) ;

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CServerObject_ProviderRegistrar_Base :: UnRegister ()
{
	HRESULT t_Result = S_OK ;

	WmiHelper :: EnterCriticalSection ( & m_CriticalSection ) ;

	try
	{
		if ( m_Registered ) 
		{
			CServerObject_DecoupledClientRegistration_Element t_Element ;
			t_Result = t_Element.Load ( m_Clsid ) ;

			HRESULT t_TempResult = DirectUnRegister ( 

				0 ,
				NULL ,
				m_User ,
				m_Locale ,
				m_Registration ,
				m_Scope ,
				m_Identity
			) ;

			if ( m_Provider )
			{
				m_Provider->Release () ;
				m_Provider = NULL ;
			}

			m_Registered = FALSE ;
		}
		else
		{
			t_Result = WBEM_E_PROVIDER_NOT_REGISTERED ;
		}
	}
	catch ( ... )
	{
		t_Result = WBEM_E_PROVIDER_FAILURE ;
	}

	WmiHelper :: LeaveCriticalSection ( & m_CriticalSection ) ;

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

CServerObject_ProviderRegistrar :: CServerObject_ProviderRegistrar (

	WmiAllocator &a_Allocator 

) : CServerObject_ProviderRegistrar_Base ( a_Allocator ) ,
	m_ReferenceCount ( 0 )
{
	InterlockedIncrement ( & DecoupledProviderSubSystem_Globals :: s_CServerObject_ProviderRegistrar_ObjectsInProgress ) ;
	InterlockedIncrement ( & DecoupledProviderSubSystem_Globals :: s_ObjectsInProgress ) ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

CServerObject_ProviderRegistrar::~CServerObject_ProviderRegistrar ()
{
	InterlockedDecrement ( & DecoupledProviderSubSystem_Globals :: s_CServerObject_ProviderRegistrar_ObjectsInProgress ) ;
	InterlockedDecrement ( & DecoupledProviderSubSystem_Globals :: s_ObjectsInProgress ) ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

STDMETHODIMP CServerObject_ProviderRegistrar::QueryInterface (

	REFIID a_Riid , 
	LPVOID FAR *a_Void 
) 
{
	*a_Void = NULL ;

	if ( a_Riid == IID_IUnknown )
	{
		*a_Void = ( LPVOID ) this ;
	}
	else if ( a_Riid == IID_IWbemDecoupledRegistrar )
	{
		*a_Void = ( LPVOID ) ( IWbemDecoupledRegistrar * ) this ;		
	}	

	if ( *a_Void )
	{
		( ( LPUNKNOWN ) *a_Void )->AddRef () ;

		return ResultFromScode ( S_OK ) ;
	}
	else
	{
		return ResultFromScode ( E_NOINTERFACE ) ;
	}
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

STDMETHODIMP_( ULONG ) CServerObject_ProviderRegistrar :: AddRef ()
{
	return InterlockedIncrement ( & m_ReferenceCount ) ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

STDMETHODIMP_(ULONG) CServerObject_ProviderRegistrar :: Release ()
{
	ULONG t_ReferenceCount = InterlockedDecrement ( & m_ReferenceCount ) ;
	if ( t_ReferenceCount == 0 )
	{
		delete this ;
	}

	return t_ReferenceCount ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\provsubsys\desktop\include\globals.h ===
/*++

Copyright (C) 1996-2001 Microsoft Corporation

Module Name:

	Globals.h

Abstract:


History:

--*/

#ifndef _Globals_H
#define _Globals_H

#include <Allocator.h>

#endif // _Globals_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\provsubsys\desktop\precomp.h ===
/*++

Copyright (C) 1996-2001 Microsoft Corporation

Module Name:

Abstract:

History:

--*/

#include <objbase.h>
#include <initguid.h>

extern "C"
{
#include <windows.h>
#include <winnls.h>
#include <stdio.h>
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\provsubsys\decoupledclient\include\provevents.h ===
/*++

Copyright (C) 1996-2001 Microsoft Corporation

Module Name:

	ProvFact.h

Abstract:


History:

--*/

#ifndef _Server_ProviderEvent_H
#define _Server_ProviderEvent_H

#include "Globals.h"
#include "ProvRegistrar.h"
#include "ProvEvt.h"
#include <lockst.h>
/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

class CDecoupledChild_IWbemObjectSink ;
class CDecoupledRoot_IWbemObjectSink ;

typedef WmiContainerController <CDecoupledChild_IWbemObjectSink *>					CWbemGlobal_Decoupled_IWmiObjectSinkController ;
typedef CWbemGlobal_Decoupled_IWmiObjectSinkController :: Container					CWbemGlobal_Decoupled_IWmiObjectSinkController_Container ;
typedef CWbemGlobal_Decoupled_IWmiObjectSinkController :: Container_Iterator		CWbemGlobal_Decoupled_IWmiObjectSinkController_Container_Iterator ;
typedef CWbemGlobal_Decoupled_IWmiObjectSinkController :: WmiContainerElement		Decoupled_ObjectSinkContainerElement ;

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

class CDecoupled_IWbemObjectSink :		public IWbemEventSink , 
										public IWbemShutdown
{
private:
protected:

	long m_SecurityDescriptorLength ;
	BYTE *m_SecurityDescriptor ;

	CriticalSection m_CriticalSection ;

	IWbemObjectSink *m_InterceptedSink ;
	IWbemEventSink *m_EventSink ;

	LONG m_GateClosed ;
	LONG m_InProgress ;
	LONG m_StatusCalled ;

public:

	CDecoupled_IWbemObjectSink () ;

	~CDecoupled_IWbemObjectSink () ;

	//Non-delegating object IUnknown

    STDMETHODIMP QueryInterface ( REFIID , LPVOID FAR * ) ;

    HRESULT STDMETHODCALLTYPE Indicate (

		long a_ObjectCount ,
		IWbemClassObject **a_ObjectArray
	) ;

    HRESULT STDMETHODCALLTYPE SetStatus (

		long a_Flags ,
		HRESULT a_Result ,
		BSTR a_StringParamater ,
		IWbemClassObject *a_ObjectParameter
	) ;

    HRESULT STDMETHODCALLTYPE IndicateWithSD (

		long a_ObjectsCount ,
		IUnknown **a_Objects ,
		long a_SecurityDescriptorLength ,
		BYTE *a_SecurityDescriptor
	) ;

    HRESULT STDMETHODCALLTYPE SetSinkSecurity (

		long a_SecurityDescriptorLength ,
		BYTE *a_SecurityDescriptor
	) ;

    HRESULT STDMETHODCALLTYPE IsActive () ;

    HRESULT STDMETHODCALLTYPE SetBatchingParameters (

		LONG a_Flags,
		DWORD a_MaxBufferSize,
		DWORD a_MaxSendLatency
	) ;

	HRESULT STDMETHODCALLTYPE Shutdown (

		LONG a_Flags ,
		ULONG a_MaxMilliSeconds ,
		IWbemContext *a_Context
	) ; 
} ;

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

class CDecoupledRoot_IWbemObjectSink :		public CDecoupled_IWbemObjectSink ,
											public CWbemGlobal_Decoupled_IWmiObjectSinkController
{
private:

	LONG m_ReferenceCount ;

	WmiAllocator &m_Allocator ;

public:

	CDecoupledRoot_IWbemObjectSink (
	
		WmiAllocator &a_Allocator 

	) : CWbemGlobal_Decoupled_IWmiObjectSinkController ( a_Allocator ) , 
		m_Allocator ( a_Allocator ) ,
		m_ReferenceCount ( 0 )
	{ ; }

	~CDecoupledRoot_IWbemObjectSink ()
	{
		CWbemGlobal_Decoupled_IWmiObjectSinkController :: UnInitialize () ;
	}

    STDMETHODIMP_( ULONG ) AddRef () ;
    STDMETHODIMP_( ULONG ) Release () ;

	HRESULT SinkInitialize () ;

	HRESULT SetSink ( IWbemObjectSink *a_Sink ) ;

    HRESULT STDMETHODCALLTYPE GetRestrictedSink (

		long a_QueryCount ,
        const LPCWSTR *a_Queries ,
        IUnknown *a_Callback ,
        IWbemEventSink **a_Sink
	) ;
} ;

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

class CDecoupledChild_IWbemObjectSink :		public CDecoupled_IWbemObjectSink ,
											public Decoupled_ObjectSinkContainerElement
{
private:

	CDecoupledRoot_IWbemObjectSink *m_RootSink ;
	long m_QueryCount ;
    LPWSTR *m_Queries ;
    IUnknown *m_Callback ;

public:

	CDecoupledChild_IWbemObjectSink (
	
		CDecoupledRoot_IWbemObjectSink *a_RootSink
	) ;

	~CDecoupledChild_IWbemObjectSink () ;

    STDMETHODIMP_( ULONG ) AddRef () ;
    STDMETHODIMP_( ULONG ) Release () ;

	HRESULT SinkInitialize (

		long a_QueryCount ,
		const LPCWSTR *a_Queries ,
		IUnknown *a_Callback
	) ;

    HRESULT STDMETHODCALLTYPE GetRestrictedSink (

		long a_QueryCount ,
        const LPCWSTR *a_Queries ,
        IUnknown *a_Callback ,
        IWbemEventSink **a_Sink
	) ;

	HRESULT SetSink ( IWbemObjectSink *a_Sink ) ;
} ;

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

class CServerObject_ProviderEvents :	public CServerObject_ProviderRegistrar_Base ,
										public IWbemDecoupledBasicEventProvider
{
private:

	WmiAllocator &m_Allocator ;

	CriticalSection m_SinkCriticalSection ;

        long m_ReferenceCount ;
	long m_InternalReferenceCount ;

	CDecoupledRoot_IWbemObjectSink *m_ObjectSink ;
	CEventProvider *m_Provider ;
	IWbemServices *m_Service ;

protected:

public: /* Internal */

	HRESULT SetSink ( IWbemObjectSink *a_Sink ) 
	{
		WmiHelper :: EnterCriticalSection ( & m_SinkCriticalSection ) ;

		if ( m_ObjectSink )
		{
			CDecoupledRoot_IWbemObjectSink *t_Sink = m_ObjectSink ;

			t_Sink->AddRef () ;
		
			WmiHelper :: LeaveCriticalSection ( & m_SinkCriticalSection ) ;

			HRESULT t_Result = t_Sink->SetSink ( a_Sink ) ;

			t_Sink->Release () ;

			return t_Result ;
		}
		else
		{
			WmiHelper :: LeaveCriticalSection ( & m_SinkCriticalSection ) ;

			return WBEM_E_NOT_AVAILABLE ;
		}
	}

    STDMETHODIMP_( ULONG ) InternalAddRef () ;
    STDMETHODIMP_( ULONG ) InternalRelease () ;

public:	/* External */

	CServerObject_ProviderEvents ( WmiAllocator &a_Allocator ) ;
	~CServerObject_ProviderEvents () ;

	//IUnknown members

	STDMETHODIMP QueryInterface ( REFIID , LPVOID FAR * ) ;
    STDMETHODIMP_( ULONG ) AddRef () ;
    STDMETHODIMP_( ULONG ) Release () ;

	HRESULT STDMETHODCALLTYPE Register (

		long a_Flags ,
		IWbemContext *a_Context ,
		LPCWSTR a_User ,
		LPCWSTR a_Locale ,
		LPCWSTR a_Scope ,
		LPCWSTR a_Registration ,
		IUnknown *a_Unknown 
	) ;

	HRESULT STDMETHODCALLTYPE UnRegister () ;

	HRESULT STDMETHODCALLTYPE GetSink (

		long a_Flags ,
		IWbemContext *a_Context ,
		IWbemObjectSink **a_Sink
	) ;

	HRESULT STDMETHODCALLTYPE GetService (

		long a_Flags ,
		IWbemContext *a_Context ,
		IWbemServices **a_Service
	) ;
};

#endif // _Server_ProviderEvent_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\provsubsys\decoupledclient\include\provregistrar.h ===
/*++

Copyright (C) 1996-2001 Microsoft Corporation

Module Name:

	ProvFact.h

Abstract:


History:

--*/

#ifndef _Server_ProviderRegistrar_H
#define _Server_ProviderRegistrar_H

#include "Globals.h"

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

class CInterceptor_DecoupledClient ;

class CServerObject_ProviderRegistrar_Base : public IWbemDecoupledRegistrar
{
protected:

	WmiAllocator &m_Allocator ;

	CriticalSection m_CriticalSection ;

	GUID m_Identity ;

	BSTR m_Clsid ;
	BSTR m_User ;
	BSTR m_Locale ;
	BSTR m_Scope ;
	BSTR m_Registration ;

	BOOL m_Registered ;

	BYTE *m_MarshaledProxy ;
	DWORD m_MarshaledProxyLength ;

	CInterceptor_DecoupledClient *m_Provider ;

	HRESULT CreateInterceptor (

		IWbemContext *a_Context ,
		IUnknown *a_Unknown ,
		BYTE *&a_MarshaledProxy ,
		DWORD &a_MarshaledProxyLength ,
		IUnknown *&a_MarshaledUnknown
	) ;

	HRESULT DirectUnRegister (

		long a_Flags ,
		IWbemContext *a_Context ,
		LPCWSTR a_User ,
		LPCWSTR a_Locale ,
		LPCWSTR a_Registration ,
		LPCWSTR a_Scope ,
		GUID &a_Identity
	) ;

	HRESULT DirectRegister (

		GUID &a_Identity ,
		long a_Flags ,
		IWbemContext *a_Context ,
		LPCWSTR a_User ,
		LPCWSTR a_Locale ,
		LPCWSTR a_Registration ,
		LPCWSTR a_Scope ,
		IUnknown *a_Unknown ,
		BYTE *a_MarshaledProxy ,
		DWORD a_MarshaledProxyLength
	) ;

	HRESULT SaveToRegistry (

		long a_Flags ,
		IWbemContext *a_Context ,
		LPCWSTR a_User ,
		LPCWSTR a_Locale ,
		LPCWSTR a_Registration ,
		LPCWSTR a_Scope ,
		IUnknown *a_Unknown ,
		BYTE *a_MarshaledProxy ,
		DWORD a_MarshaledProxyLength 
	) ;

protected:

public: /* Internal */

public:	/* External */

	CServerObject_ProviderRegistrar_Base ( WmiAllocator &a_Allocator ) ;
	~CServerObject_ProviderRegistrar_Base () ;

	HRESULT STDMETHODCALLTYPE Register (

		long a_Flags ,
		IWbemContext *a_Context ,
		LPCWSTR a_User ,
		LPCWSTR a_Locale ,
		LPCWSTR a_Scope ,
		LPCWSTR a_Registration ,
		IUnknown *a_Unknown
	) ;

	HRESULT STDMETHODCALLTYPE UnRegister () ;

	HRESULT Initialize () ;
};

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

class CServerObject_ProviderRegistrar :	public CServerObject_ProviderRegistrar_Base
{
private:

    long m_ReferenceCount ;

protected:

public: /* Internal */

public:	/* External */

	CServerObject_ProviderRegistrar ( WmiAllocator &a_Allocator ) ;
	~CServerObject_ProviderRegistrar () ;

	//IUnknown members

	STDMETHODIMP QueryInterface ( REFIID , LPVOID FAR * ) ;
    STDMETHODIMP_( ULONG ) AddRef () ;
    STDMETHODIMP_( ULONG ) Release () ;
};

#endif // _Server_ProviderRegistrar_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\provsubsys\decoupledclient\include\provevt.h ===
/*++

Copyright (C) 1996-2001 Microsoft Corporation

Module Name:

	ProvWsv.H

Abstract:


History:

--*/

#ifndef _Server_EventProvider_H
#define _Server_EventProvider_H

#include "Globals.h"
#include "CGlobals.h"

class CServerObject_ProviderEvents ;

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

class CEventProvider :					public IWbemEventProvider ,
										public IWbemEventProviderQuerySink ,
										public IWbemEventProviderSecurity ,
										public IWbemProviderIdentity ,
										public IWbemEventConsumerProviderEx ,
										public IWbemProviderInit , 
										public IWbemShutdown 
{
private:

	LONG m_ReferenceCount ;

	CriticalSection m_CriticalSection ;

	IUnknown *m_Unknown ;
	IWbemEventProvider *m_Provider_IWbemEventProvider ;
	IWbemEventProviderQuerySink *m_Provider_IWbemEventProviderQuerySink ;
	IWbemEventProviderSecurity *m_Provider_IWbemEventProviderSecurity ;
	IWbemProviderIdentity *m_Provider_IWbemProviderIdentity ;
	IWbemEventConsumerProvider *m_Provider_IWbemEventConsumerProvider ;
	IWbemEventConsumerProviderEx *m_Provider_IWbemEventConsumerProviderEx ;

	IWbemServices *m_CoreService ;
	IUnknown *m_Provider ;
	CServerObject_ProviderEvents *m_EventRegistrar ;

public:

	BSTR m_Locale ;
	BSTR m_User ;
	BSTR m_Namespace ;

private:

public:

	CEventProvider ( 

		WmiAllocator &a_Allocator ,
		CServerObject_ProviderEvents *a_EventRegistrar ,
		IUnknown *a_Unknown
	) ;

    ~CEventProvider () ;

	HRESULT Initialize () ;

	HRESULT UnRegister () ;

public:

	//Non-delegating object IUnknown

    STDMETHODIMP QueryInterface ( REFIID , LPVOID FAR * ) ;
    STDMETHODIMP_( ULONG ) AddRef () ;
    STDMETHODIMP_( ULONG ) Release () ;

	/* IWbemEventProvider */

	HRESULT STDMETHODCALLTYPE ProvideEvents (

		IWbemObjectSink *a_Sink ,
		long a_Flags
	) ;

	/* IWbemEventProviderQuerySink */

	HRESULT STDMETHODCALLTYPE NewQuery (

		unsigned long a_Id ,
		WBEM_WSTR a_QueryLanguage ,
		WBEM_WSTR a_Query
	);

	HRESULT STDMETHODCALLTYPE CancelQuery (

		unsigned long a_Id
	) ;

	/* IWbemEventProviderSecurity */

	HRESULT STDMETHODCALLTYPE AccessCheck (

		WBEM_CWSTR a_QueryLanguage ,
		WBEM_CWSTR a_Query ,
		long a_SidLength ,
		const BYTE *a_Sid
	) ;

	/* IWbemProviderIdentity */

	HRESULT STDMETHODCALLTYPE SetRegistrationObject (

		long a_Flags ,
		IWbemClassObject *a_ProviderRegistration
	) ;

	/* IWbemEventConsumerProvider */

	HRESULT STDMETHODCALLTYPE FindConsumer (

		IWbemClassObject *a_LogicalConsumer ,
		IWbemUnboundObjectSink **a_Consumer
	);

	/* IWbemEventConsumerProviderEx */

	HRESULT STDMETHODCALLTYPE ValidateSubscription (

		IWbemClassObject *a_LogicalConsumer
	) ;

	/* IWbemProviderInit methods */

	HRESULT STDMETHODCALLTYPE Initialize (

		LPWSTR a_User,
		LONG a_Flags,
		LPWSTR a_Namespace,
		LPWSTR a_Locale,
		IWbemServices *a_CoreService,         // For anybody
		IWbemContext *a_Context,
		IWbemProviderInitSink *a_Sink     // For init signals
	) ;

	// IWbemShutdown members

	HRESULT STDMETHODCALLTYPE Shutdown (

		LONG a_Flags ,
		ULONG a_MaxMilliSeconds ,
		IWbemContext *a_Context
	) ; 
} ;

#endif // _Server_EventProvider_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\provsubsys\decoupledclient\include\provinterceptor.h ===
/*++

Copyright (C) 1996-2001 Microsoft Corporation

Module Name:

	ProvWsv.H

Abstract:


History:

--*/

#ifndef _Decopled_Interceptor_IWbemServices_H
#define _Decopled_Interceptor_IWbemServices_H

#include <Allocator.h>
#include <Algorithms.h>
#include <PQueue.h>
#include <TPQueue.h>
#include <BasicTree.h>
#include <Cache.h>

#include <CGlobals.h>
#include <ProvRegInfo.h>
#include <ProvObjectSink.h>

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

typedef WmiContainerController <void *>										CWbemGlobal_VoidPointerController ;
typedef CWbemGlobal_VoidPointerController :: Container						CWbemGlobal_VoidPointerController_Container ;
typedef CWbemGlobal_VoidPointerController :: Container_Iterator				CWbemGlobal_VoidPointerController_Container_Iterator ;
typedef CWbemGlobal_VoidPointerController :: WmiContainerElement			VoidPointerContainerElement ;

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

class CInterceptor_IWbemObjectSink ;

#define CWbemGlobal_IWmiObjectSinkController						CWbemGlobal_VoidPointerController
#define CWbemGlobal_IWmiObjectSinkController_Container				CWbemGlobal_VoidPointerController_Container
#define CWbemGlobal_IWmiObjectSinkController_Container_Iterator		CWbemGlobal_VoidPointerController_Container_Iterator
#define ObjectSinkContainerElement									VoidPointerContainerElement

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

#define ProxyIndex_IWbemServices					0
#define ProxyIndex_IWbemPropertyProvider			1
#define ProxyIndex_IWbemEventProvider				2
#define ProxyIndex_IWbemEventProviderQuerySink		3
#define ProxyIndex_IWbemEventProviderSecurity		4
#define ProxyIndex_IWbemProviderIdentity			5
#define ProxyIndex_IWbemEventConsumerProvider		6
#define ProxyIndex_IWbemEventConsumerProviderEx		7
#define ProxyIndex_IWbemUnboundObjectSink			8

#define ProxyIndex_Internal_IWbemServices					9
#define ProxyIndex_Internal_IWbemPropertyProvider			10
#define ProxyIndex_Internal_IWbemEventProvider				11
#define ProxyIndex_Internal_IWbemEventProviderQuerySink		12
#define ProxyIndex_Internal_IWbemEventProviderSecurity		13
#define ProxyIndex_Internal_IWbemEventConsumerProvider		14
#define ProxyIndex_Internal_IWbemEventConsumerProviderEx	15
#define ProxyIndex_Internal_IWbemUnboundObjectSink			16

#define ProxyIndex_IWbemShutdown					17

#define ProxyIndex_Provider_Size					18

#define ProxyIndex_UnBoundSync_IWbemUnboundObjectSink			0
#define ProxyIndex_UnBoundSync_Size								1

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

class CDecoupled_IWbemSyncObjectSink :	public CCommon_IWbemSyncObjectSink
{
private:
protected:
public:

	CDecoupled_IWbemSyncObjectSink (

		WmiAllocator &a_Allocator ,
		IWbemObjectSink *a_InterceptedSink ,
		IUnknown *a_Unknown ,
		CWbemGlobal_IWmiObjectSinkController *a_Controller ,
		ULONG a_Dependant = FALSE
	) ;

	~CDecoupled_IWbemSyncObjectSink () ;
} ;

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

class CDecoupled_Batching_IWbemSyncObjectSink :	public CCommon_Batching_IWbemSyncObjectSink
{
private:
protected:
public:

	CDecoupled_Batching_IWbemSyncObjectSink (

		WmiAllocator &a_Allocator ,
		IWbemObjectSink *a_InterceptedSink ,
		IUnknown *a_Unknown ,
		CWbemGlobal_IWmiObjectSinkController *a_Controller ,
		ULONG a_Dependant = FALSE
	) ;

	~CDecoupled_Batching_IWbemSyncObjectSink () ;
} ;

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

class CInterceptor_IWbemDecoupledUnboundObjectSink : public IWbemUnboundObjectSink ,
												public Internal_IWbemUnboundObjectSink ,

												public IWbemShutdown , 
												public VoidPointerContainerElement
{
private:

	WmiAllocator &m_Allocator ;
	CServerObject_ProviderRegistrationV1 *m_Registration ;

	IUnknown *m_Unknown ;
	IWbemUnboundObjectSink *m_Provider_IWbemUnboundObjectSink ;

	ProxyContainer m_ProxyContainer ;

protected:
public:

	CInterceptor_IWbemDecoupledUnboundObjectSink (

		WmiAllocator &a_Allocator ,
		IUnknown *a_ServerSideProvider , 
		CWbemGlobal_IWmiObjectSinkController *a_Controller ,
		CServerObject_ProviderRegistrationV1 &a_Registration
	) ;

	~CInterceptor_IWbemDecoupledUnboundObjectSink () ;

	HRESULT Initialize () ;

public:

	STDMETHODIMP QueryInterface ( 

		REFIID iid , 
		LPVOID FAR *iplpv 
	) ;

	STDMETHODIMP_( ULONG ) AddRef () ;

	STDMETHODIMP_( ULONG ) Release () ;

	HRESULT STDMETHODCALLTYPE Internal_IndicateToConsumer (

		WmiInternalContext a_InternalContext ,
		IWbemClassObject *a_LogicalConsumer ,
		long a_ObjectCount ,
		IWbemClassObject **a_Objects
	) ;

	HRESULT STDMETHODCALLTYPE IndicateToConsumer (

		IWbemClassObject *a_LogicalConsumer ,
		long a_ObjectCount ,
		IWbemClassObject **a_Objects
	) ;

	/* _IWmiProviderSite */

	HRESULT STDMETHODCALLTYPE GetSite ( DWORD *a_ProcessIdentifier ) ;

	HRESULT STDMETHODCALLTYPE SetContainer ( IUnknown *a_Container ) ;

	HRESULT STDMETHODCALLTYPE Shutdown (

		LONG a_Flags ,
		ULONG a_MaxMilliSeconds ,
		IWbemContext *a_Context
	) ; 
} ;

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

class CInterceptor_DecoupledClient :	public IWbemServices , 
										public IWbemPropertyProvider ,
										public IWbemEventProvider ,
										public IWbemEventProviderQuerySink ,
										public IWbemEventProviderSecurity ,
										public IWbemProviderIdentity ,
										public IWbemEventConsumerProviderEx ,
										public IWbemUnboundObjectSink ,

										public IWbemProviderInit ,
										public Internal_IWbemProviderInit ,

										public Internal_IWbemServices , 
										public Internal_IWbemPropertyProvider ,
										public Internal_IWbemEventProvider ,
										public Internal_IWbemEventProviderQuerySink ,
										public Internal_IWbemEventProviderSecurity ,
										public Internal_IWbemEventConsumerProviderEx ,
										public Internal_IWbemUnboundObjectSink ,

										public _IWmiProviderSite ,
										public IWbemShutdown , 
										public CWbemGlobal_IWmiObjectSinkController 
{
private:

	LONG m_ReferenceCount ;

	IUnknown *m_Unknown ;
	IWbemServices *m_Provider_IWbemServices ;
	IWbemPropertyProvider *m_Provider_IWbemPropertyProvider ;
	IWbemEventProvider *m_Provider_IWbemEventProvider ;
	IWbemEventProviderQuerySink *m_Provider_IWbemEventProviderQuerySink ;
	IWbemEventProviderSecurity *m_Provider_IWbemEventProviderSecurity ;
	IWbemProviderIdentity *m_Provider_IWbemProviderIdentity ;
	IWbemEventConsumerProvider *m_Provider_IWbemEventConsumerProvider ;
	IWbemEventConsumerProviderEx *m_Provider_IWbemEventConsumerProviderEx ;
	IWbemUnboundObjectSink *m_Provider_IWbemUnboundObjectSink ;

	IWbemServices *m_CoreStub ;

	WmiAllocator &m_Allocator ;

	ProxyContainer m_ProxyContainer ;

	BSTR m_Locale ;
	BSTR m_User ;
	BSTR m_Namespace ;
	BSTR m_TransactionIdentifier ;

public:

	CServerObject_ProviderRegistrationV1 *m_Registration ;

	UINT64 m_ProviderOperation_GetObjectAsync ;
	UINT64 m_ProviderOperation_PutClassAsync ;
	UINT64 m_ProviderOperation_DeleteClassAsync ;
	UINT64 m_ProviderOperation_CreateClassEnumAsync ;
	UINT64 m_ProviderOperation_PutInstanceAsync ;
	UINT64 m_ProviderOperation_DeleteInstanceAsync ;
	UINT64 m_ProviderOperation_CreateInstanceEnumAsync ;
	UINT64 m_ProviderOperation_ExecQueryAsync ;
	UINT64 m_ProviderOperation_ExecNotificationQueryAsync ;
	UINT64 m_ProviderOperation_ExecMethodAsync ;

	UINT64 m_ProviderOperation_Begin ;
	UINT64 m_ProviderOperation_Rollback ;
	UINT64 m_ProviderOperation_Commit ;
	UINT64 m_ProviderOperation_QueryState ;

	UINT64 m_ProviderOperation_QueryInstances ;
	UINT64 m_ProviderOperation_CreateRefresher ;
	UINT64 m_ProviderOperation_CreateRefreshableObject ;
	UINT64 m_ProviderOperation_StopRefreshing ;
	UINT64 m_ProviderOperation_CreateRefreshableEnum ;
	UINT64 m_ProviderOperation_GetObjects ;

	UINT64 m_ProviderOperation_GetProperty ;
	UINT64 m_ProviderOperation_PutProperty ;

	UINT64 m_ProviderOperation_ProvideEvents ;
	UINT64 m_ProviderOperation_NewQuery ;
	UINT64 m_ProviderOperation_CancelQuery ;
	UINT64 m_ProviderOperation_AccessCheck ;
	UINT64 m_ProviderOperation_SetRegistrationObject ;
	UINT64 m_ProviderOperation_FindConsumer ;
	UINT64 m_ProviderOperation_ValidateSubscription ;

	void Increment_ProviderOperation_GetObjectAsync () { m_ProviderOperation_GetObjectAsync ++ ; }
 	void Increment_ProviderOperation_PutClassAsync () { m_ProviderOperation_PutClassAsync ++ ; }
	void Increment_ProviderOperation_DeleteClassAsync () { m_ProviderOperation_DeleteClassAsync ++ ; }
	void Increment_ProviderOperation_CreateClassEnumAsync () { m_ProviderOperation_CreateClassEnumAsync ++ ; }
	void Increment_ProviderOperation_PutInstanceAsync () { m_ProviderOperation_PutInstanceAsync ++ ; }
	void Increment_ProviderOperation_DeleteInstanceAsync () { m_ProviderOperation_DeleteInstanceAsync ++ ; }
	void Increment_ProviderOperation_CreateInstanceEnumAsync () { m_ProviderOperation_CreateInstanceEnumAsync ++ ; }
	void Increment_ProviderOperation_ExecQueryAsync () { m_ProviderOperation_ExecQueryAsync ++ ; }
	void Increment_ProviderOperation_ExecNotificationQueryAsync () { m_ProviderOperation_ExecNotificationQueryAsync ++ ; }
	void Increment_ProviderOperation_ExecMethodAsync () { m_ProviderOperation_ExecMethodAsync ++ ; }

	void Increment_ProviderOperation_Begin () { m_ProviderOperation_Begin ++ ; }
	void Increment_ProviderOperation_Rollback () { m_ProviderOperation_Rollback ++ ; }
	void Increment_ProviderOperation_Commit () { m_ProviderOperation_Commit ++ ; }
	void Increment_ProviderOperation_QueryState () { m_ProviderOperation_QueryState ++ ; }

	void Increment_ProviderOperation_QueryInstances () { m_ProviderOperation_QueryInstances ++ ; }
	void Increment_ProviderOperation_CreateRefresher () { m_ProviderOperation_CreateRefresher ++ ; }
	void Increment_ProviderOperation_CreateRefreshableObject () { m_ProviderOperation_CreateRefreshableObject ++ ; }
	void Increment_ProviderOperation_StopRefreshing () { m_ProviderOperation_StopRefreshing ++ ; }
	void Increment_ProviderOperation_CreateRefreshableEnum () { m_ProviderOperation_CreateRefreshableEnum ++ ; }
	void Increment_ProviderOperation_GetObjects () { m_ProviderOperation_GetObjects ++ ; }

	void Increment_ProviderOperation_GetProperty () { m_ProviderOperation_GetProperty ++ ; }
	void Increment_ProviderOperation_PutProperty () { m_ProviderOperation_PutProperty ++ ; }

	void Increment_ProviderOperation_ProvideEvents () { m_ProviderOperation_ProvideEvents ++ ; }
	void Increment_ProviderOperation_NewQuery () { m_ProviderOperation_NewQuery ++ ; }
	void Increment_ProviderOperation_CancelQuery () { m_ProviderOperation_CancelQuery ++ ; }
	void Increment_ProviderOperation_AccessCheck () { m_ProviderOperation_AccessCheck ++ ; }
	void Increment_ProviderOperation_SetRegistrationObject () { m_ProviderOperation_SetRegistrationObject ++ ; }
	void Increment_ProviderOperation_FindConsumer () { m_ProviderOperation_FindConsumer ++ ; }
	void Increment_ProviderOperation_ValidateSubscription () { m_ProviderOperation_ValidateSubscription ++ ; }

	UINT64 Get_ProviderOperation_GetObjectAsync () { return m_ProviderOperation_GetObjectAsync ; }
	UINT64 Get_ProviderOperation_PutClassAsync () { return m_ProviderOperation_PutClassAsync ; }
	UINT64 Get_ProviderOperation_DeleteClassAsync () { return m_ProviderOperation_DeleteClassAsync ; }
	UINT64 Get_ProviderOperation_CreateClassEnumAsync () { return m_ProviderOperation_CreateClassEnumAsync ; }
	UINT64 Get_ProviderOperation_PutInstanceAsync () { return m_ProviderOperation_PutInstanceAsync ; }
	UINT64 Get_ProviderOperation_DeleteInstanceAsync () { return m_ProviderOperation_DeleteInstanceAsync ; }
	UINT64 Get_ProviderOperation_CreateInstanceEnumAsync () { return m_ProviderOperation_CreateInstanceEnumAsync ; }
	UINT64 Get_ProviderOperation_ExecQueryAsync () { return m_ProviderOperation_ExecQueryAsync ; }
	UINT64 Get_ProviderOperation_ExecNotificationQueryAsync () { return m_ProviderOperation_ExecNotificationQueryAsync ; }
	UINT64 Get_ProviderOperation_ExecMethodAsync () { return m_ProviderOperation_ExecMethodAsync ; }

	UINT64 Get_ProviderOperation_Begin () { return m_ProviderOperation_Begin ; }
	UINT64 Get_ProviderOperation_Rollback () { return m_ProviderOperation_Rollback ; }
	UINT64 Get_ProviderOperation_Commit () { return m_ProviderOperation_Commit ; }
	UINT64 Get_ProviderOperation_QueryState () { return m_ProviderOperation_QueryState ; }

	UINT64 Get_ProviderOperation_QueryInstances () { return m_ProviderOperation_QueryInstances ; }
	UINT64 Get_ProviderOperation_CreateRefresher () { return m_ProviderOperation_CreateRefresher ; }
	UINT64 Get_ProviderOperation_CreateRefreshableObject () { return m_ProviderOperation_CreateRefreshableObject ; }
	UINT64 Get_ProviderOperation_StopRefreshing () { return m_ProviderOperation_StopRefreshing ; }
	UINT64 Get_ProviderOperation_CreateRefreshableEnum () { return m_ProviderOperation_CreateRefreshableEnum ; }
	UINT64 Get_ProviderOperation_GetObjects () { return m_ProviderOperation_GetObjects ; }

	UINT64 Get_ProviderOperation_GetProperty () { return m_ProviderOperation_GetProperty ; }
	UINT64 Get_ProviderOperation_PutProperty () { return m_ProviderOperation_PutProperty ; }

	UINT64 Get_ProviderOperation_ProvideEvents () { return m_ProviderOperation_ProvideEvents ; }
	UINT64 Get_ProviderOperation_NewQuery () { return m_ProviderOperation_NewQuery ; }
	UINT64 Get_ProviderOperation_CancelQuery () { return m_ProviderOperation_CancelQuery ; }
	UINT64 Get_ProviderOperation_AccessCheck () { return m_ProviderOperation_AccessCheck ; }
	UINT64 Get_ProviderOperation_SetRegistrationObject () { return m_ProviderOperation_SetRegistrationObject ; }
	UINT64 Get_ProviderOperation_FindConsumer () { return m_ProviderOperation_FindConsumer ; }
	UINT64 Get_ProviderOperation_ValidateSubscription () { return m_ProviderOperation_ValidateSubscription ; }

private:

	HRESULT SetStatus ( 

		LPWSTR a_Operation ,
		LPWSTR a_Parameters ,
		LPWSTR a_Description ,
		HRESULT a_Result ,
		IWbemObjectSink *a_Sink
	) ;

	HRESULT Begin_IWbemServices (

		BOOL &a_Impersonating ,
		IUnknown *&a_OldContext ,
		IServerSecurity *&a_OldSecurity ,
		BOOL &a_IsProxy ,
		IWbemServices *&a_Interface ,
		BOOL &a_Revert ,
		IUnknown *&a_Proxy
	) ;

	HRESULT End_IWbemServices (

		BOOL a_Impersonating ,
		IUnknown *a_OldContext ,
		IServerSecurity *a_OldSecurity ,
		BOOL a_IsProxy ,
		IWbemServices *a_Interface ,
		BOOL a_Revert ,
		IUnknown *a_Proxy
	) ;

	HRESULT AdjustGetContext (

		IWbemContext *a_Context
	) ;

	HRESULT Helper_GetObjectAsync (

		BOOL a_IsProxy ,
 		const BSTR a_ObjectPath ,
		long a_Flags ,
		IWbemContext *a_Context ,
		IWbemObjectSink *a_Sink ,
		IWbemServices *a_Service 
	) ;

	HRESULT Helper_PutClassAsync (

		BOOL a_IsProxy ,
		IWbemClassObject *a_Object , 
		long a_Flags ,
		IWbemContext FAR *a_Context ,
		IWbemObjectSink *a_Sink ,
		IWbemServices *a_Service 
	) ;

	HRESULT Helper_DeleteClassAsync (

		BOOL a_IsProxy ,
		const BSTR a_Class ,
		long a_Flags ,
		IWbemContext FAR *a_Context ,
		IWbemObjectSink *a_Sink ,
		IWbemServices *a_Service 
	) ;

	HRESULT Helper_CreateClassEnumAsync (

		BOOL a_IsProxy ,
		const BSTR a_SuperClass ,
		long a_Flags ,
		IWbemContext FAR *a_Context ,
		IWbemObjectSink *a_Sink ,
		IWbemServices *a_Service 
	) ;

	HRESULT Helper_PutInstanceAsync (

		BOOL a_IsProxy ,
		IWbemClassObject *a_Instance ,
		long a_Flags ,
		IWbemContext FAR *a_Context ,
		IWbemObjectSink *a_Sink ,
		IWbemServices *a_Service 
	) ;

	HRESULT Helper_DeleteInstanceAsync (

		BOOL a_IsProxy ,
		const BSTR a_ObjectPath ,
		long a_Flags ,
		IWbemContext FAR *a_Context ,
		IWbemObjectSink *a_Sink ,
		IWbemServices *a_Service 
	) ;

    HRESULT Helper_CreateInstanceEnumAsync (

		BOOL a_IsProxy ,
		const BSTR a_Class ,
		long a_Flags ,
		IWbemContext *a_Context ,
		IWbemObjectSink *a_Sink ,
		IWbemServices *a_Service
	) ;

	HRESULT Helper_ExecQueryAsync (

		BOOL a_IsProxy ,
		const BSTR a_QueryLanguage ,
		const BSTR a_Query, 
		long a_Flags ,
		IWbemContext FAR *a_Context ,
		IWbemObjectSink *a_Sink ,
		IWbemServices *a_Service 
	) ;

	HRESULT Helper_ExecMethodAsync (

		BOOL a_IsProxy ,
		const BSTR a_ObjectPath ,
		const BSTR a_MethodName ,
		long a_Flags ,
		IWbemContext *a_Context ,
		IWbemClassObject *a_InParams ,
		IWbemObjectSink *a_Sink ,
		IWbemServices *a_Service 
	) ;

public:

	CInterceptor_DecoupledClient ( 

		WmiAllocator &a_Allocator ,
		IUnknown *a_ServerSideUnknown , 
		IWbemServices *a_CoreStub ,
		CServerObject_ProviderRegistrationV1 &a_Registration
	) ;

    ~CInterceptor_DecoupledClient () ;

	HRESULT ProviderInitialize () ;

public:

	//Non-delegating object IUnknown

    STDMETHODIMP QueryInterface ( REFIID , LPVOID FAR * ) ;
    STDMETHODIMP_( ULONG ) AddRef () ;
    STDMETHODIMP_( ULONG ) Release () ;

    /* IWbemServices methods */

    HRESULT STDMETHODCALLTYPE OpenNamespace ( 

        const BSTR a_Namespace ,
        long a_Flags ,
        IWbemContext *a_Context ,
        IWbemServices **a_Service ,
        IWbemCallResult **a_CallResult
	) ;
    
    HRESULT STDMETHODCALLTYPE CancelAsyncCall ( 

        IWbemObjectSink *a_Sink
	) ;
    
    HRESULT STDMETHODCALLTYPE QueryObjectSink ( 

        long a_Flags ,
        IWbemObjectSink **a_Sink
	) ;
    
    HRESULT STDMETHODCALLTYPE GetObject ( 

		const BSTR a_ObjectPath ,
        long a_Flags ,
        IWbemContext *a_Context ,
        IWbemClassObject **ppObject ,
        IWbemCallResult **a_CallResult
	) ;
    
    HRESULT STDMETHODCALLTYPE GetObjectAsync (
        
		const BSTR a_ObjectPath ,
        long a_Flags ,
        IWbemContext *a_Context ,
        IWbemObjectSink *a_Sink
	) ;

    HRESULT STDMETHODCALLTYPE PutClass ( 

        IWbemClassObject *a_Object ,
        long a_Flags ,
        IWbemContext *a_Context ,
        IWbemCallResult **a_CallResult
	) ;
    
    HRESULT STDMETHODCALLTYPE PutClassAsync ( 

        IWbemClassObject *a_Object ,
        long a_Flags ,
        IWbemContext *a_Context ,
        IWbemObjectSink *a_Sink
	) ;
    
    HRESULT STDMETHODCALLTYPE DeleteClass ( 

        const BSTR a_Class ,
        long a_Flags ,
        IWbemContext *a_Context ,
        IWbemCallResult **a_CallResult
	) ;
    
    HRESULT STDMETHODCALLTYPE DeleteClassAsync ( 

        const BSTR a_Class ,
        long a_Flags ,
        IWbemContext *a_Context ,
        IWbemObjectSink *a_Sink
	) ;
    
    HRESULT STDMETHODCALLTYPE CreateClassEnum ( 

        const BSTR a_Superclass ,
        long a_Flags ,
        IWbemContext *a_Context ,
        IEnumWbemClassObject **a_Enum
	) ;
    
    HRESULT STDMETHODCALLTYPE CreateClassEnumAsync ( 

		const BSTR a_Superclass ,
		long a_Flags ,
		IWbemContext *a_Context ,
		IWbemObjectSink *a_Sink
	) ;
    
    HRESULT STDMETHODCALLTYPE PutInstance (

		IWbemClassObject *a_Instance ,
		long a_Flags , 
		IWbemContext *a_Context ,
		IWbemCallResult **a_CallResult
	) ;
    
    HRESULT STDMETHODCALLTYPE PutInstanceAsync (

		IWbemClassObject *a_Instance ,
		long a_Flags ,
		IWbemContext *a_Context ,
		IWbemObjectSink *a_Sink 
	) ;
    
    HRESULT STDMETHODCALLTYPE DeleteInstance ( 

		const BSTR a_ObjectPath ,
		long a_Flags ,
		IWbemContext *a_Context ,
		IWbemCallResult **a_CallResult
	) ;
    
    HRESULT STDMETHODCALLTYPE DeleteInstanceAsync ( 

		const BSTR a_ObjectPath,
		long a_Flags,
		IWbemContext *a_Context ,
		IWbemObjectSink *a_Sink
	) ;
    
    HRESULT STDMETHODCALLTYPE CreateInstanceEnum (

		const BSTR a_Class ,
		long a_Flags ,
		IWbemContext *a_Context ,
		IEnumWbemClassObject **a_Enum
	) ;
    
    HRESULT STDMETHODCALLTYPE CreateInstanceEnumAsync (

		const BSTR a_Class ,
		long a_Flags ,
		IWbemContext *a_Context ,
		IWbemObjectSink *a_Sink
	) ;
    
    HRESULT STDMETHODCALLTYPE ExecQuery ( 

		const BSTR a_QueryLanguage,
		const BSTR a_Query,
		long a_Flags ,
		IWbemContext *a_Context ,
		IEnumWbemClassObject **a_Enum
	) ;
    
    HRESULT STDMETHODCALLTYPE ExecQueryAsync (

		const BSTR a_QueryLanguage ,
		const BSTR a_Query ,
		long a_Flags ,
		IWbemContext *a_Context ,
		IWbemObjectSink *a_Sink
	) ;
    
    HRESULT STDMETHODCALLTYPE ExecNotificationQuery (

		const BSTR a_QueryLanguage ,
		const BSTR a_Query ,
		long a_Flags ,
		IWbemContext *a_Context ,
		IEnumWbemClassObject **a_Enum
	) ;
    
    HRESULT STDMETHODCALLTYPE ExecNotificationQueryAsync ( 

        const BSTR a_QueryLanguage ,
        const BSTR a_Query ,
        long a_Flags ,
        IWbemContext *a_Context ,
        IWbemObjectSink *a_Sink
	) ;
    
    HRESULT STDMETHODCALLTYPE ExecMethod (

        const BSTR a_ObjectPath ,
        const BSTR a_MethodName ,
        long a_Flags ,
        IWbemContext *a_Context ,
        IWbemClassObject *a_InParams ,
        IWbemClassObject **a_OutParams ,
        IWbemCallResult **a_CallResult
	) ;
    
    HRESULT STDMETHODCALLTYPE ExecMethodAsync ( 

		const BSTR a_ObjectPath ,
		const BSTR a_MethodName ,
		long a_Flags ,
		IWbemContext *a_Context ,
		IWbemClassObject *a_InParams ,
		IWbemObjectSink *a_Sink
	) ;

	/* IWbemPropertyProvider */

    HRESULT STDMETHODCALLTYPE GetProperty (

        long a_Flags ,
        const BSTR a_Locale ,
        const BSTR a_ClassMapping ,
        const BSTR a_InstanceMapping ,
        const BSTR a_PropertyMapping ,
        VARIANT *a_Value
	) ;
        
    HRESULT STDMETHODCALLTYPE PutProperty (

        long a_Flags ,
        const BSTR a_Locale ,
        const BSTR a_ClassMapping ,
        const BSTR a_InstanceMapping ,
        const BSTR a_PropertyMapping ,
        const VARIANT *a_Value
	) ;

	/* IWbemEventProvider */

	HRESULT STDMETHODCALLTYPE ProvideEvents (

		IWbemObjectSink *a_Sink ,
		long a_Flags
	) ;

	/* IWbemEventProviderQuerySink */

	HRESULT STDMETHODCALLTYPE NewQuery (

		unsigned long a_Id ,
		WBEM_WSTR a_QueryLanguage ,
		WBEM_WSTR a_Query
	);

	HRESULT STDMETHODCALLTYPE CancelQuery (

		unsigned long a_Id
	) ;

	/* IWbemEventProviderSecurity */

	HRESULT STDMETHODCALLTYPE AccessCheck (

		WBEM_CWSTR a_QueryLanguage ,
		WBEM_CWSTR a_Query ,
		long a_SidLength ,
		const BYTE *a_Sid
	) ;

	/* IWbemProviderIdentity */

	HRESULT STDMETHODCALLTYPE SetRegistrationObject (

		long a_Flags ,
		IWbemClassObject *a_ProviderRegistration
	) ;

	/* IWbemEventConsumerProvider */

	HRESULT STDMETHODCALLTYPE FindConsumer (

		IWbemClassObject *a_LogicalConsumer ,
		IWbemUnboundObjectSink **a_Consumer
	);

	/* IWbemEventConsumerProviderEx */

	HRESULT STDMETHODCALLTYPE ValidateSubscription (

		IWbemClassObject *a_LogicalConsumer
	) ;

	/* IWbemUnboundObjectSink */

	HRESULT STDMETHODCALLTYPE IndicateToConsumer (

		IWbemClassObject *a_LogicalConsumer ,
		long a_ObjectCount ,
		IWbemClassObject **a_Objects
	) ;

/* Internal_IWbemServices */
 
     HRESULT STDMETHODCALLTYPE Internal_OpenNamespace ( 

		WmiInternalContext a_InternalContext ,
        const BSTR a_Namespace ,
        long a_Flags ,
        IWbemContext *a_Context ,
        IWbemServices **a_Service ,
        IWbemCallResult **a_CallResult
	) ;
    
    HRESULT STDMETHODCALLTYPE Internal_CancelAsyncCall ( 

		WmiInternalContext a_InternalContext ,
        IWbemObjectSink *a_Sink
	) ;
    
    HRESULT STDMETHODCALLTYPE Internal_QueryObjectSink ( 

		WmiInternalContext a_InternalContext ,
        long a_Flags ,
        IWbemObjectSink **a_Sink
	) ;
    
    HRESULT STDMETHODCALLTYPE Internal_GetObject ( 

		WmiInternalContext a_InternalContext ,
		const BSTR a_ObjectPath ,
        long a_Flags ,
        IWbemContext *a_Context ,
        IWbemClassObject **ppObject ,
        IWbemCallResult **a_CallResult
	) ;
    
    HRESULT STDMETHODCALLTYPE Internal_GetObjectAsync (
        
		WmiInternalContext a_InternalContext ,
		const BSTR a_ObjectPath ,
        long a_Flags ,
        IWbemContext *a_Context ,
        IWbemObjectSink *a_Sink
	) ;

    HRESULT STDMETHODCALLTYPE Internal_PutClass ( 

		WmiInternalContext a_InternalContext ,
        IWbemClassObject *a_Object ,
        long a_Flags ,
        IWbemContext *a_Context ,
        IWbemCallResult **a_CallResult
	) ;
    
    HRESULT STDMETHODCALLTYPE Internal_PutClassAsync ( 

		WmiInternalContext a_InternalContext ,
        IWbemClassObject *a_Object ,
        long a_Flags ,
        IWbemContext *a_Context ,
        IWbemObjectSink *a_Sink
	) ;
    
    HRESULT STDMETHODCALLTYPE Internal_DeleteClass ( 

		WmiInternalContext a_InternalContext ,
        const BSTR a_Class ,
        long a_Flags ,
        IWbemContext *a_Context ,
        IWbemCallResult **a_CallResult
	) ;
    
    HRESULT STDMETHODCALLTYPE Internal_DeleteClassAsync ( 

		WmiInternalContext a_InternalContext ,
        const BSTR a_Class ,
        long a_Flags ,
        IWbemContext *a_Context ,
        IWbemObjectSink *a_Sink
	) ;
    
    HRESULT STDMETHODCALLTYPE Internal_CreateClassEnum ( 

		WmiInternalContext a_InternalContext ,
        const BSTR a_Superclass ,
        long a_Flags ,
        IWbemContext *a_Context ,
        IEnumWbemClassObject **a_Enum
	) ;
    
    HRESULT STDMETHODCALLTYPE Internal_CreateClassEnumAsync ( 

		WmiInternalContext a_InternalContext ,
		const BSTR a_Superclass ,
		long a_Flags ,
		IWbemContext *a_Context ,
		IWbemObjectSink *a_Sink
	) ;
    
    HRESULT STDMETHODCALLTYPE Internal_PutInstance (

		WmiInternalContext a_InternalContext ,
		IWbemClassObject *a_Instance ,
		long a_Flags , 
		IWbemContext *a_Context ,
		IWbemCallResult **a_CallResult
	) ;
    
    HRESULT STDMETHODCALLTYPE Internal_PutInstanceAsync (

		WmiInternalContext a_InternalContext ,
		IWbemClassObject *a_Instance ,
		long a_Flags ,
		IWbemContext *a_Context ,
		IWbemObjectSink *a_Sink 
	) ;
    
    HRESULT STDMETHODCALLTYPE Internal_DeleteInstance ( 

		WmiInternalContext a_InternalContext ,
		const BSTR a_ObjectPath ,
		long a_Flags ,
		IWbemContext *a_Context ,
		IWbemCallResult **a_CallResult
	) ;
    
    HRESULT STDMETHODCALLTYPE Internal_DeleteInstanceAsync ( 

		WmiInternalContext a_InternalContext ,
		const BSTR a_ObjectPath,
		long a_Flags,
		IWbemContext *a_Context ,
		IWbemObjectSink *a_Sink
	) ;
    
    HRESULT STDMETHODCALLTYPE Internal_CreateInstanceEnum (

		WmiInternalContext a_InternalContext ,
		const BSTR a_Class ,
		long a_Flags ,
		IWbemContext *a_Context ,
		IEnumWbemClassObject **a_Enum
	) ;
    
    HRESULT STDMETHODCALLTYPE Internal_CreateInstanceEnumAsync (

		WmiInternalContext a_InternalContext ,
		const BSTR a_Class ,
		long a_Flags ,
		IWbemContext *a_Context ,
		IWbemObjectSink *a_Sink
	) ;
    
    HRESULT STDMETHODCALLTYPE Internal_ExecQuery ( 

		WmiInternalContext a_InternalContext ,
		const BSTR a_QueryLanguage,
		const BSTR a_Query,
		long a_Flags ,
		IWbemContext *a_Context ,
		IEnumWbemClassObject **a_Enum
	) ;
    
    HRESULT STDMETHODCALLTYPE Internal_ExecQueryAsync (

		WmiInternalContext a_InternalContext ,
		const BSTR a_QueryLanguage ,
		const BSTR a_Query ,
		long a_Flags ,
		IWbemContext *a_Context ,
		IWbemObjectSink *a_Sink
	) ;
    
    HRESULT STDMETHODCALLTYPE Internal_ExecNotificationQuery (

		WmiInternalContext a_InternalContext ,
		const BSTR a_QueryLanguage ,
		const BSTR a_Query ,
		long a_Flags ,
		IWbemContext *a_Context ,
		IEnumWbemClassObject **a_Enum
	) ;
    
    HRESULT STDMETHODCALLTYPE Internal_ExecNotificationQueryAsync ( 

		WmiInternalContext a_InternalContext ,
        const BSTR a_QueryLanguage ,
        const BSTR a_Query ,
        long a_Flags ,
        IWbemContext *a_Context ,
        IWbemObjectSink *a_Sink
	) ;
    
    HRESULT STDMETHODCALLTYPE Internal_ExecMethod (

		WmiInternalContext a_InternalContext ,
        const BSTR a_ObjectPath ,
        const BSTR a_MethodName ,
        long a_Flags ,
        IWbemContext *a_Context ,
        IWbemClassObject *a_InParams ,
        IWbemClassObject **a_OutParams ,
        IWbemCallResult **a_CallResult
	) ;
    
    HRESULT STDMETHODCALLTYPE Internal_ExecMethodAsync ( 

		WmiInternalContext a_InternalContext ,
		const BSTR a_ObjectPath ,
		const BSTR a_MethodName ,
		long a_Flags ,
		IWbemContext *a_Context ,
		IWbemClassObject *a_InParams ,
		IWbemObjectSink *a_Sink
	) ;

	/* Internal_IWbemPropertyProvider */

    HRESULT STDMETHODCALLTYPE Internal_GetProperty (

		WmiInternalContext a_InternalContext ,
        long a_Flags ,
        const BSTR a_Locale ,
        const BSTR a_ClassMapping ,
        const BSTR a_InstanceMapping ,
        const BSTR a_PropertyMapping ,
        VARIANT *a_Value
	) ;
        
    HRESULT STDMETHODCALLTYPE Internal_PutProperty (

		WmiInternalContext a_InternalContext ,
        long a_Flags ,
        const BSTR a_Locale ,
        const BSTR a_ClassMapping ,
        const BSTR a_InstanceMapping ,
        const BSTR a_PropertyMapping ,
        const VARIANT *a_Value
	) ;

	/* Internal_IWbemEventProvider */

	HRESULT STDMETHODCALLTYPE Internal_ProvideEvents (

		WmiInternalContext a_InternalContext ,
		IWbemObjectSink *a_Sink ,
		long a_Flags
	) ;

	/* Internal_IWbemEventProviderQuerySink */

	HRESULT STDMETHODCALLTYPE Internal_NewQuery (

		WmiInternalContext a_InternalContext ,
		unsigned long a_Id ,
		WBEM_WSTR a_QueryLanguage ,
		WBEM_WSTR a_Query
	);

	HRESULT STDMETHODCALLTYPE Internal_CancelQuery (

		WmiInternalContext a_InternalContext ,
		unsigned long a_Id
	) ;

	/* Internal_IWbemEventProviderSecurity */

	HRESULT STDMETHODCALLTYPE Internal_AccessCheck (

		WmiInternalContext a_InternalContext ,
		WBEM_CWSTR a_QueryLanguage ,
		WBEM_CWSTR a_Query ,
		long a_SidLength ,
		const BYTE *a_Sid
	) ;

	/* Internal_IWbemEventConsumerProvider */

	HRESULT STDMETHODCALLTYPE Internal_FindConsumer (

		WmiInternalContext a_InternalContext ,
		IWbemClassObject *a_LogicalConsumer ,
		IWbemUnboundObjectSink **a_Consumer
	);

	/* Internal_IWbemEventConsumerProviderEx */

	HRESULT STDMETHODCALLTYPE Internal_ValidateSubscription (

		WmiInternalContext a_InternalContext ,
		IWbemClassObject *a_LogicalConsumer
	) ;

	/* Internal_IWbemUnboundObjectSink */

	HRESULT STDMETHODCALLTYPE Internal_IndicateToConsumer (

		WmiInternalContext a_InternalContext ,
		IWbemClassObject *a_LogicalConsumer ,
		long a_ObjectCount ,
		IWbemClassObject **a_Objects
	) ;


	/* IWbemProviderInit methods */

	HRESULT STDMETHODCALLTYPE Initialize (

		LPWSTR a_User ,
		LONG a_Flags ,
		LPWSTR a_Namespace ,
		LPWSTR a_Locale ,
		IWbemServices *a_CoreService ,
		IWbemContext *a_Context ,
		IWbemProviderInitSink *a_Sink
	) ;

	HRESULT STDMETHODCALLTYPE Internal_Initialize (

		WmiInternalContext a_InternalContext ,
		LPWSTR a_User ,
		LONG a_Flags ,
		LPWSTR a_Namespace ,
		LPWSTR a_Locale ,
		IWbemServices *a_CoreService ,
		IWbemContext *a_Context ,
		IWbemProviderInitSink *a_Sink
	) ;

	/* _IWmiProviderSite */

	HRESULT STDMETHODCALLTYPE GetSite ( DWORD *a_ProcessIdentifier ) ;

	HRESULT STDMETHODCALLTYPE SetContainer ( IUnknown *a_Container ) ;

	// IWmi_UnInitialize members

	HRESULT STDMETHODCALLTYPE Shutdown (

		LONG a_Flags ,
		ULONG a_MaxMilliSeconds ,
		IWbemContext *a_Context
	) ; 
} ;

#endif // _Decopled_Interceptor_IWbemServices_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\provsubsys\example\classfac.cpp ===
#ifndef __CLASSFACTORY_CPP
#define __CLASSFACTORY_CPP

/*++

Copyright (C) 1996-2001 Microsoft Corporation

Module Name:

	ClassFac.cpp

Abstract:


History:

--*/

#include <Precomp.h>

// this redefines the DEFINE_GUID() macro to do allocation.
//
#include <initguid.h>
#ifndef INITGUID
#define INITGUID
#endif


#include "Globals.h"
#include "ClassFac.h"
#include "Service.h"

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

template <class Object,class ObjectInterface>
CProviderClassFactory <Object,ObjectInterface> :: CProviderClassFactory <Object,ObjectInterface> () : m_ReferenceCount ( 0 )
{
	InterlockedIncrement ( & Provider_Globals :: s_ObjectsInProgress ) ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

template <class Object,class ObjectInterface>
CProviderClassFactory <Object,ObjectInterface> :: ~CProviderClassFactory <Object,ObjectInterface> ()
{
	InterlockedDecrement ( & Provider_Globals :: s_ObjectsInProgress ) ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

template <class Object,class ObjectInterface>
STDMETHODIMP CProviderClassFactory <Object,ObjectInterface> :: QueryInterface (

	REFIID iid , 
	LPVOID FAR *iplpv 
) 
{
	*iplpv = NULL ;

	if ( iid == IID_IUnknown )
	{
		*iplpv = ( LPVOID ) this ;
	}
	else if ( iid == IID_IClassFactory )
	{
		*iplpv = ( LPVOID ) ( IClassFactory * ) this ;		
	}	

	if ( *iplpv )
	{
		( ( LPUNKNOWN ) *iplpv )->AddRef () ;

		return ResultFromScode ( S_OK ) ;
	}
	else
	{
		return ResultFromScode ( E_NOINTERFACE ) ;
	}
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

template <class Object,class ObjectInterface>
STDMETHODIMP_( ULONG ) CProviderClassFactory <Object,ObjectInterface> :: AddRef ()
{
	return InterlockedIncrement ( & m_ReferenceCount ) ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

template <class Object,class ObjectInterface>
STDMETHODIMP_(ULONG) CProviderClassFactory <Object,ObjectInterface> :: Release ()
{
	LONG t_Reference ;
	if ( ( t_Reference = InterlockedDecrement ( & m_ReferenceCount ) ) == 0 )
	{
		delete this ;
		return 0 ;
	}
	else
	{
		return t_Reference ;
	}
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

template <class Object,class ObjectInterface>
STDMETHODIMP CProviderClassFactory <Object,ObjectInterface> :: CreateInstance (

	LPUNKNOWN pUnkOuter ,
	REFIID riid ,
	LPVOID FAR * ppvObject
)
{
	HRESULT status = S_OK ;

	if ( pUnkOuter )
	{
		status = CLASS_E_NOAGGREGATION ;
	}
	else
	{
		IUnknown *lpunk = ( ObjectInterface * ) new Object ( *Provider_Globals :: s_Allocator );
		if ( lpunk == NULL )
		{
			status = E_OUTOFMEMORY ;
		}
		else
		{
			status = lpunk->QueryInterface ( riid , ppvObject ) ;
			if ( FAILED ( status ) )
			{
				delete lpunk ;
			}
			else
			{
			}
		}			
	}

	return status ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

template <class Object,class ObjectInterface>
STDMETHODIMP CProviderClassFactory <Object,ObjectInterface> :: LockServer ( BOOL fLock )
{
/* 
 * Place code in critical section
 */

	if ( fLock )
	{
		InterlockedIncrement ( & Provider_Globals :: s_LocksInProgress ) ;
	}
	else
	{
		InterlockedDecrement ( & Provider_Globals :: s_LocksInProgress ) ;
	}

	return S_OK	;
}

#endif __CLASSFACTORY_CPP
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\provsubsys\example\main.cpp ===
*++

Copyright (C) 1996-2001 Microsoft Corporation

Module Name:

	Main.cpp

Abstract:


History:

--*/

#include <precomp.h>
#include <objbase.h>
#include <stdio.h>
#include <tchar.h>
#include <wbemcli.h>
#include <wbemint.h>
#include <Exception.h>
#include <HelperFuncs.h>
#include "Globals.h"
#include "ClassFac.h"
#include "Service.h"
#include "Guids.h"

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

DWORD g_Register = 0 ;
HANDLE g_ThreadTerminate = NULL ;

STDAPI DllRegisterServer () ;
STDAPI DllUnregisterServer () ;

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

LRESULT CALLBACK WindowsMainProc ( HWND a_hWnd , UINT a_message , WPARAM a_wParam , LPARAM a_lParam )
{
	LRESULT t_rc = 0 ;

	switch ( a_message )
	{
		case WM_DESTROY:
		{
			PostMessage ( a_hWnd , WM_QUIT , 0 , 0 ) ;
		}
		break ;

		default:
		{		
			t_rc = DefWindowProc ( a_hWnd , a_message , a_wParam , a_lParam ) ;
		}
		break ;
	}

	return ( t_rc ) ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HWND WindowsInit ( HINSTANCE a_HInstance )
{
	static wchar_t *t_TemplateCode = L"TemplateCode" ;

	WNDCLASS  t_wc ;
 
	t_wc.style            = CS_HREDRAW | CS_VREDRAW ;
	t_wc.lpfnWndProc      = WindowsMainProc ;
	t_wc.cbClsExtra       = 0 ;
	t_wc.cbWndExtra       = 0 ;
	t_wc.hInstance        = a_HInstance ;
	t_wc.hIcon            = LoadIcon(NULL, IDI_HAND) ;
	t_wc.hCursor          = LoadCursor(NULL, IDC_ARROW) ;
	t_wc.hbrBackground    = (HBRUSH) (COLOR_WINDOW + 1) ;
	t_wc.lpszMenuName     = NULL ;
	t_wc.lpszClassName    = t_TemplateCode ;
 
	ATOM t_winClass = RegisterClass ( &t_wc ) ;

	HWND t_HWnd = CreateWindow (

		t_TemplateCode ,              // see RegisterClass() call
		t_TemplateCode ,                      // text for window title bar
		WS_OVERLAPPEDWINDOW | WS_MINIMIZE ,               // window style
		CW_USEDEFAULT ,                     // default horizontal position
		CW_USEDEFAULT ,                     // default vertical position
		CW_USEDEFAULT ,                     // default width
		CW_USEDEFAULT ,                     // default height
		NULL ,                              // overlapped windows have no parent
		NULL ,                              // use the window class menu
		a_HInstance ,
		NULL                                // pointer not needed
	) ;

	ShowWindow ( t_HWnd, SW_SHOW ) ;
	//ShowWindow ( t_HWnd, SW_HIDE ) ;

	return t_HWnd ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

void WindowsStop ( HWND a_HWnd )
{
	CoUninitialize () ;
	DestroyWindow ( a_HWnd ) ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HWND WindowsStart ( HINSTANCE a_Handle )
{
	HWND t_HWnd = NULL ;
	if ( ! ( t_HWnd = WindowsInit ( a_Handle ) ) )
	{
    }

	return t_HWnd ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

void WindowsDispatch ()
{
	BOOL t_GetMessage ;
	MSG t_lpMsg ;

	while (	( t_GetMessage = GetMessage ( & t_lpMsg , NULL , 0 , 0 ) ) == TRUE )
	{
		TranslateMessage ( & t_lpMsg ) ;
		DispatchMessage ( & t_lpMsg ) ;
	}
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT UninitComServer ()
{
	CoRevokeClassObject ( g_Register );
	CoUninitialize () ;

	return S_OK ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT InitComServer ( DWORD a_AuthenticationLevel , DWORD a_ImpersonationLevel )
{
	HRESULT t_Result = S_OK ;

    t_Result = CoInitializeEx (

		0, 
		COINIT_MULTITHREADED
	);

	if ( SUCCEEDED ( t_Result ) ) 
	{
		t_Result = CoInitializeSecurity (

			NULL, 
			-1, 
			NULL, 
			NULL,
			a_AuthenticationLevel,
			a_ImpersonationLevel, 
			NULL, 
			EOAC_DYNAMIC_CLOAKING, 
			0
		);

		if ( FAILED ( t_Result ) ) 
		{
			CoUninitialize () ;
			return t_Result ;
		}
	}

	IUnknown *t_ClassFactory = new CProviderClassFactory <CProvider_IWbemServices,IWbemServices> ;

	DWORD t_ClassContext = CLSCTX_LOCAL_SERVER ;
	DWORD t_Flags = REGCLS_MULTIPLEUSE ;

	t_Result = CoRegisterClassObject (

		CLSID_WmiProvider, 
		t_ClassFactory,
        t_ClassContext, 
		t_Flags, 
		&g_Register
	);

	if ( FAILED ( t_Result ) )
	{
		CoRevokeClassObject ( g_Register );
	}

	if ( FAILED ( t_Result ) )
	{
		CoUninitialize () ;
	}

	return t_Result  ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT RegisterDecoupledInstance (

	IWbemDecoupledRegistrar *&a_Registrar 
)
{
	a_Registrar = NULL ;
	HRESULT t_Result = Provider_Globals :: CreateInstance ( 

		CLSID_WbemDecoupledRegistrar ,
		NULL ,
		CLSCTX_INPROC_SERVER ,
		IID_IWbemDecoupledRegistrar ,
		( void ** ) & a_Registrar 
	) ;

	if ( SUCCEEDED ( t_Result ) )
	{
		CProvider_IWbemServices *t_Service = new CProvider_IWbemServices ( *Provider_Globals :: s_Allocator ) ;
		if ( t_Service )
		{
			t_Service->AddRef () ;

			IUnknown *t_Unknown = NULL ;
			t_Result = t_Service->QueryInterface ( IID_IUnknown , ( void ** ) & t_Unknown ) ;
			if ( SUCCEEDED ( t_Result ) )
			{
				t_Result = a_Registrar->Register ( 

					0 ,
					NULL ,
					NULL ,
					NULL ,
					L"root\\cimv2" ,
					L"DecoupledInstanceProvider" ,
					t_Unknown
				) ;

				t_Unknown->Release () ;
			}

			t_Service->Release () ;
		}
	}

	if ( FAILED ( t_Result ) )
	{
		if ( a_Registrar )
		{
			a_Registrar->Release () ;
			a_Registrar = NULL ;
		}
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

struct ThreadArg_Struct 
{
	IWbemServices *m_Service ;
	IWbemObjectSink *m_Sink ;
	IWbemEventSink *m_EventSink ;
	IWbemDecoupledBasicEventProvider *m_Registrar ;
} ;

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

DWORD ThreadExecutionFunction ( void *a_Context )
{
	HRESULT t_Result = S_OK ;

	struct ThreadArg_Struct *t_ThreadStruct = ( struct ThreadArg_Struct * ) a_Context ;
	if ( t_ThreadStruct )
	{
		t_Result = CoInitializeEx (

			0, 
			COINIT_MULTITHREADED
		) ;

		if ( SUCCEEDED ( t_Result ) )
		{
			IWbemClassObject *t_Object = NULL ;
			BSTR t_String = SysAllocString ( L"SampleEvent" ) ;
			if ( t_String )
			{
				t_Result = t_ThreadStruct->m_Service->GetObject ( 

					t_String , 
					0 , 
					NULL , 
					& t_Object ,
					NULL
				) ;

				if ( SUCCEEDED ( t_Result ) )
				{
					IWbemClassObject *t_Instance = NULL ;
					t_Result = t_Object->SpawnInstance ( 0 , & t_Instance ) ;
					if ( SUCCEEDED ( t_Result ) )
					{
						VARIANT t_Variant ;
						VariantInit ( & t_Variant ) ;

						t_Variant.vt = VT_BSTR ;
						t_Variant.bstrVal = SysAllocString ( L"Steve" ) ;

						t_Result = t_Instance->Put ( 

							L"Name" ,
							0 , 
							& t_Variant ,
							CIM_EMPTY 
						) ;

						VariantClear ( & t_Variant ) ;

						BOOL t_Continue = TRUE ;
						while ( t_Continue )
						{
							DWORD t_Status = WaitForSingleObject ( g_ThreadTerminate , 1000 ) ;
							switch ( t_Status )
							{
								case WAIT_TIMEOUT:
								{
									t_ThreadStruct->m_Sink->Indicate ( 1 , & t_Instance ) ;
								}
								break ;

								case WAIT_OBJECT_0:
								{
									t_Continue = FALSE ;
								}
								break ;

								default:
								{
									t_Continue = FALSE ;
								}
								break ;
							}
						}

						t_Instance->Release () ;
					}

					t_Object->Release () ;
				}

				SysFreeString ( t_String ) ;
			}
			else
			{
				t_Result = WBEM_E_OUT_OF_MEMORY ;
			}
		}

		t_ThreadStruct->m_Service->Release () ;
		t_ThreadStruct->m_Sink->Release () ;
		t_ThreadStruct->m_Registrar->Release () ;

		delete t_ThreadStruct ;
	}
	else
	{
		t_Result = WBEM_E_INVALID_PARAMETER ;
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

DWORD RestrictedThreadExecutionFunction ( void *a_Context )
{
	HRESULT t_Result = S_OK ;

	struct ThreadArg_Struct *t_ThreadStruct = ( struct ThreadArg_Struct * ) a_Context ;
	if ( t_ThreadStruct )
	{
		t_Result = CoInitializeEx (

			0, 
			COINIT_MULTITHREADED
		) ;

		if ( SUCCEEDED ( t_Result ) )
		{
			IWbemClassObject *t_Object = NULL ;
			BSTR t_String = SysAllocString ( L"SampleEvent" ) ;
			if ( t_String )
			{
				wchar_t *t_Query = L"Select * from SampleEvent where Name = 'Steve'" ;

				IWbemEventSink *t_RestrictedSink = NULL ; 

				t_Result = t_ThreadStruct->m_EventSink->GetRestrictedSink (

					1 ,
					& t_Query ,
					NULL ,
					& t_RestrictedSink
				) ;

				if ( SUCCEEDED ( t_Result ) )
				{
					t_Result = t_ThreadStruct->m_Service->GetObject ( 

						t_String , 
						0 , 
						NULL , 
						& t_Object ,
						NULL
					) ;

					if ( SUCCEEDED ( t_Result ) )
					{
						IWbemClassObject *t_Instance = NULL ;
						t_Result = t_Object->SpawnInstance ( 0 , & t_Instance ) ;
						if ( SUCCEEDED ( t_Result ) )
						{
							VARIANT t_Variant ;
							VariantInit ( & t_Variant ) ;

							t_Variant.vt = VT_BSTR ;
							t_Variant.bstrVal = SysAllocString ( L"Steve" ) ;

							t_Result = t_Instance->Put ( 

								L"Name" ,
								0 , 
								& t_Variant ,
								CIM_EMPTY 
							) ;

							VariantClear ( & t_Variant ) ;

							BOOL t_Continue = TRUE ;
							while ( t_Continue )
							{
								DWORD t_Status = WaitForSingleObject ( g_ThreadTerminate , 1000 ) ;
								switch ( t_Status )
								{
									case WAIT_TIMEOUT:
									{
										if ( t_RestrictedSink->IsActive () == S_OK )
										{
											t_RestrictedSink->Indicate ( 1 , & t_Instance ) ;
										}
									}
									break ;

									case WAIT_OBJECT_0:
									{
										t_Continue = FALSE ;
									}
									break ;

									default:
									{
										t_Continue = FALSE ;
									}
									break ;
								}
							}

							t_Instance->Release () ;
						}

						t_Object->Release () ;
					}

					t_RestrictedSink->Release () ;
				}

				SysFreeString ( t_String ) ;
			}
			else
			{
				t_Result = WBEM_E_OUT_OF_MEMORY ;
			}
		}

		t_ThreadStruct->m_Service->Release () ;
		t_ThreadStruct->m_Sink->Release () ;
		t_ThreadStruct->m_Registrar->Release () ;

		delete t_ThreadStruct ;
	}
	else
	{
		t_Result = WBEM_E_INVALID_PARAMETER ;
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT RegisterDecoupledEvent ( 

	IWbemDecoupledBasicEventProvider *&a_Registrar ,
	HANDLE &a_ThreadHandle
)
{
	a_ThreadHandle = NULL ;
	a_Registrar = NULL ;

	HRESULT t_Result = S_OK ;

	g_ThreadTerminate = CreateEvent ( NULL , FALSE , FALSE , NULL ) ;
	if ( g_ThreadTerminate )
	{
		t_Result = Provider_Globals :: CreateInstance ( 

			CLSID_WbemDecoupledBasicEventProvider ,
			NULL ,
			CLSCTX_INPROC_SERVER ,
			IID_IWbemDecoupledBasicEventProvider ,
			( void ** ) & a_Registrar 
		) ;

		if ( SUCCEEDED ( t_Result ) )
		{	
			ULONG t_TickCount1 = GetTickCount ();

			t_Result = a_Registrar->Register ( 

				0 ,
				NULL ,
				NULL ,
				NULL ,
				L"root\\cimv2" ,
				L"DecoupledEventProvider" ,
				NULL
			) ;

			if ( SUCCEEDED ( t_Result ) )
			{
				IWbemServices *t_Service = NULL ;
				t_Result = a_Registrar->GetService ( 0 , NULL , & t_Service ) ;
				if ( SUCCEEDED ( t_Result ) )
				{
					IWbemObjectSink *t_Sink = NULL ;
					t_Result = a_Registrar->GetSink ( 0 , NULL , & t_Sink ) ;
					if ( SUCCEEDED ( t_Result ) )
					{
					ULONG t_TickCount2 = GetTickCount ();
						struct ThreadArg_Struct *t_ThreadStruct = new ThreadArg_Struct ;

						t_ThreadStruct->m_Service = t_Service ;
						t_ThreadStruct->m_Sink = t_Sink ;
						t_ThreadStruct->m_Registrar = a_Registrar ;

						t_ThreadStruct->m_Service->AddRef () ;
						t_ThreadStruct->m_Sink->AddRef () ;
						t_ThreadStruct->m_Registrar->AddRef () ;
						
						DWORD t_ThreadId = 0 ;
						a_ThreadHandle = CreateThread (

							NULL ,
							0 , 
							ThreadExecutionFunction ,
							t_ThreadStruct ,
							0 , 
							& t_ThreadId 
						) ;

						if ( a_ThreadHandle == NULL )
						{
							t_ThreadStruct->m_Service->Release () ;
							t_ThreadStruct->m_Sink->Release () ;
							t_ThreadStruct->m_Registrar->Release () ;

							delete t_ThreadStruct ;

							t_Result = WBEM_E_FAILED ;
						}

						t_Sink->Release () ;
					}

					t_Service->Release () ;
				}
			}
		}

		if ( FAILED ( t_Result ) )
		{
			if ( a_Registrar )
			{
				a_Registrar->Release () ;
				a_Registrar = NULL ;
			}
		}
	}
	else
	{
		t_Result = WBEM_E_OUT_OF_MEMORY ;
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT RegisterDecoupledRestrictedEvent ( 

	IWbemDecoupledBasicEventProvider *&a_Registrar ,
	HANDLE &a_ThreadHandle
)
{
	a_ThreadHandle = NULL ;
	a_Registrar = NULL ;

	HRESULT t_Result = S_OK ;

	g_ThreadTerminate = CreateEvent ( NULL , FALSE , FALSE , NULL ) ;
	if ( g_ThreadTerminate )
	{
		t_Result = Provider_Globals :: CreateInstance ( 

			CLSID_WbemDecoupledBasicEventProvider ,
			NULL ,
			CLSCTX_INPROC_SERVER ,
			IID_IWbemDecoupledBasicEventProvider ,
			( void ** ) & a_Registrar 
		) ;

		if ( SUCCEEDED ( t_Result ) )
		{
			t_Result = a_Registrar->Register ( 

				0 ,
				NULL ,
				NULL ,
				NULL ,
				L"root\\cimv2" ,
				L"DecoupledEventProvider" ,
				NULL
			) ;

			if ( SUCCEEDED ( t_Result ) )
			{
				IWbemServices *t_Service = NULL ;
				t_Result = a_Registrar->GetService ( 0 , NULL , & t_Service ) ;
				if ( SUCCEEDED ( t_Result ) )
				{
					IWbemObjectSink *t_Sink = NULL ;
					t_Result = a_Registrar->GetSink ( 0 , NULL , & t_Sink ) ;
					if ( SUCCEEDED ( t_Result ) )
					{
						IWbemEventSink *t_EventSink = NULL ;
						t_Result = t_Sink->QueryInterface ( IID_IWbemEventSink , ( void **) & t_EventSink ) ;
						if ( SUCCEEDED ( t_Result ) ) 
						{
							struct ThreadArg_Struct *t_ThreadStruct = new ThreadArg_Struct ;

							t_ThreadStruct->m_Service = t_Service ;
							t_ThreadStruct->m_Sink = t_Sink ;
							t_ThreadStruct->m_EventSink = t_EventSink ;
							t_ThreadStruct->m_Registrar = a_Registrar ;
							
							t_ThreadStruct->m_Service->AddRef () ;
							t_ThreadStruct->m_Sink->AddRef () ;
							t_ThreadStruct->m_EventSink->AddRef () ;
							t_ThreadStruct->m_Registrar->AddRef () ;
							
							DWORD t_ThreadId = 0 ;
							a_ThreadHandle = CreateThread (

								NULL ,
								0 , 
								RestrictedThreadExecutionFunction ,
								t_ThreadStruct ,
								0 , 
								& t_ThreadId 
							) ;

							if ( a_ThreadHandle == NULL )
							{
								t_ThreadStruct->m_Service->Release () ;
								t_ThreadStruct->m_Sink->Release () ;
								t_ThreadStruct->m_EventSink->Release () ;
								t_ThreadStruct->m_Registrar->Release () ;

								delete t_ThreadStruct ;

								t_Result = WBEM_E_FAILED ;
							}

							t_EventSink->Release () ;
						}

						t_Sink->Release () ;
					}

					t_Service->Release () ;
				}
			}
		}

		if ( FAILED ( t_Result ) )
		{
			if ( a_Registrar )
			{
				a_Registrar->Release () ;
				a_Registrar = NULL ;
			}
		}
	}
	else
	{
		t_Result = WBEM_E_OUT_OF_MEMORY ;
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT Process ()
{
	DWORD t_ImpersonationLevel = RPC_C_IMP_LEVEL_IDENTIFY ;
	DWORD t_AuthenticationLevel = RPC_C_AUTHN_LEVEL_CONNECT ;

	HRESULT t_Result = InitComServer ( t_AuthenticationLevel , t_ImpersonationLevel ) ;
	if ( SUCCEEDED ( t_Result ) )
	{
		Wmi_SetStructuredExceptionHandler t_StructuredException ;
		try 
		{
#if 0
			HANDLE t_ThreadHandle = NULL ;
			IWbemDecoupledBasicEventProvider *t_EventRegistrar = NULL ;

			t_Result = RegisterDecoupledRestrictedEvent ( t_EventRegistrar , t_ThreadHandle ) ;
			if ( SUCCEEDED ( t_Result ) )
			{
				WindowsDispatch () ;

				SetEvent ( g_ThreadTerminate ) ;
				WaitForSingleObject ( t_ThreadHandle , INFINITE ) ;
				CloseHandle ( t_ThreadHandle ) ;
			}

			if ( t_EventRegistrar )
			{
				t_EventRegistrar->UnRegister () ;
				t_EventRegistrar->Release () ;
			}
#else
#if 1
			IWbemDecoupledRegistrar *t_InstanceRegistrar = NULL ;
			HANDLE t_ThreadHandle = NULL ;
			IWbemDecoupledBasicEventProvider *t_EventRegistrar = NULL ;

			t_Result = RegisterDecoupledInstance ( t_InstanceRegistrar ) ;
			if ( SUCCEEDED ( t_Result ) ) 
			{
				t_Result = RegisterDecoupledEvent ( t_EventRegistrar , t_ThreadHandle ) ;
			}

			if ( SUCCEEDED ( t_Result ) )
			{
				WindowsDispatch () ;

				SetEvent ( g_ThreadTerminate ) ;
				WaitForSingleObject ( t_ThreadHandle , INFINITE ) ;
				CloseHandle ( t_ThreadHandle ) ;
			}

			if ( t_InstanceRegistrar )
			{
				t_InstanceRegistrar->UnRegister () ;
				t_InstanceRegistrar->Release () ;
			}

			if ( t_EventRegistrar )
			{
				t_EventRegistrar->UnRegister () ;
				t_EventRegistrar->Release () ;
			}
#else
			IWbemDecoupledRegistrar *t_InstanceRegistrar = NULL ;
			HANDLE t_ThreadHandle = NULL ;

			t_Result = RegisterDecoupledInstance ( t_InstanceRegistrar ) ;

			if ( SUCCEEDED ( t_Result ) )
			{
				WindowsDispatch () ;

				SetEvent ( g_ThreadTerminate ) ;
				WaitForSingleObject ( t_ThreadHandle , INFINITE ) ;
				CloseHandle ( t_ThreadHandle ) ;
			}

			if ( t_InstanceRegistrar )
			{
				t_InstanceRegistrar->UnRegister () ;
				t_InstanceRegistrar->Release () ;
			}
#endif
#endif
		}
		catch ( Wmi_Structured_Exception t_StructuredException )
		{
		}

		UninitComServer () ;
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

BOOL ParseCommandLine () 
{
	BOOL t_Exit = FALSE ;

	LPTSTR t_CommandLine = GetCommandLine () ;
	if ( t_CommandLine )
	{
		TCHAR *t_Arg = NULL ;
		TCHAR *t_ApplicationArg = NULL ;
		t_ApplicationArg = _tcstok ( t_CommandLine , _TEXT ( " \t" ) ) ;
		t_Arg = _tcstok ( NULL , _TEXT ( " \t" ) ) ;
		if ( t_Arg ) 
		{
			if ( _tcsicmp ( t_Arg , _TEXT ( "/RegServer" ) ) == 0 )
			{
				t_Exit = TRUE ;
				DllRegisterServer () ;
			}
			else if ( _tcsicmp ( t_Arg , _TEXT ( "/UnRegServer" ) ) == 0 )
			{
				t_Exit = TRUE ;
				DllUnregisterServer () ;
			}
		}
	}

	return t_Exit ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

int WINAPI WinMain (
  
    HINSTANCE hInstance,		// handle to current instance
    HINSTANCE hPrevInstance,	// handle to previous instance
    LPSTR lpCmdLine,			// pointer to command line
    int nShowCmd 				// show state of window
)
{
	HRESULT t_Result = Provider_Globals :: Global_Startup () ;
	if ( SUCCEEDED ( t_Result ) )
	{
		BOOL t_Exit = ParseCommandLine () ;
		if ( ! t_Exit ) 
		{
			HWND hWnd = WindowsStart ( hInstance ) ;

			t_Result = Process () ;

			WindowsStop ( hWnd ) ;
		}

		t_Result = Provider_Globals :: Global_Shutdown () ;

	}

	return 0 ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\provsubsys\example\classservice.cpp ===
/*++

Copyright (C) 1996-2001 Microsoft Corporation

Module Name:

	XXXX

Abstract:


History:

--*/

#include <precomp.h>
#include <objbase.h>
#include <wbemcli.h>
#include <wbemint.h>
#include "Globals.h"
#include "ClassService.h"

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

CClassProvider_IWbemServices :: CClassProvider_IWbemServices (

	 WmiAllocator &a_Allocator 

) : m_ReferenceCount ( 0 ) , 
	m_Allocator ( a_Allocator ) ,
	m_User ( NULL ) ,
	m_Locale ( NULL ) ,
	m_Namespace ( NULL ) ,
	m_Empty ( NULL ) 
{
	InterlockedIncrement ( & Provider_Globals :: s_ObjectsInProgress ) ;

	InitializeCriticalSection ( & m_CriticalSection ) ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

CClassProvider_IWbemServices :: ~CClassProvider_IWbemServices ()
{
	DeleteCriticalSection ( & m_CriticalSection ) ;

	if ( m_Empty )
	{
		m_Empty->Release () ;
	}

	if ( m_User ) 
	{
		SysFreeString ( m_User ) ;
	}

	if ( m_Locale ) 
	{
		SysFreeString ( m_Locale ) ;
	}

	if ( m_Namespace ) 
	{
		SysFreeString ( m_Namespace ) ;
	}

	if ( m_CoreService ) 
	{
		m_CoreService->Release () ;
	}

	InterlockedDecrement ( & Provider_Globals :: s_ObjectsInProgress ) ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

STDMETHODIMP_(ULONG) CClassProvider_IWbemServices :: AddRef ( void )
{
	return InterlockedIncrement ( & m_ReferenceCount ) ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

STDMETHODIMP_(ULONG) CClassProvider_IWbemServices :: Release ( void )
{
	LONG t_Reference ;
	if ( ( t_Reference = InterlockedDecrement ( & m_ReferenceCount ) ) == 0 )
	{
		delete this ;
		return 0 ;
	}
	else
	{
		return t_Reference ;
	}
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

STDMETHODIMP CClassProvider_IWbemServices :: QueryInterface (

	REFIID iid , 
	LPVOID FAR *iplpv 
) 
{
	*iplpv = NULL ;

	if ( iid == IID_IUnknown )
	{
		*iplpv = ( LPVOID ) this ;
	}
	else if ( iid == IID_IWbemServices )
	{
		*iplpv = ( LPVOID ) ( IWbemServices * ) this ;		
	}	
	else if ( iid == IID_IWbemPropertyProvider )
	{
		*iplpv = ( LPVOID ) ( IWbemPropertyProvider * ) this ;		
	}	
	else if ( iid == IID_IWbemProviderInit )
	{
		*iplpv = ( LPVOID ) ( IWbemProviderInit * ) this ;		
	}	
	else if ( iid == IID_IWbemShutdown )
	{
		*iplpv = ( LPVOID ) ( IWbemShutdown * ) this ;		
	}	
/*
	else if ( iid == IID_IWmi_Status )
	{
		*iplpv = ( LPVOID ) ( IWmi_Status * )this ;		
	}	
*/

	if ( *iplpv )
	{
		( ( LPUNKNOWN ) *iplpv )->AddRef () ;

		return ResultFromScode ( S_OK ) ;
	}
	else
	{
		return ResultFromScode ( E_NOINTERFACE ) ;
	}
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CClassProvider_IWbemServices::OpenNamespace ( 

	const BSTR ObjectPath, 
	long lFlags, 
	IWbemContext FAR* pCtx,
	IWbemServices FAR* FAR* pNewContext, 
	IWbemCallResult FAR* FAR* ppErrorObject
)
{
	return WBEM_E_NOT_AVAILABLE ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CClassProvider_IWbemServices :: CancelAsyncCall ( 
		
	IWbemObjectSink __RPC_FAR *pSink
)
{
	HRESULT t_Result = WBEM_E_NOT_AVAILABLE ;

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CClassProvider_IWbemServices :: QueryObjectSink ( 

	long lFlags,		
	IWbemObjectSink FAR* FAR* ppResponseHandler
) 
{
	return WBEM_E_NOT_AVAILABLE ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CClassProvider_IWbemServices :: GetObject ( 
		
	const BSTR ObjectPath,
    long lFlags,
    IWbemContext FAR *pCtx,
    IWbemClassObject FAR* FAR *ppObject,
    IWbemCallResult FAR* FAR *ppCallResult
)
{
	return WBEM_E_NOT_AVAILABLE ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CClassProvider_IWbemServices :: GetObjectAsync ( 
		
	const BSTR ObjectPath, 
	long lFlags, 
	IWbemContext FAR *pCtx,
	IWbemObjectSink FAR* pSink
) 
{
	HRESULT t_Result = WBEM_E_NOT_FOUND ;

    if ( _wcsicmp ( ObjectPath , L"Steve_Class" ) == 0 )
    {
        IWbemClassObject *t_Class = NULL;
    
        t_Result = BuildClass ( & t_Class ) ;

        if ( SUCCEEDED ( t_Result ) )
        {
            pSink->Indicate ( 1, & t_Class ) ;
            pSink->SetStatus ( 0, WBEM_NO_ERROR, 0, 0);
            
            t_Class->Release() ;
        }        
    }

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CClassProvider_IWbemServices :: PutClass ( 
		
	IWbemClassObject FAR* pObject, 
	long lFlags, 
	IWbemContext FAR *pCtx,
	IWbemCallResult FAR* FAR* ppCallResult
) 
{
	return WBEM_E_NOT_AVAILABLE ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CClassProvider_IWbemServices :: PutClassAsync ( 
		
	IWbemClassObject FAR* pObject, 
	long lFlags, 
	IWbemContext FAR *pCtx,
	IWbemObjectSink FAR* pResponseHandler
) 
{
 	 return WBEM_E_NOT_FOUND ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CClassProvider_IWbemServices :: DeleteClass ( 
		
	const BSTR Class, 
	long lFlags, 
	IWbemContext FAR *pCtx,
	IWbemCallResult FAR* FAR* ppCallResult
) 
{
 	 return WBEM_E_NOT_AVAILABLE ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CClassProvider_IWbemServices :: DeleteClassAsync ( 
		
	const BSTR Class, 
	long lFlags, 
	IWbemContext FAR *pCtx,
	IWbemObjectSink FAR* pResponseHandler
) 
{
 	 return WBEM_E_NOT_AVAILABLE ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CClassProvider_IWbemServices :: CreateClassEnum ( 

	const BSTR Superclass, 
	long lFlags, 
	IWbemContext FAR *pCtx,
	IEnumWbemClassObject FAR *FAR *ppEnum
) 
{
	return WBEM_E_NOT_AVAILABLE ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

SCODE CClassProvider_IWbemServices :: CreateClassEnumAsync (

	const BSTR SuperClass, 
	long lFlags, 
	IWbemContext FAR* pCtx,
	IWbemObjectSink FAR* pSink
) 
{
	HRESULT t_Result = WBEM_E_NOT_FOUND ;

    IWbemClassObject *t_Class = NULL ;
    
	if ( ( lFlags & ( WBEM_FLAG_DEEP | WBEM_FLAG_SHALLOW ) ) == WBEM_FLAG_DEEP )
	{
		if ( ( _wcsicmp ( SuperClass, L"Steve" ) == 0 ) || ( _wcsicmp ( SuperClass, L"" ) == 0 ) )
		{
			t_Result = BuildClass ( & t_Class ) ;

			if ( SUCCEEDED ( t_Result ) )
			{
				pSink->Indicate ( 1 , & t_Class ) ;
				pSink->SetStatus ( 0 , WBEM_NO_ERROR, NULL , NULL ) ;

			}        
		}
	}
	else
	{
		if ( ( _wcsicmp ( SuperClass, L"Steve" ) == 0 ) || ( _wcsicmp ( SuperClass, L"" ) == 0 ) )
		{
			t_Result = BuildClass ( & t_Class ) ;

			if ( SUCCEEDED ( t_Result ) )
			{
				pSink->Indicate ( 1 , & t_Class ) ;
				pSink->SetStatus ( 0 , WBEM_NO_ERROR, NULL , NULL ) ;

			}        
		}
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CClassProvider_IWbemServices :: PutInstance (

    IWbemClassObject FAR *pInst,
    long lFlags,
    IWbemContext FAR *pCtx,
	IWbemCallResult FAR *FAR *ppCallResult
) 
{
	return WBEM_E_NOT_AVAILABLE ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CClassProvider_IWbemServices :: PutInstanceAsync ( 
		
	IWbemClassObject FAR* pInst, 
	long lFlags, 
    IWbemContext FAR *pCtx,
	IWbemObjectSink FAR* pSink
) 
{
	HRESULT t_Result = WBEM_E_NOT_AVAILABLE ;

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CClassProvider_IWbemServices :: DeleteInstance ( 

	const BSTR ObjectPath,
    long lFlags,
    IWbemContext FAR *pCtx,
    IWbemCallResult FAR *FAR *ppCallResult
)
{
	return WBEM_E_NOT_AVAILABLE ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/
        
HRESULT CClassProvider_IWbemServices :: DeleteInstanceAsync (
 
	const BSTR ObjectPath,
    long lFlags,
    IWbemContext __RPC_FAR *pCtx,
    IWbemObjectSink __RPC_FAR *pSink	
)
{
	HRESULT t_Result = WBEM_E_NOT_AVAILABLE ;

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CClassProvider_IWbemServices :: CreateInstanceEnum ( 

	const BSTR a_Class, 
	long a_Flags, 
	IWbemContext FAR *a_Context, 
	IEnumWbemClassObject __RPC_FAR *__RPC_FAR *a_Enum
)
{
	HRESULT t_Result = WBEM_E_NOT_AVAILABLE  ;

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CClassProvider_IWbemServices :: CreateInstanceEnumAsync (

 	const BSTR a_Class ,
	long a_Flags , 
	IWbemContext __RPC_FAR *a_Context,
	IWbemObjectSink FAR *a_Sink

) 
{
	return WBEM_E_NOT_AVAILABLE ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CClassProvider_IWbemServices :: ExecQuery ( 

	const BSTR QueryLanguage, 
	const BSTR Query, 
	long lFlags, 
	IWbemContext FAR *pCtx,
	IEnumWbemClassObject FAR *FAR *ppEnum
)
{
	return WBEM_E_NOT_AVAILABLE ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CClassProvider_IWbemServices :: ExecQueryAsync ( 
		
	const BSTR QueryFormat, 
	const BSTR Query, 
	long lFlags, 
	IWbemContext FAR* pCtx,
	IWbemObjectSink FAR* pSink
) 
{
	HRESULT t_Result = WBEM_E_SHUTTING_DOWN ;

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CClassProvider_IWbemServices :: ExecNotificationQuery ( 

	const BSTR QueryLanguage,
    const BSTR Query,
    long lFlags,
    IWbemContext __RPC_FAR *pCtx,
    IEnumWbemClassObject __RPC_FAR *__RPC_FAR *ppEnum
)
{
	return WBEM_E_NOT_AVAILABLE ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/
        
HRESULT CClassProvider_IWbemServices :: ExecNotificationQueryAsync ( 
            
	const BSTR QueryLanguage,
    const BSTR Query,
    long lFlags,
    IWbemContext __RPC_FAR *pCtx,
    IWbemObjectSink __RPC_FAR *pResponseHandler
)
{
	return WBEM_E_NOT_AVAILABLE ;
}       

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT STDMETHODCALLTYPE CClassProvider_IWbemServices :: ExecMethod ( 

	const BSTR ObjectPath,
    const BSTR MethodName,
    long lFlags,
    IWbemContext FAR *pCtx,
    IWbemClassObject FAR *pInParams,
    IWbemClassObject FAR *FAR *ppOutParams,
    IWbemCallResult FAR *FAR *ppCallResult
)
{
	return WBEM_E_NOT_AVAILABLE ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT STDMETHODCALLTYPE CClassProvider_IWbemServices :: ExecMethodAsync ( 

    const BSTR ObjectPath,
    const BSTR MethodName,
    long lFlags,
    IWbemContext FAR *pCtx,
    IWbemClassObject FAR *pInParams,
	IWbemObjectSink FAR *pSink
) 
{
	HRESULT t_Result = WBEM_E_NOT_AVAILABLE ;

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CClassProvider_IWbemServices :: Initialize (

	LPWSTR a_User,
	LONG a_Flags,
	LPWSTR a_Namespace,
	LPWSTR a_Locale,
	IWbemServices *a_CoreService,         // For anybody
	IWbemContext *a_Context,
	IWbemProviderInitSink *a_Sink     // For init signals
)
{
	HRESULT t_Result = S_OK ;

	if ( a_CoreService ) 
	{
		m_CoreService = a_CoreService ;
		m_CoreService->AddRef () ;

		BSTR t_Class = SysAllocString ( L"Steve" ) ;
		if ( t_Class )
		{
			t_Result = m_CoreService->GetObject (

				t_Class ,
				0,
				a_Context , 
				& m_Empty , 
				0
			) ;
		}
		else
		{
			t_Result = WBEM_E_OUT_OF_MEMORY ;
		}
	}
	else
	{
		t_Result = WBEM_E_INVALID_PARAMETER ;
	}

	if ( SUCCEEDED ( t_Result ) )
	{
		if ( a_User ) 
		{
			m_User = SysAllocString ( a_User ) ;
			if ( m_User == NULL )
			{
				t_Result = WBEM_E_OUT_OF_MEMORY ;
			}
		}
	}

	if ( SUCCEEDED ( t_Result ) )
	{
		if ( a_Locale ) 
		{
			m_Locale = SysAllocString ( a_Locale ) ;
			if ( m_Locale == NULL )
			{
				t_Result = WBEM_E_OUT_OF_MEMORY ;
			}
		}
	}

	if ( SUCCEEDED ( t_Result ) )
	{
		if ( a_Namespace ) 
		{
			m_Namespace = SysAllocString ( a_Namespace ) ;
			if ( m_Namespace == NULL )
			{
				t_Result = WBEM_E_OUT_OF_MEMORY ;
			}
		}
	}
	
	a_Sink->SetStatus ( t_Result , 0 ) ;

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CClassProvider_IWbemServices :: Shutdown (

	LONG a_Flags ,
	ULONG a_MaxMilliSeconds ,
	IWbemContext *a_Context
)
{
	HRESULT t_Result = S_OK ;

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CClassProvider_IWbemServices :: BuildClass (

    IWbemClassObject **a_Class 
)
{
	HRESULT t_Result = S_OK ;

    IWbemClassObject *t_Class = NULL ;

    t_Result = m_Empty->Clone ( & t_Class ) ;
	if ( SUCCEEDED ( t_Result ) )
	{
		// Class name.
		// ===========
        
		BSTR t_ClassName = SysAllocString ( L"__CLASS" ) ;
		if ( t_ClassName )
		{
			VARIANT t_Variant ;
			VariantInit ( & t_Variant ) ;

			V_VT(&t_Variant) = VT_BSTR ;
			V_BSTR(&t_Variant) = SysAllocString ( L"Steve_Class" ) ;

			t_Result = t_Class->Put ( t_ClassName , 0, & t_Variant , 0 ) ;
			if ( SUCCEEDED ( t_Result ) )
			{

			// Key property.
			// =============

				BSTR t_KeyName = SysAllocString ( L"KeyProperty" ) ;
				if ( t_KeyName )
				{
					t_Result = t_Class->Put ( t_KeyName , 0 , NULL , CIM_STRING ) ;
					if ( SUCCEEDED ( t_Result ) )
					{
						IWbemQualifierSet *t_QualifierSet = NULL ;

						t_Result = t_Class->GetPropertyQualifierSet ( t_KeyName , &t_QualifierSet ) ;
						if ( SUCCEEDED ( t_Result ) )
						{
							VARIANT t_KeyVariant ;
							VariantInit ( & t_KeyVariant ) ;

							V_VT( & t_KeyVariant ) = VT_BOOL ;
							V_BOOL( & t_KeyVariant ) = VARIANT_TRUE ;

							BSTR t_Key = SysAllocString ( L"Key" ) ;
							if ( t_Key )
							{
								t_Result = t_QualifierSet->Put ( t_Key , & t_KeyVariant , 0 ) ;
								if ( SUCCEEDED ( t_Result ) )
								{
									*a_Class = t_Class ;
								}

								SysFreeString ( t_Key ) ;
							}

							VariantClear ( & t_KeyVariant ) ;

							t_QualifierSet->Release() ;
						}
					}

					SysFreeString ( t_KeyName ) ;
				}
				else
				{
					t_Result = WBEM_E_OUT_OF_MEMORY ;
				}
			}

			VariantClear ( & t_Variant ) ;

			SysFreeString ( t_ClassName ) ;
		}
		else
		{
			t_Result = WBEM_E_OUT_OF_MEMORY ;
		}
	}

    return t_Result ;        
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\provsubsys\example\events.cpp ===
/*++

Copyright (C) 1996-2001 Microsoft Corporation

Module Name:

	XXXX

Abstract:


History:

--*/

#include <precomp.h>

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <ntobapi.h>

#define _WINNT_	// have what is needed from above

#include "precomp.h"

#include <objbase.h>
#include <wbemint.h>
#include "Globals.h"
#include "HelperFuncs.h"
#include "Events.h"


/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

CProvider_IWbemEventProvider :: CProvider_IWbemEventProvider (

	 WmiAllocator &a_Allocator 

) : m_ReferenceCount ( 0 ) , 
	m_InternalReferenceCount ( 0 ) ,
	m_Allocator ( a_Allocator ) ,
	m_User ( NULL ) ,
	m_Locale ( NULL ) ,
	m_Namespace ( NULL ) ,
	m_CoreService ( NULL ) ,
	m_EventObject ( NULL ) ,
	m_EventSink ( NULL ) ,
	m_ThreadHandle ( NULL )
{
	InitializeCriticalSection ( & m_CriticalSection ) ;

	InterlockedIncrement ( & Provider_Globals :: s_ObjectsInProgress ) ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

CProvider_IWbemEventProvider :: ~CProvider_IWbemEventProvider ()
{
	DeleteCriticalSection ( & m_CriticalSection ) ;

	if ( m_EventObject )
	{
		m_EventObject->Release () ;
	}

	if ( m_EventSink )
	{
		m_EventSink->Release () ;
	}

	if ( m_User ) 
	{
		SysFreeString ( m_User ) ;
	}

	if ( m_Locale ) 
	{
		SysFreeString ( m_Locale ) ;
	}

	if ( m_Namespace ) 
	{
		SysFreeString ( m_Namespace ) ;
	}

	if ( m_CoreService ) 
	{
		m_CoreService->Release () ;
	}

	InterlockedDecrement ( & Provider_Globals :: s_ObjectsInProgress ) ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

STDMETHODIMP_(ULONG) CProvider_IWbemEventProvider :: AddRef ( void )
{
	LONG t_Reference ;

	if ( ( t_Reference = InterlockedIncrement ( & m_ReferenceCount ) ) == 1 )
	{
		InternalAddRef () ;
	}

	return t_Reference ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

STDMETHODIMP_(ULONG) CProvider_IWbemEventProvider :: Release ( void )
{
	LONG t_Reference ;
	if ( ( t_Reference = InterlockedDecrement ( & m_ReferenceCount ) ) == 0 )
	{
		if ( m_ThreadTerminate )
		{
			SetEvent ( m_ThreadTerminate ) ;
		}

		if ( m_ThreadHandle )
		{
			WaitForSingleObject ( m_ThreadHandle , INFINITE ) ;
			CloseHandle ( m_ThreadHandle ) ;
		}

		InternalRelease () ;
	}

	return t_Reference ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

STDMETHODIMP_(ULONG) CProvider_IWbemEventProvider :: InternalAddRef ( void )
{
	return InterlockedIncrement ( & m_InternalReferenceCount ) ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

STDMETHODIMP_(ULONG) CProvider_IWbemEventProvider :: InternalRelease ( void )
{
	LONG t_Reference ;
	if ( ( t_Reference = InterlockedDecrement ( & m_InternalReferenceCount ) ) == 0 )
	{
		delete this ;
	}

	return t_Reference ;
}


/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

STDMETHODIMP CProvider_IWbemEventProvider :: QueryInterface (

	REFIID iid , 
	LPVOID FAR *iplpv 
) 
{
	*iplpv = NULL ;

	if ( iid == IID_IUnknown )
	{
		*iplpv = ( LPVOID ) this ;
	}
	else if ( iid == IID_IWbemEventProvider )
	{
		*iplpv = ( LPVOID ) ( IWbemEventProvider * ) this ;		
	}	
	else if ( iid == IID_IWbemProviderInit )
	{
		*iplpv = ( LPVOID ) ( IWbemProviderInit * ) this ;		
	}	
	else if ( iid == IID_IWbemShutdown )
	{
		*iplpv = ( LPVOID ) ( IWbemShutdown * ) this ;		
	}	

	if ( *iplpv )
	{
		( ( LPUNKNOWN ) *iplpv )->AddRef () ;

		return ResultFromScode ( S_OK ) ;
	}
	else
	{
		return ResultFromScode ( E_NOINTERFACE ) ;
	}
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CProvider_IWbemEventProvider :: Initialize (

	LPWSTR a_User,
	LONG a_Flags,
	LPWSTR a_Namespace,
	LPWSTR a_Locale,
	IWbemServices *a_CoreService,         // For anybody
	IWbemContext *a_Context,
	IWbemProviderInitSink *a_Sink     // For init signals
)
{
	HRESULT t_Result = S_OK ;

	if ( a_CoreService ) 
	{
		m_CoreService = a_CoreService ;
		m_CoreService->AddRef () ;
	}
	else
	{
		t_Result = WBEM_E_INVALID_PARAMETER ;
	}

	if ( SUCCEEDED ( t_Result ) )
	{
		if ( a_User ) 
		{
			m_User = SysAllocString ( a_User ) ;
			if ( m_User == NULL )
			{
				t_Result = WBEM_E_OUT_OF_MEMORY ;
			}
		}
	}

	if ( SUCCEEDED ( t_Result ) )
	{
		if ( a_Locale ) 
		{
			m_Locale = SysAllocString ( a_Locale ) ;
			if ( m_Locale == NULL )
			{
				t_Result = WBEM_E_OUT_OF_MEMORY ;
			}
		}
	}

	if ( SUCCEEDED ( t_Result ) )
	{
		if ( a_Namespace ) 
		{
			m_Namespace = SysAllocString ( a_Namespace ) ;
			if ( m_Namespace == NULL )
			{
				t_Result = WBEM_E_OUT_OF_MEMORY ;
			}
		}
	}
	
	if ( SUCCEEDED ( t_Result ) ) 
	{
		BSTR t_Class = SysAllocString ( L"SampleEvent" ) ;
		if ( t_Class ) 
		{
			t_Result = m_CoreService->GetObject (

				t_Class ,
				0 ,
				a_Context ,
				& m_EventObject ,
				NULL 
			) ;

			if ( SUCCEEDED ( t_Result ) )
			{
			}

			SysFreeString ( t_Class ) ;
		}
		else
		{
			t_Result = WBEM_E_OUT_OF_MEMORY ;
		}
	}

	m_ThreadTerminate = CreateEvent ( NULL , FALSE , FALSE , NULL ) ;
	if ( m_ThreadTerminate == NULL )
	{
		t_Result = WBEM_E_OUT_OF_MEMORY ;
	}

	a_Sink->SetStatus ( t_Result , 0 ) ;

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CProvider_IWbemEventProvider :: Shutdown (

	LONG a_Flags ,
	ULONG a_MaxMilliSeconds ,
	IWbemContext *a_Context
)
{
	HRESULT t_Result = S_OK ;

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

DWORD CProvider_IWbemEventProvider :: ThreadExecutionFunction ( void *a_Context )
{
	HRESULT t_Result = S_OK ;

	CProvider_IWbemEventProvider *t_This = ( CProvider_IWbemEventProvider * ) a_Context ;
	if ( t_This )
	{
		t_Result = CoInitializeEx (

			0, 
			COINIT_MULTITHREADED
		) ;

		if ( SUCCEEDED ( t_Result ) )
		{
			IWbemClassObject *t_Instance = NULL ;
			t_Result = t_This->m_EventObject->SpawnInstance ( 0 , & t_Instance ) ;
			if ( SUCCEEDED ( t_Result ) )
			{
				VARIANT t_Variant ;
				VariantInit ( & t_Variant ) ;

				t_Variant.vt = VT_BSTR ;
				t_Variant.bstrVal = SysAllocString ( L"Steve" ) ;

				t_Result = t_Instance->Put ( 

					L"Name" ,
					0 , 
					& t_Variant ,
					CIM_EMPTY 
				) ;

				VariantClear ( & t_Variant ) ;

				BOOL t_Continue = TRUE ;
				while ( t_Continue )
				{
					DWORD t_Status = WaitForSingleObject ( t_This->m_ThreadTerminate , 1000 ) ;
					switch ( t_Status )
					{
						case WAIT_TIMEOUT:
						{
							IClientSecurity *t_Blanket = NULL ;

							HRESULT t_Result = t_This->m_EventSink->QueryInterface ( IID_IClientSecurity , ( void ** ) & t_Blanket ) ;
							if ( SUCCEEDED ( t_Result  ) )
							{
								t_Result = t_Blanket->SetBlanket ( 

									t_This->m_EventSink ,
									RPC_C_AUTHN_WINNT ,
									RPC_C_AUTHZ_NONE ,
									NULL ,
									RPC_C_AUTHN_LEVEL_DEFAULT ,
									RPC_C_IMP_LEVEL_IDENTIFY ,
									NULL ,
									EOAC_DYNAMIC_CLOAKING
								) ;

								t_This->m_EventSink->Indicate ( 1 , & t_Instance ) ;

								t_Blanket->Release () ;
							}

							t_This->m_EventSink->Indicate ( 1 , & t_Instance ) ;
						}
						break ;

						case WAIT_OBJECT_0:
						{
							t_Continue = FALSE ;
						}
						break ;

						default:
						{
							t_Continue = FALSE ;
						}
						break ;
					}
				}

				t_Instance->Release () ;
			}
		}

		t_This->InternalRelease () ;
	}
	else
	{
		t_Result = WBEM_E_INVALID_PARAMETER ;
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CProvider_IWbemEventProvider :: ProvideEvents ( 

	IWbemObjectSink *a_Sink ,
	LONG a_Flags
)
{
	HRESULT t_Result = S_OK ;

	m_EventSink = a_Sink ;
	m_EventSink->AddRef () ;

	InternalAddRef () ;

	DWORD t_ThreadId = 0 ;
	m_ThreadHandle = CreateThread (

		NULL ,
		0 , 
		ThreadExecutionFunction ,
		this ,
		0 , 
		& t_ThreadId 
	) ;

	if ( m_ThreadHandle == NULL )
	{
		InternalRelease () ;
	}

	return t_Result ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\provsubsys\example\globals.cpp ===
/*++

Copyright (C) 1996-2001 Microsoft Corporation

Module Name:

	Globals.cpp

Abstract:


History:

--*/

#include <PreComp.h>
#include <wbemprov.h>

#include <initguid.h>
#ifndef INITGUID
#define INITGUID
#endif

#include <Exception.h>
#include <Thread.h>

#include "Globals.h"

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

WmiAllocator *Provider_Globals :: s_Allocator = NULL ;

LONG Provider_Globals :: s_LocksInProgress ;
LONG Provider_Globals :: s_ObjectsInProgress ;

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT Provider_Globals :: Global_Startup ()
{
	HRESULT t_Result = S_OK ;

	if ( ! s_Allocator )
	{
/*
 *	Use the global process heap for this particular boot operation
 */

		WmiAllocator t_Allocator ;
		WmiStatusCode t_StatusCode = t_Allocator.New (

			( void ** ) & s_Allocator ,
			sizeof ( WmiAllocator ) 
		) ;

		if ( t_StatusCode == e_StatusCode_Success )
		{
			:: new ( ( void * ) s_Allocator ) WmiAllocator ;

			t_StatusCode = s_Allocator->Initialize () ;
			if ( t_StatusCode != e_StatusCode_Success )
			{
				t_Result = WBEM_E_OUT_OF_MEMORY ;
			}
		}
		else
		{
			t_Result = WBEM_E_OUT_OF_MEMORY ;
		}
	}

	if ( SUCCEEDED ( t_Result ) )
	{
		WmiStatusCode t_StatusCode = WmiThread <ULONG> :: Static_Initialize ( *s_Allocator ) ;
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT Provider_Globals :: Global_Shutdown ()
{
	HRESULT t_Result = S_OK ;

	WmiStatusCode t_StatusCode = WmiThread <ULONG> :: Static_UnInitialize ( *s_Allocator ) ;

	if ( s_Allocator )
	{
/*
 *	Use the global process heap for this particular boot operation
 */

		WmiAllocator t_Allocator ;
		WmiStatusCode t_StatusCode = t_Allocator.Delete (

			( void * ) s_Allocator
		) ;

		if ( t_StatusCode != e_StatusCode_Success )
		{
			t_Result = WBEM_E_OUT_OF_MEMORY ;
		}
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT Provider_Globals :: CreateInstance ( 

	const CLSID &a_ReferenceClsid ,
	LPUNKNOWN a_OuterUnknown ,
	const DWORD &a_ClassContext ,
	const UUID &a_ReferenceInterfaceId ,
	void **a_ObjectInterface
)
{
	HRESULT t_Result = S_OK ;

#if 1
	 t_Result = CoCreateInstance (
  
		a_ReferenceClsid ,
		a_OuterUnknown ,
		a_ClassContext ,
		a_ReferenceInterfaceId ,
		( void ** )  a_ObjectInterface
	);

#else

	COAUTHIDENTITY t_AuthenticationIdentity ;
	ZeroMemory ( & t_AuthenticationIdentity , sizeof ( t_AuthenticationIdentity ) ) ;

	t_AuthenticationIdentity.User = NULL ; 
	t_AuthenticationIdentity.UserLength = 0 ;
	t_AuthenticationIdentity.Domain = NULL ; 
	t_AuthenticationIdentity.DomainLength = 0 ; 
	t_AuthenticationIdentity.Password = NULL ; 
	t_AuthenticationIdentity.PasswordLength = 0 ; 
	t_AuthenticationIdentity.Flags = SEC_WINNT_AUTH_IDENTITY_UNICODE ; 

	COAUTHINFO t_AuthenticationInfo ;
	ZeroMemory ( & t_AuthenticationInfo , sizeof ( t_AuthenticationInfo ) ) ;

    t_AuthenticationInfo.dwAuthnSvc = RPC_C_AUTHN_DEFAULT ;
    t_AuthenticationInfo.dwAuthzSvc = RPC_C_AUTHZ_DEFAULT ;
    t_AuthenticationInfo.pwszServerPrincName = NULL ;
    t_AuthenticationInfo.dwAuthnLevel = RPC_C_AUTHN_LEVEL_CONNECT ;
    t_AuthenticationInfo.dwImpersonationLevel = RPC_C_IMP_LEVEL_IMPERSONATE  ;
    t_AuthenticationInfo.dwCapabilities = EOAC_NONE ;
    t_AuthenticationInfo.pAuthIdentityData = NULL ;

	COSERVERINFO t_ServerInfo ;
	ZeroMemory ( & t_ServerInfo , sizeof ( t_ServerInfo ) ) ;

	t_ServerInfo.pwszName = NULL ;
    t_ServerInfo.dwReserved2 = 0 ;
    t_ServerInfo.pAuthInfo = & t_AuthenticationInfo ;

	IClassFactory *t_ClassFactory = NULL ;

	t_Result = CoGetClassObject (

		a_ReferenceClsid ,
		a_ClassContext ,
		& t_ServerInfo ,
		IID_IClassFactory ,
		( void ** )  & t_ClassFactory
	) ;
 
	if ( SUCCEEDED ( t_Result ) )
	{
		t_Result = t_ClassFactory->CreateInstance (

			a_OuterUnknown ,
			a_ReferenceInterfaceId ,
			a_ObjectInterface 
		);	

		t_ClassFactory->Release () ;
	}

#endif

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

void * __cdecl operator new ( size_t a_Size )
{
    void *t_Ptr ;
	WmiStatusCode t_StatusCode = Provider_Globals :: s_Allocator->New (

		( void ** ) & t_Ptr ,
		a_Size
	) ;

	if ( t_StatusCode != e_StatusCode_Success )
    {
        throw Wmi_Heap_Exception (

			Wmi_Heap_Exception::HEAP_ERROR::E_ALLOCATION_ERROR
		) ;
    }

    return t_Ptr ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

void __cdecl operator delete ( void *a_Ptr )
{
    if ( a_Ptr )
    {
		WmiStatusCode t_StatusCode = Provider_Globals :: s_Allocator->Delete (

			( void * ) a_Ptr
		) ;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\provsubsys\desktop\client.cpp ===
/*++

Copyright (C) 1996-2001 Microsoft Corporation

Module Name:

	ProvFact.cpp

Abstract:


History:

--*/

#include "PreComp.h"
#include <stdio.h>

// this redefines the DEFINE_GUID() macro to do allocation.
//
#include <initguid.h>
#ifndef INITGUID
#define INITGUID
#endif

#include <wbemint.h>

#include <Allocator.h>
#include <HelperFuncs.h>
#include "Globals.h"

#if 1
#define SAMPLE_NAMESPACE L"Root\\Cimv2"
#else
#define SAMPLE_NAMESPACE L"Root\\Default"
#endif

const wchar_t g_StrUsage[] = L"Desktop(desktop.exe):\n \
e.g...  desktop /S 1 ;\n \
		desktop /C 2 ; \
		desktop /D 2 ;\n\n";

BOOL CALLBACK EnumWindowProc (

  HWND a_Window ,
  LPARAM a_lParam
)
{
	wchar_t t_Buffer [ 256 ] ;

	int t_Status = GetWindowTextW (

		a_Window ,
		t_Buffer ,
		sizeof ( t_Buffer ) / sizeof ( wchar_t )
	) ;

	if ( t_Status )
	{
		printf ( "\t\t%S\n" , t_Buffer	 ) ;
	}

	return TRUE ;	
}

BOOL CALLBACK EnumDesktopProc (

  LPTSTR a_DesktopName,
  LPARAM a_lParam
)
{
	printf ( "%S\n" , a_DesktopName ) ;

	return TRUE ;	
}

BOOL CALLBACK InternalEnumDesktopProc (

  LPTSTR a_DesktopName,
  LPARAM a_lParam
)
{
	printf ( "\t%S\n" , a_DesktopName ) ;

	HDESK t_Desktop = OpenDesktop (

		a_DesktopName ,
		0 ,
		FALSE ,
		READ_CONTROL | DESKTOP_ENUMERATE | DESKTOP_READOBJECTS
	) ;

	if ( t_Desktop )
	{
		SECURITY_DESCRIPTOR *t_SecurityDescriptor = NULL ;

		DWORD t_LengthRequested = 0 ;
		DWORD t_LengthReturned = 0 ;
		DWORD t_SecurityInformation = DACL_SECURITY_INFORMATION ;
		BOOL t_Status = GetUserObjectSecurity (

			t_Desktop ,
			& t_SecurityInformation ,
			& t_SecurityDescriptor ,
			t_LengthRequested ,
			& t_LengthReturned
		) ;

		if ( ( t_Status == FALSE ) && ( GetLastError () == ERROR_INSUFFICIENT_BUFFER ) )
		{
			t_SecurityDescriptor = ( SECURITY_DESCRIPTOR * ) new BYTE [ t_LengthReturned ] ;
			if ( t_SecurityDescriptor )
			{
				t_LengthRequested = t_LengthReturned ;

				t_Status = GetUserObjectSecurity (

					t_Desktop ,
					& t_SecurityInformation ,
					t_SecurityDescriptor ,
					t_LengthRequested ,
					& t_LengthReturned
				) ;

				if ( t_LengthRequested != t_LengthReturned )
				{
				}
			}
			else
			{
			}
		}

		CloseDesktop ( t_Desktop ) ;

		if ( t_SecurityDescriptor )
		{
			delete [] ( BYTE * ) t_SecurityDescriptor ;
		}
	}

	return TRUE ;	
}

BOOL CALLBACK WindowInternalEnumDesktopProc (

  LPTSTR a_DesktopName,
  LPARAM a_lParam
)
{
	printf ( "\t%S\n" , a_DesktopName ) ;

	HDESK t_Desktop = OpenDesktop (

		a_DesktopName ,
		0 ,
		FALSE ,
		DESKTOP_ENUMERATE | DESKTOP_READOBJECTS
	) ;

	if ( t_Desktop )
	{
		BOOL t_Status = EnumDesktopWindows (

			t_Desktop ,
			EnumWindowProc ,
			0
		) ;

		CloseDesktop ( t_Desktop ) ;
	}

	return TRUE ;	
}

BOOL CALLBACK EnumWinStationProc (

  LPTSTR a_WinStationName,
  LPARAM a_lParam
)
{
	printf ( "%S\n" , a_WinStationName ) ;

	HWINSTA t_WindowStation = OpenWindowStation (

		a_WinStationName ,
		FALSE ,
		WINSTA_ENUMERATE | WINSTA_ENUMDESKTOPS
	) ;

	if ( t_WindowStation )
	{
		BOOL t_Status = EnumDesktops (

			t_WindowStation ,            
			InternalEnumDesktopProc ,
			0
		) ;

		CloseWindowStation ( t_WindowStation ) ;
	}

	return TRUE ;	
}

BOOL CALLBACK InternalEnumWinStationProc (

  LPTSTR a_WinStationName,
  LPARAM a_lParam
)
{
	printf ( "%S\n" , a_WinStationName ) ;

	HWINSTA t_WindowStation = OpenWindowStation (

		a_WinStationName ,
		FALSE ,
		WINSTA_ENUMERATE | WINSTA_ENUMDESKTOPS
	) ;

	if ( t_WindowStation )
	{
		BOOL t_Status = EnumDesktops (

			t_WindowStation ,            
			WindowInternalEnumDesktopProc ,
			0
		) ;

		CloseWindowStation ( t_WindowStation ) ;
	}

	return TRUE ;	
}

void ListWinStationDesktops ()
{
	BOOL t_Status = EnumWindowStations (

		EnumWinStationProc ,
		0
	) ;
}

void ListWinStationDesktopsWindows ()
{
	BOOL t_Status = EnumWindowStations (

		InternalEnumWinStationProc ,
		0
	) ;
}

void ListDesktops ()
{
	HWINSTA t_WindowStation = GetProcessWindowStation() ;
	if ( t_WindowStation )
	{
		BOOL t_Status = EnumDesktops (

			t_WindowStation ,            
			EnumDesktopProc ,
			0
		) ;
	}

	CloseWindowStation ( t_WindowStation ) ;

}

void CreateDesktop ( DWORD a_Unit )
{
	HWINSTA t_WindowStation = GetProcessWindowStation() ;
	if ( t_WindowStation )
	{
		wchar_t t_DesktopDevice [ 17 ] ;
		if ( a_Unit )
		{
			swprintf ( t_DesktopDevice , L"%ld" , a_Unit ) ;
		}
		else
		{
			wcscpy ( t_DesktopDevice , L"Default" ) ;
		}

		HDESK t_Desktop = CreateDesktop (

			t_DesktopDevice,
			NULL ,
			NULL ,
			0 ,
			MAXIMUM_ALLOWED , 
			NULL
		);

		if ( t_Desktop )
		{
			STARTUPINFO t_StartupInfo ;
			memset ( & t_StartupInfo , 0 , sizeof ( STARTUPINFO ) ) ;
			t_StartupInfo.cb = sizeof ( STARTUPINFO ) ;
			t_StartupInfo.lpDesktop = t_DesktopDevice ;
			t_StartupInfo.wShowWindow = SW_SHOW; 

			PROCESS_INFORMATION t_ProcessInformation ;

			memset ( & t_ProcessInformation , 0 , sizeof ( PROCESS_INFORMATION ) ) ;

			BSTR t_Buffer = SysAllocString ( L"c:\\winnt\\system32\\cmd.exe" ) ;
			if ( t_Buffer )
			{
				BOOL t_ProcessStatus = CreateProcess (

					NULL ,
					t_Buffer ,
					NULL ,
					NULL ,
					FALSE ,
					0 ,
					NULL ,
					NULL ,
					& t_StartupInfo ,
					& t_ProcessInformation 
				);

				if ( t_ProcessStatus )
				{
					CloseHandle ( t_ProcessInformation.hThread ) ;

					CloseHandle ( t_ProcessInformation.hProcess ) ;

					Sleep ( 10 ) ;
				}
				else
				{
					DWORD t_LastError = GetLastError () ;
				}

				SysFreeString ( t_Buffer ) ;
			}

			CloseDesktop ( t_Desktop ) ;
		}
		else
		{
			DWORD t_LastError = GetLastError () ;
		}
	}
}

void DeleteDesktop ( DWORD a_Unit )
{
}

void SwitchDesktop ( DWORD a_Unit )
{
	HWINSTA t_WindowStation = GetProcessWindowStation() ;
	if ( t_WindowStation )
	{
		wchar_t t_DesktopDevice [ 17 ] ;
		if ( a_Unit )
		{
			swprintf ( t_DesktopDevice , L"%ld" , a_Unit ) ;
		}
		else
		{
			wcscpy ( t_DesktopDevice , L"Default" ) ;
		}

		HDESK t_Desktop = OpenDesktop(

			t_DesktopDevice,
			0 ,
			FALSE ,
			DESKTOP_SWITCHDESKTOP
		) ;

		if ( t_Desktop )
		{
			BOOL t_SwitchStatus = SwitchDesktop (

				t_Desktop
			);

			if ( ! t_SwitchStatus )
			{
				DWORD t_LastError = GetLastError () ;
			}

			CloseDesktop ( t_Desktop ) ;
		}
	}

	CloseWindowStation ( t_WindowStation ) ;
}

void DisplayInputDesktop () 
{
	HDESK t_Desktop = OpenInputDesktop(

		0 ,
		FALSE ,
		DESKTOP_SWITCHDESKTOP
	) ;
	
	if ( t_Desktop )
	{
		wchar_t t_DesktopName [ 256 ] ;
		DWORD t_Returned = 0 ;

		BOOL t_InfoStatus = GetUserObjectInformation (
			t_Desktop ,
			UOI_NAME,
			( PVOID ) t_DesktopName ,
			sizeof ( t_DesktopName ) ,
			&t_Returned 
		);

		if ( t_InfoStatus )
		{
			printf ( "%S\n" , t_DesktopName ) ;
		}
	}
}

int DoWork ( 

	int argc, 
	wchar_t **argv , 
	IN HINSTANCE hInstance
)
{
	DWORD t_Function = 0 ;
	DWORD t_Unit = 0 ;
	BOOL t_Usage = FALSE;

	for ( int i = 1 ; i < argc ; i ++ ) 
	{
		if ( _wcsicmp ( argv [ i ] , L"/D") == 0)
		{
			wchar_t *t_LeftOver = NULL ;
			t_Function = 3 ;
			t_Unit = wcstol(argv[++i], &t_LeftOver, 10);
			break ;
		}
		else if ( _wcsicmp ( argv [ i ] , L"/C") == 0)
		{
			wchar_t *t_LeftOver = NULL ;
			t_Function = 2 ;
			t_Unit = wcstol(argv[++i], &t_LeftOver, 10);
			break ;
		}
		else if ( _wcsicmp ( argv [ i ] , L"/S") == 0)
		{
			wchar_t *t_LeftOver = NULL ;
			t_Function = 1 ;
			t_Unit = wcstol(argv[++i], &t_LeftOver, 10);
			break ;
		}
		else if ( _wcsicmp ( argv [ i ] , L"/T") == 0)
		{
			wchar_t *t_LeftOver = NULL ;
			t_Function = 4 ;
			break ;
		}
		else if ( _wcsicmp ( argv [ i ] , L"/ED") == 0)
		{
			wchar_t *t_LeftOver = NULL ;
			t_Function = 0 ;
			break ;
		}
		else if ( _wcsicmp ( argv [ i ] , L"/EW") == 0)
		{
			wchar_t *t_LeftOver = NULL ;
			t_Function = 5 ;
			break ;
		}
		else if ( _wcsicmp ( argv [ i ] , L"/EA") == 0)
		{
			wchar_t *t_LeftOver = NULL ;
			t_Function = 6 ;
			break ;
		}
		else if ((_wcsicmp(argv[i], L"/H") == 0) || (_wcsicmp(argv[i], L"/?") == 0))
		{
			t_Usage = TRUE;
			break;
		}
	}

	if ( t_Usage )
	{
		MessageBox ( 0 , g_StrUsage , L"Desktop", MB_OK|MB_ICONINFORMATION|MB_SYSTEMMODAL) ;
	}
	else
	{
		switch ( t_Function )
		{
			case 0:
			{
				ListDesktops () ;
			}
			break ;

			case 1:
			{
				SwitchDesktop ( t_Unit ) ;
			}
			break ;

			case 2:
			{
				CreateDesktop ( t_Unit ) ;
			}
			break ;

			case 3:
			{
				DeleteDesktop ( t_Unit ) ;
			}
			break ;

			case 4:
			{
				DisplayInputDesktop () ;
			}
			break ;

			case 5:
			{
				ListWinStationDesktops () ;
			}
			break ;

			case 6:
			{
				ListWinStationDesktopsWindows () ;
			}
			break ;

			default:
			{
			}
			break ;
		}
	}

	return 0 ;
}


/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

EXTERN_C int __cdecl wmain (

	int argc ,
	wchar_t **argv 
)
{
	DoWork (
	
		argc ,
		argv ,
		NULL
	);
	
	return 0 ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\provsubsys\example\dll\makefile.inc ===
!include $(_NTDRIVE)$(_NTROOT)\ADMIN\WMI\WBEM\COMMON\makefile.cmn
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\provsubsys\example\maindll.cpp ===
/*++

Copyright (C) 1996-2001 Microsoft Corporation

Module Name:

	MainDll.cpp

Abstract:


History:

--*/

#include <precomp.h>
#include <tchar.h>
#include <objbase.h>
#include <comdef.h>

#include <wbemcli.h>
#include <wbemint.h>
#include "Globals.h"
#include "ClassFac.h"
#include "Service.h"
#include "ClassService.h"
#include "Events.h"
#include "Guids.h"

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

//OK we need this one
HINSTANCE g_hInst=NULL;

CRITICAL_SECTION s_CriticalSection ;

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

BOOL APIENTRY DllMain (

	HINSTANCE hInstance, 
	ULONG ulReason , 
	LPVOID pvReserved
)
{
	g_hInst=hInstance;

	BOOL t_Status = TRUE ;

    if ( DLL_PROCESS_DETACH == ulReason )
	{
		HRESULT t_Result = Provider_Globals :: Global_Shutdown () ;
		if ( SUCCEEDED ( t_Result ) )
		{
			t_Status = TRUE ;
		}
		else
		{
			t_Status = FALSE ;
		}

		DeleteCriticalSection ( & s_CriticalSection ) ;

		t_Status = TRUE ;
    }
    else if ( DLL_PROCESS_ATTACH == ulReason )
	{
		InitializeCriticalSection ( & s_CriticalSection ) ;

		HRESULT t_Result = Provider_Globals :: Global_Startup () ;
		if ( SUCCEEDED ( t_Result ) )
		{
			t_Status = TRUE ;
		}
		else
		{
			t_Status = FALSE ;
		}

		DisableThreadLibraryCalls ( hInstance ) ;

    }
    else if ( DLL_THREAD_DETACH == ulReason )
	{
		t_Status = TRUE ;
    }
    else if ( DLL_THREAD_ATTACH == ulReason )
	{
		t_Status = TRUE ;
    }

    return t_Status ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

STDAPI DllGetClassObject (

	REFCLSID rclsid , 
	REFIID riid, 
	void **ppv 
)
{
	HRESULT status = S_OK ; 

	if ( rclsid == CLSID_WmiProvider ) 
	{
		CProviderClassFactory <CProvider_IWbemServices,IWbemServices> *lpunk = new CProviderClassFactory <CProvider_IWbemServices,IWbemServices> () ;
		if ( lpunk == NULL )
		{
			status = E_OUTOFMEMORY ;
		}
		else
		{
			status = lpunk->QueryInterface ( riid , ppv ) ;
			if ( FAILED ( status ) )
			{
				delete lpunk ;				
			}
			else
			{
			}			
		}
	}
	else if ( rclsid == CLSID_WmiClassProvider ) 
	{
		CProviderClassFactory <CClassProvider_IWbemServices,IWbemServices> *lpunk = new CProviderClassFactory <CClassProvider_IWbemServices,IWbemServices> () ;
		if ( lpunk == NULL )
		{
			status = E_OUTOFMEMORY ;
		}
		else
		{
			status = lpunk->QueryInterface ( riid , ppv ) ;
			if ( FAILED ( status ) )
			{
				delete lpunk ;				
			}
			else
			{
			}			
		}
	}
	else if ( rclsid == CLSID_WmiEventProvider ) 
	{
		CProviderClassFactory <CProvider_IWbemEventProvider,IWbemEventProvider> *lpunk = new CProviderClassFactory <CProvider_IWbemEventProvider,IWbemEventProvider> () ;
		if ( lpunk == NULL )
		{
			status = E_OUTOFMEMORY ;
		}
		else
		{
			status = lpunk->QueryInterface ( riid , ppv ) ;
			if ( FAILED ( status ) )
			{
				delete lpunk ;				
			}
			else
			{
			}			
		}
	}
	else
	{
		status = CLASS_E_CLASSNOTAVAILABLE ;
	}

	return status ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

STDAPI DllCanUnloadNow ()
{

/* 
 * Place code in critical section
 */
	EnterCriticalSection ( & s_CriticalSection ) ;

	BOOL unload = ( 
					Provider_Globals :: s_LocksInProgress || 
					Provider_Globals :: s_ObjectsInProgress
				) ;
	unload = ! unload ;

	if ( unload )
	{
	}

	LeaveCriticalSection ( & s_CriticalSection ) ;

	return unload ? ResultFromScode ( S_OK ) : ResultFromScode ( S_FALSE ) ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

//Strings used during self registeration

#define REG_FORMAT_STR			L"%s\\%s"
#define NOT_INSERT_STR			L"NotInsertable"
#define INPROC32_STR			L"InprocServer32"
#define LOCALSERVER32_STR		L"LocalServer32"
#define THREADING_MODULE_STR	L"ThreadingModel"

#ifdef WMIASSTA
#define APARTMENT_STR			L"Apartment"
#else
#define APARTMENT_STR			L"Both"
#endif

#define APPID_VALUE_STR			L"APPID"
#define APPID_STR				L"APPID\\"
#define CLSID_STR				L"CLSID\\"

#define WMI_TASKPROVIDER				__TEXT("Microsoft WMI Task Provider")
#define WMI_PROVIDER				__TEXT("Microsoft WMI Provider")
#define WMI_EVENTPROVIDER				__TEXT("Microsoft WMI Event Provider")
#define WMI_CLASSPROVIDER				__TEXT("Microsoft WMI Class Provider")

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

BOOL SetKeyAndValue ( wchar_t *pszKey , wchar_t *pszSubkey , wchar_t *pszValueName , wchar_t *pszValue )
{
    HKEY hKey;
    wchar_t szKey[256];

	wcscpy ( szKey , pszKey ) ;

    if ( NULL != pszSubkey )
    {
		wcscat ( szKey , L"\\" ) ;
        wcscat ( szKey , pszSubkey ) ;
    }

    if ( ERROR_SUCCESS != RegCreateKeyEx ( 

			HKEY_CLASSES_ROOT , 
			szKey , 
			0, 
			NULL, 
			REG_OPTION_NON_VOLATILE ,
			KEY_ALL_ACCESS, 
			NULL, 
			&hKey, 
			NULL
		)
	)
	{
        return FALSE ;
	}

    if ( NULL != pszValue )
    {
        if ( ERROR_SUCCESS != RegSetValueEx (

				hKey, 
				pszValueName, 
				0, 
				REG_SZ, 
				(BYTE *) pszValue , 
				(lstrlen(pszValue)+1)*sizeof(wchar_t)
			)
		)
		{
			return FALSE;
		}
    }

    RegCloseKey ( hKey ) ;

    return TRUE;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

STDAPI RegisterServer ( GUID a_ProviderClassId , wchar_t *a_ProviderName )
{
	wchar_t szModule[512];
	GetModuleFileName(g_hInst,(wchar_t*)szModule, sizeof(szModule)/sizeof(wchar_t));

	wchar_t szProviderClassID[128];
	wchar_t szProviderCLSIDClassID[128];

	int iRet = StringFromGUID2(a_ProviderClassId,szProviderClassID, 128);

#ifdef WMIASLOCAL
	TCHAR szProviderCLSIDAppID[128];
	_tcscpy(szProviderCLSIDAppID,APPID_STR);
	_tcscat(szProviderCLSIDAppID,szProviderClassID);

	if (FALSE ==SetKeyAndValue(szProviderCLSIDAppID, NULL, NULL, a_ProviderName ))
		return SELFREG_E_CLASS;

#endif

	wcscpy(szProviderCLSIDClassID,CLSID_STR);
	wcscat(szProviderCLSIDClassID,szProviderClassID);

		//Create entries under CLSID
	if (FALSE ==SetKeyAndValue(szProviderCLSIDClassID, NULL, NULL, a_ProviderName ))
		return SELFREG_E_CLASS;

	if (FALSE ==SetKeyAndValue(szProviderCLSIDClassID, NOT_INSERT_STR, NULL, NULL))
			return SELFREG_E_CLASS;

#ifdef WMIASLOCAL

	if (FALSE ==SetKeyAndValue(szProviderCLSIDClassID, LOCALSERVER32_STR, NULL,szModule))
		return SELFREG_E_CLASS;

	if (FALSE ==SetKeyAndValue(szProviderCLSIDClassID, LOCALSERVER32_STR,THREADING_MODULE_STR, APARTMENT_STR))
		return SELFREG_E_CLASS;
#else

	if (FALSE ==SetKeyAndValue(szProviderCLSIDClassID, INPROC32_STR, NULL,szModule))
		return SELFREG_E_CLASS;

	if (FALSE ==SetKeyAndValue(szProviderCLSIDClassID, INPROC32_STR,THREADING_MODULE_STR, APARTMENT_STR))
		return SELFREG_E_CLASS;

#endif

	return S_OK;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

STDAPI UnregisterServer ( GUID a_ProviderClassId )
{
	wchar_t szTemp[128];

	wchar_t szProviderClassID[128];
	wchar_t szProviderCLSIDClassID[128];

	int iRet = StringFromGUID2(a_ProviderClassId ,szProviderClassID, 128);

	wcscpy(szProviderCLSIDClassID,CLSID_STR);
	wcscat(szProviderCLSIDClassID,szProviderClassID);

	//Delete entries under CLSID

	wsprintf(szTemp, REG_FORMAT_STR, szProviderCLSIDClassID, NOT_INSERT_STR);
	RegDeleteKey(HKEY_CLASSES_ROOT, szTemp);

#ifdef WMIASLOCAL

	TCHAR szProviderCLSIDAppID[128];
	_tcscpy(szProviderCLSIDAppID,APPID_STR);
	_tcscat(szProviderCLSIDAppID,szProviderClassID);

	//Delete entries under APPID

	DWORD t_Status = RegDeleteKey(HKEY_CLASSES_ROOT, szProviderCLSIDAppID);

	_tcscpy(szProviderCLSIDAppID,APPID_STR);
	_tcscat(szProviderCLSIDAppID,szProviderClassID);

	wsprintf(szTemp, REG_FORMAT_STR,szProviderCLSIDClassID, LOCALSERVER32_STR);
	t_Status = RegDeleteKey(HKEY_CLASSES_ROOT, szTemp);

#else

	wsprintf(szTemp, REG_FORMAT_STR,szProviderCLSIDClassID, INPROC32_STR);
	RegDeleteKey(HKEY_CLASSES_ROOT, szTemp);

#endif

	RegDeleteKey(HKEY_CLASSES_ROOT, szProviderCLSIDClassID);

    return S_OK;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

STDAPI DllRegisterServer ()
{
	HRESULT t_Result ;

	t_Result = RegisterServer ( CLSID_WmiProvider , WMI_PROVIDER ) ;
	if ( SUCCEEDED ( t_Result ) )
	{
		t_Result = RegisterServer ( CLSID_WmiClassProvider , WMI_CLASSPROVIDER ) ;
	}

	if ( SUCCEEDED ( t_Result ) )
	{
		t_Result = RegisterServer ( CLSID_WmiEventProvider , WMI_EVENTPROVIDER ) ;
	}

	if ( SUCCEEDED ( t_Result ) )
	{
		t_Result = RegisterServer ( CLSID_WmiTaskProvider , WMI_TASKPROVIDER ) ;
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

STDAPI DllUnregisterServer ()
{
	HRESULT t_Result ;

	t_Result = UnregisterServer ( CLSID_WmiProvider ) ;
	if ( SUCCEEDED ( t_Result ) ) 
	{
		t_Result = UnregisterServer ( CLSID_WmiClassProvider ) ;
	}

	if ( SUCCEEDED ( t_Result ) ) 
	{
		t_Result = UnregisterServer ( CLSID_WmiEventProvider ) ;
	}

	if ( SUCCEEDED ( t_Result ) ) 
	{
		t_Result = UnregisterServer ( CLSID_WmiTaskProvider ) ;
	}

	return t_Result ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\provsubsys\example\precomp.h ===
/*++

Copyright (C) 1996-2001 Microsoft Corporation

Module Name:

	Precomp.h

Abstract:


History:

--*/


#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>

#include <windows.h>
#include <stdio.h> 
#include <stdlib.h> 
#include <string.h> 
#include <tchar.h>
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\provsubsys\example\sources.inc ===
############################################################################
#
#   Copyright (C) 1999, Microsoft Corporation.
#
#   All rights reserved.
#
############################################################################

WMIUNICODE=1
WMIPRECOMPSHARED=1
!include $(PROJECT_ROOT)\wmi\wbem\common\makefile.cmn
SOURCES_USED=$(PROJECT_ROOT)\wmi\wbem\common\makefile.cmn

TARGETNAME=Provider
TARGETPATH=obj

!if "$(WMIASLOCAL)" == "true"
TARGETTYPE=PROGRAM
UMENTRY=winmain
UMTYPE=windows
!else
TARGETTYPE=DYNLINK
!endif

# The TARGETLIBS macro specifies additional libraries to link against your target
# image. Each library path specification should contain an asterisk (*)
# where the machine-specific subdirectory name should go.
LINKLIBS= \
	$(WBEMPRV_COMN_LIB)
TARGETLIBS= \
	$(WMIIDL_LIB) \
	$(WBEMINT_LIB) \
	$(WMIIDL_LIB)  \
	$(STDLIBRARY_LIB) \
	$(SDK_LIB_PATH)\ntdll.lib \
	$(SDK_LIB_PATH)\kernel32.lib \
	$(SDK_LIB_PATH)\advapi32.lib \
	$(SDK_LIB_PATH)\user32.lib \
	$(SDK_LIB_PATH)\oleaut32.lib \
	$(SDK_LIB_PATH)\ole32.lib \
	$(SDK_LIB_PATH)\uuid.lib \
	$(SDK_LIB_PATH)\msvcirt.lib \
	$(SDK_LIB_PATH)\msvcrt.lib \
	$(SDK_LIB_PATH)\vccomsup.lib

# The INCLUDES variable specifies any include paths that are specific to
# this source directory. Separate multiple paths with single
# semicolons. Relative path specifications are okay.
INCLUDES=$(INCLUDES); \
	$(WBEMINT_INC);\
	$(CONTAINER_INC); \
	$(CONTAINER_SRC); \
	$(WBEMPRV_COMN_INC);\
	..\include; \

# The developer defines the SOURCES macro. It contains a list of all the
# source files for this component. Specify each source file on a separate
# line using the line-continuation character. This minimizes merge
# conflicts if two developers are adding source files to the same component.

!if "$(WMIASLOCAL)" == "true"
XSOURCES= \
	..\Main.cpp
!endif

SOURCES=$(XSOURCES) \
	..\Provider.rc \
	..\Globals.cpp \
	..\Maindll.cpp \
	..\Service.cpp \
	..\ClassService.cpp\
	..\Events.cpp\


# Add the following to add DB verbose logging: '/DREP_VERBOSE_LOGGING'

!if "$(WMIASLOCAL)" == "true"
C_DEFINES=$(C_DEFINES) /DWMIASLOCAL
!endif

!if "$(WMIASSTA)" == "true"
C_DEFINES=$(C_DEFINES) /DWMIASSTA
!endif

C_DEFINES=$(C_DEFINES) /D_WIN32_DCOM
USE_NATIVE_EH=ASYNC
USE_RTTI=1
USE_MSVCRT=1

!if "$(WMIASLOCAL)" != "true"
DLLENTRY=_DllMainCRTStartup
!endif

!if "$(WMIASLOCAL)" != "true"
DLLDEF=$(O)\Provider.def
!else
EXEDEF=$(O)\Provider.def
!endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\provsubsys\example\include\resource.h ===
/*++

Copyright (C) 1996-2001 Microsoft Corporation

Module Name:

	Resource.h

Abstract:


History:

--*/

//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by propprov.rc
//

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NO_MFC                     1
#define _APS_NEXT_RESOURCE_VALUE        101
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1000
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\provsubsys\example\include\classfac.h ===
/*++

Copyright (C) 1996-2001 Microsoft Corporation

Module Name:

	ClassFac.h

Abstract:


History:

--*/

#ifndef _ProviderClassFactory_H
#define _ProviderClassFactory_H

template <class Object,class ObjectInterface>
class CProviderClassFactory : public IClassFactory
{
private:

    long m_ReferenceCount ;

protected:
public:

    CProviderClassFactory () ;
    ~CProviderClassFactory ( void ) ;

	//IUnknown members

	STDMETHODIMP QueryInterface ( REFIID , LPVOID FAR * ) ;
    STDMETHODIMP_( ULONG ) AddRef () ;
    STDMETHODIMP_( ULONG ) Release () ;

	//IClassFactory members

    STDMETHODIMP CreateInstance ( LPUNKNOWN , REFIID , LPVOID FAR * ) ;
    STDMETHODIMP LockServer ( BOOL ) ;
};

#include <classfac.cpp>

#endif // _ProviderClassFactory_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\provsubsys\example\sta\makefile.inc ===
!include $(_NTDRIVE)$(_NTROOT)\ADMIN\WMI\WBEM\COMMON\makefile.cmn
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\provsubsys\example\exe\makefile.inc ===
!INCLUDE $(_NTDRIVE)$(_NTROOT)\WMI\COMMON\makefile.cmn
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\provsubsys\example\include\events.h ===
/*++

Copyright (C) 1996-2001 Microsoft Corporation

Module Name:

	ProvResv.H

Abstract:


History:

--*/

#ifndef _CProvider_IWbemEventProvider_H
#define _CProvider_IWbemEventProvider_H

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

class CProvider_IWbemEventProvider : public IWbemEventProvider , 
								public IWbemProviderInit , 
								public IWbemShutdown
{
private:

	LONG m_ReferenceCount ;         //Object reference count
	LONG m_InternalReferenceCount ;         //Object reference count

	WmiAllocator &m_Allocator ;

	CRITICAL_SECTION m_CriticalSection ;

	IWbemServices *m_CoreService ;
	IWbemClassObject *m_EventObject ;
	IWbemObjectSink *m_EventSink ;

	HANDLE m_ThreadTerminate ;
	HANDLE m_ThreadHandle ;

	BSTR m_Namespace ;
	BSTR m_Locale ;
	BSTR m_User ;

private:

	static DWORD ThreadExecutionFunction ( void *a_Context ) ;

public:

	CProvider_IWbemEventProvider ( WmiAllocator &a_Allocator  ) ;
    ~CProvider_IWbemEventProvider () ;

    STDMETHODIMP_( ULONG ) InternalAddRef () ;
    STDMETHODIMP_( ULONG ) InternalRelease () ;

public:

	//Non-delegating object IUnknown

    STDMETHODIMP QueryInterface ( REFIID , LPVOID FAR * ) ;
    STDMETHODIMP_( ULONG ) AddRef () ;
    STDMETHODIMP_( ULONG ) Release () ;

	HRESULT STDMETHODCALLTYPE ProvideEvents ( 

		IWbemObjectSink *a_Sink ,
		LONG a_Flags
	) ;

	/* IWbemProviderInit methods */

	HRESULT STDMETHODCALLTYPE Initialize (

		LPWSTR a_User ,
		LONG a_Flags ,
		LPWSTR a_Namespace ,
		LPWSTR a_Locale ,
		IWbemServices *a_Core ,
		IWbemContext *a_Context ,
		IWbemProviderInitSink *a_Sink
	) ;

	// IWmi_UnInitialize members

	HRESULT STDMETHODCALLTYPE Shutdown (

		LONG a_Flags ,
		ULONG a_MaxMilliSeconds ,
		IWbemContext *a_Context
	) ; 
} ;


#endif // _CProvider_IWbemEventProvider_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\provsubsys\example\service.cpp ===
/*++

Copyright (C) 1996-2001 Microsoft Corporation

Module Name:

	XXXX

Abstract:


History:

--*/

#include <precomp.h>

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <ntobapi.h>

#define _WINNT_	// have what is needed from above

#include "precomp.h"

#include <objbase.h>
#include <wbemint.h>
#include "Globals.h"
#include "HelperFuncs.h"
#include "Service.h"

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT Set_Uint64 (

	_IWmiObject *a_Instance ,
	wchar_t *a_Name ,
	const UINT64 &a_Uint64
)
{
	HRESULT t_Result = a_Instance->WriteProp (

		a_Name , 
		0 , 
		sizeof ( UINT64 ) , 
		0 ,
		CIM_UINT64 ,
		( void * ) & a_Uint64
	) ;

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT Set_Uint32 ( 

	_IWmiObject *a_Instance , 
	wchar_t *a_Name ,
	const DWORD &a_Uint32
)
{
	HRESULT t_Result = a_Instance->WriteProp (

		a_Name , 
		0 , 
		sizeof ( DWORD ) , 
		0 ,
		CIM_UINT32 ,
		( void * ) & a_Uint32
	) ;

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT Set_String ( 

	IWbemClassObject *a_Instance , 
	wchar_t *a_Name ,
	wchar_t *a_String
)
{
	VARIANT t_Variant ;
	VariantInit ( & t_Variant ) ;
	t_Variant.vt = VT_BSTR ;
	t_Variant.bstrVal = SysAllocString ( a_String ) ;
	a_Instance->Put ( a_Name , 0 , & t_Variant , 0 ) ;
	VariantClear ( & t_Variant ) ;

	return S_OK ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT EnablePrivilegeOnCurrentThread ( wchar_t *a_Privilege )
{
	HRESULT t_Result = WBEM_E_ACCESS_DENIED ;

    HANDLE t_Token = NULL;
	BOOL t_ProcessToken = FALSE ;

    if ( OpenThreadToken ( GetCurrentThread () , TOKEN_ADJUST_PRIVILEGES | TOKEN_QUERY, TRUE , & t_Token ) )
	{
	}
	else
	{	
		t_ProcessToken = TRUE ;
		ImpersonateSelf(SecurityImpersonation) ;
		
		if ( OpenThreadToken ( GetCurrentThread () , TOKEN_ADJUST_PRIVILEGES | TOKEN_QUERY , TRUE , & t_Token ) )
		{
		}
	}

	if ( t_Token )
    {
	    TOKEN_PRIVILEGES t_TokenPrivileges ;

		BOOL t_Status = LookupPrivilegeValue (

			NULL, 
			a_Privilege , 
			& t_TokenPrivileges.Privileges[0].Luid
		) ;

        if (t_Status)
        {
            t_TokenPrivileges.PrivilegeCount = 1;
            t_TokenPrivileges.Privileges[0].Attributes = SE_PRIVILEGE_ENABLED;

            SetLastError(0);

            t_Status = AdjustTokenPrivileges (

				t_Token , 
				FALSE , 
				& t_TokenPrivileges , 
				0 ,
                (PTOKEN_PRIVILEGES) NULL , 
				0
			) ;

			if ( GetLastError() == 0 )
			{
				t_Result = S_OK ;
			}
        }

        CloseHandle ( t_Token ) ;

		if ( t_ProcessToken )
		{
			RevertToSelf () ;
		}
    }

    return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

CProvider_IWbemServices :: CProvider_IWbemServices (

	 WmiAllocator &a_Allocator 

) : m_ReferenceCount ( 0 ) , 
	m_Allocator ( a_Allocator ) ,
	m_User ( NULL ) ,
	m_Locale ( NULL ) ,
	m_Namespace ( NULL ) ,
	m_CoreService ( NULL ) ,
	m_ComputerName  ( NULL ) ,
	m_OperatingSystemVersion ( NULL ) ,
	m_OperatingSystemRunning ( NULL ) , 
	m_ProductName ( NULL ) , 
	m_Win32_ProcessEx_Object ( NULL )
{
	InitializeCriticalSection ( & m_CriticalSection ) ;

	InterlockedIncrement ( & Provider_Globals :: s_ObjectsInProgress ) ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

CProvider_IWbemServices :: ~CProvider_IWbemServices ()
{
	DeleteCriticalSection ( & m_CriticalSection ) ;

	if ( m_User ) 
	{
		SysFreeString ( m_User ) ;
	}

	if ( m_Locale ) 
	{
		SysFreeString ( m_Locale ) ;
	}

	if ( m_Namespace ) 
	{
		SysFreeString ( m_Namespace ) ;
	}

	if ( m_CoreService ) 
	{
		m_CoreService->Release () ;
	}

	if ( m_Win32_ProcessEx_Object ) 
	{
		m_Win32_ProcessEx_Object->Release () ;
	}

	if ( m_ComputerName ) 
	{
		SysFreeString ( m_ComputerName ) ;
	}

	if ( m_OperatingSystemVersion ) 
	{
		SysFreeString ( m_OperatingSystemVersion ) ;
	}

	if ( m_OperatingSystemRunning ) 
	{
		SysFreeString ( m_OperatingSystemRunning ) ;
	}

	if ( m_ProductName )
	{
		SysFreeString ( m_ProductName ) ;
	}

	InterlockedDecrement ( & Provider_Globals :: s_ObjectsInProgress ) ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

STDMETHODIMP_(ULONG) CProvider_IWbemServices :: AddRef ( void )
{
	return InterlockedIncrement ( & m_ReferenceCount ) ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

STDMETHODIMP_(ULONG) CProvider_IWbemServices :: Release ( void )
{
	LONG t_Reference ;
	if ( ( t_Reference = InterlockedDecrement ( & m_ReferenceCount ) ) == 0 )
	{
		delete this ;
		return 0 ;
	}
	else
	{
		return t_Reference ;
	}
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

STDMETHODIMP CProvider_IWbemServices :: QueryInterface (

	REFIID iid , 
	LPVOID FAR *iplpv 
) 
{
	*iplpv = NULL ;

	if ( iid == IID_IUnknown )
	{
		*iplpv = ( LPVOID ) this ;
	}
	else if ( iid == IID_IWbemServices )
	{
		*iplpv = ( LPVOID ) ( IWbemServices * ) this ;		
	}	
	else if ( iid == IID_IWbemPropertyProvider )
	{
		*iplpv = ( LPVOID ) ( IWbemPropertyProvider * ) this ;		
	}	
	else if ( iid == IID_IWbemProviderInit )
	{
		*iplpv = ( LPVOID ) ( IWbemProviderInit * ) this ;		
	}	
	else if ( iid == IID_IWbemShutdown )
	{
		*iplpv = ( LPVOID ) ( IWbemShutdown * ) this ;		
	}	

	if ( *iplpv )
	{
		( ( LPUNKNOWN ) *iplpv )->AddRef () ;

		return ResultFromScode ( S_OK ) ;
	}
	else
	{
		return ResultFromScode ( E_NOINTERFACE ) ;
	}
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CProvider_IWbemServices::OpenNamespace ( 

	const BSTR ObjectPath, 
	long lFlags, 
	IWbemContext FAR* pCtx,
	IWbemServices FAR* FAR* pNewContext, 
	IWbemCallResult FAR* FAR* ppErrorObject
)
{
	return WBEM_E_NOT_AVAILABLE ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CProvider_IWbemServices :: CancelAsyncCall ( 
		
	IWbemObjectSink *a_Sink
)
{
	HRESULT t_Result = WBEM_E_NOT_AVAILABLE ;

	OutputDebugString ( L"\nCancelAsyncCall" ) ;
	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CProvider_IWbemServices :: QueryObjectSink ( 

	long lFlags,		
	IWbemObjectSink FAR* FAR* ppResponseHandler
) 
{
	return WBEM_E_NOT_AVAILABLE ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CProvider_IWbemServices :: GetObject ( 
		
	const BSTR ObjectPath,
    long lFlags,
    IWbemContext FAR *pCtx,
    IWbemClassObject FAR* FAR *ppObject,
    IWbemCallResult FAR* FAR *ppCallResult
)
{
	return WBEM_E_NOT_AVAILABLE ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CProvider_IWbemServices :: GetObjectAsync ( 
		
	const BSTR ObjectPath, 
	long lFlags, 
	IWbemContext FAR *pCtx,
	IWbemObjectSink FAR* pSink
) 
{
	HRESULT t_Result = WBEM_E_NOT_FOUND ;

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CProvider_IWbemServices :: PutClass ( 
		
	IWbemClassObject FAR* pObject, 
	long lFlags, 
	IWbemContext FAR *pCtx,
	IWbemCallResult FAR* FAR* ppCallResult
) 
{
	return WBEM_E_NOT_AVAILABLE ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CProvider_IWbemServices :: PutClassAsync ( 
		
	IWbemClassObject FAR* pObject, 
	long lFlags, 
	IWbemContext FAR *pCtx,
	IWbemObjectSink FAR* pResponseHandler
) 
{
 	 return WBEM_E_NOT_FOUND ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CProvider_IWbemServices :: DeleteClass ( 
		
	const BSTR Class, 
	long lFlags, 
	IWbemContext FAR *pCtx,
	IWbemCallResult FAR* FAR* ppCallResult
) 
{
 	 return WBEM_E_NOT_AVAILABLE ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CProvider_IWbemServices :: DeleteClassAsync ( 
		
	const BSTR Class, 
	long lFlags, 
	IWbemContext FAR *pCtx,
	IWbemObjectSink FAR* pResponseHandler
) 
{
 	 return WBEM_E_NOT_AVAILABLE ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CProvider_IWbemServices :: CreateClassEnum ( 

	const BSTR Superclass, 
	long lFlags, 
	IWbemContext FAR *pCtx,
	IEnumWbemClassObject FAR *FAR *ppEnum
) 
{
	return WBEM_E_NOT_AVAILABLE ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

SCODE CProvider_IWbemServices :: CreateClassEnumAsync (

	const BSTR Superclass, 
	long lFlags, 
	IWbemContext FAR* pCtx,
	IWbemObjectSink FAR* pHandler
) 
{
	return WBEM_E_NOT_FOUND ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CProvider_IWbemServices :: PutInstance (

    IWbemClassObject FAR *pInst,
    long lFlags,
    IWbemContext FAR *pCtx,
	IWbemCallResult FAR *FAR *ppCallResult
) 
{
	return WBEM_E_NOT_AVAILABLE ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CProvider_IWbemServices :: PutInstanceAsync ( 
		
	IWbemClassObject FAR* pInst, 
	long lFlags, 
    IWbemContext FAR *pCtx,
	IWbemObjectSink FAR* pSink
) 
{
	HRESULT t_Result = WBEM_E_NOT_AVAILABLE ;

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CProvider_IWbemServices :: DeleteInstance ( 

	const BSTR ObjectPath,
    long lFlags,
    IWbemContext FAR *pCtx,
    IWbemCallResult FAR *FAR *ppCallResult
)
{
	return WBEM_E_NOT_AVAILABLE ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/
        
HRESULT CProvider_IWbemServices :: DeleteInstanceAsync (
 
	const BSTR ObjectPath,
    long lFlags,
    IWbemContext __RPC_FAR *pCtx,
    IWbemObjectSink __RPC_FAR *pSink	
)
{
	HRESULT t_Result = WBEM_E_NOT_AVAILABLE ;

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CProvider_IWbemServices :: CreateInstanceEnum ( 

	const BSTR a_Class, 
	long a_Flags, 
	IWbemContext FAR *a_Context, 
	IEnumWbemClassObject __RPC_FAR *__RPC_FAR *a_Enum
)
{
	HRESULT t_Result = WBEM_E_NOT_AVAILABLE ;

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

DWORD GetCurrentImpersonationLevel ()
{
	DWORD t_ImpersonationLevel = RPC_C_IMP_LEVEL_ANONYMOUS ;

    HANDLE t_ThreadToken = NULL ;

    BOOL t_Status = OpenThreadToken (

		GetCurrentThread() ,
		TOKEN_QUERY,
		TRUE,
		&t_ThreadToken
	) ;

    if ( t_Status )
    {
		SECURITY_IMPERSONATION_LEVEL t_Level = SecurityAnonymous ;
		DWORD t_Returned = 0 ;

		t_Status = GetTokenInformation (

			t_ThreadToken ,
			TokenImpersonationLevel ,
			& t_Level ,
			sizeof ( SECURITY_IMPERSONATION_LEVEL ) ,
			& t_Returned
		) ;

		CloseHandle ( t_ThreadToken ) ;

		if ( t_Status == FALSE )
		{
			t_ImpersonationLevel = RPC_C_IMP_LEVEL_ANONYMOUS ;
		}
		else
		{
			switch ( t_Level )
			{
				case SecurityAnonymous:
				{
					t_ImpersonationLevel = RPC_C_IMP_LEVEL_ANONYMOUS ;
				}
				break ;

				case SecurityIdentification:
				{
					t_ImpersonationLevel = RPC_C_IMP_LEVEL_IDENTIFY ;
				}
				break ;

				case SecurityImpersonation:
				{
					t_ImpersonationLevel = RPC_C_IMP_LEVEL_IMPERSONATE ;
				}
				break ;

				case SecurityDelegation:
				{
					t_ImpersonationLevel = RPC_C_IMP_LEVEL_DELEGATE ;
				}
				break ;

				default:
				{
					t_ImpersonationLevel = RPC_C_IMP_LEVEL_ANONYMOUS ;
				}
				break ;
			}
		}
	}
	else
	{
        ULONG t_LastError = GetLastError () ;

        if ( t_LastError == ERROR_NO_IMPERSONATION_TOKEN || t_LastError == ERROR_NO_TOKEN )
        {
            t_ImpersonationLevel = RPC_C_IMP_LEVEL_DELEGATE ;
        }
        else 
		{
			if ( t_LastError == ERROR_CANT_OPEN_ANONYMOUS )
			{
				t_ImpersonationLevel = RPC_C_IMP_LEVEL_ANONYMOUS ;
			}
			else
			{
				t_ImpersonationLevel = RPC_C_IMP_LEVEL_ANONYMOUS ;
			}
		}
    }

	return t_ImpersonationLevel ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CProvider_IWbemServices :: CreateInstanceEnumAsync (

 	const BSTR a_Class ,
	long a_Flags , 
	IWbemContext __RPC_FAR *a_Context,
	IWbemObjectSink FAR *a_Sink

) 
{
	HRESULT t_Result = CoImpersonateClient () ;
	if ( SUCCEEDED ( t_Result ) )
	{
		if ( GetCurrentImpersonationLevel () == RPC_C_IMP_LEVEL_IDENTIFY )
		{
			CoRevertToSelf () ;
		}
	}

	if ( _wcsicmp ( a_Class , L"Win32_ProcessEx" ) == 0 ) 
	{
		t_Result = CreateInstanceEnumAsync_Process_Batched ( 

			m_Win32_ProcessEx_Object ,
			a_Flags ,
			a_Context , 
			a_Sink
		) ;
	}
	else
	{
		t_Result = WBEM_E_INVALID_CLASS ;
	}
	
	a_Sink->SetStatus ( 0 , t_Result , NULL , NULL ) ;

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CProvider_IWbemServices :: ExecQuery ( 

	const BSTR a_QueryLanguage, 
	const BSTR a_Query, 
	long a_Flags, 
	IWbemContext *a_Context ,
	IEnumWbemClassObject **a_Enumerator
)
{
	return WBEM_E_NOT_AVAILABLE ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CProvider_IWbemServices :: ExecQueryAsync ( 
		
	const BSTR a_QueryFormat, 
	const BSTR a_Query, 
	long a_Flags, 
	IWbemContext *a_Context ,
	IWbemObjectSink *a_Sink
) 
{
	HRESULT t_Result = CoImpersonateClient () ;

	a_Sink->SetStatus ( WBEM_STATUS_REQUIREMENTS , S_OK , NULL , NULL ) ;

	t_Result = CreateInstanceEnumAsync_Process_Batched ( 

		m_Win32_ProcessEx_Object ,
		a_Flags ,
		a_Context , 
		a_Sink
	) ;

	a_Sink->SetStatus ( 0 , t_Result , NULL , NULL ) ;

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CProvider_IWbemServices :: ExecNotificationQuery ( 

	const BSTR a_QueryLanguage,
    const BSTR a_Query,
    long a_Flags,
    IWbemContext *a_Context ,
    IEnumWbemClassObject **a_Enumerator
)
{
	return WBEM_E_NOT_AVAILABLE ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/
        
HRESULT CProvider_IWbemServices :: ExecNotificationQueryAsync ( 
            
	const BSTR a_QueryLanguage,
    const BSTR a_Query,
    long a_Flags ,
    IWbemContext *a_Context ,
    IWbemObjectSink *a_Sink
)
{
	return WBEM_E_NOT_AVAILABLE ;
}       

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT STDMETHODCALLTYPE CProvider_IWbemServices :: ExecMethod ( 

	const BSTR ObjectPath,
    const BSTR MethodName,
    long lFlags,
    IWbemContext FAR *pCtx,
    IWbemClassObject FAR *pInParams,
    IWbemClassObject FAR *FAR *ppOutParams,
    IWbemCallResult FAR *FAR *ppCallResult
)
{
	return WBEM_E_NOT_AVAILABLE ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT STDMETHODCALLTYPE CProvider_IWbemServices :: ExecMethodAsync ( 

    const BSTR ObjectPath,
    const BSTR MethodName,
    long lFlags,
    IWbemContext FAR *pCtx,
    IWbemClassObject FAR *pInParams,
	IWbemObjectSink FAR *pSink
) 
{
	HRESULT t_Result = WBEM_E_NOT_AVAILABLE ;

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CProvider_IWbemServices :: GetProperty (

    long a_Flags ,
    const BSTR a_Locale ,
    const BSTR a_ClassMapping ,
    const BSTR a_InstanceMapping ,
    const BSTR a_PropertyMapping ,
    VARIANT *a_Value
)
{
	if ( _wcsicmp ( a_PropertyMapping , L"ExtraProperty1" ) == 0 )
	{
	}
	else if ( _wcsicmp ( a_PropertyMapping , L"ExtraProperty2" ) == 0 )
	{
	}
	else
	{
	}
	
	return WBEM_E_NOT_AVAILABLE ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CProvider_IWbemServices :: PutProperty (

    long a_Flags ,
    const BSTR a_Locale ,
    const BSTR a_ClassMapping ,
    const BSTR a_InstanceMapping ,
    const BSTR a_PropertyMapping ,
    const VARIANT *a_Value
)
{
	if ( _wcsicmp ( a_PropertyMapping , L"ExtraProperty1" ) == 0 )
	{
	}
	else if ( _wcsicmp ( a_PropertyMapping , L"ExtraProperty2" ) == 0 )
	{
	}
	else
	{
	}

	return WBEM_E_NOT_AVAILABLE ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CProvider_IWbemServices :: GetProductInformation ()
{
	HRESULT t_Result = S_OK ;

	ULONG t_ProductType = 0xffffffff ;

	if ( USER_SHARED_DATA->ProductTypeIsValid )
	{
		t_ProductType = USER_SHARED_DATA->NtProductType ;

		HKEY t_CurrentVersion ;
		LONG t_RegResult = RegOpenKeyEx (

			HKEY_LOCAL_MACHINE ,
			L"SOFTWARE\\Microsoft\\Windows NT\\Currentversion" ,
			0 ,
			KEY_READ ,
			& t_CurrentVersion 
		) ;

		if ( t_RegResult == ERROR_SUCCESS )
		{
			wchar_t t_ProductName [ _MAX_PATH ] ;

			DWORD t_ValueType = REG_SZ ;
			DWORD t_DataSize = sizeof ( t_ProductName ) ;

			t_RegResult = RegQueryValueEx (

			  t_CurrentVersion ,
			  L"" ,
			  0 ,
			  & t_ValueType ,
			  LPBYTE ( & t_ProductName ) ,
			  & t_DataSize 
			);

			if ( t_RegResult == ERROR_SUCCESS )
			{
				if ( wcscmp ( t_ProductName , L"" ) == 0 )
				{
					wcscpy ( t_ProductName , L"Microsoft Windows 2000" ) ;
				}

				if ( ( VER_SUITE_DATACENTER & USER_SHARED_DATA->SuiteMask ) &&
					( ( VER_NT_SERVER == t_ProductType ) || ( VER_NT_DOMAIN_CONTROLLER == t_ProductType ) )
				)
				{
					t_Result = WmiHelper :: ConcatenateStrings ( 

						2, 
						& m_ProductName , 
						t_ProductName ,
						L" Datacenter Server"
					) ;
				}
				else
				{
					if ( ( VER_SUITE_ENTERPRISE & USER_SHARED_DATA->SuiteMask ) &&
						( ( VER_NT_SERVER == t_ProductType ) || ( VER_NT_DOMAIN_CONTROLLER == t_ProductType ) )
					)
					{
						t_Result = WmiHelper :: ConcatenateStrings ( 

							2, 
							& m_ProductName , 
							t_ProductName ,
							L" Advanced Server"
						) ;
					}
					else
					{
						if ( ( VER_NT_SERVER == t_ProductType ) || ( VER_NT_DOMAIN_CONTROLLER == t_ProductType ) )
						{
							t_Result = WmiHelper :: ConcatenateStrings ( 

								2, 
								& m_ProductName , 
								t_ProductName ,
								L" Server"
							) ;
						}
						else
						{
							if ( VER_NT_WORKSTATION == t_ProductType )
							{
								t_Result = WmiHelper :: ConcatenateStrings ( 

									2, 
									& m_ProductName , 
									t_ProductName ,
									L" Professional"
								) ;
							}
						}
					}
				}

			}

			RegCloseKey ( t_CurrentVersion ) ;
		}

	}

	if ( SUCCEEDED ( t_Result ) ) 
	{
		wchar_t t_WindowsDirectory [ _MAX_PATH ] ;

	    if ( ! GetWindowsDirectory ( t_WindowsDirectory , sizeof ( t_WindowsDirectory ) / sizeof(wchar_t)) )
	    {
		    t_WindowsDirectory [0] = '\0';
	    }

		wchar_t t_File [_MAX_PATH] ;

		wcscpy ( t_File , t_WindowsDirectory ) ;
		wcscat ( t_File , _T("\\REPAIR\\SETUP.LOG") ) ;

		wchar_t t_Device [_MAX_PATH] ;

		GetPrivateProfileString (

			L"Paths" ,
			L"TargetDevice" ,
			L"" ,
			t_Device,
			sizeof ( t_Device ) / sizeof ( wchar_t ) ,
			t_File
		) ;

		t_Result = WmiHelper :: ConcatenateStrings ( 

			5 , 
			& m_OperatingSystemRunning , 
			m_ProductName ,
			L"|",
			t_WindowsDirectory ,
			L"|" ,
			t_Device
		) ;
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CProvider_IWbemServices :: Initialize (

	LPWSTR a_User,
	LONG a_Flags,
	LPWSTR a_Namespace,
	LPWSTR a_Locale,
	IWbemServices *a_CoreService,         // For anybody
	IWbemContext *a_Context,
	IWbemProviderInitSink *a_Sink     // For init signals
)
{
	HRESULT t_Result = S_OK ;

	if ( a_CoreService ) 
	{
		m_CoreService = a_CoreService ;
		m_CoreService->AddRef () ;
	}
	else
	{
		t_Result = WBEM_E_INVALID_PARAMETER ;
	}

	if ( SUCCEEDED ( t_Result ) )
	{
		if ( a_User ) 
		{
			m_User = SysAllocString ( a_User ) ;
			if ( m_User == NULL )
			{
				t_Result = WBEM_E_OUT_OF_MEMORY ;
			}
		}
	}

	if ( SUCCEEDED ( t_Result ) )
	{
		if ( a_Locale ) 
		{
			m_Locale = SysAllocString ( a_Locale ) ;
			if ( m_Locale == NULL )
			{
				t_Result = WBEM_E_OUT_OF_MEMORY ;
			}
		}
	}

	if ( SUCCEEDED ( t_Result ) )
	{
		if ( a_Namespace ) 
		{
			m_Namespace = SysAllocString ( a_Namespace ) ;
			if ( m_Namespace == NULL )
			{
				t_Result = WBEM_E_OUT_OF_MEMORY ;
			}
		}
	}
	
	if ( SUCCEEDED ( t_Result ) ) 
	{
		BSTR t_Class = SysAllocString ( L"Win32_ProcessEx" ) ;
		if ( t_Class ) 
		{
			t_Result = m_CoreService->GetObject (

				t_Class ,
				0 ,
				a_Context ,
				& m_Win32_ProcessEx_Object ,
				NULL 
			) ;

			if ( SUCCEEDED ( t_Result ) )
			{
			}

			SysFreeString ( t_Class ) ;
		}
		else
		{
			t_Result = WBEM_E_OUT_OF_MEMORY ;
		}
	}

	if ( SUCCEEDED ( t_Result ) ) 
	{
		m_ComputerName = SysAllocStringLen ( NULL , _MAX_PATH ) ;
		if ( m_ComputerName ) 
		{
			DWORD t_Length = _MAX_PATH ;
			GetComputerName ( m_ComputerName , & t_Length ) ;
		}
		else
		{
			t_Result = WBEM_E_OUT_OF_MEMORY ;
		}
	}

	if ( SUCCEEDED ( t_Result ) )
	{	
		OSVERSIONINFO t_VersionInfo ;
		t_VersionInfo.dwOSVersionInfoSize = sizeof ( OSVERSIONINFO ) ;
		if ( GetVersionEx ( & t_VersionInfo ) )
		{
			m_OperatingSystemVersion  = SysAllocStringLen ( NULL , _MAX_PATH ) ;
			if ( m_OperatingSystemVersion )
			{
				swprintf (	m_OperatingSystemVersion ,	L"%d.%d.%hu", t_VersionInfo.dwMajorVersion , t_VersionInfo.dwMinorVersion , LOWORD ( t_VersionInfo.dwBuildNumber ) ) ;
			}
			else
			{
				t_Result = WBEM_E_OUT_OF_MEMORY ;
			}
		}
		else
		{
			t_Result = WBEM_E_FAILED ;
		}
	}

	if ( SUCCEEDED ( t_Result ) )
	{
		t_Result = GetProductInformation () ;	
	}

	a_Sink->SetStatus ( t_Result , 0 ) ;

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CProvider_IWbemServices :: Shutdown (

	LONG a_Flags ,
	ULONG a_MaxMilliSeconds ,
	IWbemContext *a_Context
)
{
	HRESULT t_Result = S_OK ;

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CProvider_IWbemServices :: GetProcessExecutable ( HANDLE a_Process , wchar_t *&a_ExecutableName )
{
	HRESULT t_Result = WBEM_E_FAILED ;

    PROCESS_BASIC_INFORMATION t_BasicInfo ;

    NTSTATUS t_Status = NtQueryInformationProcess (

        a_Process ,
        ProcessBasicInformation ,
        & t_BasicInfo ,
        sizeof ( t_BasicInfo ) ,
        NULL
	) ;

    if ( NT_SUCCESS ( t_Status ) )
	{
		PEB *t_Peb = t_BasicInfo.PebBaseAddress ;

		//
		// Ldr = Peb->Ldr
		//

		PPEB_LDR_DATA t_Ldr ;

		t_Status = ReadProcessMemory (

			a_Process,
			& t_Peb->Ldr,
			& t_Ldr,
			sizeof ( t_Ldr ) ,
			NULL
		) ;

		if ( t_Status )
		{
			LIST_ENTRY *t_LdrHead = & t_Ldr->InMemoryOrderModuleList ;

			//
			// LdrNext = Head->Flink;
			//

			LIST_ENTRY *t_LdrNext ;

			t_Status = ReadProcessMemory (

				a_Process,
				& t_LdrHead->Flink,
				& t_LdrNext,
				sizeof ( t_LdrNext ) ,
				NULL
			) ;

			if ( t_Status )
			{
				if ( t_LdrNext != t_LdrHead )
				{
					LDR_DATA_TABLE_ENTRY t_LdrEntryData ;

					LDR_DATA_TABLE_ENTRY *t_LdrEntry = CONTAINING_RECORD ( t_LdrNext , LDR_DATA_TABLE_ENTRY, InMemoryOrderLinks ) ;

					t_Status = ReadProcessMemory (

						a_Process,
						t_LdrEntry,
						& t_LdrEntryData,
						sizeof ( t_LdrEntryData ) ,
						NULL
					) ;

					if ( t_Status )
					{
						a_ExecutableName = ( wchar_t * ) new wchar_t [t_LdrEntryData.FullDllName.MaximumLength ];
						if ( a_ExecutableName )
						{
							t_Status = ReadProcessMemory (

								a_Process,
								t_LdrEntryData.FullDllName.Buffer,
								a_ExecutableName ,
								t_LdrEntryData.FullDllName.MaximumLength ,
								NULL
							) ;

							if ( t_Status )
							{
								t_Result = S_OK ;
							}
						}
						else
						{
							t_Result = WBEM_E_OUT_OF_MEMORY ;
						}
					}
				}
			}
		}
	}

    return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CProvider_IWbemServices :: NextProcessBlock (

	SYSTEM_PROCESS_INFORMATION *a_ProcessBlock , 
	SYSTEM_PROCESS_INFORMATION *&a_NextProcessBlock
)
{
	if ( a_ProcessBlock )
	{
		DWORD t_NextOffSet = a_ProcessBlock->NextEntryOffset ;
		if ( t_NextOffSet )
		{
			a_NextProcessBlock = ( SYSTEM_PROCESS_INFORMATION * ) ( ( ( BYTE * ) a_ProcessBlock ) + t_NextOffSet ) ;
		}
		else
		{
			a_NextProcessBlock = NULL ;
		}
	}

	return S_OK ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CProvider_IWbemServices :: GetProcessBlocks ( SYSTEM_PROCESS_INFORMATION *&a_ProcessInformation )
{
	HRESULT t_Result = S_OK ;

	DWORD t_ProcessInformationSize = 32768;
	a_ProcessInformation = ( SYSTEM_PROCESS_INFORMATION * ) new BYTE [t_ProcessInformationSize] ;

	if ( a_ProcessInformation )
	{
		BOOL t_Retry = TRUE ;
		while ( t_Retry )
		{
			NTSTATUS t_Status = NtQuerySystemInformation (

				SystemProcessInformation,
				a_ProcessInformation,
				t_ProcessInformationSize,
				NULL
			) ;

			if ( t_Status == STATUS_INFO_LENGTH_MISMATCH )
			{
				delete [] a_ProcessInformation  ;
				a_ProcessInformation = NULL ;
				t_ProcessInformationSize += 32768 ;
				a_ProcessInformation = ( SYSTEM_PROCESS_INFORMATION * ) new BYTE [ t_ProcessInformationSize ] ;
				if ( ! a_ProcessInformation )
				{
					return WBEM_E_OUT_OF_MEMORY ;
				}
			}
			else
			{
				t_Retry = FALSE ;

				if ( ! NT_SUCCESS ( t_Status ) )
				{
					delete [] a_ProcessInformation;
					a_ProcessInformation = NULL ;
				}
			}
		}
	}
	else
	{
		return WBEM_E_OUT_OF_MEMORY ;
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CProvider_IWbemServices :: GetProcessInformation (

	SYSTEM_PROCESS_INFORMATION *&a_ProcessInformation
)
{
	HRESULT t_Result = S_OK ;

	EnablePrivilegeOnCurrentThread ( SE_DEBUG_NAME ) ;
	
	return GetProcessBlocks ( a_ProcessInformation ) ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CProvider_IWbemServices :: GetProcessParameters (

	HANDLE a_Process ,
	wchar_t *&a_ProcessCommandLine
)
{
	HRESULT t_Result = WBEM_E_FAILED ;

    PROCESS_BASIC_INFORMATION t_BasicInfo ;

    NTSTATUS t_Status = NtQueryInformationProcess (

        a_Process ,
        ProcessBasicInformation ,
        & t_BasicInfo ,
        sizeof ( t_BasicInfo ) ,
        NULL
	) ;

    if ( NT_SUCCESS ( t_Status ) )
	{
		PEB *t_Peb = t_BasicInfo.PebBaseAddress ;

		RTL_USER_PROCESS_PARAMETERS *t_ProcessParameters = NULL ;

		BOOL t_Success = ReadProcessMemory (

			a_Process,
			& t_Peb->ProcessParameters,
			& t_ProcessParameters,
			sizeof ( t_ProcessParameters ) ,
			NULL
		) ;

		if ( t_Success )
		{
			RTL_USER_PROCESS_PARAMETERS t_Parameters ;

			t_Success = ReadProcessMemory (

				a_Process,
				t_ProcessParameters,
				& t_Parameters ,
				sizeof ( RTL_USER_PROCESS_PARAMETERS ) ,
				NULL
			) ;

			if ( t_Success )
			{
				a_ProcessCommandLine = new wchar_t [ t_Parameters.CommandLine.MaximumLength ];

				t_Success = ReadProcessMemory (

					a_Process,
					t_Parameters.CommandLine.Buffer ,
					a_ProcessCommandLine ,
					t_Parameters.CommandLine.MaximumLength ,
					NULL
				) ;

				if ( t_Success )
				{
					t_Result = S_OK ;
				}
			}
		}
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CProvider_IWbemServices :: CreateInstanceEnumAsync_Process_Load (

	SYSTEM_PROCESS_INFORMATION *a_ProcessInformation ,
	IWbemClassObject *a_Instance 
)
{
	HRESULT t_Result = S_OK ;

	_IWmiObject *t_FastInstance = NULL ;
	t_Result = a_Instance->QueryInterface ( IID__IWmiObject , ( void ** ) & t_FastInstance ) ;
	if ( SUCCEEDED ( t_Result ) )
	{
		wchar_t t_Handle [ _MAX_PATH ] ;
		_ui64tow ( HandleToUlong ( a_ProcessInformation->UniqueProcessId ) , t_Handle , 10 ) ;
		Set_String ( a_Instance , L"Handle" , t_Handle ) ;

		Set_Uint32 ( t_FastInstance , L"ProcessId" , HandleToUlong ( a_ProcessInformation->UniqueProcessId )  ) ;

		if ( a_ProcessInformation->ImageName.Buffer )
		{
			Set_String ( a_Instance , L"Name" , a_ProcessInformation->ImageName.Buffer ) ;
			Set_String ( a_Instance , L"Caption" , a_ProcessInformation->ImageName.Buffer ) ;
			Set_String ( a_Instance , L"Description" , a_ProcessInformation->ImageName.Buffer ) ;
		}
		else
		{
			switch ( HandleToUlong ( a_ProcessInformation->UniqueProcessId ) )
			{
				case 0:
				{
					Set_String ( a_Instance , L"Name" , L"System Idle Process" ) ;
					Set_String ( a_Instance , L"Caption" , L"System Idle Process" ) ;
					Set_String ( a_Instance , L"Description" , L"System Idle Process" ) ;
				}
				break ;

				case 2:
				case 8:
				{
					Set_String ( a_Instance , L"Name" , L"System" ) ;
					Set_String ( a_Instance , L"Caption" , L"System" ) ;
					Set_String ( a_Instance , L"Description" , L"System" ) ;
				}
				break ;

				default:
				{
					Set_String ( a_Instance , L"Name" , L"Unknown" ) ;
					Set_String ( a_Instance , L"Caption" , L"Unknown" ) ;
					Set_String ( a_Instance , L"Description" , L"Unknown" ) ;
				}
				break ;
			}
		}

		Set_String ( a_Instance , L"CSCreationClassName"	, L"Win32_ComputerSystem"	) ;
		Set_String ( a_Instance , L"CSName"					, m_ComputerName			) ;
		Set_String ( a_Instance , L"OSCreationClassName"	, L"Win32_OperatingSystem"	) ;
		Set_String ( a_Instance , L"WindowsVersion"			, m_OperatingSystemVersion	) ;
		Set_String ( a_Instance , L"OSName"					, m_OperatingSystemRunning	) ;

		Set_Uint32 ( t_FastInstance , L"ProcessId" , HandleToUlong ( a_ProcessInformation->UniqueProcessId )  ) ;

		Set_Uint32 ( t_FastInstance , L"PageFaults" , a_ProcessInformation->PageFaultCount ) ;
		Set_Uint32 ( t_FastInstance , L"PeakWorkingSetSize" , a_ProcessInformation->PeakWorkingSetSize ) ;
		Set_Uint64 ( t_FastInstance , L"WorkingSetSize" , (const unsigned __int64) a_ProcessInformation->WorkingSetSize ) ;
		Set_Uint32 ( t_FastInstance , L"QuotaPeakPagedPoolUsage" , a_ProcessInformation->QuotaPeakPagedPoolUsage ) ;
		Set_Uint32 ( t_FastInstance , L"QuotaPagedPoolUsage" , a_ProcessInformation->QuotaPagedPoolUsage ) ;
		Set_Uint32 ( t_FastInstance , L"QuotaPeakNonPagedPoolUsage" , a_ProcessInformation->QuotaPeakNonPagedPoolUsage ) ;
		Set_Uint32 ( t_FastInstance , L"QuotaNonPagedPoolUsage" , a_ProcessInformation->QuotaNonPagedPoolUsage ) ;
		Set_Uint32 ( t_FastInstance , L"PageFileUsage" , a_ProcessInformation->PagefileUsage ) ;
		Set_Uint32 ( t_FastInstance , L"PeakPageFileUsage" , a_ProcessInformation->PeakPagefileUsage ) ;
		Set_Uint32 ( t_FastInstance , L"Priority" , a_ProcessInformation->BasePriority ) ;

		if ( a_ProcessInformation->CreateTime.u.HighPart > 0 )
		{
//			Set_DateTime ( a_Instance , L"CreationDate" , * ( FILETIME * ) ( & a_ProcessInformation->CreateTime.u ) ) ;
		}

		Set_Uint32 ( t_FastInstance , L"ThreadCount" , a_ProcessInformation->NumberOfThreads ) ;
		Set_Uint32 ( t_FastInstance , L"ParentProcessId" , HandleToUlong ( a_ProcessInformation->InheritedFromUniqueProcessId ) ) ;
		Set_Uint32 ( t_FastInstance , L"HandleCount" , a_ProcessInformation->HandleCount ) ;
		Set_Uint32 ( t_FastInstance , L"SessionId" , a_ProcessInformation->SessionId ) ;
		Set_Uint64 ( t_FastInstance , L"KernelModeTime" , (const unsigned __int64) a_ProcessInformation->KernelTime.QuadPart ) ;
		Set_Uint64 ( t_FastInstance , L"UserModeTime" , (const unsigned __int64) a_ProcessInformation->UserTime.QuadPart ) ;
		Set_Uint64 ( t_FastInstance , L"PrivatePageCount" , (const unsigned __int64) a_ProcessInformation->PrivatePageCount ) ;
		Set_Uint64 ( t_FastInstance , L"PeakVirtualSize" , (const unsigned __int64) a_ProcessInformation->PeakVirtualSize ) ;
		Set_Uint64 ( t_FastInstance , L"VirtualSize" , (const unsigned __int64) a_ProcessInformation->VirtualSize ) ;
		Set_Uint64 ( t_FastInstance , L"ReadOperationCount" , (const unsigned __int64) a_ProcessInformation->ReadOperationCount.QuadPart ) ;
		Set_Uint64 ( t_FastInstance , L"WriteOperationCount" , (const unsigned __int64) a_ProcessInformation->WriteOperationCount.QuadPart ) ;
		Set_Uint64 ( t_FastInstance , L"OtherOperationCount" , (const unsigned __int64) a_ProcessInformation->OtherOperationCount.QuadPart ) ;
		Set_Uint64 ( t_FastInstance , L"ReadTransferCount" , (const unsigned __int64) a_ProcessInformation->ReadTransferCount.QuadPart ) ;
		Set_Uint64 ( t_FastInstance , L"WriteTransferCount" , (const unsigned __int64) a_ProcessInformation->WriteTransferCount.QuadPart ) ;
		Set_Uint64 ( t_FastInstance , L"OtherTransferCount" , (const unsigned __int64) a_ProcessInformation->OtherTransferCount.QuadPart ) ;

		HANDLE t_ProcessHandle = OpenProcess (

			PROCESS_QUERY_INFORMATION | PROCESS_VM_READ,
			FALSE,
			HandleToUlong ( a_ProcessInformation->UniqueProcessId )
		) ;

		if ( t_ProcessHandle )
		{
			wchar_t *t_ExecutableName = NULL ;
			t_Result = GetProcessExecutable ( t_ProcessHandle , t_ExecutableName ) ;
			if ( SUCCEEDED ( t_Result ) )
			{
				Set_String ( a_Instance , L"ExecutablePath" , t_ExecutableName );
				delete [] t_ExecutableName ;
			}

			QUOTA_LIMITS QuotaLimits;
			NTSTATUS Status = NtQueryInformationProcess (

				t_ProcessHandle,
				ProcessQuotaLimits,
				&QuotaLimits,
				sizeof(QuotaLimits),
				NULL
			);

			if ( NT_SUCCESS ( Status ) )
			{
				Set_Uint32 ( t_FastInstance , L"MinimumWorkingSetSize" , QuotaLimits.MinimumWorkingSetSize ) ;
				Set_Uint32 ( t_FastInstance , L"MaximumWorkingSetSize" , QuotaLimits.MaximumWorkingSetSize ) ;
			}

			wchar_t *t_CommandParameters = NULL ;

			t_Result = GetProcessParameters (

				t_ProcessHandle ,
				t_CommandParameters
			) ;

			if ( SUCCEEDED ( t_Result ) )
			{
				Set_String ( a_Instance , L"CommandLine" , t_CommandParameters ) ;
				delete [] t_CommandParameters ;
			}

			CloseHandle ( t_ProcessHandle ) ;
		}

		t_FastInstance->Release () ;
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CProvider_IWbemServices :: CreateInstanceEnumAsync_Process_Single (

	IWbemClassObject *a_ClassObject ,
	long a_Flags , 
	IWbemContext __RPC_FAR *a_Context,
	IWbemObjectSink FAR *a_Sink
)
{
	HRESULT t_Result = S_OK ;

	SYSTEM_PROCESS_INFORMATION *t_ProcessBlock = NULL ;

	t_Result = GetProcessInformation ( t_ProcessBlock ) ;
	if ( SUCCEEDED ( t_Result ) ) 
	{
		SYSTEM_PROCESS_INFORMATION *t_CurrentInformation = t_ProcessBlock ;
		while ( SUCCEEDED ( t_Result ) && t_CurrentInformation )
		{
			IWbemClassObject *t_Instance = NULL ;
			t_Result = a_ClassObject->SpawnInstance ( 

				0 , 
				& t_Instance
			) ;

			if ( SUCCEEDED ( t_Result ) )
			{
				t_Result = CreateInstanceEnumAsync_Process_Load (

					t_CurrentInformation ,
					t_Instance
				) ;

				if ( SUCCEEDED ( t_Result ) ) 
				{
					t_Result = a_Sink->Indicate ( 1 , & t_Instance ) ;
				}

				t_Instance->Release () ;
			}

			t_Result = NextProcessBlock ( t_CurrentInformation , t_CurrentInformation ) ;
		}

		delete [] ( BYTE * ) t_ProcessBlock ;
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CProvider_IWbemServices :: CreateInstanceEnumAsync_Process_Batched (

	IWbemClassObject *a_ClassObject ,
	long a_Flags , 
	IWbemContext __RPC_FAR *a_Context,
	IWbemObjectSink FAR *a_Sink
)
{
	HRESULT t_Result = S_OK ;

	SYSTEM_PROCESS_INFORMATION *t_ProcessBlock = NULL ;

	t_Result = GetProcessInformation ( t_ProcessBlock ) ;
	if ( SUCCEEDED ( t_Result ) ) 
	{
		ULONG t_Count = 0 ; 
		SYSTEM_PROCESS_INFORMATION *t_CurrentInformation = t_ProcessBlock ;
		while ( SUCCEEDED ( t_Result ) && t_CurrentInformation )
		{
			t_Count ++ ;
			t_Result = NextProcessBlock ( t_CurrentInformation , t_CurrentInformation ) ;
		}

		if ( t_Count )
		{
			ULONG t_Index = 0 ;

			IWbemClassObject **t_ObjectArray = new IWbemClassObject * [ t_Count ] ;

			t_CurrentInformation = t_ProcessBlock ;
			while ( SUCCEEDED ( t_Result ) && t_CurrentInformation )
			{
				IWbemClassObject *t_Instance = NULL ;
				t_Result = a_ClassObject->SpawnInstance ( 

					0 , 
					& t_ObjectArray [ t_Index ]
				) ;

				if ( SUCCEEDED ( t_Result ) )
				{
					t_Result = CreateInstanceEnumAsync_Process_Load (

						t_CurrentInformation ,
						t_ObjectArray [ t_Index ]
					) ;
				}

				t_Index ++ ;

				t_Result = NextProcessBlock ( t_CurrentInformation , t_CurrentInformation ) ;
			}

			t_Result = a_Sink->Indicate ( t_Count , t_ObjectArray ) ;
			for ( t_Index = 0 ; t_Index < t_Count ; t_Index ++ )
			{
				t_ObjectArray [ t_Index ]->Release () ;
			}

			delete [] t_ObjectArray ;
		}

		delete [] ( BYTE * ) t_ProcessBlock ;
	}

	return t_Result ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\provsubsys\example\include\classservice.h ===
/*++

Copyright (C) 1996-2001 Microsoft Corporation

Module Name:

	ProvResv.H

Abstract:


History:

--*/

#ifndef _ClassProvider_IWbemServices_H
#define _ClassProvider_IWbemServices_H

class CClassProvider_IWbemServices : public IWbemServices , public IWbemProviderInit , public IWbemShutdown
{
private:

	LONG m_ReferenceCount ;         //Object reference count

	WmiAllocator &m_Allocator ;

	CRITICAL_SECTION m_CriticalSection ;

	IWbemServices *m_CoreService ;
	IWbemClassObject *m_Empty ;

	BSTR m_Namespace ;
	BSTR m_Locale ;
	BSTR m_User ;

	HRESULT BuildClass (

		IWbemClassObject **a_Class 
	) ;

public:

	CClassProvider_IWbemServices ( WmiAllocator &a_Allocator  ) ;
    ~CClassProvider_IWbemServices () ;

public:

	//Non-delegating object IUnknown

    STDMETHODIMP QueryInterface ( REFIID , LPVOID FAR * ) ;
    STDMETHODIMP_( ULONG ) AddRef () ;
    STDMETHODIMP_( ULONG ) Release () ;

    /* IWbemServices methods */

    HRESULT STDMETHODCALLTYPE OpenNamespace ( 

        const BSTR a_Namespace ,
        long a_Flags ,
        IWbemContext *a_Context ,
        IWbemServices **a_Service ,
        IWbemCallResult **a_CallResult
	) ;
    
    HRESULT STDMETHODCALLTYPE CancelAsyncCall ( 

        IWbemObjectSink *a_Sink
	) ;
    
    HRESULT STDMETHODCALLTYPE QueryObjectSink ( 

        long a_Flags ,
        IWbemObjectSink **a_Sink
	) ;
    
    HRESULT STDMETHODCALLTYPE GetObject ( 

		const BSTR a_ObjectPath ,
        long a_Flags ,
        IWbemContext *a_Context ,
        IWbemClassObject **ppObject ,
        IWbemCallResult **a_CallResult
	) ;
    
    HRESULT STDMETHODCALLTYPE GetObjectAsync (
        
		const BSTR a_ObjectPath ,
        long a_Flags ,
        IWbemContext *a_Context ,
        IWbemObjectSink *a_Sink
	) ;

    HRESULT STDMETHODCALLTYPE PutClass ( 

        IWbemClassObject *a_Object ,
        long a_Flags ,
        IWbemContext *a_Context ,
        IWbemCallResult **a_CallResult
	) ;
    
    HRESULT STDMETHODCALLTYPE PutClassAsync ( 

        IWbemClassObject *a_Object ,
        long a_Flags ,
        IWbemContext *a_Context ,
        IWbemObjectSink *a_Sink
	) ;
    
    HRESULT STDMETHODCALLTYPE DeleteClass ( 

        const BSTR a_Class ,
        long a_Flags ,
        IWbemContext *a_Context ,
        IWbemCallResult **a_CallResult
	) ;
    
    HRESULT STDMETHODCALLTYPE DeleteClassAsync ( 

        const BSTR a_Class ,
        long a_Flags ,
        IWbemContext *a_Context ,
        IWbemObjectSink *a_Sink
	) ;
    
    HRESULT STDMETHODCALLTYPE CreateClassEnum ( 

        const BSTR a_Superclass ,
        long a_Flags ,
        IWbemContext *a_Context ,
        IEnumWbemClassObject **a_Enum
	) ;
    
    HRESULT STDMETHODCALLTYPE CreateClassEnumAsync ( 

		const BSTR a_Superclass ,
		long a_Flags ,
		IWbemContext *a_Context ,
		IWbemObjectSink *a_Sink
	) ;
    
    HRESULT STDMETHODCALLTYPE PutInstance (

		IWbemClassObject *a_Instance ,
		long a_Flags , 
		IWbemContext *a_Context ,
		IWbemCallResult **a_CallResult
	) ;
    
    HRESULT STDMETHODCALLTYPE PutInstanceAsync (

		IWbemClassObject *a_Instance ,
		long a_Flags ,
		IWbemContext *a_Context ,
		IWbemObjectSink *a_Sink 
	) ;
    
    HRESULT STDMETHODCALLTYPE DeleteInstance ( 

		const BSTR a_ObjectPath ,
		long a_Flags ,
		IWbemContext *a_Context ,
		IWbemCallResult **a_CallResult
	) ;
    
    HRESULT STDMETHODCALLTYPE DeleteInstanceAsync ( 

		const BSTR a_ObjectPath,
		long a_Flags,
		IWbemContext *a_Context ,
		IWbemObjectSink *a_Sink
	) ;
    
    HRESULT STDMETHODCALLTYPE CreateInstanceEnum (

		const BSTR a_Class ,
		long a_Flags ,
		IWbemContext *a_Context ,
		IEnumWbemClassObject **a_Enum
	) ;
    
    HRESULT STDMETHODCALLTYPE CreateInstanceEnumAsync (

		const BSTR a_Class ,
		long a_Flags ,
		IWbemContext *a_Context ,
		IWbemObjectSink *a_Sink
	) ;
    
    HRESULT STDMETHODCALLTYPE ExecQuery ( 

		const BSTR a_QueryLanguage,
		const BSTR a_Query,
		long a_Flags ,
		IWbemContext *a_Context ,
		IEnumWbemClassObject **a_Enum
	) ;
    
    HRESULT STDMETHODCALLTYPE ExecQueryAsync (

		const BSTR a_QueryLanguage ,
		const BSTR a_Query ,
		long a_Flags ,
		IWbemContext *a_Context ,
		IWbemObjectSink *a_Sink
	) ;
    
    HRESULT STDMETHODCALLTYPE ExecNotificationQuery (

		const BSTR a_QueryLanguage ,
		const BSTR a_Query ,
		long a_Flags ,
		IWbemContext *a_Context ,
		IEnumWbemClassObject **a_Enum
	) ;
    
    HRESULT STDMETHODCALLTYPE ExecNotificationQueryAsync ( 

        const BSTR a_QueryLanguage ,
        const BSTR a_Query ,
        long a_Flags ,
        IWbemContext *a_Context ,
        IWbemObjectSink *a_Sink
	) ;
    
    HRESULT STDMETHODCALLTYPE ExecMethod (

        const BSTR a_ObjectPath ,
        const BSTR a_MethodName ,
        long a_Flags ,
        IWbemContext *a_Context ,
        IWbemClassObject *a_InParams ,
        IWbemClassObject **a_OutParams ,
        IWbemCallResult **a_CallResult
	) ;
    
    HRESULT STDMETHODCALLTYPE ExecMethodAsync ( 

		const BSTR a_ObjectPath ,
		const BSTR a_MethodName ,
		long a_Flags ,
		IWbemContext *a_Context ,
		IWbemClassObject *a_InParams ,
		IWbemObjectSink *a_Sink
	) ;

	/* IWbemProviderInit methods */

	HRESULT STDMETHODCALLTYPE Initialize (

		LPWSTR a_User ,
		LONG a_Flags ,
		LPWSTR a_Namespace ,
		LPWSTR a_Locale ,
		IWbemServices *a_Core ,
		IWbemContext *a_Context ,
		IWbemProviderInitSink *a_Sink
	) ;

	// IWmi_UnInitialize members

	HRESULT STDMETHODCALLTYPE Shutdown (

		LONG a_Flags ,
		ULONG a_MaxMilliSeconds ,
		IWbemContext *a_Context
	) ; 
} ;


#endif // _ClassProvider_IWbemServices_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\provsubsys\example\include\globals.h ===
/*++

Copyright (C) 1996-2001 Microsoft Corporation

Module Name:

	Globals.h

Abstract:


History:

--*/

#ifndef _Globals_H
#define _Globals_H

#include <Allocator.h>

class Provider_Globals
{
public:

	static WmiAllocator *s_Allocator ;

	static LONG s_LocksInProgress ;
	static LONG s_ObjectsInProgress ;

	static HRESULT Global_Startup () ;
	static HRESULT Global_Shutdown () ;

	static HRESULT CreateInstance ( 

		const CLSID &a_ReferenceClsid ,
		LPUNKNOWN a_OuterUnknown ,
		const DWORD &a_ClassContext ,
		const UUID &a_ReferenceInterfaceId ,
		void **a_ObjectInterface
	);
} ;

#endif // _Globals_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\provsubsys\overlappedio\precomp.h ===
/*++

Copyright (C) 1996-2001 Microsoft Corporation

Module Name:

	Precomp.h

Abstract:


History:

--*/

#include <ole2.h>
#include <windows.h>
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\provsubsys\performance\cthread.cpp ===
/*++

Copyright (C) 1996-2001 Microsoft Corporation

Module Name:

	ProvFact.cpp

Abstract:


History:

--*/

#include "PreComp.h"
#include <wbemint.h>

#include "Globals.h"
#include "CThread.h"

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

WmiStatusCode ClientThread :: Initialize_Callback ()
{
	CoInitializeEx ( NULL , COINIT_MULTITHREADED ) ;

	return e_StatusCode_Success ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

WmiStatusCode ClientThread :: UnInitialize_Callback () 
{
	CoUninitialize () ;

	return e_StatusCode_Success ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

ClientThread :: ClientThread (

	WmiAllocator &a_Allocator	

) : WmiThread < ULONG > ( a_Allocator ) ,
	m_Allocator ( a_Allocator )
{
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

ClientThread::~ClientThread ()
{
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\provsubsys\performance\globals.cpp ===
/*++

Copyright (C) 1996-2001 Microsoft Corporation

Module Name:

	Globals.cpp

Abstract:


History:

--*/

#include "PreComp.h"

#include <initguid.h>
#ifndef INITGUID
#define INITGUID
#endif

#include <wbemint.h>

#include <Exception.h>
#include <Thread.h>

#include <Allocator.cpp>
#include <HelperFuncs.cpp>

#include "Globals.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\provsubsys\performance\precomp.h ===
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>

#include <windows.h>
#include <stdio.h> 
#include <stdlib.h> 
#include <string.h> 
#include <tchar.h>
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\provsubsys\overlappedio\main.cpp ===
//  Copyright (c) 1999-2001 Microsoft Corporation
#include <precomp.h>
#include <windows.h>
#include <objbase.h>
#include <stdio.h>
#include <typeinfo.h>

#include <Allocator.h>
#include <HelperFuncs.h>

#include <Thread.h>
#include <Allocator.cpp>
#include <HelperFuncs.cpp>
#include <Thread.cpp>
#include <ReaderWriter.cpp>
#include <IoScheduler.cpp>

#include "IoScheduler.h"
#include "FileRep.h"

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

void Test_Thread ()
{
	WmiStatusCode t_StatusCode = e_StatusCode_Success ;

	WmiAllocator t_Allocator ( WmiAllocator :: e_DefaultAllocation , 0 , 1 << 24 ) ;

	t_StatusCode = t_Allocator.Initialize () ;

	if ( t_StatusCode == e_StatusCode_Success ) 
	{
		CFileRepository *t_Repository = new CFileRepository ( t_Allocator ) ;
		if ( t_Repository )
		{
			t_Repository->AddRef () ;

			t_StatusCode = t_Repository->Initialize () ;
			if ( t_StatusCode == e_StatusCode_Success ) 
			{
			}

			t_Repository->Release () ;
		}
	}
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

EXTERN_C int __cdecl wmain (

	int argc ,
	char **argv 
)
{

	Test_Thread () ;
	
	return 0 ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\provsubsys\example\include\service.h ===
/*++

Copyright (C) 1996-2001 Microsoft Corporation

Module Name:

	ProvResv.H

Abstract:


History:

--*/

#ifndef _CProvider_IWbemServices_H
#define _CProvider_IWbemServices_H

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

class CProvider_IWbemServices : public IWbemServices , 
								public IWbemPropertyProvider ,	
								public IWbemProviderInit , 
								public IWbemShutdown
{
private:

	LONG m_ReferenceCount ;         //Object reference count

	WmiAllocator &m_Allocator ;

	CRITICAL_SECTION m_CriticalSection ;

	IWbemServices *m_CoreService ;

	BSTR m_Namespace ;
	BSTR m_Locale ;
	BSTR m_User ;

	BSTR m_ComputerName ;
	BSTR m_OperatingSystemVersion ;
	BSTR m_OperatingSystemRunning ;
	BSTR m_ProductName ;

	IWbemClassObject *m_Win32_ProcessEx_Object ;

private:

	HRESULT GetProductInformation () ;

	HRESULT GetProcessExecutable (

		HANDLE a_Process , 
		wchar_t *&a_ExecutableName
	) ;

	HRESULT CProvider_IWbemServices :: NextProcessBlock (

		SYSTEM_PROCESS_INFORMATION *a_ProcessBlock , 
		SYSTEM_PROCESS_INFORMATION *&a_NextProcessBlock
	) ;

	HRESULT GetProcessBlocks ( SYSTEM_PROCESS_INFORMATION *&a_ProcessInformation ) ;

	HRESULT GetProcessInformation (	SYSTEM_PROCESS_INFORMATION *&a_ProcessInformation ) ;

	HRESULT GetProcessParameters (

		HANDLE a_Process ,
		wchar_t *&a_ProcessCommandLine
	) ;

	HRESULT CreateInstanceEnumAsync_Process_Load (

		SYSTEM_PROCESS_INFORMATION *a_ProcessInformation ,
		IWbemClassObject *a_Instance 
	) ;

	HRESULT CreateInstanceEnumAsync_Process_Single (

		IWbemClassObject *a_ClassObject ,
 		long a_Flags , 
		IWbemContext __RPC_FAR *a_Context,
		IWbemObjectSink FAR *a_Sink
	) ;

	HRESULT CreateInstanceEnumAsync_Process_Batched (

		IWbemClassObject *a_ClassObject ,
 		long a_Flags , 
		IWbemContext __RPC_FAR *a_Context,
		IWbemObjectSink FAR *a_Sink
	) ;

public:

	CProvider_IWbemServices ( WmiAllocator &a_Allocator  ) ;
    ~CProvider_IWbemServices () ;

public:

	//Non-delegating object IUnknown

    STDMETHODIMP QueryInterface ( REFIID , LPVOID FAR * ) ;
    STDMETHODIMP_( ULONG ) AddRef () ;
    STDMETHODIMP_( ULONG ) Release () ;

    /* IWbemServices methods */

    HRESULT STDMETHODCALLTYPE OpenNamespace ( 

        const BSTR a_Namespace ,
        long a_Flags ,
        IWbemContext *a_Context ,
        IWbemServices **a_Service ,
        IWbemCallResult **a_CallResult
	) ;
    
    HRESULT STDMETHODCALLTYPE CancelAsyncCall ( 

        IWbemObjectSink *a_Sink
	) ;
    
    HRESULT STDMETHODCALLTYPE QueryObjectSink ( 

        long a_Flags ,
        IWbemObjectSink **a_Sink
	) ;
    
    HRESULT STDMETHODCALLTYPE GetObject ( 

		const BSTR a_ObjectPath ,
        long a_Flags ,
        IWbemContext *a_Context ,
        IWbemClassObject **ppObject ,
        IWbemCallResult **a_CallResult
	) ;
    
    HRESULT STDMETHODCALLTYPE GetObjectAsync (
        
		const BSTR a_ObjectPath ,
        long a_Flags ,
        IWbemContext *a_Context ,
        IWbemObjectSink *a_Sink
	) ;

    HRESULT STDMETHODCALLTYPE PutClass ( 

        IWbemClassObject *a_Object ,
        long a_Flags ,
        IWbemContext *a_Context ,
        IWbemCallResult **a_CallResult
	) ;
    
    HRESULT STDMETHODCALLTYPE PutClassAsync ( 

        IWbemClassObject *a_Object ,
        long a_Flags ,
        IWbemContext *a_Context ,
        IWbemObjectSink *a_Sink
	) ;
    
    HRESULT STDMETHODCALLTYPE DeleteClass ( 

        const BSTR a_Class ,
        long a_Flags ,
        IWbemContext *a_Context ,
        IWbemCallResult **a_CallResult
	) ;
    
    HRESULT STDMETHODCALLTYPE DeleteClassAsync ( 

        const BSTR a_Class ,
        long a_Flags ,
        IWbemContext *a_Context ,
        IWbemObjectSink *a_Sink
	) ;
    
    HRESULT STDMETHODCALLTYPE CreateClassEnum ( 

        const BSTR a_Superclass ,
        long a_Flags ,
        IWbemContext *a_Context ,
        IEnumWbemClassObject **a_Enum
	) ;
    
    HRESULT STDMETHODCALLTYPE CreateClassEnumAsync ( 

		const BSTR a_Superclass ,
		long a_Flags ,
		IWbemContext *a_Context ,
		IWbemObjectSink *a_Sink
	) ;
    
    HRESULT STDMETHODCALLTYPE PutInstance (

		IWbemClassObject *a_Instance ,
		long a_Flags , 
		IWbemContext *a_Context ,
		IWbemCallResult **a_CallResult
	) ;
    
    HRESULT STDMETHODCALLTYPE PutInstanceAsync (

		IWbemClassObject *a_Instance ,
		long a_Flags ,
		IWbemContext *a_Context ,
		IWbemObjectSink *a_Sink 
	) ;
    
    HRESULT STDMETHODCALLTYPE DeleteInstance ( 

		const BSTR a_ObjectPath ,
		long a_Flags ,
		IWbemContext *a_Context ,
		IWbemCallResult **a_CallResult
	) ;
    
    HRESULT STDMETHODCALLTYPE DeleteInstanceAsync ( 

		const BSTR a_ObjectPath,
		long a_Flags,
		IWbemContext *a_Context ,
		IWbemObjectSink *a_Sink
	) ;
    
    HRESULT STDMETHODCALLTYPE CreateInstanceEnum (

		const BSTR a_Class ,
		long a_Flags ,
		IWbemContext *a_Context ,
		IEnumWbemClassObject **a_Enum
	) ;
    
    HRESULT STDMETHODCALLTYPE CreateInstanceEnumAsync (

		const BSTR a_Class ,
		long a_Flags ,
		IWbemContext *a_Context ,
		IWbemObjectSink *a_Sink
	) ;
    
    HRESULT STDMETHODCALLTYPE ExecQuery ( 

		const BSTR a_QueryLanguage,
		const BSTR a_Query,
		long a_Flags ,
		IWbemContext *a_Context ,
		IEnumWbemClassObject **a_Enum
	) ;
    
    HRESULT STDMETHODCALLTYPE ExecQueryAsync (

		const BSTR a_QueryLanguage ,
		const BSTR a_Query ,
		long a_Flags ,
		IWbemContext *a_Context ,
		IWbemObjectSink *a_Sink
	) ;
    
    HRESULT STDMETHODCALLTYPE ExecNotificationQuery (

		const BSTR a_QueryLanguage ,
		const BSTR a_Query ,
		long a_Flags ,
		IWbemContext *a_Context ,
		IEnumWbemClassObject **a_Enum
	) ;
    
    HRESULT STDMETHODCALLTYPE ExecNotificationQueryAsync ( 

        const BSTR a_QueryLanguage ,
        const BSTR a_Query ,
        long a_Flags ,
        IWbemContext *a_Context ,
        IWbemObjectSink *a_Sink
	) ;
    
    HRESULT STDMETHODCALLTYPE ExecMethod (

        const BSTR a_ObjectPath ,
        const BSTR a_MethodName ,
        long a_Flags ,
        IWbemContext *a_Context ,
        IWbemClassObject *a_InParams ,
        IWbemClassObject **a_OutParams ,
        IWbemCallResult **a_CallResult
	) ;
    
    HRESULT STDMETHODCALLTYPE ExecMethodAsync ( 

		const BSTR a_ObjectPath ,
		const BSTR a_MethodName ,
		long a_Flags ,
		IWbemContext *a_Context ,
		IWbemClassObject *a_InParams ,
		IWbemObjectSink *a_Sink
	) ;

    HRESULT STDMETHODCALLTYPE GetProperty (

        long a_Flags ,
        const BSTR a_Locale ,
        const BSTR a_ClassMapping ,
        const BSTR a_InstanceMapping ,
        const BSTR a_PropertyMapping ,
        VARIANT *a_Value
	) ;
        
    HRESULT STDMETHODCALLTYPE PutProperty (

        long a_Flags ,
        const BSTR a_Locale ,
        const BSTR a_ClassMapping ,
        const BSTR a_InstanceMapping ,
        const BSTR a_PropertyMapping ,
        const VARIANT *a_Value
	) ;

	/* IWbemProviderInit methods */

	HRESULT STDMETHODCALLTYPE Initialize (

		LPWSTR a_User ,
		LONG a_Flags ,
		LPWSTR a_Namespace ,
		LPWSTR a_Locale ,
		IWbemServices *a_Core ,
		IWbemContext *a_Context ,
		IWbemProviderInitSink *a_Sink
	) ;

	// IWmi_UnInitialize members

	HRESULT STDMETHODCALLTYPE Shutdown (

		LONG a_Flags ,
		ULONG a_MaxMilliSeconds ,
		IWbemContext *a_Context
	) ; 
} ;


#endif // _CProvider_IWbemServices_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\provsubsys\example\include\guids.h ===
/*++

Copyright (C) 1996-2001 Microsoft Corporation

Module Name:

	Guids.h

Abstract:


History:

--*/

// {FE186DC7-0FE8-4b59-81CA-8D45E50D394C}
DEFINE_GUID(CLSID_WmiProvider, 
0xfe186dc7, 0xfe8, 0x4b59, 0x81, 0xca, 0x8d, 0x45, 0xe5, 0xd, 0x39, 0x4c);

// {8B86A619-76AA-4835-AED7-BB42ED4964E7}
DEFINE_GUID(CLSID_WmiClassProvider, 
0x8b86a619, 0x76aa, 0x4835, 0xae, 0xd7, 0xbb, 0x42, 0xed, 0x49, 0x64, 0xe7);

// {06A565F1-64A5-4ff7-BC5A-EBCFCB5DAB64}
DEFINE_GUID(CLSID_WmiTaskProvider, 
0x6a565f1, 0x64a5, 0x4ff7, 0xbc, 0x5a, 0xeb, 0xcf, 0xcb, 0x5d, 0xab, 0x64);

// {D884E55D-7E96-4707-9456-86ABC6DC6D7E}
DEFINE_GUID(CLSID_WmiEventProvider,  
0xd884e55d, 0x7e96, 0x4707, 0x94, 0x56, 0x86, 0xab, 0xc6, 0xdc, 0x6d, 0x7e);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\provsubsys\performance\include\cthread.h ===
/*++

Copyright (C) 1996-2001 Microsoft Corporation

Module Name:

	ProvFact.h

Abstract:


History:

--*/

#ifndef _CThread_H
#define _CThread_H

#include <Thread.h>

class ClientThread : public WmiThread < ULONG > 
{
private:

	WmiAllocator &m_Allocator ;

protected:

public:	/* Internal */

    ClientThread ( 

		WmiAllocator & a_Allocator
	) ;

    ~ClientThread () ;

	WmiStatusCode Initialize_Callback () ;

	WmiStatusCode UnInitialize_Callback () ;

};

#endif // _CThread_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\provsubsys\performance\client.cpp ===
/*++

Copyright (C) 1996-2001 Microsoft Corporation

Module Name:

	ProvFact.cpp

Abstract:


History:

--*/

#include "PreComp.h"
#include <stdio.h>

// this redefines the DEFINE_GUID() macro to do allocation.
//
#include <initguid.h>
#ifndef INITGUID
#define INITGUID
#endif

#include <wbemint.h>

#include <Allocator.h>
#include <HelperFuncs.h>
#include "Globals.h"
#include "Task.h"
#include "CThread.h"

/******************************************************************************
 *
 *	Name:
 *
 *	`
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT Process_MultiThread ( ULONG a_OperationCount )
{
	HRESULT t_Result = S_OK ;

	WmiAllocator t_Allocator ;
	WmiStatusCode t_StatusCode = t_Allocator.Initialize () ;
	if ( t_StatusCode == e_StatusCode_Success )
	{
		WmiStatusCode t_StatusCode = WmiThread <ULONG> :: Static_Initialize ( t_Allocator ) ;

#if 1
		WmiThread < ULONG > *t_Thread1 = new ClientThread ( t_Allocator ) ;
		if ( t_Thread1 )
		{
			t_Thread1->AddRef () ;

			t_StatusCode = t_Thread1->Initialize () ;

			Task_Execute t_Task1 ( t_Allocator , a_OperationCount ) ;
			t_Task1.Initialize () ;
			t_Thread1->EnQueue ( 0 , t_Task1 ) ;

			t_Task1.WaitInterruptable () ;

			HANDLE t_Thread1Handle = NULL ;

			BOOL t_Status = DuplicateHandle ( 

				GetCurrentProcess () ,
				t_Thread1->GetHandle () ,
				GetCurrentProcess () ,
				& t_Thread1Handle, 
				0 , 
				FALSE , 
				DUPLICATE_SAME_ACCESS
			) ;

			t_Thread1->Release () ;

			WaitForSingleObject ( t_Thread1Handle , INFINITE ) ;

			CloseHandle ( t_Thread1Handle ) ;
		}

#else
		WmiThread < ULONG > *t_Thread1 = new ClientThread ( t_Allocator ) ;
		if ( t_Thread1 )
		{
			t_Thread1->AddRef () ;

			t_StatusCode = t_Thread1->Initialize () ;

			WmiThread < ULONG > *t_Thread2 = new ClientThread ( t_Allocator ) ;
			if ( t_Thread2 )
			{
				t_Thread2->AddRef () ;

				t_StatusCode = t_Thread2->Initialize () ;

				Task_Execute t_Task1 ( t_Allocator , a_OperationCount ) ;
				t_Task1.Initialize () ;
				t_Thread1->EnQueue ( 0 , t_Task1 ) ;

				Task_Execute t_Task2 ( t_Allocator , a_OperationCount ) ;
				t_Task2.Initialize () ;
				t_Thread2->EnQueue ( 0 , t_Task2 ) ;

				t_Task1.WaitInterruptable () ;
				t_Task2.WaitInterruptable () ;

				HANDLE t_Thread1Handle = NULL ;

				BOOL t_Status = DuplicateHandle ( 

					GetCurrentProcess () ,
					t_Thread1->GetHandle () ,
					GetCurrentProcess () ,
					& t_Thread1Handle, 
					0 , 
					FALSE , 
					DUPLICATE_SAME_ACCESS
				) ;

				t_Thread1->Release () ;

				WaitForSingleObject ( t_Thread1Handle , INFINITE ) ;

				CloseHandle ( t_Thread1Handle ) ;

				HANDLE t_Thread2Handle = NULL ; 

				t_Status = DuplicateHandle ( 

					GetCurrentProcess () ,
					t_Thread2->GetHandle () ,
					GetCurrentProcess () ,
					& t_Thread2Handle, 
					0 , 
					FALSE , 
					DUPLICATE_SAME_ACCESS
				) ;

				t_Thread2->Release () ;
	
				WaitForSingleObject ( t_Thread2Handle , INFINITE ) ;

				CloseHandle ( t_Thread2Handle ) ;
			}
		}

#endif
		t_StatusCode = WmiThread <ULONG> :: Static_UnInitialize ( t_Allocator ) ;
	}	
	else
	{
		t_Result = WBEM_E_OUT_OF_MEMORY ;
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

void Process ( ULONG a_OperationCount )
{
	HRESULT t_Result = CoInitializeEx(0, COINIT_MULTITHREADED) ;
	if ( SUCCEEDED ( t_Result ) )
	{
		t_Result = CoInitializeSecurity (

			NULL, 
			-1, 
			NULL, 
			NULL,
			RPC_C_AUTHN_LEVEL_NONE,
			RPC_C_IMP_LEVEL_IMPERSONATE,
			NULL, 
			EOAC_NONE, 
			0
		);

		t_Result = Process_MultiThread ( a_OperationCount );

		CoUninitialize () ;
	}
	else
	{
		// fwprintf ( stderr , L"CoInitilize: %lx\n" , t_Result ) ;
	}
}


/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

EXTERN_C int __cdecl wmain (

	int argc ,
	char **argv 
)
{
	ULONG t_OperationCount = 2 ;

	Process ( t_OperationCount ) ;
	
	return 0 ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\provsubsys\performance\include\globals.h ===
/*++

Copyright (C) 1996-2001 Microsoft Corporation

Module Name:

	Globals.h

Abstract:


History:

--*/

#ifndef _Globals_H
#define _Globals_H

#include <Allocator.h>

#endif // _Globals_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\provsubsys\provider\classfac.cpp ===
#ifndef __CLASSFACTORY_CPP
#define __CLASSFACTORY_CPP

/*++

Copyright (C) 1996-2001 Microsoft Corporation

Module Name:

	ClassFac.cpp

Abstract:


History:

--*/

#include <Precomp.h>

// this redefines the DEFINE_GUID() macro to do allocation.
//
#include <initguid.h>
#ifndef INITGUID
#define INITGUID
#endif


#include "Globals.h"
#include "ClassFac.h"
#include "Service.h"

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

template <class Object,class ObjectInterface>
CProviderClassFactory <Object,ObjectInterface> :: CProviderClassFactory <Object,ObjectInterface> () : m_ReferenceCount ( 0 )
{
	InterlockedIncrement ( & Provider_Globals :: s_ObjectsInProgress ) ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

template <class Object,class ObjectInterface>
CProviderClassFactory <Object,ObjectInterface> :: ~CProviderClassFactory <Object,ObjectInterface> ()
{
	InterlockedDecrement ( & Provider_Globals :: s_ObjectsInProgress ) ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

template <class Object,class ObjectInterface>
STDMETHODIMP CProviderClassFactory <Object,ObjectInterface> :: QueryInterface (

	REFIID iid , 
	LPVOID FAR *iplpv 
) 
{
	*iplpv = NULL ;

	if ( iid == IID_IUnknown )
	{
		*iplpv = ( LPVOID ) this ;
	}
	else if ( iid == IID_IClassFactory )
	{
		*iplpv = ( LPVOID ) ( IClassFactory * ) this ;		
	}	

	if ( *iplpv )
	{
		( ( LPUNKNOWN ) *iplpv )->AddRef () ;

		return ResultFromScode ( S_OK ) ;
	}
	else
	{
		return ResultFromScode ( E_NOINTERFACE ) ;
	}
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

template <class Object,class ObjectInterface>
STDMETHODIMP_( ULONG ) CProviderClassFactory <Object,ObjectInterface> :: AddRef ()
{
	return InterlockedIncrement ( & m_ReferenceCount ) ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

template <class Object,class ObjectInterface>
STDMETHODIMP_(ULONG) CProviderClassFactory <Object,ObjectInterface> :: Release ()
{
	LONG t_Reference ;
	if ( ( t_Reference = InterlockedDecrement ( & m_ReferenceCount ) ) == 0 )
	{
		delete this ;
		return 0 ;
	}
	else
	{
		return t_Reference ;
	}
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

template <class Object,class ObjectInterface>
STDMETHODIMP CProviderClassFactory <Object,ObjectInterface> :: CreateInstance (

	LPUNKNOWN pUnkOuter ,
	REFIID riid ,
	LPVOID FAR * ppvObject
)
{
	HRESULT status = S_OK ;

	if ( pUnkOuter )
	{
		status = CLASS_E_NOAGGREGATION ;
	}
	else
	{
		IUnknown *lpunk = ( ObjectInterface * ) new Object ( *Provider_Globals :: s_Allocator );
		if ( lpunk == NULL )
		{
			status = E_OUTOFMEMORY ;
		}
		else
		{
			status = lpunk->QueryInterface ( riid , ppvObject ) ;
			if ( FAILED ( status ) )
			{
				delete lpunk ;
			}
			else
			{
			}
		}			
	}

	return status ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

template <class Object,class ObjectInterface>
STDMETHODIMP CProviderClassFactory <Object,ObjectInterface> :: LockServer ( BOOL fLock )
{
/* 
 * Place code in critical section
 */

	if ( fLock )
	{
		InterlockedIncrement ( & Provider_Globals :: s_LocksInProgress ) ;
	}
	else
	{
		InterlockedDecrement ( & Provider_Globals :: s_LocksInProgress ) ;
	}

	return S_OK	;
}

#endif __CLASSFACTORY_CPP
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\provsubsys\provider\globals.cpp ===
/*++

Copyright (C) 1996-2001 Microsoft Corporation

Module Name:

	Globals.cpp

Abstract:


History:

--*/

#include <PreComp.h>
#include <wbemprov.h>

#include <initguid.h>
#ifndef INITGUID
#define INITGUID
#endif

#include <Exception.h>
#include <Thread.h>

#include "Globals.h"

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

WmiAllocator *Provider_Globals :: s_Allocator = NULL ;

LONG Provider_Globals :: s_LocksInProgress ;
LONG Provider_Globals :: s_ObjectsInProgress ;

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT Provider_Globals :: Global_Startup ()
{
	HRESULT t_Result = S_OK ;

	if ( ! s_Allocator )
	{
/*
 *	Use the global process heap for this particular boot operation
 */

		WmiAllocator t_Allocator ;
		WmiStatusCode t_StatusCode = t_Allocator.New (

			( void ** ) & s_Allocator ,
			sizeof ( WmiAllocator ) 
		) ;

		if ( t_StatusCode == e_StatusCode_Success )
		{
			:: new ( ( void * ) s_Allocator ) WmiAllocator ;

			t_StatusCode = s_Allocator->Initialize () ;
			if ( t_StatusCode != e_StatusCode_Success )
			{
				t_Result = WBEM_E_OUT_OF_MEMORY ;
			}
		}
		else
		{
			t_Result = WBEM_E_OUT_OF_MEMORY ;
		}
	}

	if ( SUCCEEDED ( t_Result ) )
	{
		WmiStatusCode t_StatusCode = WmiThread <ULONG> :: Static_Initialize ( *s_Allocator ) ;
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT Provider_Globals :: Global_Shutdown ()
{
	HRESULT t_Result = S_OK ;

	WmiStatusCode t_StatusCode = WmiThread <ULONG> :: Static_UnInitialize ( *s_Allocator ) ;

	if ( s_Allocator )
	{
/*
 *	Use the global process heap for this particular boot operation
 */

		WmiAllocator t_Allocator ;
		WmiStatusCode t_StatusCode = t_Allocator.Delete (

			( void * ) s_Allocator
		) ;

		if ( t_StatusCode != e_StatusCode_Success )
		{
			t_Result = WBEM_E_OUT_OF_MEMORY ;
		}
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT Provider_Globals :: CreateInstance ( 

	const CLSID &a_ReferenceClsid ,
	LPUNKNOWN a_OuterUnknown ,
	const DWORD &a_ClassContext ,
	const UUID &a_ReferenceInterfaceId ,
	void **a_ObjectInterface
)
{
	HRESULT t_Result = S_OK ;

#if 1
	 t_Result = CoCreateInstance (
  
		a_ReferenceClsid ,
		a_OuterUnknown ,
		a_ClassContext ,
		a_ReferenceInterfaceId ,
		( void ** )  a_ObjectInterface
	);

#else

	COAUTHIDENTITY t_AuthenticationIdentity ;
	ZeroMemory ( & t_AuthenticationIdentity , sizeof ( t_AuthenticationIdentity ) ) ;

	t_AuthenticationIdentity.User = NULL ; 
	t_AuthenticationIdentity.UserLength = 0 ;
	t_AuthenticationIdentity.Domain = NULL ; 
	t_AuthenticationIdentity.DomainLength = 0 ; 
	t_AuthenticationIdentity.Password = NULL ; 
	t_AuthenticationIdentity.PasswordLength = 0 ; 
	t_AuthenticationIdentity.Flags = SEC_WINNT_AUTH_IDENTITY_UNICODE ; 

	COAUTHINFO t_AuthenticationInfo ;
	ZeroMemory ( & t_AuthenticationInfo , sizeof ( t_AuthenticationInfo ) ) ;

    t_AuthenticationInfo.dwAuthnSvc = RPC_C_AUTHN_DEFAULT ;
    t_AuthenticationInfo.dwAuthzSvc = RPC_C_AUTHZ_DEFAULT ;
    t_AuthenticationInfo.pwszServerPrincName = NULL ;
    t_AuthenticationInfo.dwAuthnLevel = RPC_C_AUTHN_LEVEL_CONNECT ;
    t_AuthenticationInfo.dwImpersonationLevel = RPC_C_IMP_LEVEL_IMPERSONATE  ;
    t_AuthenticationInfo.dwCapabilities = EOAC_NONE ;
    t_AuthenticationInfo.pAuthIdentityData = NULL ;

	COSERVERINFO t_ServerInfo ;
	ZeroMemory ( & t_ServerInfo , sizeof ( t_ServerInfo ) ) ;

	t_ServerInfo.pwszName = NULL ;
    t_ServerInfo.dwReserved2 = 0 ;
    t_ServerInfo.pAuthInfo = & t_AuthenticationInfo ;

	IClassFactory *t_ClassFactory = NULL ;

	t_Result = CoGetClassObject (

		a_ReferenceClsid ,
		a_ClassContext ,
		& t_ServerInfo ,
		IID_IClassFactory ,
		( void ** )  & t_ClassFactory
	) ;
 
	if ( SUCCEEDED ( t_Result ) )
	{
		t_Result = t_ClassFactory->CreateInstance (

			a_OuterUnknown ,
			a_ReferenceInterfaceId ,
			a_ObjectInterface 
		);	

		t_ClassFactory->Release () ;
	}

#endif

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

void * __cdecl operator new ( size_t a_Size )
{
    void *t_Ptr ;
	WmiStatusCode t_StatusCode = Provider_Globals :: s_Allocator->New (

		( void ** ) & t_Ptr ,
		a_Size
	) ;

	if ( t_StatusCode != e_StatusCode_Success )
    {
        throw Wmi_Heap_Exception (

			Wmi_Heap_Exception::HEAP_ERROR::E_ALLOCATION_ERROR
		) ;
    }

    return t_Ptr ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

void __cdecl operator delete ( void *a_Ptr )
{
    if ( a_Ptr )
    {
		WmiStatusCode t_StatusCode = Provider_Globals :: s_Allocator->Delete (

			( void * ) a_Ptr
		) ;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\provsubsys\overlappedio\filerep.cpp ===
/*++

Copyright (C) 1999-2001 Microsoft Corporation

Module Name:

Abstract:

History:

--*/



/* 
 *	Class:
 *
 *		WmiFileBlockAllocator
 *
 *	Description:
 *
 *		Provides abstraction above heap allocation functions
 *
 *	Version:
 *
 *		Initial
 *
 *	Last Changed:
 *
 *		See Source Depot for change history
 *
 */

#include <precomp.h>
#include <windows.h>
#include <objbase.h>
#include <stdio.h>
#include <typeinfo.h>
#include <wbemcli.h>

#include <IoScheduler.h>
#include <FileRep.h>

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

CFileOperation :: CFileOperation (

) :	m_ReferenceCount ( 0 ) , 
	m_Status ( 0 ) ,
	m_WaitHandle ( NULL )
{
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

CFileOperation :: ~CFileOperation () 
{
	UnInitialize () ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

WmiStatusCode CFileOperation :: Initialize ()
{
	WmiStatusCode t_StatusCode = e_StatusCode_Success ;

	m_WaitHandle = CreateEvent ( NULL , FALSE , FALSE , NULL ) ;
	if ( m_WaitHandle == NULL )
	{
		t_StatusCode = e_StatusCode_OutOfResources ;
	}

	return t_StatusCode ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

WmiStatusCode CFileOperation :: UnInitialize ()
{
	WmiStatusCode t_StatusCode = e_StatusCode_Success ;

	if ( m_WaitHandle )
	{
		CloseHandle ( m_WaitHandle ) ;
		m_WaitHandle = NULL ;
	}

	return t_StatusCode ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

ULONG CFileOperation :: AddRef () 
{
	return InterlockedIncrement ( & m_ReferenceCount ) ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

ULONG CFileOperation :: Release () 
{
	ULONG t_ReferenceCount = InterlockedDecrement ( & m_ReferenceCount ) ;
	if ( t_ReferenceCount == 0 )
	{
		delete this ;
	}

	return t_ReferenceCount ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

DWORD CFileOperation :: Wait ( DWORD a_Timeout )
{
	return WaitForSingleObject ( m_WaitHandle , a_Timeout ) ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

void CFileOperation :: Operation ( DWORD a_Status , BYTE *a_OperationBytes , DWORD a_Bytes )
{
	m_Status = a_Status ;
	SetEvent ( m_WaitHandle ) ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

CFileRepository :: CFileRepository (

	WmiAllocator &a_Allocator 

) : m_Allocator ( a_Allocator ) ,
	m_ReaderWriter ( 1 << 16 ) ,
	m_ThreadPool ( NULL ) ,
	m_BlockAllocator ( NULL ) ,
	m_ReferenceCount ( 0 ) , 
	m_Status ( 0 ) ,
	m_WaitHandle ( NULL )
{
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

CFileRepository :: ~CFileRepository () 
{
	UnInitialize () ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

WmiStatusCode CFileRepository :: Initialize ()
{
	WmiStatusCode t_StatusCode = e_StatusCode_Success ;

	m_WaitHandle = CreateEvent ( NULL , FALSE , FALSE , NULL ) ;
	if ( m_WaitHandle == NULL )
	{
		t_StatusCode = e_StatusCode_OutOfResources ;
	}

	if ( t_StatusCode == e_StatusCode_Success ) 
	{
		t_StatusCode = m_ReaderWriter.Initialize () ;
	}

	if ( t_StatusCode == e_StatusCode_Success ) 
	{
		m_ThreadPool = new WmiThreadPool ( m_Allocator ) ;
		if ( m_ThreadPool )
		{
			m_ThreadPool->AddRef () ;

			t_StatusCode = m_ThreadPool->Initialize () ;
			if ( t_StatusCode == e_StatusCode_Success ) 
			{
				m_BlockAllocator = new WmiIoScheduler ( 

					m_Allocator , 
					m_ThreadPool , 
					L"c:\\temp\\repository.rep" , 
					0 , 
					0
				) ;

				if ( m_BlockAllocator )
				{
					m_BlockAllocator->AddRef () ;

					t_StatusCode = m_BlockAllocator->Initialize () ;
				}
			}
		}
		else
		{
			t_StatusCode = e_StatusCode_OutOfMemory ;
		}
	}

	if ( t_StatusCode == e_StatusCode_Success )
	{
		t_StatusCode = ReadFileHeader () ;
		switch ( t_StatusCode )
		{
			case e_StatusCode_Success:
			{
				if ( m_FileHeader.m_Header.m_Version != 1 )
				{
					t_StatusCode = e_StatusCode_Failed ;
				}
			}
			break; 

			case e_StatusCode_NotFound:
			{
				t_StatusCode = WriteFileHeader () ;
			}
			break ;

			default:	
			{
			}
			break ;
		}
	}

	return t_StatusCode ;
}


/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

WmiStatusCode CFileRepository :: ReadFileHeader ()
{
	WmiStatusCode t_StatusCode = e_StatusCode_Success ;

	CFileOperation *t_FileOperation = new CFileOperation ;
	if ( t_FileOperation )
	{
		t_FileOperation->AddRef () ;

		t_StatusCode = t_FileOperation->Initialize () ;
		if ( t_StatusCode == e_StatusCode_Success )
		{
			ZeroMemory ( & m_FileHeader.m_Block , sizeof ( m_FileHeader.m_Block ) ) ;

			t_StatusCode = m_BlockAllocator->Read ( 

				t_FileOperation ,
				0 ,
				m_FileHeader.m_Block , 
				sizeof ( m_FileHeader.m_Block )
			) ;

			if ( t_StatusCode == e_StatusCode_Success )
			{
				t_FileOperation->Wait ( INFINITE ) ;
				if ( t_FileOperation->GetStatus () != 0 )
				{
					if ( t_FileOperation->GetStatus () == 0x80000007 )
					{
						t_StatusCode = e_StatusCode_NotFound ; 
					}
				}
			}
		}

		t_FileOperation->Release () ;
	}

	return t_StatusCode ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

WmiStatusCode CFileRepository :: WriteFileHeader ()
{
	WmiStatusCode t_StatusCode = e_StatusCode_Success ;

	CFileOperation *t_FileOperation = new CFileOperation ;
	if ( t_FileOperation )
	{
		t_FileOperation->AddRef () ;

		t_StatusCode = t_FileOperation->Initialize () ;
		if ( t_StatusCode == e_StatusCode_Success )
		{
#if 0
			LARGE_INTEGER t_Integer ;
			t_Integer.QuadPart = c_WmiFileBlockSize * 2 ;
			SetFilePointerEx ( 

				m_BlockAllocator->GetFileHandle () ,
				t_Integer ,
				NULL ,
				FILE_END 
			) ;

			SetEndOfFile ( m_BlockAllocator->GetFileHandle () ) ;

			m_FileHeader.m_Header.m_Version = 1 ;
			m_FileHeader.m_Header.m_FileHeaderChain = 0 ;
			m_FileHeader.m_Header.m_FreeBlockChain = c_WmiFileBlockSize ;
			m_FileHeader.m_Header.m_EndOnFileOffSet = c_WmiFileBlockSize * 2 ;
			wcscpy ( m_FileHeader.m_Header.m_Description , L"Microsoft Corporation" ) ;

#else
			m_FileHeader.m_Header.m_Version = 1 ;
			m_FileHeader.m_Header.m_FileHeaderChain = 0 ;
			m_FileHeader.m_Header.m_FreeBlockChain = 0 ;
			m_FileHeader.m_Header.m_EndOnFileOffSet = c_WmiFileBlockSize ;
			wcscpy ( m_FileHeader.m_Header.m_Description , L"Microsoft Corporation" ) ;

#endif
			t_StatusCode = m_BlockAllocator->Write ( 

				t_FileOperation ,
				0 ,
				m_FileHeader.m_Block , 
				sizeof ( m_FileHeader.m_Block )
			) ;

			if ( t_StatusCode == e_StatusCode_Success )
			{
				t_FileOperation->Wait ( INFINITE ) ;
				if ( t_FileOperation->GetStatus () != 0 )
				{
					t_StatusCode = Win32ToApi ( t_FileOperation->GetStatus () ) ;
				}
			}
		}

		t_FileOperation->Release () ;
	}

	return t_StatusCode ;
}

#if 0 
/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

WmiStatusCode CFileRepository :: ReadChainHeader ()
{
	WmiStatusCode t_StatusCode = e_StatusCode_Success ;

	CFileOperation *t_FileOperation = new CFileOperation ;
	if ( t_FileOperation )
	{
		t_FileOperation->AddRef () ;

		t_StatusCode = t_FileOperation->Initialize () ;
		if ( t_StatusCode == e_StatusCode_Success )
		{
			ZeroMemory ( & m_ChainHeader.m_Block , sizeof ( m_ChainHeader.m_Block ) ) ;

			t_StatusCode = m_BlockAllocator->Read ( 

				t_FileOperation ,
				m_FileHeader.m_FreeBlockChain ,
				m_ChainHeader.m_Block , 
				sizeof ( m_ChainHeader.m_Block )
			) ;

			if ( t_StatusCode == e_StatusCode_Success )
			{
				t_FileOperation->Wait ( INFINITE ) ;
				if ( t_FileOperation->GetStatus () != 0 )
				{
					if ( t_FileOperation->GetStatus () == 0x80000007 )
					{
						t_StatusCode = e_StatusCode_NotFound ; 
					}
				}
			}
		}

		t_FileOperation->Release () ;
	}

	return t_StatusCode ;
}

#endif

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

WmiStatusCode CFileRepository :: UnInitialize ()
{
	WmiStatusCode t_StatusCode = e_StatusCode_Success ;

	if ( m_WaitHandle )
	{
		CloseHandle ( m_WaitHandle ) ;
		m_WaitHandle = NULL ;
	}

	if ( m_ThreadPool )
	{
		m_ThreadPool->Release () ;
		m_ThreadPool = NULL ;
	}

	if ( m_BlockAllocator )
	{
		m_BlockAllocator->Release () ;
		m_BlockAllocator = NULL ;
	}

	return t_StatusCode ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

ULONG CFileRepository :: AddRef () 
{
	return InterlockedIncrement ( & m_ReferenceCount ) ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

ULONG CFileRepository :: Release () 
{
	ULONG t_ReferenceCount = InterlockedDecrement ( & m_ReferenceCount ) ;
	if ( t_ReferenceCount == 0 )
	{
		delete this ;
	}

	return t_ReferenceCount ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

DWORD CFileRepository :: Wait ( DWORD a_Timeout )
{
	return WaitForSingleObject ( m_WaitHandle , a_Timeout ) ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

WmiStatusCode CFileRepository :: Read ( 

	CFileOperation *&a_OperationFunction ,
	WmiFileOffSet a_OffSet ,
	BYTE *a_ReadBytes ,
	DWORD a_Bytes
)
{
	WmiStatusCode t_StatusCode = e_StatusCode_Success ;

	a_OperationFunction = new CFileOperation ;
	if ( a_OperationFunction )
	{
		a_OperationFunction->AddRef () ;

		t_StatusCode = a_OperationFunction->Initialize () ;
		if ( t_StatusCode == e_StatusCode_Success )
		{
			t_StatusCode = m_BlockAllocator->Read ( 

				a_OperationFunction ,
				a_OffSet ,
				a_ReadBytes , 
				a_Bytes
			) ;
		}
	}

	return t_StatusCode ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

WmiStatusCode CFileRepository :: Write (

	CFileOperation *&a_OperationFunction ,
	WmiFileOffSet a_OffSet ,
	BYTE *a_WriteBytes ,
	DWORD a_Bytes
)
{
	WmiStatusCode t_StatusCode = e_StatusCode_Success ;

	a_OperationFunction = new CFileOperation ;
	if ( a_OperationFunction )
	{
		a_OperationFunction->AddRef () ;

		t_StatusCode = a_OperationFunction->Initialize () ;
		if ( t_StatusCode == e_StatusCode_Success )
		{
			t_StatusCode = m_BlockAllocator->Write ( 

				a_OperationFunction ,
				a_OffSet ,
				a_WriteBytes , 
				a_Bytes
			) ;
		}
	}

	return t_StatusCode ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

WmiStatusCode CFileRepository :: Lock (

	CFileOperation *&a_OperationFunction ,
	WmiFileOffSet a_OffSet ,
	WmiFileOffSet a_OffSetSize 
)
{
	WmiStatusCode t_StatusCode = e_StatusCode_Success ;

	a_OperationFunction = new CFileOperation ;
	if ( a_OperationFunction )
	{
		a_OperationFunction->AddRef () ;

		t_StatusCode = a_OperationFunction->Initialize () ;
		if ( t_StatusCode == e_StatusCode_Success )
		{
			t_StatusCode = m_BlockAllocator->UnLock ( 

				a_OperationFunction ,
				a_OffSet ,
				a_OffSetSize
			) ;
		}
	}

	return t_StatusCode ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

WmiStatusCode CFileRepository :: UnLock (

	CFileOperation *&a_OperationFunction ,
	WmiFileOffSet a_OffSet ,
	WmiFileOffSet a_OffSetSize 
)
{
	WmiStatusCode t_StatusCode = e_StatusCode_Success ;

	a_OperationFunction = new CFileOperation ;
	if ( a_OperationFunction )
	{
		a_OperationFunction->AddRef () ;

		t_StatusCode = a_OperationFunction->Initialize () ;
		if ( t_StatusCode == e_StatusCode_Success )
		{
			t_StatusCode = m_BlockAllocator->UnLock ( 

				a_OperationFunction ,
				a_OffSet ,
				a_OffSetSize
			) ;
		}
	}

	return t_StatusCode ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

WmiStatusCode CFileRepository :: AllocBlock ( WmiFileOffSet &a_OffSet )
{
	WmiStatusCode t_StatusCode = e_StatusCode_Success ;

	m_ReaderWriter.EnterWrite () ;
	if ( m_FileHeader.m_Header.m_FreeBlockChain )
	{
		
	}
	else
	{
	}

	m_ReaderWriter.LeaveWrite () ;

	return t_StatusCode ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

WmiStatusCode CFileRepository :: FreeBlock ( WmiFileOffSet a_OffSet )
{
	WmiStatusCode t_StatusCode = e_StatusCode_Success ;

	m_ReaderWriter.EnterWrite () ;
	m_ReaderWriter.LeaveWrite () ;

	return t_StatusCode ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\provsubsys\performance\task.cpp ===
/*++

Copyright (C) 1996-2001 Microsoft Corporation

Module Name:

	ProvFact.cpp

Abstract:


History:

--*/

#include "PreComp.h"
#include <wbemint.h>
#include <wmiutils.h>

#include "Globals.h"
#include "Task.h"
#include "Service.h"

#if 0
#define SAMPLE_NAMESPACE L"Root\\Cimv2"
//#define SAMPLE_CLASS L"RecursiveSample"
//#define SAMPLE_CLASS L"Sample"
#define SAMPLE_CLASS L"Win32_Process"
#else
#define SAMPLE_NAMESPACE L"Root\\Default"
#define SAMPLE_CLASS L"__Win32Provider"
#endif

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT WmiSetSecurity ( IWbemServices *a_Service ) 
{
	IClientSecurity *t_Security = NULL ;
	HRESULT t_Result = a_Service->QueryInterface ( IID_IClientSecurity , ( void ** ) & t_Security ) ;
	if ( SUCCEEDED ( t_Result ) )
	{
		t_Result = t_Security->SetBlanket ( 

			a_Service , 
			RPC_C_AUTHN_WINNT, 
			RPC_C_AUTHZ_NONE, 
			NULL,
			RPC_C_AUTHN_LEVEL_CONNECT , 
			RPC_C_IMP_LEVEL_IMPERSONATE, 
			NULL,
			EOAC_NONE
		) ;

		t_Security->Release () ;
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT WmiCompileFile (

	LPWSTR a_MofFile ,
	LPWSTR a_Namespace ,
	LPWSTR a_User,
	LPWSTR a_Authority ,
	LPWSTR a_Password ,
	LONG a_OptionFlags ,
	LONG a_ClassFlags,
	LONG a_InstanceFlags
)
{
	IMofCompiler *t_Compiler = NULL ;

	HRESULT t_Result = CoCreateInstance (
  
		CLSID_MofCompiler ,
		NULL ,
		CLSCTX_INPROC_SERVER | CLSCTX_LOCAL_SERVER ,
		IID_IMofCompiler ,
		( void ** )  & t_Compiler 
	) ;

	if ( SUCCEEDED ( t_Result ) )
	{
		WBEM_COMPILE_STATUS_INFO t_CompileStatus ;
 
		t_Result = t_Compiler->CompileFile (

			a_MofFile ,
			a_Namespace ,
			a_User,
			a_Authority ,
			a_Password ,
			a_OptionFlags ,
			a_ClassFlags,
			a_InstanceFlags,
			& t_CompileStatus
		) ;

		t_Compiler->Release () ;
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CreateContext ( IWbemServices *&a_Context )
{
	HRESULT t_Result = CoCreateInstance (
  
		CLSID_WbemContext ,
		NULL ,
		CLSCTX_INPROC_SERVER | CLSCTX_LOCAL_SERVER ,
		IID_IWbemContext ,
		( void ** )  & a_Context 
	) ;

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT WmiConnect ( LPWSTR a_Namespace , IWbemServices *&a_Service )
{
	IWbemLocator *t_Locator = NULL ;

	HRESULT t_Result = CoCreateInstance (
  
		CLSID_WbemLocator ,
		NULL ,
		CLSCTX_INPROC_SERVER | CLSCTX_LOCAL_SERVER ,
		IID_IUnknown ,
		( void ** )  & t_Locator
	);

	if ( SUCCEEDED ( t_Result ) )
	{
		BSTR t_Namespace = SysAllocString ( a_Namespace ) ;

		t_Result = t_Locator->ConnectServer (

			t_Namespace ,
			NULL ,
			NULL,
			NULL ,
			0 ,
			NULL,
			NULL,
			&a_Service
		) ;

		SysFreeString ( t_Namespace ) ;

		if ( SUCCEEDED ( t_Result ) )
		{
			t_Result = WmiSetSecurity ( a_Service ) ;
		}

		t_Locator->Release () ;
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

Task_Execute :: Task_Execute (

	WmiAllocator &a_Allocator ,
	ULONG a_Count

) : WmiTask < ULONG > ( a_Allocator ) ,
	m_Allocator ( a_Allocator ) ,
	m_WmiService ( NULL ) ,
	m_ProviderService ( NULL ) ,
	m_Count ( a_Count ) ,
	m_Index ( 0 ) ,
	m_Result ( S_OK ) 
{
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

Task_Execute :: ~Task_Execute ()
{
	if ( m_WmiService ) 
	{
		m_WmiService->Release () ;
	}

	if ( m_ProviderService ) 
	{
		m_ProviderService->Release () ;
	}
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT Task_Execute :: GetClass (

	IWbemServices *a_Service ,
	LPCWSTR a_Class
)
{
	HRESULT t_Result = S_OK ;

	LPWSTR t_ObjectPath = NULL ;

	t_Result = WmiHelper :: ConcatenateStrings ( 

		4 , 
		& t_ObjectPath , 
		L"\\\\.\\" ,
		SAMPLE_NAMESPACE,
		":" , 
		a_Class
	) ;

	if ( SUCCEEDED ( t_Result ) )
	{
		IWbemClassObject *t_Class = NULL ;

		t_Result = a_Service->GetObject ( 

			t_ObjectPath ,
			0 ,
			NULL , 
			& t_Class , 
			NULL 
		) ;

		SysFreeString ( t_ObjectPath ) ;
	
		if ( SUCCEEDED ( t_Result ) )
		{
			t_Class->Release () ;
		}
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT Task_Execute :: GetInstance (

	IWbemServices *a_Service ,
	LPCWSTR a_Instance
)
{
	HRESULT t_Result = S_OK ;

	LPWSTR t_ObjectPath = NULL ;

	t_Result = WmiHelper :: ConcatenateStrings ( 

		4 , 
		& t_ObjectPath , 
		L"\\\\.\\" ,
		SAMPLE_NAMESPACE,
		":" , 
		a_Instance
	) ;

	if ( SUCCEEDED ( t_Result ) )
	{
		IWbemClassObject *t_Instance = NULL ;
					
		t_Result = a_Service->GetObject ( 

			t_ObjectPath ,
			0 ,
			NULL , 
			& t_Instance , 
			NULL 
		) ;

		SysFreeString ( t_ObjectPath ) ;
	
		if ( SUCCEEDED ( t_Result ) )
		{
			t_Instance->Release () ;
		}
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT Task_Execute :: ExecQueryASync (

	IWbemServices *a_Service ,
	LPCWSTR a_Class
)
{
	HRESULT t_Result = S_OK ;

	CProviderSink *t_ProviderSink = new CProviderSink ;
	if ( t_ProviderSink )
	{
		t_ProviderSink->AddRef () ;

		BSTR t_Query = SysAllocString ( L"Select * from win32_process" ) ;
		BSTR t_QueryLanguage = SysAllocString ( L"WQL" ) ;

		t_Result = a_Service->ExecQueryAsync (

			t_QueryLanguage ,
			t_Query ,
			0 ,
			NULL ,
			t_ProviderSink
		) ;

		SysFreeString ( t_Query ) ;
		SysFreeString ( t_QueryLanguage ) ;

		if ( SUCCEEDED ( t_Result ) )
		{
			t_ProviderSink->Wait () ;
			if ( FAILED( t_ProviderSink->GetResult () ) )
			{
				OutputDebugString ( L"FAILED" ) ;
			}
		}

		t_ProviderSink->Release () ;
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT Task_Execute :: CreateInstanceEnumASync (

	IWbemServices *a_Service ,
	LPCWSTR a_Class
)
{
	HRESULT t_Result = S_OK ;

	CProviderSink *t_ProviderSink = new CProviderSink ;
	if ( t_ProviderSink )
	{
		t_ProviderSink->AddRef () ;

		BSTR t_Class = SysAllocString ( a_Class ) ;

		t_Result = a_Service->CreateInstanceEnumAsync (

			t_Class ,
			0 ,
			NULL ,
			t_ProviderSink
		) ;

		SysFreeString ( t_Class ) ;

		if ( SUCCEEDED ( t_Result ) )
		{
			t_ProviderSink->Wait () ;
			if ( FAILED( t_ProviderSink->GetResult () ) )
			{
				OutputDebugString ( L"FAILED" ) ;
			}
		}

		t_ProviderSink->Release () ;
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT Task_Execute :: CreateInstanceEnumSync (

	IWbemServices *a_Service ,
	LPCWSTR a_Class ,
	ULONG a_BatchSize 
)
{
	HRESULT t_Result = S_OK ;

	BSTR t_Class = SysAllocString ( a_Class ) ;

	IEnumWbemClassObject *t_InstanceObjectEnum = NULL ;

	t_Result = a_Service->CreateInstanceEnum (

		t_Class ,
		0 ,
		NULL ,
		& t_InstanceObjectEnum
	) ;

	SysFreeString ( t_Class ) ;

	if ( SUCCEEDED ( t_Result ) )
	{
		IWbemClassObject **t_ClassObjectArray = new IWbemClassObject * [ a_BatchSize ] ;
		if ( t_ClassObjectArray )
		{
			ULONG t_ObjectCount = 0 ;

			t_InstanceObjectEnum->Reset () ;
			while ( SUCCEEDED ( t_Result ) && ( t_InstanceObjectEnum->Next ( WBEM_INFINITE , a_BatchSize , t_ClassObjectArray , &t_ObjectCount ) == WBEM_NO_ERROR ) )
			{
				for ( ULONG t_Index = 0 ; t_Index < t_ObjectCount ; t_Index ++ )
				{
					t_ClassObjectArray [ t_Index ]->Release () ;
				}
			}

			delete [] t_ClassObjectArray ;
		}

		t_InstanceObjectEnum->Release () ;
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT Task_Execute :: CreateInstanceEnumForwardSync (

	IWbemServices *a_Service ,
	LPCWSTR a_Class ,
	ULONG a_BatchSize 
)
{
	HRESULT t_Result = S_OK ;

	BSTR t_Class = SysAllocString ( a_Class ) ;

	IEnumWbemClassObject *t_InstanceObjectEnum = NULL ;

	t_Result = a_Service->CreateInstanceEnum (

		t_Class ,
		WBEM_FLAG_FORWARD_ONLY ,
		NULL ,
		& t_InstanceObjectEnum
	) ;

	SysFreeString ( t_Class ) ;

	if ( SUCCEEDED ( t_Result ) )
	{
		IWbemClassObject **t_ClassObjectArray = new IWbemClassObject * [ a_BatchSize ] ;
		if ( t_ClassObjectArray )
		{
			ULONG t_ObjectCount = 0 ;

			t_InstanceObjectEnum->Reset () ;
			while ( SUCCEEDED ( t_Result ) && ( t_InstanceObjectEnum->Next ( WBEM_INFINITE , a_BatchSize , t_ClassObjectArray , &t_ObjectCount ) == WBEM_NO_ERROR ) )
			{
				for ( ULONG t_Index = 0 ; t_Index < t_ObjectCount ; t_Index ++ )
				{
					t_ClassObjectArray [ t_Index ]->Release () ;
				}
			}

			delete [] t_ClassObjectArray;
		}

		t_InstanceObjectEnum->Release () ;
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT Task_Execute :: CreateInstanceEnumSemiSync (

	IWbemServices *a_Service ,
	LPCWSTR a_Class ,
	ULONG a_BatchSize 
)
{
	HRESULT t_Result = S_OK ;

	BSTR t_Class = SysAllocString ( a_Class ) ;

	IEnumWbemClassObject *t_InstanceObjectEnum = NULL ;

	t_Result = a_Service->CreateInstanceEnum (

		t_Class ,
		WBEM_FLAG_RETURN_IMMEDIATELY ,
		NULL ,
		& t_InstanceObjectEnum
	) ;

	SysFreeString ( t_Class ) ;

	if ( SUCCEEDED ( t_Result ) )
	{
		IWbemClassObject *t_ClassObject = NULL ;
		ULONG t_ObjectCount = 0 ;

		t_InstanceObjectEnum->Reset () ;

		CProviderSink *t_ProviderSink = new CProviderSink ;
		if ( t_ProviderSink )
		{
			t_ProviderSink->AddRef () ;

			while ( t_ProviderSink && SUCCEEDED ( t_Result ) && ( t_InstanceObjectEnum->NextAsync ( a_BatchSize  , t_ProviderSink ) == WBEM_NO_ERROR ) )
			{
				t_ProviderSink->Wait () ;
				if ( FAILED( t_ProviderSink->GetResult () ) )
				{
					OutputDebugString ( L"FAILED" ) ;
				}

				t_ProviderSink->Release () ;

				t_ProviderSink = new CProviderSink ;
				if ( t_ProviderSink )
				{
					t_ProviderSink->AddRef () ;
				}
			}

			if ( t_ProviderSink )
			{
				t_ProviderSink->Release () ;
			}
		}

		t_InstanceObjectEnum->Release () ;
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT Task_Execute :: Function_ASync ()
{
	ULONG t_TickCount2 = GetTickCount () ;

	for ( ULONG t_Index2 = 0 ; t_Index2 < 100 ; t_Index2 ++ )
	{
		CreateInstanceEnumASync ( m_WmiService , L"Win32_Process2" ) ;
	}

	ULONG t_TickCount3 = GetTickCount () ;

	for ( ULONG t_Index3 = 0 ; t_Index3 < 100 ; t_Index3 ++ )
	{
		CreateInstanceEnumASync ( m_WmiService , L"Win32_Process3" ) ;
	}

	ULONG t_TickCount4 = GetTickCount () ;

	for ( ULONG t_Index4 = 0 ; t_Index4 < 100 ; t_Index4 ++ )
	{
		CreateInstanceEnumASync ( m_WmiService , L"Win32_Process4" ) ;
	}

	ULONG t_TickCount5 = GetTickCount () ;

	for ( ULONG t_Index5 = 0 ; t_Index5 < 100 ; t_Index5 ++ )
	{
		CreateInstanceEnumASync ( m_WmiService , L"Win32_Process5" ) ;
	}

	ULONG t_TickCount6 = GetTickCount () ;

	for ( ULONG t_Index6 = 0 ; t_Index6 < 100 ; t_Index6 ++ )
	{
		CreateInstanceEnumASync ( m_WmiService , L"Win32_Process6" ) ;
	}

	ULONG t_TickCount7 = GetTickCount () ;

	for ( ULONG t_Index7 = 0 ; t_Index7 < 100 ; t_Index7 ++ )
	{
		CreateInstanceEnumASync ( m_WmiService , L"Win32_Process7" ) ;
	}

	ULONG t_TickCount8 = GetTickCount () ;

	for ( ULONG t_Index8 = 0 ; t_Index8 < 100 ; t_Index8 ++ )
	{
		CreateInstanceEnumASync ( m_WmiService , L"Win32_Process8" ) ;
	}

	ULONG t_TickCount9 = GetTickCount () ;

	for ( ULONG t_Index9 = 0 ; t_Index9 < 100 ; t_Index9 ++ )
	{
		CreateInstanceEnumASync ( m_WmiService , L"Win32_Process9" ) ;
	}

	ULONG t_TickCount10 = GetTickCount () ;

	for ( ULONG t_Index10 = 0 ; t_Index10 < 100 ; t_Index10 ++ )
	{
		CreateInstanceEnumASync ( m_WmiService , L"Win32_Process10" ) ;
	}

	ULONG t_TickCount11 = GetTickCount () ;

	for ( ULONG t_Index11 = 0 ; t_Index11 < 100 ; t_Index11 ++ )
	{
		CreateInstanceEnumASync ( m_WmiService , L"Win32_Process11" ) ;
	}

	ULONG t_TickCount12 = GetTickCount () ;

	printf ( "\nASync - Winmgmt - Short Cirtuited - Single = %lu" , t_TickCount3 - t_TickCount2 ) ;
	printf ( "\nASync - Winmgmt - Short Cirtuited - Batched  = %lu" , t_TickCount4 - t_TickCount3 ) ;
	printf ( "\nASync - Winmgmt - Full Cirtuit - Single  = %lu" , t_TickCount5 - t_TickCount4 ) ;
	printf ( "\nASync - Winmgmt - Full Cirtuit - Batched  = %lu" , t_TickCount6 - t_TickCount5 ) ;
	printf ( "\nASync - Winmgmt - No Op = %lu" , t_TickCount7 - t_TickCount6 ) ;

	printf ( "\nASync - Host - Short Cirtuited - Single = %lu" , t_TickCount8 - t_TickCount7 ) ;
	printf ( "\nASync - Host - Short Cirtuited - Batched  = %lu" , t_TickCount9 - t_TickCount8 ) ;
	printf ( "\nASync - Host - Full Cirtuit - Single  = %lu" , t_TickCount10 - t_TickCount9 ) ;
	printf ( "\nASync - Host - Full Cirtuit - Batched = %lu" , t_TickCount11 - t_TickCount10 ) ;
	printf ( "\nASync - Host - No Op = %lu" , t_TickCount12 - t_TickCount11 ) ;

	return S_OK ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT Task_Execute :: Function_SemiSync ( ULONG a_BatchSize )
{
	ULONG t_TickCount2 = GetTickCount () ;

	for ( ULONG t_Index2 = 0 ; t_Index2 < 100 ; t_Index2 ++ )
	{
		CreateInstanceEnumSemiSync ( m_WmiService , L"Win32_Process2" , a_BatchSize ) ;
	}

	ULONG t_TickCount3 = GetTickCount () ;

	for ( ULONG t_Index3 = 0 ; t_Index3 < 100 ; t_Index3 ++ )
	{
		CreateInstanceEnumSemiSync ( m_WmiService , L"Win32_Process3" , a_BatchSize ) ;
	}

	ULONG t_TickCount4 = GetTickCount () ;

	for ( ULONG t_Index4 = 0 ; t_Index4 < 100 ; t_Index4 ++ )
	{
		CreateInstanceEnumSemiSync ( m_WmiService , L"Win32_Process4" , a_BatchSize ) ;
	}

	ULONG t_TickCount5 = GetTickCount () ;

	for ( ULONG t_Index5 = 0 ; t_Index5 < 100 ; t_Index5 ++ )
	{
		CreateInstanceEnumSemiSync ( m_WmiService , L"Win32_Process5" , a_BatchSize ) ;
	}

	ULONG t_TickCount6 = GetTickCount () ;

	for ( ULONG t_Index6 = 0 ; t_Index6 < 100 ; t_Index6 ++ )
	{
		CreateInstanceEnumSemiSync ( m_WmiService , L"Win32_Process6" , a_BatchSize ) ;
	}

	ULONG t_TickCount7 = GetTickCount () ;

	for ( ULONG t_Index7 = 0 ; t_Index7 < 100 ; t_Index7 ++ )
	{
		CreateInstanceEnumSemiSync ( m_WmiService , L"Win32_Process7" , a_BatchSize ) ;
	}

	ULONG t_TickCount8 = GetTickCount () ;

	for ( ULONG t_Index8 = 0 ; t_Index8 < 100 ; t_Index8 ++ )
	{
		CreateInstanceEnumSemiSync ( m_WmiService , L"Win32_Process8" , a_BatchSize ) ;
	}

	ULONG t_TickCount9 = GetTickCount () ;

	for ( ULONG t_Index9 = 0 ; t_Index9 < 100 ; t_Index9 ++ )
	{
		CreateInstanceEnumSemiSync ( m_WmiService , L"Win32_Process9" , a_BatchSize ) ;
	}

	ULONG t_TickCount10 = GetTickCount () ;

	for ( ULONG t_Index10 = 0 ; t_Index10 < 100 ; t_Index10 ++ )
	{
		CreateInstanceEnumSemiSync ( m_WmiService , L"Win32_Process10" , a_BatchSize ) ;
	}

	ULONG t_TickCount11 = GetTickCount () ;

	for ( ULONG t_Index11 = 0 ; t_Index11 < 100 ; t_Index11 ++ )
	{
		CreateInstanceEnumSemiSync ( m_WmiService , L"Win32_Process11" , a_BatchSize ) ;
	}

	ULONG t_TickCount12 = GetTickCount () ;

	printf ( "\nBatch Size = %lu" , a_BatchSize ) ;
	printf ( "\nSemiSync - Winmgmt - Short Cirtuited - Single = %lu" , t_TickCount3 - t_TickCount2 ) ;
	printf ( "\nSemiSync - Winmgmt - Short Cirtuited - Batched  = %lu" , t_TickCount4 - t_TickCount3 ) ;
	printf ( "\nSemiSync - Winmgmt - Full Cirtuit - Single  = %lu" , t_TickCount5 - t_TickCount4 ) ;
	printf ( "\nSemiSync - Winmgmt - Full Cirtuit - Batched  = %lu" , t_TickCount6 - t_TickCount5 ) ;
	printf ( "\nSemiSync - Winmgmt - No Op = %lu" , t_TickCount7 - t_TickCount6 ) ;

	printf ( "\nSemiSync - Host - Short Cirtuited - Single = %lu" , t_TickCount8 - t_TickCount7 ) ;
	printf ( "\nSemiSync - Host - Short Cirtuited - Batched  = %lu" , t_TickCount9 - t_TickCount8 ) ;
	printf ( "\nSemiSync - Host - Full Cirtuit - Single  = %lu" , t_TickCount10 - t_TickCount9 ) ;
	printf ( "\nSemiSync - Host - Full Cirtuit - Batched = %lu" , t_TickCount11 - t_TickCount10 ) ;
	printf ( "\nSemiSync - Host - No Op = %lu" , t_TickCount12 - t_TickCount11 ) ;

	return S_OK ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT Task_Execute :: Function_Sync ( ULONG a_BatchSize )
{
	ULONG t_TickCount2 = GetTickCount () ;

	for ( ULONG t_Index2 = 0 ; t_Index2 < 100 ; t_Index2 ++ )
	{
		CreateInstanceEnumSync ( m_WmiService , L"Win32_Process2" , a_BatchSize ) ;
	}

	ULONG t_TickCount3 = GetTickCount () ;

	for ( ULONG t_Index3 = 0 ; t_Index3 < 100 ; t_Index3 ++ )
	{
		CreateInstanceEnumSync ( m_WmiService , L"Win32_Process3" , a_BatchSize ) ;
	}

	ULONG t_TickCount4 = GetTickCount () ;

	for ( ULONG t_Index4 = 0 ; t_Index4 < 100 ; t_Index4 ++ )
	{
		CreateInstanceEnumSync ( m_WmiService , L"Win32_Process4" , a_BatchSize ) ;
	}

	ULONG t_TickCount5 = GetTickCount () ;

	for ( ULONG t_Index5 = 0 ; t_Index5 < 100 ; t_Index5 ++ )
	{
		CreateInstanceEnumSync ( m_WmiService , L"Win32_Process5" , a_BatchSize ) ;
	}

	ULONG t_TickCount6 = GetTickCount () ;

	for ( ULONG t_Index6 = 0 ; t_Index6 < 100 ; t_Index6 ++ )
	{
		CreateInstanceEnumSync ( m_WmiService , L"Win32_Process6" , a_BatchSize ) ;
	}

	ULONG t_TickCount7 = GetTickCount () ;

	for ( ULONG t_Index7 = 0 ; t_Index7 < 100 ; t_Index7 ++ )
	{
		CreateInstanceEnumSync ( m_WmiService , L"Win32_Process7" , a_BatchSize ) ;
	}

	ULONG t_TickCount8 = GetTickCount () ;

	for ( ULONG t_Index8 = 0 ; t_Index8 < 100 ; t_Index8 ++ )
	{
		CreateInstanceEnumSync ( m_WmiService , L"Win32_Process8" , a_BatchSize ) ;
	}

	ULONG t_TickCount9 = GetTickCount () ;

	for ( ULONG t_Index9 = 0 ; t_Index9 < 100 ; t_Index9 ++ )
	{
		CreateInstanceEnumSync ( m_WmiService , L"Win32_Process9" , a_BatchSize ) ;
	}

	ULONG t_TickCount10 = GetTickCount () ;

	for ( ULONG t_Index10 = 0 ; t_Index10 < 100 ; t_Index10 ++ )
	{
		CreateInstanceEnumSync ( m_WmiService , L"Win32_Process10" , a_BatchSize ) ;
	}

	ULONG t_TickCount11 = GetTickCount () ;

	for ( ULONG t_Index11 = 0 ; t_Index11 < 100 ; t_Index11 ++ )
	{
		CreateInstanceEnumSync ( m_WmiService , L"Win32_Process11" , a_BatchSize ) ;
	}

	ULONG t_TickCount12 = GetTickCount () ;

	printf ( "\nBatch Size = %lu" , a_BatchSize ) ;
	printf ( "\nSync - Winmgmt - Short Cirtuited - Single = %lu" , t_TickCount3 - t_TickCount2 ) ;
	printf ( "\nSync - Winmgmt - Short Cirtuited - Batched  = %lu" , t_TickCount4 - t_TickCount3 ) ;
	printf ( "\nSync - Winmgmt - Full Cirtuit - Single  = %lu" , t_TickCount5 - t_TickCount4 ) ;
	printf ( "\nSync - Winmgmt - Full Cirtuit - Batched  = %lu" , t_TickCount6 - t_TickCount5 ) ;
	printf ( "\nSync - Winmgmt - No Op = %lu" , t_TickCount7 - t_TickCount6 ) ;

	printf ( "\nSync - Host - Short Cirtuited - Single = %lu" , t_TickCount8 - t_TickCount7 ) ;
	printf ( "\nSync - Host - Short Cirtuited - Batched  = %lu" , t_TickCount9 - t_TickCount8 ) ;
	printf ( "\nSync - Host - Full Cirtuit - Single  = %lu" , t_TickCount10 - t_TickCount9 ) ;
	printf ( "\nSync - Host - Full Cirtuit - Batched = %lu" , t_TickCount11 - t_TickCount10 ) ;
	printf ( "\nSync - Host - No Op = %lu" , t_TickCount12 - t_TickCount11 ) ;

	return S_OK ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT Task_Execute :: Function_ForwardSync ( ULONG a_BatchSize )
{
	ULONG t_TickCount2 = GetTickCount () ;

	for ( ULONG t_Index2 = 0 ; t_Index2 < 100 ; t_Index2 ++ )
	{
		CreateInstanceEnumForwardSync ( m_WmiService , L"Win32_Process2" , a_BatchSize ) ;
	}

	ULONG t_TickCount3 = GetTickCount () ;

	for ( ULONG t_Index3 = 0 ; t_Index3 < 100 ; t_Index3 ++ )
	{
		CreateInstanceEnumForwardSync ( m_WmiService , L"Win32_Process3" , a_BatchSize ) ;
	}

	ULONG t_TickCount4 = GetTickCount () ;

	for ( ULONG t_Index4 = 0 ; t_Index4 < 100 ; t_Index4 ++ )
	{
		CreateInstanceEnumForwardSync ( m_WmiService , L"Win32_Process4" , a_BatchSize ) ;
	}

	ULONG t_TickCount5 = GetTickCount () ;

	for ( ULONG t_Index5 = 0 ; t_Index5 < 100 ; t_Index5 ++ )
	{
		CreateInstanceEnumForwardSync ( m_WmiService , L"Win32_Process5" , a_BatchSize ) ;
	}

	ULONG t_TickCount6 = GetTickCount () ;

	for ( ULONG t_Index6 = 0 ; t_Index6 < 100 ; t_Index6 ++ )
	{
		CreateInstanceEnumForwardSync ( m_WmiService , L"Win32_Process6" , a_BatchSize ) ;
	}

	ULONG t_TickCount7 = GetTickCount () ;

	for ( ULONG t_Index7 = 0 ; t_Index7 < 100 ; t_Index7 ++ )
	{
		CreateInstanceEnumForwardSync ( m_WmiService , L"Win32_Process7" , a_BatchSize ) ;
	}

	ULONG t_TickCount8 = GetTickCount () ;

	for ( ULONG t_Index8 = 0 ; t_Index8 < 100 ; t_Index8 ++ )
	{
		CreateInstanceEnumForwardSync ( m_WmiService , L"Win32_Process8" , a_BatchSize ) ;
	}

	ULONG t_TickCount9 = GetTickCount () ;

	for ( ULONG t_Index9 = 0 ; t_Index9 < 100 ; t_Index9 ++ )
	{
		CreateInstanceEnumForwardSync ( m_WmiService , L"Win32_Process9" , a_BatchSize ) ;
	}

	ULONG t_TickCount10 = GetTickCount () ;

	for ( ULONG t_Index10 = 0 ; t_Index10 < 100 ; t_Index10 ++ )
	{
		CreateInstanceEnumForwardSync ( m_WmiService , L"Win32_Process10" , a_BatchSize ) ;
	}

	ULONG t_TickCount11 = GetTickCount () ;

	for ( ULONG t_Index11 = 0 ; t_Index11 < 100 ; t_Index11 ++ )
	{
		CreateInstanceEnumForwardSync ( m_WmiService , L"Win32_Process11" , a_BatchSize ) ;
	}

	ULONG t_TickCount12 = GetTickCount () ;

	printf ( "\nBatch Size = %lu" , a_BatchSize ) ;
	printf ( "\nForwardSync - Winmgmt - Short Cirtuited - Single = %lu" , t_TickCount3 - t_TickCount2 ) ;
	printf ( "\nForwardSync - Winmgmt - Short Cirtuited - Batched  = %lu" , t_TickCount4 - t_TickCount3 ) ;
	printf ( "\nForwardSync - Winmgmt - Full Cirtuit - Single  = %lu" , t_TickCount5 - t_TickCount4 ) ;
	printf ( "\nForwardSync - Winmgmt - Full Cirtuit - Batched  = %lu" , t_TickCount6 - t_TickCount5 ) ;
	printf ( "\nForwardSync - Winmgmt - No Op = %lu" , t_TickCount7 - t_TickCount6 ) ;

	printf ( "\nForwardSync - Host - Short Cirtuited - Single = %lu" , t_TickCount8 - t_TickCount7 ) ;
	printf ( "\nForwardSync - Host - Short Cirtuited - Batched  = %lu" , t_TickCount9 - t_TickCount8 ) ;
	printf ( "\nForwardSync - Host - Full Cirtuit - Single  = %lu" , t_TickCount10 - t_TickCount9 ) ;
	printf ( "\nForwardSync - Host - Full Cirtuit - Batched = %lu" , t_TickCount11 - t_TickCount10 ) ;
	printf ( "\nForwardSync - Host - No Op = %lu" , t_TickCount12 - t_TickCount11 ) ;

	return S_OK ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT Task_Execute :: Function ()
{
	ULONG t_TickCount1 = GetTickCount () ;

	for ( ULONG t_Index1 = 0 ; t_Index1 < 100 ; t_Index1 ++ )
	{
		CreateInstanceEnumASync ( m_ProviderService , L"Win32_Process2" ) ;
	}

	ULONG t_TickCount2 = GetTickCount () ;

	printf ( "\nClient = %lu" , t_TickCount2 - t_TickCount1 ) ;

	Function_ASync () ;
	Function_SemiSync ( 1 ) ;
	Function_Sync ( 1 ) ;
	Function_ForwardSync ( 1 ) ;
	Function_SemiSync ( 100 ) ;
	Function_Sync ( 100 ) ;
	Function_ForwardSync ( 100 ) ;

	return S_OK ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

WmiStatusCode Task_Execute :: Process ( WmiThread <ULONG > &a_Thread )
{
	m_Result = S_OK ;

	if ( m_Index == 0 )
	{
		m_Result = WmiConnect ( L"root\\cimv2" , m_WmiService ) ;
		if ( SUCCEEDED ( m_Result ) )
		{
			CProvider_InitializationSink *t_InitializationSink = new CProvider_InitializationSink ;
			if ( t_InitializationSink )
			{
				m_ProviderService = new CProvider_IWbemServices ( m_Allocator ) ;
				if ( m_ProviderService )
				{
					m_Result = m_ProviderService->Initialize (

						NULL ,
						0 , 
						NULL ,
						NULL ,
						m_WmiService ,
						NULL ,
						t_InitializationSink
					) ;
				}
				else
				{
					m_Result = WBEM_E_OUT_OF_MEMORY ;
				}

				t_InitializationSink->Release () ;
			}
			else
			{
				m_Result = WBEM_E_OUT_OF_MEMORY ;
			}
		}

		if ( FAILED ( m_Result ) )
		{
			Complete () ;
			return e_StatusCode_Success ;
		}
	}
	
	if ( SUCCEEDED ( m_Result ) )
	{
		m_Result = Function () ;
	}

	m_Index ++ ;
	if ( m_Index < m_Count )
	{
		return e_StatusCode_EnQueue ;
	}
	else
	{
		Complete () ;
	}

	return e_StatusCode_Success ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\provsubsys\overlappedio\include\filerep.h ===
/*++

Copyright (C) 1999-2001 Microsoft Corporation

Module Name:

Abstract:

History:

--*/


#ifndef __File_Repository_H
#define __File_Repository_H

#include <ReaderWriter.h>

typedef UINT64 WmiFileOffSet ;
typedef UINT64 WmiFileSize ;

const UINT64 c_WmiFileBlockSize = 8192 ;
const UINT64 c_WmiFileBlockSizeShift = 13 ;

#define WmiFileBlockAndOffSetToAddressFunc(Block,BlockOffSet) ((Block*c_WmiFileBlockSize)+BlockOffSet)
#define WmiAddressToFileBlockFunc(Address) (Address>>c_WmiFileBlockSizeShift)
#define WmiAddressToFileOffSetFunc(Address) (Address&c_WmiFileBlockSize)

/* 
 *	Class:
 *
 *		WmiFileHeader
 *
 *	Description:
 *
 *		Provides abstraction above heap allocation functions
 *
 *	Version:
 *
 *		Initial
 *
 *	Last Changed:
 *
 *		See Source Depot for change history
 *
 */

class WmiFileHeaderChain
{
public:

	struct Header
	{
		WmiFileOffSet m_FileHeaderChain ;
	} ;

	union {

		Header m_Header ;
		BYTE m_Block [c_WmiFileBlockSize] ;
	} ;
} ;

/* 
 *	Class:
 *
 *		WmiFileHeader
 *
 *	Description:
 *
 *		Provides abstraction above heap allocation functions
 *
 *	Version:
 *
 *		Initial
 *
 *	Last Changed:
 *
 *		See Source Depot for change history
 *
 */

class WmiFileFreeBlockChain
{
public:

	struct Chain 
	{
		WmiFileOffSet m_FileFreeBlockChain ;
		DWORD m_Size ;
		WmiFileOffSet m_FileBlock [ c_WmiFileBlockSize - 1 ] ;
	} ;

	union {

		Chain m_Header ;
		BYTE m_Block [c_WmiFileBlockSize] ;
	} ;
} ;

/* 
 *	Class:
 *
 *		WmiFileHeader
 *
 *	Description:
 *
 *		Provides abstraction above heap allocation functions
 *
 *	Version:
 *
 *		Initial
 *
 *	Last Changed:
 *
 *		See Source Depot for change history
 *
 */

class WmiFileHeader
{
public:

	struct Header {

		ULONG m_Version ;
		WmiFileOffSet m_FileHeaderChain ;
		WmiFileOffSet m_FreeBlockChain ;
		WmiFileOffSet m_EndOnFileOffSet ;
		wchar_t m_Description [ 256 ] ;
	} ;

	union {

		Header m_Header ;
		BYTE m_Block [c_WmiFileBlockSize] ;
	} ;
} ;

/* 
 *	Class:
 *
 *		WmiFileHeader
 *
 *	Description:
 *
 *		Provides abstraction above heap allocation functions
 *
 *	Version:
 *
 *		Initial
 *
 *	Last Changed:
 *
 *		See Source Depot for change history
 *
 */

class CFileOperation : public  WmiFileOperation
{
private:

	LONG m_ReferenceCount ;
	HANDLE m_WaitHandle ;
	DWORD m_Status ;
	
public:

	CFileOperation () ;

	~CFileOperation () ;

	WmiStatusCode Initialize () ;

	WmiStatusCode UnInitialize () ;

	ULONG AddRef () ;

	ULONG Release () ;

	DWORD Wait ( DWORD a_Timeout ) ;

	void Operation ( DWORD a_Status , BYTE *a_OperationBytes , DWORD a_Bytes ) ;

	DWORD GetStatus () { return m_Status ; }
} ;

/* 
 *	Class:
 *
 *		WmiFileHeader
 *
 *	Description:
 *
 *		Provides abstraction above heap allocation functions
 *
 *	Version:
 *
 *		Initial
 *
 *	Last Changed:
 *
 *		See Source Depot for change history
 *
 */

class CFileRepository 
{
private:

	LONG m_ReferenceCount ;
	HANDLE m_WaitHandle ;
	DWORD m_Status ;
	WmiThreadPool *m_ThreadPool ;
	WmiIoScheduler *m_BlockAllocator ;
	WmiAllocator &m_Allocator ;
	WmiMultiReaderSingleWriter m_ReaderWriter ;

	WmiFileHeader m_FileHeader ;
	WmiFileFreeBlockChain m_ChainHeader ;

private:

	WmiStatusCode ReadFileHeader () ;

	WmiStatusCode WriteFileHeader () ;

public:

	CFileRepository (

		WmiAllocator &a_Allocator 
	) ;

	~CFileRepository () ;

	WmiStatusCode Initialize () ;

	WmiStatusCode UnInitialize () ;

	ULONG AddRef () ;

	ULONG Release () ;

	DWORD Wait ( DWORD a_Timeout ) ;

	DWORD GetStatus () { return m_Status ; }

	WmiStatusCode Read ( 

		CFileOperation *&a_OperationFunction ,
		WmiFileOffSet a_OffSet ,
		BYTE *a_ReadBytes ,
		DWORD a_Bytes
	) ;

	WmiStatusCode Write (

		CFileOperation *&a_OperationFunction ,
		WmiFileOffSet a_OffSet ,
		BYTE *a_WriteBytes ,
		DWORD a_Bytes
	) ;

	WmiStatusCode Lock (

		CFileOperation *&a_OperationFunction ,
		WmiFileOffSet a_OffSet ,
		WmiFileOffSet a_OffSetSize 
	) ;

	WmiStatusCode UnLock (

		CFileOperation *&a_OperationFunction ,
		WmiFileOffSet a_OffSet ,
		WmiFileOffSet a_OffSetSize
	) ;

	WmiStatusCode AllocBlock ( WmiFileOffSet &a_OffSet ) ;

	WmiStatusCode FreeBlock ( WmiFileOffSet a_OffSet ) ;

} ;

#endif __File_Repository_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\provsubsys\performance\service.cpp ===
/*++

Copyright (C) 1996-2001 Microsoft Corporation

Module Name:

	XXXX

Abstract:


History:

--*/

#include <precomp.h>

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <ntobapi.h>

#define _WINNT_	// have what is needed from above

#include "precomp.h"

#include <objbase.h>
#include <wbemint.h>
#include "Globals.h"
#include "HelperFuncs.h"
#include "DateTime.h"
#include "Service.h"

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT Set_Uint64 (

	_IWmiObject *a_Instance ,
	wchar_t *a_Name ,
	const UINT64 &a_Uint64
)
{
	HRESULT t_Result = a_Instance->WriteProp (

		a_Name , 
		0 , 
		sizeof ( UINT64 ) , 
		0 ,
		CIM_UINT64 ,
		( void * ) & a_Uint64
	) ;

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT Set_Uint32 ( 

	_IWmiObject *a_Instance , 
	wchar_t *a_Name ,
	const DWORD &a_Uint32
)
{
	HRESULT t_Result = a_Instance->WriteProp (

		a_Name , 
		0 , 
		sizeof ( DWORD ) , 
		0 ,
		CIM_UINT32 ,
		( void * ) & a_Uint32
	) ;

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT Set_String ( 

	IWbemClassObject *a_Instance , 
	wchar_t *a_Name ,
	wchar_t *a_String
)
{
	VARIANT t_Variant ;
	VariantInit ( & t_Variant ) ;
	t_Variant.vt = VT_BSTR ;
	t_Variant.bstrVal = SysAllocString ( a_String ) ;
	a_Instance->Put ( a_Name , 0 , & t_Variant , 0 ) ;
	VariantClear ( & t_Variant ) ;

	return S_OK ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT Set_DateTime ( 

	IWbemClassObject *a_Instance , 
	wchar_t *a_Name ,
	FILETIME a_Time
)
{
	CWbemDateTime t_Time ;
	t_Time.SetFileTimeDate ( a_Time , VARIANT_FALSE ) ;

	BSTR t_String ;
	HRESULT t_Result = t_Time.GetValue ( & t_String ) ;
	if ( SUCCEEDED ( t_Result ) ) 
	{
		VARIANT t_Variant ;
		VariantInit ( & t_Variant ) ;
		t_Variant.vt = VT_BSTR ;
		t_Variant.bstrVal = t_String ;
		a_Instance->Put ( a_Name , 0 , & t_Variant , CIM_DATETIME ) ;
		VariantClear ( & t_Variant ) ;
	}

	return t_Result ;
}

HRESULT EnablePrivilegeOnCurrentThread ( wchar_t *a_Privilege )
{
	HRESULT t_Result = WBEM_E_ACCESS_DENIED ;

    HANDLE t_Token = NULL;
	BOOL t_ProcessToken = FALSE ;

    if ( OpenThreadToken ( GetCurrentThread () , TOKEN_ADJUST_PRIVILEGES | TOKEN_QUERY, FALSE , & t_Token ) )
	{
	}
	else
	{		
		if ( OpenProcessToken ( GetCurrentProcess () , TOKEN_ADJUST_PRIVILEGES | TOKEN_QUERY , & t_Token ) )
		{
		}
	}

	if ( t_Token )
    {
	    TOKEN_PRIVILEGES t_TokenPrivileges ;

		BOOL t_Status = LookupPrivilegeValue (

			NULL, 
			a_Privilege , 
			& t_TokenPrivileges.Privileges[0].Luid
		) ;

        if (t_Status)
        {
            t_TokenPrivileges.PrivilegeCount = 1;
            t_TokenPrivileges.Privileges[0].Attributes = SE_PRIVILEGE_ENABLED;

            SetLastError(0);

            t_Status = AdjustTokenPrivileges (

				t_Token , 
				FALSE , 
				& t_TokenPrivileges , 
				0 ,
                (PTOKEN_PRIVILEGES) NULL , 
				0
			) ;

			if ( GetLastError() == 0 )
			{
				t_Result = S_OK ;
			}
        }

        CloseHandle ( t_Token ) ;

		if ( t_ProcessToken )
		{
			RevertToSelf () ;
		}
    }

    return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

CProvider_IWbemServices :: CProvider_IWbemServices (

	 WmiAllocator &a_Allocator 

) : m_ReferenceCount ( 0 ) , 
	m_Allocator ( a_Allocator ) ,
	m_User ( NULL ) ,
	m_Locale ( NULL ) ,
	m_Namespace ( NULL ) ,
	m_CoreService ( NULL ) ,
	m_ComputerName  ( NULL ) ,
	m_OperatingSystemVersion ( NULL ) ,
	m_OperatingSystemRunning ( NULL ) , 
	m_ProductName ( NULL ) , 
	m_Win32_Process_Object ( NULL )
{
	InitializeCriticalSection ( & m_CriticalSection ) ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

CProvider_IWbemServices :: ~CProvider_IWbemServices ()
{
	DeleteCriticalSection ( & m_CriticalSection ) ;

	if ( m_User ) 
	{
		SysFreeString ( m_User ) ;
	}

	if ( m_Locale ) 
	{
		SysFreeString ( m_Locale ) ;
	}

	if ( m_Namespace ) 
	{
		SysFreeString ( m_Namespace ) ;
	}

	if ( m_CoreService ) 
	{
		m_CoreService->Release () ;
	}

	if ( m_Win32_Process_Object ) 
	{
		m_Win32_Process_Object->Release () ;
	}

	if ( m_ComputerName ) 
	{
		SysFreeString ( m_ComputerName ) ;
	}

	if ( m_OperatingSystemVersion ) 
	{
		SysFreeString ( m_OperatingSystemVersion ) ;
	}

	if ( m_OperatingSystemRunning ) 
	{
		SysFreeString ( m_OperatingSystemRunning ) ;
	}

	if ( m_ProductName )
	{
		SysFreeString ( m_ProductName ) ;
	}
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

STDMETHODIMP_(ULONG) CProvider_IWbemServices :: AddRef ( void )
{
	return InterlockedIncrement ( & m_ReferenceCount ) ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

STDMETHODIMP_(ULONG) CProvider_IWbemServices :: Release ( void )
{
	LONG t_Reference ;
	if ( ( t_Reference = InterlockedDecrement ( & m_ReferenceCount ) ) == 0 )
	{
		delete this ;
		return 0 ;
	}
	else
	{
		return t_Reference ;
	}
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

STDMETHODIMP CProvider_IWbemServices :: QueryInterface (

	REFIID iid , 
	LPVOID FAR *iplpv 
) 
{
	*iplpv = NULL ;

	if ( iid == IID_IUnknown )
	{
		*iplpv = ( LPVOID ) this ;
	}
	else if ( iid == IID_IWbemServices )
	{
		*iplpv = ( LPVOID ) ( IWbemServices * ) this ;		
	}	
	else if ( iid == IID_IWbemPropertyProvider )
	{
		*iplpv = ( LPVOID ) ( IWbemPropertyProvider * ) this ;		
	}	
	else if ( iid == IID_IWbemProviderInit )
	{
		*iplpv = ( LPVOID ) ( IWbemProviderInit * ) this ;		
	}	
	else if ( iid == IID_IWbemShutdown )
	{
		*iplpv = ( LPVOID ) ( IWbemShutdown * ) this ;		
	}	

	if ( *iplpv )
	{
		( ( LPUNKNOWN ) *iplpv )->AddRef () ;

		return ResultFromScode ( S_OK ) ;
	}
	else
	{
		return ResultFromScode ( E_NOINTERFACE ) ;
	}
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CProvider_IWbemServices::OpenNamespace ( 

	const BSTR ObjectPath, 
	long lFlags, 
	IWbemContext FAR* pCtx,
	IWbemServices FAR* FAR* pNewContext, 
	IWbemCallResult FAR* FAR* ppErrorObject
)
{
	return WBEM_E_NOT_AVAILABLE ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CProvider_IWbemServices :: CancelAsyncCall ( 
		
	IWbemObjectSink __RPC_FAR *pSink
)
{
	HRESULT t_Result = WBEM_E_NOT_AVAILABLE ;

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CProvider_IWbemServices :: QueryObjectSink ( 

	long lFlags,		
	IWbemObjectSink FAR* FAR* ppResponseHandler
) 
{
	return WBEM_E_NOT_AVAILABLE ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CProvider_IWbemServices :: GetObject ( 
		
	const BSTR ObjectPath,
    long lFlags,
    IWbemContext FAR *pCtx,
    IWbemClassObject FAR* FAR *ppObject,
    IWbemCallResult FAR* FAR *ppCallResult
)
{
	return WBEM_E_NOT_AVAILABLE ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CProvider_IWbemServices :: GetObjectAsync ( 
		
	const BSTR ObjectPath, 
	long lFlags, 
	IWbemContext FAR *pCtx,
	IWbemObjectSink FAR* pSink
) 
{
	HRESULT t_Result = WBEM_E_NOT_FOUND ;

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CProvider_IWbemServices :: PutClass ( 
		
	IWbemClassObject FAR* pObject, 
	long lFlags, 
	IWbemContext FAR *pCtx,
	IWbemCallResult FAR* FAR* ppCallResult
) 
{
	return WBEM_E_NOT_AVAILABLE ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CProvider_IWbemServices :: PutClassAsync ( 
		
	IWbemClassObject FAR* pObject, 
	long lFlags, 
	IWbemContext FAR *pCtx,
	IWbemObjectSink FAR* pResponseHandler
) 
{
 	 return WBEM_E_NOT_FOUND ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CProvider_IWbemServices :: DeleteClass ( 
		
	const BSTR Class, 
	long lFlags, 
	IWbemContext FAR *pCtx,
	IWbemCallResult FAR* FAR* ppCallResult
) 
{
 	 return WBEM_E_NOT_AVAILABLE ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CProvider_IWbemServices :: DeleteClassAsync ( 
		
	const BSTR Class, 
	long lFlags, 
	IWbemContext FAR *pCtx,
	IWbemObjectSink FAR* pResponseHandler
) 
{
 	 return WBEM_E_NOT_AVAILABLE ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CProvider_IWbemServices :: CreateClassEnum ( 

	const BSTR Superclass, 
	long lFlags, 
	IWbemContext FAR *pCtx,
	IEnumWbemClassObject FAR *FAR *ppEnum
) 
{
	return WBEM_E_NOT_AVAILABLE ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

SCODE CProvider_IWbemServices :: CreateClassEnumAsync (

	const BSTR Superclass, 
	long lFlags, 
	IWbemContext FAR* pCtx,
	IWbemObjectSink FAR* pHandler
) 
{
	return WBEM_E_NOT_FOUND ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CProvider_IWbemServices :: PutInstance (

    IWbemClassObject FAR *pInst,
    long lFlags,
    IWbemContext FAR *pCtx,
	IWbemCallResult FAR *FAR *ppCallResult
) 
{
	return WBEM_E_NOT_AVAILABLE ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CProvider_IWbemServices :: PutInstanceAsync ( 
		
	IWbemClassObject FAR* pInst, 
	long lFlags, 
    IWbemContext FAR *pCtx,
	IWbemObjectSink FAR* pSink
) 
{
	HRESULT t_Result = WBEM_E_NOT_AVAILABLE ;

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CProvider_IWbemServices :: DeleteInstance ( 

	const BSTR ObjectPath,
    long lFlags,
    IWbemContext FAR *pCtx,
    IWbemCallResult FAR *FAR *ppCallResult
)
{
	return WBEM_E_NOT_AVAILABLE ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/
        
HRESULT CProvider_IWbemServices :: DeleteInstanceAsync (
 
	const BSTR ObjectPath,
    long lFlags,
    IWbemContext __RPC_FAR *pCtx,
    IWbemObjectSink __RPC_FAR *pSink	
)
{
	HRESULT t_Result = WBEM_E_NOT_AVAILABLE ;

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CProvider_IWbemServices :: CreateInstanceEnum ( 

	const BSTR a_Class, 
	long a_Flags, 
	IWbemContext FAR *a_Context, 
	IEnumWbemClassObject __RPC_FAR *__RPC_FAR *a_Enum
)
{
	HRESULT t_Result = WBEM_E_NOT_AVAILABLE ;

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

DWORD GetCurrentImpersonationLevel ()
{
	DWORD t_ImpersonationLevel = RPC_C_IMP_LEVEL_ANONYMOUS ;

    HANDLE t_ThreadToken = NULL ;

    BOOL t_Status = OpenThreadToken (

		GetCurrentThread() ,
		TOKEN_QUERY,
		TRUE,
		&t_ThreadToken
	) ;

    if ( t_Status )
    {
		SECURITY_IMPERSONATION_LEVEL t_Level = SecurityAnonymous ;
		DWORD t_Returned = 0 ;

		t_Status = GetTokenInformation (

			t_ThreadToken ,
			TokenImpersonationLevel ,
			& t_Level ,
			sizeof ( SECURITY_IMPERSONATION_LEVEL ) ,
			& t_Returned
		) ;

		CloseHandle ( t_ThreadToken ) ;

		if ( t_Status == FALSE )
		{
			t_ImpersonationLevel = RPC_C_IMP_LEVEL_ANONYMOUS ;
		}
		else
		{
			switch ( t_Level )
			{
				case SecurityAnonymous:
				{
					t_ImpersonationLevel = RPC_C_IMP_LEVEL_ANONYMOUS ;
				}
				break ;

				case SecurityIdentification:
				{
					t_ImpersonationLevel = RPC_C_IMP_LEVEL_IDENTIFY ;
				}
				break ;

				case SecurityImpersonation:
				{
					t_ImpersonationLevel = RPC_C_IMP_LEVEL_IMPERSONATE ;
				}
				break ;

				case SecurityDelegation:
				{
					t_ImpersonationLevel = RPC_C_IMP_LEVEL_DELEGATE ;
				}
				break ;

				default:
				{
					t_ImpersonationLevel = RPC_C_IMP_LEVEL_ANONYMOUS ;
				}
				break ;
			}
		}
	}
	else
	{
        ULONG t_LastError = GetLastError () ;

        if ( t_LastError == ERROR_NO_IMPERSONATION_TOKEN || t_LastError == ERROR_NO_TOKEN )
        {
            t_ImpersonationLevel = RPC_C_IMP_LEVEL_DELEGATE ;
        }
        else 
		{
			if ( t_LastError == ERROR_CANT_OPEN_ANONYMOUS )
			{
				t_ImpersonationLevel = RPC_C_IMP_LEVEL_ANONYMOUS ;
			}
			else
			{
				t_ImpersonationLevel = RPC_C_IMP_LEVEL_ANONYMOUS ;
			}
		}
    }

	return t_ImpersonationLevel ;
}

HRESULT CProvider_IWbemServices :: CreateInstanceEnumAsync (

 	const BSTR a_Class ,
	long a_Flags , 
	IWbemContext __RPC_FAR *a_Context,
	IWbemObjectSink FAR *a_Sink

) 
{
#if 1
	HRESULT t_Result = CoImpersonateClient () ;

	if ( _wcsicmp ( a_Class , L"Win32_Process2" ) == 0 )
	{
		t_Result = CreateInstanceEnumAsync_Process ( 

			a_Flags ,
			a_Context , 
			a_Sink
		) ;
	}

	a_Sink->SetStatus ( 0 , t_Result , NULL , NULL ) ;

	return t_Result ;
#else
	HRESULT t_Result = S_OK ;

	t_Result = CoImpersonateClient () ;

	DWORD t_Level = GetCurrentImpersonationLevel () ;
	if ( _wcsicmp ( a_Class , L"Sample" ) == 0 )
	{
		BSTR t_String = SysAllocString ( L"Win32_Process2" ) ;
		if ( t_String ) 
		{
			IClientSecurity *t_ClientSecurity = NULL ;

			HRESULT t_Result = m_CoreService->QueryInterface (
			
				IID_IClientSecurity , 
				( void ** ) & t_ClientSecurity
			) ;

			if ( SUCCEEDED ( t_Result ) )
			{
				t_Result = t_ClientSecurity->SetBlanket (

					m_CoreService ,
					RPC_C_AUTHN_WINNT ,
					RPC_C_AUTHZ_NONE ,
					NULL ,
					RPC_C_AUTHN_LEVEL_CONNECT ,
					RPC_C_IMP_LEVEL_IMPERSONATE ,
					NULL ,
					EOAC_DYNAMIC_CLOAKING
				) ;

				t_ClientSecurity->Release () ;
			}

			t_Result = m_CoreService->CreateInstanceEnumAsync ( 

				t_String ,
				a_Flags ,
				a_Context , 
				a_Sink
			) ;

			SysFreeString ( t_String ) ;
		}
	}
	else if ( _wcsicmp ( a_Class , L"RecursiveSample" ) == 0 )
	{
		BSTR t_String = SysAllocString ( L"Sample" ) ;
		if ( t_String ) 
		{
			t_Result = m_CoreService->CreateInstanceEnumAsync ( 

				t_String ,
				a_Flags ,
				a_Context , 
				a_Sink
			) ;

			SysFreeString ( t_String ) ;
		}
	}
	else
	{
		t_Result = WBEM_E_INVALID_CLASS ;
	}

	return t_Result ;
#endif
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CProvider_IWbemServices :: ExecQuery ( 

	const BSTR QueryLanguage, 
	const BSTR Query, 
	long lFlags, 
	IWbemContext FAR *pCtx,
	IEnumWbemClassObject FAR *FAR *ppEnum
)
{
	return WBEM_E_NOT_AVAILABLE ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CProvider_IWbemServices :: ExecQueryAsync ( 
		
	const BSTR QueryFormat, 
	const BSTR Query, 
	long lFlags, 
	IWbemContext FAR* pCtx,
	IWbemObjectSink FAR* pSink
) 
{
	HRESULT t_Result = WBEM_E_SHUTTING_DOWN ;

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CProvider_IWbemServices :: ExecNotificationQuery ( 

	const BSTR QueryLanguage,
    const BSTR Query,
    long lFlags,
    IWbemContext __RPC_FAR *pCtx,
    IEnumWbemClassObject __RPC_FAR *__RPC_FAR *ppEnum
)
{
	return WBEM_E_NOT_AVAILABLE ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/
        
HRESULT CProvider_IWbemServices :: ExecNotificationQueryAsync ( 
            
	const BSTR QueryLanguage,
    const BSTR Query,
    long lFlags,
    IWbemContext __RPC_FAR *pCtx,
    IWbemObjectSink __RPC_FAR *pResponseHandler
)
{
	return WBEM_E_NOT_AVAILABLE ;
}       

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT STDMETHODCALLTYPE CProvider_IWbemServices :: ExecMethod ( 

	const BSTR ObjectPath,
    const BSTR MethodName,
    long lFlags,
    IWbemContext FAR *pCtx,
    IWbemClassObject FAR *pInParams,
    IWbemClassObject FAR *FAR *ppOutParams,
    IWbemCallResult FAR *FAR *ppCallResult
)
{
	return WBEM_E_NOT_AVAILABLE ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT STDMETHODCALLTYPE CProvider_IWbemServices :: ExecMethodAsync ( 

    const BSTR ObjectPath,
    const BSTR MethodName,
    long lFlags,
    IWbemContext FAR *pCtx,
    IWbemClassObject FAR *pInParams,
	IWbemObjectSink FAR *pSink
) 
{
	HRESULT t_Result = WBEM_E_NOT_AVAILABLE ;

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CProvider_IWbemServices :: GetProperty (

    long a_Flags ,
    const BSTR a_Locale ,
    const BSTR a_ClassMapping ,
    const BSTR a_InstanceMapping ,
    const BSTR a_PropertyMapping ,
    VARIANT *a_Value
)
{
	if ( _wcsicmp ( a_PropertyMapping , L"ExtraProperty1" ) == 0 )
	{
	}
	else if ( _wcsicmp ( a_PropertyMapping , L"ExtraProperty2" ) == 0 )
	{
	}
	else
	{
	}
	
	return WBEM_E_NOT_AVAILABLE ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/


HRESULT CProvider_IWbemServices :: PutProperty (

    long a_Flags ,
    const BSTR a_Locale ,
    const BSTR a_ClassMapping ,
    const BSTR a_InstanceMapping ,
    const BSTR a_PropertyMapping ,
    const VARIANT *a_Value
)
{
	if ( _wcsicmp ( a_PropertyMapping , L"ExtraProperty1" ) == 0 )
	{
	}
	else if ( _wcsicmp ( a_PropertyMapping , L"ExtraProperty2" ) == 0 )
	{
	}
	else
	{
	}

	return WBEM_E_NOT_AVAILABLE ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CProvider_IWbemServices :: GetProductInformation ()
{
	HRESULT t_Result = S_OK ;

	ULONG t_ProductType = 0xffffffff ;

	if ( USER_SHARED_DATA->ProductTypeIsValid )
	{
		t_ProductType = USER_SHARED_DATA->NtProductType ;

		HKEY t_CurrentVersion ;
		LONG t_RegResult = RegOpenKeyEx (

			HKEY_LOCAL_MACHINE ,
			L"SOFTWARE\\Microsoft\\Windows NT\\Currentversion" ,
			0 ,
			KEY_READ ,
			& t_CurrentVersion 
		) ;

		if ( t_RegResult == ERROR_SUCCESS )
		{
			wchar_t t_ProductName [ _MAX_PATH ] ;

			DWORD t_ValueType = REG_SZ ;
			DWORD t_DataSize = sizeof ( t_ProductName ) ;

			t_RegResult = RegQueryValueEx (

			  t_CurrentVersion ,
			  L"" ,
			  0 ,
			  & t_ValueType ,
			  LPBYTE ( & t_ProductName ) ,
			  & t_DataSize 
			);

			if ( t_RegResult == ERROR_SUCCESS )
			{
				if ( wcscmp ( t_ProductName , L"" ) == 0 )
				{
					wcscpy ( t_ProductName , L"Microsoft Windows 2000" ) ;
				}

				if ( ( VER_SUITE_DATACENTER & USER_SHARED_DATA->SuiteMask ) &&
					( ( VER_NT_SERVER == t_ProductType ) || ( VER_NT_DOMAIN_CONTROLLER == t_ProductType ) )
				)
				{
					t_Result = WmiHelper :: ConcatenateStrings ( 

						2, 
						& m_ProductName , 
						t_ProductName ,
						L" Datacenter Server"
					) ;
				}
				else
				{
					if ( ( VER_SUITE_ENTERPRISE & USER_SHARED_DATA->SuiteMask ) &&
						( ( VER_NT_SERVER == t_ProductType ) || ( VER_NT_DOMAIN_CONTROLLER == t_ProductType ) )
					)
					{
						t_Result = WmiHelper :: ConcatenateStrings ( 

							2, 
							& m_ProductName , 
							t_ProductName ,
							L" Advanced Server"
						) ;
					}
					else
					{
						if ( ( VER_NT_SERVER == t_ProductType ) || ( VER_NT_DOMAIN_CONTROLLER == t_ProductType ) )
						{
							t_Result = WmiHelper :: ConcatenateStrings ( 

								2, 
								& m_ProductName , 
								t_ProductName ,
								L" Server"
							) ;
						}
						else
						{
							if ( VER_NT_WORKSTATION == t_ProductType )
							{
								t_Result = WmiHelper :: ConcatenateStrings ( 

									2, 
									& m_ProductName , 
									t_ProductName ,
									L" Professional"
								) ;
							}
						}
					}
				}

			}

			RegCloseKey ( t_CurrentVersion ) ;
		}

	}

	if ( SUCCEEDED ( t_Result ) ) 
	{
		wchar_t t_WindowsDirectory [ _MAX_PATH ] ;

	    if ( ! GetWindowsDirectory ( t_WindowsDirectory , sizeof ( t_WindowsDirectory ) / sizeof(wchar_t)) )
	    {
		    t_WindowsDirectory [0] = '\0';
	    }

		wchar_t t_File [_MAX_PATH] ;

		wcscpy ( t_File , t_WindowsDirectory ) ;
		wcscat ( t_File , _T("\\REPAIR\\SETUP.LOG") ) ;

		wchar_t t_Device [_MAX_PATH] ;

		GetPrivateProfileString (

			L"Paths" ,
			L"TargetDevice" ,
			L"" ,
			t_Device,
			sizeof ( t_Device ) / sizeof ( wchar_t ) ,
			t_File
		) ;

		t_Result = WmiHelper :: ConcatenateStrings ( 

			5 , 
			& m_OperatingSystemRunning , 
			m_ProductName ,
			L"|",
			t_WindowsDirectory ,
			L"|" ,
			t_Device
		) ;
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CProvider_IWbemServices :: Initialize (

	LPWSTR a_User,
	LONG a_Flags,
	LPWSTR a_Namespace,
	LPWSTR a_Locale,
	IWbemServices *a_CoreService,         // For anybody
	IWbemContext *a_Context,
	IWbemProviderInitSink *a_Sink     // For init signals
)
{
	HRESULT t_Result = S_OK ;

	if ( a_CoreService ) 
	{
		m_CoreService = a_CoreService ;
		m_CoreService->AddRef () ;
	}
	else
	{
		t_Result = WBEM_E_INVALID_PARAMETER ;
	}

	if ( SUCCEEDED ( t_Result ) )
	{
		if ( a_User ) 
		{
			m_User = SysAllocString ( a_User ) ;
			if ( m_User == NULL )
			{
				t_Result = WBEM_E_OUT_OF_MEMORY ;
			}
		}
	}

	if ( SUCCEEDED ( t_Result ) )
	{
		if ( a_Locale ) 
		{
			m_Locale = SysAllocString ( a_Locale ) ;
			if ( m_Locale == NULL )
			{
				t_Result = WBEM_E_OUT_OF_MEMORY ;
			}
		}
	}

	if ( SUCCEEDED ( t_Result ) )
	{
		if ( a_Namespace ) 
		{
			m_Namespace = SysAllocString ( a_Namespace ) ;
			if ( m_Namespace == NULL )
			{
				t_Result = WBEM_E_OUT_OF_MEMORY ;
			}
		}
	}
	
	if ( SUCCEEDED ( t_Result ) ) 
	{
		BSTR t_Class = SysAllocString ( L"Win32_Process2" ) ;
		if ( t_Class ) 
		{
			t_Result = m_CoreService->GetObject (

				t_Class ,
				0 ,
				a_Context ,
				& m_Win32_Process_Object ,
				NULL 
			) ;

			if ( SUCCEEDED ( t_Result ) )
			{
			}

			SysFreeString ( t_Class ) ;
		}
		else
		{
			t_Result = WBEM_E_OUT_OF_MEMORY ;
		}
	}

	if ( SUCCEEDED ( t_Result ) ) 
	{
		m_ComputerName = SysAllocStringLen ( NULL , _MAX_PATH ) ;
		if ( m_ComputerName ) 
		{
			DWORD t_Length = _MAX_PATH ;
			GetComputerName ( m_ComputerName , & t_Length ) ;
		}
		else
		{
			t_Result = WBEM_E_OUT_OF_MEMORY ;
		}
	}

	if ( SUCCEEDED ( t_Result ) )
	{	
		OSVERSIONINFO t_VersionInfo ;
		t_VersionInfo.dwOSVersionInfoSize = sizeof ( OSVERSIONINFO ) ;
		if ( GetVersionEx ( & t_VersionInfo ) )
		{
			m_OperatingSystemVersion  = SysAllocStringLen ( NULL , _MAX_PATH ) ;
			if ( m_OperatingSystemVersion )
			{
				swprintf (	m_OperatingSystemVersion ,	L"%d.%d.%hu", t_VersionInfo.dwMajorVersion , t_VersionInfo.dwMinorVersion , LOWORD ( t_VersionInfo.dwBuildNumber ) ) ;
			}
			else
			{
				t_Result = WBEM_E_OUT_OF_MEMORY ;
			}
		}
		else
		{
			t_Result = WBEM_E_FAILED ;
		}
	}

	if ( SUCCEEDED ( t_Result ) )
	{
		t_Result = GetProductInformation () ;	
	}

	a_Sink->SetStatus ( t_Result , 0 ) ;

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CProvider_IWbemServices :: Shutdown (

	LONG a_Flags ,
	ULONG a_MaxMilliSeconds ,
	IWbemContext *a_Context
)
{
	HRESULT t_Result = S_OK ;

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CProvider_IWbemServices :: GetProcessExecutable ( HANDLE a_Process , wchar_t *&a_ExecutableName )
{
	HRESULT t_Result = WBEM_E_FAILED ;

    PROCESS_BASIC_INFORMATION t_BasicInfo ;

    NTSTATUS t_Status = NtQueryInformationProcess (

        a_Process ,
        ProcessBasicInformation ,
        & t_BasicInfo ,
        sizeof ( t_BasicInfo ) ,
        NULL
	) ;

    if ( NT_SUCCESS ( t_Status ) )
	{
		PEB *t_Peb = t_BasicInfo.PebBaseAddress ;

		//
		// Ldr = Peb->Ldr
		//

		PPEB_LDR_DATA t_Ldr ;

		t_Status = ReadProcessMemory (

			a_Process,
			& t_Peb->Ldr,
			& t_Ldr,
			sizeof ( t_Ldr ) ,
			NULL
		) ;

		if ( t_Status )
		{
			LIST_ENTRY *t_LdrHead = & t_Ldr->InMemoryOrderModuleList ;

			//
			// LdrNext = Head->Flink;
			//

			LIST_ENTRY *t_LdrNext ;

			t_Status = ReadProcessMemory (

				a_Process,
				& t_LdrHead->Flink,
				& t_LdrNext,
				sizeof ( t_LdrNext ) ,
				NULL
			) ;

			if ( t_Status )
			{
				if ( t_LdrNext != t_LdrHead )
				{
					LDR_DATA_TABLE_ENTRY t_LdrEntryData ;

					LDR_DATA_TABLE_ENTRY *t_LdrEntry = CONTAINING_RECORD ( t_LdrNext , LDR_DATA_TABLE_ENTRY, InMemoryOrderLinks ) ;

					t_Status = ReadProcessMemory (

						a_Process,
						t_LdrEntry,
						& t_LdrEntryData,
						sizeof ( t_LdrEntryData ) ,
						NULL
					) ;

					if ( t_Status )
					{
						a_ExecutableName = ( wchar_t * ) new wchar_t [t_LdrEntryData.FullDllName.MaximumLength ];
						if ( a_ExecutableName )
						{
							t_Status = ReadProcessMemory (

								a_Process,
								t_LdrEntryData.FullDllName.Buffer,
								a_ExecutableName ,
								t_LdrEntryData.FullDllName.MaximumLength ,
								NULL
							) ;

							if ( t_Status )
							{
								t_Result = S_OK ;
							}
						}
						else
						{
							t_Result = WBEM_E_OUT_OF_MEMORY ;
						}
					}
				}
			}
		}
	}

    return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CProvider_IWbemServices :: NextProcessBlock (

	SYSTEM_PROCESS_INFORMATION *a_ProcessBlock , 
	SYSTEM_PROCESS_INFORMATION *&a_NextProcessBlock
)
{
	if ( a_ProcessBlock )
	{
		DWORD t_NextOffSet = a_ProcessBlock->NextEntryOffset ;
		if ( t_NextOffSet )
		{
			a_NextProcessBlock = ( SYSTEM_PROCESS_INFORMATION * ) ( ( ( BYTE * ) a_ProcessBlock ) + t_NextOffSet ) ;
		}
		else
		{
			a_NextProcessBlock = NULL ;
		}
	}

	return S_OK ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CProvider_IWbemServices :: GetProcessBlocks ( SYSTEM_PROCESS_INFORMATION *&a_ProcessInformation )
{
	HRESULT t_Result = S_OK ;

	DWORD t_ProcessInformationSize = 32768;
	a_ProcessInformation = ( SYSTEM_PROCESS_INFORMATION * ) new BYTE [t_ProcessInformationSize] ;

	if ( a_ProcessInformation )
	{
		BOOL t_Retry = TRUE ;
		while ( t_Retry )
		{
			NTSTATUS t_Status = NtQuerySystemInformation (

				SystemProcessInformation,
				a_ProcessInformation,
				t_ProcessInformationSize,
				NULL
			) ;

			if ( t_Status == STATUS_INFO_LENGTH_MISMATCH )
			{
				delete [] a_ProcessInformation  ;
				a_ProcessInformation = NULL ;
				t_ProcessInformationSize += 32768 ;
				a_ProcessInformation = ( SYSTEM_PROCESS_INFORMATION * ) new BYTE [ t_ProcessInformationSize ] ;
				if ( ! a_ProcessInformation )
				{
					return WBEM_E_OUT_OF_MEMORY ;
				}
			}
			else
			{
				t_Retry = FALSE ;

				if ( ! NT_SUCCESS ( t_Status ) )
				{
					delete [] a_ProcessInformation;
					a_ProcessInformation = NULL ;
				}
			}
		}
	}
	else
	{
		return WBEM_E_OUT_OF_MEMORY ;
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CProvider_IWbemServices :: GetProcessInformation (

	SYSTEM_PROCESS_INFORMATION *&a_ProcessInformation
)
{
	HRESULT t_Result = S_OK ;

	if ( FAILED ( EnablePrivilegeOnCurrentThread ( SE_DEBUG_NAME ) ) )
    {
		t_Result = WBEM_E_ACCESS_DENIED ;
    }
	else
	{
		return GetProcessBlocks ( a_ProcessInformation ) ;
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CProvider_IWbemServices :: GetProcessParameters (

	HANDLE a_Process ,
	wchar_t *&a_ProcessCommandLine
)
{
	HRESULT t_Result = WBEM_E_FAILED ;

    PROCESS_BASIC_INFORMATION t_BasicInfo ;

    NTSTATUS t_Status = NtQueryInformationProcess (

        a_Process ,
        ProcessBasicInformation ,
        & t_BasicInfo ,
        sizeof ( t_BasicInfo ) ,
        NULL
	) ;

    if ( NT_SUCCESS ( t_Status ) )
	{
		PEB *t_Peb = t_BasicInfo.PebBaseAddress ;

		RTL_USER_PROCESS_PARAMETERS *t_ProcessParameters = NULL ;

		BOOL t_Success = ReadProcessMemory (

			a_Process,
			& t_Peb->ProcessParameters,
			& t_ProcessParameters,
			sizeof ( t_ProcessParameters ) ,
			NULL
		) ;

		if ( t_Success )
		{
			RTL_USER_PROCESS_PARAMETERS t_Parameters ;

			t_Success = ReadProcessMemory (

				a_Process,
				t_ProcessParameters,
				& t_Parameters ,
				sizeof ( RTL_USER_PROCESS_PARAMETERS ) ,
				NULL
			) ;

			if ( t_Success )
			{
				a_ProcessCommandLine = new wchar_t [ t_Parameters.CommandLine.MaximumLength ];

				t_Success = ReadProcessMemory (

					a_Process,
					t_Parameters.CommandLine.Buffer ,
					a_ProcessCommandLine ,
					t_Parameters.CommandLine.MaximumLength ,
					NULL
				) ;

				if ( t_Success )
				{
					t_Result = S_OK ;
				}
			}
		}
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CProvider_IWbemServices :: CreateInstanceEnumAsync_Process_Load (

	SYSTEM_PROCESS_INFORMATION *a_ProcessInformation ,
	IWbemClassObject *a_Instance 
)
{
	HRESULT t_Result = S_OK ;

	_IWmiObject *t_FastInstance = NULL ;
	t_Result = a_Instance->QueryInterface ( IID__IWmiObject , ( void ** ) & t_FastInstance ) ;
	if ( SUCCEEDED ( t_Result ) )
	{
		wchar_t t_Handle [ _MAX_PATH ] ;
		_ui64tow ( HandleToUlong ( a_ProcessInformation->UniqueProcessId ) , t_Handle , 10 ) ;
		Set_String ( a_Instance , L"Handle" , t_Handle ) ;

		Set_Uint32 ( t_FastInstance , L"ProcessId" , HandleToUlong ( a_ProcessInformation->UniqueProcessId )  ) ;

		if ( a_ProcessInformation->ImageName.Buffer )
		{
			Set_String ( a_Instance , L"Name" , a_ProcessInformation->ImageName.Buffer ) ;
			Set_String ( a_Instance , L"Caption" , a_ProcessInformation->ImageName.Buffer ) ;
			Set_String ( a_Instance , L"Description" , a_ProcessInformation->ImageName.Buffer ) ;
		}
		else
		{
			switch ( HandleToUlong ( a_ProcessInformation->UniqueProcessId ) )
			{
				case 0:
				{
					Set_String ( a_Instance , L"Name" , L"System Idle Process" ) ;
					Set_String ( a_Instance , L"Caption" , L"System Idle Process" ) ;
					Set_String ( a_Instance , L"Description" , L"System Idle Process" ) ;
				}
				break ;

				case 2:
				case 8:
				{
					Set_String ( a_Instance , L"Name" , L"System" ) ;
					Set_String ( a_Instance , L"Caption" , L"System" ) ;
					Set_String ( a_Instance , L"Description" , L"System" ) ;
				}
				break ;

				default:
				{
					Set_String ( a_Instance , L"Name" , L"Unknown" ) ;
					Set_String ( a_Instance , L"Caption" , L"Unknown" ) ;
					Set_String ( a_Instance , L"Description" , L"Unknown" ) ;
				}
				break ;
			}
		}

		Set_String ( a_Instance , L"CSCreationClassName"	, L"Win32_ComputerSystem"	) ;
		Set_String ( a_Instance , L"CSName"					, m_ComputerName			) ;
		Set_String ( a_Instance , L"OSCreationClassName"	, L"Win32_OperatingSystem"	) ;
		Set_String ( a_Instance , L"WindowsVersion"			, m_OperatingSystemVersion	) ;
		Set_String ( a_Instance , L"OSName"					, m_OperatingSystemRunning	) ;

		Set_Uint32 ( t_FastInstance , L"ProcessId" , HandleToUlong ( a_ProcessInformation->UniqueProcessId )  ) ;

		Set_Uint32 ( t_FastInstance , L"PageFaults" , a_ProcessInformation->PageFaultCount ) ;
		Set_Uint32 ( t_FastInstance , L"PeakWorkingSetSize" , a_ProcessInformation->PeakWorkingSetSize ) ;
		Set_Uint64 ( t_FastInstance , L"WorkingSetSize" , (const unsigned __int64) a_ProcessInformation->WorkingSetSize ) ;
		Set_Uint32 ( t_FastInstance , L"QuotaPeakPagedPoolUsage" , a_ProcessInformation->QuotaPeakPagedPoolUsage ) ;
		Set_Uint32 ( t_FastInstance , L"QuotaPagedPoolUsage" , a_ProcessInformation->QuotaPagedPoolUsage ) ;
		Set_Uint32 ( t_FastInstance , L"QuotaPeakNonPagedPoolUsage" , a_ProcessInformation->QuotaPeakNonPagedPoolUsage ) ;
		Set_Uint32 ( t_FastInstance , L"QuotaNonPagedPoolUsage" , a_ProcessInformation->QuotaNonPagedPoolUsage ) ;
		Set_Uint32 ( t_FastInstance , L"PageFileUsage" , a_ProcessInformation->PagefileUsage ) ;
		Set_Uint32 ( t_FastInstance , L"PeakPageFileUsage" , a_ProcessInformation->PeakPagefileUsage ) ;
		Set_Uint32 ( t_FastInstance , L"Priority" , a_ProcessInformation->BasePriority ) ;

		if ( a_ProcessInformation->CreateTime.u.HighPart > 0 )
		{
			Set_DateTime ( a_Instance , L"CreationDate" , * ( FILETIME * ) ( & a_ProcessInformation->CreateTime.u ) ) ;
		}

		Set_Uint32 ( t_FastInstance , L"ThreadCount" , a_ProcessInformation->NumberOfThreads ) ;
		Set_Uint32 ( t_FastInstance , L"ParentProcessId" , HandleToUlong ( a_ProcessInformation->InheritedFromUniqueProcessId ) ) ;
		Set_Uint32 ( t_FastInstance , L"HandleCount" , a_ProcessInformation->HandleCount ) ;
		Set_Uint32 ( t_FastInstance , L"SessionId" , a_ProcessInformation->SessionId ) ;
		Set_Uint64 ( t_FastInstance , L"KernelModeTime" , (const unsigned __int64) a_ProcessInformation->KernelTime.QuadPart ) ;
		Set_Uint64 ( t_FastInstance , L"UserModeTime" , (const unsigned __int64) a_ProcessInformation->UserTime.QuadPart ) ;
		Set_Uint64 ( t_FastInstance , L"PrivatePageCount" , (const unsigned __int64) a_ProcessInformation->PrivatePageCount ) ;
		Set_Uint64 ( t_FastInstance , L"PeakVirtualSize" , (const unsigned __int64) a_ProcessInformation->PeakVirtualSize ) ;
		Set_Uint64 ( t_FastInstance , L"VirtualSize" , (const unsigned __int64) a_ProcessInformation->VirtualSize ) ;
		Set_Uint64 ( t_FastInstance , L"ReadOperationCount" , (const unsigned __int64) a_ProcessInformation->ReadOperationCount.QuadPart ) ;
		Set_Uint64 ( t_FastInstance , L"WriteOperationCount" , (const unsigned __int64) a_ProcessInformation->WriteOperationCount.QuadPart ) ;
		Set_Uint64 ( t_FastInstance , L"OtherOperationCount" , (const unsigned __int64) a_ProcessInformation->OtherOperationCount.QuadPart ) ;
		Set_Uint64 ( t_FastInstance , L"ReadTransferCount" , (const unsigned __int64) a_ProcessInformation->ReadTransferCount.QuadPart ) ;
		Set_Uint64 ( t_FastInstance , L"WriteTransferCount" , (const unsigned __int64) a_ProcessInformation->WriteTransferCount.QuadPart ) ;
		Set_Uint64 ( t_FastInstance , L"OtherTransferCount" , (const unsigned __int64) a_ProcessInformation->OtherTransferCount.QuadPart ) ;

		HANDLE t_ProcessHandle = OpenProcess (

			PROCESS_QUERY_INFORMATION | PROCESS_VM_READ,
			FALSE,
			HandleToUlong ( a_ProcessInformation->UniqueProcessId )
		) ;

		if ( t_ProcessHandle )
		{
			wchar_t *t_ExecutableName = NULL ;
			t_Result = GetProcessExecutable ( t_ProcessHandle , t_ExecutableName ) ;
			if ( SUCCEEDED ( t_Result ) )
			{
				Set_String ( a_Instance , L"ExecutablePath" , t_ExecutableName );
				delete [] t_ExecutableName ;
			}

			QUOTA_LIMITS QuotaLimits;
			NTSTATUS Status = NtQueryInformationProcess (

				t_ProcessHandle,
				ProcessQuotaLimits,
				&QuotaLimits,
				sizeof(QuotaLimits),
				NULL
			);

			if ( NT_SUCCESS ( Status ) )
			{
				Set_Uint32 ( t_FastInstance , L"MinimumWorkingSetSize" , QuotaLimits.MinimumWorkingSetSize ) ;
				Set_Uint32 ( t_FastInstance , L"MaximumWorkingSetSize" , QuotaLimits.MaximumWorkingSetSize ) ;
			}

			wchar_t *t_CommandParameters = NULL ;

			t_Result = GetProcessParameters (

				t_ProcessHandle ,
				t_CommandParameters
			) ;

			if ( SUCCEEDED ( t_Result ) )
			{
				Set_String ( a_Instance , L"CommandLine" , t_CommandParameters ) ;
				delete [] t_CommandParameters ;
			}

			CloseHandle ( t_ProcessHandle ) ;
		}

		t_FastInstance->Release () ;
	}

	return t_Result ;
}
/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CProvider_IWbemServices :: CreateInstanceEnumAsync_Process (

	long a_Flags , 
	IWbemContext __RPC_FAR *a_Context,
	IWbemObjectSink FAR *a_Sink
)
{
	HRESULT t_Result = S_OK ;

	SYSTEM_PROCESS_INFORMATION *t_ProcessBlock = NULL ;

	t_Result = GetProcessInformation ( t_ProcessBlock ) ;
	if ( SUCCEEDED ( t_Result ) ) 
	{
		ULONG t_Count = 0 ; 
		SYSTEM_PROCESS_INFORMATION *t_CurrentInformation = t_ProcessBlock ;
		while ( SUCCEEDED ( t_Result ) && t_CurrentInformation )
		{
			t_Count ++ ;
			t_Result = NextProcessBlock ( t_CurrentInformation , t_CurrentInformation ) ;
		}

		if ( t_Count )
		{
			ULONG t_Index = 0 ;

			IWbemClassObject **t_ObjectArray = new IWbemClassObject * [ t_Count ] ;

			t_CurrentInformation = t_ProcessBlock ;
			while ( SUCCEEDED ( t_Result ) && t_CurrentInformation )
			{
				IWbemClassObject *t_Instance = NULL ;
				t_Result = m_Win32_Process_Object->SpawnInstance ( 

					0 , 
					& t_ObjectArray [ t_Index ]
				) ;

				if ( SUCCEEDED ( t_Result ) )
				{
					t_Result = CreateInstanceEnumAsync_Process_Load (

						t_CurrentInformation ,
						t_ObjectArray [ t_Index ]
					) ;
				}

				t_Index ++ ;

				t_Result = NextProcessBlock ( t_CurrentInformation , t_CurrentInformation ) ;
			}

			t_Result = a_Sink->Indicate ( t_Count , t_ObjectArray ) ;
			for ( t_Index = 0 ; t_Index < t_Count ; t_Index ++ )
			{
				t_ObjectArray [ t_Index ]->Release () ;
			}
		}

		delete [] ( BYTE * ) t_ProcessBlock ;
	}

	return t_Result ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\provsubsys\provider\precomp.h ===
/*++

Copyright (C) 1996-2001 Microsoft Corporation

Module Name:

	Precomp.h

Abstract:


History:

--*/


#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>

#include <windows.h>
#include <stdio.h> 
#include <stdlib.h> 
#include <string.h> 
#include <tchar.h>
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\provsubsys\performance\include\task.h ===
/*++

Copyright (C) 1996-2001 Microsoft Corporation

Module Name:

	ProvFact.h

Abstract:


History:

--*/

#ifndef _Task_H
#define _Task_H

#include <Thread.h>
#include "Service.h"

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

class CProviderSink : public IWbemObjectSink 
{
private:

	HRESULT m_Result ;
	LONG m_ReferenceCount ;

	HANDLE m_Event ;

protected:

public:

    HRESULT STDMETHODCALLTYPE SetStatus (
        long lFlags,
        HRESULT hResult,
        BSTR strParam,
        IWbemClassObject *pObjParam
	)
	{
		m_Result = hResult ;

		SetEvent ( m_Event ) ;

		return S_OK ;
	}

    HRESULT STDMETHODCALLTYPE Indicate (

        LONG lObjectCount,
        IWbemClassObject **apObjArray
	)
	{
#if 0
		for ( LONG t_Index = 0 ; t_Index < lObjectCount ; t_Index ++ )
		{
			IWbemClassObject *t_Object = apObjArray [ t_Index ] ;

			VARIANT t_Variant ;
			VariantInit ( & t_Variant ) ;
		
			LONG t_VarType = 0 ;
			LONG t_Flavour = 0 ;

			wprintf ( L"\n" ) ;

			HRESULT t_Result = t_Object->Get ( L"Handle" , 0 , & t_Variant , & t_VarType , & t_Flavour ) ;
			if( SUCCEEDED ( t_Result ) )
			{
				wprintf ( L"%s", t_Variant.bstrVal ) ;

				VariantClear ( & t_Variant ) ;
			}

			t_Result = t_Object->Get ( L"Name" , 0 , & t_Variant , & t_VarType , & t_Flavour ) ;
			if( SUCCEEDED ( t_Result ) )
			{
				wprintf ( L"\t%s", t_Variant.bstrVal ) ;

				VariantClear ( & t_Variant ) ;
			}
		}
#endif

		return S_OK ;
	}

	CProviderSink () : m_ReferenceCount ( 0 ) , m_Event ( NULL ) , m_Result ( S_OK ) 
	{
		m_Event = CreateEvent ( NULL , FALSE , FALSE , NULL ) ;
	}

	~CProviderSink () 
	{
		if ( m_Event ) 
		{
			CloseHandle ( m_Event ) ;
		}
	}

	STDMETHODIMP QueryInterface (

		REFIID iid , 
		LPVOID FAR *iplpv 
	) 
	{
		*iplpv = NULL ;

		if ( iid == IID_IUnknown )
		{
			*iplpv = ( LPVOID ) this ;
		}
		else if ( iid == IID_IWbemObjectSink )
		{
			*iplpv = ( LPVOID ) this ;		
		}	

		if ( *iplpv )
		{
			( ( LPUNKNOWN ) *iplpv )->AddRef () ;

			return ResultFromScode ( S_OK ) ;
		}
		else
		{
			return ResultFromScode ( E_NOINTERFACE ) ;
		}
	}

	STDMETHODIMP_( ULONG ) AddRef ()
	{
		return InterlockedIncrement ( & m_ReferenceCount ) ;
	}

	STDMETHODIMP_(ULONG) Release ()
	{
		LONG ref ;
		if ( ( ref = InterlockedDecrement ( & m_ReferenceCount ) ) == 0 )
		{
			delete this ;
			return 0 ;
		}
		else
		{
			return ref ;
		}
	}

	void Wait () 
	{
		WaitForSingleObject ( m_Event , INFINITE ) ;
	}

	HRESULT GetResult () { return m_Result ; }
} ;

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

class Task_Execute : public WmiTask < ULONG > 
{
private:

	ULONG m_Count ;
	ULONG m_Index ;
	WmiAllocator &m_Allocator ;
	CProvider_IWbemServices *m_ProviderService ;

	HRESULT m_Result ;

	IWbemServices *m_WmiService ;

	HRESULT GetClass (

		IWbemServices *a_Service , 
		LPCWSTR a_Class
	) ;

	HRESULT GetInstance (

		IWbemServices *a_Service , 
		LPCWSTR a_Instance
	) ;

	HRESULT CreateInstanceEnumSync (

		IWbemServices *a_Service , 
		LPCWSTR a_Class ,
		ULONG a_BatchSize 
	) ;

	HRESULT CreateInstanceEnumForwardSync (

		IWbemServices *a_Service , 
		LPCWSTR a_Class ,
		ULONG a_BatchSize 
	) ;

	HRESULT CreateInstanceEnumSemiSync (

		IWbemServices *a_Service , 
		LPCWSTR a_Class ,
		ULONG a_BatchSize 
	) ;

	HRESULT CreateInstanceEnumASync (

		IWbemServices *a_Service , 
		LPCWSTR a_Class
	) ;

	HRESULT ExecQueryASync (

		IWbemServices *a_Service , 
		LPCWSTR a_Class
	) ;

	HRESULT Function_ASync () ;

	HRESULT Function_SemiSync ( ULONG a_BatchSize ) ;

	HRESULT Function_Sync ( ULONG a_BatchSize ) ;

	HRESULT Function_ForwardSync ( ULONG a_BatchSize ) ;

	HRESULT Function () ;

protected:

public:	/* Internal */

    Task_Execute ( WmiAllocator & a_Allocator , ULONG a_Count ) ;
    ~Task_Execute () ;

	WmiStatusCode Process ( WmiThread <ULONG> &a_Thread ) ;

	HRESULT GetResultCode () { return m_Result ; }
};

#endif // _Task_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\provsubsys\provider\classservice.cpp ===
/*++

Copyright (C) 1996-2001 Microsoft Corporation

Module Name:

	XXXX

Abstract:


History:

--*/

#include <precomp.h>
#include <objbase.h>
#include <wbemcli.h>
#include <wbemint.h>
#include "Globals.h"
#include "ClassService.h"

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

CClassProvider_IWbemServices :: CClassProvider_IWbemServices (

	 WmiAllocator &a_Allocator 

) : m_ReferenceCount ( 0 ) , 
	m_Allocator ( a_Allocator ) ,
	m_User ( NULL ) ,
	m_Locale ( NULL ) ,
	m_Namespace ( NULL ) ,
	m_Empty ( NULL ) 
{
	InitializeCriticalSection ( & m_CriticalSection ) ;

	InterlockedIncrement ( & Provider_Globals :: s_ObjectsInProgress ) ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

CClassProvider_IWbemServices :: ~CClassProvider_IWbemServices ()
{
	DeleteCriticalSection ( & m_CriticalSection ) ;

	if ( m_Empty )
	{
		m_Empty->Release () ;
	}

	if ( m_User ) 
	{
		SysFreeString ( m_User ) ;
	}

	if ( m_Locale ) 
	{
		SysFreeString ( m_Locale ) ;
	}

	if ( m_Namespace ) 
	{
		SysFreeString ( m_Namespace ) ;
	}

	if ( m_CoreService ) 
	{
		m_CoreService->Release () ;
	}

	InterlockedDecrement ( & Provider_Globals :: s_ObjectsInProgress ) ;

}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

STDMETHODIMP_(ULONG) CClassProvider_IWbemServices :: AddRef ( void )
{
	return InterlockedIncrement ( & m_ReferenceCount ) ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

STDMETHODIMP_(ULONG) CClassProvider_IWbemServices :: Release ( void )
{
	LONG t_Reference ;
	if ( ( t_Reference = InterlockedDecrement ( & m_ReferenceCount ) ) == 0 )
	{
		delete this ;
		return 0 ;
	}
	else
	{
		return t_Reference ;
	}
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

STDMETHODIMP CClassProvider_IWbemServices :: QueryInterface (

	REFIID iid , 
	LPVOID FAR *iplpv 
) 
{
	*iplpv = NULL ;

	if ( iid == IID_IUnknown )
	{
		*iplpv = ( LPVOID ) this ;
	}
	else if ( iid == IID_IWbemServices )
	{
		*iplpv = ( LPVOID ) ( IWbemServices * ) this ;		
	}	
	else if ( iid == IID_IWbemPropertyProvider )
	{
		*iplpv = ( LPVOID ) ( IWbemPropertyProvider * ) this ;		
	}	
	else if ( iid == IID_IWbemProviderInit )
	{
		*iplpv = ( LPVOID ) ( IWbemProviderInit * ) this ;		
	}	
	else if ( iid == IID_IWbemShutdown )
	{
		*iplpv = ( LPVOID ) ( IWbemShutdown * ) this ;		
	}	
/*
	else if ( iid == IID_IWmi_Status )
	{
		*iplpv = ( LPVOID ) ( IWmi_Status * )this ;		
	}	
*/

	if ( *iplpv )
	{
		( ( LPUNKNOWN ) *iplpv )->AddRef () ;

		return ResultFromScode ( S_OK ) ;
	}
	else
	{
		return ResultFromScode ( E_NOINTERFACE ) ;
	}
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CClassProvider_IWbemServices::OpenNamespace ( 

	const BSTR ObjectPath, 
	long lFlags, 
	IWbemContext FAR* pCtx,
	IWbemServices FAR* FAR* pNewContext, 
	IWbemCallResult FAR* FAR* ppErrorObject
)
{
	return WBEM_E_NOT_AVAILABLE ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CClassProvider_IWbemServices :: CancelAsyncCall ( 
		
	IWbemObjectSink __RPC_FAR *pSink
)
{
	HRESULT t_Result = WBEM_E_NOT_AVAILABLE ;

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CClassProvider_IWbemServices :: QueryObjectSink ( 

	long lFlags,		
	IWbemObjectSink FAR* FAR* ppResponseHandler
) 
{
	return WBEM_E_NOT_AVAILABLE ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CClassProvider_IWbemServices :: GetObject ( 
		
	const BSTR ObjectPath,
    long lFlags,
    IWbemContext FAR *pCtx,
    IWbemClassObject FAR* FAR *ppObject,
    IWbemCallResult FAR* FAR *ppCallResult
)
{
	return WBEM_E_NOT_AVAILABLE ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CClassProvider_IWbemServices :: GetObjectAsync ( 
		
	const BSTR ObjectPath, 
	long lFlags, 
	IWbemContext FAR *pCtx,
	IWbemObjectSink FAR* pSink
) 
{
	HRESULT t_Result = WBEM_E_NOT_FOUND ;

    if ( _wcsicmp ( ObjectPath , L"Steve_Class" ) == 0 )
    {
        IWbemClassObject *t_Class = NULL;
    
        t_Result = BuildClass ( & t_Class ) ;

        if ( SUCCEEDED ( t_Result ) )
        {
            pSink->Indicate ( 1, & t_Class ) ;
            pSink->SetStatus ( 0, WBEM_NO_ERROR, 0, 0);
            
            t_Class->Release() ;
        }        
    }

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CClassProvider_IWbemServices :: PutClass ( 
		
	IWbemClassObject FAR* pObject, 
	long lFlags, 
	IWbemContext FAR *pCtx,
	IWbemCallResult FAR* FAR* ppCallResult
) 
{
	return WBEM_E_NOT_AVAILABLE ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CClassProvider_IWbemServices :: PutClassAsync ( 
		
	IWbemClassObject FAR* pObject, 
	long lFlags, 
	IWbemContext FAR *pCtx,
	IWbemObjectSink FAR* pResponseHandler
) 
{
 	 return WBEM_E_NOT_FOUND ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CClassProvider_IWbemServices :: DeleteClass ( 
		
	const BSTR Class, 
	long lFlags, 
	IWbemContext FAR *pCtx,
	IWbemCallResult FAR* FAR* ppCallResult
) 
{
 	 return WBEM_E_NOT_AVAILABLE ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CClassProvider_IWbemServices :: DeleteClassAsync ( 
		
	const BSTR Class, 
	long lFlags, 
	IWbemContext FAR *pCtx,
	IWbemObjectSink FAR* pResponseHandler
) 
{
 	 return WBEM_E_NOT_AVAILABLE ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CClassProvider_IWbemServices :: CreateClassEnum ( 

	const BSTR Superclass, 
	long lFlags, 
	IWbemContext FAR *pCtx,
	IEnumWbemClassObject FAR *FAR *ppEnum
) 
{
	return WBEM_E_NOT_AVAILABLE ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

SCODE CClassProvider_IWbemServices :: CreateClassEnumAsync (

	const BSTR SuperClass, 
	long lFlags, 
	IWbemContext FAR* pCtx,
	IWbemObjectSink FAR* pSink
) 
{
	HRESULT t_Result = WBEM_E_NOT_FOUND ;

    IWbemClassObject *t_Class = NULL ;
    
	if ( ( lFlags & ( WBEM_FLAG_DEEP | WBEM_FLAG_SHALLOW ) ) == WBEM_FLAG_DEEP )
	{
		if ( ( _wcsicmp ( SuperClass, L"Steve" ) == 0 ) || ( _wcsicmp ( SuperClass, L"" ) == 0 ) )
		{
			t_Result = BuildClass ( & t_Class ) ;

			if ( SUCCEEDED ( t_Result ) )
			{
				pSink->Indicate ( 1 , & t_Class ) ;
				pSink->SetStatus ( 0 , WBEM_NO_ERROR, NULL , NULL ) ;

			}        
		}
	}
	else
	{
		if ( ( _wcsicmp ( SuperClass, L"Steve" ) == 0 ) || ( _wcsicmp ( SuperClass, L"" ) == 0 ) )
		{
			t_Result = BuildClass ( & t_Class ) ;

			if ( SUCCEEDED ( t_Result ) )
			{
				pSink->Indicate ( 1 , & t_Class ) ;
				pSink->SetStatus ( 0 , WBEM_NO_ERROR, NULL , NULL ) ;

			}        
		}
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CClassProvider_IWbemServices :: PutInstance (

    IWbemClassObject FAR *pInst,
    long lFlags,
    IWbemContext FAR *pCtx,
	IWbemCallResult FAR *FAR *ppCallResult
) 
{
	return WBEM_E_NOT_AVAILABLE ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CClassProvider_IWbemServices :: PutInstanceAsync ( 
		
	IWbemClassObject FAR* pInst, 
	long lFlags, 
    IWbemContext FAR *pCtx,
	IWbemObjectSink FAR* pSink
) 
{
	HRESULT t_Result = WBEM_E_NOT_AVAILABLE ;

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CClassProvider_IWbemServices :: DeleteInstance ( 

	const BSTR ObjectPath,
    long lFlags,
    IWbemContext FAR *pCtx,
    IWbemCallResult FAR *FAR *ppCallResult
)
{
	return WBEM_E_NOT_AVAILABLE ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/
        
HRESULT CClassProvider_IWbemServices :: DeleteInstanceAsync (
 
	const BSTR ObjectPath,
    long lFlags,
    IWbemContext __RPC_FAR *pCtx,
    IWbemObjectSink __RPC_FAR *pSink	
)
{
	HRESULT t_Result = WBEM_E_NOT_AVAILABLE ;

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CClassProvider_IWbemServices :: CreateInstanceEnum ( 

	const BSTR a_Class, 
	long a_Flags, 
	IWbemContext FAR *a_Context, 
	IEnumWbemClassObject __RPC_FAR *__RPC_FAR *a_Enum
)
{
	HRESULT t_Result = WBEM_E_NOT_AVAILABLE  ;

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CClassProvider_IWbemServices :: CreateInstanceEnumAsync (

 	const BSTR a_Class ,
	long a_Flags , 
	IWbemContext __RPC_FAR *a_Context,
	IWbemObjectSink FAR *a_Sink

) 
{
	return WBEM_E_NOT_AVAILABLE ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CClassProvider_IWbemServices :: ExecQuery ( 

	const BSTR QueryLanguage, 
	const BSTR Query, 
	long lFlags, 
	IWbemContext FAR *pCtx,
	IEnumWbemClassObject FAR *FAR *ppEnum
)
{
	return WBEM_E_NOT_AVAILABLE ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CClassProvider_IWbemServices :: ExecQueryAsync ( 
		
	const BSTR QueryFormat, 
	const BSTR Query, 
	long lFlags, 
	IWbemContext FAR* pCtx,
	IWbemObjectSink FAR* pSink
) 
{
	HRESULT t_Result = WBEM_E_SHUTTING_DOWN ;

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CClassProvider_IWbemServices :: ExecNotificationQuery ( 

	const BSTR QueryLanguage,
    const BSTR Query,
    long lFlags,
    IWbemContext __RPC_FAR *pCtx,
    IEnumWbemClassObject __RPC_FAR *__RPC_FAR *ppEnum
)
{
	return WBEM_E_NOT_AVAILABLE ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/
        
HRESULT CClassProvider_IWbemServices :: ExecNotificationQueryAsync ( 
            
	const BSTR QueryLanguage,
    const BSTR Query,
    long lFlags,
    IWbemContext __RPC_FAR *pCtx,
    IWbemObjectSink __RPC_FAR *pResponseHandler
)
{
	return WBEM_E_NOT_AVAILABLE ;
}       

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT STDMETHODCALLTYPE CClassProvider_IWbemServices :: ExecMethod ( 

	const BSTR ObjectPath,
    const BSTR MethodName,
    long lFlags,
    IWbemContext FAR *pCtx,
    IWbemClassObject FAR *pInParams,
    IWbemClassObject FAR *FAR *ppOutParams,
    IWbemCallResult FAR *FAR *ppCallResult
)
{
	return WBEM_E_NOT_AVAILABLE ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT STDMETHODCALLTYPE CClassProvider_IWbemServices :: ExecMethodAsync ( 

    const BSTR ObjectPath,
    const BSTR MethodName,
    long lFlags,
    IWbemContext FAR *pCtx,
    IWbemClassObject FAR *pInParams,
	IWbemObjectSink FAR *pSink
) 
{
	HRESULT t_Result = WBEM_E_NOT_AVAILABLE ;

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CClassProvider_IWbemServices :: Initialize (

	LPWSTR a_User,
	LONG a_Flags,
	LPWSTR a_Namespace,
	LPWSTR a_Locale,
	IWbemServices *a_CoreService,         // For anybody
	IWbemContext *a_Context,
	IWbemProviderInitSink *a_Sink     // For init signals
)
{
	HRESULT t_Result = S_OK ;

	if ( a_CoreService ) 
	{
		m_CoreService = a_CoreService ;
		m_CoreService->AddRef () ;

		BSTR t_Class = SysAllocString ( L"Steve" ) ;
		if ( t_Class )
		{
			t_Result = m_CoreService->GetObject (

				t_Class ,
				0,
				a_Context , 
				& m_Empty , 
				0
			) ;
		}
		else
		{
			t_Result = WBEM_E_OUT_OF_MEMORY ;
		}
	}
	else
	{
		t_Result = WBEM_E_INVALID_PARAMETER ;
	}

	if ( SUCCEEDED ( t_Result ) )
	{
		if ( a_User ) 
		{
			m_User = SysAllocString ( a_User ) ;
			if ( m_User == NULL )
			{
				t_Result = WBEM_E_OUT_OF_MEMORY ;
			}
		}
	}

	if ( SUCCEEDED ( t_Result ) )
	{
		if ( a_Locale ) 
		{
			m_Locale = SysAllocString ( a_Locale ) ;
			if ( m_Locale == NULL )
			{
				t_Result = WBEM_E_OUT_OF_MEMORY ;
			}
		}
	}

	if ( SUCCEEDED ( t_Result ) )
	{
		if ( a_Namespace ) 
		{
			m_Namespace = SysAllocString ( a_Namespace ) ;
			if ( m_Namespace == NULL )
			{
				t_Result = WBEM_E_OUT_OF_MEMORY ;
			}
		}
	}
	
	a_Sink->SetStatus ( t_Result , 0 ) ;

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CClassProvider_IWbemServices :: Shutdown (

	LONG a_Flags ,
	ULONG a_MaxMilliSeconds ,
	IWbemContext *a_Context
)
{
	HRESULT t_Result = S_OK ;

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CClassProvider_IWbemServices :: BuildClass (

    IWbemClassObject **a_Class 
)
{
	HRESULT t_Result = S_OK ;

    IWbemClassObject *t_Class = NULL ;

    t_Result = m_Empty->Clone ( & t_Class ) ;
	if ( SUCCEEDED ( t_Result ) )
	{
		// Class name.
		// ===========
        
		BSTR t_ClassName = SysAllocString ( L"__CLASS" ) ;
		if ( t_ClassName )
		{
			VARIANT t_Variant ;
			VariantInit ( & t_Variant ) ;

			V_VT(&t_Variant) = VT_BSTR ;
			V_BSTR(&t_Variant) = SysAllocString ( L"Steve_Class" ) ;

			t_Result = t_Class->Put ( t_ClassName , 0, & t_Variant , 0 ) ;
			if ( SUCCEEDED ( t_Result ) )
			{

			// Key property.
			// =============

				BSTR t_KeyName = SysAllocString ( L"KeyProperty" ) ;
				if ( t_KeyName )
				{
					t_Result = t_Class->Put ( t_KeyName , 0 , NULL , CIM_STRING ) ;
					if ( SUCCEEDED ( t_Result ) )
					{
						IWbemQualifierSet *t_QualifierSet = NULL ;

						t_Result = t_Class->GetPropertyQualifierSet ( t_KeyName , &t_QualifierSet ) ;
						if ( SUCCEEDED ( t_Result ) )
						{
							VARIANT t_KeyVariant ;
							VariantInit ( & t_KeyVariant ) ;

							V_VT( & t_KeyVariant ) = VT_BOOL ;
							V_BOOL( & t_KeyVariant ) = VARIANT_TRUE ;

							BSTR t_Key = SysAllocString ( L"Key" ) ;
							if ( t_Key )
							{
								t_Result = t_QualifierSet->Put ( t_Key , & t_KeyVariant , 0 ) ;
								if ( SUCCEEDED ( t_Result ) )
								{
									*a_Class = t_Class ;
								}

								SysFreeString ( t_Key ) ;
							}

							VariantClear ( & t_KeyVariant ) ;

							t_QualifierSet->Release() ;
						}
					}

					SysFreeString ( t_KeyName ) ;
				}
				else
				{
					t_Result = WBEM_E_OUT_OF_MEMORY ;
				}
			}

			VariantClear ( & t_Variant ) ;

			SysFreeString ( t_ClassName ) ;
		}
		else
		{
			t_Result = WBEM_E_OUT_OF_MEMORY ;
		}
	}

    return t_Result ;        
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\provsubsys\performance\include\service.h ===
/*++

Copyright (C) 1996-2001 Microsoft Corporation

Module Name:

	ProvResv.H

Abstract:


History:

--*/

#ifndef _Provider_IWbemServices_H
#define _Provider_IWbemServices_H

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

class CProvider_InitializationSink : public IWbemProviderInitSink 
{
private:

	LONG m_ReferenceCount ;

	BOOL m_StatusCalled ;

	HANDLE m_Event ;

	HRESULT m_Result ;

protected:

public:

    HRESULT STDMETHODCALLTYPE SetStatus (

        LONG a_Status,
        LONG a_Flags 
	)
	{
		m_Result = a_Status ;

		SetEvent ( m_Event ) ;
		return S_OK ;
	}

	CProvider_InitializationSink () : m_ReferenceCount ( 0 ) , 
										m_Event ( NULL ) , 
										m_StatusCalled ( FALSE ) , 
										m_Result ( S_OK )
	{
		m_Event = CreateEvent ( NULL , FALSE , FALSE , NULL ) ;
	}

	~CProvider_InitializationSink () 
	{
		if ( m_Event ) 
		{
			CloseHandle ( m_Event ) ;
		}
	}

	STDMETHODIMP QueryInterface (

		REFIID iid , 
		LPVOID FAR *iplpv 
	) 
	{
		*iplpv = NULL ;

		if ( iid == IID_IUnknown )
		{
			*iplpv = ( LPVOID ) this ;
		}
		else if ( iid == IID_IWbemProviderInitSink )
		{
			*iplpv = ( LPVOID ) this ;		
		}	

		if ( *iplpv )
		{
			( ( LPUNKNOWN ) *iplpv )->AddRef () ;

			return ResultFromScode ( S_OK ) ;
		}
		else
		{
			return ResultFromScode ( E_NOINTERFACE ) ;
		}
	}

	STDMETHODIMP_( ULONG ) AddRef ()
	{
		return InterlockedIncrement ( & m_ReferenceCount ) ;
	}

	STDMETHODIMP_(ULONG) Release ()
	{
		LONG t_ReferenceCount = InterlockedDecrement ( & m_ReferenceCount ) ;
		if ( t_ReferenceCount == 0 )
		{
			delete this ;
			return 0 ;
		}
		else
		{
			return t_ReferenceCount ;
		}
	}

	void Wait ( DWORD a_Timeout = 300000 ) 
	{
		if ( WaitForSingleObject ( m_Event , a_Timeout ) == WAIT_TIMEOUT )
		{
			m_Result = WBEM_E_PROVIDER_LOAD_FAILURE ;
		}
	}

	void Reset () 
	{
		ResetEvent ( m_Event ) ;
		m_Result = S_OK ;
	}

	HRESULT GetResult () { return m_Result ; }
} ;

class CProvider_IWbemServices : public IWbemServices , public IWbemPropertyProvider , public IWbemProviderInit , public IWbemShutdown
{
private:

	LONG m_ReferenceCount ;         //Object reference count

	WmiAllocator &m_Allocator ;

	CRITICAL_SECTION m_CriticalSection ;

	IWbemServices *m_CoreService ;

	BSTR m_Namespace ;
	BSTR m_Locale ;
	BSTR m_User ;

	BSTR m_ComputerName ;
	BSTR m_OperatingSystemVersion ;
	BSTR m_OperatingSystemRunning ;
	BSTR m_ProductName ;

	IWbemClassObject *m_Win32_Process_Object ;

private:

	HRESULT GetProductInformation () ;

	HRESULT GetProcessExecutable (

		HANDLE a_Process , 
		wchar_t *&a_ExecutableName
	) ;

	HRESULT CProvider_IWbemServices :: NextProcessBlock (

		SYSTEM_PROCESS_INFORMATION *a_ProcessBlock , 
		SYSTEM_PROCESS_INFORMATION *&a_NextProcessBlock
	) ;

	HRESULT GetProcessBlocks ( SYSTEM_PROCESS_INFORMATION *&a_ProcessInformation ) ;

	HRESULT GetProcessInformation (	SYSTEM_PROCESS_INFORMATION *&a_ProcessInformation ) ;

	HRESULT GetProcessParameters (

		HANDLE a_Process ,
		wchar_t *&a_ProcessCommandLine
	) ;

	HRESULT CreateInstanceEnumAsync_Process_Load (

		SYSTEM_PROCESS_INFORMATION *a_ProcessInformation ,
		IWbemClassObject *a_Instance 
	) ;

	HRESULT CreateInstanceEnumAsync_Process (

 		long a_Flags , 
		IWbemContext __RPC_FAR *a_Context,
		IWbemObjectSink FAR *a_Sink
	) ;

public:

	CProvider_IWbemServices ( WmiAllocator &a_Allocator  ) ;
    ~CProvider_IWbemServices () ;

public:

	//Non-delegating object IUnknown

    STDMETHODIMP QueryInterface ( REFIID , LPVOID FAR * ) ;
    STDMETHODIMP_( ULONG ) AddRef () ;
    STDMETHODIMP_( ULONG ) Release () ;

    /* IWbemServices methods */

    HRESULT STDMETHODCALLTYPE OpenNamespace ( 

        const BSTR a_Namespace ,
        long a_Flags ,
        IWbemContext *a_Context ,
        IWbemServices **a_Service ,
        IWbemCallResult **a_CallResult
	) ;
    
    HRESULT STDMETHODCALLTYPE CancelAsyncCall ( 

        IWbemObjectSink *a_Sink
	) ;
    
    HRESULT STDMETHODCALLTYPE QueryObjectSink ( 

        long a_Flags ,
        IWbemObjectSink **a_Sink
	) ;
    
    HRESULT STDMETHODCALLTYPE GetObject ( 

		const BSTR a_ObjectPath ,
        long a_Flags ,
        IWbemContext *a_Context ,
        IWbemClassObject **ppObject ,
        IWbemCallResult **a_CallResult
	) ;
    
    HRESULT STDMETHODCALLTYPE GetObjectAsync (
        
		const BSTR a_ObjectPath ,
        long a_Flags ,
        IWbemContext *a_Context ,
        IWbemObjectSink *a_Sink
	) ;

    HRESULT STDMETHODCALLTYPE PutClass ( 

        IWbemClassObject *a_Object ,
        long a_Flags ,
        IWbemContext *a_Context ,
        IWbemCallResult **a_CallResult
	) ;
    
    HRESULT STDMETHODCALLTYPE PutClassAsync ( 

        IWbemClassObject *a_Object ,
        long a_Flags ,
        IWbemContext *a_Context ,
        IWbemObjectSink *a_Sink
	) ;
    
    HRESULT STDMETHODCALLTYPE DeleteClass ( 

        const BSTR a_Class ,
        long a_Flags ,
        IWbemContext *a_Context ,
        IWbemCallResult **a_CallResult
	) ;
    
    HRESULT STDMETHODCALLTYPE DeleteClassAsync ( 

        const BSTR a_Class ,
        long a_Flags ,
        IWbemContext *a_Context ,
        IWbemObjectSink *a_Sink
	) ;
    
    HRESULT STDMETHODCALLTYPE CreateClassEnum ( 

        const BSTR a_Superclass ,
        long a_Flags ,
        IWbemContext *a_Context ,
        IEnumWbemClassObject **a_Enum
	) ;
    
    HRESULT STDMETHODCALLTYPE CreateClassEnumAsync ( 

		const BSTR a_Superclass ,
		long a_Flags ,
		IWbemContext *a_Context ,
		IWbemObjectSink *a_Sink
	) ;
    
    HRESULT STDMETHODCALLTYPE PutInstance (

		IWbemClassObject *a_Instance ,
		long a_Flags , 
		IWbemContext *a_Context ,
		IWbemCallResult **a_CallResult
	) ;
    
    HRESULT STDMETHODCALLTYPE PutInstanceAsync (

		IWbemClassObject *a_Instance ,
		long a_Flags ,
		IWbemContext *a_Context ,
		IWbemObjectSink *a_Sink 
	) ;
    
    HRESULT STDMETHODCALLTYPE DeleteInstance ( 

		const BSTR a_ObjectPath ,
		long a_Flags ,
		IWbemContext *a_Context ,
		IWbemCallResult **a_CallResult
	) ;
    
    HRESULT STDMETHODCALLTYPE DeleteInstanceAsync ( 

		const BSTR a_ObjectPath,
		long a_Flags,
		IWbemContext *a_Context ,
		IWbemObjectSink *a_Sink
	) ;
    
    HRESULT STDMETHODCALLTYPE CreateInstanceEnum (

		const BSTR a_Class ,
		long a_Flags ,
		IWbemContext *a_Context ,
		IEnumWbemClassObject **a_Enum
	) ;
    
    HRESULT STDMETHODCALLTYPE CreateInstanceEnumAsync (

		const BSTR a_Class ,
		long a_Flags ,
		IWbemContext *a_Context ,
		IWbemObjectSink *a_Sink
	) ;
    
    HRESULT STDMETHODCALLTYPE ExecQuery ( 

		const BSTR a_QueryLanguage,
		const BSTR a_Query,
		long a_Flags ,
		IWbemContext *a_Context ,
		IEnumWbemClassObject **a_Enum
	) ;
    
    HRESULT STDMETHODCALLTYPE ExecQueryAsync (

		const BSTR a_QueryLanguage ,
		const BSTR a_Query ,
		long a_Flags ,
		IWbemContext *a_Context ,
		IWbemObjectSink *a_Sink
	) ;
    
    HRESULT STDMETHODCALLTYPE ExecNotificationQuery (

		const BSTR a_QueryLanguage ,
		const BSTR a_Query ,
		long a_Flags ,
		IWbemContext *a_Context ,
		IEnumWbemClassObject **a_Enum
	) ;
    
    HRESULT STDMETHODCALLTYPE ExecNotificationQueryAsync ( 

        const BSTR a_QueryLanguage ,
        const BSTR a_Query ,
        long a_Flags ,
        IWbemContext *a_Context ,
        IWbemObjectSink *a_Sink
	) ;
    
    HRESULT STDMETHODCALLTYPE ExecMethod (

        const BSTR a_ObjectPath ,
        const BSTR a_MethodName ,
        long a_Flags ,
        IWbemContext *a_Context ,
        IWbemClassObject *a_InParams ,
        IWbemClassObject **a_OutParams ,
        IWbemCallResult **a_CallResult
	) ;
    
    HRESULT STDMETHODCALLTYPE ExecMethodAsync ( 

		const BSTR a_ObjectPath ,
		const BSTR a_MethodName ,
		long a_Flags ,
		IWbemContext *a_Context ,
		IWbemClassObject *a_InParams ,
		IWbemObjectSink *a_Sink
	) ;

    HRESULT STDMETHODCALLTYPE GetProperty (

        long a_Flags ,
        const BSTR a_Locale ,
        const BSTR a_ClassMapping ,
        const BSTR a_InstanceMapping ,
        const BSTR a_PropertyMapping ,
        VARIANT *a_Value
	) ;
        
    HRESULT STDMETHODCALLTYPE PutProperty (

        long a_Flags ,
        const BSTR a_Locale ,
        const BSTR a_ClassMapping ,
        const BSTR a_InstanceMapping ,
        const BSTR a_PropertyMapping ,
        const VARIANT *a_Value
	) ;

	/* IWbemProviderInit methods */

	HRESULT STDMETHODCALLTYPE Initialize (

		LPWSTR a_User ,
		LONG a_Flags ,
		LPWSTR a_Namespace ,
		LPWSTR a_Locale ,
		IWbemServices *a_Core ,
		IWbemContext *a_Context ,
		IWbemProviderInitSink *a_Sink
	) ;

	// IWmi_UnInitialize members

	HRESULT STDMETHODCALLTYPE Shutdown (

		LONG a_Flags ,
		ULONG a_MaxMilliSeconds ,
		IWbemContext *a_Context
	) ; 
} ;


#endif // _Provider_IWbemServices_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\provsubsys\provider\dll\makefile.inc ===
!include $(_NTDRIVE)$(_NTROOT)\ADMIN\WMI\WBEM\COMMON\makefile.cmn
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\provsubsys\provider\exe\makefile.inc ===
!INCLUDE $(_NTDRIVE)$(_NTROOT)\WMI\COMMON\makefile.cmn
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\provsubsys\provider\include\classfac.h ===
/*++

Copyright (C) 1996-2001 Microsoft Corporation

Module Name:

	ClassFac.h

Abstract:


History:

--*/

#ifndef _ProviderClassFactory_H
#define _ProviderClassFactory_H

template <class Object,class ObjectInterface>
class CProviderClassFactory : public IClassFactory
{
private:

    long m_ReferenceCount ;

protected:
public:

    CProviderClassFactory () ;
    ~CProviderClassFactory ( void ) ;

	//IUnknown members

	STDMETHODIMP QueryInterface ( REFIID , LPVOID FAR * ) ;
    STDMETHODIMP_( ULONG ) AddRef () ;
    STDMETHODIMP_( ULONG ) Release () ;

	//IClassFactory members

    STDMETHODIMP CreateInstance ( LPUNKNOWN , REFIID , LPVOID FAR * ) ;
    STDMETHODIMP LockServer ( BOOL ) ;
};

#include <classfac.cpp>

#endif // _ProviderClassFactory_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\provsubsys\provider\include\classservice.h ===
/*++

Copyright (C) 1996-2001 Microsoft Corporation

Module Name:

	ProvResv.H

Abstract:


History:

--*/

#ifndef _ClassProvider_IWbemServices_H
#define _ClassProvider_IWbemServices_H

class CClassProvider_IWbemServices : public IWbemServices , public IWbemProviderInit , public IWbemShutdown
{
private:

	LONG m_ReferenceCount ;         //Object reference count

	WmiAllocator &m_Allocator ;

	CRITICAL_SECTION m_CriticalSection ;

	IWbemServices *m_CoreService ;
	IWbemClassObject *m_Empty ;

	BSTR m_Namespace ;
	BSTR m_Locale ;
	BSTR m_User ;

	HRESULT BuildClass (

		IWbemClassObject **a_Class 
	) ;

public:

	CClassProvider_IWbemServices ( WmiAllocator &a_Allocator  ) ;
    ~CClassProvider_IWbemServices () ;

public:

	//Non-delegating object IUnknown

    STDMETHODIMP QueryInterface ( REFIID , LPVOID FAR * ) ;
    STDMETHODIMP_( ULONG ) AddRef () ;
    STDMETHODIMP_( ULONG ) Release () ;

    /* IWbemServices methods */

    HRESULT STDMETHODCALLTYPE OpenNamespace ( 

        const BSTR a_Namespace ,
        long a_Flags ,
        IWbemContext *a_Context ,
        IWbemServices **a_Service ,
        IWbemCallResult **a_CallResult
	) ;
    
    HRESULT STDMETHODCALLTYPE CancelAsyncCall ( 

        IWbemObjectSink *a_Sink
	) ;
    
    HRESULT STDMETHODCALLTYPE QueryObjectSink ( 

        long a_Flags ,
        IWbemObjectSink **a_Sink
	) ;
    
    HRESULT STDMETHODCALLTYPE GetObject ( 

		const BSTR a_ObjectPath ,
        long a_Flags ,
        IWbemContext *a_Context ,
        IWbemClassObject **ppObject ,
        IWbemCallResult **a_CallResult
	) ;
    
    HRESULT STDMETHODCALLTYPE GetObjectAsync (
        
		const BSTR a_ObjectPath ,
        long a_Flags ,
        IWbemContext *a_Context ,
        IWbemObjectSink *a_Sink
	) ;

    HRESULT STDMETHODCALLTYPE PutClass ( 

        IWbemClassObject *a_Object ,
        long a_Flags ,
        IWbemContext *a_Context ,
        IWbemCallResult **a_CallResult
	) ;
    
    HRESULT STDMETHODCALLTYPE PutClassAsync ( 

        IWbemClassObject *a_Object ,
        long a_Flags ,
        IWbemContext *a_Context ,
        IWbemObjectSink *a_Sink
	) ;
    
    HRESULT STDMETHODCALLTYPE DeleteClass ( 

        const BSTR a_Class ,
        long a_Flags ,
        IWbemContext *a_Context ,
        IWbemCallResult **a_CallResult
	) ;
    
    HRESULT STDMETHODCALLTYPE DeleteClassAsync ( 

        const BSTR a_Class ,
        long a_Flags ,
        IWbemContext *a_Context ,
        IWbemObjectSink *a_Sink
	) ;
    
    HRESULT STDMETHODCALLTYPE CreateClassEnum ( 

        const BSTR a_Superclass ,
        long a_Flags ,
        IWbemContext *a_Context ,
        IEnumWbemClassObject **a_Enum
	) ;
    
    HRESULT STDMETHODCALLTYPE CreateClassEnumAsync ( 

		const BSTR a_Superclass ,
		long a_Flags ,
		IWbemContext *a_Context ,
		IWbemObjectSink *a_Sink
	) ;
    
    HRESULT STDMETHODCALLTYPE PutInstance (

		IWbemClassObject *a_Instance ,
		long a_Flags , 
		IWbemContext *a_Context ,
		IWbemCallResult **a_CallResult
	) ;
    
    HRESULT STDMETHODCALLTYPE PutInstanceAsync (

		IWbemClassObject *a_Instance ,
		long a_Flags ,
		IWbemContext *a_Context ,
		IWbemObjectSink *a_Sink 
	) ;
    
    HRESULT STDMETHODCALLTYPE DeleteInstance ( 

		const BSTR a_ObjectPath ,
		long a_Flags ,
		IWbemContext *a_Context ,
		IWbemCallResult **a_CallResult
	) ;
    
    HRESULT STDMETHODCALLTYPE DeleteInstanceAsync ( 

		const BSTR a_ObjectPath,
		long a_Flags,
		IWbemContext *a_Context ,
		IWbemObjectSink *a_Sink
	) ;
    
    HRESULT STDMETHODCALLTYPE CreateInstanceEnum (

		const BSTR a_Class ,
		long a_Flags ,
		IWbemContext *a_Context ,
		IEnumWbemClassObject **a_Enum
	) ;
    
    HRESULT STDMETHODCALLTYPE CreateInstanceEnumAsync (

		const BSTR a_Class ,
		long a_Flags ,
		IWbemContext *a_Context ,
		IWbemObjectSink *a_Sink
	) ;
    
    HRESULT STDMETHODCALLTYPE ExecQuery ( 

		const BSTR a_QueryLanguage,
		const BSTR a_Query,
		long a_Flags ,
		IWbemContext *a_Context ,
		IEnumWbemClassObject **a_Enum
	) ;
    
    HRESULT STDMETHODCALLTYPE ExecQueryAsync (

		const BSTR a_QueryLanguage ,
		const BSTR a_Query ,
		long a_Flags ,
		IWbemContext *a_Context ,
		IWbemObjectSink *a_Sink
	) ;
    
    HRESULT STDMETHODCALLTYPE ExecNotificationQuery (

		const BSTR a_QueryLanguage ,
		const BSTR a_Query ,
		long a_Flags ,
		IWbemContext *a_Context ,
		IEnumWbemClassObject **a_Enum
	) ;
    
    HRESULT STDMETHODCALLTYPE ExecNotificationQueryAsync ( 

        const BSTR a_QueryLanguage ,
        const BSTR a_Query ,
        long a_Flags ,
        IWbemContext *a_Context ,
        IWbemObjectSink *a_Sink
	) ;
    
    HRESULT STDMETHODCALLTYPE ExecMethod (

        const BSTR a_ObjectPath ,
        const BSTR a_MethodName ,
        long a_Flags ,
        IWbemContext *a_Context ,
        IWbemClassObject *a_InParams ,
        IWbemClassObject **a_OutParams ,
        IWbemCallResult **a_CallResult
	) ;
    
    HRESULT STDMETHODCALLTYPE ExecMethodAsync ( 

		const BSTR a_ObjectPath ,
		const BSTR a_MethodName ,
		long a_Flags ,
		IWbemContext *a_Context ,
		IWbemClassObject *a_InParams ,
		IWbemObjectSink *a_Sink
	) ;

	/* IWbemProviderInit methods */

	HRESULT STDMETHODCALLTYPE Initialize (

		LPWSTR a_User ,
		LONG a_Flags ,
		LPWSTR a_Namespace ,
		LPWSTR a_Locale ,
		IWbemServices *a_Core ,
		IWbemContext *a_Context ,
		IWbemProviderInitSink *a_Sink
	) ;

	// IWmi_UnInitialize members

	HRESULT STDMETHODCALLTYPE Shutdown (

		LONG a_Flags ,
		ULONG a_MaxMilliSeconds ,
		IWbemContext *a_Context
	) ; 
} ;


#endif // _ClassProvider_IWbemServices_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\provsubsys\provider\main.cpp ===
*++

Copyright (C) 1996-2001 Microsoft Corporation

Module Name:

	Main.cpp

Abstract:


History:

--*/

#include <precomp.h>
#include <objbase.h>
#include <stdio.h>
#include <tchar.h>
#include <wbemcli.h>
#include <wbemint.h>
#include <Exception.h>
#include <HelperFuncs.h>
#include "Globals.h"
#include "ClassFac.h"
#include "Service.h"
#include "Guids.h"

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

DWORD g_Register = 0 ;

STDAPI DllRegisterServer () ;
STDAPI DllUnregisterServer () ;

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

LRESULT CALLBACK WindowsMainProc ( HWND a_hWnd , UINT a_message , WPARAM a_wParam , LPARAM a_lParam )
{
	LRESULT t_rc = 0 ;

	switch ( a_message )
	{
		case WM_DESTROY:
		{
			PostMessage ( a_hWnd , WM_QUIT , 0 , 0 ) ;
		}
		break ;

		default:
		{		
			t_rc = DefWindowProc ( a_hWnd , a_message , a_wParam , a_lParam ) ;
		}
		break ;
	}

	return ( t_rc ) ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HWND WindowsInit ( HINSTANCE a_HInstance )
{
	static wchar_t *t_TemplateCode = L"TemplateCode" ;

	WNDCLASS  t_wc ;
 
	t_wc.style            = CS_HREDRAW | CS_VREDRAW ;
	t_wc.lpfnWndProc      = WindowsMainProc ;
	t_wc.cbClsExtra       = 0 ;
	t_wc.cbWndExtra       = 0 ;
	t_wc.hInstance        = a_HInstance ;
	t_wc.hIcon            = LoadIcon(NULL, IDI_HAND) ;
	t_wc.hCursor          = LoadCursor(NULL, IDC_ARROW) ;
	t_wc.hbrBackground    = (HBRUSH) (COLOR_WINDOW + 1) ;
	t_wc.lpszMenuName     = NULL ;
	t_wc.lpszClassName    = t_TemplateCode ;
 
	ATOM t_winClass = RegisterClass ( &t_wc ) ;

	HWND t_HWnd = CreateWindow (

		t_TemplateCode ,              // see RegisterClass() call
		t_TemplateCode ,                      // text for window title bar
		WS_OVERLAPPEDWINDOW | WS_MINIMIZE ,               // window style
		CW_USEDEFAULT ,                     // default horizontal position
		CW_USEDEFAULT ,                     // default vertical position
		CW_USEDEFAULT ,                     // default width
		CW_USEDEFAULT ,                     // default height
		NULL ,                              // overlapped windows have no parent
		NULL ,                              // use the window class menu
		a_HInstance ,
		NULL                                // pointer not needed
	) ;

	ShowWindow ( t_HWnd, SW_SHOW ) ;
	//ShowWindow ( t_HWnd, SW_HIDE ) ;

	return t_HWnd ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

void WindowsStop ( HWND a_HWnd )
{
	CoUninitialize () ;
	DestroyWindow ( a_HWnd ) ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HWND WindowsStart ( HINSTANCE a_Handle )
{
	HWND t_HWnd = NULL ;
	if ( ! ( t_HWnd = WindowsInit ( a_Handle ) ) )
	{
    }

	return t_HWnd ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

void WindowsDispatch ()
{
	BOOL t_GetMessage ;
	MSG t_lpMsg ;

	while (	( t_GetMessage = GetMessage ( & t_lpMsg , NULL , 0 , 0 ) ) == TRUE )
	{
		TranslateMessage ( & t_lpMsg ) ;
		DispatchMessage ( & t_lpMsg ) ;
	}
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT UninitComServer ()
{
	CoRevokeClassObject ( g_Register );
	CoUninitialize () ;

	return S_OK ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT InitComServer ( DWORD a_AuthenticationLevel , DWORD a_ImpersonationLevel )
{
	HRESULT t_Result = S_OK ;

    t_Result = CoInitializeEx (

		0, 
		COINIT_MULTITHREADED
	);

	if ( SUCCEEDED ( t_Result ) ) 
	{
		t_Result = CoInitializeSecurity (

			NULL, 
			-1, 
			NULL, 
			NULL,
			a_AuthenticationLevel,
			a_ImpersonationLevel, 
			NULL, 
			EOAC_DYNAMIC_CLOAKING, 
			0
		);

		if ( FAILED ( t_Result ) ) 
		{
			CoUninitialize () ;
			return t_Result ;
		}

	}

	IUnknown *t_ClassFactory = new CProviderClassFactory <CProvider_IWbemServices,IWbemServices> ;

	DWORD t_ClassContext = CLSCTX_LOCAL_SERVER ;
	DWORD t_Flags = REGCLS_MULTIPLEUSE ;

	t_Result = CoRegisterClassObject (

		CLSID_WmiProvider, 
		t_ClassFactory,
        t_ClassContext, 
		t_Flags, 
		&g_Register
	);

	if ( FAILED ( t_Result ) )
	{
		CoRevokeClassObject ( g_Register );
	}

	if ( FAILED ( t_Result ) )
	{
		CoUninitialize () ;
	}

	return t_Result  ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT Process ()
{
#if 1
	DWORD t_ImpersonationLevel = RPC_C_IMP_LEVEL_IMPERSONATE ;
	DWORD t_AuthenticationLevel = RPC_C_AUTHN_LEVEL_CONNECT ;
#else
	DWORD t_ImpersonationLevel = RPC_C_IMP_LEVEL_IDENTITY ;
	DWORD t_AuthenticationLevel = RPC_C_AUTHN_LEVEL_NONE ;
#endif

	HRESULT t_Result = InitComServer ( t_AuthenticationLevel , t_ImpersonationLevel ) ;
	if ( SUCCEEDED ( t_Result ) )
	{

		Wmi_SetStructuredExceptionHandler t_StructuredException ;

		try 
		{
			WindowsDispatch () ;
		}
		catch ( Wmi_Structured_Exception t_StructuredException )
		{
		}

		UninitComServer () ;
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

BOOL ParseCommandLine () 
{
	BOOL t_Exit = FALSE ;

	LPTSTR t_CommandLine = GetCommandLine () ;
	if ( t_CommandLine )
	{
		TCHAR *t_Arg = NULL ;
		TCHAR *t_ApplicationArg = NULL ;
		t_ApplicationArg = _tcstok ( t_CommandLine , _TEXT ( " \t" ) ) ;
		t_Arg = _tcstok ( NULL , _TEXT ( " \t" ) ) ;
		if ( t_Arg ) 
		{
			if ( _tcsicmp ( t_Arg , _TEXT ( "/RegServer" ) ) == 0 )
			{
				t_Exit = TRUE ;
				DllRegisterServer () ;
			}
			else if ( _tcsicmp ( t_Arg , _TEXT ( "/UnRegServer" ) ) == 0 )
			{
				t_Exit = TRUE ;
				DllUnregisterServer () ;
			}
		}
	}

	return t_Exit ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

int WINAPI WinMain (
  
    HINSTANCE hInstance,		// handle to current instance
    HINSTANCE hPrevInstance,	// handle to previous instance
    LPSTR lpCmdLine,			// pointer to command line
    int nShowCmd 				// show state of window
)
{
	HRESULT t_Result = Provider_Globals :: Global_Startup () ;
	if ( SUCCEEDED ( t_Result ) )
	{
		BOOL t_Exit = ParseCommandLine () ;
		if ( ! t_Exit ) 
		{
			HWND hWnd = WindowsStart ( hInstance ) ;

			t_Result = Process () ;

			WindowsStop ( hWnd ) ;
		}

		t_Result = Provider_Globals :: Global_Shutdown () ;

	}

	return 0 ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\provsubsys\provider\include\globals.h ===
/*++

Copyright (C) 1996-2001 Microsoft Corporation

Module Name:

	Globals.h

Abstract:


History:

--*/

#ifndef _Globals_H
#define _Globals_H

#include <Allocator.h>

class Provider_Globals
{
public:

	static WmiAllocator *s_Allocator ;

	static LONG s_LocksInProgress ;
	static LONG s_ObjectsInProgress ;

	static HRESULT Global_Startup () ;
	static HRESULT Global_Shutdown () ;

	static HRESULT CreateInstance ( 

		const CLSID &a_ReferenceClsid ,
		LPUNKNOWN a_OuterUnknown ,
		const DWORD &a_ClassContext ,
		const UUID &a_ReferenceInterfaceId ,
		void **a_ObjectInterface
	);
} ;

#endif // _Globals_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\provsubsys\provider\include\resource.h ===
/*++

Copyright (C) 1996-2001 Microsoft Corporation

Module Name:

	Resource.h

Abstract:


History:

--*/

//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by propprov.rc
//

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NO_MFC                     1
#define _APS_NEXT_RESOURCE_VALUE        101
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1000
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\provsubsys\provider\service.cpp ===
/*++

Copyright (C) 1996-2001 Microsoft Corporation

Module Name:

	XXXX

Abstract:


History:

--*/

#include <precomp.h>

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <ntobapi.h>

#define _WINNT_	// have what is needed from above

#include "precomp.h"

#include <objbase.h>
#include <wbemint.h>
#include "Globals.h"
#include "HelperFuncs.h"
#include "DateTime.h"
#include "Service.h"

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT Set_Uint64 (

	_IWmiObject *a_Instance ,
	wchar_t *a_Name ,
	const UINT64 &a_Uint64
)
{
	HRESULT t_Result = a_Instance->WriteProp (

		a_Name , 
		0 , 
		sizeof ( UINT64 ) , 
		0 ,
		CIM_UINT64 ,
		( void * ) & a_Uint64
	) ;

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT Set_Uint32 ( 

	_IWmiObject *a_Instance , 
	wchar_t *a_Name ,
	const DWORD &a_Uint32
)
{
	HRESULT t_Result = a_Instance->WriteProp (

		a_Name , 
		0 , 
		sizeof ( DWORD ) , 
		0 ,
		CIM_UINT32 ,
		( void * ) & a_Uint32
	) ;

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT Set_String ( 

	IWbemClassObject *a_Instance , 
	wchar_t *a_Name ,
	wchar_t *a_String
)
{
	VARIANT t_Variant ;
	VariantInit ( & t_Variant ) ;
	t_Variant.vt = VT_BSTR ;
	t_Variant.bstrVal = SysAllocString ( a_String ) ;
	a_Instance->Put ( a_Name , 0 , & t_Variant , 0 ) ;
	VariantClear ( & t_Variant ) ;

	return S_OK ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT Set_DateTime ( 

	IWbemClassObject *a_Instance , 
	wchar_t *a_Name ,
	FILETIME a_Time
)
{
	CWbemDateTime t_Time ;
	t_Time.SetFileTimeDate ( a_Time , VARIANT_FALSE ) ;

	BSTR t_String ;
	HRESULT t_Result = t_Time.GetValue ( & t_String ) ;
	if ( SUCCEEDED ( t_Result ) ) 
	{
		VARIANT t_Variant ;
		VariantInit ( & t_Variant ) ;
		t_Variant.vt = VT_BSTR ;
		t_Variant.bstrVal = t_String ;
		a_Instance->Put ( a_Name , 0 , & t_Variant , CIM_DATETIME ) ;
		VariantClear ( & t_Variant ) ;
	}

	return t_Result ;
}

HRESULT EnablePrivilegeOnCurrentThread ( wchar_t *a_Privilege )
{
	HRESULT t_Result = WBEM_E_ACCESS_DENIED ;

    HANDLE t_Token = NULL;
	BOOL t_ProcessToken = FALSE ;

    if ( OpenThreadToken ( GetCurrentThread () , TOKEN_ADJUST_PRIVILEGES | TOKEN_QUERY, FALSE , & t_Token ) )
	{
	}
	else
	{	
		t_ProcessToken = TRUE ;
		ImpersonateSelf(SecurityImpersonation) ;
		
		if ( OpenThreadToken ( GetCurrentThread () , TOKEN_ADJUST_PRIVILEGES | TOKEN_QUERY , FALSE , & t_Token ) )
		{
		}
	}

	if ( t_Token )
    {
	    TOKEN_PRIVILEGES t_TokenPrivileges ;

		BOOL t_Status = LookupPrivilegeValue (

			NULL, 
			a_Privilege , 
			& t_TokenPrivileges.Privileges[0].Luid
		) ;

        if (t_Status)
        {
            t_TokenPrivileges.PrivilegeCount = 1;
            t_TokenPrivileges.Privileges[0].Attributes = SE_PRIVILEGE_ENABLED;

            SetLastError(0);

            t_Status = AdjustTokenPrivileges (

				t_Token , 
				FALSE , 
				& t_TokenPrivileges , 
				0 ,
                (PTOKEN_PRIVILEGES) NULL , 
				0
			) ;

			if ( GetLastError() == 0 )
			{
				t_Result = S_OK ;
			}
        }

        CloseHandle ( t_Token ) ;

		if ( t_ProcessToken )
		{
			RevertToSelf () ;
		}
    }

    return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

CProvider_IWbemServices :: CProvider_IWbemServices (

	 WmiAllocator &a_Allocator 

) : m_ReferenceCount ( 0 ) , 
	m_Allocator ( a_Allocator ) ,
	m_User ( NULL ) ,
	m_Locale ( NULL ) ,
	m_Namespace ( NULL ) ,
	m_CoreService ( NULL ) ,
	m_ComputerName  ( NULL ) ,
	m_OperatingSystemVersion ( NULL ) ,
	m_OperatingSystemRunning ( NULL ) , 
	m_ProductName ( NULL ) , 
	m_Win32_ProcessEx_Object ( NULL )
{
	InitializeCriticalSection ( & m_CriticalSection ) ;

	InterlockedIncrement ( & Provider_Globals :: s_ObjectsInProgress ) ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

CProvider_IWbemServices :: ~CProvider_IWbemServices ()
{
	DeleteCriticalSection ( & m_CriticalSection ) ;

	if ( m_User ) 
	{
		SysFreeString ( m_User ) ;
	}

	if ( m_Locale ) 
	{
		SysFreeString ( m_Locale ) ;
	}

	if ( m_Namespace ) 
	{
		SysFreeString ( m_Namespace ) ;
	}

	if ( m_CoreService ) 
	{
		m_CoreService->Release () ;
	}

	if ( m_Win32_ProcessEx_Object ) 
	{
		m_Win32_ProcessEx_Object->Release () ;
	}

	if ( m_ComputerName ) 
	{
		SysFreeString ( m_ComputerName ) ;
	}

	if ( m_OperatingSystemVersion ) 
	{
		SysFreeString ( m_OperatingSystemVersion ) ;
	}

	if ( m_OperatingSystemRunning ) 
	{
		SysFreeString ( m_OperatingSystemRunning ) ;
	}

	if ( m_ProductName )
	{
		SysFreeString ( m_ProductName ) ;
	}

	InterlockedDecrement ( & Provider_Globals :: s_ObjectsInProgress ) ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

STDMETHODIMP_(ULONG) CProvider_IWbemServices :: AddRef ( void )
{
	return InterlockedIncrement ( & m_ReferenceCount ) ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

STDMETHODIMP_(ULONG) CProvider_IWbemServices :: Release ( void )
{
	LONG t_Reference ;
	if ( ( t_Reference = InterlockedDecrement ( & m_ReferenceCount ) ) == 0 )
	{
		delete this ;
		return 0 ;
	}
	else
	{
		return t_Reference ;
	}
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

STDMETHODIMP CProvider_IWbemServices :: QueryInterface (

	REFIID iid , 
	LPVOID FAR *iplpv 
) 
{
	*iplpv = NULL ;

	if ( iid == IID_IUnknown )
	{
		*iplpv = ( LPVOID ) this ;
	}
	else if ( iid == IID_IWbemServices )
	{
		*iplpv = ( LPVOID ) ( IWbemServices * ) this ;		
	}	
	else if ( iid == IID_IWbemPropertyProvider )
	{
		*iplpv = ( LPVOID ) ( IWbemPropertyProvider * ) this ;		
	}	
	else if ( iid == IID_IWbemProviderInit )
	{
		*iplpv = ( LPVOID ) ( IWbemProviderInit * ) this ;		
	}	
	else if ( iid == IID_IWbemShutdown )
	{
		*iplpv = ( LPVOID ) ( IWbemShutdown * ) this ;		
	}	

	if ( *iplpv )
	{
		( ( LPUNKNOWN ) *iplpv )->AddRef () ;

		return ResultFromScode ( S_OK ) ;
	}
	else
	{
		return ResultFromScode ( E_NOINTERFACE ) ;
	}
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CProvider_IWbemServices::OpenNamespace ( 

	const BSTR ObjectPath, 
	long lFlags, 
	IWbemContext FAR* pCtx,
	IWbemServices FAR* FAR* pNewContext, 
	IWbemCallResult FAR* FAR* ppErrorObject
)
{
	return WBEM_E_NOT_AVAILABLE ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CProvider_IWbemServices :: CancelAsyncCall ( 
		
	IWbemObjectSink __RPC_FAR *pSink
)
{
	HRESULT t_Result = WBEM_E_NOT_AVAILABLE ;

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CProvider_IWbemServices :: QueryObjectSink ( 

	long lFlags,		
	IWbemObjectSink FAR* FAR* ppResponseHandler
) 
{
	return WBEM_E_NOT_AVAILABLE ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CProvider_IWbemServices :: GetObject ( 
		
	const BSTR ObjectPath,
    long lFlags,
    IWbemContext FAR *pCtx,
    IWbemClassObject FAR* FAR *ppObject,
    IWbemCallResult FAR* FAR *ppCallResult
)
{
	return WBEM_E_NOT_AVAILABLE ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CProvider_IWbemServices :: GetObjectAsync ( 
		
	const BSTR ObjectPath, 
	long lFlags, 
	IWbemContext FAR *pCtx,
	IWbemObjectSink FAR* pSink
) 
{
	HRESULT t_Result = WBEM_E_NOT_FOUND ;

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CProvider_IWbemServices :: PutClass ( 
		
	IWbemClassObject FAR* pObject, 
	long lFlags, 
	IWbemContext FAR *pCtx,
	IWbemCallResult FAR* FAR* ppCallResult
) 
{
	return WBEM_E_NOT_AVAILABLE ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CProvider_IWbemServices :: PutClassAsync ( 
		
	IWbemClassObject FAR* pObject, 
	long lFlags, 
	IWbemContext FAR *pCtx,
	IWbemObjectSink FAR* pResponseHandler
) 
{
 	 return WBEM_E_NOT_FOUND ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CProvider_IWbemServices :: DeleteClass ( 
		
	const BSTR Class, 
	long lFlags, 
	IWbemContext FAR *pCtx,
	IWbemCallResult FAR* FAR* ppCallResult
) 
{
 	 return WBEM_E_NOT_AVAILABLE ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CProvider_IWbemServices :: DeleteClassAsync ( 
		
	const BSTR Class, 
	long lFlags, 
	IWbemContext FAR *pCtx,
	IWbemObjectSink FAR* pResponseHandler
) 
{
 	 return WBEM_E_NOT_AVAILABLE ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CProvider_IWbemServices :: CreateClassEnum ( 

	const BSTR Superclass, 
	long lFlags, 
	IWbemContext FAR *pCtx,
	IEnumWbemClassObject FAR *FAR *ppEnum
) 
{
	return WBEM_E_NOT_AVAILABLE ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

SCODE CProvider_IWbemServices :: CreateClassEnumAsync (

	const BSTR Superclass, 
	long lFlags, 
	IWbemContext FAR* pCtx,
	IWbemObjectSink FAR* pHandler
) 
{
	return WBEM_E_NOT_FOUND ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CProvider_IWbemServices :: PutInstance (

    IWbemClassObject FAR *pInst,
    long lFlags,
    IWbemContext FAR *pCtx,
	IWbemCallResult FAR *FAR *ppCallResult
) 
{
	return WBEM_E_NOT_AVAILABLE ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CProvider_IWbemServices :: PutInstanceAsync ( 
		
	IWbemClassObject FAR* pInst, 
	long lFlags, 
    IWbemContext FAR *pCtx,
	IWbemObjectSink FAR* pSink
) 
{
	HRESULT t_Result = WBEM_E_NOT_AVAILABLE ;

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CProvider_IWbemServices :: DeleteInstance ( 

	const BSTR ObjectPath,
    long lFlags,
    IWbemContext FAR *pCtx,
    IWbemCallResult FAR *FAR *ppCallResult
)
{
	return WBEM_E_NOT_AVAILABLE ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/
        
HRESULT CProvider_IWbemServices :: DeleteInstanceAsync (
 
	const BSTR ObjectPath,
    long lFlags,
    IWbemContext __RPC_FAR *pCtx,
    IWbemObjectSink __RPC_FAR *pSink	
)
{
	HRESULT t_Result = WBEM_E_NOT_AVAILABLE ;

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CProvider_IWbemServices :: CreateInstanceEnum ( 

	const BSTR a_Class, 
	long a_Flags, 
	IWbemContext FAR *a_Context, 
	IEnumWbemClassObject __RPC_FAR *__RPC_FAR *a_Enum
)
{
	HRESULT t_Result = WBEM_E_NOT_AVAILABLE ;

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

DWORD GetCurrentImpersonationLevel ()
{
	DWORD t_ImpersonationLevel = RPC_C_IMP_LEVEL_ANONYMOUS ;

    HANDLE t_ThreadToken = NULL ;

    BOOL t_Status = OpenThreadToken (

		GetCurrentThread() ,
		TOKEN_QUERY,
		TRUE,
		&t_ThreadToken
	) ;

    if ( t_Status )
    {
		SECURITY_IMPERSONATION_LEVEL t_Level = SecurityAnonymous ;
		DWORD t_Returned = 0 ;

		t_Status = GetTokenInformation (

			t_ThreadToken ,
			TokenImpersonationLevel ,
			& t_Level ,
			sizeof ( SECURITY_IMPERSONATION_LEVEL ) ,
			& t_Returned
		) ;

		CloseHandle ( t_ThreadToken ) ;

		if ( t_Status == FALSE )
		{
			t_ImpersonationLevel = RPC_C_IMP_LEVEL_ANONYMOUS ;
		}
		else
		{
			switch ( t_Level )
			{
				case SecurityAnonymous:
				{
					t_ImpersonationLevel = RPC_C_IMP_LEVEL_ANONYMOUS ;
				}
				break ;

				case SecurityIdentification:
				{
					t_ImpersonationLevel = RPC_C_IMP_LEVEL_IDENTIFY ;
				}
				break ;

				case SecurityImpersonation:
				{
					t_ImpersonationLevel = RPC_C_IMP_LEVEL_IMPERSONATE ;
				}
				break ;

				case SecurityDelegation:
				{
					t_ImpersonationLevel = RPC_C_IMP_LEVEL_DELEGATE ;
				}
				break ;

				default:
				{
					t_ImpersonationLevel = RPC_C_IMP_LEVEL_ANONYMOUS ;
				}
				break ;
			}
		}
	}
	else
	{
        ULONG t_LastError = GetLastError () ;

        if ( t_LastError == ERROR_NO_IMPERSONATION_TOKEN || t_LastError == ERROR_NO_TOKEN )
        {
            t_ImpersonationLevel = RPC_C_IMP_LEVEL_DELEGATE ;
        }
        else 
		{
			if ( t_LastError == ERROR_CANT_OPEN_ANONYMOUS )
			{
				t_ImpersonationLevel = RPC_C_IMP_LEVEL_ANONYMOUS ;
			}
			else
			{
				t_ImpersonationLevel = RPC_C_IMP_LEVEL_ANONYMOUS ;
			}
		}
    }

	return t_ImpersonationLevel ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CProvider_IWbemServices :: CreateInstanceEnumAsync (

 	const BSTR a_Class ,
	long a_Flags , 
	IWbemContext __RPC_FAR *a_Context,
	IWbemObjectSink FAR *a_Sink

) 
{
	HRESULT t_Result = CoImpersonateClient () ;

	if ( _wcsicmp ( a_Class , L"Win32_ProcessEx" ) == 0 ) 
	{
		t_Result = CreateInstanceEnumAsync_Process_Single ( 

			m_Win32_ProcessEx_Object ,
			a_Flags ,
			a_Context , 
			a_Sink
		) ;
	}
	else
	{
		t_Result = WBEM_E_INVALID_CLASS ;
	}

	a_Sink->SetStatus ( 0 , t_Result , NULL , NULL ) ;

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CProvider_IWbemServices :: ExecQuery ( 

	const BSTR a_QueryLanguage, 
	const BSTR a_Query, 
	long a_Flags, 
	IWbemContext *a_Context ,
	IEnumWbemClassObject **a_Enumerator
)
{
	return WBEM_E_NOT_AVAILABLE ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CProvider_IWbemServices :: ExecQueryAsync ( 
		
	const BSTR a_QueryFormat, 
	const BSTR a_Query, 
	long a_Flags, 
	IWbemContext *a_Context ,
	IWbemObjectSink *a_Sink
) 
{
	HRESULT t_Result = CoImpersonateClient () ;

	a_Sink->SetStatus ( WBEM_STATUS_REQUIREMENTS , S_OK , NULL , NULL ) ;

	t_Result = CreateInstanceEnumAsync_Process_Batched ( 

		m_Win32_ProcessEx_Object ,
		a_Flags ,
		a_Context , 
		a_Sink
	) ;

	a_Sink->SetStatus ( 0 , t_Result , NULL , NULL ) ;

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CProvider_IWbemServices :: ExecNotificationQuery ( 

	const BSTR a_QueryLanguage,
    const BSTR a_Query,
    long a_Flags,
    IWbemContext *a_Context ,
    IEnumWbemClassObject **a_Enumerator
)
{
	return WBEM_E_NOT_AVAILABLE ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/
        
HRESULT CProvider_IWbemServices :: ExecNotificationQueryAsync ( 
            
	const BSTR a_QueryLanguage,
    const BSTR a_Query,
    long a_Flags ,
    IWbemContext *a_Context ,
    IWbemObjectSink *a_Sink
)
{
	return WBEM_E_NOT_AVAILABLE ;
}       

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT STDMETHODCALLTYPE CProvider_IWbemServices :: ExecMethod ( 

	const BSTR ObjectPath,
    const BSTR MethodName,
    long lFlags,
    IWbemContext FAR *pCtx,
    IWbemClassObject FAR *pInParams,
    IWbemClassObject FAR *FAR *ppOutParams,
    IWbemCallResult FAR *FAR *ppCallResult
)
{
	return WBEM_E_NOT_AVAILABLE ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT STDMETHODCALLTYPE CProvider_IWbemServices :: ExecMethodAsync ( 

    const BSTR ObjectPath,
    const BSTR MethodName,
    long lFlags,
    IWbemContext FAR *pCtx,
    IWbemClassObject FAR *pInParams,
	IWbemObjectSink FAR *pSink
) 
{
	HRESULT t_Result = WBEM_E_NOT_AVAILABLE ;

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CProvider_IWbemServices :: GetProperty (

    long a_Flags ,
    const BSTR a_Locale ,
    const BSTR a_ClassMapping ,
    const BSTR a_InstanceMapping ,
    const BSTR a_PropertyMapping ,
    VARIANT *a_Value
)
{
	if ( _wcsicmp ( a_PropertyMapping , L"ExtraProperty1" ) == 0 )
	{
	}
	else if ( _wcsicmp ( a_PropertyMapping , L"ExtraProperty2" ) == 0 )
	{
	}
	else
	{
	}
	
	return WBEM_E_NOT_AVAILABLE ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/


HRESULT CProvider_IWbemServices :: PutProperty (

    long a_Flags ,
    const BSTR a_Locale ,
    const BSTR a_ClassMapping ,
    const BSTR a_InstanceMapping ,
    const BSTR a_PropertyMapping ,
    const VARIANT *a_Value
)
{
	if ( _wcsicmp ( a_PropertyMapping , L"ExtraProperty1" ) == 0 )
	{
	}
	else if ( _wcsicmp ( a_PropertyMapping , L"ExtraProperty2" ) == 0 )
	{
	}
	else
	{
	}

	return WBEM_E_NOT_AVAILABLE ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CProvider_IWbemServices :: GetProductInformation ()
{
	HRESULT t_Result = S_OK ;

	ULONG t_ProductType = 0xffffffff ;

	if ( USER_SHARED_DATA->ProductTypeIsValid )
	{
		t_ProductType = USER_SHARED_DATA->NtProductType ;

		HKEY t_CurrentVersion ;
		LONG t_RegResult = RegOpenKeyEx (

			HKEY_LOCAL_MACHINE ,
			L"SOFTWARE\\Microsoft\\Windows NT\\Currentversion" ,
			0 ,
			KEY_READ ,
			& t_CurrentVersion 
		) ;

		if ( t_RegResult == ERROR_SUCCESS )
		{
			wchar_t t_ProductName [ _MAX_PATH ] ;

			DWORD t_ValueType = REG_SZ ;
			DWORD t_DataSize = sizeof ( t_ProductName ) ;

			t_RegResult = RegQueryValueEx (

			  t_CurrentVersion ,
			  L"" ,
			  0 ,
			  & t_ValueType ,
			  LPBYTE ( & t_ProductName ) ,
			  & t_DataSize 
			);

			if ( t_RegResult == ERROR_SUCCESS )
			{
				if ( wcscmp ( t_ProductName , L"" ) == 0 )
				{
					wcscpy ( t_ProductName , L"Microsoft Windows 2000" ) ;
				}

				if ( ( VER_SUITE_DATACENTER & USER_SHARED_DATA->SuiteMask ) &&
					( ( VER_NT_SERVER == t_ProductType ) || ( VER_NT_DOMAIN_CONTROLLER == t_ProductType ) )
				)
				{
					t_Result = WmiHelper :: ConcatenateStrings ( 

						2, 
						& m_ProductName , 
						t_ProductName ,
						L" Datacenter Server"
					) ;
				}
				else
				{
					if ( ( VER_SUITE_ENTERPRISE & USER_SHARED_DATA->SuiteMask ) &&
						( ( VER_NT_SERVER == t_ProductType ) || ( VER_NT_DOMAIN_CONTROLLER == t_ProductType ) )
					)
					{
						t_Result = WmiHelper :: ConcatenateStrings ( 

							2, 
							& m_ProductName , 
							t_ProductName ,
							L" Advanced Server"
						) ;
					}
					else
					{
						if ( ( VER_NT_SERVER == t_ProductType ) || ( VER_NT_DOMAIN_CONTROLLER == t_ProductType ) )
						{
							t_Result = WmiHelper :: ConcatenateStrings ( 

								2, 
								& m_ProductName , 
								t_ProductName ,
								L" Server"
							) ;
						}
						else
						{
							if ( VER_NT_WORKSTATION == t_ProductType )
							{
								t_Result = WmiHelper :: ConcatenateStrings ( 

									2, 
									& m_ProductName , 
									t_ProductName ,
									L" Professional"
								) ;
							}
						}
					}
				}

			}

			RegCloseKey ( t_CurrentVersion ) ;
		}

	}

	if ( SUCCEEDED ( t_Result ) ) 
	{
		wchar_t t_WindowsDirectory [ _MAX_PATH ] ;

	    if ( ! GetWindowsDirectory ( t_WindowsDirectory , sizeof ( t_WindowsDirectory ) / sizeof(wchar_t)) )
	    {
		    t_WindowsDirectory [0] = '\0';
	    }

		wchar_t t_File [_MAX_PATH] ;

		wcscpy ( t_File , t_WindowsDirectory ) ;
		wcscat ( t_File , _T("\\REPAIR\\SETUP.LOG") ) ;

		wchar_t t_Device [_MAX_PATH] ;

		GetPrivateProfileString (

			L"Paths" ,
			L"TargetDevice" ,
			L"" ,
			t_Device,
			sizeof ( t_Device ) / sizeof ( wchar_t ) ,
			t_File
		) ;

		t_Result = WmiHelper :: ConcatenateStrings ( 

			5 , 
			& m_OperatingSystemRunning , 
			m_ProductName ,
			L"|",
			t_WindowsDirectory ,
			L"|" ,
			t_Device
		) ;
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CProvider_IWbemServices :: Initialize (

	LPWSTR a_User,
	LONG a_Flags,
	LPWSTR a_Namespace,
	LPWSTR a_Locale,
	IWbemServices *a_CoreService,         // For anybody
	IWbemContext *a_Context,
	IWbemProviderInitSink *a_Sink     // For init signals
)
{
	HRESULT t_Result = S_OK ;

	if ( a_CoreService ) 
	{
		m_CoreService = a_CoreService ;
		m_CoreService->AddRef () ;
	}
	else
	{
		t_Result = WBEM_E_INVALID_PARAMETER ;
	}

	if ( SUCCEEDED ( t_Result ) )
	{
		if ( a_User ) 
		{
			m_User = SysAllocString ( a_User ) ;
			if ( m_User == NULL )
			{
				t_Result = WBEM_E_OUT_OF_MEMORY ;
			}
		}
	}

	if ( SUCCEEDED ( t_Result ) )
	{
		if ( a_Locale ) 
		{
			m_Locale = SysAllocString ( a_Locale ) ;
			if ( m_Locale == NULL )
			{
				t_Result = WBEM_E_OUT_OF_MEMORY ;
			}
		}
	}

	if ( SUCCEEDED ( t_Result ) )
	{
		if ( a_Namespace ) 
		{
			m_Namespace = SysAllocString ( a_Namespace ) ;
			if ( m_Namespace == NULL )
			{
				t_Result = WBEM_E_OUT_OF_MEMORY ;
			}
		}
	}
	
	if ( SUCCEEDED ( t_Result ) ) 
	{
		BSTR t_Class = SysAllocString ( L"Win32_ProcessEx" ) ;
		if ( t_Class ) 
		{
			t_Result = m_CoreService->GetObject (

				t_Class ,
				0 ,
				a_Context ,
				& m_Win32_ProcessEx_Object ,
				NULL 
			) ;

			if ( SUCCEEDED ( t_Result ) )
			{
			}

			SysFreeString ( t_Class ) ;
		}
		else
		{
			t_Result = WBEM_E_OUT_OF_MEMORY ;
		}
	}

	if ( SUCCEEDED ( t_Result ) ) 
	{
		m_ComputerName = SysAllocStringLen ( NULL , _MAX_PATH ) ;
		if ( m_ComputerName ) 
		{
			DWORD t_Length = _MAX_PATH ;
			GetComputerName ( m_ComputerName , & t_Length ) ;
		}
		else
		{
			t_Result = WBEM_E_OUT_OF_MEMORY ;
		}
	}

	if ( SUCCEEDED ( t_Result ) )
	{	
		OSVERSIONINFO t_VersionInfo ;
		t_VersionInfo.dwOSVersionInfoSize = sizeof ( OSVERSIONINFO ) ;
		if ( GetVersionEx ( & t_VersionInfo ) )
		{
			m_OperatingSystemVersion  = SysAllocStringLen ( NULL , _MAX_PATH ) ;
			if ( m_OperatingSystemVersion )
			{
				swprintf (	m_OperatingSystemVersion ,	L"%d.%d.%hu", t_VersionInfo.dwMajorVersion , t_VersionInfo.dwMinorVersion , LOWORD ( t_VersionInfo.dwBuildNumber ) ) ;
			}
			else
			{
				t_Result = WBEM_E_OUT_OF_MEMORY ;
			}
		}
		else
		{
			t_Result = WBEM_E_FAILED ;
		}
	}

	if ( SUCCEEDED ( t_Result ) )
	{
		t_Result = GetProductInformation () ;	
	}

	a_Sink->SetStatus ( t_Result , 0 ) ;

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CProvider_IWbemServices :: Shutdown (

	LONG a_Flags ,
	ULONG a_MaxMilliSeconds ,
	IWbemContext *a_Context
)
{
	HRESULT t_Result = S_OK ;

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CProvider_IWbemServices :: GetProcessExecutable ( HANDLE a_Process , wchar_t *&a_ExecutableName )
{
	HRESULT t_Result = WBEM_E_FAILED ;

    PROCESS_BASIC_INFORMATION t_BasicInfo ;

    NTSTATUS t_Status = NtQueryInformationProcess (

        a_Process ,
        ProcessBasicInformation ,
        & t_BasicInfo ,
        sizeof ( t_BasicInfo ) ,
        NULL
	) ;

    if ( NT_SUCCESS ( t_Status ) )
	{
		PEB *t_Peb = t_BasicInfo.PebBaseAddress ;

		//
		// Ldr = Peb->Ldr
		//

		PPEB_LDR_DATA t_Ldr ;

		t_Status = ReadProcessMemory (

			a_Process,
			& t_Peb->Ldr,
			& t_Ldr,
			sizeof ( t_Ldr ) ,
			NULL
		) ;

		if ( t_Status )
		{
			LIST_ENTRY *t_LdrHead = & t_Ldr->InMemoryOrderModuleList ;

			//
			// LdrNext = Head->Flink;
			//

			LIST_ENTRY *t_LdrNext ;

			t_Status = ReadProcessMemory (

				a_Process,
				& t_LdrHead->Flink,
				& t_LdrNext,
				sizeof ( t_LdrNext ) ,
				NULL
			) ;

			if ( t_Status )
			{
				if ( t_LdrNext != t_LdrHead )
				{
					LDR_DATA_TABLE_ENTRY t_LdrEntryData ;

					LDR_DATA_TABLE_ENTRY *t_LdrEntry = CONTAINING_RECORD ( t_LdrNext , LDR_DATA_TABLE_ENTRY, InMemoryOrderLinks ) ;

					t_Status = ReadProcessMemory (

						a_Process,
						t_LdrEntry,
						& t_LdrEntryData,
						sizeof ( t_LdrEntryData ) ,
						NULL
					) ;

					if ( t_Status )
					{
						a_ExecutableName = ( wchar_t * ) new wchar_t [t_LdrEntryData.FullDllName.MaximumLength ];
						if ( a_ExecutableName )
						{
							t_Status = ReadProcessMemory (

								a_Process,
								t_LdrEntryData.FullDllName.Buffer,
								a_ExecutableName ,
								t_LdrEntryData.FullDllName.MaximumLength ,
								NULL
							) ;

							if ( t_Status )
							{
								t_Result = S_OK ;
							}
						}
						else
						{
							t_Result = WBEM_E_OUT_OF_MEMORY ;
						}
					}
				}
			}
		}
	}

    return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CProvider_IWbemServices :: NextProcessBlock (

	SYSTEM_PROCESS_INFORMATION *a_ProcessBlock , 
	SYSTEM_PROCESS_INFORMATION *&a_NextProcessBlock
)
{
	if ( a_ProcessBlock )
	{
		DWORD t_NextOffSet = a_ProcessBlock->NextEntryOffset ;
		if ( t_NextOffSet )
		{
			a_NextProcessBlock = ( SYSTEM_PROCESS_INFORMATION * ) ( ( ( BYTE * ) a_ProcessBlock ) + t_NextOffSet ) ;
		}
		else
		{
			a_NextProcessBlock = NULL ;
		}
	}

	return S_OK ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CProvider_IWbemServices :: GetProcessBlocks ( SYSTEM_PROCESS_INFORMATION *&a_ProcessInformation )
{
	HRESULT t_Result = S_OK ;

	DWORD t_ProcessInformationSize = 32768;
	a_ProcessInformation = ( SYSTEM_PROCESS_INFORMATION * ) new BYTE [t_ProcessInformationSize] ;

	if ( a_ProcessInformation )
	{
		BOOL t_Retry = TRUE ;
		while ( t_Retry )
		{
			NTSTATUS t_Status = NtQuerySystemInformation (

				SystemProcessInformation,
				a_ProcessInformation,
				t_ProcessInformationSize,
				NULL
			) ;

			if ( t_Status == STATUS_INFO_LENGTH_MISMATCH )
			{
				delete [] a_ProcessInformation  ;
				a_ProcessInformation = NULL ;
				t_ProcessInformationSize += 32768 ;
				a_ProcessInformation = ( SYSTEM_PROCESS_INFORMATION * ) new BYTE [ t_ProcessInformationSize ] ;
				if ( ! a_ProcessInformation )
				{
					return WBEM_E_OUT_OF_MEMORY ;
				}
			}
			else
			{
				t_Retry = FALSE ;

				if ( ! NT_SUCCESS ( t_Status ) )
				{
					delete [] a_ProcessInformation;
					a_ProcessInformation = NULL ;
				}
			}
		}
	}
	else
	{
		return WBEM_E_OUT_OF_MEMORY ;
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CProvider_IWbemServices :: GetProcessInformation (

	SYSTEM_PROCESS_INFORMATION *&a_ProcessInformation
)
{
	HRESULT t_TempResult = EnablePrivilegeOnCurrentThread ( SE_DEBUG_NAME ) ;

	return GetProcessBlocks ( a_ProcessInformation ) ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CProvider_IWbemServices :: GetProcessParameters (

	HANDLE a_Process ,
	wchar_t *&a_ProcessCommandLine
)
{
	HRESULT t_Result = WBEM_E_FAILED ;

    PROCESS_BASIC_INFORMATION t_BasicInfo ;

    NTSTATUS t_Status = NtQueryInformationProcess (

        a_Process ,
        ProcessBasicInformation ,
        & t_BasicInfo ,
        sizeof ( t_BasicInfo ) ,
        NULL
	) ;

    if ( NT_SUCCESS ( t_Status ) )
	{
		PEB *t_Peb = t_BasicInfo.PebBaseAddress ;

		RTL_USER_PROCESS_PARAMETERS *t_ProcessParameters = NULL ;

		BOOL t_Success = ReadProcessMemory (

			a_Process,
			& t_Peb->ProcessParameters,
			& t_ProcessParameters,
			sizeof ( t_ProcessParameters ) ,
			NULL
		) ;

		if ( t_Success )
		{
			RTL_USER_PROCESS_PARAMETERS t_Parameters ;

			t_Success = ReadProcessMemory (

				a_Process,
				t_ProcessParameters,
				& t_Parameters ,
				sizeof ( RTL_USER_PROCESS_PARAMETERS ) ,
				NULL
			) ;

			if ( t_Success )
			{
				a_ProcessCommandLine = new wchar_t [ t_Parameters.CommandLine.MaximumLength ];

				t_Success = ReadProcessMemory (

					a_Process,
					t_Parameters.CommandLine.Buffer ,
					a_ProcessCommandLine ,
					t_Parameters.CommandLine.MaximumLength ,
					NULL
				) ;

				if ( t_Success )
				{
					t_Result = S_OK ;
				}
			}
		}
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CProvider_IWbemServices :: CreateInstanceEnumAsync_Process_Load (

	SYSTEM_PROCESS_INFORMATION *a_ProcessInformation ,
	IWbemClassObject *a_Instance 
)
{
	HRESULT t_Result = S_OK ;

	_IWmiObject *t_FastInstance = NULL ;
	t_Result = a_Instance->QueryInterface ( IID__IWmiObject , ( void ** ) & t_FastInstance ) ;
	if ( SUCCEEDED ( t_Result ) )
	{
		wchar_t t_Handle [ _MAX_PATH ] ;
		_ui64tow ( HandleToUlong ( a_ProcessInformation->UniqueProcessId ) , t_Handle , 10 ) ;
		Set_String ( a_Instance , L"Handle" , t_Handle ) ;

		Set_Uint32 ( t_FastInstance , L"ProcessId" , HandleToUlong ( a_ProcessInformation->UniqueProcessId )  ) ;

		if ( a_ProcessInformation->ImageName.Buffer )
		{
			Set_String ( a_Instance , L"Name" , a_ProcessInformation->ImageName.Buffer ) ;
			Set_String ( a_Instance , L"Caption" , a_ProcessInformation->ImageName.Buffer ) ;
			Set_String ( a_Instance , L"Description" , a_ProcessInformation->ImageName.Buffer ) ;
		}
		else
		{
			switch ( HandleToUlong ( a_ProcessInformation->UniqueProcessId ) )
			{
				case 0:
				{
					Set_String ( a_Instance , L"Name" , L"System Idle Process" ) ;
					Set_String ( a_Instance , L"Caption" , L"System Idle Process" ) ;
					Set_String ( a_Instance , L"Description" , L"System Idle Process" ) ;
				}
				break ;

				case 2:
				case 8:
				{
					Set_String ( a_Instance , L"Name" , L"System" ) ;
					Set_String ( a_Instance , L"Caption" , L"System" ) ;
					Set_String ( a_Instance , L"Description" , L"System" ) ;
				}
				break ;

				default:
				{
					Set_String ( a_Instance , L"Name" , L"Unknown" ) ;
					Set_String ( a_Instance , L"Caption" , L"Unknown" ) ;
					Set_String ( a_Instance , L"Description" , L"Unknown" ) ;
				}
				break ;
			}
		}

		Set_String ( a_Instance , L"CSCreationClassName"	, L"Win32_ComputerSystem"	) ;
		Set_String ( a_Instance , L"CSName"					, m_ComputerName			) ;
		Set_String ( a_Instance , L"OSCreationClassName"	, L"Win32_OperatingSystem"	) ;
		Set_String ( a_Instance , L"WindowsVersion"			, m_OperatingSystemVersion	) ;
		Set_String ( a_Instance , L"OSName"					, m_OperatingSystemRunning	) ;

		Set_Uint32 ( t_FastInstance , L"ProcessId" , HandleToUlong ( a_ProcessInformation->UniqueProcessId )  ) ;

		Set_Uint32 ( t_FastInstance , L"PageFaults" , a_ProcessInformation->PageFaultCount ) ;
		Set_Uint32 ( t_FastInstance , L"PeakWorkingSetSize" , a_ProcessInformation->PeakWorkingSetSize ) ;
		Set_Uint64 ( t_FastInstance , L"WorkingSetSize" , (const unsigned __int64) a_ProcessInformation->WorkingSetSize ) ;
		Set_Uint32 ( t_FastInstance , L"QuotaPeakPagedPoolUsage" , a_ProcessInformation->QuotaPeakPagedPoolUsage ) ;
		Set_Uint32 ( t_FastInstance , L"QuotaPagedPoolUsage" , a_ProcessInformation->QuotaPagedPoolUsage ) ;
		Set_Uint32 ( t_FastInstance , L"QuotaPeakNonPagedPoolUsage" , a_ProcessInformation->QuotaPeakNonPagedPoolUsage ) ;
		Set_Uint32 ( t_FastInstance , L"QuotaNonPagedPoolUsage" , a_ProcessInformation->QuotaNonPagedPoolUsage ) ;
		Set_Uint32 ( t_FastInstance , L"PageFileUsage" , a_ProcessInformation->PagefileUsage ) ;
		Set_Uint32 ( t_FastInstance , L"PeakPageFileUsage" , a_ProcessInformation->PeakPagefileUsage ) ;
		Set_Uint32 ( t_FastInstance , L"Priority" , a_ProcessInformation->BasePriority ) ;

		if ( a_ProcessInformation->CreateTime.u.HighPart > 0 )
		{
			Set_DateTime ( a_Instance , L"CreationDate" , * ( FILETIME * ) ( & a_ProcessInformation->CreateTime.u ) ) ;
		}

		Set_Uint32 ( t_FastInstance , L"ThreadCount" , a_ProcessInformation->NumberOfThreads ) ;
		Set_Uint32 ( t_FastInstance , L"ParentProcessId" , HandleToUlong ( a_ProcessInformation->InheritedFromUniqueProcessId ) ) ;
		Set_Uint32 ( t_FastInstance , L"HandleCount" , a_ProcessInformation->HandleCount ) ;
		Set_Uint32 ( t_FastInstance , L"SessionId" , a_ProcessInformation->SessionId ) ;
		Set_Uint64 ( t_FastInstance , L"KernelModeTime" , (const unsigned __int64) a_ProcessInformation->KernelTime.QuadPart ) ;
		Set_Uint64 ( t_FastInstance , L"UserModeTime" , (const unsigned __int64) a_ProcessInformation->UserTime.QuadPart ) ;
		Set_Uint64 ( t_FastInstance , L"PrivatePageCount" , (const unsigned __int64) a_ProcessInformation->PrivatePageCount ) ;
		Set_Uint64 ( t_FastInstance , L"PeakVirtualSize" , (const unsigned __int64) a_ProcessInformation->PeakVirtualSize ) ;
		Set_Uint64 ( t_FastInstance , L"VirtualSize" , (const unsigned __int64) a_ProcessInformation->VirtualSize ) ;
		Set_Uint64 ( t_FastInstance , L"ReadOperationCount" , (const unsigned __int64) a_ProcessInformation->ReadOperationCount.QuadPart ) ;
		Set_Uint64 ( t_FastInstance , L"WriteOperationCount" , (const unsigned __int64) a_ProcessInformation->WriteOperationCount.QuadPart ) ;
		Set_Uint64 ( t_FastInstance , L"OtherOperationCount" , (const unsigned __int64) a_ProcessInformation->OtherOperationCount.QuadPart ) ;
		Set_Uint64 ( t_FastInstance , L"ReadTransferCount" , (const unsigned __int64) a_ProcessInformation->ReadTransferCount.QuadPart ) ;
		Set_Uint64 ( t_FastInstance , L"WriteTransferCount" , (const unsigned __int64) a_ProcessInformation->WriteTransferCount.QuadPart ) ;
		Set_Uint64 ( t_FastInstance , L"OtherTransferCount" , (const unsigned __int64) a_ProcessInformation->OtherTransferCount.QuadPart ) ;

		HANDLE t_ProcessHandle = OpenProcess (

			PROCESS_QUERY_INFORMATION | PROCESS_VM_READ,
			FALSE,
			HandleToUlong ( a_ProcessInformation->UniqueProcessId )
		) ;

		if ( t_ProcessHandle )
		{
			wchar_t *t_ExecutableName = NULL ;
			t_Result = GetProcessExecutable ( t_ProcessHandle , t_ExecutableName ) ;
			if ( SUCCEEDED ( t_Result ) )
			{
				Set_String ( a_Instance , L"ExecutablePath" , t_ExecutableName );
				delete [] t_ExecutableName ;
			}

			QUOTA_LIMITS QuotaLimits;
			NTSTATUS Status = NtQueryInformationProcess (

				t_ProcessHandle,
				ProcessQuotaLimits,
				&QuotaLimits,
				sizeof(QuotaLimits),
				NULL
			);

			if ( NT_SUCCESS ( Status ) )
			{
				Set_Uint32 ( t_FastInstance , L"MinimumWorkingSetSize" , QuotaLimits.MinimumWorkingSetSize ) ;
				Set_Uint32 ( t_FastInstance , L"MaximumWorkingSetSize" , QuotaLimits.MaximumWorkingSetSize ) ;
			}

			wchar_t *t_CommandParameters = NULL ;

			t_Result = GetProcessParameters (

				t_ProcessHandle ,
				t_CommandParameters
			) ;

			if ( SUCCEEDED ( t_Result ) )
			{
				Set_String ( a_Instance , L"CommandLine" , t_CommandParameters ) ;
				delete [] t_CommandParameters ;
			}

			CloseHandle ( t_ProcessHandle ) ;
		}

		t_FastInstance->Release () ;
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CProvider_IWbemServices :: CreateInstanceEnumAsync_Process_Single (

	IWbemClassObject *a_ClassObject ,
	long a_Flags , 
	IWbemContext __RPC_FAR *a_Context,
	IWbemObjectSink FAR *a_Sink
)
{
	HRESULT t_Result = S_OK ;

	SYSTEM_PROCESS_INFORMATION *t_ProcessBlock = NULL ;

	t_Result = GetProcessInformation ( t_ProcessBlock ) ;
	if ( SUCCEEDED ( t_Result ) ) 
	{
		SYSTEM_PROCESS_INFORMATION *t_CurrentInformation = t_ProcessBlock ;
		while ( SUCCEEDED ( t_Result ) && t_CurrentInformation )
		{
			IWbemClassObject *t_Instance = NULL ;
			t_Result = a_ClassObject->SpawnInstance ( 

				0 , 
				& t_Instance
			) ;

			if ( SUCCEEDED ( t_Result ) )
			{
				t_Result = CreateInstanceEnumAsync_Process_Load (

					t_CurrentInformation ,
					t_Instance
				) ;

				if ( SUCCEEDED ( t_Result ) ) 
				{
					t_Result = a_Sink->Indicate ( 1 , & t_Instance ) ;
				}

				t_Instance->Release () ;
			}

			t_Result = NextProcessBlock ( t_CurrentInformation , t_CurrentInformation ) ;
		}

		delete [] ( BYTE * ) t_ProcessBlock ;
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CProvider_IWbemServices :: CreateInstanceEnumAsync_Process_Batched (

	IWbemClassObject *a_ClassObject ,
	long a_Flags , 
	IWbemContext __RPC_FAR *a_Context,
	IWbemObjectSink FAR *a_Sink
)
{
	HRESULT t_Result = S_OK ;

	SYSTEM_PROCESS_INFORMATION *t_ProcessBlock = NULL ;

	t_Result = GetProcessInformation ( t_ProcessBlock ) ;
	if ( SUCCEEDED ( t_Result ) ) 
	{
		ULONG t_Count = 0 ; 
		SYSTEM_PROCESS_INFORMATION *t_CurrentInformation = t_ProcessBlock ;
		while ( SUCCEEDED ( t_Result ) && t_CurrentInformation )
		{
			t_Count ++ ;
			t_Result = NextProcessBlock ( t_CurrentInformation , t_CurrentInformation ) ;
		}

		if ( t_Count )
		{
			ULONG t_Index = 0 ;

			IWbemClassObject **t_ObjectArray = new IWbemClassObject * [ t_Count ] ;

			t_CurrentInformation = t_ProcessBlock ;
			while ( SUCCEEDED ( t_Result ) && t_CurrentInformation )
			{
				IWbemClassObject *t_Instance = NULL ;
				t_Result = a_ClassObject->SpawnInstance ( 

					0 , 
					& t_ObjectArray [ t_Index ]
				) ;

				if ( SUCCEEDED ( t_Result ) )
				{
					t_Result = CreateInstanceEnumAsync_Process_Load (

						t_CurrentInformation ,
						t_ObjectArray [ t_Index ]
					) ;
				}

				t_Index ++ ;

				t_Result = NextProcessBlock ( t_CurrentInformation , t_CurrentInformation ) ;
			}

			t_Result = a_Sink->Indicate ( t_Count , t_ObjectArray ) ;
			for ( t_Index = 0 ; t_Index < t_Count ; t_Index ++ )
			{
				t_ObjectArray [ t_Index ]->Release () ;
			}

			delete [] t_ObjectArray ;
		}

		delete [] ( BYTE * ) t_ProcessBlock ;
	}

	return t_Result ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\provsubsys\provider\sta\makefile.inc ===
!include $(_NTDRIVE)$(_NTROOT)\ADMIN\WMI\WBEM\COMMON\makefile.cmn
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\provsubsys\provider\maindll.cpp ===
/*++

Copyright (C) 1996-2001 Microsoft Corporation

Module Name:

	MainDll.cpp

Abstract:


History:

--*/

#include <precomp.h>
#include <tchar.h>
#include <objbase.h>
#include <comdef.h>

#include <wbemcli.h>
#include <wbemint.h>
#include "Globals.h"
#include "ClassFac.h"
#include "Task.h"
#include "Service.h"
#include "ClassService.h"
#include "Guids.h"

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

//OK we need this one
HINSTANCE g_hInst=NULL;

CRITICAL_SECTION s_CriticalSection ;

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

BOOL APIENTRY DllMain (

	HINSTANCE hInstance, 
	ULONG ulReason , 
	LPVOID pvReserved
)
{
	g_hInst=hInstance;

	BOOL t_Status = TRUE ;

    if ( DLL_PROCESS_DETACH == ulReason )
	{
		HRESULT t_Result = Provider_Globals :: Global_Shutdown () ;
		if ( SUCCEEDED ( t_Result ) )
		{
			t_Status = TRUE ;
		}
		else
		{
			t_Status = FALSE ;
		}

		DeleteCriticalSection ( & s_CriticalSection ) ;

		t_Status = TRUE ;
    }
    else if ( DLL_PROCESS_ATTACH == ulReason )
	{
		InitializeCriticalSection ( & s_CriticalSection ) ;

		HRESULT t_Result = Provider_Globals :: Global_Startup () ;
		if ( SUCCEEDED ( t_Result ) )
		{
			t_Status = TRUE ;
		}
		else
		{
			t_Status = FALSE ;
		}
    }
    else if ( DLL_THREAD_DETACH == ulReason )
	{
		t_Status = TRUE ;
    }
    else if ( DLL_THREAD_ATTACH == ulReason )
	{
		t_Status = TRUE ;
    }

    return t_Status ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

STDAPI DllGetClassObject (

	REFCLSID rclsid , 
	REFIID riid, 
	void **ppv 
)
{
	HRESULT status = S_OK ; 

	if ( rclsid == CLSID_WmiProvider ) 
	{
		CProviderClassFactory <CProvider_IWbemServices,IWbemServices> *lpunk = new CProviderClassFactory <CProvider_IWbemServices,IWbemServices> () ;
		if ( lpunk == NULL )
		{
			status = E_OUTOFMEMORY ;
		}
		else
		{
			status = lpunk->QueryInterface ( riid , ppv ) ;
			if ( FAILED ( status ) )
			{
				delete lpunk ;				
			}
			else
			{
			}			
		}
	}
	else if ( rclsid == CLSID_WmiClassProvider ) 
	{
		CProviderClassFactory <CClassProvider_IWbemServices,IWbemServices> *lpunk = new CProviderClassFactory <CClassProvider_IWbemServices,IWbemServices> () ;
		if ( lpunk == NULL )
		{
			status = E_OUTOFMEMORY ;
		}
		else
		{
			status = lpunk->QueryInterface ( riid , ppv ) ;
			if ( FAILED ( status ) )
			{
				delete lpunk ;				
			}
			else
			{
			}			
		}
	}
	else if ( rclsid == CLSID_WmiTaskProvider ) 
	{
		CProviderClassFactory <CTask_IWbemServices,IWbemServices> *lpunk = new CProviderClassFactory <CTask_IWbemServices,IWbemServices> () ;
		if ( lpunk == NULL )
		{
			status = E_OUTOFMEMORY ;
		}
		else
		{
			status = lpunk->QueryInterface ( riid , ppv ) ;
			if ( FAILED ( status ) )
			{
				delete lpunk ;				
			}
			else
			{
			}			
		}
	}
	else
	{
		status = CLASS_E_CLASSNOTAVAILABLE ;
	}

	return status ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

STDAPI DllCanUnloadNow ()
{

/* 
 * Place code in critical section
 */
	EnterCriticalSection ( & s_CriticalSection ) ;

	BOOL unload = ( 
					Provider_Globals :: s_LocksInProgress || 
					Provider_Globals :: s_ObjectsInProgress
				) ;
	unload = ! unload ;

	if ( unload )
	{
	}

	LeaveCriticalSection ( & s_CriticalSection ) ;

	return unload ? ResultFromScode ( S_OK ) : ResultFromScode ( S_FALSE ) ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

//Strings used during self registeration

#define REG_FORMAT_STR			L"%s\\%s"
#define NOT_INSERT_STR			L"NotInsertable"
#define INPROC32_STR			L"InprocServer32"
#define LOCALSERVER32_STR		L"LocalServer32"
#define THREADING_MODULE_STR	L"ThreadingModel"

#ifdef WMIASSTA
#define APARTMENT_STR			L"Apartment"
#else
#define APARTMENT_STR			L"Both"
#endif

#define APPID_VALUE_STR			L"APPID"
#define APPID_STR				L"APPID\\"
#define CLSID_STR				L"CLSID\\"

#define WMI_TASKPROVIDER				__TEXT("Microsoft WMI Task Provider")
#define WMI_PROVIDER				__TEXT("Microsoft WMI Provider")
#define WMI_CLASSPROVIDER				__TEXT("Microsoft WMI Class Provider")

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

BOOL SetKeyAndValue ( wchar_t *pszKey , wchar_t *pszSubkey , wchar_t *pszValueName , wchar_t *pszValue )
{
    HKEY hKey;
    wchar_t szKey[256];

	wcscpy ( szKey , pszKey ) ;

    if ( NULL != pszSubkey )
    {
		wcscat ( szKey , L"\\" ) ;
        wcscat ( szKey , pszSubkey ) ;
    }

    if ( ERROR_SUCCESS != RegCreateKeyEx ( 

			HKEY_CLASSES_ROOT , 
			szKey , 
			0, 
			NULL, 
			REG_OPTION_NON_VOLATILE ,
			KEY_ALL_ACCESS, 
			NULL, 
			&hKey, 
			NULL
		)
	)
	{
        return FALSE ;
	}

    if ( NULL != pszValue )
    {
        if ( ERROR_SUCCESS != RegSetValueEx (

				hKey, 
				pszValueName, 
				0, 
				REG_SZ, 
				(BYTE *) pszValue , 
				(lstrlen(pszValue)+1)*sizeof(wchar_t)
			)
		)
		{
			return FALSE;
		}
    }

    RegCloseKey ( hKey ) ;

    return TRUE;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

STDAPI RegisterServer ( GUID a_ProviderClassId , wchar_t *a_ProviderName )
{
	wchar_t szModule[512];
	GetModuleFileName(g_hInst,(wchar_t*)szModule, sizeof(szModule)/sizeof(wchar_t));

	wchar_t szProviderClassID[128];
	wchar_t szProviderCLSIDClassID[128];

	int iRet = StringFromGUID2(a_ProviderClassId,szProviderClassID, 128);

#ifdef WMIASLOCAL
	TCHAR szProviderCLSIDAppID[128];
	_tcscpy(szProviderCLSIDAppID,APPID_STR);
	_tcscat(szProviderCLSIDAppID,szProviderClassID);

	if (FALSE ==SetKeyAndValue(szProviderCLSIDAppID, NULL, NULL, a_ProviderName ))
		return SELFREG_E_CLASS;

#endif

	wcscpy(szProviderCLSIDClassID,CLSID_STR);
	wcscat(szProviderCLSIDClassID,szProviderClassID);

		//Create entries under CLSID
	if (FALSE ==SetKeyAndValue(szProviderCLSIDClassID, NULL, NULL, a_ProviderName ))
		return SELFREG_E_CLASS;

	if (FALSE ==SetKeyAndValue(szProviderCLSIDClassID, NOT_INSERT_STR, NULL, NULL))
			return SELFREG_E_CLASS;

#ifdef WMIASLOCAL

	if (FALSE ==SetKeyAndValue(szProviderCLSIDClassID, LOCALSERVER32_STR, NULL,szModule))
		return SELFREG_E_CLASS;

	if (FALSE ==SetKeyAndValue(szProviderCLSIDClassID, LOCALSERVER32_STR,THREADING_MODULE_STR, APARTMENT_STR))
		return SELFREG_E_CLASS;
#else

	if (FALSE ==SetKeyAndValue(szProviderCLSIDClassID, INPROC32_STR, NULL,szModule))
		return SELFREG_E_CLASS;

	if (FALSE ==SetKeyAndValue(szProviderCLSIDClassID, INPROC32_STR,THREADING_MODULE_STR, APARTMENT_STR))
		return SELFREG_E_CLASS;

#endif

	return S_OK;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

STDAPI UnregisterServer ( GUID a_ProviderClassId )
{
	wchar_t szTemp[128];

	wchar_t szProviderClassID[128];
	wchar_t szProviderCLSIDClassID[128];

	int iRet = StringFromGUID2(a_ProviderClassId ,szProviderClassID, 128);

	wcscpy(szProviderCLSIDClassID,CLSID_STR);
	wcscat(szProviderCLSIDClassID,szProviderClassID);

	//Delete entries under CLSID

	wsprintf(szTemp, REG_FORMAT_STR, szProviderCLSIDClassID, NOT_INSERT_STR);
	RegDeleteKey(HKEY_CLASSES_ROOT, szTemp);

#ifdef WMIASLOCAL

	TCHAR szProviderCLSIDAppID[128];
	_tcscpy(szProviderCLSIDAppID,APPID_STR);
	_tcscat(szProviderCLSIDAppID,szProviderClassID);

	//Delete entries under APPID

	DWORD t_Status = RegDeleteKey(HKEY_CLASSES_ROOT, szProviderCLSIDAppID);

	_tcscpy(szProviderCLSIDAppID,APPID_STR);
	_tcscat(szProviderCLSIDAppID,szProviderClassID);

	wsprintf(szTemp, REG_FORMAT_STR,szProviderCLSIDClassID, LOCALSERVER32_STR);
	t_Status = RegDeleteKey(HKEY_CLASSES_ROOT, szTemp);

#else

	wsprintf(szTemp, REG_FORMAT_STR,szProviderCLSIDClassID, INPROC32_STR);
	RegDeleteKey(HKEY_CLASSES_ROOT, szTemp);

#endif

	RegDeleteKey(HKEY_CLASSES_ROOT, szProviderCLSIDClassID);

    return S_OK;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

STDAPI DllRegisterServer ()
{
	HRESULT t_Result ;

	t_Result = RegisterServer ( CLSID_WmiProvider , WMI_PROVIDER ) ;
	if ( SUCCEEDED ( t_Result ) )
	{
		t_Result = RegisterServer ( CLSID_WmiClassProvider , WMI_CLASSPROVIDER ) ;
		if ( SUCCEEDED ( t_Result ) )
		{
			t_Result = RegisterServer ( CLSID_WmiTaskProvider , WMI_TASKPROVIDER ) ;
		}
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

STDAPI DllUnregisterServer ()
{
	HRESULT t_Result ;

	t_Result = UnregisterServer ( CLSID_WmiProvider ) ;
	if ( SUCCEEDED ( t_Result ) ) 
	{
		t_Result = UnregisterServer ( CLSID_WmiClassProvider ) ;
		if ( SUCCEEDED ( t_Result ) ) 
		{
			t_Result = UnregisterServer ( CLSID_WmiTaskProvider ) ;
		}
	}

	return t_Result ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\provsubsys\provider\task.cpp ===
/*++

Copyright (C) 1996-2001 Microsoft Corporation

Module Name:

	XXXX

Abstract:


History:

--*/

#include <precomp.h>
#include "precomp.h"

#include <objbase.h>
#include <wbemint.h>

#include <mstask.h>
#include <msterr.h>

#include "CGlobals.h"
#include "Globals.h"
#include "HelperFuncs.h"
#include "DateTime.h"
#include "Task.h"

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

CTask_IWbemServices :: CTask_IWbemServices (

	 WmiAllocator &a_Allocator 

) : m_ReferenceCount ( 0 ) , 
	m_Allocator ( a_Allocator ) ,
	m_User ( NULL ) ,
	m_Locale ( NULL ) ,
	m_Namespace ( NULL ) ,
	m_CoreService ( NULL ) ,
	m_Win32_Task_Object ( NULL ) ,
	m_Win32_Once_Object ( NULL ) ,
	m_Win32_WeeklyTrigger_Object ( NULL ) ,
	m_Win32_DailyTrigger_Object ( NULL ) ,
	m_Win32_MonthlyDateTrigger_Object ( NULL ) ,
	m_Win32_MonthlyDayOfWeekTrigger_Object ( NULL ) ,
	m_Win32_OnIdle_Object ( NULL ) ,
	m_Win32_AtSystemStart_Object ( NULL ) ,
	m_Win32_AtLogon_Object ( NULL ) ,
	m_Win32_ScheduledWorkItemTrigger_Object ( NULL )
{
	InitializeCriticalSection ( & m_CriticalSection ) ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

CTask_IWbemServices :: ~CTask_IWbemServices ()
{
	DeleteCriticalSection ( & m_CriticalSection ) ;

	if ( m_User ) 
	{
		SysFreeString ( m_User ) ;
	}

	if ( m_Locale ) 
	{
		SysFreeString ( m_Locale ) ;
	}

	if ( m_Namespace ) 
	{
		SysFreeString ( m_Namespace ) ;
	}

	if ( m_CoreService ) 
	{
		m_CoreService->Release () ;
	}

	if ( m_Win32_Task_Object ) 
	{
		m_Win32_Task_Object->Release () ;
	}

	if ( m_Win32_DailyTrigger_Object )
	{
		m_Win32_DailyTrigger_Object->Release () ;
	}

	if ( m_Win32_Once_Object )
	{
		m_Win32_Once_Object->Release () ;
	}

	if ( m_Win32_WeeklyTrigger_Object )	
	{
		m_Win32_WeeklyTrigger_Object->Release () ;
	}

	if ( m_Win32_MonthlyDateTrigger_Object )
	{
		m_Win32_MonthlyDateTrigger_Object->Release () ;
	}

	if ( m_Win32_MonthlyDayOfWeekTrigger_Object )
	{
		m_Win32_MonthlyDayOfWeekTrigger_Object->Release () ;
	}

	if ( m_Win32_OnIdle_Object )
	{
		m_Win32_OnIdle_Object->Release () ;
	}

	if ( m_Win32_AtSystemStart_Object )
	{
		m_Win32_AtSystemStart_Object->Release () ;
	}

	if ( m_Win32_AtLogon_Object )
	{
		m_Win32_AtLogon_Object->Release () ;
	}

	if ( m_Win32_ScheduledWorkItemTrigger_Object )
	{
		m_Win32_ScheduledWorkItemTrigger_Object->Release () ;
	}
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

STDMETHODIMP_(ULONG) CTask_IWbemServices :: AddRef ( void )
{
	return InterlockedIncrement ( & m_ReferenceCount ) ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

STDMETHODIMP_(ULONG) CTask_IWbemServices :: Release ( void )
{
	LONG t_Reference ;
	if ( ( t_Reference = InterlockedDecrement ( & m_ReferenceCount ) ) == 0 )
	{
		delete this ;
		return 0 ;
	}
	else
	{
		return t_Reference ;
	}
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

STDMETHODIMP CTask_IWbemServices :: QueryInterface (

	REFIID iid , 
	LPVOID FAR *iplpv 
) 
{
	*iplpv = NULL ;

	if ( iid == IID_IUnknown )
	{
		*iplpv = ( LPVOID ) this ;
	}
	else if ( iid == IID_IWbemServices )
	{
		*iplpv = ( LPVOID ) ( IWbemServices * ) this ;		
	}	
	else if ( iid == IID_IWbemProviderInit )
	{
		*iplpv = ( LPVOID ) ( IWbemProviderInit * ) this ;		
	}	
	else if ( iid == IID_IWbemShutdown )
	{
		*iplpv = ( LPVOID ) ( IWbemShutdown * ) this ;		
	}	

	if ( *iplpv )
	{
		( ( LPUNKNOWN ) *iplpv )->AddRef () ;

		return ResultFromScode ( S_OK ) ;
	}
	else
	{
		return ResultFromScode ( E_NOINTERFACE ) ;
	}
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CTask_IWbemServices::OpenNamespace ( 

	const BSTR ObjectPath, 
	long lFlags, 
	IWbemContext FAR* pCtx,
	IWbemServices FAR* FAR* pNewContext, 
	IWbemCallResult FAR* FAR* ppErrorObject
)
{
	return WBEM_E_NOT_AVAILABLE ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CTask_IWbemServices :: CancelAsyncCall ( 
		
	IWbemObjectSink *pSink
)
{
	HRESULT t_Result = WBEM_E_NOT_AVAILABLE ;

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CTask_IWbemServices :: QueryObjectSink ( 

	long lFlags,		
	IWbemObjectSink FAR* FAR* ppResponseHandler
) 
{
	return WBEM_E_NOT_AVAILABLE ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CTask_IWbemServices :: GetObject ( 
		
	const BSTR ObjectPath,
    long lFlags,
    IWbemContext FAR *pCtx,
    IWbemClassObject FAR* FAR *ppObject,
    IWbemCallResult FAR* FAR *ppCallResult
)
{
	return WBEM_E_NOT_AVAILABLE ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CTask_IWbemServices :: GetObjectAsync_Win32_Task (

	IWbemClassObject *a_ClassObject ,
	long a_Flags , 
	IWbemContext *a_Context,
	IWbemObjectSink FAR *a_Sink ,
	IWbemPath *a_Path 
)
{
	HRESULT t_Result = S_OK ;

	wchar_t *t_Key_Name = NULL ;

	IWbemPathKeyList *t_Keys = NULL ;

	t_Result = a_Path->GetKeyList (

		& t_Keys 
	) ;

	if ( SUCCEEDED ( t_Result ) )
	{
		ULONG t_KeyCount = 0 ;
		t_Result = t_Keys->GetCount (

			& t_KeyCount 
		) ;

		if ( SUCCEEDED ( t_Result ) )
		{
			if ( t_KeyCount == 1 )
			{
				wchar_t t_Key [ 32 ] ; 
				ULONG t_KeyLength = 32 ;
				ULONG t_KeyValueLength = 0 ;
				ULONG t_KeyType = 0 ;

				t_Result = t_Keys->GetKey (

					0 ,
					0 ,
					& t_KeyLength ,
					t_Key ,
					& t_KeyValueLength ,
					NULL ,
					& t_KeyType
				) ;

				if ( SUCCEEDED ( t_Result ) ) 
				{
					if ( t_KeyType == CIM_STRING )
					{
						t_Key_Name = new wchar_t [ t_KeyValueLength ] ;
						if ( t_Key_Name )
						{
							t_Result = t_Keys->GetKey (

								0 ,
								0 ,
								& t_KeyLength ,
								t_Key ,
								& t_KeyValueLength ,
								t_Key_Name ,
								& t_KeyType
							) ;
						}
						else
						{
							t_Result = WBEM_E_OUT_OF_MEMORY ;
						}
					}
					else
					{
						t_Result = WBEM_E_INVALID_CLASS ;
					}
				}
			}
			else
			{
				t_Result = WBEM_E_INVALID_CLASS ;
			}
		}
	}

	BOOL t_Found = FALSE ;

	if ( SUCCEEDED ( t_Result ) )
	{
		ITaskScheduler *t_TaskScheduler = NULL ;

		t_Result = CoCreateInstance (

			CLSID_CTaskScheduler,
			NULL,
			CLSCTX_INPROC_SERVER,
			IID_ITaskScheduler,
			(void **) & t_TaskScheduler
		) ;

		if ( SUCCEEDED ( t_Result ) ) 
		{
			IEnumTasks *t_TaskEnumerator = NULL ;
			t_Result = t_TaskScheduler->Enum ( & t_TaskEnumerator ) ;
			if ( SUCCEEDED ( t_Result ) )
			{
				wchar_t **t_Name = NULL ;
				t_TaskEnumerator->Reset () ;
				while ( ( t_Result = t_TaskEnumerator->Next ( 1 , & t_Name , NULL ) ) == S_OK ) 
				{
					if ( wcscmp ( t_Name [ 0 ] , t_Key_Name ) == 0 )
					{
						t_Found = TRUE ;

						IWbemClassObject *t_Instance = NULL ;
						t_Result = a_ClassObject->SpawnInstance ( 

							0 , 
							& t_Instance
						) ;

						if ( SUCCEEDED ( t_Result ) )
						{
							HRESULT t_Result = CommonAsync_Win32_Task_Load (

								t_TaskScheduler ,
								t_Name [ 0 ] ,
								t_Instance
							) ;

							if ( SUCCEEDED ( t_Result ) ) 
							{
								t_Result = a_Sink->Indicate ( 1 , & t_Instance ) ;
							}

							t_Instance->Release () ;
						}
					}

					CoTaskMemFree ( t_Name ) ;
				}

				if ( t_Result != S_FALSE )
				{
					t_Result = WBEM_E_FAILED ;
				}

				t_TaskEnumerator->Release () ;
			}

			t_TaskScheduler->Release () ;

		}
	}

	if ( t_Key_Name )
	{
		delete [] t_Key_Name ;
	}

	if ( SUCCEEDED ( t_Result ) && t_Found == FALSE )
	{
		t_Result = WBEM_E_NOT_FOUND ;
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CTask_IWbemServices :: GetObjectAsync_Win32_Trigger (

	IWbemClassObject *a_ClassObject ,
	long a_Flags , 
	IWbemContext *a_Context,
	IWbemObjectSink FAR *a_Sink ,
	IWbemPath *a_Path ,
	TASK_TRIGGER_TYPE a_TriggerType 
)
{
	HRESULT t_Result = S_OK ;

	wchar_t *t_Key_Name = NULL ;
	WORD t_Key_TriggerIndex = 0 ;

	IWbemPathKeyList *t_Keys = NULL ;

	t_Result = a_Path->GetKeyList (

		& t_Keys 
	) ;

	if ( SUCCEEDED ( t_Result ) )
	{
		ULONG t_KeyCount = 0 ;
		t_Result = t_Keys->GetCount (

			& t_KeyCount 
		) ;

		if ( SUCCEEDED ( t_Result ) )
		{
			if ( t_KeyCount == 2 )
			{
				wchar_t t_Key [ 32 ] ; 
				ULONG t_KeyLength = 32 ;
				ULONG t_KeyValueLength = 0 ;
				ULONG t_KeyType = 0 ;

				t_Result = t_Keys->GetKey (

					0 ,
					0 ,
					& t_KeyLength ,
					t_Key ,
					& t_KeyValueLength ,
					NULL ,
					& t_KeyType
				) ;

				if ( SUCCEEDED ( t_Result ) ) 
				{
					if ( t_KeyType == CIM_SINT32 )
					{
						t_Result = t_Keys->GetKey (

							0 ,
							0 ,
							& t_KeyLength ,
							t_Key ,
							& t_KeyValueLength ,
							& t_Key_TriggerIndex ,
							& t_KeyType
						) ;
					}
					else
					{
						t_Result = WBEM_E_INVALID_CLASS ;
					}
				}

				t_KeyLength = 32 ;
				t_KeyValueLength = 0 ;
				t_KeyType = 0 ;

				t_Result = t_Keys->GetKey (

					1 ,
					0 ,
					& t_KeyLength ,
					t_Key ,
					& t_KeyValueLength ,
					NULL ,
					& t_KeyType
				) ;

				if ( SUCCEEDED ( t_Result ) ) 
				{
					if ( t_KeyType == CIM_STRING )
					{
						t_Key_Name = new wchar_t [ t_KeyValueLength ] ;
						if ( t_Key_Name )
						{
							t_Result = t_Keys->GetKey (

								1 ,
								0 ,
								& t_KeyLength ,
								t_Key ,
								& t_KeyValueLength ,
								t_Key_Name ,
								& t_KeyType
							) ;
						}
						else
						{
							t_Result = WBEM_E_OUT_OF_MEMORY ;
						}
					}
					else
					{
						t_Result = WBEM_E_INVALID_CLASS ;
					}
				}

			}
			else
			{
				t_Result = WBEM_E_INVALID_CLASS ;
			}
		}
	}

	BOOL t_Found = FALSE ;

	if ( SUCCEEDED ( t_Result ) )
	{
		ITaskScheduler *t_TaskScheduler = NULL ;

		t_Result = CoCreateInstance (

			CLSID_CTaskScheduler,
			NULL,
			CLSCTX_INPROC_SERVER,
			IID_ITaskScheduler,
			(void **) & t_TaskScheduler
		) ;

		if ( SUCCEEDED ( t_Result ) ) 
		{
			IEnumTasks *t_TaskEnumerator = NULL ;
			t_Result = t_TaskScheduler->Enum ( & t_TaskEnumerator ) ;
			if ( SUCCEEDED ( t_Result ) )
			{
				wchar_t **t_Name = NULL ;
				t_TaskEnumerator->Reset () ;
				while ( ( t_Result = t_TaskEnumerator->Next ( 1 , & t_Name , NULL ) ) == S_OK ) 
				{
					if ( wcscmp ( t_Name [ 0 ] , t_Key_Name ) == 0 )
					{
						t_Found = TRUE ;

						if ( SUCCEEDED ( t_Result ) )
						{
							t_Result = GetObjectAsync_Win32_Trigger_Load (

								a_ClassObject ,
								a_Sink ,
								t_TaskScheduler ,
								t_Key_Name ,
								t_Key_TriggerIndex ,
								a_TriggerType
							) ;
						}
					}

					CoTaskMemFree ( t_Name ) ;
				}

				if ( t_Result != S_FALSE )
				{
					t_Result = WBEM_E_FAILED ;
				}

				t_TaskEnumerator->Release () ;
			}

			t_TaskScheduler->Release () ;

		}
	}

	if ( t_Key_Name )
	{
		delete [] t_Key_Name ;
	}

	if ( SUCCEEDED ( t_Result ) && t_Found == FALSE )
	{
		t_Result = WBEM_E_NOT_FOUND ;
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CTask_IWbemServices :: GetObjectAsync ( 
		
	const BSTR a_ObjectPath , 
	long a_Flags , 
	IWbemContext *a_Context ,
	IWbemObjectSink *a_Sink
) 
{
	IWbemPath *t_Path = NULL ;

	HRESULT t_Result = CoCreateInstance (

		CLSID_WbemDefPath ,
		NULL ,
		CLSCTX_INPROC_SERVER ,
		IID_IWbemPath ,
		( void ** )  & t_Path
	) ;

	if ( SUCCEEDED ( t_Result ) )
	{
		t_Result = t_Path->SetText ( WBEMPATH_CREATE_ACCEPT_ALL , a_ObjectPath ) ;
		if ( SUCCEEDED ( t_Result ) ) 
		{
			ULONG t_Length = 32 ; // None of supported classes is longer than this length
			BSTR t_Class = SysAllocStringLen ( NULL , t_Length ) ; 
			if ( t_Class )
			{
				t_Result = t_Path->GetClassName (

					& t_Length ,
					t_Class
				) ;

				if ( SUCCEEDED ( t_Result ) )
				{
					HRESULT t_Result = CoImpersonateClient () ;

					if ( _wcsicmp ( t_Class , L"Win32_Task" ) == 0 ) 
					{
						t_Result = GetObjectAsync_Win32_Task ( 

							m_Win32_Task_Object ,
							a_Flags ,
							a_Context , 
							a_Sink ,
							t_Path
						) ;
					}
					else if ( _wcsicmp ( t_Class , L"Win32_Once" ) == 0 ) 
					{
						t_Result = GetObjectAsync_Win32_Trigger ( 

							m_Win32_Once_Object ,
							a_Flags ,
							a_Context , 
							a_Sink ,
							t_Path ,
							TASK_TIME_TRIGGER_ONCE
						) ;
					}
					else if ( _wcsicmp ( t_Class , L"Win32_WeeklyTrigger" ) == 0 ) 
					{
						t_Result = GetObjectAsync_Win32_Trigger ( 

							m_Win32_WeeklyTrigger_Object ,
							a_Flags ,
							a_Context , 
							a_Sink ,
							t_Path ,
							TASK_TIME_TRIGGER_WEEKLY
						) ;
					}
					else if ( _wcsicmp ( t_Class , L"Win32_DailyTrigger" ) == 0 ) 
					{
						t_Result = GetObjectAsync_Win32_Trigger ( 

							m_Win32_DailyTrigger_Object ,
							a_Flags ,
							a_Context , 
							a_Sink ,
							t_Path ,
							TASK_TIME_TRIGGER_DAILY
						) ;
					}
					else if ( _wcsicmp ( t_Class , L"Win32_MonthlyDateTrigger" ) == 0 ) 
					{
						t_Result = GetObjectAsync_Win32_Trigger ( 

							m_Win32_MonthlyDateTrigger_Object ,
							a_Flags ,
							a_Context , 
							a_Sink ,
							t_Path ,
							TASK_TIME_TRIGGER_MONTHLYDATE
						) ;
					}
					else if ( _wcsicmp ( t_Class , L"Win32_MonthlyDayOfWeekTrigger" ) == 0 ) 
					{
						t_Result = GetObjectAsync_Win32_Trigger ( 

							m_Win32_MonthlyDayOfWeekTrigger_Object ,
							a_Flags ,
							a_Context , 
							a_Sink ,
							t_Path ,
							TASK_TIME_TRIGGER_MONTHLYDOW
						) ;
					}
					else if ( _wcsicmp ( t_Class , L"Win32_OnIdle" ) == 0 ) 
					{
						t_Result = GetObjectAsync_Win32_Trigger ( 

							m_Win32_OnIdle_Object ,
							a_Flags ,
							a_Context , 
							a_Sink ,
							t_Path ,
							TASK_EVENT_TRIGGER_ON_IDLE
						) ;
					}
					else if ( _wcsicmp ( t_Class , L"Win32_AtSystemStart" ) == 0 ) 
					{
						t_Result = GetObjectAsync_Win32_Trigger ( 

							m_Win32_AtSystemStart_Object ,
							a_Flags ,
							a_Context , 
							a_Sink ,
							t_Path ,
							TASK_EVENT_TRIGGER_AT_SYSTEMSTART
						) ;
					}
					else if ( _wcsicmp ( t_Class , L"Win32_AtLogon" ) == 0 ) 
					{
						t_Result = GetObjectAsync_Win32_Trigger ( 

							m_Win32_AtLogon_Object ,
							a_Flags ,
							a_Context , 
							a_Sink ,
							t_Path ,
							TASK_EVENT_TRIGGER_AT_LOGON
						) ;
					}
					else if ( _wcsicmp ( t_Class , L"Win32_ScheduledWorkItemTrigger" ) == 0 ) 
					{
#if 0
						t_Result = GetObjectAsync_Win32_ScheduledWorkItemTrigger ( 

							m_Win32_ScheduledWorkItemTrigger_Object ,
							a_Flags ,
							a_Context , 
							a_Sink
						) ;
#endif
					}
					else
					{
						t_Result = WBEM_E_INVALID_CLASS ;
					}
	
					SysFreeString ( t_Class ) ;
				}
			}
			else
			{
				t_Result = WBEM_E_OUT_OF_MEMORY ;
			}
		}

		t_Path->Release () ;
	}

	a_Sink->SetStatus ( 0 , t_Result , NULL , NULL ) ;

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CTask_IWbemServices :: PutClass ( 
		
	IWbemClassObject FAR* pObject, 
	long lFlags, 
	IWbemContext FAR *pCtx,
	IWbemCallResult FAR* FAR* ppCallResult
) 
{
	return WBEM_E_NOT_AVAILABLE ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CTask_IWbemServices :: PutClassAsync ( 
		
	IWbemClassObject FAR* pObject, 
	long lFlags, 
	IWbemContext FAR *pCtx,
	IWbemObjectSink FAR* pResponseHandler
) 
{
 	 return WBEM_E_NOT_FOUND ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CTask_IWbemServices :: DeleteClass ( 
		
	const BSTR Class, 
	long lFlags, 
	IWbemContext FAR *pCtx,
	IWbemCallResult FAR* FAR* ppCallResult
) 
{
 	 return WBEM_E_NOT_AVAILABLE ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CTask_IWbemServices :: DeleteClassAsync ( 
		
	const BSTR Class, 
	long lFlags, 
	IWbemContext FAR *pCtx,
	IWbemObjectSink FAR* pResponseHandler
) 
{
 	 return WBEM_E_NOT_AVAILABLE ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CTask_IWbemServices :: CreateClassEnum ( 

	const BSTR Superclass, 
	long lFlags, 
	IWbemContext FAR *pCtx,
	IEnumWbemClassObject FAR *FAR *ppEnum
) 
{
	return WBEM_E_NOT_AVAILABLE ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

SCODE CTask_IWbemServices :: CreateClassEnumAsync (

	const BSTR Superclass, 
	long lFlags, 
	IWbemContext FAR* pCtx,
	IWbemObjectSink FAR* pHandler
) 
{
	return WBEM_E_NOT_FOUND ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CTask_IWbemServices :: PutInstance (

    IWbemClassObject *a_Instance ,
    long a_Flags ,
    IWbemContext *a_Context ,
	IWbemCallResult **a_CallResult
) 
{
	return WBEM_E_NOT_AVAILABLE ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CTask_IWbemServices :: PutInstanceAsync_Win32_Task (

	IWbemClassObject *a_Instance, 
	IWbemClassObject *a_ClassObject ,
	long a_Flags , 
	IWbemContext *a_Context,
	IWbemObjectSink *a_Sink
)
{
	_IWmiObject *t_FastInstance = NULL ;
	HRESULT t_Result = a_Instance->QueryInterface ( IID__IWmiObject , ( void ** ) & t_FastInstance ) ;
	if ( SUCCEEDED ( t_Result ) )
	{
		wchar_t *t_WorkItemName = NULL ;
		BOOL t_Null = FALSE ;

		t_Result = ProviderSubSystem_Common_Globals :: Get_String (

			a_Instance ,
			L"WorkItemName" ,
			t_WorkItemName ,
			t_Null 
		) ;

		if ( SUCCEEDED ( t_Result ) )
		{
			if ( t_Null )
			{
				t_Result = WBEM_E_INVALID_OBJECT ;
			}
		}

		wchar_t *t_ApplicationName = NULL ;

		if ( SUCCEEDED ( t_Result ) )
		{
			t_Result = ProviderSubSystem_Common_Globals :: Get_String (

				a_Instance ,
				L"ApplicationName" ,
				t_ApplicationName ,
				t_Null 
			) ;

			if ( SUCCEEDED ( t_Result ) )
			{
				if ( t_Null )
				{
					t_Result = WBEM_E_INVALID_OBJECT ;
				}
			}
		}

		wchar_t *t_Parameters = NULL ;

		if ( SUCCEEDED ( t_Result ) )
		{
			t_Result = ProviderSubSystem_Common_Globals :: Get_String (

				a_Instance ,
				L"Parameters" ,
				t_Parameters ,
				t_Null 
			) ;
		}

		wchar_t *t_WorkingDirectory = NULL ;

		if ( SUCCEEDED ( t_Result ) )
		{
			t_Result = ProviderSubSystem_Common_Globals :: Get_String (

				a_Instance ,
				L"WorkingDirectory" ,
				t_WorkingDirectory ,
				t_Null 
			) ;
		}

		wchar_t *t_AccountName = NULL ;

		if ( SUCCEEDED ( t_Result ) )
		{
			t_Result = ProviderSubSystem_Common_Globals :: Get_String (

				a_Instance ,
				L"AccountName" ,
				t_AccountName ,
				t_Null 
			) ;
		}

		wchar_t *t_Password = NULL ;

		if ( SUCCEEDED ( t_Result ) )
		{
			t_Result = ProviderSubSystem_Common_Globals :: Get_String (

				a_Instance ,
				L"Password" ,
				t_Password ,
				t_Null 
			) ;
		}

		wchar_t *t_Comment = NULL ;

		if ( SUCCEEDED ( t_Result ) )
		{
			t_Result = ProviderSubSystem_Common_Globals :: Get_String (

				a_Instance ,
				L"Comment" ,
				t_Comment ,
				t_Null 
			) ;
		}

		wchar_t *t_Creator = NULL ;

		if ( SUCCEEDED ( t_Result ) )
		{
			t_Result = ProviderSubSystem_Common_Globals :: Get_String (

				a_Instance ,
				L"Creator" ,
				t_Creator ,
				t_Null 
			) ;
		}

		WORD t_RetryCount = 0 ;
		BOOL t_RetryCountSpecified = TRUE ;

		if ( SUCCEEDED ( t_Result ) )
		{
			t_Result = ProviderSubSystem_Common_Globals :: Get_Uint16 (

				t_FastInstance ,
				L"RetryCount" ,
				t_RetryCount ,
				t_Null 
			) ;

			if ( SUCCEEDED ( t_Result ) )
			{
				if ( t_Null )
				{
					t_RetryCountSpecified = FALSE ;
				}
			}
		}

		WORD t_RetryInterval = 0 ;
		BOOL t_RetryIntervalSpecified = TRUE ;

		if ( SUCCEEDED ( t_Result ) )
		{
			t_Result = ProviderSubSystem_Common_Globals :: Get_Uint16 (

				t_FastInstance ,
				L"RetryInterval" ,
				t_RetryInterval ,
				t_Null 
			) ;

			if ( SUCCEEDED ( t_Result ) )
			{
				if ( t_Null )
				{
					t_RetryIntervalSpecified = FALSE ;
				}
			}
		}

		WORD t_IdleWait = 0 ;
		BOOL t_IdleWaitSpecified = TRUE ;

		if ( SUCCEEDED ( t_Result ) )
		{
			t_Result = ProviderSubSystem_Common_Globals :: Get_Uint16 (

				t_FastInstance ,
				L"IdleWait" ,
				t_IdleWait ,
				t_Null 
			) ;

			if ( SUCCEEDED ( t_Result ) )
			{
				if ( t_Null )
				{
					t_IdleWaitSpecified = FALSE ;
				}
			}
		}

		WORD t_Deadline = 0 ;
		BOOL t_DeadlineSpecified = TRUE ;

		if ( SUCCEEDED ( t_Result ) )
		{
			t_Result = ProviderSubSystem_Common_Globals :: Get_Uint16 (

				t_FastInstance ,
				L"Deadline" ,
				t_Deadline ,
				t_Null 
			) ;

			if ( SUCCEEDED ( t_Result ) )
			{
				if ( t_Null )
				{
					t_DeadlineSpecified = FALSE ;
				}
			}
		}

		DWORD t_Flags = 0 ;
		BOOL t_FlagsSpecified = TRUE ;

		if ( SUCCEEDED ( t_Result ) )
		{
			t_Result = ProviderSubSystem_Common_Globals :: Get_Uint32 (

				t_FastInstance ,
				L"Flags" ,
				t_Flags ,
				t_Null 
			) ;

			if ( SUCCEEDED ( t_Result ) )
			{
				if ( t_Null )
				{
					t_FlagsSpecified = FALSE ;
				}
			}
		}

		DWORD t_MaxRunTime = 0 ;
		BOOL t_MaxRunTimeSpecified = TRUE ;

		if ( SUCCEEDED ( t_Result ) )
		{
			t_Result = ProviderSubSystem_Common_Globals :: Get_Uint32 (

				t_FastInstance ,
				L"MaxRunTime" ,
				t_MaxRunTime ,
				t_Null 
			) ;

			if ( SUCCEEDED ( t_Result ) )
			{
				if ( t_Null )
				{
					t_MaxRunTimeSpecified = FALSE ;
				}
			}
		}

		DWORD t_Priority = 0 ;
		BOOL t_PrioritySpecified = TRUE ;

		if ( SUCCEEDED ( t_Result ) )
		{
			t_Result = ProviderSubSystem_Common_Globals :: Get_Uint32 (

				t_FastInstance ,
				L"Priority" ,
				t_Priority ,
				t_Null 
			) ;

			if ( SUCCEEDED ( t_Result ) )
			{
				if ( t_Null )
				{
					t_PrioritySpecified = FALSE ;
				}
			}
		}

		if ( SUCCEEDED ( t_Result ) )
		{
			ITaskScheduler *t_TaskScheduler = NULL ;

			t_Result = CoCreateInstance (

				CLSID_CTaskScheduler,
				NULL,
				CLSCTX_INPROC_SERVER,
				IID_ITaskScheduler,
				(void **) & t_TaskScheduler
			) ;

			if ( SUCCEEDED ( t_Result ) ) 
			{
				IScheduledWorkItem *t_ScheduledWorkItem = NULL ;

				t_Result = GetScheduledWorkItem (

					t_TaskScheduler ,
					t_WorkItemName ,
					t_ScheduledWorkItem
				) ;

				if ( t_Result == WBEM_E_NOT_FOUND ) 
				{
					if ( ( a_Flags & ( WBEM_FLAG_CREATE_ONLY | WBEM_FLAG_UPDATE_ONLY ) ) == WBEM_FLAG_UPDATE_ONLY ) 
					{
						t_Result = WBEM_E_NOT_FOUND ;
					}
					else
					{
						t_Result = t_TaskScheduler->NewWorkItem (

							t_WorkItemName ,
							CLSID_CTask ,
							IID_IScheduledWorkItem ,
							( IUnknown ** ) & t_ScheduledWorkItem
						) ;
					}
				}
				else
				{
					if ( ( a_Flags & ( WBEM_FLAG_CREATE_ONLY | WBEM_FLAG_UPDATE_ONLY ) ) == WBEM_FLAG_CREATE_ONLY )
					{		
						t_Result = WBEM_E_ALREADY_EXISTS ;
					}
				}

				if ( SUCCEEDED ( t_Result ) )
				{
					if ( SUCCEEDED ( t_Result ) && t_Comment )
					{
						t_Result = t_ScheduledWorkItem->SetComment ( t_Comment ) ;
					}

					if ( SUCCEEDED ( t_Result ) && t_Creator )
					{
						t_Result = t_ScheduledWorkItem->SetCreator ( t_Creator ) ;
					}

					if ( SUCCEEDED ( t_Result ) && ( t_AccountName || t_Password ) )
					{
						t_Result = t_ScheduledWorkItem->SetAccountInformation ( t_AccountName , t_Password ) ;
					}

#if 0
/*
 * Not implemented
 */
					if ( SUCCEEDED ( t_Result ) && t_RetryCountSpecified )
					{
						t_Result = t_ScheduledWorkItem->SetErrorRetryCount ( t_RetryCount ) ;
					}

					if ( SUCCEEDED ( t_Result ) && t_RetryIntervalSpecified )
					{
						t_Result = t_ScheduledWorkItem->SetErrorRetryInterval ( t_RetryInterval ) ;
					}
#endif

					if ( SUCCEEDED ( t_Result ) && t_FlagsSpecified )
					{
						t_Result = t_ScheduledWorkItem->SetFlags ( t_Flags ) ;
					}

					if ( SUCCEEDED ( t_Result ) && ( t_IdleWaitSpecified && t_DeadlineSpecified ) )
					{
						t_Result = t_ScheduledWorkItem->SetIdleWait ( t_IdleWait , t_Deadline ) ;
					}

					if ( SUCCEEDED ( t_Result ) )
					{
						ITask *t_Task = NULL ;
						t_Result = t_ScheduledWorkItem->QueryInterface (

							IID_ITask , 
							( void ** ) & t_Task
						) ;

						if ( SUCCEEDED ( t_Result ) )
						{
							if ( SUCCEEDED ( t_Result ) && t_ApplicationName )
							{
								t_Result = t_Task->SetApplicationName ( t_ApplicationName ) ;
							}

							if ( SUCCEEDED ( t_Result ) && t_WorkingDirectory )
							{
								t_Result = t_Task->SetWorkingDirectory ( t_WorkingDirectory ) ;
							}

							if ( SUCCEEDED ( t_Result ) && t_Parameters )
							{
								t_Result = t_Task->SetParameters ( t_Parameters ) ;
							}

							if ( SUCCEEDED ( t_Result ) && t_PrioritySpecified )
							{
								t_Result = t_Task->SetPriority ( t_Priority ) ;
							}

						}
					}

					if ( SUCCEEDED ( t_Result ) )
					{
						IPersistFile *t_Persist = NULL ;
						t_Result = t_ScheduledWorkItem->QueryInterface (

							IID_IPersistFile ,
							( void ** ) & t_Persist 
						) ;

						if ( SUCCEEDED ( t_Result ) )
						{
							t_Result = t_Persist->Save ( NULL , TRUE ) ;

							t_Persist->Release () ;
						}
					}

					t_ScheduledWorkItem->Release () ;
				}

				t_TaskScheduler->Release () ;
			}
		}

		if ( t_WorkItemName )
		{
			delete [] t_WorkItemName ;
		}

		if ( t_ApplicationName )
		{
			delete [] t_ApplicationName ;
		}

		if ( t_Parameters )
		{
			delete [] t_Parameters ;
		}

		if ( t_WorkingDirectory )
		{
			delete [] t_WorkingDirectory ;
		}

		if ( t_AccountName )
		{
			delete [] t_AccountName ;
		}

		if ( t_Password )
		{
			delete [] t_Password ;
		}

		if ( t_Comment )
		{
			delete [] t_Comment ;
		}

		if ( t_Creator )
		{
			delete [] t_Creator ;
		}

		t_FastInstance->Release () ;
	}

	return t_Result ;
}

#if 0
			if ( SUCCEEDED ( t_Result ) )
			{
				t_Result = t_TaskScheduler->AddWorkItem (

					t_WorkItemName ,
					t_ScheduledWorkItem
				) ;

				if ( SUCCEEDED ( t_Result ) )
				{
					t_ScheduledWorkItem->Release () ;
				}
				else
				{
					if ( t_Result == HRESULT_FROM_WIN32(ERROR_FILE_EXISTS) )
					{
						t_Result = WBEM_E_ALREADY_EXISTS ;
					}
				}
			}
#endif

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CTask_IWbemServices :: PutInstanceAsync_Win32_Trigger (

	IWbemClassObject *a_Instance, 
	IWbemClassObject *a_ClassObject ,
	long a_Flags , 
	IWbemContext *a_Context,
	IWbemObjectSink FAR *a_Sink ,
	TASK_TRIGGER_TYPE a_TriggerType 
)
{
	_IWmiObject *t_FastInstance = NULL ;
	HRESULT t_Result = a_Instance->QueryInterface ( IID__IWmiObject , ( void ** ) & t_FastInstance ) ;
	if ( SUCCEEDED ( t_Result ) )
	{
		wchar_t *t_WorkItemName = NULL ;
		BOOL t_Null = FALSE ;

		t_Result = ProviderSubSystem_Common_Globals :: Get_String (

				a_Instance ,
				L"WorkItemName" ,
				t_WorkItemName ,
				t_Null 
		) ;

		if ( SUCCEEDED ( t_Result ) )
		{
			if ( t_Null )
			{
				t_Result = WBEM_E_INVALID_OBJECT ;
			}
		}

		FILETIME t_BeginDate ;
		SYSTEMTIME t_SystemBeginDate ;
		ZeroMemory ( & t_SystemBeginDate , sizeof ( t_SystemBeginDate ) ) ;

		if ( SUCCEEDED ( t_Result ) )
		{
			t_Result = ProviderSubSystem_Common_Globals :: Get_DateTime (

					a_Instance ,
					L"BeginDate" ,
					t_BeginDate ,
					t_Null 
			) ;

			if ( SUCCEEDED ( t_Result ) )
			{
				if ( ! t_Null )
				{
					if ( FileTimeToSystemTime ( & t_BeginDate , & t_SystemBeginDate ) )
					{
					}
					else
					{
						t_Result = WBEM_E_INVALID_PROPERTY ;
					}
				}
				else
				{
					t_Result = WBEM_E_INVALID_OBJECT ;
				}
			}
		}

		FILETIME t_EndDate ;
		SYSTEMTIME t_SystemEndDate ;
		ZeroMemory ( & t_SystemEndDate , sizeof ( t_SystemEndDate ) ) ;
		BOOL t_EndDateSpecified = TRUE ;

		if ( SUCCEEDED ( t_Result ) )
		{
			t_Result = ProviderSubSystem_Common_Globals :: Get_DateTime (

					a_Instance ,
					L"EndDate" ,
					t_EndDate ,
					t_Null 
			) ;

			if ( SUCCEEDED ( t_Result ) )
			{
				if ( ! t_Null )
				{
					if ( FileTimeToSystemTime ( & t_EndDate , & t_SystemEndDate ) )
					{
					}
					else
					{
						t_Result = WBEM_E_INVALID_PROPERTY ;
					}
				}
				else
				{
					t_EndDateSpecified = FALSE ;
				}
			}
		}

		WORD t_TriggerId = 0 ;
		BOOL t_TriggerIdSpecified = TRUE ;

		if ( SUCCEEDED ( t_Result ) )
		{
			t_Result = ProviderSubSystem_Common_Globals :: Get_Uint16 (

				t_FastInstance ,
				L"TriggerId" ,
				t_TriggerId ,
				t_Null 
			) ;

			if ( SUCCEEDED ( t_Result ) )
			{
				if ( t_Null )
				{
					t_TriggerIdSpecified = FALSE ;
				}
			}
		}

		DWORD t_Duration = 0 ;
		BOOL t_DurationSpecified = TRUE ;

		if ( SUCCEEDED ( t_Result ) )
		{
			t_Result = ProviderSubSystem_Common_Globals :: Get_Uint32 (

				t_FastInstance ,
				L"Duration" ,
				t_Duration ,
				t_Null 
			) ;

			if ( SUCCEEDED ( t_Result ) )
			{
				if ( t_Null )
				{
					t_DurationSpecified = FALSE ;
				}
			}
		}

		DWORD t_Interval = 0 ;
		BOOL t_IntervalSpecified = TRUE ;

		if ( SUCCEEDED ( t_Result ) )
		{
			t_Result = ProviderSubSystem_Common_Globals :: Get_Uint32 (

				t_FastInstance ,
				L"Interval" ,
				t_Interval ,
				t_Null 
			) ;

			if ( SUCCEEDED ( t_Result ) )
			{
				if ( t_Null )
				{
					t_IntervalSpecified = FALSE ;
				}
			}
		}

		BOOL t_KillAtDurationEnd = 0 ;
		BOOL t_KillAtDurationEndSpecified = TRUE ;

		if ( SUCCEEDED ( t_Result ) )
		{
			t_Result = ProviderSubSystem_Common_Globals :: Get_Bool (

				t_FastInstance ,
				L"KillAtDurationEnd" ,
				t_KillAtDurationEnd ,
				t_Null 
			) ;

			if ( SUCCEEDED ( t_Result ) )
			{
				if ( t_Null )
				{
					t_KillAtDurationEndSpecified = FALSE ;
				}
			}
		}

		if ( SUCCEEDED ( t_Result ) )
		{
			ITaskScheduler *t_TaskScheduler = NULL ;

			t_Result = CoCreateInstance (

				CLSID_CTaskScheduler,
				NULL,
				CLSCTX_INPROC_SERVER,
				IID_ITaskScheduler,
				(void **) & t_TaskScheduler
			) ;

			if ( SUCCEEDED ( t_Result ) ) 
			{
				IScheduledWorkItem *t_ScheduledWorkItem = NULL ;

				t_Result = GetScheduledWorkItem (

					t_TaskScheduler ,
					t_WorkItemName ,
					t_ScheduledWorkItem
				) ;

				if ( SUCCEEDED ( t_Result ) )
				{
					WORD t_TriggerId = 0 ;
					ITaskTrigger *t_Trigger = NULL ;

					t_Result = t_ScheduledWorkItem->CreateTrigger (

						& t_TriggerId ,
						& t_Trigger
					) ;

					if ( SUCCEEDED ( t_Result ) )
					{
						TASK_TRIGGER t_TaskTrigger ;
						ZeroMemory ( & t_TaskTrigger , sizeof ( t_TaskTrigger ) ) ;
						t_TaskTrigger.cbTriggerSize = sizeof ( t_TaskTrigger ) ;

						if ( SUCCEEDED ( t_Result ) )
						{
							t_TaskTrigger.TriggerType = a_TriggerType ;
							t_TaskTrigger.wBeginYear = t_SystemBeginDate.wYear ;
							t_TaskTrigger.wBeginMonth = t_SystemBeginDate.wMonth ;
							t_TaskTrigger.wBeginDay = t_SystemBeginDate.wDay ;

							if ( t_EndDateSpecified )
							{
								t_TaskTrigger.wEndYear = t_SystemEndDate.wYear ;
								t_TaskTrigger.wEndMonth = t_SystemEndDate.wMonth ;
								t_TaskTrigger.wEndDay = t_SystemEndDate.wDay ;
								t_TaskTrigger.rgFlags |= TASK_TRIGGER_FLAG_HAS_END_DATE ;
							}

							if ( t_KillAtDurationEndSpecified && t_KillAtDurationEnd )
							{
								t_TaskTrigger.rgFlags |= TASK_TRIGGER_FLAG_KILL_AT_DURATION_END ;
							}
						}

						switch ( t_TaskTrigger.TriggerType )
						{
							case TASK_TIME_TRIGGER_ONCE:
							case TASK_TIME_TRIGGER_DAILY:
							case TASK_TIME_TRIGGER_WEEKLY:
							case TASK_TIME_TRIGGER_MONTHLYDATE:
							case TASK_TIME_TRIGGER_MONTHLYDOW:
							{
								WORD t_StartHour = 0 ;
								BOOL t_StartHourSpecified = TRUE ;

								if ( SUCCEEDED ( t_Result ) )
								{
									t_Result = ProviderSubSystem_Common_Globals :: Get_Uint16 (

										t_FastInstance ,
										L"StartHour" ,
										t_StartHour ,
										t_Null 
									) ;

									if ( SUCCEEDED ( t_Result ) )
									{
										if ( t_Null )
										{
											t_StartHourSpecified = FALSE ;
										}
									}
								}

								WORD t_StartMinute = 0 ;
								BOOL t_StartMinuteSpecified = TRUE ;

								if ( SUCCEEDED ( t_Result ) )
								{
									t_Result = ProviderSubSystem_Common_Globals :: Get_Uint16 (

										t_FastInstance ,
										L"StartMinute" ,
										t_StartMinute ,
										t_Null 
									) ;

									if ( SUCCEEDED ( t_Result ) )
									{
										if ( t_Null )
										{
											t_StartMinuteSpecified = FALSE ;
										}
									}
								}

								if ( t_StartHourSpecified && t_StartMinuteSpecified )
								{
									t_TaskTrigger.wStartHour = t_StartHour ;
									t_TaskTrigger.wStartMinute = t_StartMinute ;
								}
								else
								{
									t_Result = WBEM_E_INVALID_PROPERTY ;
								}
							}
							break ;

							case TASK_EVENT_TRIGGER_ON_IDLE:
							case TASK_EVENT_TRIGGER_AT_SYSTEMSTART:
							case TASK_EVENT_TRIGGER_AT_LOGON:
							{
							}
							break ;

							default:
							{
								t_Result = WBEM_E_UNEXPECTED ;
							}
							break ;
						}

						switch ( t_TaskTrigger.TriggerType )
						{
							case TASK_TIME_TRIGGER_DAILY:
							{
								WORD t_DaysInterval = 0 ;

								if ( SUCCEEDED ( t_Result ) )
								{
									t_Result = ProviderSubSystem_Common_Globals :: Get_Uint16 (

										t_FastInstance ,
										L"DaysInterval" ,
										t_DaysInterval ,
										t_Null 
									) ;

									if ( SUCCEEDED ( t_Result ) )
									{
										if ( t_Null == FALSE )
										{
											t_TaskTrigger.Type.Daily.DaysInterval = t_DaysInterval ;
										}
										else
										{
											t_Result = WBEM_E_INVALID_PROPERTY ;
										}
									}
								}
							}
							break ;

							case TASK_TIME_TRIGGER_WEEKLY:
							{
								WORD t_Days = 0 ;

								if ( SUCCEEDED ( t_Result ) )
								{
									t_Result = ProviderSubSystem_Common_Globals :: Get_Uint16 (

										t_FastInstance ,
										L"Days" ,
										t_Days ,
										t_Null 
									) ;

									if ( SUCCEEDED ( t_Result ) )
									{
										if ( t_Null == FALSE )
										{
											t_TaskTrigger.Type.Weekly.rgfDaysOfTheWeek = t_Days ;
										}
										else
										{
											t_Result = WBEM_E_INVALID_PROPERTY ;
										}
									}
								}

								WORD t_WeeklyInterval = 0 ;

								if ( SUCCEEDED ( t_Result ) )
								{
									t_Result = ProviderSubSystem_Common_Globals :: Get_Uint16 (

										t_FastInstance ,
										L"WeeklyInterval" ,
										t_WeeklyInterval ,
										t_Null 
									) ;

									if ( SUCCEEDED ( t_Result ) )
									{
										if ( t_Null == FALSE )
										{
											t_TaskTrigger.Type.Weekly.WeeksInterval = t_WeeklyInterval ;
										}
										else
										{
											t_Result = WBEM_E_INVALID_PROPERTY ;
										}
									}
								}
							}
							break ;

							case TASK_TIME_TRIGGER_MONTHLYDATE:
							{
								DWORD t_Days = 0 ;

								if ( SUCCEEDED ( t_Result ) )
								{
									t_Result = ProviderSubSystem_Common_Globals :: Get_Uint32 (

										t_FastInstance ,
										L"Days" ,
										t_Days ,
										t_Null 
									) ;

									if ( SUCCEEDED ( t_Result ) )
									{
										if ( t_Null == FALSE )
										{
											t_TaskTrigger.Type.MonthlyDate.rgfDays = t_Days ;
										}
										else
										{
											t_Result = WBEM_E_INVALID_PROPERTY ;
										}
									}
								}

								WORD t_Months = 0 ;

								if ( SUCCEEDED ( t_Result ) )
								{
									t_Result = ProviderSubSystem_Common_Globals :: Get_Uint16 (

										t_FastInstance ,
										L"Months" ,
										t_Months ,
										t_Null 
									) ;

									if ( SUCCEEDED ( t_Result ) )
									{
										if ( t_Null == FALSE )
										{
											t_TaskTrigger.Type.MonthlyDate.rgfMonths = t_Months ;
										}
										else
										{
											t_Result = WBEM_E_INVALID_PROPERTY ;
										}
									}
								}
							}
							break ;

							case TASK_TIME_TRIGGER_MONTHLYDOW:
							{
								WORD t_Week = 0 ;

								if ( SUCCEEDED ( t_Result ) )
								{
									t_Result = ProviderSubSystem_Common_Globals :: Get_Uint16 (

										t_FastInstance ,
										L"Week" ,
										t_Week ,
										t_Null 
									) ;

									if ( SUCCEEDED ( t_Result ) )
									{
										if ( t_Null == FALSE )
										{
											t_TaskTrigger.Type.MonthlyDOW.wWhichWeek = t_Week ;
										}
										else
										{
											t_Result = WBEM_E_INVALID_PROPERTY ;
										}
									}
								}

								WORD t_Days = 0 ;

								if ( SUCCEEDED ( t_Result ) )
								{
									t_Result = ProviderSubSystem_Common_Globals :: Get_Uint16 (

										t_FastInstance ,
										L"Days" ,
										t_Days ,
										t_Null 
									) ;

									if ( SUCCEEDED ( t_Result ) )
									{
										if ( t_Null == FALSE )
										{
											t_TaskTrigger.Type.MonthlyDOW.rgfDaysOfTheWeek = t_Days ;
										}
										else
										{
											t_Result = WBEM_E_INVALID_PROPERTY ;
										}
									}
								}

								WORD t_Months = 0 ;

								if ( SUCCEEDED ( t_Result ) )
								{
									t_Result = ProviderSubSystem_Common_Globals :: Get_Uint16 (

										t_FastInstance ,
										L"Months" ,
										t_Months ,
										t_Null 
									) ;

									if ( SUCCEEDED ( t_Result ) )
									{
										if ( t_Null == FALSE )
										{
											t_TaskTrigger.Type.MonthlyDOW.rgfMonths = t_Months ;
										}
										else
										{
											t_Result = WBEM_E_INVALID_PROPERTY ;
										}
									}
								}
							}
							break ;

							case TASK_TIME_TRIGGER_ONCE:
							case TASK_EVENT_TRIGGER_ON_IDLE:
							case TASK_EVENT_TRIGGER_AT_SYSTEMSTART:
							case TASK_EVENT_TRIGGER_AT_LOGON:
							{
							}
							break ;

							default:
							{
								t_Result = WBEM_E_UNEXPECTED ;
							}
							break ;
						}
						
						if ( SUCCEEDED ( t_Result ) )
						{
							t_Result = t_Trigger->SetTrigger ( & t_TaskTrigger ) ;
						}

						if ( SUCCEEDED ( t_Result ) )
						{
							IPersistFile *t_Persist = NULL ;
							t_Result = t_ScheduledWorkItem->QueryInterface (

								IID_IPersistFile ,
								( void ** ) & t_Persist 
							) ;

							if ( SUCCEEDED ( t_Result ) )
							{
								t_Result = t_Persist->Save ( NULL , TRUE ) ;

								t_Persist->Release () ;
							}
						}
					}

					t_ScheduledWorkItem->Release () ;
				}
			}

			t_TaskScheduler->Release () ;
		}

		if ( t_WorkItemName )
		{
			delete [] t_WorkItemName ;
		}

		t_FastInstance->Release () ;
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *
 * Uint16 IdleWait ;
 * Uint16 Deadline ;
 * String Comment ;
 * String Creator ;
 * Uint32 ItemData [] ;
 * Uint16 RetryCount ;
 * Uint16 RetryInterval ;
 * Uint32 Flags ;
 * String AccountName ;
 * String Password ;
 * String WorkItemName ;
 * String ApplicationName ;
 * String Parameters ;
 * String WorkingDirectory ;
 * Uint32 Priority ;
 * Uint32 MaxRunTime ;
 * 
 *****************************************************************************/

HRESULT CTask_IWbemServices :: PutInstanceAsync ( 
		
	IWbemClassObject *a_Instance, 
	long a_Flags, 
    IWbemContext *a_Context ,
	IWbemObjectSink *a_Sink
) 
{
	wchar_t *t_Class = NULL ;
	BOOL t_Null = FALSE ;

	HRESULT t_Result = ProviderSubSystem_Common_Globals :: Get_String (

		a_Instance ,
		L"__CLASS" ,
		t_Class ,
		t_Null 
	) ;

	if ( SUCCEEDED ( t_Result ) )
	{
		if ( ! t_Null )
		{
			t_Result = CoImpersonateClient () ;

			if ( _wcsicmp ( t_Class , L"Win32_Task" ) == 0 ) 
			{
				t_Result = PutInstanceAsync_Win32_Task ( 

					a_Instance ,
					m_Win32_Task_Object ,
					a_Flags ,
					a_Context , 
					a_Sink
				) ;
			}
			else if ( _wcsicmp ( t_Class , L"Win32_Once" ) == 0 ) 
			{
				t_Result = PutInstanceAsync_Win32_Trigger ( 

					a_Instance ,
					m_Win32_Once_Object ,
					a_Flags ,
					a_Context , 
					a_Sink ,
					TASK_TIME_TRIGGER_ONCE
				) ;
			}
			else if ( _wcsicmp ( t_Class , L"Win32_WeeklyTrigger" ) == 0 ) 
			{
				t_Result = PutInstanceAsync_Win32_Trigger ( 

					a_Instance ,
					m_Win32_WeeklyTrigger_Object ,
					a_Flags ,
					a_Context , 
					a_Sink ,
					TASK_TIME_TRIGGER_WEEKLY
				) ;
			}
			else if ( _wcsicmp ( t_Class , L"Win32_DailyTrigger" ) == 0 ) 
			{
				t_Result = PutInstanceAsync_Win32_Trigger ( 

					a_Instance ,
					m_Win32_DailyTrigger_Object ,
					a_Flags ,
					a_Context , 
					a_Sink ,
					TASK_TIME_TRIGGER_DAILY
				) ;
			}
			else if ( _wcsicmp ( t_Class , L"Win32_MonthlyDateTrigger" ) == 0 ) 
			{
				t_Result = PutInstanceAsync_Win32_Trigger ( 

					a_Instance ,
					m_Win32_MonthlyDateTrigger_Object ,
					a_Flags ,
					a_Context , 
					a_Sink ,
					TASK_TIME_TRIGGER_MONTHLYDATE
				) ;
			}
			else if ( _wcsicmp ( t_Class , L"Win32_MonthlyDayOfWeekTrigger" ) == 0 ) 
			{
				t_Result = PutInstanceAsync_Win32_Trigger ( 

					a_Instance ,
					m_Win32_MonthlyDayOfWeekTrigger_Object ,
					a_Flags ,
					a_Context , 
					a_Sink ,
					TASK_TIME_TRIGGER_MONTHLYDOW
				) ;
			}
			else if ( _wcsicmp ( t_Class , L"Win32_OnIdle" ) == 0 ) 
			{
				t_Result = PutInstanceAsync_Win32_Trigger ( 

					a_Instance ,
					m_Win32_OnIdle_Object ,
					a_Flags ,
					a_Context , 
					a_Sink ,
					TASK_EVENT_TRIGGER_ON_IDLE
				) ;
			}
			else if ( _wcsicmp ( t_Class , L"Win32_AtSystemStart" ) == 0 ) 
			{
				t_Result = PutInstanceAsync_Win32_Trigger ( 

					a_Instance ,
					m_Win32_AtSystemStart_Object ,
					a_Flags ,
					a_Context , 
					a_Sink ,
					TASK_EVENT_TRIGGER_AT_SYSTEMSTART
				) ;
			}
			else if ( _wcsicmp ( t_Class , L"Win32_AtLogon" ) == 0 ) 
			{
				t_Result = PutInstanceAsync_Win32_Trigger ( 

					a_Instance ,
					m_Win32_AtLogon_Object ,
					a_Flags ,
					a_Context , 
					a_Sink ,
					TASK_EVENT_TRIGGER_AT_LOGON
				) ;
			}
			else if ( _wcsicmp ( t_Class , L"Win32_ScheduledWorkItemTrigger" ) == 0 ) 
			{
				t_Result = WBEM_E_NOT_SUPPORTED ;
			}
			else
			{
				t_Result = WBEM_E_INVALID_CLASS ;
			}
		}
		else
		{
			t_Result = WBEM_E_INVALID_PROPERTY ;
		}
	}

	if ( t_Class )
	{
		delete [] t_Class ;
	}

	a_Sink->SetStatus ( 0 , t_Result , NULL , NULL ) ;

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CTask_IWbemServices :: DeleteInstance ( 

	const BSTR ObjectPath,
    long lFlags,
    IWbemContext FAR *pCtx,
    IWbemCallResult FAR *FAR *ppCallResult
)
{
	return WBEM_E_NOT_AVAILABLE ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CTask_IWbemServices :: DeleteInstanceAsync_Win32_Task (

	IWbemClassObject *a_ClassObject ,
	long a_Flags , 
	IWbemContext *a_Context,
	IWbemObjectSink FAR *a_Sink ,
	IWbemPath *a_Path 
)
{
	HRESULT t_Result = S_OK ;

	wchar_t *t_Key_Name = NULL ;

	IWbemPathKeyList *t_Keys = NULL ;

	t_Result = a_Path->GetKeyList (

		& t_Keys 
	) ;

	if ( SUCCEEDED ( t_Result ) )
	{
		ULONG t_KeyCount = 0 ;
		t_Result = t_Keys->GetCount (

			& t_KeyCount 
		) ;

		if ( SUCCEEDED ( t_Result ) )
		{
			if ( t_KeyCount == 1 )
			{
				wchar_t t_Key [ 32 ] ; 
				ULONG t_KeyLength = 32 ;
				ULONG t_KeyValueLength = 0 ;
				ULONG t_KeyType = 0 ;

				t_Result = t_Keys->GetKey (

					0 ,
					0 ,
					& t_KeyLength ,
					t_Key ,
					& t_KeyValueLength ,
					NULL ,
					& t_KeyType
				) ;

				if ( SUCCEEDED ( t_Result ) ) 
				{
					if ( t_KeyType == CIM_STRING )
					{
						t_Key_Name = new wchar_t [ t_KeyValueLength ] ;
						if ( t_Key_Name )
						{
							t_Result = t_Keys->GetKey (

								0 ,
								0 ,
								& t_KeyLength ,
								t_Key ,
								& t_KeyValueLength ,
								t_Key_Name ,
								& t_KeyType
							) ;
						}
						else
						{
							t_Result = WBEM_E_OUT_OF_MEMORY ;
						}
					}
					else
					{
						t_Result = WBEM_E_INVALID_CLASS ;
					}
				}
			}
			else
			{
				t_Result = WBEM_E_INVALID_CLASS ;
			}
		}
	}

	BOOL t_Found = FALSE ;

	if ( SUCCEEDED ( t_Result ) )
	{
		ITaskScheduler *t_TaskScheduler = NULL ;

		t_Result = CoCreateInstance (

			CLSID_CTaskScheduler,
			NULL,
			CLSCTX_INPROC_SERVER,
			IID_ITaskScheduler,
			(void **) & t_TaskScheduler
		) ;

		if ( SUCCEEDED ( t_Result ) ) 
		{
			IEnumTasks *t_TaskEnumerator = NULL ;
			t_Result = t_TaskScheduler->Delete ( t_Key_Name ) ;
			if ( SUCCEEDED ( t_Result ) )
			{
				t_Found = TRUE ;
			}
			else
			{
				t_Result = WBEM_E_NOT_FOUND ;
			}

			t_TaskScheduler->Release () ;
		}
	}

	if ( t_Key_Name )
	{
		delete [] t_Key_Name ;
	}

	if ( SUCCEEDED ( t_Result ) && t_Found == FALSE )
	{
		t_Result = WBEM_E_NOT_FOUND ;
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CTask_IWbemServices :: DeleteInstanceAsync_Win32_Trigger (

	IWbemClassObject *a_ClassObject ,
	long a_Flags , 
	IWbemContext *a_Context,
	IWbemObjectSink FAR *a_Sink ,
	IWbemPath *a_Path ,
	TASK_TRIGGER_TYPE a_TriggerType 
)
{
	HRESULT t_Result = S_OK ;

	wchar_t *t_Key_Name = NULL ;
	WORD t_Key_TriggerIndex = 0 ;

	IWbemPathKeyList *t_Keys = NULL ;

	t_Result = a_Path->GetKeyList (

		& t_Keys 
	) ;

	if ( SUCCEEDED ( t_Result ) )
	{
		ULONG t_KeyCount = 0 ;
		t_Result = t_Keys->GetCount (

			& t_KeyCount 
		) ;

		if ( SUCCEEDED ( t_Result ) )
		{
			if ( t_KeyCount == 2 )
			{
				wchar_t t_Key [ 32 ] ; 
				ULONG t_KeyLength = 32 ;
				ULONG t_KeyValueLength = 0 ;
				ULONG t_KeyType = 0 ;

				t_Result = t_Keys->GetKey (

					0 ,
					0 ,
					& t_KeyLength ,
					t_Key ,
					& t_KeyValueLength ,
					NULL ,
					& t_KeyType
				) ;

				if ( SUCCEEDED ( t_Result ) ) 
				{
					if ( t_KeyType == CIM_SINT32 )
					{
						t_Result = t_Keys->GetKey (

							0 ,
							0 ,
							& t_KeyLength ,
							t_Key ,
							& t_KeyValueLength ,
							& t_Key_TriggerIndex ,
							& t_KeyType
						) ;
					}
					else
					{
						t_Result = WBEM_E_INVALID_CLASS ;
					}
				}

				t_KeyLength = 32 ;
				t_KeyValueLength = 0 ;
				t_KeyType = 0 ;

				t_Result = t_Keys->GetKey (

					1 ,
					0 ,
					& t_KeyLength ,
					t_Key ,
					& t_KeyValueLength ,
					NULL ,
					& t_KeyType
				) ;

				if ( SUCCEEDED ( t_Result ) ) 
				{
					if ( t_KeyType == CIM_STRING )
					{
						t_Key_Name = new wchar_t [ t_KeyValueLength ] ;
						if ( t_Key_Name )
						{
							t_Result = t_Keys->GetKey (

								1 ,
								0 ,
								& t_KeyLength ,
								t_Key ,
								& t_KeyValueLength ,
								t_Key_Name ,
								& t_KeyType
							) ;
						}
						else
						{
							t_Result = WBEM_E_OUT_OF_MEMORY ;
						}
					}
					else
					{
						t_Result = WBEM_E_INVALID_CLASS ;
					}
				}

			}
			else
			{
				t_Result = WBEM_E_INVALID_CLASS ;
			}
		}
	}

	BOOL t_Found = FALSE ;

	if ( SUCCEEDED ( t_Result ) )
	{
		ITaskScheduler *t_TaskScheduler = NULL ;

		t_Result = CoCreateInstance (

			CLSID_CTaskScheduler,
			NULL,
			CLSCTX_INPROC_SERVER,
			IID_ITaskScheduler,
			(void **) & t_TaskScheduler
		) ;

		if ( SUCCEEDED ( t_Result ) ) 
		{
			IEnumTasks *t_TaskEnumerator = NULL ;
			t_Result = t_TaskScheduler->Enum ( & t_TaskEnumerator ) ;
			if ( SUCCEEDED ( t_Result ) )
			{
				wchar_t **t_Name = NULL ;
				t_TaskEnumerator->Reset () ;
				while ( ( t_Result = t_TaskEnumerator->Next ( 1 , & t_Name , NULL ) ) == S_OK ) 
				{
					if ( wcscmp ( t_Name [ 0 ] , t_Key_Name ) == 0 )
					{
						IScheduledWorkItem *t_ScheduledWorkItem = NULL ;
						t_Result = t_TaskScheduler->Activate (

							t_Name [ 0 ] , 
							IID_IScheduledWorkItem , 
							( IUnknown ** ) & t_ScheduledWorkItem
						) ;

						if ( SUCCEEDED ( t_Result ) )
						{
							t_Found = TRUE ;

							t_Result = t_ScheduledWorkItem->DeleteTrigger (

								t_Key_TriggerIndex
							) ;

							if ( SUCCEEDED ( t_Result ) )
							{
								IPersistFile *t_Persist = NULL ;
								t_Result = t_ScheduledWorkItem->QueryInterface (

									IID_IPersistFile ,
									( void ** ) & t_Persist 
								) ;

								if ( SUCCEEDED ( t_Result ) )
								{
									t_Result = t_Persist->Save ( NULL , TRUE ) ;

									t_Persist->Release () ;
								}
							}

							t_ScheduledWorkItem->Release () ;
						}
					}

					CoTaskMemFree ( t_Name ) ;
				}

				if ( t_Result != S_FALSE )
				{
					t_Result = WBEM_E_FAILED ;
				}

				t_TaskEnumerator->Release () ;
			}

			t_TaskScheduler->Release () ;

		}
	}

	if ( t_Key_Name )
	{
		delete [] t_Key_Name ;
	}

	if ( SUCCEEDED ( t_Result ) && t_Found == FALSE )
	{
		t_Result = WBEM_E_NOT_FOUND ;
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/
        
HRESULT CTask_IWbemServices :: DeleteInstanceAsync (
 
	const BSTR a_ObjectPath,
    long a_Flags ,
    IWbemContext *a_Context ,
    IWbemObjectSink *a_Sink	
)
{
	IWbemPath *t_Path = NULL ;

	HRESULT t_Result = CoCreateInstance (

		CLSID_WbemDefPath ,
		NULL ,
		CLSCTX_INPROC_SERVER ,
		IID_IWbemPath ,
		( void ** )  & t_Path
	) ;

	if ( SUCCEEDED ( t_Result ) )
	{
		t_Result = t_Path->SetText ( WBEMPATH_CREATE_ACCEPT_ALL , a_ObjectPath ) ;
		if ( SUCCEEDED ( t_Result ) ) 
		{
			ULONG t_Length = 32 ; // None of supported classes is longer than this length
			BSTR t_Class = SysAllocStringLen ( NULL , t_Length ) ; 
			if ( t_Class )
			{
				t_Result = t_Path->GetClassName (

					& t_Length ,
					t_Class
				) ;

				if ( SUCCEEDED ( t_Result ) )
				{
					t_Result = CoImpersonateClient () ;

					if ( _wcsicmp ( t_Class , L"Win32_Task" ) == 0 ) 
					{
						t_Result = DeleteInstanceAsync_Win32_Task ( 

							m_Win32_Task_Object ,
							a_Flags ,
							a_Context , 
							a_Sink ,
							t_Path
						) ;
					}
					else if ( _wcsicmp ( t_Class , L"Win32_Once" ) == 0 ) 
					{
						t_Result = DeleteInstanceAsync_Win32_Trigger ( 

							m_Win32_Once_Object ,
							a_Flags ,
							a_Context , 
							a_Sink ,
							t_Path ,
							TASK_TIME_TRIGGER_ONCE
						) ;
					}
					else if ( _wcsicmp ( t_Class , L"Win32_WeeklyTrigger" ) == 0 ) 
					{
						t_Result = DeleteInstanceAsync_Win32_Trigger ( 

							m_Win32_WeeklyTrigger_Object ,
							a_Flags ,
							a_Context , 
							a_Sink ,
							t_Path ,
							TASK_TIME_TRIGGER_WEEKLY
						) ;
					}
					else if ( _wcsicmp ( t_Class , L"Win32_DailyTrigger" ) == 0 ) 
					{
						t_Result = DeleteInstanceAsync_Win32_Trigger ( 

							m_Win32_DailyTrigger_Object ,
							a_Flags ,
							a_Context , 
							a_Sink ,
							t_Path ,
							TASK_TIME_TRIGGER_DAILY
						) ;
					}
					else if ( _wcsicmp ( t_Class , L"Win32_MonthlyDateTrigger" ) == 0 ) 
					{
						t_Result = DeleteInstanceAsync_Win32_Trigger ( 

							m_Win32_MonthlyDateTrigger_Object ,
							a_Flags ,
							a_Context , 
							a_Sink ,
							t_Path ,
							TASK_TIME_TRIGGER_MONTHLYDATE
						) ;
					}
					else if ( _wcsicmp ( t_Class , L"Win32_MonthlyDayOfWeekTrigger" ) == 0 ) 
					{
						t_Result = DeleteInstanceAsync_Win32_Trigger ( 

							m_Win32_MonthlyDayOfWeekTrigger_Object ,
							a_Flags ,
							a_Context , 
							a_Sink ,
							t_Path ,
							TASK_TIME_TRIGGER_MONTHLYDOW
						) ;
					}
					else if ( _wcsicmp ( t_Class , L"Win32_OnIdle" ) == 0 ) 
					{
						t_Result = DeleteInstanceAsync_Win32_Trigger ( 

							m_Win32_OnIdle_Object ,
							a_Flags ,
							a_Context , 
							a_Sink ,
							t_Path ,
							TASK_EVENT_TRIGGER_ON_IDLE
						) ;
					}
					else if ( _wcsicmp ( t_Class , L"Win32_AtSystemStart" ) == 0 ) 
					{
						t_Result = DeleteInstanceAsync_Win32_Trigger ( 

							m_Win32_AtSystemStart_Object ,
							a_Flags ,
							a_Context , 
							a_Sink ,
							t_Path ,
							TASK_EVENT_TRIGGER_AT_SYSTEMSTART
						) ;
					}
					else if ( _wcsicmp ( t_Class , L"Win32_AtLogon" ) == 0 ) 
					{
						t_Result = DeleteInstanceAsync_Win32_Trigger ( 

							m_Win32_AtLogon_Object ,
							a_Flags ,
							a_Context , 
							a_Sink ,
							t_Path ,
							TASK_EVENT_TRIGGER_AT_LOGON
						) ;
					}
					else if ( _wcsicmp ( t_Class , L"Win32_ScheduledWorkItemTrigger" ) == 0 ) 
					{
						t_Result = WBEM_E_NOT_SUPPORTED ;
					}
					else
					{
						t_Result = WBEM_E_INVALID_CLASS ;
					}
				}

				SysFreeString ( t_Class ) ;
			}
		}

		t_Path->Release () ;
	}

	a_Sink->SetStatus ( 0 , t_Result , NULL , NULL ) ;

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CTask_IWbemServices :: CreateInstanceEnum ( 

	const BSTR a_Class, 
	long a_Flags, 
	IWbemContext FAR *a_Context, 
	IEnumWbemClassObject **a_Enum
)
{
	HRESULT t_Result = WBEM_E_NOT_AVAILABLE ;

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CTask_IWbemServices :: CreateInstanceEnumAsync (

 	const BSTR a_Class ,
	long a_Flags , 
	IWbemContext *a_Context,
	IWbemObjectSink FAR *a_Sink

) 
{
	HRESULT t_Result = CoImpersonateClient () ;

	if ( _wcsicmp ( a_Class , L"Win32_Task" ) == 0 ) 
	{
		t_Result = CreateInstanceEnumAsync_Win32_Task ( 

			m_Win32_Task_Object ,
			a_Flags ,
			a_Context , 
			a_Sink
		) ;
	}
	else if ( _wcsicmp ( a_Class , L"Win32_Once" ) == 0 ) 
	{
		t_Result = CreateInstanceEnumAsync_Win32_Trigger ( 

			m_Win32_Once_Object ,
			a_Flags ,
			a_Context , 
			a_Sink ,
			TASK_TIME_TRIGGER_ONCE
		) ;
	}
	else if ( _wcsicmp ( a_Class , L"Win32_WeeklyTrigger" ) == 0 ) 
	{
		t_Result = CreateInstanceEnumAsync_Win32_Trigger ( 

			m_Win32_WeeklyTrigger_Object ,
			a_Flags ,
			a_Context , 
			a_Sink ,
			TASK_TIME_TRIGGER_WEEKLY
		) ;
	}
	else if ( _wcsicmp ( a_Class , L"Win32_DailyTrigger" ) == 0 ) 
	{
		t_Result = CreateInstanceEnumAsync_Win32_Trigger ( 

			m_Win32_DailyTrigger_Object ,
			a_Flags ,
			a_Context , 
			a_Sink ,
			TASK_TIME_TRIGGER_DAILY
		) ;
	}
	else if ( _wcsicmp ( a_Class , L"Win32_MonthlyDateTrigger" ) == 0 ) 
	{
		t_Result = CreateInstanceEnumAsync_Win32_Trigger ( 

			m_Win32_MonthlyDateTrigger_Object ,
			a_Flags ,
			a_Context , 
			a_Sink ,
			TASK_TIME_TRIGGER_MONTHLYDATE
		) ;
	}
	else if ( _wcsicmp ( a_Class , L"Win32_MonthlyDayOfWeekTrigger" ) == 0 ) 
	{
		t_Result = CreateInstanceEnumAsync_Win32_Trigger ( 

			m_Win32_MonthlyDayOfWeekTrigger_Object ,
			a_Flags ,
			a_Context , 
			a_Sink ,
			TASK_TIME_TRIGGER_MONTHLYDOW
		) ;
	}
	else if ( _wcsicmp ( a_Class , L"Win32_OnIdle" ) == 0 ) 
	{
		t_Result = CreateInstanceEnumAsync_Win32_Trigger ( 

			m_Win32_OnIdle_Object ,
			a_Flags ,
			a_Context , 
			a_Sink ,
			TASK_EVENT_TRIGGER_ON_IDLE
		) ;
	}
	else if ( _wcsicmp ( a_Class , L"Win32_AtSystemStart" ) == 0 ) 
	{
		t_Result = CreateInstanceEnumAsync_Win32_Trigger ( 

			m_Win32_AtSystemStart_Object ,
			a_Flags ,
			a_Context , 
			a_Sink ,
			TASK_EVENT_TRIGGER_AT_SYSTEMSTART
		) ;
	}
	else if ( _wcsicmp ( a_Class , L"Win32_AtLogon" ) == 0 ) 
	{
		t_Result = CreateInstanceEnumAsync_Win32_Trigger ( 

			m_Win32_AtLogon_Object ,
			a_Flags ,
			a_Context , 
			a_Sink ,
			TASK_EVENT_TRIGGER_AT_LOGON
		) ;
	}
	else if ( _wcsicmp ( a_Class , L"Win32_ScheduledWorkItemTrigger" ) == 0 ) 
	{
		t_Result = CreateInstanceEnumAsync_Win32_ScheduledWorkItemTrigger ( 

			m_Win32_ScheduledWorkItemTrigger_Object ,
			a_Flags ,
			a_Context , 
			a_Sink
		) ;
	}
	else
	{
		t_Result = WBEM_E_INVALID_CLASS ;
	}
	
	a_Sink->SetStatus ( 0 , t_Result , NULL , NULL ) ;

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CTask_IWbemServices :: ExecQuery ( 

	const BSTR a_QueryLanguage, 
	const BSTR a_Query, 
	long a_Flags, 
	IWbemContext *a_Context ,
	IEnumWbemClassObject **a_Enumerator
)
{
	return WBEM_E_NOT_AVAILABLE ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CTask_IWbemServices :: ExecQueryAsync ( 
		
	const BSTR a_QueryFormat, 
	const BSTR a_Query, 
	long a_Flags, 
	IWbemContext *a_Context ,
	IWbemObjectSink *a_Sink
) 
{
	HRESULT t_Result = CoImpersonateClient () ;

	a_Sink->SetStatus ( WBEM_STATUS_REQUIREMENTS , S_OK , NULL , NULL ) ;

	t_Result = CreateInstanceEnumAsync_Win32_Task ( 

		m_Win32_Task_Object ,
		a_Flags ,
		a_Context , 
		a_Sink
	) ;

	a_Sink->SetStatus ( 0 , t_Result , NULL , NULL ) ;

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CTask_IWbemServices :: ExecNotificationQuery ( 

	const BSTR a_QueryLanguage,
    const BSTR a_Query,
    long a_Flags,
    IWbemContext *a_Context ,
    IEnumWbemClassObject **a_Enumerator
)
{
	return WBEM_E_NOT_AVAILABLE ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/
        
HRESULT CTask_IWbemServices :: ExecNotificationQueryAsync ( 
            
	const BSTR a_QueryLanguage,
    const BSTR a_Query,
    long a_Flags ,
    IWbemContext *a_Context ,
    IWbemObjectSink *a_Sink
)
{
	return WBEM_E_NOT_AVAILABLE ;
}       

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT STDMETHODCALLTYPE CTask_IWbemServices :: ExecMethod ( 

	const BSTR ObjectPath,
    const BSTR MethodName,
    long lFlags,
    IWbemContext FAR *pCtx,
    IWbemClassObject FAR *pInParams,
    IWbemClassObject FAR *FAR *ppOutParams,
    IWbemCallResult FAR *FAR *ppCallResult
)
{
	return WBEM_E_NOT_AVAILABLE ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CTask_IWbemServices :: ExecMethodAsync_Win32_Task (

	IWbemClassObject *a_ClassObject ,
	long a_Flags , 
	IWbemContext *a_Context,
	IWbemObjectSink FAR *a_Sink ,
	IWbemPath *a_Path ,
	BSTR a_MethodName
)
{
	HRESULT t_Result = S_OK ;

	wchar_t *t_Key_Name = NULL ;

	IWbemPathKeyList *t_Keys = NULL ;

	t_Result = a_Path->GetKeyList (

		& t_Keys 
	) ;

	if ( SUCCEEDED ( t_Result ) )
	{
		ULONG t_KeyCount = 0 ;
		t_Result = t_Keys->GetCount (

			& t_KeyCount 
		) ;

		if ( SUCCEEDED ( t_Result ) )
		{
			if ( t_KeyCount == 1 )
			{
				wchar_t t_Key [ 32 ] ; 
				ULONG t_KeyLength = 32 ;
				ULONG t_KeyValueLength = 0 ;
				ULONG t_KeyType = 0 ;

				t_Result = t_Keys->GetKey (

					0 ,
					0 ,
					& t_KeyLength ,
					t_Key ,
					& t_KeyValueLength ,
					NULL ,
					& t_KeyType
				) ;

				if ( SUCCEEDED ( t_Result ) ) 
				{
					if ( t_KeyType == CIM_STRING )
					{
						t_Key_Name = new wchar_t [ t_KeyValueLength ] ;
						if ( t_Key_Name )
						{
							t_Result = t_Keys->GetKey (

								0 ,
								0 ,
								& t_KeyLength ,
								t_Key ,
								& t_KeyValueLength ,
								t_Key_Name ,
								& t_KeyType
							) ;
						}
						else
						{
							t_Result = WBEM_E_OUT_OF_MEMORY ;
						}
					}
					else
					{
						t_Result = WBEM_E_INVALID_CLASS ;
					}
				}
			}
			else
			{
				t_Result = WBEM_E_INVALID_CLASS ;
			}
		}
	}

	BOOL t_Found = FALSE ;

	if ( SUCCEEDED ( t_Result ) )
	{
		ITaskScheduler *t_TaskScheduler = NULL ;

		t_Result = CoCreateInstance (

			CLSID_CTaskScheduler,
			NULL,
			CLSCTX_INPROC_SERVER,
			IID_ITaskScheduler,
			(void **) & t_TaskScheduler
		) ;

		if ( SUCCEEDED ( t_Result ) ) 
		{
			IEnumTasks *t_TaskEnumerator = NULL ;
			t_Result = t_TaskScheduler->Enum ( & t_TaskEnumerator ) ;
			if ( SUCCEEDED ( t_Result ) )
			{
				wchar_t **t_Name = NULL ;
				t_TaskEnumerator->Reset () ;
				while ( ( t_Result = t_TaskEnumerator->Next ( 1 , & t_Name , NULL ) ) == S_OK ) 
				{
					if ( wcscmp ( t_Name [ 0 ] , t_Key_Name ) == 0 )
					{
						t_Found = TRUE ;

						IScheduledWorkItem *t_ScheduledWorkItem = NULL ;
						t_Result = t_TaskScheduler->Activate (

							t_Name [ 0 ] , 
							IID_IScheduledWorkItem , 
							( IUnknown ** ) & t_ScheduledWorkItem
						) ;

						if ( SUCCEEDED ( t_Result ) )
						{
							if ( _wcsicmp ( a_MethodName , L"Run" ) == 0 ) 
							{
								t_Result = t_ScheduledWorkItem->Run () ;
							}
							else if ( _wcsicmp ( a_MethodName , L"Terminate" ) == 0 ) 
							{
								t_Result = t_ScheduledWorkItem->Terminate () ;
							}
							
							t_ScheduledWorkItem->Release () ;
						}
					}

					CoTaskMemFree ( t_Name ) ;
				}

				if ( t_Result != S_FALSE )
				{
					t_Result = WBEM_E_FAILED ;
				}

				t_TaskEnumerator->Release () ;
			}

			t_TaskScheduler->Release () ;

		}
	}

	if ( t_Key_Name )
	{
		delete [] t_Key_Name ;
	}

	if ( SUCCEEDED ( t_Result ) && t_Found == FALSE )
	{
		t_Result = WBEM_E_NOT_FOUND ;
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT STDMETHODCALLTYPE CTask_IWbemServices :: ExecMethodAsync ( 

    const BSTR a_ObjectPath,
    const BSTR a_MethodName,
    long a_Flags,
    IWbemContext *a_Context,
    IWbemClassObject *a_InParams,
	IWbemObjectSink *a_Sink
)
{
	HRESULT t_Result = S_OK ;

	IWbemPath *t_Path = NULL ;

	if ( a_ObjectPath && a_MethodName ) 
	{
		t_Result = CoCreateInstance (

			CLSID_WbemDefPath ,
			NULL ,
			CLSCTX_INPROC_SERVER ,
			IID_IWbemPath ,
			( void ** )  & t_Path
		) ;

		if ( SUCCEEDED ( t_Result ) )
		{
			t_Result = t_Path->SetText ( WBEMPATH_CREATE_ACCEPT_ALL , a_ObjectPath ) ;
			if ( SUCCEEDED ( t_Result ) )
			{
				ULONG t_Length = 32 ; // None of supported classes is longer than this length
				BSTR t_Class = SysAllocStringLen ( NULL , t_Length ) ; 
				if ( t_Class )
				{
					t_Result = t_Path->GetClassName (

						& t_Length ,
						t_Class
					) ;

					if ( SUCCEEDED ( t_Result ) )
					{
						if ( _wcsicmp ( t_Class , L"Win32_ScheduledWorkItem" ) == 0 ) 
						{
							if ( _wcsicmp ( a_MethodName , L"Run" ) == 0 ) 
							{
								t_Result = ExecMethodAsync_Win32_Task ( 

									m_Win32_Task_Object ,
									a_Flags ,
									a_Context , 
									a_Sink ,
									t_Path ,
									a_MethodName 
								) ;
							}
							else if ( _wcsicmp ( a_MethodName , L"Terminate" ) == 0 ) 
							{
								t_Result = ExecMethodAsync_Win32_Task ( 

									m_Win32_Task_Object ,
									a_Flags ,
									a_Context , 
									a_Sink ,
									t_Path ,
									a_MethodName 
								) ;
							}
							else
							{
								t_Result = WBEM_E_INVALID_METHOD ;
							}
						}
						else
						{
							t_Result = WBEM_E_INVALID_CLASS ;
						}
					}

					SysFreeString ( t_Class ) ;
				}
			}

			t_Path->Release () ;
		}
	}
	else
	{
		t_Result = WBEM_E_INVALID_PARAMETER ;
	}

	a_Sink->SetStatus ( 0 , t_Result , NULL , NULL ) ;

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT GetClassObject (

	IWbemServices *a_CoreService,
	IWbemContext *a_Context,
	wchar_t *a_Class ,
	IWbemClassObject **a_ClassObject
)
{
	HRESULT t_Result = S_OK ;

	BSTR t_Class = SysAllocString ( a_Class ) ;
	if ( t_Class ) 
	{
		t_Result = a_CoreService->GetObject (

			t_Class ,
			0 ,
			a_Context ,
			a_ClassObject ,
			NULL 
		) ;

		if ( SUCCEEDED ( t_Result ) )
		{
		}

		SysFreeString ( t_Class ) ;
	}
	else
	{
		t_Result = WBEM_E_OUT_OF_MEMORY ;
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CTask_IWbemServices :: Initialize (

	LPWSTR a_User,
	LONG a_Flags,
	LPWSTR a_Namespace,
	LPWSTR a_Locale,
	IWbemServices *a_CoreService,         // For anybody
	IWbemContext *a_Context,
	IWbemProviderInitSink *a_Sink     // For init signals
)
{
	HRESULT t_Result = S_OK ;

	if ( a_CoreService ) 
	{
		m_CoreService = a_CoreService ;
		m_CoreService->AddRef () ;
	}
	else
	{
		t_Result = WBEM_E_INVALID_PARAMETER ;
	}

	if ( SUCCEEDED ( t_Result ) )
	{
		if ( a_User ) 
		{
			m_User = SysAllocString ( a_User ) ;
			if ( m_User == NULL )
			{
				t_Result = WBEM_E_OUT_OF_MEMORY ;
			}
		}
	}

	if ( SUCCEEDED ( t_Result ) )
	{
		if ( a_Locale ) 
		{
			m_Locale = SysAllocString ( a_Locale ) ;
			if ( m_Locale == NULL )
			{
				t_Result = WBEM_E_OUT_OF_MEMORY ;
			}
		}
	}

	if ( SUCCEEDED ( t_Result ) )
	{
		if ( a_Namespace ) 
		{
			m_Namespace = SysAllocString ( a_Namespace ) ;
			if ( m_Namespace == NULL )
			{
				t_Result = WBEM_E_OUT_OF_MEMORY ;
			}
		}
	}
	
	if ( SUCCEEDED ( t_Result ) ) 
	{
		t_Result = GetClassObject (

			a_CoreService ,
			a_Context ,
			L"Win32_Task" ,
			& m_Win32_Task_Object
		) ;
	}

	if ( SUCCEEDED ( t_Result ) ) 
	{
		t_Result = GetClassObject (

			a_CoreService ,
			a_Context ,
			L"Win32_Once" ,
			& m_Win32_Once_Object
		) ;
	}

	if ( SUCCEEDED ( t_Result ) ) 
	{
		t_Result = GetClassObject (

			a_CoreService ,
			a_Context ,
			L"Win32_WeeklyTrigger" ,
			& m_Win32_WeeklyTrigger_Object
		) ;
	}

	if ( SUCCEEDED ( t_Result ) ) 
	{
		t_Result = GetClassObject (

			a_CoreService ,
			a_Context ,
			L"Win32_DailyTrigger" ,
			& m_Win32_DailyTrigger_Object
		) ;
	}

	if ( SUCCEEDED ( t_Result ) ) 
	{
		t_Result = GetClassObject (

			a_CoreService ,
			a_Context ,
			L"Win32_MonthlyDateTrigger" ,
			& m_Win32_MonthlyDateTrigger_Object
		) ;
	}

	if ( SUCCEEDED ( t_Result ) ) 
	{
		t_Result = GetClassObject (

			a_CoreService ,
			a_Context ,
			L"Win32_MonthlyDayOfWeekTrigger" ,
			& m_Win32_MonthlyDayOfWeekTrigger_Object
		) ;
	}

	if ( SUCCEEDED ( t_Result ) ) 
	{
		t_Result = GetClassObject (

			a_CoreService ,
			a_Context ,
			L"Win32_OnIdle" ,
			& m_Win32_OnIdle_Object
		) ;
	}
	
	if ( SUCCEEDED ( t_Result ) ) 
	{
		t_Result = GetClassObject (

			a_CoreService ,
			a_Context ,
			L"Win32_AtSystemStart" ,
			& m_Win32_AtSystemStart_Object
		) ;
	}
	
	if ( SUCCEEDED ( t_Result ) ) 
	{
		t_Result = GetClassObject (

			a_CoreService ,
			a_Context ,
			L"Win32_AtLogon" ,
			& m_Win32_AtLogon_Object
		) ;
	}

	if ( SUCCEEDED ( t_Result ) ) 
	{
		t_Result = GetClassObject (

			a_CoreService ,
			a_Context ,
			L"Win32_ScheduledWorkItemTrigger" ,
			& m_Win32_ScheduledWorkItemTrigger_Object
		) ;
	}

	a_Sink->SetStatus ( t_Result , 0 ) ;

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CTask_IWbemServices :: Shutdown (

	LONG a_Flags ,
	ULONG a_MaxMilliSeconds ,
	IWbemContext *a_Context
)
{
	HRESULT t_Result = S_OK ;

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CTask_IWbemServices :: CreateInstanceEnumAsync_Win32_Task (

	IWbemClassObject *a_ClassObject ,
	long a_Flags , 
	IWbemContext *a_Context,
	IWbemObjectSink FAR *a_Sink
)
{
	HRESULT t_Result = S_OK ;

	ITaskScheduler *t_TaskScheduler = NULL ;

    t_Result = CoCreateInstance (

		CLSID_CTaskScheduler,
        NULL,
        CLSCTX_INPROC_SERVER,
        IID_ITaskScheduler,
        (void **) & t_TaskScheduler
	) ;

	if ( SUCCEEDED ( t_Result ) ) 
	{
		IEnumTasks *t_TaskEnumerator = NULL ;
		t_Result = t_TaskScheduler->Enum ( & t_TaskEnumerator ) ;
		if ( SUCCEEDED ( t_Result ) )
		{
			wchar_t **t_Name = NULL ;
			t_TaskEnumerator->Reset () ;
			while ( ( t_Result = t_TaskEnumerator->Next ( 1 , & t_Name , NULL ) ) == S_OK ) 
			{
				IWbemClassObject *t_Instance = NULL ;
				t_Result = a_ClassObject->SpawnInstance ( 

					0 , 
					& t_Instance
				) ;

				if ( SUCCEEDED ( t_Result ) )
				{
					HRESULT t_Result = CommonAsync_Win32_Task_Load (

						t_TaskScheduler ,
						t_Name [ 0 ] ,
						t_Instance
					) ;

					if ( SUCCEEDED ( t_Result ) ) 
					{
						t_Result = a_Sink->Indicate ( 1 , & t_Instance ) ;
					}

					t_Instance->Release () ;
				}

				CoTaskMemFree ( t_Name ) ;
			}

			if ( t_Result != S_FALSE )
			{
				t_Result = WBEM_E_FAILED ;
			}

			t_TaskEnumerator->Release () ;
		}

		t_TaskScheduler->Release () ;

	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CTask_IWbemServices :: CommonAsync_Win32_Task_Load (

	ITaskScheduler *a_TaskScheduler ,
	wchar_t *a_TaskName ,
	IWbemClassObject *a_Instance 
)
{
	HRESULT t_Result = S_OK ;

	_IWmiObject *t_FastInstance = NULL ;
	t_Result = a_Instance->QueryInterface ( IID__IWmiObject , ( void ** ) & t_FastInstance ) ;
	if ( SUCCEEDED ( t_Result ) )
	{
		ITask *t_Task = NULL ;
		t_Result = a_TaskScheduler->Activate (

			a_TaskName , 
			IID_ITask , 
			( IUnknown ** ) & t_Task
		) ;

		if ( SUCCEEDED ( t_Result ) )
		{
			ProviderSubSystem_Common_Globals :: Set_String ( a_Instance , L"WorkItemName" , a_TaskName ) ;

			wchar_t *t_ApplicationName = NULL ;
			t_Result = t_Task->GetApplicationName ( & t_ApplicationName ) ;
			if ( SUCCEEDED ( t_Result ) )
			{
				ProviderSubSystem_Common_Globals :: Set_String ( a_Instance , L"ApplicationName" , t_ApplicationName ) ;

				CoTaskMemFree ( t_ApplicationName ) ;
			}

			wchar_t *t_WorkingDirectory = NULL ;
			t_Result = t_Task->GetWorkingDirectory ( & t_WorkingDirectory ) ;
			if ( SUCCEEDED ( t_Result ) )
			{
				ProviderSubSystem_Common_Globals :: Set_String ( a_Instance , L"WorkingDirectory" , t_WorkingDirectory ) ;

				CoTaskMemFree ( t_WorkingDirectory ) ;
			}

			wchar_t *t_Parameters = NULL ;
			t_Result = t_Task->GetParameters ( & t_Parameters ) ;
			if ( SUCCEEDED ( t_Result ) )
			{
				ProviderSubSystem_Common_Globals :: Set_String ( a_Instance , L"Parameters" , t_Parameters ) ;

				CoTaskMemFree ( t_Parameters ) ;
			}

			DWORD t_MaxRunTime = 0 ;
			t_Result = t_Task->GetMaxRunTime ( & t_MaxRunTime ) ;
			if ( SUCCEEDED ( t_Result ) )
			{
				ProviderSubSystem_Common_Globals :: Set_Uint32 ( t_FastInstance , L"MaxRunTime" , t_MaxRunTime ) ;
			}

			DWORD t_Priority = 0 ;
			t_Result = t_Task->GetPriority ( & t_Priority ) ;
			if ( SUCCEEDED ( t_Result ) )
			{
				ProviderSubSystem_Common_Globals :: Set_Uint32 ( t_FastInstance , L"Priority" , t_Priority ) ;
			}

			IScheduledWorkItem *t_ScheduledWorkItem = NULL ;
			t_Result = t_Task->QueryInterface (

				IID_IScheduledWorkItem , 
				( void ** ) & t_ScheduledWorkItem
			) ;

			if ( SUCCEEDED ( t_Result ) )
			{
				wchar_t *t_Comment = NULL ;
				t_Result = t_ScheduledWorkItem->GetComment ( & t_Comment ) ;
				if ( SUCCEEDED ( t_Result ) )
				{
					ProviderSubSystem_Common_Globals :: Set_String ( a_Instance , L"Comment" , t_Comment ) ;

					CoTaskMemFree ( t_Comment ) ;
				}

				wchar_t *t_Creator = NULL ;
				t_Result = t_ScheduledWorkItem->GetCreator ( & t_Creator ) ;
				if ( SUCCEEDED ( t_Result ) )
				{
					ProviderSubSystem_Common_Globals :: Set_String ( a_Instance , L"Creator" , t_Creator ) ;

					CoTaskMemFree ( t_Creator ) ;
				}

				wchar_t *t_AccountInformation = NULL ;
				t_Result = t_ScheduledWorkItem->GetAccountInformation ( & t_AccountInformation ) ;
				if ( SUCCEEDED ( t_Result ) )
				{
					ProviderSubSystem_Common_Globals :: Set_String ( a_Instance , L"AccountName" , t_AccountInformation ) ;

					CoTaskMemFree ( t_AccountInformation ) ;
				}

				HRESULT t_Status = 0 ;
				t_Result = t_ScheduledWorkItem->GetStatus ( & t_Status ) ;
				if ( SUCCEEDED ( t_Result ) )
				{
					ProviderSubSystem_Common_Globals :: Set_Uint32 ( t_FastInstance , L"Status" , t_Status ) ;
				}

				DWORD t_ExitCode = 0 ;
				t_Result = t_ScheduledWorkItem->GetExitCode ( & t_ExitCode ) ;
				if ( SUCCEEDED ( t_Result ) )
				{
					ProviderSubSystem_Common_Globals :: Set_Uint32 ( t_FastInstance , L"ExitCode" , t_ExitCode ) ;
				}

				DWORD t_Flags = 0 ;
				t_Result = t_ScheduledWorkItem->GetExitCode ( & t_Flags ) ;
				if ( SUCCEEDED ( t_Result ) )
				{
					ProviderSubSystem_Common_Globals :: Set_Uint32 ( t_FastInstance , L"Flags" , t_Flags ) ;
					ProviderSubSystem_Common_Globals :: Set_Bool ( t_FastInstance , L"Enabled" , ( t_Flags & TASK_FLAG_DISABLED ) == 0 ) ;

				}

				WORD t_ErrorRetryCount = 0 ;
				t_Result = t_ScheduledWorkItem->GetErrorRetryCount ( & t_ErrorRetryCount ) ;
				if ( SUCCEEDED ( t_Result ) )
				{
					ProviderSubSystem_Common_Globals :: Set_Uint16 ( t_FastInstance , L"RetryCount" , t_ErrorRetryCount ) ;
				}

				WORD t_ErrorRetryInterval = 0 ;
				t_Result = t_ScheduledWorkItem->GetErrorRetryInterval ( & t_ErrorRetryInterval ) ;
				if ( SUCCEEDED ( t_Result ) )
				{
					ProviderSubSystem_Common_Globals :: Set_Uint16 ( t_FastInstance , L"RetryInterval" , t_ErrorRetryInterval ) ;
				}

				WORD t_IdleWait = 0 ;
				WORD t_DeadlineMinutes = 0 ;

				t_Result = t_ScheduledWorkItem->GetIdleWait ( & t_IdleWait , &  t_DeadlineMinutes ) ;
				if ( SUCCEEDED ( t_Result ) )
				{
					ProviderSubSystem_Common_Globals :: Set_Uint16 ( t_FastInstance , L"IdleWait" , t_IdleWait ) ;
					ProviderSubSystem_Common_Globals :: Set_Uint16 ( t_FastInstance , L"Deadline" , t_DeadlineMinutes ) ;
				}

				SYSTEMTIME t_LastRunTime ;
				t_Result = t_ScheduledWorkItem->GetMostRecentRunTime ( & t_LastRunTime ) ;
				if ( SUCCEEDED ( t_Result ) )
				{
					FILETIME t_FileTime ;

					BOOL t_Status = SystemTimeToFileTime (

					  & t_LastRunTime ,
					  & t_FileTime
					) ;

					if ( t_Status )
					{
						ProviderSubSystem_Common_Globals :: Set_DateTime ( a_Instance , L"LastRunTime" , t_FileTime ) ;
					}
				}

				SYSTEMTIME t_NextRunTime ;
				t_Result = t_ScheduledWorkItem->GetNextRunTime ( & t_NextRunTime ) ;
				if ( SUCCEEDED ( t_Result ) )
				{
					FILETIME t_FileTime ;

					BOOL t_Status = SystemTimeToFileTime (

					  & t_NextRunTime ,
					  & t_FileTime
					) ;

					if ( t_Status )
					{
						ProviderSubSystem_Common_Globals :: Set_DateTime ( a_Instance , L"NextRunTime" , t_FileTime ) ;
					}
				}

				WORD t_ItemDataByteCount = 0 ;
				BYTE *t_ItemDataByte = NULL ;

				t_Result = t_ScheduledWorkItem->GetWorkItemData ( & t_ItemDataByteCount , & t_ItemDataByte ) ;
				if ( SUCCEEDED ( t_Result ) )
				{
					ProviderSubSystem_Common_Globals :: Set_Byte_Array ( t_FastInstance , L"ItemData" , t_ItemDataByte , t_ItemDataByteCount ) ;

					CoTaskMemFree ( t_ItemDataByte ) ;
				}

				t_ScheduledWorkItem->Release () ;
			}

			t_Task->Release () ;
		}

		t_FastInstance->Release () ;
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CTask_IWbemServices :: CreateInstanceEnumAsync_Win32_Trigger (

	IWbemClassObject *a_ClassObject ,
	long a_Flags , 
	IWbemContext *a_Context,
	IWbemObjectSink FAR *a_Sink ,
	TASK_TRIGGER_TYPE a_TriggerType 
)
{
	HRESULT t_Result = S_OK ;

	ITaskScheduler *t_TaskScheduler = NULL ;

    t_Result = CoCreateInstance (

		CLSID_CTaskScheduler,
        NULL,
        CLSCTX_INPROC_SERVER,
        IID_ITaskScheduler,
        (void **) & t_TaskScheduler
	) ;

	if ( SUCCEEDED ( t_Result ) ) 
	{
		IEnumTasks *t_TaskEnumerator = NULL ;
		t_Result = t_TaskScheduler->Enum ( & t_TaskEnumerator ) ;
		if ( SUCCEEDED ( t_Result ) )
		{
			wchar_t **t_Name = NULL ;
			t_TaskEnumerator->Reset () ;
			while ( ( t_Result = t_TaskEnumerator->Next ( 1 , & t_Name , NULL ) ) == S_OK ) 
			{
				HRESULT t_Result = CreateInstanceEnumAsync_Win32_Trigger_Enumerate (

					a_ClassObject ,
					a_Sink ,
					t_TaskScheduler ,
					t_Name [ 0 ] ,
					a_TriggerType
				) ;	

				CoTaskMemFree ( t_Name ) ;
			}

			if ( t_Result != S_FALSE )
			{
				t_Result = WBEM_E_FAILED ;
			}

			t_TaskEnumerator->Release () ;
		}

		t_TaskScheduler->Release () ;

	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CTask_IWbemServices :: CreateInstanceEnumAsync_Win32_Trigger_Enumerate (

	IWbemClassObject *a_ClassObject ,
	IWbemObjectSink *a_Sink ,
	ITaskScheduler *a_TaskScheduler ,
	wchar_t *a_TaskName ,
	TASK_TRIGGER_TYPE a_TriggerType 
)
{
	HRESULT t_Result = S_OK ;

	ITask *t_Task = NULL ;
	t_Result = a_TaskScheduler->Activate (

		a_TaskName , 
		IID_ITask , 
		( IUnknown ** ) & t_Task
	) ;

	if ( SUCCEEDED ( t_Result ) )
	{
		IScheduledWorkItem *t_ScheduledWorkItem = NULL ;
		t_Result = t_Task->QueryInterface (

			IID_IScheduledWorkItem , 
			( void ** ) & t_ScheduledWorkItem
		) ;

		if ( SUCCEEDED ( t_Result ) )
		{
			WORD t_TriggerCount = 0 ;

			t_Result = t_ScheduledWorkItem->GetTriggerCount(

				& t_TriggerCount 
			) ;

			if ( SUCCEEDED ( t_Result ) )
			{
				for ( WORD t_Index = 0 ;t_Index < t_TriggerCount ; t_Index ++ )
				{
					IWbemClassObject *t_Instance = NULL ;
					t_Result = a_ClassObject->SpawnInstance ( 

						0 , 
						& t_Instance
					) ;

					if ( SUCCEEDED ( t_Result ) )
					{
						_IWmiObject *t_FastInstance = NULL ;
						t_Result = t_Instance->QueryInterface ( IID__IWmiObject , ( void ** ) & t_FastInstance ) ;
						if ( SUCCEEDED ( t_Result ) )
						{
							ProviderSubSystem_Common_Globals :: Set_Uint16 ( t_FastInstance , L"TriggerId" , t_Index ) ;

							ProviderSubSystem_Common_Globals :: Set_String ( t_Instance , L"WorkItemName" , a_TaskName ) ;

							wchar_t *t_TriggerString = NULL ;
							t_Result = t_Task->GetTriggerString ( t_Index , & t_TriggerString ) ;
							if ( SUCCEEDED ( t_Result ) )
							{
								ProviderSubSystem_Common_Globals :: Set_String ( t_Instance , L"TriggerName" , t_TriggerString ) ;

								CoTaskMemFree ( t_TriggerString ) ;
							}

							ITaskTrigger *t_Trigger = NULL ;
							t_Result = t_Task->GetTrigger ( t_Index , & t_Trigger ) ;
							if ( SUCCEEDED ( t_Result ) ) 
							{
								TASK_TRIGGER t_TaskTrigger ;
								ZeroMemory ( & t_TaskTrigger , sizeof ( t_TaskTrigger ) ) ;
								t_TaskTrigger.cbTriggerSize = sizeof ( t_TaskTrigger ) ;

								t_Result = t_Trigger->GetTrigger ( & t_TaskTrigger ) ;
								if ( SUCCEEDED ( t_Result ) )
								{
									ProviderSubSystem_Common_Globals :: Set_Uint32 ( t_FastInstance , L"Type" , t_TaskTrigger.TriggerType ) ;

									SYSTEMTIME t_BeginDate ;
									ZeroMemory ( & t_BeginDate , sizeof ( t_BeginDate ) ) ;

									t_BeginDate.wYear = t_TaskTrigger.wBeginYear ;
									t_BeginDate.wMonth = t_TaskTrigger.wBeginMonth ;
									t_BeginDate.wDay = t_TaskTrigger.wBeginDay ;

									FILETIME t_BeginFileTime ;

									BOOL t_Status = SystemTimeToFileTime (

									  & t_BeginDate ,
									  & t_BeginFileTime
									) ;

									if ( t_Status )
									{
										ProviderSubSystem_Common_Globals :: Set_DateTime ( t_Instance , L"BeginDate" , t_BeginFileTime ) ;
									}

									if ( t_TaskTrigger.rgFlags == TASK_TRIGGER_FLAG_HAS_END_DATE )
									{
										SYSTEMTIME t_EndDate ;
										ZeroMemory ( & t_EndDate , sizeof ( t_EndDate ) ) ;

										t_EndDate.wYear = t_TaskTrigger.wEndYear ;          
										t_EndDate.wMonth = t_TaskTrigger.wEndMonth ;
										t_EndDate.wDay = t_TaskTrigger.wEndDay ;        

										FILETIME t_EndFileTime ;

										t_Status = SystemTimeToFileTime (

										  & t_EndDate ,
										  & t_EndFileTime
										) ;

										if ( t_Status )
										{
											ProviderSubSystem_Common_Globals :: Set_DateTime ( t_Instance , L"EndDate" , t_EndFileTime ) ;
										}
									}

									ProviderSubSystem_Common_Globals :: Set_Uint32 ( t_FastInstance , L"Interval" , t_TaskTrigger.MinutesInterval ) ;
									ProviderSubSystem_Common_Globals :: Set_Uint32 ( t_FastInstance , L"Duration" , t_TaskTrigger.MinutesDuration ) ;
									ProviderSubSystem_Common_Globals :: Set_Bool ( t_FastInstance , L"KillAtDurationEnd" , t_TaskTrigger.rgFlags == TASK_TRIGGER_FLAG_KILL_AT_DURATION_END ) ;

									if ( t_TaskTrigger.TriggerType == a_TriggerType )
									{	
										switch ( t_TaskTrigger.TriggerType )
										{
											case TASK_TIME_TRIGGER_ONCE:
											case TASK_TIME_TRIGGER_DAILY:
											case TASK_TIME_TRIGGER_WEEKLY:
											case TASK_TIME_TRIGGER_MONTHLYDATE:
											case TASK_TIME_TRIGGER_MONTHLYDOW:
											{
												ProviderSubSystem_Common_Globals :: Set_Uint16 ( t_FastInstance , L"StartHour" , t_TaskTrigger.wStartHour ) ;
												ProviderSubSystem_Common_Globals :: Set_Uint16 ( t_FastInstance , L"StartMinute" , t_TaskTrigger.wStartMinute ) ;
											}
											break ;

											case TASK_EVENT_TRIGGER_ON_IDLE:
											case TASK_EVENT_TRIGGER_AT_SYSTEMSTART:
											case TASK_EVENT_TRIGGER_AT_LOGON:
											{
											}
											break ;

											default:
											{
												t_Result = WBEM_E_UNEXPECTED ;
											}
											break ;
										}

										switch ( t_TaskTrigger.TriggerType )
										{
											case TASK_TIME_TRIGGER_DAILY:
											{
												ProviderSubSystem_Common_Globals :: Set_Uint16 ( t_FastInstance , L"DailyInterval" , t_TaskTrigger.Type.Daily.DaysInterval ) ;
											}
											break ;


											case TASK_TIME_TRIGGER_WEEKLY:
											{
												ProviderSubSystem_Common_Globals :: Set_Uint16 ( t_FastInstance , L"WeeklyInterval" , t_TaskTrigger.Type.Weekly.WeeksInterval ) ;
												ProviderSubSystem_Common_Globals :: Set_Uint16 ( t_FastInstance , L"Days" , t_TaskTrigger.Type.Weekly.rgfDaysOfTheWeek ) ;
											}
											break ;

											case TASK_TIME_TRIGGER_MONTHLYDATE:
											{
												ProviderSubSystem_Common_Globals :: Set_Uint16 ( t_FastInstance , L"Months" , t_TaskTrigger.Type.MonthlyDate.rgfMonths ) ;
												ProviderSubSystem_Common_Globals :: Set_Uint32 ( t_FastInstance , L"Days" , t_TaskTrigger.Type.MonthlyDate.rgfDays ) ;
											}
											break ;

											case TASK_TIME_TRIGGER_MONTHLYDOW:
											{
												ProviderSubSystem_Common_Globals :: Set_Uint16 ( t_FastInstance , L"Week" , t_TaskTrigger.Type.MonthlyDOW.wWhichWeek ) ;
												ProviderSubSystem_Common_Globals :: Set_Uint16 ( t_FastInstance , L"Days" , t_TaskTrigger.Type.MonthlyDOW.rgfDaysOfTheWeek ) ;
												ProviderSubSystem_Common_Globals :: Set_Uint16 ( t_FastInstance , L"Months" , t_TaskTrigger.Type.MonthlyDOW.rgfMonths ) ;
											}
											break ;

											case TASK_TIME_TRIGGER_ONCE:
											case TASK_EVENT_TRIGGER_ON_IDLE:
											case TASK_EVENT_TRIGGER_AT_SYSTEMSTART:
											case TASK_EVENT_TRIGGER_AT_LOGON:
											{
											}
											break ;

											default:
											{
												t_Result = WBEM_E_UNEXPECTED ;
											}
											break ;
										}

										if ( SUCCEEDED ( t_Result ) ) 
										{
											t_Result = a_Sink->Indicate ( 1 , & t_Instance ) ;
										}
									}									
								}

								t_Trigger->Release () ;
							}

							t_FastInstance->Release () ;
						}

						t_Instance->Release () ;
					}
				}
			}

			t_ScheduledWorkItem->Release () ;
		}

		t_Task->Release () ;
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CTask_IWbemServices :: GetObjectAsync_Win32_Trigger_Load (

	IWbemClassObject *a_ClassObject ,
	IWbemObjectSink *a_Sink ,
	ITaskScheduler *a_TaskScheduler ,
	wchar_t *a_TaskName ,
	WORD a_TriggerIndex ,
	TASK_TRIGGER_TYPE a_TriggerType 
)
{
	HRESULT t_Result = S_OK ;

	ITask *t_Task = NULL ;
	t_Result = a_TaskScheduler->Activate (

		a_TaskName , 
		IID_ITask , 
		( IUnknown ** ) & t_Task
	) ;

	if ( SUCCEEDED ( t_Result ) )
	{
		IScheduledWorkItem *t_ScheduledWorkItem = NULL ;
		t_Result = t_Task->QueryInterface (

			IID_IScheduledWorkItem , 
			( void ** ) & t_ScheduledWorkItem
		) ;

		if ( SUCCEEDED ( t_Result ) )
		{
			WORD t_TriggerCount = 0 ;

			t_Result = t_ScheduledWorkItem->GetTriggerCount(

				& t_TriggerCount 
			) ;

			if ( SUCCEEDED ( t_Result ) )
			{
				IWbemClassObject *t_Instance = NULL ;
				t_Result = a_ClassObject->SpawnInstance ( 

					0 , 
					& t_Instance
				) ;

				if ( SUCCEEDED ( t_Result ) )
				{
					_IWmiObject *t_FastInstance = NULL ;
					t_Result = t_Instance->QueryInterface ( IID__IWmiObject , ( void ** ) & t_FastInstance ) ;
					if ( SUCCEEDED ( t_Result ) )
					{
						ProviderSubSystem_Common_Globals :: Set_Uint16 ( t_FastInstance , L"TriggerId" , a_TriggerIndex ) ;

						ProviderSubSystem_Common_Globals :: Set_String ( t_Instance , L"WorkItemName" , a_TaskName ) ;

						wchar_t *t_TriggerString = NULL ;
						t_Result = t_Task->GetTriggerString ( a_TriggerIndex , & t_TriggerString ) ;
						if ( SUCCEEDED ( t_Result ) )
						{
							ProviderSubSystem_Common_Globals :: Set_String ( t_Instance , L"TriggerName" , t_TriggerString ) ;

							CoTaskMemFree ( t_TriggerString ) ;
						}

						ITaskTrigger *t_Trigger = NULL ;
						t_Result = t_Task->GetTrigger ( a_TriggerIndex , & t_Trigger ) ;
						if ( SUCCEEDED ( t_Result ) ) 
						{
							TASK_TRIGGER t_TaskTrigger ;
							ZeroMemory ( & t_TaskTrigger , sizeof ( t_TaskTrigger ) ) ;
							t_TaskTrigger.cbTriggerSize = sizeof ( t_TaskTrigger ) ;

							t_Result = t_Trigger->GetTrigger ( & t_TaskTrigger ) ;
							if ( SUCCEEDED ( t_Result ) )
							{
								ProviderSubSystem_Common_Globals :: Set_Uint32 ( t_FastInstance , L"Type" , t_TaskTrigger.TriggerType ) ;

								SYSTEMTIME t_BeginDate ;
								ZeroMemory ( & t_BeginDate , sizeof ( t_BeginDate ) ) ;

								t_BeginDate.wYear = t_TaskTrigger.wBeginYear ;
								t_BeginDate.wMonth = t_TaskTrigger.wBeginMonth ;
								t_BeginDate.wDay = t_TaskTrigger.wBeginDay ;

								FILETIME t_BeginFileTime ;

								BOOL t_Status = SystemTimeToFileTime (

								  & t_BeginDate ,
								  & t_BeginFileTime
								) ;

								if ( t_Status )
								{

									ProviderSubSystem_Common_Globals :: Set_DateTime ( t_Instance , L"BeginDate" , t_BeginFileTime ) ;
								}

								if ( t_TaskTrigger.rgFlags == TASK_TRIGGER_FLAG_HAS_END_DATE )
								{
									SYSTEMTIME t_EndDate ;
									ZeroMemory ( & t_EndDate , sizeof ( t_EndDate ) ) ;

									t_EndDate.wYear = t_TaskTrigger.wEndYear ;          
									t_EndDate.wMonth = t_TaskTrigger.wEndMonth ;
									t_EndDate.wDay = t_TaskTrigger.wEndDay ;        

									FILETIME t_EndFileTime ;

									t_Status = SystemTimeToFileTime (

									  & t_EndDate ,
									  & t_EndFileTime
									) ;

									if ( t_Status )
									{
										ProviderSubSystem_Common_Globals :: Set_DateTime ( t_Instance , L"EndDate" , t_EndFileTime ) ;
									}
								}

								ProviderSubSystem_Common_Globals :: Set_Uint32 ( t_FastInstance , L"Interval" , t_TaskTrigger.MinutesInterval ) ;
								ProviderSubSystem_Common_Globals :: Set_Uint32 ( t_FastInstance , L"Duration" , t_TaskTrigger.MinutesDuration ) ;
								ProviderSubSystem_Common_Globals :: Set_Bool ( t_FastInstance , L"KillAtDurationEnd" , t_TaskTrigger.rgFlags == TASK_TRIGGER_FLAG_KILL_AT_DURATION_END ) ;

								if ( t_TaskTrigger.TriggerType == a_TriggerType )
								{	
									switch ( t_TaskTrigger.TriggerType )
									{
										case TASK_TIME_TRIGGER_ONCE:
										case TASK_TIME_TRIGGER_DAILY:
										case TASK_TIME_TRIGGER_WEEKLY:
										case TASK_TIME_TRIGGER_MONTHLYDATE:
										case TASK_TIME_TRIGGER_MONTHLYDOW:
										{
											ProviderSubSystem_Common_Globals :: Set_Uint16 ( t_FastInstance , L"StartHour" , t_TaskTrigger.wStartHour ) ;
											ProviderSubSystem_Common_Globals :: Set_Uint16 ( t_FastInstance , L"StartMinute" , t_TaskTrigger.wStartMinute ) ;
										}
										break ;

										case TASK_EVENT_TRIGGER_ON_IDLE:
										case TASK_EVENT_TRIGGER_AT_SYSTEMSTART:
										case TASK_EVENT_TRIGGER_AT_LOGON:
										{
										}
										break ;

										default:
										{
											t_Result = WBEM_E_UNEXPECTED ;
										}
										break ;
									}

									switch ( t_TaskTrigger.TriggerType )
									{
										case TASK_TIME_TRIGGER_DAILY:
										{
											ProviderSubSystem_Common_Globals :: Set_Uint16 ( t_FastInstance , L"DailyInterval" , t_TaskTrigger.Type.Daily.DaysInterval ) ;
										}
										break ;


										case TASK_TIME_TRIGGER_WEEKLY:
										{
											ProviderSubSystem_Common_Globals :: Set_Uint16 ( t_FastInstance , L"WeeklyInterval" , t_TaskTrigger.Type.Weekly.WeeksInterval ) ;
											ProviderSubSystem_Common_Globals :: Set_Uint16 ( t_FastInstance , L"Days" , t_TaskTrigger.Type.Weekly.rgfDaysOfTheWeek ) ;
										}
										break ;

										case TASK_TIME_TRIGGER_MONTHLYDATE:
										{
											ProviderSubSystem_Common_Globals :: Set_Uint16 ( t_FastInstance , L"Months" , t_TaskTrigger.Type.MonthlyDate.rgfMonths ) ;
											ProviderSubSystem_Common_Globals :: Set_Uint32 ( t_FastInstance , L"Days" , t_TaskTrigger.Type.MonthlyDate.rgfDays ) ;
										}
										break ;

										case TASK_TIME_TRIGGER_MONTHLYDOW:
										{
											ProviderSubSystem_Common_Globals :: Set_Uint16 ( t_FastInstance , L"Week" , t_TaskTrigger.Type.MonthlyDOW.wWhichWeek ) ;
											ProviderSubSystem_Common_Globals :: Set_Uint16 ( t_FastInstance , L"Days" , t_TaskTrigger.Type.MonthlyDOW.rgfDaysOfTheWeek ) ;
											ProviderSubSystem_Common_Globals :: Set_Uint16 ( t_FastInstance , L"Months" , t_TaskTrigger.Type.MonthlyDOW.rgfMonths ) ;
										}
										break ;

										case TASK_TIME_TRIGGER_ONCE:
										case TASK_EVENT_TRIGGER_ON_IDLE:
										case TASK_EVENT_TRIGGER_AT_SYSTEMSTART:
										case TASK_EVENT_TRIGGER_AT_LOGON:
										{
										}
										break ;

										default:
										{
											t_Result = WBEM_E_UNEXPECTED ;
										}
										break ;
									}

									if ( SUCCEEDED ( t_Result ) ) 
									{
										t_Result = a_Sink->Indicate ( 1 , & t_Instance ) ;
									}
								}
								else
								{
									t_Result = WBEM_E_NOT_FOUND ;
								}					
							}

							t_Trigger->Release () ;
						}
						else
						{
							t_Result = WBEM_E_NOT_FOUND ;
						}

						t_FastInstance->Release () ;
					}

					t_Instance->Release () ;
				}
			}

			t_ScheduledWorkItem->Release () ;
		}

		t_Task->Release () ;
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CTask_IWbemServices :: CreateInstanceEnumAsync_Win32_ScheduledWorkItemTrigger (

	IWbemClassObject *a_ClassObject ,
	long a_Flags , 
	IWbemContext *a_Context,
	IWbemObjectSink FAR *a_Sink
)
{
	HRESULT t_Result = S_OK ;

	ITaskScheduler *t_TaskScheduler = NULL ;

    t_Result = CoCreateInstance (

		CLSID_CTaskScheduler,
        NULL,
        CLSCTX_INPROC_SERVER,
        IID_ITaskScheduler,
        (void **) & t_TaskScheduler
	) ;

	if ( SUCCEEDED ( t_Result ) ) 
	{
		IEnumTasks *t_TaskEnumerator = NULL ;
		t_Result = t_TaskScheduler->Enum ( & t_TaskEnumerator ) ;
		if ( SUCCEEDED ( t_Result ) )
		{
			wchar_t **t_Name = NULL ;
			t_TaskEnumerator->Reset () ;
			while ( ( t_Result = t_TaskEnumerator->Next ( 1 , & t_Name , NULL ) ) == S_OK ) 
			{
				HRESULT t_Result = CreateInstanceEnumAsync_Win32_ScheduledWorkItemTrigger_Enumerate (

					a_ClassObject ,
					a_Sink ,
					t_TaskScheduler ,
					t_Name [ 0 ]
				) ;	

				CoTaskMemFree ( t_Name ) ;
			}

			if ( t_Result != S_FALSE )
			{
				t_Result = WBEM_E_FAILED ;
			}

			t_TaskEnumerator->Release () ;
		}

		t_TaskScheduler->Release () ;

	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CTask_IWbemServices :: CreateInstanceEnumAsync_Win32_ScheduledWorkItemTrigger_Enumerate (

	IWbemClassObject *a_ClassObject ,
	IWbemObjectSink *a_Sink ,
	ITaskScheduler *a_TaskScheduler ,
	wchar_t *a_TaskName
)
{
	HRESULT t_Result = S_OK ;

	ITask *t_Task = NULL ;
	t_Result = a_TaskScheduler->Activate (

		a_TaskName , 
		IID_ITask , 
		( IUnknown ** ) & t_Task
	) ;

	if ( SUCCEEDED ( t_Result ) )
	{
		wchar_t *t_ApplicationName = NULL ;
		t_Result = t_Task->GetApplicationName ( & t_ApplicationName ) ;
		if ( SUCCEEDED ( t_Result ) )
		{
			IScheduledWorkItem *t_ScheduledWorkItem = NULL ;
			t_Result = t_Task->QueryInterface (

				IID_IScheduledWorkItem , 
				( void ** ) & t_ScheduledWorkItem
			) ;

			if ( SUCCEEDED ( t_Result ) )
			{
				WORD t_TriggerCount = 0 ;

				t_Result = t_ScheduledWorkItem->GetTriggerCount(

					& t_TriggerCount 
				) ;

				if ( SUCCEEDED ( t_Result ) )
				{
					for ( WORD t_Index = 0 ;t_Index < t_TriggerCount ; t_Index ++ )
					{
						IWbemClassObject *t_Instance = NULL ;
						t_Result = a_ClassObject->SpawnInstance ( 

							0 , 
							& t_Instance
						) ;

						if ( SUCCEEDED ( t_Result ) )
						{
							_IWmiObject *t_FastInstance = NULL ;
							t_Result = t_Instance->QueryInterface ( IID__IWmiObject , ( void ** ) & t_FastInstance ) ;
							if ( SUCCEEDED ( t_Result ) )
							{
								ProviderSubSystem_Common_Globals :: Set_Uint16 ( t_FastInstance , L"TriggerId" , t_Index ) ;

								ProviderSubSystem_Common_Globals :: Set_String ( t_Instance , L"WorkItemName" , t_ApplicationName ) ;

								ITaskTrigger *t_Trigger = NULL ;
								t_Result = t_Task->GetTrigger ( t_Index , & t_Trigger ) ;
								if ( SUCCEEDED ( t_Result ) ) 
								{
									ProviderSubSystem_Common_Globals :: Set_Uint16 ( t_FastInstance , L"TriggerId" , t_Index ) ;

									if ( SUCCEEDED ( t_Result ) ) 
									{
										t_Result = a_Sink->Indicate ( 1 , & t_Instance ) ;
									}

									t_Trigger->Release () ;
								}

								t_FastInstance->Release () ;
							}

							t_Instance->Release () ;
						}
					}
				}

				t_ScheduledWorkItem->Release () ;
			}

			CoTaskMemFree ( t_ApplicationName ) ;
		}

		t_Task->Release () ;
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CTask_IWbemServices :: GetScheduledWorkItem (

	ITaskScheduler *a_TaskScheduler ,
	wchar_t *a_Name ,
	IScheduledWorkItem *&a_ScheduledWorkItem
)
{
	BOOL t_Found = FALSE ;

	IEnumTasks *t_TaskEnumerator = NULL ;
	HRESULT t_Result = a_TaskScheduler->Enum ( & t_TaskEnumerator ) ;
	if ( SUCCEEDED ( t_Result ) )
	{
		wchar_t **t_Name = NULL ;
		t_TaskEnumerator->Reset () ;
		while ( ( t_Result = t_TaskEnumerator->Next ( 1 , & t_Name , NULL ) ) == S_OK ) 
		{
			if ( wcscmp ( t_Name [ 0 ] , a_Name ) == 0 )
			{
				t_Result = a_TaskScheduler->Activate (

					t_Name [ 0 ] , 
					IID_IScheduledWorkItem , 
					( IUnknown ** ) & a_ScheduledWorkItem
				) ;

				if ( SUCCEEDED ( t_Result ) )
				{
					t_Found = TRUE ;
				}
			}
		}

		t_TaskEnumerator->Release () ;
	}

	if ( SUCCEEDED ( t_Result ) )
	{
		if ( t_Found == FALSE )
		{
			t_Result = WBEM_E_NOT_FOUND ;
		}
	}

	return t_Result ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\provsubsys\rpcexample\precomp.h ===
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>

#include <windows.h>
#include <stdio.h> 
#include <stdlib.h> 
#include <string.h> 
#include <tchar.h>
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\provsubsys\provider\sources.inc ===
############################################################################
#
#   Copyright (C) 1999, Microsoft Corporation.
#
#   All rights reserved.
#
############################################################################

WMIUNICODE=1
WMIPRECOMPSHARED=1
!include $(PROJECT_ROOT)\wmi\wbem\common\makefile.cmn
SOURCES_USED=$(PROJECT_ROOT)\wmi\wbem\common\makefile.cmn

TARGETNAME=Provider
TARGETPATH=obj

!if "$(WMIASLOCAL)" == "true"
TARGETTYPE=PROGRAM
UMENTRY=winmain
UMTYPE=windows
!else
TARGETTYPE=DYNLINK
!endif

# The TARGETLIBS macro specifies additional libraries to link against your target
# image. Each library path specification should contain an asterisk (*)
# where the machine-specific subdirectory name should go.
LINKLIBS= \
	$(WBEMPRV_COMN_LIB)
TARGETLIBS= \
	$(WMIIDL_LIB) \
	$(WBEMINT_LIB) \
	$(WMIIDL_LIB)  \
	$(STDLIBRARY_LIB) \
	$(COREPROX_LIB) \
	$(SDK_LIB_PATH)\ntdll.lib \
	$(SDK_LIB_PATH)\kernel32.lib \
	$(SDK_LIB_PATH)\advapi32.lib \
	$(SDK_LIB_PATH)\user32.lib \
	$(SDK_LIB_PATH)\oleaut32.lib \
	$(SDK_LIB_PATH)\ole32.lib \
	$(SDK_LIB_PATH)\uuid.lib \
	$(SDK_LIB_PATH)\msvcirt.lib \
	$(SDK_LIB_PATH)\msvcrt.lib \
	$(SDK_LIB_PATH)\vccomsup.lib

# The INCLUDES variable specifies any include paths that are specific to
# this source directory. Separate multiple paths with single
# semicolons. Relative path specifications are okay.
INCLUDES=$(INCLUDES); \
	$(WBEMINT_INC);\
	$(WBEMPSSPROV_INC); \
	$(CONTAINER_INC); \
	$(CONTAINER_SRC); \
	$(WBEMPRV_COMN_INC);\

# The developer defines the SOURCES macro. It contains a list of all the
# source files for this component. Specify each source file on a separate
# line using the line-continuation character. This minimizes merge
# conflicts if two developers are adding source files to the same component.

!if "$(WMIASLOCAL)" == "true"
XSOURCES= \
	..\Main.cpp
!endif

SOURCES=$(XSOURCES) \
	..\Provider.rc \
	..\Globals.cpp \
	..\Maindll.cpp \
	..\Service.cpp \
	..\ClassService.cpp \
	..\Task.cpp \


# Add the following to add DB verbose logging: '/DREP_VERBOSE_LOGGING'

!if "$(WMIASLOCAL)" == "true"
C_DEFINES=$(C_DEFINES) /DWMIASLOCAL
!endif

!if "$(WMIASSTA)" == "true"
C_DEFINES=$(C_DEFINES) /DWMIASSTA
!endif

C_DEFINES=$(C_DEFINES) /D_WIN32_DCOM
MSC_OPTIMIZATION=/Od 
USE_NATIVE_EH=ASYNC
USE_RTTI=1
USE_MSVCRT=1

!if "$(WMIASLOCAL)" != "true"
DLLENTRY=_DllMainCRTStartup
!endif

!if "$(WMIASLOCAL)" != "true"
DLLDEF=$(O)\Provider.def
!else
EXEDEF=$(O)\Provider.def
!endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\provsubsys\provider\include\task.h ===
/*++

Copyright (C) 1996-2001 Microsoft Corporation

Module Name:

	ProvResv.H

Abstract:


History:

--*/

#ifndef _Task_IWbemServices_H
#define _Task_IWbemServices_H

#include <mstask.h>
#include <msterr.h>

class CTask_IWbemServices : public IWbemServices , public IWbemProviderInit , public IWbemShutdown
{
private:

	LONG m_ReferenceCount ;         //Object reference count

	WmiAllocator &m_Allocator ;

	CRITICAL_SECTION m_CriticalSection ;

	IWbemServices *m_CoreService ;

	BSTR m_Namespace ;
	BSTR m_Locale ;
	BSTR m_User ;

	IWbemClassObject *m_Win32_Task_Object ;

	IWbemClassObject *m_Win32_TimeBasedTrigger_Object ;
	IWbemClassObject *m_Win32_Once_Object ;
	IWbemClassObject *m_Win32_WeeklyTrigger_Object ;
	IWbemClassObject *m_Win32_DailyTrigger_Object ;
	IWbemClassObject *m_Win32_MonthlyDateTrigger_Object ;
	IWbemClassObject *m_Win32_MonthlyDayOfWeekTrigger_Object ;
	IWbemClassObject *m_Win32_OnIdle_Object ;
	IWbemClassObject *m_Win32_AtSystemStart_Object ;
	IWbemClassObject *m_Win32_AtLogon_Object ;

	IWbemClassObject *m_Win32_ScheduledWorkItemTrigger_Object ;

private:

	HRESULT PutInstanceAsync_Win32_Task (

		IWbemClassObject *a_Instance, 
		IWbemClassObject *a_ClassObject ,
		long a_Flags , 
		IWbemContext *a_Context,
		IWbemObjectSink *a_Sink
	) ;

	HRESULT PutInstanceAsync_Win32_Trigger (

		IWbemClassObject *a_Instance, 
		IWbemClassObject *a_ClassObject ,
		long a_Flags , 
		IWbemContext *a_Context,
		IWbemObjectSink *a_Sink ,
		TASK_TRIGGER_TYPE a_TriggerType 
	) ;

	HRESULT ExecMethodAsync_Win32_Task (

		IWbemClassObject *a_ClassObject ,
		long a_Flags , 
		IWbemContext *a_Context,
		IWbemObjectSink FAR *a_Sink ,
		IWbemPath *a_Path ,
		BSTR a_MethodName
	) ;

	HRESULT GetObjectAsync_Win32_Trigger_Load (

		IWbemClassObject *a_ClassObject ,
		IWbemObjectSink *a_Sink ,
		ITaskScheduler *a_TaskScheduler ,
		wchar_t *a_TaskName ,
		WORD a_TriggerIndex ,
		TASK_TRIGGER_TYPE a_TriggerType 
	);

	HRESULT GetObjectAsync_Win32_Task (

		IWbemClassObject *a_ClassObject ,
		long a_Flags , 
		IWbemContext *a_Context,
		IWbemObjectSink FAR *a_Sink ,
		IWbemPath *a_Path 
	) ;

	HRESULT DeleteInstanceAsync_Win32_Task (

		IWbemClassObject *a_ClassObject ,
		long a_Flags , 
		IWbemContext *a_Context,
		IWbemObjectSink FAR *a_Sink ,
		IWbemPath *a_Path 
	) ;

	HRESULT GetObjectAsync_Win32_Trigger (

		IWbemClassObject *a_ClassObject ,
		long a_Flags , 
		IWbemContext *a_Context,
		IWbemObjectSink FAR *a_Sink ,
		IWbemPath *a_Path ,
		TASK_TRIGGER_TYPE a_TriggerType 
	) ;

	HRESULT DeleteInstanceAsync_Win32_Trigger (

		IWbemClassObject *a_ClassObject ,
		long a_Flags , 
		IWbemContext *a_Context,
		IWbemObjectSink FAR *a_Sink ,
		IWbemPath *a_Path ,
		TASK_TRIGGER_TYPE a_TriggerType 
	) ;

	HRESULT CommonAsync_Win32_Task_Load (

		ITaskScheduler *a_TaskScheduler ,
		wchar_t *a_TaskName ,
		IWbemClassObject *a_Instance 
	) ;

	HRESULT CreateInstanceEnumAsync_Win32_Task (

		IWbemClassObject *a_ClassObject ,
		long a_Flags , 
		IWbemContext *a_Context,
		IWbemObjectSink FAR *a_Sink
	) ;

	HRESULT CreateInstanceEnumAsync_Win32_Trigger_Enumerate (

		IWbemClassObject *a_ClassObject ,
		IWbemObjectSink *a_Sink ,
		ITaskScheduler *a_TaskScheduler ,
		wchar_t *a_TaskName ,
		TASK_TRIGGER_TYPE a_TriggerType 
	) ;

	HRESULT CreateInstanceEnumAsync_Win32_Trigger (

		IWbemClassObject *a_ClassObject ,
		long a_Flags , 
		IWbemContext *a_Context,
		IWbemObjectSink FAR *a_Sink ,
		TASK_TRIGGER_TYPE a_TriggerType 
	) ;

	HRESULT CreateInstanceEnumAsync_Win32_ScheduledWorkItemTrigger_Enumerate (

		IWbemClassObject *a_ClassObject ,
		IWbemObjectSink *a_Sink ,
		ITaskScheduler *a_TaskScheduler ,
		wchar_t *a_TaskName
	) ;

	HRESULT CreateInstanceEnumAsync_Win32_ScheduledWorkItemTrigger (

		IWbemClassObject *a_ClassObject ,
		long a_Flags , 
		IWbemContext *a_Context,
		IWbemObjectSink FAR *a_Sink
	) ;

	HRESULT GetScheduledWorkItem (

		ITaskScheduler *a_TaskScheduler ,
		wchar_t *a_Name ,
		IScheduledWorkItem *&a_ScheduledWorkItem
	) ;

public:

	CTask_IWbemServices ( WmiAllocator &a_Allocator  ) ;
    ~CTask_IWbemServices () ;

public:

	//Non-delegating object IUnknown

    STDMETHODIMP QueryInterface ( REFIID , LPVOID FAR * ) ;
    STDMETHODIMP_( ULONG ) AddRef () ;
    STDMETHODIMP_( ULONG ) Release () ;

    /* IWbemServices methods */

    HRESULT STDMETHODCALLTYPE OpenNamespace ( 

        const BSTR a_Namespace ,
        long a_Flags ,
        IWbemContext *a_Context ,
        IWbemServices **a_Service ,
        IWbemCallResult **a_CallResult
	) ;
    
    HRESULT STDMETHODCALLTYPE CancelAsyncCall ( 

        IWbemObjectSink *a_Sink
	) ;
    
    HRESULT STDMETHODCALLTYPE QueryObjectSink ( 

        long a_Flags ,
        IWbemObjectSink **a_Sink
	) ;
    
    HRESULT STDMETHODCALLTYPE GetObject ( 

		const BSTR a_ObjectPath ,
        long a_Flags ,
        IWbemContext *a_Context ,
        IWbemClassObject **ppObject ,
        IWbemCallResult **a_CallResult
	) ;
    
    HRESULT STDMETHODCALLTYPE GetObjectAsync (
        
		const BSTR a_ObjectPath ,
        long a_Flags ,
        IWbemContext *a_Context ,
        IWbemObjectSink *a_Sink
	) ;

    HRESULT STDMETHODCALLTYPE PutClass ( 

        IWbemClassObject *a_Object ,
        long a_Flags ,
        IWbemContext *a_Context ,
        IWbemCallResult **a_CallResult
	) ;
    
    HRESULT STDMETHODCALLTYPE PutClassAsync ( 

        IWbemClassObject *a_Object ,
        long a_Flags ,
        IWbemContext *a_Context ,
        IWbemObjectSink *a_Sink
	) ;
    
    HRESULT STDMETHODCALLTYPE DeleteClass ( 

        const BSTR a_Class ,
        long a_Flags ,
        IWbemContext *a_Context ,
        IWbemCallResult **a_CallResult
	) ;
    
    HRESULT STDMETHODCALLTYPE DeleteClassAsync ( 

        const BSTR a_Class ,
        long a_Flags ,
        IWbemContext *a_Context ,
        IWbemObjectSink *a_Sink
	) ;
    
    HRESULT STDMETHODCALLTYPE CreateClassEnum ( 

        const BSTR a_Superclass ,
        long a_Flags ,
        IWbemContext *a_Context ,
        IEnumWbemClassObject **a_Enum
	) ;
    
    HRESULT STDMETHODCALLTYPE CreateClassEnumAsync ( 

		const BSTR a_Superclass ,
		long a_Flags ,
		IWbemContext *a_Context ,
		IWbemObjectSink *a_Sink
	) ;
    
    HRESULT STDMETHODCALLTYPE PutInstance (

		IWbemClassObject *a_Instance ,
		long a_Flags , 
		IWbemContext *a_Context ,
		IWbemCallResult **a_CallResult
	) ;
    
    HRESULT STDMETHODCALLTYPE PutInstanceAsync (

		IWbemClassObject *a_Instance ,
		long a_Flags ,
		IWbemContext *a_Context ,
		IWbemObjectSink *a_Sink 
	) ;
    
    HRESULT STDMETHODCALLTYPE DeleteInstance ( 

		const BSTR a_ObjectPath ,
		long a_Flags ,
		IWbemContext *a_Context ,
		IWbemCallResult **a_CallResult
	) ;
    
    HRESULT STDMETHODCALLTYPE DeleteInstanceAsync ( 

		const BSTR a_ObjectPath,
		long a_Flags,
		IWbemContext *a_Context ,
		IWbemObjectSink *a_Sink
	) ;
    
    HRESULT STDMETHODCALLTYPE CreateInstanceEnum (

		const BSTR a_Class ,
		long a_Flags ,
		IWbemContext *a_Context ,
		IEnumWbemClassObject **a_Enum
	) ;
    
    HRESULT STDMETHODCALLTYPE CreateInstanceEnumAsync (

		const BSTR a_Class ,
		long a_Flags ,
		IWbemContext *a_Context ,
		IWbemObjectSink *a_Sink
	) ;
    
    HRESULT STDMETHODCALLTYPE ExecQuery ( 

		const BSTR a_QueryLanguage,
		const BSTR a_Query,
		long a_Flags ,
		IWbemContext *a_Context ,
		IEnumWbemClassObject **a_Enum
	) ;
    
    HRESULT STDMETHODCALLTYPE ExecQueryAsync (

		const BSTR a_QueryLanguage ,
		const BSTR a_Query ,
		long a_Flags ,
		IWbemContext *a_Context ,
		IWbemObjectSink *a_Sink
	) ;
    
    HRESULT STDMETHODCALLTYPE ExecNotificationQuery (

		const BSTR a_QueryLanguage ,
		const BSTR a_Query ,
		long a_Flags ,
		IWbemContext *a_Context ,
		IEnumWbemClassObject **a_Enum
	) ;
    
    HRESULT STDMETHODCALLTYPE ExecNotificationQueryAsync ( 

        const BSTR a_QueryLanguage ,
        const BSTR a_Query ,
        long a_Flags ,
        IWbemContext *a_Context ,
        IWbemObjectSink *a_Sink
	) ;
    
    HRESULT STDMETHODCALLTYPE ExecMethod (

        const BSTR a_ObjectPath ,
        const BSTR a_MethodName ,
        long a_Flags ,
        IWbemContext *a_Context ,
        IWbemClassObject *a_InParams ,
        IWbemClassObject **a_OutParams ,
        IWbemCallResult **a_CallResult
	) ;
    
    HRESULT STDMETHODCALLTYPE ExecMethodAsync ( 

		const BSTR a_ObjectPath ,
		const BSTR a_MethodName ,
		long a_Flags ,
		IWbemContext *a_Context ,
		IWbemClassObject *a_InParams ,
		IWbemObjectSink *a_Sink
	) ;

	/* IWbemProviderInit methods */

	HRESULT STDMETHODCALLTYPE Initialize (

		LPWSTR a_User ,
		LONG a_Flags ,
		LPWSTR a_Namespace ,
		LPWSTR a_Locale ,
		IWbemServices *a_Core ,
		IWbemContext *a_Context ,
		IWbemProviderInitSink *a_Sink
	) ;

	// IWmi_UnInitialize members

	HRESULT STDMETHODCALLTYPE Shutdown (

		LONG a_Flags ,
		ULONG a_MaxMilliSeconds ,
		IWbemContext *a_Context
	) ; 
} ;


#endif // _Task_IWbemServices_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\provsubsys\rpcexample\globals.cpp ===
/*++

Copyright (C) 1996-2001 Microsoft Corporation

Module Name:

	Globals.cpp

Abstract:


History:

--*/

#include "PreComp.h"

#include <initguid.h>
#ifndef INITGUID
#define INITGUID
#endif

#include <wbemint.h>

#include <Exception.h>
#include <Thread.h>

#include <Allocator.cpp>
#include <HelperFuncs.cpp>

#include "Globals.h"


extern "C" void * __RPC_API MIDL_user_allocate ( size_t a_Size )
{
    return malloc ( a_Size ) ;
}

extern "C" void __RPC_API MIDL_user_free( void *a_Void )
{
    free ( a_Void ) ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\provsubsys\rpcexample\cthread.cpp ===
/*++

Copyright (C) 1996-2001 Microsoft Corporation

Module Name:

	ProvFact.cpp

Abstract:


History:

--*/

#include "PreComp.h"
#include <wbemint.h>

#include "Globals.h"
#include "CThread.h"
#include "Interface.h"

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

WmiStatusCode ClientThread :: Initialize_Callback ()
{
	return e_StatusCode_Success ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

WmiStatusCode ClientThread :: UnInitialize_Callback () 
{
	return e_StatusCode_Success ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

ClientThread :: ClientThread (

	WmiAllocator &a_Allocator	

) : WmiThread < ULONG > ( a_Allocator ) ,
	m_Allocator ( a_Allocator )
{
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

ClientThread::~ClientThread ()
{
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

ClientTask_Execute :: ClientTask_Execute (

	WmiAllocator &a_Allocator

) : WmiTask < ULONG > ( a_Allocator ) ,
	m_Allocator ( a_Allocator )
{
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

ClientTask_Execute :: ~ClientTask_Execute ()
{
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

WmiStatusCode ClientTask_Execute :: Process ( WmiThread <ULONG > &a_Thread )
{
    WCHAR *t_Uuid = NULL;
    WCHAR *t_ProtocolSequence = L"ncacn_np";
    WCHAR *t_NetworkAddress = NULL;
    WCHAR *t_Endpoint = L"\\pipe\\hello";
    WCHAR *t_Options = NULL;
    WCHAR *t_StringBinding = NULL;
 
    RPC_STATUS t_RpcStatus = RpcStringBindingCompose (

		t_Uuid,
        t_ProtocolSequence,
        t_NetworkAddress,
        t_Endpoint,
        t_Options,
        & t_StringBinding
	) ;

	if ( t_RpcStatus == RPC_S_OK )
	{
		t_RpcStatus = RpcBindingFromStringBinding (

			t_StringBinding,
			& Example_InterfaceHandle
		);
 
		if ( t_RpcStatus == RPC_S_OK )
		{ 
			t_RpcStatus = RpcMgmtIsServerListening ( Example_InterfaceHandle ) ;

			RpcTryExcept  
			{
				Function ();
			}
			RpcExcept ( 1 ) 
			{
				DWORD t_ExceptionCode = RpcExceptionCode () ;
			}
			RpcEndExcept

			t_RpcStatus = RpcBindingFree ( & Example_InterfaceHandle ) ;  
 		}

		t_RpcStatus = RpcStringFree ( &t_StringBinding ) ;  
	}

	Complete () ;

	return e_StatusCode_Success ;

}

/******************************************************************************
 *
 *	Name:
 *
 *	`
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT Process_Client ()
{
	HRESULT t_Result = S_OK ;

	WmiAllocator t_Allocator ;
	WmiStatusCode t_StatusCode = t_Allocator.Initialize () ;
	if ( t_StatusCode == e_StatusCode_Success )
	{
		WmiStatusCode t_StatusCode = WmiThread <ULONG> :: Static_Initialize ( t_Allocator ) ;

		WmiThread < ULONG > *t_Thread1 = new ClientThread ( t_Allocator ) ;
		if ( t_Thread1 )
		{
			t_Thread1->AddRef () ;

			t_StatusCode = t_Thread1->Initialize () ;

			ClientTask_Execute *t_Task1 = new ClientTask_Execute ( t_Allocator ) ;
			if ( t_Task1 )
			{
				t_Task1->AddRef () ;

				t_Task1->Initialize () ;
				t_Thread1->EnQueue ( 0 , *t_Task1 ) ;

				t_Task1->WaitInterruptable () ;
				t_Task1->Release () ;
			}

			HANDLE t_Thread1Handle = NULL ;

			BOOL t_Status = DuplicateHandle ( 

				GetCurrentProcess () ,
				t_Thread1->GetHandle () ,
				GetCurrentProcess () ,
				& t_Thread1Handle, 
				0 , 
				FALSE , 
				DUPLICATE_SAME_ACCESS
			) ;

			t_Thread1->Release () ;

			WaitForSingleObject ( t_Thread1Handle , INFINITE ) ;

			CloseHandle ( t_Thread1Handle ) ;
		}

		t_StatusCode = WmiThread <ULONG> :: Static_UnInitialize ( t_Allocator ) ;
	}	
	else
	{
		t_Result = WBEM_E_OUT_OF_MEMORY ;
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

EXTERN_C int __cdecl wmain (

	int argc ,
	char **argv 
)
{
	Process_Client () ;

	return 0 ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\provsubsys\provider\include\guids.h ===
/*++

Copyright (C) 1996-2001 Microsoft Corporation

Module Name:

	Guids.h

Abstract:


History:

--*/

// {FE186DC7-0FE8-4b59-81CA-8D45E50D394C}
DEFINE_GUID(CLSID_WmiProvider, 
0xfe186dc7, 0xfe8, 0x4b59, 0x81, 0xca, 0x8d, 0x45, 0xe5, 0xd, 0x39, 0x4c);

// {8B86A619-76AA-4835-AED7-BB42ED4964E7}
DEFINE_GUID(CLSID_WmiClassProvider, 
0x8b86a619, 0x76aa, 0x4835, 0xae, 0xd7, 0xbb, 0x42, 0xed, 0x49, 0x64, 0xe7);

// {06A565F1-64A5-4ff7-BC5A-EBCFCB5DAB64}
DEFINE_GUID(CLSID_WmiTaskProvider, 
0x6a565f1, 0x64a5, 0x4ff7, 0xbc, 0x5a, 0xeb, 0xcf, 0xcb, 0x5d, 0xab, 0x64);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\provsubsys\rpcexample\include\globals.h ===
/*++

Copyright (C) 1996-2001 Microsoft Corporation

Module Name:

	Globals.h

Abstract:


History:

--*/

#ifndef _Globals_H
#define _Globals_H

#include <Allocator.h>

#endif // _Globals_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\provsubsys\rpcexample\sources.inc ===
############################################################################
#
#   Copyright (C) 1999, Microsoft Corporation.
#
#   All rights reserved.
#
############################################################################

WMIPLATFORM=WINNT
WMIUNICODE=1
WMIPRECOMPSHARED=1

!include $(PROJECT_ROOT)\wmi\wbem\common\makefile.cmn
SOURCES_USED=$(PROJECT_ROOT)\wmi\wbem\common\makefile.cmn

TARGETNAME=Main
TARGETPATH=obj
TARGETTYPE=PROGRAM

# The TARGETLIBS macro specifies additional libraries to link against your target
# image. Each library path specification should contain an asterisk (*)
# where the machine-specific subdirectory name should go.
LINKLIBS= \
	$(WBEMPRV_COMN_LIB)

TARGETLIBS= \
	$(WMIIDL_LIB)\
	$(WBEMINT_LIB) \
	$(WBEMCOMN_LIB) \
	$(SDK_LIB_PATH)\ntdll.lib \
	$(SDK_LIB_PATH)\kernel32.lib \
	$(SDK_LIB_PATH)\advapi32.lib \
	$(SDK_LIB_PATH)\user32.lib \
	$(SDK_LIB_PATH)\version.lib \
	$(SDK_LIB_PATH)\oleaut32.lib \
	$(SDK_LIB_PATH)\rpcrt4.lib \
	$(SDK_LIB_PATH)\msvcirt.lib \
	$(SDK_LIB_PATH)\msvcrt.lib \
	$(SDK_LIB_PATH)\wsock32.lib

INCLUDES=$(INCLUDES); \
	$(WBEMINT_INC);\
	$(WBEMCOMN_INC); \
	$(CONTAINER_INC); \
	$(CONTAINER_SRC); \
	$(WBEMPRV_COMN_INC); \
	$(O);\
	..\Include;\

SOURCES=\
	Interface.Idl \
	Globals.cpp \

USE_MSVCRT=1
UMENTRY=wmain
UMTYPE=console

DLLDEF=$(O)\Main.def
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\provsubsys\rpcexample\sthread.cpp ===
/*++

Copyright (C) 1996-2001 Microsoft Corporation

Module Name:

	ProvFact.cpp

Abstract:


History:

--*/

#include "PreComp.h"
#include <wbemint.h>

#include "Globals.h"
#include "SThread.h"
#include "Interface.h"

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

WmiStatusCode ServerThread :: Initialize_Callback ()
{
	return e_StatusCode_Success ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

WmiStatusCode ServerThread :: UnInitialize_Callback () 
{
	return e_StatusCode_Success ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

ServerThread :: ServerThread (

	WmiAllocator &a_Allocator	

) : WmiThread < ULONG > ( a_Allocator ) ,
	m_Allocator ( a_Allocator )
{
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

ServerThread::~ServerThread ()
{
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

ServerTask_Execute :: ServerTask_Execute (

	WmiAllocator &a_Allocator

) : WmiTask < ULONG > ( a_Allocator ) ,
	m_Allocator ( a_Allocator )
{
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

ServerTask_Execute :: ~ServerTask_Execute ()
{
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

WmiStatusCode ServerTask_Execute :: Process ( WmiThread <ULONG > &a_Thread )
{
    WCHAR *t_ProtocolSequence = L"ncacn_np";
    WCHAR *t_Endpoint = L"\\pipe\\hello";
 
	RPC_STATUS t_RpcStatus = RpcServerUseProtseqEp (

		t_ProtocolSequence,
		5 ,
		t_Endpoint,
		NULL
	); 

	if ( t_RpcStatus == RPC_S_OK )
	{
		t_RpcStatus = RpcServerRegisterIf (

			Example_v1_0_s_ifspec ,  
			NULL,   
			NULL
		) ;

		if ( t_RpcStatus == RPC_S_OK )
		{
			t_RpcStatus = RpcServerListen (

				1 ,
				20 ,
				FALSE
			) ;
		}
	}

	Complete () ;

	return e_StatusCode_Success ;
}

void Function (void)
{
	printf ( "Steve" ) ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	`
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT Process_Server ()
{
	HRESULT t_Result = S_OK ;

	WmiAllocator t_Allocator ;
	WmiStatusCode t_StatusCode = t_Allocator.Initialize () ;
	if ( t_StatusCode == e_StatusCode_Success )
	{
		WmiStatusCode t_StatusCode = WmiThread <ULONG> :: Static_Initialize ( t_Allocator ) ;

		WmiThread < ULONG > *t_Thread1 = new ServerThread ( t_Allocator ) ;
		if ( t_Thread1 )
		{
			t_Thread1->AddRef () ;

			t_StatusCode = t_Thread1->Initialize () ;

			ServerTask_Execute *t_Task1 = new ServerTask_Execute ( t_Allocator ) ;
			if ( t_Task1 )
			{
				t_Task1->AddRef () ;

				t_Task1->Initialize () ;
				t_Thread1->EnQueue ( 0 , *t_Task1 ) ;

				t_Task1->WaitInterruptable () ;

				t_Task1->Release () ;
			}

			HANDLE t_Thread1Handle = NULL ;

			BOOL t_Status = DuplicateHandle ( 

				GetCurrentProcess () ,
				t_Thread1->GetHandle () ,
				GetCurrentProcess () ,
				& t_Thread1Handle, 
				0 , 
				FALSE , 
				DUPLICATE_SAME_ACCESS
			) ;

			t_Thread1->Release () ;

			WaitForSingleObject ( t_Thread1Handle , INFINITE ) ;

			CloseHandle ( t_Thread1Handle ) ;
		}

		t_StatusCode = WmiThread <ULONG> :: Static_UnInitialize ( t_Allocator ) ;
	}	
	else
	{
		t_Result = WBEM_E_OUT_OF_MEMORY ;
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

EXTERN_C int __cdecl wmain (

	int argc ,
	char **argv 
)
{
	Process_Server () ;

	return 0 ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\provsubsys\provider\include\service.h ===
/*++

Copyright (C) 1996-2001 Microsoft Corporation

Module Name:

	ProvResv.H

Abstract:


History:

--*/

#ifndef _Provider_IWbemServices_H
#define _Provider_IWbemServices_H

class CProvider_IWbemServices : public IWbemServices , public IWbemPropertyProvider , public IWbemProviderInit , public IWbemShutdown
{
private:

	LONG m_ReferenceCount ;         //Object reference count

	WmiAllocator &m_Allocator ;

	CRITICAL_SECTION m_CriticalSection ;

	IWbemServices *m_CoreService ;

	BSTR m_Namespace ;
	BSTR m_Locale ;
	BSTR m_User ;

	BSTR m_ComputerName ;
	BSTR m_OperatingSystemVersion ;
	BSTR m_OperatingSystemRunning ;
	BSTR m_ProductName ;

	IWbemClassObject *m_Win32_ProcessEx_Object ;

private:

	HRESULT GetProductInformation () ;

	HRESULT GetProcessExecutable (

		HANDLE a_Process , 
		wchar_t *&a_ExecutableName
	) ;

	HRESULT CProvider_IWbemServices :: NextProcessBlock (

		SYSTEM_PROCESS_INFORMATION *a_ProcessBlock , 
		SYSTEM_PROCESS_INFORMATION *&a_NextProcessBlock
	) ;

	HRESULT GetProcessBlocks ( SYSTEM_PROCESS_INFORMATION *&a_ProcessInformation ) ;

	HRESULT GetProcessInformation (	SYSTEM_PROCESS_INFORMATION *&a_ProcessInformation ) ;

	HRESULT GetProcessParameters (

		HANDLE a_Process ,
		wchar_t *&a_ProcessCommandLine
	) ;

	HRESULT CreateInstanceEnumAsync_Process_Load (

		SYSTEM_PROCESS_INFORMATION *a_ProcessInformation ,
		IWbemClassObject *a_Instance 
	) ;

	HRESULT CreateInstanceEnumAsync_Process_Single (

		IWbemClassObject *a_ClassObject ,
 		long a_Flags , 
		IWbemContext __RPC_FAR *a_Context,
		IWbemObjectSink FAR *a_Sink
	) ;

	HRESULT CreateInstanceEnumAsync_Process_Batched (

		IWbemClassObject *a_ClassObject ,
 		long a_Flags , 
		IWbemContext __RPC_FAR *a_Context,
		IWbemObjectSink FAR *a_Sink
	) ;

public:

	CProvider_IWbemServices ( WmiAllocator &a_Allocator  ) ;
    ~CProvider_IWbemServices () ;

public:

	//Non-delegating object IUnknown

    STDMETHODIMP QueryInterface ( REFIID , LPVOID FAR * ) ;
    STDMETHODIMP_( ULONG ) AddRef () ;
    STDMETHODIMP_( ULONG ) Release () ;

    /* IWbemServices methods */

    HRESULT STDMETHODCALLTYPE OpenNamespace ( 

        const BSTR a_Namespace ,
        long a_Flags ,
        IWbemContext *a_Context ,
        IWbemServices **a_Service ,
        IWbemCallResult **a_CallResult
	) ;
    
    HRESULT STDMETHODCALLTYPE CancelAsyncCall ( 

        IWbemObjectSink *a_Sink
	) ;
    
    HRESULT STDMETHODCALLTYPE QueryObjectSink ( 

        long a_Flags ,
        IWbemObjectSink **a_Sink
	) ;
    
    HRESULT STDMETHODCALLTYPE GetObject ( 

		const BSTR a_ObjectPath ,
        long a_Flags ,
        IWbemContext *a_Context ,
        IWbemClassObject **ppObject ,
        IWbemCallResult **a_CallResult
	) ;
    
    HRESULT STDMETHODCALLTYPE GetObjectAsync (
        
		const BSTR a_ObjectPath ,
        long a_Flags ,
        IWbemContext *a_Context ,
        IWbemObjectSink *a_Sink
	) ;

    HRESULT STDMETHODCALLTYPE PutClass ( 

        IWbemClassObject *a_Object ,
        long a_Flags ,
        IWbemContext *a_Context ,
        IWbemCallResult **a_CallResult
	) ;
    
    HRESULT STDMETHODCALLTYPE PutClassAsync ( 

        IWbemClassObject *a_Object ,
        long a_Flags ,
        IWbemContext *a_Context ,
        IWbemObjectSink *a_Sink
	) ;
    
    HRESULT STDMETHODCALLTYPE DeleteClass ( 

        const BSTR a_Class ,
        long a_Flags ,
        IWbemContext *a_Context ,
        IWbemCallResult **a_CallResult
	) ;
    
    HRESULT STDMETHODCALLTYPE DeleteClassAsync ( 

        const BSTR a_Class ,
        long a_Flags ,
        IWbemContext *a_Context ,
        IWbemObjectSink *a_Sink
	) ;
    
    HRESULT STDMETHODCALLTYPE CreateClassEnum ( 

        const BSTR a_Superclass ,
        long a_Flags ,
        IWbemContext *a_Context ,
        IEnumWbemClassObject **a_Enum
	) ;
    
    HRESULT STDMETHODCALLTYPE CreateClassEnumAsync ( 

		const BSTR a_Superclass ,
		long a_Flags ,
		IWbemContext *a_Context ,
		IWbemObjectSink *a_Sink
	) ;
    
    HRESULT STDMETHODCALLTYPE PutInstance (

		IWbemClassObject *a_Instance ,
		long a_Flags , 
		IWbemContext *a_Context ,
		IWbemCallResult **a_CallResult
	) ;
    
    HRESULT STDMETHODCALLTYPE PutInstanceAsync (

		IWbemClassObject *a_Instance ,
		long a_Flags ,
		IWbemContext *a_Context ,
		IWbemObjectSink *a_Sink 
	) ;
    
    HRESULT STDMETHODCALLTYPE DeleteInstance ( 

		const BSTR a_ObjectPath ,
		long a_Flags ,
		IWbemContext *a_Context ,
		IWbemCallResult **a_CallResult
	) ;
    
    HRESULT STDMETHODCALLTYPE DeleteInstanceAsync ( 

		const BSTR a_ObjectPath,
		long a_Flags,
		IWbemContext *a_Context ,
		IWbemObjectSink *a_Sink
	) ;
    
    HRESULT STDMETHODCALLTYPE CreateInstanceEnum (

		const BSTR a_Class ,
		long a_Flags ,
		IWbemContext *a_Context ,
		IEnumWbemClassObject **a_Enum
	) ;
    
    HRESULT STDMETHODCALLTYPE CreateInstanceEnumAsync (

		const BSTR a_Class ,
		long a_Flags ,
		IWbemContext *a_Context ,
		IWbemObjectSink *a_Sink
	) ;
    
    HRESULT STDMETHODCALLTYPE ExecQuery ( 

		const BSTR a_QueryLanguage,
		const BSTR a_Query,
		long a_Flags ,
		IWbemContext *a_Context ,
		IEnumWbemClassObject **a_Enum
	) ;
    
    HRESULT STDMETHODCALLTYPE ExecQueryAsync (

		const BSTR a_QueryLanguage ,
		const BSTR a_Query ,
		long a_Flags ,
		IWbemContext *a_Context ,
		IWbemObjectSink *a_Sink
	) ;
    
    HRESULT STDMETHODCALLTYPE ExecNotificationQuery (

		const BSTR a_QueryLanguage ,
		const BSTR a_Query ,
		long a_Flags ,
		IWbemContext *a_Context ,
		IEnumWbemClassObject **a_Enum
	) ;
    
    HRESULT STDMETHODCALLTYPE ExecNotificationQueryAsync ( 

        const BSTR a_QueryLanguage ,
        const BSTR a_Query ,
        long a_Flags ,
        IWbemContext *a_Context ,
        IWbemObjectSink *a_Sink
	) ;
    
    HRESULT STDMETHODCALLTYPE ExecMethod (

        const BSTR a_ObjectPath ,
        const BSTR a_MethodName ,
        long a_Flags ,
        IWbemContext *a_Context ,
        IWbemClassObject *a_InParams ,
        IWbemClassObject **a_OutParams ,
        IWbemCallResult **a_CallResult
	) ;
    
    HRESULT STDMETHODCALLTYPE ExecMethodAsync ( 

		const BSTR a_ObjectPath ,
		const BSTR a_MethodName ,
		long a_Flags ,
		IWbemContext *a_Context ,
		IWbemClassObject *a_InParams ,
		IWbemObjectSink *a_Sink
	) ;

    HRESULT STDMETHODCALLTYPE GetProperty (

        long a_Flags ,
        const BSTR a_Locale ,
        const BSTR a_ClassMapping ,
        const BSTR a_InstanceMapping ,
        const BSTR a_PropertyMapping ,
        VARIANT *a_Value
	) ;
        
    HRESULT STDMETHODCALLTYPE PutProperty (

        long a_Flags ,
        const BSTR a_Locale ,
        const BSTR a_ClassMapping ,
        const BSTR a_InstanceMapping ,
        const BSTR a_PropertyMapping ,
        const VARIANT *a_Value
	) ;

	/* IWbemProviderInit methods */

	HRESULT STDMETHODCALLTYPE Initialize (

		LPWSTR a_User ,
		LONG a_Flags ,
		LPWSTR a_Namespace ,
		LPWSTR a_Locale ,
		IWbemServices *a_Core ,
		IWbemContext *a_Context ,
		IWbemProviderInitSink *a_Sink
	) ;

	// IWmi_UnInitialize members

	HRESULT STDMETHODCALLTYPE Shutdown (

		LONG a_Flags ,
		ULONG a_MaxMilliSeconds ,
		IWbemContext *a_Context
	) ; 
} ;


#endif // _Provider_IWbemServices_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\provsubsys\server\precomp.h ===
/*++

Copyright (C) 1996-2001 Microsoft Corporation

Module Name:

	Precomp.h

Abstract:


History:

--*/

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <ntobapi.h>
#include <ntpsapi.h>
#include <ntexapi.h>

#define _WINNT_	// have what is needed from above

#include <ole2.h>
#include <windows.h>
#define COREPOL_HEADERFILE_IS_INCLUDED
#ifndef POLARITY
#if 1
#define POLARITY __declspec( dllimport )
#else
#define POLARITY 
#endif
#endif

#define COREPROX_POLARITY __declspec( dllimport )
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\provsubsys\rpcexample\include\cthread.h ===
/*++

Copyright (C) 1996-2001 Microsoft Corporation

Module Name:

	ProvFact.h

Abstract:


History:

--*/

#ifndef _CThread_H
#define _CThread_H

#include <Thread.h>

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

class ClientThread : public WmiThread < ULONG > 
{
private:

	WmiAllocator &m_Allocator ;

protected:

public:	/* Internal */

    ClientThread ( 

		WmiAllocator & a_Allocator
	) ;

    ~ClientThread () ;

	WmiStatusCode Initialize_Callback () ;

	WmiStatusCode UnInitialize_Callback () ;
};

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

class ClientTask_Execute : public WmiTask < ULONG > 
{
private:

	WmiAllocator &m_Allocator ;

protected:

public:	/* Internal */

    ClientTask_Execute ( WmiAllocator & a_Allocator ) ;
    ~ClientTask_Execute () ;

	WmiStatusCode Process ( WmiThread <ULONG> &a_Thread ) ;
};

#endif // _CThread_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\provsubsys\server\classfac.cpp ===
#ifndef __CLASSFACTORY_CPP
#define __CLASSFACTORY_CPP

/*++

Copyright (C) 1996-2001 Microsoft Corporation

Module Name:

	ClassFac.cpp

Abstract:


History:

--*/

#include "PreComp.h"
#include <wbemint.h>

#include "Globals.h"
#include "CGlobals.h"
#include "ProvResv.h"
#include "ProvFact.h"
#include "ProvSubS.h"
#include "classfac.h"

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

template <class Object,class ObjectInterface>
CServerClassFactory <Object,ObjectInterface> :: CServerClassFactory <Object,ObjectInterface> () : m_ReferenceCount ( 0 )
{
	InterlockedIncrement ( & ProviderSubSystem_Globals :: s_CServerClassFactory_ObjectsInProgress ) ;

	ProviderSubSystem_Globals :: Increment_Global_Object_Count () ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

template <class Object,class ObjectInterface>
CServerClassFactory <Object,ObjectInterface> :: ~CServerClassFactory <Object,ObjectInterface> ()
{
	InterlockedDecrement ( & ProviderSubSystem_Globals :: s_CServerClassFactory_ObjectsInProgress ) ;
	ProviderSubSystem_Globals :: Decrement_Global_Object_Count () ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

template <class Object,class ObjectInterface>
STDMETHODIMP CServerClassFactory <Object,ObjectInterface> :: QueryInterface (

	REFIID iid , 
	LPVOID FAR *iplpv 
) 
{
	*iplpv = NULL ;

	if ( iid == IID_IUnknown )
	{
		*iplpv = ( LPVOID ) this ;
	}
	else if ( iid == IID_IClassFactory )
	{
		*iplpv = ( LPVOID ) ( IClassFactory * ) this ;		
	}	

	if ( *iplpv )
	{
		( ( LPUNKNOWN ) *iplpv )->AddRef () ;

		return ResultFromScode ( S_OK ) ;
	}
	else
	{
		return ResultFromScode ( E_NOINTERFACE ) ;
	}
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

template <class Object,class ObjectInterface>
STDMETHODIMP_( ULONG ) CServerClassFactory <Object,ObjectInterface> :: AddRef ()
{
	ULONG t_ReferenceCount = InterlockedIncrement ( & m_ReferenceCount ) ;
	return t_ReferenceCount ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

template <class Object,class ObjectInterface>
STDMETHODIMP_(ULONG) CServerClassFactory <Object,ObjectInterface> :: Release ()
{
	ULONG t_ReferenceCount = InterlockedDecrement ( & m_ReferenceCount ) ;
	if ( t_ReferenceCount == 0 )
	{
		delete this ;
		return 0 ;
	}
	else
	{
		return t_ReferenceCount ;
	}
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

template <class Object,class ObjectInterface>
STDMETHODIMP CServerClassFactory <Object,ObjectInterface> :: CreateInstance (

	LPUNKNOWN pUnkOuter ,
	REFIID riid ,
	LPVOID FAR * ppvObject
)
{
	HRESULT status = S_OK ;

	if ( pUnkOuter )
	{
		status = CLASS_E_NOAGGREGATION ;
	}
	else
	{
		IUnknown *lpunk = ( ObjectInterface * ) new Object ( *ProviderSubSystem_Globals :: s_Allocator );
		if ( lpunk == NULL )
		{
			status = E_OUTOFMEMORY ;
		}
		else
		{
			status = lpunk->QueryInterface ( riid , ppvObject ) ;
			if ( FAILED ( status ) )
			{
				delete lpunk ;
			}
			else
			{
			}
		}			
	}

	return status ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

template <class Object,class ObjectInterface>
STDMETHODIMP CServerClassFactory <Object,ObjectInterface> :: LockServer ( BOOL fLock )
{
/* 
 * Place code in critical section
 */

	if ( fLock )
	{
		InterlockedIncrement ( & ProviderSubSystem_Globals :: s_LocksInProgress ) ;
	}
	else
	{
		InterlockedDecrement ( & ProviderSubSystem_Globals :: s_LocksInProgress ) ;
	}

	return S_OK	;
}

#endif __CLASSFACTORY_CPP
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\provsubsys\server\globals.cpp ===
/*++

Copyright (C) 1996-2001 Microsoft Corporation

Module Name:

	Globals.cpp

Abstract:


History:

--*/

#include <precomp.h>
#include <windows.h>
#include <objbase.h>

#include <initguid.h>
#ifndef INITGUID
#define INITGUID
#endif

#include <wbemcli.h>
#include <wbemint.h>
#include <winntsec.h>
#include <callsec.h>
#include <cominit.h>

#include <NCObjApi.h>
#include "winmgmtr.h"

#include <Guids.h>

#include <BasicTree.h>
#include <Thread.h>
#include <Logging.h>

#include "Globals.h"
#include "CGlobals.h"
#include "ProvSubS.h"

#ifdef WMIASLOCAL
#include "Main.h"
#endif

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

LONG ProviderSubSystem_Globals :: s_Initialized = 0 ;

WmiAllocator *ProviderSubSystem_Globals :: s_Allocator = NULL ;

CriticalSection ProviderSubSystem_Globals :: s_DecoupledRegistrySection(NOTHROW_LOCK) ;

HANDLE ProviderSubSystem_Globals :: s_FileMapping = NULL ;
CServerObject_ProviderSubsystem_Counters *ProviderSubSystem_Globals :: s_SharedCounters = NULL ;

StrobeThread *ProviderSubSystem_Globals :: s_StrobeThread = NULL ;

HANDLE ProviderSubSystem_Globals :: s_CoFreeUnusedLibrariesEvent = NULL ;

HANDLE ProviderSubSystem_Globals :: s_HostJobObject = NULL ;
LPCWSTR ProviderSubSystem_Globals :: s_HostJobObjectName = L"Global\\WmiProviderSubSystemHostJob" ;

LPCWSTR ProviderSubSystem_Globals :: s_ProviderSubsystemEventSourceName = L"WinMgmt" ;
HANDLE ProviderSubSystem_Globals :: s_NtEventLogSource = NULL ;

HostController *ProviderSubSystem_Globals :: s_HostController = NULL ;
RefresherManagerController *ProviderSubSystem_Globals :: s_RefresherManagerController = NULL ;
CWbemGlobal_HostedProviderController *ProviderSubSystem_Globals :: s_HostedProviderController = NULL ;
CWbemGlobal_IWmiProvSubSysController *ProviderSubSystem_Globals :: s_ProvSubSysController = NULL ;
CWbemGlobal_IWbemSyncProviderController *ProviderSubSystem_Globals :: s_SyncProviderController = NULL ;
CDecoupled_ProviderSubsystemRegistrar *ProviderSubSystem_Globals :: s_DecoupledRegistrar = NULL ;

CriticalSection ProviderSubSystem_Globals :: s_GuidTagSection(NOTHROW_LOCK) ;
CWbemGlobal_ComServerTagContainer *ProviderSubSystem_Globals ::  s_GuidTag = NULL ;

LONG ProviderSubSystem_Globals :: s_LocksInProgress = 0 ;
LONG ProviderSubSystem_Globals :: s_ObjectsInProgress = 0 ;

ULONG ProviderSubSystem_Globals :: s_InternalCacheTimeout = DEFAULT_PROVIDER_TIMEOUT ;
ULONG ProviderSubSystem_Globals :: s_ObjectCacheTimeout = DEFAULT_PROVIDER_TIMEOUT ;
ULONG ProviderSubSystem_Globals :: s_EventCacheTimeout = DEFAULT_PROVIDER_TIMEOUT ;
ULONG ProviderSubSystem_Globals :: s_StrobeTimeout = DEFAULT_PROVIDER_TIMEOUT >> 1 ;

ULONG ProviderSubSystem_Globals :: s_Quota_ProcessLimitCount = 0x20 ;
SIZE_T ProviderSubSystem_Globals :: s_Quota_ProcessMemoryLimitCount = 0x10000000 ;
SIZE_T ProviderSubSystem_Globals :: s_Quota_JobMemoryLimitCount = 0x10000000 ;
SIZE_T ProviderSubSystem_Globals :: s_Quota_PrivatePageCount = 0x10000000 ;
ULONG ProviderSubSystem_Globals :: s_Quota_HandleCount = 0x1000 ;
ULONG ProviderSubSystem_Globals :: s_Quota_NumberOfThreads = 0x1000 ;


LONG ProviderSubSystem_Globals :: s_CAggregator_IWbemProvider_ObjectsInProgress = 0 ;
LONG ProviderSubSystem_Globals :: s_CInterceptor_IWbemProviderInitSink_ObjectsInProgress = 0 ;
LONG ProviderSubSystem_Globals :: s_CInterceptor_IWbemServices_Proxy_ObjectsInProgress = 0 ;
LONG ProviderSubSystem_Globals :: s_CInterceptor_IWbemServices_Stub_ObjectsInProgress = 0 ;
LONG ProviderSubSystem_Globals :: s_CInterceptor_IEnumWbemClassObject_Stub_ObjectsInProgress = 0 ;
LONG ProviderSubSystem_Globals :: s_CInterceptor_IEnumWbemClassObject_Proxy_ObjectsInProgress = 0 ;
LONG ProviderSubSystem_Globals :: s_CInterceptor_IWbemServices_Interceptor_ObjectsInProgress = 0 ;
LONG ProviderSubSystem_Globals :: s_CInterceptor_IWbemServices_RestrictingInterceptor_ObjectsInProgress = 0 ;
LONG ProviderSubSystem_Globals :: s_CInterceptor_IWbemObjectSink_ObjectsInProgress = 0 ;
LONG ProviderSubSystem_Globals :: s_CInterceptor_IWbemObjectSinkEx_ObjectsInProgress = 0 ;
LONG ProviderSubSystem_Globals :: s_CInterceptor_IWbemFilteringObjectSink_ObjectsInProgress = 0 ;
LONG ProviderSubSystem_Globals :: s_CInterceptor_IWbemProvider_ObjectsInProgress = 0 ;
LONG ProviderSubSystem_Globals :: s_CInterceptor_IWbemSyncProvider_ObjectsInProgress = 0 ;
LONG ProviderSubSystem_Globals :: s_CInterceptor_IWbemSyncObjectSink_ObjectsInProgress = 0 ;
LONG ProviderSubSystem_Globals :: s_CInterceptor_IWbemSyncObjectSinkEx_ObjectsInProgress = 0 ;
LONG ProviderSubSystem_Globals :: s_CInterceptor_IWbemSyncFilteringObjectSink_ObjectsInProgress = 0 ;
LONG ProviderSubSystem_Globals :: s_CInterceptor_IWbemCombiningObjectSink_ObjectsInProgress = 0 ;
LONG ProviderSubSystem_Globals :: s_CInterceptor_IWbemWaitingObjectSink_ObjectsInProgress = 0 ;
LONG ProviderSubSystem_Globals :: s_CInterceptor_IWbemUnboundObjectSink_ObjectsInProgress = 0 ;
LONG ProviderSubSystem_Globals :: s_CInterceptor_IWbemSyncUnboundObjectSink_ObjectsInProgress = 0 ;
LONG ProviderSubSystem_Globals :: s_CInterceptor_IWbemDecoupledProvider_ObjectsInProgress = 0 ;
LONG ProviderSubSystem_Globals :: s_CDecoupled_IWbemUnboundObjectSink_ObjectsInProgress = 0 ;

LONG ProviderSubSystem_Globals :: s_CServerObject_Host_ObjectsInProgress = 0 ;
LONG ProviderSubSystem_Globals :: s_CServerObject_HostInterceptor_ObjectsInProgress = 0 ;
LONG ProviderSubSystem_Globals :: s_CServerObject_BindingFactory_ObjectsInProgress = 0 ;
LONG ProviderSubSystem_Globals :: s_CServerObject_DynamicPropertyProviderResolver_ObjectsInProgress = 0 ;
LONG ProviderSubSystem_Globals :: s_CServerObject_IWbemServices_ObjectsInProgress = 0 ;
LONG ProviderSubSystem_Globals :: s_CServerObject_ProviderSubsystem_Counters_ObjectsInProgress = 0 ;
LONG ProviderSubSystem_Globals :: s_CServerObject_ProviderSubSystem_ObjectsInProgress = 0 ;
LONG ProviderSubSystem_Globals :: s_CServerObject_RawFactory_ObjectsInProgress = 0 ;
LONG ProviderSubSystem_Globals :: s_StaTask_Create_ObjectsInProgress = 0 ;
LONG ProviderSubSystem_Globals :: s_CServerObject_StaThread_ObjectsInProgress = 0 ;
LONG ProviderSubSystem_Globals :: s_StrobeThread_ObjectsInProgress = 0 ;
LONG ProviderSubSystem_Globals :: s_CServerClassFactory_ObjectsInProgress = 0 ;
LONG ProviderSubSystem_Globals :: s_CDecoupledAggregator_IWbemProvider_ObjectsInProgress = 0 ;
LONG ProviderSubSystem_Globals :: s_CDecoupled_ProviderSubsystemRegistrar_ObjectsInProgress = 0 ;

LONG ProviderSubSystem_Globals :: s_CServerObject_ProviderRefresherManager_ObjectsInProgress = 0 ;
LONG ProviderSubSystem_Globals :: s_CServerProvRefreshManagerClassFactory_ObjectsInProgress = 0 ;
LONG ProviderSubSystem_Globals :: s_CServerObject_InterceptorProviderRefresherManager_ObjectsInProgress = 0 ;

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

LPCWSTR ProviderSubSystem_Globals :: s_FileMappingName = L"Global\\Wmi Provider Sub System Counters" ;

LPCWSTR ProviderSubSystem_Globals :: s_QueryPrefix = L"Select * from __Win32Provider Where Name = \"" ;
ULONG ProviderSubSystem_Globals :: s_QueryPrefixLen = wcslen ( ProviderSubSystem_Globals :: s_QueryPrefix ) ;

LPCWSTR ProviderSubSystem_Globals :: s_QueryPostfix = L"\"" ;
ULONG ProviderSubSystem_Globals :: s_QueryPostfixLen = wcslen ( ProviderSubSystem_Globals :: s_QueryPostfix ) ;

ULONG ProviderSubSystem_Globals :: s_QueryConstantsLen = ProviderSubSystem_Globals :: s_QueryPrefixLen + ProviderSubSystem_Globals :: s_QueryPostfixLen  ;

LPCWSTR ProviderSubSystem_Globals :: s_Provider = L"Provider" ;
ULONG ProviderSubSystem_Globals :: s_ProviderLen = wcslen ( ProviderSubSystem_Globals :: s_Provider ) ;

LPCWSTR ProviderSubSystem_Globals :: s_Class = L"__Class" ;
ULONG ProviderSubSystem_Globals :: s_ClassLen = wcslen ( ProviderSubSystem_Globals :: s_Class ) ;

LPCWSTR ProviderSubSystem_Globals :: s_Wql = L"Wql" ;

LPCWSTR ProviderSubSystem_Globals :: s_DynProps = L"DynProps" ;
LPCWSTR ProviderSubSystem_Globals :: s_Dynamic = L"Dynamic" ;
LPCWSTR ProviderSubSystem_Globals :: s_ClassContext = L"ClassContext" ;
LPCWSTR ProviderSubSystem_Globals :: s_InstanceContext = L"InstanceContext" ;
LPCWSTR ProviderSubSystem_Globals :: s_PropertyContext = L"PropertyContext" ;

HANDLE ProviderSubSystem_Globals :: s_EventSource = NULL ;
LPWSTR ProviderSubSystem_Globals :: s_EventPropertySources [] = {

	L"Msft_WmiProvider_ComServerLoadOperationEvent" ,
    L"Namespace!s! Provider!s! User!s! Locale!s! TransactionIdentifier!s! Clsid!s! ServerName!s! InProcServer!b! LocalServer!b! InProcServerPath!s! LocalServerPath!s!" ,

	L"Msft_WmiProvider_ComServerOperationFailureEvent" ,
    L"Namespace!s! Provider!s! User!s! Locale!s! TransactionIdentifier!s! Clsid!s! ServerName!s! InProcServer!b! LocalServer!b! InProcServerPath!s! LocalServerPath!s! ResultCode!u!" ,

    L"Msft_WmiProvider_LoadOperationEvent",
    L"Namespace!s! Provider!s! User!s! Locale!s! TransactionIdentifier!s! Clsid!s! ServerName!s! InProcServer!b! LocalServer!b! InProcServerPath!s! LocalServerPath!s! ThreadingModel!u! Synchronisation!u!" ,

    L"Msft_WmiProvider_LoadOperationFailureEvent",
    L"Namespace!s! Provider!s! User!s! Locale!s! TransactionIdentifier!s! Clsid!s! ServerName!s! InProcServer!b! LocalServer!b! InProcServerPath!s! LocalServerPath!s! ThreadingModel!u! Synchronisation!u! ResultCode!u!" ,

    L"Msft_WmiProvider_InitializationOperationFailureEvent" ,
    L"Namespace!s! Provider!s! User!s! Locale!s! TransactionIdentifier!s! ResultCode!u!" ,

    L"Msft_WmiProvider_InitializationOperationEvent" ,
    L"Namespace!s! Provider!s! User!s! Locale!s! TransactionIdentifier!s!" ,

    L"Msft_WmiProvider_UnLoadOperationEvent" ,
    L"Namespace!s! Provider!s! User!s! Locale!s! TransactionIdentifier!s!" ,

	L"Msft_WmiProvider_GetObjectAsyncEvent_Pre" ,
    L"Namespace!s! Provider!s! User!s! Locale!s! TransactionIdentifier!s! Flags!u! ObjectPath!s!" ,

	L"Msft_WmiProvider_PutClassAsyncEvent_Pre" ,
    L"Namespace!s! Provider!s! User!s! Locale!s! TransactionIdentifier!s! Flags!u! ClassObject!O!" ,
 
	L"Msft_WmiProvider_DeleteClassAsyncEvent_Pre" ,
    L"Namespace!s! Provider!s! User!s! Locale!s! TransactionIdentifier!s! Flags!u! ClassName!s!" ,

	L"Msft_WmiProvider_CreateClassEnumAsyncEvent_Pre" ,
    L"Namespace!s! Provider!s! User!s! Locale!s! TransactionIdentifier!s! Flags!u! SuperclassName!s!" ,

	L"Msft_WmiProvider_PutInstanceAsyncEvent_Pre" ,
    L"Namespace!s! Provider!s! User!s! Locale!s! TransactionIdentifier!s! Flags!u! InstanceObject!O!" ,

	L"Msft_WmiProvider_DeleteInstanceAsyncEvent_Pre" ,
    L"Namespace!s! Provider!s! User!s! Locale!s! TransactionIdentifier!s! Flags!u! ObjectPath!s!" ,

	L"Msft_WmiProvider_CreateInstanceEnumAsyncEvent_Pre" ,
    L"Namespace!s! Provider!s! User!s! Locale!s! TransactionIdentifier!s! Flags!u! ClassName!s!" ,

	L"Msft_WmiProvider_ExecQueryAsyncEvent_Pre" ,
    L"Namespace!s! Provider!s! User!s! Locale!s! TransactionIdentifier!s! Flags!u! QueryLanguage!s! Query!s!" ,

	L"Msft_WmiProvider_ExecNotificationQueryAsyncEvent_Pre" ,
    L"Namespace!s! Provider!s! User!s! Locale!s! TransactionIdentifier!s! Flags!u! QueryLanguage!s! Query!s!" ,

	L"Msft_WmiProvider_ExecMethodAsyncEvent_Pre" ,
    L"Namespace!s! Provider!s! User!s! Locale!s! TransactionIdentifier!s! Flags!u! ObjectPath!s! MethodName!s! InputParameters!O!" ,

	L"Msft_WmiProvider_ProvideEvents_Pre" ,
    L"Namespace!s! Provider!s! User!s! Locale!s! TransactionIdentifier!s! Flags!u!" ,

	L"Msft_WmiProvider_AccessCheck_Pre" ,
    L"Namespace!s! Provider!s! User!s! Locale!s! TransactionIdentifier!s! QueryLanguage!s! Query!s! Sid!c[]!" ,

	L"Msft_WmiProvider_CancelQuery_Pre" ,
    L"Namespace!s! Provider!s! User!s! Locale!s! TransactionIdentifier!s! QueryId!u!" ,

	L"Msft_WmiProvider_NewQuery_Pre" ,
    L"Namespace!s! Provider!s! User!s! Locale!s! TransactionIdentifier!s! QueryId!u! QueryLanguage!s! Query!s!" ,

	L"Msft_WmiProvider_GetObjectAsyncEvent_Post" ,
    L"Namespace!s! Provider!s! User!s! Locale!s! TransactionIdentifier!s! Flags!u! ObjectPath!s! ResultCode!u! StringParameter!s! ObjectParameter!O!" ,

	L"Msft_WmiProvider_PutClassAsyncEvent_Post" ,
    L"Namespace!s! Provider!s! User!s! Locale!s! TransactionIdentifier!s! Flags!u! ClassObject!O! ResultCode!u! StringParameter!s! ObjectParameter!O!" ,

	L"Msft_WmiProvider_DeleteClassAsyncEvent_Post" ,
    L"Namespace!s! Provider!s! User!s! Locale!s! TransactionIdentifier!s! Flags!u! ClassName!s! ResultCode!u! StringParameter!s! ObjectParameter!O!" ,

	L"Msft_WmiProvider_CreateClassEnumAsyncEvent_Post" ,
    L"Namespace!s! Provider!s! User!s! Locale!s! TransactionIdentifier!s! Flags!u! SuperclassName!s! ResultCode!u! StringParameter!s! ObjectParameter!O!" ,

	L"Msft_WmiProvider_PutInstanceAsyncEvent_Post" ,
    L"Namespace!s! Provider!s! User!s! Locale!s! TransactionIdentifier!s! Flags!u! InstanceObject!O! ResultCode!u! StringParameter!s! ObjectParameter!O!" ,

	L"Msft_WmiProvider_DeleteInstanceAsyncEvent_Post" ,
    L"Namespace!s! Provider!s! User!s! Locale!s! TransactionIdentifier!s! Flags!u! ObjectPath!s! ResultCode!u! StringParameter!s! ObjectParameter!O!" ,

	L"Msft_WmiProvider_CreateInstanceEnumAsyncEvent_Post" ,
    L"Namespace!s! Provider!s! User!s! Locale!s! TransactionIdentifier!s! Flags!u! ClassName!s! ResultCode!u! StringParameter!s! ObjectParameter!O!" ,

	L"Msft_WmiProvider_ExecQueryAsyncEvent_Post" ,
    L"Namespace!s! Provider!s! User!s! Locale!s! TransactionIdentifier!s! Flags!u! QueryLanguage!s! Query!s! ResultCode!u! StringParameter!s! ObjectParameter!O!" ,

	L"Msft_WmiProvider_ExecNotificationQueryAsyncEvent_Post" ,
    L"Namespace!s! Provider!s! User!s! Locale!s! TransactionIdentifier!s! Flags!u! QueryLanguage!s! Query!s! ResultCode!u! StringParameter!s! ObjectParameter!O!" ,

	L"Msft_WmiProvider_ExecMethodAsyncEvent_Post" ,
    L"Namespace!s! Provider!s! User!s! Locale!s! TransactionIdentifier!s! Flags!u! ObjectPath!s! MethodName!s! InputParameters!O! ResultCode!u! StringParameter!s! ObjectParameter!O!" ,

	L"Msft_WmiProvider_ProvideEvents_Post" ,
    L"Namespace!s! Provider!s! User!s! Locale!s! TransactionIdentifier!s! Flags!u! Result!u!" ,

	L"Msft_WmiProvider_AccessCheck_Post" ,
    L"Namespace!s! Provider!s! User!s! Locale!s! TransactionIdentifier!s! QueryLanguage!s! Query!s! Sid!c[]! Result!u!" ,

	L"Msft_WmiProvider_CancelQuery_Post" ,
    L"Namespace!s! Provider!s! User!s! Locale!s! TransactionIdentifier!s! QueryId!u! Result!u!" ,

	L"Msft_WmiProvider_NewQuery_Post" ,
    L"Namespace!s! Provider!s! User!s! Locale!s! TransactionIdentifier!s! QueryId!u! QueryLanguage!s! Query!s! Result!u!" 
} ;

#if 0
	L"Msft_WmiProvider_HostLoadOperationEvent" ,
    L"Namespace!s! Provider!s! User!s! Locale!s! TransactionIdentifier!s! ProcessIdentifier!u!" ,

	L"Msft_WmiProvider_HostLoadFailureOperationEvent" ,
    L"Namespace!s! Provider!s! User!s! Locale!s! TransactionIdentifier!s! ResultCode!u!" ,

	L"Msft_WmiProvider_HostUnLoadOperationEvent" ,
    L"Namespace!s! Provider!s! User!s! Locale!s! TransactionIdentifier!s! ProcessIdentifier!u!" ,
#endif



ULONG ProviderSubSystem_Globals :: s_EventClassHandlesSize = sizeof ( s_EventPropertySources ) / ( sizeof ( wchar_t * ) * 2 )  ;
HANDLE ProviderSubSystem_Globals :: s_EventClassHandles [ sizeof ( s_EventPropertySources ) / ( sizeof ( wchar_t * ) * 2 ) ] ;

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT ProviderSubSystem_Globals :: Initialize_Events ()
{
	HRESULT t_Result = S_OK ;

    ProviderSubSystem_Globals ::s_EventSource = WmiEventSourceConnect (

		L"root\\cimv2" ,
        L"ProviderSubSystem" ,
        TRUE ,
        32000 ,
        100 ,
        NULL ,
        NULL
	) ;

    if ( ProviderSubSystem_Globals :: s_EventSource )
    {
        for ( ULONG t_Index = 0 ; t_Index < ProviderSubSystem_Globals :: s_EventClassHandlesSize ; t_Index ++ )
        {
            ProviderSubSystem_Globals :: s_EventClassHandles [ t_Index ] =  WmiCreateObjectWithFormat (

				ProviderSubSystem_Globals :: s_EventSource ,
                s_EventPropertySources [ t_Index * 2 ] ,
                WMI_CREATEOBJ_LOCKABLE ,
                s_EventPropertySources [ t_Index * 2 + 1 ]
			) ;

            if ( ProviderSubSystem_Globals :: s_EventClassHandles [ t_Index ] == NULL )
			{
				t_Result = WBEM_E_CRITICAL_ERROR ;

                break;
			}
        }
	}
	else
	{
		t_Result = WBEM_E_CRITICAL_ERROR ;
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT ProviderSubSystem_Globals :: UnInitialize_Events ()
{
	HRESULT t_Result = S_OK ;

    if ( ProviderSubSystem_Globals ::s_EventSource )
    {
        for ( ULONG t_Index = 0 ; t_Index < ProviderSubSystem_Globals :: s_EventClassHandlesSize ; t_Index ++ )
        {
	HANDLE eventHandle = ProviderSubSystem_Globals :: s_EventClassHandles [ t_Index ];
        ProviderSubSystem_Globals :: s_EventClassHandles [ t_Index ] = NULL;    
	WmiDestroyObject ( eventHandle) ;
        }

        WmiEventSourceDisconnect ( ProviderSubSystem_Globals :: s_EventSource );
        ProviderSubSystem_Globals :: s_EventSource = NULL;
        
    }

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT GetSecurityDescriptor ( SECURITY_DESCRIPTOR &a_SecurityDescriptor , DWORD a_Access ) 
{
	HRESULT t_Result = S_OK ;

	BOOL t_BoolResult = InitializeSecurityDescriptor ( & a_SecurityDescriptor , SECURITY_DESCRIPTOR_REVISION ) ;
	if ( t_BoolResult )
	{
		SID_IDENTIFIER_AUTHORITY t_NtAuthoritySid = SECURITY_NT_AUTHORITY ;

		PSID t_System_Sid = NULL ;
		ACCESS_ALLOWED_ACE *t_System_ACE = NULL ;
		USHORT t_System_ACESize = 0 ;

		t_BoolResult = AllocateAndInitializeSid (

			& t_NtAuthoritySid ,
			1 ,
			SECURITY_LOCAL_SYSTEM_RID,
			0,
			0,
			0,
			0,
			0,
			0,
			0,
			& t_System_Sid
		);

		if ( t_BoolResult )
		{
			DWORD t_SidLength = ::GetLengthSid ( t_System_Sid );
			t_System_ACESize = sizeof(ACCESS_ALLOWED_ACE) + (WORD) ( t_SidLength - sizeof(DWORD) ) ;
			t_System_ACE = (ACCESS_ALLOWED_ACE*) new BYTE [ t_System_ACESize ] ;
			if ( t_System_ACE )
			{
				CopySid ( t_SidLength, (PSID) & t_System_ACE->SidStart, t_System_Sid ) ;
				t_System_ACE->Mask = FILE_MAP_ALL_ACCESS;
				t_System_ACE->Header.AceType = 0 ;
				t_System_ACE->Header.AceFlags = 3 ;
				t_System_ACE->Header.AceSize = t_System_ACESize ;
			}
			else
			{
				t_Result = WBEM_E_OUT_OF_MEMORY ;
			}
		}
		else
		{
			DWORD t_LastError = ::GetLastError();

			t_Result = WBEM_E_OUT_OF_MEMORY ;
		}

		SID_IDENTIFIER_AUTHORITY t_WorldAuthoritySid = SECURITY_WORLD_SID_AUTHORITY ;

		PSID t_Everyone_Sid = NULL ;
		ACCESS_ALLOWED_ACE *t_Everyone_ACE = NULL ;
		USHORT t_Everyone_ACESize = 0 ;
		
		t_BoolResult = AllocateAndInitializeSid (

			& t_WorldAuthoritySid ,
			1 ,
			SECURITY_WORLD_RID ,
			0,
			0,
			0,
			0,
			0,
			0,
			0,
			& t_Everyone_Sid
		);

		if ( t_BoolResult )
		{
			DWORD t_SidLength = ::GetLengthSid ( t_Everyone_Sid );
			t_Everyone_ACESize = sizeof(ACCESS_ALLOWED_ACE) + (WORD) ( t_SidLength - sizeof(DWORD) ) ;
			t_Everyone_ACE = (ACCESS_ALLOWED_ACE*) new BYTE [ t_Everyone_ACESize ] ;
			if ( t_Everyone_ACE )
			{
				CopySid ( t_SidLength, (PSID) & t_Everyone_ACE->SidStart, t_Everyone_Sid ) ;
				t_Everyone_ACE->Mask = a_Access ;
				t_Everyone_ACE->Header.AceType = 0 ;
				t_Everyone_ACE->Header.AceFlags = 3 ;
				t_Everyone_ACE->Header.AceSize = t_Everyone_ACESize ;
			}
			else
			{
				t_Result = WBEM_E_OUT_OF_MEMORY ;
			}
		}
		else
		{
			DWORD t_LastError = ::GetLastError();

			t_Result = WBEM_E_OUT_OF_MEMORY ;
		}

		// Now we need to set permissions on the registry: Everyone read; Admins full.
		// We have the sid for admins from the above code.  Now get the sid for "Everyone"

		DWORD t_TotalAclSize = sizeof(ACL) + t_System_ACESize + t_Everyone_ACESize ;
		PACL t_Dacl = (PACL) new BYTE [ t_TotalAclSize ] ;
		if ( t_Dacl )
		{
			if ( :: InitializeAcl ( t_Dacl, t_TotalAclSize, ACL_REVISION ) )
			{
				DWORD t_AceIndex = 0 ;

				if ( t_System_ACESize && :: AddAce ( t_Dacl , ACL_REVISION , t_AceIndex , t_System_ACE , t_System_ACESize ) )
				{
					t_AceIndex ++ ;
				}

				if ( t_Everyone_ACESize && :: AddAce ( t_Dacl , ACL_REVISION, t_AceIndex , t_Everyone_ACE , t_Everyone_ACESize ) )
				{
					t_AceIndex ++ ;
				}

				t_BoolResult = SetSecurityDescriptorDacl (

				  & a_SecurityDescriptor ,
				  TRUE ,
				  t_Dacl ,
				  FALSE
				) ;

				if ( t_BoolResult == FALSE )
				{
					delete [] ( ( BYTE * ) t_Dacl ) ;

					t_Result = WBEM_E_CRITICAL_ERROR ;
				}
			}
		}
		else
		{
			t_Result = WBEM_E_OUT_OF_MEMORY ;
		}

		if ( t_System_ACE )
		{
			delete [] ( ( BYTE * ) t_System_ACE ) ;
		}

		if ( t_Everyone_ACE )
		{
			delete [] ( ( BYTE * ) t_Everyone_ACE ) ;
		}

		if ( t_System_Sid )
		{
			FreeSid ( t_System_Sid ) ;
		}

		if ( t_Everyone_Sid )
		{
			FreeSid ( t_Everyone_Sid ) ;
		}
	}
	else
	{
		t_Result = WBEM_E_CRITICAL_ERROR ;
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT ProviderSubSystem_Globals :: Initialize_SharedCounters ()
{
	HRESULT t_Result = S_OK ;

	HANDLE t_Handle = OpenFileMapping (

		FILE_MAP_READ | FILE_MAP_WRITE ,
		FALSE ,
		s_FileMappingName
	) ;

	if ( t_Handle == NULL )
	{
		if ( GetLastError () == ERROR_FILE_NOT_FOUND )
		{
			SECURITY_DESCRIPTOR t_SecurityDescriptor ;

			t_Result = GetSecurityDescriptor ( 

				t_SecurityDescriptor ,
				SECTION_QUERY | SECTION_MAP_WRITE | SECTION_MAP_READ | READ_CONTROL | DELETE
				// FILE_MAP_ALL_ACCESS
			) ;

			if ( SUCCEEDED ( t_Result ) ) 
			{
				SECURITY_ATTRIBUTES t_SecurityAttributes ;

				t_SecurityAttributes.nLength = sizeof ( SECURITY_ATTRIBUTES ) ; 
				t_SecurityAttributes.lpSecurityDescriptor = & t_SecurityDescriptor ; 
				t_SecurityAttributes.bInheritHandle = FALSE ; 

				t_Handle = CreateFileMapping (

					INVALID_HANDLE_VALUE ,
					& t_SecurityAttributes , 
					PAGE_READWRITE | SEC_COMMIT ,
					0 ,
					sizeof ( CServerObject_ProviderSubsystem_Counters ) , 
					s_FileMappingName
				) ;

				if ( t_Handle == NULL )
				{
					t_Result = WBEM_E_ACCESS_DENIED ;
				}

				delete [] t_SecurityDescriptor.Dacl ;
			}
		}
		else
		{
			t_Result = WBEM_E_ACCESS_DENIED ;
		}
	}

	void *t_Location = NULL ;

	if ( SUCCEEDED ( t_Result ) )
	{
		t_Location = MapViewOfFile (
			
			t_Handle ,
			FILE_MAP_READ | FILE_MAP_WRITE ,
			0 ,
			0 ,
			sizeof ( CServerObject_ProviderSubsystem_Counters )
		) ;

		if ( t_Location )
		{
		}
		else
		{
			t_Result = WBEM_E_ACCESS_DENIED ;
		}
	}

	if ( SUCCEEDED ( t_Result ) )
	{
		s_FileMapping = t_Handle ;
		s_SharedCounters = ( CServerObject_ProviderSubsystem_Counters * ) t_Location ;
	}
	else
	{
		if ( t_Handle )
		{
			CloseHandle ( t_Handle ) ;
		}

		SID_IDENTIFIER_AUTHORITY t_NtAuthoritySid = SECURITY_NT_AUTHORITY ;

		PSID t_System_Sid = NULL ;

		BOOL t_BoolResult = AllocateAndInitializeSid (

			& t_NtAuthoritySid ,
			1 ,
			SECURITY_LOCAL_SYSTEM_RID,
			0,
			0,
			0,
			0,
			0,
			0,
			0,
			& t_System_Sid
		);

		if ( t_BoolResult )
		{
			LPCWSTR t_Array [ 1 ] ;

			t_Array [ 0 ] = s_FileMappingName ;

			BOOL t_Status = :: ReportEvent (

			  ProviderSubSystem_Globals :: GetNtEventSource () ,
			  EVENTLOG_WARNING_TYPE ,
			  0 ,
			  WBEM_MC_PROVIDER_SUBSYSTEM_LOCALSYSTEM_NAMED_SECTION ,
			  t_System_Sid ,
			  1 ,
			  0 ,
			  ( LPCWSTR * ) t_Array ,
			  NULL
			) ;

			if ( t_Status == 0 )
			{
				DWORD t_LastError = GetLastError () ;
			}

			LocalFree ( t_System_Sid ) ; 
		}
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT ProviderSubSystem_Globals :: UnInitialize_SharedCounters ()
{
	HRESULT t_Result = S_OK ;

	if ( s_SharedCounters )
	{
		BOOL t_Status = UnmapViewOfFile ( ( void * ) s_SharedCounters ) ;
                s_SharedCounters = NULL ;
	}

	if ( s_FileMapping )
	{
		CloseHandle ( s_FileMapping ) ;
		s_FileMapping = NULL ;
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT ProviderSubSystem_Globals :: CreateJobObject ()
{
	HRESULT t_Result = S_OK ;

	s_HostJobObject = :: CreateJobObject (

		NULL ,
		s_HostJobObjectName	
	) ;

	if ( s_HostJobObject == NULL )
	{
		switch ( GetLastError () )
		{
			case ERROR_ALREADY_EXISTS:
			{
				s_HostJobObject = OpenJobObject (

					JOB_OBJECT_ALL_ACCESS ,
					FALSE ,
					s_HostJobObjectName
				) ;

				if ( ! s_HostJobObject )
				{
					t_Result = WBEM_E_ACCESS_DENIED ;
				}
			}
			break ;

			default:
			{
				t_Result = WBEM_E_ACCESS_DENIED ;
			}
			break;
		}
	}
	else
	{
		JOBOBJECTINFOCLASS t_JobObjectInfoClass = JobObjectExtendedLimitInformation ;
		JOBOBJECT_EXTENDED_LIMIT_INFORMATION t_JobObjectInfo ;
		DWORD t_JobObjectInfoLength = sizeof ( JOBOBJECT_EXTENDED_LIMIT_INFORMATION ) ;
		ZeroMemory ( & t_JobObjectInfo , sizeof ( JOBOBJECT_EXTENDED_LIMIT_INFORMATION ) ) ;

		ULONG t_LimitRequirements = s_Quota_ProcessLimitCount > 0 ? JOB_OBJECT_LIMIT_ACTIVE_PROCESS : 0 ;
		t_LimitRequirements = ( s_Quota_ProcessMemoryLimitCount > 0 ? t_LimitRequirements | JOB_OBJECT_LIMIT_JOB_MEMORY : t_LimitRequirements );
		t_LimitRequirements = s_Quota_JobMemoryLimitCount > 0 ? t_LimitRequirements | JOB_OBJECT_LIMIT_PROCESS_MEMORY : t_LimitRequirements ;

		t_JobObjectInfo.BasicLimitInformation.LimitFlags = t_LimitRequirements | JOB_OBJECT_LIMIT_BREAKAWAY_OK;
		t_JobObjectInfo.BasicLimitInformation.ActiveProcessLimit = s_Quota_ProcessLimitCount ;
		t_JobObjectInfo.ProcessMemoryLimit = s_Quota_ProcessMemoryLimitCount ;
		t_JobObjectInfo.JobMemoryLimit = s_Quota_JobMemoryLimitCount ;
		t_JobObjectInfo.PeakProcessMemoryUsed = s_Quota_ProcessMemoryLimitCount ;
		t_JobObjectInfo.PeakJobMemoryUsed = s_Quota_JobMemoryLimitCount ;

		OSVERSIONINFOEX t_OsInformationEx ;
		ZeroMemory ( & t_OsInformationEx , sizeof ( t_OsInformationEx ) ) ;
		t_OsInformationEx.dwOSVersionInfoSize = sizeof ( t_OsInformationEx ) ;

		if ( GetVersionEx ( ( OSVERSIONINFO * ) & t_OsInformationEx ) )
		{
			if ( ( t_OsInformationEx.dwPlatformId == VER_PLATFORM_WIN32_NT ) && ( ( t_OsInformationEx.dwMajorVersion > 5 ) || ( ( t_OsInformationEx.dwMajorVersion == 5 ) && ( t_OsInformationEx.dwMinorVersion >= 1 ) ) ) )
			{
				t_JobObjectInfo.BasicLimitInformation.LimitFlags = t_JobObjectInfo.BasicLimitInformation.LimitFlags | JOB_OBJECT_LIMIT_KILL_ON_JOB_CLOSE | JOB_OBJECT_LIMIT_BREAKAWAY_OK;
			}
		}
		else
		{
			t_Result = WBEM_E_UNEXPECTED ;
		}

		if ( SUCCEEDED ( t_Result ) )
		{
			BOOL t_Status = SetInformationJobObject (

			  s_HostJobObject ,
			  t_JobObjectInfoClass ,
			  & t_JobObjectInfo ,
			  t_JobObjectInfoLength
			) ;

			if ( t_Status == FALSE ) 
			{
				t_Result = WBEM_E_ACCESS_DENIED ;
			}
		}
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT ProviderSubSystem_Globals :: DeleteJobObject ()
{
	HRESULT t_Result = S_OK ;

	if ( s_HostJobObject )
	{
		BOOL t_Status = TerminateJobObject ( s_HostJobObject ,  0 ) ;
		CloseHandle ( s_HostJobObject ) ;
                s_HostJobObject = NULL ;
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT ProviderSubSystem_Globals :: AssignProcessToJobObject ( HANDLE a_Handle )
{
	HRESULT t_Result = S_OK ;

	if ( s_HostJobObject )
	{
		BOOL t_Status =:: AssignProcessToJobObject (

		  s_HostJobObject ,
		  a_Handle 
		) ;

		if ( t_Status == FALSE ) 
		{
			t_Result = WBEM_E_ACCESS_DENIED ;
		}
	}
	else
	{
		t_Result = WBEM_E_CRITICAL_ERROR ;
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT ProviderSubSystem_Globals :: Global_Startup ()
{
	HRESULT t_Result = S_OK ;

	if ( ! s_Allocator )
	{
/*
 *	Use the global process heap for this particular boot operation
 */
	
		WmiAllocator t_Allocator ;
		WmiStatusCode t_StatusCode = t_Allocator.New (

			( void ** ) & s_Allocator ,
			sizeof ( WmiAllocator ) 
		) ;

		if ( t_StatusCode == e_StatusCode_Success )
		{
#ifdef DBG
			:: new ( ( void * ) s_Allocator ) WmiAllocator ( WmiAllocator :: e_DefaultAllocation , 0 , 0 ) ;
#else
			:: new ( ( void * ) s_Allocator ) WmiAllocator ;
#endif

			t_StatusCode = s_Allocator->Initialize () ;
			if ( t_StatusCode != e_StatusCode_Success )
			{
				t_Result = WBEM_E_OUT_OF_MEMORY ;
			}
		}
		else
		{
			t_Result = WBEM_E_OUT_OF_MEMORY ;
		}
	}

	if ( SUCCEEDED ( t_Result ) )
	{
		WmiStatusCode t_StatusCode = WmiHelper :: InitializeCriticalSection ( & s_DecoupledRegistrySection ) ;
		if ( t_StatusCode != e_StatusCode_Success )
		{
			t_Result = WBEM_E_OUT_OF_MEMORY ;
		}
	}
 
	if ( SUCCEEDED ( t_Result ) )
	{
		WmiStatusCode t_StatusCode = WmiHelper :: InitializeCriticalSection ( & s_GuidTagSection ) ;
		if ( t_StatusCode == e_StatusCode_Success )
		{
			s_GuidTag = new CWbemGlobal_ComServerTagContainer ( *s_Allocator ) ;
			if ( s_GuidTag )
			{
				t_StatusCode = s_GuidTag->Initialize () ;
				if ( t_StatusCode != e_StatusCode_Success )
				{
					t_Result = WBEM_E_OUT_OF_MEMORY ;
				}
			}
			else
			{
				t_Result = WBEM_E_OUT_OF_MEMORY ;
			}
		}
		else
		{
			t_Result = WBEM_E_OUT_OF_MEMORY ;
		}
	}

	if ( SUCCEEDED ( t_Result ) )
	{
		s_NtEventLogSource = RegisterEventSource ( NULL , s_ProviderSubsystemEventSourceName ) ;
		if ( s_NtEventLogSource == NULL )
		{
			return WBEM_E_CRITICAL_ERROR ;
		}
	}

	if ( SUCCEEDED ( t_Result ) )
	{
		s_ProvSubSysController = :: new CWbemGlobal_IWmiProvSubSysController ( *s_Allocator ) ;
		if ( s_ProvSubSysController )
		{
			s_ProvSubSysController->AddRef () ;

			WmiStatusCode t_StatusCode = s_ProvSubSysController->Initialize () ;
			if ( t_StatusCode != e_StatusCode_Success )
			{
				delete s_ProvSubSysController ;
				s_ProvSubSysController = NULL ;
				t_Result = WBEM_E_OUT_OF_MEMORY ;
			}
		}
		else
		{
			t_Result = WBEM_E_OUT_OF_MEMORY ;
		}
	}

	if ( SUCCEEDED ( t_Result ) )
	{
		s_SyncProviderController = :: new CWbemGlobal_IWbemSyncProviderController ( *s_Allocator ) ;
		if ( s_SyncProviderController )
		{
			s_SyncProviderController->AddRef () ;

			WmiStatusCode t_StatusCode = s_SyncProviderController->Initialize () ;
			if ( t_StatusCode != e_StatusCode_Success )
			{
				delete s_SyncProviderController ;
				s_SyncProviderController = NULL ;
				t_Result = WBEM_E_OUT_OF_MEMORY ;
			}
		}
		else
		{
			t_Result = WBEM_E_OUT_OF_MEMORY ;
		}
	}

	if ( SUCCEEDED ( t_Result ) )
	{
		s_HostedProviderController = :: new CWbemGlobal_HostedProviderController ( *s_Allocator ) ;
		if ( s_HostedProviderController )
		{
			s_HostedProviderController->AddRef () ;

			WmiStatusCode t_StatusCode = s_HostedProviderController->Initialize () ;
			if ( t_StatusCode != e_StatusCode_Success )
			{
				delete s_HostedProviderController ;
				s_HostedProviderController = NULL ;
				t_Result = WBEM_E_OUT_OF_MEMORY ;
			}
		}
		else
		{
			t_Result = WBEM_E_OUT_OF_MEMORY ;
		}
	}

	if ( SUCCEEDED ( t_Result ) )
	{
		s_HostController = :: new HostController ( *s_Allocator ) ;
		if ( s_HostController )
		{
			s_HostController->AddRef () ;

			WmiStatusCode t_StatusCode = s_HostController->Initialize () ;
			if ( t_StatusCode != e_StatusCode_Success )
			{
				delete s_HostController ;
				s_HostController = NULL ;
				t_Result = WBEM_E_OUT_OF_MEMORY ;
			}
		}
		else
		{
			t_Result = WBEM_E_OUT_OF_MEMORY ;
		}
	}

	if ( SUCCEEDED ( t_Result ) )
	{
		s_RefresherManagerController = :: new RefresherManagerController ( *s_Allocator ) ;
		if ( s_RefresherManagerController )
		{
			s_RefresherManagerController->AddRef () ;

			WmiStatusCode t_StatusCode = s_RefresherManagerController->Initialize () ;
			if ( t_StatusCode != e_StatusCode_Success )
			{
				delete s_RefresherManagerController ;
				s_RefresherManagerController = NULL ;
				t_Result = WBEM_E_OUT_OF_MEMORY ;
			}
		}
		else
		{
			t_Result = WBEM_E_OUT_OF_MEMORY ;
		}
	}

	if ( SUCCEEDED ( t_Result ) )
	{
		WmiStatusCode t_StatusCode = WmiThread <ULONG> :: Static_Initialize ( *s_Allocator ) ;
	}

	ProviderSubSystem_Common_Globals :: InitializeTransmitSize () ;

	ProviderSubSystem_Common_Globals :: InitializeDefaultStackSize () ;

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT ProviderSubSystem_Globals :: Global_Shutdown ()
{
	HRESULT t_Result = S_OK ;

	WmiStatusCode t_StatusCode = WmiHelper :: DeleteCriticalSection ( & s_DecoupledRegistrySection ) ;

	t_StatusCode = WmiHelper :: DeleteCriticalSection ( & s_GuidTagSection ) ;

	if ( s_GuidTag ) 
	{
		t_StatusCode = s_GuidTag->UnInitialize () ;
		delete s_GuidTag ;
		s_GuidTag = NULL ;
	}

	if ( s_ProvSubSysController )
	{
		WmiStatusCode t_StatusCode = s_ProvSubSysController->UnInitialize () ;
		s_ProvSubSysController->Release () ;
		s_ProvSubSysController = NULL ;
	}

	if ( s_SyncProviderController )
	{
		WmiStatusCode t_StatusCode = s_SyncProviderController->Shutdown () ;
		t_StatusCode = s_SyncProviderController->UnInitialize () ;
		s_SyncProviderController->Release () ;
		s_SyncProviderController = NULL ;
	}

	if ( s_HostedProviderController )
	{
		WmiStatusCode t_StatusCode = s_HostController->Shutdown () ;
		t_StatusCode = s_HostController->UnInitialize () ;
		s_HostController->Release () ;
		s_HostController = NULL ;
	}

	if ( s_HostController )
	{
		WmiStatusCode t_StatusCode = s_HostController->Shutdown () ;
		t_StatusCode = s_HostController->UnInitialize () ;
		s_HostController->Release () ;
		s_HostController = NULL ;
	}

	if ( s_RefresherManagerController )
	{
		WmiStatusCode t_StatusCode = s_RefresherManagerController->Shutdown () ;
		t_StatusCode = s_RefresherManagerController->UnInitialize () ;
		s_RefresherManagerController->Release () ;
		s_RefresherManagerController= NULL ;
	}

	t_StatusCode = WmiThread <ULONG> :: Static_UnInitialize ( *s_Allocator ) ;

	if ( s_NtEventLogSource )
	{
		DeregisterEventSource ( s_NtEventLogSource ) ;
	}

	if ( s_Allocator )
	{
/*
 *	Use the global process heap for this particular boot operation
 */

		WmiAllocator t_Allocator ;
		WmiStatusCode t_StatusCode = t_Allocator.Delete (

			( void * ) s_Allocator
		) ;

		if ( t_StatusCode != e_StatusCode_Success )
		{
			t_Result = WBEM_E_OUT_OF_MEMORY ;
		}
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

CWbemGlobal_ComServerTagContainer *ProviderSubSystem_Globals :: GetGuidTag ()
{
	return s_GuidTag ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

CWbemGlobal_IWmiProvSubSysController *ProviderSubSystem_Globals :: GetProvSubSysController ()
{
	return s_ProvSubSysController ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

CWbemGlobal_IWbemSyncProviderController *ProviderSubSystem_Globals :: GetSyncProviderController ()
{
	return s_SyncProviderController ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HostController *ProviderSubSystem_Globals :: GetHostController ()
{
	return s_HostController ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

RefresherManagerController *ProviderSubSystem_Globals :: GetRefresherManagerController ()
{
	return s_RefresherManagerController ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

CWbemGlobal_HostedProviderController *ProviderSubSystem_Globals :: GetHostedProviderController ()
{
	return s_HostedProviderController ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

CriticalSection *ProviderSubSystem_Globals :: GetGuidTagCriticalSection ()
{
	return & s_GuidTagSection ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

CriticalSection *ProviderSubSystem_Globals :: GetDecoupledRegistrySection ()
{
	return & s_DecoupledRegistrySection ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

void * __cdecl operator new ( size_t a_Size )
{
    void *t_Ptr ;
	WmiStatusCode t_StatusCode = ProviderSubSystem_Globals :: s_Allocator->New (

		( void ** ) & t_Ptr ,
		a_Size
	) ;

	if ( t_StatusCode != e_StatusCode_Success )
    {
#if 1
		t_Ptr = NULL ;
#else
        throw Wmi_Heap_Exception (

			Wmi_Heap_Exception::HEAP_ERROR::E_ALLOCATION_ERROR
		) ;
#endif
    }

    return t_Ptr ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

void __cdecl operator delete ( void *a_Ptr )
{
    if ( a_Ptr )
    {
		WmiStatusCode t_StatusCode = ProviderSubSystem_Globals :: s_Allocator->Delete (

			( void * ) a_Ptr
		) ;
    }
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT ProviderSubSystem_Globals :: ForwardReload (

	long a_Flags ,
	IWbemContext *a_Context ,
	LPCWSTR a_Namespace ,
	LPCWSTR a_Provider
)
{
	HRESULT t_Result = S_OK ;

	CWbemGlobal_IWmiProvSubSysController *t_SubSystemController = ProviderSubSystem_Globals :: GetProvSubSysController () ;
	if ( t_SubSystemController )
	{
		t_SubSystemController->Lock () ;

		CWbemGlobal_IWmiProvSubSysController_Container *t_Container = NULL ;
		t_SubSystemController->GetContainer ( t_Container ) ;

		if ( t_Container->Size () )
		{
			CWbemGlobal_IWmiProvSubSysController_Container_Iterator t_Iterator = t_Container->Begin ();

			CServerObject_ProviderSubSystem **t_ControllerElements = new CServerObject_ProviderSubSystem * [ t_Container->Size () ] ;
			if ( t_ControllerElements )
			{
				ULONG t_Count = 0 ;
				while ( ! t_Iterator.Null () )
				{
					HRESULT t_Result = t_Iterator.GetElement ()->QueryInterface ( IID_CWbemProviderSubSystem , ( void ** ) & t_ControllerElements [ t_Count ] ) ;

					t_Iterator.Increment () ;

					t_Count ++ ;
				}

				t_SubSystemController->UnLock () ;

				for ( ULONG t_Index = 0 ; t_Index < t_Count ; t_Index ++ )
				{
					if ( t_ControllerElements [ t_Index ] )
					{
						t_Result = t_ControllerElements [ t_Index ]->ForwardReload ( 

							0 , 
							NULL ,
							a_Namespace ,
							a_Provider
						) ;

						t_ControllerElements [ t_Index ]->Release () ;
					}
				}

				delete [] t_ControllerElements ;
			}
			else
			{
				t_SubSystemController->UnLock () ;
			}
		}
		else
		{
			t_SubSystemController->UnLock () ;
		}
	}
	else
	{
		t_Result = WBEM_E_CRITICAL_ERROR ;
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

BOOL ProviderSubSystem_Globals :: CheckGuidTag ( const GUID &a_Guid )
{
	BOOL t_Present = FALSE ;

	CWbemGlobal_ComServerTagContainer_Iterator t_Iterator ;

	WmiStatusCode t_StatusCode = WmiHelper :: EnterCriticalSection ( & s_GuidTagSection ) ;
	
	t_StatusCode = s_GuidTag->Find ( a_Guid , t_Iterator ) ;
	if ( t_StatusCode == e_StatusCode_Success ) 
	{
		t_Present = TRUE ;
	}

	t_StatusCode = WmiHelper :: LeaveCriticalSection ( & s_GuidTagSection ) ;

	return t_Present ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

void ProviderSubSystem_Globals :: InsertGuidTag ( const GUID &a_Guid )
{
	CWbemGlobal_ComServerTagContainer_Iterator t_Iterator ;

	WmiStatusCode t_StatusCode = WmiHelper :: EnterCriticalSection ( & s_GuidTagSection ) ;
	
	t_StatusCode = s_GuidTag->Insert ( a_Guid , a_Guid , t_Iterator ) ;
	
	t_StatusCode = WmiHelper :: LeaveCriticalSection ( & s_GuidTagSection ) ;

}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

void ProviderSubSystem_Globals :: DeleteGuidTag ( const GUID &a_Guid )
{
	WmiStatusCode t_StatusCode = WmiHelper :: EnterCriticalSection ( & s_GuidTagSection ) ;
	
	t_StatusCode = s_GuidTag->Delete ( a_Guid ) ;
	
	t_StatusCode = WmiHelper :: LeaveCriticalSection ( & s_GuidTagSection ) ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT ProviderSubSystem_Globals :: BeginThreadImpersonation (

	IUnknown *&a_OldContext ,
	IServerSecurity *&a_OldSecurity ,
	BOOL &a_Impersonating
)
{
	HRESULT t_Result = S_OK ;

	IServerSecurity *t_ServerSecurity = NULL ;

	t_Result = CoGetCallContext ( IID_IUnknown , ( void ** ) & a_OldContext ) ;
	if ( SUCCEEDED ( t_Result ) )
	{
		t_Result = a_OldContext->QueryInterface ( IID_IServerSecurity , ( void ** ) & t_ServerSecurity ) ;
		if ( SUCCEEDED ( t_Result ) ) 
		{
			a_Impersonating = t_ServerSecurity->IsImpersonating () ;
		}
		else
		{
			a_Impersonating = FALSE ;
		}
	}

	CWbemCallSecurity *t_CallSecurity = CWbemCallSecurity :: New () ;
	if ( t_CallSecurity )
	{
		t_CallSecurity->AddRef () ;

		_IWmiThreadSecHandle *t_ThreadSecurity = NULL ;
		t_Result = t_CallSecurity->GetThreadSecurity ( ( WMI_THREAD_SECURITY_ORIGIN ) ( WMI_ORIGIN_THREAD ) , & t_ThreadSecurity ) ;
		if ( SUCCEEDED ( t_Result ) )
		{
			t_Result = t_CallSecurity->SetThreadSecurity ( t_ThreadSecurity ) ;
			if ( SUCCEEDED ( t_Result ) ) 
			{
				t_Result = t_CallSecurity->QueryInterface ( IID_IServerSecurity , ( void ** ) & a_OldSecurity ) ;
				if ( SUCCEEDED ( t_Result ) ) 
				{
					if ( a_Impersonating )
					{
						t_ServerSecurity->RevertToSelf () ;
					}
				}				
			}

			t_ThreadSecurity->Release () ;
		}

		t_CallSecurity->Release () ;
	}

	if ( t_ServerSecurity )
	{
		t_ServerSecurity->Release () ;
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT ProviderSubSystem_Globals :: EndThreadImpersonation (

	IUnknown *a_OldContext ,
	IServerSecurity *a_OldSecurity ,
	BOOL a_Impersonating

)
{
	HRESULT t_Result = S_OK ;

	IUnknown *t_NewContext = NULL ;

	t_Result = CoSwitchCallContext ( a_OldContext , & t_NewContext ) ;
	if ( SUCCEEDED ( t_Result ) ) 
	{
		if ( a_OldContext )
		{
			if ( a_Impersonating )
			{
				IServerSecurity *t_ServerSecurity = NULL ;
				t_Result = a_OldContext->QueryInterface ( IID_IServerSecurity , ( void ** ) & t_ServerSecurity ) ;
				if ( SUCCEEDED ( t_Result ) )
				{
					t_ServerSecurity->ImpersonateClient () ;

					t_ServerSecurity->Release () ;
				}
			}
		}

		if ( a_OldSecurity )
		{
			a_OldSecurity->Release() ;
		}
	}
	else
	{
		t_Result = WBEM_E_OUT_OF_MEMORY ;
	}

/* 
 * CoGetCallContext AddReffed this thing so now we have to release it.
 */

	if ( a_OldContext )
	{ 
        a_OldContext->Release () ;
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT ProviderSubSystem_Globals :: Begin_IdentifyCall_PrvHost (

	WmiInternalContext a_InternalContext ,
	BOOL &a_Impersonating ,
	IUnknown *&a_OldContext ,
	IServerSecurity *&a_OldSecurity
)
{
	HRESULT t_Result = WBEM_E_INVALID_PARAMETER ;

	if ( a_InternalContext.m_IdentifyHandle )
	{
		HANDLE t_IdentifyToken = ( HANDLE ) a_InternalContext.m_IdentifyHandle ;
		BOOL t_Status = SetThreadToken ( NULL , t_IdentifyToken ) ;
		if ( t_Status )
		{
			t_Result = BeginThreadImpersonation ( a_OldContext , a_OldSecurity , a_Impersonating ) ;

			RevertToSelf () ;
		}
		else
		{
			t_Result = WBEM_E_ACCESS_DENIED ;
		}

		CloseHandle ( t_IdentifyToken ) ;
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT ProviderSubSystem_Globals :: End_IdentifyCall_PrvHost (

	WmiInternalContext a_InternalContext ,
	IUnknown *&a_OldContext ,
	IServerSecurity *&a_OldSecurity ,
	BOOL &a_Impersonating
)
{
	EndThreadImpersonation ( a_OldContext , a_OldSecurity , a_Impersonating ) ;

	RevertToSelf () ;

	return S_OK ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT ProviderSubSystem_Globals :: Begin_IdentifyCall_SvcHost (

	WmiInternalContext a_InternalContext ,
	BOOL &a_Impersonating ,
	IUnknown *&a_OldContext ,
	IServerSecurity *&a_OldSecurity
)
{
	HRESULT t_Result = WBEM_E_INVALID_PARAMETER ;

	if ( a_InternalContext.m_IdentifyHandle )
	{
		HANDLE t_IdentifyToken = NULL ;

		t_Result = CoImpersonateClient () ;
		if ( SUCCEEDED ( t_Result ) )
		{
			HANDLE t_CallerIdentifyToken = ( HANDLE ) a_InternalContext.m_IdentifyHandle ;
			DWORD t_ProcessIdentifier = a_InternalContext.m_ProcessIdentifier ;

			HANDLE t_ProcessHandle = OpenProcess (

				PROCESS_DUP_HANDLE ,
				FALSE ,
				t_ProcessIdentifier 
			) ;

			if ( t_ProcessHandle )
			{
				BOOL t_Status = DuplicateHandle (

					t_ProcessHandle ,
					t_CallerIdentifyToken ,
					GetCurrentProcess () ,
					& t_IdentifyToken ,
					MAXIMUM_ALLOWED | TOKEN_DUPLICATE | TOKEN_IMPERSONATE ,
					TRUE ,
					0
				) ;

				if ( t_Status )
				{
				}
				else
				{
					t_Result = WBEM_E_ACCESS_DENIED ;
				}
								
				CloseHandle ( t_ProcessHandle ) ;
			}
			else
			{
				t_Result = WBEM_E_ACCESS_DENIED ;
			}

			CoRevertToSelf () ;
		}

		if ( SUCCEEDED ( t_Result ) )
		{
			BOOL t_Status = SetThreadToken ( NULL , t_IdentifyToken ) ;
			if ( t_Status )
			{
				t_Result = BeginThreadImpersonation ( a_OldContext , a_OldSecurity , a_Impersonating ) ;

				CoRevertToSelf () ;

				RevertToSelf () ;
			}
			else
			{
				t_Result = WBEM_E_ACCESS_DENIED ;
			}

			CloseHandle ( t_IdentifyToken ) ;
		}
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT ProviderSubSystem_Globals :: End_IdentifyCall_SvcHost (

	WmiInternalContext a_InternalContext ,
	IUnknown *&a_OldContext ,
	IServerSecurity *&a_OldSecurity ,
	BOOL &a_Impersonating
)
{
	EndThreadImpersonation ( a_OldContext , a_OldSecurity , a_Impersonating ) ;

	RevertToSelf () ;

	return S_OK ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

LONG ProviderSubSystem_Globals :: Increment_Global_Object_Count ()
{
	return InterlockedIncrement ( & ProviderSubSystem_Globals :: s_ObjectsInProgress ) ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

LONG ProviderSubSystem_Globals :: Decrement_Global_Object_Count ()
{
	LONG t_Count = InterlockedDecrement ( & ProviderSubSystem_Globals :: s_ObjectsInProgress ) ;

#ifdef WMIASLOCAL
#ifdef DBG
	if ( t_Count == 1 )
	{
		SetObjectDestruction () ;
	}
#else
	if ( ProviderSubSystem_Globals :: s_CServerObject_Host_ObjectsInProgress == 0 )
	{
		SetObjectDestruction () ;
	}
#endif
#endif

	return t_Count ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\provsubsys\rpcexample\include\sthread.h ===
/*++

Copyright (C) 1996-2001 Microsoft Corporation

Module Name:

	ProvFact.h

Abstract:


History:

--*/

#ifndef _SThread_H
#define _SThread_H

#include <Thread.h>

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

class ServerThread : public WmiThread < ULONG > 
{
private:

	WmiAllocator &m_Allocator ;

protected:

public:	/* Internal */

    ServerThread ( 

		WmiAllocator & a_Allocator
	) ;

    ~ServerThread () ;

	WmiStatusCode Initialize_Callback () ;

	WmiStatusCode UnInitialize_Callback () ;
};

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

class ServerTask_Execute : public WmiTask < ULONG > 
{
private:

	WmiAllocator &m_Allocator ;

protected:

public:	/* Internal */

    ServerTask_Execute ( WmiAllocator & a_Allocator ) ;
    ~ServerTask_Execute () ;

	WmiStatusCode Process ( WmiThread <ULONG> &a_Thread ) ;
};

#endif // _SThread_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\provsubsys\server\maindll.cpp ===
/*++

Copyright (C) 1996-2001 Microsoft Corporation

Module Name:

	MainDll.cpp

Abstract:


History:

--*/

#include "PreComp.h"
#include <wbemint.h>
#include <comdef.h>
#include <stdio.h>

#include <HelperFuncs.h>
#include <Logging.h>

#include <CGlobals.h>
#include "Globals.h"
#include "ClassFac.h"
#include "ProvResv.h"
#include "ProvFact.h"
#include "ProvSubS.h"
#include "ProvAggr.h"
#include "ProvLoad.h"
#include "ProvSelf.h"
#include "ProvHost.h"
#include "StrobeThread.h"
#include "ProvCache.h"
#include "Guids.h"

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HINSTANCE g_hInst=NULL;

CriticalSection s_CriticalSection(NOTHROW_LOCK) ;

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT DllStartup ()
{
	HRESULT t_Result = S_OK ;

#if 1
	WmiStatusCode t_StatusCode = WmiDebugLog :: Initialize ( *ProviderSubSystem_Globals :: s_Allocator ) ;
#else
	WmiStatusCode t_StatusCode = e_StatusCode_Success ;
#endif

	t_Result = ProviderSubSystem_Globals :: Initialize_SharedCounters () ;
	if ( FAILED ( t_Result ) )
	{
		t_Result = S_OK ;
	}

	if ( SUCCEEDED ( t_Result ) )
	{
		t_Result = ProviderSubSystem_Globals :: Initialize_Events () ;
		if ( SUCCEEDED ( t_Result ) )
		{
		}
		else
		{
			t_Result = WBEM_E_INVALID_PARAMETER ;
		}
	}

	if ( SUCCEEDED ( t_Result ) )
	{
		t_Result = ProviderSubSystem_Common_Globals :: CreateSystemAces () ;
	}

	if ( SUCCEEDED ( t_Result ) )
	{
		t_Result = ProviderSubSystem_Common_Globals :: CreateMethodSecurityDescriptor () ;
	}
		
	if ( SUCCEEDED ( t_Result ) )
	{
		ProviderSubSystem_Globals :: s_StrobeThread = new StrobeThread ( *ProviderSubSystem_Globals :: s_Allocator, ProviderSubSystem_Globals :: s_StrobeTimeout ) ;
	
		if ( ProviderSubSystem_Globals :: s_StrobeThread)
		{
			if (!Dispatcher::scheduleTimer(*ProviderSubSystem_Globals :: s_StrobeThread, ProviderSubSystem_Globals :: s_StrobeTimeout, 0 , WT_EXECUTELONGFUNCTION))
				{
				ProviderSubSystem_Globals :: s_StrobeThread->Release();
				ProviderSubSystem_Globals :: s_StrobeThread=0;
				t_Result = WBEM_E_OUT_OF_MEMORY;
				}
			else
				ProviderSubSystem_Globals :: s_StrobeThread->Release();
		}
	}

	if ( SUCCEEDED ( t_Result ) )
	{
		ProviderSubSystem_Globals :: s_CoFreeUnusedLibrariesEvent = OpenEvent (

			EVENT_ALL_ACCESS,
			FALSE,
			L"WINMGMT_PROVIDER_CANSHUTDOWN"
		) ;

		if ( ProviderSubSystem_Globals :: s_CoFreeUnusedLibrariesEvent == NULL )
		{
			t_Result = WBEM_E_UNEXPECTED ;
		}
	}

	if ( SUCCEEDED ( t_Result ) )
	{
		_IWmiCoreServices *t_CoreService = NULL ;

		t_Result = CoCreateInstance (

			CLSID_IWmiCoreServices ,
			NULL ,
			CLSCTX_INPROC_SERVER ,
			IID__IWmiCoreServices ,
			( void ** )  & t_CoreService
		) ;

		if ( SUCCEEDED ( t_Result ) )
		{
			IWbemServices *t_Service = NULL ;

			LONG t_Flags = WMICORE_FLAG_REPOSITORY | WMICORE_CLIENT_TYPE_PROVIDER ;

			t_Result = t_CoreService->GetServices (

				L"root" ,
				NULL,
				NULL,
				t_Flags ,
				IID_IWbemServices ,
				( void ** ) & t_Service
			) ;

			if ( SUCCEEDED ( t_Result ) )
			{
				CServerObject_GlobalRegistration t_Registration ;
				t_Result = t_Registration.SetContext (

					NULL ,
					NULL ,
					t_Service
				) ;
				
				if ( SUCCEEDED ( t_Result ) )
				{
					t_Result = t_Registration.Load (

						e_All
					) ;

					if ( SUCCEEDED ( t_Result ) )
					{
						ProviderSubSystem_Globals :: s_StrobeTimeout = t_Registration.GetUnloadTimeoutMilliSeconds () >> 1 ;
						ProviderSubSystem_Globals :: s_InternalCacheTimeout = t_Registration.GetUnloadTimeoutMilliSeconds () ;
						ProviderSubSystem_Globals :: s_ObjectCacheTimeout = t_Registration.GetObjectUnloadTimeoutMilliSeconds () ;
						ProviderSubSystem_Globals :: s_EventCacheTimeout = t_Registration.GetEventUnloadTimeoutMilliSeconds () ;
					}
				}

				if ( SUCCEEDED ( t_Result ) )
				{
					CServerObject_HostQuotaRegistration t_Registration ;
					t_Result = t_Registration.SetContext (

						NULL ,
						NULL ,
						t_Service
					) ;
					
					if ( SUCCEEDED ( t_Result ) )
					{
						t_Result = t_Registration.Load (

							e_All
						) ;

						if ( SUCCEEDED ( t_Result ) )
						{
							ProviderSubSystem_Globals ::s_Quota_ProcessLimitCount = t_Registration.GetProcessLimitAllHosts () ;
							ProviderSubSystem_Globals ::s_Quota_ProcessMemoryLimitCount = t_Registration.GetMemoryPerHost () ;
							ProviderSubSystem_Globals ::s_Quota_JobMemoryLimitCount = t_Registration.GetMemoryAllHosts () ;
							ProviderSubSystem_Globals ::s_Quota_HandleCount = t_Registration.GetHandlesPerHost () ;
							ProviderSubSystem_Globals ::s_Quota_NumberOfThreads = t_Registration.GetThreadsPerHost () ;
							ProviderSubSystem_Globals ::s_Quota_PrivatePageCount = t_Registration.GetMemoryPerHost () ;
						}
					}
				}

				t_Service->Release () ;
			}

			t_CoreService->Release () ;
		}
	}

	if ( SUCCEEDED ( t_Result ) )
	{
		t_Result = ProviderSubSystem_Globals :: CreateJobObject () ;
	}

	if ( SUCCEEDED ( t_Result ) )
	{
		ProviderSubSystem_Globals :: s_Initialized = 1 ;
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT DllShutdown ()
{
	HRESULT t_Result = S_OK ;

	Dispatcher::cancelTimer(*ProviderSubSystem_Globals :: s_StrobeThread);
	Dispatcher::close();
	
	ProviderSubSystem_Globals :: s_StrobeThread = 0;

	t_Result = ProviderSubSystem_Globals :: UnInitialize_Events () ;

	t_Result = ProviderSubSystem_Globals :: UnInitialize_SharedCounters () ;

	if ( ProviderSubSystem_Globals :: s_CoFreeUnusedLibrariesEvent )
	{
		CloseHandle ( ProviderSubSystem_Globals :: s_CoFreeUnusedLibrariesEvent ) ;
		ProviderSubSystem_Globals :: s_CoFreeUnusedLibrariesEvent = NULL ;
	}

	t_Result = ProviderSubSystem_Common_Globals :: DeleteMethodSecurityDescriptor () ;

	t_Result = ProviderSubSystem_Common_Globals :: DeleteSystemAces () ;

#if 0
	WmiStatusCode t_StatusCode = WmiDebugLog :: UnInitialize ( m_Allocator ) ;
#endif

	t_Result = ProviderSubSystem_Globals :: DeleteJobObject () ;

	ProviderSubSystem_Globals :: s_Initialized = 0 ;

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

BOOL APIENTRY DllMain (

	HINSTANCE hInstance, 
	ULONG ulReason , 
	LPVOID pvReserved
)
{
	g_hInst=hInstance;

	BOOL t_Status = TRUE ;

    if ( DLL_PROCESS_DETACH == ulReason )
	{
		HRESULT t_Result = ProviderSubSystem_Globals :: Global_Shutdown () ;
		if ( SUCCEEDED ( t_Result ) )
		{
			t_Status = TRUE ;
		}
		else
		{
			t_Status = FALSE ;
		}

		WmiHelper :: DeleteCriticalSection ( & s_CriticalSection ) ;

		t_Status = TRUE ;
    }
    else if ( DLL_PROCESS_ATTACH == ulReason )
	{
		DisableThreadLibraryCalls ( hInstance ) ;

		WmiStatusCode t_StatusCode = WmiHelper :: InitializeCriticalSection ( & s_CriticalSection ) ;
		if ( t_StatusCode == e_StatusCode_Success )
		{
			HRESULT t_Result = ProviderSubSystem_Globals :: Global_Startup () ;
			if ( SUCCEEDED ( t_Result ) )
			{
				t_Status = TRUE ;
			}
			else
			{
				t_Status = FALSE ;
			}
		}
		else
		{
			t_Status = FALSE ;
		}
    }
    else if ( DLL_THREAD_DETACH == ulReason )
	{
		t_Status = TRUE ;
    }
    else if ( DLL_THREAD_ATTACH == ulReason )
	{
		t_Status = TRUE ;
    }

    return t_Status ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

STDAPI DllGetClassObject (

	REFCLSID rclsid , 
	REFIID riid, 
	void **ppv 
)
{
	HRESULT t_Result = S_OK ; 

	WmiStatusCode t_StatusCode = WmiHelper :: EnterCriticalSection ( & s_CriticalSection , FALSE ) ;
	if ( t_StatusCode == e_StatusCode_Success )
	{
		if ( ProviderSubSystem_Globals :: s_Initialized == 0 )
		{
			DllStartup () ;
		}

		if ( rclsid == CLSID_WmiProvSS ) 
		{
			CServerProvSubSysClassFactory *lpunk = new CServerProvSubSysClassFactory ;
			if ( lpunk == NULL )
			{
				t_Result = E_OUTOFMEMORY ;
			}
			else
			{
				t_Result = lpunk->QueryInterface ( riid , ppv ) ;
				if ( FAILED ( t_Result ) )
				{
					delete lpunk ;				
				}
				else
				{
				}			
			}
		}
		else if ( rclsid == CLSID_WmiProviderBindingFactory ) 
		{
			CServerClassFactory <CServerObject_BindingFactory,_IWmiProviderFactory> *lpunk = new CServerClassFactory <CServerObject_BindingFactory,_IWmiProviderFactory> ;
			if ( lpunk == NULL )
			{
				t_Result = E_OUTOFMEMORY ;
			}
			else
			{
				t_Result = lpunk->QueryInterface ( riid , ppv ) ;
				if ( FAILED ( t_Result ) )
				{
					delete lpunk ;				
				}
				else
				{
				}			
			}
		}
		else if ( rclsid == CLSID_WmiProviderInProcFactory ) 
		{
			CServerClassFactory <CServerObject_RawFactory,_IWmiProviderFactory> *lpunk = new CServerClassFactory <CServerObject_RawFactory,_IWmiProviderFactory> ;
			if ( lpunk == NULL )
			{
				t_Result = E_OUTOFMEMORY ;
			}
			else
			{
				t_Result = lpunk->QueryInterface ( riid , ppv ) ;
				if ( FAILED ( t_Result ) )
				{
					delete lpunk ;				
				}
				else
				{
				}			
			}
		}
		else if ( rclsid == CLSID_ProvSubSys_Provider ) 
		{
			CServerClassFactory <CServerObject_IWbemServices,IWbemServices> *lpunk = new CServerClassFactory <CServerObject_IWbemServices,IWbemServices> ;
			if ( lpunk == NULL )
			{
				t_Result = E_OUTOFMEMORY ;
			}
			else
			{
				t_Result = lpunk->QueryInterface ( riid , ppv ) ;
				if ( FAILED ( t_Result ) )
				{
					delete lpunk ;				
				}
				else
				{
				}			
			}
		}
		else
		{
			t_Result = CLASS_E_CLASSNOTAVAILABLE ;
		}

		WmiHelper :: LeaveCriticalSection ( & s_CriticalSection ) ;
	}
	else
	{
		t_Result = E_OUTOFMEMORY ;
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

STDAPI DllCanUnloadNow ()
{

/* 
 * Place code in critical section
 */
	WmiStatusCode t_StatusCode = WmiHelper :: EnterCriticalSection ( & s_CriticalSection , FALSE ) ;
	if ( t_StatusCode == e_StatusCode_Success )
	{	
		BOOL unload = ( 
						ProviderSubSystem_Globals :: s_LocksInProgress || ProviderSubSystem_Globals :: s_ObjectsInProgress 
					) ;
		unload = ! unload ;

		if ( unload )
		{
			DllShutdown () ;
		}

		WmiHelper :: LeaveCriticalSection ( & s_CriticalSection ) ;

		return unload ? ResultFromScode ( S_OK ) : ResultFromScode ( S_FALSE ) ;
	}
	else
	{
		return FALSE ;
	}
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT SetApplicationSecurity ( HKEY a_Key , LPCWSTR a_Name , DWORD a_Access ) 
{
	HRESULT t_Result = S_OK ;

	SID_IDENTIFIER_AUTHORITY t_NtAuthoritySid = SECURITY_NT_AUTHORITY ;

	PSID t_Administrator_Sid = NULL ;
	ACCESS_ALLOWED_ACE *t_Administrator_ACE = NULL ;
	WORD t_Administrator_ACESize = 0 ;

	BOOL t_BoolResult = AllocateAndInitializeSid (

		& t_NtAuthoritySid ,
		2 ,
		SECURITY_BUILTIN_DOMAIN_RID,
		DOMAIN_ALIAS_RID_ADMINS,
		0,
		0,
		0,
		0,
		0,
		0,
		& t_Administrator_Sid
	);

	if ( t_BoolResult )
	{
		DWORD t_SidLength = ::GetLengthSid ( t_Administrator_Sid );
		t_Administrator_ACESize = sizeof(ACCESS_ALLOWED_ACE) + (WORD) ( t_SidLength - sizeof(DWORD) ) ;
		t_Administrator_ACE = (ACCESS_ALLOWED_ACE*) new BYTE [ t_Administrator_ACESize ] ;
		if ( t_Administrator_ACE )
		{
			CopySid ( t_SidLength, (PSID) & t_Administrator_ACE->SidStart, t_Administrator_Sid ) ;
			t_Administrator_ACE->Mask = a_Access;
			t_Administrator_ACE->Header.AceType = 0 ;
			t_Administrator_ACE->Header.AceFlags = 3 ;
			t_Administrator_ACE->Header.AceSize = t_Administrator_ACESize ;
		}
		else
		{
			t_Result = E_OUTOFMEMORY ;
		}
	}
	else
	{
		DWORD t_LastError = ::GetLastError();

		t_Result = E_OUTOFMEMORY ;
	}

	PSID t_Interactive_Sid = NULL ;
	ACCESS_ALLOWED_ACE *t_Interactive_ACE = NULL ;
	WORD t_Interactive_ACESize = 0 ;

	t_BoolResult = AllocateAndInitializeSid (

		& t_NtAuthoritySid ,
		1 ,
		SECURITY_INTERACTIVE_RID,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		& t_Interactive_Sid
	);

	if ( t_BoolResult )
	{
		DWORD t_SidLength = ::GetLengthSid ( t_Interactive_Sid );
		t_Interactive_ACESize = sizeof(ACCESS_ALLOWED_ACE) + (WORD) ( t_SidLength - sizeof(DWORD) ) ;
		t_Interactive_ACE = (ACCESS_ALLOWED_ACE*) new BYTE [ t_Interactive_ACESize ] ;
		if ( t_Interactive_ACE )
		{
			CopySid ( t_SidLength, (PSID) & t_Interactive_ACE->SidStart, t_Interactive_Sid ) ;
			t_Interactive_ACE->Mask = a_Access;
			t_Interactive_ACE->Header.AceType = 0 ;
			t_Interactive_ACE->Header.AceFlags = 3 ;
			t_Interactive_ACE->Header.AceSize = t_Interactive_ACESize ;
		}
		else
		{
			t_Result = E_OUTOFMEMORY ;
		}
	}
	else
	{
		DWORD t_LastError = ::GetLastError();

		t_Result = E_OUTOFMEMORY ;
	}

	PSID t_System_Sid = NULL ;
	ACCESS_ALLOWED_ACE *t_System_ACE = NULL ;
	WORD t_System_ACESize = 0 ;

	t_BoolResult = AllocateAndInitializeSid (

		& t_NtAuthoritySid ,
		1 ,
		SECURITY_LOCAL_SYSTEM_RID,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		& t_System_Sid
	);

	if ( t_BoolResult )
	{
		DWORD t_SidLength = ::GetLengthSid ( t_System_Sid );
		t_System_ACESize = sizeof(ACCESS_ALLOWED_ACE) + (WORD) ( t_SidLength - sizeof(DWORD) ) ;
		t_System_ACE = (ACCESS_ALLOWED_ACE*) new BYTE [ t_System_ACESize ] ;
		if ( t_System_ACE )
		{
			CopySid ( t_SidLength, (PSID) & t_System_ACE->SidStart, t_System_Sid ) ;
			t_System_ACE->Mask = a_Access;
			t_System_ACE->Header.AceType = 0 ;
			t_System_ACE->Header.AceFlags = 3 ;
			t_System_ACE->Header.AceSize = t_System_ACESize ;
		}
		else
		{
			t_Result = E_OUTOFMEMORY ;
		}
	}
	else
	{
		DWORD t_LastError = ::GetLastError();

		t_Result = E_OUTOFMEMORY ;
	}

	PSID t_LocalService_Sid = NULL ;
	ACCESS_ALLOWED_ACE *t_LocalService_ACE = NULL ;
	WORD t_LocalService_ACESize = 0 ;

	t_BoolResult = AllocateAndInitializeSid (

		& t_NtAuthoritySid ,
		1 ,
		SECURITY_LOCAL_SERVICE_RID,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		& t_LocalService_Sid
	);

	if ( t_BoolResult )
	{
		DWORD t_SidLength = ::GetLengthSid ( t_LocalService_Sid );
		t_LocalService_ACESize = sizeof(ACCESS_ALLOWED_ACE) + (WORD) ( t_SidLength - sizeof(DWORD) ) ;
		t_LocalService_ACE = (ACCESS_ALLOWED_ACE*) new BYTE [ t_LocalService_ACESize ] ;
		if ( t_LocalService_ACE )
		{
			CopySid ( t_SidLength, (PSID) & t_LocalService_ACE->SidStart, t_LocalService_Sid ) ;
			t_LocalService_ACE->Mask = a_Access;
			t_LocalService_ACE->Header.AceType = 0 ;
			t_LocalService_ACE->Header.AceFlags = 3 ;
			t_LocalService_ACE->Header.AceSize = t_LocalService_ACESize ;
		}
		else
		{
			t_Result = E_OUTOFMEMORY ;
		}
	}
	else
	{
		DWORD t_LastError = ::GetLastError();

		t_Result = E_OUTOFMEMORY ;
	}

	PSID t_NetworkService_Sid = NULL ;
	ACCESS_ALLOWED_ACE *t_NetworkService_ACE = NULL ;
	WORD t_NetworkService_ACESize = 0 ;

	t_BoolResult = AllocateAndInitializeSid (

		& t_NtAuthoritySid ,
		1 ,
		SECURITY_NETWORK_SERVICE_RID,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		& t_NetworkService_Sid
	);

	if ( t_BoolResult )
	{
		DWORD t_SidLength = ::GetLengthSid ( t_NetworkService_Sid );
		t_NetworkService_ACESize = sizeof(ACCESS_ALLOWED_ACE) + (WORD) ( t_SidLength - sizeof(DWORD) ) ;
		t_NetworkService_ACE = (ACCESS_ALLOWED_ACE*) new BYTE [ t_NetworkService_ACESize ] ;
		if ( t_NetworkService_ACE )
		{
			CopySid ( t_SidLength, (PSID) & t_NetworkService_ACE->SidStart, t_NetworkService_Sid ) ;
			t_NetworkService_ACE->Mask = a_Access;
			t_NetworkService_ACE->Header.AceType = 0 ;
			t_NetworkService_ACE->Header.AceFlags = 3 ;
			t_NetworkService_ACE->Header.AceSize = t_NetworkService_ACESize ;
		}
		else
		{
			t_Result = E_OUTOFMEMORY ;
		}
	}
	else
	{
		DWORD t_LastError = ::GetLastError();

		t_Result = E_OUTOFMEMORY ;
	}

	// Now we need to set permissions on the registry: Everyone read; Admins full.
	// We have the sid for admins from the above code.  Now get the sid for "Everyone"

	DWORD t_TotalAclSize = sizeof(ACL) + t_Administrator_ACESize + t_Interactive_ACESize + t_LocalService_ACESize + 
										 t_NetworkService_ACESize + t_System_ACESize ;
	PACL t_Dacl = (PACL) new BYTE [ t_TotalAclSize ] ;
	if ( t_Dacl )
	{
		if ( :: InitializeAcl ( t_Dacl, t_TotalAclSize, ACL_REVISION ) )
		{
			DWORD t_AceIndex = 0 ;

			if ( t_Interactive_ACESize && :: AddAce ( t_Dacl , ACL_REVISION , t_AceIndex , t_Interactive_ACE , t_Interactive_ACESize ) )
			{
				t_AceIndex ++ ;
			}

			if ( t_System_ACESize && :: AddAce ( t_Dacl , ACL_REVISION , t_AceIndex , t_System_ACE , t_System_ACESize ) )
			{
				t_AceIndex ++ ;
			}

			if ( t_LocalService_ACESize && :: AddAce ( t_Dacl , ACL_REVISION , t_AceIndex , t_LocalService_ACE , t_LocalService_ACESize ) )
			{
				t_AceIndex ++ ;
			}

			if ( t_NetworkService_ACESize && :: AddAce ( t_Dacl , ACL_REVISION , t_AceIndex , t_NetworkService_ACE , t_NetworkService_ACESize ) )
			{
				t_AceIndex ++ ;
			}
			
			if ( t_Administrator_ACESize && :: AddAce ( t_Dacl , ACL_REVISION , t_AceIndex , t_Administrator_ACE , t_Administrator_ACESize ) )
			{
				t_AceIndex ++ ;
			}

			SECURITY_INFORMATION t_SecurityInfo = 0L;

			t_SecurityInfo |= DACL_SECURITY_INFORMATION;
			t_SecurityInfo |= PROTECTED_DACL_SECURITY_INFORMATION;

			SECURITY_DESCRIPTOR t_SecurityDescriptor ;
			t_BoolResult = InitializeSecurityDescriptor ( & t_SecurityDescriptor , SECURITY_DESCRIPTOR_REVISION ) ;
			if ( t_BoolResult )
			{
				t_BoolResult = SetSecurityDescriptorDacl (

				  & t_SecurityDescriptor ,
				  TRUE ,
				  t_Dacl ,
				  FALSE
				) ;

				if ( t_BoolResult )
				{
					t_BoolResult = SetSecurityDescriptorOwner (

						& t_SecurityDescriptor ,
						t_System_Sid,
						FALSE 				
					) ;
				}

				if ( t_BoolResult )
				{
					t_BoolResult = SetSecurityDescriptorGroup (

						& t_SecurityDescriptor ,
						t_Administrator_Sid,
						FALSE 				
					) ;
				}

				if ( t_BoolResult )
				{
					DWORD t_Length = GetSecurityDescriptorLength ( & t_SecurityDescriptor ) ;

					SECURITY_DESCRIPTOR *t_RelativeSecurityDescriptor = ( SECURITY_DESCRIPTOR * ) new BYTE [ t_Length ];
;					if ( t_RelativeSecurityDescriptor )
					{
						t_BoolResult = MakeSelfRelativeSD (

							& t_SecurityDescriptor ,
							t_RelativeSecurityDescriptor ,
							& t_Length 
						);

						if ( t_BoolResult )
						{
							DWORD t_ValueType = REG_BINARY ;
							DWORD t_DataSize = t_Length ;

							LONG t_RegResult = RegSetValueEx (

							  a_Key ,
							  a_Name ,
							  0 ,
							  t_ValueType ,
							  LPBYTE ( t_RelativeSecurityDescriptor ) ,
							  t_DataSize 
							) ;

							if ( t_RegResult != ERROR_SUCCESS ) 
							{
								t_Result = E_FAIL ;
							}
						}

						delete [] t_RelativeSecurityDescriptor ;
					}
					else
					{
						t_Result = E_OUTOFMEMORY ;
					}
				}
				else
				{
					t_Result = E_FAIL ;	
				}
			}
			else
			{
				t_Result = E_FAIL ;	
			}
		}

		delete [] ( ( BYTE * ) t_Dacl ) ;
	}
	else
	{
		t_Result = E_OUTOFMEMORY ;
	}

	if ( t_Administrator_ACE )
	{
		delete [] ( ( BYTE * ) t_Administrator_ACE ) ;
	}

	if ( t_Interactive_ACE )
	{
		delete [] ( ( BYTE * ) t_Interactive_ACE ) ;
	}

	if ( t_System_ACE )
	{
		delete [] ( ( BYTE * ) t_System_ACE ) ;
	}

	if ( t_LocalService_ACE )
	{
		delete [] ( ( BYTE * ) t_LocalService_ACE ) ;
	}

	if ( t_NetworkService_ACE )
	{
		delete [] ( ( BYTE * ) t_NetworkService_ACE ) ;
	}

	if ( t_Interactive_Sid )
	{
		FreeSid ( t_Interactive_Sid ) ;
	}

	if ( t_System_Sid )
	{
		FreeSid ( t_System_Sid ) ;
	}

	if ( t_LocalService_Sid )
	{
		FreeSid ( t_LocalService_Sid ) ;
	}

	if ( t_NetworkService_Sid )
	{
		FreeSid ( t_NetworkService_Sid ) ;
	}

	if ( t_Administrator_Sid )
	{
		FreeSid ( t_Administrator_Sid ) ;
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

//Strings used during self registeration


#define REG_FORMAT_STR			L"%s\\%s"
#define NOT_INSERT_STR			L"NotInsertable"
#define INPROC32_STR			L"InprocServer32"
#define LOCALSERVER32_STR		L"LocalServer32"
#define THREADING_MODULE_STR	L"ThreadingModel"
#define APARTMENT_STR			L"Both"
#define APPID_VALUE_STR			L"AppId"
#define APPID_STR				L"APPID\\"
#define CLSID_STR				L"CLSID\\"

#define WMI_PROVIDER_SUBSYSTEM				__TEXT("Microsoft WMI Provider Subsystem")
#define WMI_PROVIDER_HOST					__TEXT("Microsoft WMI Provider Subsystem Host")
#define WMI_PROVIDER_BINDINGFACTORY			__TEXT("Microsoft WMI Provider Subsystem Binding Factory")
#define WMI_PROVIDER_INPROCFACTORY			__TEXT("Microsoft WMI Provider Subsystem InProc Factory")
#define WMI_PROVIDER_HOSTINPROCFACTORY		__TEXT("Microsoft WMI Provider Subsystem Host InProc Factory")
#define WMI_PROVIDER						__TEXT("Microsoft WMI Provider Subsystem Self Instrumentation")
#define WMI_REFRESHER_MANAGER				__TEXT("Microsoft WMI Provider Subsystem Refresher Manager")

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

BOOL SetKeyAndValue ( wchar_t *pszKey , wchar_t *pszSubkey , wchar_t *pszValueName , wchar_t *pszValue )
{
    HKEY hKey;
    wchar_t szKey[256];

	wcscpy ( szKey , pszKey ) ;

    if ( NULL != pszSubkey )
    {
		wcscat ( szKey , L"\\" ) ;
        wcscat ( szKey , pszSubkey ) ;
    }

    if ( ERROR_SUCCESS != RegCreateKeyEx ( 

			HKEY_CLASSES_ROOT , 
			szKey , 
			0, 
			NULL, 
			REG_OPTION_NON_VOLATILE ,
			KEY_ALL_ACCESS, 
			NULL, 
			&hKey, 
			NULL
		)
	)
	{
        return FALSE ;
	}

    if ( NULL != pszValue )
    {
        if ( ERROR_SUCCESS != RegSetValueEx (

				hKey, 
				pszValueName, 
				0, 
				REG_SZ, 
				(BYTE *) pszValue , 
				(lstrlen(pszValue)+1)*sizeof(wchar_t)
			)
		)
		{
			return FALSE;
		}
    }

    RegCloseKey ( hKey ) ;

    return TRUE;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

STDAPI RegisterServer ( 

	BOOL a_Local , 
	BOOL a_InProc , 
	GUID a_ProviderClassId , 
	wchar_t *a_ProviderName ,
	wchar_t *a_ExecutableArguments
)
{
	wchar_t t_Executable [512];
	DWORD t_Length = GetModuleFileName (

		g_hInst , 
		( wchar_t * ) t_Executable , 
		sizeof ( t_Executable ) / sizeof ( wchar_t )
	) ;

	if ( t_Length )
	{
		if ( a_ExecutableArguments )
		{
			wcscat ( t_Executable , L" " ) ;
			wcscat ( t_Executable , a_ExecutableArguments ) ;
		}

		wchar_t szProviderClassID[128];
		wchar_t szProviderCLSIDClassID[128];

		int iRet = StringFromGUID2(a_ProviderClassId,szProviderClassID, 128);

		if ( a_Local )
		{
			TCHAR szProviderCLSIDAppID[128];
			wcscpy(szProviderCLSIDAppID,APPID_STR);
			wcscat(szProviderCLSIDAppID,szProviderClassID);

			if (FALSE ==SetKeyAndValue(szProviderCLSIDAppID, NULL, NULL, a_ProviderName ))
				return SELFREG_E_CLASS;

			HKEY t_Key ;
			DWORD t_Disposition = 0 ;

			LONG t_RegResult = RegOpenKeyEx (

				HKEY_CLASSES_ROOT ,
				szProviderCLSIDAppID ,
				NULL ,
				KEY_READ | KEY_WRITE ,
				& t_Key
			) ;

			if ( t_RegResult == ERROR_SUCCESS )
			{
				HRESULT t_Result = SetApplicationSecurity ( t_Key , L"LaunchPermission" , COM_RIGHTS_EXECUTE ) ;

				RegCloseKey ( t_Key ) ;

				if ( FAILED ( t_Result ) )
				{
					return SELFREG_E_CLASS;
				}
			}
			else
			{
				return SELFREG_E_CLASS;
			}
		}

		wcscpy(szProviderCLSIDClassID,CLSID_STR);
		wcscat(szProviderCLSIDClassID,szProviderClassID);

		if ( a_Local )
		{
			if (FALSE ==SetKeyAndValue(szProviderCLSIDClassID, NULL , APPID_VALUE_STR, szProviderClassID ))
				return SELFREG_E_CLASS;
		}

			//Create entries under CLSID
		if (FALSE ==SetKeyAndValue(szProviderCLSIDClassID, NULL, NULL, a_ProviderName ))
			return SELFREG_E_CLASS;

		if (FALSE ==SetKeyAndValue(szProviderCLSIDClassID, NOT_INSERT_STR, NULL, NULL))
				return SELFREG_E_CLASS;

		if ( a_Local )
		{
			if (FALSE ==SetKeyAndValue(szProviderCLSIDClassID, LOCALSERVER32_STR, NULL,t_Executable))
				return SELFREG_E_CLASS;

			if (FALSE ==SetKeyAndValue(szProviderCLSIDClassID, LOCALSERVER32_STR,THREADING_MODULE_STR, APARTMENT_STR))
				return SELFREG_E_CLASS;
		}

		if ( a_InProc )
		{
			if (FALSE ==SetKeyAndValue(szProviderCLSIDClassID, INPROC32_STR, NULL,t_Executable))
				return SELFREG_E_CLASS;

			if (FALSE ==SetKeyAndValue(szProviderCLSIDClassID, INPROC32_STR,THREADING_MODULE_STR, APARTMENT_STR))
				return SELFREG_E_CLASS;
		}

		return S_OK;
	}
	else
	{
		return E_FAIL ;
	}
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

STDAPI UnregisterServer( BOOL a_Local , BOOL a_InProc , GUID a_ProviderClassId )
{
	wchar_t szTemp[128];

	wchar_t szProviderClassID[128];
	wchar_t szProviderCLSIDClassID[128];

	int iRet = StringFromGUID2(a_ProviderClassId ,szProviderClassID, 128);

	wcscpy(szProviderCLSIDClassID,CLSID_STR);
	wcscat(szProviderCLSIDClassID,szProviderClassID);

	//Delete entries under CLSID

	wsprintf(szTemp, REG_FORMAT_STR, szProviderCLSIDClassID, NOT_INSERT_STR);
	RegDeleteKey(HKEY_CLASSES_ROOT, szTemp);

	if ( a_Local )
	{
		TCHAR szProviderCLSIDAppID[128];
		wcscpy(szProviderCLSIDAppID,APPID_STR);
		wcscat(szProviderCLSIDAppID,szProviderClassID);

		//Delete entries under APPID

		DWORD t_Status = RegDeleteKey(HKEY_CLASSES_ROOT, szProviderCLSIDAppID);

		wcscpy(szProviderCLSIDAppID,APPID_STR);
		wcscat(szProviderCLSIDAppID,szProviderClassID);

		wsprintf(szTemp, REG_FORMAT_STR,szProviderCLSIDClassID, LOCALSERVER32_STR);
		t_Status = RegDeleteKey(HKEY_CLASSES_ROOT, szTemp);
	}

	if ( a_InProc )
	{
		wsprintf(szTemp, REG_FORMAT_STR,szProviderCLSIDClassID, INPROC32_STR);
		RegDeleteKey(HKEY_CLASSES_ROOT, szTemp);
	}

	RegDeleteKey(HKEY_CLASSES_ROOT, szProviderCLSIDClassID);

    return S_OK;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

STDAPI DllRegisterServer ()
{
	HRESULT t_Result ;

#ifdef WMIASLOCAL
	t_Result = RegisterServer ( TRUE , FALSE , CLSID_WmiProviderHost				,	WMI_PROVIDER_HOST , NULL ) ;
#else
	t_Result = RegisterServer ( FALSE , TRUE , CLSID_WmiProvSS						,	WMI_PROVIDER_SUBSYSTEM , NULL ) ;
	t_Result = RegisterServer ( FALSE , TRUE , CLSID_WmiProviderBindingFactory		,	WMI_PROVIDER_BINDINGFACTORY , NULL ) ;
	t_Result = RegisterServer ( FALSE , TRUE , CLSID_WmiProviderInProcFactory		,	WMI_PROVIDER_INPROCFACTORY , NULL ) ;
	t_Result = RegisterServer ( FALSE , TRUE , CLSID_ProvSubSys_Provider			,	WMI_PROVIDER , NULL ) ;
#endif

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

STDAPI DllUnregisterServer ()
{
	HRESULT t_Result ;

#ifdef WMIASLOCAL
	t_Result = UnregisterServer ( TRUE , FALSE , CLSID_WmiProviderHost ) ;
#else
	t_Result = UnregisterServer ( FALSE , TRUE , CLSID_WmiProvSS ) ;
	t_Result = UnregisterServer ( FALSE , TRUE , CLSID_WmiProviderBindingFactory ) ;
	t_Result = UnregisterServer ( FALSE , TRUE , CLSID_WmiProviderInProcFactory ) ;
	t_Result = UnregisterServer ( FALSE , TRUE , CLSID_ProvSubSys_Provider ) ;
#endif

	return t_Result ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\provsubsys\server\exclusion.cpp ===
/*++

Copyright (C) 1996-2001 Microsoft Corporation

Module Name:

	ProvFact.cpp

Abstract:


History:

--*/

#include "PreComp.h"
#include <wbemint.h>

#include "Globals.h"
#include "CGlobals.h"
#include "Exclusion.h"
#include "ProvFact.h"

#ifdef WMIASLOCAL
#include "Main.h"
#endif

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

Exclusion :: Exclusion (

	const ULONG &a_ReaderSize ,
	const ULONG &a_WriterSize ,
	const GUID &a_Guid ,
	const ULONG &a_Period ,
	CWbemGlobal_ExclusionController *a_Controller

) : ExclusionCacheElement (

		a_Controller ,
		a_Guid ,
		a_Period
	) ,
	m_Exclusion ( a_ReaderSize , a_WriterSize )
{
	InterlockedIncrement ( & ProviderSubSystem_Globals :: s_Exclusion_ObjectsInProgress ) ;

	ProviderSubSystem_Globals :: Increment_Global_Object_Count () ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

Exclusion::~Exclusion ()
{
	InterlockedDecrement ( & ProviderSubSystem_Globals :: s_Exclusion_ObjectsInProgress ) ;

	ProviderSubSystem_Globals :: Decrement_Global_Object_Count () ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

STDMETHODIMP_( ULONG ) Exclusion :: AddRef ( void )
{
	return ExclusionCacheElement :: AddRef () ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

STDMETHODIMP_( ULONG ) Exclusion :: Release ( void )
{
	return ExclusionCacheElement :: Release () ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

STDMETHODIMP Exclusion :: QueryInterface (

	REFIID iid , 
	LPVOID FAR *iplpv 
) 
{
	*iplpv = NULL ;

	if ( iid == IID_IUnknown )
	{
		*iplpv = ( LPVOID ) this ;
	}

	if ( *iplpv )
	{
		( ( LPUNKNOWN ) *iplpv )->AddRef () ;

		return ResultFromScode ( S_OK ) ;
	}
	else
	{
		return ResultFromScode ( E_NOINTERFACE ) ;
	}
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT Exclusion :: CreateAndCache (

	const GUID &a_Clsid ,
	Exclusion *&a_Exclusion 
)
{
	HRESULT t_Result = S_OK ;

	CWbemGlobal_ExclusionController *t_Controller = ProviderSubSystem_Globals :: GetExclusionController () ;

	CWbemGlobal_ExclusionController_Cache_Iterator t_Iterator ;

	t_Controller->Lock () ;

	WmiStatusCode t_StatusCode = t_Controller->Find ( a_Clsid , t_Iterator ) ;
	if ( t_StatusCode == e_StatusCode_Success )
	{
		a_Exclusion = ( Exclusion * ) t_Iterator.GetElement ();
	}
	else
	{
		a_Exclusion = new Exclusion ( 1 , 0x7FFFFFFF , a_Clsid , 10000 , t_Controller ) ;
		if ( a_Exclusion )
		{
			a_Exclusion->AddRef () ;

			t_StatusCode = t_Controller->Insert ( 

				*a_Exclusion ,
				t_Iterator
			) ;
		}
		else
		{
			t_Result = WBEM_E_OUT_OF_MEMORY ;
		}
	}

	t_Controller->UnLock () ;

	return t_Result ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\provsubsys\server\provaggr.cpp ===
/*++

Copyright (C) 1996-2001 Microsoft Corporation

Module Name:

	XXXX

Abstract:


History:

--*/

#include "PreComp.h"
#include <typeinfo.h>
#include <wbemint.h>
#include <Like.h>
#include "Globals.h"
#include "CGlobals.h"
#include "ProvAggr.h"
#include "ProvFact.h"
#include "ProvObSk.h"
#include "ProvInSk.h"
#include "ProvRegInfo.h"

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

CAggregator_IWbemProvider :: CAggregator_IWbemProvider (

	WmiAllocator &a_Allocator ,
	CWbemGlobal_IWmiProviderController *a_Controller , 
	_IWmiProviderFactory *a_Factory ,
	IWbemServices *a_CoreRepositoryStub ,
	IWbemServices *a_CoreFullStub ,
	const ProviderCacheKey &a_Key ,
	const ULONG &a_Period ,
	IWbemContext *a_InitializationContext

) :	CWbemGlobal_IWmiObjectSinkController ( a_Allocator ) ,
	ServiceCacheElement ( 

		a_Controller ,
		a_Key ,
		a_Period 
	) ,
	m_ReferenceCount ( 0 ) , 
	m_Allocator ( a_Allocator ) ,
	m_CoreRepositoryStub ( a_CoreRepositoryStub ) ,
	m_CoreFullStub ( a_CoreFullStub ) ,
	m_Factory ( a_Factory ) ,
	m_ClassProvidersCount ( 0 ) ,
	m_ClassProviders ( NULL ) ,
	m_User ( NULL ) ,
	m_Locale ( NULL ) ,
	m_Initialized ( 0 ) ,
	m_InitializeResult ( S_OK ) ,
	m_InitializedEvent ( NULL ) , 
	m_InitializationContext ( a_InitializationContext )
{
	InterlockedIncrement ( & ProviderSubSystem_Globals :: s_CAggregator_IWbemProvider_ObjectsInProgress ) ;

	ProviderSubSystem_Globals :: Increment_Global_Object_Count () ;

	if ( m_InitializationContext )
	{
		m_InitializationContext->AddRef () ;
	}

	if ( m_Factory ) 
	{
		m_Factory->AddRef () ;
	}

	if ( m_CoreRepositoryStub )
	{
		m_CoreRepositoryStub->AddRef () ;
	}

	if ( m_CoreFullStub )
	{
		m_CoreFullStub->AddRef () ;
	}
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

CAggregator_IWbemProvider :: ~CAggregator_IWbemProvider ()
{
#if 0
wchar_t t_Buffer [ 128 ] ;
wsprintf ( t_Buffer , L"\n%lx - ~CAggregator_IWbemProvider ( %lx ) " , GetTickCount () , this ) ;
OutputDebugString ( t_Buffer ) ;
#endif

	if ( m_Factory ) 
	{
		m_Factory->Release () ;
	}

	if ( m_CoreRepositoryStub )
	{
		m_CoreRepositoryStub->Release () ;
	}

	if ( m_CoreFullStub )
	{
		m_CoreFullStub->Release () ;
	}

	if ( m_User ) 
	{
		SysFreeString ( m_User ) ;
	}

	if ( m_Locale ) 
	{
		SysFreeString ( m_Locale ) ;
	}

	if ( m_ClassProviders )
	{
		for ( ULONG t_Index = 0 ; t_Index < m_ClassProvidersCount ; t_Index ++ )
		{
			if ( m_ClassProviders [ t_Index ] )
			{
				m_ClassProviders [ t_Index ]->Release () ;
			}
		}

		delete [] m_ClassProviders ;
	}

	if ( m_InitializationContext )
	{
		m_InitializationContext->Release () ;
	}

	if ( m_InitializedEvent )
	{
		CloseHandle ( m_InitializedEvent ) ;
	}

	WmiStatusCode t_StatusCode = CWbemGlobal_IWmiObjectSinkController :: UnInitialize () ;

	InterlockedDecrement ( & ProviderSubSystem_Globals :: s_CAggregator_IWbemProvider_ObjectsInProgress ) ;

	ProviderSubSystem_Globals :: Decrement_Global_Object_Count () ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CAggregator_IWbemProvider :: Initialize (

	long a_Flags ,
	IWbemContext *a_Context ,
	GUID *a_TransactionIdentifier,
	LPCWSTR a_User,
    LPCWSTR a_Locale,
	LPCWSTR a_Namespace ,
	IWbemServices *a_Repository ,
	IWbemServices *a_Service ,
	IWbemProviderInitSink *a_Sink     // For init signals
)
{
	HRESULT t_Result = S_OK ;

	WmiStatusCode t_StatusCode = CWbemGlobal_IWmiObjectSinkController :: Initialize () ;
	if ( t_StatusCode != e_StatusCode_Success ) 
	{
		t_Result = WBEM_E_OUT_OF_MEMORY ;
	}

	if ( SUCCEEDED ( t_Result ) )
	{
		m_InitializedEvent = CreateEvent ( NULL , TRUE , FALSE , NULL ) ;
		if ( m_InitializedEvent == NULL )
		{
			t_Result = t_Result = WBEM_E_OUT_OF_MEMORY ;
		}
	}

	if ( SUCCEEDED ( t_Result ) )
	{
		if ( a_User )
		{
			m_User = SysAllocString ( a_User ) ;
			if ( ! m_User ) 
			{
				t_Result = WBEM_E_OUT_OF_MEMORY ;
			}
		}
	}

	if ( SUCCEEDED ( t_Result ) )
	{
		if ( a_Locale )
		{
			m_Locale = SysAllocString ( a_Locale ) ;
			if ( ! m_Locale ) 
			{
				t_Result = WBEM_E_OUT_OF_MEMORY ;
			}
		}
	}

	a_Sink->SetStatus ( t_Result , 0 ) ;

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CAggregator_IWbemProvider :: IsIndependant ( IWbemContext *a_Context )
{
	BOOL t_DependantCall = FALSE ;
	HRESULT t_Result = ProviderSubSystem_Common_Globals :: IsDependantCall ( m_InitializationContext , a_Context , t_DependantCall ) ;
	if ( SUCCEEDED ( t_Result ) )
	{
		if ( t_DependantCall == FALSE )
		{
		}
		else
		{
			return S_FALSE ;
		}
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CAggregator_IWbemProvider :: WaitProvider ( IWbemContext *a_Context , ULONG a_Timeout )
{
	HRESULT t_Result = WBEM_E_UNEXPECTED ;

	if ( m_Initialized == 0 )
	{
		BOOL t_DependantCall = FALSE ;
		t_Result = ProviderSubSystem_Common_Globals :: IsDependantCall ( m_InitializationContext , a_Context , t_DependantCall ) ;
		if ( SUCCEEDED ( t_Result ) )
		{
			if ( t_DependantCall == FALSE )
			{
				if ( WaitForSingleObject ( m_InitializedEvent , a_Timeout ) == WAIT_TIMEOUT )
				{
					return WBEM_E_PROVIDER_LOAD_FAILURE ;
				}
			}
			else
			{
				if ( WaitForSingleObject ( m_InitializedEvent , 0 ) == WAIT_TIMEOUT )
				{
					return S_FALSE ;
				}
			}
		}
	}
	else
	{
		t_Result = S_OK ;
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CAggregator_IWbemProvider :: SetInitialized ( HRESULT a_InitializeResult )
{
	m_InitializeResult = a_InitializeResult ;

	InterlockedExchange ( & m_Initialized , 1 ) ;

	if ( m_InitializedEvent )
	{
		SetEvent ( m_InitializedEvent ) ;
	}

	return S_OK ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

STDMETHODIMP_(ULONG) CAggregator_IWbemProvider :: AddRef ( void )
{
	return ServiceCacheElement :: AddRef () ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

STDMETHODIMP_(ULONG) CAggregator_IWbemProvider :: Release ( void )
{
	return ServiceCacheElement :: Release () ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

STDMETHODIMP CAggregator_IWbemProvider :: QueryInterface (

	REFIID iid , 
	LPVOID FAR *iplpv 
) 
{
	*iplpv = NULL ;

	if ( iid == IID_IUnknown )
	{
		*iplpv = ( LPVOID ) this ;
	}
	else if ( iid == IID_IWbemServices )
	{
		*iplpv = ( LPVOID ) ( IWbemServices * ) this ;		
	}	
	else if ( iid == IID__IWmiProviderInitialize )
	{
		*iplpv = ( LPVOID ) ( _IWmiProviderInitialize * ) this ;		
	}
	else if ( iid == IID__IWmiProviderCache )
	{
		*iplpv = ( LPVOID ) ( _IWmiProviderCache * ) this ;
	}	
	else if ( iid == IID_IWbemShutdown )
	{
		*iplpv = ( LPVOID ) ( IWbemShutdown * ) this ;		
	}	
	else if ( iid == IID_CAggregator_IWbemProvider )
	{
		*iplpv = ( LPVOID ) ( CAggregator_IWbemProvider * ) this ;		
	}	
	else if ( iid == IID__IWmiProviderAssociatorsHelper )
	{
		*iplpv = ( LPVOID ) ( _IWmiProviderAssociatorsHelper * ) this ;		
	}

	if ( *iplpv )
	{
		( ( LPUNKNOWN ) *iplpv )->AddRef () ;

		return ResultFromScode ( S_OK ) ;
	}
	else
	{
		return ResultFromScode ( E_NOINTERFACE ) ;
	}
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

QueryPreprocessor :: QuadState CAggregator_IWbemProvider :: Get_RecursiveEvaluate ( 

	wchar_t *a_Class ,
	IWbemContext *a_Context , 
	WmiTreeNode *&a_Node
)
{
	QueryPreprocessor :: QuadState t_Status = QueryPreprocessor :: State_Undefined ;

	if ( a_Node ) 
	{
		if ( a_Node->GetType () == TypeId_WmiOrNode )
		{
			WmiTreeNode *t_Left = a_Node->GetLeft () ;
			WmiTreeNode *t_Right = a_Node->GetRight () ;

			if ( t_Left )
			{
				t_Status = Get_RecursiveEvaluate ( a_Class , a_Context , t_Left ) ;
				if ( t_Status == QueryPreprocessor :: State_False )
				{
					if ( t_Right )
					{
						t_Status = Get_RecursiveEvaluate ( a_Class , a_Context , t_Right ) ;
						return t_Status ;
					}
				}
			}
		}
		else if ( a_Node->GetType () == TypeId_WmiAndNode )
		{
			WmiTreeNode *t_Left = a_Node->GetLeft () ;
			WmiTreeNode *t_Right = a_Node->GetRight () ;

			if ( t_Left )
			{
				t_Status = Get_RecursiveEvaluate ( a_Class , a_Context , t_Left ) ;
				if ( ( t_Status == QueryPreprocessor :: State_True ) || ( t_Status == QueryPreprocessor :: State_Undefined ) )
				{
					if ( t_Right )
					{
						t_Status = Get_RecursiveEvaluate ( a_Class , a_Context , t_Right ) ;
						return t_Status ;
					}
				}
			}
		}
		else if ( a_Node->GetType () == TypeId_WmiNotNode )
		{
// Should never happen, failure in DFN evaluation otherwise
		}
		else if ( a_Node->GetType () == TypeId_WmiOperatorEqualNode )
		{
			WmiTreeNode *t_Left = a_Node->GetLeft () ;
			if ( t_Left )
			{
				if ( t_Left->GetType () == TypeId_WmiStringNode )
				{
					WmiStringNode *t_String = ( WmiStringNode * ) t_Left ;

					if ( _wcsicmp ( L"__Class" , t_String->GetPropertyName () ) == 0 )
					{
						if ( t_String->GetValue () && _wcsicmp ( a_Class , t_String->GetValue () ) == 0 )
						{
							t_Status = QueryPreprocessor :: State_True ;
						}
						else
						{
							t_Status = QueryPreprocessor :: State_False ;
						}
					}
				}
			}
			else
			{
// Should never happen, failure in DFN evaluation otherwise
			}
		}
		else if ( a_Node->GetType () == TypeId_WmiOperatorNotEqualNode )
		{
			WmiTreeNode *t_Left = a_Node->GetLeft () ;
			if ( t_Left )
			{
				if ( t_Left->GetType () == TypeId_WmiStringNode )
				{
					WmiStringNode *t_String = ( WmiStringNode * ) t_Left ;

					if ( _wcsicmp ( L"__Class" , t_String->GetPropertyName () ) == 0 )
					{
						if ( t_String->GetValue () && _wcsicmp ( a_Class , t_String->GetValue () ) != 0 )
						{
							t_Status = QueryPreprocessor :: State_True ;
						}
						else
						{
							t_Status = QueryPreprocessor :: State_False ;
						}
					}
				}
			}
			else
			{
// Should never happen, failure in DFN evaluation otherwise
			}
		}
		else if ( a_Node->GetType () == TypeId_WmiOperatorEqualOrGreaterNode )
		{
			WmiTreeNode *t_Left = a_Node->GetLeft () ;
			if ( t_Left )
			{
				if ( t_Left->GetType () == TypeId_WmiStringNode )
				{
					WmiStringNode *t_String = ( WmiStringNode * ) t_Left ;

					if ( _wcsicmp ( L"__Class" , t_String->GetPropertyName () ) == 0 )
					{
						if ( t_String->GetValue () && _wcsicmp ( a_Class , t_String->GetValue () ) >= 0 )
						{
							t_Status = QueryPreprocessor :: State_True ;
						}
						else
						{
							t_Status = QueryPreprocessor :: State_False ;
						}
					}
				}
			}
			else
			{
// Should never happen, failure in DFN evaluation otherwise
			}
		}
		else if ( a_Node->GetType () == TypeId_WmiOperatorEqualOrLessNode )
		{
			WmiTreeNode *t_Left = a_Node->GetLeft () ;
			if ( t_Left )
			{
				if ( t_Left->GetType () == TypeId_WmiStringNode )
				{
					WmiStringNode *t_String = ( WmiStringNode * ) t_Left ;

					if ( _wcsicmp ( L"__Class" , t_String->GetPropertyName () ) == 0 )
					{
						if ( t_String->GetValue () && _wcsicmp ( a_Class , t_String->GetValue () ) <= 0 )
						{
							t_Status = QueryPreprocessor :: State_True ;
						}
						else
						{
							t_Status = QueryPreprocessor :: State_False ;
						}
					}
				}
			}
			else
			{
// Should never happen, failure in DFN evaluation otherwise
			}
		}
		else if ( a_Node->GetType () == TypeId_WmiOperatorLessNode )
		{
			WmiTreeNode *t_Left = a_Node->GetLeft () ;
			if ( t_Left )
			{
				if ( t_Left->GetType () == TypeId_WmiStringNode )
				{
					WmiStringNode *t_String = ( WmiStringNode * ) t_Left ;

					if ( _wcsicmp ( L"__Class" , t_String->GetPropertyName () ) == 0 )
					{
						if ( t_String->GetValue () && _wcsicmp ( a_Class , t_String->GetValue () ) < 0 )
						{
							t_Status = QueryPreprocessor :: State_True ;
						}
						else
						{
							t_Status = QueryPreprocessor :: State_False ;
						}
					}
				}
			}
			else
			{
// Should never happen, failure in DFN evaluation otherwise
			}
		}
		else if ( a_Node->GetType () == TypeId_WmiOperatorGreaterNode )
		{
			WmiTreeNode *t_Left = a_Node->GetLeft () ;
			if ( t_Left )
			{
				if ( t_Left->GetType () == TypeId_WmiStringNode )
				{
					WmiStringNode *t_String = ( WmiStringNode * ) t_Left ;

					if ( _wcsicmp ( L"__Class" , t_String->GetPropertyName () ) == 0 )
					{
						if ( t_String->GetValue () && _wcsicmp ( a_Class , t_String->GetValue () ) > 0 )
						{
							t_Status = QueryPreprocessor :: State_True ;
						}
						else
						{
							t_Status = QueryPreprocessor :: State_False ;
						}
					}
				}
			}
			else
			{
// Should never happen, failure in DFN evaluation otherwise
			}
		}
		else if ( a_Node->GetType () == TypeId_WmiOperatorLikeNode )
		{
			WmiTreeNode *t_Left = a_Node->GetLeft () ;
			if ( t_Left )
			{
				if ( t_Left->GetType () == TypeId_WmiStringNode )
				{
					WmiStringNode *t_String = ( WmiStringNode * ) t_Left ;

					if ( _wcsicmp ( L"__Class" , t_String->GetPropertyName () ) == 0 )
					{
						CLike t_Like ( t_String->GetValue () ) ;
						if ( t_Like.Match ( a_Class ) )
						{
							t_Status = QueryPreprocessor :: State_True ;
						}
						else
						{
							t_Status = QueryPreprocessor :: State_False ;
						}
					}
				}
			}
			else
			{
// Should never happen, failure in DFN evaluation otherwise
			}
		}
		else if ( a_Node->GetType () == TypeId_WmiOperatorNotLikeNode )
		{
			WmiTreeNode *t_Left = a_Node->GetLeft () ;
			if ( t_Left )
			{
				if ( t_Left->GetType () == TypeId_WmiStringNode )
				{
					WmiStringNode *t_String = ( WmiStringNode * ) t_Left ;

					if ( _wcsicmp ( L"__Class" , t_String->GetPropertyName () ) == 0 )
					{
						CLike t_Like ( t_String->GetValue () ) ;
						if ( ! t_Like.Match ( a_Class ) )
						{
							t_Status = QueryPreprocessor :: State_True ;
						}
						else
						{
							t_Status = QueryPreprocessor :: State_False ;
						}
					}
				}
			}
			else
			{
// Should never happen, failure in DFN evaluation otherwise
			}
		}
		else if ( a_Node->GetType () == TypeId_WmiOperatorIsANode )
		{
			WmiTreeNode *t_Left = a_Node->GetLeft () ;
			if ( t_Left )
			{
			}
			else
			{
// Should never happen, failure in DFN evaluation otherwise
			}
		}
		else if ( a_Node->GetType () == TypeId_WmiOperatorNotIsANode )
		{
			WmiTreeNode *t_Left = a_Node->GetLeft () ;
			if ( t_Left )
			{
			}
			else
			{
// Should never happen, failure in DFN evaluation otherwise
			}
		}
		else
		{
// Should never happen, failure in DFN evaluation otherwise
		}
	}

	return t_Status ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

QueryPreprocessor :: QuadState CAggregator_IWbemProvider :: Get_Evaluate (

	wchar_t *a_Class ,
	IWbemContext *a_Context , 
	WmiTreeNode *&a_Root
)
{
	QueryPreprocessor :: QuadState t_Status = Get_RecursiveEvaluate ( a_Class , a_Context , a_Root ) ;
	return t_Status ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

QueryPreprocessor :: QuadState CAggregator_IWbemProvider :: EnumDeep_RecursiveEvaluate ( 

	IWbemClassObject *a_Class ,
	IWbemContext *a_Context , 
	WmiTreeNode *&a_Node
)
{
	QueryPreprocessor :: QuadState t_Status = QueryPreprocessor :: State_Undefined ;

	if ( a_Node ) 
	{
		if ( a_Node->GetType () == TypeId_WmiOrNode )
		{
			WmiTreeNode *t_Left = a_Node->GetLeft () ;
			WmiTreeNode *t_Right = a_Node->GetRight () ;

			if ( t_Left )
			{
				t_Status = EnumDeep_RecursiveEvaluate ( a_Class , a_Context , t_Left ) ;
				if ( t_Status == QueryPreprocessor :: State_False )
				{
					if ( t_Right )
					{
						t_Status = EnumDeep_RecursiveEvaluate ( a_Class , a_Context , t_Right ) ;
						return t_Status ;
					}
				}
			}
		}
		else if ( a_Node->GetType () == TypeId_WmiAndNode )
		{
			WmiTreeNode *t_Left = a_Node->GetLeft () ;
			WmiTreeNode *t_Right = a_Node->GetRight () ;

			if ( t_Left )
			{
				t_Status = EnumDeep_RecursiveEvaluate ( a_Class , a_Context , t_Left ) ;
				if ( ( t_Status == QueryPreprocessor :: State_True ) || ( t_Status == QueryPreprocessor :: State_Undefined ) )
				{
					if ( t_Right )
					{
						t_Status = EnumDeep_RecursiveEvaluate ( a_Class , a_Context , t_Right ) ;
						return t_Status ;
					}
				}
			}
		}
		else if ( a_Node->GetType () == TypeId_WmiNotNode )
		{
// Should never happen, failure in DFN evaluation otherwise
		}
		else if ( a_Node->GetType () == TypeId_WmiOperatorEqualNode )
		{
			WmiTreeNode *t_Left = a_Node->GetLeft () ;
			if ( t_Left )
			{
				if ( t_Left->GetType () == TypeId_WmiStringNode )
				{
					WmiStringNode *t_String = ( WmiStringNode * ) t_Left ;

					if ( _wcsicmp ( L"__SuperClass" , t_String->GetPropertyName () ) == 0 )
					{
						VARIANT t_Variant ;
						VariantInit ( & t_Variant ) ;

						LONG t_VarType = 0 ;
						LONG t_Flavour = 0 ;

						HRESULT t_Result = a_Class->Get ( L"__SuperClass" , 0 , & t_Variant , & t_VarType , & t_Flavour ) ;
						if ( SUCCEEDED ( t_Result ) )
						{
							if ( t_Variant.vt == VT_BSTR )
							{
								if ( t_String->GetValue () && _wcsicmp ( t_Variant.bstrVal , t_String->GetValue () ) == 0 )
								{
									t_Status = QueryPreprocessor :: State_True ;
								}
								else
								{
									t_Status = QueryPreprocessor :: State_False ;
								}
							}

							VariantClear ( & t_Variant ) ;
						}
					}
				}
			}
			else
			{
// Should never happen, failure in DFN evaluation otherwise
			}
		}
		else if ( a_Node->GetType () == TypeId_WmiOperatorNotEqualNode )
		{
			WmiTreeNode *t_Left = a_Node->GetLeft () ;
			if ( t_Left )
			{
			}
			else
			{
// Should never happen, failure in DFN evaluation otherwise
			}
		}
		else if ( a_Node->GetType () == TypeId_WmiOperatorEqualOrGreaterNode )
		{
			WmiTreeNode *t_Left = a_Node->GetLeft () ;
			if ( t_Left )
			{
			}
			else
			{
// Should never happen, failure in DFN evaluation otherwise
			}
		}
		else if ( a_Node->GetType () == TypeId_WmiOperatorEqualOrLessNode )
		{
			WmiTreeNode *t_Left = a_Node->GetLeft () ;
			if ( t_Left )
			{
			}
			else
			{
// Should never happen, failure in DFN evaluation otherwise
			}
		}
		else if ( a_Node->GetType () == TypeId_WmiOperatorLessNode )
		{
			WmiTreeNode *t_Left = a_Node->GetLeft () ;
			if ( t_Left )
			{
			}
			else
			{
// Should never happen, failure in DFN evaluation otherwise
			}
		}
		else if ( a_Node->GetType () == TypeId_WmiOperatorGreaterNode )
		{
			WmiTreeNode *t_Left = a_Node->GetLeft () ;
			if ( t_Left )
			{
			}
			else
			{
// Should never happen, failure in DFN evaluation otherwise
			}
		}
		else if ( a_Node->GetType () == TypeId_WmiOperatorLikeNode )
		{
			WmiTreeNode *t_Left = a_Node->GetLeft () ;
			if ( t_Left )
			{
			}
			else
			{
// Should never happen, failure in DFN evaluation otherwise
			}
		}
		else if ( a_Node->GetType () == TypeId_WmiOperatorNotLikeNode )
		{
			WmiTreeNode *t_Left = a_Node->GetLeft () ;
			if ( t_Left )
			{
			}
			else
			{
// Should never happen, failure in DFN evaluation otherwise
			}
		}
		else if ( a_Node->GetType () == TypeId_WmiOperatorIsANode )
		{
			WmiTreeNode *t_Left = a_Node->GetLeft () ;
			if ( t_Left )
			{
				if ( t_Left->GetType () == TypeId_WmiStringNode )
				{
					WmiStringNode *t_String = ( WmiStringNode * ) t_Left ;

					if ( _wcsicmp ( L"__this" , t_String->GetPropertyName () ) == 0 )
					{
						IWbemClassObject *t_FilterObject = NULL ;

						HRESULT t_Result = m_CoreFullStub->GetObject ( 

							t_String->GetValue () ,
							0 ,
							a_Context , 
							& t_FilterObject , 
							NULL 
						) ;

						if ( SUCCEEDED ( t_Result ) ) 
						{
							LONG t_LeftLength = 0 ;
							LONG t_RightLength = 0 ;
							BOOL t_LeftIsA = FALSE ;

							t_Status = IsA (

								a_Class ,
								t_FilterObject ,
								t_LeftLength ,
								t_RightLength ,
								t_LeftIsA
							) ;

							if ( ( t_Status == QueryPreprocessor :: State_True ) && ( t_LeftIsA == TRUE ) )
							{
								t_Status = QueryPreprocessor :: State_True ;
							}
							else
							{
								t_Status = QueryPreprocessor :: State_False ;
							}

							t_FilterObject->Release () ;
						}
					}
				}
			}
			else
			{
// Should never happen, failure in DFN evaluation otherwise
			}
		}
		else if ( a_Node->GetType () == TypeId_WmiOperatorNotIsANode )
		{
			WmiTreeNode *t_Left = a_Node->GetLeft () ;
			if ( t_Left )
			{
				if ( t_Left->GetType () == TypeId_WmiStringNode )
				{
					WmiStringNode *t_String = ( WmiStringNode * ) t_Left ;

					if ( _wcsicmp ( L"__this" , t_String->GetPropertyName () ) == 0 )
					{
						IWbemClassObject *t_FilterObject = NULL ;

						HRESULT t_Result = m_CoreFullStub->GetObject ( 

							t_String->GetValue () ,
							0 ,
							a_Context , 
							& t_FilterObject , 
							NULL 
						) ;

						if ( SUCCEEDED ( t_Result ) ) 
						{
							LONG t_LeftLength = 0 ;
							LONG t_RightLength = 0 ;
							BOOL t_LeftIsA = FALSE ;

							t_Status = IsA (

								a_Class ,
								t_FilterObject ,
								t_LeftLength ,
								t_RightLength ,
								t_LeftIsA
							) ;

							if ( ! ( ( t_Status == QueryPreprocessor :: State_True ) && ( t_LeftIsA == TRUE ) ) )
							{
								t_Status = QueryPreprocessor :: State_True ;
							}
							else
							{
								t_Status = QueryPreprocessor :: State_False ;
							}

							t_FilterObject->Release () ;
						}
					}
				}
			}
		}
		else
		{
// Should never happen, failure in DFN evaluation otherwise
		}
	}

	return t_Status ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

QueryPreprocessor :: QuadState CAggregator_IWbemProvider :: EnumDeep_Evaluate (

	IWbemClassObject *a_Class ,
	IWbemContext *a_Context , 
	WmiTreeNode *&a_Root
)
{
	QueryPreprocessor :: QuadState t_Status = QueryPreprocessor :: State_True ;
 
	VARIANT t_Variant ;
	VariantInit ( & t_Variant ) ;

	LONG t_VarType = 0 ;
	LONG t_Flavour = 0 ;

	HRESULT t_Result = a_Class->Get ( L"__Class" , 0 , & t_Variant , & t_VarType , & t_Flavour ) ;
	if ( SUCCEEDED ( t_Result ) )
	{
		if ( t_Variant.vt == ( VT_NULL ) )
		{
			t_Status = QueryPreprocessor :: State_True ;
		}
		else
		{
			t_Status = EnumDeep_RecursiveEvaluate ( a_Class , a_Context , a_Root ) ;
		}

		VariantClear ( & t_Variant ) ;
	}
	else
	{
		t_Status = QueryPreprocessor :: State_Error ;
	}

	return t_Status ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

QueryPreprocessor :: QuadState CAggregator_IWbemProvider :: EnumShallow_RecursiveEvaluate ( 

	IWbemClassObject *a_Class ,
	IWbemContext *a_Context , 
	WmiTreeNode *&a_Node
)
{
	QueryPreprocessor :: QuadState t_Status = QueryPreprocessor :: State_Undefined ;

	if ( a_Node ) 
	{
		if ( a_Node->GetType () == TypeId_WmiOrNode )
		{
			WmiTreeNode *t_Left = a_Node->GetLeft () ;
			WmiTreeNode *t_Right = a_Node->GetRight () ;

			if ( t_Left )
			{
				t_Status = EnumShallow_RecursiveEvaluate ( a_Class , a_Context , t_Left ) ;
				if ( t_Status == QueryPreprocessor :: State_False )
				{
					if ( t_Right )
					{
						t_Status = EnumShallow_RecursiveEvaluate ( a_Class , a_Context , t_Right ) ;
						return t_Status ;
					}
				}
			}
		}
		else if ( a_Node->GetType () == TypeId_WmiAndNode )
		{
			WmiTreeNode *t_Left = a_Node->GetLeft () ;
			WmiTreeNode *t_Right = a_Node->GetRight () ;

			if ( t_Left )
			{
				t_Status = EnumShallow_RecursiveEvaluate ( a_Class , a_Context , t_Left ) ;
				if ( ( t_Status == QueryPreprocessor :: State_True ) || ( t_Status == QueryPreprocessor :: State_Undefined ) )
				{
					if ( t_Right )
					{
						t_Status = EnumShallow_RecursiveEvaluate ( a_Class , a_Context , t_Right ) ;
						return t_Status ;
					}
				}
			}
		}
		else if ( a_Node->GetType () == TypeId_WmiNotNode )
		{
// Should never happen, failure in DFN evaluation otherwise
		}
		else if ( a_Node->GetType () == TypeId_WmiOperatorEqualNode )
		{
			WmiTreeNode *t_Left = a_Node->GetLeft () ;
			if ( t_Left )
			{
				if ( t_Left->GetType () == TypeId_WmiStringNode )
				{
					WmiStringNode *t_String = ( WmiStringNode * ) t_Left ;

					if ( _wcsicmp ( L"__SuperClass" , t_String->GetPropertyName () ) == 0 )
					{
						VARIANT t_Variant ;
						VariantInit ( & t_Variant ) ;

						LONG t_VarType = 0 ;
						LONG t_Flavour = 0 ;

						HRESULT t_Result = a_Class->Get ( L"__SuperClass" , 0 , & t_Variant , & t_VarType , & t_Flavour ) ;
						if ( SUCCEEDED ( t_Result ) )
						{
							if ( t_Variant.vt == VT_BSTR )
							{
								if ( t_String->GetValue () && _wcsicmp ( t_Variant.bstrVal , t_String->GetValue () ) == 0 )
								{
									t_Status = QueryPreprocessor :: State_True ;
								}
								else
								{
									t_Status = QueryPreprocessor :: State_False ;
								}
							}

							VariantClear ( & t_Variant ) ;
						}
					}
				}
			}
			else
			{
// Should never happen, failure in DFN evaluation otherwise
			}
		}
		else if ( a_Node->GetType () == TypeId_WmiOperatorNotEqualNode )
		{
			WmiTreeNode *t_Left = a_Node->GetLeft () ;
			if ( t_Left )
			{
			}
			else
			{
// Should never happen, failure in DFN evaluation otherwise
			}
		}
		else if ( a_Node->GetType () == TypeId_WmiOperatorEqualOrGreaterNode )
		{
			WmiTreeNode *t_Left = a_Node->GetLeft () ;
			if ( t_Left )
			{
			}
			else
			{
// Should never happen, failure in DFN evaluation otherwise
			}
		}
		else if ( a_Node->GetType () == TypeId_WmiOperatorEqualOrLessNode )
		{
			WmiTreeNode *t_Left = a_Node->GetLeft () ;
			if ( t_Left )
			{
			}
			else
			{
// Should never happen, failure in DFN evaluation otherwise
			}
		}
		else if ( a_Node->GetType () == TypeId_WmiOperatorLessNode )
		{
			WmiTreeNode *t_Left = a_Node->GetLeft () ;
			if ( t_Left )
			{
			}
			else
			{
// Should never happen, failure in DFN evaluation otherwise
			}
		}
		else if ( a_Node->GetType () == TypeId_WmiOperatorGreaterNode )
		{
			WmiTreeNode *t_Left = a_Node->GetLeft () ;
			if ( t_Left )
			{
			}
			else
			{
// Should never happen, failure in DFN evaluation otherwise
			}
		}
		else if ( a_Node->GetType () == TypeId_WmiOperatorLikeNode )
		{
			WmiTreeNode *t_Left = a_Node->GetLeft () ;
			if ( t_Left )
			{
			}
			else
			{
// Should never happen, failure in DFN evaluation otherwise
			}
		}
		else if ( a_Node->GetType () == TypeId_WmiOperatorNotLikeNode )
		{
			WmiTreeNode *t_Left = a_Node->GetLeft () ;
			if ( t_Left )
			{
			}
			else
			{
// Should never happen, failure in DFN evaluation otherwise
			}
		}
		else if ( a_Node->GetType () == TypeId_WmiOperatorIsANode )
		{
			WmiTreeNode *t_Left = a_Node->GetLeft () ;
			if ( t_Left )
			{
				if ( t_Left->GetType () == TypeId_WmiStringNode )
				{
					WmiStringNode *t_String = ( WmiStringNode * ) t_Left ;

					if ( _wcsicmp ( L"__this" , t_String->GetPropertyName () ) == 0 )
					{
						IWbemClassObject *t_FilterObject = NULL ;

						HRESULT t_Result = m_CoreFullStub->GetObject ( 

							t_String->GetValue () ,
							0 ,
							a_Context , 
							& t_FilterObject , 
							NULL 
						) ;

						if ( SUCCEEDED ( t_Result ) ) 
						{
							LONG t_LeftLength = 0 ;
							LONG t_RightLength = 0 ;
							BOOL t_LeftIsA = FALSE ;

							t_Status = IsA (

								a_Class ,
								t_FilterObject  ,
								t_LeftLength ,
								t_RightLength ,
								t_LeftIsA
							) ;

							if ( ( t_Status == QueryPreprocessor :: State_True ) && ( t_LeftIsA == TRUE ) )
							{
								t_Status = QueryPreprocessor :: State_True ;
							}
							else
							{
								t_Status = QueryPreprocessor :: State_False ;
							}

							t_FilterObject->Release () ;
						}
					}
				}
			}
			else
			{
// Should never happen, failure in DFN evaluation otherwise
			}
		}
		else if ( a_Node->GetType () == TypeId_WmiOperatorNotIsANode )
		{
			WmiTreeNode *t_Left = a_Node->GetLeft () ;
			if ( t_Left )
			{
				if ( t_Left->GetType () == TypeId_WmiStringNode )
				{
					WmiStringNode *t_String = ( WmiStringNode * ) t_Left ;

					if ( _wcsicmp ( L"__this" , t_String->GetPropertyName () ) == 0 )
					{
						IWbemClassObject *t_FilterObject = NULL ;

						HRESULT t_Result = m_CoreFullStub->GetObject ( 

							t_String->GetValue () ,
							0 ,
							a_Context , 
							& t_FilterObject , 
							NULL 
						) ;

						if ( SUCCEEDED ( t_Result ) ) 
						{
							LONG t_LeftLength = 0 ;
							LONG t_RightLength = 0 ;
							BOOL t_LeftIsA = FALSE ;

							t_Status = IsA (

								a_Class  ,
								t_FilterObject,
								t_LeftLength ,
								t_RightLength ,
								t_LeftIsA
							) ;

							if ( ! ( ( t_Status == QueryPreprocessor :: State_True ) && ( t_LeftIsA == TRUE ) ) )
							{
								t_Status = QueryPreprocessor :: State_True ;
							}
							else
							{
								t_Status = QueryPreprocessor :: State_False ;
							}

							t_FilterObject->Release () ;
						}
					}
				}
			}
		}
		else
		{
// Should never happen, failure in DFN evaluation otherwise
		}
	}

	return t_Status ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

QueryPreprocessor :: QuadState CAggregator_IWbemProvider :: EnumShallow_Evaluate (

	IWbemClassObject *a_Class ,
	IWbemContext *a_Context , 
	WmiTreeNode *&a_Root
)
{
	QueryPreprocessor :: QuadState t_Status = QueryPreprocessor :: State_True ;
 
	VARIANT t_Variant ;
	VariantInit ( & t_Variant ) ;

	LONG t_VarType = 0 ;
	LONG t_Flavour = 0 ;

	HRESULT t_Result = a_Class->Get ( L"__Class" , 0 , & t_Variant , & t_VarType , & t_Flavour ) ;
	if ( SUCCEEDED ( t_Result ) )
	{
		if ( t_Variant.vt == ( VT_NULL ) )
		{
			t_Status = QueryPreprocessor :: State_True ;
		}
		else
		{
			t_Status = EnumShallow_RecursiveEvaluate ( a_Class , a_Context , a_Root ) ;
		}

		VariantClear ( & t_Variant ) ;
	}
	else
	{
		t_Status = QueryPreprocessor :: State_Error ;
	}

	return t_Status ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

QueryPreprocessor :: QuadState CAggregator_IWbemProvider :: IsA (

	IWbemClassObject *a_Left ,
	IWbemClassObject *a_Right ,
	LONG &a_LeftLength ,
	LONG &a_RightLength ,
	BOOL &a_LeftIsA
) 
{
	QueryPreprocessor :: QuadState t_Status = QueryPreprocessor :: State_False ;

	SAFEARRAY *t_LeftArray = NULL ;
	SAFEARRAY *t_RightArray = NULL ;
	
	VARIANT t_Variant ;
	VariantInit ( & t_Variant ) ;

	LONG t_VarType = 0 ;
	LONG t_Flavour = 0 ;

	BSTR t_LeftClass = NULL ;
	BSTR t_RightClass = NULL ;

	HRESULT t_Result = a_Left->Get ( L"__Class" , 0 , & t_Variant , & t_VarType , & t_Flavour ) ;
	if ( SUCCEEDED ( t_Result ) )
	{
		if ( t_Variant.vt == ( VT_NULL ) )
		{
			t_Status = QueryPreprocessor :: State_True ;
			a_LeftIsA = FALSE ;
		}
		else
		{
			t_LeftClass = SysAllocString ( t_Variant.bstrVal ) ;
		}

		VariantClear ( & t_Variant ) ;
	}
	else
	{
		t_Status = QueryPreprocessor :: State_Error ;
	}

	if ( t_Status == QueryPreprocessor :: State_False )
	{
		t_Result = a_Right->Get ( L"__Class" , 0 , & t_Variant , & t_VarType , & t_Flavour ) ;
		if ( SUCCEEDED ( t_Result ) )
		{
			if ( t_Variant.vt == ( VT_NULL ) )
			{
				t_Status = QueryPreprocessor :: State_True ;
				a_LeftIsA = TRUE ;
			}
			else
			{
				t_RightClass = SysAllocString ( t_Variant.bstrVal ) ;
			}

			VariantClear ( & t_Variant ) ;
		}
		else
		{
			t_Status = QueryPreprocessor :: State_Error ;
		}
	}

	VARIANT t_RightSafeArray ;
	VariantInit ( & t_RightSafeArray ) ;

	VARIANT t_LeftSafeArray ;
	VariantInit ( & t_LeftSafeArray ) ;

	if ( t_Status == QueryPreprocessor :: State_False )
	{
		t_Result = a_Right->Get ( L"__Derivation" , 0 , & t_RightSafeArray , & t_VarType , & t_Flavour ) ;
		if ( SUCCEEDED ( t_Result ) )
		{
			if ( t_RightSafeArray.vt == ( VT_BSTR | VT_ARRAY ) )
			{
				if ( SafeArrayGetDim ( t_RightSafeArray.parray ) == 1 )
				{
					LONG t_Dimension = 1 ; 

					LONG t_Lower ;
					SafeArrayGetLBound ( t_RightSafeArray.parray , t_Dimension , & t_Lower ) ;

					LONG t_Upper ;
					SafeArrayGetUBound ( t_RightSafeArray.parray , t_Dimension , & t_Upper ) ;

					a_RightLength = ( t_Upper - t_Lower ) + 2 ;

					SAFEARRAYBOUND t_ArrayBounds ;
					t_ArrayBounds.cElements = ( t_Upper - t_Lower ) + 2 ; 
					t_ArrayBounds.lLbound = t_Lower ;

					t_RightArray = SafeArrayCreate ( 

						VT_BSTR , 
						t_Dimension ,
						& t_ArrayBounds
					) ;

					if ( t_RightArray )
					{
						for ( LONG t_Index = t_Lower ; t_Index <= t_Upper ; t_Index ++ )
						{
							LONG t_ElementIndex = t_Lower + 1 ;

							BSTR t_Element = NULL ;
							if ( SUCCEEDED ( SafeArrayGetElement ( t_RightSafeArray.parray , & t_Index , & t_Element ) ) )
							{
								if ( SUCCEEDED ( SafeArrayPutElement ( t_RightArray , & t_ElementIndex , t_Element ) ) )
								{
								}
								else
								{
									t_Status = QueryPreprocessor :: State_Error ;

									SysFreeString ( t_Element ) ;

									break ;
								}

								SysFreeString ( t_Element ) ;
							}
							else
							{
							}
						}

						if ( t_Status != QueryPreprocessor :: State_Error )
						{
							LONG t_ElementIndex = t_Lower ;
							if ( SUCCEEDED ( SafeArrayPutElement ( t_RightArray , & t_ElementIndex , t_RightClass ) ) )
							{
							}
							else
							{
								t_Status = QueryPreprocessor :: State_Error ;
							}
						}
					}
					else
					{
						t_Status = QueryPreprocessor :: State_Error ;
					}
				}
				else
				{
					t_Status = QueryPreprocessor :: State_Error ;
				}
			}
			else
			{
				t_Status = QueryPreprocessor :: State_Error ;
			}
		}
		else
		{
			t_Status = QueryPreprocessor :: State_Error ;
		}

		if ( t_Status != QueryPreprocessor :: State_Error )
		{
			t_Result = a_Left->Get ( L"__Derivation" , 0 , & t_LeftSafeArray , & t_VarType , & t_Flavour ) ;
			if ( SUCCEEDED ( t_Result ) )
			{
				if ( t_LeftSafeArray.vt == ( VT_BSTR | VT_ARRAY ) )
				{
					t_LeftArray = t_LeftSafeArray.parray ;
					if ( SafeArrayGetDim ( t_LeftSafeArray.parray ) == 1 )
					{
						LONG t_Dimension = 1 ; 

						LONG t_Lower ;
						SafeArrayGetLBound ( t_LeftSafeArray.parray , t_Dimension , & t_Lower ) ;

						LONG t_Upper ;
						SafeArrayGetUBound ( t_LeftSafeArray.parray , t_Dimension , & t_Upper ) ;

						a_LeftLength = ( t_Upper - t_Lower ) + 2 ;

						SAFEARRAYBOUND t_ArrayBounds ;
						t_ArrayBounds.cElements = ( t_Upper - t_Lower ) + 2 ; 
						t_ArrayBounds.lLbound = t_Lower ;

						t_LeftArray = SafeArrayCreate ( 

							VT_BSTR , 
							t_Dimension ,
							& t_ArrayBounds
						) ;

						if ( t_LeftArray )
						{
							for ( LONG t_Index = t_Lower ; t_Index <= t_Upper ; t_Index ++ )
							{
								LONG t_ElementIndex = t_Lower + 1 ;

								BSTR t_Element = NULL ;
								if ( SUCCEEDED ( SafeArrayGetElement ( t_LeftSafeArray.parray , & t_Index , & t_Element ) ) )
								{
									if ( SUCCEEDED ( SafeArrayPutElement ( t_LeftArray , & t_ElementIndex , t_Element ) ) )
									{
									}
									else
									{
										t_Status = QueryPreprocessor :: State_Error ;

										SysFreeString ( t_Element ) ;

										break ;
									}

									SysFreeString ( t_Element ) ;
								}
								else
								{
									t_Status = QueryPreprocessor :: State_Error ;

									break ;
								}
							}

							if ( t_Status != QueryPreprocessor :: State_Error )
							{
								LONG t_ElementIndex = t_Lower ;
								if ( SUCCEEDED ( SafeArrayPutElement ( t_LeftArray , & t_ElementIndex , t_LeftClass ) ) )
								{
								}
								else
								{
									t_Status = QueryPreprocessor :: State_Error ;
								}
							}
						}
						else
						{
							t_Status = QueryPreprocessor :: State_Error ;
						}
					}
					else
					{
						t_Status = QueryPreprocessor :: State_Error ;
					}
				}
				else
				{
					t_Status = QueryPreprocessor :: State_Error ;
				}
			}
			else
			{
				t_Status = QueryPreprocessor :: State_Error ;
			}
		}

		if ( t_Status != QueryPreprocessor :: State_Error )
		{
			if ( t_LeftArray && t_RightArray )
			{
				ULONG t_MinimumLength = a_LeftLength < a_RightLength ? a_LeftLength : a_RightLength ;
				for ( LONG t_Index = t_MinimumLength ; t_Index > 0 ; t_Index -- )
				{
					BSTR t_LeftElement = NULL ;
					BSTR t_RightElement = NULL ;

					LONG t_Dimension = 1 ; 

					LONG t_Lower ;
					SafeArrayGetLBound ( t_LeftArray , t_Dimension , & t_Lower ) ;
					t_Lower = t_Lower + t_Index - 1 ;
 
					if ( SUCCEEDED ( t_Result = SafeArrayGetElement ( t_LeftArray , & t_Lower , & t_LeftElement ) ) )
					{
						SafeArrayGetUBound ( t_RightArray , t_Dimension , & t_Lower ) ;
						t_Lower = t_Lower + t_Index - 1 ;

						if ( SUCCEEDED ( t_Result = SafeArrayGetElement ( t_RightArray , & t_Lower , & t_RightElement ) ) )
						{
						}
					}

					if ( SUCCEEDED ( t_Result ) )
					{
						if ( _wcsicmp ( t_LeftElement , t_RightElement ) != 0 )
						{
							SysFreeString ( t_LeftElement ) ;
							SysFreeString ( t_RightElement ) ;

							break ;
						}
					}

					SysFreeString ( t_LeftElement ) ;
					SysFreeString ( t_RightElement ) ;
				}

				if ( t_Index == 0 ) 
				{
					t_Status = QueryPreprocessor :: State_True ;

					a_LeftIsA = TRUE ;
				}
				else
				{
					if ( t_Index == t_MinimumLength )
					{
						if ( a_RightLength == t_MinimumLength )
						{
							t_Status = QueryPreprocessor :: State_True ;

							a_LeftIsA = TRUE ;
						}
						else
						{
							if ( a_LeftLength == t_MinimumLength )
							{
								t_Status = QueryPreprocessor :: State_True ;

								a_LeftIsA = FALSE ;
							}
						}
					}
				}
			}
			else	
			{
				t_Status = QueryPreprocessor :: State_Error ;
			}
		}

		SafeArrayDestroy ( t_LeftArray ) ;
		SafeArrayDestroy ( t_RightArray ) ;

		VariantClear ( & t_LeftSafeArray ) ;
		VariantClear ( & t_RightSafeArray ) ;
	}

	SysFreeString ( t_LeftClass ) ;
	SysFreeString ( t_RightClass ) ;

	return t_Status ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CAggregator_IWbemProvider :: Enum_ClassProviders ( IWbemContext *a_Context )
{
	HRESULT t_Result = Enum_ClassProviders ( 

		m_CoreRepositoryStub ,
		a_Context 
	) ;

	if ( SUCCEEDED ( t_Result ) )
	{
		for ( ULONG t_Index = 0 ; t_Index < m_ClassProvidersCount ; t_Index ++ )
		{
			CServerObject_ClassProviderRegistrationV1 *t_Registration = & m_ClassProviders [ t_Index ]->GetClassProviderRegistration () ;
			if ( t_Registration && SUCCEEDED ( t_Registration->GetResult () ) )
			{
				if ( t_Registration->InteractionType () == e_InteractionType_Push )
				{
					IWbemServices *t_Provider = NULL ;

					WmiInternalContext t_InternalContext ;
					ZeroMemory ( & t_InternalContext , sizeof ( t_InternalContext ) ) ;

					HRESULT t_TempResult = m_Factory->GetProvider ( 

						t_InternalContext ,
						0 ,
						a_Context ,
						NULL ,
						m_User ,
						m_Locale ,
						NULL ,
						m_ClassProviders [ t_Index ]->GetProviderName () ,
						IID_IWbemServices , 
						( void ** ) & t_Provider 

					) ;

					if ( SUCCEEDED ( t_TempResult ) )
					{
						t_Provider->Release () ;
					}
				}
			}
		}
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CAggregator_IWbemProvider :: Enum_ClassProviders (

	IWbemServices *a_Repository ,
	IWbemContext *a_Context 
)
{
	HRESULT t_Result = S_OK ;

	BSTR t_Query = SysAllocString ( L"Select * from __ClassProviderRegistration" ) ;
	if ( t_Query )
	{
		IEnumWbemClassObject *t_ClassObjectEnum = NULL ;

		BSTR t_Language = SysAllocString ( ProviderSubSystem_Globals :: s_Wql ) ;
		if ( t_Language ) 
		{
			t_Result = a_Repository->ExecQuery ( 
				
				t_Language ,
				t_Query ,
				WBEM_FLAG_BIDIRECTIONAL ,
				a_Context , 
				& t_ClassObjectEnum
			) ;

			if ( SUCCEEDED ( t_Result ) )
			{
				m_ClassProvidersCount = 0 ;

				IWbemClassObject *t_ClassObject = NULL ;
				ULONG t_ObjectCount = 0 ;

				t_ClassObjectEnum->Reset () ;
				while ( t_ClassObjectEnum->Next ( WBEM_INFINITE , 1 , & t_ClassObject , &t_ObjectCount ) == WBEM_NO_ERROR ) 
				{
					m_ClassProvidersCount ++ ;
					t_ClassObject->Release () ;
				}

				if ( m_ClassProvidersCount )
				{
					m_ClassProviders = new CServerObject_ProviderRegistrationV1 * [ m_ClassProvidersCount ] ;
					if ( m_ClassProviders )
					{
						ZeroMemory ( m_ClassProviders , sizeof ( CServerObject_ProviderRegistrationV1 * ) * m_ClassProvidersCount ) ;

						ULONG t_Index = 0 ;

						t_ClassObjectEnum->Reset () ;
						while ( SUCCEEDED ( t_Result ) && ( t_ClassObjectEnum->Next ( WBEM_INFINITE , 1 , & t_ClassObject , &t_ObjectCount ) == WBEM_NO_ERROR ) )
						{
							VARIANT t_Variant ;
							VariantInit ( & t_Variant ) ;
						
							LONG t_VarType = 0 ;
							LONG t_Flavour = 0 ;

							t_Result = t_ClassObject->Get ( L"Provider" , 0 , & t_Variant , & t_VarType , & t_Flavour ) ;
							if ( SUCCEEDED ( t_Result ) )
							{
								if ( t_Variant.vt == VT_BSTR )
								{
									IWbemPath *t_Path = NULL ;

									t_Result = CoCreateInstance (

										CLSID_WbemDefPath ,
										NULL ,
										CLSCTX_INPROC_SERVER ,
										IID_IWbemPath ,
										( void ** )  & t_Path
									) ;

									if ( SUCCEEDED ( t_Result ) )
									{
										t_Result = t_Path->SetText ( WBEMPATH_TREAT_SINGLE_IDENT_AS_NS | WBEMPATH_CREATE_ACCEPT_ALL , t_Variant.bstrVal ) ;
										if ( SUCCEEDED ( t_Result ) )
										{
											m_ClassProviders [ t_Index ] = new CServerObject_ProviderRegistrationV1  ;
											if ( m_ClassProviders [ t_Index ] )
											{
												m_ClassProviders [ t_Index ]->AddRef () ;

												t_Result = m_ClassProviders [ t_Index ]->SetContext ( 

													a_Context ,
													NULL , 
													a_Repository
												) ;
												
												if ( SUCCEEDED ( t_Result ) )
												{
													t_Result = m_ClassProviders [ t_Index ]->Load ( 

														e_All ,
														NULL , 
														t_Path
													) ;
												}
											}
											else
											{
												t_Result = WBEM_E_OUT_OF_MEMORY ;
											}
										}

										t_Path->Release () ;
									}
								}
							}

							VariantClear ( & t_Variant ) ;

							t_ClassObject->Release () ;

							t_Index ++ ;
						}
					}
					else
					{
						t_Result = WBEM_E_OUT_OF_MEMORY ;
					}
				}

				t_ClassObjectEnum->Release () ;
			}

			SysFreeString ( t_Language ) ;
		}
		else
		{
			t_Result = WBEM_E_OUT_OF_MEMORY ;
		}

		SysFreeString ( t_Query ) ;
	}
	else
	{
		t_Result = WBEM_E_OUT_OF_MEMORY ;
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CAggregator_IWbemProvider::OpenNamespace ( 

	const BSTR a_ObjectPath, 
	long a_Flags, 
	IWbemContext *a_Context,
	IWbemServices **a_NamespaceService, 
	IWbemCallResult **a_CallResult
)
{
	return WBEM_E_NOT_AVAILABLE ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CAggregator_IWbemProvider :: CancelAsyncCall ( 
		
	IWbemObjectSink *a_Sink
)
{
	HRESULT t_Result = S_OK ;

	CWbemGlobal_IWmiObjectSinkController_Container_Iterator t_Iterator ;

	Lock () ;

	WmiStatusCode t_StatusCode = Find ( 

		a_Sink ,
		t_Iterator
	) ;

	if ( t_StatusCode == e_StatusCode_Success ) 
	{
		ObjectSinkContainerElement *t_Element = t_Iterator.GetElement () ;

		UnLock () ;

		IObjectSink_CancelOperation *t_ObjectSink = NULL ;
		t_Result = t_Element->QueryInterface ( IID_IObjectSink_CancelOperation , ( void ** ) & t_ObjectSink ) ;
		if ( SUCCEEDED ( t_Result ) )
		{ 
			t_Result = t_ObjectSink->Cancel (

				0
			) ;

			t_ObjectSink->Release () ;
		}

		IWbemShutdown *t_Shutdown = NULL ;
		HRESULT t_TempResult = t_Element->QueryInterface ( IID_IWbemShutdown , ( void ** ) & t_Shutdown ) ;
		if ( SUCCEEDED ( t_TempResult ) )
		{
			t_TempResult = t_Shutdown->Shutdown ( 

				0 , 
				0 , 
				NULL 
			) ;

			t_Shutdown->Release () ;
		}

		t_Element->Release () ;
	}
	else
	{
		UnLock () ;

		t_Result = WBEM_E_NOT_FOUND ;
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CAggregator_IWbemProvider :: QueryObjectSink ( 

	long a_Flags,		
	IWbemObjectSink **a_Sink
) 
{
	return WBEM_E_NOT_AVAILABLE ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CAggregator_IWbemProvider :: GetObject ( 
		
	const BSTR a_ObjectPath,
    long a_Flags,
    IWbemContext *a_Context,
    IWbemClassObject **a_Object,
    IWbemCallResult **a_CallResult
)
{
	return WBEM_E_NOT_AVAILABLE ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CAggregator_IWbemProvider :: GetObjectAsync ( 
		
	const BSTR a_ObjectPath, 
	long a_Flags, 
	IWbemContext *a_Context,
	IWbemObjectSink *a_Sink
) 
{
	HRESULT t_Result = S_OK ;

	if ( m_Initialized == 0 )
	{
		a_Sink->SetStatus ( 0 , WBEM_E_NOT_FOUND , NULL , NULL ) ;

		return WBEM_E_NOT_FOUND ;
	}

	if ( m_ClassProvidersCount )
	{
		IWbemPath *t_Path = NULL ;

		t_Result = CoCreateInstance (

			CLSID_WbemDefPath ,
			NULL ,
			CLSCTX_INPROC_SERVER ,
			IID_IWbemPath ,
			( void ** )  & t_Path
		) ;

		if ( SUCCEEDED ( t_Result ) )
		{
			t_Result = t_Path->SetText ( WBEMPATH_CREATE_ACCEPT_ALL , a_ObjectPath ) ;
			if ( SUCCEEDED ( t_Result ) )
			{
				ULONG t_ClassNameLength = 0 ;
				LPWSTR t_ClassName = NULL ;

				t_Result = t_Path->GetClassName (

					& t_ClassNameLength ,
					t_ClassName
				);

				if ( SUCCEEDED ( t_Result ) )
				{
					t_ClassName = new wchar_t [ t_ClassNameLength ] ;
					if ( t_ClassName )
					{
						t_Result = t_Path->GetClassName (

							& t_ClassNameLength ,
							t_ClassName
						);

						if ( SUCCEEDED ( t_Result ) )
						{
							BOOL t_ClassProviderFound = FALSE ;

							for ( ULONG t_Index = 0 ; t_Index < m_ClassProvidersCount ; t_Index ++ )
							{
								BOOL t_ProbeProvider = FALSE ;

								CServerObject_ClassProviderRegistrationV1 *t_Registration = & m_ClassProviders [ t_Index ]->GetClassProviderRegistration () ;
								if ( t_Registration && SUCCEEDED ( t_Registration->GetResult () ) )
								{
									WmiTreeNode **t_Forest = t_Registration->GetResultSetQuery () ;
									ULONG t_ForestCount = t_Registration->GetResultSetQueryCount () ;
									if ( t_ForestCount )
									{
										for ( ULONG t_FilterIndex = 0 ; t_FilterIndex < t_ForestCount ; t_FilterIndex ++ )
										{
											QueryPreprocessor :: QuadState t_Status = Get_Evaluate (

												t_ClassName ,
												a_Context , 
												t_Forest [ t_FilterIndex ] 
											) ;

											if ( ( t_Status == QueryPreprocessor :: State_True ) || ( t_Status == QueryPreprocessor :: State_Undefined ) )
											{
												t_ProbeProvider = TRUE ;
											}
										}
									}
									else
									{
										t_ProbeProvider = TRUE ;
									}
								}

								if ( t_ProbeProvider )
								{
									IWbemServices *t_Provider = NULL ;

									WmiInternalContext t_InternalContext ;
									ZeroMemory ( & t_InternalContext , sizeof ( t_InternalContext ) ) ;

									t_Result = m_Factory->GetProvider ( 

										t_InternalContext ,
										0 ,
										a_Context ,
										NULL ,
										m_User ,
										m_Locale ,
										NULL ,
										m_ClassProviders [ t_Index ]->GetProviderName () ,
										IID_IWbemServices , 
										( void ** ) & t_Provider 

									) ;

									if ( SUCCEEDED ( t_Result ) )
									{
										if ( t_Registration->InteractionType () == e_InteractionType_Pull )
										{
											CInterceptor_IWbemWaitingObjectSink_GetObjectAsync *t_WaitingSink = new CInterceptor_IWbemWaitingObjectSink_GetObjectAsync (

												m_Allocator ,
												t_Provider ,
												a_Sink ,
												( CWbemGlobal_IWmiObjectSinkController * ) this ,
												*m_ClassProviders [ t_Index ]
											) ;

											if ( t_WaitingSink )
											{
												t_WaitingSink->AddRef () ;

												t_Result = t_WaitingSink->Initialize ( 
											
													m_ClassProviders [ t_Index ]->GetComRegistration ().GetSecurityDescriptor () , 
													a_ObjectPath ,
													a_Flags ,
													a_Context 
												) ;

												if ( SUCCEEDED ( t_Result ) ) 
												{
													CWbemGlobal_IWmiObjectSinkController_Container_Iterator t_Iterator ;

													Lock () ;

													WmiStatusCode t_StatusCode = Insert ( 

														*t_WaitingSink ,
														t_Iterator
													) ;

													UnLock () ;

													if ( t_StatusCode == e_StatusCode_Success ) 
													{
														t_Result = t_Provider->GetObjectAsync ( 
																
															a_ObjectPath, 
															a_Flags, 
															a_Context,
															t_WaitingSink
														) ;

														if ( SUCCEEDED ( t_Result ) )
														{
															t_Result = t_WaitingSink->Wait ( INFINITE ) ;
															if ( SUCCEEDED ( t_Result ) )
															{
																if ( SUCCEEDED ( t_WaitingSink->GetResult () ) )
																{
																	t_ClassProviderFound = TRUE ;
																}
																else
																{
																	if ( t_Result == WBEM_E_NOT_FOUND || t_Result  == WBEM_E_INVALID_CLASS || t_Result == WBEM_E_PROVIDER_NOT_CAPABLE )
																	{
																		t_Result = S_OK ;
																	}
																	else
																	{
																	}
																}
															}
															else
															{
															}
														}
														else
														{
															if ( t_Result == WBEM_E_NOT_FOUND || t_Result  == WBEM_E_INVALID_CLASS || t_Result == WBEM_E_PROVIDER_NOT_CAPABLE )
															{
																t_Result = S_OK ;
															}
														}

														WmiQueue <IWbemClassObject *,8> &t_Queue = t_WaitingSink->GetQueue () ;

														CriticalSection &t_CriticalSection = t_WaitingSink->GetQueueCriticalSection () ;

														WmiHelper :: EnterCriticalSection ( & t_CriticalSection ) ;

														WmiStatusCode t_StatusCode = e_StatusCode_Success ;

														IWbemClassObject *t_Object = NULL ;
														while ( ( t_StatusCode = t_Queue.Top ( t_Object ) ) == e_StatusCode_Success )
														{
															if(SUCCEEDED(t_Result))
																t_Result = a_Sink->Indicate ( 1 , & t_Object ) ;

															t_Object->Release () ;
															t_StatusCode = t_Queue.DeQueue () ;
														}

														WmiHelper :: LeaveCriticalSection ( & t_CriticalSection ) ;
													}
													else
													{
														t_Result = WBEM_E_OUT_OF_MEMORY ;
													}
												}

												t_WaitingSink->Release () ;
											}
											else
											{
												t_Result = WBEM_E_OUT_OF_MEMORY ;
											}
										}

										t_Provider->Release () ;
									}
									else
									{
										t_Result = S_OK ;
									}
								}
							}

							if ( SUCCEEDED ( t_Result ) )
							{
								if ( t_ClassProviderFound == FALSE )
								{
									t_Result = WBEM_E_NOT_FOUND ;
								}
							}
						}

						delete [] t_ClassName ;
					}
					else
					{
						t_Result = WBEM_E_OUT_OF_MEMORY ;
					}
				}
			}

			t_Path->Release () ;
		}
	}
	else
	{
		t_Result = WBEM_E_NOT_FOUND ;
	}

	a_Sink->SetStatus ( 0 , t_Result , NULL , NULL ) ;

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CAggregator_IWbemProvider :: PutClass ( 
		
	IWbemClassObject *a_Object, 
	long a_Flags, 
	IWbemContext *a_Context,
	IWbemCallResult **a_CallResult
) 
{
	return WBEM_E_NOT_AVAILABLE ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CAggregator_IWbemProvider :: PutClass_Helper_Advisory ( 

	IWbemClassObject *a_ClassObject, 
	long a_Flags, 
	IWbemContext *a_Context,
	IWbemObjectSink *a_Sink
)
{
	HRESULT t_Result = S_OK ;

	for ( ULONG t_Index = 0 ; SUCCEEDED ( t_Result ) && ( t_Index < m_ClassProvidersCount ) ; t_Index ++ )
	{
		CServerObject_ClassProviderRegistrationV1 *t_Registration = & m_ClassProviders [ t_Index ]->GetClassProviderRegistration () ;
		if ( t_Registration && SUCCEEDED ( t_Registration->GetResult () ) )
		{
			switch ( t_Registration->GetVersion () )
			{
				case 1:
				{
				}
				break ;

				case 2:
				{
					BOOL t_ProbeProvider = FALSE ;

					WmiTreeNode **t_Forest = t_Registration->GetResultSetQuery () ;
					ULONG t_ForestCount = t_Registration->GetResultSetQueryCount () ;
					if ( t_ForestCount )
					{
						for ( ULONG t_FilterIndex = 0 ; t_FilterIndex < t_ForestCount ; t_FilterIndex ++ )
						{
							QueryPreprocessor :: QuadState t_Status = QueryPreprocessor :: State_True ;

							t_Status = EnumDeep_Evaluate (

								a_ClassObject ,
								a_Context , 
								t_Forest [ t_FilterIndex ] 
							) ;

							if ( ( t_Status == QueryPreprocessor :: State_True ) || ( t_Status == QueryPreprocessor :: State_Undefined ) )
							{
								t_ProbeProvider = TRUE ;
							}
						}
					}
					else
					{
						t_ProbeProvider = TRUE ;
					}

					if ( t_ProbeProvider )
					{
						IWbemServices *t_Provider = NULL ;

						WmiInternalContext t_InternalContext ;
						ZeroMemory ( & t_InternalContext , sizeof ( t_InternalContext ) ) ;

						t_Result = m_Factory->GetProvider ( 

							t_InternalContext ,
							0 ,
							a_Context ,
							NULL ,
							m_User ,
							m_Locale ,
							NULL ,
							m_ClassProviders [ t_Index ]->GetProviderName () ,
							IID_IWbemServices , 
							( void ** ) & t_Provider 
						) ;

						if ( SUCCEEDED ( t_Result ) )
						{
							if ( t_Registration->InteractionType () == e_InteractionType_Pull )
							{
								CInterceptor_IWbemWaitingObjectSink_PutClassAsync *t_PuttingSink = new CInterceptor_IWbemWaitingObjectSink_PutClassAsync (

									m_Allocator , 
									t_Provider ,
									a_Sink ,
									( CWbemGlobal_IWmiObjectSinkController * ) this ,
									*m_ClassProviders [ t_Index ]
								) ;

								if ( t_PuttingSink )
								{
									t_PuttingSink->AddRef () ;

									t_Result = t_PuttingSink->Initialize ( 
									
										m_ClassProviders [ t_Index ]->GetComRegistration ().GetSecurityDescriptor () ,
										a_ClassObject , 
										a_Flags & ~WBEM_FLAG_USE_AMENDED_QUALIFIERS , 
										a_Context
									) ;

									if ( SUCCEEDED ( t_Result ) ) 
									{
										CWbemGlobal_IWmiObjectSinkController_Container_Iterator t_Iterator ;

										Lock () ;

										WmiStatusCode t_StatusCode = Insert ( 

											*t_PuttingSink ,
											t_Iterator
										) ;

										UnLock () ;

										if ( t_StatusCode == e_StatusCode_Success ) 
										{
											t_Result = t_Provider->PutClassAsync ( 
													
												a_ClassObject , 
												a_Flags & ~WBEM_FLAG_USE_AMENDED_QUALIFIERS , 
												a_Context,
												t_PuttingSink
											) ;

											if ( SUCCEEDED ( t_Result ) ) 
											{
												t_Result = t_PuttingSink->Wait ( INFINITE ) ;

												if ( SUCCEEDED ( t_Result ) )
												{
													t_Result = t_PuttingSink->GetResult () ;
													if ( FAILED ( t_Result ) )
													{
														if ( t_Result == WBEM_E_NOT_FOUND || t_Result  == WBEM_E_INVALID_CLASS || t_Result == WBEM_E_PROVIDER_NOT_CAPABLE )
														{
															t_Result = S_OK ;
														}
													}
												}
											}
											else
											{
												if ( t_Result == WBEM_E_NOT_FOUND || t_Result  == WBEM_E_INVALID_CLASS || t_Result == WBEM_E_PROVIDER_NOT_CAPABLE )
												{
													t_Result = S_OK ;
												}
											}
										}
										else
										{
											t_Result = WBEM_E_OUT_OF_MEMORY ;
										}

										WmiQueue <IWbemClassObject *,8> &t_Queue = t_PuttingSink->GetQueue () ;

										CriticalSection &t_CriticalSection = t_PuttingSink->GetQueueCriticalSection () ;

										WmiHelper :: EnterCriticalSection ( & t_CriticalSection ) ;

										IWbemClassObject *t_Object = NULL ;
										while ( ( t_StatusCode = t_Queue.Top ( t_Object ) ) == e_StatusCode_Success )
										{
											t_Object->Release () ;
											t_StatusCode = t_Queue.DeQueue () ;
										}

										WmiHelper :: LeaveCriticalSection ( & t_CriticalSection ) ;
									}

									t_PuttingSink->Release () ;
								}
								else
								{
									t_Result = WBEM_E_OUT_OF_MEMORY ;
								}
							}

							t_Provider->Release () ;
						}
					}
				}
				break ;

				default:
				{
					t_Result = WBEM_E_INVALID_PROVIDER_REGISTRATION ;
				}
				break ;
			}
		}
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CAggregator_IWbemProvider :: PutClass_Helper_Put_CreateOrUpdate ( 

	BSTR a_Class ,
	IWbemClassObject *a_Object, 
	long a_Flags, 
	IWbemContext *a_Context,
	IWbemObjectSink *a_Sink
) 
{
	HRESULT t_Result = S_OK ;

	BOOL t_FoundProvider = FALSE ;

	for ( ULONG t_Index = 0 ; SUCCEEDED ( t_Result ) && ( t_Index < m_ClassProvidersCount ) ; t_Index ++ )
	{
		BOOL t_ProbeProvider = FALSE ;

		CServerObject_ClassProviderRegistrationV1 *t_Registration = & m_ClassProviders [ t_Index ]->GetClassProviderRegistration () ;
		if ( t_Registration && SUCCEEDED ( t_Registration->GetResult () ) )
		{
			WmiTreeNode **t_Forest = t_Registration->GetResultSetQuery () ;
			ULONG t_ForestCount = t_Registration->GetResultSetQueryCount () ;
			if ( t_ForestCount )
			{
				for ( ULONG t_FilterIndex = 0 ; t_FilterIndex < t_ForestCount ; t_FilterIndex ++ )
				{
					QueryPreprocessor :: QuadState t_Status = Get_Evaluate (

						a_Class ,
						a_Context , 
						t_Forest [ t_FilterIndex ] 
					) ;

					if ( ( t_Status == QueryPreprocessor :: State_True ) || ( t_Status == QueryPreprocessor :: State_Undefined ) )
					{
						t_ProbeProvider = TRUE ;
					}
				}
			}
			else
			{
				t_ProbeProvider = TRUE ;
			}
		}

		if ( t_ProbeProvider )
		{
			IWbemServices *t_Provider = NULL ;

			WmiInternalContext t_InternalContext ;
			ZeroMemory ( & t_InternalContext , sizeof ( t_InternalContext ) ) ;

			t_Result = m_Factory->GetProvider ( 

				t_InternalContext ,
				0 ,
				a_Context ,
				NULL ,
				m_User ,
				m_Locale ,
				NULL ,
				m_ClassProviders [ t_Index ]->GetProviderName () ,
				IID_IWbemServices , 
				( void ** ) & t_Provider 
			) ;

			if ( SUCCEEDED ( t_Result ) )
			{
				if ( t_Registration->InteractionType () == e_InteractionType_Pull )
				{
					CInterceptor_IWbemWaitingObjectSink_PutClassAsync *t_WaitingSink = new CInterceptor_IWbemWaitingObjectSink_PutClassAsync (

						m_Allocator ,
						t_Provider ,
						a_Sink ,
						( CWbemGlobal_IWmiObjectSinkController * ) this ,
						*m_ClassProviders [ t_Index ]
					) ;

					if ( t_WaitingSink )
					{
						t_WaitingSink->AddRef () ;

						t_Result = t_WaitingSink->Initialize (
						
							m_ClassProviders [ t_Index ]->GetComRegistration ().GetSecurityDescriptor () ,
							a_Object , 
							a_Flags, 
							a_Context
						) ;

						if ( SUCCEEDED ( t_Result ) ) 
						{
							CWbemGlobal_IWmiObjectSinkController_Container_Iterator t_Iterator ;

							Lock () ;

							WmiStatusCode t_StatusCode = Insert ( 

								*t_WaitingSink ,
								t_Iterator
							) ;

							UnLock () ;

							if ( t_StatusCode == e_StatusCode_Success ) 
							{
								t_Result = t_Provider->PutClassAsync ( 
										
									a_Object , 
									a_Flags, 
									a_Context,
									t_WaitingSink
								) ;

								if ( SUCCEEDED ( t_Result ) )
								{
									t_Result = t_WaitingSink->Wait ( INFINITE ) ;
									if ( SUCCEEDED ( t_Result ) )
									{
										if ( SUCCEEDED ( t_WaitingSink->GetResult () ) )
										{
											t_FoundProvider = TRUE ;
										}
										else
										{
											if ( ( a_Flags & ( WBEM_FLAG_CREATE_ONLY | WBEM_FLAG_UPDATE_ONLY ) ) == WBEM_FLAG_CREATE_ONLY )
											{
												if ( t_Result == WBEM_E_NOT_FOUND || t_Result  == WBEM_E_INVALID_CLASS || t_Result == WBEM_E_PROVIDER_NOT_CAPABLE )
												{
													t_Result = S_OK ;
												}
												else
												{
												}
											}
											else
											{
												if ( t_Result == WBEM_E_NOT_FOUND || t_Result  == WBEM_E_INVALID_CLASS )
												{
													t_Result = S_OK ;
												}
												else
												{
												}
											}
										}
									}
									else
									{
									}
								}
								else
								{
									if ( ( a_Flags & ( WBEM_FLAG_CREATE_ONLY | WBEM_FLAG_UPDATE_ONLY ) ) == WBEM_FLAG_CREATE_ONLY )
									{
										if ( t_Result == WBEM_E_NOT_FOUND || t_Result  == WBEM_E_INVALID_CLASS || t_Result == WBEM_E_PROVIDER_NOT_CAPABLE )
										{
											t_Result = S_OK ;
										}
										else
										{
										}
									}
									else
									{
										if ( t_Result == WBEM_E_NOT_FOUND || t_Result  == WBEM_E_INVALID_CLASS )
										{
											t_Result = S_OK ;
										}
										else
										{
										}
									}
								}

								WmiQueue <IWbemClassObject *,8> &t_Queue = t_WaitingSink->GetQueue () ;

								CriticalSection &t_CriticalSection = t_WaitingSink->GetQueueCriticalSection () ;

								WmiHelper :: EnterCriticalSection ( & t_CriticalSection ) ;

								WmiStatusCode t_StatusCode = e_StatusCode_Success ;

								IWbemClassObject *t_Object = NULL ;
								while ( ( t_StatusCode = t_Queue.Top ( t_Object ) ) == e_StatusCode_Success )
								{
									t_Object->Release () ;
									t_StatusCode = t_Queue.DeQueue () ;
								}

								WmiHelper :: LeaveCriticalSection ( & t_CriticalSection ) ;
							}
							else
							{
								t_Result = WBEM_E_OUT_OF_MEMORY ;
							}
						}

						t_WaitingSink->Release () ;
					}
					else
					{
						t_Result = WBEM_E_OUT_OF_MEMORY ;
					}
				}

				t_Provider->Release () ;
			}
		}
	}

	if ( SUCCEEDED ( t_Result ) )
	{
		if ( t_FoundProvider == FALSE )
		{
			t_Result = WBEM_E_NOT_FOUND ;
		}
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CAggregator_IWbemProvider :: PutClass_Helper_Put ( 
		
	IWbemClassObject *a_Object, 
	long a_Flags, 
	IWbemContext *a_Context,
	IWbemObjectSink *a_Sink
) 
{
	VARIANT t_Variant ;
	VariantInit ( & t_Variant ) ;

	LONG t_VarType = 0 ;
	LONG t_Flavour = 0 ;

	BOOL t_FoundProvider = FALSE ;

	HRESULT t_Result = a_Object->Get ( L"__Class" , 0 , & t_Variant , & t_VarType , & t_Flavour ) ;
	if ( SUCCEEDED ( t_Result ) )
	{
		BOOL t_OwningRegistration = FALSE ;

		for ( ULONG t_Index = 0 ; ( SUCCEEDED ( t_Result ) && ( t_Index < m_ClassProvidersCount ) ) && ( t_OwningRegistration == FALSE ) ; t_Index ++ )
		{
			BOOL t_ProbeProvider = FALSE ;

			CServerObject_ClassProviderRegistrationV1 *t_Registration = & m_ClassProviders [ t_Index ]->GetClassProviderRegistration () ;
			if ( t_Registration && SUCCEEDED ( t_Registration->GetResult () ) )
			{
				WmiTreeNode **t_Forest = t_Registration->GetResultSetQuery () ;
				ULONG t_ForestCount = t_Registration->GetResultSetQueryCount () ;
				if ( t_ForestCount )
				{
					for ( ULONG t_FilterIndex = 0 ; t_FilterIndex < t_ForestCount ; t_FilterIndex ++ )
					{
						QueryPreprocessor :: QuadState t_Status = Get_Evaluate (

							t_Variant.bstrVal ,
							a_Context , 
							t_Forest [ t_FilterIndex ] 
						) ;

						if ( ( t_Status == QueryPreprocessor :: State_True ) || ( t_Status == QueryPreprocessor :: State_Undefined ) )
						{
							if ( t_Registration->InteractionType () == e_InteractionType_Pull )
							{
								t_FoundProvider = TRUE ;
							}

							t_ProbeProvider = TRUE ;
						}
					}
				}
				else
				{
					if ( t_Registration->InteractionType () == e_InteractionType_Pull )
					{
						t_FoundProvider = TRUE ;
					}

					t_ProbeProvider = TRUE ;
				}
			}

			if ( t_ProbeProvider )
			{
				IWbemServices *t_Provider = NULL ;

				WmiInternalContext t_InternalContext ;
				ZeroMemory ( & t_InternalContext , sizeof ( t_InternalContext ) ) ;

				t_Result = m_Factory->GetProvider ( 

					t_InternalContext ,
					0 ,
					a_Context ,
					NULL ,
					m_User ,
					m_Locale ,
					NULL ,
					m_ClassProviders [ t_Index ]->GetProviderName () ,
					IID_IWbemServices , 
					( void ** ) & t_Provider 
				) ;

				if ( SUCCEEDED ( t_Result ) )
				{
					if ( t_Registration->InteractionType () == e_InteractionType_Pull )
					{
						CInterceptor_IWbemWaitingObjectSink_GetObjectAsync *t_WaitingSink = new CInterceptor_IWbemWaitingObjectSink_GetObjectAsync (

							m_Allocator ,
							t_Provider ,
							a_Sink ,
							( CWbemGlobal_IWmiObjectSinkController * ) this ,
							*m_ClassProviders [ t_Index ]
						) ;

						if ( t_WaitingSink )
						{
							t_WaitingSink->AddRef () ;

							t_Result = t_WaitingSink->Initialize (
							
								m_ClassProviders [ t_Index ]->GetComRegistration ().GetSecurityDescriptor () ,
								t_Variant.bstrVal , 
								a_Flags, 
								a_Context
							) ;

							if ( SUCCEEDED ( t_Result ) ) 
							{
								CWbemGlobal_IWmiObjectSinkController_Container_Iterator t_Iterator ;

								Lock () ;

								WmiStatusCode t_StatusCode = Insert ( 

									*t_WaitingSink ,
									t_Iterator
								) ;

								UnLock () ;

								if ( t_StatusCode == e_StatusCode_Success ) 
								{
									WmiStatusCode t_StatusCode = e_StatusCode_Success ;

									WmiQueue <IWbemClassObject *,8> &t_Queue = t_WaitingSink->GetQueue () ;

									t_Result = t_Provider->GetObjectAsync ( 
											
										t_Variant.bstrVal , 
										a_Flags, 
										a_Context,
										t_WaitingSink
									) ;

									if ( SUCCEEDED ( t_Result ) )
									{
										t_Result = t_WaitingSink->Wait ( INFINITE ) ;

										if ( SUCCEEDED ( t_Result ) )
										{
											if ( SUCCEEDED ( t_WaitingSink->GetResult () ) )
											{
												t_OwningRegistration = TRUE ;

												CriticalSection &t_CriticalSection = t_WaitingSink->GetQueueCriticalSection () ;

												WmiHelper :: EnterCriticalSection ( & t_CriticalSection ) ;

												IWbemClassObject *t_Object = NULL ;
												while ( ( t_StatusCode = t_Queue.Top ( t_Object ) ) == e_StatusCode_Success )
												{
													t_Object->Release () ;
													t_StatusCode = t_Queue.DeQueue () ;
												}

												WmiHelper :: LeaveCriticalSection ( & t_CriticalSection ) ;
											}
											else
											{
												if ( t_Result == WBEM_E_NOT_FOUND || t_Result  == WBEM_E_INVALID_CLASS || t_Result == WBEM_E_PROVIDER_NOT_CAPABLE )
												{
													t_Result = S_OK ;
												}
											}
										}
									}
									else
									{
										if ( t_Result == WBEM_E_NOT_FOUND || t_Result  == WBEM_E_INVALID_CLASS || t_Result == WBEM_E_PROVIDER_NOT_CAPABLE )
										{
											t_Result = S_OK ;
										}
									}

									CriticalSection &t_CriticalSection = t_WaitingSink->GetQueueCriticalSection () ;

									WmiHelper :: EnterCriticalSection ( & t_CriticalSection ) ;

									IWbemClassObject *t_Object = NULL ;
									while ( ( t_StatusCode = t_Queue.Top ( t_Object ) ) == e_StatusCode_Success )
									{
										t_Object->Release () ;
										t_StatusCode = t_Queue.DeQueue () ;
									}

									WmiHelper :: LeaveCriticalSection ( & t_CriticalSection ) ;
								}
								else
								{
									t_Result = WBEM_E_OUT_OF_MEMORY ;
								}
							}

							t_WaitingSink->Release () ;
						}
						else
						{
							t_Result = WBEM_E_OUT_OF_MEMORY ;
						}
					}

					t_Provider->Release () ;
				}
			}
		}

		if ( SUCCEEDED ( t_Result ) )
		{
			if ( t_OwningRegistration )
			{
				if ( ( a_Flags & ( WBEM_FLAG_CREATE_ONLY | WBEM_FLAG_UPDATE_ONLY ) ) == WBEM_FLAG_CREATE_ONLY )
				{
					t_Result = WBEM_E_ALREADY_EXISTS ;
				}

				if ( SUCCEEDED ( t_Result ) )
				{
					t_Result = PutClass_Helper_Put_CreateOrUpdate ( 

						t_Variant.bstrVal ,							
						a_Object, 
						( ( a_Flags & ( WBEM_FLAG_CREATE_ONLY | WBEM_FLAG_UPDATE_ONLY ) ) == WBEM_FLAG_CREATE_OR_UPDATE ) ? a_Flags | WBEM_FLAG_UPDATE_ONLY : a_Flags & ( ~WBEM_FLAG_CREATE_ONLY ) , 
						a_Context,
						a_Sink
					) ;
				}
			}
			else
			{
				if ( ( a_Flags & ( WBEM_FLAG_CREATE_ONLY | WBEM_FLAG_UPDATE_ONLY ) ) == WBEM_FLAG_UPDATE_ONLY ) 
				{
					t_Result = WBEM_E_NOT_FOUND ;
				}

				if ( SUCCEEDED ( t_Result ) )
				{
					t_Result = PutClass_Helper_Put_CreateOrUpdate ( 

						t_Variant.bstrVal ,							
						a_Object, 
						( ( a_Flags & ( WBEM_FLAG_CREATE_ONLY | WBEM_FLAG_UPDATE_ONLY ) ) == WBEM_FLAG_CREATE_OR_UPDATE ) ? a_Flags | WBEM_FLAG_CREATE_ONLY  : a_Flags & ( ~WBEM_FLAG_UPDATE_ONLY ) , 
						a_Context,
						a_Sink
					) ;
				}
			}
		}

		VariantClear ( & t_Variant ) ;
	}

	if ( SUCCEEDED ( t_Result ) )
	{
		if ( t_FoundProvider == FALSE ) 
		{
			t_Result = WBEM_E_NOT_FOUND ;
		}
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CAggregator_IWbemProvider :: PutClassAsync ( 
		
	IWbemClassObject *a_Object, 
	long a_Flags, 
	IWbemContext *a_Context,
	IWbemObjectSink *a_Sink
) 
{
	HRESULT t_Result = S_OK ;

	if ( m_Initialized == 0 )
	{
		if ( WBEM_FLAG_ADVISORY & a_Flags )
		{
			a_Sink->SetStatus ( 0 , S_OK , NULL , NULL ) ;

			return S_OK ;
		}
		else
		{
			a_Sink->SetStatus ( 0 , WBEM_E_NOT_FOUND , NULL , NULL ) ;

			return WBEM_E_NOT_FOUND ;
		}
	}

	if ( WBEM_FLAG_ADVISORY & a_Flags )
	{
		if ( m_ClassProvidersCount )
		{
			t_Result = PutClass_Helper_Advisory ( 

				a_Object ,
				a_Flags, 
				a_Context,
				a_Sink
			) ;
		}
	}
	else
	{
		if ( m_ClassProvidersCount )
		{
			t_Result = PutClass_Helper_Put ( 

				a_Object ,
				a_Flags, 
				a_Context,
				a_Sink
			) ;
		}
		else
		{
			t_Result = WBEM_E_NOT_FOUND ;
		}
	}

	a_Sink->SetStatus ( 0 , t_Result , NULL , NULL ) ;

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CAggregator_IWbemProvider :: DeleteClass ( 
		
	const BSTR a_Class, 
	long a_Flags, 
	IWbemContext *a_Context,
	IWbemCallResult **a_CallResult
) 
{
 	 return WBEM_E_NOT_AVAILABLE ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CAggregator_IWbemProvider :: DeleteClass_Helper_Advisory ( 

	IWbemClassObject *a_ClassObject ,
	const BSTR a_Class, 
	long a_Flags, 
	IWbemContext *a_Context,
	IWbemObjectSink *a_Sink
)
{
	HRESULT t_Result = S_OK ;

	for ( ULONG t_Index = 0 ; SUCCEEDED ( t_Result ) && ( t_Index < m_ClassProvidersCount ) ; t_Index ++ )
	{
		CServerObject_ClassProviderRegistrationV1 *t_Registration = & m_ClassProviders [ t_Index ]->GetClassProviderRegistration () ;
		if ( t_Registration && SUCCEEDED ( t_Registration->GetResult () ) )
		{
			switch ( t_Registration->GetVersion () )
			{
				case 1:
				{
				}
				break ;

				case 2:
				{
					BOOL t_ProbeProvider = FALSE ;

					WmiTreeNode **t_Forest = t_Registration->GetResultSetQuery () ;
					ULONG t_ForestCount = t_Registration->GetResultSetQueryCount () ;
					if ( t_ForestCount )
					{
						for ( ULONG t_FilterIndex = 0 ; t_FilterIndex < t_ForestCount ; t_FilterIndex ++ )
						{
							QueryPreprocessor :: QuadState t_Status = QueryPreprocessor :: State_True ;

							t_Status = EnumDeep_Evaluate (

								a_ClassObject ,
								a_Context , 
								t_Forest [ t_FilterIndex ] 
							) ;

							if ( ( t_Status == QueryPreprocessor :: State_True ) || ( t_Status == QueryPreprocessor :: State_Undefined ) )
							{
								t_ProbeProvider = TRUE ;
							}
						}
					}
					else
					{
						t_ProbeProvider = TRUE ;
					}

					if ( t_ProbeProvider )
					{
						IWbemServices *t_Provider = NULL ;

						WmiInternalContext t_InternalContext ;
						ZeroMemory ( & t_InternalContext , sizeof ( t_InternalContext ) ) ;

						t_Result = m_Factory->GetProvider ( 

							t_InternalContext ,
							0 ,
							a_Context ,
							NULL ,
							m_User ,
							m_Locale ,
							NULL ,
							m_ClassProviders [ t_Index ]->GetProviderName () ,
							IID_IWbemServices , 
							( void ** ) & t_Provider 
						) ;

						if ( SUCCEEDED ( t_Result ) )
						{
							if ( t_Registration->InteractionType () == e_InteractionType_Pull )
							{
								CInterceptor_IWbemWaitingObjectSink_DeleteClassAsync *t_DeletingSink = new CInterceptor_IWbemWaitingObjectSink_DeleteClassAsync (

									m_Allocator , 
									t_Provider ,
									a_Sink ,
									( CWbemGlobal_IWmiObjectSinkController * ) this ,
									*m_ClassProviders [ t_Index ]
								) ;

								if ( t_DeletingSink )
								{
									t_DeletingSink->AddRef () ;

									t_Result = t_DeletingSink->Initialize ( 
									
										m_ClassProviders [ t_Index ]->GetComRegistration ().GetSecurityDescriptor () ,
										a_Class ,
										a_Flags ,
										a_Context	
									) ;

									if ( SUCCEEDED ( t_Result ) ) 
									{
										CWbemGlobal_IWmiObjectSinkController_Container_Iterator t_Iterator ;

										Lock () ;

										WmiStatusCode t_StatusCode = Insert ( 

											*t_DeletingSink ,
											t_Iterator
										) ;

										UnLock () ;

										if ( t_StatusCode == e_StatusCode_Success ) 
										{
											t_Result = t_Provider->DeleteClassAsync ( 
													
												a_Class, 
												a_Flags & ~WBEM_FLAG_USE_AMENDED_QUALIFIERS , 
												a_Context,
												t_DeletingSink
											) ;

											if ( SUCCEEDED ( t_Result ) ) 
											{
												t_Result = t_DeletingSink->Wait ( INFINITE ) ;

												if ( SUCCEEDED ( t_Result ) )
												{
													t_Result = t_DeletingSink->GetResult () ;
													if ( FAILED ( t_Result ) )
													{
														if ( t_Result == WBEM_E_NOT_FOUND || t_Result  == WBEM_E_INVALID_CLASS || t_Result == WBEM_E_PROVIDER_NOT_CAPABLE )
														{
															t_Result = S_OK ;
														}

													}
												}
												else
												{
													if ( t_Result == WBEM_E_NOT_FOUND || t_Result  == WBEM_E_INVALID_CLASS || t_Result == WBEM_E_PROVIDER_NOT_CAPABLE )
													{
														t_Result = S_OK ;
													}
												}
											}
										}
										else
										{
											t_Result = WBEM_E_OUT_OF_MEMORY ;
										}

										WmiQueue <IWbemClassObject *,8> &t_Queue = t_DeletingSink->GetQueue () ;

										CriticalSection &t_CriticalSection = t_DeletingSink->GetQueueCriticalSection () ;

										WmiHelper :: EnterCriticalSection ( & t_CriticalSection ) ;

										IWbemClassObject *t_Object = NULL ;
										while ( ( t_StatusCode = t_Queue.Top ( t_Object ) ) == e_StatusCode_Success )
										{
											t_Object->Release () ;
											t_StatusCode = t_Queue.DeQueue () ;
										}

										WmiHelper :: LeaveCriticalSection ( & t_CriticalSection ) ;
									}

									t_DeletingSink->Release () ;
								}
								else
								{
									t_Result = WBEM_E_OUT_OF_MEMORY ;
								}
							}

							t_Provider->Release () ;
						}
					}
				}
				break ;

				default:
				{
					t_Result = WBEM_E_INVALID_PROVIDER_REGISTRATION ;
				}
				break ;
			}
		}
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CAggregator_IWbemProvider :: DeleteClass_Helper_Enum ( 

	IWbemClassObject *a_ClassObject ,
	const BSTR a_Class, 
	long a_Flags, 
	IWbemContext *a_Context,
	IWbemObjectSink *a_Sink
)
{
	HRESULT t_Result = S_OK ;

	for ( ULONG t_Index = 0 ; SUCCEEDED ( t_Result ) && ( t_Index < m_ClassProvidersCount ) ; t_Index ++ )
	{
		CServerObject_ClassProviderRegistrationV1 *t_Registration = & m_ClassProviders [ t_Index ]->GetClassProviderRegistration () ;
		if ( t_Registration && SUCCEEDED ( t_Registration->GetResult () ) )
		{
			switch ( t_Registration->GetVersion () )
			{
				case 1:
				{
					BOOL t_EnumProbeProvider = FALSE ;

					WmiTreeNode **t_Forest = t_Registration->GetResultSetQuery () ;
					ULONG t_ForestCount = t_Registration->GetResultSetQueryCount () ;
					if ( t_ForestCount )
					{
						for ( ULONG t_FilterIndex = 0 ; t_FilterIndex < t_ForestCount ; t_FilterIndex ++ )
						{
							QueryPreprocessor :: QuadState t_Status = QueryPreprocessor :: State_True ;

							t_Status = EnumDeep_Evaluate (

								a_ClassObject ,
								a_Context , 
								t_Forest [ t_FilterIndex ] 
							) ;

							if ( ( t_Status == QueryPreprocessor :: State_True ) || ( t_Status == QueryPreprocessor :: State_Undefined ) )
							{
								t_EnumProbeProvider = TRUE ;
							}
						}
					}
					else
					{
						t_EnumProbeProvider = TRUE ;
					}

					if ( t_EnumProbeProvider )
					{
						IWbemServices *t_Provider = NULL ;

						WmiInternalContext t_InternalContext ;
						ZeroMemory ( & t_InternalContext , sizeof ( t_InternalContext ) ) ;

						t_Result = m_Factory->GetProvider ( 

							t_InternalContext ,
							0 ,
							a_Context ,
							NULL ,
							m_User ,
							m_Locale ,
							NULL ,
							m_ClassProviders [ t_Index ]->GetProviderName () ,
							IID_IWbemServices , 
							( void ** ) & t_Provider 
						) ;

						if ( SUCCEEDED ( t_Result ) )
						{
							CInterceptor_IWbemWaitingObjectSink_CreateClassEnumAsync *t_EnumeratingSink = new CInterceptor_IWbemWaitingObjectSink_CreateClassEnumAsync (

								m_Allocator , 
								t_Provider ,
								a_Sink ,
								( CWbemGlobal_IWmiObjectSinkController * ) this ,
								*m_ClassProviders [ t_Index ]
							) ;

							if ( t_EnumeratingSink )
							{
								t_EnumeratingSink->AddRef () ;

								t_Result = t_EnumeratingSink->Initialize (
								
									m_ClassProviders [ t_Index ]->GetComRegistration ().GetSecurityDescriptor () ,
									a_Class, 
									WBEM_FLAG_DEEP, 
									a_Context
								) ;

								if ( SUCCEEDED ( t_Result ) ) 
								{
									CWbemGlobal_IWmiObjectSinkController_Container_Iterator t_Iterator ;

									Lock () ;

									WmiStatusCode t_StatusCode = Insert ( 

										*t_EnumeratingSink ,
										t_Iterator
									) ;

									UnLock () ;

									if ( t_StatusCode == e_StatusCode_Success ) 
									{
										t_Result = t_Provider->CreateClassEnumAsync ( 
												
											a_Class, 
											WBEM_FLAG_DEEP, 
											a_Context,
											t_EnumeratingSink
										) ;

										if ( SUCCEEDED ( t_Result ) )
										{
											t_Result = t_EnumeratingSink->Wait ( INFINITE ) ;
											if ( SUCCEEDED ( t_Result ) )
											{
												t_Result = t_EnumeratingSink->GetResult () ;
												if ( SUCCEEDED ( t_Result ) )
												{
													WmiQueue <IWbemClassObject *,8> &t_Queue = t_EnumeratingSink->GetQueue () ;

													CriticalSection &t_CriticalSection = t_EnumeratingSink->GetQueueCriticalSection () ;

													WmiHelper :: EnterCriticalSection ( & t_CriticalSection ) ;

													IWbemClassObject *t_Object = NULL ;

													WmiStatusCode t_StatusCode = e_StatusCode_Success ;

													while ( ( t_StatusCode = t_Queue.Top ( t_Object ) ) == e_StatusCode_Success )
													{
														VARIANT t_Variant ;
														VariantInit ( & t_Variant ) ;

														LONG t_VarType = 0 ;
														LONG t_Flavour = 0 ;

														t_Result = t_Object->Get ( L"__Class" , 0 , & t_Variant , & t_VarType , & t_Flavour ) ;
														if ( SUCCEEDED ( t_Result ) )
														{
															CInterceptor_IWbemWaitingObjectSink_DeleteClassAsync *t_DeletingSink = new CInterceptor_IWbemWaitingObjectSink_DeleteClassAsync (

																m_Allocator ,
																t_Provider ,
																a_Sink ,
																( CWbemGlobal_IWmiObjectSinkController * ) this ,
																*m_ClassProviders [ t_Index ]
															) ;

															if ( t_DeletingSink )
															{
																t_DeletingSink->AddRef () ;

																t_Result = t_DeletingSink->Initialize ( 
																
																	m_ClassProviders [ t_Index ]->GetComRegistration ().GetSecurityDescriptor () ,
																	t_Variant.bstrVal , 
																	a_Flags & ~WBEM_FLAG_USE_AMENDED_QUALIFIERS ,
																	a_Context
																) ;

																if ( SUCCEEDED ( t_Result ) ) 
																{
																	CWbemGlobal_IWmiObjectSinkController_Container_Iterator t_Iterator ;

																	Lock () ;

																	WmiStatusCode t_StatusCode = Insert ( 

																		*t_DeletingSink ,
																		t_Iterator
																	) ;

																	UnLock () ;

																	if ( t_StatusCode == e_StatusCode_Success ) 
																	{
																		t_Result = t_Provider->DeleteClassAsync ( 
																				
																			t_Variant.bstrVal , 
																			a_Flags & ~WBEM_FLAG_USE_AMENDED_QUALIFIERS , 
																			a_Context,
																			t_DeletingSink
																		) ;

																		if ( SUCCEEDED ( t_Result ) )
																		{
																			t_Result = t_DeletingSink->Wait ( INFINITE ) ;
																			if ( SUCCEEDED ( t_Result ) )
																			{
																				if ( SUCCEEDED ( t_DeletingSink->GetResult () ) )
																				{
																				}
																				else
																				{
																					if ( t_Result == WBEM_E_NOT_FOUND || t_Result  == WBEM_E_INVALID_CLASS )
																					{
																						t_Result = S_OK ;
																					}
																				}
																			}
																		}
																		else
																		{
																			if ( t_Result == WBEM_E_NOT_FOUND || t_Result  == WBEM_E_INVALID_CLASS )
																			{
																				t_Result = S_OK ;
																			}
																		}
																	}
																	else
																	{
																		t_Result = WBEM_E_OUT_OF_MEMORY ;
																	}

																	WmiQueue <IWbemClassObject *,8> &t_Queue = t_DeletingSink->GetQueue () ;

																	CriticalSection &t_CriticalSection = t_DeletingSink->GetQueueCriticalSection () ;

																	WmiHelper :: EnterCriticalSection ( & t_CriticalSection ) ;

																	IWbemClassObject *t_Object = NULL ;
																	while ( ( t_StatusCode = t_Queue.Top ( t_Object ) ) == e_StatusCode_Success )
																	{
																		t_Object->Release () ;
																		t_StatusCode = t_Queue.DeQueue () ;
																	}

																	WmiHelper :: LeaveCriticalSection ( & t_CriticalSection ) ;
																}

																t_DeletingSink->Release () ;
															}
															else
															{
																t_Result = WBEM_E_OUT_OF_MEMORY ;
															}

															VariantClear ( & t_Variant ) ;
														}
														else
														{
															t_Result = WBEM_E_CRITICAL_ERROR ;
														}

														t_Object->Release () ;

														t_StatusCode = t_Queue.DeQueue () ;
													}

													WmiHelper :: LeaveCriticalSection ( & t_CriticalSection ) ;

												}
												else
												{
													if ( t_Result == WBEM_E_NOT_FOUND || t_Result  == WBEM_E_INVALID_CLASS || t_Result == WBEM_E_PROVIDER_NOT_CAPABLE )
													{
														t_Result = S_OK ;
													}
												}
											}
										}
										else
										{
											if ( t_Result == WBEM_E_NOT_FOUND || t_Result  == WBEM_E_INVALID_CLASS || t_Result == WBEM_E_PROVIDER_NOT_CAPABLE )
											{
												t_Result = S_OK ;
											}
										}
									}
									else
									{
										t_Result = WBEM_E_OUT_OF_MEMORY ;
									}
								}

								t_EnumeratingSink->Release () ;
							}
							else
							{
								t_Result = WBEM_E_OUT_OF_MEMORY ;
							}

							t_Provider->Release () ;
						}
					}
				}
				break ;

				case 2:
				{
				}
				break ;

				default:
				{
					t_Result = WBEM_E_INVALID_PROVIDER_REGISTRATION ;
				}
				break ;
			}
		}
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CAggregator_IWbemProvider :: DeleteClass_Helper_Get ( 

	IWbemClassObject *a_ClassObject ,
	const BSTR a_Class, 
	long a_Flags, 
	IWbemContext *a_Context,
	IWbemObjectSink *a_Sink
)
{
	HRESULT t_Result = S_OK ;

	BOOL t_ClassDeleted = FALSE ;

	for ( ULONG t_Index = 0 ; SUCCEEDED ( t_Result ) && ( t_Index < m_ClassProvidersCount ) ; t_Index ++ )
	{
		BOOL t_EnumProbeProvider = FALSE ;

		CServerObject_ClassProviderRegistrationV1 *t_Registration = & m_ClassProviders [ t_Index ]->GetClassProviderRegistration () ;
		if ( t_Registration && SUCCEEDED ( t_Registration->GetResult () ) )
		{
			WmiTreeNode **t_Forest = t_Registration->GetResultSetQuery () ;
			ULONG t_ForestCount = t_Registration->GetResultSetQueryCount () ;
			if ( t_ForestCount )
			{
				for ( ULONG t_FilterIndex = 0 ; t_FilterIndex < t_ForestCount ; t_FilterIndex ++ )
				{
					QueryPreprocessor :: QuadState t_Status = QueryPreprocessor :: State_True ;

					t_Status = Get_Evaluate (

						a_Class ,
						a_Context , 
						t_Forest [ t_FilterIndex ] 
					) ;

					if ( ( t_Status == QueryPreprocessor :: State_True ) || ( t_Status == QueryPreprocessor :: State_Undefined ) )
					{
						t_EnumProbeProvider = TRUE ;
					}
				}
			}
			else
			{
				t_EnumProbeProvider = TRUE ;
			}
		}

		if ( t_EnumProbeProvider )
		{
			IWbemServices *t_Provider = NULL ;

			WmiInternalContext t_InternalContext ;
			ZeroMemory ( & t_InternalContext , sizeof ( t_InternalContext ) ) ;

			t_Result = m_Factory->GetProvider ( 

				t_InternalContext ,
				0 ,
				a_Context ,
				NULL ,
				m_User ,
				m_Locale ,
				NULL ,
				m_ClassProviders [ t_Index ]->GetProviderName () ,
				IID_IWbemServices , 
				( void ** ) & t_Provider 
			) ;

			if ( SUCCEEDED ( t_Result ) )
			{
				if ( t_Registration->InteractionType () == e_InteractionType_Pull )
				{
					CInterceptor_IWbemWaitingObjectSink_GetObjectAsync *t_GettingSink = new CInterceptor_IWbemWaitingObjectSink_GetObjectAsync (

						m_Allocator , 
						t_Provider ,
						a_Sink ,
						( CWbemGlobal_IWmiObjectSinkController * ) this ,
						*m_ClassProviders [ t_Index ]
					) ;

					if ( t_GettingSink )
					{
						t_GettingSink->AddRef () ;

						t_Result = t_GettingSink->Initialize (

							m_ClassProviders [ t_Index ]->GetComRegistration ().GetSecurityDescriptor () ,
							a_Class, 
							0 , 
							a_Context
						) ;

						if ( SUCCEEDED ( t_Result ) ) 
						{
							CWbemGlobal_IWmiObjectSinkController_Container_Iterator t_Iterator ;

							Lock () ;

							WmiStatusCode t_StatusCode = Insert ( 

								*t_GettingSink ,
								t_Iterator
							) ;

							UnLock () ;

							if ( t_StatusCode == e_StatusCode_Success ) 
							{
								t_Result = t_Provider->GetObjectAsync ( 
										
									a_Class, 
									0 , 
									a_Context,
									t_GettingSink
								) ;

								if ( SUCCEEDED ( t_Result ) )
								{
									t_Result = t_GettingSink->Wait ( INFINITE ) ;
									if ( SUCCEEDED ( t_Result ) )
									{
										t_Result = t_GettingSink->GetResult () ;
										if ( SUCCEEDED ( t_Result ) )
										{
											CInterceptor_IWbemWaitingObjectSink_DeleteClassAsync *t_DeletingSink = new CInterceptor_IWbemWaitingObjectSink_DeleteClassAsync (

												m_Allocator ,
												t_Provider ,
												a_Sink ,
												( CWbemGlobal_IWmiObjectSinkController * ) this ,
												*m_ClassProviders [ t_Index ]
											) ;

											if ( t_DeletingSink )
											{
												t_DeletingSink->AddRef () ;

												t_Result = t_DeletingSink->Initialize ( 
												
													m_ClassProviders [ t_Index ]->GetComRegistration ().GetSecurityDescriptor () ,
													a_Class , 
													a_Flags & ~WBEM_FLAG_USE_AMENDED_QUALIFIERS , 
													a_Context
												) ;

												if ( SUCCEEDED ( t_Result ) ) 
												{
													CWbemGlobal_IWmiObjectSinkController_Container_Iterator t_Iterator ;

													Lock () ;

													WmiStatusCode t_StatusCode = Insert ( 

														*t_DeletingSink ,
														t_Iterator
													) ;

													UnLock () ;

													if ( t_StatusCode == e_StatusCode_Success ) 
													{
														t_Result = t_Provider->DeleteClassAsync ( 
																
															a_Class, 
															a_Flags & ~WBEM_FLAG_USE_AMENDED_QUALIFIERS , 
															a_Context,
															t_DeletingSink
														) ;

														if ( SUCCEEDED ( t_Result ) )
														{
															t_Result = t_DeletingSink->Wait ( INFINITE ) ;
															if ( SUCCEEDED ( t_Result ) )
															{
																if ( SUCCEEDED ( t_DeletingSink->GetResult () ) )
																{
																	t_ClassDeleted = TRUE ;
																}
															}
															else
															{
																if ( t_Result == WBEM_E_NOT_FOUND || t_Result  == WBEM_E_INVALID_CLASS )
																{
																	t_Result = S_OK ;
																}
															}
														}
														else
														{
															if ( t_Result == WBEM_E_NOT_FOUND || t_Result  == WBEM_E_INVALID_CLASS )
															{
																t_Result = S_OK ;
															}
														}
													}
													else
													{
														t_Result = WBEM_E_OUT_OF_MEMORY ;
													}

													WmiQueue <IWbemClassObject *,8> &t_Queue = t_DeletingSink->GetQueue () ;

													CriticalSection &t_CriticalSection = t_DeletingSink->GetQueueCriticalSection () ;

													WmiHelper :: EnterCriticalSection ( & t_CriticalSection ) ;

													IWbemClassObject *t_Object = NULL ;
													while ( ( t_StatusCode = t_Queue.Top ( t_Object ) ) == e_StatusCode_Success )
													{
														t_Object->Release () ;
														t_StatusCode = t_Queue.DeQueue () ;
													}

													WmiHelper :: LeaveCriticalSection ( & t_CriticalSection ) ;
												}

												t_DeletingSink->Release () ;
											}
											else
											{
												t_Result = WBEM_E_OUT_OF_MEMORY ;
											}
										}
										else
										{
											if ( t_Result == WBEM_E_NOT_FOUND || t_Result  == WBEM_E_INVALID_CLASS || t_Result == WBEM_E_PROVIDER_NOT_CAPABLE )
											{
												t_Result = S_OK ;
											}
										}
									}
								}
								else
								{
									if ( t_Result == WBEM_E_NOT_FOUND || t_Result  == WBEM_E_INVALID_CLASS || t_Result == WBEM_E_PROVIDER_NOT_CAPABLE )
									{
										t_Result = S_OK ;
									}
								}
							}
							else
							{
								t_Result = WBEM_E_OUT_OF_MEMORY ;
							}

							WmiQueue <IWbemClassObject *,8> &t_Queue = t_GettingSink->GetQueue () ;

							CriticalSection &t_CriticalSection = t_GettingSink->GetQueueCriticalSection () ;

							WmiHelper :: EnterCriticalSection ( & t_CriticalSection ) ;

							IWbemClassObject *t_Object = NULL ;
							while ( ( t_StatusCode = t_Queue.Top ( t_Object ) ) == e_StatusCode_Success )
							{
								t_Object->Release () ;
								t_StatusCode = t_Queue.DeQueue () ;
							}

							WmiHelper :: LeaveCriticalSection ( & t_CriticalSection ) ;
						}
					
						t_GettingSink->Release () ;
					}
					else
					{
						t_Result = WBEM_E_OUT_OF_MEMORY ;
					}
				}

				t_Provider->Release () ;
			}
		}
	}

	if ( SUCCEEDED ( t_Result ) )
	{
		if ( t_ClassDeleted == FALSE )
		{
			t_Result = WBEM_E_NOT_FOUND ;
		}
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CAggregator_IWbemProvider :: DeleteClassAsync ( 
		
	const BSTR a_Class, 
	long a_Flags, 
	IWbemContext *a_Context,
	IWbemObjectSink *a_Sink
) 
{
	HRESULT t_Result = S_OK ;

	if ( m_Initialized == 0 )
	{
		if ( WBEM_FLAG_ADVISORY & a_Flags )
		{
			a_Sink->SetStatus ( 0 , S_OK , NULL , NULL ) ;

			return S_OK ;
		}
		else
		{
			a_Sink->SetStatus ( 0 , WBEM_E_NOT_FOUND , NULL , NULL ) ;

			return WBEM_E_NOT_FOUND ;
		}
	}

	IWbemClassObject *t_ClassObject = NULL ;

	t_Result = m_CoreFullStub->GetObject ( 

		a_Class ,
		0 ,
		a_Context , 
		& t_ClassObject , 
		NULL 
	) ;

	if ( SUCCEEDED ( t_Result ) ) 
	{
		if ( WBEM_FLAG_ADVISORY & a_Flags )
		{
			t_Result = DeleteClass_Helper_Advisory ( 

				t_ClassObject ,
				a_Class, 
				a_Flags, 
				a_Context,
				a_Sink
			) ;
		}
		else
		{
			t_Result = DeleteClass_Helper_Enum ( 

				t_ClassObject ,
				a_Class, 
				a_Flags, 
				a_Context,
				a_Sink
			) ;

			if ( SUCCEEDED ( t_Result ) )
			{
				t_Result = DeleteClass_Helper_Get ( 

					t_ClassObject ,
					a_Class, 
					a_Flags, 
					a_Context,
					a_Sink
				) ;
			}
		}

		t_ClassObject->Release () ;
	}

	a_Sink->SetStatus ( 0 , t_Result , NULL , NULL ) ;

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CAggregator_IWbemProvider :: CreateClassEnum ( 

	const BSTR a_Superclass, 
	long a_Flags, 
	IWbemContext *a_Context,
	IEnumWbemClassObject **a_Enum
) 
{
	return WBEM_E_NOT_AVAILABLE ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

SCODE CAggregator_IWbemProvider :: CreateClassEnumAsync (

	const BSTR a_Superclass , 
	long a_Flags, 
	IWbemContext *a_Context,
	IWbemObjectSink *a_Sink
) 
{
	HRESULT t_Result = S_OK ;

	if ( m_Initialized == 0 )
	{
		a_Sink->SetStatus ( 0 , S_OK , NULL , NULL ) ;

		return S_OK ;
	}

	if ( m_ClassProvidersCount )
	{
		IWbemClassObject *t_SuperclassObject = NULL ;

		if ( wcscmp ( L"" , a_Superclass ) != 0 )
		{
			t_Result = m_CoreFullStub->GetObject ( 

				a_Superclass ,
				0 ,
				a_Context , 
				& t_SuperclassObject , 
				NULL 
			) ;
		}

		if ( SUCCEEDED ( t_Result ) ) 
		{
			BOOL t_ClassProviderFound = FALSE ;

			for ( ULONG t_Index = 0 ; t_Index < m_ClassProvidersCount ; t_Index ++ )
			{
				BOOL t_ProbeProvider = FALSE ;

				CServerObject_ClassProviderRegistrationV1 *t_Registration = & m_ClassProviders [ t_Index ]->GetClassProviderRegistration () ;
				if ( t_Registration && SUCCEEDED ( t_Registration->GetResult () ) )
				{
					if ( t_SuperclassObject )
					{
						WmiTreeNode **t_Forest = t_Registration->GetResultSetQuery () ;
						ULONG t_ForestCount = t_Registration->GetResultSetQueryCount () ;
						if ( t_ForestCount )
						{
							for ( ULONG t_FilterIndex = 0 ; t_FilterIndex < t_ForestCount ; t_FilterIndex ++ )
							{
								QueryPreprocessor :: QuadState t_Status = QueryPreprocessor :: State_True ;

								if ( ( a_Flags & ( WBEM_FLAG_DEEP | WBEM_FLAG_SHALLOW ) ) == WBEM_FLAG_DEEP )
								{
									t_Status = EnumDeep_Evaluate (

										t_SuperclassObject ,
										a_Context , 
										t_Forest [ t_FilterIndex ] 
									) ;
								}
								else
								{
									t_Status = EnumShallow_Evaluate (

										t_SuperclassObject ,
										a_Context , 
										t_Forest [ t_FilterIndex ] 
									) ;
								}

								if ( ( t_Status == QueryPreprocessor :: State_True ) || ( t_Status == QueryPreprocessor :: State_Undefined ) )
								{
									t_ProbeProvider = TRUE ;
								}
							}
						}
						else
						{
							t_ProbeProvider = TRUE ;
						}
					}
					else
					{
						t_ProbeProvider = TRUE ;
					}
				}

				if ( t_ProbeProvider )
				{
					IWbemServices *t_Provider = NULL ;

					WmiInternalContext t_InternalContext ;
					ZeroMemory ( & t_InternalContext , sizeof ( t_InternalContext ) ) ;

					t_Result = m_Factory->GetProvider ( 

						t_InternalContext ,
						0 ,
						a_Context ,
						NULL ,
						m_User ,
						m_Locale ,
						NULL ,
						m_ClassProviders [ t_Index ]->GetProviderName () ,
						IID_IWbemServices , 
						( void ** ) & t_Provider 
					) ;

					if ( SUCCEEDED ( t_Result ) )
					{
						if ( t_Registration->InteractionType () == e_InteractionType_Pull )
						{
							CInterceptor_IWbemWaitingObjectSink_CreateClassEnumAsync *t_WaitingSink = new CInterceptor_IWbemWaitingObjectSink_CreateClassEnumAsync (

								m_Allocator ,
								t_Provider ,
								a_Sink ,
								( CWbemGlobal_IWmiObjectSinkController * ) this ,
								*m_ClassProviders [ t_Index ]
							) ;

							if ( t_WaitingSink )
							{
								t_WaitingSink->AddRef () ;

								t_Result = t_WaitingSink->Initialize (
								
									m_ClassProviders [ t_Index ]->GetComRegistration ().GetSecurityDescriptor () ,
									a_Superclass , 
									a_Flags, 
									a_Context
								) ;

								if ( SUCCEEDED ( t_Result ) ) 
								{
									CWbemGlobal_IWmiObjectSinkController_Container_Iterator t_Iterator ;

									Lock () ;

									WmiStatusCode t_StatusCode = Insert ( 

										*t_WaitingSink ,
										t_Iterator
									) ;

									UnLock () ;

									if ( t_StatusCode == e_StatusCode_Success ) 
									{
										t_ClassProviderFound = TRUE ;

										t_Result = t_Provider->CreateClassEnumAsync ( 
												
											a_Superclass, 
											a_Flags, 
											a_Context,
											t_WaitingSink
										) ;

										if ( SUCCEEDED ( t_Result ) )
										{
											t_Result = t_WaitingSink->Wait ( INFINITE ) ;
											if ( SUCCEEDED ( t_Result ) )
											{
												if ( SUCCEEDED ( t_WaitingSink->GetResult () ) )
												{
													WmiQueue <IWbemClassObject *,8> &t_Queue = t_WaitingSink->GetQueue () ;

													CriticalSection &t_CriticalSection = t_WaitingSink->GetQueueCriticalSection () ;

													WmiHelper :: EnterCriticalSection ( & t_CriticalSection ) ;

													WmiStatusCode t_StatusCode = e_StatusCode_Success ;

													IWbemClassObject *t_Object = NULL ;
													while ( ( t_StatusCode = t_Queue.Top ( t_Object ) ) == e_StatusCode_Success )
													{
														if(SUCCEEDED(t_Result))
															t_Result = a_Sink->Indicate ( 1 , & t_Object ) ;

														t_Object->Release () ;
														t_StatusCode = t_Queue.DeQueue () ;
													}

													WmiHelper :: LeaveCriticalSection ( & t_CriticalSection ) ;
												}
												else
												{
													t_Result = S_OK ;
												}
											}
											else
											{
											}
										}
										else
										{
											t_Result = S_OK ;
										}
									}
									else
									{
										t_Result = WBEM_E_OUT_OF_MEMORY ;
									}
								}

								t_WaitingSink->Release () ;
							}
							else
							{
								t_Result = WBEM_E_OUT_OF_MEMORY ;
							}
						}

						t_Provider->Release () ;
					}
					else
					{
						t_Result = S_OK ;
					}
				}
			}

			a_Sink->SetStatus ( 0 , t_Result , NULL , NULL ) ;
		}
		else if ( t_Result == WBEM_E_NOT_FOUND )
		{
			a_Sink->SetStatus ( 0 , t_Result , NULL , NULL ) ;
		}

		if ( t_SuperclassObject )
		{
			t_SuperclassObject->Release () ;
		}
	}
	else
	{
		t_Result = WBEM_E_NOT_FOUND;
		a_Sink->SetStatus ( 0 , t_Result , NULL , NULL ) ;
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CAggregator_IWbemProvider :: PutInstance (

    IWbemClassObject *a_Instance,
    long a_Flags,
    IWbemContext *a_Context,
	IWbemCallResult **a_CallResult
) 
{
	return WBEM_E_NOT_AVAILABLE ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CAggregator_IWbemProvider :: PutInstanceAsync ( 
		
	IWbemClassObject *a_Instance, 
	long a_Flags ,
    IWbemContext *a_Context ,
	IWbemObjectSink *a_Sink
) 
{
	HRESULT t_Result = WBEM_E_NOT_AVAILABLE ;

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CAggregator_IWbemProvider :: DeleteInstance ( 

	const BSTR a_ObjectPath,
    long a_Flags,
    IWbemContext *a_Context,
    IWbemCallResult **a_CallResult
)
{
	return WBEM_E_NOT_AVAILABLE ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/
        
HRESULT CAggregator_IWbemProvider :: DeleteInstanceAsync (
 
	const BSTR a_ObjectPath,
    long a_Flags,
    IWbemContext *a_Context,
    IWbemObjectSink *a_Sink
)
{
	HRESULT t_Result = WBEM_E_NOT_AVAILABLE ;

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CAggregator_IWbemProvider :: CreateInstanceEnum ( 

	const BSTR a_Class, 
	long a_Flags, 
	IWbemContext *a_Context, 
	IEnumWbemClassObject **a_Enum
)
{
	return WBEM_E_NOT_AVAILABLE ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CAggregator_IWbemProvider :: CreateInstanceEnumAsync (

 	const BSTR a_Class ,
	long a_Flags ,
	IWbemContext *a_Context ,
	IWbemObjectSink *a_Sink

) 
{
	HRESULT t_Result = WBEM_E_NOT_AVAILABLE ;

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CAggregator_IWbemProvider :: ExecQuery ( 

	const BSTR a_QueryLanguage, 
	const BSTR a_Query, 
	long a_Flags, 
	IWbemContext *a_Context,
	IEnumWbemClassObject **a_Enum
)
{
	return WBEM_E_NOT_AVAILABLE ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CAggregator_IWbemProvider :: ExecQueryAsync ( 
		
	const BSTR a_QueryLanguage, 
	const BSTR a_Query, 
	long a_Flags, 
	IWbemContext *a_Context,
	IWbemObjectSink *a_Sink
) 
{
	HRESULT t_Result = WBEM_E_NOT_AVAILABLE ;

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CAggregator_IWbemProvider :: ExecNotificationQuery ( 

	const BSTR a_QueryLanguage,
    const BSTR a_Query,
    long a_Flags,
    IWbemContext *a_Context,
    IEnumWbemClassObject **a_Enum
)
{
	return WBEM_E_NOT_AVAILABLE ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/
        
HRESULT CAggregator_IWbemProvider :: ExecNotificationQueryAsync ( 
            
	const BSTR a_QueryLanguage ,
    const BSTR a_Query,
    long a_Flags,
    IWbemContext *a_Context,
    IWbemObjectSink *a_Sink
)
{
	return WBEM_E_NOT_AVAILABLE ;
}       

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT STDMETHODCALLTYPE CAggregator_IWbemProvider :: ExecMethod ( 

	const BSTR a_ObjectPath ,
    const BSTR a_MethodName ,
    long a_Flags ,
    IWbemContext *a_Context ,
    IWbemClassObject *a_InParams ,
    IWbemClassObject **a_OutParams ,
    IWbemCallResult **a_CallResult
)
{
	return WBEM_E_NOT_AVAILABLE ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT STDMETHODCALLTYPE CAggregator_IWbemProvider :: ExecMethodAsync ( 

    const BSTR a_ObjectPath,
    const BSTR a_MethodName,
    long a_Flags,
    IWbemContext *a_Context,
    IWbemClassObject *a_InParams,
	IWbemObjectSink *a_Sink
) 
{
	HRESULT t_Result = WBEM_E_NOT_AVAILABLE ;

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CAggregator_IWbemProvider :: Expel (

	long a_Flags ,
	IWbemContext *a_Context
)
{
	HRESULT t_Result = S_OK ;

	CWbemGlobal_IWmiProviderController *t_Controller = ServiceCacheElement :: GetController () ;
	if ( t_Controller )
	{
		t_Controller->Shutdown ( ServiceCacheElement :: GetKey () ) ;
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CAggregator_IWbemProvider :: ForceReload ()
{
	return WBEM_E_NOT_AVAILABLE ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CAggregator_IWbemProvider :: Shutdown (

	LONG a_Flags ,
	ULONG a_MaxMilliSeconds ,
	IWbemContext *a_Context
)
{
	HRESULT t_Result = S_OK ;

	CWbemGlobal_IWmiObjectSinkController :: Shutdown () ;

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CAggregator_IWbemProvider :: GetReferencesClasses (

	LONG a_Flags ,
	IWbemContext *a_Context ,
	IWbemObjectSink *a_Sink
)
{
	HRESULT t_Result = S_OK ;

	if ( m_Initialized == 0 )
	{
		a_Sink->SetStatus ( 0 , S_OK , NULL , NULL ) ;

		return S_OK ;
	}

	if ( m_ClassProvidersCount )
	{
		BOOL t_ClassProviderFound = FALSE ;

		for ( ULONG t_Index = 0 ; t_Index < m_ClassProvidersCount ; t_Index ++ )
		{
			BOOL t_ProbeProvider = FALSE ;

			CServerObject_ClassProviderRegistrationV1 *t_Registration = & m_ClassProviders [ t_Index ]->GetClassProviderRegistration () ;
			if ( t_Registration && SUCCEEDED ( t_Registration->GetResult () ) )
			{
				t_ProbeProvider = t_Registration->HasReferencedSet() ;
			}

			if ( t_ProbeProvider )
			{
				IWbemServices *t_Provider = NULL ;

				WmiInternalContext t_InternalContext ;
				ZeroMemory ( & t_InternalContext , sizeof ( t_InternalContext ) ) ;

				t_Result = m_Factory->GetProvider ( 

					t_InternalContext ,
					0 ,
					a_Context ,
					NULL ,
					m_User ,
					m_Locale ,
					NULL ,
					m_ClassProviders [ t_Index ]->GetProviderName () ,
					IID_IWbemServices , 
					( void ** ) & t_Provider 
				) ;

				if ( SUCCEEDED ( t_Result ) )
				{
					if ( t_Registration->InteractionType () == e_InteractionType_Pull )
					{
						CInterceptor_IWbemWaitingObjectSink_CreateClassEnumAsync *t_WaitingSink = new CInterceptor_IWbemWaitingObjectSink_CreateClassEnumAsync (

							m_Allocator ,
							t_Provider ,
							a_Sink ,
							( CWbemGlobal_IWmiObjectSinkController * ) this ,
							*m_ClassProviders [ t_Index ]
						) ;

						if ( t_WaitingSink )
						{
							t_WaitingSink->AddRef () ;

							t_Result = t_WaitingSink->Initialize (
							
								m_ClassProviders [ t_Index ]->GetComRegistration ().GetSecurityDescriptor () ,
								L"" , 
								a_Flags, 
								a_Context
							) ;

							if ( SUCCEEDED ( t_Result ) ) 
							{
								CWbemGlobal_IWmiObjectSinkController_Container_Iterator t_Iterator ;

								Lock () ;

								WmiStatusCode t_StatusCode = Insert ( 

									*t_WaitingSink ,
									t_Iterator
								) ;

								UnLock () ;

								if ( t_StatusCode == e_StatusCode_Success ) 
								{
									t_ClassProviderFound = TRUE ;

									t_Result = t_Provider->CreateClassEnumAsync ( 
											
										L"", 
										a_Flags, 
										a_Context,
										t_WaitingSink
									) ;

									if ( SUCCEEDED ( t_Result ) )
									{
										t_Result = t_WaitingSink->Wait ( INFINITE ) ;
										if ( SUCCEEDED ( t_Result ) )
										{
											if ( SUCCEEDED ( t_WaitingSink->GetResult () ) )
											{
												WmiQueue <IWbemClassObject *,8> &t_Queue = t_WaitingSink->GetQueue () ;

												CriticalSection &t_CriticalSection = t_WaitingSink->GetQueueCriticalSection () ;

												WmiHelper :: EnterCriticalSection ( & t_CriticalSection ) ;

												WmiStatusCode t_StatusCode = e_StatusCode_Success ;

												IWbemClassObject *t_Object = NULL ;
												while ( ( t_StatusCode = t_Queue.Top ( t_Object ) ) == e_StatusCode_Success )
												{
													if(SUCCEEDED(t_Result))
														t_Result = a_Sink->Indicate ( 1 , & t_Object ) ;

													t_Object->Release () ;
													t_StatusCode = t_Queue.DeQueue () ;
												}

												WmiHelper :: LeaveCriticalSection ( & t_CriticalSection ) ;
											}
											else
											{
												t_Result = S_OK ;
											}
										}
										else
										{
										}
									}
									else
									{
										t_Result = S_OK ;
									}
								}
								else
								{
									t_Result = WBEM_E_OUT_OF_MEMORY ;
								}
							}

							t_WaitingSink->Release () ;
						}
						else
						{
							t_Result = WBEM_E_OUT_OF_MEMORY ;
						}
					}

					t_Provider->Release () ;
				}
				else
				{
					t_Result = S_OK ;
				}
			}
		}

		a_Sink->SetStatus ( 0 , t_Result , NULL , NULL ) ;
	}
	else
	{
		a_Sink->SetStatus ( 0 , S_OK , NULL , NULL ) ;
	}

	return t_Result ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\provsubsys\server\main.cpp ===
/*++

Copyright (C) 1996-2001 Microsoft Corporation

Module Name:

	Main.cpp

Abstract:


History:

--*/

#include <precomp.h>

#include <objbase.h>
#include <stdio.h>
#include <tchar.h>
#include <wbemint.h>
#include <Thread.h>
#include <HelperFuncs.h>
#include <Logging.h>

#include "Globals.h"
#include "CGlobals.h"
#include "classfac.h"
#include "ProvLoad.h"
#include "ProvAggr.h"
#include "ProvHost.h"
#include "guids.h"
#include "Main.h"

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

#define VALIDATE_HEAP {};
#ifdef DEV_BUILD
#ifdef  _X86_

////////////////////////////////////////////////////////
class ValidateHeap : public EventHandler
{
	BOOL (* rtlValidateProcessHeaps)(void);
public:

	ValidateHeap () ;
	int handleTimeout (void) ;
	void validateHeap();
} heapValidator;

#undef VALIDATE_HEAP
#define VALIDATE_HEAP {heapValidator.validateHeap(); };

ValidateHeap::ValidateHeap()
{
	FARPROC OldRoutine = GetProcAddress(GetModuleHandleW(L"NTDLL"),"RtlValidateProcessHeaps");
	rtlValidateProcessHeaps = reinterpret_cast<BOOL (*)(void)>(OldRoutine) ;
}

int 
ValidateHeap::handleTimeout (void)
{
	validateHeap();
	return 0;
}

void
ValidateHeap::validateHeap (void)
{
	//NtCurrentPeb()->BeingDebugged = 1;
	if (rtlValidateProcessHeaps)
	{
	    if ((*rtlValidateProcessHeaps)()==FALSE)
		    DebugBreak();
	}
	//NtCurrentPeb()->BeingDebugged = 0;
}
////////////////////////////////////////////////////////

#include <malloc.h>

struct HEAP_ENTRY {
	WORD Size;
	WORD PrevSize;
	BYTE SegmentIndex;
	BYTE Flags;
    BYTE UnusedBytes;
	BYTE SmallTagIndex;
};

#define HEAP_SLOW_FLAGS  0x7d030f60

// only the "header"

typedef struct _HEAP {
    HEAP_ENTRY Entry;

    ULONG Signature;
    ULONG Flags;
    ULONG ForceFlags;
} HEAP;


BOOL  g_FaultHeapEnabled = FALSE;
BOOL  g_FaultFileEnabled = FALSE;
ULONG g_Seed;
ULONG g_Factor  = 100000;
ULONG g_Percent = 0x20;
//ULONG g_RowOfFailures = 5;
//LONG  g_NumFailInARow = 0;
//LONG  g_NumFailedAllocation = 0;
BOOL g_bDisableBreak = FALSE;
BOOL g_ExitProcessCalled = FALSE;
LONG g_Index = -1;


#define MAX_OPERATIONS (1024*8)

typedef struct _FinalOperations 
{
    enum OpType
    {
        Delete = 'eerF',
        Alloc  = 'ollA',
        ReAlloc = 'lAeR',
        Destroy = 'tseD',
        Create = 'aerC'        
    };
    OpType m_OpType;
    ULONG_PTR m_Addr;
    PVOID m_Stack[6];   
} FinalOperations;

FinalOperations g_FinalOp[MAX_OPERATIONS];

VOID SetFinalOp(FinalOperations::OpType Type,
	          ULONG_PTR Addr)
{
    if (!g_ExitProcessCalled)
    	return;

    if (g_bDisableBreak)
    	return;
    
    ULONG * pDW = (ULONG *)_alloca(sizeof(ULONG));
    LONG NewIndex = InterlockedIncrement(&g_Index);
    NewIndex %= MAX_OPERATIONS;
    //if (g_Index >= MAX_OPERATIONS)
    //{    	
    //	InterlockedIncrement(&g_IndexRot);
    //}
    g_FinalOp[NewIndex].m_OpType = Type;
    g_FinalOp[NewIndex].m_Addr = Addr;
    RtlCaptureStackBackTrace(2,
        		          6,
                		  (PVOID *)g_FinalOp[NewIndex].m_Stack,
                          pDW);    
}

#define SIZE_JUMP_ADR    5
#define SIZE_SAVED_INSTR 12

void
_declspec(naked) Prolog__ReadFile(){
	_asm {
		// this is the space for the "saved istructions"
		nop ;
		nop ;
        nop ;
        nop ;
		nop ;
		nop ;		
		nop ;
		nop ;
        nop ;
        nop ;
		nop ;
		nop ;
		// this is the place for the JMP
        nop ;
        nop ;
        nop ;
		nop ;
		nop ;
		nop ; // dist
		nop ; // dist		
		nop ; // dist		
		nop ; // dist		
	}
}


BOOL _I_ReadFile(
  HANDLE hFile,               // handle to file
  LPVOID lpBuffer,            // data buffer
  DWORD nNumberOfBytesToRead, // number of bytes to read
  LPDWORD lpNumberOfBytesRead, // number of bytes read  
  LPOVERLAPPED lpOverlapped   // offset
){
	DWORD * pDw = (DWORD *)_alloca(sizeof(DWORD));
    BOOL bRet;

	LONG Ret = RtlRandomEx(&g_Seed);
	if (g_FaultFileEnabled && (Ret%g_Factor < g_Percent))
	{
	    if (lpNumberOfBytesRead)
	        *lpNumberOfBytesRead = 0;
		return FALSE;
	}    
    
    _asm{
		push lpOverlapped;
        push lpNumberOfBytesRead;
		push nNumberOfBytesToRead;
		push lpBuffer;
		push hFile;
		call Prolog__ReadFile;
		mov  bRet,eax
	}

    return bRet;
}


void
_declspec(naked) Prolog__WriteFile(){
	_asm {
		// this is the space for the "saved istructions"
		nop ;
		nop ;
        nop ;
        nop ;
		nop ;
		nop ;		
		nop ;
		nop ;
        nop ;
        nop ;
		nop ;
		nop ;
		// this is the place for the JMP
        nop ;
        nop ;
        nop ;
		nop ;
		nop ;
		nop ; // dist
		nop ; // dist		
		nop ; // dist		
	}
}

BOOL _I_WriteFile(
  HANDLE hFile,                    // handle to file
  LPCVOID lpBuffer,                // data buffer
  DWORD nNumberOfBytesToWrite,     // number of bytes to write
  LPDWORD lpNumberOfBytesWritten,  // number of bytes written
  LPOVERLAPPED lpOverlapped        // overlapped buffer
){

	DWORD * pDw = (DWORD *)_alloca(sizeof(DWORD));
    BOOL bRet;

	LONG Ret = RtlRandomEx(&g_Seed);
	if (g_FaultFileEnabled && (Ret%g_Factor < g_Percent))
	{
	    if (lpNumberOfBytesWritten)
	        *lpNumberOfBytesWritten = 0;
		return FALSE;
	}    
    
    _asm{
		push lpOverlapped;
        push lpNumberOfBytesWritten;
		push nNumberOfBytesToWrite;
		push lpBuffer;
		push hFile;
		call Prolog__WriteFile;
		mov  bRet,eax
	}

    return bRet;
}


void
_declspec(naked) Prolog__CreateEvent(){
	_asm {
		// this is the space for the "saved istructions"
		nop ;
		nop ;
        nop ;
        nop ;
		nop ;
		nop ;		
		nop ;
		nop ;
        nop ;
        nop ;
		nop ;
		nop ;
		// this is the place for the JMP
        nop ;
        nop ;
        nop ;
		nop ;
		nop ;
		nop ; // dist
		nop ; // dist		
	}
}

HANDLE _I_CreateEvent(
  LPSECURITY_ATTRIBUTES lpEventAttributes, // SD
  BOOL bManualReset,                       // reset type
  BOOL bInitialState,                      // initial state
  LPCWSTR lpName                           // object name
)
{
	DWORD * pDw = (DWORD *)_alloca(sizeof(DWORD));
	HANDLE hHandle;

	LONG Ret = RtlRandomEx(&g_Seed);
	if (g_FaultFileEnabled && (Ret%g_Factor < g_Percent))
	{
		return NULL;
	}

    _asm{
		push lpName;
        push bInitialState;
		push bManualReset;
		push lpEventAttributes
		call Prolog__CreateEvent;
		mov  hHandle,eax
	}
    
	return hHandle;
}


void
_declspec(naked) Prolog__RtlFreeHeap(){
	_asm {
		// this is the space for the "saved istructions"
		nop ;
		nop ;
        nop ;
        nop ;
		nop ;
		nop ;		
		nop ;
		nop ;
        nop ;
        nop ;
		nop ;
		nop ;
		// this is the place for the JMP
        nop ;
        nop ;
        nop ;
		nop ;
		nop ;
	}
}

#define SPACE_STACK_ALLOC (4*sizeof(ULONG_PTR))

DWORD _I_RtlFreeHeap(VOID * pHeap,DWORD Flags,VOID * pBlock)
{	
	ULONG * pLong = (ULONG *)_alloca(sizeof(DWORD));
	Flags |= (((HEAP *)pHeap)->Flags) | (((HEAP *)pHeap)->ForceFlags);	
	DWORD dwRet;

	if (pBlock && !(HEAP_SLOW_FLAGS & Flags))
	{
		HEAP_ENTRY * pEntry = (HEAP_ENTRY *)pBlock-1;

              DWORD RealSize = pEntry->Size * sizeof(HEAP_ENTRY);
		DWORD Size = RealSize - pEntry->UnusedBytes;
		
		ULONG_PTR * pL = (ULONG_PTR *)pBlock;

		if (0 == (pEntry->Flags & 0x01) ||0xf0f0f0f0 == pL[1] )
		{
			if (!g_bDisableBreak)
				DebugBreak();
		}
		
		//memset(pBlock,0xF0,RealSize-SPACE_STACK_ALLOC-sizeof(HEAP_ENTRY));		
		DWORD CanMemset = RealSize-sizeof(HEAP_ENTRY);
		memset(pBlock,0xF0,(CanMemset > SPACE_STACK_ALLOC)?CanMemset-SPACE_STACK_ALLOC:CanMemset);
		
				
		if (pEntry->Size >=4)
		{		    
		    RtlCaptureStackBackTrace (1,
        		                      4,
                		              (PVOID *)(pEntry+2),
                        		      pLong);		
		}

	}

	_asm {
		push pBlock              ;
		push Flags               ;
		push pHeap               ;
		call Prolog__RtlFreeHeap ;
		mov  dwRet,eax           ;
	}

    SetFinalOp(FinalOperations::Delete,(ULONG_PTR)pBlock);

	return dwRet;
}

void
_declspec(naked) Prolog__RtlAllocateHeap(){
	_asm {
		// this is the space for the "saved istructions"
		nop ;
		nop ;
        nop ;
        nop ;
		nop ;
		nop ;		
		nop ;
		nop ;
        nop ;
        nop ;
		nop ;
		nop ;
		// this is the place for the JMP
        nop ;
        nop ;
        nop ;
		nop ;
		nop ;
		nop ; // to make this distinct
	}
}

VOID * _I_RtlAllocateHeap(VOID * pHeap,DWORD Flags,DWORD Size)
{
	//Size+=0x1000;	
	ULONG * pLong = (ULONG *)_alloca(sizeof(DWORD));
	Flags |= (((HEAP *)pHeap)->Flags) | (((HEAP *)pHeap)->ForceFlags);	
	VOID * pRet;
	DWORD NewSize = (Size < (3*sizeof(HEAP_ENTRY)))?(3*sizeof(HEAP_ENTRY)+SPACE_STACK_ALLOC):(Size+SPACE_STACK_ALLOC);	


//       if (g_FaultHeapEnabled && g_NumFailInARow)
//       {
//       	InterlockedDecrement(&g_NumFailInARow);
//       	goto here;
//       }
       
	LONG Ret = RtlRandomEx(&g_Seed);
	if (g_FaultHeapEnabled && (Ret%g_Factor < g_Percent))
	{
//		g_NumFailInARow = g_RowOfFailures;
//here:		
//		InterlockedIncrement(&g_NumFailedAllocation);
		return NULL;
	}

	_asm {
		push NewSize                 ;
		push Flags                   ;
		push pHeap                   ;
		call Prolog__RtlAllocateHeap ;
		mov  pRet,eax                ;
	}

    SetFinalOp(FinalOperations::Alloc,(ULONG_PTR)pRet);	
	
	if (pRet && !(HEAP_SLOW_FLAGS & Flags) )
	{

	   if (NewSize <= 0xffff)
       	    NewSize = sizeof(HEAP_ENTRY)*((HEAP_ENTRY *)pRet-1)->Size;
		
	    if (!(HEAP_ZERO_MEMORY & Flags))
	    {	
		    memset(pRet,0xc0,NewSize-sizeof(HEAP_ENTRY));
	    }

	    RtlCaptureStackBackTrace(1,
	    	                                     4,
                         		               (PVOID *)((BYTE *)pRet+(NewSize-SPACE_STACK_ALLOC-sizeof(HEAP_ENTRY))),
                        		               pLong);
	    
	}
	

	return pRet;
	
}

void
_declspec(naked) Prolog__RtlReAllocateHeap(){
	_asm {
		// this is the space for the "saved istructions"
		nop ;
		nop ;
        nop ;
        nop ;
		nop ;
		nop ;		
		nop ;
		nop ;
        nop ;
        nop ;
		nop ;
		nop ;
		// this is the place for the JMP
        nop ;
        nop ;
        nop ;
		nop ;
		nop ;
		nop ; // dist
		nop ; // dist		
		nop ; // dist		
		nop ; // dist		
		nop ; // dist			
	}
}


VOID *
_I_RtlReAllocateHeap(
  HANDLE pHeap,   // handle to heap block
  DWORD Flags,  // heap reallocation options
  LPVOID lpMem,   // pointer to memory to reallocate
  SIZE_T Size  // number of bytes to reallocate
){
	ULONG * pLong = (ULONG *)_alloca(sizeof(DWORD));
	Flags |= (((HEAP *)pHeap)->Flags) | (((HEAP *)pHeap)->ForceFlags);	
	VOID * pRet;

	DWORD NewSize = (Size < (3*sizeof(HEAP_ENTRY)))?(3*sizeof(HEAP_ENTRY)+SPACE_STACK_ALLOC):(Size+SPACE_STACK_ALLOC);
	
	_asm {
		push NewSize                 ;
		push lpMem                   ;
		push Flags                 ;
		push pHeap                   ;
		call Prolog__RtlReAllocateHeap ;
		mov  pRet,eax                ;
	}

    SetFinalOp(FinalOperations::ReAlloc,(ULONG_PTR)pRet);	

	if (pRet && !(HEAP_SLOW_FLAGS & Flags) )
	{

	   if (NewSize <= 0xffff)
       	    NewSize = sizeof(HEAP_ENTRY)*((HEAP_ENTRY *)pRet-1)->Size;
		
	    RtlCaptureStackBackTrace(1,
	    	                                     4,
                         		               (PVOID *)((BYTE *)pRet+(NewSize-SPACE_STACK_ALLOC-sizeof(HEAP_ENTRY))),
                        		               pLong);
	    
	}


       return pRet;
}

void
_declspec(naked) Prolog__RtlValidateHeap(){
	_asm {
		// this is the space for the "saved istructions"
		nop ;
		nop ;
        nop ;
        nop ;
		nop ;
		nop ;		
		nop ;
		nop ;
        nop ;
        nop ;
		nop ;
		nop ;
		// this is the place for the JMP
        nop ;
        nop ;
        nop ;
		nop ;
		nop ;
		nop ; // dist
		nop ; // dist		
		nop ; // dist		
		nop ; // dist		
		nop ; // dist			
		nop ; // dist			
	}
}

BOOL
_I_RtlValidateHeap(
  HANDLE pHeap,   // handle to heap block
  DWORD dwFlags,  // heap reallocation options
  LPVOID lpMem   // pointer to memory to validate
){
	ULONG * pLong = (ULONG *)_alloca(sizeof(DWORD));
	BOOL bRet;

       g_bDisableBreak = TRUE;
	
	_asm {
		push lpMem                   ;
		push dwFlags                 ;
		push pHeap                   ;
		call Prolog__RtlValidateHeap ;
		mov  bRet,eax                ;
	}

       g_bDisableBreak = FALSE;

       return bRet;
}

void
_declspec(naked) Prolog__RtlCreateHeap(){
	_asm {
		// this is the space for the "saved istructions"
		nop ;
		nop ;
        nop ;
        nop ;
		nop ;
		nop ;		
		nop ;
		nop ;
        nop ;
        nop ;
		nop ;
		nop ;
		// this is the place for the JMP
        nop ;
        nop ;
        nop ;
		nop ;
		nop ;
		nop ; // dist
		nop ; // dist		
		nop ; // dist		
		nop ; // dist		
		nop ; // dist			
		nop ; // dist			
		nop ; // dist		
	}
}

PVOID
_I_RtlCreateHeap (
    IN ULONG Flags,
    IN PVOID HeapBase,
    IN SIZE_T ReserveSize,
    IN SIZE_T CommitSize,
    IN PVOID Lock_,
    IN VOID * Parameters
    )
{
	ULONG * pLong = (ULONG *)_alloca(sizeof(DWORD));
	PVOID pHeap;
	
	_asm {
		push Parameters        ;
		push Lock_              ;
		push CommitSize        ;
		push  ReserveSize      ;
		push HeapBase          ;		
		push Flags             ;
		call Prolog__RtlCreateHeap ;
		mov  pHeap,eax         ;
	}
	if (pHeap)
	{
	    HEAP * pRealHeap = (HEAP *)pHeap;
	    if (pRealHeap->Flags & (HEAP_TAIL_CHECKING_ENABLED | HEAP_FREE_CHECKING_ENABLED))
	    {
    	    pRealHeap->Flags &= ~(HEAP_TAIL_CHECKING_ENABLED | HEAP_FREE_CHECKING_ENABLED);
    	}
	    if (pRealHeap->ForceFlags & (HEAP_TAIL_CHECKING_ENABLED | HEAP_FREE_CHECKING_ENABLED))
	    {
    	    pRealHeap->ForceFlags &= ~(HEAP_TAIL_CHECKING_ENABLED | HEAP_FREE_CHECKING_ENABLED);
    	}	    
	}

    SetFinalOp(FinalOperations::ReAlloc,(ULONG_PTR)pHeap);
	
	return pHeap;
}


void
_declspec(naked) Prolog__RtlDestroyHeap(){
	_asm {
		// this is the space for the "saved istructions"
		nop ;
		nop ;
        nop ;
        nop ;
		nop ;
		nop ;		
		nop ;
		nop ;
        nop ;
        nop ;
		nop ;
		nop ;
		// this is the place for the JMP
        nop ;
        nop ;
        nop ;
		nop ;
		nop ;
		nop ; // dist
		nop ; // dist		
		nop ; // dist		
		nop ; // dist		
		nop ; // dist			
		nop ; // dist			
		nop ; // dist		
		nop ; // dist		
	}
}

PVOID
_I_RtlDestroyHeap (
    IN PVOID HeapHandle
    )
{
    ULONG * pLong = (ULONG *)_alloca(sizeof(DWORD));    
    PVOID pRet;

    SetFinalOp(FinalOperations::Destroy,(ULONG_PTR)HeapHandle);
    
    VALIDATE_HEAP;
    	
    _asm {
    	push HeapHandle;
    	call Prolog__RtlDestroyHeap;
    	mov pRet, eax;
    }
    return pRet;
}

void intercept2(WCHAR * Module,
			   LPSTR Function,
			   VOID * NewRoutine,
			   VOID * pPrologStorage,
			   DWORD Size)    
{
	FARPROC OldRoutine = GetProcAddress(GetModuleHandleW(Module),Function);

	if (OldRoutine)
	{
		MEMORY_BASIC_INFORMATION MemBI;
		DWORD dwOldProtect;
		BOOL bRet, bRet2;
		DWORD dwRet;

		dwRet = VirtualQuery(OldRoutine,&MemBI,sizeof(MemBI));

		bRet = VirtualProtect(MemBI.BaseAddress,
							  MemBI.RegionSize,
							  PAGE_EXECUTE_WRITECOPY,
							  &dwOldProtect);

		dwRet = VirtualQuery(pPrologStorage,&MemBI,sizeof(MemBI));

		bRet2 = VirtualProtect(MemBI.BaseAddress,
							  MemBI.RegionSize,
							  PAGE_EXECUTE_WRITECOPY,
							  &dwOldProtect);

		if (bRet && bRet2)
		{
			VOID * pToJump = (VOID *)NewRoutine;
			BYTE Arr[SIZE_JUMP_ADR] = { 0xe9 };
			
			LONG * pOffset = (LONG *)&Arr[1];
			* pOffset = (LONG)NewRoutine - (LONG)OldRoutine - SIZE_JUMP_ADR ;        
			// save the old code
			
			memcpy(pPrologStorage,OldRoutine,Size); 		
			// put the new code
			memset(OldRoutine,0x90,Size);
			memcpy(OldRoutine,Arr,SIZE_JUMP_ADR);
			// adjust the prolog to continue
			* pOffset = (LONG)OldRoutine + Size - (LONG)pPrologStorage - SIZE_SAVED_INSTR - SIZE_JUMP_ADR; // magic for nops
			memcpy((BYTE *)pPrologStorage+SIZE_SAVED_INSTR,Arr,SIZE_JUMP_ADR);
		}
	}
	else
	{
		OutputDebugStringA("GetProcAddress FAIL\n");
	}
}

void unintercept(WCHAR * Module,
                 LPSTR Function,
			     VOID * pPrologStorage,
			     DWORD Size)
{
    FARPROC OldRoutine = GetProcAddress(GetModuleHandleW(Module),Function);

	if (OldRoutine)
	{
	    memcpy((void *)OldRoutine,pPrologStorage,Size);
	}

}

#endif /*_X86_*/
#endif

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

#define CORE_PROVIDER_UNLOAD_TIMEOUT ( 30 * 1000 )

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HWND g_Wnd = NULL ;
DWORD g_DebugLevel = 0 ;
DWORD g_HostRegister = 0 ;
IUnknown *g_HostClassFactory = NULL ;
static const wchar_t *g_TemplateCode = L"Wmi Provider Host" ;
Task_ObjectDestruction *g_Task = NULL ;

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/
void initiateShutdown(void);

LRESULT CALLBACK WindowsMainProc ( HWND a_hWnd , UINT a_message , WPARAM a_wParam , LPARAM a_lParam )
{
	LRESULT t_rc = 0 ;

	switch ( a_message )
	{
		case WM_DESTROY:
		{
			PostMessage ( a_hWnd , WM_QUIT , 0 , 0 ) ;
		}
		break ;

		default:
		{		
			t_rc = DefWindowProc ( a_hWnd , a_message , a_wParam , a_lParam ) ;
		}
		break ;
	}

	return ( t_rc ) ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HWND WindowsInit ( HINSTANCE a_HInstance )
{
	WNDCLASS  t_wc ;
 
	t_wc.style            = CS_HREDRAW | CS_VREDRAW ;
	t_wc.lpfnWndProc      = WindowsMainProc ;
	t_wc.cbClsExtra       = 0 ;
	t_wc.cbWndExtra       = 0 ;
	t_wc.hInstance        = a_HInstance ;
	t_wc.hIcon            = LoadIcon(NULL, IDI_HAND) ;
	t_wc.hCursor          = LoadCursor(NULL, IDC_ARROW) ;
	t_wc.hbrBackground    = (HBRUSH) (COLOR_WINDOW + 1) ;
	t_wc.lpszMenuName     = NULL ;
	t_wc.lpszClassName    = g_TemplateCode ;
 
	ATOM t_winClass = RegisterClass ( &t_wc ) ;

	HWND t_HWnd = CreateWindow (

		g_TemplateCode ,              // see RegisterClass() call
		g_TemplateCode ,                      // text for window title bar
		WS_OVERLAPPEDWINDOW | WS_MINIMIZE ,               // window style
		CW_USEDEFAULT ,                     // default horizontal position
		CW_USEDEFAULT ,                     // default vertical position
		CW_USEDEFAULT ,                     // default width
		CW_USEDEFAULT ,                     // default height
		NULL ,                              // overlapped windows have no parent
		NULL ,                              // use the window class menu
		a_HInstance ,
		NULL                                // pointer not needed
	) ;

	//ShowWindow ( t_HWnd , SW_SHOW ) ;
	ShowWindow ( t_HWnd, SW_HIDE ) ;

	UpdateWindow ( t_HWnd ) ;

	HMENU t_Menu = GetSystemMenu ( t_HWnd , FALSE ) ; 
	if ( t_Menu )
	{
		DeleteMenu ( t_Menu , SC_RESTORE , MF_BYCOMMAND ) ;
	}

	return t_HWnd ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

void WindowsStop ( HINSTANCE a_Instance , HWND a_HWnd )
{
	CoUninitialize () ;
	DestroyWindow ( a_HWnd ) ;
	UnregisterClass ( g_TemplateCode , a_Instance ) ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HWND WindowsStart ( HINSTANCE a_Handle )
{
	HWND t_HWnd = NULL ;
	if ( ! ( t_HWnd = WindowsInit ( a_Handle ) ) )
	{
    }

	return t_HWnd ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

void WindowsDispatch ()
{
	BOOL t_GetMessage ;
	MSG t_lpMsg ;

	while (	( t_GetMessage = GetMessage ( & t_lpMsg , NULL , 0 , 0 ) ) == TRUE )
	{
		TranslateMessage ( & t_lpMsg ) ;
		DispatchMessage ( & t_lpMsg ) ;
	}
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT RevokeFactories ()
{
	if ( g_HostRegister )
	{
		CoRevokeClassObject ( g_HostRegister );
		g_HostRegister = 0 ;
	}

	return S_OK ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT UninitComServer ()
{
	RevokeFactories () ;

	CoUninitialize () ;

	return S_OK ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT InitComServer ( DWORD a_AuthenticationLevel , DWORD a_ImpersonationLevel )
{
	HRESULT t_Result = S_OK ;

    t_Result = CoInitializeEx (

		0, 
		COINIT_MULTITHREADED
	);

	if ( SUCCEEDED ( t_Result ) ) 
	{
		t_Result = CoInitializeSecurity (

			NULL, 
			-1, 
			NULL, 
			NULL,
			a_AuthenticationLevel,
			a_ImpersonationLevel, 
			NULL, 
			EOAC_DYNAMIC_CLOAKING , 
			0
		);

		if ( FAILED ( t_Result ) ) 
		{
			CoUninitialize () ;
			return t_Result ;
		}
	}

	if ( FAILED ( t_Result ) )
	{
		CoUninitialize () ;
	}

	return t_Result  ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT InitFactories ()
{
	HRESULT t_Result = S_OK ;

	DWORD t_ClassContext = CLSCTX_LOCAL_SERVER ;
	DWORD t_Flags = REGCLS_SINGLEUSE ;

	g_HostClassFactory = new CServerClassFactory <CServerObject_Host,_IWmiProviderHost> ;

	t_Result = CoRegisterClassObject (

		CLSID_WmiProviderHost, 
		g_HostClassFactory,
		t_ClassContext, 
		t_Flags, 
		& g_HostRegister
	);

	if ( FAILED ( t_Result ) )
	{
		if ( g_HostRegister )
		{
			CoRevokeClassObject ( g_HostRegister );
			g_HostRegister = 0 ;
			g_HostClassFactory->Release () ;
			g_HostClassFactory = NULL ;
		}
	}	

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT Enqueue_ObjectDestruction ( WmiThread < ULONG > *a_Thread )
{
	HRESULT t_Result = S_OK ;
	g_Task = new Task_ObjectDestruction ( *ProviderSubSystem_Globals :: s_Allocator ) ;
	if ( g_Task )
	{
		g_Task->AddRef () ;

		if ( g_Task->Initialize () == e_StatusCode_Success ) 
		{
			if ( a_Thread->EnQueueAlertable ( 0 , *g_Task ) == e_StatusCode_Success )
			{
			}
			else
			{
				t_Result = WBEM_E_OUT_OF_MEMORY ;
			}
		}
		else
		{
			t_Result = WBEM_E_OUT_OF_MEMORY ;
		}
	}
	else
	{
		t_Result = WBEM_E_OUT_OF_MEMORY ;
	}

	if ( FAILED ( t_Result ) )
	{
		g_Task = NULL ;
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT Dequeue_ObjectDestruction ( WmiThread < ULONG > *a_Thread )
{
	HRESULT t_Result = S_OK ;

/*
 *	Don't clean up since we need a guarantee that no syncronisation needs to take place
 */

#if 0
	if ( g_Task )
	{
		g_Task->Release () ;
	}
#endif


	return t_Result ;
}


/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT Process ()
{
#if 1
	DWORD t_ImpersonationLevel = RPC_C_IMP_LEVEL_IMPERSONATE ;
	DWORD t_AuthenticationLevel = RPC_C_AUTHN_LEVEL_CONNECT ;
#else
	DWORD t_ImpersonationLevel = RPC_C_IMP_LEVEL_IDENTITY ;
	DWORD t_AuthenticationLevel = RPC_C_AUTHN_LEVEL_NONE ;
#endif

	HRESULT t_Result = InitComServer ( t_AuthenticationLevel , t_ImpersonationLevel ) ;
	if ( SUCCEEDED ( t_Result ) )
	{
		WmiStatusCode t_StatusCode = WmiDebugLog :: Initialize ( *ProviderSubSystem_Globals :: s_Allocator  ) ;
		if ( t_StatusCode == e_StatusCode_Success )
		{
			t_Result = ProviderSubSystem_Globals :: Initialize_SharedCounters () ;
			if ( FAILED ( t_Result ) )
			{
				t_Result = S_OK ;
			}

			t_Result = ProviderSubSystem_Globals :: Initialize_Events () ;
			if ( SUCCEEDED ( t_Result ) )
			{
				t_Result = ProviderSubSystem_Common_Globals :: CreateSystemAces () ;
			}

			if ( SUCCEEDED ( t_Result ) )
			{
				IWbemLocator *t_Locator = NULL ;

				HRESULT t_Result = CoCreateInstance (
  
					CLSID_WbemLocator ,
					NULL ,
					CLSCTX_INPROC_SERVER | CLSCTX_LOCAL_SERVER ,
					IID_IUnknown ,
					( void ** )  & t_Locator
				);

				if ( SUCCEEDED ( t_Result ) )
				{
					IWbemServices *t_Service = NULL ;

					BSTR t_Namespace = SysAllocString ( L"Root" ) ;
					if ( t_Namespace ) 
					{
						t_Result = t_Locator->ConnectServer (

							t_Namespace ,
							NULL ,
							NULL,
							NULL ,
							0 ,
							NULL,
							NULL,
							& t_Service
						) ;

						if ( SUCCEEDED ( t_Result ) )
						{
							CServerObject_GlobalRegistration t_Registration ;
							t_Result = t_Registration.SetContext (

								NULL ,
								NULL ,
								t_Service
							) ;
							
							if ( SUCCEEDED ( t_Result ) )
							{
								t_Result = t_Registration.Load (

									e_All
								) ;

								if ( SUCCEEDED ( t_Result ) )
								{
									ProviderSubSystem_Globals :: s_StrobeTimeout = t_Registration.GetUnloadTimeoutMilliSeconds () >> 1 ;
									ProviderSubSystem_Globals :: s_InternalCacheTimeout = t_Registration.GetUnloadTimeoutMilliSeconds () ;
									ProviderSubSystem_Globals :: s_ObjectCacheTimeout = t_Registration.GetObjectUnloadTimeoutMilliSeconds () ;
									ProviderSubSystem_Globals :: s_EventCacheTimeout = t_Registration.GetEventUnloadTimeoutMilliSeconds () ;
								}
							}

							if ( SUCCEEDED ( t_Result ) )
							{
								CServerObject_HostQuotaRegistration t_Registration ;
								t_Result = t_Registration.SetContext (

									NULL ,
									NULL ,
									t_Service
								) ;
								
								if ( SUCCEEDED ( t_Result ) )
								{
									t_Result = t_Registration.Load (

										e_All
									) ;

									if ( SUCCEEDED ( t_Result ) )
									{
										ProviderSubSystem_Globals ::s_Quota_ProcessLimitCount = t_Registration.GetProcessLimitAllHosts () ;
										ProviderSubSystem_Globals ::s_Quota_ProcessMemoryLimitCount = t_Registration.GetMemoryPerHost () ;
										ProviderSubSystem_Globals ::s_Quota_JobMemoryLimitCount = t_Registration.GetMemoryAllHosts () ;
										ProviderSubSystem_Globals ::s_Quota_HandleCount = t_Registration.GetHandlesPerHost () ;
										ProviderSubSystem_Globals ::s_Quota_NumberOfThreads = t_Registration.GetThreadsPerHost () ;
										ProviderSubSystem_Globals ::s_Quota_PrivatePageCount = t_Registration.GetMemoryPerHost () ;
									}
								}
							}

							t_Service->Release () ;
						}

						SysFreeString ( t_Namespace ) ;
					}
					else
					{
						t_Result = WBEM_E_OUT_OF_MEMORY ;
					}

					t_Locator->Release () ;
				}
			}

			if ( SUCCEEDED ( t_Result ) )
			{
				FactoryLifeTimeThread *t_Thread = new FactoryLifeTimeThread ( *ProviderSubSystem_Globals :: s_Allocator , DEFAULT_PROVIDER_TIMEOUT ) ;
				if ( t_Thread )
				{
					t_Thread->AddRef () ;

					t_StatusCode = t_Thread->Initialize () ;
					if ( t_StatusCode == e_StatusCode_Success )
					{
						t_Result = Enqueue_ObjectDestruction ( t_Thread ) ;
						if ( SUCCEEDED ( t_Result ) )
						{
							t_Result = InitFactories () ;

#ifdef DEV_BUILD
#ifdef _X86_
//    g_FaultHeapEnabled = TRUE;
//	g_FaultFileEnabled = TRUE;
#endif
#endif
					
							if ( SUCCEEDED ( t_Result ) )
							{
								Wmi_SetStructuredExceptionHandler t_StructuredException ;

								try 
								{
									WindowsDispatch () ;
								}
								catch ( Wmi_Structured_Exception t_StructuredException )
								{
								}
							}

							Dequeue_ObjectDestruction ( t_Thread ) ;
						}

						HANDLE t_ThreadHandle = NULL ;

						BOOL t_Status = DuplicateHandle ( 

							GetCurrentProcess () ,
							t_Thread->GetHandle () ,
							GetCurrentProcess () ,
							& t_ThreadHandle, 
							0 , 
							FALSE , 
							DUPLICATE_SAME_ACCESS
						) ;

						t_Thread->Release () ;

						WaitForSingleObject ( t_ThreadHandle , INFINITE ) ;

						CloseHandle ( t_ThreadHandle ) ;
					}
				}
				else
				{
					t_Result = WBEM_E_OUT_OF_MEMORY ;
				}

				t_Result = ProviderSubSystem_Common_Globals :: DeleteSystemAces () ;

				t_Result = ProviderSubSystem_Globals :: UnInitialize_Events () ;
			}

			t_Result = ProviderSubSystem_Globals :: UnInitialize_SharedCounters () ;

			WmiStatusCode t_StatusCode = WmiDebugLog :: UnInitialize ( *ProviderSubSystem_Globals :: s_Allocator  ) ;
		}
			
		UninitComServer () ;
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

BOOL ParseCommandLine () 
{
	BOOL t_Exit = FALSE ;

	LPTSTR t_CommandLine = GetCommandLine () ;
	if ( t_CommandLine )
	{
		TCHAR *t_Arg = NULL ;
		TCHAR *t_ApplicationArg = NULL ;
		t_ApplicationArg = _tcstok ( t_CommandLine , _TEXT ( " \t" ) ) ;
		t_Arg = _tcstok ( NULL , _TEXT ( " \t" ) ) ;
		if ( t_Arg ) 
		{
			if ( _tcsicmp ( t_Arg , _TEXT ( "/RegServer" ) ) == 0 )
			{
				t_Exit = TRUE ;
				DllRegisterServer () ;
			}
			else if ( _tcsicmp ( t_Arg , _TEXT ( "/UnRegServer" ) ) == 0 )
			{
				t_Exit = TRUE ;
				DllUnregisterServer () ;
			}
		}
	}

	return t_Exit ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

DWORD GetDebugLevel ()
{
	DWORD t_DebugLevel = 0 ;

	HKEY t_ConfigRoot ;

	LONG t_RegResult = RegOpenKeyEx (

		HKEY_LOCAL_MACHINE ,
		L"Software\\Microsoft\\WBEM\\CIMOM" ,
		0 ,
		KEY_READ ,
		& t_ConfigRoot 
	) ;

	if ( t_RegResult == ERROR_SUCCESS )
	{
		DWORD t_ValueType = REG_DWORD ;
		DWORD t_DataSize = sizeof ( t_DebugLevel ) ;

		t_RegResult = RegQueryValueEx (

		  t_ConfigRoot ,
		  L"HostDebugBreak" ,
		  0 ,
		  & t_ValueType ,
		  LPBYTE ( & t_DebugLevel ) ,
		  & t_DataSize 
		);

		if ( t_RegResult == ERROR_SUCCESS )
		{
		}

		RegCloseKey ( t_ConfigRoot ) ;
	}

	return t_DebugLevel ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

void EnterDebugger ()
{
    //
    // If the process is being debugged, just let the exception happen
    // so that the debugger can see it. This way the debugger can ignore
    // all first chance exceptions.
    //

    HANDLE t_DebugPort = NULL ;
    NTSTATUS t_Status = NtQueryInformationProcess (

        GetCurrentProcess () ,
        ProcessDebugPort ,
        (PVOID) & t_DebugPort ,
        sizeof ( t_DebugPort ) ,
        NULL
	);

    if ( NT_SUCCESS ( t_Status ) && t_DebugPort )
	{

        //
        // Process is being debugged.
        // Return a code that specifies that the exception
        // processing is to continue
        //

		CloseHandle ( t_DebugPort ) ;
	}
	else
	{	
		//
		// See if a debugger has been programmed in. If so, use the
		// debugger specified. If not then there is no AE Cancel support
		// DEVL systems will default the debugger command line. Retail
		// systems will not.
		// Also, check to see if we need to report the exception up to anyone
		//

		wchar_t t_Debugger [ MAX_PATH ] ;

		DWORD t_RegStatus = GetProfileString (

			L"AeDebug" ,
			L"Debugger" ,
			NULL ,
			t_Debugger ,
			( sizeof ( t_Debugger ) / sizeof ( wchar_t ) ) - 1 
		) ;

		if ( t_RegStatus )
		{
			HANDLE t_CurrentProcess = NULL ;

			t_Status = DuplicateHandle (
			
				GetCurrentProcess (),
				GetCurrentProcess (),
				GetCurrentProcess (),
				& t_CurrentProcess,
				0,
				TRUE,
				DUPLICATE_SAME_ACCESS
			) ;

			if ( NT_SUCCESS ( t_Status ) )
			{
				SECURITY_ATTRIBUTES t_SecurityAttributes ;
				t_SecurityAttributes.nLength = sizeof( t_SecurityAttributes ) ;
				t_SecurityAttributes.lpSecurityDescriptor = NULL ;
				t_SecurityAttributes.bInheritHandle = TRUE ;

				HANDLE t_EventHandle = CreateEvent ( & t_SecurityAttributes , TRUE , FALSE , NULL ) ;
				if ( t_EventHandle )
				{
					wchar_t t_CmdLine [ MAX_PATH  ] ;
					wsprintf ( t_CmdLine , t_Debugger , GetCurrentProcessId () , t_EventHandle ) ;
					
					STARTUPINFO t_StartupInfo ;
					PROCESS_INFORMATION t_ProcessInformation ;

					RtlZeroMemory ( & t_StartupInfo , sizeof ( t_StartupInfo ) ) ;
					t_StartupInfo.cb = sizeof ( t_StartupInfo ) ;
					t_StartupInfo.lpDesktop = L"Winsta0\\Default";

					BOOL t_CreateStatus = CreateProcess (

						NULL ,
						t_CmdLine ,
						NULL ,
						NULL ,
						TRUE ,
						0 ,
						NULL ,
						NULL ,
						& t_StartupInfo ,
						& t_ProcessInformation
					);

					if ( t_CreateStatus ) 
					{

						//
						// Do an alertable wait on the event
						//

						do {

							t_Status = NtWaitForSingleObject (

								t_EventHandle,
								TRUE,
								NULL
							) ;

							OutputDebugString ( L"\nSpinning" ) ;

						} while ( t_Status == STATUS_USER_APC || t_Status == STATUS_ALERTED ) ;

						CloseHandle ( t_ProcessInformation.hProcess ) ;
						CloseHandle ( t_ProcessInformation.hThread ) ;

					}

					CloseHandle ( t_EventHandle ) ;
				}

				CloseHandle ( t_CurrentProcess ) ;
			}
		}
	}
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

int WINAPI WinMain (
  
    HINSTANCE hInstance,		// handle to current instance
    HINSTANCE hPrevInstance,	// handle to previous instance
    LPSTR lpCmdLine,			// pointer to command line
    int nShowCmd 				// show state of window
)
{

#ifdef DEV_BUILD
#ifdef _X86_
	NtCurrentPeb()->BeingDebugged = 1;
    //Dispatcher::scheduleTimer(heapValidator, 5*60*1000);
	intercept2(L"ntdll.dll","RtlFreeHeap",_I_RtlFreeHeap,Prolog__RtlFreeHeap,5);
	intercept2(L"ntdll.dll","RtlAllocateHeap",_I_RtlAllocateHeap,Prolog__RtlAllocateHeap,5);
	intercept2(L"ntdll.dll","RtlReAllocateHeap",_I_RtlReAllocateHeap,Prolog__RtlReAllocateHeap,5);	
	intercept2(L"ntdll.dll","RtlValidateHeap",_I_RtlValidateHeap,Prolog__RtlValidateHeap,7);
	intercept2(L"ntdll.dll","RtlCreateHeap",_I_RtlCreateHeap,Prolog__RtlCreateHeap,5);
	intercept2(L"ntdll.dll","RtlDestroyHeap",_I_RtlDestroyHeap,Prolog__RtlDestroyHeap,6);	
	intercept2(L"kernel32.dll","CreateEventW",_I_CreateEvent,Prolog__CreateEvent,6);
	intercept2(L"kernel32.dll","WriteFile",_I_WriteFile,Prolog__WriteFile,7);
	intercept2(L"kernel32.dll","ReadFile",_I_ReadFile,Prolog__ReadFile,7);

#endif /*_X86_*/
#endif

	g_DebugLevel = GetDebugLevel () ;

	if ( g_DebugLevel == 1 )
	{
		EnterDebugger () ;
	}

	HRESULT t_Result = ProviderSubSystem_Globals :: Global_Startup () ;
	if ( SUCCEEDED ( t_Result ) )
	{
		BOOL t_Exit = ParseCommandLine () ;
		if ( ! t_Exit ) 
		{
			RPC_STATUS t_Status = RpcMgmtSetServerStackSize ( ProviderSubSystem_Common_Globals :: GetDefaultStackSize () );

			g_Wnd = WindowsStart ( hInstance ) ;

			t_Result = Process () ;

			WindowsStop ( hInstance , g_Wnd ) ;
		}

		t_Result = ProviderSubSystem_Globals :: Global_Shutdown () ;
	}

#ifdef DEV_BUILD
#ifdef _X86_

	//VALIDATE_HEAP;
	//Dispatcher::cancelTimer(heapValidator);
	unintercept(L"ntdll.dll","RtlFreeHeap",Prolog__RtlFreeHeap,5);	
	unintercept(L"ntdll.dll","RtlAllocateHeap",Prolog__RtlAllocateHeap,5);
	unintercept(L"ntdll.dll","RtlReAllocateHeap",Prolog__RtlReAllocateHeap,5);	
	unintercept(L"ntdll.dll","RtlValidateHeap",Prolog__RtlValidateHeap,7);
	unintercept(L"ntdll.dll","RtlCreateHeap",Prolog__RtlCreateHeap,5);
	unintercept(L"ntdll.dll","RtlDestroyHeap",Prolog__RtlDestroyHeap,6);		
	unintercept(L"kernel32.dll","CreateEventW",Prolog__CreateEvent,6);
	unintercept(L"kernel32.dll","WriteFile",Prolog__WriteFile,7);
	unintercept(L"kernel32.dll","ReadFile",Prolog__ReadFile,7);
	
#endif /*_X86_*/
#endif


	return 0 ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

WmiStatusCode FactoryLifeTimeThread :: Initialize_Callback ()
{
	CoInitializeEx ( NULL , COINIT_MULTITHREADED ) ;

	return e_StatusCode_Success ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

WmiStatusCode FactoryLifeTimeThread :: UnInitialize_Callback () 
{
	CoUninitialize () ;

	return e_StatusCode_Success ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

FactoryLifeTimeThread :: FactoryLifeTimeThread (

	WmiAllocator &a_Allocator ,
	const ULONG &a_Timeout 

) : WmiThread < ULONG > ( a_Allocator , NULL , a_Timeout ) ,
	m_Allocator ( a_Allocator )
{
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

FactoryLifeTimeThread::~FactoryLifeTimeThread ()
{
}

#if 0
#define DBG_PRINTFA( a ) { char pBuff[128]; sprintf a ; OutputDebugStringA(pBuff); }
#else
#define DBG_PRINTFA( a )
#endif


/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

BOOL FactoryLifeTimeThread :: QuotaCheck ()
{
	DWORD t_ProcessInformationSize = sizeof ( SYSTEM_PROCESS_INFORMATION ) ;
	SYSTEM_PROCESS_INFORMATION *t_ProcessInformation = ( SYSTEM_PROCESS_INFORMATION * ) new BYTE [t_ProcessInformationSize] ;
	if ( t_ProcessInformation )
	{
		BOOL t_Retry = TRUE ;
		while ( t_Retry )
		{
			NTSTATUS t_Status = NtQuerySystemInformation (

				SystemProcessInformation,
				t_ProcessInformation,
				t_ProcessInformationSize,
				NULL
			) ;

			if ( t_Status == STATUS_INFO_LENGTH_MISMATCH )
			{
				delete [] t_ProcessInformation;

				t_ProcessInformation = NULL ;
				t_ProcessInformationSize += 32768 ;
				t_ProcessInformation = ( SYSTEM_PROCESS_INFORMATION * ) new BYTE [t_ProcessInformationSize] ;
				if ( ! t_ProcessInformation )
				{
					return FALSE ;
				}
			}
			else
			{
				t_Retry = FALSE ;

				if ( ! NT_SUCCESS ( t_Status ) )
				{
					delete [] t_ProcessInformation;
					t_ProcessInformation = NULL ;

					return FALSE ;
				}
			}
		}
	}
	else
	{
		return FALSE ;
	}

	BOOL t_Status = TRUE ;

	SYSTEM_PROCESS_INFORMATION *t_Block = t_ProcessInformation ;

	while ( t_Block )
	{
		if ( ( HandleToUlong ( t_Block->UniqueProcessId ) ) == GetCurrentProcessId () )
		{
			if ( t_Block->HandleCount > ProviderSubSystem_Globals::s_Quota_HandleCount )
			{
			    DBG_PRINTFA((pBuff,"HandleCount %x %x\n",t_Block->HandleCount,ProviderSubSystem_Globals::s_Quota_HandleCount));
				t_Status = FALSE ;
			}

			if ( t_Block->NumberOfThreads > ProviderSubSystem_Globals::s_Quota_NumberOfThreads )
			{
			    DBG_PRINTFA((pBuff,"NumberOfThreads %x %x\n",t_Block->NumberOfThreads,ProviderSubSystem_Globals::s_Quota_NumberOfThreads));
				t_Status = FALSE ;
			}

			if ( t_Block->PrivatePageCount > ProviderSubSystem_Globals :: s_Quota_PrivatePageCount )
			{
			    DBG_PRINTFA((pBuff,"PrivatePageCount %x %x\n", t_Block->PrivatePageCount,ProviderSubSystem_Globals::s_Quota_PrivatePageCount));			
				t_Status = FALSE ;
			}
		}

		DWORD t_NextOffSet = t_Block->NextEntryOffset ;
		if ( t_NextOffSet )
		{
			t_Block = ( SYSTEM_PROCESS_INFORMATION * ) ( ( ( BYTE * ) t_Block ) + t_NextOffSet ) ;
		}
		else
		{
			t_Block = NULL ;
		}
	}

	delete [] t_ProcessInformation;

	return t_Status ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

WmiStatusCode FactoryLifeTimeThread :: TimedOut ()
{
	try
	{
	
		if ( QuotaCheck () == TRUE ) 
		{
			initiateShutdown();
		}
		else
		{
			CWbemGlobal_IWbemSyncProviderController *t_SyncProviderController = ProviderSubSystem_Globals :: GetSyncProviderController () ;

			CWbemGlobal_IWbemSyncProvider_Container *t_Container = NULL ;
			WmiStatusCode t_StatusCode = t_SyncProviderController->GetContainer ( t_Container ) ;

			t_SyncProviderController->Lock () ;

			_IWmiProviderQuota **t_QuotaElements = new _IWmiProviderQuota * [ t_Container->Size () ] ;
			if ( t_QuotaElements )
			{
				CWbemGlobal_IWbemSyncProvider_Container_Iterator t_Iterator = t_Container->Begin () ;

				ULONG t_Count = 0 ;

				while ( ! t_Iterator.Null () )
				{
					SyncProviderContainerElement *t_Element = t_Iterator.GetElement () ;

					t_QuotaElements [ t_Count ] = NULL ;

					HRESULT t_Result = t_Element->QueryInterface ( IID__IWmiProviderQuota , ( void ** ) & t_QuotaElements [ t_Count ] ) ;

					t_Iterator.Increment () ;

					t_Count ++ ;
				}

				t_SyncProviderController->UnLock () ;

				for ( ULONG t_Index = 0 ; t_Index < t_Count ; t_Index ++ )
				{
					if ( t_QuotaElements [ t_Index ] )
					{
						HRESULT t_Result = t_QuotaElements [ t_Index ]->Violation ( 0 , NULL , NULL ) ;

						t_QuotaElements [ t_Index ]->Release () ;
					}
				}

				delete [] t_QuotaElements ;
			}
			else
			{
				t_SyncProviderController->UnLock () ;
			}

			RevokeFactories () ;

/*
 *	Just exit since we can't safely wait for clients to disconnect correctly before cleaning up dependant resources.
 */
#ifdef _X86_
#ifdef DEV_BUILD
            g_ExitProcessCalled = TRUE;
#endif
#endif
            VALIDATE_HEAP;
			TerminateProcess ( GetCurrentProcess () , WBEM_E_QUOTA_VIOLATION ) ;
		}

		CoFreeUnusedLibrariesEx ( CORE_PROVIDER_UNLOAD_TIMEOUT , 0 ) ;
	}
	catch ( ... )
	{
	}

	return e_StatusCode_Success ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

void SetObjectDestruction ()
{
	if ( g_Task )
	{
		SetEvent ( g_Task->GetEvent () ) ;
	}
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

WmiStatusCode Task_ObjectDestruction :: Process ( WmiThread <ULONG> &a_Thread )
{
	initiateShutdown();
	return e_StatusCode_EnQueue ;
}

void initiateShutdown(void)
{
#ifdef DBG
	if ( ProviderSubSystem_Globals :: s_ObjectsInProgress == 1 )
#else
	if ( ProviderSubSystem_Globals :: s_CServerObject_Host_ObjectsInProgress == 0 )
#endif
	{
		RevokeFactories () ;
	}
	if (ProviderSubSystem_Globals :: s_CServerObject_StaThread_ObjectsInProgress == 0 && 
	    ProviderSubSystem_Globals :: s_CServerObject_Host_ObjectsInProgress == 0 )
	{
		PostMessage ( g_Wnd , WM_QUIT , 0 , 0 ) ;
	}
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\provsubsys\server\provcache.cpp ===
/*++

Copyright (C) 1996-2001 Microsoft Corporation

Module Name:

	ProvSubS.cpp

Abstract:


History:

--*/

#include <precomp.h>
#include <wbemint.h>

#include <HelperFuncs.h>

#include "Guids.h"
#include "Globals.h"
#include "CGlobals.h"
#include "ProvSubS.h"
#include "ProvFact.h"
#include "ProvAggr.h"
#include "ProvLoad.h"
#include "ProvWsv.h"
#include "ProvObSk.h"

#include "ProvCache.h"

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

LONG CompareElement ( const HostCacheKey &a_Arg1 , const HostCacheKey &a_Arg2 )
{
	return a_Arg1.Compare ( a_Arg2 ) ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

LONG CompareElement ( const BindingFactoryCacheKey &a_Arg1 , const BindingFactoryCacheKey &a_Arg2 )
{
	return a_Arg1.Compare ( a_Arg2 ) ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

LONG CompareElement ( const ProviderCacheKey &a_Arg1 , const ProviderCacheKey &a_Arg2 ) 
{
	return a_Arg1.Compare ( a_Arg2 ) ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

LONG CompareElement ( const GUID &a_Guid1 , const GUID &a_Guid2 )
{
	return memcmp ( & a_Guid1, & a_Guid2 , sizeof ( GUID ) ) ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

LONG CompareElement ( const LONG &a_Arg1 , const LONG &a_Arg2 )
{
	return a_Arg1 - a_Arg2 ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HostController :: HostController ( WmiAllocator &a_Allocator ) : CWbemGlobal_IWmiHostController ( a_Allocator ) 
{
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

WmiStatusCode HostController :: StrobeBegin ( const ULONG &a_Period )
{
	ULONG t_Timeout = ProviderSubSystem_Globals :: GetStrobeThread ().GetTimeout () ;
	ProviderSubSystem_Globals :: GetStrobeThread ().SetTimeout ( t_Timeout < a_Period ? t_Timeout : a_Period ) ;
	return e_StatusCode_Success ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

RefresherManagerController :: RefresherManagerController ( WmiAllocator &a_Allocator ) : CWbemGlobal_IWbemRefresherMgrController ( a_Allocator ) 
{
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

WmiStatusCode RefresherManagerController :: StrobeBegin ( const ULONG &a_Period )
{
	ULONG t_Timeout = ProviderSubSystem_Globals :: GetStrobeThread ().GetTimeout () ;
	ProviderSubSystem_Globals :: GetStrobeThread ().SetTimeout ( t_Timeout < a_Period ? t_Timeout : a_Period ) ;
	return e_StatusCode_Success ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

ProviderController :: ProviderController (

	WmiAllocator &a_Allocator ,
	CWbemGlobal_HostedProviderController *a_Controller ,
	DWORD a_ProcessIdentifier

) : m_Container ( a_Allocator ) ,
    m_CriticalSection(NOTHROW_LOCK),
	HostedProviderContainerElement ( 

		a_Controller ,
		a_ProcessIdentifier
	)
{
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

ProviderController :: ~ProviderController () 
{
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

STDMETHODIMP_( ULONG ) ProviderController :: AddRef () 
{
	return HostedProviderContainerElement :: AddRef () ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

STDMETHODIMP_( ULONG ) ProviderController :: Release () 
{
	return HostedProviderContainerElement :: Release () ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

STDMETHODIMP ProviderController :: QueryInterface ( 

	REFIID iid , 
	LPVOID FAR *iplpv 
)
{
	*iplpv = NULL ;

	if ( iid == IID_IUnknown )
	{
		*iplpv = ( LPVOID ) this ;
	}
	else if ( iid == IID_ProviderController )
	{
		*iplpv = ( LPVOID ) ( ProviderController * ) this ;		
	}	

	if ( *iplpv )
	{
		( ( LPUNKNOWN ) *iplpv )->AddRef () ;

		return ResultFromScode ( S_OK ) ;
	}
	else
	{
		return ResultFromScode ( E_NOINTERFACE ) ;
	}

}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

WmiStatusCode ProviderController :: Initialize () 
{
	WmiStatusCode t_StatusCode = m_Container.Initialize () ;
	if ( t_StatusCode == e_StatusCode_Success )
	{
		t_StatusCode = m_CriticalSection.valid() ? e_StatusCode_Success : e_StatusCode_OutOfMemory;
	}

	return t_StatusCode ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

WmiStatusCode ProviderController :: UnInitialize () 
{
	WmiStatusCode t_StatusCode = m_Container.UnInitialize () ;
	return t_StatusCode ;
}	

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

WmiStatusCode ProviderController :: Insert ( 

	CInterceptor_IWbemProvider *a_Element ,
	Container_Iterator &a_Iterator 
)
{
	Lock () ;

	Container_Iterator t_Iterator ;
	WmiStatusCode t_StatusCode = m_Container.Insert ( a_Element , a_Element , t_Iterator ) ;
	if ( t_StatusCode == e_StatusCode_Success )
	{
		a_Element->NonCyclicAddRef () ;
	}

	UnLock () ;

	return t_StatusCode ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

WmiStatusCode ProviderController :: Delete ( 

	CInterceptor_IWbemProvider * const &a_Key
)
{
	Lock () ;

	WmiStatusCode t_StatusCode = m_Container.Delete ( a_Key ) ;

	UnLock () ;

	return t_StatusCode ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

WmiStatusCode ProviderController :: Find ( 

	CInterceptor_IWbemProvider * const &a_Key , 
	Container_Iterator &a_Iterator
)
{
	Lock () ;

	WmiStatusCode t_StatusCode = m_Container.Find ( a_Key , a_Iterator ) ;
	if ( t_StatusCode == e_StatusCode_Success )
	{
		a_Iterator.GetElement ()->NonCyclicAddRef ( ) ;
	}

	UnLock () ;

	return t_StatusCode ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

WmiStatusCode ProviderController :: Lock ()
{
	if (!m_CriticalSection.valid())
		return e_StatusCode_OutOfMemory;

	while (!m_CriticalSection.acquire())
		Sleep(1000);

	return e_StatusCode_Success ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

WmiStatusCode ProviderController :: UnLock ()
{
	m_CriticalSection.release();
	return e_StatusCode_Success ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

WmiStatusCode ProviderController :: Shutdown ()
{
	Lock () ;

	Container_Iterator t_Iterator = m_Container.Root ();

	while ( ! t_Iterator.Null () )
	{
		m_Container.Delete ( t_Iterator.GetKey () ) ;
		t_Iterator = m_Container.Root () ;
	}

	UnLock () ;

	return e_StatusCode_Success ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\provsubsys\server\provcntrs.cpp ===
/*++

Copyright (C) 1996-2001 Microsoft Corporation

Module Name:

	ProvFact.cpp

Abstract:


History:

--*/

#include "PreComp.h"
#include <wbemint.h>

#include "Globals.h"
#include "CGlobals.h"
#include "ProvCntrs.h"

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

CServerObject_ProviderSubsystem_Counters :: CServerObject_ProviderSubsystem_Counters () : 

    m_ProviderHost_WmiCore_Loads ( 0 ) ,
    m_ProviderHost_WmiCore_UnLoads ( 0 ) ,
	m_ProviderHost_WmiCoreOrSelfHost_Loads ( 0 ) ,
	m_ProviderHost_WmiCoreOrSelfHost_UnLoads ( 0 ) ,
	m_ProviderHost_SelfHost_Loads ( 0 ) ,
	m_ProviderHost_SelfHost_UnLoads ( 0 ) ,
	m_ProviderHost_ClientHost_Loads ( 0 ) ,
	m_ProviderHost_ClientHost_UnLoads ( 0 ) ,
	m_ProviderHost_Decoupled_Loads ( 0 ) ,
	m_ProviderHost_Decoupled_UnLoads ( 0 ) ,
	m_ProviderHost_SharedLocalSystemHost_Loads ( 0 ) ,
	m_ProviderHost_SharedLocalSystemHost_UnLoads ( 0 ) ,
	m_ProviderHost_SharedNetworkHost_Loads ( 0 ) ,
	m_ProviderHost_SharedNetworkHost_UnLoads ( 0 ) ,
	m_ProviderHost_SharedUserHost_Loads ( 0 ) ,
	m_ProviderHost_SharedUserHost_UnLoads ( 0 ) ,
	m_ProviderOperation_GetObjectAsync ( 0 ) ,
	m_ProviderOperation_PutClassAsync ( 0 ) ,
	m_ProviderOperation_DeleteClassAsync ( 0 ) ,
	m_ProviderOperation_CreateClassEnumAsync ( 0 ) ,
	m_ProviderOperation_PutInstanceAsync ( 0 ) ,
	m_ProviderOperation_DeleteInstanceAsync ( 0 ) ,
	m_ProviderOperation_CreateInstanceEnumAsync ( 0 ) ,
	m_ProviderOperation_ExecQueryAsync ( 0 ) ,
	m_ProviderOperation_ExecNotificationQueryAsync ( 0 ) ,
	m_ProviderOperation_ExecMethodAsync ( 0 ) ,
	m_ProviderOperation_QueryInstances ( 0 ) ,
	m_ProviderOperation_CreateRefresher ( 0 ) ,
	m_ProviderOperation_CreateRefreshableObject ( 0 ) ,
	m_ProviderOperation_StopRefreshing ( 0 ) ,
	m_ProviderOperation_CreateRefreshableEnum ( 0 ) ,
	m_ProviderOperation_GetObjects ( 0 ) ,
	m_ProviderOperation_GetProperty ( 0 ) ,
	m_ProviderOperation_PutProperty ( 0 ) ,
	m_ProviderOperation_ProvideEvents ( 0 ) ,
	m_ProviderOperation_NewQuery ( 0 ) ,
	m_ProviderOperation_CancelQuery ( 0 ) ,
	m_ProviderOperation_AccessCheck ( 0 ) ,
	m_ProviderOperation_SetRegistrationObject ( 0 ) ,
	m_ProviderOperation_FindConsumer ( 0 ) ,
	m_ProviderOperation_ValidateSubscription ( 0 )
{
	InterlockedDecrement ( & ProviderSubSystem_Globals :: s_CServerObject_ProviderSubsystem_Counters_ObjectsInProgress ) ;

	ProviderSubSystem_Globals :: Increment_Global_Object_Count () ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

CServerObject_ProviderSubsystem_Counters::~CServerObject_ProviderSubsystem_Counters ()
{
	InterlockedDecrement ( & ProviderSubSystem_Globals :: s_CServerObject_ProviderSubsystem_Counters_ObjectsInProgress ) ;

	ProviderSubSystem_Globals :: Decrement_Global_Object_Count () ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\provsubsys\server\provdcaggr.cpp ===
/*++

Copyright (C) 1996-2001 Microsoft Corporation

Module Name:

	XXXX

Abstract:


History:

--*/

#include "PreComp.h"
#include <typeinfo.h>
#include <wbemint.h>
#include <NCObjApi.h>

#include <Guids.h>
#include <Like.h>
#include "Globals.h"
#include "CGlobals.h"
#include "DateTime.h"
#include "ProvSubS.h"
#include "ProvDcAggr.h"
#include "ProvWsvS.h"
#include "ProvFact.h"
#include "ProvObSk.h"
#include "ProvInSk.h"

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

CDecoupled_ProviderSubsystemRegistrar :: CDecoupled_ProviderSubsystemRegistrar (

	WmiAllocator &a_Allocator ,
	CServerObject_ProviderSubSystem *a_SubSystem

) :	m_SubSystem ( a_SubSystem ) ,
	m_ReferenceCount ( 0 ) , 
	m_Allocator ( a_Allocator )
{
	m_SubSystem->AddRef () ;

	InterlockedIncrement ( & ProviderSubSystem_Globals :: s_CDecoupledAggregator_IWbemProvider_ObjectsInProgress ) ;

	ProviderSubSystem_Globals :: Increment_Global_Object_Count () ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

CDecoupled_ProviderSubsystemRegistrar :: ~CDecoupled_ProviderSubsystemRegistrar ()
{
#if 0
wchar_t t_Buffer [ 128 ] ;
wsprintf ( t_Buffer , L"\n%lx - ~CDecoupled_ProviderSubsystemRegistrar ( %lx ) " , GetTickCount () , this ) ;
OutputDebugString ( t_Buffer ) ;
#endif

	m_SubSystem->Release () ;

	InterlockedDecrement ( & ProviderSubSystem_Globals :: s_CDecoupledAggregator_IWbemProvider_ObjectsInProgress ) ;

	ProviderSubSystem_Globals :: Decrement_Global_Object_Count () ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

STDMETHODIMP CDecoupled_ProviderSubsystemRegistrar::QueryInterface (

	REFIID iid , 
	LPVOID FAR *iplpv 
) 
{
	*iplpv = NULL ;

	if ( iid == IID_IUnknown )
	{
		*iplpv = ( LPVOID ) this ;
	}
	else if ( iid == IID__IWmiProviderSubsystemRegistrar )
	{
		*iplpv = ( LPVOID ) ( _IWmiProviderSubsystemRegistrar * ) this ;		
	}	

	if ( *iplpv )
	{
		( ( LPUNKNOWN ) *iplpv )->AddRef () ;

		return ResultFromScode ( S_OK ) ;
	}
	else
	{
		return ResultFromScode ( E_NOINTERFACE ) ;
	}
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

STDMETHODIMP_( ULONG ) CDecoupled_ProviderSubsystemRegistrar :: AddRef ()
{
	return InterlockedIncrement ( & m_ReferenceCount ) ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

STDMETHODIMP_(ULONG) CDecoupled_ProviderSubsystemRegistrar :: Release ()
{
	ULONG t_ReferenceCount = InterlockedDecrement ( & m_ReferenceCount ) ;
	if ( t_ReferenceCount == 0 )
	{
		delete this ;
	}

	return t_ReferenceCount ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CDecoupled_ProviderSubsystemRegistrar :: SaveToRegistry (

	long a_Flags ,
	IWbemContext *a_Context ,
	LPCWSTR a_User ,
	LPCWSTR a_Locale ,
	LPCWSTR a_Scope ,
	LPCWSTR a_Registration ,
	DWORD a_ProcessIdentifier ,
	GUID &a_Identity ,
	IUnknown *a_Unknown
)
{
	HRESULT t_Result = S_OK ;

	HANDLE t_Handle = OpenProcess (

		PROCESS_QUERY_INFORMATION ,
		FALSE ,
		a_ProcessIdentifier
	) ;

	if ( t_Handle ) 
	{
		wchar_t t_Guid [64] ;

		int t_Status = StringFromGUID2 ( a_Identity , t_Guid , sizeof ( t_Guid ) / sizeof ( wchar_t ) ) ;
		if ( t_Status )
		{
			BYTE *t_MarshaledProxy = NULL ;
			DWORD t_MarshaledProxyLength = 0 ;

			t_Result = ProviderSubSystem_Common_Globals :: MarshalRegistration ( 

				a_Unknown ,
				t_MarshaledProxy ,
				t_MarshaledProxyLength
			) ;

			if ( SUCCEEDED ( t_Result ) )
			{
				CServerObject_DecoupledClientRegistration_Element t_Element ;

				BSTR t_CreationTime = NULL ;

				FILETIME t_CreationFileTime ;
				FILETIME t_ExitFileTime ;
				FILETIME t_KernelFileTime ;
				FILETIME t_UserFileTime ;

				BOOL t_Status = GetProcessTimes (

					  t_Handle ,
					  & t_CreationFileTime,
					  & t_ExitFileTime,
					  & t_KernelFileTime,
					  & t_UserFileTime
				);

				if ( t_Status ) 
				{
					CWbemDateTime t_Time ;
					t_Time.SetFileTimeDate ( t_CreationFileTime , VARIANT_FALSE ) ;

					t_Result = t_Time.GetValue ( & t_CreationTime ) ;
					if ( SUCCEEDED ( t_Result ) ) 
					{
						t_Result = t_Element.SetProcessIdentifier ( a_ProcessIdentifier ) ;

						if ( SUCCEEDED ( t_Result ) ) 
						{
							if ( a_Locale ) 
							{
								t_Result = t_Element.SetLocale ( ( BSTR ) a_Locale ) ;
							}
						}

						if ( SUCCEEDED ( t_Result ) ) 
						{
							if ( a_User ) 
							{
								t_Result = t_Element.SetUser ( ( BSTR ) a_User ) ;
							}
						}

						if ( SUCCEEDED ( t_Result ) ) 
						{
							t_Result = t_Element.SetProvider ( ( BSTR ) a_Registration ) ;
						}

						if ( SUCCEEDED ( t_Result ) ) 
						{
							t_Result = t_Element.SetScope ( ( BSTR ) a_Scope ) ;
						}

						if ( SUCCEEDED ( t_Result ) ) 
						{
							t_Result = t_Element.SetCreationTime ( ( BSTR ) t_CreationTime ) ;
						}

						if ( SUCCEEDED ( t_Result ) ) 
						{
							t_Result = t_Element.SetMarshaledProxy ( t_MarshaledProxy , t_MarshaledProxyLength ) ;
						}

						if ( SUCCEEDED ( t_Result ) )
						{
							WmiStatusCode t_StatusCode = WmiHelper :: EnterCriticalSection ( ProviderSubSystem_Globals :: GetDecoupledRegistrySection () ) ;
							
							t_Result = t_Element.Save ( t_Guid ) ;

							t_StatusCode = WmiHelper :: LeaveCriticalSection ( ProviderSubSystem_Globals :: GetDecoupledRegistrySection () ) ;
						}

						SysFreeString ( t_CreationTime ) ;
					}
					else
					{
						t_Result = WBEM_E_UNEXPECTED ;
					}
				}
				else
				{
					t_Result = WBEM_E_UNEXPECTED ;
				}

				delete [] t_MarshaledProxy ;
			}
		}
		else
		{
			t_Result = WBEM_E_CRITICAL_ERROR ;
		}

		CloseHandle ( t_Handle ) ;
	}
	else
	{
		t_Result = WBEM_E_ACCESS_DENIED ;
	}
	
	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CDecoupled_ProviderSubsystemRegistrar :: ValidateClientSecurity (

	IWbemContext *a_Context ,
	LPCWSTR a_Scope ,
	LPCWSTR a_Registration ,
	IWbemServices *a_Service 
) 
{
	HRESULT t_Result = S_OK ;

	t_Result = CoImpersonateClient () ;
	if ( SUCCEEDED ( t_Result ) )
	{
		IWbemPath *t_Scope = NULL ;

		t_Result = CoCreateInstance (

			CLSID_WbemDefPath ,
			NULL ,
			CLSCTX_INPROC_SERVER ,
			IID_IWbemPath ,
			( void ** )  & t_Scope 
		) ;

		if ( SUCCEEDED ( t_Result ) )
		{
			t_Result = t_Scope->SetText ( WBEMPATH_TREAT_SINGLE_IDENT_AS_NS | WBEMPATH_CREATE_ACCEPT_ALL , a_Scope ) ;
			if ( SUCCEEDED ( t_Result ) )
			{
				CServerObject_ProviderRegistrationV1 *t_Registration = new CServerObject_ProviderRegistrationV1 ;
				if ( t_Registration )
				{
					t_Registration->AddRef () ;

					t_Result = t_Registration->SetContext ( 

						a_Context ,
						t_Scope , 
						a_Service
					) ;

					if ( SUCCEEDED ( t_Result ) )
					{
						t_Registration->SetUnloadTimeoutMilliSeconds ( ProviderSubSystem_Globals :: s_InternalCacheTimeout ) ;

						t_Result = t_Registration->Load ( 

							e_All ,
							NULL , 
							a_Registration
						) ;

						if ( SUCCEEDED ( t_Result ) )
						{
							SECURITY_DESCRIPTOR *t_SecurityDescriptor = t_Registration->GetComRegistration ().GetSecurityDescriptor () ;

							t_Result = ProviderSubSystem_Common_Globals :: Check_SecurityDescriptor_CallIdentity (

								t_SecurityDescriptor , 
								MASK_PROVIDER_BINDING_BIND ,
								& g_ProviderBindingMapping,
								ProviderSubSystem_Common_Globals::GetDefaultDecoupledSD()
							) ;
						}
						else
						{
							if ( t_Result == WBEM_E_NOT_FOUND )
							{
								t_Result = WBEM_E_PROVIDER_NOT_FOUND ;
							}	
							else
							{
								t_Result = WBEM_E_PROVIDER_LOAD_FAILURE ;
							}
						}
					}

					t_Registration->Release () ;
				}
				else
				{
					t_Result = WBEM_E_OUT_OF_MEMORY ;
				}
			}

			t_Scope->Release () ;
		}

		CoRevertToSelf () ;
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CDecoupled_ProviderSubsystemRegistrar :: Register (

	long a_Flags ,
	IWbemContext *a_Context ,
	LPCWSTR a_User ,
	LPCWSTR a_Locale ,
	LPCWSTR a_Scope ,
	LPCWSTR a_Registration ,
	DWORD a_ProcessIdentifier ,
	IUnknown *a_Unknown ,
	GUID a_Identity
)
{
	HRESULT t_Result = S_OK ;

	try
	{
		IWbemContext *t_Context = NULL ;

		if ( a_Context )
		{
			t_Context = a_Context ;
			t_Context->AddRef () ;
		}
		else
		{
			t_Result = CoCreateInstance ( 

				CLSID_WbemContext ,
				NULL ,
				CLSCTX_INPROC_SERVER ,
				IID_IWbemContext ,
				( void ** )  & t_Context
			) ;
		}

		if ( SUCCEEDED ( t_Result ) )
		{
			IWbemServices *t_Service = NULL ;
			t_Result = m_SubSystem->GetWmiService ( 

				( const BSTR ) a_Scope ,
				( const BSTR ) a_User ,
				( const BSTR ) a_Locale ,
				t_Service
			) ;

			if ( SUCCEEDED ( t_Result ) )
			{
				t_Result = ValidateClientSecurity (

					a_Context ,
					a_Scope ,
					a_Registration ,
					t_Service 
				) ;

				if ( SUCCEEDED ( t_Result ) ) 
				{
					t_Result = SaveToRegistry (

						a_Flags ,
						a_Context ,
						a_User ,
						a_Locale ,
						a_Scope ,
						a_Registration ,
						a_ProcessIdentifier ,
						a_Identity ,
						a_Unknown
					) ;
				}

				if ( SUCCEEDED ( t_Result ) ) 
				{
					_IWmiProviderFactory *t_Factory = NULL ;
					t_Result = m_SubSystem->Create (

						t_Service ,
						0,
						t_Context ,
						a_Scope  ,
						IID__IWmiProviderFactory  ,
						( void ** ) & t_Factory
					) ;
					
					if ( SUCCEEDED ( t_Result ) ) 
					{
						_IWmiProviderSubsystemRegistrar *t_Registrar = NULL ;

						t_Result = t_Factory->GetDecoupledProvider (

							0 ,
							t_Context ,
							a_User ,
							a_Locale  ,
							a_Scope ,
							a_Registration ,
							IID__IWmiProviderSubsystemRegistrar ,
							( void ** ) & t_Registrar
						) ;

						if ( SUCCEEDED ( t_Result ) )
						{
							t_Result = t_Registrar->Register (

								0 ,
								t_Context ,
								a_User ,
								a_Locale  ,
								a_Scope ,
								a_Registration ,
								a_ProcessIdentifier ,
								a_Unknown ,
								a_Identity
							) ;

							t_Registrar->Release () ;
						}

						t_Factory->Release () ;
					}
				}

				t_Service->Release () ;
			}
		}

		if ( t_Context )
		{
			t_Context->Release () ;
		}

	}
	catch ( ... )
	{
		t_Result = WBEM_E_PROVIDER_FAILURE ;
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/


HRESULT CDecoupled_ProviderSubsystemRegistrar :: UnRegister (

	long a_Flags ,
	IWbemContext *a_Context ,
	LPCWSTR a_User ,
	LPCWSTR a_Locale ,
	LPCWSTR a_Scope ,
	LPCWSTR a_Registration ,
	GUID a_Identity
)
{
	HRESULT t_Result = S_OK ;

	try
	{
		IWbemServices *t_Service = NULL ;
		t_Result = m_SubSystem->GetWmiService ( 

			( const BSTR ) a_Scope ,
			( const BSTR ) a_User ,
			( const BSTR ) a_Locale ,
			t_Service
		) ;

		if (SUCCEEDED ( t_Result ) )
		{
			_IWmiProviderFactory *t_Factory = NULL ;
			t_Result = m_SubSystem->Create (

				t_Service ,
				0,
				a_Context ,
				a_Scope  ,
				IID__IWmiProviderFactory  ,
				( void ** ) & t_Factory
			) ;
			
			if ( SUCCEEDED ( t_Result ) ) 
			{
				_IWmiProviderSubsystemRegistrar *t_Registrar = NULL ;

				t_Result = t_Factory->GetDecoupledProvider (

					0 ,
					a_Context ,
					a_User ,
					a_Locale  ,
					a_Scope ,
					a_Registration ,
					IID__IWmiProviderSubsystemRegistrar ,
					( void ** ) & t_Registrar
				) ;

				if ( SUCCEEDED ( t_Result ) )
				{
					t_Result = t_Registrar->UnRegister (

						0 ,
						a_Context ,
						a_User ,
						a_Locale  ,
						a_Scope ,
						a_Registration ,
						a_Identity
					) ;

					t_Registrar->Release () ;
				}

				t_Factory->Release () ;
			}

			t_Service->Release () ;
		}

		wchar_t t_Guid [64] ;

		int t_Status = StringFromGUID2 ( a_Identity , t_Guid , sizeof ( t_Guid ) / sizeof ( wchar_t ) ) ;
		if ( t_Status )
		{
			CServerObject_DecoupledClientRegistration_Element t_Element ;

			WmiStatusCode t_StatusCode = WmiHelper :: EnterCriticalSection ( ProviderSubSystem_Globals :: GetDecoupledRegistrySection () ) ;

			t_Result = t_Element.Delete ( t_Guid ) ;

			t_StatusCode = WmiHelper :: LeaveCriticalSection ( ProviderSubSystem_Globals :: GetDecoupledRegistrySection () ) ;
		}
	}
	catch ( ... )
	{
		t_Result = WBEM_E_PROVIDER_FAILURE ;
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CDecoupled_ProviderSubsystemRegistrar :: CacheProvider (

	CServerObject_ProviderSubSystem *a_SubSystem ,
	IWbemContext *a_Context ,
	CServerObject_DecoupledClientRegistration_Element &a_Element ,
	IUnknown *a_Unknown 
)
{
	HRESULT t_Result = S_OK ;

	IWbemServices *t_Service = NULL ;
	t_Result = a_SubSystem->GetWmiService ( 

		a_Element.GetScope () ,
		( const BSTR ) a_Element.GetUser () ,
		( const BSTR ) a_Element.GetLocale () ,
		t_Service
	) ;

	if (SUCCEEDED ( t_Result ) )
	{
		_IWmiProviderFactory *t_Factory = NULL ;
		t_Result = a_SubSystem->Create (

			t_Service ,
			0,
			a_Context ,
			a_Element.GetScope () ,
			IID__IWmiProviderFactory  ,
			( void ** ) & t_Factory
		) ;
		
		if ( SUCCEEDED ( t_Result ) ) 
		{
			_IWmiProviderSubsystemRegistrar *t_Registrar = NULL ;

			t_Result = t_Factory->GetDecoupledProvider (

				0 ,
				a_Context ,
				a_Element.GetUser () ,
				a_Element.GetLocale () ,
				a_Element.GetScope () ,
				a_Element.GetProvider () ,
				IID__IWmiProviderSubsystemRegistrar ,
				( void ** ) & t_Registrar
			) ;

			if ( SUCCEEDED ( t_Result ) )
			{
				GUID t_Identity ;
				t_Result = CLSIDFromString ( a_Element.GetClsid () , & t_Identity ) ;
				if ( SUCCEEDED ( t_Result ) )
				{
					t_Result = t_Registrar->Register (

						0 ,
						a_Context ,
						a_Element.GetUser () ,
						a_Element.GetLocale () ,
						a_Element.GetScope () ,
						a_Element.GetProvider () ,
						a_Element.GetProcessIdentifier () ,
						a_Unknown ,
						t_Identity
					) ;
				}	

				t_Registrar->Release () ;
			}

			t_Factory->Release () ;
		}

		t_Service->Release () ;
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CDecoupled_ProviderSubsystemRegistrar :: Load (

	CServerObject_ProviderSubSystem *a_SubSystem ,
	IWbemContext *a_Context ,
	CServerObject_DecoupledClientRegistration_Element &a_Element
)
{
	HRESULT t_Result = S_OK ;

	BYTE *t_MarshaledProxy = a_Element.GetMarshaledProxy () ;
	DWORD t_MarshaledProxyLength = a_Element.GetMarshaledProxyLength () ;

	if ( t_MarshaledProxy )
	{
		IUnknown *t_Unknown = NULL ;
		t_Result = ProviderSubSystem_Common_Globals :: UnMarshalRegistration ( & t_Unknown , t_MarshaledProxy , t_MarshaledProxyLength ) ;
		if ( SUCCEEDED ( t_Result ) )
		{
			t_Result = CacheProvider ( 

				a_SubSystem ,
				a_Context ,
				a_Element ,
				t_Unknown 	
			) ;

			t_Unknown->Release () ;
		}
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CDecoupled_ProviderSubsystemRegistrar :: Load (

	CServerObject_ProviderSubSystem *a_SubSystem ,
	IWbemContext *a_Context
)
{
	HRESULT t_Result = S_OK ;

	try
	{
		CServerObject_DecoupledClientRegistration t_Elements ( m_Allocator ) ;

		WmiStatusCode t_StatusCode = WmiHelper :: EnterCriticalSection ( ProviderSubSystem_Globals :: GetDecoupledRegistrySection () ) ;

		HRESULT t_TempResult = t_Elements.Load () ;

		t_StatusCode = WmiHelper :: LeaveCriticalSection ( ProviderSubSystem_Globals :: GetDecoupledRegistrySection () ) ;

		if ( SUCCEEDED ( t_TempResult ) )
		{
			WmiQueue < CServerObject_DecoupledClientRegistration_Element , 8 > &t_Queue = t_Elements.GetQueue () ;
			
			CServerObject_DecoupledClientRegistration_Element t_Top ;

			WmiStatusCode t_StatusCode ;
			while ( ( t_StatusCode = t_Queue.Top ( t_Top ) ) == e_StatusCode_Success )
			{
				HRESULT t_TempResult = Load (

					a_SubSystem , 
					a_Context , 
					t_Top
				) ;

				t_StatusCode = t_Queue.DeQueue () ;
			}
		}
		else
		{
		}
	}
	catch ( ... )
	{
		t_Result = WBEM_E_PROVIDER_FAILURE ;
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CDecoupled_ProviderSubsystemRegistrar :: SaveToRegistry (

	IUnknown *a_Unknown ,
	BYTE *a_MarshaledProxy ,
	DWORD a_MarshaledProxyLength
)
{
	HRESULT t_Result = S_OK ;

	CServerObject_DecoupledServerRegistration t_Element ( m_Allocator ) ;

	BSTR t_CreationTime = NULL ;

	FILETIME t_CreationFileTime ;
	FILETIME t_ExitFileTime ;
	FILETIME t_KernelFileTime ;
	FILETIME t_UserFileTime ;

	BOOL t_Status = GetProcessTimes (

		  GetCurrentProcess (),
		  & t_CreationFileTime,
		  & t_ExitFileTime,
		  & t_KernelFileTime,
		  & t_UserFileTime
	);

	if ( t_Status ) 
	{
		CWbemDateTime t_Time ;
		t_Time.SetFileTimeDate ( t_CreationFileTime , VARIANT_FALSE ) ;
		t_Result = t_Time.GetValue ( & t_CreationTime ) ;
		if ( SUCCEEDED ( t_Result ) ) 
		{
			t_Result = t_Element.SetProcessIdentifier ( GetCurrentProcessId () ) ;

			if ( SUCCEEDED ( t_Result ) ) 
			{
				t_Result = t_Element.SetCreationTime ( ( BSTR ) t_CreationTime ) ;
			}

			if ( SUCCEEDED ( t_Result ) ) 
			{
				t_Result = t_Element.SetMarshaledProxy ( a_MarshaledProxy , a_MarshaledProxyLength ) ;
			}

			if ( SUCCEEDED ( t_Result ) )
			{
				t_Result = t_Element.Save () ;
			}

			SysFreeString ( t_CreationTime ) ;
		}
		else
		{
			t_Result = WBEM_E_UNEXPECTED ;
		}
	}
	else
	{
		t_Result = WBEM_E_UNEXPECTED ;
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CDecoupled_ProviderSubsystemRegistrar :: Save ()
{
	HRESULT t_Result = S_OK ;

	try
	{
/*
 *	Clear existing stale entries.
 */

		CServerObject_DecoupledClientRegistration t_Elements ( m_Allocator ) ;
		HRESULT t_TempResult = t_Elements.Load () ;
		if ( SUCCEEDED ( t_TempResult ) )
		{
			WmiQueue < CServerObject_DecoupledClientRegistration_Element , 8 > &t_Queue = t_Elements.GetQueue () ;
			
			CServerObject_DecoupledClientRegistration_Element t_Top ;

			WmiStatusCode t_StatusCode ;
			while ( ( t_StatusCode = t_Queue.Top ( t_Top ) ) == e_StatusCode_Success )
			{
				t_StatusCode = t_Queue.DeQueue () ;
			}
		}
		else
		{
		}

		BYTE *t_MarshaledProxy = NULL ;
		DWORD t_MarshaledProxyLength = 0 ;

		IUnknown *t_Unknown = NULL ;
		t_Result = this->QueryInterface ( IID_IUnknown, ( void ** ) & t_Unknown ) ;
		if ( SUCCEEDED ( t_Result ) ) 
		{
			t_Result = ProviderSubSystem_Common_Globals :: MarshalRegistration ( 

				t_Unknown ,
				t_MarshaledProxy ,
				t_MarshaledProxyLength
			) ;

			if ( SUCCEEDED ( t_Result ) )
			{
				t_Result = SaveToRegistry ( 

					t_Unknown ,
					t_MarshaledProxy ,
					t_MarshaledProxyLength
				) ;

				delete [] t_MarshaledProxy ;
			}

			t_Unknown->Release () ;
		}
	}
	catch ( ... )
	{
		t_Result = WBEM_E_PROVIDER_FAILURE ;
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CDecoupled_ProviderSubsystemRegistrar :: Delete ()
{
	HRESULT t_Result = S_OK ;

	try
	{
		CServerObject_DecoupledServerRegistration t_Element ( m_Allocator ) ;
		t_Result = t_Element.Delete () ;
	}
	catch ( ... )
	{
		t_Result = WBEM_E_PROVIDER_FAILURE ;
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

CDecoupledAggregator_IWbemProvider :: CDecoupledAggregator_IWbemProvider (

	WmiAllocator &a_Allocator ,
	CWbemGlobal_IWmiProviderController *a_Controller , 
	_IWmiProviderFactory *a_Factory ,
	IWbemServices *a_CoreRepositoryStub ,
	IWbemServices *a_CoreFullStub ,
	const ProviderCacheKey &a_Key ,
	const ULONG &a_Period ,
	IWbemContext *a_InitializationContext ,
	CServerObject_ProviderRegistrationV1 &a_Registration
	
) :	CWbemGlobal_IWmiObjectSinkController ( a_Allocator ) ,
	ServiceCacheElement ( 

		a_Controller ,
		a_Key ,
		a_Period 
	) ,
	m_ReferenceCount ( 0 ) , 
	m_Allocator ( a_Allocator ) ,
	m_Registration ( & a_Registration ) ,
	m_ExtendedStatusObject ( NULL ) , 
	m_CoreRepositoryStub ( a_CoreRepositoryStub ) ,
	m_CoreFullStub ( a_CoreFullStub ) ,
	m_Factory ( a_Factory ) ,
	m_User ( NULL ) ,
	m_Locale ( NULL ) ,
	m_Namespace ( NULL ) ,
	m_Controller ( NULL ) ,
	m_NamespacePath ( NULL ) ,
	m_Sink ( NULL ) ,
	m_Initialized ( 0 ) ,
	m_InitializeResult ( S_OK ) ,
	m_InitializedEvent ( NULL ) , 
	m_InitializationContext ( a_InitializationContext )
{
	InterlockedIncrement ( & ProviderSubSystem_Globals :: s_CDecoupledAggregator_IWbemProvider_ObjectsInProgress ) ;

	ProviderSubSystem_Globals :: Increment_Global_Object_Count () ;

	m_Registration->AddRef () ;

	if ( m_Factory ) 
	{
		m_Factory->AddRef () ;
	}

	if ( m_CoreRepositoryStub )
	{
		m_CoreRepositoryStub->AddRef () ;
	}

	if ( m_CoreFullStub )
	{
		m_CoreFullStub->AddRef () ;
	}

	if ( m_InitializationContext )
	{
		m_InitializationContext->AddRef () ;
	}
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

CDecoupledAggregator_IWbemProvider :: ~CDecoupledAggregator_IWbemProvider ()
{
#if 0
wchar_t t_Buffer [ 128 ] ;
wsprintf ( t_Buffer , L"\n%lx - ~CDecoupledAggregator_IWbemProvider ( %lx ) " , GetTickCount () , this ) ;
OutputDebugString ( t_Buffer ) ;
#endif

	WmiStatusCode t_StatusCode = CWbemGlobal_IWmiObjectSinkController :: UnInitialize () ;

	if ( m_Controller )
	{
		CWbemGlobal_IWbemSyncProvider_Container *t_Container = NULL ;
		WmiStatusCode t_StatusCode = m_Controller->GetContainer ( t_Container ) ;

		m_Controller->Lock () ;

		CWbemGlobal_IWbemSyncProvider_Container_Iterator t_Iterator = t_Container->Begin () ;
		while ( ! t_Iterator.Null () )
		{
			SyncProviderContainerElement *t_Element = t_Iterator.GetElement () ;

			t_Container->Delete ( t_Element->GetKey () ) ;

			m_Controller->UnLock () ;

			t_Element->Release () ;

			m_Controller->Lock () ;

			t_Iterator = t_Container->Begin () ;
		}

		m_Controller->UnLock () ;

		m_Controller->UnInitialize () ;

		m_Controller->Release () ;
	}

	if ( m_NamespacePath )
	{
		m_NamespacePath->Release () ;
	}

	if ( m_Factory ) 
	{
		m_Factory->Release () ;
	}

	if ( m_CoreRepositoryStub )
	{
		m_CoreRepositoryStub->Release () ;
	}

	if ( m_CoreFullStub )
	{
		m_CoreFullStub->Release () ;
	}

	if ( m_User ) 
	{
		SysFreeString ( m_User ) ;
	}

	if ( m_Locale ) 
	{
		SysFreeString ( m_Locale ) ;
	}

	if ( m_Namespace )
	{
		SysFreeString ( m_Namespace ) ;
	}

	if ( m_Sink )
	{
		m_Sink->AddRef () ;
	}

	if ( m_InitializationContext )
	{
		m_InitializationContext->Release () ;
	}

	if ( m_InitializedEvent )
	{
		CloseHandle ( m_InitializedEvent ) ;
	}

	if ( m_Registration )
	{
		m_Registration->Release () ;
	}

	if ( m_ExtendedStatusObject )
	{
		m_ExtendedStatusObject->Release () ;
	}

	InterlockedDecrement ( & ProviderSubSystem_Globals :: s_CDecoupledAggregator_IWbemProvider_ObjectsInProgress ) ;

	ProviderSubSystem_Globals :: Decrement_Global_Object_Count () ;

}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CDecoupledAggregator_IWbemProvider :: Initialize (

	long a_Flags ,
	IWbemContext *a_Context ,
	GUID *a_TransactionIdentifier,
	LPCWSTR a_User,
    LPCWSTR a_Locale,
	LPCWSTR a_Namespace ,
	IWbemServices *a_Repository ,
	IWbemServices *a_Service ,
	IWbemProviderInitSink *a_Sink     // For init signals
)
{
	HRESULT t_Result = S_OK ;

	WmiStatusCode t_StatusCode = CWbemGlobal_IWmiObjectSinkController :: Initialize () ;
	if ( t_StatusCode != e_StatusCode_Success ) 
	{
		t_Result = WBEM_E_OUT_OF_MEMORY ;
	}

	if ( SUCCEEDED ( t_Result ) )
	{
		m_Controller = new CWbemGlobal_IWbemSyncProviderController ( m_Allocator ) ;
		if ( m_Controller )
		{
			m_Controller->AddRef () ;

			t_StatusCode = m_Controller->Initialize () ;
			if ( t_StatusCode != e_StatusCode_Success ) 
			{
				t_Result = WBEM_E_OUT_OF_MEMORY ;
			}
		}
		else
		{
			t_Result = WBEM_E_OUT_OF_MEMORY ;
		}
	}

	if ( SUCCEEDED ( t_Result ) )
	{
		t_Result = CoCreateInstance (

			CLSID_WbemDefPath ,
			NULL ,
			CLSCTX_INPROC_SERVER ,
			IID_IWbemPath ,
			( void ** )  & m_NamespacePath
		) ;

		if ( SUCCEEDED ( t_Result ) )
		{
			t_Result = m_NamespacePath->SetText ( WBEMPATH_TREAT_SINGLE_IDENT_AS_NS | WBEMPATH_CREATE_ACCEPT_ALL , a_Namespace ) ;
		}
	}

	if ( SUCCEEDED ( t_Result ) )
	{
		if ( a_User )
		{
			m_User = SysAllocString ( a_User ) ;
			if ( ! m_User ) 
			{
				t_Result = WBEM_E_OUT_OF_MEMORY ;
			}
		}

		if ( SUCCEEDED ( t_Result ) )
		{
			if ( a_Locale )
			{
				m_Locale = SysAllocString ( a_Locale ) ;
				if ( ! m_Locale ) 
				{
					t_Result = WBEM_E_OUT_OF_MEMORY ;
				}
			}
		}

		if ( SUCCEEDED ( t_Result ) )
		{
			if ( a_Namespace )
			{
				m_Namespace = SysAllocString ( a_Namespace ) ;
				if ( ! m_Namespace ) 
				{
					t_Result = WBEM_E_OUT_OF_MEMORY ;
				}
			}
		}
	}

	if ( SUCCEEDED ( t_Result ) )
	{
		m_InitializedEvent = CreateEvent ( NULL , TRUE , FALSE , NULL ) ;
		if ( m_InitializedEvent == NULL )
		{
			t_Result = t_Result = WBEM_E_OUT_OF_MEMORY ;
		}
	}

	if ( SUCCEEDED ( t_Result ) )
	{
		t_Result = a_Repository->GetObject ( 

			L"__ExtendedStatus" ,
			0 , 
			a_Context ,
			& m_ExtendedStatusObject ,
			NULL
		) ;
	}

	a_Sink->SetStatus ( t_Result , 0 ) ;

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CDecoupledAggregator_IWbemProvider :: SetStatus ( 

	LPWSTR a_Operation ,
	LPWSTR a_Parameters ,
	LPWSTR a_Description ,
	HRESULT a_Result ,
	IWbemObjectSink *a_Sink
)
{
	if ( m_ExtendedStatusObject )
	{
		IWbemClassObject *t_StatusObject ;
		HRESULT t_Result = m_ExtendedStatusObject->SpawnInstance ( 

			0 , 
			& t_StatusObject
		) ;

		if ( SUCCEEDED ( t_Result ) )
		{
			ProviderSubSystem_Common_Globals :: Set_String ( t_StatusObject , L"Provider" , m_Registration ? m_Registration->GetProviderName () : L"ProviderSubsystem" ) ;

			if ( a_Operation ) 
			{
				ProviderSubSystem_Common_Globals :: Set_String ( t_StatusObject , L"Operation" , a_Operation ) ;
			}

			if ( a_Parameters ) 
			{
				ProviderSubSystem_Common_Globals :: Set_String ( t_StatusObject , L"ParameterInfo" , a_Parameters ) ;
			}

			if ( a_Description ) 
			{
				ProviderSubSystem_Common_Globals :: Set_String ( t_StatusObject , L"Description" , a_Description ) ;
			}

			_IWmiObject *t_FastStatusObject ;
			t_Result = t_StatusObject->QueryInterface ( IID__IWmiObject , ( void ** ) & t_FastStatusObject ) ;
			if ( SUCCEEDED ( t_Result ) )
			{
				ProviderSubSystem_Common_Globals :: Set_Uint32 ( t_FastStatusObject , L"StatusCode" , a_Result ) ;

				t_FastStatusObject->Release () ;
			}

			if ( SUCCEEDED ( a_Result ) )
			{
				t_Result = a_Sink->SetStatus ( 0 , a_Result , NULL , t_StatusObject ) ;
			}
			else
			{
				t_Result = a_Sink->SetStatus ( 0 , a_Result , L"Provider Subsystem Error Report" , t_StatusObject ) ;
			}

			t_StatusObject->Release () ;
		}
		else
		{
			t_Result = a_Sink->SetStatus ( 0 , a_Result , NULL , NULL ) ;
		}
	}
	else
	{
		HRESULT t_Result = a_Sink->SetStatus ( 0 , a_Result , NULL , NULL ) ;
	}

	return S_OK ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CDecoupledAggregator_IWbemProvider :: IsIndependant ( IWbemContext *a_Context )
{
	BOOL t_DependantCall = FALSE ;
	HRESULT t_Result = ProviderSubSystem_Common_Globals :: IsDependantCall ( m_InitializationContext , a_Context , t_DependantCall ) ;
	if ( SUCCEEDED ( t_Result ) )
	{
		if ( t_DependantCall == FALSE )
		{
		}
		else
		{
			return S_FALSE ;
		}
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CDecoupledAggregator_IWbemProvider :: WaitProvider ( IWbemContext *a_Context , ULONG a_Timeout )
{
	HRESULT t_Result = WBEM_E_UNEXPECTED ;

	if ( m_Initialized == 0 )
	{
		BOOL t_DependantCall = FALSE ;
		t_Result = ProviderSubSystem_Common_Globals :: IsDependantCall ( m_InitializationContext , a_Context , t_DependantCall ) ;
		if ( SUCCEEDED ( t_Result ) )
		{
			if ( t_DependantCall == FALSE )
			{
				if ( WaitForSingleObject ( m_InitializedEvent , a_Timeout ) == WAIT_TIMEOUT )
				{
					return WBEM_E_PROVIDER_LOAD_FAILURE ;
				}
			}
			else
			{
				if ( WaitForSingleObject ( m_InitializedEvent , 0 ) == WAIT_TIMEOUT )
				{
					return S_FALSE ;
				}
			}
		}
	}
	else
	{
		t_Result = S_OK ;
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CDecoupledAggregator_IWbemProvider :: SetInitialized ( HRESULT a_InitializeResult )
{
	m_InitializeResult = a_InitializeResult ;

	InterlockedExchange ( & m_Initialized , 1 ) ;

	if ( m_InitializedEvent )
	{
		SetEvent ( m_InitializedEvent ) ;
	}

	return S_OK ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

STDMETHODIMP_(ULONG) CDecoupledAggregator_IWbemProvider :: AddRef ( void )
{
	return ServiceCacheElement :: AddRef () ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

STDMETHODIMP_(ULONG) CDecoupledAggregator_IWbemProvider :: Release ( void )
{
	return ServiceCacheElement :: Release () ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

STDMETHODIMP CDecoupledAggregator_IWbemProvider :: QueryInterface (

	REFIID iid , 
	LPVOID FAR *iplpv 
) 
{
	*iplpv = NULL ;

	if ( iid == IID_IUnknown )
	{
		*iplpv = ( LPVOID ) this ;
	}
	else if ( iid == IID_IWbemServices )
	{
		*iplpv = ( LPVOID ) ( IWbemServices * ) this ;		
	}	
	else if ( iid == IID_IWbemEventProvider )
	{
		*iplpv = ( LPVOID ) ( IWbemEventProvider * ) this ;
	}
	else if ( iid == IID_IWbemEventProviderQuerySink )
	{
		*iplpv = ( LPVOID ) ( IWbemEventProviderQuerySink * ) this ;
	}
	else if ( iid == IID_IWbemEventProviderSecurity )
	{
		*iplpv = ( LPVOID ) ( IWbemEventProviderSecurity * ) this ;
	}
	else if ( iid == IID_IWbemProviderIdentity )
	{
		*iplpv = ( LPVOID ) ( IWbemProviderIdentity * ) this ;
	}
	else if ( iid == IID_IWbemEventConsumerProvider )
	{
		*iplpv = ( LPVOID ) ( IWbemEventConsumerProvider * ) this ;
	}
	else if ( iid == IID_IWbemEventConsumerProviderEx )
	{
		*iplpv = ( LPVOID ) ( IWbemEventConsumerProviderEx  * ) this ;
	}
	else if ( iid == IID__IWmiProviderSubsystemRegistrar )
	{
		*iplpv = ( LPVOID ) ( _IWmiProviderSubsystemRegistrar * ) this ;		
	}	
	else if ( iid == IID__IWmiProviderInitialize )
	{
		*iplpv = ( LPVOID ) ( _IWmiProviderInitialize * ) this ;		
	}	
	else if ( iid == IID_CDecoupledAggregator_IWbemProvider )
	{
		*iplpv = ( LPVOID ) ( CDecoupledAggregator_IWbemProvider * ) this ;
	}	
	else if ( iid == IID__IWmiProviderCache )
	{
		*iplpv = ( LPVOID ) ( _IWmiProviderCache * ) this ;
	}	
	else if ( iid == IID_IWbemShutdown )
	{
		*iplpv = ( LPVOID ) ( IWbemShutdown * )this ;		
	}	

	if ( *iplpv )
	{
		( ( LPUNKNOWN ) *iplpv )->AddRef () ;

		return ResultFromScode ( S_OK ) ;
	}
	else
	{
		return ResultFromScode ( E_NOINTERFACE ) ;
	}
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

template <class TInterface, const IID *TInterface_Id>
HRESULT GetProviders (

	IWbemContext *a_Context ,
	CWbemGlobal_IWbemSyncProviderController *a_Controller ,
	TInterface **&a_Elements ,
	ULONG &a_ElementCount ,
	ULONG &a_ContainerCount 
) 
{
	HRESULT t_Result = S_OK ;

	CWbemGlobal_IWbemSyncProvider_Container *t_Container = NULL ;
	WmiStatusCode t_StatusCode = a_Controller->GetContainer ( t_Container ) ;

	a_Controller->Lock () ;

	a_ContainerCount = t_Container->Size () ;

	a_Elements = new TInterface * [ t_Container->Size () ] ;
	if ( a_Elements )
	{
		CWbemGlobal_IWbemSyncProvider_Container_Iterator t_Iterator = t_Container->Begin () ;

		a_ElementCount = 0 ;

		while ( ! t_Iterator.Null () )
		{
			SyncProviderContainerElement *t_Element = t_Iterator.GetElement () ;

			a_Elements [ a_ElementCount ] = NULL ;

			_IWmiProviderInitialize *t_Initializer = NULL ;

			t_Result = t_Element->QueryInterface (

				IID__IWmiProviderInitialize	,
				( void ** ) & t_Initializer
			) ;

			if ( SUCCEEDED ( t_Result ) )
			{
				t_Result = t_Initializer->WaitProvider ( a_Context , DEFAULT_PROVIDER_LOAD_TIMEOUT ) ;
				if ( SUCCEEDED ( t_Result ) )
				{
					HRESULT t_Result = t_Element->QueryInterface ( *TInterface_Id , ( void ** ) & a_Elements [ a_ElementCount ] ) ;
					if ( SUCCEEDED ( t_Result ) )
					{
						a_ElementCount ++ ;
					}
				}

				t_Initializer->Release () ;
			}

			t_Iterator.Increment () ;
		}
	}
	else
	{
		t_Result = WBEM_E_OUT_OF_MEMORY ;
	}

	a_Controller->UnLock () ;

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

template <class TInterface>
HRESULT ClearProviders (

	TInterface **a_Elements ,
	ULONG a_ElementCount
) 
{
	HRESULT t_Result = S_OK ;

	for ( ULONG t_Index = 0 ; t_Index < a_ElementCount ; t_Index ++ )
	{
		a_Elements [ t_Index ]->Release () ;
	}

	delete [] a_Elements ;

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CDecoupledAggregator_IWbemProvider::OpenNamespace ( 

	const BSTR a_ObjectPath, 
	long a_Flags, 
	IWbemContext *a_Context,
	IWbemServices **a_NamespaceService, 
	IWbemCallResult **a_CallResult
)
{
	return WBEM_E_NOT_AVAILABLE ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CDecoupledAggregator_IWbemProvider :: CancelAsyncCall ( 
		
	IWbemObjectSink *a_Sink
)
{
	HRESULT t_Result = S_OK ;

	CWbemGlobal_IWmiObjectSinkController_Container_Iterator t_Iterator ;

	Lock () ;

	WmiStatusCode t_StatusCode = Find ( 

		a_Sink ,
		t_Iterator
	) ;

	if ( t_StatusCode == e_StatusCode_Success ) 
	{
		ObjectSinkContainerElement *t_Element = t_Iterator.GetElement () ;

		UnLock () ;

		IObjectSink_CancelOperation *t_ObjectSink = NULL ;
		t_Result = t_Element->QueryInterface ( IID_IObjectSink_CancelOperation , ( void ** ) & t_ObjectSink ) ;
		if ( SUCCEEDED ( t_Result ) )
		{ 
			t_Result = t_ObjectSink->Cancel (

				0
			) ;

			t_ObjectSink->Release () ;
		}

		IWbemShutdown *t_Shutdown = NULL ;
		HRESULT t_TempResult = t_Element->QueryInterface ( IID_IWbemShutdown , ( void ** ) & t_Shutdown ) ;
		if ( SUCCEEDED ( t_TempResult ) )
		{
			t_TempResult = t_Shutdown->Shutdown ( 

				0 , 
				0 , 
				NULL 
			) ;

			t_Shutdown->Release () ;
		}

		t_Element->Release () ;
	}
	else
	{
		UnLock () ;

		t_Result = WBEM_E_NOT_FOUND ;
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CDecoupledAggregator_IWbemProvider :: QueryObjectSink ( 

	long a_Flags,		
	IWbemObjectSink **a_Sink
) 
{
	return WBEM_E_NOT_AVAILABLE ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CDecoupledAggregator_IWbemProvider :: GetObject ( 
		
	const BSTR a_ObjectPath,
    long a_Flags,
    IWbemContext *a_Context,
    IWbemClassObject **a_Object,
    IWbemCallResult **a_CallResult
)
{
	return WBEM_E_NOT_AVAILABLE ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CDecoupledAggregator_IWbemProvider :: GetObjectAsync ( 
		
	const BSTR a_ObjectPath, 
	long a_Flags, 
	IWbemContext *a_Context,
	IWbemObjectSink *a_Sink
) 
{
	if ( m_Initialized == 0 )
	{
		a_Sink->SetStatus ( 0 , WBEM_E_NOT_FOUND , NULL , NULL ) ;

		return WBEM_E_NOT_FOUND ;
	}

	BOOL t_ObjectGot = FALSE ;

	IWbemServices **t_Elements = NULL ;
	ULONG t_ElementsCount = 0 ;
	ULONG t_ContainerCount = 0 ;

	HRESULT t_Result = GetProviders <IWbemServices,&IID_IWbemServices> ( a_Context , m_Controller , t_Elements , t_ElementsCount , t_ContainerCount ) ;
	if ( SUCCEEDED ( t_Result ) )
	{
		for ( ULONG t_Index = 0 ; ( t_Index < t_ElementsCount ) && SUCCEEDED ( t_Result ) ; t_Index ++ )
		{
			IWbemServices *t_Provider = t_Elements [ t_Index ] ;

			CInterceptor_IWbemWaitingObjectSink *t_GettingSink = new CInterceptor_IWbemWaitingObjectSink (

				m_Allocator , 
				t_Provider ,
				a_Sink ,
				( CWbemGlobal_IWmiObjectSinkController * ) this ,
				*m_Registration
			) ;

			if ( t_GettingSink )
			{
				t_GettingSink->AddRef () ;

				if ( SUCCEEDED ( t_Result ) ) 
				{
					CWbemGlobal_IWmiObjectSinkController_Container_Iterator t_Iterator ;

					Lock () ;

					WmiStatusCode t_StatusCode = Insert ( 

						*t_GettingSink ,
						t_Iterator
					) ;

					UnLock () ;

					if ( t_StatusCode == e_StatusCode_Success ) 
					{
						t_Result = t_Provider->GetObjectAsync ( 
								
							a_ObjectPath , 
							0 , 
							a_Context,
							t_GettingSink
						) ;

						if ( FAILED ( t_Result ) )
						{
							if ( ( HRESULT_ERROR_FUNC(t_Result) == RPC_S_SERVER_UNAVAILABLE ) || ( HRESULT_ERROR_FUNC(t_Result) == RPC_S_CALL_FAILED_DNE ) )
							{
								AbnormalShutdown ( t_Elements [ t_Index ] ) ;
							}
						}

						if ( SUCCEEDED ( t_Result ) )
						{
							t_Result = t_GettingSink->Wait ( INFINITE ) ;
							if ( SUCCEEDED ( t_Result ) )
							{
								t_Result = t_GettingSink->GetResult () ;
								if ( SUCCEEDED ( t_Result ) )
								{
									t_ObjectGot = TRUE ;
								}
								else
								{
									if ( t_Result == WBEM_E_NOT_FOUND || t_Result  == WBEM_E_INVALID_CLASS )
									{
										t_Result = S_OK ;
									}
								}
							}
						}
						else
						{
							if ( t_Result == WBEM_E_NOT_FOUND || t_Result  == WBEM_E_INVALID_CLASS )
							{
								t_Result = S_OK ;
							}
						}
					}
					else
					{
						t_Result = WBEM_E_OUT_OF_MEMORY ;
					}

					WmiQueue <IWbemClassObject *,8> &t_Queue = t_GettingSink->GetQueue () ;

					IWbemClassObject *t_Object = NULL ;
					while ( ( t_StatusCode = t_Queue.Top ( t_Object ) ) == e_StatusCode_Success )
					{
						if ( SUCCEEDED ( t_Result ) )
						{
							t_Result = a_Sink->Indicate ( 1 , & t_Object ) ;
						}

						t_Object->Release () ;
						t_StatusCode = t_Queue.DeQueue () ;
					}
				}

				t_GettingSink->Release () ;
			}
			else
			{
				t_Result = WBEM_E_OUT_OF_MEMORY ;
			}
		}

		HRESULT t_TempResult = ClearProviders <IWbemServices> ( t_Elements , t_ElementsCount ) ;
	}

	if ( SUCCEEDED ( t_Result ) )
	{
		if ( t_ObjectGot == FALSE )
		{
			if ( t_ElementsCount )
			{ 
				t_Result = WBEM_E_NOT_FOUND ;

				a_Sink->SetStatus ( 0 , t_Result , NULL , NULL ) ;
			}
			else
			{
				SetStatus ( L"GetObjectAsync" , NULL , L"No Decoupled Providers Attached" , WBEM_E_NOT_FOUND , a_Sink ) ;
			}
		}
		else
		{
			a_Sink->SetStatus ( 0 , t_Result , NULL , NULL ) ;
		}
	}
	else
	{
		a_Sink->SetStatus ( 0 , t_Result , NULL , NULL ) ;
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CDecoupledAggregator_IWbemProvider :: PutClass ( 
		
	IWbemClassObject *a_Object, 
	long a_Flags, 
	IWbemContext *a_Context,
	IWbemCallResult **a_CallResult
) 
{
	return WBEM_E_NOT_AVAILABLE ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CDecoupledAggregator_IWbemProvider :: PutClassAsync ( 
		
	IWbemClassObject *a_Object, 
	long a_Flags, 
	IWbemContext *a_Context,
	IWbemObjectSink *a_Sink
) 
{
	if ( m_Initialized == 0 )
	{
		if ( WBEM_FLAG_ADVISORY & a_Flags )
		{
			a_Sink->SetStatus ( 0 , S_OK , NULL , NULL ) ;

			return S_OK ;
		}
		else
		{
			a_Sink->SetStatus ( 0 , WBEM_E_NOT_FOUND , NULL , NULL ) ;

			return WBEM_E_NOT_FOUND ;
		}
	}

	BOOL t_ClassPut = FALSE ;

	IWbemServices **t_Elements = NULL ;
	ULONG t_ElementsCount = 0 ;
	ULONG t_ContainerCount = 0 ;

	HRESULT t_Result = GetProviders <IWbemServices,&IID_IWbemServices> ( a_Context , m_Controller , t_Elements , t_ElementsCount , t_ContainerCount ) ;
	if ( SUCCEEDED ( t_Result ) )
	{
		for ( ULONG t_Index = 0 ; ( t_Index < t_ElementsCount ) && SUCCEEDED ( t_Result ) ; t_Index ++ )
		{
			IWbemServices *t_Provider = t_Elements [ t_Index ] ;

			CInterceptor_IWbemWaitingObjectSink *t_ClassPuttingSink = new CInterceptor_IWbemWaitingObjectSink (

				m_Allocator , 
				t_Provider ,
				a_Sink ,
				( CWbemGlobal_IWmiObjectSinkController * ) this ,
				*m_Registration
			) ;

			if ( t_ClassPuttingSink )
			{
				t_ClassPuttingSink->AddRef () ;

				if ( SUCCEEDED ( t_Result ) ) 
				{
					CWbemGlobal_IWmiObjectSinkController_Container_Iterator t_Iterator ;

					Lock () ;

					WmiStatusCode t_StatusCode = Insert ( 

						*t_ClassPuttingSink ,
						t_Iterator
					) ;

					UnLock () ;

					if ( t_StatusCode == e_StatusCode_Success ) 
					{
						t_Result = t_Provider->PutClassAsync ( 
								
							a_Object , 
							a_Flags & ~WBEM_FLAG_USE_AMENDED_QUALIFIERS , 
							a_Context,
							t_ClassPuttingSink
						) ;

						if ( FAILED ( t_Result ) )
						{
							if ( ( HRESULT_ERROR_FUNC(t_Result) == RPC_S_SERVER_UNAVAILABLE ) || ( HRESULT_ERROR_FUNC(t_Result) == RPC_S_CALL_FAILED_DNE ) )
							{
								AbnormalShutdown ( t_Elements [ t_Index ] ) ;
							}
						}

						if ( SUCCEEDED ( t_Result ) )
						{
							t_Result = t_ClassPuttingSink->Wait ( INFINITE ) ;
							if ( SUCCEEDED ( t_Result ) )
							{
								if ( SUCCEEDED ( t_ClassPuttingSink->GetResult () ) )
								{
									t_ClassPut = TRUE ;
								}
							}
							else
							{
								if ( t_Result == WBEM_E_NOT_FOUND || t_Result  == WBEM_E_INVALID_CLASS )
								{
									t_Result = S_OK ;
								}
							}
						}
						else
						{
							if ( t_Result == WBEM_E_NOT_FOUND || t_Result  == WBEM_E_INVALID_CLASS )
							{
								t_Result = S_OK ;
							}
						}
					}
					else
					{
						t_Result = WBEM_E_OUT_OF_MEMORY ;
					}

					WmiQueue <IWbemClassObject *,8> &t_Queue = t_ClassPuttingSink->GetQueue () ;

					IWbemClassObject *t_Object = NULL ;
					while ( ( t_StatusCode = t_Queue.Top ( t_Object ) ) == e_StatusCode_Success )
					{
						t_Object->Release () ;
						t_StatusCode = t_Queue.DeQueue () ;
					}
				}

				t_ClassPuttingSink->Release () ;
			}
			else
			{
				t_Result = WBEM_E_OUT_OF_MEMORY ;
			}
		}

		HRESULT t_TempResult = ClearProviders <IWbemServices> ( t_Elements , t_ElementsCount ) ;
	}

	if ( SUCCEEDED ( t_Result ) )
	{
		if ( t_ClassPut == FALSE )
		{
			if ( t_ElementsCount )
			{ 
				t_Result = WBEM_E_NOT_FOUND ;

				a_Sink->SetStatus ( 0 , t_Result , NULL , NULL ) ;
			}
			else
			{
				SetStatus ( L"PutClassAsync" , NULL , L"No Decoupled Providers Attached" , WBEM_E_NOT_FOUND , a_Sink ) ;
			}
		}
		else
		{
			a_Sink->SetStatus ( 0 , t_Result , NULL , NULL ) ;
		}
	}
	else
	{
		a_Sink->SetStatus ( 0 , t_Result , NULL , NULL ) ;
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CDecoupledAggregator_IWbemProvider :: DeleteClass ( 
		
	const BSTR a_Class, 
	long a_Flags, 
	IWbemContext *a_Context,
	IWbemCallResult **a_CallResult
) 
{
 	 return WBEM_E_NOT_AVAILABLE ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CDecoupledAggregator_IWbemProvider :: DeleteClassAsync ( 
		
	const BSTR a_Class, 
	long a_Flags, 
	IWbemContext *a_Context,
	IWbemObjectSink *a_Sink
) 
{
	if ( m_Initialized == 0 )
	{
		if ( WBEM_FLAG_ADVISORY & a_Flags )
		{
			a_Sink->SetStatus ( 0 , S_OK , NULL , NULL ) ;

			return S_OK ;
		}
		else
		{
			a_Sink->SetStatus ( 0 , WBEM_E_NOT_FOUND , NULL , NULL ) ;

			return WBEM_E_NOT_FOUND ;
		}
	}

	BOOL t_ClassDeleted = FALSE ;

	IWbemServices **t_Elements = NULL ;
	ULONG t_ElementsCount = 0 ;
	ULONG t_ContainerCount = 0 ;

	HRESULT t_Result = GetProviders <IWbemServices,&IID_IWbemServices> ( a_Context , m_Controller , t_Elements , t_ElementsCount , t_ContainerCount ) ;
	if ( SUCCEEDED ( t_Result ) )
	{
		for ( ULONG t_Index = 0 ; ( t_Index < t_ElementsCount ) && SUCCEEDED ( t_Result ) ; t_Index ++ )
		{
			IWbemServices *t_Provider = t_Elements [ t_Index ] ;

			CInterceptor_IWbemWaitingObjectSink *t_ClassDeletingSink = new CInterceptor_IWbemWaitingObjectSink (

				m_Allocator , 
				t_Provider ,
				a_Sink ,
				( CWbemGlobal_IWmiObjectSinkController * ) this ,
				*m_Registration
			) ;

			if ( t_ClassDeletingSink )
			{
				t_ClassDeletingSink->AddRef () ;

				if ( SUCCEEDED ( t_Result ) ) 
				{
					CWbemGlobal_IWmiObjectSinkController_Container_Iterator t_Iterator ;

					Lock () ;

					WmiStatusCode t_StatusCode = Insert ( 

						*t_ClassDeletingSink ,
						t_Iterator
					) ;

					UnLock () ;

					if ( t_StatusCode == e_StatusCode_Success ) 
					{
						t_Result = t_Provider->DeleteClassAsync ( 
								
							a_Class , 
							a_Flags & ~WBEM_FLAG_USE_AMENDED_QUALIFIERS , 
							a_Context,
							t_ClassDeletingSink
						) ;

						if ( FAILED ( t_Result ) )
						{
							if ( ( HRESULT_ERROR_FUNC(t_Result) == RPC_S_SERVER_UNAVAILABLE ) || ( HRESULT_ERROR_FUNC(t_Result) == RPC_S_CALL_FAILED_DNE ) )
							{
								AbnormalShutdown ( t_Elements [ t_Index ] ) ;
							}
						}

						if ( SUCCEEDED ( t_Result ) )
						{
							t_Result = t_ClassDeletingSink->Wait ( INFINITE ) ;
							if ( SUCCEEDED ( t_Result ) )
							{
								if ( SUCCEEDED ( t_ClassDeletingSink->GetResult () ) )
								{
									t_ClassDeleted = TRUE ;
								}
							}
							else
							{
								if ( t_Result == WBEM_E_NOT_FOUND || t_Result  == WBEM_E_INVALID_CLASS )
								{
									t_Result = S_OK ;
								}
							}
						}
						else
						{
							if ( t_Result == WBEM_E_NOT_FOUND || t_Result  == WBEM_E_INVALID_CLASS )
							{
								t_Result = S_OK ;
							}
						}
					}
					else
					{
						t_Result = WBEM_E_OUT_OF_MEMORY ;
					}

					WmiQueue <IWbemClassObject *,8> &t_Queue = t_ClassDeletingSink->GetQueue () ;

					IWbemClassObject *t_Object = NULL ;
					while ( ( t_StatusCode = t_Queue.Top ( t_Object ) ) == e_StatusCode_Success )
					{
						t_Object->Release () ;
						t_StatusCode = t_Queue.DeQueue () ;
					}
				}

				t_ClassDeletingSink->Release () ;
			}
			else
			{
				t_Result = WBEM_E_OUT_OF_MEMORY ;
			}
		}

		HRESULT t_TempResult = ClearProviders <IWbemServices> ( t_Elements , t_ElementsCount ) ;
	}

	if ( SUCCEEDED ( t_Result ) )
	{
		if ( t_ClassDeleted == FALSE )
		{
			if ( t_ElementsCount )
			{ 
				t_Result = WBEM_E_NOT_FOUND ;

				a_Sink->SetStatus ( 0 , t_Result , NULL , NULL ) ;
			}
			else
			{
				SetStatus ( L"DeleteClassAsync" , NULL , L"No Decoupled Providers Attached" , WBEM_E_NOT_FOUND , a_Sink ) ;
			}
		}
		else
		{
			a_Sink->SetStatus ( 0 , t_Result , NULL , NULL ) ;
		}
	}
	else
	{
		a_Sink->SetStatus ( 0 , t_Result , NULL , NULL ) ;
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CDecoupledAggregator_IWbemProvider :: CreateClassEnum ( 

	const BSTR a_Superclass, 
	long a_Flags, 
	IWbemContext *a_Context,
	IEnumWbemClassObject **a_Enum
) 
{
	return WBEM_E_NOT_AVAILABLE ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

SCODE CDecoupledAggregator_IWbemProvider :: CreateClassEnumAsync (

	const BSTR a_Superclass , 
	long a_Flags, 
	IWbemContext *a_Context,
	IWbemObjectSink *a_Sink
) 
{
	if ( m_Initialized == 0 )
	{
		a_Sink->SetStatus ( 0 , S_OK , NULL , NULL ) ;

		return S_OK ;
	}

	HRESULT t_Result = S_OK ;

	CInterceptor_DecoupledIWbemCombiningObjectSink *t_CombiningSink = new CInterceptor_DecoupledIWbemCombiningObjectSink (

		m_Allocator ,
		a_Sink , 
		( CWbemGlobal_IWmiObjectSinkController * ) this
	) ;

	if ( t_CombiningSink )
	{
		t_CombiningSink->AddRef () ;

		t_CombiningSink->Suspend () ;

		CWbemGlobal_IWmiObjectSinkController_Container_Iterator t_Iterator ;

		Lock () ;

		WmiStatusCode t_StatusCode = Insert ( 

			*t_CombiningSink ,
			t_Iterator
		) ;

		UnLock () ;

		if ( t_StatusCode == e_StatusCode_Success ) 
		{
			IWbemServices **t_Elements = NULL ;
			ULONG t_ElementsCount = 0 ;
			ULONG t_ContainerCount = 0 ;

			t_Result = GetProviders <IWbemServices,&IID_IWbemServices> ( a_Context , m_Controller , t_Elements , t_ElementsCount , t_ContainerCount ) ;
			if ( SUCCEEDED ( t_Result ) )
			{
				BOOL t_ProviderFound = FALSE ;

				for ( ULONG t_Index = 0 ; ( t_Index < t_ElementsCount ) && SUCCEEDED ( t_Result ) ; t_Index ++ )
				{
					IWbemServices *t_Provider = t_Elements [ t_Index ] ; 

					CInterceptor_DecoupledIWbemObjectSink *t_Sink = new CInterceptor_DecoupledIWbemObjectSink (

						t_Provider ,
						t_CombiningSink , 
						( IWbemObjectSink * ) t_CombiningSink , 
						( CWbemGlobal_IWmiObjectSinkController * ) t_CombiningSink
					) ;

					if ( t_Sink )
					{
						t_Sink->AddRef () ;

						if ( SUCCEEDED ( t_Result ) ) 
						{
							t_Result = t_CombiningSink->EnQueue ( t_Sink ) ;
							if ( SUCCEEDED ( t_Result ) )
							{
								t_Result = t_Provider->CreateClassEnumAsync ( 
										
									a_Superclass , 
									a_Flags, 
									a_Context,
									t_Sink
								) ;

								if ( FAILED ( t_Result ) )
								{
									if ( ( HRESULT_ERROR_FUNC(t_Result) == RPC_S_SERVER_UNAVAILABLE ) || ( HRESULT_ERROR_FUNC(t_Result) == RPC_S_CALL_FAILED_DNE ) )
									{
										AbnormalShutdown ( t_Elements [ t_Index ] ) ;
									}
								}

								if ( SUCCEEDED ( t_Result ) )
								{
								}
								else
								{
									if ( t_Result == WBEM_E_NOT_FOUND || t_Result  == WBEM_E_INVALID_CLASS )
									{
										t_Result = S_OK ;
									}
								}
							}
						}

						t_Sink->Release () ;
					}
					else
					{
						t_Result = WBEM_E_OUT_OF_MEMORY ;
					}
				}

				HRESULT t_TempResult = ClearProviders <IWbemServices> ( t_Elements , t_ElementsCount ) ;
			}

			if ( SUCCEEDED ( t_Result ) && t_ElementsCount )
			{
				t_CombiningSink->Resume () ;

				t_Result = t_CombiningSink->Wait ( INFINITE ) ;
			}
			else
			{
				SetStatus ( L"CreateClassEnumAsync" , NULL , L"No Decoupled Providers Attached" , WBEM_S_SOURCE_NOT_AVAILABLE , a_Sink ) ;
			}
		}
		else
		{
			t_Result = WBEM_E_OUT_OF_MEMORY ;
		}

		t_CombiningSink->Release () ;
	}
	else
	{
		t_Result = WBEM_E_OUT_OF_MEMORY ;
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CDecoupledAggregator_IWbemProvider :: PutInstance (

    IWbemClassObject *a_Instance,
    long a_Flags,
    IWbemContext *a_Context,
	IWbemCallResult **a_CallResult
) 
{
	return WBEM_E_NOT_AVAILABLE ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CDecoupledAggregator_IWbemProvider :: PutInstanceAsync ( 
		
	IWbemClassObject *a_Instance, 
	long a_Flags ,
    IWbemContext *a_Context ,
	IWbemObjectSink *a_Sink
) 
{
	if ( m_Initialized == 0 )
	{
		if ( WBEM_FLAG_ADVISORY & a_Flags )
		{
			a_Sink->SetStatus ( 0 , S_OK , NULL , NULL ) ;

			return S_OK ;
		}
		else
		{
			a_Sink->SetStatus ( 0 , WBEM_E_NOT_FOUND , NULL , NULL ) ;

			return WBEM_E_NOT_FOUND ;
		}
	}

	BOOL t_InstancePut = FALSE ;

	IWbemServices **t_Elements = NULL ;
	ULONG t_ElementsCount = 0 ;
	ULONG t_ContainerCount = 0 ;

	HRESULT t_Result = GetProviders <IWbemServices,&IID_IWbemServices> ( a_Context , m_Controller , t_Elements , t_ElementsCount , t_ContainerCount ) ;
	if ( SUCCEEDED ( t_Result ) )
	{
		for ( ULONG t_Index = 0 ; ( t_Index < t_ElementsCount ) && SUCCEEDED ( t_Result ) ; t_Index ++ )
		{
			IWbemServices *t_Provider = t_Elements [ t_Index ] ;

			CInterceptor_IWbemWaitingObjectSink *t_InstancePuttingSink = new CInterceptor_IWbemWaitingObjectSink (

				m_Allocator , 
				t_Provider ,
				a_Sink ,
				( CWbemGlobal_IWmiObjectSinkController * ) this ,
				*m_Registration
			) ;

			if ( t_InstancePuttingSink )
			{
				t_InstancePuttingSink->AddRef () ;

				if ( SUCCEEDED ( t_Result ) ) 
				{
					CWbemGlobal_IWmiObjectSinkController_Container_Iterator t_Iterator ;

					Lock () ;

					WmiStatusCode t_StatusCode = Insert ( 

						*t_InstancePuttingSink ,
						t_Iterator
					) ;

					UnLock () ;

					if ( t_StatusCode == e_StatusCode_Success ) 
					{
						t_Result = t_Provider->PutInstanceAsync ( 
								
							a_Instance , 
							a_Flags & ~WBEM_FLAG_USE_AMENDED_QUALIFIERS , 
							a_Context,
							t_InstancePuttingSink
						) ;

						if ( FAILED ( t_Result ) )
						{
							if ( ( HRESULT_ERROR_FUNC(t_Result) == RPC_S_SERVER_UNAVAILABLE ) || ( HRESULT_ERROR_FUNC(t_Result) == RPC_S_CALL_FAILED_DNE ) )
							{
								AbnormalShutdown ( t_Elements [ t_Index ] ) ;
							}
						}

						if ( SUCCEEDED ( t_Result ) )
						{
							t_Result = t_InstancePuttingSink->Wait ( INFINITE ) ;
							if ( SUCCEEDED ( t_Result ) )
							{
								if ( SUCCEEDED ( t_InstancePuttingSink->GetResult () ) )
								{
									t_InstancePut = TRUE ;
								}
							}
							else
							{
								if ( t_Result == WBEM_E_NOT_FOUND || t_Result  == WBEM_E_INVALID_CLASS )
								{
									t_Result = S_OK ;
								}
							}
						}
						else
						{
							if ( t_Result == WBEM_E_NOT_FOUND || t_Result  == WBEM_E_INVALID_CLASS )
							{
								t_Result = S_OK ;
							}
						}
					}
					else
					{
						t_Result = WBEM_E_OUT_OF_MEMORY ;
					}

					WmiQueue <IWbemClassObject *,8> &t_Queue = t_InstancePuttingSink->GetQueue () ;

					IWbemClassObject *t_Object = NULL ;
					while ( ( t_StatusCode = t_Queue.Top ( t_Object ) ) == e_StatusCode_Success )
					{
						t_Object->Release () ;
						t_StatusCode = t_Queue.DeQueue () ;
					}
				}

				t_InstancePuttingSink->Release () ;
			}
			else
			{
				t_Result = WBEM_E_OUT_OF_MEMORY ;
			}
		}

		HRESULT t_TempResult = ClearProviders <IWbemServices> ( t_Elements , t_ElementsCount ) ;
	}

	if ( SUCCEEDED ( t_Result ) )
	{
		if ( t_InstancePut == FALSE )
		{
			if ( t_ElementsCount )
			{ 
				t_Result = WBEM_E_NOT_FOUND ;

				a_Sink->SetStatus ( 0 , t_Result , NULL , NULL ) ;
			}
			else
			{
				SetStatus ( L"PutInstanceAsync" , NULL , L"No Decoupled Providers Attached" , WBEM_E_NOT_FOUND , a_Sink ) ;
			}
		}
		else
		{
			a_Sink->SetStatus ( 0 , t_Result , NULL , NULL ) ;
		}
	}
	else
	{
		a_Sink->SetStatus ( 0 , t_Result , NULL , NULL ) ;
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CDecoupledAggregator_IWbemProvider :: DeleteInstance ( 

	const BSTR a_ObjectPath,
    long a_Flags,
    IWbemContext *a_Context,
    IWbemCallResult **a_CallResult
)
{
	return WBEM_E_NOT_AVAILABLE ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/
        
HRESULT CDecoupledAggregator_IWbemProvider :: DeleteInstanceAsync (
 
	const BSTR a_ObjectPath,
    long a_Flags,
    IWbemContext *a_Context,
    IWbemObjectSink *a_Sink
)
{
	if ( m_Initialized == 0 )
	{
		if ( WBEM_FLAG_ADVISORY & a_Flags )
		{
			a_Sink->SetStatus ( 0 , S_OK , NULL , NULL ) ;

			return S_OK ;
		}
		else
		{
			a_Sink->SetStatus ( 0 , WBEM_E_NOT_FOUND , NULL , NULL ) ;

			return WBEM_E_NOT_FOUND ;
		}
	}

	BOOL t_InstanceDeleted = FALSE ;

	IWbemServices **t_Elements = NULL ;
	ULONG t_ElementsCount = 0 ;
	ULONG t_ContainerCount = 0 ;

	HRESULT t_Result = GetProviders <IWbemServices,&IID_IWbemServices> ( a_Context , m_Controller , t_Elements , t_ElementsCount , t_ContainerCount ) ;
	if ( SUCCEEDED ( t_Result ) )
	{
		for ( ULONG t_Index = 0 ; ( t_Index < t_ElementsCount ) && SUCCEEDED ( t_Result ) ; t_Index ++ )
		{
			IWbemServices *t_Provider = t_Elements [ t_Index ] ;

			CInterceptor_IWbemWaitingObjectSink *t_InstanceDeletingSink = new CInterceptor_IWbemWaitingObjectSink (

				m_Allocator , 
				t_Provider ,
				a_Sink ,
				( CWbemGlobal_IWmiObjectSinkController * ) this ,
				*m_Registration
			) ;

			if ( t_InstanceDeletingSink )
			{
				t_InstanceDeletingSink->AddRef () ;

				if ( SUCCEEDED ( t_Result ) ) 
				{
					CWbemGlobal_IWmiObjectSinkController_Container_Iterator t_Iterator ;

					Lock () ;

					WmiStatusCode t_StatusCode = Insert ( 

						*t_InstanceDeletingSink ,
						t_Iterator
					) ;

					UnLock () ;

					if ( t_StatusCode == e_StatusCode_Success ) 
					{
						t_Result = t_Provider->DeleteInstanceAsync ( 
								
							a_ObjectPath , 
							a_Flags & ~WBEM_FLAG_USE_AMENDED_QUALIFIERS , 
							a_Context,
							t_InstanceDeletingSink
						) ;

						if ( FAILED ( t_Result ) )
						{
							if ( ( HRESULT_ERROR_FUNC(t_Result) == RPC_S_SERVER_UNAVAILABLE ) || ( HRESULT_ERROR_FUNC(t_Result) == RPC_S_CALL_FAILED_DNE ) )
							{
								AbnormalShutdown ( t_Elements [ t_Index ] ) ;
							}
						}

						if ( SUCCEEDED ( t_Result ) )
						{
							t_Result = t_InstanceDeletingSink->Wait ( INFINITE ) ;
							if ( SUCCEEDED ( t_Result ) )
							{
								if ( SUCCEEDED ( t_InstanceDeletingSink->GetResult () ) )
								{
									t_InstanceDeleted = TRUE ;
								}
							}
							else
							{
								if ( t_Result == WBEM_E_NOT_FOUND || t_Result  == WBEM_E_INVALID_CLASS )
								{
									t_Result = S_OK ;
								}
							}
						}
						else
						{
							if ( t_Result == WBEM_E_NOT_FOUND || t_Result  == WBEM_E_INVALID_CLASS )
							{
								t_Result = S_OK ;
							}
						}
					}
					else
					{
						t_Result = WBEM_E_OUT_OF_MEMORY ;
					}

					WmiQueue <IWbemClassObject *,8> &t_Queue = t_InstanceDeletingSink->GetQueue () ;

					IWbemClassObject *t_Object = NULL ;
					while ( ( t_StatusCode = t_Queue.Top ( t_Object ) ) == e_StatusCode_Success )
					{
						t_Object->Release () ;
						t_StatusCode = t_Queue.DeQueue () ;
					}
				}

				t_InstanceDeletingSink->Release () ;
			}
			else
			{
				t_Result = WBEM_E_OUT_OF_MEMORY ;
			}
		}

		HRESULT t_TempResult = ClearProviders <IWbemServices> ( t_Elements , t_ElementsCount ) ;
	}

	if ( SUCCEEDED ( t_Result ) )
	{
		if ( t_InstanceDeleted == FALSE )
		{
			if ( t_ElementsCount )
			{ 
				t_Result = WBEM_E_NOT_FOUND ;

				a_Sink->SetStatus ( 0 , t_Result , NULL , NULL ) ;
			}
			else
			{
				SetStatus ( L"DeleteInstanceAsync" , NULL , L"No Decoupled Providers Attached" , WBEM_E_NOT_FOUND , a_Sink ) ;
			}
		}
		else
		{
			a_Sink->SetStatus ( 0 , t_Result , NULL , NULL ) ;
		}
	}
	else
	{
		a_Sink->SetStatus ( 0 , t_Result , NULL , NULL ) ;
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CDecoupledAggregator_IWbemProvider :: CreateInstanceEnum ( 

	const BSTR a_Class, 
	long a_Flags, 
	IWbemContext *a_Context, 
	IEnumWbemClassObject **a_Enum
)
{
	return WBEM_E_NOT_AVAILABLE ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CDecoupledAggregator_IWbemProvider :: CreateInstanceEnumAsync (

 	const BSTR a_Class ,
	long a_Flags ,
	IWbemContext *a_Context ,
	IWbemObjectSink *a_Sink
) 
{
	if ( m_Initialized == 0 )
	{
		a_Sink->SetStatus ( 0 , S_OK , NULL , NULL ) ;

		return S_OK ;
	}

	HRESULT t_Result = S_OK ;

	CInterceptor_DecoupledIWbemCombiningObjectSink *t_CombiningSink = new CInterceptor_DecoupledIWbemCombiningObjectSink (

		m_Allocator ,
		a_Sink , 
		( CWbemGlobal_IWmiObjectSinkController * ) this
	) ;

	if ( t_CombiningSink )
	{
		t_CombiningSink->AddRef () ;

		t_CombiningSink->Suspend () ;

		CWbemGlobal_IWmiObjectSinkController_Container_Iterator t_Iterator ;

		Lock () ;

		WmiStatusCode t_StatusCode = Insert ( 

			*t_CombiningSink ,
			t_Iterator
		) ;

		UnLock () ;

		if ( t_StatusCode == e_StatusCode_Success ) 
		{
			IWbemServices **t_Elements = NULL ;
			ULONG t_ElementsCount = 0 ;
			ULONG t_ContainerCount = 0 ;

			t_Result = GetProviders <IWbemServices,&IID_IWbemServices> ( a_Context , m_Controller , t_Elements , t_ElementsCount , t_ContainerCount ) ;
			if ( SUCCEEDED ( t_Result ) )
			{
				BOOL t_ProviderFound = FALSE ;

				for ( ULONG t_Index = 0 ; ( t_Index < t_ElementsCount ) && SUCCEEDED ( t_Result ) ; t_Index ++ )
				{
					IWbemServices *t_Provider = t_Elements [ t_Index ] ; 

					CInterceptor_DecoupledIWbemObjectSink *t_Sink = new CInterceptor_DecoupledIWbemObjectSink (

						t_Provider ,
						t_CombiningSink , 
						( IWbemObjectSink * ) t_CombiningSink , 
						( CWbemGlobal_IWmiObjectSinkController * ) t_CombiningSink
					) ;

					if ( t_Sink )
					{
						t_Sink->AddRef () ;

						if ( SUCCEEDED ( t_Result ) ) 
						{
							t_Result = t_CombiningSink->EnQueue ( t_Sink ) ;
							if ( SUCCEEDED ( t_Result ) )
							{
								t_Result = t_Provider->CreateInstanceEnumAsync ( 
										
									a_Class, 
									a_Flags, 
									a_Context,
									t_Sink
								) ;

								if ( FAILED ( t_Result ) )
								{
									if ( ( HRESULT_ERROR_FUNC(t_Result) == RPC_S_SERVER_UNAVAILABLE ) || ( HRESULT_ERROR_FUNC(t_Result) == RPC_S_CALL_FAILED_DNE ) )
									{
										AbnormalShutdown ( t_Elements [ t_Index ] ) ;
									}
								}

								if ( SUCCEEDED ( t_Result ) )
								{
								}
								else
								{
									if ( t_Result == WBEM_E_NOT_FOUND || t_Result  == WBEM_E_INVALID_CLASS )
									{
										t_Result = S_OK ;
									}
								}
							}
						}

						t_Sink->Release () ;
					}
					else
					{
						t_Result = WBEM_E_OUT_OF_MEMORY ;
					}
				}

				HRESULT t_TempResult = ClearProviders <IWbemServices> ( t_Elements , t_ElementsCount ) ;
			}

			if ( SUCCEEDED ( t_Result ) && t_ElementsCount )
			{
				t_CombiningSink->Resume () ;

				t_Result = t_CombiningSink->Wait ( INFINITE ) ;
			}
			else
			{
				SetStatus ( L"CreateInstanceEnumAsync" , NULL , L"No Decoupled Providers Attached" , WBEM_S_SOURCE_NOT_AVAILABLE , a_Sink ) ;
			}
		}
		else
		{
			t_Result = WBEM_E_OUT_OF_MEMORY ;
		}

		t_CombiningSink->Release () ;
	}
	else
	{
		t_Result = WBEM_E_OUT_OF_MEMORY ;
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CDecoupledAggregator_IWbemProvider :: ExecQuery ( 

	const BSTR a_QueryLanguage, 
	const BSTR a_Query, 
	long a_Flags, 
	IWbemContext *a_Context,
	IEnumWbemClassObject **a_Enum
)
{
	return WBEM_E_NOT_AVAILABLE ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CDecoupledAggregator_IWbemProvider :: ExecQueryAsync ( 
		
	const BSTR a_QueryLanguage, 
	const BSTR a_Query, 
	long a_Flags, 
	IWbemContext *a_Context,
	IWbemObjectSink *a_Sink
) 
{
	if ( m_Initialized == 0 )
	{
		a_Sink->SetStatus ( 0 , S_OK , NULL , NULL ) ;

		return S_OK ;
	}

	HRESULT t_Result = S_OK ;

	CInterceptor_DecoupledIWbemCombiningObjectSink *t_CombiningSink = new CInterceptor_DecoupledIWbemCombiningObjectSink (

		m_Allocator ,
		a_Sink , 
		( CWbemGlobal_IWmiObjectSinkController * ) this
	) ;

	if ( t_CombiningSink )
	{
		t_CombiningSink->AddRef () ;

		t_CombiningSink->Suspend () ;

		CWbemGlobal_IWmiObjectSinkController_Container_Iterator t_Iterator ;

		Lock () ;

		WmiStatusCode t_StatusCode = Insert ( 

			*t_CombiningSink ,
			t_Iterator
		) ;

		UnLock () ;

		if ( t_StatusCode == e_StatusCode_Success ) 
		{
			IWbemServices **t_Elements = NULL ;
			ULONG t_ElementsCount = 0 ;
			ULONG t_ContainerCount = 0 ;

			t_Result = GetProviders <IWbemServices,&IID_IWbemServices> ( a_Context , m_Controller , t_Elements , t_ElementsCount , t_ContainerCount ) ;
			if ( SUCCEEDED ( t_Result ) )
			{
				BOOL t_ProviderFound = FALSE ;

				for ( ULONG t_Index = 0 ; ( t_Index < t_ElementsCount ) && SUCCEEDED ( t_Result ) ; t_Index ++ )
				{
					IWbemServices *t_Provider = t_Elements [ t_Index ] ; 

					CInterceptor_DecoupledIWbemObjectSink *t_Sink = new CInterceptor_DecoupledIWbemObjectSink (

						t_Provider ,
						t_CombiningSink , 
						( IWbemObjectSink * ) t_CombiningSink , 
						( CWbemGlobal_IWmiObjectSinkController * ) t_CombiningSink
					) ;

					if ( t_Sink )
					{
						t_Sink->AddRef () ;

						if ( SUCCEEDED ( t_Result ) ) 
						{
							t_Result = t_CombiningSink->EnQueue ( t_Sink ) ;
							if ( SUCCEEDED ( t_Result ) )
							{
								t_Result = t_Provider->ExecQueryAsync ( 
										
									a_QueryLanguage, 
									a_Query, 
									a_Flags, 
									a_Context,
									t_Sink
								) ;

								if ( FAILED ( t_Result ) )
								{
									if ( ( HRESULT_ERROR_FUNC(t_Result) == RPC_S_SERVER_UNAVAILABLE ) || ( HRESULT_ERROR_FUNC(t_Result) == RPC_S_CALL_FAILED_DNE ) )
									{
										AbnormalShutdown ( t_Elements [ t_Index ] ) ;
									}
								}

								if ( SUCCEEDED ( t_Result ) )
								{
								}
								else
								{
									if ( t_Result == WBEM_E_NOT_FOUND || t_Result  == WBEM_E_INVALID_CLASS )
									{
										t_Result = S_OK ;
									}
								}
							}
						}

						t_Sink->Release () ;
					}
					else
					{
						t_Result = WBEM_E_OUT_OF_MEMORY ;
					}
				}

				HRESULT t_TempResult = ClearProviders <IWbemServices> ( t_Elements , t_ElementsCount ) ;
			}

			if ( SUCCEEDED ( t_Result ) && t_ElementsCount )
			{
				t_CombiningSink->Resume () ;

				t_Result = t_CombiningSink->Wait ( INFINITE ) ;
			}
			else
			{
				SetStatus ( L"ExecQueryAsync" , NULL , L"No Decoupled Providers Attached" , WBEM_S_SOURCE_NOT_AVAILABLE , a_Sink ) ;
			}
		}
		else
		{
			t_Result = WBEM_E_OUT_OF_MEMORY ;
		}

		t_CombiningSink->Release () ;
	}
	else
	{
		t_Result = WBEM_E_OUT_OF_MEMORY ;
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CDecoupledAggregator_IWbemProvider :: ExecNotificationQuery ( 

	const BSTR a_QueryLanguage,
    const BSTR a_Query,
    long a_Flags,
    IWbemContext *a_Context,
    IEnumWbemClassObject **a_Enum
)
{
	return WBEM_E_NOT_AVAILABLE ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/
        
HRESULT CDecoupledAggregator_IWbemProvider :: ExecNotificationQueryAsync ( 
            
	const BSTR a_QueryLanguage ,
    const BSTR a_Query,
    long a_Flags,
    IWbemContext *a_Context,
    IWbemObjectSink *a_Sink
)
{
	return WBEM_E_NOT_AVAILABLE ;
}       

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT STDMETHODCALLTYPE CDecoupledAggregator_IWbemProvider :: ExecMethod ( 

	const BSTR a_ObjectPath ,
    const BSTR a_MethodName ,
    long a_Flags ,
    IWbemContext *a_Context ,
    IWbemClassObject *a_InParams ,
    IWbemClassObject **a_OutParams ,
    IWbemCallResult **a_CallResult
)
{
	return WBEM_E_NOT_AVAILABLE ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CDecoupledAggregator_IWbemProvider :: ExecMethodAsync ( 

    const BSTR a_ObjectPath,
    const BSTR a_MethodName,
    long a_Flags,
    IWbemContext *a_Context,
    IWbemClassObject *a_InParams,
	IWbemObjectSink *a_Sink
) 
{
	if ( m_Initialized == 0 )
	{
		a_Sink->SetStatus ( 0 , WBEM_E_NOT_FOUND , NULL , NULL ) ;

		return WBEM_E_NOT_FOUND ;
	}

	BOOL t_MethodCalled = FALSE ;

	IWbemServices **t_Elements = NULL ;
	ULONG t_ElementsCount = 0 ;
	ULONG t_ContainerCount = 0 ;

	HRESULT t_Result = GetProviders <IWbemServices,&IID_IWbemServices> ( a_Context , m_Controller , t_Elements , t_ElementsCount , t_ContainerCount ) ;
	if ( SUCCEEDED ( t_Result ) )
	{
		for ( ULONG t_Index = 0 ; ( t_Index < t_ElementsCount ) && SUCCEEDED ( t_Result ) ; t_Index ++ )
		{
			IWbemServices *t_Provider = t_Elements [ t_Index ] ;

			CInterceptor_IWbemWaitingObjectSink *t_MethodSink = new CInterceptor_IWbemWaitingObjectSink (

				m_Allocator , 
				t_Provider ,
				a_Sink ,
				( CWbemGlobal_IWmiObjectSinkController * ) this ,
				*m_Registration
			) ;

			if ( t_MethodSink )
			{
				t_MethodSink->AddRef () ;

				if ( SUCCEEDED ( t_Result ) ) 
				{
					CWbemGlobal_IWmiObjectSinkController_Container_Iterator t_Iterator ;

					Lock () ;

					WmiStatusCode t_StatusCode = Insert ( 

						*t_MethodSink ,
						t_Iterator
					) ;

					UnLock () ;

					if ( t_StatusCode == e_StatusCode_Success ) 
					{
						t_Result = t_Provider->ExecMethodAsync ( 
								
							a_ObjectPath,
							a_MethodName,
							a_Flags & ~WBEM_FLAG_USE_AMENDED_QUALIFIERS , 
							a_Context,
							a_InParams,
							t_MethodSink
						) ;

						if ( FAILED ( t_Result ) )
						{
							if ( ( HRESULT_ERROR_FUNC(t_Result) == RPC_S_SERVER_UNAVAILABLE ) || ( HRESULT_ERROR_FUNC(t_Result) == RPC_S_CALL_FAILED_DNE ) )
							{
								AbnormalShutdown ( t_Elements [ t_Index ] ) ;
							}
						}

						if ( SUCCEEDED ( t_Result ) )
						{
							t_Result = t_MethodSink->Wait ( INFINITE ) ;
							if ( SUCCEEDED ( t_Result ) )
							{
								if ( SUCCEEDED ( t_MethodSink->GetResult () ) )
								{
									t_MethodCalled = TRUE ;
								}
							}
							else
							{
								if ( t_Result == WBEM_E_NOT_FOUND || t_Result  == WBEM_E_INVALID_CLASS )
								{
									t_Result = S_OK ;
								}
							}
						}
						else
						{
							if ( t_Result == WBEM_E_NOT_FOUND || t_Result  == WBEM_E_INVALID_CLASS )
							{
								t_Result = S_OK ;
							}
						}
					}
					else
					{
						t_Result = WBEM_E_OUT_OF_MEMORY ;
					}

					WmiQueue <IWbemClassObject *,8> &t_Queue = t_MethodSink->GetQueue () ;

					IWbemClassObject *t_Object = NULL ;
					while ( ( t_StatusCode = t_Queue.Top ( t_Object ) ) == e_StatusCode_Success )
					{
						t_Object->Release () ;
						t_StatusCode = t_Queue.DeQueue () ;
					}
				}

				t_MethodSink->Release () ;
			}
			else
			{
				t_Result = WBEM_E_OUT_OF_MEMORY ;
			}
		}

		HRESULT t_TempResult = ClearProviders <IWbemServices> ( t_Elements , t_ElementsCount ) ;
	}

	if ( SUCCEEDED ( t_Result ) )
	{
		if ( t_MethodCalled == FALSE )
		{
			if ( t_ElementsCount )
			{ 
				t_Result = WBEM_E_NOT_FOUND ;

				a_Sink->SetStatus ( 0 , t_Result , NULL , NULL ) ;
			}
			else
			{
				SetStatus ( L"ExecMethodAsync" , NULL , L"No Decoupled Providers Attached" , WBEM_E_NOT_FOUND , a_Sink ) ;
			}
		}
		else
		{
			a_Sink->SetStatus ( 0 , t_Result , NULL , NULL ) ;
		}
	}
	else
	{
		a_Sink->SetStatus ( 0 , t_Result , NULL , NULL ) ;
	}

	return t_Result ;
}

 /******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CDecoupledAggregator_IWbemProvider ::  ProvideEvents (

	IWbemObjectSink *a_Sink ,
	long a_Flags
)
{
	HRESULT t_Result = WBEM_E_NOT_AVAILABLE ;

	if ( InterlockedCompareExchangePointer ( ( void ** ) & m_Sink , a_Sink , NULL ) == NULL )
	{
		m_Sink->AddRef () ;
	}

	IWbemEventProvider **t_Elements = NULL ;
	ULONG t_ElementsCount = 0 ;
	ULONG t_ContainerCount = 0 ;

	t_Result = GetProviders <IWbemEventProvider,&IID_IWbemEventProvider> ( NULL , m_Controller , t_Elements , t_ElementsCount , t_ContainerCount ) ;
	if ( SUCCEEDED ( t_Result ) )
	{
		for ( ULONG t_Index = 0 ; ( t_Index < t_ElementsCount ) && SUCCEEDED ( t_Result ) ; t_Index ++ )
		{
			t_Result = t_Elements [ t_Index ]->ProvideEvents (

 				a_Sink,
				a_Flags
			) ;

			if ( FAILED ( t_Result ) )
			{
				if ( ( HRESULT_ERROR_FUNC(t_Result) == RPC_S_SERVER_UNAVAILABLE ) || ( HRESULT_ERROR_FUNC(t_Result) == RPC_S_CALL_FAILED_DNE ) )
				{
					AbnormalShutdown ( t_Elements [ t_Index ] ) ;
				}
			}
		}

		HRESULT t_TempResult = ClearProviders <IWbemEventProvider> ( t_Elements , t_ElementsCount ) ;
	}
	
	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CDecoupledAggregator_IWbemProvider ::NewQuery (

	unsigned long a_Id ,
	WBEM_WSTR a_QueryLanguage ,
	WBEM_WSTR a_Query
)
{
	HRESULT t_Result = WBEM_E_NOT_AVAILABLE ;

	IWbemEventProviderQuerySink **t_Elements = NULL ;
	ULONG t_ElementsCount = 0 ;
	ULONG t_ContainerCount = 0 ;

	t_Result = GetProviders <IWbemEventProviderQuerySink,&IID_IWbemEventProviderQuerySink> ( NULL , m_Controller , t_Elements , t_ElementsCount , t_ContainerCount ) ;
	if ( SUCCEEDED ( t_Result ) )
	{
		for ( ULONG t_Index = 0 ; ( t_Index < t_ElementsCount ) && SUCCEEDED ( t_Result ) ; t_Index ++ )
		{
			t_Result = t_Elements [ t_Index ]->NewQuery (

 				a_Id,
				a_QueryLanguage ,
				a_Query
			) ;

			if ( FAILED ( t_Result ) )
			{
				if ( ( HRESULT_ERROR_FUNC(t_Result) == RPC_S_SERVER_UNAVAILABLE ) || ( HRESULT_ERROR_FUNC(t_Result) == RPC_S_CALL_FAILED_DNE ) )
				{
					AbnormalShutdown ( t_Elements [ t_Index ] ) ;
				}
			}
		}

		HRESULT t_TempResult = ClearProviders <IWbemEventProviderQuerySink> ( t_Elements , t_ElementsCount ) ;
	}
	
	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CDecoupledAggregator_IWbemProvider ::CancelQuery (

	unsigned long a_Id
)
{
	HRESULT t_Result = WBEM_E_NOT_AVAILABLE ;

	IWbemEventProviderQuerySink **t_Elements = NULL ;
	ULONG t_ElementsCount = 0 ;
	ULONG t_ContainerCount = 0 ;

	t_Result = GetProviders <IWbemEventProviderQuerySink,&IID_IWbemEventProviderQuerySink> ( NULL , m_Controller , t_Elements , t_ElementsCount , t_ContainerCount ) ;
	if ( SUCCEEDED ( t_Result ) )
	{
		for ( ULONG t_Index = 0 ; ( t_Index < t_ElementsCount ) && SUCCEEDED ( t_Result ) ; t_Index ++ )
		{
			t_Result = t_Elements [ t_Index ]->CancelQuery (

 				a_Id
			) ;

			if ( FAILED ( t_Result ) )
			{
				if ( ( HRESULT_ERROR_FUNC(t_Result) == RPC_S_SERVER_UNAVAILABLE ) || ( HRESULT_ERROR_FUNC(t_Result) == RPC_S_CALL_FAILED_DNE ) )
				{
					AbnormalShutdown ( t_Elements [ t_Index ] ) ;
				}
			}
		}

		HRESULT t_TempResult = ClearProviders <IWbemEventProviderQuerySink> ( t_Elements , t_ElementsCount ) ;
	}
	
	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CDecoupledAggregator_IWbemProvider ::AccessCheck (

	WBEM_CWSTR a_QueryLanguage ,
	WBEM_CWSTR a_Query ,
	long a_SidLength ,
	const BYTE *a_Sid
)
{
	HRESULT t_AggregatedResult = S_OK ;

	IWbemEventProviderSecurity **t_Elements = NULL ;
	ULONG t_ElementsCount = 0 ;
	ULONG t_ContainerCount = 0 ;

	HRESULT t_Result = GetProviders <IWbemEventProviderSecurity,&IID_IWbemEventProviderSecurity> ( NULL , m_Controller , t_Elements , t_ElementsCount , t_ContainerCount ) ;
	if ( SUCCEEDED ( t_Result ) )
	{
		for ( ULONG t_Index = 0 ; ( t_Index < t_ElementsCount ) && SUCCEEDED ( t_Result ) ; t_Index ++ )
		{
			t_Result = t_Elements [ t_Index ]->AccessCheck (

 				a_QueryLanguage,
				a_Query ,
				a_SidLength ,
				a_Sid
			) ;

			if ( SUCCEEDED ( t_Result ) )
			{
				if ( t_Result != S_OK )
				{
					t_AggregatedResult = t_Result ;
				}
			}
			else
			{
				if ( ( HRESULT_ERROR_FUNC(t_Result) == RPC_S_SERVER_UNAVAILABLE ) || ( HRESULT_ERROR_FUNC(t_Result) == RPC_S_CALL_FAILED_DNE ) )
				{
					AbnormalShutdown ( t_Elements [ t_Index ] ) ;
				}
			}
		}

		HRESULT t_TempResult = ClearProviders <IWbemEventProviderSecurity> ( t_Elements , t_ElementsCount ) ;
	}

	if ( SUCCEEDED ( t_Result ) )
	{		
		if ( t_ContainerCount )
		{
			if ( t_ElementsCount != t_ContainerCount )
			{
				t_AggregatedResult = WBEM_S_SUBJECT_TO_SDS ;
			}
		}

		t_Result = t_AggregatedResult ;
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CDecoupledAggregator_IWbemProvider ::SetRegistrationObject (

	long a_Flags ,
	IWbemClassObject *a_ProviderRegistration
)
{
	HRESULT t_Result = WBEM_E_NOT_AVAILABLE ;

	IWbemProviderIdentity **t_Elements = NULL ;
	ULONG t_ElementsCount = 0 ;
	ULONG t_ContainerCount = 0 ;

	t_Result = GetProviders <IWbemProviderIdentity,&IID_IWbemProviderIdentity> ( NULL , m_Controller , t_Elements , t_ElementsCount , t_ContainerCount ) ;
	if ( SUCCEEDED ( t_Result ) )
	{
		for ( ULONG t_Index = 0 ; ( t_Index < t_ElementsCount ) && SUCCEEDED ( t_Result ) ; t_Index ++ )
		{
			t_Result = t_Elements [ t_Index ]->SetRegistrationObject (

				a_Flags ,
				a_ProviderRegistration
			) ;

			if ( FAILED ( t_Result ) )
			{
				if ( ( HRESULT_ERROR_FUNC(t_Result) == RPC_S_SERVER_UNAVAILABLE ) || ( HRESULT_ERROR_FUNC(t_Result) == RPC_S_CALL_FAILED_DNE ) )
				{
					AbnormalShutdown ( t_Elements [ t_Index ] ) ;
				}
			}
		}

		HRESULT t_TempResult = ClearProviders <IWbemProviderIdentity> ( t_Elements , t_ElementsCount ) ;
	}
	
	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CDecoupledAggregator_IWbemProvider ::FindConsumer (

	IWbemClassObject *a_LogicalConsumer ,
	IWbemUnboundObjectSink **a_Consumer
)
{
	HRESULT t_Result = WBEM_E_NOT_AVAILABLE ;

	IWbemEventConsumerProvider **t_Elements = NULL ;
	ULONG t_ElementsCount = 0 ;
	ULONG t_ContainerCount = 0 ;

	t_Result = GetProviders <IWbemEventConsumerProvider,&IID_IWbemEventConsumerProvider> ( NULL , m_Controller , t_Elements , t_ElementsCount , t_ContainerCount ) ;
	if ( SUCCEEDED ( t_Result ) )
	{
		for ( ULONG t_Index = 0 ; ( t_Index < t_ElementsCount ) && SUCCEEDED ( t_Result ) ; t_Index ++ )
		{
			t_Result = t_Elements [ t_Index ]->FindConsumer (

 				a_LogicalConsumer,
				a_Consumer
			) ;

			if ( FAILED ( t_Result ) )
			{
				if ( ( HRESULT_ERROR_FUNC(t_Result) == RPC_S_SERVER_UNAVAILABLE ) || ( HRESULT_ERROR_FUNC(t_Result) == RPC_S_CALL_FAILED_DNE ) )
				{
					AbnormalShutdown ( t_Elements [ t_Index ] ) ;
				}
			}
		}

		HRESULT t_TempResult = ClearProviders <IWbemEventConsumerProvider> ( t_Elements , t_ElementsCount ) ;
	}
	
	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CDecoupledAggregator_IWbemProvider ::ValidateSubscription (

	IWbemClassObject *a_LogicalConsumer
)
{
	HRESULT t_Result = WBEM_E_NOT_AVAILABLE ;

	IWbemEventConsumerProviderEx **t_Elements = NULL ;
	ULONG t_ElementsCount = 0 ;
	ULONG t_ContainerCount = 0 ;

	t_Result = GetProviders <IWbemEventConsumerProviderEx,&IID_IWbemEventConsumerProviderEx> ( NULL , m_Controller , t_Elements , t_ElementsCount , t_ContainerCount ) ;
	if ( SUCCEEDED ( t_Result ) )
	{
		for ( ULONG t_Index = 0 ; ( t_Index < t_ElementsCount ) && SUCCEEDED ( t_Result ) ; t_Index ++ )
		{
			t_Result = t_Elements [ t_Index ]->ValidateSubscription (

 				a_LogicalConsumer
			) ;

			if ( FAILED ( t_Result ) )
			{
				if ( ( HRESULT_ERROR_FUNC(t_Result) == RPC_S_SERVER_UNAVAILABLE ) || ( HRESULT_ERROR_FUNC(t_Result) == RPC_S_CALL_FAILED_DNE ) )
				{
					AbnormalShutdown ( t_Elements [ t_Index ] ) ;
				}
			}
		}

		HRESULT t_TempResult = ClearProviders <IWbemEventConsumerProviderEx> ( t_Elements , t_ElementsCount ) ;
	}
	
	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CDecoupledAggregator_IWbemProvider :: AbnormalShutdown ( IUnknown *t_Element )
{
	SyncProviderContainerElement *t_ContainerElement = NULL ;
	HRESULT t_Result = t_Element->QueryInterface ( IID_CacheElement , ( void ** ) & t_ContainerElement ) ;
	if ( SUCCEEDED ( t_Result ) ) 
	{
		m_Controller->Lock () ;

		GUID t_Identity = t_ContainerElement->GetKey () ;
		WmiStatusCode t_StatusCode = m_Controller->Delete ( t_Identity ) ;
		if ( t_StatusCode == e_StatusCode_Success )
		{
			m_Controller->UnLock () ;

			t_Element->Release () ;
		}
		else
		{
			m_Controller->UnLock () ;
		}

		t_ContainerElement->Release () ;
	}

	return S_OK ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CDecoupledAggregator_IWbemProvider :: InitializeProvider ( 

	IUnknown *a_Unknown ,
	IWbemServices *a_Stub ,
	wchar_t *a_NamespacePath ,
	LONG a_Flags ,
	IWbemContext *a_Context ,
	LPCWSTR a_User ,
	LPCWSTR a_Locale ,
    LPCWSTR a_Scope ,
	CServerObject_ProviderRegistrationV1 &a_Registration
)
{
	HRESULT t_Result = S_OK ;

	if ( a_Registration.GetEventProviderRegistration ().Supported () )
	{
		IWbemProviderIdentity *t_ProviderIdentity = NULL ;
		t_Result = a_Unknown->QueryInterface ( IID_IWbemProviderIdentity , ( void ** ) & t_ProviderIdentity ) ;
		if ( SUCCEEDED ( t_Result ) )
		{
			t_Result = t_ProviderIdentity->SetRegistrationObject (

				0 ,
				a_Registration.GetIdentity () 
			) ;

			t_ProviderIdentity->Release () ;
		}
	}

	IWbemProviderInit *t_ProviderInit = NULL ;
	t_Result = a_Unknown->QueryInterface ( IID_IWbemProviderInit , ( void ** ) & t_ProviderInit ) ;
	if ( SUCCEEDED ( t_Result ) )
	{
		CServerObject_ProviderInitSink *t_ProviderInitSink = new CServerObject_ProviderInitSink () ; 
		if ( t_ProviderInitSink )
		{
			t_ProviderInitSink->AddRef () ;

			t_Result = t_ProviderInitSink->SinkInitialize ( a_Registration.GetComRegistration().GetSecurityDescriptor () ) ;
			if ( SUCCEEDED ( t_Result ) ) 
			{
				CInterceptor_IWbemProviderInitSink *t_Sink = new CInterceptor_IWbemProviderInitSink ( t_ProviderInitSink ) ;
				if ( t_Sink )
				{
					t_Sink->AddRef () ;

					t_Result = t_ProviderInit->Initialize (

						a_Registration.GetComRegistration ().PerUserInitialization () ? ( const BSTR ) a_User : NULL ,
						0 ,
						( const BSTR ) a_NamespacePath ,
						a_Registration.GetComRegistration ().PerLocaleInitialization () ? ( const BSTR ) a_Locale : NULL ,
						a_Stub ,
						a_Context ,
						t_Sink    
					) ;

					t_Sink->Release () ;
				}
				else
				{
					t_Result = WBEM_E_OUT_OF_MEMORY ;
				}

				if ( SUCCEEDED ( t_Result ) )
				{
					t_ProviderInitSink->Wait () ;
					t_Result = t_ProviderInitSink->GetResult () ;
				}

				if ( SUCCEEDED ( t_Result ) )
				{
					WmiSetAndCommitObject (

						ProviderSubSystem_Globals :: s_EventClassHandles [ Msft_WmiProvider_InitializationOperationEvent ] , 
						WMI_SENDCOMMIT_SET_NOT_REQUIRED,
						a_NamespacePath,
						a_Registration.GetProviderName () ,
						a_Registration.GetComRegistration ().PerUserInitialization () ? ( const BSTR ) a_User : NULL ,
						a_Registration.GetComRegistration ().PerLocaleInitialization () ? ( const BSTR ) a_Locale : NULL ,
						NULL
					) ;
				}
				else
				{
					WmiSetAndCommitObject (

						ProviderSubSystem_Globals :: s_EventClassHandles [ Msft_WmiProvider_InitializationOperationFailureEvent ] , 
						WMI_SENDCOMMIT_SET_NOT_REQUIRED,
						a_NamespacePath,
						a_Registration.GetProviderName () ,
						a_Registration.GetComRegistration ().PerUserInitialization () ? ( const BSTR ) a_User : NULL ,
						a_Registration.GetComRegistration ().PerLocaleInitialization () ? ( const BSTR ) a_Locale : NULL ,
						NULL ,
						t_Result 
					) ;
				}
			}

			t_ProviderInitSink->Release () ;
		}
		else
		{
			t_Result = WBEM_E_OUT_OF_MEMORY ;
		}

		t_ProviderInit->Release () ;
	}
	else
	{
		t_Result = WBEM_E_ACCESS_DENIED ;
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CDecoupledAggregator_IWbemProvider :: CreateSyncProvider ( 

	IUnknown *a_ServerSideProvider ,
	IWbemServices *a_Stub ,
	wchar_t *a_NamespacePath ,
	LONG a_Flags ,
	IWbemContext *a_Context ,
	LPCWSTR a_User ,
	LPCWSTR a_Locale ,
    LPCWSTR a_Scope ,
	CServerObject_ProviderRegistrationV1 &a_Registration ,
	GUID a_Identity ,
	CInterceptor_IWbemDecoupledProvider *&a_Interceptor 
)
{
	HRESULT t_Result = S_OK ;

	CInterceptor_IWbemDecoupledProvider *t_Interceptor = new CInterceptor_IWbemDecoupledProvider (

		m_Allocator , 
		a_ServerSideProvider ,
		a_Stub ,
		m_Controller , 
		a_Context ,
		a_Registration ,
		a_Identity
	) ;

	if ( t_Interceptor ) 
	{
/*
 *	One for the cache
 */
		t_Interceptor->AddRef () ;

		_IWmiProviderInitialize *t_InterceptorInit = NULL ;

		t_Result = t_Interceptor->QueryInterface ( IID__IWmiProviderInitialize , ( void ** ) & t_InterceptorInit ) ;
		if ( SUCCEEDED ( t_Result ) )
		{
			CServerObject_ProviderInitSink *t_ProviderInitSink = new CServerObject_ProviderInitSink ; 
			if ( t_ProviderInitSink )
			{
				t_ProviderInitSink->AddRef () ;

				t_Result = t_ProviderInitSink->SinkInitialize () ;
				if ( SUCCEEDED ( t_Result ) ) 
				{
					CInterceptor_IWbemProviderInitSink *t_Sink = new CInterceptor_IWbemProviderInitSink ( t_ProviderInitSink ) ;
					if ( t_Sink )
					{
						t_Sink->AddRef () ;

						t_Result = t_InterceptorInit->Initialize (

							0 ,
							a_Context ,
							NULL ,
							a_Registration.GetComRegistration ().PerUserInitialization () ? ( BSTR ) a_User : NULL ,
							a_Registration.GetComRegistration ().PerLocaleInitialization () ? ( BSTR ) a_Locale : NULL  ,
							a_NamespacePath ,
							NULL ,
							NULL ,
							t_Sink    
						) ;

						if ( SUCCEEDED ( t_Result ) )
						{
							t_ProviderInitSink->Wait () ;
							t_Result = t_ProviderInitSink->GetResult () ;
						}

						t_Sink->Release () ;
					}
					else
					{
						t_Result = WBEM_E_OUT_OF_MEMORY ;
					}
				}

				t_ProviderInitSink->Release () ;
			}
			else
			{
				t_Result = WBEM_E_OUT_OF_MEMORY ;
			}

			t_InterceptorInit->Release () ;
		}

		if ( SUCCEEDED ( t_Result ) )
		{
			t_Interceptor->AddRef () ;

			CWbemGlobal_IWbemSyncProvider_Container_Iterator t_Iterator ;

			WmiStatusCode t_StatusCode = m_Controller->Insert ( 

				*t_Interceptor ,
				t_Iterator
			) ;

			if ( t_StatusCode == e_StatusCode_Success ) 
			{
			}
			else
			{
				t_Result = WBEM_E_OUT_OF_MEMORY ;
			}

			m_Controller->UnLock () ;
		}
		else
		{
			m_Controller->UnLock () ;
		}

		t_Interceptor->SetInitialized ( t_Result ) ;
		if ( SUCCEEDED ( t_Result ) )
		{
			a_Interceptor = t_Interceptor ;
		}
		else
		{
			t_Interceptor->Release () ;
		}
	}
	else
	{
		m_Controller->UnLock () ;

		t_Result = WBEM_E_OUT_OF_MEMORY ;
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CDecoupledAggregator_IWbemProvider :: Register (

	long a_Flags ,
	IWbemContext *a_Context ,
	LPCWSTR a_User ,
	LPCWSTR a_Locale ,
	LPCWSTR a_Scope ,
	LPCWSTR a_Registration ,
	DWORD a_ProcessIdentifier ,
	IUnknown *a_Unknown ,
	GUID a_Identity
)
{
	HRESULT t_Result = S_OK ;

	try
	{
		m_Controller->Lock () ;

		CWbemGlobal_IWbemSyncProvider_Container_Iterator t_Iterator ;

		WmiStatusCode t_StatusCode = m_Controller->Find ( a_Identity , t_Iterator ) ;
		if ( t_StatusCode != e_StatusCode_Success )
		{
			CInterceptor_IWbemServices_Interceptor *t_Stub = new CInterceptor_IWbemServices_Interceptor ( m_Allocator , m_CoreFullStub ) ;
			if ( t_Stub )
			{
				t_Stub->AddRef () ;

				CInterceptor_IWbemDecoupledProvider *t_Interceptor = NULL ;

				t_Result = CreateSyncProvider ( 

					a_Unknown ,
					t_Stub ,
					( BSTR ) a_Scope ,
					0 ,
					a_Context ,
					a_User ,
					a_Locale ,
					NULL ,
					*m_Registration ,
					a_Identity ,
					t_Interceptor
				) ;

				if ( SUCCEEDED ( t_Result ) )
				{
					IUnknown *t_Unknown = NULL ;
					t_Result = t_Interceptor->QueryInterface ( IID_IUnknown , ( void ** ) & t_Unknown ) ;
					if ( SUCCEEDED ( t_Result ) )
					{
						t_Result = InitializeProvider ( 

							t_Unknown ,
							t_Stub ,
							( BSTR ) a_Scope ,
							a_Flags ,
							a_Context ,
							a_User ,
							a_Locale ,
							NULL ,
							*m_Registration
						) ;

						if ( SUCCEEDED ( t_Result ) )
						{
							if ( InterlockedCompareExchangePointer ( ( void ** ) & m_Sink , NULL , NULL ) )
							{
								IWbemEventProvider *t_Provider = NULL ;

								t_Result = t_Unknown->QueryInterface ( IID_IWbemEventProvider , ( void ** ) & t_Provider ) ;
								if ( SUCCEEDED ( t_Result ) )
								{
									t_Result = t_Provider->ProvideEvents ( m_Sink , 0 ) ;

									t_Provider->Release () ;
								}

								m_Sink->SetStatus ( 

									WBEM_STATUS_REQUIREMENTS, 
									WBEM_REQUIREMENTS_RECHECK_SUBSCRIPTIONS, 
									NULL, 
									NULL
								) ;
							}
						}

						t_Unknown->Release () ;
					}

					t_Interceptor->Release () ;
				}

				t_Stub->Release () ;
			}
			else
			{
				m_Controller->UnLock () ;

				t_Result = WBEM_E_OUT_OF_MEMORY ;
			}
		}
		else
		{
			SyncProviderContainerElement *t_Element = t_Iterator.GetElement () ;

			m_Controller->UnLock () ;

			t_Element->Release () ;

			t_Result = S_OK ;
		}
	}
	catch ( ... )
	{
		t_Result = WBEM_E_PROVIDER_FAILURE ;
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CDecoupledAggregator_IWbemProvider :: UnRegister (

	long a_Flags ,
	IWbemContext *a_Context ,
	LPCWSTR a_User ,
	LPCWSTR a_Locale ,
	LPCWSTR a_Scope ,
	LPCWSTR a_Registration ,
	GUID a_Identity
)
{
	HRESULT t_Result = S_OK ;

	try
	{
		CWbemGlobal_IWbemSyncProvider_Container_Iterator t_Iterator ;

		IWbemShutdown *t_Shutdown = NULL ;

		m_Controller->Lock () ;

		WmiStatusCode t_StatusCode = m_Controller->Find ( a_Identity , t_Iterator ) ;
		if ( t_StatusCode == e_StatusCode_Success )
		{
			SyncProviderContainerElement *t_Element = t_Iterator.GetElement () ;			

			t_Result = t_Element->QueryInterface ( IID_IWbemShutdown , ( void ** ) & t_Shutdown ) ;

			m_Controller->Delete ( a_Identity ) ;

			m_Controller->UnLock () ;

			if ( SUCCEEDED ( t_Result ) && t_Shutdown )
			{
				t_Result = t_Shutdown->Shutdown ( 
		
					0 , 
					0 , 
					NULL 
				) ;

				t_Shutdown->Release () ;
			}

/*
 *	One for the find.
 */

			t_Element->Release () ;

/*
 *	Removed reference due the cache.
 */

			t_Element->Release () ;
		}
		else
		{
			m_Controller->UnLock () ;
		}
	}
	catch ( ... )
	{
		t_Result = WBEM_E_PROVIDER_FAILURE ;
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CDecoupledAggregator_IWbemProvider :: Expel (

	long a_Flags ,
	IWbemContext *a_Context
)
{
	HRESULT t_Result = S_OK ;

	CWbemGlobal_IWmiProviderController *t_Controller = ServiceCacheElement :: GetController () ;
	if ( t_Controller )
	{
		t_Controller->Shutdown ( ServiceCacheElement :: GetKey () ) ;
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CDecoupledAggregator_IWbemProvider  :: ForceReload ()
{
	HRESULT t_Result = ProviderSubSystem_Globals :: ForwardReload ( 

		_IWMIPROVSSSINK_FLAGS_RELOAD , 
		NULL ,
		m_Namespace ,
		ServiceCacheElement :: GetKey ().m_Provider
	) ;

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CDecoupledAggregator_IWbemProvider :: Shutdown (

	LONG a_Flags ,
	ULONG a_MaxMilliSeconds ,
	IWbemContext *a_Context
)
{
	HRESULT t_Result = S_OK ;

	if ( m_Controller )
	{
		CWbemGlobal_IWbemSyncProvider_Container *t_Container = NULL ;
		
		m_Controller->GetContainer ( t_Container ) ;

		Lock () ;

		if ( t_Container->Size () )
		{
			IWbemShutdown **t_ShutdownElements = new IWbemShutdown * [ t_Container->Size () ] ;
			if ( t_ShutdownElements )
			{
				CWbemGlobal_IWbemSyncProvider_Container_Iterator t_Iterator = t_Container->Begin ();

				ULONG t_Count = 0 ;
				while ( ! t_Iterator.Null () )
				{
					t_Result = t_Iterator.GetElement ()->QueryInterface ( IID_IWbemShutdown , ( void ** ) & t_ShutdownElements [ t_Count ] ) ;

					t_Iterator.Increment () ;

					t_Count ++ ;
				}

				UnLock () ;

				for ( ULONG t_Index = 0 ; t_Index < t_Count ; t_Index ++ )
				{
					if ( t_ShutdownElements [ t_Index ] ) 
					{
						t_Result = t_ShutdownElements [ t_Index ]->Shutdown ( 

							a_Flags ,
							a_MaxMilliSeconds ,
							a_Context
						) ;

						t_ShutdownElements [ t_Index ]->Release () ;
					}
				}

				delete [] t_ShutdownElements ;
			}
			else
			{
				UnLock () ;

				t_Result = WBEM_E_OUT_OF_MEMORY ;
			}
		}
		else
		{
			UnLock () ;
		}

		m_Controller->Shutdown () ;
	}

	CWbemGlobal_IWmiObjectSinkController :: Shutdown () ;

	return t_Result ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\provsubsys\server\provdwsv.cpp ===
/*++

Copyright (C) 1996-2001 Microsoft Corporation

Module Name:

	XXXX

Abstract:


History:

--*/

#include "PreComp.h"

#include <wbemint.h>
#include <stdio.h>
#include <NCObjApi.h>

#include "Globals.h"
#include "CGlobals.h"
#include "ProvSubs.h"
#include "ProvFact.h"
#include "ProvObSk.h"
#include "ProvInSk.h"
#include "ProvWsv.h"
#include "ProvCache.h"

#include "arrtempl.h"

#include "Guids.h"
#include <cominit.h>
#include <wbemutil.h>

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

#pragma warning( disable : 4355 )

CDecoupled_IWbemUnboundObjectSink :: CDecoupled_IWbemUnboundObjectSink (

	WmiAllocator &a_Allocator ,
	IUnknown *a_ServerSideProvider , 
	CWbemGlobal_IWmiObjectSinkController *a_Controller ,
	CServerObject_ProviderRegistrationV1 &a_Registration

) :	VoidPointerContainerElement (

		a_Controller ,
		this 
	) ,
	m_Allocator ( a_Allocator ) ,
	m_Controller ( NULL ) ,
	m_Unknown ( NULL ) ,
	m_Provider_IWbemUnboundObjectSink ( NULL ) ,
	m_Provider_Internal_IWbemUnboundObjectSink ( NULL ) ,
	m_Registration ( & a_Registration ) ,
	m_ProxyContainer ( a_Allocator , ProxyIndex_UnBound_Size , MAX_PROXIES ) ,
	m_ProcessIdentifier ( 0 ) ,
	m_InitializeResult ( S_OK ) 
{
	InterlockedIncrement ( & ProviderSubSystem_Globals :: s_CDecoupled_IWbemUnboundObjectSink_ObjectsInProgress ) ;

	ProviderSubSystem_Globals :: Increment_Global_Object_Count () ;
	
	if ( m_Registration )
	{
		m_Registration->AddRef () ;
	}

	m_InitializeResult = a_Controller->QueryInterface ( IID__IWmiProviderAbnormalShutdown , ( void ** ) & m_Controller ) ;
	if ( SUCCEEDED ( m_InitializeResult ) )
	{
		if ( a_ServerSideProvider ) 
		{
			m_Unknown = a_ServerSideProvider ;
			m_Unknown->AddRef () ;

			m_InitializeResult = a_ServerSideProvider->QueryInterface ( IID_IWbemUnboundObjectSink , ( void ** ) & m_Provider_IWbemUnboundObjectSink ) ;
			if ( SUCCEEDED ( m_InitializeResult ) )
			{
				m_InitializeResult  = a_ServerSideProvider->QueryInterface ( IID_Internal_IWbemUnboundObjectSink , ( void ** ) & m_Provider_Internal_IWbemUnboundObjectSink ) ;
			}
		}
	}
}

#pragma warning( default : 4355 )

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

CDecoupled_IWbemUnboundObjectSink :: ~CDecoupled_IWbemUnboundObjectSink ()
{
	if ( m_Controller )
	{
		m_Controller->Release () ;
	}

	if ( m_Unknown )
	{
		m_Unknown->Release () ;
	}

	if ( m_Provider_IWbemUnboundObjectSink )
	{
		m_Provider_IWbemUnboundObjectSink->Release () ;
	}

	if ( m_Provider_Internal_IWbemUnboundObjectSink )
	{
		m_Provider_Internal_IWbemUnboundObjectSink->Release () ;
	}

	if ( m_Registration )
	{
		m_Registration->Release () ;
	}

	InterlockedDecrement ( & ProviderSubSystem_Globals :: s_CDecoupled_IWbemUnboundObjectSink_ObjectsInProgress ) ;

	ProviderSubSystem_Globals :: Decrement_Global_Object_Count () ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CDecoupled_IWbemUnboundObjectSink :: Initialize ()
{
	if ( SUCCEEDED ( m_InitializeResult ) )
	{
		WmiStatusCode t_StatusCode = m_ProxyContainer.Initialize () ;
		if ( t_StatusCode != e_StatusCode_Success ) 
		{
			m_InitializeResult = WBEM_E_OUT_OF_MEMORY ;
		}
	}

	if ( SUCCEEDED ( m_InitializeResult ) )
	{
		_IWmiProviderSite *t_Site = NULL ;
		m_InitializeResult = m_Unknown->QueryInterface ( IID__IWmiProviderSite , ( void ** ) & t_Site ) ;
		if ( SUCCEEDED ( m_InitializeResult ) )
		{
			m_InitializeResult = t_Site->GetSite ( & m_ProcessIdentifier ) ;
			t_Site->Release () ;
		}
	}

	return m_InitializeResult ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

STDMETHODIMP_( ULONG ) CDecoupled_IWbemUnboundObjectSink :: AddRef ()
{
	return VoidPointerContainerElement :: AddRef () ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

STDMETHODIMP_(ULONG) CDecoupled_IWbemUnboundObjectSink :: Release ()
{
	return VoidPointerContainerElement :: Release () ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

STDMETHODIMP CDecoupled_IWbemUnboundObjectSink :: QueryInterface (

	REFIID iid , 
	LPVOID FAR *iplpv 
) 
{
	*iplpv = NULL ;

	if ( iid == IID_IUnknown )
	{
		*iplpv = ( LPVOID ) this ;
	}
	else if ( iid == IID_IWbemUnboundObjectSink )
	{
		if ( m_Provider_IWbemUnboundObjectSink )
		{
			*iplpv = ( LPVOID ) ( IWbemUnboundObjectSink * ) this ;
		}
	}
	else if ( iid == IID_IWbemShutdown )
	{
		*iplpv = ( LPVOID ) ( IWbemShutdown * ) this ;		
	}

	if ( *iplpv )
	{
		( ( LPUNKNOWN ) *iplpv )->AddRef () ;

		return ResultFromScode ( S_OK ) ;
	}
	else
	{
		return ResultFromScode ( E_NOINTERFACE ) ;
	}
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CDecoupled_IWbemUnboundObjectSink :: Begin_Interface (

	IUnknown *a_ServerInterface ,
	REFIID a_InterfaceIdentifier ,
	DWORD a_ProxyIndex ,
	IUnknown *a_InternalServerInterface ,
	REFIID a_InternalInterfaceIdentifier ,
	DWORD a_InternalProxyIndex ,
	DWORD a_ProcessIdentifier ,
	HANDLE &a_IdentifyToken ,
	BOOL &a_Impersonating ,
	IUnknown *&a_OldContext ,
	IServerSecurity *&a_OldSecurity ,
	BOOL &a_IsProxy ,
	IUnknown *&a_Interface ,
	BOOL &a_Revert ,
	IUnknown *&a_Proxy ,
	IWbemContext *a_Context
)
{
	HRESULT t_Result = S_OK ;

	a_IdentifyToken = NULL ;
	a_Revert = FALSE ;
	a_Proxy = NULL ;
	a_Impersonating = FALSE ;
	a_OldContext = NULL ;
	a_OldSecurity = NULL ;

	DWORD t_AuthenticationLevel = 0 ;

	t_Result = ProviderSubSystem_Common_Globals :: BeginImpersonation ( a_OldContext , a_OldSecurity , a_Impersonating , & t_AuthenticationLevel ) ;
	if ( SUCCEEDED ( t_Result ) ) 
	{
		if ( a_ProcessIdentifier )
		{
			t_Result = CoImpersonateClient () ;
			if ( SUCCEEDED ( t_Result ) )
			{
				DWORD t_ImpersonationLevel = ProviderSubSystem_Common_Globals :: GetCurrentImpersonationLevel () ;

				CoRevertToSelf () ;

				if ( t_ImpersonationLevel == RPC_C_IMP_LEVEL_IMPERSONATE || t_ImpersonationLevel == RPC_C_IMP_LEVEL_DELEGATE )
				{
					t_Result = ProviderSubSystem_Common_Globals :: SetProxyState ( 
					
						m_ProxyContainer , 
						a_ProxyIndex , 
						a_InterfaceIdentifier , 
						a_ServerInterface , 
						a_Proxy , 
						a_Revert
					) ;
				}
				else
				{
					WORD t_AceSize = 0 ;
					ACCESS_ALLOWED_ACE *t_Ace = NULL ;

					t_Result = ProviderSubSystem_Common_Globals :: GetAceWithProcessTokenUser ( 
					
						a_ProcessIdentifier ,
						t_AceSize ,
						t_Ace 
					) ;

					if ( SUCCEEDED ( t_Result ) )
					{
						t_Result = ProviderSubSystem_Common_Globals :: SetProxyState_SvcHost ( 
						
							m_ProxyContainer , 
							a_InternalProxyIndex , 
							a_InterfaceIdentifier , 
							a_InternalServerInterface , 
							a_Proxy , 
							a_Revert , 
							a_ProcessIdentifier , 
							a_IdentifyToken ,
							t_Ace ,
							t_AceSize
						) ;

						delete [] ( BYTE * ) t_Ace ;
					}
				}
			}
		}
		else
		{
			t_Result = ProviderSubSystem_Common_Globals :: SetProxyState ( 
			
				m_ProxyContainer , 
				a_ProxyIndex , 
				a_InterfaceIdentifier , 
				a_ServerInterface , 
				a_Proxy , 
				a_Revert
			) ;
		}

		if ( t_Result == WBEM_E_NOT_FOUND )
		{
			a_Interface = a_ServerInterface ;
			a_IsProxy = FALSE ;
			t_Result = S_OK ;
		}
		else
		{
			if ( SUCCEEDED ( t_Result ) )
			{
				a_IsProxy = TRUE ;

				a_Interface = ( IUnknown * ) a_Proxy ;

				// Set cloaking on the proxy
				// =========================

				DWORD t_ImpersonationLevel ;

				if ( m_Registration->GetComRegistration ().GetDecoupledImpersonationRestriction () )
				{
					t_ImpersonationLevel = RPC_C_IMP_LEVEL_IDENTIFY ;
				}
				else
				{
					t_ImpersonationLevel = ProviderSubSystem_Common_Globals :: GetCurrentImpersonationLevel () ;
				}

				t_Result = ProviderSubSystem_Common_Globals :: SetCloaking (

					a_Interface ,
					RPC_C_AUTHN_LEVEL_CONNECT , 
					t_ImpersonationLevel
				) ;

				if ( SUCCEEDED ( t_Result ) )
				{
					if ( a_Context )
					{
						VARIANT t_Variant ;
						VariantInit ( & t_Variant ) ;
						t_Variant.lVal = t_AuthenticationLevel ;
						t_Variant.vt = VT_I4 ;

						
						t_Result = a_Context->SetValue ( L"__WBEM_CLIENT_AUTHENTICATION_LEVEL" , 0, & t_Variant ) ;
					}
				}

				if ( FAILED ( t_Result ) )
				{
					if ( a_IdentifyToken )
					{
						HRESULT t_TempResult = ProviderSubSystem_Common_Globals :: RevertProxyState_SvcHost ( 

							m_ProxyContainer , 
							a_InternalProxyIndex , 
							a_Proxy , 
							a_Revert ,
							a_ProcessIdentifier , 
							a_IdentifyToken 
						) ;
					}
					else
					{
						HRESULT t_TempResult = ProviderSubSystem_Common_Globals :: RevertProxyState ( 

							m_ProxyContainer , 
							a_ProxyIndex , 
							a_Proxy , 
							a_Revert
						) ;
					}
				}
			}
		}

		if ( FAILED ( t_Result ) )
		{
			ProviderSubSystem_Common_Globals :: EndImpersonation ( a_OldContext , a_OldSecurity , a_Impersonating ) ;
		}
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CDecoupled_IWbemUnboundObjectSink :: End_Interface (

	IUnknown *a_ServerInterface ,
	REFIID a_InterfaceIdentifier ,
	DWORD a_ProxyIndex ,
	IUnknown *a_InternalServerInterface ,
	REFIID a_InternalInterfaceIdentifier ,
	DWORD a_InternalProxyIndex ,
	DWORD a_ProcessIdentifier ,
	HANDLE a_IdentifyToken ,
	BOOL a_Impersonating ,
	IUnknown *a_OldContext ,
	IServerSecurity *a_OldSecurity ,
	BOOL a_IsProxy ,
	IUnknown *a_Interface ,
	BOOL a_Revert ,
	IUnknown *a_Proxy
)
{
	CoRevertToSelf () ;

	if ( a_Proxy )
	{
		if ( a_IdentifyToken )
		{
			HRESULT t_TempResult = ProviderSubSystem_Common_Globals :: RevertProxyState_SvcHost ( 

				m_ProxyContainer , 
				a_InternalProxyIndex , 
				a_Proxy , 
				a_Revert ,
				a_ProcessIdentifier ,
				a_IdentifyToken 
			) ;
		}
		else
		{
			HRESULT t_TempResult = ProviderSubSystem_Common_Globals :: RevertProxyState ( 

				m_ProxyContainer , 
				a_ProxyIndex , 
				a_Proxy , 
				a_Revert
			) ;
		}
	}

	ProviderSubSystem_Common_Globals :: EndImpersonation ( a_OldContext , a_OldSecurity , a_Impersonating ) ;

	return S_OK ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CDecoupled_IWbemUnboundObjectSink :: IndicateToConsumer (

	IWbemClassObject *a_LogicalConsumer ,
	long a_ObjectCount ,
	IWbemClassObject **a_Objects
)
{
	if ( m_Provider_IWbemUnboundObjectSink )
	{
		IUnknown *t_ServerInterface = m_Provider_IWbemUnboundObjectSink ;
		REFIID t_InterfaceIdentifier = IID_IWbemUnboundObjectSink ;
		DWORD t_ProxyIndex = ProxyIndex_UnBound_IWbemUnboundObjectSink ;
		IUnknown *t_InternalServerInterface = m_Provider_Internal_IWbemUnboundObjectSink ;
		REFIID t_InternalInterfaceIdentifier = IID_Internal_IWbemUnboundObjectSink ;
		DWORD t_InternalProxyIndex = ProxyIndex_UnBound_Internal_IWbemUnboundObjectSink ;
		BOOL t_Impersonating ;
		IUnknown *t_OldContext ;
		IServerSecurity *t_OldSecurity ;
		BOOL t_IsProxy ;
		IUnknown *t_Interface ;
		BOOL t_Revert ;
		IUnknown *t_Proxy ;
		DWORD t_ProcessIdentifier = m_ProcessIdentifier ;
		HANDLE t_IdentifyToken = NULL ;

		HRESULT t_Result = Begin_Interface (

			t_ServerInterface ,
			t_InterfaceIdentifier ,
			t_ProxyIndex ,
			t_InternalServerInterface ,
			t_InternalInterfaceIdentifier ,
			t_InternalProxyIndex ,
			t_ProcessIdentifier ,
			t_IdentifyToken ,
			t_Impersonating ,
			t_OldContext ,
			t_OldSecurity ,
			t_IsProxy ,
			t_Interface ,
			t_Revert ,
			t_Proxy
		) ;

		if ( SUCCEEDED ( t_Result ) )
		{
			if ( t_IdentifyToken )
			{
				WmiInternalContext t_InternalContext ;
				t_InternalContext.m_IdentifyHandle = ( unsigned __int64 ) t_IdentifyToken ;
				t_InternalContext.m_ProcessIdentifier = GetCurrentProcessId () ;

				t_Result = ( ( Internal_IWbemUnboundObjectSink * ) t_Interface )->Internal_IndicateToConsumer (

					t_InternalContext ,
					a_LogicalConsumer ,
					a_ObjectCount ,
					a_Objects
				) ;
			}
			else
			{

				t_Result = ( ( IWbemUnboundObjectSink * ) t_Interface )->IndicateToConsumer (

					a_LogicalConsumer ,
					a_ObjectCount ,
					a_Objects
				) ;
			}

			End_Interface (

				t_ServerInterface ,
				t_InterfaceIdentifier ,
				t_ProxyIndex ,
				t_InternalServerInterface ,
				t_InternalInterfaceIdentifier ,
				t_InternalProxyIndex ,
				t_ProcessIdentifier ,
				t_IdentifyToken ,
				t_Impersonating ,
				t_OldContext ,
				t_OldSecurity ,
				t_IsProxy ,
				t_Interface ,
				t_Revert ,
				t_Proxy
			) ;
		}

		if ( FAILED ( t_Result ) )
		{
			if ( ( HRESULT_ERROR_FUNC(t_Result) == HRESULT_ERROR_SERVER_UNAVAILABLE ) || ( HRESULT_ERROR_FUNC(t_Result) == HRESULT_ERROR_CALL_FAILED_DNE ) || ( t_Result == RPC_E_DISCONNECTED ))
			{
				if ( m_Controller )
				{
					m_Controller->AbnormalShutdown () ;
				}
			}
		}

		return t_Result ;
	}

	return WBEM_E_PROVIDER_NOT_CAPABLE;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CDecoupled_IWbemUnboundObjectSink :: Shutdown (

		LONG a_Flags ,
		ULONG a_MaxMilliSeconds ,
		IWbemContext *a_Context
)
{
	return S_OK ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

#pragma warning( disable : 4355 )

CInterceptor_IWbemDecoupledProvider :: CInterceptor_IWbemDecoupledProvider (

	WmiAllocator &a_Allocator ,
	IUnknown *a_ServerSideProvider , 
	IWbemServices *a_CoreStub ,
	CWbemGlobal_IWbemSyncProviderController *a_Controller ,
	IWbemContext *a_InitializationContext ,
	CServerObject_ProviderRegistrationV1 &a_Registration ,
	GUID &a_Guid 

) :	CWbemGlobal_IWmiObjectSinkController ( a_Allocator ) ,
	SyncProviderContainerElement (

		a_Controller ,
		a_Guid
	) ,
	m_Allocator ( a_Allocator ) ,
	m_Unknown ( NULL ) ,
	m_Provider_IWbemServices ( NULL ) ,
	m_Provider_IWbemPropertyProvider ( NULL ) ,
	m_Provider_IWbemEventProvider ( NULL ) ,
	m_Provider_IWbemEventProviderQuerySink ( NULL ) ,
	m_Provider_IWbemEventProviderSecurity ( NULL ) ,
	m_Provider_IWbemEventConsumerProvider ( NULL ) ,
	m_Provider_IWbemEventConsumerProviderEx ( NULL ) ,
	m_Provider_IWbemUnboundObjectSink ( NULL ) ,
	m_Provider_IWbemProviderInit ( NULL ) ,
	m_Provider_IWbemProviderIdentity ( NULL ) ,
	m_Provider_Internal_IWbemServices ( NULL ) ,
	m_Provider_Internal_IWbemPropertyProvider ( NULL ) ,
	m_Provider_Internal_IWbemEventProvider ( NULL ) ,
	m_Provider_Internal_IWbemEventProviderQuerySink ( NULL ) ,
	m_Provider_Internal_IWbemEventProviderSecurity ( NULL ) ,
	m_Provider_Internal_IWbemEventConsumerProvider ( NULL ) ,
	m_Provider_Internal_IWbemEventConsumerProviderEx ( NULL ) ,
	m_Provider_Internal_IWbemUnboundObjectSink ( NULL ) ,
	m_Provider_Internal_IWmiProviderConfiguration ( NULL ) ,
	m_Provider_Internal_IWbemProviderInit ( NULL ) ,
	m_Provider_Internal_IWbemProviderIdentity ( NULL ) ,
	m_ExtendedStatusObject ( NULL ) ,
	m_CoreStub ( a_CoreStub ) ,
	m_Registration ( & a_Registration ) ,
	m_Locale ( NULL ) ,
	m_User ( NULL ) ,
	m_Namespace ( NULL ) ,
	m_ProcessIdentifier ( 0 ) ,
	m_ProxyContainer ( a_Allocator , ProxyIndex_Provider_Size , MAX_PROXIES ) ,
	m_ProviderOperation_GetObjectAsync ( 0 ) ,
	m_ProviderOperation_PutClassAsync ( 0 ) ,
	m_ProviderOperation_DeleteClassAsync ( 0 ) ,
	m_ProviderOperation_CreateClassEnumAsync ( 0 ) ,
	m_ProviderOperation_PutInstanceAsync ( 0 ) ,
	m_ProviderOperation_DeleteInstanceAsync ( 0 ) ,
	m_ProviderOperation_CreateInstanceEnumAsync ( 0 ) ,
	m_ProviderOperation_ExecQueryAsync ( 0 ) ,
	m_ProviderOperation_ExecNotificationQueryAsync ( 0 ) ,
	m_ProviderOperation_ExecMethodAsync ( 0 ) ,
	m_ProviderOperation_QueryInstances ( 0 ) ,
	m_ProviderOperation_CreateRefresher ( 0 ) ,
	m_ProviderOperation_CreateRefreshableObject ( 0 ) ,
	m_ProviderOperation_StopRefreshing ( 0 ) ,
	m_ProviderOperation_CreateRefreshableEnum ( 0 ) ,
	m_ProviderOperation_GetObjects ( 0 ) ,
	m_ProviderOperation_GetProperty ( 0 ) ,
	m_ProviderOperation_PutProperty ( 0 ) ,
	m_ProviderOperation_ProvideEvents ( 0 ) ,
	m_ProviderOperation_NewQuery ( 0 ) ,
	m_ProviderOperation_CancelQuery ( 0 ) ,
	m_ProviderOperation_AccessCheck ( 0 ) ,
	m_ProviderOperation_SetRegistrationObject ( 0 ) ,
	m_ProviderOperation_FindConsumer ( 0 ) ,
	m_ProviderOperation_ValidateSubscription ( 0 ) ,
	m_Initialized ( 0 ) ,
	m_InitializeResult ( S_OK ) ,
	m_InitializedEvent ( NULL ) , 
	m_InitializationContext ( a_InitializationContext ),
	m_expandedSD(0)
{
	InterlockedIncrement ( & ProviderSubSystem_Globals :: s_CInterceptor_IWbemDecoupledProvider_ObjectsInProgress ) ;

	ProviderSubSystem_Globals :: Increment_Global_Object_Count () ;

	if ( a_InitializationContext )
	{
		a_InitializationContext->AddRef () ;
	}

	if ( m_Registration )
	{
		m_Registration->AddRef () ;
	}

	if ( a_ServerSideProvider ) 
	{
		m_Unknown = a_ServerSideProvider ;
		m_Unknown->AddRef () ;

		HRESULT t_TempResult = m_Unknown->QueryInterface ( IID_IWbemServices , ( void ** ) & m_Provider_IWbemServices ) ;
		if ( SUCCEEDED ( t_TempResult ) )
		{
			t_TempResult = m_Unknown->QueryInterface ( IID_Internal_IWbemServices , ( void ** ) & m_Provider_Internal_IWbemServices ) ;
			if ( FAILED ( t_TempResult ) )
			{
				m_InitializeResult = WBEM_E_PROVIDER_LOAD_FAILURE ;
			}
		}

		t_TempResult = m_Unknown->QueryInterface ( IID_IWbemPropertyProvider , ( void ** ) & m_Provider_IWbemPropertyProvider ) ;
		if ( SUCCEEDED ( t_TempResult ) )
		{
			t_TempResult = m_Unknown->QueryInterface ( IID_Internal_IWbemPropertyProvider , ( void ** ) & m_Provider_Internal_IWbemPropertyProvider ) ;
			if ( FAILED ( t_TempResult ) )
			{
				m_InitializeResult = WBEM_E_PROVIDER_LOAD_FAILURE ;
			}
		}

		t_TempResult = m_Unknown->QueryInterface ( IID_IWbemEventProvider , ( void ** ) & m_Provider_IWbemEventProvider ) ;
		if ( SUCCEEDED ( t_TempResult ) )
		{
			t_TempResult = m_Unknown->QueryInterface ( IID_Internal_IWbemEventProvider , ( void ** ) & m_Provider_Internal_IWbemEventProvider ) ;
			if ( FAILED ( t_TempResult ) )
			{
				m_InitializeResult = WBEM_E_PROVIDER_LOAD_FAILURE ;
			}
		}

		t_TempResult = m_Unknown->QueryInterface ( IID_IWbemEventProviderQuerySink , ( void ** ) & m_Provider_IWbemEventProviderQuerySink ) ;
		if ( SUCCEEDED ( t_TempResult ) )
		{
			t_TempResult = m_Unknown->QueryInterface ( IID_Internal_IWbemEventProviderQuerySink , ( void ** ) & m_Provider_Internal_IWbemEventProviderQuerySink ) ;
			if ( FAILED ( t_TempResult ) )
			{
				m_InitializeResult = WBEM_E_PROVIDER_LOAD_FAILURE ;
			}
		}

		t_TempResult = m_Unknown->QueryInterface ( IID_IWbemEventProviderSecurity , ( void ** ) & m_Provider_IWbemEventProviderSecurity ) ;
		if ( SUCCEEDED ( t_TempResult ) )
		{
			t_TempResult = m_Unknown->QueryInterface ( IID_Internal_IWbemEventProviderSecurity , ( void ** ) & m_Provider_Internal_IWbemEventProviderSecurity ) ;
			if ( FAILED ( t_TempResult ) )
			{
				m_InitializeResult = WBEM_E_PROVIDER_LOAD_FAILURE ;
			}
		}

		t_TempResult = m_Unknown->QueryInterface ( IID_IWbemUnboundObjectSink , ( void ** ) & m_Provider_IWbemUnboundObjectSink ) ;
		if ( SUCCEEDED ( t_TempResult ) )
		{
			t_TempResult = m_Unknown->QueryInterface ( IID_Internal_IWbemUnboundObjectSink , ( void ** ) & m_Provider_Internal_IWbemUnboundObjectSink ) ;
			if ( FAILED ( t_TempResult ) )
			{
				m_InitializeResult = WBEM_E_PROVIDER_LOAD_FAILURE ;
			}
		}

		t_TempResult = m_Unknown->QueryInterface ( IID_IWbemEventConsumerProvider , ( void ** ) & m_Provider_IWbemEventConsumerProvider ) ;
		if ( SUCCEEDED ( t_TempResult ) )
		{
			t_TempResult = m_Unknown->QueryInterface ( IID_Internal_IWbemEventConsumerProvider , ( void ** ) & m_Provider_Internal_IWbemEventConsumerProvider ) ;
			if ( FAILED ( t_TempResult ) )
			{
				m_InitializeResult = WBEM_E_PROVIDER_LOAD_FAILURE ;
			}
		}

		t_TempResult = m_Unknown->QueryInterface ( IID_IWbemEventConsumerProviderEx , ( void ** ) & m_Provider_IWbemEventConsumerProviderEx ) ;
		if ( SUCCEEDED ( t_TempResult ) )
		{
			t_TempResult = m_Unknown->QueryInterface ( IID_Internal_IWbemEventConsumerProviderEx , ( void ** ) & m_Provider_Internal_IWbemEventConsumerProviderEx ) ;
			if ( FAILED ( t_TempResult ) )
			{
				m_InitializeResult = WBEM_E_PROVIDER_LOAD_FAILURE ;
			}
		}

		t_TempResult = m_Unknown->QueryInterface ( IID_IWbemProviderInit , ( void ** ) & m_Provider_IWbemProviderInit ) ;
		if ( SUCCEEDED ( t_TempResult ) )
		{
			t_TempResult = m_Unknown->QueryInterface ( IID_Internal_IWbemProviderInit , ( void ** ) & m_Provider_Internal_IWbemProviderInit ) ;
			if ( FAILED ( t_TempResult ) )
			{
				m_InitializeResult = WBEM_E_PROVIDER_LOAD_FAILURE ;
			}
		}

		t_TempResult = m_Unknown->QueryInterface ( IID_IWbemProviderIdentity , ( void ** ) & m_Provider_IWbemProviderIdentity ) ;
		if ( SUCCEEDED ( t_TempResult ) )
		{
			t_TempResult = m_Unknown->QueryInterface ( IID_Internal_IWbemProviderIdentity , ( void ** ) & m_Provider_Internal_IWbemProviderIdentity ) ;
			if ( FAILED ( t_TempResult ) )
			{
				m_InitializeResult = WBEM_E_PROVIDER_LOAD_FAILURE ;
			}
		}
	}

	if ( m_CoreStub )
	{
		m_CoreStub->AddRef () ;
	}
}

#pragma warning( default : 4355 )

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

CInterceptor_IWbemDecoupledProvider :: ~CInterceptor_IWbemDecoupledProvider ()
{
	WmiSetAndCommitObject (

		ProviderSubSystem_Globals :: s_EventClassHandles [ Msft_WmiProvider_UnLoadOperationEvent ] , 
		WMI_SENDCOMMIT_SET_NOT_REQUIRED,
		m_Namespace ,
		m_Registration->GetProviderName () ,
		m_User ,
		m_Locale ,
		NULL 
	) ;

	if ( m_ExtendedStatusObject )
	{
		m_ExtendedStatusObject->Release () ;
	}

	if ( m_Unknown )
	{
		m_Unknown->Release () ;
	}

	if ( m_Provider_IWbemServices )
	{
		m_Provider_IWbemServices->Release () ; 
	}

	if ( m_Provider_IWbemPropertyProvider )
	{
		m_Provider_IWbemPropertyProvider->Release () ; 
	}

	if ( m_Provider_IWbemEventProvider )
	{
		m_Provider_IWbemEventProvider->Release () ;
	}

	if ( m_Provider_IWbemEventProviderQuerySink )
	{
		m_Provider_IWbemEventProviderQuerySink->Release () ;
	}

	if ( m_Provider_IWbemEventProviderSecurity )
	{
		m_Provider_IWbemEventProviderSecurity->Release () ;
	}

	if ( m_Provider_IWbemEventConsumerProviderEx )
	{
		m_Provider_IWbemEventConsumerProviderEx->Release () ;
	}

	if ( m_Provider_IWbemEventConsumerProvider )
	{
		m_Provider_IWbemEventConsumerProvider->Release () ;
	}

	if ( m_Provider_IWbemUnboundObjectSink )
	{
		m_Provider_IWbemUnboundObjectSink->Release () ;
	}

	if ( m_Provider_IWbemUnboundObjectSink )
	{
		m_Provider_IWbemUnboundObjectSink->Release () ;
	}

	if ( m_Provider_IWbemProviderInit )
	{
		m_Provider_IWbemProviderInit->Release () ;
	}

	if ( m_Provider_IWbemProviderIdentity )
	{
		m_Provider_IWbemProviderIdentity->Release () ;
	}

	if ( m_Provider_Internal_IWbemServices )
	{
		m_Provider_Internal_IWbemServices->Release () ;
	}

	if ( m_Provider_Internal_IWbemPropertyProvider )
	{
		m_Provider_Internal_IWbemPropertyProvider->Release () ;
	}

	if ( m_Provider_Internal_IWbemEventProvider )
	{
		m_Provider_Internal_IWbemEventProvider->Release () ;
	}

	if ( m_Provider_Internal_IWbemEventProviderQuerySink )
	{
		m_Provider_Internal_IWbemEventProviderQuerySink->Release () ;
	}

	if ( m_Provider_Internal_IWbemEventProviderSecurity )
	{
		m_Provider_Internal_IWbemEventProviderSecurity->Release () ;
	}

	if ( m_Provider_Internal_IWbemEventConsumerProvider )
	{
		m_Provider_Internal_IWbemEventConsumerProvider->Release () ;
	}

	if ( m_Provider_Internal_IWbemEventConsumerProviderEx )
	{
		m_Provider_Internal_IWbemEventConsumerProviderEx->Release () ;
	}

	if ( m_Provider_Internal_IWbemUnboundObjectSink )
	{
		m_Provider_Internal_IWbemUnboundObjectSink->Release () ;
	}

	if ( m_Provider_Internal_IWmiProviderConfiguration )
	{
		m_Provider_Internal_IWmiProviderConfiguration->Release () ;
	}

	if ( m_Provider_Internal_IWbemProviderInit )
	{
		m_Provider_Internal_IWbemProviderInit->Release () ;
	}

	if ( m_Provider_Internal_IWbemProviderIdentity )
	{
		m_Provider_Internal_IWbemProviderIdentity->Release () ;
	}

	if ( m_CoreStub )
	{
		m_CoreStub->Release () ;
	}

	WmiStatusCode t_StatusCode = m_ProxyContainer.UnInitialize () ;

	if ( m_InitializationContext )
	{
		m_InitializationContext->Release () ;
	}

	if ( m_InitializedEvent )
	{
		CloseHandle ( m_InitializedEvent ) ;
	}

	if ( m_Namespace ) 
	{
		SysFreeString ( m_Namespace ) ;
	}

	if ( m_Locale ) 
	{
		SysFreeString ( m_Locale ) ;
	}

	if ( m_User ) 
	{
		SysFreeString ( m_User ) ;
	}

	if ( m_Registration )
	{
		m_Registration->Release () ;
	}

	delete[] (BYTE*)m_expandedSD;
		
	CWbemGlobal_IWmiObjectSinkController :: UnInitialize () ;

	InterlockedDecrement ( & ProviderSubSystem_Globals :: s_CInterceptor_IWbemDecoupledProvider_ObjectsInProgress ) ;

	ProviderSubSystem_Globals :: Decrement_Global_Object_Count () ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

STDMETHODIMP_( ULONG ) CInterceptor_IWbemDecoupledProvider :: AddRef ()
{
	return SyncProviderContainerElement :: AddRef () ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

STDMETHODIMP_(ULONG) CInterceptor_IWbemDecoupledProvider :: Release ()
{
	return SyncProviderContainerElement :: Release () ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

STDMETHODIMP CInterceptor_IWbemDecoupledProvider :: QueryInterface (

	REFIID iid , 
	LPVOID FAR *iplpv 
) 
{
	*iplpv = NULL ;

	if ( iid == IID_IUnknown )
	{
		*iplpv = ( LPVOID ) this ;
	}
	else if ( iid == IID_IWbemServices )
	{
		if ( m_Provider_IWbemServices )
		{
			*iplpv = ( LPVOID ) ( IWbemServices * ) this ;
		}
	}
	else if ( iid == IID_IWbemPropertyProvider )
	{
		if ( m_Provider_IWbemPropertyProvider )
		{
			*iplpv = ( LPVOID ) ( IWbemPropertyProvider * ) this ;
		}
	}	
	else if ( iid == IID_IWbemEventProvider )
	{
		if ( m_Provider_IWbemEventProvider )
		{
			*iplpv = ( LPVOID ) ( IWbemEventProvider * ) this ;
		}
	}
	else if ( iid == IID_IWbemEventProviderQuerySink )
	{
		if ( m_Provider_IWbemEventProviderQuerySink )
		{
			*iplpv = ( LPVOID ) ( IWbemEventProviderQuerySink * ) this ;
		}
	}
	else if ( iid == IID_IWbemEventProviderSecurity )
	{
		if ( m_Provider_IWbemEventProviderSecurity )
		{
			*iplpv = ( LPVOID ) ( IWbemEventProviderSecurity * ) this ;
		}
	}
	else if ( iid == IID_IWbemEventConsumerProvider )
	{
		if ( m_Provider_IWbemEventConsumerProvider )
		{
			*iplpv = ( LPVOID ) ( IWbemEventConsumerProvider * ) this ;
		}
	}
	else if ( iid == IID_IWbemEventConsumerProviderEx )
	{
		if ( m_Provider_IWbemEventConsumerProviderEx )
		{
			*iplpv = ( LPVOID ) ( IWbemEventConsumerProviderEx  * ) this ;
		}
	}
	else if ( iid == IID_IWbemUnboundObjectSink )
	{
		if ( m_Provider_IWbemUnboundObjectSink )
		{
			*iplpv = ( LPVOID ) ( IWbemUnboundObjectSink * ) this ;
		}
	}
	else if ( iid == IID_IWbemProviderInit )
	{
		if ( m_Provider_IWbemProviderInit )
		{
			*iplpv = ( LPVOID ) ( IWbemProviderInit * ) this ;
		}
	}
	else if ( iid == IID_IWbemProviderIdentity )
	{
		if ( m_Provider_IWbemProviderIdentity )
		{
			*iplpv = ( LPVOID ) ( IWbemProviderIdentity * ) this ;
		}
	}
	else if ( iid == IID__IWmiProviderAbnormalShutdown )
	{
		*iplpv = ( LPVOID ) ( _IWmiProviderAbnormalShutdown * ) this ;
	}	
	else if ( iid == IID_IWbemShutdown )
	{
		*iplpv = ( LPVOID ) ( IWbemShutdown * ) this ;		
	}
	else if ( iid == IID_CWbemGlobal_IWmiObjectSinkController )
	{
		*iplpv = ( LPVOID ) ( CWbemGlobal_IWmiObjectSinkController * ) this ;		
	}	
	else if ( iid == IID_CacheElement )
	{
		*iplpv = ( LPVOID ) ( SyncProviderContainerElement * ) this ;		
	}
	else if ( iid == IID__IWmiProviderInitialize )
	{
		*iplpv = ( LPVOID ) ( _IWmiProviderInitialize * ) this ;
	}

	if ( *iplpv )
	{
		( ( LPUNKNOWN ) *iplpv )->AddRef () ;

		return ResultFromScode ( S_OK ) ;
	}
	else
	{
		return ResultFromScode ( E_NOINTERFACE ) ;
	}
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT ConstructToken_SvcHost (

	BOOL &a_Revert ,
	DWORD a_ProcessIdentifier ,
	HANDLE &a_IdentifyToken ,
	ACCESS_ALLOWED_ACE *a_Ace ,
	WORD a_AceSize,
	SECURITY_IMPERSONATION_LEVEL level
)
{
	HRESULT t_Result = S_OK ;

	HANDLE t_ThreadToken = NULL ;

	BOOL t_Status = OpenThreadToken (

		GetCurrentThread () ,
		MAXIMUM_ALLOWED ,
		TRUE ,
		& t_ThreadToken
	) ;
	
	if ( t_Status )
	{
		CoRevertToSelf () ;

		a_Revert = FALSE ;

		SECURITY_DESCRIPTOR *t_SecurityDescriptor = NULL ;

		DWORD t_LengthRequested = 0 ;
		DWORD t_LengthReturned = 0 ;

		t_Status = GetKernelObjectSecurity (

			t_ThreadToken ,
			DACL_SECURITY_INFORMATION ,
			& t_SecurityDescriptor ,
			t_LengthRequested ,
			& t_LengthReturned
		) ;

		if ( ( t_Status == FALSE ) && ( GetLastError () == ERROR_INSUFFICIENT_BUFFER ) )
		{
			t_SecurityDescriptor = ( SECURITY_DESCRIPTOR * ) new BYTE [ t_LengthReturned ] ;
			if ( t_SecurityDescriptor )
			{
				t_LengthRequested = t_LengthReturned ;

				t_Status = GetKernelObjectSecurity (

					t_ThreadToken ,
					DACL_SECURITY_INFORMATION ,
					t_SecurityDescriptor ,
					t_LengthRequested ,
					& t_LengthReturned
				) ;

				if ( t_LengthRequested != t_LengthReturned )
				{
					t_Result = WBEM_E_UNEXPECTED ;
				}
			}
			else
			{
				t_Result = WBEM_E_OUT_OF_MEMORY ;
			}
		}
		else
		{
			t_Result = WBEM_E_ACCESS_DENIED ;
		}

		HANDLE t_AdjustedThreadToken = NULL ;

		if ( SUCCEEDED ( t_Result ) )
		{
			PACL t_ExtraDacl = NULL ;

			ACL *t_Dacl = NULL ;
			BOOL t_DaclPresent = FALSE ;
			BOOL t_DaclDefaulted = FALSE ;

			t_Status = GetSecurityDescriptorDacl (

				t_SecurityDescriptor ,
				& t_DaclPresent ,
				& t_Dacl ,
				& t_DaclDefaulted
			) ;

			if ( t_Status )
			{
				ACL_SIZE_INFORMATION t_Size ;

				if ( t_Dacl )
				{
					BOOL t_Status = GetAclInformation (

						t_Dacl ,
						& t_Size ,
						sizeof ( t_Size ) ,
						AclSizeInformation
					);

					if ( t_Status )
					{
						DWORD t_ExtraSize = t_Size.AclBytesInUse + t_Size.AclBytesFree + a_AceSize ;

						t_ExtraDacl = ( PACL ) new BYTE [ t_ExtraSize ] ;
						if ( t_ExtraDacl )
						{
							CopyMemory ( t_ExtraDacl , t_Dacl , t_Size.AclBytesInUse + t_Size.AclBytesFree ) ;
							t_ExtraDacl->AclSize = t_ExtraSize ;

							BOOL t_Status = :: AddAce ( t_ExtraDacl , ACL_REVISION, t_Size.AceCount , a_Ace , a_AceSize ) ;
							if ( t_Status )
							{
								SECURITY_DESCRIPTOR t_AdjustedSecurityDescriptor ;

								if ( SUCCEEDED ( t_Result ) )
								{
									BOOL t_Status = InitializeSecurityDescriptor ( & t_AdjustedSecurityDescriptor , SECURITY_DESCRIPTOR_REVISION ) ;
									if ( t_Status ) 
									{
										t_Status = SetSecurityDescriptorDacl (

											& t_AdjustedSecurityDescriptor ,
											t_DaclPresent ,
											t_ExtraDacl ,
											t_DaclDefaulted
										) ;

										if ( t_Status ) 
										{
											SECURITY_ATTRIBUTES t_SecurityAttributes ;
											t_SecurityAttributes.nLength = GetSecurityDescriptorLength ( & t_AdjustedSecurityDescriptor ) ;
											t_SecurityAttributes.lpSecurityDescriptor = & t_AdjustedSecurityDescriptor ;
											t_SecurityAttributes.bInheritHandle = FALSE ;

											t_Status = DuplicateTokenEx ( 

												t_ThreadToken,
												0 ,
												& t_SecurityAttributes ,
												( SECURITY_IMPERSONATION_LEVEL ) level,
												TokenImpersonation ,
												& t_AdjustedThreadToken
											) ;

											if ( t_Status == FALSE )
											{
												t_Result = WBEM_E_ACCESS_DENIED ;
											}
										}
										else
										{
											t_Result = WBEM_E_CRITICAL_ERROR ;
										}
									}
									else
									{
										t_Result = WBEM_E_UNEXPECTED ;
									}
								}
							}
							else
							{
								t_Result = WBEM_E_CRITICAL_ERROR ;
							}

							delete [] ( BYTE * ) t_ExtraDacl ;
						}
						else
						{
							t_Result = WBEM_E_OUT_OF_MEMORY ;
						}
					}
					else
					{
						t_Result = WBEM_E_CRITICAL_ERROR ;
					}
				}
				else
				{
					t_Result = WBEM_E_CRITICAL_ERROR ;
				}
			}
			else
			{
				t_Result = WBEM_E_CRITICAL_ERROR ;
			}
		}

		if ( SUCCEEDED ( t_Result ) )
		{
			HANDLE t_ProcessHandle = OpenProcess (

				MAXIMUM_ALLOWED ,
				FALSE ,
				a_ProcessIdentifier 
			) ;

			if ( t_ProcessHandle )
			{
				t_Status = DuplicateHandle (

					GetCurrentProcess () ,
					t_AdjustedThreadToken ,
					t_ProcessHandle ,
					& a_IdentifyToken ,
					TOKEN_READ | TOKEN_DUPLICATE | TOKEN_IMPERSONATE,
					TRUE ,
					0
				) ;

				if ( t_Status )
				{

				}
				else
				{
					t_Result = WBEM_E_ACCESS_DENIED ;
				}

				CloseHandle ( t_ProcessHandle ) ;
			}
			else
			{
				t_Result = WBEM_E_ACCESS_DENIED ;
			}
		}

		if ( t_SecurityDescriptor )
		{
			delete [] ( BYTE * ) t_SecurityDescriptor ; 
		}

		if ( t_AdjustedThreadToken )
		{
			CloseHandle ( t_AdjustedThreadToken ) ;
		}

		CloseHandle ( t_ThreadToken ) ;
	}
	else
	{
		t_Result = WBEM_E_ACCESS_DENIED ;
	}

	return t_Result ;
}

HRESULT SetProxyState_SvcHost ( 

    CInterceptor_IWbemDecoupledProvider * a_pInterceptor,
	ProxyContainer &a_Container , 
	ULONG a_ProxyIndex ,
	REFIID a_InterfaceId ,
	IUnknown *a_Interface , 
	IUnknown *&a_Proxy , 
	BOOL &a_Revert ,
	DWORD a_ProcessIdentifier ,
	HANDLE &a_IdentifyToken ,
	ACCESS_ALLOWED_ACE *a_Ace ,
	WORD a_AceSize
)
{
	a_Revert = FALSE ;

	HRESULT t_Result = ProviderSubSystem_Common_Globals::GetProxy ( a_Container , a_ProxyIndex , a_InterfaceId , a_Interface , a_Proxy ) ;
	if ( SUCCEEDED ( t_Result ) )
	{
        t_Result = CoImpersonateClient () ;
        if ( SUCCEEDED ( t_Result ) )
        {
			a_Revert = TRUE ;

			DWORD t_ImpersonationLevel ;

			if ( a_pInterceptor->m_Registration->GetComRegistration ().GetDecoupledImpersonationRestriction () )
			{
				t_ImpersonationLevel = RPC_C_IMP_LEVEL_IDENTIFY ;
			}
			else
			{
				t_ImpersonationLevel = ProviderSubSystem_Common_Globals::GetCurrentImpersonationLevel () ;
			}
		
			// At this point, our thread token contains all the privileges that the
			// client has enabled for us; however, those privileges are not enabled.
			// Since we are calling into a proxied provider, we need to enable all
			// these privileges so that they would propagate to the provider
			// =====================================================================

			HRESULT t_TempResult = ProviderSubSystem_Common_Globals::EnableAllPrivileges () ;
			// Get the token's impersonation level
			// ===================================

				t_Result = ConstructToken_SvcHost (

					a_Revert ,
					a_ProcessIdentifier ,
					a_IdentifyToken ,
					a_Ace ,
					a_AceSize,
					(SECURITY_IMPERSONATION_LEVEL)(t_ImpersonationLevel-1)
				) ;
				
				if ( SUCCEEDED ( t_Result ) ) 
				{
					t_Result = SetInterfaceSecurity (

						a_Proxy ,
						NULL ,
						NULL ,
						NULL ,
						DWORD(RPC_C_AUTHN_LEVEL_DEFAULT),
						RPC_C_IMP_LEVEL_IDENTIFY
					) ;
				}
				CoRevertToSelf () ;
		}
		else
		{
			t_Result = WBEM_E_ACCESS_DENIED ;
		}
	}
	else 
	{
		if ( t_Result == WBEM_E_NOT_FOUND )
		{
		}
		else 
		{
			t_Result = WBEM_E_CRITICAL_ERROR ;
		}
	}

	return t_Result ;
}

HRESULT CInterceptor_IWbemDecoupledProvider :: Begin_Interface (

	IUnknown *a_ServerInterface ,
	REFIID a_InterfaceIdentifier ,
	DWORD a_ProxyIndex ,
	IUnknown *a_InternalServerInterface ,
	REFIID a_InternalInterfaceIdentifier ,
	DWORD a_InternalProxyIndex ,
	DWORD a_ProcessIdentifier ,
	HANDLE &a_IdentifyToken ,
	BOOL &a_Impersonating ,
	IUnknown *&a_OldContext ,
	IServerSecurity *&a_OldSecurity ,
	BOOL &a_IsProxy ,
	IUnknown *&a_Interface ,
	BOOL &a_Revert ,
	IUnknown *&a_Proxy ,
	IWbemContext *a_Context
)
{
	HRESULT t_Result = S_OK ;

	a_IdentifyToken = NULL ;
	a_Revert = FALSE ;
	a_Proxy = NULL ;
	a_Impersonating = FALSE ;
	a_OldContext = NULL ;
	a_OldSecurity = NULL ;

	DWORD t_AuthenticationLevel = 0 ;

	t_Result = ProviderSubSystem_Common_Globals :: BeginImpersonation ( a_OldContext , a_OldSecurity , a_Impersonating , & t_AuthenticationLevel ) ;
	if ( SUCCEEDED ( t_Result ) ) 
	{
		_DBG_ASSERT( a_ProcessIdentifier );

		WORD t_AceSize = 0 ;
		ACCESS_ALLOWED_ACE *t_Ace = NULL ;

		t_Result = ProviderSubSystem_Common_Globals :: GetAceWithProcessTokenUser ( 
		
			a_ProcessIdentifier ,
			t_AceSize ,
			t_Ace 
		) ;

		if ( SUCCEEDED ( t_Result ) )
		{
			t_Result = SetProxyState_SvcHost ( 

			    this,
				m_ProxyContainer , 
				a_InternalProxyIndex , 
				a_InterfaceIdentifier , 
				a_InternalServerInterface , 
				a_Proxy , 
				a_Revert , 
				a_ProcessIdentifier , 
				a_IdentifyToken ,
				t_Ace ,
				t_AceSize
			) ;

			delete [] ( BYTE * ) t_Ace ;
		}


		if ( t_Result == WBEM_E_NOT_FOUND )
		{
			a_Interface = a_ServerInterface ;
			a_IsProxy = FALSE ;
			t_Result = S_OK ;
		}
		else
		{
			if ( SUCCEEDED ( t_Result ) )
			{
				a_IsProxy = TRUE ;

				a_Interface = ( IUnknown * ) a_Proxy ;

				// Set cloaking on the proxy

				DWORD t_ImpersonationLevel ;

				if ( m_Registration->GetComRegistration ().GetDecoupledImpersonationRestriction () )
				{
					t_ImpersonationLevel = RPC_C_IMP_LEVEL_IDENTIFY ;
				}
				else
				{
					t_ImpersonationLevel = ProviderSubSystem_Common_Globals :: GetCurrentImpersonationLevel () ;
				}

				t_Result = ProviderSubSystem_Common_Globals :: SetCloaking (

					a_Interface ,
					RPC_C_AUTHN_LEVEL_CONNECT , 
					t_ImpersonationLevel
				) ;

				if ( SUCCEEDED ( t_Result ) )
				{
					if ( a_Context )
					{
						VARIANT t_Variant ;
						VariantInit ( & t_Variant ) ;
						t_Variant.lVal = t_AuthenticationLevel ;
						t_Variant.vt = VT_I4 ;

						
						t_Result = a_Context->SetValue ( L"__WBEM_CLIENT_AUTHENTICATION_LEVEL" , 0, & t_Variant ) ;
					}
				}

				if ( FAILED ( t_Result ) )
				{
					if ( a_IdentifyToken )
					{
						HRESULT t_TempResult = ProviderSubSystem_Common_Globals :: RevertProxyState_SvcHost ( 

							m_ProxyContainer , 
							a_InternalProxyIndex , 
							a_Proxy , 
							a_Revert ,
							a_ProcessIdentifier , 
							a_IdentifyToken 
						) ;
					}
					else
					{
						HRESULT t_TempResult = ProviderSubSystem_Common_Globals :: RevertProxyState ( 

							m_ProxyContainer , 
							a_ProxyIndex , 
							a_Proxy , 
							a_Revert
						) ;
					}
				}
			}
		}

		if ( FAILED ( t_Result ) )
		{
			ProviderSubSystem_Common_Globals :: EndImpersonation ( a_OldContext , a_OldSecurity , a_Impersonating ) ;
		}
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_IWbemDecoupledProvider :: End_Interface (

	IUnknown *a_ServerInterface ,
	REFIID a_InterfaceIdentifier ,
	DWORD a_ProxyIndex ,
	IUnknown *a_InternalServerInterface ,
	REFIID a_InternalInterfaceIdentifier ,
	DWORD a_InternalProxyIndex ,
	DWORD a_ProcessIdentifier ,
	HANDLE a_IdentifyToken ,
	BOOL a_Impersonating ,
	IUnknown *a_OldContext ,
	IServerSecurity *a_OldSecurity ,
	BOOL a_IsProxy ,
	IUnknown *a_Interface ,
	BOOL a_Revert ,
	IUnknown *a_Proxy
)
{
	CoRevertToSelf () ;


	if ( a_Proxy )
	{
		_DBG_ASSERT(a_IdentifyToken);
		if ( a_IdentifyToken )
		{
			HRESULT t_TempResult = ProviderSubSystem_Common_Globals :: RevertProxyState_SvcHost ( 

				m_ProxyContainer , 
				a_InternalProxyIndex , 
				a_Proxy , 
				a_Revert ,
				a_ProcessIdentifier ,
				a_IdentifyToken 
			) ;
		}
		else
		{
			HRESULT t_TempResult = ProviderSubSystem_Common_Globals :: RevertProxyState ( 

				m_ProxyContainer , 
				a_ProxyIndex , 
				a_Proxy , 
				a_Revert
			) ;
		}
	}

	ProviderSubSystem_Common_Globals :: EndImpersonation ( a_OldContext , a_OldSecurity , a_Impersonating ) ;

	return S_OK ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_IWbemDecoupledProvider::OpenNamespace ( 

	const BSTR a_ObjectPath ,
	long a_Flags ,
	IWbemContext *a_Context ,
	IWbemServices **a_NamespaceService ,
	IWbemCallResult **a_CallResult
)
{
	return WBEM_E_NOT_AVAILABLE ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_IWbemDecoupledProvider :: CancelAsyncCall ( 
		
	IWbemObjectSink *a_Sink
)
{
	HRESULT t_Result = WBEM_E_PROVIDER_NOT_CAPABLE ;

	if ( m_Provider_IWbemServices )
	{
		CWbemGlobal_IWmiObjectSinkController_Container_Iterator t_Iterator ;

		Lock () ;

		WmiStatusCode t_StatusCode = Find ( 

			a_Sink ,
			t_Iterator
		) ;

		if ( t_StatusCode == e_StatusCode_Success ) 
		{
			ObjectSinkContainerElement *t_Element = t_Iterator.GetElement () ;

			UnLock () ;

			IWbemObjectSink *t_ObjectSink = NULL ;
			t_Result = t_Element->QueryInterface ( IID_IWbemObjectSink , ( void ** ) & t_ObjectSink ) ;
			if ( SUCCEEDED ( t_Result ) )
			{ 
				IUnknown *t_ServerInterface = m_Provider_IWbemServices ;
				REFIID t_InterfaceIdentifier = IID_IWbemServices ;
				DWORD t_ProxyIndex = ProxyIndex_IWbemServices ;
				IUnknown *t_InternalServerInterface = m_Provider_Internal_IWbemServices ;
				REFIID t_InternalInterfaceIdentifier = IID_Internal_IWbemServices ;
				DWORD t_InternalProxyIndex = ProxyIndex_Internal_IWbemServices ;
				BOOL t_Impersonating ;
				IUnknown *t_OldContext ;
				IServerSecurity *t_OldSecurity ;
				BOOL t_IsProxy ;
				IUnknown *t_Interface ;
				BOOL t_Revert ;
				IUnknown *t_Proxy ;
				HANDLE t_IdentifyToken = NULL ;

				t_Result = Begin_Interface (

					t_ServerInterface ,
					t_InterfaceIdentifier ,
					t_ProxyIndex ,
					t_InternalServerInterface ,
					t_InternalInterfaceIdentifier ,
					t_InternalProxyIndex ,
					m_ProcessIdentifier ,
					t_IdentifyToken ,
					t_Impersonating ,
					t_OldContext ,
					t_OldSecurity ,
					t_IsProxy ,
					t_Interface ,
					t_Revert ,
					t_Proxy
				) ;

				if ( SUCCEEDED ( t_Result ) )
				{
					if ( t_IdentifyToken )
					{
						WmiInternalContext t_InternalContext ;
						t_InternalContext.m_IdentifyHandle = ( unsigned __int64 ) t_IdentifyToken ;
						t_InternalContext.m_ProcessIdentifier = GetCurrentProcessId () ;

						t_Result = ( ( Internal_IWbemServices * ) t_Interface )->Internal_CancelAsyncCall (

							t_InternalContext ,
							t_ObjectSink
						) ;
					}
					else
					{
						t_Result = ( ( IWbemServices * ) t_Interface )->CancelAsyncCall (

							t_ObjectSink
						) ;
					}

					End_Interface (

						t_ServerInterface ,
						t_InterfaceIdentifier ,
						t_ProxyIndex ,
						t_InternalServerInterface ,
						t_InternalInterfaceIdentifier ,
						t_InternalProxyIndex ,
						m_ProcessIdentifier ,
						t_IdentifyToken ,
						t_Impersonating ,
						t_OldContext ,
						t_OldSecurity ,
						t_IsProxy ,
						t_Interface ,
						t_Revert ,
						t_Proxy
					) ;
				}

				t_ObjectSink->Release () ;
			}

			IWbemShutdown *t_Shutdown = NULL ;
			HRESULT t_TempResult = t_Element->QueryInterface ( IID_IWbemShutdown , ( void ** ) & t_Shutdown ) ;
			if ( SUCCEEDED ( t_TempResult ) )
			{
				t_TempResult = t_Shutdown->Shutdown ( 

					0 , 
					0 , 
					NULL 
				) ;

				t_Shutdown->Release () ;
			}

			t_Element->Release () ;
		}
		else
		{
			UnLock () ;

			t_Result = WBEM_E_NOT_FOUND ;
		}
	}

	if ( FAILED ( t_Result ) )
	{
		if ( ( HRESULT_ERROR_FUNC(t_Result) == HRESULT_ERROR_SERVER_UNAVAILABLE ) || ( HRESULT_ERROR_FUNC(t_Result) == HRESULT_ERROR_CALL_FAILED_DNE ) || ( t_Result == RPC_E_DISCONNECTED ))
		{
			AbnormalShutdown () ;
		}
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_IWbemDecoupledProvider :: QueryObjectSink ( 

	long a_Flags ,
	IWbemObjectSink **a_Sink
) 
{
	return WBEM_E_NOT_AVAILABLE ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_IWbemDecoupledProvider :: GetObject ( 
		
	const BSTR a_ObjectPath ,
    long a_Flags ,
    IWbemContext *a_Context ,
    IWbemClassObject **a_Object ,
    IWbemCallResult **a_CallResult
)
{
	return WBEM_E_NOT_AVAILABLE ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_IWbemDecoupledProvider :: GetObjectAsync ( 
		
	const BSTR a_ObjectPath ,
	long a_Flags , 
	IWbemContext *a_Context ,
	IWbemObjectSink *a_Sink
) 
{
	if ( m_Initialized == 0 )
	{
		a_Sink->SetStatus ( 0 , WBEM_E_NOT_FOUND , NULL , NULL ) ;

		return WBEM_E_NOT_FOUND ;
	}

	BOOL t_DependantCall = FALSE ;

	HRESULT t_Result = WBEM_E_PROVIDER_NOT_CAPABLE ;

	if ( m_Provider_IWbemServices )
	{
		CInterceptor_IWbemObjectSink *t_Sink = new CInterceptor_IWbemObjectSink (

			a_Sink , 
			( IWbemServices * ) this , 
			( CWbemGlobal_IWmiObjectSinkController * ) this
		) ;

		if ( t_Sink )
		{
			t_Sink->AddRef () ;

			t_Result = t_Sink->Initialize ( this->GetSD() ) ;
			if ( SUCCEEDED ( t_Result ) ) 
			{
				CWbemGlobal_IWmiObjectSinkController_Container_Iterator t_Iterator ;

				Lock () ;

				WmiStatusCode t_StatusCode = Insert ( 

					*t_Sink ,
					t_Iterator
				) ;

				if ( t_StatusCode == e_StatusCode_Success ) 
				{
					UnLock () ;

					IUnknown *t_ServerInterface = m_Provider_IWbemServices ;
					REFIID t_InterfaceIdentifier = IID_IWbemServices ;
					DWORD t_ProxyIndex = ProxyIndex_IWbemServices ;
					IUnknown *t_InternalServerInterface = m_Provider_Internal_IWbemServices ;
					REFIID t_InternalInterfaceIdentifier = IID_Internal_IWbemServices ;
					DWORD t_InternalProxyIndex = ProxyIndex_Internal_IWbemServices ;
					BOOL t_Impersonating ;
					IUnknown *t_OldContext ;
					IServerSecurity *t_OldSecurity ;
					BOOL t_IsProxy ;
					IUnknown *t_Interface ;
					BOOL t_Revert ;
					IUnknown *t_Proxy ;
					HANDLE t_IdentifyToken = NULL ;

					t_Result = Begin_Interface (

						t_ServerInterface ,
						t_InterfaceIdentifier ,
						t_ProxyIndex ,
						t_InternalServerInterface ,
						t_InternalInterfaceIdentifier ,
						t_InternalProxyIndex ,
						m_ProcessIdentifier ,
						t_IdentifyToken ,
						t_Impersonating ,
						t_OldContext ,
						t_OldSecurity ,
						t_IsProxy ,
						t_Interface ,
						t_Revert ,
						t_Proxy
					) ;

					if ( SUCCEEDED ( t_Result ) )
					{
						if ( t_IdentifyToken )
						{
							BSTR t_ObjectPath = SysAllocString ( a_ObjectPath ) ;
							if ( t_ObjectPath )
							{
								WmiInternalContext t_InternalContext ;
								t_InternalContext.m_IdentifyHandle = ( unsigned __int64 ) t_IdentifyToken ;
								t_InternalContext.m_ProcessIdentifier = GetCurrentProcessId () ;

								t_Result = ( ( Internal_IWbemServices * ) t_Interface )->Internal_GetObjectAsync (

									t_InternalContext ,
									t_ObjectPath, 
									a_Flags, 
									a_Context ,
									t_Sink
								) ;

								SysFreeString ( t_ObjectPath ) ;
							}
							else
							{
								t_Result = WBEM_E_OUT_OF_MEMORY ;
							}
						}
						else
						{
							t_Result = ( ( IWbemServices * ) t_Interface )->GetObjectAsync (

								a_ObjectPath, 
								a_Flags, 
								a_Context ,
								t_Sink
							) ;
						}

						End_Interface (

							t_ServerInterface ,
							t_InterfaceIdentifier ,
							t_ProxyIndex ,
							t_InternalServerInterface ,
							t_InternalInterfaceIdentifier ,
							t_InternalProxyIndex ,
							m_ProcessIdentifier ,
							t_IdentifyToken ,
							t_Impersonating ,
							t_OldContext ,
							t_OldSecurity ,
							t_IsProxy ,
							t_Interface ,
							t_Revert ,
							t_Proxy
						) ;
					}
				}
				else
				{
					UnLock () ;

					t_Result = WBEM_E_OUT_OF_MEMORY ;
				}
			}

			if ( FAILED ( t_Result ) )
			{
				t_Sink->SetStatus ( 0 , t_Result , NULL , NULL ) ;
			}

			t_Sink->Release () ;
		}
		else
		{
			t_Result = WBEM_E_OUT_OF_MEMORY ;
			a_Sink->SetStatus ( 0 , t_Result , NULL , NULL ) ;
		}
	}
	else
	{
		a_Sink->SetStatus ( 0 , t_Result , NULL , NULL ) ;
	}

	if ( FAILED ( t_Result ) )
	{
		if ( ( HRESULT_ERROR_FUNC(t_Result) == HRESULT_ERROR_SERVER_UNAVAILABLE ) || ( HRESULT_ERROR_FUNC(t_Result) == HRESULT_ERROR_CALL_FAILED_DNE ) || ( t_Result == RPC_E_DISCONNECTED ))
		{
			AbnormalShutdown () ;
		}
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_IWbemDecoupledProvider :: PutClass ( 
		
	IWbemClassObject *a_Object ,
	long a_Flags , 
	IWbemContext *a_Context ,
	IWbemCallResult **a_CallResult
) 
{
	return WBEM_E_NOT_AVAILABLE ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_IWbemDecoupledProvider :: PutClassAsync ( 
		
	IWbemClassObject *a_Object , 
	long a_Flags ,
	IWbemContext FAR *a_Context ,
	IWbemObjectSink *a_Sink
) 
{
	if ( m_Initialized == 0 )
	{
		if ( WBEM_FLAG_ADVISORY & a_Flags )
		{
			a_Sink->SetStatus ( 0 , S_OK , NULL , NULL ) ;

			return S_OK ;
		}
		else
		{
			a_Sink->SetStatus ( 0 , WBEM_E_NOT_FOUND , NULL , NULL ) ;

			return WBEM_E_NOT_FOUND ;
		}
	}

	HRESULT t_Result = WBEM_E_PROVIDER_NOT_CAPABLE ;

	if ( m_Provider_IWbemServices )
	{
		CInterceptor_IWbemObjectSink *t_Sink = new CInterceptor_IWbemObjectSink (

			a_Sink , 
			( IWbemServices * ) this , 
			( CWbemGlobal_IWmiObjectSinkController * ) this
		) ;

		if ( t_Sink )
		{
			t_Sink->AddRef () ;

			t_Result = t_Sink->Initialize ( GetSD() ) ;
			if ( SUCCEEDED ( t_Result ) ) 
			{
				CWbemGlobal_IWmiObjectSinkController_Container_Iterator t_Iterator ;

				Lock () ;

				WmiStatusCode t_StatusCode = Insert ( 

					*t_Sink ,
					t_Iterator
				) ;

				if ( t_StatusCode == e_StatusCode_Success ) 
				{
					UnLock () ;

					IUnknown *t_ServerInterface = m_Provider_IWbemServices ;
					REFIID t_InterfaceIdentifier = IID_IWbemServices ;
					DWORD t_ProxyIndex = ProxyIndex_IWbemServices ;
					IUnknown *t_InternalServerInterface = m_Provider_Internal_IWbemServices ;
					REFIID t_InternalInterfaceIdentifier = IID_Internal_IWbemServices ;
					DWORD t_InternalProxyIndex = ProxyIndex_Internal_IWbemServices ;
					BOOL t_Impersonating ;
					IUnknown *t_OldContext ;
					IServerSecurity *t_OldSecurity ;
					BOOL t_IsProxy ;
					IUnknown *t_Interface ;
					BOOL t_Revert ;
					IUnknown *t_Proxy ;
					HANDLE t_IdentifyToken = NULL ;

					t_Result = Begin_Interface (

						t_ServerInterface ,
						t_InterfaceIdentifier ,
						t_ProxyIndex ,
						t_InternalServerInterface ,
						t_InternalInterfaceIdentifier ,
						t_InternalProxyIndex ,
						m_ProcessIdentifier ,
						t_IdentifyToken ,
						t_Impersonating ,
						t_OldContext ,
						t_OldSecurity ,
						t_IsProxy ,
						t_Interface ,
						t_Revert ,
						t_Proxy
					) ;

					if ( SUCCEEDED ( t_Result ) )
					{
						if ( t_IdentifyToken )
						{
							WmiInternalContext t_InternalContext ;
							t_InternalContext.m_IdentifyHandle = ( unsigned __int64 ) t_IdentifyToken ;
							t_InternalContext.m_ProcessIdentifier = GetCurrentProcessId () ;

							t_Result = ( ( Internal_IWbemServices * ) t_Interface )->Internal_PutClassAsync (

								t_InternalContext ,
								a_Object , 
								a_Flags, 
								a_Context ,
								t_Sink
							) ;
						}
						else
						{
							t_Result = ( ( IWbemServices * ) t_Interface )->PutClassAsync (

								a_Object , 
								a_Flags, 
								a_Context ,
								t_Sink
							) ;
						}

						End_Interface (

							t_ServerInterface ,
							t_InterfaceIdentifier ,
							t_ProxyIndex ,
							t_InternalServerInterface ,
							t_InternalInterfaceIdentifier ,
							t_InternalProxyIndex ,
							m_ProcessIdentifier ,
							t_IdentifyToken ,
							t_Impersonating ,
							t_OldContext ,
							t_OldSecurity ,
							t_IsProxy ,
							t_Interface ,
							t_Revert ,
							t_Proxy
						) ;
					}
				}
				else
				{
					UnLock () ;

					t_Result = WBEM_E_OUT_OF_MEMORY ;
				}
			}

			if ( FAILED ( t_Result ) )
			{
				t_Sink->SetStatus ( 0 , t_Result , NULL , NULL ) ;
			}

			t_Sink->Release () ;
		}
		else
		{
			t_Result = WBEM_E_OUT_OF_MEMORY ;
			a_Sink->SetStatus ( 0 , t_Result , NULL , NULL ) ;
		}
	}
	else
	{
		a_Sink->SetStatus ( 0 , t_Result , NULL , NULL ) ;
	}

	if ( FAILED ( t_Result ) )
	{
		if ( ( HRESULT_ERROR_FUNC(t_Result) == HRESULT_ERROR_SERVER_UNAVAILABLE ) || ( HRESULT_ERROR_FUNC(t_Result) == HRESULT_ERROR_CALL_FAILED_DNE ) || ( t_Result == RPC_E_DISCONNECTED ))
		{
			AbnormalShutdown () ;
		}
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_IWbemDecoupledProvider :: DeleteClass ( 
		
	const BSTR a_Class , 
	long a_Flags , 
	IWbemContext *a_Context ,
	IWbemCallResult **a_CallResult
) 
{
 	 return WBEM_E_NOT_AVAILABLE ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_IWbemDecoupledProvider :: DeleteClassAsync ( 
		
	const BSTR a_Class ,
	long a_Flags,
	IWbemContext *a_Context ,
	IWbemObjectSink *a_Sink
) 
{
	if ( m_Initialized == 0 )
	{
		if ( WBEM_FLAG_ADVISORY & a_Flags )
		{
			a_Sink->SetStatus ( 0 , S_OK , NULL , NULL ) ;

			return S_OK ;
		}
		else
		{
			a_Sink->SetStatus ( 0 , WBEM_E_NOT_FOUND , NULL , NULL ) ;

			return WBEM_E_NOT_FOUND ;
		}
	}

	HRESULT t_Result = WBEM_E_PROVIDER_NOT_CAPABLE ;

	if ( m_Provider_IWbemServices )
	{
		CInterceptor_IWbemObjectSink *t_Sink = new CInterceptor_IWbemObjectSink (

			a_Sink , 
			( IWbemServices * ) this , 
			( CWbemGlobal_IWmiObjectSinkController * ) this
		) ;

		if ( t_Sink )
		{
			t_Sink->AddRef () ;

			t_Result = t_Sink->Initialize ( GetSD() ) ;
			if ( SUCCEEDED ( t_Result ) ) 
			{
				CWbemGlobal_IWmiObjectSinkController_Container_Iterator t_Iterator ;

				Lock () ;

				WmiStatusCode t_StatusCode = Insert ( 

					*t_Sink ,
					t_Iterator
				) ;

				if ( t_StatusCode == e_StatusCode_Success ) 
				{
					UnLock () ;

					IUnknown *t_ServerInterface = m_Provider_IWbemServices ;
					REFIID t_InterfaceIdentifier = IID_IWbemServices ;
					DWORD t_ProxyIndex = ProxyIndex_IWbemServices ;
					IUnknown *t_InternalServerInterface = m_Provider_Internal_IWbemServices ;
					REFIID t_InternalInterfaceIdentifier = IID_Internal_IWbemServices ;
					DWORD t_InternalProxyIndex = ProxyIndex_Internal_IWbemServices ;
					BOOL t_Impersonating ;
					IUnknown *t_OldContext ;
					IServerSecurity *t_OldSecurity ;
					BOOL t_IsProxy ;
					IUnknown *t_Interface ;
					BOOL t_Revert ;
					IUnknown *t_Proxy ;
					HANDLE t_IdentifyToken = NULL ;

					t_Result = Begin_Interface (

						t_ServerInterface ,
						t_InterfaceIdentifier ,
						t_ProxyIndex ,
						t_InternalServerInterface ,
						t_InternalInterfaceIdentifier ,
						t_InternalProxyIndex ,
						m_ProcessIdentifier ,
						t_IdentifyToken ,
						t_Impersonating ,
						t_OldContext ,
						t_OldSecurity ,
						t_IsProxy ,
						t_Interface ,
						t_Revert ,
						t_Proxy
					) ;

					if ( SUCCEEDED ( t_Result ) )
					{
						if ( t_IdentifyToken )
						{
							BSTR t_Class = SysAllocString ( a_Class ) ;
							if ( t_Class ) 
							{
								WmiInternalContext t_InternalContext ;
								t_InternalContext.m_IdentifyHandle = ( unsigned __int64 ) t_IdentifyToken ;
								t_InternalContext.m_ProcessIdentifier = GetCurrentProcessId () ;

								t_Result = ( ( Internal_IWbemServices * ) t_Interface )->Internal_DeleteClassAsync (

									t_InternalContext ,
									t_Class , 
									a_Flags, 
									a_Context ,
									t_Sink
								) ;

								SysFreeString ( t_Class ) ;
							}
							else
							{
								t_Result = WBEM_E_OUT_OF_MEMORY ;
							}
						}
						else
						{
							t_Result = ( ( IWbemServices * ) t_Interface )->DeleteClassAsync (

								a_Class , 
								a_Flags, 
								a_Context ,
								t_Sink
							) ;
						}

						End_Interface (

							t_ServerInterface ,
							t_InterfaceIdentifier ,
							t_ProxyIndex ,
							t_InternalServerInterface ,
							t_InternalInterfaceIdentifier ,
							t_InternalProxyIndex ,
							m_ProcessIdentifier ,
							t_IdentifyToken ,
							t_Impersonating ,
							t_OldContext ,
							t_OldSecurity ,
							t_IsProxy ,
							t_Interface ,
							t_Revert ,
							t_Proxy
						) ;
					}
				}
				else
				{
					UnLock () ;

					t_Result = WBEM_E_OUT_OF_MEMORY ;
				}
			}

			if ( FAILED ( t_Result ) )
			{
				t_Sink->SetStatus ( 0 , t_Result , NULL , NULL ) ;
			}

			t_Sink->Release () ;
		}
		else
		{
			t_Result = WBEM_E_OUT_OF_MEMORY ;
			a_Sink->SetStatus ( 0 , t_Result , NULL , NULL ) ;
		}
	}
	else
	{
		a_Sink->SetStatus ( 0 , t_Result , NULL , NULL ) ;
	}

	if ( FAILED ( t_Result ) )
	{
		if ( ( HRESULT_ERROR_FUNC(t_Result) == HRESULT_ERROR_SERVER_UNAVAILABLE ) || ( HRESULT_ERROR_FUNC(t_Result) == HRESULT_ERROR_CALL_FAILED_DNE ) || ( t_Result == RPC_E_DISCONNECTED ))
		{
			AbnormalShutdown () ;
		}
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_IWbemDecoupledProvider :: CreateClassEnum ( 

	const BSTR a_Superclass ,
	long a_Flags, 
	IWbemContext *a_Context ,
	IEnumWbemClassObject **a_Enum
) 
{
	return WBEM_E_NOT_AVAILABLE ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

SCODE CInterceptor_IWbemDecoupledProvider :: CreateClassEnumAsync (

	const BSTR a_Superclass ,
	long a_Flags ,
	IWbemContext *a_Context ,
	IWbemObjectSink *a_Sink
) 
{
	if ( m_Initialized == 0 )
	{
		a_Sink->SetStatus ( 0 , S_OK , NULL , NULL ) ;

		return S_OK ;
	}

	HRESULT t_Result = WBEM_E_PROVIDER_NOT_CAPABLE ;

	if ( m_Provider_IWbemServices )
	{
		CInterceptor_IWbemObjectSink *t_Sink = new CInterceptor_IWbemObjectSink (

			a_Sink , 
			( IWbemServices * ) this , 
			( CWbemGlobal_IWmiObjectSinkController * ) this
		) ;

		if ( t_Sink )
		{
			t_Sink->AddRef () ;

			t_Result = t_Sink->Initialize ( GetSD() ) ;
			if ( SUCCEEDED ( t_Result ) ) 
			{
				CWbemGlobal_IWmiObjectSinkController_Container_Iterator t_Iterator ;

				Lock () ;

				WmiStatusCode t_StatusCode = Insert ( 

					*t_Sink ,
					t_Iterator
				) ;

				if ( t_StatusCode == e_StatusCode_Success ) 
				{
					UnLock () ;

					IUnknown *t_ServerInterface = m_Provider_IWbemServices ;
					REFIID t_InterfaceIdentifier = IID_IWbemServices ;
					DWORD t_ProxyIndex = ProxyIndex_IWbemServices ;
					IUnknown *t_InternalServerInterface = m_Provider_Internal_IWbemServices ;
					REFIID t_InternalInterfaceIdentifier = IID_Internal_IWbemServices ;
					DWORD t_InternalProxyIndex = ProxyIndex_Internal_IWbemServices ;
					BOOL t_Impersonating ;
					IUnknown *t_OldContext ;
					IServerSecurity *t_OldSecurity ;
					BOOL t_IsProxy ;
					IUnknown *t_Interface ;
					BOOL t_Revert ;
					IUnknown *t_Proxy ;
					HANDLE t_IdentifyToken = NULL ;

					t_Result = Begin_Interface (

						t_ServerInterface ,
						t_InterfaceIdentifier ,
						t_ProxyIndex ,
						t_InternalServerInterface ,
						t_InternalInterfaceIdentifier ,
						t_InternalProxyIndex ,
						m_ProcessIdentifier ,
						t_IdentifyToken ,
						t_Impersonating ,
						t_OldContext ,
						t_OldSecurity ,
						t_IsProxy ,
						t_Interface ,
						t_Revert ,
						t_Proxy
					) ;

					if ( SUCCEEDED ( t_Result ) )
					{
						if ( t_IdentifyToken )
						{
							BSTR t_Superclass = SysAllocString ( a_Superclass ) ;
							if ( t_Superclass ) 
							{
								WmiInternalContext t_InternalContext ;
								t_InternalContext.m_IdentifyHandle = ( unsigned __int64 ) t_IdentifyToken ;
								t_InternalContext.m_ProcessIdentifier = GetCurrentProcessId () ;

								t_Result = ( ( Internal_IWbemServices * ) t_Interface )->Internal_CreateClassEnumAsync  (

									t_InternalContext ,
									t_Superclass , 
									a_Flags, 
									a_Context ,
									t_Sink
								) ;

								SysFreeString ( t_Superclass ) ;
							}
							else
							{
								t_Result = WBEM_E_OUT_OF_MEMORY ;
							}
						}
						else
						{
							t_Result = ( ( IWbemServices * ) t_Interface )->CreateClassEnumAsync  (

								a_Superclass , 
								a_Flags, 
								a_Context ,
								t_Sink
							) ;
						}

						End_Interface (

							t_ServerInterface ,
							t_InterfaceIdentifier ,
							t_ProxyIndex ,
							t_InternalServerInterface ,
							t_InternalInterfaceIdentifier ,
							t_InternalProxyIndex ,
							m_ProcessIdentifier ,
							t_IdentifyToken ,
							t_Impersonating ,
							t_OldContext ,
							t_OldSecurity ,
							t_IsProxy ,
							t_Interface ,
							t_Revert ,
							t_Proxy
						) ;
					}
				}
				else
				{
					UnLock () ;

					t_Result = WBEM_E_OUT_OF_MEMORY ;
				}
			}

			if ( FAILED ( t_Result ) )
			{
				t_Sink->SetStatus ( 0 , t_Result , NULL , NULL ) ;
			}

			t_Sink->Release () ;
		}
		else
		{
			t_Result = WBEM_E_OUT_OF_MEMORY ;
			a_Sink->SetStatus ( 0 , t_Result , NULL , NULL ) ;
		}
	}
	else
	{
		a_Sink->SetStatus ( 0 , t_Result , NULL , NULL ) ;
	}

	if ( FAILED ( t_Result ) )
	{
		if ( ( HRESULT_ERROR_FUNC(t_Result) == HRESULT_ERROR_SERVER_UNAVAILABLE ) || ( HRESULT_ERROR_FUNC(t_Result) == HRESULT_ERROR_CALL_FAILED_DNE ) || ( t_Result == RPC_E_DISCONNECTED ))
		{
			AbnormalShutdown () ;
		}
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_IWbemDecoupledProvider :: PutInstance (

    IWbemClassObject *a_Instance ,
    long a_Flags ,
    IWbemContext *a_Context ,
	IWbemCallResult **a_CallResult
) 
{
	return WBEM_E_NOT_AVAILABLE ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_IWbemDecoupledProvider :: PutInstanceAsync ( 
		
	IWbemClassObject *a_Instance , 
	long a_Flags ,
    IWbemContext *a_Context ,
	IWbemObjectSink *a_Sink
) 
{
	if ( m_Initialized == 0 )
	{
		if ( WBEM_FLAG_ADVISORY & a_Flags )
		{
			a_Sink->SetStatus ( 0 , S_OK , NULL , NULL ) ;

			return S_OK ;
		}
		else
		{
			a_Sink->SetStatus ( 0 , WBEM_E_NOT_FOUND , NULL , NULL ) ;

			return WBEM_E_NOT_FOUND ;
		}
	}

	HRESULT t_Result = WBEM_E_PROVIDER_NOT_CAPABLE ;

	if ( m_Provider_IWbemServices )
	{
		CInterceptor_IWbemObjectSink *t_Sink = new CInterceptor_IWbemObjectSink (

			a_Sink , 
			( IWbemServices * ) this , 
			( CWbemGlobal_IWmiObjectSinkController * ) this
		) ;

		if ( t_Sink )
		{
			t_Sink->AddRef () ;

			t_Result = t_Sink->Initialize ( GetSD() ) ;
			if ( SUCCEEDED ( t_Result ) ) 
			{
				CWbemGlobal_IWmiObjectSinkController_Container_Iterator t_Iterator ;

				Lock () ;

				WmiStatusCode t_StatusCode = Insert ( 

					*t_Sink ,
					t_Iterator
				) ;

				if ( t_StatusCode == e_StatusCode_Success ) 
				{
					UnLock () ;

					IUnknown *t_ServerInterface = m_Provider_IWbemServices ;
					REFIID t_InterfaceIdentifier = IID_IWbemServices ;
					DWORD t_ProxyIndex = ProxyIndex_IWbemServices ;
					IUnknown *t_InternalServerInterface = m_Provider_Internal_IWbemServices ;
					REFIID t_InternalInterfaceIdentifier = IID_Internal_IWbemServices ;
					DWORD t_InternalProxyIndex = ProxyIndex_Internal_IWbemServices ;
					BOOL t_Impersonating ;
					IUnknown *t_OldContext ;
					IServerSecurity *t_OldSecurity ;
					BOOL t_IsProxy ;
					IUnknown *t_Interface ;
					BOOL t_Revert ;
					IUnknown *t_Proxy ;
					HANDLE t_IdentifyToken = NULL ;

					t_Result = Begin_Interface (

						t_ServerInterface ,
						t_InterfaceIdentifier ,
						t_ProxyIndex ,
						t_InternalServerInterface ,
						t_InternalInterfaceIdentifier ,
						t_InternalProxyIndex ,
						m_ProcessIdentifier ,
						t_IdentifyToken ,
						t_Impersonating ,
						t_OldContext ,
						t_OldSecurity ,
						t_IsProxy ,
						t_Interface ,
						t_Revert ,
						t_Proxy
					) ;

					if ( SUCCEEDED ( t_Result ) )
					{
						if ( t_IdentifyToken )
						{
							WmiInternalContext t_InternalContext ;
							t_InternalContext.m_IdentifyHandle = ( unsigned __int64 ) t_IdentifyToken ;
							t_InternalContext.m_ProcessIdentifier = GetCurrentProcessId () ;

							t_Result = ( ( Internal_IWbemServices * ) t_Interface )->Internal_PutInstanceAsync (

								t_InternalContext ,
								a_Instance , 
								a_Flags, 
								a_Context ,
								t_Sink
							) ;
						}
						else
						{
							t_Result = ( ( IWbemServices * ) t_Interface )->PutInstanceAsync (

								a_Instance , 
								a_Flags, 
								a_Context ,
								t_Sink
							) ;
						}

						End_Interface (

							t_ServerInterface ,
							t_InterfaceIdentifier ,
							t_ProxyIndex ,
							t_InternalServerInterface ,
							t_InternalInterfaceIdentifier ,
							t_InternalProxyIndex ,
							m_ProcessIdentifier ,
							t_IdentifyToken ,
							t_Impersonating ,
							t_OldContext ,
							t_OldSecurity ,
							t_IsProxy ,
							t_Interface ,
							t_Revert ,
							t_Proxy
						) ;
					}
				}
				else
				{
					UnLock () ;

					t_Result = WBEM_E_OUT_OF_MEMORY ;
				}
			}

			if ( FAILED ( t_Result ) )
			{
				t_Sink->SetStatus ( 0 , t_Result , NULL , NULL ) ;
			}

			t_Sink->Release () ;
		}
		else
		{
			t_Result = WBEM_E_OUT_OF_MEMORY ;
			a_Sink->SetStatus ( 0 , t_Result , NULL , NULL ) ;
		}
	}
	else
	{
		a_Sink->SetStatus ( 0 , t_Result , NULL , NULL ) ;
	}

	if ( FAILED ( t_Result ) )
	{
		if ( ( HRESULT_ERROR_FUNC(t_Result) == HRESULT_ERROR_SERVER_UNAVAILABLE ) || ( HRESULT_ERROR_FUNC(t_Result) == HRESULT_ERROR_CALL_FAILED_DNE ) || ( t_Result == RPC_E_DISCONNECTED ))
		{
			AbnormalShutdown () ;
		}
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_IWbemDecoupledProvider :: DeleteInstance ( 

	const BSTR a_ObjectPath ,
    long a_Flags ,
    IWbemContext *a_Context ,
    IWbemCallResult **a_CallResult
)
{
	return WBEM_E_NOT_AVAILABLE ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/
        
HRESULT CInterceptor_IWbemDecoupledProvider :: DeleteInstanceAsync (
 
	const BSTR a_ObjectPath ,
    long a_Flags ,
    IWbemContext *a_Context ,
    IWbemObjectSink *a_Sink	
)
{
	if ( m_Initialized == 0 )
	{
		if ( WBEM_FLAG_ADVISORY & a_Flags )
		{
			a_Sink->SetStatus ( 0 , S_OK , NULL , NULL ) ;

			return S_OK ;
		}
		else
		{
			a_Sink->SetStatus ( 0 , WBEM_E_NOT_FOUND , NULL , NULL ) ;

			return WBEM_E_NOT_FOUND ;
		}
	}

	HRESULT t_Result = WBEM_E_PROVIDER_NOT_CAPABLE ;

	if ( m_Provider_IWbemServices )
	{
		CInterceptor_IWbemObjectSink *t_Sink = new CInterceptor_IWbemObjectSink (

			a_Sink , 
			( IWbemServices * ) this , 
			( CWbemGlobal_IWmiObjectSinkController * ) this
		) ;

		if ( t_Sink )
		{
			t_Sink->AddRef () ;

			t_Result = t_Sink->Initialize ( GetSD() ) ;
			if ( SUCCEEDED ( t_Result ) ) 
			{
				CWbemGlobal_IWmiObjectSinkController_Container_Iterator t_Iterator ;

				Lock () ;

				WmiStatusCode t_StatusCode = Insert ( 

					*t_Sink ,
					t_Iterator
				) ;

				if ( t_StatusCode == e_StatusCode_Success ) 
				{
					UnLock () ;

					IUnknown *t_ServerInterface = m_Provider_IWbemServices ;
					REFIID t_InterfaceIdentifier = IID_IWbemServices ;
					DWORD t_ProxyIndex = ProxyIndex_IWbemServices ;
					IUnknown *t_InternalServerInterface = m_Provider_Internal_IWbemServices ;
					REFIID t_InternalInterfaceIdentifier = IID_Internal_IWbemServices ;
					DWORD t_InternalProxyIndex = ProxyIndex_Internal_IWbemServices ;
					BOOL t_Impersonating ;
					IUnknown *t_OldContext ;
					IServerSecurity *t_OldSecurity ;
					BOOL t_IsProxy ;
					IUnknown *t_Interface ;
					BOOL t_Revert ;
					IUnknown *t_Proxy ;
					HANDLE t_IdentifyToken = NULL ;

					t_Result = Begin_Interface (

						t_ServerInterface ,
						t_InterfaceIdentifier ,
						t_ProxyIndex ,
						t_InternalServerInterface ,
						t_InternalInterfaceIdentifier ,
						t_InternalProxyIndex ,
						m_ProcessIdentifier ,
						t_IdentifyToken ,
						t_Impersonating ,
						t_OldContext ,
						t_OldSecurity ,
						t_IsProxy ,
						t_Interface ,
						t_Revert ,
						t_Proxy
					) ;

					if ( SUCCEEDED ( t_Result ) )
					{
						if ( t_IdentifyToken )
						{
							BSTR t_ObjectPath = SysAllocString ( a_ObjectPath ) ;
							if ( t_ObjectPath ) 
							{
								WmiInternalContext t_InternalContext ;
								t_InternalContext.m_IdentifyHandle = ( unsigned __int64 ) t_IdentifyToken ;
								t_InternalContext.m_ProcessIdentifier = GetCurrentProcessId () ;

								t_Result = ( ( Internal_IWbemServices * ) t_Interface )->Internal_DeleteInstanceAsync  (

									t_InternalContext ,
									t_ObjectPath ,
									a_Flags ,
									a_Context ,
									t_Sink
								) ;

								SysFreeString ( t_ObjectPath ) ;
							}
							else
							{
								t_Result = WBEM_E_OUT_OF_MEMORY ;
							}
						}
						else
						{
							t_Result = ( ( IWbemServices * ) t_Interface )->DeleteInstanceAsync  (

								a_ObjectPath ,
								a_Flags ,
								a_Context ,
								t_Sink
							) ;
						}

						End_Interface (

							t_ServerInterface ,
							t_InterfaceIdentifier ,
							t_ProxyIndex ,
							t_InternalServerInterface ,
							t_InternalInterfaceIdentifier ,
							t_InternalProxyIndex ,
							m_ProcessIdentifier ,
							t_IdentifyToken ,
							t_Impersonating ,
							t_OldContext ,
							t_OldSecurity ,
							t_IsProxy ,
							t_Interface ,
							t_Revert ,
							t_Proxy
						) ;
					}
				}
				else
				{
					UnLock () ;

					t_Result = WBEM_E_OUT_OF_MEMORY ;
				}
			}

			if ( FAILED ( t_Result ) )
			{
				t_Sink->SetStatus ( 0 , t_Result , NULL , NULL ) ;
			}

			t_Sink->Release () ;
		}
		else
		{
			t_Result = WBEM_E_OUT_OF_MEMORY ;
			a_Sink->SetStatus ( 0 , t_Result , NULL , NULL ) ;
		}
	}
	else
	{
		a_Sink->SetStatus ( 0 , t_Result , NULL , NULL ) ;
	}

	if ( FAILED ( t_Result ) )
	{
		if ( ( HRESULT_ERROR_FUNC(t_Result) == HRESULT_ERROR_SERVER_UNAVAILABLE ) || ( HRESULT_ERROR_FUNC(t_Result) == HRESULT_ERROR_CALL_FAILED_DNE ) || ( t_Result == RPC_E_DISCONNECTED ))
		{
			AbnormalShutdown () ;
		}
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_IWbemDecoupledProvider :: CreateInstanceEnum ( 

	const BSTR a_Class ,
	long a_Flags , 
	IWbemContext *a_Context , 
	IEnumWbemClassObject **a_Enum
)
{
	return WBEM_E_NOT_AVAILABLE ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_IWbemDecoupledProvider :: CreateInstanceEnumAsync (

 	const BSTR a_Class ,
	long a_Flags ,
	IWbemContext *a_Context ,
	IWbemObjectSink *a_Sink

) 
{
	if ( m_Initialized == 0 )
	{
		a_Sink->SetStatus ( 0 , S_OK , NULL , NULL ) ;

		return S_OK ;
	}

	HRESULT t_Result = WBEM_E_PROVIDER_NOT_CAPABLE ;

	if ( m_Provider_IWbemServices )
	{
		CInterceptor_IWbemObjectSink *t_Sink = new CInterceptor_IWbemObjectSink (

			a_Sink , 
			( IWbemServices * ) this , 
			( CWbemGlobal_IWmiObjectSinkController * ) this
		) ;

		if ( t_Sink )
		{
			t_Sink->AddRef () ;

			t_Result = t_Sink->Initialize ( GetSD() ) ;
			if ( SUCCEEDED ( t_Result ) ) 
			{
				CWbemGlobal_IWmiObjectSinkController_Container_Iterator t_Iterator ;

				Lock () ;

				WmiStatusCode t_StatusCode = Insert ( 

					*t_Sink ,
					t_Iterator
				) ;

				if ( t_StatusCode == e_StatusCode_Success ) 
				{
					UnLock () ;

					IUnknown *t_ServerInterface = m_Provider_IWbemServices ;
					REFIID t_InterfaceIdentifier = IID_IWbemServices ;
					DWORD t_ProxyIndex = ProxyIndex_IWbemServices ;
					IUnknown *t_InternalServerInterface = m_Provider_Internal_IWbemServices ;
					REFIID t_InternalInterfaceIdentifier = IID_Internal_IWbemServices ;
					DWORD t_InternalProxyIndex = ProxyIndex_Internal_IWbemServices ;
					BOOL t_Impersonating ;
					IUnknown *t_OldContext ;
					IServerSecurity *t_OldSecurity ;
					BOOL t_IsProxy ;
					IUnknown *t_Interface ;
					BOOL t_Revert ;
					IUnknown *t_Proxy ;
					HANDLE t_IdentifyToken = NULL ;

					t_Result = Begin_Interface (

						t_ServerInterface ,
						t_InterfaceIdentifier ,
						t_ProxyIndex ,
						t_InternalServerInterface ,
						t_InternalInterfaceIdentifier ,
						t_InternalProxyIndex ,
						m_ProcessIdentifier ,
						t_IdentifyToken ,
						t_Impersonating ,
						t_OldContext ,
						t_OldSecurity ,
						t_IsProxy ,
						t_Interface ,
						t_Revert ,
						t_Proxy 
					) ;

					if ( SUCCEEDED ( t_Result ) )
					{
						if ( t_IdentifyToken )
						{
							WmiInternalContext t_InternalContext ;
							t_InternalContext.m_IdentifyHandle = ( unsigned __int64 ) t_IdentifyToken ;
							t_InternalContext.m_ProcessIdentifier = GetCurrentProcessId () ;

							BSTR t_Class = SysAllocString ( a_Class ) ;
							if ( t_Class )
							{
								t_Result = ( ( Internal_IWbemServices * ) t_Interface )->Internal_CreateInstanceEnumAsync (

									t_InternalContext ,
 									t_Class ,
									a_Flags ,
									a_Context ,
									t_Sink 
								) ;

								SysFreeString ( t_Class ) ;
							}
							else
							{
								t_Result = WBEM_E_OUT_OF_MEMORY ;
							}
						}
						else
						{

							t_Result = ( ( IWbemServices * ) t_Interface )->CreateInstanceEnumAsync (

 								a_Class ,
								a_Flags ,
								a_Context ,
								t_Sink 
							) ;
						}

						End_Interface (

							t_ServerInterface ,
							t_InterfaceIdentifier ,
							t_ProxyIndex ,
							t_InternalServerInterface ,
							t_InternalInterfaceIdentifier ,
							t_InternalProxyIndex ,
							m_ProcessIdentifier ,
							t_IdentifyToken ,
							t_Impersonating ,
							t_OldContext ,
							t_OldSecurity ,
							t_IsProxy ,
							t_Interface ,
							t_Revert ,
							t_Proxy
						) ;
					}
				}
				else
				{
					UnLock () ;

					t_Result = WBEM_E_OUT_OF_MEMORY ;
				}
			}

			if ( FAILED ( t_Result ) )
			{
				t_Sink->SetStatus ( 0 , t_Result , NULL , NULL ) ;
			}

			t_Sink->Release () ;
		}
		else
		{
			t_Result = WBEM_E_OUT_OF_MEMORY ;
			a_Sink->SetStatus ( 0 , t_Result , NULL , NULL ) ;
		}
	}
	else
	{
		a_Sink->SetStatus ( 0 , t_Result , NULL , NULL ) ;
	}

	if ( FAILED ( t_Result ) )
	{
		if ( ( HRESULT_ERROR_FUNC(t_Result) == HRESULT_ERROR_SERVER_UNAVAILABLE ) || ( HRESULT_ERROR_FUNC(t_Result) == HRESULT_ERROR_CALL_FAILED_DNE ) || ( t_Result == RPC_E_DISCONNECTED ))
		{
			AbnormalShutdown () ;
		}
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_IWbemDecoupledProvider :: ExecQuery ( 

	const BSTR a_QueryLanguage ,
	const BSTR a_Query ,
	long a_Flags ,
	IWbemContext *a_Context ,
	IEnumWbemClassObject **a_Enum
)
{
	return WBEM_E_NOT_AVAILABLE ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_IWbemDecoupledProvider :: ExecQueryAsync ( 
		
	const BSTR a_QueryLanguage ,
	const BSTR a_Query, 
	long a_Flags, 
	IWbemContext *a_Context ,
	IWbemObjectSink *a_Sink
) 
{
	if ( m_Initialized == 0 )
	{
		a_Sink->SetStatus ( 0 , S_OK , NULL , NULL ) ;

		return S_OK ;
	}

	HRESULT t_Result = WBEM_E_PROVIDER_NOT_CAPABLE ;

	if ( m_Provider_IWbemServices )
	{
		CInterceptor_IWbemFilteringObjectSink *t_Sink = new CInterceptor_IWbemFilteringObjectSink (

			a_Sink , 
			( IWbemServices * ) this , 
			( CWbemGlobal_IWmiObjectSinkController * ) this ,
			a_QueryLanguage ,
			a_Query 
		) ;

		if ( t_Sink )
		{
			t_Sink->AddRef () ;

			t_Result = t_Sink->Initialize ( GetSD() ) ;
			if ( SUCCEEDED ( t_Result ) ) 
			{
				CWbemGlobal_IWmiObjectSinkController_Container_Iterator t_Iterator ;

				Lock () ;

				WmiStatusCode t_StatusCode = Insert ( 

					*t_Sink ,
					t_Iterator
				) ;

				if ( t_StatusCode == e_StatusCode_Success ) 
				{
					UnLock () ;

					IUnknown *t_ServerInterface = m_Provider_IWbemServices ;
					REFIID t_InterfaceIdentifier = IID_IWbemServices ;
					DWORD t_ProxyIndex = ProxyIndex_IWbemServices ;
					IUnknown *t_InternalServerInterface = m_Provider_Internal_IWbemServices ;
					REFIID t_InternalInterfaceIdentifier = IID_Internal_IWbemServices ;
					DWORD t_InternalProxyIndex = ProxyIndex_Internal_IWbemServices ;
					BOOL t_Impersonating ;
					IUnknown *t_OldContext ;
					IServerSecurity *t_OldSecurity ;
					BOOL t_IsProxy ;
					IUnknown *t_Interface ;
					BOOL t_Revert ;
					IUnknown *t_Proxy ;
					HANDLE t_IdentifyToken = NULL ;

					t_Result = Begin_Interface (

						t_ServerInterface ,
						t_InterfaceIdentifier ,
						t_ProxyIndex ,
						t_InternalServerInterface ,
						t_InternalInterfaceIdentifier ,
						t_InternalProxyIndex ,
						m_ProcessIdentifier ,
						t_IdentifyToken ,
						t_Impersonating ,
						t_OldContext ,
						t_OldSecurity ,
						t_IsProxy ,
						t_Interface ,
						t_Revert ,
						t_Proxy
					) ;

					if ( SUCCEEDED ( t_Result ) )
					{
						if ( t_IdentifyToken )
						{
							BSTR t_QueryLanguage = SysAllocString ( a_QueryLanguage ) ;
							BSTR t_Query = SysAllocString ( a_Query ) ;

							if ( t_QueryLanguage && t_Query ) 
							{
								WmiInternalContext t_InternalContext ;
								t_InternalContext.m_IdentifyHandle = ( unsigned __int64 ) t_IdentifyToken ;
								t_InternalContext.m_ProcessIdentifier = GetCurrentProcessId () ;

								t_Result = ( ( Internal_IWbemServices * ) t_Interface )->Internal_ExecQueryAsync  (

									t_InternalContext ,
									t_QueryLanguage , 
									t_Query, 
									a_Flags, 
									a_Context ,
									t_Sink
								) ;
							}
							else
							{
								t_Result = WBEM_E_OUT_OF_MEMORY ;
							}

							SysFreeString ( t_QueryLanguage ) ;
							SysFreeString ( t_Query ) ;
						}
						else
						{
							t_Result = ( ( IWbemServices * ) t_Interface )->ExecQueryAsync  (

								a_QueryLanguage , 
								a_Query, 
								a_Flags, 
								a_Context ,
								t_Sink
							) ;
						}

						End_Interface (

							t_ServerInterface ,
							t_InterfaceIdentifier ,
							t_ProxyIndex ,
							t_InternalServerInterface ,
							t_InternalInterfaceIdentifier ,
							t_InternalProxyIndex ,
							m_ProcessIdentifier ,
							t_IdentifyToken ,
							t_Impersonating ,
							t_OldContext ,
							t_OldSecurity ,
							t_IsProxy ,
							t_Interface ,
							t_Revert ,
							t_Proxy
						) ;
					}
				}
				else
				{
					UnLock () ;

					t_Result = WBEM_E_OUT_OF_MEMORY ;
				}
			}
			
			if ( FAILED ( t_Result ) )
			{
				t_Sink->SetStatus ( 0 , t_Result , NULL , NULL ) ;
			}

			t_Sink->Release () ;
		}
		else
		{
			t_Result = WBEM_E_OUT_OF_MEMORY ;
			a_Sink->SetStatus ( 0 , t_Result , NULL , NULL ) ;
		}
	}
	else
	{
		a_Sink->SetStatus ( 0 , t_Result , NULL , NULL ) ;
	}

	if ( FAILED ( t_Result ) )
	{
		if ( ( HRESULT_ERROR_FUNC(t_Result) == HRESULT_ERROR_SERVER_UNAVAILABLE ) || ( HRESULT_ERROR_FUNC(t_Result) == HRESULT_ERROR_CALL_FAILED_DNE ) || ( t_Result == RPC_E_DISCONNECTED ))
		{
			AbnormalShutdown () ;
		}
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_IWbemDecoupledProvider :: ExecNotificationQuery ( 

	const BSTR a_QueryLanguage ,
    const BSTR a_Query ,
    long a_Flags ,
    IWbemContext *a_Context ,
    IEnumWbemClassObject **a_Enum
)
{
	return WBEM_E_NOT_AVAILABLE ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/
        
HRESULT CInterceptor_IWbemDecoupledProvider :: ExecNotificationQueryAsync ( 
            
	const BSTR a_QueryLanguage ,
    const BSTR a_Query ,
    long a_Flags ,
    IWbemContext *a_Context ,
    IWbemObjectSink *a_Sink 
)
{
	return WBEM_E_NOT_AVAILABLE ;
}       

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_IWbemDecoupledProvider :: ExecMethod (

	const BSTR a_ObjectPath ,
    const BSTR a_MethodName ,
    long a_Flags ,
    IWbemContext *a_Context ,
    IWbemClassObject *a_InParams ,
    IWbemClassObject **a_OutParams ,
    IWbemCallResult **a_CallResult
)
{
	return WBEM_E_NOT_AVAILABLE ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_IWbemDecoupledProvider :: ExecMethodAsync ( 

    const BSTR a_ObjectPath ,
    const BSTR a_MethodName ,
    long a_Flags ,
    IWbemContext *a_Context ,
    IWbemClassObject *a_InParams ,
	IWbemObjectSink *a_Sink
) 
{
	if ( m_Initialized == 0 )
	{
		a_Sink->SetStatus ( 0 , WBEM_E_NOT_FOUND , NULL , NULL ) ;

		return WBEM_E_NOT_FOUND ;
	}

	HRESULT t_Result = WBEM_E_NOT_AVAILABLE ;

	if ( m_Provider_IWbemServices )
	{
		CInterceptor_IWbemObjectSink *t_Sink = new CInterceptor_IWbemObjectSink (

			a_Sink , 
			( IWbemServices * ) this , 
			( CWbemGlobal_IWmiObjectSinkController * ) this
		) ;

		if ( t_Sink )
		{
			t_Sink->AddRef () ;

			t_Result = t_Sink->Initialize ( GetSD() ) ;
			if ( SUCCEEDED ( t_Result ) ) 
			{
				CWbemGlobal_IWmiObjectSinkController_Container_Iterator t_Iterator ;

				Lock () ;

				WmiStatusCode t_StatusCode = Insert ( 

					*t_Sink ,
					t_Iterator
				) ;

				if ( t_StatusCode == e_StatusCode_Success ) 
				{
					UnLock () ;

					IUnknown *t_ServerInterface = m_Provider_IWbemServices ;
					REFIID t_InterfaceIdentifier = IID_IWbemServices ;
					DWORD t_ProxyIndex = ProxyIndex_IWbemServices ;
					IUnknown *t_InternalServerInterface = m_Provider_Internal_IWbemServices ;
					REFIID t_InternalInterfaceIdentifier = IID_Internal_IWbemServices ;
					DWORD t_InternalProxyIndex = ProxyIndex_Internal_IWbemServices ;
					BOOL t_Impersonating ;
					IUnknown *t_OldContext ;
					IServerSecurity *t_OldSecurity ;
					BOOL t_IsProxy ;
					IUnknown *t_Interface ;
					BOOL t_Revert ;
					IUnknown *t_Proxy ;
					HANDLE t_IdentifyToken = NULL ;

					t_Result = Begin_Interface (

						t_ServerInterface ,
						t_InterfaceIdentifier ,
						t_ProxyIndex ,
						t_InternalServerInterface ,
						t_InternalInterfaceIdentifier ,
						t_InternalProxyIndex ,
						m_ProcessIdentifier ,
						t_IdentifyToken ,
						t_Impersonating ,
						t_OldContext ,
						t_OldSecurity ,
						t_IsProxy ,
						t_Interface ,
						t_Revert ,
						t_Proxy ,
						a_Context
					) ;

					if ( SUCCEEDED ( t_Result ) )
					{
						if ( t_IdentifyToken )
						{
							BSTR t_ObjectPath = SysAllocString ( a_ObjectPath ) ;
							BSTR t_MethodName = SysAllocString ( a_MethodName ) ;

							if ( t_ObjectPath && t_MethodName ) 
							{
								WmiInternalContext t_InternalContext ;
								t_InternalContext.m_IdentifyHandle = ( unsigned __int64 ) t_IdentifyToken ;
								t_InternalContext.m_ProcessIdentifier = GetCurrentProcessId () ;

								t_Result = ( ( Internal_IWbemServices * ) t_Interface )->Internal_ExecMethodAsync  (

									t_InternalContext ,
									t_ObjectPath ,
									t_MethodName ,
									a_Flags ,
									a_Context ,
									a_InParams ,
									t_Sink
								) ;
							}
							else
							{
								t_Result = WBEM_E_OUT_OF_MEMORY ;
							}

							SysFreeString ( t_ObjectPath ) ;
							SysFreeString ( t_MethodName ) ;
						}
						else
						{
							t_Result = ( ( IWbemServices * ) t_Interface )->ExecMethodAsync  (

								a_ObjectPath ,
								a_MethodName ,
								a_Flags ,
								a_Context ,
								a_InParams ,
								t_Sink
							) ;
						}

						End_Interface (

							t_ServerInterface ,
							t_InterfaceIdentifier ,
							t_ProxyIndex ,
							t_InternalServerInterface ,
							t_InternalInterfaceIdentifier ,
							t_InternalProxyIndex ,
							m_ProcessIdentifier ,
							t_IdentifyToken ,
							t_Impersonating ,
							t_OldContext ,
							t_OldSecurity ,
							t_IsProxy ,
							t_Interface ,
							t_Revert ,
							t_Proxy
						) ;
					}
				}
				else
				{
					UnLock () ;

					t_Result = WBEM_E_OUT_OF_MEMORY ;
				}
			}

			if ( FAILED ( t_Result ) )
			{
				t_Sink->SetStatus ( 0 , t_Result , NULL , NULL ) ;
			}

			t_Sink->Release () ;
		}
		else
		{
			t_Result = WBEM_E_OUT_OF_MEMORY ;
			a_Sink->SetStatus ( 0 , t_Result , NULL , NULL ) ;
		}
	}
	else
	{
		a_Sink->SetStatus ( 0 , t_Result , NULL , NULL ) ;
	}

	if ( FAILED ( t_Result ) )
	{
		if ( ( HRESULT_ERROR_FUNC(t_Result) == HRESULT_ERROR_SERVER_UNAVAILABLE ) || ( HRESULT_ERROR_FUNC(t_Result) == HRESULT_ERROR_CALL_FAILED_DNE ) || ( t_Result == RPC_E_DISCONNECTED ))
		{
			AbnormalShutdown () ;
		}
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_IWbemDecoupledProvider :: GetProperty (

    long a_Flags ,
    const BSTR a_Locale ,
    const BSTR a_ClassMapping ,
    const BSTR a_InstanceMapping ,
    const BSTR a_PropertyMapping ,
    VARIANT *a_Value
)
{
	if ( m_Provider_IWbemPropertyProvider )
	{
		IUnknown *t_ServerInterface = m_Provider_IWbemPropertyProvider ;
		REFIID t_InterfaceIdentifier = IID_IWbemPropertyProvider ;
		DWORD t_ProxyIndex = ProxyIndex_IWbemPropertyProvider ;
		IUnknown *t_InternalServerInterface = m_Provider_Internal_IWbemPropertyProvider ;
		REFIID t_InternalInterfaceIdentifier = IID_Internal_IWbemPropertyProvider ;
		DWORD t_InternalProxyIndex = ProxyIndex_Internal_IWbemPropertyProvider ;
		BOOL t_Impersonating ;
		IUnknown *t_OldContext ;
		IServerSecurity *t_OldSecurity ;
		BOOL t_IsProxy ;
		IUnknown *t_Interface ;
		BOOL t_Revert ;
		IUnknown *t_Proxy ;
		HANDLE t_IdentifyToken = NULL ;

		HRESULT t_Result = Begin_Interface (

			t_ServerInterface ,
			t_InterfaceIdentifier ,
			t_ProxyIndex ,
			t_InternalServerInterface ,
			t_InternalInterfaceIdentifier ,
			t_InternalProxyIndex ,
			m_ProcessIdentifier ,
			t_IdentifyToken ,
			t_Impersonating ,
			t_OldContext ,
			t_OldSecurity ,
			t_IsProxy ,
			t_Interface ,
			t_Revert ,
			t_Proxy
		) ;

		if ( SUCCEEDED ( t_Result ) )
		{
			if ( t_IdentifyToken )
			{
				BSTR t_ClassMapping = NULL ;
				BSTR t_InstanceMapping = NULL ;
				BSTR t_PropertyMapping = NULL ;

				if ( a_ClassMapping )
				{
					t_ClassMapping = SysAllocString ( a_ClassMapping ) ;
					if ( t_ClassMapping == NULL )
					{
						t_Result = WBEM_E_OUT_OF_MEMORY ;
					}
				}

				if ( a_InstanceMapping )
				{
					t_InstanceMapping = SysAllocString ( a_InstanceMapping ) ;
					if ( t_InstanceMapping == NULL )
					{
						t_Result = WBEM_E_OUT_OF_MEMORY ;
					} 
				}

				if ( a_PropertyMapping )
				{
					t_PropertyMapping = SysAllocString ( a_PropertyMapping ) ;
					if ( t_PropertyMapping == NULL )
					{
						t_Result = WBEM_E_OUT_OF_MEMORY ;
					}
				}

				if ( SUCCEEDED ( t_Result ) )
				{
					WmiInternalContext t_InternalContext ;
					t_InternalContext.m_IdentifyHandle = ( unsigned __int64 ) t_IdentifyToken ;
					t_InternalContext.m_ProcessIdentifier = GetCurrentProcessId () ;

					( ( Internal_IWbemPropertyProvider * ) t_Interface )->Internal_GetProperty ( 

						t_InternalContext ,
						a_Flags ,
						a_Locale ,
						t_ClassMapping ,
						t_InstanceMapping ,
						t_PropertyMapping ,
						a_Value
					) ;
				}
				else
				{
					t_Result = WBEM_E_OUT_OF_MEMORY ;
				}

				SysFreeString ( t_ClassMapping ) ;
				SysFreeString ( t_InstanceMapping ) ;
				SysFreeString ( t_PropertyMapping ) ;
			}
			else
			{
				t_Result = ( ( IWbemPropertyProvider * ) t_Interface )->GetProperty (

					a_Flags ,
					a_Locale ,
					a_ClassMapping ,
					a_InstanceMapping ,
					a_PropertyMapping ,
					a_Value
				) ;
			}

			End_Interface (

				t_ServerInterface ,
				t_InterfaceIdentifier ,
				t_ProxyIndex ,
				t_InternalServerInterface ,
				t_InternalInterfaceIdentifier ,
				t_InternalProxyIndex ,
				m_ProcessIdentifier ,
				t_IdentifyToken ,
				t_Impersonating ,
				t_OldContext ,
				t_OldSecurity ,
				t_IsProxy ,
				t_Interface ,
				t_Revert ,
				t_Proxy
			) ;
		}

		if ( FAILED ( t_Result ) )
		{
			if ( ( HRESULT_ERROR_FUNC(t_Result) == HRESULT_ERROR_SERVER_UNAVAILABLE ) || ( HRESULT_ERROR_FUNC(t_Result) == HRESULT_ERROR_CALL_FAILED_DNE ) || ( t_Result == RPC_E_DISCONNECTED ))
			{
				AbnormalShutdown () ;
			}
		}

		return t_Result ;
	}	
	else
	{
		return WBEM_E_PROVIDER_NOT_CAPABLE;
	}
}


/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_IWbemDecoupledProvider :: PutProperty (

    long a_Flags ,
    const BSTR a_Locale ,
    const BSTR a_ClassMapping ,
    const BSTR a_InstanceMapping ,
    const BSTR a_PropertyMapping ,
    const VARIANT *a_Value
)
{
	if ( m_Provider_IWbemPropertyProvider )
	{
		IUnknown *t_ServerInterface = m_Provider_IWbemPropertyProvider ;
		REFIID t_InterfaceIdentifier = IID_IWbemPropertyProvider ;
		DWORD t_ProxyIndex = ProxyIndex_IWbemPropertyProvider ;
		IUnknown *t_InternalServerInterface = m_Provider_Internal_IWbemPropertyProvider ;
		REFIID t_InternalInterfaceIdentifier = IID_Internal_IWbemPropertyProvider ;
		DWORD t_InternalProxyIndex = ProxyIndex_Internal_IWbemPropertyProvider ;
		BOOL t_Impersonating ;
		IUnknown *t_OldContext ;
		IServerSecurity *t_OldSecurity ;
		BOOL t_IsProxy ;
		IUnknown *t_Interface ;
		BOOL t_Revert ;
		IUnknown *t_Proxy ;
		HANDLE t_IdentifyToken = NULL ;

		HRESULT t_Result = Begin_Interface (

			t_ServerInterface ,
			t_InterfaceIdentifier ,
			t_ProxyIndex ,
			t_InternalServerInterface ,
			t_InternalInterfaceIdentifier ,
			t_InternalProxyIndex ,
			m_ProcessIdentifier ,
			t_IdentifyToken ,
			t_Impersonating ,
			t_OldContext ,
			t_OldSecurity ,
			t_IsProxy ,
			t_Interface ,
			t_Revert ,
			t_Proxy
		) ;

		if ( SUCCEEDED ( t_Result ) )
		{
			if ( t_IdentifyToken )
			{
				BSTR t_ClassMapping = NULL ;
				BSTR t_InstanceMapping = NULL ;
				BSTR t_PropertyMapping = NULL ;

				if ( a_ClassMapping )
				{
					t_ClassMapping = SysAllocString ( a_ClassMapping ) ;
					if ( t_ClassMapping == NULL )
					{
						t_Result = WBEM_E_OUT_OF_MEMORY ;
					}
				}

				if ( a_InstanceMapping )
				{
					t_InstanceMapping = SysAllocString ( a_InstanceMapping ) ;
					if ( t_InstanceMapping == NULL )
					{
						t_Result = WBEM_E_OUT_OF_MEMORY ;
					} 
				}

				if ( a_PropertyMapping )
				{
					t_PropertyMapping = SysAllocString ( a_PropertyMapping ) ;
					if ( t_PropertyMapping == NULL )
					{
						t_Result = WBEM_E_OUT_OF_MEMORY ;
					}
				}

				if ( SUCCEEDED ( t_Result ) )
				{
					WmiInternalContext t_InternalContext ;
					t_InternalContext.m_IdentifyHandle = ( unsigned __int64 ) t_IdentifyToken ;
					t_InternalContext.m_ProcessIdentifier = GetCurrentProcessId () ;

					( ( Internal_IWbemPropertyProvider * ) t_Interface )->Internal_PutProperty ( 

						t_InternalContext ,
						a_Flags ,
						a_Locale ,
						t_ClassMapping ,
						t_InstanceMapping ,
						t_PropertyMapping ,
						a_Value
					) ;
				}
				else
				{
					t_Result = WBEM_E_OUT_OF_MEMORY ;
				}

				SysFreeString ( t_ClassMapping ) ;
				SysFreeString ( t_InstanceMapping ) ;
				SysFreeString ( t_PropertyMapping ) ;
			}
			else
			{
				t_Result = ( ( IWbemPropertyProvider * ) t_Interface )->PutProperty (

					a_Flags ,
					a_Locale ,
					a_ClassMapping ,
					a_InstanceMapping ,
					a_PropertyMapping ,
					a_Value
				) ;
			}

			End_Interface (

				t_ServerInterface ,
				t_InterfaceIdentifier ,
				t_ProxyIndex ,
				t_InternalServerInterface ,
				t_InternalInterfaceIdentifier ,
				t_InternalProxyIndex ,
				m_ProcessIdentifier ,
				t_IdentifyToken ,
				t_Impersonating ,
				t_OldContext ,
				t_OldSecurity ,
				t_IsProxy ,
				t_Interface ,
				t_Revert ,
				t_Proxy
			) ;
		}

		if ( FAILED ( t_Result ) )
		{
			if ( ( HRESULT_ERROR_FUNC(t_Result) == HRESULT_ERROR_SERVER_UNAVAILABLE ) || ( HRESULT_ERROR_FUNC(t_Result) == HRESULT_ERROR_CALL_FAILED_DNE ) || ( t_Result == RPC_E_DISCONNECTED ))
			{
				AbnormalShutdown () ;
			}
		}

		return t_Result ;
	}

	return WBEM_E_PROVIDER_NOT_CAPABLE;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_IWbemDecoupledProvider ::ProvideEvents (

	IWbemObjectSink *a_Sink ,
	long a_Flags
)
{
	if ( m_Provider_IWbemEventProvider )
	{
		IUnknown *t_ServerInterface = m_Provider_IWbemEventProvider ;
		REFIID t_InterfaceIdentifier = IID_IWbemEventProvider ;
		DWORD t_ProxyIndex = ProxyIndex_IWbemEventProvider ;
		IUnknown *t_InternalServerInterface = m_Provider_Internal_IWbemEventProvider ;
		REFIID t_InternalInterfaceIdentifier = IID_Internal_IWbemEventProvider ;
		DWORD t_InternalProxyIndex = ProxyIndex_Internal_IWbemEventProvider ;
		BOOL t_Impersonating ;
		IUnknown *t_OldContext ;
		IServerSecurity *t_OldSecurity ;
		BOOL t_IsProxy ;
		IUnknown *t_Interface ;
		BOOL t_Revert ;
		IUnknown *t_Proxy ;
		HANDLE t_IdentifyToken = NULL ;

		HRESULT t_Result = Begin_Interface (

			t_ServerInterface ,
			t_InterfaceIdentifier ,
			t_ProxyIndex ,
			t_InternalServerInterface ,
			t_InternalInterfaceIdentifier ,
			t_InternalProxyIndex ,
			m_ProcessIdentifier ,
			t_IdentifyToken ,
			t_Impersonating ,
			t_OldContext ,
			t_OldSecurity ,
			t_IsProxy ,
			t_Interface ,
			t_Revert ,
			t_Proxy
		) ;

		if ( SUCCEEDED ( t_Result ) )
		{
			if ( t_IdentifyToken )
			{
				WmiInternalContext t_InternalContext ;
				t_InternalContext.m_IdentifyHandle = ( unsigned __int64 ) t_IdentifyToken ;
				t_InternalContext.m_ProcessIdentifier = GetCurrentProcessId () ;

				t_Result = ( ( Internal_IWbemEventProvider * ) t_Interface )->Internal_ProvideEvents (

					t_InternalContext ,
					a_Sink ,
					a_Flags 
				) ;
			}
			else
			{
				t_Result = ( ( IWbemEventProvider * ) t_Interface )->ProvideEvents (

					a_Sink ,
					a_Flags 
				) ;
			}

			End_Interface (

				t_ServerInterface ,
				t_InterfaceIdentifier ,
				t_ProxyIndex ,
				t_InternalServerInterface ,
				t_InternalInterfaceIdentifier ,
				t_InternalProxyIndex ,
				m_ProcessIdentifier ,
				t_IdentifyToken ,
				t_Impersonating ,
				t_OldContext ,
				t_OldSecurity ,
				t_IsProxy ,
				t_Interface ,
				t_Revert ,
				t_Proxy
			) ;
		}

		if ( FAILED ( t_Result ) )
		{
			if ( ( HRESULT_ERROR_FUNC(t_Result) == HRESULT_ERROR_SERVER_UNAVAILABLE ) || ( HRESULT_ERROR_FUNC(t_Result) == HRESULT_ERROR_CALL_FAILED_DNE ) || ( t_Result == RPC_E_DISCONNECTED ))
			{
				AbnormalShutdown () ;
			}
		}

		return t_Result ;
	}

	return WBEM_E_PROVIDER_NOT_CAPABLE;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_IWbemDecoupledProvider ::NewQuery (

	unsigned long a_Id ,
	WBEM_WSTR a_QueryLanguage ,
	WBEM_WSTR a_Query
)
{
	if ( m_Provider_IWbemEventProviderQuerySink )
	{
		IUnknown *t_ServerInterface = m_Provider_IWbemEventProviderQuerySink ;
		REFIID t_InterfaceIdentifier = IID_IWbemEventProviderQuerySink ;
		DWORD t_ProxyIndex = ProxyIndex_IWbemEventProviderQuerySink ;
		IUnknown *t_InternalServerInterface = m_Provider_Internal_IWbemEventProviderQuerySink ;
		REFIID t_InternalInterfaceIdentifier = IID_Internal_IWbemEventProviderQuerySink ;
		DWORD t_InternalProxyIndex = ProxyIndex_Internal_IWbemEventProviderQuerySink ;
		BOOL t_Impersonating ;
		IUnknown *t_OldContext ;
		IServerSecurity *t_OldSecurity ;
		BOOL t_IsProxy ;
		IUnknown *t_Interface ;
		BOOL t_Revert ;
		IUnknown *t_Proxy ;
		HANDLE t_IdentifyToken = NULL ;

		HRESULT t_Result = Begin_Interface (

			t_ServerInterface ,
			t_InterfaceIdentifier ,
			t_ProxyIndex ,
			t_InternalServerInterface ,
			t_InternalInterfaceIdentifier ,
			t_InternalProxyIndex ,
			m_ProcessIdentifier ,
			t_IdentifyToken ,
			t_Impersonating ,
			t_OldContext ,
			t_OldSecurity ,
			t_IsProxy ,
			t_Interface ,
			t_Revert ,
			t_Proxy
		) ;

		if ( SUCCEEDED ( t_Result ) )
		{
			if ( t_IdentifyToken )
			{
				BSTR t_QueryLanguage = SysAllocString ( a_QueryLanguage ) ;
				BSTR t_Query = SysAllocString ( a_Query ) ;

				if ( t_QueryLanguage && t_Query )
				{
					WmiInternalContext t_InternalContext ;
					t_InternalContext.m_IdentifyHandle = ( unsigned __int64 ) t_IdentifyToken ;
					t_InternalContext.m_ProcessIdentifier = GetCurrentProcessId () ;

					t_Result = ( ( Internal_IWbemEventProviderQuerySink * ) t_Interface )->Internal_NewQuery (

						t_InternalContext ,
						a_Id ,
						t_QueryLanguage ,
						t_Query
					) ;
				}
				else
				{
					t_Result = WBEM_E_OUT_OF_MEMORY ;
				}

				SysFreeString ( t_QueryLanguage ) ;
				SysFreeString ( t_Query ) ;
			}
			else
			{
				t_Result = ( ( IWbemEventProviderQuerySink * ) t_Interface )->NewQuery (

					a_Id ,
					a_QueryLanguage ,
					a_Query
				) ;
			}

			End_Interface (

				t_ServerInterface ,
				t_InterfaceIdentifier ,
				t_ProxyIndex ,
				t_InternalServerInterface ,
				t_InternalInterfaceIdentifier ,
				t_InternalProxyIndex ,
				m_ProcessIdentifier ,
				t_IdentifyToken ,
				t_Impersonating ,
				t_OldContext ,
				t_OldSecurity ,
				t_IsProxy ,
				t_Interface ,
				t_Revert ,
				t_Proxy
			) ;
		}

		if ( FAILED ( t_Result ) )
		{
			if ( ( HRESULT_ERROR_FUNC(t_Result) == HRESULT_ERROR_SERVER_UNAVAILABLE ) || ( HRESULT_ERROR_FUNC(t_Result) == HRESULT_ERROR_CALL_FAILED_DNE ) || ( t_Result == RPC_E_DISCONNECTED ))
			{
				AbnormalShutdown () ;
			}
		}

		return t_Result ;
	}

	return WBEM_E_PROVIDER_NOT_CAPABLE;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_IWbemDecoupledProvider ::CancelQuery (

	unsigned long a_Id
)
{
	if ( m_Provider_IWbemEventProviderQuerySink )
	{
		IUnknown *t_ServerInterface = m_Provider_IWbemEventProviderQuerySink ;
		REFIID t_InterfaceIdentifier = IID_IWbemEventProviderQuerySink ;
		DWORD t_ProxyIndex = ProxyIndex_IWbemEventProviderQuerySink ;
		IUnknown *t_InternalServerInterface = m_Provider_Internal_IWbemEventProviderQuerySink ;
		REFIID t_InternalInterfaceIdentifier = IID_Internal_IWbemEventProviderQuerySink ;
		DWORD t_InternalProxyIndex = ProxyIndex_Internal_IWbemEventProviderQuerySink ;
		BOOL t_Impersonating ;
		IUnknown *t_OldContext ;
		IServerSecurity *t_OldSecurity ;
		BOOL t_IsProxy ;
		IUnknown *t_Interface ;
		BOOL t_Revert ;
		IUnknown *t_Proxy ;
		HANDLE t_IdentifyToken = NULL ;

		HRESULT t_Result = Begin_Interface (

			t_ServerInterface ,
			t_InterfaceIdentifier ,
			t_ProxyIndex ,
			t_InternalServerInterface ,
			t_InternalInterfaceIdentifier ,
			t_InternalProxyIndex ,
			m_ProcessIdentifier ,
			t_IdentifyToken ,
			t_Impersonating ,
			t_OldContext ,
			t_OldSecurity ,
			t_IsProxy ,
			t_Interface ,
			t_Revert ,
			t_Proxy
		) ;

		if ( SUCCEEDED ( t_Result ) )
		{
			if ( t_IdentifyToken )
			{
				WmiInternalContext t_InternalContext ;
				t_InternalContext.m_IdentifyHandle = ( unsigned __int64 ) t_IdentifyToken ;
				t_InternalContext.m_ProcessIdentifier = GetCurrentProcessId () ;

				t_Result = ( ( Internal_IWbemEventProviderQuerySink * ) t_Interface )->Internal_CancelQuery (

					t_InternalContext ,
					a_Id
				) ;
			}
			else
			{
				t_Result = ( ( IWbemEventProviderQuerySink * ) t_Interface )->CancelQuery (

					a_Id
				) ;
			}

			End_Interface (

				t_ServerInterface ,
				t_InterfaceIdentifier ,
				t_ProxyIndex ,
				t_InternalServerInterface ,
				t_InternalInterfaceIdentifier ,
				t_InternalProxyIndex ,
				m_ProcessIdentifier ,
				t_IdentifyToken ,
				t_Impersonating ,
				t_OldContext ,
				t_OldSecurity ,
				t_IsProxy ,
				t_Interface ,
				t_Revert ,
				t_Proxy
			) ;
		}

		if ( FAILED ( t_Result ) )
		{
			if ( ( HRESULT_ERROR_FUNC(t_Result) == HRESULT_ERROR_SERVER_UNAVAILABLE ) || ( HRESULT_ERROR_FUNC(t_Result) == HRESULT_ERROR_CALL_FAILED_DNE ) || ( t_Result == RPC_E_DISCONNECTED ))
			{
				AbnormalShutdown () ;
			}
		}

		return t_Result ;
	}

	return WBEM_E_PROVIDER_NOT_CAPABLE;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_IWbemDecoupledProvider ::AccessCheck (

	WBEM_CWSTR a_QueryLanguage ,
	WBEM_CWSTR a_Query ,
	long a_SidLength ,
	const BYTE *a_Sid
)
{
	if ( m_Provider_IWbemEventProviderSecurity )
	{
		IUnknown *t_ServerInterface = m_Provider_IWbemEventProviderSecurity ;
		REFIID t_InterfaceIdentifier = IID_IWbemEventProviderSecurity ;
		DWORD t_ProxyIndex = ProxyIndex_IWbemEventProviderSecurity ;
		IUnknown *t_InternalServerInterface = m_Provider_Internal_IWbemEventProviderSecurity ;
		REFIID t_InternalInterfaceIdentifier = IID_Internal_IWbemEventProviderSecurity ;
		DWORD t_InternalProxyIndex = ProxyIndex_Internal_IWbemEventProviderSecurity;
		BOOL t_Impersonating ;
		IUnknown *t_OldContext ;
		IServerSecurity *t_OldSecurity ;
		BOOL t_IsProxy ;
		IUnknown *t_Interface ;
		BOOL t_Revert ;
		IUnknown *t_Proxy ;
		HANDLE t_IdentifyToken = NULL ;

		HRESULT t_Result = Begin_Interface (

			t_ServerInterface ,
			t_InterfaceIdentifier ,
			t_ProxyIndex ,
			t_InternalServerInterface ,
			t_InternalInterfaceIdentifier ,
			t_InternalProxyIndex ,
			m_ProcessIdentifier ,
			t_IdentifyToken ,
			t_Impersonating ,
			t_OldContext ,
			t_OldSecurity ,
			t_IsProxy ,
			t_Interface ,
			t_Revert ,
			t_Proxy
		) ;

		if ( SUCCEEDED ( t_Result ) )
		{
			if ( t_IdentifyToken )
			{
				BSTR t_QueryLanguage = SysAllocString ( a_QueryLanguage ) ;
				BSTR t_Query = SysAllocString ( a_Query ) ;

				if ( t_QueryLanguage && t_Query )
				{
					WmiInternalContext t_InternalContext ;
					t_InternalContext.m_IdentifyHandle = ( unsigned __int64 ) t_IdentifyToken ;
					t_InternalContext.m_ProcessIdentifier = GetCurrentProcessId () ;

					t_Result = ( ( Internal_IWbemEventProviderSecurity * ) t_Interface )->Internal_AccessCheck (

						t_InternalContext ,
						t_QueryLanguage ,
						t_Query ,
						a_SidLength ,
						a_Sid
					) ;
				}
				else
				{
					t_Result = WBEM_E_OUT_OF_MEMORY ;
				}

				SysFreeString ( t_QueryLanguage ) ;
				SysFreeString ( t_Query ) ;
			}
			else
			{
				t_Result = ( ( IWbemEventProviderSecurity * ) t_Interface )->AccessCheck (

					a_QueryLanguage ,
					a_Query ,
					a_SidLength ,
					a_Sid
				) ;
			}

			End_Interface (

				t_ServerInterface ,
				t_InterfaceIdentifier ,
				t_ProxyIndex ,
				t_InternalServerInterface ,
				t_InternalInterfaceIdentifier ,
				t_InternalProxyIndex ,
				m_ProcessIdentifier ,
				t_IdentifyToken ,
				t_Impersonating ,
				t_OldContext ,
				t_OldSecurity ,
				t_IsProxy ,
				t_Interface ,
				t_Revert ,
				t_Proxy
			) ;

			if ( FAILED ( t_Result ) )
			{
				if ( ( HRESULT_ERROR_FUNC(t_Result) == HRESULT_ERROR_SERVER_UNAVAILABLE ) || ( HRESULT_ERROR_FUNC(t_Result) == HRESULT_ERROR_CALL_FAILED_DNE ) || ( t_Result == RPC_E_DISCONNECTED ))
				{
					AbnormalShutdown () ;
				}
			}
		}

		return t_Result ;
	}

	return WBEM_E_PROVIDER_NOT_CAPABLE;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_IWbemDecoupledProvider ::FindConsumer (

	IWbemClassObject *a_LogicalConsumer ,
	IWbemUnboundObjectSink **a_Consumer
)
{
	if ( m_Provider_IWbemEventConsumerProvider )
	{
		IWbemUnboundObjectSink *t_Consumer = NULL ;

		IUnknown *t_ServerInterface = m_Provider_IWbemEventConsumerProvider ;
		REFIID t_InterfaceIdentifier = IID_IWbemEventConsumerProvider ;
		DWORD t_ProxyIndex = ProxyIndex_IWbemEventConsumerProvider ;
		IUnknown *t_InternalServerInterface = m_Provider_Internal_IWbemEventConsumerProvider ;
		REFIID t_InternalInterfaceIdentifier = IID_Internal_IWbemEventConsumerProvider ;
		DWORD t_InternalProxyIndex = ProxyIndex_Internal_IWbemEventConsumerProvider ;
		BOOL t_Impersonating ;
		IUnknown *t_OldContext ;
		IServerSecurity *t_OldSecurity ;
		BOOL t_IsProxy ;
		IUnknown *t_Interface ;
		BOOL t_Revert ;
		IUnknown *t_Proxy ;
		HANDLE t_IdentifyToken = NULL ;

		HRESULT t_Result = Begin_Interface (

			t_ServerInterface ,
			t_InterfaceIdentifier ,
			t_ProxyIndex ,
			t_InternalServerInterface ,
			t_InternalInterfaceIdentifier ,
			t_InternalProxyIndex ,
			m_ProcessIdentifier ,
			t_IdentifyToken ,
			t_Impersonating ,
			t_OldContext ,
			t_OldSecurity ,
			t_IsProxy ,
			t_Interface ,
			t_Revert ,
			t_Proxy
		) ;

		if ( SUCCEEDED ( t_Result ) )
		{
			if ( t_IdentifyToken )
			{
				WmiInternalContext t_InternalContext ;
				t_InternalContext.m_IdentifyHandle = ( unsigned __int64 ) t_IdentifyToken ;
				t_InternalContext.m_ProcessIdentifier = GetCurrentProcessId () ;

				t_Result = ( ( Internal_IWbemEventConsumerProvider * ) t_Interface )->Internal_FindConsumer (

					t_InternalContext ,
					a_LogicalConsumer ,
					& t_Consumer
				) ;
			}
			else
			{
				t_Result = ( ( IWbemEventConsumerProvider * ) t_Interface )->FindConsumer (

					a_LogicalConsumer ,
					& t_Consumer
				) ;
			}

			End_Interface (

				t_ServerInterface ,
				t_InterfaceIdentifier ,
				t_ProxyIndex ,
				t_InternalServerInterface ,
				t_InternalInterfaceIdentifier ,
				t_InternalProxyIndex ,
				m_ProcessIdentifier ,
				t_IdentifyToken ,
				t_Impersonating ,
				t_OldContext ,
				t_OldSecurity ,
				t_IsProxy ,
				t_Interface ,
				t_Revert ,
				t_Proxy
			) ;
		}

		if ( SUCCEEDED ( t_Result ) )
		{
			if ( a_Consumer )
			{
				CDecoupled_IWbemUnboundObjectSink *t_UnboundObjectSink = new CDecoupled_IWbemUnboundObjectSink (

						m_Allocator ,
						t_Consumer , 
						this ,
						*m_Registration
				) ;

				if ( t_UnboundObjectSink )
				{
					t_UnboundObjectSink->AddRef () ;

					t_Result = t_UnboundObjectSink->Initialize () ;
					if ( SUCCEEDED ( t_Result ) ) 
					{
						CWbemGlobal_VoidPointerController_Container_Iterator t_Iterator ;

						Lock () ;

						WmiStatusCode t_StatusCode = Insert ( 

							*t_UnboundObjectSink ,
							t_Iterator
						) ;

						if ( t_StatusCode == e_StatusCode_Success ) 
						{
							UnLock () ;

							*a_Consumer = t_UnboundObjectSink ;

							t_UnboundObjectSink->AddRef () ;
						}
						else
						{
							UnLock () ;

							t_Result = WBEM_E_OUT_OF_MEMORY ;
						}
					}

					t_UnboundObjectSink->Release () ;
				}
			}
		}
		else
		{
			if ( ( HRESULT_ERROR_FUNC(t_Result) == HRESULT_ERROR_SERVER_UNAVAILABLE ) || ( HRESULT_ERROR_FUNC(t_Result) == HRESULT_ERROR_CALL_FAILED_DNE ) || ( t_Result == RPC_E_DISCONNECTED ))
			{
				AbnormalShutdown () ;
			}
		}

		if ( t_Consumer )
		{
			t_Consumer->Release () ;
		}

		return t_Result ;
	}

	return WBEM_E_PROVIDER_NOT_CAPABLE;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_IWbemDecoupledProvider ::ValidateSubscription (

	IWbemClassObject *a_LogicalConsumer
)
{
	if ( m_Provider_IWbemEventConsumerProviderEx )
	{
		IUnknown *t_ServerInterface = m_Provider_IWbemEventConsumerProviderEx ;
		REFIID t_InterfaceIdentifier = IID_IWbemEventConsumerProviderEx ;
		DWORD t_ProxyIndex = ProxyIndex_IWbemEventConsumerProviderEx ;
		IUnknown *t_InternalServerInterface = m_Provider_Internal_IWbemEventConsumerProviderEx ;
		REFIID t_InternalInterfaceIdentifier = IID_Internal_IWbemEventConsumerProviderEx ;
		DWORD t_InternalProxyIndex = ProxyIndex_Internal_IWbemEventConsumerProviderEx ;
		BOOL t_Impersonating ;
		IUnknown *t_OldContext ;
		IServerSecurity *t_OldSecurity ;
		BOOL t_IsProxy ;
		IUnknown *t_Interface ;
		BOOL t_Revert ;
		IUnknown *t_Proxy ;
		HANDLE t_IdentifyToken = NULL ;

		HRESULT t_Result = Begin_Interface (

			t_ServerInterface ,
			t_InterfaceIdentifier ,
			t_ProxyIndex ,
			t_InternalServerInterface ,
			t_InternalInterfaceIdentifier ,
			t_InternalProxyIndex ,
			m_ProcessIdentifier ,
			t_IdentifyToken ,
			t_Impersonating ,
			t_OldContext ,
			t_OldSecurity ,
			t_IsProxy ,
			t_Interface ,
			t_Revert ,
			t_Proxy
		) ;

		if ( SUCCEEDED ( t_Result ) )
		{
			if ( t_IdentifyToken )
			{
				WmiInternalContext t_InternalContext ;
				t_InternalContext.m_IdentifyHandle = ( unsigned __int64 ) t_IdentifyToken ;
				t_InternalContext.m_ProcessIdentifier = GetCurrentProcessId () ;

				t_Result = ( ( Internal_IWbemEventConsumerProviderEx * ) t_Interface )->Internal_ValidateSubscription (

					t_InternalContext ,
					a_LogicalConsumer
				) ;
			}
			else
			{

				t_Result = ( ( IWbemEventConsumerProviderEx * ) t_Interface )->ValidateSubscription (

					a_LogicalConsumer
				) ;
			}

			End_Interface (

				t_ServerInterface ,
				t_InterfaceIdentifier ,
				t_ProxyIndex ,
				t_InternalServerInterface ,
				t_InternalInterfaceIdentifier ,
				t_InternalProxyIndex ,
				m_ProcessIdentifier ,
				t_IdentifyToken ,
				t_Impersonating ,
				t_OldContext ,
				t_OldSecurity ,
				t_IsProxy ,
				t_Interface ,
				t_Revert ,
				t_Proxy
			) ;
		}

		if ( FAILED ( t_Result ) )
		{
			if ( ( HRESULT_ERROR_FUNC(t_Result) == HRESULT_ERROR_SERVER_UNAVAILABLE ) || ( HRESULT_ERROR_FUNC(t_Result) == HRESULT_ERROR_CALL_FAILED_DNE ) || ( t_Result == RPC_E_DISCONNECTED ))
			{
				AbnormalShutdown () ;
			}
		}

		return t_Result ;
	}

	return WBEM_E_PROVIDER_NOT_CAPABLE;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_IWbemDecoupledProvider :: IndicateToConsumer (

	IWbemClassObject *a_LogicalConsumer ,
	long a_ObjectCount ,
	IWbemClassObject **a_Objects
)
{
	if ( m_Provider_IWbemUnboundObjectSink )
	{
		IUnknown *t_ServerInterface = m_Provider_IWbemUnboundObjectSink ;
		REFIID t_InterfaceIdentifier = IID_IWbemUnboundObjectSink ;
		DWORD t_ProxyIndex = ProxyIndex_IWbemUnboundObjectSink ;
		IUnknown *t_InternalServerInterface = m_Provider_Internal_IWbemUnboundObjectSink ;
		REFIID t_InternalInterfaceIdentifier = IID_Internal_IWbemUnboundObjectSink ;
		DWORD t_InternalProxyIndex = ProxyIndex_Internal_IWbemUnboundObjectSink ;
		BOOL t_Impersonating ;
		IUnknown *t_OldContext ;
		IServerSecurity *t_OldSecurity ;
		BOOL t_IsProxy ;
		IUnknown *t_Interface ;
		BOOL t_Revert ;
		IUnknown *t_Proxy ;
		HANDLE t_IdentifyToken = NULL ;

		HRESULT t_Result = Begin_Interface (

			t_ServerInterface ,
			t_InterfaceIdentifier ,
			t_ProxyIndex ,
			t_InternalServerInterface ,
			t_InternalInterfaceIdentifier ,
			t_InternalProxyIndex ,
			m_ProcessIdentifier ,
			t_IdentifyToken ,
			t_Impersonating ,
			t_OldContext ,
			t_OldSecurity ,
			t_IsProxy ,
			t_Interface ,
			t_Revert ,
			t_Proxy
		) ;

		if ( SUCCEEDED ( t_Result ) )
		{
			if ( t_IdentifyToken )
			{
				WmiInternalContext t_InternalContext ;
				t_InternalContext.m_IdentifyHandle = ( unsigned __int64 ) t_IdentifyToken ;
				t_InternalContext.m_ProcessIdentifier = GetCurrentProcessId () ;

				t_Result = ( ( Internal_IWbemUnboundObjectSink * ) t_Interface )->Internal_IndicateToConsumer (

					t_InternalContext ,
					a_LogicalConsumer ,
					a_ObjectCount ,
					a_Objects
				) ;
			}
			else
			{

				t_Result = ( ( IWbemUnboundObjectSink * ) t_Interface )->IndicateToConsumer (

					a_LogicalConsumer ,
					a_ObjectCount ,
					a_Objects
				) ;
			}

			End_Interface (

				t_ServerInterface ,
				t_InterfaceIdentifier ,
				t_ProxyIndex ,
				t_InternalServerInterface ,
				t_InternalInterfaceIdentifier ,
				t_InternalProxyIndex ,
				m_ProcessIdentifier ,
				t_IdentifyToken ,
				t_Impersonating ,
				t_OldContext ,
				t_OldSecurity ,
				t_IsProxy ,
				t_Interface ,
				t_Revert ,
				t_Proxy
			) ;
		}

		if ( FAILED ( t_Result ) )
		{
			if ( ( HRESULT_ERROR_FUNC(t_Result) == HRESULT_ERROR_SERVER_UNAVAILABLE ) || ( HRESULT_ERROR_FUNC(t_Result) == HRESULT_ERROR_CALL_FAILED_DNE ) || ( t_Result == RPC_E_DISCONNECTED ))
			{
				AbnormalShutdown () ;
			}
		}

		return t_Result ;
	}

	return WBEM_E_PROVIDER_NOT_CAPABLE;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_IWbemDecoupledProvider :: SetInitialized ( HRESULT a_InitializeResult )
{
	m_InitializeResult = a_InitializeResult ;

	InterlockedExchange ( & m_Initialized , 1 ) ;

	if ( m_InitializedEvent )
	{
		SetEvent ( m_InitializedEvent ) ;
	}

	return S_OK ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_IWbemDecoupledProvider :: WaitProvider ( IWbemContext *a_Context , ULONG a_Timeout )
{
	HRESULT t_Result = WBEM_E_UNEXPECTED ;

	if ( m_Initialized == 0 )
	{
		BOOL t_DependantCall = FALSE ;
		t_Result = ProviderSubSystem_Common_Globals :: IsDependantCall ( m_InitializationContext , a_Context , t_DependantCall ) ;
		if ( SUCCEEDED ( t_Result ) )
		{
			if ( t_DependantCall == FALSE )
			{
				if ( WaitForSingleObject ( m_InitializedEvent , a_Timeout ) == WAIT_TIMEOUT )
				{
					return WBEM_E_PROVIDER_LOAD_FAILURE ;
				}
			}
			else
			{
				if ( WaitForSingleObject ( m_InitializedEvent , 0 ) == WAIT_TIMEOUT )
				{
					return S_FALSE ;
				}
			}
		}
	}
	else
	{
		t_Result = S_OK ;
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_IWbemDecoupledProvider :: SetRegistrationObject (

	long a_Flags ,
	IWbemClassObject *a_ProviderRegistration
)
{
	if ( m_Provider_IWbemProviderIdentity )
	{
		IUnknown *t_ServerInterface = m_Provider_IWbemProviderIdentity ;
		REFIID t_InterfaceIdentifier = IID_IWbemProviderIdentity ;
		DWORD t_ProxyIndex = ProxyIndex_IWbemProviderIdentity ;
		IUnknown *t_InternalServerInterface = m_Provider_Internal_IWbemProviderIdentity ;
		REFIID t_InternalInterfaceIdentifier = IID_Internal_IWbemProviderIdentity ;
		DWORD t_InternalProxyIndex = ProxyIndex_Internal_IWbemProviderIdentity ;
		BOOL t_Impersonating ;
		IUnknown *t_OldContext ;
		IServerSecurity *t_OldSecurity ;
		BOOL t_IsProxy ;
		IUnknown *t_Interface ;
		BOOL t_Revert ;
		IUnknown *t_Proxy ;
		HANDLE t_IdentifyToken = NULL ;

		HRESULT t_Result = Begin_Interface (

			t_ServerInterface ,
			t_InterfaceIdentifier ,
			t_ProxyIndex ,
			t_InternalServerInterface ,
			t_InternalInterfaceIdentifier ,
			t_InternalProxyIndex ,
			m_ProcessIdentifier ,
			t_IdentifyToken ,
			t_Impersonating ,
			t_OldContext ,
			t_OldSecurity ,
			t_IsProxy ,
			t_Interface ,
			t_Revert ,
			t_Proxy
		) ;

		if ( SUCCEEDED ( t_Result ) )
		{
			if ( t_IdentifyToken )
			{
				WmiInternalContext t_InternalContext ;
				t_InternalContext.m_IdentifyHandle = ( unsigned __int64 ) t_IdentifyToken ;
				t_InternalContext.m_ProcessIdentifier = GetCurrentProcessId () ;

				t_Result = ( ( Internal_IWbemProviderIdentity * ) t_Interface )->Internal_SetRegistrationObject (

					t_InternalContext ,
					a_Flags ,
					a_ProviderRegistration
				) ;
			}
			else
			{
				t_Result = ( ( IWbemProviderIdentity * ) t_Interface )->SetRegistrationObject (

					a_Flags ,
					a_ProviderRegistration
				) ;
			}

			End_Interface (

				t_ServerInterface ,
				t_InterfaceIdentifier ,
				t_ProxyIndex ,
				t_InternalServerInterface ,
				t_InternalInterfaceIdentifier ,
				t_InternalProxyIndex ,
				m_ProcessIdentifier ,
				t_IdentifyToken ,
				t_Impersonating ,
				t_OldContext ,
				t_OldSecurity ,
				t_IsProxy ,
				t_Interface ,
				t_Revert ,
				t_Proxy
			) ;

			if ( FAILED ( t_Result ) )
			{
				if ( ( HRESULT_ERROR_FUNC(t_Result) == HRESULT_ERROR_SERVER_UNAVAILABLE ) || ( HRESULT_ERROR_FUNC(t_Result) == HRESULT_ERROR_CALL_FAILED_DNE ) || ( t_Result == RPC_E_DISCONNECTED ))
				{
					AbnormalShutdown () ;
				}
			}
		}

		return t_Result ;
	}

	return WBEM_E_PROVIDER_NOT_CAPABLE;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_IWbemDecoupledProvider :: Initialize (

	LPWSTR a_User ,
	LONG a_Flags ,
	LPWSTR a_Namespace ,
	LPWSTR a_Locale ,
	IWbemServices *a_CoreService ,
	IWbemContext *a_Context ,
	IWbemProviderInitSink *a_Sink
)
{
	if ( m_Provider_IWbemProviderInit )
	{
		IUnknown *t_ServerInterface = m_Provider_IWbemProviderInit ;
		REFIID t_InterfaceIdentifier = IID_IWbemProviderInit ;
		DWORD t_ProxyIndex = ProxyIndex_IWbemProviderInit ;
		IUnknown *t_InternalServerInterface = m_Provider_Internal_IWbemProviderInit ;
		REFIID t_InternalInterfaceIdentifier = IID_Internal_IWbemProviderInit ;
		DWORD t_InternalProxyIndex = ProxyIndex_Internal_IWbemProviderInit ;
		BOOL t_Impersonating ;
		IUnknown *t_OldContext ;
		IServerSecurity *t_OldSecurity ;
		BOOL t_IsProxy ;
		IUnknown *t_Interface ;
		BOOL t_Revert ;
		IUnknown *t_Proxy ;
		HANDLE t_IdentifyToken = NULL ;

		HRESULT t_Result = Begin_Interface (

			t_ServerInterface ,
			t_InterfaceIdentifier ,
			t_ProxyIndex ,
			t_InternalServerInterface ,
			t_InternalInterfaceIdentifier ,
			t_InternalProxyIndex ,
			m_ProcessIdentifier ,
			t_IdentifyToken ,
			t_Impersonating ,
			t_OldContext ,
			t_OldSecurity ,
			t_IsProxy ,
			t_Interface ,
			t_Revert ,
			t_Proxy
		) ;

		if ( SUCCEEDED ( t_Result ) )
		{
			if ( t_IdentifyToken )
			{
				WmiInternalContext t_InternalContext ;
				t_InternalContext.m_IdentifyHandle = ( unsigned __int64 ) t_IdentifyToken ;
				t_InternalContext.m_ProcessIdentifier = GetCurrentProcessId () ;

				t_Result = ( ( Internal_IWbemProviderInit * ) t_Interface )->Internal_Initialize (

					t_InternalContext ,
					a_User ,
					a_Flags ,
					a_Namespace ,
					a_Locale ,
					a_CoreService ,
					a_Context ,
					a_Sink
				) ;
			}
			else
			{
				t_Result = ( ( IWbemProviderInit * ) t_Interface )->Initialize (

					a_User ,
					a_Flags ,
					a_Namespace ,
					a_Locale ,
					a_CoreService ,
					a_Context ,
					a_Sink
				) ;
			}

			End_Interface (

				t_ServerInterface ,
				t_InterfaceIdentifier ,
				t_ProxyIndex ,
				t_InternalServerInterface ,
				t_InternalInterfaceIdentifier ,
				t_InternalProxyIndex ,
				m_ProcessIdentifier ,
				t_IdentifyToken ,
				t_Impersonating ,
				t_OldContext ,
				t_OldSecurity ,
				t_IsProxy ,
				t_Interface ,
				t_Revert ,
				t_Proxy
			) ;

			if ( FAILED ( t_Result ) )
			{
				if ( ( HRESULT_ERROR_FUNC(t_Result) == HRESULT_ERROR_SERVER_UNAVAILABLE ) || ( HRESULT_ERROR_FUNC(t_Result) == HRESULT_ERROR_CALL_FAILED_DNE ) || ( t_Result == RPC_E_DISCONNECTED ))
				{
					AbnormalShutdown () ;
				}
			}
		}

		return t_Result ;
	}

	return WBEM_E_PROVIDER_NOT_CAPABLE;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_IWbemDecoupledProvider :: AbnormalShutdown ()
{
	HRESULT t_Result = S_OK ;
	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_IWbemDecoupledProvider :: Shutdown (

	LONG a_Flags ,
	ULONG a_MaxMilliSeconds ,
	IWbemContext *a_Context
)
{
	HRESULT t_Result = S_OK ;

	IWbemShutdown *t_Shutdown = NULL ;

	if ( m_Unknown )
	{
		t_Result = m_Unknown->QueryInterface ( IID_IWbemShutdown , ( void ** ) & t_Shutdown ) ;
		if ( SUCCEEDED ( t_Result ) ) 
		{
			BOOL t_Impersonating = FALSE ;
			IUnknown *t_OldContext = NULL ;
			IServerSecurity *t_OldSecurity = NULL ;

			t_Result = ProviderSubSystem_Common_Globals :: BeginImpersonation ( t_OldContext , t_OldSecurity , t_Impersonating ) ;
			if ( SUCCEEDED ( t_Result ) ) 
			{
				BOOL t_Revert = FALSE ;
				IUnknown *t_Proxy = NULL ;

				t_Result = ProviderSubSystem_Common_Globals :: SetProxyState ( m_ProxyContainer , ProxyIndex_IWbemShutdown , IID_IWbemShutdown , t_Shutdown , t_Proxy , t_Revert ) ;
				if ( t_Result == WBEM_E_NOT_FOUND )
				{
					try
					{
						t_Result = t_Shutdown->Shutdown (

							a_Flags ,
							a_MaxMilliSeconds ,
							a_Context
						) ;
					}
					catch ( ... )
					{
						t_Result = WBEM_E_PROVIDER_FAILURE ;
					}

					CoRevertToSelf () ;
				}
				else
				{
					if ( SUCCEEDED ( t_Result ) )
					{
						IWbemShutdown *t_Provider = ( IWbemShutdown * ) t_Proxy ;

						// Set cloaking on the proxy
						// =========================

						DWORD t_ImpersonationLevel = ProviderSubSystem_Common_Globals :: GetCurrentImpersonationLevel () ;

						t_Result = ProviderSubSystem_Common_Globals :: SetCloaking (

							t_Provider ,
							RPC_C_AUTHN_LEVEL_CONNECT , 
							t_ImpersonationLevel
						) ;

						if ( SUCCEEDED ( t_Result ) )
						{
							t_Result = CoImpersonateClient () ;
							if ( SUCCEEDED ( t_Result ) )
							{
								try
								{
									t_Result = t_Provider->Shutdown (

										a_Flags ,
										a_MaxMilliSeconds ,
										a_Context
									) ;
								}
								catch ( ... )
								{
									t_Result = WBEM_E_PROVIDER_FAILURE ;
								}

								CoRevertToSelf () ;
							}
						}

						HRESULT t_TempResult = ProviderSubSystem_Common_Globals :: RevertProxyState ( m_ProxyContainer , ProxyIndex_IWbemShutdown , t_Proxy , t_Revert ) ;
					}
				}

				ProviderSubSystem_Common_Globals :: EndImpersonation ( t_OldContext , t_OldSecurity , t_Impersonating ) ;
			}

			t_Shutdown->Release () ;
		}
	}

	if ( m_CoreStub )
	{
		t_Shutdown = NULL ;
		t_Result = m_CoreStub->QueryInterface ( IID_IWbemShutdown , ( void ** ) & t_Shutdown ) ;
		if ( SUCCEEDED ( t_Result ) ) 
		{
			t_Result = t_Shutdown->Shutdown (

				a_Flags ,
				a_MaxMilliSeconds ,
				a_Context
			) ;

			t_Shutdown->Release () ;
		}
	}

	Lock () ;

	CWbemGlobal_IWmiObjectSinkController_Container *t_Container = NULL ;
	GetContainer ( t_Container ) ;

	IWbemShutdown **t_ShutdownElements = new IWbemShutdown * [ t_Container->Size () ] ;
	if ( t_ShutdownElements )
	{
		CWbemGlobal_IWmiObjectSinkController_Container_Iterator t_Iterator = t_Container->Begin ();

		ULONG t_Count = 0 ;
		while ( ! t_Iterator.Null () )
		{
			t_Result = t_Iterator.GetElement ()->QueryInterface ( IID_IWbemShutdown , ( void ** ) & t_ShutdownElements [ t_Count ] ) ;

			t_Iterator.Increment () ;

			t_Count ++ ;
		}

		UnLock () ;

		for ( ULONG t_Index = 0 ; t_Index < t_Count ; t_Index ++ )
		{
			if ( t_ShutdownElements [ t_Index ] ) 
			{
				t_Result = t_ShutdownElements [ t_Index ]->Shutdown ( 

					a_Flags ,
					a_MaxMilliSeconds ,
					a_Context
				) ;

				t_ShutdownElements [ t_Index ]->Release () ;
			}
		}

		delete [] t_ShutdownElements ;
	}
	else
	{	
		UnLock () ;

		t_Result = WBEM_E_OUT_OF_MEMORY ;
	}

	CWbemGlobal_IWmiObjectSinkController :: Shutdown () ;

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CInterceptor_IWbemDecoupledProvider :: Initialize (

	LONG a_Flags ,
	IWbemContext *a_Context ,
	GUID *a_TransactionIdentifier,
	LPCWSTR a_User ,
	LPCWSTR a_Locale ,
	LPCWSTR a_Namespace ,
	IWbemServices *a_Repository ,
	IWbemServices *a_Service ,
	IWbemProviderInitSink *a_Sink
)
{
	HRESULT t_Result = S_OK ;

	WmiStatusCode t_StatusCode = CWbemGlobal_IWmiObjectSinkController :: Initialize () ;
	if ( t_StatusCode != e_StatusCode_Success ) 
	{
		t_Result = WBEM_E_OUT_OF_MEMORY ;
	}

	if ( SUCCEEDED ( t_Result ) )
	{
		t_StatusCode = m_ProxyContainer.Initialize () ;
		if ( t_StatusCode != e_StatusCode_Success ) 
		{
			t_Result = WBEM_E_OUT_OF_MEMORY ;
		}
	}

	if ( SUCCEEDED ( t_Result ) ) 
	{
		if ( a_User ) 
		{
			m_User = SysAllocString ( a_User ) ;
			if ( m_User == NULL )
			{
				t_Result = WBEM_E_OUT_OF_MEMORY ;
			}
		}
	}

	if ( SUCCEEDED ( t_Result ) ) 
	{
		if ( a_Locale ) 
		{
			m_Locale = SysAllocString ( a_Locale ) ;
			if ( m_Locale == NULL )
			{
				t_Result = WBEM_E_OUT_OF_MEMORY ;
			}
		}
	}

	if ( SUCCEEDED ( t_Result ) ) 
	{
		if ( a_Namespace ) 
		{
			m_Namespace = SysAllocString ( a_Namespace ) ;
			if ( m_Namespace == NULL )
			{
				t_Result = WBEM_E_OUT_OF_MEMORY ;
			}
		}
	}

	if ( SUCCEEDED ( t_Result ) ) 
	{
		if ( a_TransactionIdentifier )
		{
			wchar_t t_TransactionIdentifier [ sizeof ( L"{00000000-0000-0000-0000-000000000000}" ) ] ;

			if ( a_TransactionIdentifier )
			{
				StringFromGUID2 ( *a_TransactionIdentifier , t_TransactionIdentifier , sizeof ( t_TransactionIdentifier ) / sizeof ( wchar_t ) );
			}

			m_TransactionIdentifier = SysAllocString ( t_TransactionIdentifier ) ;
		}
	}

	if ( a_Repository )
	{
		t_Result = a_Repository->GetObject ( 

			L"__ExtendedStatus" ,
			0 , 
			a_Context ,
			& m_ExtendedStatusObject ,
			NULL
		) ;
	}

	if ( SUCCEEDED ( t_Result ) )
	{
		m_InitializedEvent = CreateEvent ( NULL , TRUE , FALSE , NULL ) ;
		if ( m_InitializedEvent == NULL )
		{
			t_Result = t_Result = WBEM_E_OUT_OF_MEMORY ;
		}
	}

	if ( SUCCEEDED ( t_Result ) )
	{
		_IWmiProviderSite *t_Site = NULL ;
		t_Result = m_Unknown->QueryInterface ( IID__IWmiProviderSite , ( void ** ) & t_Site ) ;
		if ( SUCCEEDED ( t_Result ) )
		{
			t_Result = t_Site->GetSite ( & m_ProcessIdentifier ) ;
			t_Site->Release () ;

			// Add the process SD
			t_Result = AddProcessToSD(m_ProcessIdentifier, m_expandedSD, m_Registration->GetComRegistration ().GetSecurityDescriptor ());
		}
	}

	a_Sink->SetStatus ( t_Result , 0 ) ;

	return t_Result ;
}


HANDLE TokenOfProcess(DWORD a_ProcessIdentifier)
{
	HANDLE t_ProcessToken = NULL;

	HANDLE t_ProcessHandle = OpenProcess (
		MAXIMUM_ALLOWED ,
		FALSE ,
		a_ProcessIdentifier 
	) ;

	if ( t_ProcessHandle )
	{
		BOOL t_Status = OpenProcessToken (
			t_ProcessHandle ,
			TOKEN_QUERY ,
			& t_ProcessToken
		) ;
		CloseHandle(t_ProcessHandle);
	}
	return t_ProcessToken;
};

// If the oject is secured we are using that SD to secure the interceptor
// if not we are aloweing well knowns SID's plus the process owner to pass

HRESULT CInterceptor_IWbemDecoupledProvider :: AddProcessToSD (DWORD pid, SECURITY_DESCRIPTOR*& destSD, SECURITY_DESCRIPTOR* sourceSD )
{
	_DBG_ASSERT(pid !=0);

	HRESULT t_Result = S_OK;
	if (sourceSD) return t_Result;
	
	if(HANDLE t_Token = TokenOfProcess(pid))
	{
			DWORD t_OwnerSize = 0 ; 
			PSID t_OwnerSid = NULL ;
			BOOL t_OwnerDefaulted = FALSE ;

			t_Result = ProviderSubSystem_Common_Globals :: GetUserSid (

				t_Token ,
				& t_OwnerSize , 
				t_OwnerSid 
			) ; 

			if ( SUCCEEDED ( t_Result ) )
			{
				DWORD t_GroupSize = 0 ; 
				PSID t_GroupSid = NULL ;
				BOOL t_GroupDefaulted = FALSE ;

				t_Result = ProviderSubSystem_Common_Globals :: GetGroupSid (

					t_Token ,
					& t_GroupSize , 
					t_GroupSid 
				) ; 

				if ( SUCCEEDED ( t_Result ) )
				{
					t_Result = ProviderSubSystem_Common_Globals :: AdjustSecurityDescriptorWithSid ( 
						( SID * ) t_OwnerSid ,
						( SID * ) t_GroupSid ,
						MASK_PROVIDER_BINDING_BIND ,
						sourceSD , 
						destSD
					) ;

					delete [] ( BYTE * ) t_GroupSid ;
				}

				delete [] ( BYTE * ) t_OwnerSid ;
			}
			else
			{
				t_Result = WBEM_E_CRITICAL_ERROR ;
			}

			CloseHandle ( t_Token ) ;
	}
	else
	{
		t_Result = MAKE_HRESULT(SEVERITY_ERROR,FACILITY_WIN32,GetLastError());
	};
	
	return S_OK;
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\provsubsys\server\provhost.cpp ===
/*++

Copyright (C) 1996-2001 Microsoft Corporation

Module Name:

	ProvSubS.cpp

Abstract:


History:

--*/

#include <precomp.h>
#include <wbemint.h>

#include <HelperFuncs.h>
#include <Logging.h>

#include <CGlobals.h>
#include "Globals.h"
#include "ClassFac.h"
#include "ProvInSk.h"
#include "ProvLoad.h"
#include "ProvHost.h"
#include "ProvCache.h"
#include "ProvRMgr.h"
#include "Guids.h"
#include <tpwrap.cpp>

#ifdef WMIASLOCAL
#include "Main.h"
#endif

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CServerObject_HostInterceptor :: AbnormalShutdown (

	HostCacheKey &a_Key
) 
{
	WmiStatusCode t_StatusCode = ProviderSubSystem_Globals :: GetHostController ()->Shutdown ( a_Key ) ;
	if ( t_StatusCode == e_StatusCode_Success )
	{
	}

	return S_OK ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CServerObject_HostInterceptor :: CreateUsingToken (

	HostCacheKey &a_Key ,
	_IWmiProviderHost **a_Host ,
	_IWbemRefresherMgr **a_RefresherManager 
)
{
	HRESULT t_Result = FindHost (

		NULL , 
		a_Key ,
		IID__IWmiProviderHost ,
		( void ** ) a_Host
	) ;

	if ( SUCCEEDED ( t_Result ) )
	{
		t_Result = (*a_Host)->GetObject (

			CLSID__WbemHostedRefresherMgr ,
			0 ,
			NULL ,
			IID__IWbemRefresherMgr,
			( void ** ) a_RefresherManager 
		) ;

		if ( FAILED ( t_Result ) )
		{
			if ( ( HRESULT_ERROR_FUNC(t_Result) == RPC_S_SERVER_UNAVAILABLE ) || ( HRESULT_ERROR_FUNC(t_Result) == RPC_S_CALL_FAILED_DNE ) )
			{
				AbnormalShutdown ( a_Key ) ;
			}
		}
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CServerObject_HostInterceptor :: CreateUsingAccount (

	HostCacheKey &a_Key ,
	LPWSTR a_User ,
	LPWSTR a_Domain ,
	_IWmiProviderHost **a_Host ,
	_IWbemRefresherMgr **a_RefresherManager 
)
{
	HRESULT t_Result = S_OK ;

/*
 *	Revert to LocalService 
 */

	CoRevertToSelf () ;

/*
 *	Logon the system defined Account
 */

	HANDLE t_ThreadToken = NULL ;

	BOOL t_Status = LogonUser (

		a_User ,
		a_Domain ,
		NULL ,
		LOGON32_LOGON_SERVICE ,
		LOGON32_PROVIDER_WINNT50,
        & t_ThreadToken 
	) ;

	if ( t_Status )
	{
		t_Status = ImpersonateLoggedOnUser ( t_ThreadToken ) ;
		if ( t_Status )
		{
			ProviderSubSystem_Common_Globals :: EnableAllPrivileges () ;
		}
		else
		{
			t_Result = WBEM_E_ACCESS_DENIED ;

			DWORD t_LastError = GetLastError () ;
		}
	}
	else
	{
		t_Result = WBEM_E_ACCESS_DENIED ;

		DWORD t_LastError = GetLastError () ;
	}

	if ( SUCCEEDED ( t_Result ) )
	{
		t_Result = FindHost (

			NULL , 
			a_Key ,
			IID__IWmiProviderHost ,
			( void ** ) a_Host
		) ;
	}

	RevertToSelf () ;

	if ( t_ThreadToken )
	{
		CloseHandle ( t_ThreadToken ) ;
	}

	if ( SUCCEEDED ( t_Result ) )
	{
		t_Result = (*a_Host)->GetObject (

			CLSID__WbemHostedRefresherMgr ,
			0 ,
			NULL ,
			IID__IWbemRefresherMgr,
			( void ** ) a_RefresherManager 
		) ;

		if ( FAILED ( t_Result ) )
		{
			if ( ( HRESULT_ERROR_FUNC(t_Result) == RPC_S_SERVER_UNAVAILABLE ) || ( HRESULT_ERROR_FUNC(t_Result) == RPC_S_CALL_FAILED_DNE ) )
			{
				AbnormalShutdown ( a_Key ) ;
			}
		}
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CServerObject_HostInterceptor :: CreateUsingToken (

	HostCacheKey &a_Key ,
	_IWmiProviderHost **a_Host ,
	_IWmiProviderFactory **a_Factory 
)
{
	HRESULT t_Result = FindHost (

		NULL , 
		a_Key ,
		IID__IWmiProviderHost ,
		( void ** ) a_Host
	) ;

	if ( SUCCEEDED ( t_Result ) )
	{
		t_Result = (*a_Host)->GetObject (

			CLSID_WmiProviderHostedInProcFactory ,
			0 ,
			NULL ,
			IID__IWmiProviderFactory,
			( void ** ) a_Factory 
		) ;

		if ( FAILED ( t_Result ) )
		{
			if ( ( HRESULT_ERROR_FUNC(t_Result) == RPC_S_SERVER_UNAVAILABLE ) || ( HRESULT_ERROR_FUNC(t_Result) == RPC_S_CALL_FAILED_DNE ) )
			{
				AbnormalShutdown ( a_Key ) ;
			}
		}
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CServerObject_HostInterceptor :: CreateUsingAccount (

	HostCacheKey &a_Key ,
	LPWSTR a_User ,
	LPWSTR a_Domain ,
	_IWmiProviderHost **a_Host ,
	_IWmiProviderFactory **a_Factory 
)
{
	HRESULT t_Result = S_OK ;

/*
 *	Revert to LocalService 
 */

	CoRevertToSelf () ;

/*
 *	Logon the system defined Account
 */

	HANDLE t_ThreadToken = NULL ;

	BOOL t_Status = LogonUser (

		a_User ,
		a_Domain ,
		NULL ,
		LOGON32_LOGON_SERVICE ,
		LOGON32_PROVIDER_WINNT50,
        & t_ThreadToken 
	) ;

	if ( t_Status )
	{
		t_Status = ImpersonateLoggedOnUser ( t_ThreadToken ) ;
		if ( t_Status )
		{
			ProviderSubSystem_Common_Globals :: EnableAllPrivileges () ;
		}
		else
		{
			t_Result = WBEM_E_ACCESS_DENIED ;

			DWORD t_LastError = GetLastError () ;
		}
	}
	else
	{
		t_Result = WBEM_E_ACCESS_DENIED ;

		DWORD t_LastError = GetLastError () ;
	}

	if ( SUCCEEDED ( t_Result ) )
	{
		t_Result = FindHost (

			NULL , 
			a_Key ,
			IID__IWmiProviderHost ,
			( void ** ) a_Host
		) ;
	}

	RevertToSelf () ;

	if ( t_ThreadToken )
	{
		CloseHandle ( t_ThreadToken ) ;
	}

	if ( SUCCEEDED ( t_Result ) )
	{
		t_Result = (*a_Host)->GetObject (

			CLSID_WmiProviderHostedInProcFactory ,
			0 ,
			NULL ,
			IID__IWmiProviderFactory,
			( void ** ) a_Factory 
		) ;

		if ( FAILED ( t_Result ) )
		{
			if ( ( HRESULT_ERROR_FUNC(t_Result) == RPC_S_SERVER_UNAVAILABLE ) || ( HRESULT_ERROR_FUNC(t_Result) == RPC_S_CALL_FAILED_DNE ) )
			{
				AbnormalShutdown ( a_Key ) ;
			}
		}
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CServerObject_HostInterceptor :: FindHost ( 

	IWbemContext *a_Context ,
	HostCacheKey &a_Key ,
	REFIID a_RIID , 
	void **a_Interface 
)
{
	HRESULT t_Result = S_OK;

	*a_Interface = NULL ;

	ProviderSubSystem_Globals :: GetHostController ()->Lock () ;

	CWbemGlobal_IWmiHostController_Cache_Iterator t_Iterator ;

	WmiStatusCode t_StatusCode = ProviderSubSystem_Globals :: GetHostController ()->Find ( a_Key , t_Iterator ) ;
	if ( t_StatusCode == e_StatusCode_Success )
	{
		HostCacheElement *t_Element = t_Iterator.GetElement () ;

		ProviderSubSystem_Globals :: GetHostController ()->UnLock () ;

		CServerObject_HostInterceptor *t_HostInterceptor = NULL ;

		t_Result = t_Element->QueryInterface (

			IID_CServerObject_HostInterceptor ,
			( void ** ) & t_HostInterceptor
		) ;

		if ( SUCCEEDED ( t_Result ) )
		{
			t_Result = t_HostInterceptor->WaitHost ( a_Context , DEFAULT_PROVIDER_LOAD_TIMEOUT ) ;
			if ( SUCCEEDED ( t_Result ) )
			{
				t_Result = t_HostInterceptor->GetInitializeResult () ;
				if ( SUCCEEDED ( t_Result ) )
				{
					t_Result = t_Element->QueryInterface (

						a_RIID ,
						a_Interface
					) ;

					if ( FAILED ( t_Result ) )
					{
						t_Result = WBEM_E_PROVIDER_NOT_CAPABLE ;
					}
				}
			}

			t_HostInterceptor->Release () ;
		}
		else
		{
			t_Result = WBEM_E_UNEXPECTED ;
		}

		t_Element->Release () ;
	}
	else
	{
		CServerObject_HostInterceptor *t_HostInterceptor = new CServerObject_HostInterceptor ( 

			*ProviderSubSystem_Globals :: s_Allocator , 
			ProviderSubSystem_Globals :: GetHostController () , 
			a_Key ,
			ProviderSubSystem_Globals :: s_InternalCacheTimeout ,
			a_Context
		) ;

		if ( t_HostInterceptor ) 
		{
			t_HostInterceptor->AddRef () ;

			CServerObject_ProviderInitSink *t_ProviderInitSink = new CServerObject_ProviderInitSink ; 
			if ( t_ProviderInitSink )
			{
				t_ProviderInitSink->AddRef () ;

				t_Result = t_ProviderInitSink->SinkInitialize () ;
				if ( SUCCEEDED ( t_Result ) ) 
				{
					t_Result = t_HostInterceptor->Initialize (

						NULL ,
						t_ProviderInitSink
					) ;

					if ( SUCCEEDED ( t_Result ) )
					{
						t_ProviderInitSink->Wait () ;

						t_Result = t_ProviderInitSink->GetResult () ;
					}
				}

				t_ProviderInitSink->Release () ;
			}
			else
			{
				t_Result = WBEM_E_OUT_OF_MEMORY ;
			}
		}
		else
		{
			t_Result = WBEM_E_OUT_OF_MEMORY ;
		}

		if ( SUCCEEDED ( t_Result ) )
		{
			WmiStatusCode t_StatusCode = ProviderSubSystem_Globals :: GetHostController ()->Insert ( 

				*t_HostInterceptor ,
				t_Iterator
			) ;

			if ( t_StatusCode == e_StatusCode_Success ) 
			{
				ProviderSubSystem_Globals :: GetHostController ()->UnLock () ;

				IUnknown *t_Host = NULL ;

				t_Result = ProviderSubSystem_Common_Globals :: CreateInstance (

					CLSID_WmiProviderHost ,
					NULL ,
					CLSCTX_LOCAL_SERVER | CLSCTX_ENABLE_AAA ,
					IID_IUnknown ,
					( void ** ) & t_Host 
				) ;

				if ( SUCCEEDED ( t_Result ) ) 
				{
					t_HostInterceptor->SetHost ( t_Host ) ;

					t_Host->Release () ;
				}
			}
			else
			{
				ProviderSubSystem_Globals :: GetHostController ()->UnLock () ;

				t_Result = WBEM_E_OUT_OF_MEMORY ;
			}
		}
		else
		{
			ProviderSubSystem_Globals :: GetHostController ()->UnLock () ;
		}

		if ( SUCCEEDED ( t_Result ) )
		{
			DWORD t_ProcessIdentifier = 0 ;
			t_Result = t_HostInterceptor->GetProcessIdentifier ( & t_ProcessIdentifier ) ;
			if ( SUCCEEDED ( t_Result ) ) 
			{
				RevertToSelf () ;

				HANDLE t_Handle = OpenProcess (

					PROCESS_DUP_HANDLE | PROCESS_QUERY_INFORMATION | SYNCHRONIZE | PROCESS_SET_QUOTA | PROCESS_TERMINATE ,
					FALSE ,
					t_ProcessIdentifier
				) ;

				if ( t_Handle ) 
				{
					Task_ProcessTermination *t_Task = new Task_ProcessTermination ( *ProviderSubSystem_Globals :: s_Allocator , t_Handle , t_ProcessIdentifier ) ;
					if ( t_Task )
					{
							if (Dispatcher::registerHandlerOnce(*t_Task))
							{
								t_Result = ProviderSubSystem_Globals :: AssignProcessToJobObject ( t_Handle ) ;
							}
							else
							{
								t_Result = WBEM_E_OUT_OF_MEMORY ;
							}
							t_Task->Release();
					}
					else
					{
						t_Result = WBEM_E_OUT_OF_MEMORY ;
					}

				}
				else
				{
					DWORD t_LastError = GetLastError () ;

					t_Result = WBEM_E_ACCESS_DENIED ;
				}
			}

			if ( SUCCEEDED ( t_Result ) )
			{
				t_Result = t_HostInterceptor->QueryInterface (

					a_RIID ,
					a_Interface
				) ;
			}
		}

		if ( FAILED ( t_Result ) )
		{
			WmiStatusCode t_StatusCode = ProviderSubSystem_Globals :: GetHostController ()->Shutdown ( a_Key ) ; 
		}

		t_HostInterceptor->SetInitialized ( t_Result ) ;

		if ( t_HostInterceptor )
		{
			t_HostInterceptor->Release () ;
		}
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

#pragma warning( disable : 4355 )

CServerObject_HostInterceptor :: CServerObject_HostInterceptor (

	WmiAllocator &a_Allocator ,
	CWbemGlobal_IWmiHostController *a_Controller , 
	const HostCacheKey &a_Key ,
	const ULONG &a_Period ,
	IWbemContext *a_InitializationContext

) :	HostCacheElement ( 

		a_Controller ,
		a_Key ,
		a_Period 
	) ,
	m_Allocator ( a_Allocator ) ,
	m_ProxyContainer ( m_Allocator , 2 , MAX_PROXIES ) ,
	m_Unknown ( NULL ) ,
	m_Host_IWmiProviderHost ( NULL ) ,
	m_Host_IWbemShutdown ( NULL ) ,
	m_ProcessIdentifier ( 0 ) ,
	m_UnInitialized ( 0 ) ,
	m_Initialized ( 0 ) ,
	m_InitializeResult ( S_OK ) ,
	m_InitializedEvent ( NULL ) , 
	m_InitializationContext ( a_InitializationContext )
{
	InterlockedIncrement ( & ProviderSubSystem_Globals :: s_CServerObject_HostInterceptor_ObjectsInProgress ) ;

	ProviderSubSystem_Globals :: Increment_Global_Object_Count () ;

	if ( m_InitializationContext )
	{
		m_InitializationContext->AddRef () ;
	}
}

#pragma warning( default : 4355 )

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

CServerObject_HostInterceptor :: ~CServerObject_HostInterceptor ()
{
#if 0
wchar_t t_Buffer [ 128 ] ;
wsprintf ( t_Buffer , L"\n%lx - ~CServerObject_HostInterceptor ( %lx ) " , GetTickCount () , this ) ;
OutputDebugString ( t_Buffer ) ;
#endif

	if ( m_InitializationContext )
	{
		m_InitializationContext->Release () ;
	}

	if ( m_InitializedEvent )
	{
		CloseHandle ( m_InitializedEvent ) ;
	}

	InterlockedDecrement ( & ProviderSubSystem_Globals :: s_CServerObject_HostInterceptor_ObjectsInProgress ) ;

	ProviderSubSystem_Globals :: Decrement_Global_Object_Count () ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

STDMETHODIMP CServerObject_HostInterceptor :: QueryInterface (

	REFIID iid ,
	LPVOID FAR *iplpv
)
{
	*iplpv = NULL ;

	if ( iid == IID_IUnknown )
	{
		*iplpv = ( LPVOID ) this ;
	}
	else if ( iid == IID__IWmiProviderHost )
	{
		*iplpv = ( LPVOID ) ( _IWmiProviderHost * ) this ;		
	}
	else if ( iid == IID_IWbemShutdown )
	{
		*iplpv = ( LPVOID ) ( IWbemShutdown * ) this ;
	}
	else if ( iid == IID_CServerObject_HostInterceptor )
	{
		*iplpv = ( LPVOID ) ( CServerObject_HostInterceptor * ) this ;
	}

	if ( *iplpv )
	{
		( ( LPUNKNOWN ) *iplpv )->AddRef () ;

		return ResultFromScode ( S_OK ) ;
	}
	else
	{
		return ResultFromScode ( E_NOINTERFACE ) ;
	}
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

STDMETHODIMP_( ULONG ) CServerObject_HostInterceptor :: AddRef ()
{
	return HostCacheElement :: AddRef () ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

STDMETHODIMP_(ULONG) CServerObject_HostInterceptor :: Release ()
{
	return HostCacheElement :: Release () ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CServerObject_HostInterceptor :: Initialize (

	IWbemContext *a_Context ,
	IWbemProviderInitSink *a_Sink     // For init signals
)
{
	HRESULT t_Result = S_OK ;

	WmiStatusCode t_StatusCode = m_ProxyContainer.Initialize () ;
	if ( t_StatusCode != e_StatusCode_Success ) 
	{
		t_Result = WBEM_E_OUT_OF_MEMORY ;
	}

	if ( SUCCEEDED ( t_Result ) )
	{
		m_InitializedEvent = CreateEvent ( NULL , TRUE , FALSE , NULL ) ;
		if ( m_InitializedEvent == NULL )
		{
			t_Result = t_Result = WBEM_E_OUT_OF_MEMORY ;
		}
	}

	a_Sink->SetStatus ( t_Result , 0 ) ;

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CServerObject_HostInterceptor :: SetHost ( IUnknown *a_Unknown )
{
	m_Unknown = a_Unknown ;
	m_Unknown->AddRef () ;

	HRESULT t_TempResult = m_Unknown->QueryInterface ( IID_IWbemShutdown , ( void ** ) & m_Host_IWbemShutdown ) ;
	t_TempResult = m_Unknown->QueryInterface ( IID__IWmiProviderHost , ( void ** ) & m_Host_IWmiProviderHost ) ;

	return S_OK ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CServerObject_HostInterceptor :: SetInitialized ( HRESULT a_InitializeResult )
{
	m_InitializeResult = a_InitializeResult ;

	InterlockedExchange ( & m_Initialized , 1 ) ;

	if ( m_InitializedEvent )
	{
		SetEvent ( m_InitializedEvent ) ;
	}

	return S_OK ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CServerObject_HostInterceptor :: IsIndependant ( IWbemContext *a_Context )
{
	BOOL t_DependantCall = FALSE ;
	HRESULT t_Result = ProviderSubSystem_Common_Globals :: IsDependantCall ( m_InitializationContext , a_Context , t_DependantCall ) ;
	if ( SUCCEEDED ( t_Result ) )
	{
		if ( t_DependantCall == FALSE )
		{
		}
		else
		{
			return S_FALSE ;
		}
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CServerObject_HostInterceptor :: WaitHost ( IWbemContext *a_Context , ULONG a_Timeout )
{
	HRESULT t_Result = WBEM_E_UNEXPECTED ;

	if ( m_Initialized == 0 )
	{
		BOOL t_DependantCall = FALSE ;
		t_Result = ProviderSubSystem_Common_Globals :: IsDependantCall ( m_InitializationContext , a_Context , t_DependantCall ) ;
		if ( SUCCEEDED ( t_Result ) )
		{
			if ( t_DependantCall == FALSE )
			{
				if ( WaitForSingleObject ( m_InitializedEvent , a_Timeout ) == WAIT_TIMEOUT )
				{
					return WBEM_E_PROVIDER_LOAD_FAILURE ;
				}
			}
			else
			{
				if ( WaitForSingleObject ( m_InitializedEvent , 0 ) == WAIT_TIMEOUT )
				{
					return S_FALSE ;
				}
			}
		}
	}
	else
	{
		t_Result = S_OK ;
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

void CServerObject_HostInterceptor :: CallBackInternalRelease ()
{
	if ( InterlockedCompareExchange ( & m_UnInitialized ,  1 , 0 ) == 0 )
	{
		WmiStatusCode t_StatusCode = m_ProxyContainer.UnInitialize () ;

		if ( m_Unknown )
		{
			m_Unknown->Release () ;
			m_Unknown = NULL ;
		}

		if ( m_Host_IWmiProviderHost )
		{
			m_Host_IWmiProviderHost->Release () ; 
			m_Host_IWmiProviderHost = NULL ;
		}

		if ( m_Host_IWbemShutdown )
		{
			m_Host_IWbemShutdown->Release () ;
			m_Host_IWbemShutdown = NULL ;
		}
	}
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CServerObject_HostInterceptor :: GetObject (

	REFCLSID a_Clsid ,
	long a_Flags ,
	IWbemContext *a_Context ,
	REFIID a_Riid ,
	void **a_Interface
)
{
	HRESULT t_Result = S_OK ;

	if ( m_Host_IWmiProviderHost )
	{
		BOOL t_Impersonating = FALSE ;
		IUnknown *t_OldContext = NULL ;
		IServerSecurity *t_OldSecurity = NULL ;

		t_Result = ProviderSubSystem_Common_Globals :: BeginCallbackImpersonation ( t_OldContext , t_OldSecurity , t_Impersonating ) ;
		if ( SUCCEEDED ( t_Result ) ) 
		{
			BOOL t_Revert = FALSE ;
			IUnknown *t_Proxy = NULL ;

			t_Result = ProviderSubSystem_Common_Globals :: SetProxyState ( m_ProxyContainer , ProxyIndex_Host__IWmiProviderHost , IID__IWmiProviderHost , m_Host_IWmiProviderHost , t_Proxy , t_Revert ) ;
			if ( t_Result == WBEM_E_NOT_FOUND )
			{
				t_Result = m_Host_IWmiProviderHost->GetObject (

					a_Clsid ,
					a_Flags ,
					a_Context ,
					a_Riid ,
					a_Interface
				) ;
			}
			else
			{
				if ( SUCCEEDED ( t_Result ) )
				{
					_IWmiProviderHost *t_Host = ( _IWmiProviderHost * ) t_Proxy ;

					// Set cloaking on the proxy
					// =========================

					DWORD t_ImpersonationLevel = ProviderSubSystem_Common_Globals :: GetCurrentImpersonationLevel () ;

					t_Result = ProviderSubSystem_Common_Globals :: SetCloaking (

						t_Host ,
						RPC_C_AUTHN_LEVEL_CONNECT , 
						t_ImpersonationLevel
					) ;

					if ( SUCCEEDED ( t_Result ) )
					{
						t_Result = CoImpersonateClient () ;
						if ( SUCCEEDED ( t_Result ) )
						{
							t_Result = t_Host->GetObject (

								a_Clsid ,
								a_Flags ,
								a_Context ,
								a_Riid ,
								a_Interface
							) ;

							CoRevertToSelf () ;
						}
						else
						{
							t_Result = WBEM_E_ACCESS_DENIED ;
						}
					}	

					HRESULT t_TempResult = ProviderSubSystem_Common_Globals :: RevertProxyState ( m_ProxyContainer , ProxyIndex_Host__IWmiProviderHost , t_Proxy , t_Revert ) ;
				}
			}

			ProviderSubSystem_Common_Globals :: EndImpersonation ( t_OldContext , t_OldSecurity , t_Impersonating ) ;
		}
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CServerObject_HostInterceptor :: GetProcessIdentifier ( DWORD *a_ProcessIdentifier )
{
	HRESULT t_Result = S_OK ;

	if ( m_Host_IWmiProviderHost )
	{
		BOOL t_Impersonating = FALSE ;
		IUnknown *t_OldContext = NULL ;
		IServerSecurity *t_OldSecurity = NULL ;

		t_Result = ProviderSubSystem_Common_Globals :: BeginCallbackImpersonation ( t_OldContext , t_OldSecurity , t_Impersonating ) ;
		if ( SUCCEEDED ( t_Result ) ) 
		{
			BOOL t_Revert = FALSE ;
			IUnknown *t_Proxy = NULL ;

			t_Result = ProviderSubSystem_Common_Globals :: SetProxyState ( m_ProxyContainer , ProxyIndex_Host__IWmiProviderHost , IID__IWmiProviderHost , m_Host_IWmiProviderHost , t_Proxy , t_Revert ) ;
			if ( t_Result == WBEM_E_NOT_FOUND )
			{
				t_Result = m_Host_IWmiProviderHost->GetProcessIdentifier (

					a_ProcessIdentifier
				) ;

				if ( SUCCEEDED ( t_Result ) ) 
				{
					m_ProcessIdentifier = *a_ProcessIdentifier ;
				}
			}
			else
			{
				if ( SUCCEEDED ( t_Result ) )
				{
					_IWmiProviderHost *t_Host = ( _IWmiProviderHost * ) t_Proxy ;

					// Set cloaking on the proxy
					// =========================

					DWORD t_ImpersonationLevel = ProviderSubSystem_Common_Globals :: GetCurrentImpersonationLevel () ;

					t_Result = ProviderSubSystem_Common_Globals :: SetCloaking (

						t_Host ,
						RPC_C_AUTHN_LEVEL_CONNECT , 
						t_ImpersonationLevel
					) ;

					if ( SUCCEEDED ( t_Result ) )
					{
						t_Result = CoImpersonateClient () ;
						if ( SUCCEEDED ( t_Result ) )
						{
							t_Result = t_Host->GetProcessIdentifier (

								a_ProcessIdentifier
							) ;

							if ( SUCCEEDED ( t_Result ) ) 
							{
								m_ProcessIdentifier = *a_ProcessIdentifier ;
							}

							CoRevertToSelf () ;
						}
						else
						{
							t_Result = WBEM_E_ACCESS_DENIED ;
						}
					}	

					HRESULT t_TempResult = ProviderSubSystem_Common_Globals :: RevertProxyState ( m_ProxyContainer , ProxyIndex_Host__IWmiProviderHost , t_Proxy , t_Revert ) ;
				}
			}

			ProviderSubSystem_Common_Globals :: EndImpersonation ( t_OldContext , t_OldSecurity , t_Impersonating ) ;
		}
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CServerObject_HostInterceptor :: Shutdown (

	LONG a_Flags ,
	ULONG a_MaxMilliSeconds ,
	IWbemContext *a_Context
)
{
	HRESULT t_Result = S_OK ;

	if ( m_Host_IWbemShutdown )
	{
		BOOL t_Impersonating = FALSE ;
		IUnknown *t_OldContext = NULL ;
		IServerSecurity *t_OldSecurity = NULL ;

		t_Result = ProviderSubSystem_Common_Globals :: BeginCallbackImpersonation ( t_OldContext , t_OldSecurity , t_Impersonating ) ;
		if ( SUCCEEDED ( t_Result ) ) 
		{
			BOOL t_Revert = FALSE ;
			IUnknown *t_Proxy = NULL ;

			t_Result = ProviderSubSystem_Common_Globals :: SetProxyState ( m_ProxyContainer , ProxyIndex_Host_IWbemShutdown , IID_IWbemShutdown , m_Host_IWbemShutdown , t_Proxy , t_Revert ) ;
			if ( t_Result == WBEM_E_NOT_FOUND )
			{
				t_Result = m_Host_IWbemShutdown->Shutdown (

					a_Flags ,
					a_MaxMilliSeconds ,
					a_Context
				) ;
			}
			else
			{
				if ( SUCCEEDED ( t_Result ) )
				{
					IWbemShutdown *t_Host = ( IWbemShutdown * ) t_Proxy ;

					// Set cloaking on the proxy
					// =========================

					DWORD t_ImpersonationLevel = ProviderSubSystem_Common_Globals :: GetCurrentImpersonationLevel () ;

					t_Result = ProviderSubSystem_Common_Globals :: SetCloaking (

						t_Host ,
						RPC_C_AUTHN_LEVEL_CONNECT , 
						t_ImpersonationLevel
					) ;

					if ( SUCCEEDED ( t_Result ) )
					{
						t_Result = CoImpersonateClient () ;
						if ( SUCCEEDED ( t_Result ) )
						{
							t_Result = t_Host->Shutdown (

								a_Flags ,
								a_MaxMilliSeconds ,
								a_Context
							) ;

							CoRevertToSelf () ;
						}
						else
						{
							t_Result = WBEM_E_ACCESS_DENIED ;
						}
					}	

					HRESULT t_TempResult = ProviderSubSystem_Common_Globals :: RevertProxyState ( m_ProxyContainer , ProxyIndex_Host_IWbemShutdown , t_Proxy , t_Revert ) ;
				}
			}

			ProviderSubSystem_Common_Globals :: EndImpersonation ( t_OldContext , t_OldSecurity , t_Impersonating ) ;
		}
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

#pragma warning( disable : 4355 )

CServerObject_Host :: CServerObject_Host (

	WmiAllocator &a_Allocator

) :	m_Allocator ( a_Allocator )
{
	InterlockedIncrement ( & ProviderSubSystem_Globals :: s_CServerObject_Host_ObjectsInProgress ) ;

	ProviderSubSystem_Globals :: Increment_Global_Object_Count () ;
}

#pragma warning( default : 4355 )

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

CServerObject_Host :: ~CServerObject_Host ()
{
	InterlockedDecrement ( & ProviderSubSystem_Globals :: s_CServerObject_Host_ObjectsInProgress ) ;

	ProviderSubSystem_Globals :: Decrement_Global_Object_Count () ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

STDMETHODIMP CServerObject_Host :: QueryInterface (

	REFIID iid ,
	LPVOID FAR *iplpv
)
{
	*iplpv = NULL ;

	if ( iid == IID_IUnknown )
	{
		*iplpv = ( LPVOID ) this ;
	}
	else if ( iid == IID__IWmiProviderHost )
	{
		*iplpv = ( LPVOID ) ( _IWmiProviderHost * ) this ;		
	}	
	else if ( iid == IID_IWbemShutdown )
	{
		*iplpv = ( LPVOID ) ( IWbemShutdown * )this ;		
	}	

	if ( *iplpv )
	{
		( ( LPUNKNOWN ) *iplpv )->AddRef () ;

		return ResultFromScode ( S_OK ) ;
	}
	else
	{
		return ResultFromScode ( E_NOINTERFACE ) ;
	}
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

STDMETHODIMP_( ULONG ) CServerObject_Host :: AddRef ()
{
	return InterlockedIncrement ( & m_ReferenceCount ) ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

STDMETHODIMP_(ULONG) CServerObject_Host :: Release ()
{
	ULONG t_ReferenceCount = InterlockedDecrement ( & m_ReferenceCount ) ;
	if ( t_ReferenceCount == 0 )
	{
		delete this ;
	}

	return t_ReferenceCount ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CServerObject_Host :: GetObject (

	REFCLSID a_Clsid ,
	long a_Flags ,
	IWbemContext *a_Context ,
	REFIID a_Riid ,
	void **a_Interface
)
{
	if ( a_Clsid == CLSID_WmiProviderHostedInProcFactory )
	{
		IUnknown *lpunk = ( _IWmiProviderFactory * ) new CServerObject_RawFactory ( *ProviderSubSystem_Globals :: s_Allocator );
		if ( lpunk )
		{
			HRESULT t_Result = lpunk->QueryInterface ( a_Riid , a_Interface ) ;
			if ( SUCCEEDED ( t_Result ) )
			{
			}
			else
			{
				delete lpunk ;		
			}	

			return t_Result ;		
		}
		else
		{
			return E_OUTOFMEMORY ;
		}
	}
	else if ( a_Clsid == CLSID__WbemHostedRefresherMgr )
	{
		IUnknown