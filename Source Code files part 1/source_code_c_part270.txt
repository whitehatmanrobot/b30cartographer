
            }

            public IntPtr WriteHandle {
                get {
                    if (writeHandle == (IntPtr)(-1)) {
                        if (this.disposed)
                            throw new ObjectDisposedException(GetType().Name);
                        
                        lock(this) {
                            if (writeHandle == (IntPtr)(-1)) {
                                IntPtr result;
                                int status = UnsafeNativeMethods.MQOpenQueue(this.formatName, NativeMethods.QUEUE_ACCESS_SEND, 0, out result);
                                if (MessageQueue.IsFatalError(status))
                                    throw new MessageQueueException(status);

                                writeHandle = result;
                            }
                        }
                    }

                    return writeHandle;
                }
            }

            public bool Transactional {
                get {
                    if (!isTransactional_valid) {
                        lock(this) {
                            if (!isTransactional_valid) {
                                QueuePropertyVariants props = new QueuePropertyVariants();
                                props.SetUI1(NativeMethods.QUEUE_PROPID_TRANSACTION, (byte)0);
                                int status = UnsafeNativeMethods.MQGetQueueProperties(formatName, props.Lock());
                                props.Unlock();
                                if (MessageQueue.IsFatalError(status))
                                    throw new MessageQueueException(status);
                                
                                this.isTransactional = (props.GetUI1(NativeMethods.QUEUE_PROPID_TRANSACTION) != NativeMethods.QUEUE_TRANSACTIONAL_NONE);
                                isTransactional_valid = true;
                            }
                        }
                    }

                    return isTransactional;
                }
            }

            public void AddRef() {
                lock (this) {
                    ++ refCount;                
                }                    
            }                                                    
             
            public void BindToThreadPool() {   
                if (!this.boundToThreadPool) {                    
                    lock (this) {
                        if (!this.boundToThreadPool) {                    
                            //SECREVIEW: At this point at least MessageQueue permission with Browse
                            //                         access has already been demanded.
                            SecurityPermission permission = new SecurityPermission(PermissionState.Unrestricted);
                            permission.Assert();
                            try {
                                ThreadPool.BindHandle(ReadHandle);
                            }
                            finally {
                                SecurityPermission.RevertAssert();
                            }
                                                            
                            this.boundToThreadPool = true;
                        }                     
                    }                    
                }
            }
                                                                                                
            public void CloseIfNotReferenced() {
                lock (this) {
                    if (refCount == 0)
                        Close();
                }
            }
                                         
            public void Close() {
                this.boundToThreadPool = false;
                if (this.writeHandle != (IntPtr)(-1)) {                
                    lock(this) {
                        if (this.writeHandle != (IntPtr)(-1)) {
                            SafeNativeMethods.MQCloseQueue(this.writeHandle);
                            this.writeHandle = (IntPtr)(-1);                            
                        }
                    }
                }                
                if (this.readHandle != (IntPtr)(-1)) {
                    lock(this) {
                        if (this.readHandle != (IntPtr)(-1)) {
                            SafeNativeMethods.MQCloseQueue(this.readHandle);                
                            this.readHandle = (IntPtr)(-1);                             
                        }
                    }
                }
            }
                                    
            public void Dispose() {                        
                Dispose(true);            
                GC.SuppressFinalize(this);                           
            }                         
                    
            protected virtual void Dispose(bool disposing) {
                if (disposing)
                    this.Close();      
                else {
                     if (this.writeHandle != (IntPtr)(-1)) {
                        SafeNativeMethods.MQCloseQueue(this.writeHandle);
                        this.writeHandle = (IntPtr)(-1);                            
                    }
                    
                    if (this.readHandle != (IntPtr)(-1)) {
                        SafeNativeMethods.MQCloseQueue(this.readHandle);                
                        this.readHandle = (IntPtr)(-1);                             
                    }
                }                    
                this.disposed = true;                      
            }
                                   
            public void Release() {
                lock (this) {
                    -- refCount;                
                }                    
            }
                                                                             
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\services\messaging\system\messaging\messagequeuetransactiontype.cs ===
//------------------------------------------------------------------------------
// <copyright file="MessageQueueTransactionType.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Messaging {
    using System.Diagnostics;
    using System.Messaging.Interop;
    
    /// <include file='doc\MessageQueueTransactionType.uex' path='docs/doc[@for="MessageQueueTransactionType"]/*' />
    /// <devdoc>
    ///    <para>[To be supplied.]</para>
    /// </devdoc>
    public enum MessageQueueTransactionType {
        /// <include file='doc\MessageQueueTransactionType.uex' path='docs/doc[@for="MessageQueueTransactionType.None"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        None = NativeMethods.QUEUE_TRANSACTION_NONE,
        /// <include file='doc\MessageQueueTransactionType.uex' path='docs/doc[@for="MessageQueueTransactionType.Automatic"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        Automatic = NativeMethods.QUEUE_TRANSACTION_MTS,
        /// <include file='doc\MessageQueueTransactionType.uex' path='docs/doc[@for="MessageQueueTransactionType.Single"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        Single = NativeMethods.QUEUE_TRANSACTION_SINGLE,        
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\services\messaging\system\messaging\peekcompletedeventhandler.cs ===
//------------------------------------------------------------------------------
// <copyright file="PeekCompletedEventHandler.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Messaging {

    using System.Diagnostics;

    using System;

    // <summary>
    //    Represents the signature of the callback that will
    //    be executed when an asynchronous message queue
    //    peek operation is completed.
    // </summary>
    // <param name='sender'>
    //    Contains the MessageQueue object that calls the method.
    // </param>
    // <param name='args'>
    //    The event information associated with the call.
    // </param>
    // </doc>
    //    
    /// <include file='doc\PeekCompletedEventHandler.uex' path='docs/doc[@for="PeekCompletedEventHandler"]/*' />
    /// <devdoc>
    /// <para>Represents the method that will handle the <see cref='System.Messaging.MessageQueue.PeekCompleted'/> event of a <see cref='System.Messaging.MessageQueue'/>.</para>
    /// </devdoc>
    public delegate void PeekCompletedEventHandler(object sender, PeekCompletedEventArgs e);

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\services\messaging\system\messaging\receivecompletedeventhandler.cs ===
//------------------------------------------------------------------------------
// <copyright file="ReceiveCompletedEventHandler.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Messaging {

    using System.Diagnostics;

    using System;

    // <summary>
    //    Represents the signature of the callback that will
    //    be executed when an asynchronous message queue
    //    receive operation is completed.
    // </summary>
    // <param name='sender'>
    //    Contains the MessageQueue object that calls the method.
    // </param>
    // <param name='args'>
    //    The event information associated with the call.
    // </param>
    // </doc>
    //    
    /// <include file='doc\ReceiveCompletedEventHandler.uex' path='docs/doc[@for="ReceiveCompletedEventHandler"]/*' />
    /// <devdoc>
    /// <para>Represents the method that will handle the <see cref='System.Messaging.MessageQueue.ReceiveCompleted'/> event of a <see cref='System.Messaging.MessageQueue'/>.</para>
    /// </devdoc>
    public delegate void ReceiveCompletedEventHandler(object sender, ReceiveCompletedEventArgs e);

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\services\messaging\system\messaging\peekcompletedeventargs.cs ===
//------------------------------------------------------------------------------
// <copyright file="PeekCompletedEventArgs.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Messaging {

    using System.Diagnostics;

    using System;
 
    /// <include file='doc\PeekCompletedEventArgs.uex' path='docs/doc[@for="PeekCompletedEventArgs"]/*' />
    /// <devdoc>
    /// <para>Provides data for the <see cref='System.Messaging.MessageQueue.PeekCompleted'/> event. When your asynchronous 
    ///    operation calls an event handler, an instance of this class is passed to the
    ///    handler.</para>
    /// </devdoc>
    public class PeekCompletedEventArgs : EventArgs {   
        private IAsyncResult result;
        private Message message;        
        private MessageQueue sender;
        
        /// <include file='doc\PeekCompletedEventArgs.uex' path='docs/doc[@for="PeekCompletedEventArgs.PeekCompletedEventArgs"]/*' />
        /// <internalonly/>            
        internal PeekCompletedEventArgs(MessageQueue sender, IAsyncResult result) {
            this.result = result;
            this.sender = sender;
        }
        
        /// <include file='doc\PeekCompletedEventArgs.uex' path='docs/doc[@for="PeekCompletedEventArgs.AsyncResult"]/*' />
        /// <devdoc>
        ///    <para>Contains the result of the asynchronous
        ///       operation requested.</para>
        /// </devdoc>
        public IAsyncResult AsyncResult {
            get {
                return this.result;
            }
            
            set {
                this.result = value;
            }
        }
        
        /// <include file='doc\PeekCompletedEventArgs.uex' path='docs/doc[@for="PeekCompletedEventArgs.Message"]/*' />
        /// <devdoc>
        ///    <para>The end result of the posted asynchronous peek
        ///       operation.</para>
        /// </devdoc>
        public Message  Message {
            get {
                if (this.message == null) {
                    try {
                        this.message = this.sender.EndPeek(result);
                    }
                    catch {
                        throw;
                    }
                }
            
                return this.message;
            }                
        }        
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\services\messaging\system\messaging\messagingdescriptionattribute.cs ===
//------------------------------------------------------------------------------
// <copyright file="MessagingDescriptionAttribute.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Messaging {


    using System;
    using System.ComponentModel;   

    /// <include file='doc\MessagingDescriptionAttribute.uex' path='docs/doc[@for="MessagingDescriptionAttribute"]/*' />
    /// <devdoc>
    ///     DescriptionAttribute marks a property, event, or extender with a
    ///     description. Visual designers can display this description when referencing
    ///     the member.
    /// </devdoc>
    [AttributeUsage(AttributeTargets.All)]
    public class MessagingDescriptionAttribute : DescriptionAttribute {

        private bool replaced = false;

        /// <include file='doc\MessagingDescriptionAttribute.uex' path='docs/doc[@for="MessagingDescriptionAttribute.MessagingDescriptionAttribute"]/*' />
        /// <devdoc>
        ///     Constructs a new sys description.
        /// </devdoc>
        public MessagingDescriptionAttribute(string description) : base(description) {
        }

        /// <include file='doc\MessagingDescriptionAttribute.uex' path='docs/doc[@for="MessagingDescriptionAttribute.Description"]/*' />
        /// <devdoc>
        ///     Retrieves the description text.
        /// </devdoc>
        public override string Description {
            get {
                if (!replaced) {
                    replaced = true;
                    DescriptionValue = Res.GetString(base.Description);
                }
                return base.Description;
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\services\messaging\system\messaging\receivecompletedeventargs.cs ===
//------------------------------------------------------------------------------
// <copyright file="ReceiveCompletedEventArgs.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Messaging {

    using System.Diagnostics;

    using System;
 
    /// <include file='doc\ReceiveCompletedEventArgs.uex' path='docs/doc[@for="ReceiveCompletedEventArgs"]/*' />
    /// <devdoc>
    /// <para>Provides data for the <see cref='System.Messaging.MessageQueue.ReceiveCompleted'/> 
    /// event.</para>
    /// </devdoc>
    public class ReceiveCompletedEventArgs : EventArgs {   
        private IAsyncResult result;
        private Message message;        
        private MessageQueue sender;
                
        /// <include file='doc\ReceiveCompletedEventArgs.uex' path='docs/doc[@for="ReceiveCompletedEventArgs.ReceiveCompletedEventArgs"]/*' />
        /// <internalonly/>            
        internal ReceiveCompletedEventArgs(MessageQueue sender, IAsyncResult result) {
            this.result = result;
            this.sender = sender;
        }
        
        /// <include file='doc\ReceiveCompletedEventArgs.uex' path='docs/doc[@for="ReceiveCompletedEventArgs.AsyncResult"]/*' />
        /// <devdoc>
        ///    <para>Contains the result of the asynchronous
        ///       operation requested.</para>
        /// </devdoc>
        public IAsyncResult AsyncResult {
            get {
                return this.result;
            }
            
            set {
                this.result = value;
            }
        }
        
        /// <include file='doc\ReceiveCompletedEventArgs.uex' path='docs/doc[@for="ReceiveCompletedEventArgs.Message"]/*' />
        /// <devdoc>
        ///    <para>The end result of the posted asynchronous receive
        ///       operation.</para>
        /// </devdoc>
        public Message  Message {
            get {
                if (this.message == null) {
                    try {
                        this.message = this.sender.EndReceive(result);
                    }
                    catch {
                        throw;
                    }
                }
            
                return this.message;
            }
        }     
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\services\messaging\system\messaging\standardaccessrights.cs ===
//------------------------------------------------------------------------------
// <copyright file="StandardAccessRights.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>
//------------------------------------------------------------------------------


/**************************************************************************\
*
* Copyright (c) 1998-2002, Microsoft Corp.  All Rights Reserved.
*
* Module Name:
*
*   StandardAccessRights.cs
*
* Abstract:
*
* Revision History:
*
\**************************************************************************/
 namespace System.Messaging {
    /// <include file='doc\StandardAccessRights.uex' path='docs/doc[@for="StandardAccessRights"]/*' />
    /// <devdoc>
    ///    <para>[To be supplied.]</para>
    /// </devdoc>
    [Flags]
    public enum StandardAccessRights {
        /// <include file='doc\StandardAccessRights.uex' path='docs/doc[@for="StandardAccessRights.Delete"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        Delete        = 1 << 16,
        /// <include file='doc\StandardAccessRights.uex' path='docs/doc[@for="StandardAccessRights.ReadSecurity"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        ReadSecurity  = 1 << 17,
        /// <include file='doc\StandardAccessRights.uex' path='docs/doc[@for="StandardAccessRights.WriteSecurity"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        WriteSecurity = 1 << 18,
        /// <include file='doc\StandardAccessRights.uex' path='docs/doc[@for="StandardAccessRights.Synchronize"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        Synchronize   = 1 << 20,
        /// <include file='doc\StandardAccessRights.uex' path='docs/doc[@for="StandardAccessRights.ModifyOwner"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        ModifyOwner   = 1 << 19,
        /// <include file='doc\StandardAccessRights.uex' path='docs/doc[@for="StandardAccessRights.Read"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        Read = ReadSecurity,
        /// <include file='doc\StandardAccessRights.uex' path='docs/doc[@for="StandardAccessRights.Write"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        Write = ReadSecurity,
        /// <include file='doc\StandardAccessRights.uex' path='docs/doc[@for="StandardAccessRights.Execute"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        Execute = ReadSecurity,
        /// <include file='doc\StandardAccessRights.uex' path='docs/doc[@for="StandardAccessRights.Required"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        Required = Delete | WriteSecurity | ModifyOwner,
        /// <include file='doc\StandardAccessRights.uex' path='docs/doc[@for="StandardAccessRights.All"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        All = Delete | WriteSecurity | ModifyOwner | ReadSecurity | Synchronize,
        /// <include file='doc\StandardAccessRights.uex' path='docs/doc[@for="StandardAccessRights.None"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        None = 0
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\services\messaging\system\messaging\trusteetype.cs ===
//------------------------------------------------------------------------------
// <copyright file="TrusteeType.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>
//------------------------------------------------------------------------------


/**************************************************************************\
*
* Copyright (c) 1998-2002, Microsoft Corp.  All Rights Reserved.
*
* Module Name:
*
*   TrusteeType.cs
*
* Abstract:
*
* Revision History:
*
\**************************************************************************/
namespace System.Messaging {
    /// <include file='doc\TrusteeType.uex' path='docs/doc[@for="TrusteeType"]/*' />
    /// <devdoc>
    ///    <para>[To be supplied.]</para>
    /// </devdoc>
    public enum TrusteeType {
        /// <include file='doc\TrusteeType.uex' path='docs/doc[@for="TrusteeType.Unknown"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        Unknown  = 0,
        /// <include file='doc\TrusteeType.uex' path='docs/doc[@for="TrusteeType.User"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        User     = 1,
        /// <include file='doc\TrusteeType.uex' path='docs/doc[@for="TrusteeType.Group"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        Group    = 2,
        /// <include file='doc\TrusteeType.uex' path='docs/doc[@for="TrusteeType.Domain"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        Domain   = 3,
        /// <include file='doc\TrusteeType.uex' path='docs/doc[@for="TrusteeType.Alias"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        Alias    = 4,
        /// <include file='doc\TrusteeType.uex' path='docs/doc[@for="TrusteeType.Computer"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        Computer = 5
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\services\messaging\system\messaging\trustee.cs ===
//------------------------------------------------------------------------------
// <copyright file="Trustee.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>
//------------------------------------------------------------------------------


/**************************************************************************\
*
* Copyright (c) 1998-2002, Microsoft Corp.  All Rights Reserved.
*
* Module Name:
*
*   Trustee.cs
*
* Abstract:
*
* Revision History:
*
\**************************************************************************/
using System;
using System.Collections;
using System.Runtime.InteropServices;
using System.ComponentModel;
using System.Text;
using System.Messaging.Interop;
using System.Messaging;

namespace System.Messaging {
    
    /// <include file='doc\Trustee.uex' path='docs/doc[@for="Trustee"]/*' />
    /// <devdoc>
    ///    <para>[To be supplied.]</para>
    /// </devdoc>
    public class Trustee {
        string name;
        string systemName;
        TrusteeType trusteeType;
    
        /// <include file='doc\Trustee.uex' path='docs/doc[@for="Trustee.Name"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public string Name {
            get { return name; }
            set { 
                if (value == null)
                    throw new ArgumentNullException("value");
                    
                name = value; 
            }
        }
    
        /// <include file='doc\Trustee.uex' path='docs/doc[@for="Trustee.SystemName"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public string SystemName {
            get { return systemName; }
            set { systemName = value; }
        }

        /// <include file='doc\Trustee.uex' path='docs/doc[@for="Trustee.TrusteeType"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public TrusteeType TrusteeType {
            get { return trusteeType; }
            set { 
                if (!Enum.IsDefined(typeof(TrusteeType), value)) 
                    throw new InvalidEnumArgumentException("value", (int)value, typeof(TrusteeType));
                    
                trusteeType = value; 
            }
        }
    
        /// <include file='doc\Trustee.uex' path='docs/doc[@for="Trustee.Trustee"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public Trustee() {            
        }
        
        /// <include file='doc\Trustee.uex' path='docs/doc[@for="Trustee.Trustee1"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public Trustee(string name) : this(name, null) {}
        
        /// <include file='doc\Trustee.uex' path='docs/doc[@for="Trustee.Trustee2"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public Trustee(string name, string systemName) : this(name, systemName, System.Messaging.TrusteeType.Unknown) {}
        
        /// <include file='doc\Trustee.uex' path='docs/doc[@for="Trustee.Trustee3"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public Trustee(string name, string systemName, TrusteeType trusteeType) {            
            this.Name = name;
            this.SystemName = systemName;
            this.TrusteeType = trusteeType;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\services\messaging\system\messaging\design\sizeconverter.cs ===
//------------------------------------------------------------------------------
// <copyright file="SizeConverter.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Messaging.Design {    
    using System.Messaging;                                                    
    using System.ComponentModel;
    using System.Diagnostics;
    using System;                
    using System.ComponentModel.Design.Serialization;
    using System.Reflection;
    using System.Collections; 
    using System.Globalization;

    /// <include file='doc\SizeConverter.uex' path='docs/doc[@for="SizeConverter"]/*' />
    internal class SizeConverter : TypeConverter {

        /// <include file='doc\SizeConverter.uex' path='docs/doc[@for="SizeConverter.SizeConverter.CanConvertFrom"]/*' />
        /// <devdoc>
        ///      Determines if this converter can convert an object in the given source
        ///      type to the native type of the converter.
        /// </devdoc>
        public override bool CanConvertFrom(ITypeDescriptorContext context, Type sourceType) {
            if (sourceType == typeof(string)) {
                return true;
            }
            return base.CanConvertFrom(context, sourceType);
        }

        /// <include file='doc\SizeConverter.uex' path='docs/doc[@for="SizeConverter.SizeConverter.ConvertFrom"]/*' />
        /// <devdoc>
        ///      Converts the given object to the converter's native type.
        /// </devdoc>
        public override object ConvertFrom(ITypeDescriptorContext context, CultureInfo culture, object value) {

            if (value is string) {

                string text = ((string)value).Trim();
                
                if (text.Length == 0 || string.Compare(text, Res.GetString(Res.InfiniteValue), true, CultureInfo.CurrentCulture) == 0)
                    return(long)uint.MaxValue;
                else {
                    long size = Convert.ToInt64(text);
                    return size;
                }
                
            }

            return base.ConvertFrom(context, culture, value);
        }

        /// <include file='doc\SizeConverter.uex' path='docs/doc[@for="SizeConverter.SizeConverter.ConvertTo"]/*' />
        /// <devdoc>
        ///      Converts the given object to another type.  The most common types to convert
        ///      are to and from a string object.  The default implementation will make a call
        ///      to ToString on the object if the object is valid and if the destination
        ///      type is string.  If this cannot convert to the desitnation type, this will
        ///      throw a NotSupportedException.
        /// </devdoc>
        public override object ConvertTo(ITypeDescriptorContext context, CultureInfo culture, object value, Type destinationType) {
            if (destinationType == null) {
                throw new ArgumentNullException("destinationType");
            }

            if (destinationType == typeof(string)) {
                if (value != null) {
                    if ((long)value == uint.MaxValue)
                        return Res.GetString(Res.InfiniteValue);
                    else
                        return value.ToString();
                }
            }

            return base.ConvertTo(context, culture, value, destinationType);
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\services\messaging\system\messaging\design\queuepatheditor.cs ===
//------------------------------------------------------------------------------
// <copyright file="QueuePathEditor.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Messaging.Design {
    using System;
    using System.Drawing;
    using System.Drawing.Design;
    using System.Windows.Forms;
    using System.Windows.Forms.ComponentModel;
    using System.Windows.Forms.Design;
    using System.ComponentModel;
    using System.ComponentModel.Design;
    using System.Messaging;
   
    /// <include file='doc\QueuePathEditor.uex' path='docs/doc[@for="QueuePathEditor"]/*' />
    /// <devdoc>
    ///    <para>[To be supplied.]</para>
    /// </devdoc>
    public class QueuePathEditor : UITypeEditor {
                    
        /// <include file='doc\QueuePathEditor.uex' path='docs/doc[@for="QueuePathEditor.EditValue"]/*' />
        /// <devdoc>
        ///      Edits the given object value using the editor style provided by
        ///      GetEditorStyle.  A service provider is provided so that any
        ///      required editing services can be obtained.
        /// </devdoc>
        public override object EditValue(ITypeDescriptorContext context, IServiceProvider provider, object value) {                    
            if (provider != null) {
                IWindowsFormsEditorService edSvc = (IWindowsFormsEditorService)provider.GetService(typeof(IWindowsFormsEditorService));
                if (edSvc != null) {                                                                                                                                                     
                    QueuePathDialog dialog = new QueuePathDialog(provider);                    
                    MessageQueue queue = null;
                    if (value is MessageQueue) 
                        queue = (MessageQueue)value;
                    else if (value is string)
                        queue = new MessageQueue((string)value);
                    else if (value != null)
                        return value;
                    
                    if (queue != null)
                        dialog.SelectQueue(queue);
                                                                                
                    IDesignerHost host = (IDesignerHost)provider.GetService(typeof(IDesignerHost));                    
                    DesignerTransaction trans = null;
                    if (host != null) 
                        trans = host.CreateTransaction();
                        
                    try {                
                        if ((context == null || context.OnComponentChanging()) && edSvc.ShowDialog(dialog) == DialogResult.OK) {                            
                            if (dialog.Path != String.Empty) {                                 
                                if (context.Instance is MessageQueue || context.Instance is MessageQueueInstaller) 
                                    value = dialog.Path;
                                else {                                               
                                        value = MessageQueueConverter.GetFromCache(dialog.Path);
                                        if (value == null) {
                                            value = new MessageQueue(dialog.Path);       
                                            MessageQueueConverter.AddToCache((MessageQueue)value);                                                                                                         
                                            if (context != null)
                                                context.Container.Add((IComponent)value);                                                                    
                                        }                                                                                                                                                                                                        
                                }                                    
                                    
                                context.OnComponentChanged();
                            }                                    
                       }        
                    }                               
                    finally {                                                                                                    
                        if (trans != null) {
                            trans.Commit();
                        }
                    }                                                   
                }                                            
            }
            
            return value;
        }

        /// <include file='doc\QueuePathEditor.uex' path='docs/doc[@for="QueuePathEditor.GetEditStyle"]/*' />
        /// <devdoc>
        ///      Retrieves the editing style of the Edit method.  If the method
        ///      is not supported, this will return None.
        /// </devdoc>
        public override UITypeEditorEditStyle GetEditStyle(ITypeDescriptorContext context) {
            return UITypeEditorEditStyle.Modal;
        }        
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\services\messaging\system\messaging\design\messagequeueconverter.cs ===
//------------------------------------------------------------------------------
// <copyright file="MessageQueueConverter.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

 namespace System.Messaging.Design {    
    using System.Messaging;                                                    
    using System.Threading;    
    using System.ComponentModel;
    using System.ComponentModel.Design;
    using System.Diagnostics;
    using System;            
    using System.Drawing;
    using System.Windows.Forms;
    using System.Windows.Forms.Design;
    using System.Windows.Forms.ComponentModel;    
    using System.ComponentModel.Design.Serialization;
    using System.Reflection;
    using System.Messaging.Interop;       
    using System.Collections; 
    using System.Collections.Specialized; 
    using System.Globalization;    
        
    /// <include file='doc\MessageQueueConverter.uex' path='docs/doc[@for="MessageQueueConverter"]/*' />
    /// <internalonly/>
    internal class MessageQueueConverter : TypeConverter {        
        private static Hashtable componentsCreated = new Hashtable(new CaseInsensitiveHashCodeProvider(CultureInfo.InvariantCulture), new CaseInsensitiveComparer(CultureInfo.InvariantCulture));
                        
        /// <include file='doc\MessageQueueConverter.uex' path='docs/doc[@for="MessageQueueConverter.CanConvertFrom"]/*' />
        /// <internalonly/>                               
        public override bool CanConvertFrom(ITypeDescriptorContext context, Type sourceType) {
            if (sourceType == typeof(string)) {
                return true;
            }
            return base.CanConvertFrom(context, sourceType);
        }                        
        
        internal static void AddToCache(MessageQueue queue) {   
            componentsCreated[queue.Path] = queue;
        }
                                 
        /// <include file='doc\MessageQueueConverter.uex' path='docs/doc[@for="MessageQueueConverter.ConvertFrom"]/*' />
        /// <internalonly/>                 
        public override object ConvertFrom(ITypeDescriptorContext context, CultureInfo culture, object value) {
            if (value != null && value is string) {
                string text = ((string)value).Trim();
            
                if (text == String.Empty)
                    return null;
                    
                if (text.CompareTo(Res.GetString(Res.NotSet)) != 0) {                                                             
                    MessageQueue newQueue = GetFromCache(text);                    
                    if (newQueue != null) 
                        return newQueue;
                    else {
                        newQueue = new MessageQueue(text);  
                        AddToCache(newQueue);
                        if (context != null)
                            context.Container.Add(newQueue);                            
                             
                        return newQueue;    
                    }                                        
                }                                                                                                      
            }
            
            return null;
        }
                
                                                                                   
        /// <include file='doc\MessageQueueConverter.uex' path='docs/doc[@for="MessageQueueConverter.ConvertTo"]/*' />
        /// <internalonly/>                 
        public override object ConvertTo(ITypeDescriptorContext context, CultureInfo culture, object value, Type destinationType) {
            if (destinationType != null && destinationType == typeof(string)) {                
                if (value != null)
                    return((MessageQueue)value).Path;
                else
                    return Res.GetString(Res.NotSet);
            }
            
            return base.ConvertTo(context, culture, value, destinationType);
        }                    
        
        internal static MessageQueue GetFromCache(string path) {
            if (componentsCreated.ContainsKey(path)) {
                MessageQueue existingComponent = (MessageQueue)componentsCreated[path];
                if (existingComponent.Site == null)
                    componentsCreated.Remove(path);
                else {                                                                                        
                    if (existingComponent.Path == path)                                
                        return existingComponent;
                    else                            
                        componentsCreated.Remove(path);    
                }                                                                    
            }
            
            return null;
        }
    }                                    
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\services\messaging\system\messaging\design\messageformatterconverter.cs ===
//------------------------------------------------------------------------------
// <copyright file="MessageFormatterConverter.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

 namespace System.Messaging.Design {    
    using System.Messaging;                                                    
    using System.Threading;    
    using System.ComponentModel;
    using System.ComponentModel.Design.Serialization;
    using System.Reflection;
    using System.Diagnostics;
    using System;                
    using System.Drawing;
    using System.Windows.Forms;
    using System.Windows.Forms.Design;
    using System.Windows.Forms.ComponentModel;    
    using System.Messaging.Interop;       
    using System.Collections;                                                                                                                                                                                                       
    using System.Runtime.Serialization.Formatters;
    using System.Globalization;    
            
    /// <include file='doc\MessageFormatterConverter.uex' path='docs/doc[@for="MessageFormatterConverter"]/*' />
    /// <internalonly/>
    internal class MessageFormatterConverter : ExpandableObjectConverter {        
        
        public override bool CanConvertFrom(ITypeDescriptorContext context, Type sourceType) {
            return (sourceType == typeof(string));
        }
                                 
        /// <include file='doc\MessageFormatterConverter.uex' path='docs/doc[@for="MessageFormatterConverter.CanConvertTo"]/*' />
        /// <devdoc>
        ///    <para>Gets a value indicating whether this converter can
        ///       convert an object to the given destination type using the context.</para>
        /// </devdoc>
        public override bool CanConvertTo(ITypeDescriptorContext context, Type destinationType) {
            if (destinationType == typeof(InstanceDescriptor)) {
                return true;
            }
            return base.CanConvertTo(context, destinationType);
        }

        /// <include file='doc\MessageFormatterConverter.uex' path='docs/doc[@for="MessageFormatterConverter.ConvertFrom"]/*' />
        /// <internalonly/>                                                  
        public override object ConvertFrom(ITypeDescriptorContext context, CultureInfo culture, object value) {
            if (value != null && value is string) {
                if (((string)value) == typeof(ActiveXMessageFormatter).Name)
                    return new ActiveXMessageFormatter();
                if (((string)value) == typeof(BinaryMessageFormatter).Name)
                    return new BinaryMessageFormatter();
                if (((string)value)  == typeof(XmlMessageFormatter).Name)
                    return new XmlMessageFormatter();                                    
            }
            
            return null;
        }
                                                                                   
        /// <include file='doc\MessageFormatterConverter.uex' path='docs/doc[@for="MessageFormatterConverter.ConvertTo"]/*' />
        /// <internalonly/>                 
        public override object ConvertTo(ITypeDescriptorContext context, CultureInfo culture, object value, Type destinationType) {
            if (destinationType != null && destinationType == typeof(string)) {                
                if (value == null)
                    return Res.GetString(Res.toStringNone); 
                                   
                return value.GetType().Name;
            }
            if (destinationType == typeof(InstanceDescriptor)) {
                if (value is XmlMessageFormatter) {
                    XmlMessageFormatter f = (XmlMessageFormatter)value;
                    ConstructorInfo ctor = typeof(XmlMessageFormatter).GetConstructor(new Type[] {typeof(string[])});
                    if (ctor != null) {
                        return new InstanceDescriptor(ctor, new object[] {f.TargetTypeNames});
                    }
                }
                else if (value is ActiveXMessageFormatter) {
                    ConstructorInfo ctor = typeof(ActiveXMessageFormatter).GetConstructor(new Type[0]);
                    if (ctor != null) {
                        return new InstanceDescriptor(ctor, new object[0]);
                    }
                }
                else if (value is BinaryMessageFormatter) {
                    BinaryMessageFormatter f = (BinaryMessageFormatter)value;
                    ConstructorInfo ctor = typeof(BinaryMessageFormatter).GetConstructor(new Type[] {
                        typeof(FormatterAssemblyStyle), typeof(FormatterTypeStyle)});
                        
                    if (ctor != null) {
                        return new InstanceDescriptor(ctor, new object[] {f.TopObjectFormat, f.TypeFormat});
                    }
                }
            }
            
            return base.ConvertTo(context, culture, value, destinationType);
        }                    
                                                                                                                      
        /// <include file='doc\MessageFormatterConverter.uex' path='docs/doc[@for="MessageFormatterConverter.GetStandardValues"]/*' />
        /// <internalonly/>            
        public override StandardValuesCollection GetStandardValues(ITypeDescriptorContext context) {            
            StandardValuesCollection values = new StandardValuesCollection(new object[] {new ActiveXMessageFormatter(), 
                                                                                                           new BinaryMessageFormatter(),                                                                                                            
                                                                                                           new XmlMessageFormatter(),
                                                                                                           null});
            
            return values;
        }
        
        public override bool GetStandardValuesExclusive(ITypeDescriptorContext context) {
            return true;
        }
        
        /// <include file='doc\MessageFormatterConverter.uex' path='docs/doc[@for="MessageFormatterConverter.GetStandardValuesSupported"]/*' />
        /// <internalonly/>                        
        public override bool GetStandardValuesSupported(ITypeDescriptorContext context) {
            return true;
        }
    }                                    
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\services\messaging\system\messaging\xmlmessageformatter.cs ===
//------------------------------------------------------------------------------
// <copyright file="XmlMessageFormatter.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Messaging {   
    using System;    
    using System.IO;   
    using System.Xml;
    using System.Collections;
    using System.Xml.Serialization;    
    using System.ComponentModel;
    using System.Security.Permissions;
    
    /// <include file='doc\XmlMessageFormatter.uex' path='docs/doc[@for="XmlMessageFormatter"]/*' />
    /// <devdoc>
    ///    Formatter class that serializes and deserializes objects into
    ///    and from  MessageQueue messages using Xml.
    /// </devdoc>    
    public class XmlMessageFormatter : IMessageFormatter {        
        private Type[] targetTypes;    
        private string[] targetTypeNames;    
        Hashtable targetSerializerTable = new Hashtable();
        private bool typeNamesAdded;
        private bool typesAdded;
                                                                    
        /// <include file='doc\XmlMessageFormatter.uex' path='docs/doc[@for="XmlMessageFormatter.XmlMessageFormatter"]/*' />
        /// <devdoc>
        ///    Creates a new Xml message formatter object.
        /// </devdoc>
        public XmlMessageFormatter() {                        
            this.TargetTypes = new Type[0];
            this.TargetTypeNames = new string[0];            
        }
    
        /// <include file='doc\XmlMessageFormatter.uex' path='docs/doc[@for="XmlMessageFormatter.XmlMessageFormatter1"]/*' />
        /// <devdoc>
        ///    Creates a new Xml message formatter object,
        ///    using the given properties.
        /// </devdoc>
        public XmlMessageFormatter(string[] targetTypeNames) {
            this.TargetTypeNames = targetTypeNames;
            this.TargetTypes = new Type[0];
        }
                
        /// <include file='doc\XmlMessageFormatter.uex' path='docs/doc[@for="XmlMessageFormatter.XmlMessageFormatter2"]/*' />
        /// <devdoc>
        ///    Creates a new Xml message formatter object,
        ///    using the given properties.
        /// </devdoc>
        public XmlMessageFormatter(Type[] targetTypes) {            
            this.TargetTypes = targetTypes;
            this.TargetTypeNames = new string[0];            
        }
                
        /// <include file='doc\XmlMessageFormatter.uex' path='docs/doc[@for="XmlMessageFormatter.TargetTypeNames"]/*' />
        /// <devdoc>
        ///    Specifies the set of possible types that will
        ///    be deserialized by the formatter from the 
        ///    message provided.
         /// </devdoc>
        [MessagingDescription(Res.XmlMsgTargetTypeNames)]
        public string[] TargetTypeNames {
            get {                                                
                return this.targetTypeNames;
            }
            
            set {                        
                if (value == null) 
                    throw new ArgumentNullException("value");
                                            
                this.typeNamesAdded = false;
                this.targetTypeNames = value;                
            }
        }        
         
        /// <include file='doc\XmlMessageFormatter.uex' path='docs/doc[@for="XmlMessageFormatter.TargetTypes"]/*' />
        /// <devdoc>
        ///    Specifies the set of possible types that will
        ///    be deserialized by the formatter from the 
        ///    message provided.
         /// </devdoc>
        [Browsable(false), DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden), MessagingDescription(Res.XmlMsgTargetTypes)]
        public Type[] TargetTypes {
            get {
                return this.targetTypes;
            }
            
            set {
                if (value == null)
                    throw new ArgumentNullException("value");
                            
                this.typesAdded = false;
                this.targetTypes = value;
            }
        }
        
        /// <include file='doc\XmlMessageFormatter.uex' path='docs/doc[@for="XmlMessageFormatter.CanRead"]/*' />
        /// <devdoc>
        ///    When this method is called, the formatter will attempt to determine 
        ///    if the contents of the message are something the formatter can deal with.
        /// </devdoc>
        public bool CanRead(Message message) {
            if (message == null)
                throw new ArgumentNullException("message");
                
            this.CreateTargetSerializerTable();                
                            
            Stream stream = message.BodyStream;                                            
            XmlTextReader reader =  new XmlTextReader(stream);
            reader.WhitespaceHandling = WhitespaceHandling.Significant;
            foreach (XmlSerializer serializer in targetSerializerTable.Values) {                                
                if (serializer.CanDeserialize(reader)) 
                    return true;
            }

            return false;                                
        }

        /// <include file='doc\XmlMessageFormatter.uex' path='docs/doc[@for="XmlMessageFormatter.Clone"]/*' />
        /// <devdoc>
        ///    This method is needed to improve scalability on Receive and ReceiveAsync scenarios.  Not requiring 
        ///     thread safety on read and write.
        /// </devdoc>
        public object Clone() {
            XmlMessageFormatter formatter = new XmlMessageFormatter();
            formatter.targetTypes = targetTypes;
            formatter.targetTypeNames = targetTypeNames;
            formatter.typesAdded = typesAdded;
            formatter.typeNamesAdded = typeNamesAdded;
            foreach (Type targetType in targetSerializerTable.Keys) 
                formatter.targetSerializerTable[targetType] = new XmlSerializer(targetType);                         
                
            return formatter;                           
        }

        
        ///<internalonly/>        
        private void CreateTargetSerializerTable() {
            if (!this.typeNamesAdded) {                
                for (int index = 0; index < this.targetTypeNames.Length; ++ index) {                
                    Type targetType = Type.GetType(this.targetTypeNames[index], true);
                    if (targetType != null)
                       this.targetSerializerTable[targetType] = new XmlSerializer(targetType);                                    
                }
                
                this.typeNamesAdded = true;                    
            }                    
             
            if (!this.typesAdded) {                                    
                for (int index = 0; index < this.targetTypes.Length; ++ index)
                    this.targetSerializerTable[this.targetTypes[index]] = new XmlSerializer(this.targetTypes[index]);                                                                                                                                                                             

                this.typesAdded = true;                    
            }
            
            if (this.targetSerializerTable.Count == 0)
                throw new InvalidOperationException(Res.GetString(Res.TypeListMissing));
        }                                         
                                         
        /// <include file='doc\XmlMessageFormatter.uex' path='docs/doc[@for="XmlMessageFormatter.Read"]/*' />
        /// <devdoc>
        ///    This method is used to read the contents from the given message 
        ///     and create an object.
        /// </devdoc>
        public object Read(Message message) {            
            if (message == null)
                throw new ArgumentNullException("message");
                
            this.CreateTargetSerializerTable();                
                
            Stream stream = message.BodyStream;                                            
            XmlTextReader reader =  new XmlTextReader(stream);
            reader.WhitespaceHandling = WhitespaceHandling.Significant;
            foreach (XmlSerializer serializer in targetSerializerTable.Values) {                                
                if (serializer.CanDeserialize(reader)) 
                    return serializer.Deserialize(reader);
            }

            throw new InvalidOperationException(Res.GetString(Res.InvalidTypeDeserialization));
        }
        
        /// <include file='doc\XmlMessageFormatter.uex' path='docs/doc[@for="XmlMessageFormatter.Write"]/*' />
        /// <devdoc>
        ///    This method is used to write the given object into the given message.  
        ///     If the formatter cannot understand the given object, an exception is thrown.
        /// </devdoc>
        public void Write(Message message, object obj) {   
            if (message == null)
                throw new ArgumentNullException("message");
                
            if (obj == null)
                throw new ArgumentNullException("obj");                
                                 
            Stream stream = new MemoryStream();            
            Type serializedType =  obj.GetType();                                      
            XmlSerializer serializer = null;
            if (this.targetSerializerTable.ContainsKey(serializedType)) 
                serializer = (XmlSerializer)this.targetSerializerTable[serializedType];
            else {
                serializer = new XmlSerializer(serializedType);                
                this.targetSerializerTable[serializedType] = serializer;
            }                                    
            
            serializer.Serialize(stream, obj);
            message.BodyStream = stream;
            //Need to reset the body type, in case the same message
            //is reused by some other formatter.
            message.BodyType = 0;
        }                                            
    }            
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\services\messaging\system\messaging\design\queuepathdialog.cs ===
//------------------------------------------------------------------------------
// <copyright file="QueuePathDialog.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Messaging.Design {    
    using System.Messaging;                                                    
    using System.Threading;    
    using System.ComponentModel;
    using System.ComponentModel.Design;
    using System.Diagnostics;
    using System;            
    using System.Drawing;
    using System.Windows.Forms;
    using System.Windows.Forms.Design;
    using System.Windows.Forms.ComponentModel;    
    using System.Messaging.Interop;       
    using System.Collections;                                                                                                                                                                                                
    using System.Text;          
    using System.Globalization;
    
    /// <include file='doc\QueuePathDialog.uex' path='docs/doc[@for="QueuePathDialog"]/*' />
    /// <internalonly/>
    /// <devdoc>
    /// </devdoc>
    public class QueuePathDialog : Form {    
        private static readonly string HELP_KEYWORD = "System.Messaging.Design.QueuePathDialog";
        
        private System.Windows.Forms.ImageList icons;
        
        private System.Windows.Forms.Button okButton;
        
        private System.Windows.Forms.ComboBox pathType;
        
        private System.Windows.Forms.TreeView enterprise;
        
        private System.Windows.Forms.Button helpButton;
        
        private System.Windows.Forms.Label selectLabel;
        
        private System.Windows.Forms.Label referenceLabel;
        
        private System.Windows.Forms.Button cancelButton;
                        
        private string path = String.Empty;
        private string queuePath = String.Empty;
        private int lastPathType = 0;         
        private bool exit;            
        private MessageQueue selectedQueue;
        private delegate void FinishPopulateDelegate(MessageQueue[] queues);
        private delegate void SelectQueueDelegate(MessageQueue queue, int pathTypeIndex);
        private delegate void ShowErrorDelegate();
        private IUIService uiService;
        private IServiceProvider provider;
        private Hashtable machinesTable = new Hashtable();
        
        //Path prefixes
        private static readonly string PREFIX_LABEL = "LABEL:";
        private static readonly string PREFIX_FORMAT_NAME = "FORMATNAME:";

        /// <include file='doc\QueuePathDialog.uex' path='docs/doc[@for="QueuePathDialog.QueuePathDialog"]/*' />
        /// <devdoc>
        ///     Creates a path editor control.
        ///     This will create also a tree view control, and an ImageList with
        ///     the icons.
        /// </devdoc>                     
        public QueuePathDialog(IServiceProvider provider)
        : base() {   
            this.uiService = (IUIService)provider.GetService(typeof(IUIService));
            this.provider = provider;
            this.InitializeComponent();                                    
        }

            
        /// <include file='doc\QueuePathDialog.uex' path='docs/doc[@for="QueuePathDialog.QueuePathDialog2"]/*' />
        /// <devdoc>
        ///     Creates a path editor control.
        ///     This will create also a tree view control, and an ImageList with
        ///     the icons.
        /// </devdoc>
        public QueuePathDialog(IUIService uiService)
        : base() {                
            this.uiService = uiService;
            this.InitializeComponent();            
        }
                                
        /// <include file='doc\QueuePathDialog.uex' path='docs/doc[@for="QueuePathDialog.Path"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public string Path {
            get {
                return this.queuePath;
            }
        }

        private void AfterSelect(object source, TreeViewEventArgs e) {
            TreeNode node =  (TreeNode)e.Node;
            string[] nodeTexts = node.FullPath.Split(new char[]{'\\'});

            if (nodeTexts.Length == 2) {
                StringBuilder path = new StringBuilder();
                path.Append(node.Parent.Text);
                path.Append("\\");
                path.Append(nodeTexts[1]);
                this.path = path.ToString();
                ChoosePath();
                exit = true;
            }
        }       

        private void BeforeSelect(object source, TreeViewCancelEventArgs e) {
            TreeNode node = e.Node;
            string[] nodeTexts = node.FullPath.Split(new char[]{'\\'});
            node.SelectedImageIndex = nodeTexts.Length - 1;
            exit = false;
        }

        /// <include file='doc\QueuePathDialog.uex' path='docs/doc[@for="QueuePathDialog.ChoosePath"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public void ChoosePath() {
            if (this.path != null && this.path != String.Empty) {
                if (pathType.Text.CompareTo(Res.GetString(Res.RefByPath)) == 0) {
                    this.queuePath = this.path;
                    this.lastPathType = this.pathType.SelectedIndex;
                }                    
                else if (pathType.Text.CompareTo(Res.GetString(Res.RefByFormatName)) == 0) {
                    MessageQueue queue = new MessageQueue(this.path);
                    this.queuePath = PREFIX_FORMAT_NAME + queue.FormatName;
                    this.lastPathType = this.pathType.SelectedIndex;
                }
                else {
                    MessageQueue queue = new MessageQueue(this.path);
                    string tempPath = PREFIX_LABEL + queue.Label;                    
                    try {
                        MessageQueue validate = new MessageQueue(tempPath);
                        string stringValidate = validate.FormatName;                        
                        this.queuePath = tempPath;                        
                        this.lastPathType = this.pathType.SelectedIndex;
                    }
                    catch (Exception e) {                        
                        if (this.queuePath != null && String.Compare(this.queuePath, tempPath, true, CultureInfo.InvariantCulture) != 0)  {
                            exit = false;
                            if (uiService != null)
                                uiService.ShowError(e.Message);
                            else
                                MessageBox.Show(e.Message, "", MessageBoxButtons.OK, MessageBoxIcon.Error);                                                                                                                                                                         
                                
                            if (this.queuePath == String.Empty) {                            
                                this.queuePath = this.path;
                                this.lastPathType = 0;
                            }                                
                                
                            OnSelectQueue(new MessageQueue(this.queuePath), this.lastPathType);                                                            
                        }                                
                    }                                                                                    
                }                                                                
            }
        }                

        /// <include file='doc\QueuePathDialog.uex' path='docs/doc[@for="QueuePathDialog.DoubleClicked"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public void DoubleClicked(object source, EventArgs e) {
            if (exit) {
                this.Close();
                this.DialogResult = DialogResult.OK;
            }
        }
        
        private void IndexChanged(object source, EventArgs e) {
            ChoosePath();
        }                                        

        private void InitializeComponent() {
            System.Resources.ResourceManager resources = new System.Resources.ResourceManager(typeof(QueuePathDialog));
            this.icons = new ImageList();
            this.okButton = new System.Windows.Forms.Button();
            this.pathType = new System.Windows.Forms.ComboBox();
            this.enterprise = new System.Windows.Forms.TreeView();
            this.helpButton = new System.Windows.Forms.Button();
            this.selectLabel = new System.Windows.Forms.Label();
            this.referenceLabel = new System.Windows.Forms.Label();
            this.cancelButton = new System.Windows.Forms.Button();
            this.okButton.Location = ((System.Drawing.Point)(resources.GetObject("okButton.Location")));
            this.okButton.Size = ((System.Drawing.Size)(resources.GetObject("okButton.Size")));
            this.okButton.TabIndex = ((int)(resources.GetObject("okButton.TabIndex")));
            this.okButton.Text = resources.GetString("okButton.Text");
            this.okButton.DialogResult = DialogResult.OK;
            this.pathType.DropDownStyle = System.Windows.Forms.ComboBoxStyle.DropDownList;
            this.pathType.DropDownWidth = 264;
            this.pathType.Items.Add(Res.GetString(Res.RefByPath));
            this.pathType.Items.Add(Res.GetString(Res.RefByFormatName));
            this.pathType.Items.Add(Res.GetString(Res.RefByLabel));
            this.pathType.SelectedIndex = 0;            
            this.pathType.Location = ((System.Drawing.Point)(resources.GetObject("pathType.Location")));
            this.pathType.Size = ((System.Drawing.Size)(resources.GetObject("pathType.Size")));
            this.pathType.TabIndex = ((int)(resources.GetObject("pathType.TabIndex")));
            this.pathType.SelectedIndexChanged += new System.EventHandler(this.IndexChanged);
            this.enterprise.HideSelection = false;
            this.enterprise.ImageIndex = -1;
            this.enterprise.Location = ((System.Drawing.Point)(resources.GetObject("enterprise.Location")));
            this.enterprise.Nodes.AddRange(new System.Windows.Forms.TreeNode[] {new System.Windows.Forms.TreeNode(Res.GetString(Res.PleaseWait))});
            this.enterprise.SelectedImageIndex = -1;
            this.enterprise.Size = ((System.Drawing.Size)(resources.GetObject("enterprise.Size")));
            this.enterprise.Sorted = true;
            this.enterprise.TabIndex = ((int)(resources.GetObject("enterprise.TabIndex")));
            this.enterprise.AfterSelect += new System.Windows.Forms.TreeViewEventHandler(this.AfterSelect);
            this.enterprise.BeforeSelect += new System.Windows.Forms.TreeViewCancelEventHandler(this.BeforeSelect);
            this.enterprise.DoubleClick += new System.EventHandler(this.DoubleClicked);
            this.enterprise.ImageList = icons;
            this.helpButton.Location = ((System.Drawing.Point)(resources.GetObject("helpButton.Location")));
            this.helpButton.Size = ((System.Drawing.Size)(resources.GetObject("helpButton.Size")));
            this.helpButton.TabIndex = ((int)(resources.GetObject("helpButton.TabIndex")));
            this.helpButton.Text = resources.GetString("helpButton.Text");
            this.helpButton.Click += new System.EventHandler(this.OnClickHelpButton);
            this.icons.Images.Add(new Bitmap(typeof(MessageQueue), "Machine.bmp"));
            this.icons.Images.Add(new Bitmap(typeof(MessageQueue), "PublicQueue.bmp"));
            this.selectLabel.Location = ((System.Drawing.Point)(resources.GetObject("selectLabel.Location")));
            this.selectLabel.Size = ((System.Drawing.Size)(resources.GetObject("selectLabel.Size")));
            this.selectLabel.TabIndex = ((int)(resources.GetObject("selectLabel.TabIndex")));
            this.selectLabel.Text = resources.GetString("selectLabel.Text");
            this.referenceLabel.Location = ((System.Drawing.Point)(resources.GetObject("referenceLabel.Location")));
            this.referenceLabel.Size = ((System.Drawing.Size)(resources.GetObject("referenceLabel.Size")));
            this.referenceLabel.TabIndex = ((int)(resources.GetObject("referenceLabel.TabIndex")));
            this.referenceLabel.Text = resources.GetString("referenceLabel.Text");
            this.cancelButton.DialogResult = System.Windows.Forms.DialogResult.Cancel;
            this.cancelButton.Location = ((System.Drawing.Point)(resources.GetObject("cancelButton.Location")));
            this.cancelButton.Size = ((System.Drawing.Size)(resources.GetObject("cancelButton.Size")));
            this.cancelButton.TabIndex = ((int)(resources.GetObject("cancelButton.TabIndex")));
            this.cancelButton.Text = resources.GetString("cancelButton.Text");
            this.cancelButton.DialogResult = DialogResult.Cancel;
            this.HelpRequested += new HelpEventHandler(this.OnHelpRequested);
            this.AcceptButton = this.okButton;
            this.AutoScaleBaseSize = new System.Drawing.Size(5, 13);            
            this.CancelButton = this.cancelButton;
            this.ClientSize = ((System.Drawing.Size)(resources.GetObject("$this.ClientSize")));
            this.Controls.AddRange(new System.Windows.Forms.Control[] {this.helpButton,
                        this.cancelButton,
                        this.okButton,
                        this.pathType,
                        this.referenceLabel,
                        this.enterprise,
                        this.selectLabel});
            this.FormBorderStyle = System.Windows.Forms.FormBorderStyle.FixedDialog;
            this.MaximizeBox = false;
            this.MinimizeBox = false;
            this.Name = "Win32Form1";
            this.ShowInTaskbar = false;
            this.StartPosition = FormStartPosition.CenterParent;
            this.Text = resources.GetString("$this.Text");                                    
            this.lastPathType = 0;
            this.Icon = null;
            Thread populateThread = new Thread(new ThreadStart(this.PopulateThread));
            populateThread.Start();                                                                             
        }  
                                                                                                          
        private void PopulateThread() {                                                              
            try {                
                IEnumerator messageQueues = MessageQueue.GetMessageQueueEnumerator();
                MessageQueue[] queues = new MessageQueue[100];
                bool locate = true;
                while (locate) {
                    for (int index = 0; index < queues.Length; ++index) {
                        if (messageQueues.MoveNext())                         
                            queues[index] = (MessageQueue)messageQueues.Current;                                        
                        else {
                            queues[index] = null;
                            locate = false;
                        }                        
                    }                 
                    
                    this.BeginInvoke(new FinishPopulateDelegate(this.OnPopulateTreeview), new object[]{queues});
                }                                                                        
            }
            catch(Exception) {                
                Thread.Sleep(1000);
                this.BeginInvoke(new ShowErrorDelegate(this.OnShowError), null);                                
            }
            
            this.BeginInvoke(new SelectQueueDelegate(this.OnSelectQueue), new object[]{this.selectedQueue, 0});                   
        }

        /// <include file='doc\QueuePathDialog.uex' path='docs/doc[@for="QueuePathDialog.SelectQueue"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public void SelectQueue(MessageQueue queue) {            
            this.selectedQueue = queue;
        }
      
        private void OnHelpRequested(object sender, HelpEventArgs e) {
            OnClickHelpButton(null, null);
        }
      
        private void OnClickHelpButton(object source, EventArgs e) {
            if (this.provider != null) {
                IHelpService helpService = (IHelpService)provider.GetService(typeof(IHelpService));
                if (helpService != null) {
                    helpService.ShowHelpFromKeyword(HELP_KEYWORD);
                }
            }                
        }
        
        private void OnPopulateTreeview(MessageQueue[] queues) {                    
            if (queues == null || queues.Length == 0) {
                return;
            }
            
            if (machinesTable.Count == 0)
                enterprise.Nodes.Clear();
                               
            for (int index = 0; index < queues.Length; ++ index) {   
                if (queues[index] != null) {       
                    string machineName = queues[index].MachineName;
                    TreeNode machineNode = null;
                    if (machinesTable.ContainsKey(machineName)) 
                        machineNode = (TreeNode)machinesTable[machineName];
                    else {
                        machineNode = enterprise.Nodes.Add(machineName);
                        machinesTable[machineName] = machineNode;                    
                    }                
                            
                    machineNode.Nodes.Add(queues[index].QueueName).ImageIndex = 1;                
                }                    
            }            
        }
        
        private void OnShowError() {
            if (uiService != null)
                uiService.ShowError(Res.GetString(Res.QueueNetworkProblems));
            else
                MessageBox.Show(Res.GetString(Res.QueueNetworkProblems), "", MessageBoxButtons.OK, MessageBoxIcon.Error);
            
            this.DialogResult = DialogResult.Cancel;                        
            this.Close();                
        }
        
        private void OnSelectQueue(MessageQueue queue, int pathTypeIndex) {
            try {                
                pathType.SelectedIndex = pathTypeIndex;
                string machineName = queue.MachineName;
                string queueName = queue.QueueName;
                TreeNodeCollection machines = enterprise.Nodes;
                for (int index = 0; index < machines.Count; ++ index) {
                    TreeNode machine = machines[index];
                    if ( String.Compare(machineName, machine.Text, true, CultureInfo.InvariantCulture) == 0) {
                        machine.Expand();
                        //Need to flush all events so that the children nodes get added.
                        Application.DoEvents();                            
                        TreeNodeCollection queues = machine.Nodes;                                                            
                        for (int index2 = 0; index2 < queues.Count; ++ index2) {      
                            TreeNode queueNode = queues[index2];                                
                            if (queueNode.Text != null && String.Compare(queueName, queueNode.Text, true, CultureInfo.InvariantCulture) == 0) {
                                enterprise.SelectedNode = queueNode;
                                return;    
                            }                                                                
                        }                                                                                                                                                  
                        return;
                    }
                }
            }
            catch(Exception) {
                //Ignore all Exceptions.
            }
        }
    }                                                                                                                                                                  
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\services\messaging\system\messaging\interop\columns.cs ===
//------------------------------------------------------------------------------
// <copyright file="Columns.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Messaging.Interop {
    using System.Runtime.InteropServices;

    using System.Diagnostics;

    using System;
    using System.ComponentModel;
    
    using Microsoft.Win32;

    internal class Columns {
        private int maxCount;
        private MQCOLUMNSET columnSet = new MQCOLUMNSET();

        public Columns(int maxCount) {
            this.maxCount = maxCount;
            this.columnSet.columnIdentifiers = Marshal.AllocHGlobal(maxCount * 4);
            this.columnSet.columnCount = 0;
        }

        public virtual void  AddColumnId(int columnId) {
            lock(this) {
                if (this.columnSet.columnCount >= this.maxCount)
                    throw new InvalidOperationException(Res.GetString(Res.TooManyColumns, this.maxCount.ToString()));

                ++ this.columnSet.columnCount;
                this.columnSet.SetId(columnId, this.columnSet.columnCount - 1);
            }
        }

        public virtual MQCOLUMNSET GetColumnsRef() {
            return this.columnSet;
        }

        [StructLayout(LayoutKind.Sequential)]
        public class MQCOLUMNSET{
            public int columnCount;
            public IntPtr columnIdentifiers;

            ~MQCOLUMNSET() {                
                if (this.columnIdentifiers != (IntPtr)0) {
                    Marshal.FreeHGlobal(this.columnIdentifiers);
                    this.columnIdentifiers = (IntPtr)0;
                }                
            }

            public virtual void SetId(int columnId, int index) {
                Marshal.WriteInt32((IntPtr)((long)this.columnIdentifiers + (index * 4)), columnId);
            }            
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\services\messaging\system\messaging\design\timeoutconverter.cs ===
//------------------------------------------------------------------------------
// <copyright file="TimeoutConverter.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Messaging.Design {    
    using System.Messaging;                                                    
    using System.ComponentModel;
    using System.Diagnostics;
    using System;            
    using System.ComponentModel.Design.Serialization;
    using System.Reflection;
    using System.Collections; 
    using System.Globalization;                                                 
    
    /// <include file='doc\TimeoutConverter.uex' path='docs/doc[@for="TimeoutConverter"]/*' />
    /// <devdoc>
    ///      TimeoutConverter is a class that can be used to convert
    ///      Timeout from one data type to another.  Access this
    ///      class through the TypeDescriptor.
    /// </devdoc>
    internal class TimeoutConverter : TypeConverter {

        /// <include file='doc\TimeoutConverter.uex' path='docs/doc[@for="TimeoutConverter.CanConvertFrom"]/*' />
        /// <devdoc>
        ///      Determines if this converter can convert an object in the given source
        ///      type to the native type of the converter.
        /// </devdoc>
        public override bool CanConvertFrom(ITypeDescriptorContext context, Type sourceType) {
            if (sourceType == typeof(string)) {
                return true;
            }
            return base.CanConvertFrom(context, sourceType);
        }

        /// <include file='doc\TimeoutConverter.uex' path='docs/doc[@for="TimeoutConverter.ConvertFrom"]/*' />
        /// <devdoc>
        ///      Converts the given object to the converter's native type.
        /// </devdoc>
        public override object ConvertFrom(ITypeDescriptorContext context, CultureInfo culture, object value) {

            if (value is string) {
                string text = ((string)value).Trim();            
                if (text.Length == 0 || (string.Compare(text, Res.GetString(Res.InfiniteValue), true, CultureInfo.CurrentCulture) == 0))
                    return TimeSpan.FromSeconds((double)uint.MaxValue);
                else {
                    double totalSeconds = Convert.ToDouble(text);
                    if (totalSeconds > (double)uint.MaxValue)
                        totalSeconds = (double)uint.MaxValue;
                                                         
                    return TimeSpan.FromSeconds(totalSeconds);
                }               
            }

            return base.ConvertFrom(context, culture, value);
        }

        /// <include file='doc\TimeoutConverter.uex' path='docs/doc[@for="TimeoutConverter.ConvertTo"]/*' />
        /// <devdoc>
        ///      Converts the given object to another type.  The most common types to convert
        ///      are to and from a string object.  The default implementation will make a call
        ///      to ToString on the object if the object is valid and if the destination
        ///      type is string.  If this cannot convert to the desitnation type, this will
        ///      throw a NotSupportedException.
        /// </devdoc>
        public override object ConvertTo(ITypeDescriptorContext context, CultureInfo culture, object value, Type destinationType) {
            if (destinationType == null) {
                throw new ArgumentNullException("destinationType");
            }

            if (destinationType == typeof(string)) {
                if (value != null) {
                    double totalSeconds = ((TimeSpan)value).TotalSeconds;
                    if (totalSeconds >= uint.MaxValue)
                        return Res.GetString(Res.InfiniteValue);
                    else
                        return((uint)totalSeconds).ToString();
                }
            }

            return base.ConvertTo(context, culture, value, destinationType);
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\services\messaging\system\messaging\interop\ipersiststreaminit.cs ===
//------------------------------------------------------------------------------
// <copyright file="IPersistStreamInit.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Messaging.Interop {
    using System;   
    using System.Security;
    using System.Security.Permissions;
    using System.Runtime.InteropServices;    
    
    [
    ComImport(), 
    Guid("7FD52380-4E07-101B-AE2D-08002B2EC713"), 
    InterfaceType(ComInterfaceType.InterfaceIsIUnknown),
    CLSCompliant(false)
    ]
    internal interface IPersistStreamInit {        
        [SuppressUnmanagedCodeSecurity()]
        void GetClassID([Out] out Guid pClassID);

        [SuppressUnmanagedCodeSecurity()]
        int IsDirty();

        [SuppressUnmanagedCodeSecurity()]
        void Load([In, MarshalAs(UnmanagedType.Interface)] IStream pstm);

        [SuppressUnmanagedCodeSecurity()]
        void Save([In, MarshalAs(UnmanagedType.Interface)] IStream pstm,
                  [In, MarshalAs(UnmanagedType.Bool)] bool fClearDirty);

        [SuppressUnmanagedCodeSecurity()] 
        long GetSizeMax();

        [SuppressUnmanagedCodeSecurity()] 
        void InitNew();
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\services\messaging\system\messaging\interop\istream.cs ===
//------------------------------------------------------------------------------
// <copyright file="IStream.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Messaging.Interop {
    using System;   
    using System.Security;       
    using System.Runtime.InteropServices;    
    
    [
    ComImport(), 
    Guid("0000000C-0000-0000-C000-000000000046"), 
    InterfaceType(ComInterfaceType.InterfaceIsIUnknown),
    CLSCompliant(false)
    ]
    internal interface IStream {       
        
        int Read(IntPtr buf, int len);

        
        int Write(IntPtr buf, int len);

        [return: MarshalAs(UnmanagedType.I8)]
        long Seek([In, MarshalAs(UnmanagedType.I8)] long dlibMove, int dwOrigin);

        
        void SetSize([In, MarshalAs(UnmanagedType.I8)] long libNewSize);

        [return: MarshalAs(UnmanagedType.I8)]
        long CopyTo([In, MarshalAs(UnmanagedType.Interface)] IStream pstm,
                    [In, MarshalAs(UnmanagedType.I8)] long cb,
                    [Out, MarshalAs(UnmanagedType.LPArray)] long[] pcbRead);

        
        void Commit(int grfCommitFlags);

        
        void Revert();

        
        void LockRegion([In, MarshalAs(UnmanagedType.I8)] long libOffset,
                        [In, MarshalAs(UnmanagedType.I8)] long cb,
                         int dwLockType);

        
        void UnlockRegion([In, MarshalAs(UnmanagedType.I8)]  long libOffset,
                          [In, MarshalAs(UnmanagedType.I8)]  long cb,
                           int dwLockType);

        
        void Stat(IntPtr pStatstg, int grfStatFlag);

        [return: MarshalAs(UnmanagedType.Interface)]
        IStream Clone();
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\services\messaging\system\messaging\interop\itransaction.cs ===
//------------------------------------------------------------------------------
// <copyright file="ITransaction.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Messaging.Interop {
    using System;   
    using System.Security;
    using System.Runtime.InteropServices;    
    using System.Diagnostics;
    using UnmanagedType = System.Runtime.InteropServices.UnmanagedType;

    [ComImport, Guid("0FB15084-AF41-11CE-BD2B-204C4F4F5020"), System.Runtime.InteropServices.InterfaceTypeAttribute(System.Runtime.InteropServices.ComInterfaceType.InterfaceIsIUnknown)]
    internal interface ITransaction {

    	[return: MarshalAs(UnmanagedType.I4)][SuppressUnmanagedCodeSecurity()]
    	 [PreserveSig]
    	 int Commit(
    		[In, MarshalAs(UnmanagedType.I4)] 
    		 int fRetaining,
    		[In, MarshalAs(UnmanagedType.U4)] 
    		 int grfTC,
    		[In, MarshalAs(UnmanagedType.U4)] 
    		 int grfRM);

    	[return: MarshalAs(UnmanagedType.I4)][SuppressUnmanagedCodeSecurity()]
    	 [PreserveSig]
    	 int Abort(
    		[In, MarshalAs(UnmanagedType.U4)]
              int pboidReason,
    		[In, MarshalAs(UnmanagedType.I4)] 
    		 int fRetaining,
    		[In, MarshalAs(UnmanagedType.I4)] 
    		 int fAsync);

    	[return: MarshalAs(UnmanagedType.I4)][SuppressUnmanagedCodeSecurity()]
    	 [PreserveSig]
    	 int GetTransactionInfo(
    		[In, Out]
    		  XACTTRANSINFO pinfo);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\services\messaging\system\messaging\interop\ipersist.cs ===
//------------------------------------------------------------------------------
// <copyright file="IPersist.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Messaging.Interop {
    using System;   
    using System.Security;
    using System.Security.Permissions;
    using System.Runtime.InteropServices;    
    
    [
    ComImport(), 
    Guid("0000010C-0000-0000-C000-000000000046"), 
    InterfaceTypeAttribute(ComInterfaceType.InterfaceIsIUnknown),
    CLSCompliant(false)
    ]
    internal interface IPersist {    
        [SuppressUnmanagedCodeSecurity()]
        void GetClassID([Out] out Guid pClassID);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\services\messaging\system\messaging\interop\ipersiststream.cs ===
//------------------------------------------------------------------------------
// <copyright file="IPersistStream.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Messaging.Interop {
    using System;   
    using System.Security;
    using System.Security.Permissions;
    using System.Runtime.InteropServices;    
    
    [
    ComImport(), 
    Guid("00000109-0000-0000-C000-000000000046"), 
    InterfaceType(ComInterfaceType.InterfaceIsIUnknown),
    CLSCompliant(false)
    ]
    internal interface IPersistStream {        
        [SuppressUnmanagedCodeSecurity()]
        void GetClassID([Out] out Guid pClassID);

        [SuppressUnmanagedCodeSecurity()]
        int IsDirty();

        [SuppressUnmanagedCodeSecurity()]
        void Load([In, MarshalAs(UnmanagedType.Interface)] IStream pstm);

        [SuppressUnmanagedCodeSecurity()]
        void Save([In, MarshalAs(UnmanagedType.Interface)] IStream pstm,
                  [In, MarshalAs(UnmanagedType.Bool)] bool fClearDirty);

        [SuppressUnmanagedCodeSecurity()] 
        long GetSizeMax();
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\services\messaging\system\messaging\interop\safenativemethods.cs ===
//------------------------------------------------------------------------------
// <copyright file="SafeNativeMethods.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------    

namespace System.Messaging.Interop {
    using System.Text;
    using System.Threading;
    using System.Runtime.InteropServices;
    using System.Diagnostics;
    using System;    
    using System.ComponentModel;
    using Microsoft.Win32;
    using System.Security;
    using System.Security.Permissions;
        
    [
    System.Runtime.InteropServices.ComVisible(false), 
    System.Security.SuppressUnmanagedCodeSecurityAttribute()
    ]
    internal class SafeNativeMethods {    
        public unsafe delegate void ReceiveCallback(int result, IntPtr handle, int timeout, int action, IntPtr propertiesPointer, NativeOverlapped  * overlappedPointer, IntPtr cursorHandle);
        
        [DllImport(ExternDll.Mqrt, EntryPoint="MQBeginTransaction", CharSet=System.Runtime.InteropServices.CharSet.Unicode)]
        public static extern int IntMQBeginTransaction(out ITransaction refTransaction);
        public static int MQBeginTransaction(out ITransaction refTransaction) {
            try {
                return IntMQBeginTransaction(out refTransaction);
            }            
            catch (Exception) {
                throw new InvalidOperationException(Res.GetString(Res.MSMQNotInstalled));
            }
        }
        
        [DllImport(ExternDll.Mqrt, CharSet=System.Runtime.InteropServices.CharSet.Unicode)]
        public static extern int MQCloseQueue(IntPtr handle);
        
        [DllImport(ExternDll.Mqrt, EntryPoint="MQPathNameToFormatName", CharSet=System.Runtime.InteropServices.CharSet.Unicode)]
        private static extern int IntMQPathNameToFormatName(string pathName, StringBuilder formatName, ref int count);
        public static int MQPathNameToFormatName(string pathName, StringBuilder formatName, ref int count) {
            try {
                return IntMQPathNameToFormatName(pathName, formatName, ref count);
            }            
            catch (Exception) {
                throw new InvalidOperationException(Res.GetString(Res.MSMQNotInstalled));
            }
        }

        [DllImport(ExternDll.Mqrt, EntryPoint="MQInstanceToFormatName", CharSet=System.Runtime.InteropServices.CharSet.Unicode)]
        public static extern int IntMQInstanceToFormatName(byte[] id, StringBuilder formatName, ref int count);        
        public static int MQInstanceToFormatName(byte[] id, StringBuilder formatName, ref int count) {
            try {
                return IntMQInstanceToFormatName(id, formatName, ref count);
            }            
            catch (Exception) {
                throw new InvalidOperationException(Res.GetString(Res.MSMQNotInstalled));
            }
        }
        
        [DllImport(ExternDll.Mqrt, CharSet=System.Runtime.InteropServices.CharSet.Unicode)]
        public static extern int MQCreateCursor(IntPtr handle, out IntPtr cursorHandle);

        [DllImport(ExternDll.Mqrt, CharSet=System.Runtime.InteropServices.CharSet.Unicode)]
        public static extern int MQCloseCursor(IntPtr cursorHandle);
        
        [DllImport(ExternDll.Mqrt, CharSet=System.Runtime.InteropServices.CharSet.Unicode)]
        public static extern int MQLocateEnd(IntPtr enumHandle);

        [DllImport(ExternDll.Mqrt, CharSet=System.Runtime.InteropServices.CharSet.Unicode)]
        public static extern int MQLocateNext(IntPtr enumHandle, ref int propertyCount, int[] variantArray);

        [DllImport(ExternDll.Mqrt, CharSet=System.Runtime.InteropServices.CharSet.Unicode)]
        public static extern void MQFreeMemory(IntPtr memory);

        [DllImport(ExternDll.Kernel32, ExactSpelling=true, CharSet=System.Runtime.InteropServices.CharSet.Auto, SetLastError=true)]
        public static extern bool GetHandleInformation(IntPtr handle, out int handleInformation);
        
        [DllImport(ExternDll.Kernel32)]
        public static extern IntPtr LocalFree(IntPtr hMem);
        
        [DllImport(ExternDll.Advapi32)]
        public static extern int SetEntriesInAclW(int count, 
                                                  //[MarshalAs(UnmanagedType.LPArray, SizeParamIndex = 0, ArraySubType = ExplicitAccess)]
                                                  //ExplicitAccess[] entries,
                                                  IntPtr entries,
                                                  IntPtr oldacl, 
                                                  out IntPtr newAcl);
                                                  
        [DllImport(ExternDll.Kernel32, CharSet=CharSet.Auto)]
        public static extern bool GetComputerName(StringBuilder lpBuffer, int[] nSize);                                                     
        
        public const int FORMAT_MESSAGE_ALLOCATE_BUFFER = 0x00000100,
            FORMAT_MESSAGE_IGNORE_INSERTS = 0x00000200,
            FORMAT_MESSAGE_FROM_STRING = 0x00000400,
            FORMAT_MESSAGE_FROM_HMODULE = 0x00000800,
            FORMAT_MESSAGE_FROM_SYSTEM = 0x00001000,
            FORMAT_MESSAGE_ARGUMENT_ARRAY = 0x00002000,
            FORMAT_MESSAGE_MAX_WIDTH_MASK = 0x000000FF;

        [DllImport(ExternDll.Kernel32, CharSet=System.Runtime.InteropServices.CharSet.Auto)]
        public static extern int FormatMessage(int dwFlags, int lpSource, int dwMessageId,
                                                int dwLanguageId, StringBuilder lpBuffer, int nSize, int arguments);            
                
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\services\messaging\system\messaging\interop\machinepropertyvariants.cs ===
//------------------------------------------------------------------------------
// <copyright file="MachinePropertyVariants.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Messaging.Interop {

    using System.Diagnostics;
    
    using System;

    internal class MachinePropertyVariants : MessagePropertyVariants {     
        public MachinePropertyVariants()
            : base(5, NativeMethods.MACHINE_BASE + 1) {
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\services\messaging\system\messaging\interop\queuepropertyvariants.cs ===
//------------------------------------------------------------------------------
// <copyright file="QueuePropertyVariants.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Messaging.Interop {

    using System.Diagnostics;
    
    using System;

    internal class QueuePropertyVariants : MessagePropertyVariants {     
        public QueuePropertyVariants()
            : base(13, NativeMethods.QUEUE_PROPID_BASE + 1) {
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\services\messaging\system\messaging\interop\restrictions.cs ===
//------------------------------------------------------------------------------
// <copyright file="Restrictions.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Messaging.Interop {
    using System.Runtime.InteropServices;

    using System.Diagnostics;

    using System;
    using System.ComponentModel;
    
    using Microsoft.Win32;

    internal class Restrictions {
        private MQRESTRICTION restrictionStructure;
        public const int PRLT = 0;
        public const int PRLE = 1;
        public const int PRGT = 2;
        public const int PRGE = 3;
        public const int PREQ = 4;
        public const int PRNE = 5;

        public Restrictions(int maxRestrictions) {
            this.restrictionStructure = new MQRESTRICTION(maxRestrictions);
        }

        public virtual void AddGuid(int propertyId, int op, Guid value) {
            IntPtr data = Marshal.AllocHGlobal(16);            
            Marshal.Copy(value.ToByteArray(), 0 , data, 16);
            this.AddItem(propertyId, op,  MessagePropertyVariants.VT_CLSID, data);
        }

        public virtual void AddGuid(int propertyId, int op) {            
            IntPtr data = Marshal.AllocHGlobal(16);            
            this.AddItem(propertyId, op,  MessagePropertyVariants.VT_CLSID, data);
        }

        private void AddItem(int id,int  op, short vt, IntPtr data) {
            Marshal.WriteInt32(restrictionStructure.GetNextValidPtr(0) , op);
            Marshal.WriteInt32(restrictionStructure.GetNextValidPtr(4), id);
            Marshal.WriteInt16(restrictionStructure.GetNextValidPtr(8), vt);
            Marshal.WriteInt16(restrictionStructure.GetNextValidPtr(10), (short)0);
            Marshal.WriteInt16(restrictionStructure.GetNextValidPtr(12), (short)0);
            Marshal.WriteInt16(restrictionStructure.GetNextValidPtr(14), (short)0);
            Marshal.WriteIntPtr(restrictionStructure.GetNextValidPtr(16), data);
            Marshal.WriteIntPtr(restrictionStructure.GetNextValidPtr(16 + IntPtr.Size), (IntPtr)0);
            ++restrictionStructure.restrictionCount;
        }

        public virtual void AddI4(int propertyId, int op, int value) {
            this.AddItem(propertyId, op, MessagePropertyVariants.VT_I4, (IntPtr)value);
        }

        public virtual void AddString(int propertyId, int op, string value) {            
            if (value == null)
                this.AddItem(propertyId, op, MessagePropertyVariants.VT_NULL, (IntPtr)0);                
            else {
                IntPtr data = Marshal.StringToHGlobalUni(value);
                this.AddItem(propertyId, op, MessagePropertyVariants.VT_LPWSTR, data);
            }

        }

        public virtual MQRESTRICTION GetRestrictionsRef() {
            return this.restrictionStructure;
        }

        [StructLayout(LayoutKind.Sequential)]
        public class MQRESTRICTION {
            public int restrictionCount;
            public IntPtr restrinctions;

            public MQRESTRICTION(int maxCount) {
                this.restrinctions = Marshal.AllocHGlobal(maxCount * GetRestrictionSize());
            }

            ~MQRESTRICTION() {                
                if (this.restrinctions != (IntPtr)0) {
                    for (int index= 0; index < this.restrictionCount; ++ index) {                        
                        short vt = Marshal.ReadInt16((IntPtr)((long)this.restrinctions + (index * GetRestrictionSize()) + 8));
                        if (vt != MessagePropertyVariants.VT_I4) {
                            IntPtr dataPtr = (IntPtr)((long)this.restrinctions + (index * GetRestrictionSize()) + 16);
                            IntPtr data = Marshal.ReadIntPtr(dataPtr);
                            Marshal.FreeHGlobal(data);                                                    
                        }                            
                    }

                    Marshal.FreeHGlobal(this.restrinctions);
                    this.restrinctions = (IntPtr)0;
                }
            }

            public IntPtr GetNextValidPtr(int offset) {
                return (IntPtr)((long)restrinctions + restrictionCount * GetRestrictionSize() + offset);                    
            }

            public static int GetRestrictionSize() {
                return 16 + (IntPtr.Size * 2);    
            }                                                                                                                      
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\services\messaging\system\messaging\interop\xacttransinfo.cs ===
//------------------------------------------------------------------------------
// <copyright file="XACTTRANSINFO.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

//---------------------------------------------------------------------------
// XACTTRANSINFO.cs
//---------------------------------------------------------------------------
// WARNING: this file autogenerated
//---------------------------------------------------------------------------
// Copyright (c) 1999, Microsoft Corporation   All Rights Reserved
// Information Contained Herein Is Proprietary and Confidential.
//---------------------------------------------------------------------------

namespace System.Messaging.Interop {
    using System.Runtime.InteropServices;

    using System.Diagnostics;
    using System;
    using UnmanagedType = System.Runtime.InteropServices.UnmanagedType;

    [StructLayout(LayoutKind.Sequential)]
    internal sealed class XACTTRANSINFO {

        [MarshalAs(UnmanagedType.ByValArray, SizeConst=16)]
        public byte[] uow = null;

    	[MarshalAs(UnmanagedType.I4)]
    	public Int32 isoLevel = 0;

    	[MarshalAs(UnmanagedType.U4)]
    	public Int32 isoFlags = 0;

    	[MarshalAs(UnmanagedType.U4)]
    	public Int32 grfTCSupported = 0;

    	[MarshalAs(UnmanagedType.U4)]
    	public Int32 grfRMSupported = 0;

    	[MarshalAs(UnmanagedType.U4)]
    	public Int32 grfTCSupportedRetaining = 0;

    	[MarshalAs(UnmanagedType.U4)]
    	public Int32 grfRMSupportedRetaining = 0;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\services\messaging\system\messaging\interop\messagepropertyvariants.cs ===
//------------------------------------------------------------------------------
// <copyright file="MessagePropertyVariants.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

using INTPTR_INTPTRCAST = System.IntPtr;
using INTPTR_INTCAST    = System.Int32;
                                                  
namespace System.Messaging.Interop {
    using System.Diagnostics;
    using System;   
    using System.Runtime.InteropServices;
    using Microsoft.Win32;

    internal class MessagePropertyVariants {
        private const short VT_UNDEFINED = 0;
        public const short VT_ARRAY = 0x2000;
        public const short VT_BOOL = 11;
        public const short VT_BSTR = 8;
        public const short VT_CLSID = 72;
        public const short VT_CY = 6;
        public const short VT_DATE = 7;
        public const short VT_I1 = 16;
        public const short VT_I2 = 2;
        public const short VT_I4 = 3;
        public const short VT_I8 = 20;
        public const short VT_LPSTR = 30;
        public const short VT_LPWSTR = 31;
        public const short VT_NULL = 1;
        public const short VT_R4 = 4;
        public const short VT_R8 = 5;
        public const short VT_STREAMED_OBJECT = 68;
        public const short VT_STORED_OBJECT = 69;
        public const short VT_UI1 = 17;
        public const short VT_UI2 = 18;
        public const short VT_UI4 = 19;
        public const short VT_UI8 = 21;
        public const short VT_VECTOR = 0x1000;
        private int MAX_PROPERTIES = 53;
        private int basePropertyId = NativeMethods.MESSAGE_PROPID_BASE + 1;
        private int propertyCount;
        private GCHandle handleVectorProperties;
        private GCHandle handleVectorIdentifiers;
        private GCHandle handleVectorStatus;
        private MQPROPS reference;
        private int[] vectorIdentifiers;
        private int[] vectorStatus;
        private int[] vectorProperties;
        private short[] variantTypes;
        private object[] objects;
        private object[] handles;        

        internal MessagePropertyVariants(int maxProperties, int baseId) {            
            reference = new MQPROPS();
            MAX_PROPERTIES = maxProperties;
            basePropertyId = baseId;            
            variantTypes = new short[MAX_PROPERTIES];
            objects = new object[MAX_PROPERTIES];
            handles = new object[MAX_PROPERTIES];            
        }

        public MessagePropertyVariants() {                        
            reference = new MQPROPS();
            variantTypes = new short[MAX_PROPERTIES];
            objects = new object[MAX_PROPERTIES];
            handles = new object[MAX_PROPERTIES];                        
        }

        public byte[] GetGuid(int propertyId) {
            return(byte[])objects[propertyId - basePropertyId];
        }

        public void SetGuid(int propertyId, byte[] value) {
            if (variantTypes[propertyId - basePropertyId] == VT_UNDEFINED) {
                variantTypes[propertyId - basePropertyId] = VT_CLSID;
                ++ propertyCount;
            }                
            
            objects[propertyId - basePropertyId] = value;            
        }

        public short GetI2(int propertyId) {
            return(short)objects[propertyId - basePropertyId];
        }

        public void SetI2(int propertyId, short value) {
            if ((variantTypes[propertyId - basePropertyId]) == VT_UNDEFINED) {
                variantTypes[propertyId - basePropertyId] = VT_I2;
                ++ propertyCount;
            }                
            
            objects[propertyId - basePropertyId] = value;            
        }

        public int GetI4(int propertyId) {
            return(int)objects[propertyId - basePropertyId];
        }

        public void SetI4(int propertyId, int value) {
            if (variantTypes[propertyId - basePropertyId] == VT_UNDEFINED) {
                variantTypes[propertyId - basePropertyId] = VT_I4;
                ++ propertyCount;
            }                
            
            objects[propertyId - basePropertyId] = value;            
        }
        
        public IntPtr GetStringVectorBasePointer(int propertyId) {
            return (IntPtr)(int)handles[propertyId - basePropertyId];                    
        }

        public int GetStringVectorLength(int propertyId) {
            return (int)objects[propertyId - basePropertyId];                    
        }
        
        public byte[] GetString(int propertyId) {
            return(byte[])objects[propertyId - basePropertyId];
        }

        public void SetString(int propertyId, byte[] value) {
            if (variantTypes[propertyId - basePropertyId] == VT_UNDEFINED) {
                variantTypes[propertyId - basePropertyId] = VT_LPWSTR;
                ++ propertyCount;
            }
            
            objects[propertyId - basePropertyId] = value;
        }

        public byte GetUI1(int propertyId) {
            return(byte)objects[propertyId - basePropertyId];
        }

        public void SetUI1(int propertyId, byte value) {
            if (variantTypes[propertyId - basePropertyId] == VT_UNDEFINED) {
                variantTypes[propertyId - basePropertyId] = VT_UI1;
                ++ propertyCount;
            }                
            
            objects[propertyId - basePropertyId] = value;            
        }

        public byte[] GetUI1Vector(int propertyId) {
            return(byte[])objects[propertyId - basePropertyId];
        }

        public void SetUI1Vector(int propertyId, byte[] value) {
            if (variantTypes[propertyId - basePropertyId] == VT_UNDEFINED) {
                variantTypes[propertyId - basePropertyId] = (short)(VT_VECTOR | VT_UI1);
                ++ propertyCount;
            }                
            
            objects[propertyId - basePropertyId] = value;            
        }

        public short GetUI2(int propertyId) {
            return(short)objects[propertyId - basePropertyId];
        }

        public void SetUI2(int propertyId, short value) {
            if (variantTypes[propertyId - basePropertyId] == VT_UNDEFINED) {
                variantTypes[propertyId - basePropertyId] = VT_UI2;
                ++ propertyCount;
            }                
            
            objects[propertyId - basePropertyId] = value;            
        }

        public int GetUI4(int propertyId) {
            return(int)objects[propertyId - basePropertyId];
        }

        public void SetUI4(int propertyId, int value) {
            if (variantTypes[propertyId - basePropertyId] == VT_UNDEFINED) {
                variantTypes[propertyId - basePropertyId] = VT_UI4;
                ++ propertyCount;
            }
            
            objects[propertyId - basePropertyId] = value;            
        }

        public virtual void AdjustSize(int propertyId, int size) {
            //I'm going to reuse this field to store the size temporarily.
            //Later I'll be storing the handle.
            handles[propertyId - basePropertyId] = size;
        }

        public virtual void Ghost(int propertyId) {
            if (variantTypes[propertyId - basePropertyId] != VT_UNDEFINED) {
                variantTypes[propertyId - basePropertyId] = VT_UNDEFINED;
                --propertyCount;
            }            
        }

        public virtual MQPROPS Lock() {                                                                                                                             
            int[] newVectorIdentifiers = new int[propertyCount];
            int[] newVectorStatus = new int[propertyCount];            
            int[] newVectorProperties = new int[propertyCount * 4];
            int usedProperties = 0;            
                                               
            for (int i = 0; i < MAX_PROPERTIES; ++ i) {
                short vt = variantTypes[i];
                if (vt != VT_UNDEFINED) {
                    //Set PropertyId
                    newVectorIdentifiers[usedProperties] = i + basePropertyId;
                    //Set VariantType
                    newVectorProperties[usedProperties * 4] = vt;
                    if (vt == (short)(VT_VECTOR | VT_UI1)) {
                        if (handles[i] == null)
                            newVectorProperties[usedProperties * 4 + 2] = ((byte[])objects[i]).Length;                            
                        else
                            newVectorProperties[usedProperties * 4 + 2] = (int)handles[i];

                        GCHandle handle = GCHandle.Alloc(objects[i], GCHandleType.Pinned);
                        handles[i] = handle;
                        newVectorProperties[usedProperties * 4 + 3] = (int)handle.AddrOfPinnedObject();
                    }                    
                    else if (vt == VT_UI1 || vt == VT_I1)
                        newVectorProperties[usedProperties * 4 + 2] = (byte)objects[i];
                    else if (vt == VT_UI2 || vt == VT_I2)
                        newVectorProperties[usedProperties * 4 + 2] = (short)objects[i];
                    else if (vt == VT_UI4 || vt == VT_I4)                        
                        newVectorProperties[usedProperties * 4 + 2] = (int)objects[i];                    
                    else if (vt == VT_LPWSTR || vt == VT_CLSID) {
                        GCHandle handle = GCHandle.Alloc(objects[i], GCHandleType.Pinned);
                        handles[i] = handle;
                        newVectorProperties[usedProperties * 4 + 2] = (int)handle.AddrOfPinnedObject();
                    }                    

                    ++usedProperties;
                    if (propertyCount == usedProperties)
                        break;
                }                
            }

            handleVectorIdentifiers = GCHandle.Alloc(newVectorIdentifiers, GCHandleType.Pinned);
            handleVectorProperties = GCHandle.Alloc(newVectorProperties, GCHandleType.Pinned);
            handleVectorStatus = GCHandle.Alloc(newVectorStatus, GCHandleType.Pinned);
            vectorIdentifiers = newVectorIdentifiers;
            vectorStatus = newVectorStatus;
            vectorProperties = newVectorProperties;
            reference.propertyCount = propertyCount;
            reference.propertyIdentifiers = (INTPTR_INTPTRCAST)handleVectorIdentifiers.AddrOfPinnedObject();
            reference.propertyValues = (INTPTR_INTPTRCAST)handleVectorProperties.AddrOfPinnedObject();
            reference.status = (INTPTR_INTPTRCAST)handleVectorStatus.AddrOfPinnedObject();            
            return reference;
        }

        public virtual void Remove(int propertyId) {
            if (variantTypes[propertyId - basePropertyId] != VT_UNDEFINED) {
                variantTypes[propertyId - basePropertyId] = VT_UNDEFINED;
                objects[propertyId - basePropertyId] = null;
                handles[propertyId - basePropertyId] = null;
                --propertyCount;
            }         
        }

        public virtual void SetNull(int propertyId) {
            if (variantTypes[propertyId - basePropertyId] == VT_UNDEFINED) {
                variantTypes[propertyId - basePropertyId] = VT_NULL;
                ++ propertyCount;
            }                
            
            objects[propertyId - basePropertyId] = null;            
        }

        public virtual void Unlock() {                                                
            for (int i = 0; i < vectorIdentifiers.Length; ++ i) {
                short vt = (short)vectorProperties[i * 4];
                    
                if (variantTypes[vectorIdentifiers[i] - basePropertyId] == VT_NULL) {                
                    if (vt == (short)(VT_VECTOR | VT_UI1) || vt == VT_NULL)
                        //Support for MSMQ self memory allocation.
                        objects[vectorIdentifiers[i] - basePropertyId] = vectorProperties[i * 4 + 3];
                    else if (vt == (short)(VT_VECTOR | VT_LPWSTR)) {                        
                        //Support for MSMQ management apis.
                        objects[vectorIdentifiers[i] - basePropertyId] = vectorProperties[i * 4 + 2];
                        handles[vectorIdentifiers[i] - basePropertyId] = vectorProperties[i * 4 + 3];                        
                    }
                    else
                        objects[vectorIdentifiers[i] - basePropertyId] = vectorProperties[i * 4 + 2];
                }
                else if (vt == VT_LPWSTR || vt == VT_CLSID || vt == (short)(VT_VECTOR | VT_UI1)) {
                    ((GCHandle)handles[vectorIdentifiers[i] - basePropertyId]).Free();            
                    handles[vectorIdentifiers[i] - basePropertyId] = null;
                }                                            
                else if (vt == VT_UI1 || vt == VT_I1)
                    objects[vectorIdentifiers[i] - basePropertyId] = (byte)vectorProperties[i * 4 + 2];
                else if (vt == VT_UI2 || vt == VT_I2) 
                    objects[vectorIdentifiers[i] - basePropertyId] = (short)vectorProperties[i * 4 + 2];
                else if (vt == VT_UI4 || vt == VT_I4)
                    objects[vectorIdentifiers[i] - basePropertyId] = vectorProperties[i * 4 + 2];
            }

            handleVectorIdentifiers.Free();
            handleVectorProperties.Free();
            handleVectorStatus.Free();                  
        }

        [StructLayout(LayoutKind.Sequential)]
        public class MQPROPS {
            internal int propertyCount;
            internal IntPtr propertyIdentifiers;
            internal IntPtr propertyValues;
            internal IntPtr status;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\services\messaging\system\messaging\interop\unsafenativemethods.cs ===
//------------------------------------------------------------------------------
// <copyright file="UnsafeNativeMethods.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Messaging.Interop {
    using System.Text;
    using System.Threading;
    using System.Runtime.InteropServices;
    using System.Diagnostics;
    using System;    
    using System.ComponentModel;
    using Microsoft.Win32;
    using System.Security;
    using System.Security.Permissions;
        
    [
    System.Runtime.InteropServices.ComVisible(false), 
    System.Security.SuppressUnmanagedCodeSecurityAttribute()
    ]
    internal class UnsafeNativeMethods {
                    
        [DllImport(ExternDll.Mqrt, EntryPoint="MQOpenQueue", CharSet=System.Runtime.InteropServices.CharSet.Unicode)]
        private static extern int IntMQOpenQueue(string formatName, int access, int shareMode, out IntPtr handle);
        public static int MQOpenQueue(string formatName, int access, int shareMode, out IntPtr handle) {
            try {
                return IntMQOpenQueue(formatName, access, shareMode, out handle);
            }         
            catch (Exception) {
                throw new InvalidOperationException(Res.GetString(Res.MSMQNotInstalled));
            }
        }
    
        [DllImport(ExternDll.Mqrt, CharSet=System.Runtime.InteropServices.CharSet.Unicode)]
        public static extern int MQSendMessage(IntPtr handle, MessagePropertyVariants.MQPROPS properties, IntPtr transaction);        
    
        [DllImport(ExternDll.Mqrt, CharSet=System.Runtime.InteropServices.CharSet.Unicode)]
        public static extern int MQSendMessage(IntPtr handle, MessagePropertyVariants.MQPROPS properties, ITransaction transaction);        

        [DllImport(ExternDll.Mqrt, CharSet=System.Runtime.InteropServices.CharSet.Unicode)]
        public unsafe static extern int MQReceiveMessage(IntPtr handle, uint timeout, int action, MessagePropertyVariants.MQPROPS properties, NativeOverlapped * overlapped,
                                                                                                     SafeNativeMethods.ReceiveCallback receiveCallback, IntPtr cursorHandle, IntPtr transaction);
        
        [DllImport(ExternDll.Mqrt, CharSet=System.Runtime.InteropServices.CharSet.Unicode)]
        public unsafe static extern int MQReceiveMessage(IntPtr handle, uint timeout, int action, MessagePropertyVariants.MQPROPS properties, NativeOverlapped * overlapped, 
                                                                                                    SafeNativeMethods.ReceiveCallback receiveCallback, IntPtr cursorHandle, ITransaction transaction);
                                                                                                    
        [DllImport(ExternDll.Mqrt, EntryPoint="MQCreateQueue", CharSet=System.Runtime.InteropServices.CharSet.Unicode)]
        private static extern int IntMQCreateQueue(IntPtr securityDescriptor, MessagePropertyVariants.MQPROPS queueProperties, StringBuilder formatName, ref int formatNameLength);
        public static int MQCreateQueue(IntPtr securityDescriptor, MessagePropertyVariants.MQPROPS queueProperties, StringBuilder formatName, ref int formatNameLength) {
            try {
                return IntMQCreateQueue(securityDescriptor, queueProperties, formatName, ref formatNameLength);
            }            
            catch (Exception) {
                throw new InvalidOperationException(Res.GetString(Res.MSMQNotInstalled));
            }
        }

        [DllImport(ExternDll.Mqrt, EntryPoint="MQDeleteQueue", CharSet=System.Runtime.InteropServices.CharSet.Unicode)]
        private static extern int IntMQDeleteQueue(string formatName);
        public static int MQDeleteQueue(string formatName) {
            try {
                return IntMQDeleteQueue(formatName);
            }
            catch (Exception) {
                throw new InvalidOperationException(Res.GetString(Res.MSMQNotInstalled));
            }
        }

        [DllImport(ExternDll.Mqrt, EntryPoint="MQLocateBegin", CharSet=System.Runtime.InteropServices.CharSet.Unicode)]
        private static extern int IntMQLocateBegin(string context,  Restrictions.MQRESTRICTION Restriction,  Columns.MQCOLUMNSET columnSet, NativeMethods.MQSORTSET  sort, out IntPtr enumHandle);
        public static int MQLocateBegin(string context,  Restrictions.MQRESTRICTION Restriction,  Columns.MQCOLUMNSET columnSet, NativeMethods.MQSORTSET  sort, out IntPtr enumHandle) {
            try {
                return IntMQLocateBegin(context, Restriction, columnSet, sort, out enumHandle);
            }            
            catch (Exception) {
                throw new InvalidOperationException(Res.GetString(Res.MSMQNotInstalled));
            }
        }                                                                                                    

         [DllImport(ExternDll.Mqrt, EntryPoint="MQGetMachineProperties", CharSet=System.Runtime.InteropServices.CharSet.Unicode)]
        private static extern int IntMQGetMachineProperties(string machineName, IntPtr machineIdPointer, MessagePropertyVariants.MQPROPS machineProperties);
        public static int MQGetMachineProperties(string machineName, IntPtr machineIdPointer, MessagePropertyVariants.MQPROPS machineProperties) {
            try {
                return IntMQGetMachineProperties(machineName, machineIdPointer, machineProperties);
            }            
            catch (Exception) {
                throw new InvalidOperationException(Res.GetString(Res.MSMQNotInstalled));
            }
        }

        [DllImport(ExternDll.Mqrt, EntryPoint="MQGetQueueProperties", CharSet=System.Runtime.InteropServices.CharSet.Unicode)]
        private static extern int IntMQGetQueueProperties(string formatName, MessagePropertyVariants.MQPROPS queueProperties);
        public static int MQGetQueueProperties(string formatName, MessagePropertyVariants.MQPROPS queueProperties) {
            try {
                return IntMQGetQueueProperties(formatName, queueProperties);
            }            
            catch (Exception) {
                throw new InvalidOperationException(Res.GetString(Res.MSMQNotInstalled));
            }
        }

        [DllImport(ExternDll.Mqrt, EntryPoint="MQMgmtGetInfo", CharSet=System.Runtime.InteropServices.CharSet.Unicode)]
        private static extern int IntMQMgmtGetInfo(string machineName, string objectName, MessagePropertyVariants.MQPROPS queueProperties);
        public static int MQMgmtGetInfo(string machineName, string objectName, MessagePropertyVariants.MQPROPS queueProperties) {
            try {
                return IntMQMgmtGetInfo(machineName, objectName, queueProperties);
            }                        
            catch (EntryPointNotFoundException) {
                throw new InvalidOperationException(Res.GetString(Res.MSMQInfoNotSupported));
            }
            catch (Exception) {
                throw new InvalidOperationException(Res.GetString(Res.MSMQNotInstalled));
            }
        }

        [DllImport(ExternDll.Mqrt, CharSet=System.Runtime.InteropServices.CharSet.Unicode)]
        public static extern int MQPurgeQueue(IntPtr handle);

        [DllImport(ExternDll.Mqrt, EntryPoint="MQSetQueueProperties", CharSet=System.Runtime.InteropServices.CharSet.Unicode)]
        private static extern int IntMQSetQueueProperties(string formatName,  MessagePropertyVariants.MQPROPS queueProperties);
        public static int MQSetQueueProperties(string formatName,  MessagePropertyVariants.MQPROPS queueProperties) {
            try {
                return IntMQSetQueueProperties(formatName, queueProperties);
            }         
            catch (Exception) {
                throw new InvalidOperationException(Res.GetString(Res.MSMQNotInstalled));
            }
        }
        
        // This method gets us the current security descriptor In "self-relative" format - so it contains offsets instead of pointers,
        // and we don't know how big the return buffer is, so we just use an IntPtr parameter
        [DllImport(ExternDll.Mqrt, CharSet=System.Runtime.InteropServices.CharSet.Unicode, SetLastError=true)]
        public static extern int MQGetQueueSecurity(string formatName, int SecurityInformation, IntPtr SecurityDescriptor, int length, out int lengthNeeded);
        
        // This method takes a security descriptor In "absolute" formate - so it will always be the same size and
        // we can just use the SECURITY_DESCRIPTOR class.
        [DllImport(ExternDll.Mqrt, CharSet=System.Runtime.InteropServices.CharSet.Unicode, SetLastError=true)]
        public static extern int MQSetQueueSecurity(string formatName, int SecurityInformation, NativeMethods.SECURITY_DESCRIPTOR SecurityDescriptor);    
        
        [DllImport(ExternDll.Advapi32, SetLastError=true)]
        public static extern bool GetSecurityDescriptorDacl(IntPtr pSD, out bool daclPresent, out IntPtr pDacl, out bool daclDefaulted);
        
        [DllImport(ExternDll.Advapi32, SetLastError=true)]
        public static extern bool SetSecurityDescriptorDacl(NativeMethods.SECURITY_DESCRIPTOR pSD, bool daclPresent, IntPtr pDacl, bool daclDefaulted);
        
        [DllImport(ExternDll.Advapi32, SetLastError=true)]
        public static extern bool InitializeSecurityDescriptor(NativeMethods.SECURITY_DESCRIPTOR SD, int revision);
        
        [DllImport(ExternDll.Advapi32, CharSet=System.Runtime.InteropServices.CharSet.Auto, SetLastError=true)]
        public static extern bool LookupAccountName(string lpSystemName,
                                                     string lpAccountName,
                                                     IntPtr sid,
                                                     ref int sidSize,
                                                     StringBuilder DomainName,
                                                     ref int DomainSize,
                                                     out int pUse);                                                          
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\services\messaging\system\messaging\interop\nativemethods.cs ===
//------------------------------------------------------------------------------
// <copyright file="NativeMethods.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------    

namespace System.Messaging.Interop {
    using System.Text;
    using System.Threading;
    using System.Runtime.InteropServices;
    using System.Diagnostics;
    using System;    
    using System.ComponentModel;
    using Microsoft.Win32;
    using System.Security;
    using System.Security.Permissions;
        
    [
    System.Runtime.InteropServices.ComVisible(false)    
    ]
    internal class NativeMethods {
        //Message Acknowledge constants.
        public const int ACKNOWLEDGE_NEGATIVE_ARRIVAL = 0x04;
        public const int ACKNOWLEDGE_NEGATIVE_RECEIVE = 0x08;
        public const int ACKNOWLEDGE_NONE = 0x00;
        public const int ACKNOWLEDGE_POSITIVE_ARRIVAL = 0x01;
        public const int ACKNOWLEDGE_POSITIVE_RECEIVE = 0x02;
        public const int ACKNOWLEDGE_FULL_REACH_QUEUE = ACKNOWLEDGE_NEGATIVE_ARRIVAL |
                                                        ACKNOWLEDGE_POSITIVE_ARRIVAL;
        public const int ACKNOWLEDGE_FULL_RECEIVE = ACKNOWLEDGE_NEGATIVE_ARRIVAL |
                                                    ACKNOWLEDGE_NEGATIVE_RECEIVE | ACKNOWLEDGE_POSITIVE_RECEIVE;
        public const int ACKNOWLEDGE_NOTACKNOWLEDGE_REACH_QUEUE = ACKNOWLEDGE_NEGATIVE_ARRIVAL;
        public const int ACKNOWLEDGE_NOTACKNOWLEDGE_RECEIVE = ACKNOWLEDGE_NEGATIVE_ARRIVAL |
                                                              ACKNOWLEDGE_NEGATIVE_RECEIVE;

        // Algorithm classes.
        private const int ALG_CLASS_DATA_ENCRYPT = (3 << 13);
        private const int ALG_CLASS_HASH = (4 << 13);

        // Hash sub ids.
        private const int ALG_SID_MD2 = 1;
        private const int ALG_SID_MD4 = 2;
        private const int ALG_SID_MD5 = 3;
        private const int ALG_SID_SHA = 4;
        private const int ALG_SID_MAC = 5;
        private const int ALG_SID_RIPEMD = 6;
        private const int ALG_SID_RIPEMD160 = 7;
        private const int ALG_SID_SSL3SHAMD5 = 8;

        // RC2 sub-ids.
        private const int ALG_SID_RC2 = 2;
        private const int ALG_SID_RC4 = 1;

        // Algorithm types.
        private const int ALG_TYPE_ANY = 0;
        private const int ALG_TYPE_BLOCK = (3 << 9);
        private const int ALG_TYPE_STREAM = (4 << 9);

        // Algorithm identifier definitions.
        public const int CALG_MD2 = (ALG_CLASS_HASH | ALG_TYPE_ANY | ALG_SID_MD2);
        public const int CALG_MD4 = (ALG_CLASS_HASH | ALG_TYPE_ANY | ALG_SID_MD4);
        public const int CALG_MD5 = (ALG_CLASS_HASH | ALG_TYPE_ANY | ALG_SID_MD5);
        public const int CALG_SHA = (ALG_CLASS_HASH | ALG_TYPE_ANY | ALG_SID_SHA);
        public const int CALG_MAC = (ALG_CLASS_HASH | ALG_TYPE_ANY | ALG_SID_MAC);
        public const int CALG_RC2 = (ALG_CLASS_DATA_ENCRYPT|ALG_TYPE_BLOCK|ALG_SID_RC2);
        public const int CALG_RC4 = (ALG_CLASS_DATA_ENCRYPT|ALG_TYPE_STREAM|ALG_SID_RC4);

        //Stream constants
        public const   int LOCK_WRITE = 0x1;
        public const   int LOCK_EXCLUSIVE = 0x2;
        public const   int LOCK_ONLYONCE = 0x4;
        public const   int STATFLAG_DEFAULT = 0x0;
        public const   int STATFLAG_NONAME = 0x1;
        public const   int STATFLAG_NOOPEN = 0x2;
        public const   int STGC_DEFAULT = 0x0;
        public const   int STGC_OVERWRITE = 0x1;
        public const   int STGC_ONLYIFCURRENT = 0x2;
        public const   int STGC_DANGEROUSLYCOMMITMERELYTODISKCACHE = 0x4;
        public const   int STREAM_SEEK_SET = 0x0;
        public const   int STREAM_SEEK_CUR = 0x1;
        public const   int STREAM_SEEK_END = 0x2;
        
        public const int E_UNEXPECTED = unchecked((int)0x8000FFFF);
        public const int E_NOTIMPL = unchecked((int)0x80004001);
        public const int E_OUTOFMEMORY = unchecked((int)0x8007000E);
        public const int E_INVALIDARG = unchecked((int)0x80070057);
        public const int E_NOINTERFACE = unchecked((int)0x80004002);
        public const int E_POINTER = unchecked((int)0x80004003);
        public const int E_HANDLE = unchecked((int)0x80070006);
        public const int E_ABORT = unchecked((int)0x80004004);
        public const int E_FAIL = unchecked((int)0x80004005);

        public static Guid IID_IUnknown = new Guid("{00000000-0000-0000-C000-000000000046}");
        public static IntPtr InvalidIntPtr = ((IntPtr)((int)(-1)));       
        
        //Management Properties constants.
        public const int MANAGEMENT_BASE = 0;
        public const int MANAGEMENT_ACTIVEQUEUES = (MANAGEMENT_BASE + 1);   /* VT_LPWSTR | VT_VECTOR */
        public const int MANAGEMENT_PRIVATEQ = (MANAGEMENT_BASE + 2);      /* VT_LPWSTR | VT_VECTOR  */
        public const int MANAGEMENT_DSSERVER = (MANAGEMENT_BASE + 3);      /* VT_LPWSTR        */
        public const int MANAGEMENT_CONNECTED = (MANAGEMENT_BASE + 4);     /* VT_LPWSTR        */
        public const int MANAGEMENT_TYPE = (MANAGEMENT_BASE + 5);    /* VT_LPWSTR        */

        //Machine Properties constants.
        public const int MACHINE_BASE = 200;
        public const int MACHINE_SITE_ID = MACHINE_BASE + 1;  /* VT_CLSID            */
        public const int MACHINE_ID = MACHINE_BASE + 2;  /* VT_CLSID            */
        public const int MACHINE_PATHNAME = MACHINE_BASE + 3;  /* VT_LPWSTR           */
        public const int MACHINE_CONNECTION =  MACHINE_BASE + 4;  /* VT_LPWSTR|VT_VECTOR */
        public const int MACHINE_ENCRYPTION_PK = MACHINE_BASE + 5;  /* VT_BLOB             */

        //Max constants.
        public const int MAX_MESSAGE_ID_SIZE = 20;
        public const int MAX_LABEL_LEN = 124;

        //Message Authentication level constants.
        public const int MESSAGE_AUTHENTICATION_LEVEL_NONE = 0;
        public const int MESSAGE_AUTHENTICATION_LEVEL_ALWAYS = 1;
        public const int MESSAGE_AUTHENTICATION_LEVEL_MSMQ10 = 2;
        public const int MESSAGE_AUTHENTICATION_LEVEL_MSMQ20 = 4;

        //Message Class constants
        public const int MESSAGE_CLASS_ACCESS_DENIED = (1 << 15) | 0x04;
        public const int MESSAGE_CLASS_BAD_DESTINATION_QUEUE = (1 << 15);
        public const int MESSAGE_CLASS_BAD_ENCRYPTION = (1 << 15) | 0x07;
        public const int MESSAGE_CLASS_BAD_SIGNATURE = (1 << 15) | 0x06;
        public const int MESSAGE_CLASS_COULD_NOT_ENCRYPT = (1 << 15) | 0x08;
        public const int MESSAGE_CLASS_HOP_COUNT_EXCEEDED = (1 << 15) | 0x05;
        public const int MESSAGE_CLASS_NORMAL = 0x00;
        public const int MESSAGE_CLASS_NOT_TRANSACTIONAL_QUEUE = (1 << 15) | 0x09;
        public const int MESSAGE_CLASS_NOT_TRANSACTIONAL_MESSAGE = (1 << 15) | 0x0A;
        public const int MESSAGE_CLASS_PURGED = (1 << 15) | 0x01;
        public const int MESSAGE_CLASS_QUEUE_DELETED = (1 << 15) | (1 << 14);
        public const int MESSAGE_CLASS_QUEUE_EXCEED_QUOTA = (1 << 15) | 0x03;
        public const int MESSAGE_CLASS_QUEUE_PURGED = (1 << 15) | (1 << 14) | 0x01;
        public const int MESSAGE_CLASS_REACH_QUEUE = 0x02;
        public const int MESSAGE_CLASS_REACH_QUEUE_TIMEOUT = (1 << 15) | 0x02;
        public const int MESSAGE_CLASS_RECEIVE = (1 << 14);
        public const int MESSAGE_CLASS_RECEIVE_TIMEOUT = (1 << 15) | (1 << 14) | 0x02;
        public const int MESSAGE_CLASS_REPORT = 0x01;

        //Message Delivery constants.
        public const int MESSAGE_DELIVERY_EXPRESS = 0;
        public const int MESSAGE_DELIVERY_RECOVERABLE = 1;

        //Message Journal constants.
        public const int MESSAGE_JOURNAL_NONE = 0;
        public const int MESSAGE_JOURNAL_DEADLETTER = 1;
        public const int MESSAGE_JOURNAL_JOURNAL = 2;

        //Message Privacy Level constants.
        public const int MESSAGE_PRIVACY_LEVEL_NONE = 0;
        public const int MESSAGE_PRIVACY_LEVEL_BODY = 1;

        //Message PropertyId constants.
        public const int MESSAGE_PROPID_BASE = 0;
        public const int MESSAGE_PROPID_ACKNOWLEDGE = (MESSAGE_PROPID_BASE + 6);            /* VT_UI1           */
        public const int MESSAGE_PROPID_ADMIN_QUEUE = (MESSAGE_PROPID_BASE + 17);           /* VT_LPWSTR        */
        public const int MESSAGE_PROPID_ADMIN_QUEUE_LEN = (MESSAGE_PROPID_BASE + 18);       /* VT_UI4           */
        public const int MESSAGE_PROPID_APPSPECIFIC = (MESSAGE_PROPID_BASE + 8);            /* VT_UI4           */
        public const int MESSAGE_PROPID_ARRIVEDTIME = (MESSAGE_PROPID_BASE + 32);           /* VT_UI4           */
        public const int MESSAGE_PROPID_AUTHENTICATED = (MESSAGE_PROPID_BASE + 25);         /* VT_UI1           */
        public const int MESSAGE_PROPID_AUTH_LEVEL = (MESSAGE_PROPID_BASE + 24);            /* VT_UI4           */
        public const int MESSAGE_PROPID_BODY = (MESSAGE_PROPID_BASE + 9);                   /* VT_UI1|VT_VECTOR */
        public const int MESSAGE_PROPID_BODY_SIZE = (MESSAGE_PROPID_BASE + 10);             /* VT_UI4           */
        public const int MESSAGE_PROPID_BODY_TYPE = (MESSAGE_PROPID_BASE + 42);             /* VT_UI4           */
        public const int MESSAGE_PROPID_CLASS = (MESSAGE_PROPID_BASE + 1);                  /* VT_UI2           */
        public const int MESSAGE_PROPID_CONNECTOR_TYPE = (MESSAGE_PROPID_BASE + 38);        /* VT_CLSID         */
        public const int MESSAGE_PROPID_CORRELATIONID = (MESSAGE_PROPID_BASE + 3);          /* VT_UI1|VT_VECTOR */
        public const int MESSAGE_PROPID_DELIVERY = (MESSAGE_PROPID_BASE + 5);               /* VT_UI1           */
        public const int MESSAGE_PROPID_DEST_QUEUE = (MESSAGE_PROPID_BASE + 33);            /* VT_LPWSTR        */
        public const int MESSAGE_PROPID_DEST_QUEUE_LEN = (MESSAGE_PROPID_BASE + 34);        /* VT_UI4           */
        public const int MESSAGE_PROPID_DEST_SYMM_KEY = (MESSAGE_PROPID_BASE + 43);         /* VT_UI1|VT_VECTOR */
        public const int MESSAGE_PROPID_DEST_SYMM_KEY_LEN = (MESSAGE_PROPID_BASE + 44);     /* VT_UI4           */
        public const int MESSAGE_PROPID_ENCRYPTION_ALG = (MESSAGE_PROPID_BASE + 27);        /* VT_UI4           */
        public const int MESSAGE_PROPID_EXTENSION = (MESSAGE_PROPID_BASE + 35);             /* VT_UI1|VT_VECTOR */
        public const int MESSAGE_PROPID_EXTENSION_LEN = (MESSAGE_PROPID_BASE + 36);         /* VT_UI4           */
        public const int MESSAGE_PROPID_FIRST_IN_XACT = (MESSAGE_PROPID_BASE + 50);  /* VT_UI1           */
        public const int MESSAGE_PROPID_HASH_ALG = (MESSAGE_PROPID_BASE + 26);              /* VT_UI4           */
        public const int MESSAGE_PROPID_JOURNAL = (MESSAGE_PROPID_BASE + 7);                /* VT_UI1           */
        public const int MESSAGE_PROPID_LABEL = (MESSAGE_PROPID_BASE + 11);                 /* VT_LPWSTR        */
        public const int MESSAGE_PROPID_LABEL_LEN = (MESSAGE_PROPID_BASE + 12);             /* VT_UI4           */
        public const int MESSAGE_PROPID_LAST_IN_XACT = (MESSAGE_PROPID_BASE + 51);  /* VT_UI1           */
        public const int MESSAGE_PROPID_MSGID = (MESSAGE_PROPID_BASE + 2);                  /* VT_UI1|VT_VECTOR */
        public const int MESSAGE_PROPID_PRIORITY = (MESSAGE_PROPID_BASE + 4);               /* VT_UI1           */
        public const int MESSAGE_PROPID_PRIV_LEVEL = (MESSAGE_PROPID_BASE + 23);            /* VT_UI4           */
        public const int MESSAGE_PROPID_PROV_NAME = (MESSAGE_PROPID_BASE + 48);             /* VT_LPWSTR        */
        public const int MESSAGE_PROPID_PROV_NAME_LEN = (MESSAGE_PROPID_BASE + 49);         /* VT_UI4           */
        public const int MESSAGE_PROPID_PROV_TYPE = (MESSAGE_PROPID_BASE + 47);             /* VT_UI4           */
        public const int MESSAGE_PROPID_RESP_QUEUE = (MESSAGE_PROPID_BASE + 15);            /* VT_LPWSTR        */
        public const int MESSAGE_PROPID_RESP_QUEUE_LEN = (MESSAGE_PROPID_BASE + 16);        /* VT_UI4           */
        public const int MESSAGE_PROPID_SECURITY_CONTEXT = (MESSAGE_PROPID_BASE + 37);      /* VT_UI4           */
        public const int MESSAGE_PROPID_SENDERID = (MESSAGE_PROPID_BASE + 20);              /* VT_UI1|VT_VECTOR */
        public const int MESSAGE_PROPID_SENDERID_LEN = (MESSAGE_PROPID_BASE + 21);          /* VT_UI4           */
        public const int MESSAGE_PROPID_SENDERID_TYPE = (MESSAGE_PROPID_BASE + 22);         /* VT_UI4           */
        public const int MESSAGE_PROPID_SENDER_CERT = (MESSAGE_PROPID_BASE + 28);           /* VT_UI1|VT_VECTOR */
        public const int MESSAGE_PROPID_SENDER_CERT_LEN = (MESSAGE_PROPID_BASE + 29);       /* VT_UI4           */
        public const int MESSAGE_PROPID_SENTTIME = (MESSAGE_PROPID_BASE + 31);              /* VT_UI4           */
        public const int MESSAGE_PROPID_SIGNATURE = (MESSAGE_PROPID_BASE + 45);             /* VT_UI1|VT_VECTOR */
        public const int MESSAGE_PROPID_SIGNATURE_LEN = (MESSAGE_PROPID_BASE + 46);         /* VT_UI4           */
        public const int MESSAGE_PROPID_SRC_MACHINE_ID = (MESSAGE_PROPID_BASE + 30);        /* VT_CLSID         */
        public const int MESSAGE_PROPID_TIME_TO_BE_RECEIVED = (MESSAGE_PROPID_BASE + 14);   /* VT_UI4           */
        public const int MESSAGE_PROPID_TIME_TO_REACH_QUEUE = (MESSAGE_PROPID_BASE + 13);   /* VT_UI4           */
        public const int MESSAGE_PROPID_TRACE = (MESSAGE_PROPID_BASE + 41);                 /* VT_UI1           */
        public const int MESSAGE_PROPID_VERSION = (MESSAGE_PROPID_BASE + 19);               /* VT_UI4           */
        public const int MESSAGE_PROPID_XACT_STATUS_QUEUE = (MESSAGE_PROPID_BASE + 39);     /* VT_LPWSTR        */
        public const int MESSAGE_PROPID_XACT_STATUS_QUEUE_LEN = (MESSAGE_PROPID_BASE + 40); /* VT_UI4           */
        public const int MESSAGE_PROPID_XACTID = (MESSAGE_PROPID_BASE + 52); /* VT_UI1|VT_VECTOR */

        //Message SenderId types
        public const int MESSAGE_SENDERID_TYPE_NONE = 0;
        public const int MESSAGE_SENDERID_TYPE_SID = 1;

        //Message Trace constants.
        public const int MESSAGE_TRACE_NONE = 0;
        public const int MESSAGE_TRACE_SEND_ROUTE_TO_REPORT_QUEUE  =  1;

        // Chryptographic Provider Types
        public const int PROV_RSA_FULL = 1;
        public const int PROV_RSA_SIG = 2;
        public const int PROV_DSS = 3;
        public const int PROV_FORTEZZA = 4;
        public const int PROV_MS_EXCHANGE = 5;
        public const int PROV_SSL = 6;
        public const int PROV_STT_MER = 7;
        public const int PROV_STT_ACQ = 8;
        public const int PROV_STT_BRND = 9;
        public const int PROV_STT_ROOT = 10;
        public const int PROV_STT_ISS = 11;

        //Queue Access constants.
        public const int QUEUE_ACCESS_RECEIVE = 1;
        public const int QUEUE_ACCESS_SEND = 2;
        public const int QUEUE_ACCESS_PEEK = 32;

        //Queue Action constants
        public const int QUEUE_ACTION_RECEIVE = 0x00000000;
        public const int QUEUE_ACTION_PEEK_CURRENT = unchecked((int)0x80000000);
        public const int QUEUE_ACTION_PEEK_NEXT = unchecked((int)0x80000001);

        //Queue Authenticate constants.
        public const int QUEUE_AUTHENTICATE_NONE = 0;
        public const int QUEUE_AUTHENTICATE_AUTHENTICATE = 1;

        //Queue Journal constants.
        public const int QUEUE_JOURNAL_NONE = 0;
        public const int QUEUE_JOURNAL_JOURNAL = 1;

        //Queue Privacy level constants
        public const int QUEUE_PRIVACY_LEVEL_NONE = 0;
        public const int QUEUE_PRIVACY_LEVEL_OPTIONAL = 1;
        public const int QUEUE_PRIVACY_LEVEL_BODY = 2;

        //Queue PropertyId constants.
        public const int QUEUE_PROPID_BASE = 100;
        public const int QUEUE_PROPID_INSTANCE = QUEUE_PROPID_BASE + 1;           /* VT_CLSID     */
        public const int QUEUE_PROPID_TYPE = QUEUE_PROPID_BASE + 2;               /* VT_CLSID     */
        public const int QUEUE_PROPID_PATHNAME = QUEUE_PROPID_BASE + 3;           /* VT_LPWSTR    */
        public const int QUEUE_PROPID_JOURNAL = QUEUE_PROPID_BASE + 4;            /* VT_UI1       */
        public const int QUEUE_PROPID_QUOTA = QUEUE_PROPID_BASE + 5;              /* VT_UI4       */
        public const int QUEUE_PROPID_BASEPRIORITY = QUEUE_PROPID_BASE + 6;       /* VT_I2        */
        public const int QUEUE_PROPID_JOURNAL_QUOTA = QUEUE_PROPID_BASE + 7;      /* VT_UI4       */
        public const int QUEUE_PROPID_LABEL = QUEUE_PROPID_BASE + 8;              /* VT_LPWSTR    */
        public const int QUEUE_PROPID_CREATE_TIME = QUEUE_PROPID_BASE + 9;        /* VT_I4        */
        public const int QUEUE_PROPID_MODIFY_TIME = QUEUE_PROPID_BASE + 10;       /* VT_I4        */
        public const int QUEUE_PROPID_AUTHENTICATE = QUEUE_PROPID_BASE + 11;      /* VT_UI1       */
        public const int QUEUE_PROPID_PRIV_LEVEL = QUEUE_PROPID_BASE + 12;        /* VT_UI4       */
        public const int QUEUE_PROPID_TRANSACTION = QUEUE_PROPID_BASE + 13;       /* VT_UI1       */
        public const int QUEUE_PROPID_PATHNAME_DNS  = QUEUE_PROPID_BASE + 24; /* VT_LPWSTR    */ 

        //Queue Shared Mode constants.
        public const int QUEUE_SHARED_MODE_DENY_NONE = 0;
        public const int QUEUE_SHARED_MODE_DENY_RECEIVE = 1;

        //Queue Transaction constants.
        public const int QUEUE_TRANSACTION_NONE   = 0;
        public const int QUEUE_TRANSACTION_MTS    = 1;
        public const int QUEUE_TRANSACTION_XA     = 2;
        public const int QUEUE_TRANSACTION_SINGLE = 3;

        //Queue Transactional Mode constants.
        public const int QUEUE_TRANSACTIONAL_NONE = 0;
        public const int QUEUE_TRANSACTIONAL_TRANSACTIONAL = 1;

        //Security constants
        public const int MQ_ERROR_SECURITY_DESCRIPTOR_TOO_SMALL = unchecked((int)0xc00e0023);
        public const int MQ_OK = 0;
        
        public const int TRUSTEE_IS_SID = 0;
        public const int TRUSTEE_IS_NAME = 1;
        public const int TRUSTEE_IS_USER = 1;
        public const int TRUSTEE_IS_GROUP = 2;
        public const int TRUSTEE_IS_DOMAIN = 3;
        public const int TRUSTEE_IS_ALIAS = 4;
        public const int TRUSTEE_IS_WELL_KNOWN_GROUP = 5;
        public const int DACL_SECURITY_INFORMATION = 4;
        public const int GRANT_ACCESS  = 1;
        public const int SET_ACCESS    = 2;
        public const int DENY_ACCESS   = 3;
        public const int REVOKE_ACCESS = 4;
        public const int NO_MULTIPLE_TRUSTEE = 0;
        public const int ERROR_SUCCESS = 0;
        public const int SECURITY_DESCRIPTOR_REVISION = 1;
                
        [StructLayout(LayoutKind.Sequential)]
        public class MQSORTSET {
            internal int sortCount = 0;
            internal int sortObjects = 0;
        }
                
        [DllImport(ExternDll.Ole32, PreserveSig=false)]
        [return: MarshalAs(UnmanagedType.Interface)]
        public static extern object OleLoadFromStream(IStream stream, [In] ref Guid iid);
        
        [DllImport(ExternDll.Ole32, PreserveSig=false)]
        public static extern void OleSaveToStream(IPersistStream persistStream, IStream stream);                                        
        
        [StructLayout(LayoutKind.Sequential)]
        public class SECURITY_DESCRIPTOR {
            public byte revision = 0;
            public byte size = 0;
            public short control = 0;
            public IntPtr owner = (IntPtr)0;
            public IntPtr Group = (IntPtr)0;
            public IntPtr Sacl = (IntPtr)0;
            public IntPtr Dacl = (IntPtr)0;
        }
        
        [StructLayout(LayoutKind.Sequential)]
        public struct ExplicitAccess {
            public int     grfAccessPermissions;
            public int     grfAccessMode;
            public int     grfInheritance;
            public IntPtr  pMultipleTrustees;
            public int     MultipleTrusteeOperation;
            public int     TrusteeForm;
            public int     TrusteeType;
            public IntPtr  data;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\services\monitoring\system\diagnosticts\countercreationdatacollection.cs ===
//------------------------------------------------------------------------------
// <copyright file="CounterCreationDataCollection.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Diagnostics {
    using System;
    using System.ComponentModel;
    using System.Collections;
 
    /// <include file='doc\CounterCreationDataCollection.uex' path='docs/doc[@for="CounterCreationDataCollection"]/*' />
    /// <devdoc>
    ///    <para>[To be supplied.]</para>
    /// </devdoc>
    [Serializable()]
    public class CounterCreationDataCollection : CollectionBase {
        private const int MaxCreationDataCount = 64;            
                                                                     
        /// <include file='doc\CounterCreationDataCollection.uex' path='docs/doc[@for="CounterCreationDataCollection.CounterCreationDataCollection"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public CounterCreationDataCollection() {
        }

        /// <include file='doc\CounterCreationDataCollection.uex' path='docs/doc[@for="CounterCreationDataCollection.CounterCreationDataCollection1"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public CounterCreationDataCollection(CounterCreationDataCollection value) {
            this.AddRange(value);
        } 
        
        /// <include file='doc\CounterCreationDataCollection.uex' path='docs/doc[@for="CounterCreationDataCollection.CounterCreationDataCollection2"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public CounterCreationDataCollection(CounterCreationData[] value) {
            this.AddRange(value);
        }
         
        /// <include file='doc\CounterCreationDataCollection.uex' path='docs/doc[@for="CounterCreationDataCollection.this"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public CounterCreationData this[int index] {
            get {
                return ((CounterCreationData)(List[index]));
            }
            set {
                List[index] = value;
            }
        }
        
        /// <include file='doc\CounterCreationDataCollection.uex' path='docs/doc[@for="CounterCreationDataCollection.Add"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public int Add(CounterCreationData value) {
            return List.Add(value);
        }

        /// <include file='doc\CounterCreationDataCollection.uex' path='docs/doc[@for="CounterCreationDataCollection.AddRange"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public void AddRange(CounterCreationData[] value) {
            if (value == null) {
                throw new ArgumentNullException("value");
            }
            for (int i = 0; ((i) < (value.Length)); i = ((i) + (1))) {
                this.Add(value[i]);
            }
        }

        /// <include file='doc\CounterCreationDataCollection.uex' path='docs/doc[@for="CounterCreationDataCollection.AddRange1"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public void AddRange(CounterCreationDataCollection value) {
            if (value == null) {
                throw new ArgumentNullException("value");
            }
            int currentCount = value.Count;
            for (int i = 0; i < currentCount; i = ((i) + (1))) {
                this.Add(value[i]);
            }
        }
                
        /// <include file='doc\CounterCreationDataCollection.uex' path='docs/doc[@for="CounterCreationDataCollection.Contains"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public bool Contains(CounterCreationData value) {
            return List.Contains(value);
        }
        
        /// <include file='doc\CounterCreationDataCollection.uex' path='docs/doc[@for="CounterCreationDataCollection.CopyTo"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public void CopyTo(CounterCreationData[] array, int index) {
            List.CopyTo(array, index);
        }
        
        /// <include file='doc\CounterCreationDataCollection.uex' path='docs/doc[@for="CounterCreationDataCollection.IndexOf"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public int IndexOf(CounterCreationData value) {
            return List.IndexOf(value);
        }
        
        /// <include file='doc\CounterCreationDataCollection.uex' path='docs/doc[@for="CounterCreationDataCollection.Insert"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public void Insert(int index, CounterCreationData value) {
            List.Insert(index, value);
        }
        
        /// <include file='doc\CounterCreationDataCollection.uex' path='docs/doc[@for="CounterCreationDataCollection.Remove"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public virtual void Remove(CounterCreationData value) {
            List.Remove(value);
        }       
        
        /// <include file='doc\CounterCreationDataCollection.uex' path='docs/doc[@for="CounterCreationDataCollection.OnInsert"]/*' />
        ///<internalonly/>
        protected override void OnInsert(int index, object value) {        
            if (InnerList.Count == MaxCreationDataCount)
                throw new InvalidOperationException(SR.GetString(SR.PerfMaxCreationDataCount, 0 , MaxCreationDataCount));
        }         			
    }    
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\services\monitoring\system\diagnosticts\alphabeticalenumconverter.cs ===
//------------------------------------------------------------------------------
// <copyright file="AlphabeticalEnumConverter.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Diagnostics {

    using System.Collections;
    using System.ComponentModel;
    using System;
    using System.Globalization;
    

    /// <include file='doc\AlphabeticalEnumConverter.uex' path='docs/doc[@for="AlphabeticalEnumConverter"]/*' />
    /// <internalonly/>
    /// <devdoc>
    ///    <para>
    ///       Provides a type converter to
    ///       convert ???? objects to and from various other representations.
    ///    </para>
    /// </devdoc>
    internal class AlphabeticalEnumConverter : EnumConverter {

        public AlphabeticalEnumConverter(Type type) : base(type) {
        }

        public override StandardValuesCollection GetStandardValues(ITypeDescriptorContext context) {
            if (Values == null) {
                Array objValues = Enum.GetValues(EnumType);
                //IComparer comparer = Comparer;
                object[] names = new object[objValues.Length];
                for (int i = 0; i < names.Length; i++)
                    names[i] = ConvertTo(context, null, objValues.GetValue(i), typeof(string));
                Array.Sort(names, objValues, 0, objValues.Length, System.Collections.Comparer.Default);
                Values = new StandardValuesCollection(objValues);
            }
            return Values;
        }

    }

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\services\monitoring\system\diagnosticts\countersamplecalculator.cs ===
//------------------------------------------------------------------------------
// <copyright file="CounterSampleCalculator.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Diagnostics {
    using System.Threading;    
    using System;    
    using Microsoft.Win32;

    /// <include file='doc\CounterSampleCalculator.uex' path='docs/doc[@for="CounterSampleCalculator"]/*' />
    /// <devdoc>
    ///     Set of utility functions for interpreting the counter data
    ///     NOTE: most of this code was taken and ported from counters.c (PerfMon source code)
    /// </devdoc>
    public sealed class CounterSampleCalculator {
        // Constant used to determine if a data set is "too big."
        // Value seems a bit arbitrary, but it's the same that PerfMon uses, so...
        private const float TOO_BIG = 1500000000;

        private CounterSampleCalculator() {
        } 
        
        /// <include file='doc\CounterSampleCalculator.uex' path='docs/doc[@for="CounterSampleCalculator.GetTimeInterval"]/*' />
        /// <devdoc>
        ///    Get the difference between the current and previous time counts,
        ///        then divide by the frequency.
        /// </devdoc>
        /// <internalonly/>
        private static float GetTimeInterval(ulong currentTime, ulong previousTime, ulong freq)
        {
            float eTimeDifference;
            float eFreq;
            float eTimeInterval;            

            // Get the number of counts that have occured since the last sample
            if (previousTime >=  currentTime || freq <= 0)
                return 0.0f;
                
            eTimeDifference = (float)(currentTime - previousTime);                        
            eFreq = (float) freq;
            // Get the time since the last sample.
            eTimeInterval = eTimeDifference / eFreq ;

            return eTimeInterval;
        
        }

        /// <include file='doc\CounterSampleCalculator.uex' path='docs/doc[@for="CounterSampleCalculator.IsCounterBulk"]/*' />
        /// <devdoc>
        ///    Helper function, determines if a given counter type is of a bulk count type.
        /// </devdoc>
        /// <internalonly/>
        private static bool IsCounterBulk(int counterType) {
            if (counterType == NativeMethods.PERF_COUNTER_BULK_COUNT) {
                return true;
            }

            return false;
        }
        
        /// <include file='doc\CounterSampleCalculator.uex' path='docs/doc[@for="CounterSampleCalculator.CounterCounterCommon"]/*' />
        /// <devdoc>
        ///    Take the difference between the current and previous counts
        ///        then divide by the time interval
        /// </devdoc>
        /// <internalonly/>
        private static float CounterCounterCommon(CounterSample oldSample, CounterSample newSample) {
            float eTimeInterval;
            float eDifference;
            float eCount ;            
            bool bValueDrop = false;            

            if (! IsCounterBulk((int)oldSample.CounterType)) {
                // check if it is too big to be a wrap-around case
                if (newSample.UnsignedRawValue < oldSample.UnsignedRawValue) {
                    if (newSample.UnsignedRawValue - oldSample.UnsignedRawValue > 0x00ffff0000) {
                        return 0.0f;
                    }
                    
                    bValueDrop = true;   
                }
            }

            if (oldSample.UnsignedRawValue >= newSample.UnsignedRawValue)
                return 0.0f;
                                
            eDifference = (float)(newSample.UnsignedRawValue - oldSample.UnsignedRawValue);

            
            eTimeInterval = GetTimeInterval((ulong)newSample.TimeStamp,
                                             (ulong)oldSample.TimeStamp,
                                             (ulong)newSample.SystemFrequency);

            if (eTimeInterval <= 0.0f) {
                return 0.0f;
            } 
            else {                    
                eCount = eDifference / eTimeInterval ;

                if (bValueDrop && (eCount > TOO_BIG)) {
                    // ignore this bogus data since it is too big for
                    // the wrap-around case
                    eCount = 0.0f ;
                }
                return eCount;
            }            
        }

        /// <include file='doc\CounterSampleCalculator.uex' path='docs/doc[@for="CounterSampleCalculator.CounterAverageTimer"]/*' />
        /// <devdoc>
        ///    Take the differences between the current and previous times and counts
        ///    divide the time interval by the counts multiply by 10,000,000 (convert
        ///    from 100 nsec to sec)
        /// </devdoc>
        /// <internalonly/>
        private static float CounterAverageTimer(CounterSample oldSample, CounterSample newSample) {
            float eTimeInterval;
            float eCount;
            float eDifference;

            // Get the current and previous counts.

            if (oldSample.UnsignedBaseValue >= newSample.UnsignedBaseValue)
                return 0.0f;
                             
            eDifference = (float)(newSample.UnsignedBaseValue - oldSample.UnsignedBaseValue);

            // Get the amount of time that has passed since the last sample
            eTimeInterval = GetTimeInterval(newSample.UnsignedRawValue, oldSample.UnsignedRawValue, (ulong)newSample.SystemFrequency);

            if (eTimeInterval < 0.0f) { // return 0 if negative time has passed
                return 0.0f;
            } 
            else {
                // Get the number of counts in this time interval.
                eCount = eTimeInterval / (eDifference);
                return eCount;
            }
            
        }

        /// <include file='doc\CounterSampleCalculator.uex' path='docs/doc[@for="CounterSampleCalculator.CounterAverageBulk"]/*' />
        /// <devdoc>
        ///    Take the differences between the current and previous byte counts and
        ///    operation counts divide the bulk count by the operation counts
        /// </devdoc>
        /// <internalonly/>
        private static float CounterAverageBulk(CounterSample oldSample, CounterSample newSample) {
            float   eBulkDelta;
            float   eDifference;
            float   eCount;            

            // Get the bulk count increment since the last sample
            if (oldSample.UnsignedRawValue >= newSample.UnsignedRawValue)
                return 0.0f;
                
            eBulkDelta = (float)(newSample.UnsignedRawValue - oldSample.UnsignedRawValue);

            // Get the number of counts in this time interval.
            if (oldSample.UnsignedBaseValue >= newSample.UnsignedBaseValue)
                // Counter value invalid
                return 0.0f;
                
            // Get the current and previous counts.
            eDifference = (float)(newSample.UnsignedBaseValue - oldSample.UnsignedBaseValue);
                       
            eCount = eBulkDelta / eDifference;
            // Scale the value to up to 1 second
            return eCount ;        
        }
        

        /// <include file='doc\CounterSampleCalculator.uex' path='docs/doc[@for="CounterSampleCalculator.CounterTimerCommon"]/*' />
        /// <devdoc>
        ///    Take the difference between the current and previous counts,
        ///      Normalize the count (counts per interval)
        ///      divide by the time interval (count = % of interval)
        ///      if (invert)
        ///        subtract from 1 (the normalized size of an interval)
        ///      multiply by 100 (convert to a percentage)
        ///      this value from 100.
        /// </devdoc>
        /// <internalonly/>
        private static float CounterTimerCommon(CounterSample oldSample, CounterSample newSample) {
            float   eTimeInterval;
            float   eDifference;
            float   eFreq;
            float   eFraction;
            float   eMultiBase;
            float   eCount ;
            
            // Get the amount of time that has passed since the last sample
            int oldCounterType = (int) oldSample.CounterType;

            if (oldCounterType == NativeMethods.PERF_100NSEC_TIMER ||
                oldCounterType == NativeMethods.PERF_100NSEC_TIMER_INV ||
                oldCounterType == NativeMethods.PERF_100NSEC_MULTI_TIMER ||
                oldCounterType == NativeMethods.PERF_100NSEC_MULTI_TIMER_INV) {            
                    if (oldSample.TimeStamp100nSec >= newSample.TimeStamp100nSec)
                        return 0.0f;
                             
                    eTimeInterval = (float)((ulong)newSample.TimeStamp100nSec - (ulong)oldSample.TimeStamp100nSec);
            } 
            else {
                    eTimeInterval = GetTimeInterval((ulong)newSample.TimeStamp, (ulong)oldSample.TimeStamp, (ulong)newSample.SystemFrequency);
                    
                    if (eTimeInterval <= 0.0f) 
                        return 0.0f;           
            }

            
            // Get the current and previous counts.
            if (oldSample.UnsignedRawValue >= newSample.UnsignedRawValue)
                eDifference = -(float)(oldSample.UnsignedRawValue - newSample.UnsignedRawValue);
            else                
                eDifference = (float)(newSample.UnsignedRawValue - oldSample.UnsignedRawValue);

            // Get the number of counts in this time interval.
            // (1, 2, 3 or any number of seconds could have gone by since
            // the last sample)
            if (oldCounterType == 0 || oldCounterType == NativeMethods.PERF_COUNTER_TIMER_INV) {
                // Get the counts per interval (second)
                eFreq = (float)(ulong)newSample.SystemFrequency;
                if (eFreq <= 0.0f)
                   return (float) 0.0f;

                // Calculate the fraction of the counts that are used by whatever
                // we are measuring
                eFraction = eDifference / eFreq ;
            }
            else {
                eFraction = eDifference ;
            }

            // Calculate the fraction of time used by what were measuring.

            eCount = eFraction / eTimeInterval ;

            // If this is  an inverted count take care of the inversion.

            if (oldCounterType == NativeMethods.PERF_COUNTER_TIMER_INV || 
                oldCounterType == NativeMethods.PERF_100NSEC_TIMER_INV) {
                eCount = (float) 1.0f - eCount;
            }

            // If this is  an inverted multi count take care of the inversion.
            if (oldCounterType == NativeMethods.PERF_COUNTER_MULTI_TIMER_INV || 
                oldCounterType == NativeMethods.PERF_100NSEC_MULTI_TIMER_INV) {
                eMultiBase  = (float) newSample.UnsignedBaseValue;
                eCount = eMultiBase - eCount ;
            }

            // adjust eCount for non-inverted multi count

            if (oldCounterType == NativeMethods.PERF_COUNTER_MULTI_TIMER || 
                oldCounterType == NativeMethods.PERF_100NSEC_MULTI_TIMER) {
                eMultiBase = (float) newSample.UnsignedBaseValue;
                eCount = eCount / eMultiBase;
            }

            // Scale the value to up to 100.
            eCount *= 100.0f ;

            if (eCount < 0.0f) {
                eCount = 0.0f;
            }

            if (eCount > 100.0f &&
                oldCounterType != NativeMethods.PERF_100NSEC_MULTI_TIMER &&
                oldCounterType != NativeMethods.PERF_100NSEC_MULTI_TIMER_INV &&
                oldCounterType != NativeMethods.PERF_COUNTER_MULTI_TIMER &&
                oldCounterType != NativeMethods.PERF_COUNTER_MULTI_TIMER_INV) {

                eCount = 100.0f;
            }

            return eCount;
        } 

        /// <include file='doc\CounterSampleCalculator.uex' path='docs/doc[@for="CounterSampleCalculator.CounterRawFraction"]/*' />
        /// <devdoc>
        ///    Evaluate a raw fraction (no time, just two values: Numerator and
        ///        Denominator) and multiply by 100 (to make a percentage;
        /// </devdoc>
        /// <internalonly/>
        private static float CounterRawFraction(CounterSample newSample) {
            float eCount;
            float eNumerator;

            if (newSample.RawValue == 0 ||
                newSample.BaseValue == 0) {
                // invalid value
                return 0.0f;
            } 
            else {
                eNumerator = (float)newSample.UnsignedRawValue * 100;
                eCount = eNumerator /
                         (float) newSample.UnsignedBaseValue;
                return eCount;
            }
        } 

        /// <include file='doc\CounterSampleCalculator.uex' path='docs/doc[@for="CounterSampleCalculator.SampleCommon"]/*' />
        /// <devdoc>
        ///    Divites "Top" differenced by Base Difference
        /// </devdoc>
        /// <internalonly/>
        private static float SampleCommon(CounterSample oldSample, CounterSample newSample) {
            float eCount;
            float eDifference;
            float eBaseDifference;

            if (oldSample.UnsignedRawValue >= newSample.UnsignedRawValue)
                return 0.0f;
                
            eDifference = (float)(newSample.UnsignedRawValue - oldSample.UnsignedRawValue);

            if (oldSample.UnsignedBaseValue >= newSample.UnsignedBaseValue)
                return 0.0f;
                
            eBaseDifference = (float)(newSample.UnsignedBaseValue - oldSample.UnsignedBaseValue);

            eCount = eDifference / eBaseDifference;
            if (((int)oldSample.CounterType) == NativeMethods.PERF_SAMPLE_FRACTION) {
                eCount *= 100.0f ;
            }
            return eCount;        
        }        

        /// <include file='doc\CounterSampleCalculator.uex' path='docs/doc[@for="CounterSampleCalculator.GetElapsedTime"]/*' />
        /// <devdoc>
        ///    Converts 100NS elapsed time to fractional seconds
        /// </devdoc>
        /// <internalonly/>
        private static float GetElapsedTime(CounterSample oldSample, CounterSample newSample) {
            float eSeconds;
            float eDifference;

            if (newSample.RawValue == 0) {
                // no data [start time = 0] so return 0
                return 0.0f;
            } 
            else {
                float eFreq;
                eFreq = (float)(ulong)oldSample.CounterFrequency;

                if (oldSample.UnsignedRawValue >= (ulong)newSample.CounterTimeStamp || eFreq <= 0.0f)
                    return 0.0f;
                    
                // otherwise compute difference between current time and start time
                eDifference = (float)((ulong)newSample.CounterTimeStamp - oldSample.UnsignedRawValue);
            
                // convert to fractional seconds using object counter
                eSeconds = eDifference / eFreq;

                return eSeconds;
            }           
        }

        /// <include file='doc\CounterSampleCalculator.uex' path='docs/doc[@for="CounterSampleCalculator.ComputeCounterValue"]/*' />
        /// <devdoc>
        ///    Computes the calculated value given a raw counter sample.
        /// </devdoc>
        public static float ComputeCounterValue(CounterSample newSample) {
            return ComputeCounterValue(CounterSample.Empty, newSample);
        }

        /// <include file='doc\CounterSampleCalculator.uex' path='docs/doc[@for="CounterSampleCalculator.ComputeCounterValue1"]/*' />
        /// <devdoc>
        ///    Computes the calculated value given a raw counter sample.
        /// </devdoc>
        public static float ComputeCounterValue(CounterSample oldSample, CounterSample newSample) {
            int newCounterType = (int) newSample.CounterType;
        
            if (oldSample.SystemFrequency == 0) {
                if ((newCounterType != NativeMethods.PERF_RAW_FRACTION) &&
                    (newCounterType != NativeMethods.PERF_COUNTER_RAWCOUNT) &&
                    (newCounterType != NativeMethods.PERF_COUNTER_RAWCOUNT_HEX) &&
                    (newCounterType != NativeMethods.PERF_COUNTER_LARGE_RAWCOUNT) &&
                    (newCounterType != NativeMethods.PERF_COUNTER_LARGE_RAWCOUNT_HEX) &&
                    (newCounterType != NativeMethods.PERF_COUNTER_MULTI_BASE)) {

                    // Since oldSample has a system frequency of 0, this means the newSample is the first sample
                    // on a two sample calculation.  Since we can't do anything with it, return 0.
                    return 0.0f;
                }
            }
            else if (oldSample.CounterType != newSample.CounterType) {
                throw new InvalidOperationException(SR.GetString(SR.MismatchedCounterTypes));
            }
                

            switch (newCounterType) {

                case NativeMethods.PERF_COUNTER_COUNTER:
                case NativeMethods.PERF_COUNTER_BULK_COUNT:
                case NativeMethods.PERF_SAMPLE_COUNTER:
                    return CounterCounterCommon(oldSample, newSample);

                case NativeMethods.PERF_AVERAGE_TIMER:
                    return CounterAverageTimer(oldSample, newSample);

                case NativeMethods.PERF_COUNTER_QUEUELEN_TYPE:
                case NativeMethods.PERF_COUNTER_LARGE_QUEUELEN_TYPE:
                case NativeMethods.PERF_AVERAGE_BULK:
                    return CounterAverageBulk(oldSample, newSample);                                
                
                case NativeMethods.PERF_COUNTER_TIMER:
                case NativeMethods.PERF_COUNTER_TIMER_INV:
                case NativeMethods.PERF_100NSEC_TIMER:
                case NativeMethods.PERF_100NSEC_TIMER_INV:
                case NativeMethods.PERF_COUNTER_MULTI_TIMER:
                case NativeMethods.PERF_COUNTER_MULTI_TIMER_INV:
                case NativeMethods.PERF_100NSEC_MULTI_TIMER:
                case NativeMethods.PERF_100NSEC_MULTI_TIMER_INV:
                    return CounterTimerCommon(oldSample, newSample);

                case NativeMethods.PERF_RAW_FRACTION:
                    return CounterRawFraction(newSample);

                case NativeMethods.PERF_SAMPLE_FRACTION:
                    return SampleCommon(oldSample, newSample);

                case NativeMethods.PERF_COUNTER_RAWCOUNT:
                case NativeMethods.PERF_COUNTER_RAWCOUNT_HEX:
                    return (float)newSample.RawValue;

                case NativeMethods.PERF_COUNTER_LARGE_RAWCOUNT:
                case NativeMethods.PERF_COUNTER_LARGE_RAWCOUNT_HEX:
                    return (float)newSample.RawValue;

                case NativeMethods.PERF_COUNTER_MULTI_BASE:
                    return 0.0f;

                case NativeMethods.PERF_ELAPSED_TIME:
                    return (float)GetElapsedTime(oldSample, newSample);
                    
                case NativeMethods.PERF_COUNTER_DELTA:
                case NativeMethods.PERF_COUNTER_LARGE_DELTA:
                    if (oldSample.UnsignedRawValue >= newSample.UnsignedRawValue)
                        return -(float)(oldSample.UnsignedRawValue - newSample.UnsignedRawValue);
                    else                        
                        return (float)(newSample.UnsignedRawValue - oldSample.UnsignedRawValue);

                default:
                    return 0.0f;

            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\services\monitoring\system\diagnosticts\countersample.cs ===
//------------------------------------------------------------------------------
// <copyright file="CounterSample.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Diagnostics {

    using System.Diagnostics;

    using System;

    /// <include file='doc\CounterSample.uex' path='docs/doc[@for="CounterSample"]/*' />
    /// <devdoc>
    ///     A struct holding the raw data for a performance counter.
    /// </devdoc>    
    public struct CounterSample {
        private long rawValue;
        private long baseValue;
        private long timeStamp;
        private long counterFrequency;
        private PerformanceCounterType counterType;
        private long timeStamp100nSec;
        private long systemFrequency;
        private long counterTimeStamp;
    
        // Dummy holder for an empty sample
        /// <include file='doc\CounterSample.uex' path='docs/doc[@for="CounterSample.Empty"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public static CounterSample Empty = new CounterSample(0, 0, 0, 0, 0, 0, PerformanceCounterType.NumberOfItems32);

        /// <include file='doc\CounterSample.uex' path='docs/doc[@for="CounterSample.CounterSample"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public CounterSample(long rawValue, long baseValue, long counterFrequency, long systemFrequency, long timeStamp, long timeStamp100nSec, PerformanceCounterType counterType) {
            this.rawValue = rawValue;
            this.baseValue = baseValue;
            this.timeStamp = timeStamp;
            this.counterFrequency = counterFrequency;
            this.counterType = counterType;
            this.timeStamp100nSec = timeStamp100nSec;
            this.systemFrequency = systemFrequency;
            this.counterTimeStamp = 0;
        }

        /// <include file='doc\CounterSample.uex' path='docs/doc[@for="CounterSample.CounterSample1"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public CounterSample(long rawValue, long baseValue, long counterFrequency, long systemFrequency, long timeStamp, long timeStamp100nSec, PerformanceCounterType counterType, long counterTimeStamp) {
            this.rawValue = rawValue;
            this.baseValue = baseValue;
            this.timeStamp = timeStamp;
            this.counterFrequency = counterFrequency;
            this.counterType = counterType;
            this.timeStamp100nSec = timeStamp100nSec;
            this.systemFrequency = systemFrequency;
            this.counterTimeStamp = counterTimeStamp;
        }         
         
        /// <include file='doc\CounterSample.uex' path='docs/doc[@for="CounterSample.RawValue"]/*' />
        /// <devdoc>
        ///      Raw value of the counter.
        /// </devdoc>
        public long RawValue {
            get {
                return this.rawValue;
            }
        }

        internal ulong UnsignedRawValue {
             get {
                return (ulong)this.rawValue;
            }
        }
        
        /// <include file='doc\CounterSample.uex' path='docs/doc[@for="CounterSample.BaseValue"]/*' />
        /// <devdoc>
        ///      Optional base raw value for the counter (only used if multiple counter based).
        /// </devdoc>
        public long BaseValue {
            get {
                return this.baseValue;
            }
        }
        
        internal ulong UnsignedBaseValue {
            get {
                return (ulong)this.baseValue;
            }
        }

        /// <include file='doc\CounterSample.uex' path='docs/doc[@for="CounterSample.SystemFrequency"]/*' />
        /// <devdoc>
        ///      Raw system frequency
        /// </devdoc>
        public long SystemFrequency {
            get {
               return this.systemFrequency;
            }
        }

        /// <include file='doc\CounterSample.uex' path='docs/doc[@for="CounterSample.CounterFrequency"]/*' />
        /// <devdoc>
        ///      Raw counter frequency
        /// </devdoc>
        public long CounterFrequency {
            get {
                return this.counterFrequency;
            }
        }

        /// <include file='doc\CounterSample.uex' path='docs/doc[@for="CounterSample.CounterTimeStamp"]/*' />
        /// <devdoc>
        ///      Raw counter frequency
        /// </devdoc>
        public long CounterTimeStamp {
            get {
                return this.counterTimeStamp;
            }
        }
        
        /// <include file='doc\CounterSample.uex' path='docs/doc[@for="CounterSample.TimeStamp"]/*' />
        /// <devdoc>
        ///      Raw timestamp
        /// </devdoc>
        public long TimeStamp {
            get {
                return this.timeStamp;
            }
        }

        /// <include file='doc\CounterSample.uex' path='docs/doc[@for="CounterSample.TimeStamp100nSec"]/*' />
        /// <devdoc>
        ///      Raw high fidelity timestamp
        /// </devdoc>
        public long TimeStamp100nSec {
            get {
                return this.timeStamp100nSec;
            }
        }
        
        /// <include file='doc\CounterSample.uex' path='docs/doc[@for="CounterSample.CounterType"]/*' />
        /// <devdoc>
        ///      Counter type
        /// </devdoc>
        public PerformanceCounterType CounterType {
            get {
                return this.counterType;
            }
        }

        /// <include file='doc\CounterSample.uex' path='docs/doc[@for="CounterSample.Calculate"]/*' />
        /// <devdoc>
        ///    Static functions to calculate the performance value off the sample
        /// </devdoc>
        public static float Calculate(CounterSample counterSample) {
            return CounterSampleCalculator.ComputeCounterValue(counterSample);
        }

        /// <include file='doc\CounterSample.uex' path='docs/doc[@for="CounterSample.Calculate1"]/*' />
        /// <devdoc>
        ///    Static functions to calculate the performance value off the samples
        /// </devdoc>
        public static float Calculate(CounterSample counterSample, CounterSample nextCounterSample) { 
            return CounterSampleCalculator.ComputeCounterValue(counterSample, nextCounterSample);
        }

    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\services\monitoring\system\diagnosticts\countercreationdata.cs ===
//------------------------------------------------------------------------------
// <copyright file="CounterCreationData.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Diagnostics {

    using System.Diagnostics;

    using System;
    using System.ComponentModel;
    
    /// <include file='doc\CounterCreationData.uex' path='docs/doc[@for="CounterCreationData"]/*' />
    /// <devdoc>
    ///     A struct defining the counter type, name and help string for a custom counter.
    /// </devdoc>
    [
    TypeConverter("System.Diagnostics.Design.CounterCreationDataConverter, " + AssemblyRef.SystemDesign), 
    Serializable
    ]
    public class CounterCreationData {
        private PerformanceCounterType counterType = PerformanceCounterType.NumberOfItems32;
        private string counterName = String.Empty;
        private string counterHelp = String.Empty;

        /// <include file='doc\CounterCreationData.uex' path='docs/doc[@for="CounterCreationData.CounterCreationData"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public CounterCreationData() {            
        }
    
        /// <include file='doc\CounterCreationData.uex' path='docs/doc[@for="CounterCreationData.CounterCreationData1"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public CounterCreationData(string counterName, string counterHelp, PerformanceCounterType counterType) {
            CounterType = counterType;
            CounterName = counterName;
            CounterHelp = counterHelp;
        }

        /// <include file='doc\CounterCreationData.uex' path='docs/doc[@for="CounterCreationData.CounterType"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        [
        DefaultValue(PerformanceCounterType.NumberOfItems32),
        MonitoringDescription(SR.CounterType)
        ]
        public PerformanceCounterType CounterType {
            get {
                return counterType;
            }
            set {
                if (!Enum.IsDefined(typeof(PerformanceCounterType), value)) 
                    throw new InvalidEnumArgumentException("value", (int)value, typeof(PerformanceCounterType));
            
                counterType = value;
            }
        }

        /// <include file='doc\CounterCreationData.uex' path='docs/doc[@for="CounterCreationData.CounterName"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        [
        DefaultValue(""),
        MonitoringDescription(SR.CounterName),        
        TypeConverter("System.Diagnostics.Design.StringValueConverter, " + AssemblyRef.SystemDesign)        
        ]
        public string CounterName {
            get {
                return counterName;
            }
            set {
                PerformanceCounterCategory.CheckValidCounter(value);
                counterName = value;
            }
        }

        /// <include file='doc\CounterCreationData.uex' path='docs/doc[@for="CounterCreationData.CounterHelp"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        [
        DefaultValue(""),
        MonitoringDescription(SR.CounterHelp)
        ]
        public string CounterHelp {
            get {
                return counterHelp;
            }
            set {
                PerformanceCounterCategory.CheckValidHelp(value);
                counterHelp = value;
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\services\monitoring\system\diagnosticts\entrywritteneventargs.cs ===
//------------------------------------------------------------------------------
// <copyright file="EntryWrittenEventArgs.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Diagnostics {

    using System.Diagnostics;

    using System;
    using System.ComponentModel;

    /// <include file='doc\EntryWrittenEventArgs.uex' path='docs/doc[@for="EntryWrittenEventArgs"]/*' />
    /// <devdoc>
    ///    <para>
    ///       Provides data for the <see cref='System.Diagnostics.EventLog.EntryWritten'/> event.
    ///    </para>
    /// </devdoc>
    public class EntryWrittenEventArgs : EventArgs {
        private EventLogEntry entry;

        /// <include file='doc\EntryWrittenEventArgs.uex' path='docs/doc[@for="EntryWrittenEventArgs.EntryWrittenEventArgs"]/*' />
        /// <devdoc>
        ///    <para>
        ///       The default constructor, which
        ///       initializes a new instance of the <see cref='System.Diagnostics.EntryWrittenEventArgs'/> class without
        ///       specifying a value for <see cref='System.Diagnostics.EntryWrittenEventArgs.Entry'/>.
        ///       
        ///    </para>
        /// </devdoc>
        public EntryWrittenEventArgs() {
        }

        /// <include file='doc\EntryWrittenEventArgs.uex' path='docs/doc[@for="EntryWrittenEventArgs.EntryWrittenEventArgs1"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Initializes a new instance of the <see cref='System.Diagnostics.EntryWrittenEventArgs'/> class with the
        ///       specified event log entry.
        ///    </para>
        /// </devdoc>
        public EntryWrittenEventArgs(EventLogEntry entry) {
            this.entry = entry;
        }
        
        /// <include file='doc\EntryWrittenEventArgs.uex' path='docs/doc[@for="EntryWrittenEventArgs.Entry"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Represents
        ///       an event log entry.
        ///       
        ///    </para>
        /// </devdoc>
        public EventLogEntry Entry {
            get {
                return this.entry;
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\services\monitoring\system\diagnosticts\diagnosticsconfigurationhandler.cs ===
//------------------------------------------------------------------------------
// <copyright file="DiagnosticsConfigurationHandler.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

#if !LIB
#define TRACE
#define DEBUG
namespace System.Diagnostics {

    using System;
    using System.Collections;
    using System.Diagnostics;    
    using System.Xml;
    using System.Configuration;
    using System.Reflection;

    /// <include file='doc\DiagnosticsConfigurationHandler.uex' path='docs/doc[@for="DiagnosticsConfigurationHandler"]/*' />
    /// <devdoc>
    ///    The configuration section handler for the diagnostics section of the configuration
    ///    file. The section handler participates in the resolution of configuration settings 
    ///    between the &lt;diagnostics&gt; and &lt;/diagnostics&gt;portion of the .config file.
    /// </devdoc>
    /// <internalonly/>
    public class DiagnosticsConfigurationHandler : IConfigurationSectionHandler {

        /// <include file='doc\DiagnosticsConfigurationHandler.uex' path='docs/doc[@for="DiagnosticsConfigurationHandler.Create"]/*' />
        /// <devdoc>
        ///    <para>Parses the configuration settings between the 
        ///       &lt;diagnostics&gt; and &lt;/diagnostics&gt; portion of the .config file to populate
        ///       the values of 'WebServicesConfiguration' object and returning it.
        ///    </para>
        /// </devdoc>
        /// <internalonly/>
        public virtual object Create(object parent, object configContext, XmlNode section) {
            bool foundSwitches = false;
            bool foundAssert = false;
            bool foundTrace = false;
            bool foundCounters = false;

            HandlerBase.CheckForUnrecognizedAttributes(section);

            // Since the tracing and switch code lives in System.Dll and config is in System.Configuration.dll
            // the settings just go into a hashtable to communicate to the values to the diagnostics code in System.dll
            Hashtable parentConfig = (Hashtable)parent;
            Hashtable config;
            if (parentConfig == null)
                config = new Hashtable();
            else
                config = (Hashtable)parentConfig.Clone();

            foreach (XmlNode child in section.ChildNodes) {
                if (HandlerBase.IsIgnorableAlsoCheckForNonElement(child))
                    continue;

                switch (child.Name) {
                    case "switches":                        
                        if (foundSwitches)
                            throw new ConfigurationException(SR.GetString(SR.ConfigSectionsUnique, "switches"));
                        foundSwitches = true;
            
                        HandleSwitches(config, child, configContext);
                        break;
                    case "assert":
                        if (foundAssert)
                            throw new ConfigurationException(SR.GetString(SR.ConfigSectionsUnique, "assert"));
                        foundAssert = true;

                        HandleAssert(config, child, configContext);
                        break;
                    case "trace":
                        if (foundTrace)
                            throw new ConfigurationException(SR.GetString(SR.ConfigSectionsUnique, "trace"));
                        foundTrace = true;

                        HandleTrace(config, child, configContext);
                        break;
                    case "performanceCounters":                      
                        if (foundCounters)
                            throw new ConfigurationException(SR.GetString(SR.ConfigSectionsUnique, "performanceCounters"));
                        foundCounters = true;

                        HandleCounters((Hashtable)parent, config, child, configContext);                                                    
                        break;
                    default:
                        HandlerBase.ThrowUnrecognizedElement(child);
                        break;
                } // switch(child.Name)
                
                HandlerBase.CheckForUnrecognizedAttributes(child);
            }
            return config;
        }

        private static void HandleSwitches(Hashtable config, XmlNode switchesNode, object context) {
            Hashtable switches = (Hashtable) new SwitchesDictionarySectionHandler().Create(config["switches"], context, switchesNode);
            IDictionaryEnumerator en = switches.GetEnumerator();
            while (en.MoveNext()) {
                try {
                    Int32.Parse((string) en.Value);
                }
                catch (Exception) {
                    throw new ConfigurationException(SR.GetString(SR.Value_must_be_numeric, en.Key));
                }
            }

            config["switches"] = switches;
        }

        private static void HandleAssert(Hashtable config, XmlNode assertNode, object context) {
            bool assertuienabled = false;
            if (HandlerBase.GetAndRemoveBooleanAttribute(assertNode, "assertuienabled", ref assertuienabled) != null)
                config["assertuienabled"] = assertuienabled;

            string logfilename = null;
            if (HandlerBase.GetAndRemoveStringAttribute(assertNode, "logfilename", ref logfilename) != null)
                config["logfilename"] = logfilename;

            HandlerBase.CheckForChildNodes(assertNode);
        }

        private static void HandleCounters(Hashtable parent, Hashtable config, XmlNode countersNode, object context) {            
            int filemappingsize = 0;
            if (HandlerBase.GetAndRemoveIntegerAttribute(countersNode, "filemappingsize", ref filemappingsize) != null) {
                //Should only be handled at machine config level
                if (parent == null)
                    config["filemappingsize"] = filemappingsize;
            }                

            HandlerBase.CheckForChildNodes(countersNode);
        }
        
        private static void HandleTrace(Hashtable config, XmlNode traceNode, object context) {
            bool foundListeners = false;
            bool autoflush = false;
            if (HandlerBase.GetAndRemoveBooleanAttribute(traceNode, "autoflush", ref autoflush) != null)
                config["autoflush"] = autoflush;
                                       
            int indentsize = 0;
            if (HandlerBase.GetAndRemoveIntegerAttribute(traceNode, "indentsize", ref indentsize) != null)
                config["indentsize"] = indentsize;

            foreach (XmlNode traceChild in traceNode.ChildNodes) {
                if (HandlerBase.IsIgnorableAlsoCheckForNonElement(traceChild))
                    continue;
                
                if (traceChild.Name == "listeners") {
                    if (foundListeners) 
                        throw new ConfigurationException(SR.GetString(SR.ConfigSectionsUnique, "listeners"));
                    foundListeners = true;

                    HandleListeners(config, traceChild, context);
                }
                else {
                    HandlerBase.ThrowUnrecognizedElement(traceChild);
                }
            }
        }

        private static void HandleListeners(Hashtable config, XmlNode listenersNode, object context) {
            HandlerBase.CheckForUnrecognizedAttributes(listenersNode);
            foreach (XmlNode listenersChild in listenersNode.ChildNodes) {
                if (HandlerBase.IsIgnorableAlsoCheckForNonElement(listenersChild))
                    continue;
                
                string name = null, className = null, initializeData = null;
                string op = listenersChild.Name;

                switch (op) {
                    case "add":
                    case "remove":
                    case "clear":
                        break;
                    default:
                        HandlerBase.ThrowUnrecognizedElement(listenersChild);
                        break;
                }

                HandlerBase.GetAndRemoveStringAttribute(listenersChild, "name", ref name);
                HandlerBase.GetAndRemoveStringAttribute(listenersChild, "type", ref className);
                HandlerBase.GetAndRemoveStringAttribute(listenersChild, "initializeData", ref initializeData);
                HandlerBase.CheckForUnrecognizedAttributes(listenersChild);
                HandlerBase.CheckForChildNodes(listenersChild);

                TraceListener newListener = null;
                if (className != null) {  
                    Type t = Type.GetType(className);

                    if (t == null)
                        throw new ConfigurationException(SR.GetString(SR.Could_not_find_type, className));

                    if (!typeof(TraceListener).IsAssignableFrom(t))
                        throw new ConfigurationException(SR.GetString(SR.Type_isnt_tracelistener, className));

                    // create a listener with parameterless constructor 
                    if (initializeData == null) {
                        ConstructorInfo ctorInfo = t.GetConstructor(new Type[] {});
                        if (ctorInfo == null)
                            throw new ConfigurationException(SR.GetString(SR.Could_not_get_constructor, className));
                        newListener = (TraceListener)(ctorInfo.Invoke(new object[] {}));
                    }
                    // create a listener with a one-string constructor
                    else {
                        ConstructorInfo ctorInfo = t.GetConstructor(new Type[] { typeof(string) });
                        if (ctorInfo == null)
                            throw new ConfigurationException(SR.GetString(SR.Could_not_get_constructor, className));
                        newListener = (TraceListener)(ctorInfo.Invoke(new object[] { initializeData }));
                    }
                    if (name != null) {
                        newListener.Name = name;
                    }
                }

                // we already verified above that we only have "add", "remove", or "clear", so we can 
                // switch on the first char here for perf. 
                switch (op[0]) {
                    case 'a':
                        if (newListener == null)
                            throw new ConfigurationException(SR.GetString(SR.Could_not_create_listener, name));  
    
                        Trace.Listeners.Add(newListener);
    
                        break;
                    case 'r':
                        if (newListener == null) {
                            // no type specified, we'll have to delete by name
    
                            // if no name is specified we can't do anything
                            if (name == null)
                                throw new ConfigurationException(SR.GetString(SR.Cannot_remove_with_null));
    
                            Trace.Listeners.Remove(name);
                        }
                        else {
                            // remove by listener
                            Trace.Listeners.Remove(newListener);
                        }
                        break;
                    case 'c':
                        Trace.Listeners.Clear();
                        break;
                    default:
                        HandlerBase.ThrowUnrecognizedElement(listenersChild);
                        break;
                }
            }
        }
    }

    /// <include file='doc\DiagnosticsConfigurationHandler.uex' path='docs/doc[@for="SwitchesDictionarySectionHandler"]/*' />
    internal class SwitchesDictionarySectionHandler : DictionarySectionHandler {
        protected override string KeyAttributeName {
            get { return "name";}
        }

        internal override bool ValueRequired {
            get { return true; }
        }
        
    }
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\services\monitoring\system\diagnosticts\eventlogentrycollection.cs ===
//------------------------------------------------------------------------------
// <copyright file="EventLogEntryCollection.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Diagnostics {
    using System.Text;
    using System;
    using System.Collections;
   
    //Consider, V2, jruiz: Is there a way to implement Contains
    //and IndexOf, can we live withouth this part of the ReadOnly
    //collection pattern?
    /// <include file='doc\EventLogEntryCollection.uex' path='docs/doc[@for="EventLogEntryCollection"]/*' />
    /// <devdoc>
    ///    <para>[To be supplied.]</para>
    /// </devdoc>
    public class EventLogEntryCollection : ICollection {
        private EventLog log;

        internal EventLogEntryCollection(EventLog log) {
            this.log = log;
        }
        
        /// <include file='doc\EventLogEntryCollection.uex' path='docs/doc[@for="EventLogEntryCollection.Count"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets the number of entries in the event log
        ///    </para>
        /// </devdoc>
        public int Count {
            get {
                return log.EntryCount;
            }
        }

        /// <include file='doc\EventLogEntryCollection.uex' path='docs/doc[@for="EventLogEntryCollection.this"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets an entry in
        ///       the event log, based on an index starting at 0.
        ///    </para>
        /// </devdoc>
        public virtual EventLogEntry this[int index] {
            get {
                return log.GetEntryAt(index);
            }
        }
        
        /// <include file='doc\EventLogEntryCollection.uex' path='docs/doc[@for="EventLogEntryCollection.CopyTo"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public void CopyTo(EventLogEntry[] entries, int index) {
            ((ICollection)this).CopyTo((Array)entries, index);
        }       
                       
        /// <include file='doc\EventLogEntryCollection.uex' path='docs/doc[@for="EventLogEntryCollection.GetEnumerator"]/*' />
        /// <internalonly/>
        /// <devdoc>
        /// </devdoc>
        public IEnumerator GetEnumerator() {                
            return new EntriesEnumerator(this);
        } 
       
        /// <include file='doc\EventLogEntryCollection.uex' path='docs/doc[@for="EventLogEntryCollection.ICollection.IsSynchronized"]/*' />
        /// <internalonly/>
        bool ICollection.IsSynchronized {
            get {
                return false;
            }
        }

        /// <include file='doc\EventLogEntryCollection.uex' path='docs/doc[@for="EventLogEntryCollection.ICollection.SyncRoot"]/*' />
        /// <devdoc>        
        ///    ICollection private interface implementation.        
        /// </devdoc>
        /// <internalonly/>
        object ICollection.SyncRoot {
            get {
                return this;
            }
        }
    
        /// <include file='doc\EventLogEntryCollection.uex' path='docs/doc[@for="EventLogEntryCollection.ICollection.CopyTo"]/*' />
        /// <devdoc>        
        ///    ICollection private interface implementation.        
        /// </devdoc>
        /// <internalonly/>
        void ICollection.CopyTo(Array array, int index) {
            EventLogEntry[] entries = log.GetAllEntries();
            Array.Copy(entries, 0, array, index, entries.Length);			       				
        }                     
    
        /// <include file='doc\EventLogEntryCollection.uex' path='docs/doc[@for="EventLogEntryCollection.EntriesEnumerator"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Holds an System.Diagnostics.EventLog.EventLogEntryCollection that
        ///       consists of the entries in an event
        ///       log.
        ///    </para>
        /// </devdoc>
        private class EntriesEnumerator : IEnumerator {
            private EventLogEntryCollection entries;
            private int num = -1;

            internal EntriesEnumerator(EventLogEntryCollection entries) {
                this.entries = entries;
            }

            /// <include file='doc\EventLogEntryCollection.uex' path='docs/doc[@for="EventLogEntryCollection.EntriesEnumerator.Current"]/*' />
            /// <devdoc>
            ///    <para>
            ///       Gets the entry at the current position.
            ///    </para>
            /// </devdoc>
            public object Current {
                get {
                    if (num == -1 || num >= entries.Count)
                        throw new InvalidOperationException(SR.GetString(SR.NoCurrentEntry));
                        
                    return entries[num];
                }
            }

            /// <include file='doc\EventLogEntryCollection.uex' path='docs/doc[@for="EventLogEntryCollection.EntriesEnumerator.MoveNext"]/*' />
            /// <devdoc>
            ///    <para>
            ///       Advances the enumerator to the next entry in the event log.
            ///    </para>
            /// </devdoc>
            public bool MoveNext() {
                num++;                
                return num < entries.Count;
            }            
            
            /// <include file='doc\EventLogEntryCollection.uex' path='docs/doc[@for="EventLogEntryCollection.EntriesEnumerator.Reset"]/*' />
            /// <devdoc>
            ///    <para>
            ///       Resets the state of the enumeration.
            ///    </para>
            /// </devdoc>
            public void Reset() {
                num = -1;
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\services\monitoring\system\diagnosticts\entrywritteneventhandler.cs ===
//------------------------------------------------------------------------------
// <copyright file="EntryWrittenEventHandler.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Diagnostics {

    using System.Diagnostics;

    using System;

    /// <include file='doc\EntryWrittenEventHandler.uex' path='docs/doc[@for="EntryWrittenEventHandler"]/*' />
    /// <devdoc>
    ///    <para>[To be supplied.]</para>
    /// </devdoc>
    public delegate void EntryWrittenEventHandler(object sender, EntryWrittenEventArgs e);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\services\monitoring\system\diagnosticts\eventlogentrytype.cs ===
//------------------------------------------------------------------------------
// <copyright file="EventLogEntryType.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Diagnostics {

    using System.Diagnostics;
    
    // cpr: make this class an enum
    using System;

    /// <include file='doc\EventLogEntryType.uex' path='docs/doc[@for="EventLogEntryType"]/*' />
    /// <devdoc>
    ///    <para>
    ///       Specifies the event type of the event log entry.
    ///       
    ///    </para>
    /// </devdoc>
    public enum EventLogEntryType {
        /// <include file='doc\EventLogEntryType.uex' path='docs/doc[@for="EventLogEntryType.Error"]/*' />
        /// <devdoc>
        ///    <para>
        ///       An
        ///       error event. This indicates a significant problem the
        ///       user should know about; usually a loss of
        ///       functionality or data.
        ///       
        ///    </para>
        /// </devdoc>
        Error = 1,
        /// <include file='doc\EventLogEntryType.uex' path='docs/doc[@for="EventLogEntryType.Warning"]/*' />
        /// <devdoc>
        ///    <para>
        ///       A warning event. This indicates a problem that is not
        ///       immediately significant, but that may signify conditions that could
        ///       cause future problems.
        ///       
        ///    </para>
        /// </devdoc>
        Warning = 2,
        /// <include file='doc\EventLogEntryType.uex' path='docs/doc[@for="EventLogEntryType.Information"]/*' />
        /// <devdoc>
        ///    <para>
        ///       An information event. This indicates a significant successful
        ///       operation.
        ///    </para>
        /// </devdoc>
        Information = 4,
        /// <include file='doc\EventLogEntryType.uex' path='docs/doc[@for="EventLogEntryType.SuccessAudit"]/*' />
        /// <devdoc>
        ///    <para>
        ///       A success audit event. This indicates a security event
        ///       that occurs when an audited access attempt is successful; for
        ///       example, a successful logon.
        ///       
        ///    </para>
        /// </devdoc>
        SuccessAudit = 8,
        /// <include file='doc\EventLogEntryType.uex' path='docs/doc[@for="EventLogEntryType.FailureAudit"]/*' />
        /// <devdoc>
        ///    <para>
        ///       A failure audit event. This indicates a security event
        ///       that occurs when an audited access attempt fails; for example, a failed attempt
        ///       to open a file.
        ///       
        ///    </para>
        /// </devdoc>
        FailureAudit = 16,
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\services\monitoring\system\diagnosticts\eventlogpermission.cs ===
//------------------------------------------------------------------------------
// <copyright file="EventLogPermission.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Diagnostics {
    using System;        
    using System.Security.Permissions;    
                                                                        
    /// <include file='doc\EventLogPermission.uex' path='docs/doc[@for="EventLogPermission"]/*' />
    /// <devdoc>
    ///    <para>[To be supplied.]</para>
    /// </devdoc>
    [
    Serializable()
    ]
    public sealed class EventLogPermission : ResourcePermissionBase {    
        private EventLogPermissionEntryCollection innerCollection;
        
        /// <include file='doc\EventLogPermission.uex' path='docs/doc[@for="EventLogPermission.EventLogPermission"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public EventLogPermission() {
            SetNames();
        }                                                                
        
        /// <include file='doc\EventLogPermission.uex' path='docs/doc[@for="EventLogPermission.EventLogPermission1"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public EventLogPermission(PermissionState state) 
        : base(state) {
            SetNames();
        }
        
        /// <include file='doc\EventLogPermission.uex' path='docs/doc[@for="EventLogPermission.EventLogPermission2"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public EventLogPermission(EventLogPermissionAccess permissionAccess, string machineName) {            
            SetNames();
            this.AddPermissionAccess(new EventLogPermissionEntry(permissionAccess, machineName));              
        }         
         
        /// <include file='doc\EventLogPermission.uex' path='docs/doc[@for="EventLogPermission.EventLogPermission3"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public EventLogPermission(EventLogPermissionEntry[] permissionAccessEntries) {            
            if (permissionAccessEntries == null)
                throw new ArgumentNullException("permissionAccessEntries");
                
            SetNames();            
            for (int index = 0; index < permissionAccessEntries.Length; ++index)
                this.AddPermissionAccess(permissionAccessEntries[index]);                          
        }

        /// <include file='doc\EventLogPermission.uex' path='docs/doc[@for="EventLogPermission.PermissionEntries"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>                
        public EventLogPermissionEntryCollection PermissionEntries {
            get {
                if (this.innerCollection == null)                     
                    this.innerCollection = new EventLogPermissionEntryCollection(this, base.GetPermissionEntries()); 
                                                                           
                return this.innerCollection;                                                               
            }
        }

        /// <include file='doc\EventLogPermission.uex' path='docs/doc[@for="EventLogPermission.AddPermissionAccess"]/*' />                
        ///<internalonly/> 
        internal void AddPermissionAccess(EventLogPermissionEntry entry) {
            base.AddPermissionAccess(entry.GetBaseEntry());
        }
        
        /// <include file='doc\EventLogPermission.uex' path='docs/doc[@for="EventLogPermission.Clear"]/*' />                        
        ///<internalonly/> 
        internal new void Clear() {
            base.Clear();
        }

        /// <include file='doc\EventLogPermission.uex' path='docs/doc[@for="EventLogPermission.RemovePermissionAccess"]/*' />                                                  
        ///<internalonly/> 
        internal void RemovePermissionAccess(EventLogPermissionEntry entry) {
            base.RemovePermissionAccess(entry.GetBaseEntry());
        }
                        
        private void SetNames() {
            this.PermissionAccessType = typeof(EventLogPermissionAccess);
            this.TagNames = new string[]{"Machine"};
        }                                
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\services\monitoring\system\diagnosticts\eventlogentry.cs ===
//------------------------------------------------------------------------------
// <copyright file="EventLogEntry.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Diagnostics {
    using System.Text;    
    using System.Runtime.InteropServices;
    using System.Runtime.Serialization;
    using System.ComponentModel;
    using System.Diagnostics;
    using Microsoft.Win32;
    using System;    
    using System.Security;
    using System.Security.Permissions;
    using System.IO;
//    using System.Windows.Forms;    

    /// <include file='doc\EventLogEntry.uex' path='docs/doc[@for="EventLogEntry"]/*' />
    /// <devdoc>
    ///    <para>
    ///    <see cref='System.Diagnostics.EventLogEntry'/> 
    ///    encapsulates a single record in the NT event log.
    /// </para>
    /// </devdoc>
    [
    ToolboxItem(false),
    DesignTimeVisible(false),
    Serializable,    
    PermissionSet(SecurityAction.LinkDemand, Name="FullTrust")
    ]
    public sealed class EventLogEntry : Component, ISerializable {
        internal byte[] dataBuf;
        internal int bufOffset;
        internal string logName;
        internal string ownerMachineName;

        // make sure only others in this package can create us
        internal EventLogEntry(byte[] buf, int offset, string logName, string ownerMachineName) {
            this.dataBuf = buf;
            this.bufOffset = offset;
            this.logName = logName;
            this.ownerMachineName = ownerMachineName;
        }

        /// <include file='doc\EventLogEntry.uex' path='docs/doc[@for="EventLogEntry.EventLogEntry"]/*' />
        /// <devdoc>
        /// </devdoc>
        /// <internalonly/>
        private EventLogEntry(SerializationInfo info, StreamingContext context) {
            dataBuf = (byte[])info.GetValue("DataBuffer", typeof(byte[]));
            logName = info.GetString("LogName");
        }

        /// <include file='doc\EventLogEntry.uex' path='docs/doc[@for="EventLogEntry.MachineName"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets the name of the computer on which this entry was generated.
        ///       
        ///    </para>
        /// </devdoc>
        [MonitoringDescription(SR.LogEntryMachineName)]
        public string MachineName {
            get {
                // first skip over the source name
                int pos = bufOffset + FieldOffsets.RAWDATA;
                while (CharFrom(dataBuf, pos) != '\0')
                    pos += 2;
                pos += 2;
                char ch = CharFrom(dataBuf, pos);
                StringBuilder buf = new StringBuilder();
                while (ch != '\0') {
                    buf.Append(ch);
                    pos += 2;
                    ch = CharFrom(dataBuf, pos);
                }
                return buf.ToString();
            }
        }

        /// <include file='doc\EventLogEntry.uex' path='docs/doc[@for="EventLogEntry.Data"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets the binary data associated with the entry.
        ///       
        ///    </para>
        /// </devdoc>
        [
        MonitoringDescription(SR.LogEntryData)
        ]
        public byte[] Data {
            get {
                int dataLen = IntFrom(dataBuf, bufOffset + FieldOffsets.DATALENGTH);
                byte[] data = new byte[dataLen];
                Array.Copy(dataBuf, bufOffset + IntFrom(dataBuf, bufOffset + FieldOffsets.DATAOFFSET),
                           data, 0, dataLen);
                return data;
            }
        }

        /*
        /// <summary>
        ///    <para>
        ///       Copies the binary data in the <see cref='System.Diagnostics.EventLogEntry.Data'/> member into an
        ///       array.
        ///    </para>
        /// </summary>
        /// <returns>
        ///    <para>
        ///       An array of type <see cref='System.Byte'/>.
        ///    </para>
        /// </returns>
        /// <keyword term=''/>
        public Byte[] getDataBytes() {
            Byte[] data = new Byte[rec.dataLength];
            for (int i = 0; i < data.Length; i++)
                data[i] = new Byte(rec.buf[i]);
            return data;
        }
        */

        /// <include file='doc\EventLogEntry.uex' path='docs/doc[@for="EventLogEntry.Index"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets the index of this entry in the event
        ///       log.
        ///    </para>
        /// </devdoc>
        [MonitoringDescription(SR.LogEntryIndex)]
        public int Index {
            get {
                return IntFrom(dataBuf, bufOffset + FieldOffsets.RECORDNUMBER);
            }
        }

        /// <include file='doc\EventLogEntry.uex' path='docs/doc[@for="EventLogEntry.Category"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets the text associated with the <see cref='System.Diagnostics.EventLogEntry.CategoryNumber'/> for this entry.
        ///       
        ///    </para>
        /// </devdoc>
        [MonitoringDescription(SR.LogEntryCategory)]
        public string Category {
            get {
                string dllName = GetMessageLibraryNames("CategoryMessageFile");
                string msg = FormatMessageWrapper(dllName, CategoryNumber, null);
                if (msg == null)
                    return "(" + CategoryNumber.ToString() + ")";
                else
                    return msg;
            }
        }

        /// <include file='doc\EventLogEntry.uex' path='docs/doc[@for="EventLogEntry.CategoryNumber"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets the application-specific category number for this entry
        ///       
        ///    </para>
        /// </devdoc>
        [
        MonitoringDescription(SR.LogEntryCategoryNumber)
        ]
        public short CategoryNumber {
            get {
                return ShortFrom(dataBuf, bufOffset + FieldOffsets.EVENTCATEGORY);
            }
        }

        /// <include file='doc\EventLogEntry.uex' path='docs/doc[@for="EventLogEntry.EventID"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets the application-specific event indentifier of this entry.
        ///       
        ///    </para>
        /// </devdoc>
        [MonitoringDescription(SR.LogEntryEventID)]
        public int EventID {
            get {
                // Apparently the top 2 bits of this number are not
                // always 0. Strip them so the number looks nice to the user.
                // The problem is, if the user were to want to call FormatMessage(),
                // they'd need these two bits.
                return IntFrom(dataBuf, bufOffset + FieldOffsets.EVENTID) & 0x3FFFFFFF;
            }
        }

        /// <include file='doc\EventLogEntry.uex' path='docs/doc[@for="EventLogEntry.EntryType"]/*' />
        /// <devdoc>
        ///    <para>
        ///       
        ///       Gets the type
        ///       of this entry.
        ///       
        ///    </para>
        /// </devdoc>
        [MonitoringDescription(SR.LogEntryEntryType)]
        public EventLogEntryType EntryType {
            get {
                return(EventLogEntryType) ShortFrom(dataBuf, bufOffset + FieldOffsets.EVENTTYPE);
            }
        }

        /// <include file='doc\EventLogEntry.uex' path='docs/doc[@for="EventLogEntry.Message"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets the localized message corresponding to this event entry.
        ///       
        ///    </para>
        /// </devdoc>
        [        
        MonitoringDescription(SR.LogEntryMessage),
        Editor("System.ComponentModel.Design.BinaryEditor, " + AssemblyRef.SystemDesign, "System.Drawing.Design.UITypeEditor, " + AssemblyRef.SystemDrawing)
        ]
        public string Message {
            get {
                string dllNames = GetMessageLibraryNames("EventMessageFile");
                int msgId =   IntFrom(dataBuf, bufOffset + FieldOffsets.EVENTID);
                string msg = FormatMessageWrapper(dllNames, msgId, ReplacementStrings);
                if (msg == null) {
                    StringBuilder msgBuf = new StringBuilder(SR.GetString(SR.MessageNotFormatted, msgId, Source, dllNames));
                    string[] strings = ReplacementStrings;
                    for (int i = 0; i < strings.Length; i++) {
                        if (i != 0)
                            msgBuf.Append(", ");
                        msgBuf.Append("'");
                        msgBuf.Append(strings[i]);
                        msgBuf.Append("'");
                    }
                    msg = msgBuf.ToString();
                }
                else
                    msg = ReplaceMessageParameters( msg, ReplacementStrings );
                return msg;
            }
        }       

        /// <include file='doc\EventLogEntry.uex' path='docs/doc[@for="EventLogEntry.Source"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets the name of the application that generated this event.
        ///    </para>
        /// </devdoc>
        [MonitoringDescription(SR.LogEntrySource)]
        public string Source {
            get {
                StringBuilder buf = new StringBuilder();
                int pos = bufOffset + FieldOffsets.RAWDATA;

                char ch = CharFrom(dataBuf, pos);
                while (ch != '\0') {
                    buf.Append(ch);
                    pos += 2;
                    ch = CharFrom(dataBuf, pos);
                }

                return buf.ToString();
            }
        }

        /// <include file='doc\EventLogEntry.uex' path='docs/doc[@for="EventLogEntry.ReplacementStrings"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets the replacement strings
        ///       associated with the entry.
        ///       
        ///    </para>
        /// </devdoc>
        [MonitoringDescription(SR.LogEntryReplacementStrings)]
        public string[] ReplacementStrings {
            get {
                string[] strings = new string[ShortFrom(dataBuf, bufOffset + FieldOffsets.NUMSTRINGS)];
                int i = 0;
                int bufpos = bufOffset + IntFrom(dataBuf, bufOffset + FieldOffsets.STRINGOFFSET);
                StringBuilder buf = new StringBuilder();
                while (i < strings.Length) {
                    char ch = CharFrom(dataBuf, bufpos);
                    if (ch != '\0')
                        buf.Append(ch);
                    else {
                        strings[i] = buf.ToString();
                        i++;
                        buf = new StringBuilder();
                    }
                    bufpos += 2;
                }
                return strings;
            }
        }

#if false
        internal string StringsBuffer {
            get {
                StringBuilder buf = new StringBuilder();
                int bufpos = bufOffset + IntFrom(dataBuf, bufOffset + FieldOffsets.STRINGOFFSET);
                int i = 0;
                int numStrings = ShortFrom(dataBuf, bufOffset + FieldOffsets.NUMSTRINGS);
                while (i < numStrings) {
                    char ch = CharFrom(dataBuf, bufpos);
                    buf.Append(ch);
                    bufpos += 2;
                    if (ch == '\0')
                        i++;
                }
                return buf.ToString();
            }
        }
#endif

        /// <include file='doc\EventLogEntry.uex' path='docs/doc[@for="EventLogEntry.TimeGenerated"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets the time at which this event was generated, in local time.
        ///       
        ///    </para>
        /// </devdoc>
        [MonitoringDescription(SR.LogEntryTimeGenerated)]
        public DateTime TimeGenerated {
            get {
                return beginningOfTime.AddSeconds(IntFrom(dataBuf, bufOffset + FieldOffsets.TIMEGENERATED)).ToLocalTime();
            }
        }

        /// <include file='doc\EventLogEntry.uex' path='docs/doc[@for="EventLogEntry.TimeWritten"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets
        ///       the time at which this event was written to the log, in local time.
        ///       
        ///    </para>
        /// </devdoc>
        [MonitoringDescription(SR.LogEntryTimeWritten)]
        public DateTime TimeWritten {
            get {
                return beginningOfTime.AddSeconds(IntFrom(dataBuf, bufOffset + FieldOffsets.TIMEWRITTEN)).ToLocalTime();
            }
        }

        /// <include file='doc\EventLogEntry.uex' path='docs/doc[@for="EventLogEntry.UserName"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets the name
        ///       of the user responsible for this event.
        ///    </para>
        /// </devdoc>
        [MonitoringDescription(SR.LogEntryUserName)]
        public string UserName {
            get {
                int sidLen = IntFrom(dataBuf, bufOffset + FieldOffsets.USERSIDLENGTH);
                if (sidLen == 0)
                    return null;
                byte[] sid = new byte[sidLen];
                Array.Copy(dataBuf, bufOffset + IntFrom(dataBuf, bufOffset + FieldOffsets.USERSIDOFFSET),
                           sid, 0, sid.Length);
                int[] nameUse = new int[1];
                char[] name = new char[1024];
                char[] refDomName = new char[1024];
                int[] nameLen = new int[] {1024};
                int[] refDomNameLen = new int[] {1024};
                bool success = UnsafeNativeMethods.LookupAccountSid(MachineName, sid, name, nameLen, refDomName, refDomNameLen, nameUse);
                if (!success) {
                    return "";
                    // NOTE, stefanph: it would be nice to return error info, but the only right way to do that
                    // is to throw an exception. People don't want exceptions thrown in the property though.
#if false
                    if (Marshal.GetLastWin32Error() == ERROR_NONE_MAPPED)
                        // There are some SIDs (evidently rare) that are legitimate SIDs but don't
                        // have a mapping to a name.
                        return "";
                    else
                        throw new InvalidOperationException(SR.GetString(SR.NoAccountInfo), EventLog.CreateSafeWin32Exception());
#endif
                }
                StringBuilder username = new StringBuilder();
                username.Append(refDomName, 0, refDomNameLen[0]);
                username.Append("\\");
                username.Append(name, 0, nameLen[0]);
                return username.ToString();
            }
        }

        private char CharFrom(byte[] buf, int offset) {
            return(char) ShortFrom(buf, offset);
        }

        /// <include file='doc\EventLogEntry.uex' path='docs/doc[@for="EventLogEntry.Equals"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Performs a comparison between two event log entries.
        ///       
        ///    </para>
        /// </devdoc>
        public bool Equals(EventLogEntry otherEntry) {
            if (otherEntry == null)
                return false;
            int ourLen = IntFrom(dataBuf, bufOffset + FieldOffsets.LENGTH);
            int theirLen = IntFrom(otherEntry.dataBuf, otherEntry.bufOffset + FieldOffsets.LENGTH);
            if (ourLen != theirLen) {
                return false;
            }
            int min = bufOffset;
            int max = bufOffset + ourLen;
            int j = otherEntry.bufOffset;
            for (int i = min; i < max; i++, j++)
                if (dataBuf[i] != otherEntry.dataBuf[j]) {
                    return false;
                }
            return true;
        }

        private int IntFrom(byte[] buf, int offset) {
            // assumes Little Endian byte order.
            return(unchecked((int)0xFF000000) & (buf[offset+3] << 24)) | (0xFF0000 & (buf[offset+2] << 16)) |
            (0xFF00 & (buf[offset+1] << 8)) | (0xFF & (buf[offset]));
        }
        
        internal static  string FormatMessageWrapper(string dllNameList, int messageNum, string[] insertionStrings) {
            if (dllNameList == null)
                return null;
                
            if (insertionStrings == null)
                insertionStrings = new string[0];

            string[] listDll = dllNameList.Split(';');
            
            // Find first mesage in DLL list
            foreach ( string dllName in  listDll) {
                if (dllName == null || dllName.Length == 0)
                    continue;
                    
                IntPtr hModule = SafeNativeMethods.LoadLibraryEx(dllName, 0, NativeMethods.LOAD_LIBRARY_AS_DATAFILE);
            
                if (hModule == (IntPtr)0)
                    continue;
                    
                string msg = null;     
                try {
                    msg = TryFormatMessage(hModule, messageNum, insertionStrings);    
                } 
                finally {
                    SafeNativeMethods.FreeLibrary(new HandleRef(null, hModule));
                }    

                if ( msg != null ) {
                    return msg;
                }

            }
            return null;
        }


        // Replacing parameters '%n' in formated message using 'ParameterMessageFile' registry key. 
        internal string ReplaceMessageParameters( String msg,  string[] insertionStrings )   {
            
            int percentIdx = msg.IndexOf('%');
            if ( percentIdx < 0 ) 
                return msg;     // no '%' at all
            
            int startCopyIdx     = 0;        // start idx of last orig msg chars to copy
            int msgLength   = msg.Length;
            StringBuilder buf = new StringBuilder();                        
            string paramDLLNames = GetMessageLibraryNames("ParameterMessageFile");
            
            while ( percentIdx >= 0 ) {
                string param = null;
            
                // Convert numeric string after '%' to paramMsgID number.
                int lasNumIdx =  percentIdx + 1;
                while ( lasNumIdx < msgLength && Char.IsDigit(msg, lasNumIdx) ) 
                    lasNumIdx++;
                int  paramMsgID = ( lasNumIdx == percentIdx + 1 ) ? 0 :      // empty number means zero
                                    (int)UInt32.Parse( msg.Substring(percentIdx + 1, lasNumIdx - percentIdx - 1) );
                
                if ( paramMsgID != 0 )
                    param = FormatMessageWrapper( paramDLLNames, paramMsgID, insertionStrings); 
                                                    
                if ( param != null ) {
                    if ( percentIdx > startCopyIdx )
                        buf.Append(msg, startCopyIdx, percentIdx - startCopyIdx);    // original chars from msg
                    buf.Append(param);
                    startCopyIdx = lasNumIdx;
                }
                
                percentIdx = msg.IndexOf('%', percentIdx + 1);
            }    
            
            if ( msgLength - startCopyIdx > 0 )
                buf.Append(msg, startCopyIdx, msgLength - startCopyIdx);          // last span of original msg
            return buf.ToString();
        }

        // Format message in specific DLL. Return <null> on failure. 
        internal static string TryFormatMessage(IntPtr hModule, int messageNum, string[] insertionStrings) {
            string msg = null;

            StringBuilder buf = new StringBuilder(1024);
            IntPtr[] addresses = new IntPtr[insertionStrings.Length];
            int i = 0;
            try {
                for (i = 0; i < insertionStrings.Length; i++)
                    addresses[i] = Marshal.StringToCoTaskMemUni(insertionStrings[i]);
            }
            catch (Exception e) {
                // we failed to allocate one of the strings. Make sure we free the ones
                // that succeeded before that.
                for (i = i-1; i >= 0; i--)
                    Marshal.FreeCoTaskMem(addresses[i]);
                throw e;
            }
            
            int msgLen = 0;
            try {
                int lastError = NativeMethods.ERROR_INSUFFICIENT_BUFFER;
                while (msgLen == 0 && lastError == NativeMethods.ERROR_INSUFFICIENT_BUFFER) {
                    msgLen = SafeNativeMethods.FormatMessage(
                        NativeMethods.FORMAT_MESSAGE_FROM_HMODULE | NativeMethods.FORMAT_MESSAGE_ARGUMENT_ARRAY,
                        new HandleRef(null, hModule),
                        messageNum,
                        0,
                        buf,
                        buf.Capacity,
                        addresses);
                        
                    if (msgLen == 0) {
                        lastError = Marshal.GetLastWin32Error();
                        if (lastError == NativeMethods.ERROR_INSUFFICIENT_BUFFER)
                            buf.Capacity = buf.Capacity * 2;
                    }
                }
            }
            catch (Exception) {
                msgLen = 0;              // return empty on failure
            }
            finally  {
                for (i = 0; i < addresses.Length; i++)
                    Marshal.FreeCoTaskMem(addresses[i]);
            }
            
            if (msgLen > 0) {
                msg = buf.ToString();
                // chop off a single CR/LF pair from the end if there is one. FormatMessage always appends one extra.
                if (msg.Length > 1 && msg[msg.Length-1] == '\n')
                    msg = msg.Substring(0, msg.Length-2);
            }
            
            return msg;
        }



        private static RegistryKey GetSourceRegKey(string logName, string source, string machineName) {
            RegistryKey regKey = null;
            if (machineName.Equals(".")) {
                regKey = Registry.LocalMachine;
            }
            else {
                regKey = RegistryKey.OpenRemoteBaseKey(RegistryHive.LocalMachine, machineName);
            }

            regKey = regKey.OpenSubKey("System\\CurrentControlSet\\Services\\EventLog", /*writable*/false);
            if (regKey == null)
                return null;
            if (logName == null)
                regKey = regKey.OpenSubKey("Application", /*writable*/false);
            else
                regKey = regKey.OpenSubKey(logName, /*writable*/false);
            if (regKey == null)
                return null;
            regKey = regKey.OpenSubKey(source, /*writable*/false);
            return regKey;
        }

        // ------------------------------------------------------------------------------
        // Returns DLL names list.            
        // libRegKey can be: "EventMessageFile", "CategoryMessageFile", "ParameterMessageFile"
        private string GetMessageLibraryNames(string libRegKey ) {
            // get the value stored in the registry

            //Remote EventLog libraries cannot be retrieved unless the source
            //also exists on the local machine. For entries written using this
            //particular API, we can retrieve the local messages library and
            //return the correct information.                                                                                 
            string fileName = null;  
            RegistryKey regKey = null;
            try {                                  
                regKey = GetSourceRegKey(logName, Source, ".");
                if (regKey != null) 
                    fileName = (string)regKey.GetValue(libRegKey);   
                else if (ownerMachineName != "."){
                    try {
                        regKey = GetSourceRegKey(logName, Source, ownerMachineName);
                    }                                                    
                    catch (Exception) {
                    }
                    
                    if (regKey != null) {
                        string remoteFileName = (string)regKey.GetValue(libRegKey);   
                        if (remoteFileName.EndsWith(EventLog.DllName)) 
                            fileName = EventLog.GetDllPath(".");
                    }                
                }                                
            }
            finally {
                if (regKey != null)
                    regKey.Close();
            }                
                                                                
            // convert any environment variables to their current values
            // (the key might have something like %systemroot% in it.)
            return TranslateEnvironmentVars(fileName);
        }


        private short ShortFrom(byte[] buf, int offset) {
            // assumes little Endian byte order.
            return(short) ((0xFF00 & (buf[offset+1] << 8)) | (0xFF & buf[offset]));
        }

        /// <include file='doc\EventLogEntry.uex' path='docs/doc[@for="EventLogEntry.TranslateEnvironmentVars"]/*' />
        internal static string TranslateEnvironmentVars(string untranslated) {
            // (the key might have something like %systemroot% in it.)
            if (untranslated != null) {
                StringBuilder result = new StringBuilder();
                char[] chars = untranslated.ToCharArray();
                int pos = 0;

                while (pos < chars.Length) {
                    char ch = chars[pos];
                    if (ch == '%') {
                        ch = chars[++pos];
                        if (ch == '%')
                            // escape: %% means %
                            result.Append('%');
                        else {
                            StringBuilder varName = new StringBuilder();
                            while (pos < chars.Length && ch != '%') {
                                varName.Append(ch);
                                ch = chars[++pos];
                            }
                            if (ch != '%')
                                // there was one %, but we got to the end of the string before
                                // we found another.
                                result.Append("%" + varName.ToString());
                            else {
                                result.Append(Environment.GetEnvironmentVariable(varName.ToString()));
                            }
                        }
                    }
                    else
                        result.Append(ch);

                    pos++;

                }
                return result.ToString();
            }
            else
                return null;
        }
        
        /// <include file='doc\EventLogEntry.uex' path='docs/doc[@for="EventLogEntry.ISerializable.GetObjectData"]/*' />
        /// <internalonly/>
        /// <devdoc>
        /// <para>
        /// Saves an entry as a stream of data.
        /// </para>
        /// </devdoc>
        void ISerializable.GetObjectData(SerializationInfo info, StreamingContext context) {
            int len = IntFrom(dataBuf, bufOffset + FieldOffsets.LENGTH);
            byte[] buf = new byte[len];
            Array.Copy(dataBuf, bufOffset, buf, 0, len);
            
            info.AddValue("DataBuffer", buf, typeof(byte[]));
            info.AddValue("LogName", logName);
        }

        /// <include file='doc\EventLogEntry.uex' path='docs/doc[@for="EventLogEntry.FieldOffsets"]/*' />
        /// <devdoc>
        ///     Stores the offsets from the beginning of the record to fields within the record.
        /// </devdoc>
        private class FieldOffsets {
            /** int */
            internal const int LENGTH = 0;
            /** int */
            internal const int RESERVED = 4;
            /** int */
            internal const int RECORDNUMBER = 8;
            /** int */
            internal const int TIMEGENERATED = 12;
            /** int */
            internal const int TIMEWRITTEN = 16;
            /** int */
            internal const int EVENTID = 20;
            /** short */
            internal const int EVENTTYPE = 24;
            /** short */
            internal const int NUMSTRINGS = 26;
            /** short */
            internal const int EVENTCATEGORY = 28;
            /** short */
            internal const int RESERVEDFLAGS = 30;
            /** int */
            internal const int CLOSINGRECORDNUMBER = 32;
            /** int */
            internal const int STRINGOFFSET = 36;
            /** int */
            internal const int USERSIDLENGTH = 40;
            /** int */
            internal const int USERSIDOFFSET = 44;
            /** int */
            internal const int DATALENGTH = 48;
            /** int */
            internal const int DATAOFFSET = 52;
            /** bytes */
            internal const int RAWDATA = 56;
        }

        // times in the struct are # seconds from midnight 1/1/1970.
        private static readonly DateTime beginningOfTime = new DateTime(1970, 1, 1, 0, 0, 0);

        // offsets in the struct are specified from the beginning, but we have to reference
        // them from the beginning of the array.  This is the size of the members before that.
        private const int OFFSETFIXUP = 4+4+4+4+4+4+2+2+2+2+4+4+4+4+4+4;
        
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\services\monitoring\system\diagnosticts\eventlogpermissionentrycollection.cs ===
//----------------------------------------------------
// <copyright file="EventLogPermissionEntryCollection.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Diagnostics {
    using System.Security.Permissions;
    using System.Collections;
    
    /// <include file='doc\EventLogPermissionEntryCollection.uex' path='docs/doc[@for="EventLogPermissionEntryCollection"]/*' />        
    [
    Serializable()
    ]
    public class EventLogPermissionEntryCollection : CollectionBase {
        EventLogPermission owner;
        
        /// <include file='doc\EventLogPermissionEntryCollection.uex' path='docs/doc[@for="EventLogPermissionEntryCollection.EventLogPermissionEntryCollection"]/*' />        
        ///<internalonly/>           
        internal EventLogPermissionEntryCollection(EventLogPermission owner, ResourcePermissionBaseEntry[] entries) {
            this.owner = owner;
            for (int index = 0; index < entries.Length; ++index)
                this.InnerList.Add(new EventLogPermissionEntry(entries[index]));
        }                                                                                                            
                                                                                                                              
        /// <include file='doc\EventLogPermissionEntryCollection.uex' path='docs/doc[@for="EventLogPermissionEntryCollection.this"]/*' />        
        public EventLogPermissionEntry this[int index] {
            get {
                return (EventLogPermissionEntry)List[index];
            }
            set {
                List[index] = value;
            }            
        }
        
        /// <include file='doc\EventLogPermissionEntryCollection.uex' path='docs/doc[@for="EventLogPermissionEntryCollection.Add"]/*' />        
        public int Add(EventLogPermissionEntry value) {   
            return List.Add(value);
        }
        
        /// <include file='doc\EventLogPermissionEntryCollection.uex' path='docs/doc[@for="EventLogPermissionEntryCollection.AddRange"]/*' />        
        public void AddRange(EventLogPermissionEntry[] value) {            
            if (value == null) {
                throw new ArgumentNullException("value");
            }
            for (int i = 0; ((i) < (value.Length)); i = ((i) + (1))) {
                this.Add(value[i]);
            }
        }
    
        /// <include file='doc\EventLogPermissionEntryCollection.uex' path='docs/doc[@for="EventLogPermissionEntryCollection.AddRange1"]/*' />        
        public void AddRange(EventLogPermissionEntryCollection value) {            
            if (value == null) {
                throw new ArgumentNullException("value");
            }
            int currentCount = value.Count;
            for (int i = 0; i < currentCount; i = ((i) + (1))) {
                this.Add(value[i]);
            }
        }         
    
        /// <include file='doc\EventLogPermissionEntryCollection.uex' path='docs/doc[@for="EventLogPermissionEntryCollection.Contains"]/*' />                
        public bool Contains(EventLogPermissionEntry value) {            
            return List.Contains(value);
        }
    
        /// <include file='doc\EventLogPermissionEntryCollection.uex' path='docs/doc[@for="EventLogPermissionEntryCollection.CopyTo"]/*' />        
        public void CopyTo(EventLogPermissionEntry[] array, int index) {            
            List.CopyTo(array, index);
        }
    
        /// <include file='doc\EventLogPermissionEntryCollection.uex' path='docs/doc[@for="EventLogPermissionEntryCollection.IndexOf"]/*' />
        public int IndexOf(EventLogPermissionEntry value) {            
            return List.IndexOf(value);
        }
        
        /// <include file='doc\EventLogPermissionEntryCollection.uex' path='docs/doc[@for="EventLogPermissionEntryCollection.Insert"]/*' />        
        public void Insert(int index, EventLogPermissionEntry value) {            
            List.Insert(index, value);
        }
                
        /// <include file='doc\EventLogPermissionEntryCollection.uex' path='docs/doc[@for="EventLogPermissionEntryCollection.Remove"]/*' />        
        public void Remove(EventLogPermissionEntry value) {
            List.Remove(value);                     
        }
        
        /// <include file='doc\EventLogPermissionEntryCollection.uex' path='docs/doc[@for="EventLogPermissionEntryCollection.OnClear"]/*' />        
        ///<internalonly/>                          
        protected override void OnClear() {   
            this.owner.Clear();         
        }
        
        /// <include file='doc\EventLogPermissionEntryCollection.uex' path='docs/doc[@for="EventLogPermissionEntryCollection.OnInsert"]/*' />        
        ///<internalonly/>                          
        protected override void OnInsert(int index, object value) {        
            this.owner.AddPermissionAccess((EventLogPermissionEntry)value);
        }
        
        /// <include file='doc\EventLogPermissionEntryCollection.uex' path='docs/doc[@for="EventLogPermissionEntryCollection.OnRemove"]/*' />
        ///<internalonly/>                          
        protected override void OnRemove(int index, object value) {
            this.owner.RemovePermissionAccess((EventLogPermissionEntry)value);
        }
                 
        /// <include file='doc\EventLogPermissionEntryCollection.uex' path='docs/doc[@for="EventLogPermissionEntryCollection.OnSet"]/*' />
        ///<internalonly/>                          
        protected override void OnSet(int index, object oldValue, object newValue) {     
            this.owner.RemovePermissionAccess((EventLogPermissionEntry)oldValue);
            this.owner.AddPermissionAccess((EventLogPermissionEntry)newValue);       
        } 
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\services\monitoring\system\diagnosticts\eventlogpermissionaccess.cs ===
//------------------------------------------------------------------------------
// <copyright file="EventLogPermissionAccess.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Diagnostics {

    /// <include file='doc\EventLogPermissionAccess.uex' path='docs/doc[@for="EventLogPermissionAccess"]/*' />
    /// <devdoc>
    ///    <para>[To be supplied.]</para>
    /// </devdoc>
    [Flags]         
    public enum EventLogPermissionAccess {
        /// <include file='doc\EventLogPermissionAccess.uex' path='docs/doc[@for="EventLogPermissionAccess.None"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        None = 0,
        /// <include file='doc\EventLogPermissionAccess.uex' path='docs/doc[@for="EventLogPermissionAccess.Browse"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        Browse = 1 << 1,
        /// <include file='doc\EventLogPermissionAccess.uex' path='docs/doc[@for="EventLogPermissionAccess.Instrument"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        Instrument = 1 << 2 | Browse,
        /// <include file='doc\EventLogPermissionAccess.uex' path='docs/doc[@for="EventLogPermissionAccess.Audit"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        Audit = 1 << 3 | Browse,
    }    
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\services\monitoring\system\diagnosticts\eventlogpermissionattribute.cs ===
//------------------------------------------------------------------------------
// <copyright file="EventLogPermissionAttribute.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Diagnostics {
    using System.ComponentModel;
    using System.Security;
    using System.Security.Permissions;   
         
    /// <include file='doc\EventLogPermissionAttribute.uex' path='docs/doc[@for="EventLogPermissionAttribute"]/*' />
    [
    AttributeUsage(AttributeTargets.Method | AttributeTargets.Constructor | AttributeTargets.Class | AttributeTargets.Struct | AttributeTargets.Assembly | AttributeTargets.Event, AllowMultiple = true, Inherited = false ),
    Serializable()
    ]     
    public class EventLogPermissionAttribute : CodeAccessSecurityAttribute {
        private string machineName;
        private EventLogPermissionAccess permissionAccess;
        
        /// <include file='doc\EventLogPermissionAttribute.uex' path='docs/doc[@for="EventLogPermissionAttribute.EventLogPermissionAttribute"]/*' />
        public EventLogPermissionAttribute(SecurityAction action)
        : base(action) {
            this.machineName = ".";
            this.permissionAccess = EventLogPermissionAccess.Browse;                
        }

        /// <include file='doc\EventLogPermissionAttribute.uex' path='docs/doc[@for="EventLogPermissionAttribute.MachineName"]/*' />
        public string MachineName {
            get {                
                return this.machineName;                
            }
            
            set {
                if (!SyntaxCheck.CheckMachineName(value))
                    throw new ArgumentException(SR.GetString(SR.InvalidProperty, "MachineName", value));
                    
                this.machineName = value;                                    
            }
        }
        
        /// <include file='doc\EventLogPermissionAttribute.uex' path='docs/doc[@for="EventLogPermissionAttribute.PermissionAccess"]/*' />        
        public EventLogPermissionAccess PermissionAccess {
            get {
                return this.permissionAccess;
            }
            
            set {
                this.permissionAccess = value;
            }
        }                                                    
              
        /// <include file='doc\EventLogPermissionAttribute.uex' path='docs/doc[@for="EventLogPermissionAttribute.CreatePermission"]/*' />
        public override IPermission CreatePermission() {            
             if (Unrestricted) 
                return new EventLogPermission(PermissionState.Unrestricted);
            
            return new EventLogPermission(this.PermissionAccess, this.MachineName);

        }
    }    
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\services\monitoring\system\diagnosticts\eventlogpermissionentry.cs ===
//----------------------------------------------------
// <copyright file="EventLogPermissionEntry.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Diagnostics {
    using System.ComponentModel;
    using System.Security.Permissions;

    /// <include file='doc\EventLogPermissionEntry.uex' path='docs/doc[@for="EventLogPermissionEntry"]/*' />                                                                                                                                 
    [
    Serializable()
    ]     
    public class EventLogPermissionEntry {
        private string machineName;
        private EventLogPermissionAccess permissionAccess;
            
        /// <include file='doc\EventLogPermissionEntry.uex' path='docs/doc[@for="EventLogPermissionEntry.EventLogPermissionEntry"]/*' />                                                                                                                                 
        public EventLogPermissionEntry(EventLogPermissionAccess permissionAccess, string machineName) {
            if (!SyntaxCheck.CheckMachineName(machineName))
                throw new ArgumentException(SR.GetString(SR.InvalidParameter, "MachineName", machineName));
                                    
            this.permissionAccess = permissionAccess;
            this.machineName = machineName;
        }  
        
        /// <include file='doc\EventLogPermissionEntry.uex' path='docs/doc[@for="EventLogPermissionEntry.EventLogPermissionEntry1"]/*' />                                                                                                                                 
        ///<internalonly/> 
        internal EventLogPermissionEntry(ResourcePermissionBaseEntry baseEntry) {
            this.permissionAccess = (EventLogPermissionAccess)baseEntry.PermissionAccess;
            this.machineName = baseEntry.PermissionAccessPath[0]; 
        }
        
        /// <include file='doc\EventLogPermissionEntry.uex' path='docs/doc[@for="EventLogPermissionEntry.MachineName"]/*' />
        public string MachineName {
            get {                
                return this.machineName;                
            }                        
        }
        
        /// <include file='doc\EventLogPermissionEntry.uex' path='docs/doc[@for="EventLogPermissionEntry.PermissionAccess"]/*' />
        public EventLogPermissionAccess PermissionAccess {
            get {
                return this.permissionAccess;
            }                        
        }      
        
        /// <include file='doc\EventLogPermissionEntry.uex' path='docs/doc[@for="EventLogPermissionEntry.GetBaseEntry"]/*' />                                                                                                                                 
        ///<internalonly/> 
        internal ResourcePermissionBaseEntry GetBaseEntry() {
            ResourcePermissionBaseEntry baseEntry = new ResourcePermissionBaseEntry((int)this.PermissionAccess, new string[] {this.MachineName});            
            return baseEntry;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\services\monitoring\system\diagnosticts\fileversioninfo.cs ===
//------------------------------------------------------------------------------
// <copyright file="FileVersionInfo.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Diagnostics {
    using Microsoft.Win32;
    using System.Runtime.Serialization.Formatters;
    using System.Text;
    using System.Configuration.Assemblies;
    using System.Runtime.InteropServices;
    using System.IO;
    using System.Security;
    using System.Security.Permissions;
    using System;
    using System.Globalization;
    

    /// <include file='doc\FileVersionInfo.uex' path='docs/doc[@for="FileVersionInfo"]/*' />
    /// <devdoc>
    ///    <para>Provides version information for a physical file on disk.</para>
    /// </devdoc>
    [
    // Disabling partial trust scenarios
    PermissionSet(SecurityAction.LinkDemand, Name="FullTrust")
    ]
    public sealed class FileVersionInfo {

        private string fileName;
        private string companyName;
        private string fileDescription;
        private string fileVersion;
        private string internalName;
        private string legalCopyright;
        private string originalFilename;
        private string productName;
        private string productVersion;
        private string comments;
        private string legalTrademarks;
        private string privateBuild;
        private string specialBuild;
        private string language;
        private int fileMajor;
        private int fileMinor;
        private int fileBuild;
        private int filePrivate;
        private int productMajor;
        private int productMinor;
        private int productBuild;
        private int productPrivate;
        private int fileFlags;

        internal FileVersionInfo(string fileName,
                                 string companyName,
                                 string fileDescription,
                                 string fileVersion,
                                 string internalName,
                                 string legalCopyright,
                                 string originalFilename,
                                 string productName,
                                 string productVersion,
                                 string comments,
                                 string legalTrademarks,
                                 string privateBuild,
                                 string specialBuild,
                                 string language,
                                 int fileMajor,
                                 int fileMinor,
                                 int fileBuild,
                                 int filePrivate,
                                 int productMajor,
                                 int productMinor,
                                 int productBuild,
                                 int productPrivate,
                                 int fileFlags) {

            this.fileName = fileName;
            this.fileFlags = fileFlags;
            this.companyName = companyName;
            this.fileDescription = fileDescription;
            this.fileVersion = fileVersion;
            this.internalName = internalName;
            this.legalCopyright = legalCopyright;
            this.originalFilename = originalFilename;
            this.productName = productName;
            this.productVersion = productVersion;
            this.comments = comments;
            this.legalTrademarks = legalTrademarks;
            this.privateBuild = privateBuild;
            this.specialBuild = specialBuild;
            this.language = language;
            this.fileMajor = fileMajor;
            this.fileMinor = fileMinor;
            this.fileBuild = fileBuild;
            this.filePrivate = filePrivate;
            this.productMajor = productMajor;
            this.productMinor = productMinor;
            this.productBuild = productBuild;
            this.productPrivate = productPrivate;
        }

        /// <include file='doc\FileVersionInfo.uex' path='docs/doc[@for="FileVersionInfo.Comments"]/*' />
        /// <devdoc>
        ///    <para>Gets the comments associated with the file.</para>
        /// </devdoc>
        public string Comments {
            get {
                return comments;
            }
        }

        /// <include file='doc\FileVersionInfo.uex' path='docs/doc[@for="FileVersionInfo.CompanyName"]/*' />
        /// <devdoc>
        ///    <para>Gets the name of the company that produced the file.</para>
        /// </devdoc>
        public string CompanyName {
            get {
                return companyName;
            }
        }

        /// <include file='doc\FileVersionInfo.uex' path='docs/doc[@for="FileVersionInfo.FileBuildPart"]/*' />
        /// <devdoc>
        ///    <para>Gets the build number of the file.</para>
        /// </devdoc>
        public int FileBuildPart {
            get {
                return fileBuild;
            }
        }

        /// <include file='doc\FileVersionInfo.uex' path='docs/doc[@for="FileVersionInfo.FileDescription"]/*' />
        /// <devdoc>
        ///    <para>Gets the description of the file.</para>
        /// </devdoc>
        public string FileDescription {
            get {
                return fileDescription;
            }
        }

        /// <include file='doc\FileVersionInfo.uex' path='docs/doc[@for="FileVersionInfo.FileMajorPart"]/*' />
        /// <devdoc>
        ///    <para>Gets the major part of the version number.</para>
        /// </devdoc>
        public int FileMajorPart {
            get {
                return fileMajor;
            }
        }

        /// <include file='doc\FileVersionInfo.uex' path='docs/doc[@for="FileVersionInfo.FileMinorPart"]/*' />
        /// <devdoc>
        ///    <para>Gets the minor
        ///       part of the version number of the file.</para>
        /// </devdoc>
        public int FileMinorPart {
            get {
                return fileMinor;
            }
        }

        /// <include file='doc\FileVersionInfo.uex' path='docs/doc[@for="FileVersionInfo.FileName"]/*' />
        /// <devdoc>
        ///    <para>Gets the name of the file that this instance of System.Windows.Forms.FileVersionInfo
        ///       describes.</para>
        /// </devdoc>
        public string FileName {
            get {
                new FileIOPermission(FileIOPermissionAccess.PathDiscovery, fileName).Demand();
                return fileName;
            }
        }

        /// <include file='doc\FileVersionInfo.uex' path='docs/doc[@for="FileVersionInfo.FilePrivatePart"]/*' />
        /// <devdoc>
        ///    <para>Gets the file private part number.</para>
        /// </devdoc>
        public int FilePrivatePart {
            get {
                return filePrivate;
            }
        }

        /// <include file='doc\FileVersionInfo.uex' path='docs/doc[@for="FileVersionInfo.FileVersion"]/*' />
        /// <devdoc>
        ///    <para>Gets the file version number.</para>
        /// </devdoc>
        public string FileVersion {
            get {
                return fileVersion;
            }
        }

        /// <include file='doc\FileVersionInfo.uex' path='docs/doc[@for="FileVersionInfo.InternalName"]/*' />
        /// <devdoc>
        ///    <para>Gets the internal name of the file, if one exists.</para>
        /// </devdoc>
        public string InternalName {
            get {
                return internalName;
            }
        }

        /// <include file='doc\FileVersionInfo.uex' path='docs/doc[@for="FileVersionInfo.IsDebug"]/*' />
        /// <devdoc>
        ///    <para>Gets a value that specifies whether the file
        ///       contains debugging information or is compiled with debugging features enabled.</para>
        /// </devdoc>
        public bool IsDebug {
            get {
                return (fileFlags & NativeMethods.VS_FF_DEBUG) != 0;
            }
        }

        /// <include file='doc\FileVersionInfo.uex' path='docs/doc[@for="FileVersionInfo.IsPatched"]/*' />
        /// <devdoc>
        ///    <para>Gets a value that specifies whether the file has been modified and is not identical to
        ///       the original shipping file of the same version number.</para>
        /// </devdoc>
        public bool IsPatched {
            get {
                return (fileFlags & NativeMethods.VS_FF_PATCHED) != 0;
            }
        }

        /// <include file='doc\FileVersionInfo.uex' path='docs/doc[@for="FileVersionInfo.IsPrivateBuild"]/*' />
        /// <devdoc>
        ///    <para>Gets a value that specifies whether the file was built using standard release procedures.</para>
        /// </devdoc>
        public bool IsPrivateBuild {
            get {
                return (fileFlags & NativeMethods.VS_FF_PRIVATEBUILD) != 0;
            }
        }

        /// <include file='doc\FileVersionInfo.uex' path='docs/doc[@for="FileVersionInfo.IsPreRelease"]/*' />
        /// <devdoc>
        ///    <para>Gets a value that specifies whether the file
        ///       is a development version, rather than a commercially released product.</para>
        /// </devdoc>
        public bool IsPreRelease {
            get {
                return (fileFlags & NativeMethods.VS_FF_PRERELEASE) != 0;
            }
        }

        /// <include file='doc\FileVersionInfo.uex' path='docs/doc[@for="FileVersionInfo.IsSpecialBuild"]/*' />
        /// <devdoc>
        ///    <para>Gets a value that specifies whether the file is a special build.</para>
        /// </devdoc>
        public bool IsSpecialBuild {
            get {
                return (fileFlags & NativeMethods.VS_FF_SPECIALBUILD) != 0;
            }
        }

        /// <include file='doc\FileVersionInfo.uex' path='docs/doc[@for="FileVersionInfo.Language"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets the default language string for the version info block.
        ///    </para>
        /// </devdoc>
        public string Language {
            get {
                return language;
            }
        }
        
        /// <include file='doc\FileVersionInfo.uex' path='docs/doc[@for="FileVersionInfo.LegalCopyright"]/*' />
        /// <devdoc>
        ///    <para>Gets all copyright notices that apply to the specified file.</para>
        /// </devdoc>
        public string LegalCopyright {
            get {
                return legalCopyright;
            }
        }

        /// <include file='doc\FileVersionInfo.uex' path='docs/doc[@for="FileVersionInfo.LegalTrademarks"]/*' />
        /// <devdoc>
        ///    <para>Gets the trademarks and registered trademarks that apply to the file.</para>
        /// </devdoc>
        public string LegalTrademarks {
            get {
                return legalTrademarks;
            }
        }

        /// <include file='doc\FileVersionInfo.uex' path='docs/doc[@for="FileVersionInfo.OriginalFilename"]/*' />
        /// <devdoc>
        ///    <para>Gets the name the file was created with.</para>
        /// </devdoc>
        public string OriginalFilename {
            get {
                return originalFilename;
            }
        }

        /// <include file='doc\FileVersionInfo.uex' path='docs/doc[@for="FileVersionInfo.PrivateBuild"]/*' />
        /// <devdoc>
        ///    <para>Gets information about a private version of the file.</para>
        /// </devdoc>
        public string PrivateBuild {
            get {
                return privateBuild;
            }
        }

        /// <include file='doc\FileVersionInfo.uex' path='docs/doc[@for="FileVersionInfo.ProductBuildPart"]/*' />
        /// <devdoc>
        ///    <para>Gets the build number of the product this file is associated with.</para>
        /// </devdoc>
        public int ProductBuildPart {
            get {
                return productBuild;
            }
        }

        /// <include file='doc\FileVersionInfo.uex' path='docs/doc[@for="FileVersionInfo.ProductMajorPart"]/*' />
        /// <devdoc>
        ///    <para>Gets the major part of the version number for the product this file is associated with.</para>
        /// </devdoc>
        public int ProductMajorPart {
            get {
                return productMajor;
            }
        }

        /// <include file='doc\FileVersionInfo.uex' path='docs/doc[@for="FileVersionInfo.ProductMinorPart"]/*' />
        /// <devdoc>
        ///    <para>Gets the minor part of the version number for the product the file is associated with.</para>
        /// </devdoc>
        public int ProductMinorPart {
            get {
                return productMinor;
            }
        }

        /// <include file='doc\FileVersionInfo.uex' path='docs/doc[@for="FileVersionInfo.ProductName"]/*' />
        /// <devdoc>
        ///    <para>Gets the name of the product this file is distributed with.</para>
        /// </devdoc>
        public string ProductName {
            get {
                return productName;
            }
        }

        /// <include file='doc\FileVersionInfo.uex' path='docs/doc[@for="FileVersionInfo.ProductPrivatePart"]/*' />
        /// <devdoc>
        ///    <para>Gets the private part number of the product this file is associated with.</para>
        /// </devdoc>
        public int ProductPrivatePart {
            get {
                return productPrivate;
            }
        }

        /// <include file='doc\FileVersionInfo.uex' path='docs/doc[@for="FileVersionInfo.ProductVersion"]/*' />
        /// <devdoc>
        ///    <para>Gets the version of the product this file is distributed with.</para>
        /// </devdoc>
        public string ProductVersion {
            get {
                return productVersion;
            }
        }

        /// <include file='doc\FileVersionInfo.uex' path='docs/doc[@for="FileVersionInfo.SpecialBuild"]/*' />
        /// <devdoc>
        ///    <para>Gets the special build information for the file.</para>
        /// </devdoc>
        public string SpecialBuild {
            get {
                return specialBuild;
            }
        }

        private static string ConvertTo8DigitHex(int value) {
            string s = Convert.ToString(value, 16);
            int l = s.Length;
            if (l == 8) {
                return s.ToUpper(CultureInfo.InvariantCulture);
            }
            else {
                StringBuilder b = new StringBuilder(8);
                for (;l<8; l++) {
                    b.Append("0");
                }
                b.Append(s.ToUpper(CultureInfo.InvariantCulture));
                return b.ToString();
            }
        }
        
        private static NativeMethods.VS_FIXEDFILEINFO GetFixedFileInfo(IntPtr memPtr) {
            IntPtr memRef = IntPtr.Zero;
            int[] memLen = new int[] {0};

            if (UnsafeNativeMethods.VerQueryValue(new HandleRef(null, memPtr), "\\", ref memRef, memLen)) {
                NativeMethods.VS_FIXEDFILEINFO fixedFileInfo = new NativeMethods.VS_FIXEDFILEINFO();
                Marshal.PtrToStructure(memRef, fixedFileInfo);
                return fixedFileInfo;
            }

            return new NativeMethods.VS_FIXEDFILEINFO();
        }

        private static string GetFileVersionLanguage( IntPtr memPtr ) {
            int langid = GetVarEntry( memPtr ) >> 16;
            
            StringBuilder lang = new StringBuilder( 256 );
            UnsafeNativeMethods.VerLanguageName( langid, lang, lang.Capacity );
            return lang.ToString();
        }
        
        private static string GetFileVersionString(IntPtr memPtr, string name) {
            string data = "";

            IntPtr memRef = IntPtr.Zero;
            int[] memLen = new int[] {0};

            if (UnsafeNativeMethods.VerQueryValue(new HandleRef(null, memPtr), name, ref memRef, memLen)) {

                if (memRef != IntPtr.Zero) {
                    data = Marshal.PtrToStringAuto(memRef);
                }
            }
            return data;
        }

        private static int GetVarEntry(IntPtr memPtr) {
            IntPtr memRef = IntPtr.Zero;
            int[] memLen = new int[] {0};

            if (UnsafeNativeMethods.VerQueryValue(new HandleRef(null, memPtr), "\\VarFileInfo\\Translation", ref memRef, memLen)) {
                return(Marshal.ReadInt16(memRef) << 16) + Marshal.ReadInt16((IntPtr)((long)memRef + 2));
            }

            return 0x040904E4;
        }

        /// <include file='doc\FileVersionInfo.uex' path='docs/doc[@for="FileVersionInfo.GetVersionInfo"]/*' />
        /// <devdoc>
        /// <para>Returns a System.Windows.Forms.FileVersionInfo representing the version information associated with the specified file.</para>
        /// </devdoc>
        public static FileVersionInfo GetVersionInfo(string fileName) {
            string fullPath;

            FileIOPermission fiop = new FileIOPermission( PermissionState.None );
            fiop.AllFiles = FileIOPermissionAccess.PathDiscovery;
            fiop.Assert();
            try {
                fullPath = Path.GetFullPath(fileName);
            }
            finally {
                CodeAccessPermission.RevertAssert();
            }

            new FileIOPermission(FileIOPermissionAccess.Read, fullPath).Demand();

            if (!File.Exists(fullPath))
                throw new FileNotFoundException(fileName);

            string companyName = "";
            string fileDescription = "";
            string fileVersion = "";
            string internalName = "";
            string legalCopyright = "";
            string originalFilename = "";
            string productName = "";
            string productVersion = "";
            string comments = "";
            string legalTrademarks = "";
            string privateBuild = "";
            string specialBuild = "";
            string language = "";
            int fileMajor = 0;
            int fileMinor = 0;
            int fileBuild = 0;
            int filePrivate = 0;
            int productMajor = 0;
            int productMinor = 0;
            int productBuild = 0;
            int productPrivate = 0;
            int fileFlags = 0;

            int [] handle = new int[] {0};
            int infoSize;

            infoSize = UnsafeNativeMethods.GetFileVersionInfoSize(fileName, handle);

            if (infoSize != 0) {
                IntPtr memHandle = UnsafeNativeMethods.GlobalAlloc(NativeMethods.GMEM_MOVEABLE | NativeMethods.GMEM_ZEROINIT, infoSize);
                try {
                    IntPtr memPtr = UnsafeNativeMethods.GlobalLock(new HandleRef(null, memHandle));

                    try {
                        if (UnsafeNativeMethods.GetFileVersionInfo(fileName, handle[0], infoSize, new HandleRef(null, memPtr))) {

                            string codepage = ConvertTo8DigitHex(GetVarEntry(memPtr));
                            string template = "\\\\StringFileInfo\\\\{0}\\\\{1}";

                            companyName = GetFileVersionString(memPtr, string.Format(template, codepage, "CompanyName"));
                            fileDescription = GetFileVersionString(memPtr, string.Format(template, codepage, "FileDescription"));
                            fileVersion = GetFileVersionString(memPtr, string.Format(template, codepage, "FileVersion"));
                            internalName = GetFileVersionString(memPtr, string.Format(template, codepage, "InternalName"));
                            legalCopyright = GetFileVersionString(memPtr, string.Format(template, codepage, "LegalCopyright"));
                            originalFilename = GetFileVersionString(memPtr, string.Format(template, codepage, "OriginalFilename"));
                            productName = GetFileVersionString(memPtr, string.Format(template, codepage, "ProductName"));
                            productVersion = GetFileVersionString(memPtr, string.Format(template, codepage, "ProductVersion"));
                            comments = GetFileVersionString(memPtr, string.Format(template, codepage, "Comments"));
                            legalTrademarks = GetFileVersionString(memPtr, string.Format(template, codepage, "LegalTrademarks"));
                            privateBuild = GetFileVersionString(memPtr, string.Format(template, codepage, "PrivateBuild"));
                            specialBuild = GetFileVersionString(memPtr, string.Format(template, codepage, "SpecialBuild"));
                            
                            language = GetFileVersionLanguage( memPtr );

                            NativeMethods.VS_FIXEDFILEINFO ffi = GetFixedFileInfo(memPtr);
                            fileMajor = HIWORD(ffi.dwFileVersionMS);
                            fileMinor = LOWORD(ffi.dwFileVersionMS);
                            fileBuild = HIWORD(ffi.dwFileVersionLS);
                            filePrivate = LOWORD(ffi.dwFileVersionLS);
                            productMajor = HIWORD(ffi.dwProductVersionMS);
                            productMinor = LOWORD(ffi.dwProductVersionMS);
                            productBuild = HIWORD(ffi.dwProductVersionLS);
                            productPrivate = LOWORD(ffi.dwProductVersionLS);
                            fileFlags = ffi.dwFileFlags;
                        }
                    }
                    finally {
                        UnsafeNativeMethods.GlobalUnlock(new HandleRef(null, memHandle));
                    }
                }
                finally {
                    UnsafeNativeMethods.GlobalFree(new HandleRef(null, memHandle));
                    memHandle = IntPtr.Zero;
                }
            }

            return new FileVersionInfo(fileName,
                                       companyName,
                                       fileDescription,
                                       fileVersion,
                                       internalName,
                                       legalCopyright,
                                       originalFilename,
                                       productName,
                                       productVersion,
                                       comments,
                                       legalTrademarks,
                                       privateBuild,
                                       specialBuild,
                                       language,
                                       fileMajor,
                                       fileMinor,
                                       fileBuild,
                                       filePrivate,
                                       productMajor,
                                       productMinor,
                                       productBuild,
                                       productPrivate,
                                       fileFlags);
        }

        private static int HIWORD(int dword) {
            return NativeMethods.Util.HIWORD(dword);
        }

        private static int LOWORD(int dword) {
            return NativeMethods.Util.LOWORD(dword);
        }

        /// <include file='doc\FileVersionInfo.uex' path='docs/doc[@for="FileVersionInfo.ToString"]/*' />
        /// <devdoc>
        /// <para>Returns a partial list of properties in System.Windows.Forms.FileVersionInfo
        /// and their values.</para>
        /// </devdoc>
        public override string ToString() {
            StringBuilder sb = new StringBuilder(128);
            String nl = "\r\n";
            sb.Append("File:             ");   sb.Append(FileName);   sb.Append(nl);
            sb.Append("InternalName:     ");   sb.Append(InternalName);   sb.Append(nl);
            sb.Append("OriginalFilename: ");   sb.Append(OriginalFilename);   sb.Append(nl);
            sb.Append("FileVersion:      ");   sb.Append(FileVersion);   sb.Append(nl);
            sb.Append("FileDescription:  ");   sb.Append(FileDescription);   sb.Append(nl);
            sb.Append("Product:          ");   sb.Append(ProductName);   sb.Append(nl);
            sb.Append("ProductVersion:   ");   sb.Append(ProductVersion);   sb.Append(nl);
            sb.Append("Debug:            ");   sb.Append(IsDebug.ToString());   sb.Append(nl);
            sb.Append("Patched:          ");   sb.Append(IsPatched.ToString());   sb.Append(nl);
            sb.Append("PreRelease:       ");   sb.Append(IsPreRelease.ToString());   sb.Append(nl);
            sb.Append("PrivateBuild:     ");   sb.Append(IsPrivateBuild.ToString());   sb.Append(nl);
            sb.Append("SpecialBuild:     ");   sb.Append(IsSpecialBuild.ToString());   sb.Append(nl);
            sb.Append("Language          ");   sb.Append(Language);  sb.Append(nl);
            return sb.ToString();
        }

    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\services\monitoring\system\diagnosticts\eventlogtracelistener.cs ===
//------------------------------------------------------------------------------
// <copyright file="EventLogTraceListener.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

/*
 */
namespace System.Diagnostics {
    using System;
    using System.Security;
    using System.Security.Permissions;
    using System.IO;

    /// <include file='doc\EventLogTraceListener.uex' path='docs/doc[@for="EventLogTraceListener"]/*' />
    /// <devdoc>
    ///    <para>Provides a simple listener for directing tracing or 
    ///       debugging output to a <see cref='T:System.IO.TextWriter'/> or to a <see cref='T:System.IO.Stream'/>, such as <see cref='F:System.Console.Out'/> or
    ///    <see cref='T:System.IO.FileStream'/>.</para>
    /// </devdoc>    
    [
    // Disabling partial trust scenarios
    PermissionSet(SecurityAction.LinkDemand, Name="FullTrust")
    ]
    public sealed class EventLogTraceListener : TraceListener {
        private EventLog eventLog;
        private bool nameSet;

        /// <include file='doc\EventLogTraceListener.uex' path='docs/doc[@for="EventLogTraceListener.EventLogTraceListener"]/*' />
        /// <devdoc>
        /// <para>Initializes a new instance of the <see cref='System.Diagnostics.EventLogTraceListener'/> class without a trace 
        ///    listener.</para>
        /// </devdoc>
        public EventLogTraceListener() {
        }

        /// <include file='doc\EventLogTraceListener.uex' path='docs/doc[@for="EventLogTraceListener.EventLogTraceListener1"]/*' />
        /// <devdoc>
        /// <para>Initializes a new instance of the <see cref='System.Diagnostics.EventLogTraceListener'/> class using the 
        ///    specified event log.</para>
        /// </devdoc>
        public EventLogTraceListener(EventLog eventLog) 
            : base((eventLog != null) ? eventLog.Source : string.Empty) {
            this.eventLog = eventLog;            
        }
        
        /// <include file='doc\EventLogTraceListener.uex' path='docs/doc[@for="EventLogTraceListener.EventLogTraceListener2"]/*' />
        /// <devdoc>
        /// <para>Initializes a new instance of the <see cref='System.Diagnostics.EventLogTraceListener'/> class using the 
        ///    specified source.</para>
        /// </devdoc>
        public EventLogTraceListener(string source) {            
            eventLog = new EventLog();
            eventLog.Source = source;            
        }
        
        /// <include file='doc\EventLogTraceListener.uex' path='docs/doc[@for="EventLogTraceListener.EventLog"]/*' />
        /// <devdoc>
        ///    <para>Gets or sets the event log to write to.</para>
        /// </devdoc>
        public EventLog EventLog {
            get {
                return eventLog;
            }

            set {
                eventLog = value;
            }
        }

        /// <include file='doc\EventLogTraceListener.uex' path='docs/doc[@for="EventLogTraceListener.Name"]/*' />
        /// <devdoc>
        ///    <para> Gets or sets the
        ///       name of this trace listener.</para>
        /// </devdoc>
        public override string Name {
            get {
                if (nameSet == false && eventLog != null) {
                    nameSet = true;
                    base.Name = eventLog.Source;
                }

                return base.Name;
            }

            set {            
                nameSet = true;
                base.Name = value;                
            }
        }                                                                                 
                                                      
        /// <include file='doc\EventLogTraceListener.uex' path='docs/doc[@for="EventLogTraceListener.Close"]/*' />
        /// <devdoc>
        ///    <para>Closes the text writer so that it no longer receives tracing or 
        ///       debugging output.</para>
        /// </devdoc>
        public override void Close() {
            if (eventLog != null) 
                eventLog.Close();
        }
                                                                   
        /// <include file='doc\EventLogTraceListener.uex' path='docs/doc[@for="EventLogTraceListener.Dispose"]/*' />
        /// <internalonly/>
        /// <devdoc>        
        /// </devdoc>
        protected override void Dispose(bool disposing) {
            if (disposing) 
                this.Close();
        }                

        /// <include file='doc\EventLogTraceListener.uex' path='docs/doc[@for="EventLogTraceListener.Write"]/*' />
        /// <devdoc>
        ///    <para>Writes a message to this instance's event log.</para>
        /// </devdoc>
        public override void Write(string message) {
            if (eventLog != null) eventLog.WriteEntry(message);
        }

        /// <include file='doc\EventLogTraceListener.uex' path='docs/doc[@for="EventLogTraceListener.WriteLine"]/*' />
        /// <devdoc>
        ///    <para>Writes a message to this instance's event log followed by a line terminator. 
        ///       The default line terminator is a carriage return followed by a line feed
        ///       (\r\n).</para>
        /// </devdoc>
        public override void WriteLine(string message) {
            Write(message);
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\services\monitoring\system\diagnosticts\icollectdata.cs ===
//------------------------------------------------------------------------------
// <copyright file="ICollectData.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

//---------------------------------------------------------------------------
// ICollectData.cs
//---------------------------------------------------------------------------
// WARNING: this file autogenerated
//---------------------------------------------------------------------------
// Copyright (c) 1999, Microsoft Corporation   All Rights Reserved
// Information Contained Herein Is Proprietary and Confidential.
//---------------------------------------------------------------------------

namespace System.Diagnostics {
    using System.Runtime.InteropServices;

    using System.Diagnostics;
    using System;
    

    /// <include file='doc\ICollectData.uex' path='docs/doc[@for="ICollectData"]/*' />
    /// <internalonly/>
    [ComImport, Guid("73386977-D6FD-11D2-BED5-00C04F79E3AE"), System.Runtime.InteropServices.InterfaceTypeAttribute(System.Runtime.InteropServices.ComInterfaceType.InterfaceIsIUnknown)]
    public interface ICollectData {

    	 /// <include file='doc\ICollectData.uex' path='docs/doc[@for="ICollectData.CollectData"]/*' />
    	 /// <devdoc>
    	 ///    <para>[To be supplied.]</para>
    	 /// </devdoc>
    	[return: MarshalAs(UnmanagedType.I4 )]
    	 void CollectData(
    		[In, MarshalAs(UnmanagedType.I4 )] 
    		 int id,
    		[In, MarshalAs(UnmanagedType.SysInt )] 
    		 IntPtr valueName,
    		[In, MarshalAs(UnmanagedType.SysInt )] 
    		 IntPtr data,
    		[In, MarshalAs(UnmanagedType.I4 )] 
    		 int totalBytes,
            [Out, MarshalAs(UnmanagedType.SysInt)]
    		 out IntPtr res);

         /// <include file='doc\ICollectData.uex' path='docs/doc[@for="ICollectData.CloseData"]/*' />
    	 /// <devdoc>
    	 ///    <para>[To be supplied.]</para>
    	 /// </devdoc>
    	 void CloseData();


    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\services\monitoring\system\diagnosticts\monitoringdescriptionattribute.cs ===
//------------------------------------------------------------------------------
// <copyright file="MonitoringDescriptionAttribute.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Diagnostics {


    using System;
    using System.ComponentModel;   

    /// <include file='doc\MonitoringDescriptionAttribute.uex' path='docs/doc[@for="MonitoringDescriptionAttribute"]/*' />
    /// <devdoc>
    ///     DescriptionAttribute marks a property, event, or extender with a
    ///     description. Visual designers can display this description when referencing
    ///     the member.
    /// </devdoc>
    [AttributeUsage(AttributeTargets.All)]
    public class MonitoringDescriptionAttribute : DescriptionAttribute {

        private bool replaced = false;

        /// <include file='doc\MonitoringDescriptionAttribute.uex' path='docs/doc[@for="MonitoringDescriptionAttribute.MonitoringDescriptionAttribute"]/*' />
        /// <devdoc>
        ///     Constructs a new sys description.
        /// </devdoc>
        public MonitoringDescriptionAttribute(string description) : base(description) {
        }

        /// <include file='doc\MonitoringDescriptionAttribute.uex' path='docs/doc[@for="MonitoringDescriptionAttribute.Description"]/*' />
        /// <devdoc>
        ///     Retrieves the description text.
        /// </devdoc>
        public override string Description {
            get {
                if (!replaced) {
                    replaced = true;
                    DescriptionValue = SR.GetString(base.Description);
                }
                return base.Description;
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\services\monitoring\system\diagnosticts\instancedatacollectioncollection.cs ===
//------------------------------------------------------------------------------
// <copyright file="InstanceDataCollectionCollection.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Diagnostics {

    using System.Diagnostics;
    using System;
    using System.Collections;
    using System.Globalization;
    
    /// <include file='doc\InstanceDataCollectionCollection.uex' path='docs/doc[@for="InstanceDataCollectionCollection"]/*' />
    /// <devdoc>
    ///     The collection returned from  the <see cref='System.Diagnostics.PerformanceCounterCategory.ReadCategory'/> method.  
    ///     that contains all the counter and instance data.
    ///     The collection contains an InstanceDataCollection object for each counter.  Each InstanceDataCollection
    ///     object contains the performance data for all counters for that instance.  In other words the data is
    ///     indexed by counter name and then by instance name.
    /// </devdoc>    
    public class InstanceDataCollectionCollection : DictionaryBase {
        /// <include file='doc\InstanceDataCollectionCollection.uex' path='docs/doc[@for="InstanceDataCollectionCollection.this"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public InstanceDataCollection this[string counterName] {
            get {
                if (counterName == null)
                    throw new ArgumentNullException("counterName");
                    
                object objectName = counterName.ToLower(CultureInfo.InvariantCulture);
                return (InstanceDataCollection) Dictionary[objectName];
            }
        }

        /// <include file='doc\InstanceDataCollectionCollection.uex' path='docs/doc[@for="InstanceDataCollectionCollection.Keys"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public ICollection Keys {
            get { return Dictionary.Keys; }
        }

        /// <include file='doc\InstanceDataCollectionCollection.uex' path='docs/doc[@for="InstanceDataCollectionCollection.Values"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public ICollection Values {
            get {
                return Dictionary.Values;
            }
        }

        internal void Add(string counterName, InstanceDataCollection value) {
            object objectName = counterName.ToLower(CultureInfo.InvariantCulture); 
            Dictionary.Add(objectName, value);
        }

        /// <include file='doc\InstanceDataCollectionCollection.uex' path='docs/doc[@for="InstanceDataCollectionCollection.Contains"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public bool Contains(string counterName) {    
            if (counterName == null)
                    throw new ArgumentNullException("counterName");
                    
            object objectName = counterName.ToLower(CultureInfo.InvariantCulture);
            return Dictionary.Contains(objectName);
        }
        
        /// <include file='doc\InstanceDataCollectionCollection.uex' path='docs/doc[@for="InstanceDataCollectionCollection.CopyTo"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public void CopyTo(InstanceDataCollection[] counters, int index) {
            Dictionary.Values.CopyTo((Array)counters, index);
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\services\monitoring\system\diagnosticts\instancedata.cs ===
//------------------------------------------------------------------------------
// <copyright file="InstanceData.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Diagnostics {

    using System.Diagnostics;

    using System;
    using System.Collections;

    /// <include file='doc\InstanceData.uex' path='docs/doc[@for="InstanceData"]/*' />
    /// <devdoc>
    ///     A holder of instance data.
    /// </devdoc>    
    public class InstanceData {
        private string instanceName;
        private CounterSample sample;

        /// <include file='doc\InstanceData.uex' path='docs/doc[@for="InstanceData.InstanceData"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public InstanceData(string instanceName, CounterSample sample) {
            this.instanceName = instanceName;
            this.sample = sample;
        }

        /// <include file='doc\InstanceData.uex' path='docs/doc[@for="InstanceData.InstanceName"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public string InstanceName {
            get {
                return instanceName;
            }
        }

        /// <include file='doc\InstanceData.uex' path='docs/doc[@for="InstanceData.Sample"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public CounterSample Sample {
            get {
                return sample;
            }
        }

        /// <include file='doc\InstanceData.uex' path='docs/doc[@for="InstanceData.RawValue"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public long RawValue {
            get {
                return sample.RawValue;
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\services\monitoring\system\diagnosticts\performancecounter.cs ===
//------------------------------------------------------------------------------
// <copyright file="PerformanceCounter.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Diagnostics {
    using System.Runtime.Serialization.Formatters;
    using System.Runtime.InteropServices;
    using System.ComponentModel;
    using System.Diagnostics;
    using System;
    using System.Collections;   
    using System.Globalization;
    using System.Security;
    using System.Security.Permissions;

    /// <include file='doc\PerformanceCounter.uex' path='docs/doc[@for="PerformanceCounter"]/*' />
    /// <devdoc>
    ///     Performance Counter component.
    ///     This class provides support for NT Performance counters.
    ///     It handles both the existing counters (accesible by Perf Registry Interface)
    ///     and user defined (extensible) counters.
    ///     This class is a part of a larger framework, that includes the perf dll object and
    ///     perf service.
    /// </devdoc>
    [
    InstallerType("System.Diagnostics.PerformanceCounterInstaller," + AssemblyRef.SystemConfigurationInstall),
    Designer("Microsoft.VisualStudio.Install.PerformanceCounterDesigner, " + AssemblyRef.MicrosoftVisualStudio),
    // Disabling partial trust scenarios
    PermissionSet(SecurityAction.LinkDemand, Name="FullTrust")
    ]
    public sealed class PerformanceCounter : Component, ISupportInitialize {
        private string machineName;
        private string categoryName;
        private string counterName;
        private string instanceName;
        
        private bool isReadOnly;
        private bool initialized = false;        
        private string helpMsg = null;
        private int counterType = -1;
        
        // Cached old sample
        private CounterSample oldSample = CounterSample.Empty;
        
        // Cached IP Shared Performanco counter
        private SharedPerformanceCounter sharedCounter;

        /// <include file='doc\PerformanceCounter.uex' path='docs/doc[@for="PerformanceCounter.DefaultFileMappingSize"]/*' />
        public static int DefaultFileMappingSize = 524288;    
                                 
        /// <include file='doc\PerformanceCounter.uex' path='docs/doc[@for="PerformanceCounter.PerformanceCounter"]/*' />
        /// <devdoc>
        ///     The defaut constructor. Creates the perf counter object
        /// </devdoc>
        public PerformanceCounter() {
            machineName = ".";
            categoryName = String.Empty;
            counterName = String.Empty;
            instanceName = String.Empty;
            this.isReadOnly = true;
        }

        /// <include file='doc\PerformanceCounter.uex' path='docs/doc[@for="PerformanceCounter.PerformanceCounter1"]/*' />
        /// <devdoc>
        ///     Creates the Performance Counter Object
        /// </devdoc>
        public PerformanceCounter(string categoryName, string counterName, string instanceName, string machineName) {
            this.MachineName = machineName;
            this.CategoryName = categoryName;
            this.CounterName = counterName;
            this.InstanceName = instanceName;
            this.isReadOnly = true;
            Initialize();
        }
        
        internal PerformanceCounter(string categoryName, string counterName, string instanceName, string machineName, bool skipInit) {
            this.MachineName = machineName;
            this.CategoryName = categoryName;
            this.CounterName = counterName;
            this.InstanceName = instanceName;
            this.isReadOnly = true;
            this.initialized = true;                                      
        }

        /// <include file='doc\PerformanceCounter.uex' path='docs/doc[@for="PerformanceCounter.PerformanceCounter2"]/*' />
        /// <devdoc>
        ///     Creates the Performance Counter Object on local machine.
        /// </devdoc>
        public PerformanceCounter(string categoryName, string counterName, string instanceName) :
        this(categoryName, counterName, instanceName, true) {            
        }
        
        /// <include file='doc\PerformanceCounter.uex' path='docs/doc[@for="PerformanceCounter.PerformanceCounter3"]/*' />
        /// <devdoc>
        ///     Creates the Performance Counter Object on local machine.
        /// </devdoc>
        public PerformanceCounter(string categoryName, string counterName, string instanceName, bool readOnly) {
            this.MachineName = ".";
            this.CategoryName = categoryName;
            this.CounterName = counterName;
            this.InstanceName = instanceName;
            this.isReadOnly = readOnly;
            Initialize();
        }
        
        /// <include file='doc\PerformanceCounter.uex' path='docs/doc[@for="PerformanceCounter.PerformanceCounter4"]/*' />
        /// <devdoc>
        ///     Creates the Performance Counter Object, assumes that it's a single instance
        /// </devdoc>
        public PerformanceCounter(string categoryName, string counterName) :
        this(categoryName, counterName, true) {            
        }
        
        /// <include file='doc\PerformanceCounter.uex' path='docs/doc[@for="PerformanceCounter.PerformanceCounter5"]/*' />
        /// <devdoc>
        ///     Creates the Performance Counter Object, assumes that it's a single instance
        /// </devdoc>
        public PerformanceCounter(string categoryName, string counterName, bool readOnly) :
        this(categoryName, counterName, "", readOnly) {            
        }
        
        /// <include file='doc\PerformanceCounter.uex' path='docs/doc[@for="PerformanceCounter.CategoryName"]/*' />
        /// <devdoc>
        ///     Returns the performance category name for this performance counter
        /// </devdoc>
        [
        ReadOnly(true),
        DefaultValue(""),
        TypeConverter("System.Diagnostics.Design.CategoryValueConverter, " + AssemblyRef.SystemDesign),
        SRDescription(SR.PCCategoryName),
        RecommendedAsConfigurable(true)
        ]
        public string CategoryName {
            get {
                return categoryName;
            }
            set {
                if (value == null)
                    throw new ArgumentNullException("value");
                
                if (categoryName == null || String.Compare(categoryName, value, true, CultureInfo.InvariantCulture) != 0) {
                    categoryName = value;
                    Close();
                }
            }
        }

        /// <include file='doc\PerformanceCounter.uex' path='docs/doc[@for="PerformanceCounter.CounterHelp"]/*' />
        /// <devdoc>
        ///     Returns the description message for this performance counter
        /// </devdoc>
        [
        ReadOnly(true),
        DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden),
        MonitoringDescription(SR.PC_CounterHelp)
        ]
        public string CounterHelp {
            get {
                Initialize();
                
                if (helpMsg == null) 
                    helpMsg = PerformanceCounterLib.GetCounterHelp(this.machineName, this.categoryName, this.counterName);                    

                return helpMsg;
            }
        }

        /// <include file='doc\PerformanceCounter.uex' path='docs/doc[@for="PerformanceCounter.CounterName"]/*' />
        /// <devdoc>
        ///     Sets/returns the performance counter name for this performance counter
        /// </devdoc>
        [
        ReadOnly(true),
        DefaultValue(""),
        TypeConverter("System.Diagnostics.Design.CounterNameConverter, " + AssemblyRef.SystemDesign),
        SRDescription(SR.PCCounterName),
        RecommendedAsConfigurable(true)
        ]
        public string CounterName {
            get {
                return counterName;
            }
            set {
                if (value == null)
                    throw new ArgumentNullException("value");
                    
                if (counterName == null || String.Compare(counterName, value, true, CultureInfo.InvariantCulture) != 0) {
                    counterName = value;
                    Close();
                }
            }
        }

        /// <include file='doc\PerformanceCounter.uex' path='docs/doc[@for="PerformanceCounter.CounterType"]/*' />
        /// <devdoc>
        ///     Sets/Returns the counter type for this performance counter
        /// </devdoc>
        [
        DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden), 
        MonitoringDescription(SR.PC_CounterType)
        ]
        public PerformanceCounterType CounterType {
            get {                
                if (counterType == -1) {
                    //No need to initialize, since NextSample already does.
                    CounterSample sample = NextSample();                                                              
                }

                return(PerformanceCounterType) counterType;
            }            
        }

        /// <include file='doc\PerformanceCounter.uex' path='docs/doc[@for="PerformanceCounter.InstanceName"]/*' />
        /// <devdoc>
        ///     Sets/returns an instance name for this performance counter
        /// </devdoc>
        [
        ReadOnly(true),
        DefaultValue(""),
        TypeConverter("System.Diagnostics.Design.InstanceNameConverter, " + AssemblyRef.SystemDesign),
        SRDescription(SR.PCInstanceName),
        RecommendedAsConfigurable(true)
        ]
        public string InstanceName {
            get {
                return instanceName;
            }
            set {   
                if (value == null && instanceName == null)
                    return;
                                
                if ((value == null && instanceName != null) ||
                      (value != null && instanceName == null) ||
                      String.Compare(instanceName, value, true, CultureInfo.InvariantCulture) != 0) {
                    instanceName = value;
                    Close();
                }
            }
        }        
         
        /// <include file='doc\PerformanceCounter.uex' path='docs/doc[@for="PerformanceCounter.ReadOnly"]/*' />
        /// <devdoc>
        ///     Returns true if counter is read only (system counter, foreign extensible counter or remote counter)
        /// </devdoc>
        [               
        Browsable(false),
        DefaultValue(true),        
        MonitoringDescription(SR.PC_ReadOnly)
        ]
        public bool ReadOnly {
            get {                                
                return isReadOnly;
            }
            
            set {
                if (value != this.isReadOnly) {
                    this.isReadOnly = value;
                    Close();
                }                    
            }
        }

        
        /// <include file='doc\PerformanceCounter.uex' path='docs/doc[@for="PerformanceCounter.MachineName"]/*' />
        /// <devdoc>
        ///     Set/returns the machine name for this performance counter
        /// </devdoc>
        [
        Browsable(false),
        DefaultValue("."),
        SRDescription(SR.PCMachineName),
        RecommendedAsConfigurable(true)
        ]
        public string MachineName {
            get {
                return machineName;
            }
            set {  
                if (!SyntaxCheck.CheckMachineName(value))
                    throw new ArgumentException(SR.GetString(SR.InvalidParameter, "machineName", value));
                
                if (machineName != value) {                 
                    machineName = value;
                    Close();
                }                    
            }
        }

        /// <include file='doc\PerformanceCounter.uex' path='docs/doc[@for="PerformanceCounter.RawValue"]/*' />
        /// <devdoc>
        ///     Directly accesses the raw value of this counter.  If counter type is of a 32-bit size, it will truncate
        ///     the value given to 32 bits.  This can be significantly more performant for scenarios where
        ///     the raw value is sufficient.   Note that this only works for custom counters created using
        ///     this component,  non-custom counters will throw an exception if this property is accessed.
        /// </devdoc>
        [
        Browsable(false),
        DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden),
        MonitoringDescription(SR.PC_RawValue)
        ]
        public long RawValue {
            get {                                
                if (ReadOnly) {
                    //No need to initialize, since NextSample already does.
                    return NextSample().RawValue;
                }
                else {                    
                    Initialize();
                    
                    return this.sharedCounter.Value;
                }
            }                                                       
            set {
                if (ReadOnly)
                    throw new InvalidOperationException(SR.GetString(SR.ReadOnlyCounter));
                    
                Initialize();
                                                                                   
                this.sharedCounter.Value = value;
            }
        }

        /// <include file='doc\PerformanceCounter.uex' path='docs/doc[@for="PerformanceCounter.BeginInit"]/*' />
        /// <devdoc>        
        /// </devdoc>            
        public void BeginInit() {            
            this.Close();
        }        

        /// <include file='doc\PerformanceCounter.uex' path='docs/doc[@for="PerformanceCounter.Close"]/*' />
        /// <devdoc>
        ///     Frees all the resources allocated by this counter
        /// </devdoc>
        public void Close() {            
            this.helpMsg = null;                        
            this.oldSample = CounterSample.Empty;
            this.sharedCounter = null;            
            this.initialized = false;
        }         
            
        /// <include file='doc\PerformanceCounter.uex' path='docs/doc[@for="PerformanceCounter.CloseSharedResources"]/*' />
        /// <devdoc>
        ///     Frees all the resources allocated for all performance
        ///     counters, frees File Mapping used by extensible counters,
        ///     unloads dll's used to read counters.
        /// </devdoc>                                    
        public static void CloseSharedResources() {            
            PerformanceCounterLib.CloseAllLibraries();            
        }            
        
        /// <include file='doc\PerformanceCounter.uex' path='docs/doc[@for="PerformanceCounter.Dispose"]/*' />
        /// <internalonly/>
        /// <devdoc>        
        /// </devdoc>
        protected override void Dispose(bool disposing) {
            // safe to call while finalizing or disposing
            //
            if (disposing) {
                //Dispose managed and unmanaged resources
                Close();
            }
                            
            base.Dispose(disposing);
        }
                                 
        /// <include file='doc\PerformanceCounter.uex' path='docs/doc[@for="PerformanceCounter.Decrement"]/*' />
        /// <devdoc>
        ///     Decrements counter by one using an efficient atomic operation.
        /// </devdoc>
        public long Decrement() {                        
            if (ReadOnly)
                throw new InvalidOperationException(SR.GetString(SR.ReadOnlyCounter));

            Initialize();
                            
            return this.sharedCounter.Decrement();
        }                        
        
        /// <include file='doc\PerformanceCounter.uex' path='docs/doc[@for="PerformanceCounter.EndInit"]/*' />
        /// <devdoc>        
        /// </devdoc>         
        public void EndInit() {                 
            Initialize();
        }
                        
        /// <include file='doc\PerformanceCounter.uex' path='docs/doc[@for="PerformanceCounter.IncrementBy"]/*' />
        /// <devdoc>
        ///     Increments the value of this counter.  If counter type is of a 32-bit size, it'll truncate
        ///     the value given to 32 bits. This method uses a mutex to guarantee correctness of
        ///     the operation in case of multiple writers. This method should be used with caution because of the negative
        ///     impact on performance due to creation of the mutex.
        /// </devdoc>
        public long IncrementBy(long value) {                        
            if (ReadOnly)
                throw new InvalidOperationException(SR.GetString(SR.ReadOnlyCounter));

            Initialize();
                        
            return this.sharedCounter.IncrementBy(value);
        }       

        /// <include file='doc\PerformanceCounter.uex' path='docs/doc[@for="PerformanceCounter.Increment"]/*' />
        /// <devdoc>
        ///     Increments counter by one using an efficient atomic operation.
        /// </devdoc>
        public long Increment() {                        
            if (ReadOnly)
                throw new InvalidOperationException(SR.GetString(SR.ReadOnlyCounter));
                        
            Initialize();                        
                        
            return this.sharedCounter.Increment();
        }
                              
        /// <include file='doc\PerformanceCounter.uex' path='docs/doc[@for="PerformanceCounter.Initialize"]/*' />
        /// <devdoc>
        ///     Intializes required resources
        /// </devdoc>                                                                                                                                                                                                                                                                 
        private void Initialize() {
            if (!initialized && ! DesignMode) {
                lock(this) {
                    if (!initialized) {
                        if (this.categoryName == String.Empty)
                            throw new InvalidOperationException(SR.GetString(SR.CategoryNameMissing));
                        if (this.counterName == String.Empty)
                            throw new InvalidOperationException(SR.GetString(SR.CounterNameMissing));
                                                          
                        if (this.ReadOnly) {
                            PerformanceCounterPermission permission = new PerformanceCounterPermission(
                                                                                            PerformanceCounterPermissionAccess.Browse, this.machineName, this.categoryName);
                    
                            permission.Demand();                                    
                            
                            if (!PerformanceCounterLib.CounterExists(machineName , categoryName, counterName))                                                                                                                      
                                throw new InvalidOperationException(SR.GetString(SR.CounterExists, categoryName, counterName));   
                                                                                                          
                            this.initialized = true;                                      
                        }                
                        else {
                            PerformanceCounterPermission permission = new PerformanceCounterPermission(PerformanceCounterPermissionAccess.Instrument, this.machineName, this.categoryName);
                            permission.Demand();
                            
                            if (this.machineName != "." && String.Compare(this.machineName, PerformanceCounterLib.ComputerName, true, CultureInfo.InvariantCulture) != 0)
                                throw new InvalidOperationException(SR.GetString(SR.RemoteWriting));                                                    

                            SharedUtils.CheckNtEnvironment();
                                                                                                                
                            if (!PerformanceCounterLib.IsCustomCategory(machineName, categoryName)) 
                                throw new InvalidOperationException(SR.GetString(SR.NotCustomCounter));
                                                                  
                            this.sharedCounter = new SharedPerformanceCounter(categoryName.ToLower(CultureInfo.InvariantCulture), counterName.ToLower(CultureInfo.InvariantCulture), instanceName.ToLower(CultureInfo.InvariantCulture));
                            this.initialized = true;          
                        }                                                                                                                                                                                                                                                                            
                    }                
               }
            }
        }
                                                                                 
         // Will cause an update, raw value
        /// <include file='doc\PerformanceCounter.uex' path='docs/doc[@for="PerformanceCounter.NextSample"]/*' />
        /// <devdoc>
        ///     Obtains a counter sample and returns the raw value for it.
        /// </devdoc>
        public CounterSample NextSample() {                                                   
            Initialize();           
            CategorySample categorySample = PerformanceCounterLib.GetCategorySample(this.machineName , this.categoryName);                            
            try {
                CounterDefinitionSample counterSample = categorySample.GetCounterDefinitionSample(this.counterName);            
                this.counterType = counterSample.CounterType;                        
                if (counterSample.IsSingleInstance) {
                    if (instanceName != null && instanceName.Length != 0)
                        throw new InvalidOperationException(SR.GetString(SR.InstanceNameProhibited, this.instanceName));
    
                    return counterSample.GetSingleValue();                                                                                        
                }
                else {
                    if (instanceName == null || instanceName.Length == 0)
                        throw new InvalidOperationException(SR.GetString(SR.InstanceNameRequired));
                    
                    return counterSample.GetInstanceValue(this.instanceName);                                    
                }    
            }
            finally {
                categorySample.Dispose();
            }                                                                                                                                                                                                                                                                                                                                                                                                     
        }

        /// <include file='doc\PerformanceCounter.uex' path='docs/doc[@for="PerformanceCounter.NextValue"]/*' />
        /// <devdoc>
        ///     Obtains a counter sample and returns the calculated value for it.
        ///     NOTE: For counters whose calculated value depend upon 2 counter reads,
        ///           the very first read will return 0.0.
        /// </devdoc>
        public float NextValue() {
            //No need to initialize, since NextSample already does.
            CounterSample newSample = NextSample();
            float retVal = 0.0f;

            retVal = CounterSample.Calculate(oldSample, newSample);
            oldSample = newSample;

            return retVal;
        }                                                                                                                                                                            
         
        /// <include file='doc\PerformanceCounter.uex' path='docs/doc[@for="PerformanceCounter.RemoveInstance"]/*' />
        /// <devdoc>
        ///     Removes this counter instance from the shared memory
        /// </devdoc>
        public void RemoveInstance() {
            if (ReadOnly)
                throw new InvalidOperationException(SR.GetString(SR.ReadOnlyRemoveInstance));

            Initialize();                                   
            SharedPerformanceCounter.RemoveInstance(this.categoryName.ToLower(CultureInfo.InvariantCulture), this.instanceName.ToLower(CultureInfo.InvariantCulture));
        }                                
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\services\monitoring\system\diagnosticts\instancedatacollection.cs ===
//------------------------------------------------------------------------------
// <copyright file="InstanceDataCollection.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Diagnostics {
    using System;
    using System.Diagnostics;
    using System.Collections;
    using System.Globalization;
    
    /// <include file='doc\InstanceDataCollection.uex' path='docs/doc[@for="InstanceDataCollection"]/*' />
    /// <devdoc>
    ///     A collection containing all the instance data for a counter.  This collection is contained in the 
    ///     <see cref='System.Diagnostics.InstanceDataCollectionCollection'/> when using the 
    ///     <see cref='System.Diagnostics.PerformanceCounterCategory.ReadCategory'/> method.  
    /// </devdoc>    
    public class InstanceDataCollection : DictionaryBase {
        private string counterName;

        /// <include file='doc\InstanceDataCollection.uex' path='docs/doc[@for="InstanceDataCollection.InstanceDataCollection"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public InstanceDataCollection(string counterName) {
            if (counterName == null)
                throw new ArgumentNullException("counterName");
            this.counterName = counterName;
        }

        /// <include file='doc\InstanceDataCollection.uex' path='docs/doc[@for="InstanceDataCollection.CounterName"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public string CounterName {
            get {
                return counterName;
            }
        }

        /// <include file='doc\InstanceDataCollection.uex' path='docs/doc[@for="InstanceDataCollection.Keys"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public ICollection Keys {
            get { return Dictionary.Keys; }
        }

        /// <include file='doc\InstanceDataCollection.uex' path='docs/doc[@for="InstanceDataCollection.Values"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public ICollection Values {
            get {
                return Dictionary.Values;
            }
        }

        /// <include file='doc\InstanceDataCollection.uex' path='docs/doc[@for="InstanceDataCollection.this"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public InstanceData this[string instanceName] {
            get {
                if (instanceName == null)
                    throw new ArgumentNullException("instanceName");
                    
                object objectName = instanceName.ToLower(CultureInfo.InvariantCulture);
                return (InstanceData) Dictionary[objectName];
            }
        }

        internal void Add(string instanceName, InstanceData value) {
            object objectName = instanceName.ToLower(CultureInfo.InvariantCulture); 
            Dictionary.Add(objectName, value);
        }

        /// <include file='doc\InstanceDataCollection.uex' path='docs/doc[@for="InstanceDataCollection.Contains"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public bool Contains(string instanceName) {
            if (instanceName == null)
                    throw new ArgumentNullException("instanceName");
                    
            object objectName = instanceName.ToLower(CultureInfo.InvariantCulture);
            return Dictionary.Contains(objectName);
        }
        
        /// <include file='doc\InstanceDataCollection.uex' path='docs/doc[@for="InstanceDataCollection.CopyTo"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public void CopyTo(InstanceData[] instances, int index) {
            Dictionary.Values.CopyTo((Array)instances, index);
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\services\monitoring\system\diagnosticts\performancecountercategory.cs ===
//------------------------------------------------------------------------------
// <copyright file="PerformanceCounterCategory.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Diagnostics {
    using System.Runtime.Serialization.Formatters;
    using System.ComponentModel;
    using System.Diagnostics;
    using System;    
    using System.Threading;    
    using System.Security;
    using System.Security.Permissions;
    using System.Collections;
    using Microsoft.Win32;    
    using System.Globalization;
    
    /// <include file='doc\PerformanceCounterCategory.uex' path='docs/doc[@for="PerformanceCounterCategory"]/*' />
    /// <devdoc>
    ///     A Performance counter category object.
    /// </devdoc>
    [
    // Disabling partial trust scenarios
    PermissionSet(SecurityAction.LinkDemand, Name="FullTrust")
    ]
    public sealed class PerformanceCounterCategory {
        private string categoryName;
        private string categoryHelp;
        private string machineName;        
        internal const int MaxNameLength = 80;
        internal const int MaxHelpLength = 255;
        private const string perfMutexName = "netfxperf.1.0";

        /// <include file='doc\PerformanceCounterCategory.uex' path='docs/doc[@for="PerformanceCounterCategory.PerformanceCounterCategory"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public PerformanceCounterCategory() {            
            machineName = ".";            
        }

        /// <include file='doc\PerformanceCounterCategory.uex' path='docs/doc[@for="PerformanceCounterCategory.PerformanceCounterCategory1"]/*' />
        /// <devdoc>
        ///     Creates a PerformanceCounterCategory object for given category.
        ///     Uses the local machine.
        /// </devdoc>
        public PerformanceCounterCategory(string categoryName) 
            : this(categoryName, ".") {
        }
        
        /// <include file='doc\PerformanceCounterCategory.uex' path='docs/doc[@for="PerformanceCounterCategory.PerformanceCounterCategory2"]/*' />
        /// <devdoc>
        ///     Creates a PerformanceCounterCategory object for given category.
        ///     Uses the given machine name.
        /// </devdoc>
        public PerformanceCounterCategory(string categoryName, string machineName) {
            if (categoryName == null)
                throw new ArgumentNullException("categoryName");
                
            if (categoryName.Length == 0)
                throw new ArgumentException(SR.GetString(SR.InvalidParameter, "categoryName", categoryName));

            if (!SyntaxCheck.CheckMachineName(machineName))                                                             
                throw new ArgumentException(SR.GetString(SR.InvalidParameter, "machineName", machineName));                                                    

            PerformanceCounterPermission permission = new PerformanceCounterPermission(PerformanceCounterPermissionAccess.Browse, machineName, categoryName);
            permission.Demand();                        
                        
            this.categoryName = categoryName;
            this.machineName = machineName;                        
         }

        /// <include file='doc\PerformanceCounterCategory.uex' path='docs/doc[@for="PerformanceCounterCategory.CategoryName"]/*' />
        /// <devdoc>
        ///     Gets/sets the Category name
        /// </devdoc>
        public string CategoryName {
            get {
                return categoryName;
            }            
            
            set {
                if (value == null)
                    throw new ArgumentNullException("value");
                
                if (value.Length == 0)
                    throw new ArgumentException(SR.GetString(SR.InvalidProperty, "CategoryName", value));
            
                PerformanceCounterPermission permission = new PerformanceCounterPermission(PerformanceCounterPermissionAccess.Browse, machineName, value);
                permission.Demand();        
                                        
                this.categoryName = value;                    
            }
        }
        
        /// <include file='doc\PerformanceCounterCategory.uex' path='docs/doc[@for="PerformanceCounterCategory.CategoryHelp"]/*' />
        /// <devdoc>
        ///     Gets/sets the Category help
        /// </devdoc>
        public string CategoryHelp {
            get {                  
                if (this.categoryName == null)
                    throw new InvalidOperationException(SR.GetString(SR.CategoryNameNotSet));
                          
                if (categoryHelp == null)                                            
                    categoryHelp = PerformanceCounterLib.GetCategoryHelp(this.machineName, this.categoryName);
                                                   
                return categoryHelp;
            }
        }

        /// <include file='doc\PerformanceCounterCategory.uex' path='docs/doc[@for="PerformanceCounterCategory.MachineName"]/*' />
        /// <devdoc>
        ///     Gets/sets the Machine name
        /// </devdoc>
        public string MachineName {
            get {
                return machineName;
            }
            set {
                if (!SyntaxCheck.CheckMachineName(value))                                                             
                    throw new ArgumentException(SR.GetString(SR.InvalidProperty, "MachineName", value));                                        

                if (categoryName != null) {
                    PerformanceCounterPermission permission = new PerformanceCounterPermission(PerformanceCounterPermissionAccess.Browse, value, categoryName);
                    permission.Demand();                            
                }                    
                            
                machineName = value;
            }
        }

        /// <include file='doc\PerformanceCounterCategory.uex' path='docs/doc[@for="PerformanceCounterCategory.CounterExists"]/*' />
        /// <devdoc>
        ///     Returns true if the counter is registered for this category
        /// </devdoc>
        public bool CounterExists(string counterName) {
            if (counterName == null)
                throw new ArgumentNullException("counterName");            

            if (this.categoryName == null)
                    throw new InvalidOperationException(SR.GetString(SR.CategoryNameNotSet));
                                                   
            return PerformanceCounterLib.CounterExists(machineName, categoryName, counterName);
        }
        
        /// <include file='doc\PerformanceCounterCategory.uex' path='docs/doc[@for="PerformanceCounterCategory.CounterExists1"]/*' />
        /// <devdoc>
        ///     Returns true if the counter is registered for this category on the current machine.
        /// </devdoc>
        public static bool CounterExists(string counterName, string categoryName) {
            return CounterExists(counterName, categoryName, ".");
        }

        /// <include file='doc\PerformanceCounterCategory.uex' path='docs/doc[@for="PerformanceCounterCategory.CounterExists2"]/*' />
        /// <devdoc>
        ///     Returns true if the counter is registered for this category on a particular machine.
        /// </devdoc>
        public static bool CounterExists(string counterName, string categoryName, string machineName) {
            if (counterName == null)
                throw new ArgumentNullException("counterName");
                
            if (categoryName == null)
                throw new ArgumentNullException("categoryName");
            
            if (categoryName.Length == 0)
                throw new ArgumentException(SR.GetString(SR.InvalidParameter, "categoryName", categoryName));                                            
                            
            if (!SyntaxCheck.CheckMachineName(machineName))                                                             
                throw new ArgumentException(SR.GetString(SR.InvalidParameter, "machineName", machineName));                

            PerformanceCounterPermission permission = new PerformanceCounterPermission(PerformanceCounterPermissionAccess.Browse,  machineName, categoryName);
            permission.Demand();        
                            
            return PerformanceCounterLib.CounterExists(machineName, categoryName, counterName);                                        
         }
                
        /// <include file='doc\PerformanceCounterCategory.uex' path='docs/doc[@for="PerformanceCounterCategory.Create"]/*' />
        /// <devdoc>
        ///     Registers the extensible performance category with the system on the local machine
        /// </devdoc>
        public static PerformanceCounterCategory Create(string categoryName, string categoryHelp, CounterCreationDataCollection counterData) {            
            return Create(categoryName, categoryHelp, counterData, ".", null);
        }        
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  
        internal static PerformanceCounterCategory Create(string categoryName, string categoryHelp, CounterCreationDataCollection counterData, string machineName, string localizedIniFilePath) {            
            CheckValidCategory(categoryName);
                
            if (!SyntaxCheck.CheckMachineName(machineName))                                                             
                    throw new ArgumentException(SR.GetString(SR.InvalidParameter, "machineName", machineName));
            
            if (machineName != "." && String.Compare(machineName, PerformanceCounterLib.ComputerName, true, CultureInfo.InvariantCulture) != 0) 
                throw new NotSupportedException(SR.GetString(SR.RemoteCounterAdmin));                                     
            
            PerformanceCounterPermission permission = new PerformanceCounterPermission(PerformanceCounterPermissionAccess.Administer,  machineName, categoryName);
            permission.Demand();  

            SharedUtils.CheckNtEnvironment();
                            
            Mutex mutex = SharedUtils.EnterMutex(perfMutexName);
            try {                                                                   
                if (PerformanceCounterLib.IsCustomCategory(machineName, categoryName) || PerformanceCounterLib.CategoryExists(machineName , categoryName))
                    throw new InvalidOperationException(SR.GetString(SR.PerformanceCategoryExists));                   
                                                                                     
                // Ensure that there are no duplicate counter names being created
                Hashtable h = new Hashtable();
                for (int i = 0; i < counterData.Count; i++) {
                    // Ensure that all counter help strings aren't null or empty
                    if (counterData[i].CounterName == null || counterData[i].CounterName.Length == 0) {
                        throw new ArgumentException(SR.GetString(SR.InvalidCounterName));
                    }
    
                    int currentSampleType = (int)counterData[i].CounterType;                                        
                    if (    (currentSampleType  == NativeMethods.PERF_AVERAGE_BULK) ||
                            (currentSampleType  == NativeMethods.PERF_COUNTER_QUEUELEN_TYPE) ||
                            (currentSampleType  == NativeMethods.PERF_COUNTER_LARGE_QUEUELEN_TYPE) ||
                            (currentSampleType  == NativeMethods.PERF_100NSEC_MULTI_TIMER) ||
                            (currentSampleType  == NativeMethods.PERF_100NSEC_MULTI_TIMER_INV) ||
                            (currentSampleType  == NativeMethods.PERF_COUNTER_MULTI_TIMER) ||
                            (currentSampleType  == NativeMethods.PERF_COUNTER_MULTI_TIMER_INV) ||
                            (currentSampleType  == NativeMethods.PERF_RAW_FRACTION) ||
                            (currentSampleType  == NativeMethods.PERF_SAMPLE_FRACTION) ||
                            (currentSampleType  == NativeMethods.PERF_SAMPLE_COUNTER) || 
                            (currentSampleType  == NativeMethods.PERF_AVERAGE_TIMER)) {
                            
                        if (counterData.Count <= (i + 1)) 
                            throw new InvalidOperationException(SR.GetString(SR.CounterLayout));
                        else {
                            currentSampleType = (int)counterData[i + 1].CounterType;                            
                            
                            
                            if (currentSampleType != NativeMethods.PERF_AVERAGE_BASE &&
                                currentSampleType != NativeMethods.PERF_COUNTER_MULTI_BASE &&
                                currentSampleType != NativeMethods.PERF_RAW_BASE  &&
                                currentSampleType != NativeMethods.PERF_SAMPLE_BASE)
                                throw new InvalidOperationException(SR.GetString(SR.CounterLayout));
                        }                                                
                    }                       
                    else if (currentSampleType == NativeMethods.PERF_AVERAGE_BASE ||
                                currentSampleType == NativeMethods.PERF_COUNTER_MULTI_BASE ||
                                currentSampleType == NativeMethods.PERF_RAW_BASE  ||
                                currentSampleType == NativeMethods.PERF_SAMPLE_BASE) {
                                
                        if (i == 0) 
                            throw new InvalidOperationException(SR.GetString(SR.CounterLayout));
                        else {
                            currentSampleType = (int)counterData[i - 1].CounterType;                            
                                                   
                            if (
                            (currentSampleType  != NativeMethods.PERF_AVERAGE_BULK) &&
                            (currentSampleType  != NativeMethods.PERF_COUNTER_QUEUELEN_TYPE) &&
                            (currentSampleType  != NativeMethods.PERF_COUNTER_LARGE_QUEUELEN_TYPE) &&
                            (currentSampleType  != NativeMethods.PERF_100NSEC_MULTI_TIMER) &&
                            (currentSampleType  != NativeMethods.PERF_100NSEC_MULTI_TIMER_INV) &&
                            (currentSampleType  != NativeMethods.PERF_COUNTER_MULTI_TIMER) &&
                            (currentSampleType  != NativeMethods.PERF_COUNTER_MULTI_TIMER_INV) &&
                            (currentSampleType  != NativeMethods.PERF_RAW_FRACTION) &&
                            (currentSampleType  != NativeMethods.PERF_SAMPLE_FRACTION) &&
                            (currentSampleType  != NativeMethods.PERF_SAMPLE_COUNTER) && 
                            (currentSampleType  != NativeMethods.PERF_AVERAGE_TIMER))
                                throw new InvalidOperationException(SR.GetString(SR.CounterLayout));
                        }                            
                                                    
                    }                            
                    
                    if (h.ContainsKey(counterData[i].CounterName)) {
                        throw new ArgumentException(SR.GetString(SR.DuplicateCounterName, counterData[i].CounterName));
                    }
                    else {
                        h.Add(counterData[i].CounterName, String.Empty);
    
                        // Ensure that all counter help strings aren't null or empty
                        if (counterData[i].CounterHelp == null || counterData[i].CounterHelp.Length == 0) {
                            counterData[i].CounterHelp = counterData[i].CounterName + " help";
                        }
                    }
                }
    
                if (localizedIniFilePath == null)               
                    PerformanceCounterLib.RegisterCategory(machineName, categoryName, categoryHelp, counterData);            
                else 
                    PerformanceCounterLib.RegisterCategory(machineName, categoryName, categoryHelp, counterData, localizedIniFilePath);            
                                        
                return new PerformanceCounterCategory(categoryName, machineName);                                                        
            }
            finally {                
                mutex.ReleaseMutex();                    
                mutex.Close();
            }            
        }

        /// <include file='doc\PerformanceCounterCategory.uex' path='docs/doc[@for="PerformanceCounterCategory.Create2"]/*' />
        /// <devdoc>
        ///     Registers one extensible performance category of type NumberOfItems32 with the system
        /// </devdoc>
        public static PerformanceCounterCategory Create(string categoryName, string categoryHelp, string counterName, string counterHelp) {
            CounterCreationData customData = new CounterCreationData(counterName, categoryHelp, PerformanceCounterType.NumberOfItems32);
            return Create(categoryName, categoryHelp, new CounterCreationDataCollection(new CounterCreationData [] {customData}), ".", null);            
        }
        
        internal static void CheckValidCategory(string categoryName) {
            if (categoryName == null)
                throw new ArgumentNullException("categoryName");

            if (!CheckValidId(categoryName))
                throw new ArgumentException(SR.GetString(SR.PerfInvalidCategoryName, 1, MaxNameLength));                                                                                
        }                                                                                         

        internal static void CheckValidCounter(string counterName) {
            if (counterName == null)
                throw new ArgumentNullException("counterName");

            if (!CheckValidId(counterName))
                throw new ArgumentException(SR.GetString(SR.PerfInvalidCounterName, 1, MaxNameLength));                                                                                
        } 
         
        internal static bool CheckValidId(string id) {
            if (id.Length == 0 || id.Length > MaxNameLength)
                return false;
                
            for (int index = 0; index < id.Length; ++index) {
                char current = id[index];
                
                if ((index == 0 || index == (id.Length -1)) && current == ' ')
                    return false;
                    
                if (current == '\"')
                    return false;                    
                
                if (char.IsControl(current))
                    return false;                    
            }
                        
            return true;
        }
                 
        internal static void CheckValidHelp(string help) {
            if (help == null)
                throw new ArgumentNullException("help");

            if (help.Length > MaxHelpLength)
                throw new ArgumentException(SR.GetString(SR.PerfInvalidHelp, 0, MaxHelpLength));                                                    
        }         
                                                                                         
        /// <include file='doc\PerformanceCounterCategory.uex' path='docs/doc[@for="PerformanceCounterCategory.Delete"]/*' />
        /// <devdoc>
        ///     Removes the counter (category) from the system
        /// </devdoc>
        public static void Delete(string categoryName) {
            DeleteCategory(categoryName, ".");
        }
        
        private static void DeleteCategory(string categoryName, string machineName) {
            CheckValidCategory(categoryName);                            

            if (machineName != "." && String.Compare(machineName, PerformanceCounterLib.ComputerName, true, CultureInfo.InvariantCulture) != 0) 
                throw new NotSupportedException(SR.GetString(SR.RemoteCounterAdmin));                 

            if (!SyntaxCheck.CheckMachineName(machineName))                                                             
                    throw new ArgumentException(SR.GetString(SR.InvalidParameter, "machineName", machineName));
            
            PerformanceCounterPermission permission = new PerformanceCounterPermission(PerformanceCounterPermissionAccess.Administer,  machineName, categoryName);
            permission.Demand();                

            SharedUtils.CheckNtEnvironment();

            Mutex mutex = SharedUtils.EnterMutex(perfMutexName);
            try {                                                                                     
                if (!PerformanceCounterLib.IsCustomCategory(machineName, categoryName))
                    throw new InvalidOperationException(SR.GetString(SR.CantDeleteCategory));
                                                
                PerformanceCounterLib.UnregisterCategory(machineName, categoryName);                                                                                   
            }
            finally {                
                mutex.ReleaseMutex();                    
                mutex.Close();
            }                
        }

        /// <include file='doc\PerformanceCounterCategory.uex' path='docs/doc[@for="PerformanceCounterCategory.Exists"]/*' />
        /// <devdoc>
        ///     Returns true if the category is registered on the current machine.
        /// </devdoc>
        public static bool Exists(string categoryName) {
            return Exists(categoryName, ".");
        }

        /// <include file='doc\PerformanceCounterCategory.uex' path='docs/doc[@for="PerformanceCounterCategory.Exists1"]/*' />
        /// <devdoc>
        ///     Returns true if the category is registered in the machine.
        /// </devdoc>
        public static bool Exists(string categoryName, string machineName) {
            if (categoryName == null)
                throw new ArgumentNullException("categoryName");

            if (categoryName.Length == 0)
                throw new ArgumentException(SR.GetString(SR.InvalidParameter, "categoryName", categoryName));                                
            
            if (!SyntaxCheck.CheckMachineName(machineName))                                                             
                    throw new ArgumentException(SR.GetString(SR.InvalidParameter, "machineName", machineName));

            PerformanceCounterPermission permission = new PerformanceCounterPermission(PerformanceCounterPermissionAccess.Browse,  machineName, categoryName);
            permission.Demand();        
                        
            if (PerformanceCounterLib.IsCustomCategory(machineName , categoryName)) 
                return true;                                       
                                    
            return PerformanceCounterLib.CategoryExists(machineName , categoryName);            
        }
        
        /// <include file='doc\PerformanceCounterCategory.uex' path='docs/doc[@for="PerformanceCounterCategory.GetCounterInstances"]/*' />
        /// <devdoc>
        ///     Returns the instance names for a given category
        /// </devdoc>
        /// <internalonly/>
        internal static string[] GetCounterInstances(string categoryName, string machineName) {
            if (categoryName == null)
                throw new ArgumentNullException("categoryName");
            
            if (categoryName.Length == 0)
                throw new ArgumentException(SR.GetString(SR.InvalidParameter, "categoryName", categoryName));                                
                                                                
            if (!SyntaxCheck.CheckMachineName(machineName))                                                             
                throw new ArgumentException(SR.GetString(SR.InvalidParameter, "machineName", machineName));
                                        
            PerformanceCounterPermission permission = new PerformanceCounterPermission(PerformanceCounterPermissionAccess.Browse, machineName, categoryName);
            permission.Demand();                                                
                                                                            
            CategorySample categorySample = PerformanceCounterLib.GetCategorySample(machineName, categoryName); 
            try {                           
                if (categorySample.InstanceNameTable.Count == 0)
                    throw new InvalidOperationException(SR.GetString(SR.NoInstanceInformation, categoryName));
                    
                string[] instanceNames = new string[categorySample.InstanceNameTable.Count];
                categorySample.InstanceNameTable.Keys.CopyTo(instanceNames, 0); 
                if (instanceNames.Length == 1 && instanceNames[0].CompareTo(PerformanceCounterLib.SingleInstanceName) == 0)
                    return new string[0];                               
                    
                return instanceNames;            
            }
            finally {
                categorySample.Dispose();
            }
        }                                                                      
                                                                      
        /// <include file='doc\PerformanceCounterCategory.uex' path='docs/doc[@for="PerformanceCounterCategory.GetCounters"]/*' />
        /// <devdoc>
        ///     Returns an array of counters in this category.  The counter must have only one instance.
        /// </devdoc>
        public PerformanceCounter[] GetCounters() {                                    
            if (GetInstanceNames().Length != 0)
                throw new ArgumentException(SR.GetString(SR.InstanceNameRequired));
            return GetCounters("");
        }

        /// <include file='doc\PerformanceCounterCategory.uex' path='docs/doc[@for="PerformanceCounterCategory.GetCounters1"]/*' />
        /// <devdoc>
        ///     Returns an array of counters in this category for the given instance.
        /// </devdoc>
        public PerformanceCounter[] GetCounters(string instanceName) {
            if (instanceName == null)
                throw new ArgumentNullException("instanceName");

            if (this.categoryName == null)
                throw new InvalidOperationException(SR.GetString(SR.CategoryNameNotSet));
                                
            if (instanceName.Length != 0 && !InstanceExists(instanceName))
                throw new InvalidOperationException(SR.GetString(SR.MissingInstance, instanceName, categoryName));            
                
            string[] counterNames = PerformanceCounterLib.GetCounters(machineName, categoryName);
            PerformanceCounter[] counters = new PerformanceCounter[counterNames.Length];
            for (int index = 0; index < counters.Length; index++) 
                counters[index] = new PerformanceCounter(categoryName, counterNames[index], instanceName, machineName, true);

            return counters;
        }

        
        /// <include file='doc\PerformanceCounterCategory.uex' path='docs/doc[@for="PerformanceCounterCategory.GetCategories"]/*' />
        /// <devdoc>
        ///     Returns an array of performance counter categories for the current machine.
        /// </devdoc>
        public static PerformanceCounterCategory[] GetCategories() {
            return GetCategories(".");
        }
        
        /// <include file='doc\PerformanceCounterCategory.uex' path='docs/doc[@for="PerformanceCounterCategory.GetCategories1"]/*' />
        /// <devdoc>
        ///     Returns an array of performance counter categories for a particular machine.
        /// </devdoc>
        public static PerformanceCounterCategory[] GetCategories(string machineName) {
            if (!SyntaxCheck.CheckMachineName(machineName))                                                             
                    throw new ArgumentException(SR.GetString(SR.InvalidParameter, "machineName", machineName));

            PerformanceCounterPermission permission = new PerformanceCounterPermission(PerformanceCounterPermissionAccess.Browse, machineName, "*");
            permission.Demand();        
                                                              
            string[] categoryNames = PerformanceCounterLib.GetCategories(machineName);                
            PerformanceCounterCategory[] categories = new PerformanceCounterCategory[categoryNames.Length];
            for (int index = 0; index < categories.Length; index++) 
                categories[index] = new PerformanceCounterCategory(categoryNames[index], machineName);
            
            return categories;
        }

        /// <include file='doc\PerformanceCounterCategory.uex' path='docs/doc[@for="PerformanceCounterCategory.GetInstanceNames"]/*' />
        /// <devdoc>
        ///     Returns an array of instances for this category
        /// </devdoc>
        public string[] GetInstanceNames() {
            if (this.categoryName == null)
                    throw new InvalidOperationException(SR.GetString(SR.CategoryNameNotSet));
                    
            return GetCounterInstances(categoryName, machineName);
        }      

        /// <include file='doc\PerformanceCounterCategory.uex' path='docs/doc[@for="PerformanceCounterCategory.InstanceExists"]/*' />
        /// <devdoc>
        ///     Returns true if the instance already exists for this category.  
        /// </devdoc>
        public bool InstanceExists(string instanceName) {
            if (instanceName == null)
                throw new ArgumentNullException("instanceName");
              
            if (this.categoryName == null)
                    throw new InvalidOperationException(SR.GetString(SR.CategoryNameNotSet));
                                                                                                                                    
            CategorySample categorySample = PerformanceCounterLib.GetCategorySample(machineName, categoryName);        
            try {    
                IEnumerator valueEnum = categorySample.CounterTable.Values.GetEnumerator();
                return categorySample.InstanceNameTable.ContainsKey(instanceName);                
            }
            finally {
                categorySample.Dispose();
            }
        }        

        /// <include file='doc\PerformanceCounterCategory.uex' path='docs/doc[@for="PerformanceCounterCategory.InstanceExists1"]/*' />
        /// <devdoc>
        ///     Returns true if the instance already exists for the category specified.
        /// </devdoc>                      
        public static bool InstanceExists(string instanceName, string categoryName) {                            
            return InstanceExists(instanceName, categoryName, ".");
        }
        
        /// <include file='doc\PerformanceCounterCategory.uex' path='docs/doc[@for="PerformanceCounterCategory.InstanceExists2"]/*' />
        /// <devdoc>
        ///     Returns true if the instance already exists for this category and machine specified.  
        /// </devdoc>                      
        public static bool InstanceExists(string instanceName, string categoryName, string machineName) {
            if (instanceName == null)
                throw new ArgumentNullException("instanceName");

            if (categoryName == null)
                throw new ArgumentNullException("categoryName");
                
            if (categoryName.Length == 0)
                throw new ArgumentException(SR.GetString(SR.InvalidParameter, "categoryName", categoryName));                     
                                                                        
            if (!SyntaxCheck.CheckMachineName(machineName))                                                             
                throw new ArgumentException(SR.GetString(SR.InvalidParameter, "machineName", machineName));                
                
            PerformanceCounterCategory category = new PerformanceCounterCategory(categoryName, machineName);
            return category.InstanceExists(instanceName);
        }

        /// <include file='doc\PerformanceCounterCategory.uex' path='docs/doc[@for="PerformanceCounterCategory.ReadCategory"]/*' />
        /// <devdoc>
        ///     Reads all the counter and instance data of this performance category.  Note that reading the entire category
        ///     at once can be as efficient as reading a single counter because of the way the system provides the data.
        /// </devdoc>
        public InstanceDataCollectionCollection ReadCategory() {                         
            if (this.categoryName == null)
                    throw new InvalidOperationException(SR.GetString(SR.CategoryNameNotSet));
                    
            CategorySample categorySample = PerformanceCounterLib.GetCategorySample(this.machineName, this.categoryName);
            try {
                return categorySample.ReadCategory();                
            }                
            finally {
                categorySample.Dispose();
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\services\monitoring\system\diagnosticts\performancecountermanager.cs ===
//------------------------------------------------------------------------------
// <copyright file="PerformanceCounterManager.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Diagnostics {
    using System.Runtime.Serialization.Formatters;
    using System.Runtime.InteropServices;    
    using System;    
    using System.ComponentModel;    
    using System.Threading;    
    using System.Security.Permissions;    
    using System.Security;
    using System.IO;
    using System.Text;
    using System.Collections;
    using Microsoft.Win32;
    using System.Globalization;
    

    //
    // PerfCounterManager the COM Object, responsible for preparing the performance data for
    // the Performance Counter perf dll.
    //
    // This class is designed to be packaged with a COM DLL output format.
    // The class has no standard entry points, other than the constructor.
    // Public methods will be exposed as methods on the default COM interface.
    // @com.register ( clsid=82840BE1-D273-11D2-B94A-00600893B17A)
    //

    /// <include file='doc\PerformanceCounterManager.uex' path='docs/doc[@for="PerformanceCounterManager"]/*' />
    /// <internalonly/>
    [
    ComVisible(true), GuidAttribute("82840BE1-D273-11D2-B94A-00600893B17A"),
    // Disabling partial trust scenarios
    PermissionSet(SecurityAction.LinkDemand, Name="FullTrust")
    ]
    public sealed class PerformanceCounterManager : ICollectData
    {
        private const int MAX_SIZEOF_INSTANCE_NAME  = 32;

        //This flag is internal static; For performance reasons in order to avoid 
        //reloading all the perf counter libraries after creating or deleting a new 
        //performance counter category.
        //First important fact is that only one instance of this class will exists
        //in any given process.        
        internal static bool FirstEntry = true;
        private bool initError = false;
        private bool closed = false;
        private static long perfFrequency;
        private int[] queryIds;
        private int queryIndex;
        private string previousQuery;

        // lookup structures
        private Hashtable perfObjects; // KEY:object name | VAL:ObjectData        
        
        /// <include file='doc\PerformanceCounterManager.uex' path='docs/doc[@for="PerformanceCounterManager.PerformanceCounterManager"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public PerformanceCounterManager() {              
        }
        
        /// <include file='doc\PerformanceCounterManager.uex' path='docs/doc[@for="PerformanceCounterManager.ICollectData.CollectData"]/*' />
        /// <internalonly/>
        /// <devdoc>
        /// Performance data collection routine. Called by the PerfCount perf dll.
        /// </devdoc>
        void ICollectData.CollectData(int callIdx, IntPtr valueNamePtr, IntPtr dataPtr, int totalBytes, out IntPtr res) {                                          
            if (closed) 
                res = (IntPtr)(-1);
            else {
                //If the code in the callstack above has no UnmanagedCode access rights, 
                //just bail out.
                try {
                    new SecurityPermission(SecurityPermissionFlag.UnmanagedCode).Demand();
                }
                catch(Exception) {                    
                    res = (IntPtr)(-1);                    
                    return;
                } 
                
                try {                                        
                    Initialize();                    
                    if (initError) 
                        res = (IntPtr)(-1);
                    else {                        
                        string requestedItems = Marshal.PtrToStringAuto(valueNamePtr);                                                                        
                        int id = GetCurrentQueryId(requestedItems);                        
                        if (id == 0) 
                            res = dataPtr;
                        else {                            
                            if (GetSpaceRequired(id) > totalBytes) 
                                res = (IntPtr)(-2);
                            else {                                           
                                res = CreateDataForObject(id, dataPtr);                                                               
                            }                                
                        }                            
                    }                     
                }
                catch (Exception) {                
                    res = (IntPtr)(-1);                    
                    initError = true;
                    FirstEntry = false;
                }
            }                                     
        }

        /// <include file='doc\PerformanceCounterManager.uex' path='docs/doc[@for="PerformanceCounterManager.CreateDataForObject"]/*' />
        /// <devdoc>
        ///     Prepares data for a single performance object (category)
        /// </devdoc>
        /// <internalonly/>
        private IntPtr CreateDataForObject(int objId, IntPtr ptr) {            
            IntPtr startPtr = ptr;
            int numInstances = NativeMethods.PERF_NO_INSTANCES;

            ObjectData data = (ObjectData) perfObjects[objId];

            // Init the PerfObjectType later, just skip over it for now.
            ptr = (IntPtr)((long)ptr + Marshal.SizeOf(typeof(NativeMethods.PERF_OBJECT_TYPE)));

            // Start the counter offset at 4 to skip over the counter block size
            int nextCounterOffset = 4;
            for (int i = 0; i < data.CounterNameHashCodes.Length; i++) {            
                nextCounterOffset += InitCounterDefinition(ptr, i, data, nextCounterOffset);
                ptr = (IntPtr)((long)ptr + Marshal.SizeOf(typeof(NativeMethods.PERF_COUNTER_DEFINITION)));
            }
            // now ptr points at the begining of the instances block or counter block (for global counter)
            string[] instanceNames = SharedPerformanceCounter.GetInstanceNames(data.CategoryNameHashCode, data.CategoryName);
            if (instanceNames.Length == 0) {
                ptr = InitCounterData(ptr, SharedPerformanceCounter.SingleInstanceHashCode, SharedPerformanceCounter.SingleInstanceName, data);
            } 
            else {
                
                for (int index = 0; index < instanceNames.Length; ++index) {                    
                    ptr = InitInstanceDefinition(ptr, 0, 0, NativeMethods.PERF_NO_UNIQUE_ID, instanceNames[index]);
                    string instanceName = instanceNames[index].ToLower(CultureInfo.InvariantCulture); 
                    ptr = InitCounterData(ptr, instanceName.GetHashCode(), instanceName, data);
                }

                // update instance count
                numInstances = instanceNames.Length;
            }
            // update arguments for return
            InitPerfObjectType(startPtr, data, numInstances, (int)((long)ptr - (long)startPtr));

            return ptr;
        }


        /// <include file='doc\PerformanceCounterManager.uex' path='docs/doc[@for="PerformanceCounterManager.ICollectData.CloseData"]/*' />
        /// <internalonly/>
        /// <devdoc>
        /// Called by the perf dll's close performance data
        /// </devdoc>
        void ICollectData.CloseData() {            
            try {
                GC.Collect();                
            }
            catch(Exception) {
            } 
                            
            FirstEntry = true;
            this.closed = true;                      
        }

        private static long GetFrequency() {
            if (perfFrequency == 0) {
                SafeNativeMethods.QueryPerformanceFrequency(out perfFrequency);
            }
            
            return perfFrequency;
        }
        
        private static long GetCurrentPerfTime() {
            long perfTime = 0;
            SafeNativeMethods.QueryPerformanceCounter(out perfTime);
            return perfTime;
        }
        
        private int GetCurrentQueryId(string query) {
            if (query != previousQuery) {
                previousQuery = query;
                this.queryIds = null;
            }
            
            if (this.queryIds == null) {
                this.queryIds = GetObjectIds(query);
                if (this.queryIds == null)
                    return 0;
                    
                this.queryIndex = 0;
            }
                        
            int result = this.queryIds[queryIndex];
            ++this.queryIndex;
            if (this.queryIndex == this.queryIds.Length)
                this.queryIds = null;
                
            return result;                
        }        
        
        private int[] GetObjectIds(string query) {            
            if (perfObjects == null) 
                return null;

            int[] ids;                
            if (query == "Global") {                
                ids = new int[perfObjects.Count];
                perfObjects.Keys.CopyTo(ids, 0);                                                
            }                
            else {            
                string[] idStrings = query.Split(' ');  
                ArrayList idList = new ArrayList();
                
                for (int index = 0; index < idStrings.Length; ++ index) {                                        
                    try {
                        int currentId = Int32.Parse(idStrings[index]);
                        if (perfObjects.ContainsKey(currentId)) 
                            idList.Add(currentId);
                    }                        
                    catch(Exception) {
                    }
                }                                 
            
                ids = (int[])idList.ToArray(typeof(int));                                                     
            }
            
            if (ids.Length == 0)
                return null;
                
            return ids;                
        }
                
                
        /// <include file='doc\PerformanceCounterManager.uex' path='docs/doc[@for="PerformanceCounterManager.SpaceRequired"]/*' />
        /// <devdoc>
        ///     Returns a size in bytes of the space required to pass all requested
        ///     performance data
        /// </devdoc>
        /// <internalonly/>
        private int GetSpaceRequired(int objectId) {
            int totalSize = 0;                                                            
            ObjectData data = (ObjectData) perfObjects[objectId];
            int numberOfInstances = SharedPerformanceCounter.GetNumberOfInstances(data.CategoryNameHashCode, data.CategoryName);
            totalSize += Marshal.SizeOf(typeof(NativeMethods.PERF_OBJECT_TYPE));
            totalSize += (data.CounterNameHashCodes.Length * Marshal.SizeOf(typeof(NativeMethods.PERF_COUNTER_DEFINITION)));
            if (numberOfInstances == 0) {
                totalSize+=(data.CounterNameHashCodes.Length * NativeMethods.LARGE_INTEGER_SIZE) + NativeMethods.DWORD_SIZE;
            } else {
                int instanceSize = Marshal.SizeOf(typeof(NativeMethods.PERF_INSTANCE_DEFINITION)) + 2*(MAX_SIZEOF_INSTANCE_NAME+1)
                                    + (data.CounterNameHashCodes.Length * NativeMethods.LARGE_INTEGER_SIZE) + NativeMethods.DWORD_SIZE;

                totalSize+= numberOfInstances * instanceSize;
            }
            
            return totalSize;
        }

                              
        /// <include file='doc\PerformanceCounterManager.uex' path='docs/doc[@for="PerformanceCounterManager.InitPerfObjectType"]/*' />
        /// <devdoc>
        ///     Initializes the PERF_OBJECT_TYPE structure
        /// </devdoc>
        /// <internalonly/>
        private static void InitPerfObjectType(IntPtr ptr, ObjectData data, int numInstances, int totalByteLength) {
            NativeMethods.PERF_OBJECT_TYPE perfObjType = (NativeMethods.PERF_OBJECT_TYPE) new NativeMethods.PERF_OBJECT_TYPE();

            perfObjType.TotalByteLength = totalByteLength;
            perfObjType.DefinitionLength = Marshal.SizeOf(typeof(NativeMethods.PERF_OBJECT_TYPE)) + data.CounterNameHashCodes.Length *
                                           Marshal.SizeOf(typeof(NativeMethods.PERF_COUNTER_DEFINITION));
            perfObjType.HeaderLength = Marshal.SizeOf(typeof(NativeMethods.PERF_OBJECT_TYPE));
            perfObjType.ObjectNameTitleIndex = data.FirstCounterId;
            perfObjType.ObjectNameTitlePtr = 0;
            perfObjType.ObjectHelpTitleIndex = data.FirstHelpId;
            perfObjType.ObjectHelpTitlePtr = 0;
            perfObjType.DetailLevel = NativeMethods.PERF_DETAIL_NOVICE;
            perfObjType.NumCounters = data.CounterNameHashCodes.Length;
            perfObjType.DefaultCounter = 0;
            perfObjType.NumInstances = numInstances;
            perfObjType.CodePage = 0;                                
            perfObjType.PerfTime = GetCurrentPerfTime();
            perfObjType.PerfFreq =  GetFrequency();                              
            Marshal.StructureToPtr(perfObjType, ptr, false);
        }

        /// <include file='doc\PerformanceCounterManager.uex' path='docs/doc[@for="PerformanceCounterManager.InitCounterDefinition"]/*' />
        /// <devdoc>
        ///     Initializes the PERF_COUNTER_DEFINITION structure
        /// </devdoc>
        /// <internalonly/>
        private static int InitCounterDefinition(IntPtr ptr, int counterIndex, ObjectData data, int nextCounterOffset) {
            NativeMethods.PERF_COUNTER_DEFINITION perfCounter = new NativeMethods.PERF_COUNTER_DEFINITION();
            perfCounter.ByteLength = Marshal.SizeOf(typeof(NativeMethods.PERF_COUNTER_DEFINITION));
            perfCounter.CounterNameTitleIndex = data.FirstCounterId + 2 + counterIndex * 2;
            perfCounter.CounterNameTitlePtr = 0;
            perfCounter.CounterHelpTitleIndex = data.FirstHelpId + 2 + counterIndex * 2;
            perfCounter.CounterHelpTitlePtr = 0;
            perfCounter.DefaultScale = 0;
            perfCounter.DetailLevel = NativeMethods.PERF_DETAIL_NOVICE;

            int counterType = data.CounterTypes[counterIndex];
            perfCounter.CounterType = counterType;

            if (((counterType & NativeMethods.PERF_SIZE_LARGE) != 0) || (counterType == NativeMethods.PERF_AVERAGE_TIMER)) {
                perfCounter.CounterSize = NativeMethods.LARGE_INTEGER_SIZE;
            }
            else { // Since we only support two counter sizes, if it's not an Int64, must be an Int32.
                perfCounter.CounterSize = NativeMethods.DWORD_SIZE;
            }

            perfCounter.CounterOffset = nextCounterOffset;
            int retVal = perfCounter.CounterSize;

            Marshal.StructureToPtr(perfCounter, ptr, false);

            return retVal;
        }


        /// <include file='doc\PerformanceCounterManager.uex' path='docs/doc[@for="PerformanceCounterManager.InitCounterData"]/*' />
        /// <devdoc>
        ///     Initializes the PERF_OBJECT_TYPE structure
        /// </devdoc>
        /// <internalonly/>
        private static IntPtr InitCounterData(IntPtr ptr, int instanceNameHashCode, string instanceName, ObjectData data) {
            NativeMethods.PERF_COUNTER_BLOCK counterBlock = new NativeMethods.PERF_COUNTER_BLOCK();
            IntPtr startPtr = ptr;
            ptr = (IntPtr)((long)ptr + Marshal.SizeOf(typeof(NativeMethods.PERF_COUNTER_BLOCK)));
            for (int index = 0; index < data.CounterNameHashCodes.Length; ++index) {
                long counterValue = SharedPerformanceCounter.GetCounterValue(data.CategoryNameHashCode, data.CategoryName,
                                                                                                          data.CounterNameHashCodes[index], data.CounterNames[index], 
                                                                                                          instanceNameHashCode, instanceName);
                if (((data.CounterTypes[index] & NativeMethods.PERF_SIZE_LARGE) != 0) || (data.CounterTypes[index] == NativeMethods.PERF_AVERAGE_TIMER)) {
                    LARGE_COUNTER_DATA counterData = new LARGE_COUNTER_DATA();
                    counterData.value = counterValue;
                    Marshal.StructureToPtr(counterData, ptr, false);
                    ptr = (IntPtr)((long)ptr + Marshal.SizeOf(typeof(LARGE_COUNTER_DATA)));                        
                }
                else { // Must be DWORD size
                    DWORD_COUNTER_DATA counterData = new DWORD_COUNTER_DATA();
                    counterData.value = (int) counterValue;
                    Marshal.StructureToPtr(counterData, ptr, false);
                    ptr = (IntPtr)((long)ptr + Marshal.SizeOf(typeof(DWORD_COUNTER_DATA)));
                }
            }

            // Make sure our data block is 8-byte aligned.
            int diff = ((int)((long)ptr - (long)startPtr) % 8);

            // Null out block (because our data is either 32 or 64 bits, at most we'll need to zero out 4 bytes).
            if (diff != 0) {                
                Marshal.WriteInt32(ptr, 0);
                ptr = (IntPtr)((long)ptr + 4);
            } 
            
            counterBlock.ByteLength = (int)((long)ptr - (long)startPtr);            
            Marshal.StructureToPtr(counterBlock, startPtr, false);
            return ptr;
        }      

        /// <include file='doc\PerformanceCounterManager.uex' path='docs/doc[@for="PerformanceCounterManager.InitInstanceDefinition"]/*' />
        /// <devdoc>
        ///     Initializes the PERF_INSTANCE_DEFINITION structure
        /// </devdoc>
        /// <internalonly/>
        private IntPtr InitInstanceDefinition(IntPtr ptr, int parentObjectTitleIndex,
                                            int parentObjectInstance, int uniqueID, string name) {
            NativeMethods.PERF_INSTANCE_DEFINITION inst = new NativeMethods.PERF_INSTANCE_DEFINITION();
            IntPtr startPtr = ptr;

            int nameLengthInBytes = (name.Length + 1) * 2;  //Unicode

            inst.ParentObjectTitleIndex = parentObjectTitleIndex;
            inst.ParentObjectInstance = parentObjectInstance;
            inst.UniqueID = uniqueID;
            inst.NameOffset = Marshal.SizeOf(typeof(NativeMethods.PERF_INSTANCE_DEFINITION));
            inst.NameLength = nameLengthInBytes;

            // 8 byte alignment
            int diff = 8 - ((inst.NameOffset + nameLengthInBytes) % 8);

            inst.ByteLength = inst.NameOffset + nameLengthInBytes + diff;

            // Write instance definition to unmanaged memory
            Marshal.StructureToPtr(inst, startPtr, false);

            //deal with the instance name

            // Length is the length of the string, plus null, plus the padding needed
            int length = name.Length + 1 + (diff / 2);
            char[] nameChars = new char[length];
            name.CopyTo(0, nameChars, 0, name.Length);
            Marshal.Copy(nameChars, 0, (IntPtr)((long)ptr + Marshal.SizeOf(typeof(NativeMethods.PERF_INSTANCE_DEFINITION))), length);                                          
            return (IntPtr)((long)ptr + inst.ByteLength);
        }

        /// <include file='doc\PerformanceCounterManager.uex' path='docs/doc[@for="PerformanceCounterManager.Initialize"]/*' />
        /// <devdoc>
        ///     Initializes perf com dll internal tables
        /// </devdoc>
        /// <internalonly/>
        private void Initialize() {
            if (FirstEntry) {
                lock(this) {      
                    if (FirstEntry) {
                        RegistryKey parentKey = null;                        
                        perfObjects = new Hashtable(); 
                        //SECREVIEW: This is being loaded by NT, it is executed
                        //                         when perfmon collects the data for all the
                        //                         registered counters.
                        RegistryPermission registryPermission = new RegistryPermission(PermissionState.Unrestricted);
                        registryPermission.Assert();
                        try {          
                            parentKey = Registry.LocalMachine.OpenSubKey("SYSTEM\\CurrentControlSet\\Services");
                            if (parentKey == null) 
                                return;
                            
                            string[] categoryNames = parentKey.GetSubKeyNames();
                            for (int i = 0; i < categoryNames.Length; i++) {                                                                                                                                                                                                        
                                try {                                                                       
                                    RegistryKey currentKey = parentKey.OpenSubKey(categoryNames[i] + "\\Performance");                                    
                                    if (currentKey == null) 
                                        continue;
                                                                                                     
                                    object systemDllName = currentKey.GetValue("Library");                                            
                                    if (systemDllName == null || !(systemDllName is string) || String.Compare((string)systemDllName, PerformanceCounterLib.PerfShimName, true, CultureInfo.InvariantCulture) != 0)
                                        continue;
                                                                                                            
                                    object openEntryPoint = currentKey.GetValue("Open");
                                    if (openEntryPoint == null || !(openEntryPoint is string) || (string)openEntryPoint != PerformanceCounterLib.OpenEntryPoint) 
                                        continue;
                                    
                                    object collectEntryPoint = currentKey.GetValue("Collect");
                                    if (collectEntryPoint == null || !(collectEntryPoint is string) || (string)collectEntryPoint != PerformanceCounterLib.CollectEntryPoint) 
                                        continue;
                                    
                                    object closeEntryPoint = currentKey.GetValue("Close");
                                    if (closeEntryPoint == null || !(closeEntryPoint is string) || (string)closeEntryPoint != PerformanceCounterLib.CloseEntryPoint) 
                                        continue;
                                                                        
                                    object counterDisabled = currentKey.GetValue("Disable Performance Counters");                                            
                                    if (counterDisabled != null &&  (int)counterDisabled != 0)
                                        continue;
                                    
                                    object firstCounterId = currentKey.GetValue("First Counter");                                            
                                    if (firstCounterId == null)
                                        continue;
                                    
                                    object lastCounterId = currentKey.GetValue("Last Counter");                                            
                                    if (lastCounterId == null)
                                        continue;

                                    object firstHelpId = currentKey.GetValue("First Help");                                            
                                    if (firstHelpId == null)
                                        continue;
                                                                                                                                                                                                                                                                        
                                    object countersData = currentKey.GetValue("Counter Types");                                    
                                    int[] counterTypes = null;
                                    if (countersData == null) 
                                        counterTypes = new int[0];                                            
                                    else {                                                                                
                                        string[] counterStrs;
                                        if (countersData is string[]) 
                                            counterStrs = (string[])countersData;
                                        else if (countersData is byte[]) 
                                            counterStrs = PerformanceCounterLib.GetStrings((byte[])countersData);
                                        else
                                            counterStrs = new string[0];                                                                                                                                   
                                                                                                                                                                                                                                                                                                                                                    
                                        counterTypes = new int[counterStrs.Length];
                                        for (int index = 0; index < counterTypes.Length; index++) 
                                            counterTypes[index] = Int32.Parse(counterStrs[index]);                                                                                            
                                    }
                                        
                                    countersData = currentKey.GetValue("Counter Names");
                                    int[] counterNameHashCodes = null;
                                    string[] counterNames = null;
                                    if (countersData == null) { 
                                        counterNameHashCodes = new int[0];                                            
                                        counterNames = new string[0];
                                    }                                                
                                    else {
                                        string[] counterStrs;
                                        if (countersData is string[]) 
                                            counterStrs = (string[])countersData;
                                        else if (countersData is byte[]) 
                                            counterStrs = PerformanceCounterLib.GetStrings((byte[])countersData);
                                        else
                                            counterStrs = new string[0];                                                                                                                                   
                                            
                                        counterNameHashCodes = new int[counterStrs.Length];
                                        counterNames = new string[counterStrs.Length];
                                        for (int index = 0; index < counterTypes.Length; index++) {                                            
                                            counterNames[index] = counterStrs[index].ToLower(CultureInfo.InvariantCulture);                                                                                                    
                                            counterNameHashCodes[index] = counterNames[index].GetHashCode();
                                        }                                                    
                                    }
                                                                                                                                                                                         
                                    if ((int)firstCounterId != -1 && (int)firstHelpId != -1) {
                                        ObjectData data = new ObjectData();                                                                                                        
                                        data.CategoryName = categoryNames[i].ToLower(CultureInfo.InvariantCulture);
                                        data.CategoryNameHashCode = data.CategoryName.GetHashCode();
                                        data.CounterTypes = counterTypes;
                                        data.CounterNames = counterNames;
                                        data.CounterNameHashCodes = counterNameHashCodes;
                                        data.FirstCounterId = (int)firstCounterId; 
                                        data.FirstHelpId = (int)firstHelpId;                                                                                      
                                        perfObjects.Add((int)firstCounterId, data);                                                        
                                    }                                                                                                                                                                                            
                                }
                                catch(Exception) {                                    
                                }                                                                                                                                                                                                                 
                            }                            
                        }                    
                        finally {
                            if (parentKey != null)
                                parentKey.Close();               
                                
                            RegistryPermission.RevertAssert();                                                        
                        }
                        
                        FirstEntry = false;      
                    }            
                }                    
            }                   
        }
                                                
        [StructLayout(LayoutKind.Sequential)]
        internal class LARGE_COUNTER_DATA {
            public long value;
        }

        [StructLayout(LayoutKind.Sequential)]
        internal class DWORD_COUNTER_DATA {
            public int value;
        }

        internal struct ObjectData {
            internal int[] CounterTypes;
            internal int[] CounterNameHashCodes;            
            internal string[] CounterNames;
            internal int CategoryNameHashCode;
            internal string CategoryName;
            internal int FirstCounterId;
            internal int FirstHelpId;
        }                
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\services\monitoring\system\diagnosticts\performancecounterpermissionaccess.cs ===
//------------------------------------------------------------------------------
// <copyright file="PerformanceCounterPermissionAccess.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Diagnostics {

    /// <include file='doc\PerformanceCounterPermissionAccess.uex' path='docs/doc[@for="PerformanceCounterPermissionAccess"]/*' />
    /// <devdoc>
    ///    <para>[To be supplied.]</para>
    /// </devdoc>
    [Flags]         
    public enum PerformanceCounterPermissionAccess {
        /// <include file='doc\PerformanceCounterPermissionAccess.uex' path='docs/doc[@for="PerformanceCounterPermissionAccess.None"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        None = 0,
        /// <include file='doc\PerformanceCounterPermissionAccess.uex' path='docs/doc[@for="PerformanceCounterPermissionAccess.Browse"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        Browse = 1 << 1,
        /// <include file='doc\PerformanceCounterPermissionAccess.uex' path='docs/doc[@for="PerformanceCounterPermissionAccess.Instrument"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        Instrument = 1 << 2 | Browse,
        /// <include file='doc\PerformanceCounterPermissionAccess.uex' path='docs/doc[@for="PerformanceCounterPermissionAccess.Administer"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        Administer = 1 << 3 | Instrument,
    }    
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\services\monitoring\system\diagnosticts\performancecounterpermission.cs ===
//------------------------------------------------------------------------------
// <copyright file="PerformanceCounterPermission.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Diagnostics {
    using System;    
    using System.Security.Permissions;
                                                                        
    /// <include file='doc\PerformanceCounterPermission.uex' path='docs/doc[@for="PerformanceCounterPermission"]/*' />
    /// <devdoc>
    ///    <para>[To be supplied.]</para>
    /// </devdoc>
    [
    Serializable()
    ]
    public sealed class PerformanceCounterPermission : ResourcePermissionBase {      
        private PerformanceCounterPermissionEntryCollection innerCollection;
        
        /// <include file='doc\PerformanceCounterPermission.uex' path='docs/doc[@for="PerformanceCounterPermission.PerformanceCounterPermission"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public PerformanceCounterPermission() {
            SetNames();
        }                                                                
        
        /// <include file='doc\PerformanceCounterPermission.uex' path='docs/doc[@for="PerformanceCounterPermission.PerformanceCounterPermission1"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public PerformanceCounterPermission(PermissionState state) 
        : base(state) {
            SetNames();
        }
        
        /// <include file='doc\PerformanceCounterPermission.uex' path='docs/doc[@for="PerformanceCounterPermission.PerformanceCounterPermission2"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public PerformanceCounterPermission(PerformanceCounterPermissionAccess permissionAccess, string machineName, string categoryName) {            
            SetNames();
            this.AddPermissionAccess(new PerformanceCounterPermissionEntry(permissionAccess, machineName, categoryName));              
        }         
         
        /// <include file='doc\PerformanceCounterPermission.uex' path='docs/doc[@for="PerformanceCounterPermission.PerformanceCounterPermission3"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public PerformanceCounterPermission(PerformanceCounterPermissionEntry[] permissionAccessEntries) {            
            if (permissionAccessEntries == null)
                throw new ArgumentNullException("permissionAccessEntries");
                
            SetNames();            
            for (int index = 0; index < permissionAccessEntries.Length; ++index)
                this.AddPermissionAccess(permissionAccessEntries[index]);                          
        }

        /// <include file='doc\PerformanceCounterPermission.uex' path='docs/doc[@for="PerformanceCounterPermission.PermissionEntries"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>                
        public PerformanceCounterPermissionEntryCollection PermissionEntries {
            get {
                if (this.innerCollection == null)                     
                    this.innerCollection = new PerformanceCounterPermissionEntryCollection(this, base.GetPermissionEntries()); 
                                                                           
                return this.innerCollection;                                                               
            }
        }

        /// <include file='doc\PerformanceCounterPermission.uex' path='docs/doc[@for="PerformanceCounterPermission.AddPermissionAccess"]/*' />                
        ///<internalonly/> 
        internal void AddPermissionAccess(PerformanceCounterPermissionEntry entry) {
            base.AddPermissionAccess(entry.GetBaseEntry());
        }
        
        /// <include file='doc\PerformanceCounterPermission.uex' path='docs/doc[@for="PerformanceCounterPermission.Clear"]/*' />                        
        ///<internalonly/> 
        internal new void Clear() {
            base.Clear();
        }

        /// <include file='doc\PerformanceCounterPermission.uex' path='docs/doc[@for="PerformanceCounterPermission.RemovePermissionAccess"]/*' />                                                  
        ///<internalonly/> 
        internal void RemovePermissionAccess(PerformanceCounterPermissionEntry entry) {
            base.RemovePermissionAccess(entry.GetBaseEntry());
        }                                                                      
        
        private void SetNames() {
            this.PermissionAccessType = typeof(PerformanceCounterPermissionAccess);       
            this.TagNames = new string[]{"Machine", "Category"};
        } 
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\services\monitoring\system\diagnosticts\eventlog.cs ===
//------------------------------------------------------------------------------                    
// <copyright file="EventLog.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

//#define RETRY_ON_ALL_ERRORS

using INTPTR_INTCAST = System.Int32;
using INTPTR_INTPTRCAST = System.IntPtr;
                            
namespace System.Diagnostics {
    using System.Text;
    using System.Text.RegularExpressions;
    using System.Threading;
    using System.Runtime.InteropServices;
    using System.ComponentModel;
    using System.Diagnostics;
    using System;
    using Microsoft.Win32;    
    using System.IO;   
    using System.Collections;
    using System.Globalization;
    using System.ComponentModel.Design;
    using System.Security;
    using System.Security.Permissions;
    using System.Reflection;

    /// <include file='doc\EventLog.uex' path='docs/doc[@for="EventLog"]/*' />
    /// <devdoc>
    ///    <para>
    ///       Provides interaction with Windows 2000 event logs.
    ///    </para>
    /// </devdoc>
    [
    DefaultEvent("EntryWritten"),
    Designer("Microsoft.VisualStudio.Install.EventLogInstallableComponentDesigner, " + AssemblyRef.MicrosoftVisualStudio),
    InstallerType("System.Diagnostics.EventLogInstaller, " + AssemblyRef.SystemConfigurationInstall),
    PermissionSet(SecurityAction.InheritanceDemand, Name="FullTrust"),
    PermissionSet(SecurityAction.LinkDemand, Name="FullTrust")
    ]
    public class EventLog : Component, ISupportInitialize {
        // a collection over all our entries. Since the class holds no state, we
        // can just hand the same instance out every time.
        private EventLogEntryCollection entriesCollection;
        // the name of the log we're reading from or writing to
        private string logName;
        // used in monitoring for event postings.
        private int lastSeenCount;
        // holds the machine we're on, or null if it's the local machine
        private string machineName;
                        
        // keeps track of whether we're notifying our listeners - to prevent double notifications
        private bool notifying;
        // the delegate to call when an event arrives
        private EntryWrittenEventHandler onEntryWrittenHandler;
        // holds onto the handle for reading
        private IntPtr readHandle;
        // the source name - used only when writing
        private string sourceName;
        // holds onto the handle for writing
        private IntPtr writeHandle;
        
        private string logDisplayName;

        // cache system state variables
        // the initial size of the buffer (it can be made larger if necessary)
        private const int BUF_SIZE = 40000;
        // the number of bytes in the cache that belong to entries (not necessarily
        // the same as BUF_SIZE, because the cache only holds whole entries)
        private int bytesCached;
        // the actual cache buffer
        private byte[] cache;
        // the number of the entry at the beginning of the cache
        private int firstCachedEntry = -1;
        // whether the cache contains entries in forwards order (true) or backwards (false)
        private bool forwards = true;
        // the number of the entry that we got out of the cache most recently
        private int lastSeenEntry;
        // where that entry was
        private int lastSeenPos;
        //support for threadpool based deferred execution
        private ISynchronizeInvoke synchronizingObject;                

        private const string EventLogKey = "SYSTEM\\CurrentControlSet\\Services\\EventLog";
        internal const string DllName = "EventLogMessages.dll";
        private const string eventLogMutexName = "netfxeventlog.1.0";
        private bool initializing = false;
        private bool monitoring = false;
        private bool registeredAsListener = false;
        private bool instrumentGranted;
        private bool auditGranted;
        private bool browseGranted;                                                                                                                                                               
        private bool disposed;
        private static Hashtable listenerInfos = new Hashtable();

        // just here for debugging:
        // private static int nextInstanceNum = 0;
        // private int instanceNum = nextInstanceNum++;

        /// <include file='doc\EventLog.uex' path='docs/doc[@for="EventLog.EventLog"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Initializes a new instance of the <see cref='System.Diagnostics.EventLog'/>
        ///       class.
        ///    </para>
        /// </devdoc>
        public EventLog() : this("", ".", "") {
        }

        /// <include file='doc\EventLog.uex' path='docs/doc[@for="EventLog.EventLog1"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public EventLog(string logName) : this(logName, ".", "") {
        }

        /// <include file='doc\EventLog.uex' path='docs/doc[@for="EventLog.EventLog2"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public EventLog(string logName, string machineName) : this(logName, machineName, "") {
        }

        /// <include file='doc\EventLog.uex' path='docs/doc[@for="EventLog.EventLog3"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public EventLog(string logName, string machineName, string source) {
            //look out for invalid log names
            if (logName == null)
                throw new ArgumentNullException("logName");
            if (!ValidLogName(logName))
                throw new ArgumentException(SR.GetString(SR.BadLogName));

            if (!SyntaxCheck.CheckMachineName(machineName))
                throw new ArgumentException(SR.GetString(SR.InvalidProperty, "MachineName", machineName));

            readHandle = (IntPtr)0;
            writeHandle = (IntPtr)0;
            this.machineName = machineName;
            this.logName = logName;
            this.sourceName = source;
        }

        
        
        /// <include file='doc\EventLog.uex' path='docs/doc[@for="EventLog.Entries"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets the contents of the event log.
        ///    </para>
        /// </devdoc>
        [
        Browsable(false), 
        DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden),
        MonitoringDescription(SR.LogEntries)
        ]
        public EventLogEntryCollection Entries {
            get {
                if (!auditGranted) {
                    EventLogPermission permission = new EventLogPermission(EventLogPermissionAccess.Audit, this.machineName);
                    permission.Demand();
                    auditGranted = true;                        
                }                    
            
                if (entriesCollection == null)
                    entriesCollection = new EventLogEntryCollection(this);
                return entriesCollection;
            }
        }

        /// <include file='doc\EventLog.uex' path='docs/doc[@for="EventLog.EntryCount"]/*' />
        /// <devdoc>
        ///     Gets the number of entries in the log
        /// </devdoc>
        internal int EntryCount {
            get {
                if (!IsOpenForRead)
                    OpenForRead();
                int count;
                bool success = UnsafeNativeMethods.GetNumberOfEventLogRecords(new HandleRef(this, readHandle), out count);
                if (!success)
                    throw CreateSafeWin32Exception();
                return count;
            }
        }

        /// <include file='doc\EventLog.uex' path='docs/doc[@for="EventLog.IsOpen"]/*' />
        /// <devdoc>
        ///     Determines whether the event log is open in either read or write access
        /// </devdoc>
        private bool IsOpen {
            get {
                return readHandle != (IntPtr)0 || writeHandle != (IntPtr)0;
            }
        }

        /// <include file='doc\EventLog.uex' path='docs/doc[@for="EventLog.IsOpenForRead"]/*' />
        /// <devdoc>
        ///     Determines whether the event log is open with read access
        /// </devdoc>
        private bool IsOpenForRead {
            get {
                return readHandle != (IntPtr)0;
            }
        }

        /// <include file='doc\EventLog.uex' path='docs/doc[@for="EventLog.IsOpenForWrite"]/*' />
        /// <devdoc>
        ///     Determines whether the event log is open with write access.
        /// </devdoc>
        private bool IsOpenForWrite {
            get {
                return writeHandle != (IntPtr)0;
            }
        }

        /// <include file='doc\EventLog.uex' path='docs/doc[@for="EventLog.LogDisplayName"]/*' />
        /// <devdoc>
        ///    <para>        
        ///    </para>
        /// </devdoc>
        [Browsable(false)]
        public string LogDisplayName {
            get {                 
                if (logDisplayName == null) {
                    if (Log != null) {                                           
                        if (!browseGranted) { 
                            EventLogPermission permission = new EventLogPermission(EventLogPermissionAccess.Browse, machineName);
                            permission.Demand();                                                                                                            
                            browseGranted = true;
                        }                            
            
                        //Check environment before looking at the registry
                        SharedUtils.CheckEnvironment();
                                    
                        //SECREVIEW: Note that EventLogPermission is just demmanded above
                        RegistryPermission registryPermission = new RegistryPermission(PermissionState.Unrestricted);
                        registryPermission.Assert();
                        try {                                                                                                                     
                            // we figure out what logs are on the machine by looking in the registry.
                            RegistryKey key = null;
                            if (machineName.Equals(".")) {
                                key = Registry.LocalMachine;
                            }
                            else {
                                key = RegistryKey.OpenRemoteBaseKey(RegistryHive.LocalMachine, machineName);
                            }
                            if (key == null)
                                throw new InvalidOperationException(SR.GetString(SR.RegKeyMissingShort, "HKEY_LOCAL_MACHINE", machineName));
                                
                            key = key.OpenSubKey("SYSTEM\\CurrentControlSet\\Services\\EventLog\\" + Log, false);
                            if (key == null)
                                throw new InvalidOperationException(SR.GetString(SR.MissingLog, Log, machineName));

                            string resourceDll = (string)key.GetValue("DisplayNameFile");
                            if (resourceDll == null) 
                                logDisplayName = Log;
                            else {
                                int resourceId = (int)key.GetValue("DisplayNameID");
                                logDisplayName = EventLogEntry.FormatMessageWrapper(resourceDll, resourceId, null);
                                if (logDisplayName == null)
                                    logDisplayName = Log;
                            }                                                                                                                        
                        }                                                   
                        finally {                                
                            RegistryPermission.RevertAssert();
                        }
                    }                                                
                }
                
                return logDisplayName;
            }
        }
                                                  
        /// <include file='doc\EventLog.uex' path='docs/doc[@for="EventLog.Log"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets or sets the name of the log to read from and write to.
        ///    </para>
        /// </devdoc>
        [
        TypeConverter("System.Diagnostics.Design.LogConverter, " + AssemblyRef.SystemDesign),
        ReadOnly(true), 
        MonitoringDescription(SR.LogLog),
        DefaultValue(""),
        RecommendedAsConfigurable(true)
        ]
        public string Log {
            get {
                if ((logName == null || logName.Length == 0) && sourceName != null && !sourceName.Equals(string.Empty))
                    // they've told us a source, but they haven't told us a log name.
                    // try to deduce the log name from the source name.
                    logName = LogNameFromSourceName(sourceName, machineName);
                return logName;
            }
            set {
                //look out for invalid log names
                if (value == null)
                    throw new ArgumentNullException("value");
                if (!ValidLogName(value))
                    throw new ArgumentException(SR.GetString(SR.BadLogName));

                if (value == null)
                    value = string.Empty;
                if (logName == null) 
                    logName = value;    
                else {
                    if (String.Compare(logName, value, true, CultureInfo.InvariantCulture) == 0)
                        return;
                    
                    logDisplayName = null;
                    logName = value;                        
                    if (IsOpen) {
                        bool setEnableRaisingEvents = this.EnableRaisingEvents;
                        Close();
                        this.EnableRaisingEvents = setEnableRaisingEvents;
                    }                        
                }
                
            }
        }

        /// <include file='doc\EventLog.uex' path='docs/doc[@for="EventLog.MachineName"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets or sets the name of the computer on which to read or write events.
        ///    </para>
        /// </devdoc>
        [
        ReadOnly(true),
        MonitoringDescription(SR.LogMachineName),
        DefaultValue("."),
        RecommendedAsConfigurable(true)
        ]
        public string MachineName {
            get {
                return machineName;
            }
            set {
                if (!SyntaxCheck.CheckMachineName(value)) {
                    throw new ArgumentException(SR.GetString(SR.InvalidProperty, "MachineName", value));
                }

                if (machineName != null) {
                    if (String.Compare(machineName, value, true, CultureInfo.InvariantCulture) == 0)
                        return;

                    instrumentGranted = false;
                    auditGranted = false;
                    browseGranted = false;                        
                        
                    if (IsOpen)
                        Close();
                }
                machineName = value;
            }
        }

        /// <include file='doc\EventLog.uex' path='docs/doc[@for="EventLog.EnableRaisingEvents"]/*' />
        /// <devdoc>
        /// </devdoc>
        [
        Browsable(false),
        MonitoringDescription(SR.LogMonitoring),
        DefaultValue(false)        
        ]
        public bool EnableRaisingEvents {
            get {
                return monitoring;
            }
            set {
                if (this.DesignMode) 
                    this. monitoring = value;
                else {                    
                    if (value)
                        StartRaisingEvents();
                    else
                        StopRaisingEvents();
                }                        
            }
        }

        private int OldestEntryNumber {
            get {
                if (!IsOpenForRead)
                    OpenForRead();
                int[] num = new int[1];
                bool success = UnsafeNativeMethods.GetOldestEventLogRecord(new HandleRef(this, readHandle), num);
                if (!success)
                    throw CreateSafeWin32Exception();
                int oldest = num[0];

                // When the event log is empty, GetOldestEventLogRecord returns 0.
                // But then after an entry is written, it returns 1. We need to go from 
                // the last oldest to the current. 
                if (oldest == 0)
                    oldest = 1;

                return oldest;
            }
        }

        internal IntPtr ReadHandle {
            get {
                if (!IsOpenForRead)
                    OpenForRead();
                return readHandle;
            }
        }

        /// <include file='doc\EventLog.uex' path='docs/doc[@for="EventLog.SynchronizingObject"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Represents the object used to marshal the event handler
        ///       calls issued as a result of an <see cref='System.Diagnostics.EventLog'/>
        ///       change.
        ///    </para>
        /// </devdoc>
        [
        Browsable(false), 
        DefaultValue(null), 
        MonitoringDescription(SR.LogSynchronizingObject)
        ]
        public ISynchronizeInvoke SynchronizingObject {
            get {
             if (this.synchronizingObject == null && DesignMode) {
                    IDesignerHost host = (IDesignerHost)GetService(typeof(IDesignerHost));
                    if (host != null) {
                        object baseComponent = host.RootComponent;
                        if (baseComponent != null && baseComponent is ISynchronizeInvoke)
                            this.synchronizingObject = (ISynchronizeInvoke)baseComponent;
                    }                        
                }

                return this.synchronizingObject;
            }
            
            set {
                this.synchronizingObject = value;
            }
        }        
        
        /// <include file='doc\EventLog.uex' path='docs/doc[@for="EventLog.Source"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets or
        ///       sets the application name (source name) to register and use when writing to the event log.
        ///    </para>
        /// </devdoc>
        [
        ReadOnly(true), 
        TypeConverter("System.Diagnostics.Design.StringValueConverter, " + AssemblyRef.SystemDesign),
        MonitoringDescription(SR.LogSource),
        DefaultValue(""),
        RecommendedAsConfigurable(true)
        ]
        public string Source {
            get {
                return sourceName;
            }
            set {
                if (value == null)
                    value = string.Empty;

                // this 254 limit is the max length of a registry key.
                if (value.Length + EventLogKey.Length > 254)
                    throw new ArgumentException(SR.GetString(SR.ParameterTooLong, "source", 254 - EventLogKey.Length));
                
                if (sourceName == null) 
                    sourceName = value;                        
                else {
                    if (String.Compare(sourceName, value, true, CultureInfo.InvariantCulture) == 0)
                        return;
                                
                    sourceName = value;                                                                    
                    if (IsOpen) {
                        bool setEnableRaisingEvents = this.EnableRaisingEvents;
                        Close();                        
                        this.EnableRaisingEvents = setEnableRaisingEvents;
                    }                        
                }                
                //Trace("Set_Source", "Setting source to " + (sourceName == null ? "null" : sourceName));
            }
        }

        private static void AddListenerComponent(EventLog component) {
            lock (typeof(EventLog)) {
                Debug.WriteLineIf(CompModSwitches.EventLog.TraceVerbose, "EventLog::AddListenerComponent(" + component.Log + ")");

                LogListeningInfo info = (LogListeningInfo) listenerInfos[component.Log.ToLower(CultureInfo.InvariantCulture)];
                if (info != null) {
                    Debug.WriteLineIf(CompModSwitches.EventLog.TraceVerbose, "EventLog::AddListenerComponent: listener already active.");
                    info.listeningComponents.Add(component);
                    return;
                }

                info = new LogListeningInfo();
                info.listeningComponents.Add(component);

                info.handleOwner = new EventLog();
                info.handleOwner.MachineName = component.MachineName;                    
                info.handleOwner.Log = component.Log;                

                // create a system event
                IntPtr notifyEventHandle = SafeNativeMethods.CreateEvent(NativeMethods.NullHandleRef, false, false, null);
                if (notifyEventHandle == (IntPtr)0) {
                    Win32Exception e = null;
                    if (Marshal.GetLastWin32Error() != 0) {
                        e = CreateSafeWin32Exception();
                    }
                    throw new InvalidOperationException(SR.GetString(SR.NotifyCreateFailed), e);
                }
                                    
                // tell the event log system about it
                bool success = UnsafeNativeMethods.NotifyChangeEventLog(new HandleRef(info.handleOwner, info.handleOwner.ReadHandle), new HandleRef(null, notifyEventHandle));
                if (!success)
                    throw new InvalidOperationException(SR.GetString(SR.CantMonitorEventLog), CreateSafeWin32Exception());
                                
                info.waitHandle = new EventLogHandle(notifyEventHandle);
                info.registeredWaitHandle = ThreadPool.RegisterWaitForSingleObject(info.waitHandle, new WaitOrTimerCallback(StaticCompletionCallback), info, -1, false);

                listenerInfos[component.Log.ToLower(CultureInfo.InvariantCulture)] = info;
            }
        }

        internal static Win32Exception CreateSafeWin32Exception() {
            return CreateSafeWin32Exception(0);
        }
                                                
        internal static Win32Exception CreateSafeWin32Exception(int error) {
            Win32Exception newException = null;
            //SECREVIEW: Need to assert SecurtiyPermission, otherwise Win32Exception
            //                         will not be able to get the error message. At this point the right
            //                         permissions have already been demanded.
            SecurityPermission securityPermission = new SecurityPermission(PermissionState.Unrestricted);
            securityPermission.Assert();                            
            try {                
                if (error == 0)
                    newException = new Win32Exception();               
                else                    
                    newException = new Win32Exception(error);               
            }
            finally {
                SecurityPermission.RevertAssert();
            }                       
                        
            return newException;        
        }
                                                                                                                                                        
        /// <include file='doc\EventLog.uex' path='docs/doc[@for="EventLog.EntryWritten"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Occurs when an entry is written to the event log.
        ///    </para>
        /// </devdoc>
        [MonitoringDescription(SR.LogEntryWritten)]
        public event EntryWrittenEventHandler EntryWritten {
            add {
                if (!auditGranted) {
                    EventLogPermission permission = new EventLogPermission(EventLogPermissionAccess.Audit, this.machineName);
                    permission.Demand();
                    auditGranted = true;                        
                }                    
            
                onEntryWrittenHandler += value;
            }
            remove {
                onEntryWrittenHandler -= value;
            }
        }

        /// <include file='doc\EventLog.uex' path='docs/doc[@for="EventLog.BeginInit"]/*' />
        /// <devdoc>
        /// </devdoc>
        public void BeginInit() {            
            if (initializing) throw new InvalidOperationException(SR.GetString(SR.InitTwice));
            initializing = true;
            if (monitoring)
                StopListening();
        }

        /// <include file='doc\EventLog.uex' path='docs/doc[@for="EventLog.Clear"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Clears
        ///       the event log by removing all entries from it.
        ///    </para>
        /// </devdoc>
        public void Clear() {
            if (!auditGranted) {
                EventLogPermission permission = new EventLogPermission(EventLogPermissionAccess.Audit, this.machineName);
                permission.Demand();
                auditGranted = true;                        
            }                    
                
            if (!IsOpenForRead)
                OpenForRead();
            bool success = UnsafeNativeMethods.ClearEventLog(new HandleRef(this, readHandle), NativeMethods.NullHandleRef);
            if (!success)
                throw CreateSafeWin32Exception();
            // now that we've cleared the event log, we need to re-open our handles, because
            // the internal state of the event log has changed.
            Reset();
        }

        /// <include file='doc\EventLog.uex' path='docs/doc[@for="EventLog.Close"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Closes the event log and releases read and write handles.
        ///    </para>
        /// </devdoc>
        public void Close() {
            Debug.WriteLineIf(CompModSwitches.EventLog.TraceVerbose, "EventLog::Close");
            //Trace("Close", "Closing the event log");
            bool success = true;
            if (readHandle != (IntPtr)0) {
                success = SafeNativeMethods.CloseEventLog(new HandleRef(this, readHandle));
                if (!success) {
                    throw CreateSafeWin32Exception();
                }
                readHandle = (IntPtr)0;                
                //Trace("Close", "Closed read handle");
                Debug.WriteLineIf(CompModSwitches.EventLog.TraceVerbose, "EventLog::Close: closed read handle");
            }
            if (writeHandle != (IntPtr)0) {
                success = UnsafeNativeMethods.DeregisterEventSource(new HandleRef(this, writeHandle));
                if (!success) {
                    throw CreateSafeWin32Exception();
                }
                writeHandle = (IntPtr)0;
                //Trace("Close", "Closed write handle");
                Debug.WriteLineIf(CompModSwitches.EventLog.TraceVerbose, "EventLog::Close: closed write handle");
            }
            if (monitoring)
                StopRaisingEvents();
        }


        /// <include file='doc\EventLog.uex' path='docs/doc[@for="EventLog.CompletionCallback"]/*' />
        /// <internalonly/>        
        /// <devdoc>
        ///     Called when the threadpool is ready for us to handle a status change.
        /// </devdoc>
        private void CompletionCallback(object context)  {
            Debug.WriteLineIf(CompModSwitches.EventLog.TraceVerbose, "EventLog::CompletionStatusChanged: starting at " + lastSeenCount.ToString());
            lock (this) {
                if (notifying) {
                    // don't do double notifications.
                    Debug.WriteLineIf(CompModSwitches.EventLog.TraceVerbose, "EventLog::CompletionStatusChanged: aborting because we're already notifying.");
                    return;
                }
                notifying = true;
            }

            int i = lastSeenCount;
            try {
                // NOTE, stefanph: We have a double loop here so that we access the
                // EntryCount property as infrequently as possible. (It may be expensive
                // to get the property.) Even though there are two loops, they will together
                // only execute as many times as (final value of EntryCount) - lastSeenCount.                
                int oldest = OldestEntryNumber;
                int count = EntryCount + oldest;                                
                Debug.WriteLineIf(CompModSwitches.EventLog.TraceVerbose, "EventLog::CompletionStatusChanged: OldestEntryNumber is " + OldestEntryNumber + ", EntryCount is " + EntryCount);
                while (i < count) {
                    while (i < count) {
                        EventLogEntry entry = GetEntryWithOldest(i);
                        if (this.SynchronizingObject != null && this.SynchronizingObject.InvokeRequired)
                            this.SynchronizingObject.BeginInvoke(this.onEntryWrittenHandler, new object[]{this, new EntryWrittenEventArgs(entry)});
                        else                        
                           onEntryWrittenHandler(this, new EntryWrittenEventArgs(entry));                
                       
                        i++;
                    }
                    oldest = OldestEntryNumber;
                    count = EntryCount + oldest;                    
                }
            }
            catch (Exception e) {
                Debug.WriteLineIf(CompModSwitches.EventLog.TraceVerbose, "EventLog::CompletionStatusChanged: Caught exception notifying event handlers: " + e.ToString());
            }
            lastSeenCount = i;
            lock (this) {
                notifying = false;
            }
            Debug.WriteLineIf(CompModSwitches.EventLog.TraceVerbose, "EventLog::CompletionStatusChanged: finishing at " + lastSeenCount.ToString());
        }

        /// <include file='doc\EventLog.uex' path='docs/doc[@for="EventLog.CreateEventSource"]/*' />
        /// <devdoc>
        ///    <para> Establishes an application, using the
        ///       specified <see cref='System.Diagnostics.EventLog.Source'/> , as a valid event source for
        ///       writing entries
        ///       to a log on the local computer. This method
        ///       can also be used to create
        ///       a new custom log on the local computer.</para>
        /// </devdoc>
        public static void CreateEventSource(string source, string logName) {
            CreateEventSource(source, logName, ".");
        }

        /// <include file='doc\EventLog.uex' path='docs/doc[@for="EventLog.CreateEventSource1"]/*' />
        /// <devdoc>
        ///    <para>Establishes an application, using the specified 
        ///    <see cref='System.Diagnostics.EventLog.Source'/> as a valid event source for writing 
        ///       entries to a log on the computer
        ///       specified by <paramref name="machineName"/>. This method can also be used to create a new
        ///       custom log on the given computer.</para>
        /// </devdoc>
        public static void CreateEventSource(string source, string logName, string machineName) {
            CreateEventSource(source, logName, machineName, true);
        }
                
        private static void CreateEventSource(string source, string logName, string machineName, bool useMutex) {        
            // verify parameters
            Debug.WriteLineIf(CompModSwitches.EventLog.TraceVerbose, "CreateEventSource: Checking arguments");
            if (!SyntaxCheck.CheckMachineName(machineName)) {
                throw new ArgumentException(SR.GetString(SR.InvalidParameter, "machineName", machineName));
            }
            if (logName == null || logName.Equals(string.Empty))
                logName = "Application";
            if (!ValidLogName(logName))
                throw new ArgumentException(SR.GetString(SR.BadLogName));
            if (source == null || string.Empty.Equals(source))
                throw new ArgumentException(SR.GetString(SR.MissingParameter, "source"));
            if (source.Length + EventLogKey.Length > 254)
                throw new ArgumentException(SR.GetString(SR.ParameterTooLong, "source", 254 - EventLogKey.Length));

            EventLogPermission permission = new EventLogPermission(EventLogPermissionAccess.Instrument, machineName);
            permission.Demand();                                
            Mutex mutex = null;
            if (useMutex)
                mutex = SharedUtils.EnterMutex(eventLogMutexName);            
                
            try {
                Debug.WriteLineIf(CompModSwitches.EventLog.TraceVerbose, "CreateEventSource: Calling SourceExists");
                if (SourceExists(source, machineName)) {
                    Debug.WriteLineIf(CompModSwitches.EventLog.TraceVerbose, "CreateEventSource: SourceExists returned true");
                    // don't let them register a source if it already exists
                    // this makes more sense than just doing it anyway, because the source might
                    // be registered under a different log name, and we don't want to create
                    // duplicates.
                    if (".".Equals(machineName))
                        throw new ArgumentException(SR.GetString(SR.LocalSourceAlreadyExists, source));
                    else
                        throw new ArgumentException(SR.GetString(SR.SourceAlreadyExists, source, machineName));
                }
                            
                Debug.WriteLineIf(CompModSwitches.EventLog.TraceVerbose, "CreateEventSource: Getting DllPath");
                string eventMessageFile = GetDllPath((string) machineName);
                
                //SECREVIEW: Note that EventLog permission is demanded above.            
                RegistryPermission registryPermission = new RegistryPermission(PermissionState.Unrestricted);
                registryPermission.Assert();
                RegistryKey baseKey = null;
                RegistryKey eventKey = null;
                RegistryKey logKey = null;
                RegistryKey sourceLogKey = null;
                RegistryKey sourceKey = null;
                try {                     
                    Debug.WriteLineIf(CompModSwitches.EventLog.TraceVerbose, "CreateEventSource: Getting local machine regkey");                
                    if (machineName == ".") 
                        baseKey = Registry.LocalMachine;                                                        
                    else 
                        baseKey = RegistryKey.OpenRemoteBaseKey(RegistryHive.LocalMachine, machineName);
    
                    eventKey = baseKey.OpenSubKey("SYSTEM\\CurrentControlSet\\Services\\EventLog", true);                     
                    if (eventKey == null) {
                        if (!".".Equals(machineName))
                            throw new InvalidOperationException(SR.GetString(SR.RegKeyMissing, "SYSTEM\\CurrentControlSet\\Services\\EventLog", logName, source, machineName));
                        else
                            throw new InvalidOperationException(SR.GetString(SR.LocalRegKeyMissing, "SYSTEM\\CurrentControlSet\\Services\\EventLog", logName, source));
                    }                
                    
                    // The event log system only treats the first 8 characters of the log name as
                    // significant. If they're creating a new log, but that new log has the same 
                    // first 8 characters as another log, the system will think they're the same. 
                    // Throw an exception to let them know.
                    logKey = eventKey.OpenSubKey(logName, true);
                    if (logKey == null && logName.Length >= 8) {
    
                        // check for Windows embedded logs file names
                        string logNameFirst8 = logName.Substring(0,8); 
                        if ( string.Compare(logNameFirst8,"AppEvent",true, CultureInfo.InvariantCulture) ==0  ||
                             string.Compare(logNameFirst8,"SecEvent",true, CultureInfo.InvariantCulture) ==0  ||
                             string.Compare(logNameFirst8,"SysEvent",true, CultureInfo.InvariantCulture) ==0 )
                            throw new ArgumentException(SR.GetString(SR.InvalidCustomerLogName, logName));
                            
                        string sameLogName = FindSame8FirstCharsLog(eventKey, logName);    
                        if ( sameLogName != null )
                            throw new ArgumentException(SR.GetString(SR.DuplicateLogName, logName, sameLogName));
                    }                     
                    
                    if (logKey == null) {
                        if (SourceExists(logName, machineName)) {
                            // don't let them register a log name that already
                            // exists as source name, a source with the same 
                            // name as the log will have to be created by default
                            if (".".Equals(machineName))
                                throw new ArgumentException(SR.GetString(SR.LocalLogAlreadyExistsAsSource, logName));
                            else
                                throw new ArgumentException(SR.GetString(SR.LogAlreadyExistsAsSource, logName, machineName));
                        }
                            
                        // A source with the same name as the log has to be created
                        // by default. It is the behavior expected by EventLog API.
                        logKey = eventKey.CreateSubKey(logName);
                        sourceLogKey = logKey.CreateSubKey(logName);
                        if (eventMessageFile != null)
                            sourceLogKey.SetValue("EventMessageFile", eventMessageFile);
                    }
                    
                    if (logName != source) {
                        sourceKey = logKey.CreateSubKey(source);                        
                        if (eventMessageFile != null)
                            sourceKey.SetValue("EventMessageFile", eventMessageFile);
                    }                        
                                                                                                                      
                }   
                finally {
                    if (baseKey != null)
                        baseKey.Close();
                        
                    if (eventKey != null)
                        eventKey.Close();
    
                    if (logKey != null)
                        logKey.Close();
                        
                    if (sourceLogKey != null)
                        sourceLogKey.Close();
    
                    if (sourceKey != null)
                        sourceKey.Close();                                                            
                    
                    RegistryPermission.RevertAssert();
                }                
            }
            finally {
                if (mutex != null) {
                    mutex.ReleaseMutex();                    
                    mutex.Close();
                }                    
            }                
        }

        /// <include file='doc\EventLog.uex' path='docs/doc[@for="EventLog.Delete"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Removes
        ///       an event
        ///       log from the local computer.
        ///    </para>
        /// </devdoc>
        public static void Delete(string logName) {
            Delete(logName, ".");
        }

        /// <include file='doc\EventLog.uex' path='docs/doc[@for="EventLog.Delete1"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Removes
        ///       an
        ///       event
        ///       log from the specified computer.
        ///    </para>
        /// </devdoc>
        public static void Delete(string logName, string machineName) {                        
            RegistryKey key = null;

            if (!SyntaxCheck.CheckMachineName(machineName))
                throw new ArgumentException(SR.GetString(SR.InvalidParameterFormat, "machineName"));
            if (logName == null || logName.Equals(string.Empty))
                throw new ArgumentException(SR.GetString(SR.NoLogName));

            EventLogPermission permission = new EventLogPermission(EventLogPermissionAccess.Audit, machineName);
            permission.Demand();
            
            //Check environment before even trying to play with the registry                               
            SharedUtils.CheckEnvironment();
                        
            //SECREVIEW: Note that EventLog permission is demanded above.                        
            RegistryPermission registryPermission = new RegistryPermission(PermissionState.Unrestricted);
            registryPermission.Assert();
            Mutex mutex = SharedUtils.EnterMutex(eventLogMutexName);                        
            try {                                                                                                                    
                if (machineName.Equals(".")) {
                    key = Registry.LocalMachine;
                }
                else {
                    key = RegistryKey.OpenRemoteBaseKey(RegistryHive.LocalMachine, machineName);
                }
                if (key != null)
                    key = key.OpenSubKey("SYSTEM\\CurrentControlSet\\Services\\EventLog", true);
                if (key == null) {
                    // there's not even an event log service on the machine.
                    // or, more likely, we don't have the access to read the registry.
                    throw new InvalidOperationException(SR.GetString(SR.RegKeyNoAccess, "HKEY_LOCAL_MACHINE\\SYSTEM\\CurrentControlSet\\Services\\EventLog", machineName));
                }
    
                RegistryKey logKey = key.OpenSubKey(logName);
                if (logKey == null)
                    throw new InvalidOperationException(SR.GetString(SR.MissingLog, logName, machineName));
    
                //clear out log before trying to delete it
                //that way, if we can't delete the log file, no entries will persist because it has been cleared
                EventLog logToClear = new EventLog();
                logToClear.Log = logName;
                logToClear.MachineName = machineName;
                logToClear.Clear();
                logToClear.Close();
    
                // before deleting the registry entry, delete the file on disk. If there's no file key,
                // or if we can't delete the file, just ignore the problem.                
                string filename = null;
                try {
                    //most of the time, the "File" key does not exist, but we'll still give it a whirl
                    filename = (string) logKey.GetValue("File");
                }
                catch {
                }
                if (filename != null) {
                    try {
                        File.Delete(EventLogEntry.TranslateEnvironmentVars(filename));
                    }
                    catch {
                    }
                }
                logKey.Close();
    
                // now delete the registry entry
                key.DeleteSubKeyTree(logName);
            }
            finally {                                
                mutex.ReleaseMutex();
                RegistryPermission.RevertAssert();
            }                            
                                 
        }

        /// <include file='doc\EventLog.uex' path='docs/doc[@for="EventLog.DeleteEventSource"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Removes the event source
        ///       registration from the event log of the local computer.
        ///    </para>
        /// </devdoc>
        public static void DeleteEventSource(string source) {
            DeleteEventSource(source, ".");
        }

        /// <include file='doc\EventLog.uex' path='docs/doc[@for="EventLog.DeleteEventSource1"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Removes
        ///       the application's event source registration from the specified computer.
        ///    </para>
        /// </devdoc>
        public static void DeleteEventSource(string source, string machineName) {
            if (!SyntaxCheck.CheckMachineName(machineName)) {
                throw new ArgumentException(SR.GetString(SR.InvalidParameter, "machineName", machineName));
            }

            EventLogPermission permission = new EventLogPermission(EventLogPermissionAccess.Instrument, machineName);
            permission.Demand();
            
            //Check environment before looking at the registry
            SharedUtils.CheckEnvironment();
            
            //SECREVIEW: Note that EventLog permission is demanded above.            
            RegistryPermission registryPermission = new RegistryPermission(PermissionState.Unrestricted);
            registryPermission.Assert();
            Mutex mutex = SharedUtils.EnterMutex(eventLogMutexName);                        
            try {                     
                             
                RegistryKey key = FindSourceRegistration(source, machineName, false);
                if (key == null) {
                    if (machineName == null)
                        throw new ArgumentException(SR.GetString(SR.LocalSourceNotRegistered, source));
                    else
                        throw new ArgumentException(SR.GetString(SR.SourceNotRegistered, source, machineName, "HKEY_LOCAL_MACHINE\\SYSTEM\\CurrentControlSet\\Services\\EventLog"));
                }

                // Check parent registry key (Event Log Name) and if it's equal to source, then throw an exception.
                // The reason: each log reggistry key must always contain subkey (i.e. source) with the same name.
                string keyname = key.Name;
                int index = keyname.LastIndexOf('\\');
                if ( string.Compare(keyname, index+1, source, 0, keyname.Length - index, false, CultureInfo.InvariantCulture) == 0 )
                    throw new InvalidOperationException(SR.GetString(SR.CannotDeleteEqualSource, source));
    
                key.DeleteSubKeyTree(source);
                key.Close();
            }
            finally {                
                mutex.ReleaseMutex();                
                RegistryPermission.RevertAssert();
            }                                                    
        }

        /// <include file='doc\EventLog.uex' path='docs/doc[@for="EventLog.Dispose1"]/*' />
        /// <devdoc>                
        /// </devdoc>
        protected override void Dispose(bool disposing) {
            if (disposing) {                
                //Dispose unmanaged and managed resources
                if (IsOpen)
                    Close();
            }
            else {
                //Dispose unmanaged resources
                if (readHandle != (IntPtr)0) 
                    SafeNativeMethods.CloseEventLog(new HandleRef(this, readHandle));
                
                if (writeHandle != (IntPtr)0) 
                    UnsafeNativeMethods.DeregisterEventSource(new HandleRef(this, writeHandle));
            }
            
            this.disposed = true;
            base.Dispose(disposing);
        }
                         
        /// <include file='doc\EventLog.uex' path='docs/doc[@for="EventLog.EndInit"]/*' />
        /// <devdoc>
        /// </devdoc>
        public void EndInit() {
            initializing = false;
            if (monitoring)
                StartListening();
        }

        /// <include file='doc\EventLog.uex' path='docs/doc[@for="EventLog.Exists"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Determines whether the log
        ///       exists on the local computer.
        ///    </para>
        /// </devdoc>
        public static bool Exists(string logName) {
            return Exists(logName, ".");
        }

        /// <include file='doc\EventLog.uex' path='docs/doc[@for="EventLog.Exists1"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Determines whether the
        ///       log exists on the specified computer.
        ///    </para>
        /// </devdoc>
        public static bool Exists(string logName, string machineName) {
            if (!SyntaxCheck.CheckMachineName(machineName))
                throw new ArgumentException(SR.GetString(SR.InvalidParameterFormat, "machineName"));
                            
            EventLogPermission permission = new EventLogPermission(EventLogPermissionAccess.Browse, machineName);
            permission.Demand();                                
            
            if (logName == null || logName.Equals(string.Empty))
                return false;

            //Check environment before looking at the registry
            SharedUtils.CheckEnvironment();
                
            //SECREVIEW: Note that EventLog permission is demanded above.            
            RegistryPermission registryPermission = new RegistryPermission(PermissionState.Unrestricted);
            registryPermission.Assert();
            try {                                                     
                RegistryKey key = null;
    
                if (machineName.Equals(".")) {
                    key = Registry.LocalMachine;
                }
                else {
                    key = RegistryKey.OpenRemoteBaseKey(RegistryHive.LocalMachine, machineName);
                }
                if (key != null)
                    key = key.OpenSubKey("SYSTEM\\CurrentControlSet\\Services\\EventLog", false);
                if (key == null)            
                    return false;
                    
                RegistryKey logKey = key.OpenSubKey(logName, false);         // try to find log file key immediately.
                if (logKey != null )    // full name is found
                    return true;
                else if (logName.Length < 8 ) 
                    return false;       // short name is not found => all clear
                else    
                    return ( FindSame8FirstCharsLog(key, logName) != null ) ;
                    
            }                        
            finally {                                
                RegistryPermission.RevertAssert();                        
            }                            
        }        

        
        // Try to find log file name with the same 8 first characters.       
        // Returns 'null' if no "same first 8 chars" log is found.   logName.Length must be > 7 
        private static string FindSame8FirstCharsLog(RegistryKey keyParent, string logName) {

            string logNameFirst8 = logName.Substring(0, 8);
            string[] logNames = keyParent.GetSubKeyNames();

            for (int i = 0; i < logNames.Length; i++) {
                string currentLogName = logNames[i];
                if ( currentLogName.Length >= 8  && 
                     string.Compare(currentLogName.Substring(0, 8), logNameFirst8, true, CultureInfo.InvariantCulture) == 0)
                    return currentLogName;    
            }    
            
            return null;   // not found
        }
                
        /// <include file='doc\EventLog.uex' path='docs/doc[@for="EventLog.FindSourceRegistration1"]/*' />
        /// <devdoc>
        ///     Gets a RegistryKey that points to the LogName entry in the registry that is
        ///     the parent of the given source on the given machine, or null if none is found.
        /// </devdoc>
        private static RegistryKey FindSourceRegistration(string source, string machineName, bool readOnly) {
            if (source != null && source.Length != 0) {
                
                //Check environment before looking at the registry
                SharedUtils.CheckEnvironment();
            
                //SECREVIEW: Any call to this function must have demmanded 
                //                         EventLogPermission before. 
                RegistryPermission registryPermission = new RegistryPermission(PermissionState.Unrestricted);
                registryPermission.Assert();
                try {                                                     
                    RegistryKey key = null;
    
                    if (machineName.Equals(".")) {
                        key = Registry.LocalMachine;
                    }
                    else {
                        key = RegistryKey.OpenRemoteBaseKey(RegistryHive.LocalMachine, machineName);
                    }
                    if (key != null)
                        key = key.OpenSubKey(EventLogKey, /*writable*/!readOnly);
                    if (key == null)
                        // there's not even an event log service on the machine.
                        // or, more likely, we don't have the access to read the registry.
                        return null;
                    // Most machines will return only { "Application", "System", "Security" },
                    // but you can create your own if you want.
                    string[] logNames = key.GetSubKeyNames();
                    for (int i = 0; i < logNames.Length; i++) {
                        // see if the source is registered in this log.
                        // NOTE: A source name must be unique across ALL LOGS!
                        RegistryKey logKey = key.OpenSubKey(logNames[i], /*writable*/!readOnly);
                        if (logKey != null) {
                            RegistryKey sourceKey = logKey.OpenSubKey(source, /*writable*/!readOnly);
                            if (sourceKey != null) {
                                key.Close();
                                sourceKey.Close();
                                // found it
                                return logKey;
                            }
                            logKey.Close();
                        }
                    }
                    key.Close();
                }            
                finally {                                
                    RegistryPermission.RevertAssert();
                }                    
                // didn't see it anywhere
            }

            return null;
        }

        /// <include file='doc\EventLog.uex' path='docs/doc[@for="EventLog.GetAllEntries"]/*' />
        /// <devdoc>
        ///     Gets an array of EventLogEntry's, one for each entry in the log.
        /// </devdoc>
        internal EventLogEntry[] GetAllEntries() {
            // we could just call getEntryAt() on all the entries, but it'll be faster
            // if we grab multiple entries at once.
            if (!IsOpenForRead)
                OpenForRead();

            EventLogEntry[] entries = new EventLogEntry[EntryCount];
            int idx = 0;
            int oldestEntry = OldestEntryNumber;

            int[] bytesRead = new int[1];
            int[] minBytesNeeded = new int[] { BUF_SIZE};
            int error = 0;
            while (idx < entries.Length) {
                byte[] buf = new byte[BUF_SIZE];
                bool success = UnsafeNativeMethods.ReadEventLog(new HandleRef(this, readHandle), FORWARDS_READ | SEEK_READ,
                                                      oldestEntry+idx, buf, buf.Length, bytesRead, minBytesNeeded);
                if (!success) {
                    error = Marshal.GetLastWin32Error();
                    // NOTE, stefanph: ERROR_PROC_NOT_FOUND used to get returned, but I think that
                    // was because I was calling GetLastError directly instead of GetLastWin32Error.
                    // Making the buffer bigger and trying again seemed to work. I've removed the check
                    // for ERROR_PROC_NOT_FOUND because I don't think it's necessary any more, but
                    // I can't prove it...
                    Debug.WriteLineIf(CompModSwitches.EventLog.TraceVerbose, "Error from ReadEventLog is " + error.ToString());
#if !RETRY_ON_ALL_ERRORS
                    if (error == ERROR_INSUFFICIENT_BUFFER || error == ERROR_EVENTLOG_FILE_CHANGED) {
#endif
                        if (error == ERROR_EVENTLOG_FILE_CHANGED) {
                            // somewhere along the way the event log file changed - probably it
                            // got cleared while we were looping here. Reset the handle and
                            // try again.
                            Reset();
                        }
                        // try again with a bigger buffer if necessary
                        else if (minBytesNeeded[0] > buf.Length) {
                            Debug.WriteLineIf(CompModSwitches.EventLog.TraceVerbose, "Increasing buffer size from " + buf.Length.ToString() + " to " + minBytesNeeded[0].ToString() + " bytes");
                            buf = new byte[minBytesNeeded[0]];
                        }
                        success = UnsafeNativeMethods.ReadEventLog(new HandleRef(this, readHandle), FORWARDS_READ | SEEK_READ,
                                                         oldestEntry+idx, buf, buf.Length, bytesRead, minBytesNeeded);
                        if (!success)
                            // we'll just stop right here.
                            break;
#if !RETRY_ON_ALL_ERRORS
                    }
                    else {
                        break;
                    }
#endif
                    error = 0;
                }
                entries[idx] = new EventLogEntry(buf, 0, logName, machineName);
                int sum = IntFrom(buf, 0);
                idx++;
                while (sum < bytesRead[0] && idx < entries.Length) {
                    entries[idx] = new EventLogEntry(buf, sum, logName, machineName);
                    sum += IntFrom(buf, sum);
                    idx++;
                }
            }
            if (idx != entries.Length) {
                if (error != 0)
                    throw new InvalidOperationException(SR.GetString(SR.CantRetrieveEntries), CreateSafeWin32Exception(error));
                else
                    throw new InvalidOperationException(SR.GetString(SR.CantRetrieveEntries));
            }
            return entries;
        }

        /// <include file='doc\EventLog.uex' path='docs/doc[@for="EventLog.GetEventLogs"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Searches for all event logs on the local computer and
        ///       creates an array of <see cref='System.Diagnostics.EventLog'/>
        ///       objects to contain the
        ///       list.
        ///    </para>
        /// </devdoc>
        public static EventLog[] GetEventLogs() {
            return GetEventLogs(".");
        }

        /// <include file='doc\EventLog.uex' path='docs/doc[@for="EventLog.GetEventLogs1"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Searches for all event logs on the given computer and
        ///       creates an array of <see cref='System.Diagnostics.EventLog'/>
        ///       objects to contain the
        ///       list.
        ///    </para>
        /// </devdoc>
        public static EventLog[] GetEventLogs(string machineName) {
            if (!SyntaxCheck.CheckMachineName(machineName)) {
                throw new ArgumentException(SR.GetString(SR.InvalidParameter, "machineName", machineName));
            }

            EventLogPermission permission = new EventLogPermission(EventLogPermissionAccess.Browse, machineName);
            permission.Demand();                                                                                                            
            
            //Check environment before looking at the registry
            SharedUtils.CheckEnvironment();
            
            string[] logNames = new string[0];
            //SECREVIEW: Note that EventLogPermission is just demmanded above
            RegistryPermission registryPermission = new RegistryPermission(PermissionState.Unrestricted);
            registryPermission.Assert();
            try {                                                                                                                     
                // we figure out what logs are on the machine by looking in the registry.
                RegistryKey key = null;
                if (machineName.Equals(".")) {
                    key = Registry.LocalMachine;
                }
                else {
                    key = RegistryKey.OpenRemoteBaseKey(RegistryHive.LocalMachine, machineName);
                }
                if (key == null)
                    throw new InvalidOperationException(SR.GetString(SR.RegKeyMissingShort, "HKEY_LOCAL_MACHINE", machineName));
                key = key.OpenSubKey("SYSTEM\\CurrentControlSet\\Services\\EventLog", /*writable*/false);
                if (key == null)
                    // there's not even an event log service on the machine.
                    // or, more likely, we don't have the access to read the registry.
                    throw new InvalidOperationException(SR.GetString(SR.RegKeyMissingShort, "SYSTEM\\CurrentControlSet\\Services\\EventLog", machineName));
                // Most machines will return only { "Application", "System", "Security" },
                // but you can create your own if you want.
                logNames = key.GetSubKeyNames();                
            }            
            finally {                                
                RegistryPermission.RevertAssert();
            }                                                
            
            // now create EventLog objects that point to those logs
            EventLog[] logs = new EventLog[logNames.Length];
            for (int i = 0; i < logNames.Length; i++) {
                EventLog log = new EventLog();
                log.Log = logNames[i];
                log.MachineName = machineName;
                logs[i] = log;
            }
                
            return logs;
        }

        /// <include file='doc\EventLog.uex' path='docs/doc[@for="EventLog.GetCachedEntryPos"]/*' />
        /// <devdoc>
        ///     Searches the cache for an entry with the given index
        /// </devdoc>
        private int GetCachedEntryPos(int entryIndex) {
            if (cache == null || (forwards && entryIndex < firstCachedEntry) ||
                (!forwards && entryIndex > firstCachedEntry) || firstCachedEntry == -1) {
                // the index falls before anything we have in the cache, or the cache
                // is not yet valid
                return -1;
            }
            // we only know where the beginning of the cache is, not the end, so even
            // if it's past the end of the cache, we'll have to search through the whole
            // cache to find out.

            // we're betting heavily that the one they want to see now is close
            // to the one they asked for last time. We start looking where we
            // stopped last time.

            // We have two loops, one to go forwards and one to go backwards. Only one
            // of them will ever be executed.
            while (lastSeenEntry < entryIndex) {
                lastSeenEntry++;
                if (forwards) {
                    lastSeenPos = GetNextEntryPos(lastSeenPos);
                    if (lastSeenPos >= bytesCached)
                        break;
                }
                else {
                    lastSeenPos = GetPreviousEntryPos(lastSeenPos);
                    if (lastSeenPos < 0)
                        break;
                }
            }
            while (lastSeenEntry > entryIndex) {
                lastSeenEntry--;
                if (forwards) {
                    lastSeenPos = GetPreviousEntryPos(lastSeenPos);
                    if (lastSeenPos < 0)
                        break;
                }
                else {
                    lastSeenPos = GetNextEntryPos(lastSeenPos);
                    if (lastSeenPos >= bytesCached)
                        break;
                }
            }
            if (lastSeenPos >= bytesCached) {
                // we ran past the end. move back to the last one and return -1
                lastSeenPos = GetPreviousEntryPos(lastSeenPos);
                if (forwards)
                    lastSeenEntry--;
                else
                    lastSeenEntry++;
                return -1;
            }
            else if (lastSeenPos < 0) {
                // we ran past the beginning. move back to the first one and return -1
                lastSeenPos = 0;
                if (forwards)
                    lastSeenEntry++;
                else
                    lastSeenEntry--;
                return -1;
            }
            else {
                // we found it.
                return lastSeenPos;
            }
        }

        /// <include file='doc\EventLog.uex' path='docs/doc[@for="EventLog.GetEntryAt"]/*' />
        /// <devdoc>
        ///     Gets the entry at the given index
        /// </devdoc>
        internal EventLogEntry GetEntryAt(int index) {
            if (!IsOpenForRead)
                OpenForRead();

            if (index < 0 || index >= EntryCount)
                throw new ArgumentException(SR.GetString(SR.IndexOutOfBounds, index.ToString()));

            index += OldestEntryNumber;
            
            return GetEntryWithOldest(index);
        }            
        
        private EventLogEntry GetEntryWithOldest(int index) {        
            EventLogEntry entry = null;
            int entryPos = GetCachedEntryPos(index);
            if (entryPos >= 0) {
                entry = new EventLogEntry(cache, entryPos, logName, machineName);
                return entry;
            }

            // if we haven't seen the one after this, we were probably going
            // forwards.
            int flags = 0;
            if (GetCachedEntryPos(index+1) < 0) {
                flags = FORWARDS_READ | SEEK_READ;
                forwards = true;
            }
            else {
                flags = BACKWARDS_READ | SEEK_READ;
                forwards = false;
            }

            cache = new byte[BUF_SIZE];
            int[] bytesRead = new int[1];
            int[] minBytesNeeded = new int[] { cache.Length};
            bool success = UnsafeNativeMethods.ReadEventLog(new HandleRef(this, readHandle), flags, index,
                                                  cache, cache.Length, bytesRead, minBytesNeeded);
            if (!success) {
                int error = Marshal.GetLastWin32Error();
                // NOTE, stefanph: ERROR_PROC_NOT_FOUND used to get returned, but I think that
                // was because I was calling GetLastError directly instead of GetLastWin32Error.
                // Making the buffer bigger and trying again seemed to work. I've removed the check
                // for ERROR_PROC_NOT_FOUND because I don't think it's necessary any more, but
                // I can't prove it...
                Debug.WriteLineIf(CompModSwitches.EventLog.TraceVerbose, "Error from ReadEventLog is " + error.ToString());
                if (error == ERROR_INSUFFICIENT_BUFFER || error == ERROR_EVENTLOG_FILE_CHANGED) {
                    if (error == ERROR_EVENTLOG_FILE_CHANGED) {
                        // Reset() sets the cache null.  But since we're going to call ReadEventLog right after this, 
                        // we need the cache to be something valid.  We'll reuse the old byte array rather 
                        // than creating a new one. 
                        byte[] tempcache = cache;
                        Reset();
                        cache = tempcache; 
                    } else {
                        // try again with a bigger buffer.
                        if (minBytesNeeded[0] > cache.Length) {
                            cache = new byte[minBytesNeeded[0]];
                        }
                    }
                    success = UnsafeNativeMethods.ReadEventLog(new HandleRef(this, readHandle), FORWARDS_READ | SEEK_READ, index,
                                                     cache, cache.Length, bytesRead, minBytesNeeded);
                }
                
                if (!success) {
                    throw new InvalidOperationException(SR.GetString(SR.CantReadLogEntryAt, index.ToString()), CreateSafeWin32Exception());
                }
            }
            bytesCached = bytesRead[0];
            firstCachedEntry = index;
            lastSeenEntry = index;
            lastSeenPos = 0;
            return new EventLogEntry(cache, 0, logName, machineName);
        }

        /// <include file='doc\EventLog.uex' path='docs/doc[@for="EventLog.GetNextEntryPos"]/*' />
        /// <devdoc>
        ///     Finds the index into the cache where the next entry starts
        /// </devdoc>
        private int GetNextEntryPos(int pos) {
            return pos + IntFrom(cache, pos);
        }

        /// <include file='doc\EventLog.uex' path='docs/doc[@for="EventLog.GetPreviousEntryPos"]/*' />
        /// <devdoc>
        ///     Finds the index into the cache where the previous entry starts
        /// </devdoc>
        private int GetPreviousEntryPos(int pos) {
            // the entries in our buffer come back like this:
            // <length 1> ... <data> ...  <length 1> <length 2> ... <data> ... <length 2> ...
            // In other words, the length for each entry is repeated at the beginning and
            // at the end. This makes it easy to navigate forwards and backwards through
            // the buffer.
            return pos - IntFrom(cache, pos - 4);
        }
        
        internal static string GetDllPath(string machineName) {            
            return SharedUtils.GetLatestBuildDllDirectory(machineName) + DllName;        
        }

        /// <include file='doc\EventLog.uex' path='docs/doc[@for="EventLog.IntFrom"]/*' />
        /// <devdoc>
        ///     Extracts a 32-bit integer from the ubyte buffer, beginning at the byte offset
        ///     specified in offset.
        /// </devdoc>
        private static int IntFrom(byte[] buf, int offset) {
            // assumes Little Endian byte order.
            return(unchecked((int)0xFF000000) & (buf[offset+3] << 24)) | (0xFF0000 & (buf[offset+2] << 16)) |
            (0xFF00 & (buf[offset+1] << 8)) | (0xFF & (buf[offset]));
        }

        /// <include file='doc\EventLog.uex' path='docs/doc[@for="EventLog.SourceExists"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Determines whether an event source is registered on the local computer.
        ///    </para>
        /// </devdoc>
        public static bool SourceExists(string source) {
            return SourceExists(source, ".");
        }

        /// <include file='doc\EventLog.uex' path='docs/doc[@for="EventLog.SourceExists1"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Determines whether an event
        ///       source is registered on a specified computer.
        ///    </para>
        /// </devdoc>
        public static bool SourceExists(string source, string machineName) {
            if (!SyntaxCheck.CheckMachineName(machineName)) {
                throw new ArgumentException(SR.GetString(SR.InvalidParameter, "machineName", machineName));
            }

            EventLogPermission permission = new EventLogPermission(EventLogPermissionAccess.Browse, machineName);
            permission.Demand();                                                                                                
                                                                                                                                                                             
            RegistryKey keyFound = FindSourceRegistration(source, machineName, true);
            if (keyFound != null) {
                keyFound.Close();
                return true;
            }
            else
                return false;            
        }

        /// <include file='doc\EventLog.uex' path='docs/doc[@for="EventLog.LogNameFromSourceName"]/*' />
        /// <devdoc>
        ///     Gets the name of the log that the given source name is registered in.
        /// </devdoc>
        public static string LogNameFromSourceName(string source, string machineName) {
            EventLogPermission permission = new EventLogPermission(EventLogPermissionAccess.Browse, machineName);
            permission.Demand();                                                                                                
            
            RegistryKey key = FindSourceRegistration(source, machineName, true);
            if (key == null)
                return "";
            else {
                string name = key.Name;
                key.Close();
                int whackPos = name.LastIndexOf('\\');
                // this will work even if whackPos is -1
                return name.Substring(whackPos+1);
            }
        }

        /// <include file='doc\EventLog.uex' path='docs/doc[@for="EventLog.OpenForRead"]/*' />
        /// <devdoc>
        ///     Opens the event log with read access
        /// </devdoc>
        private void OpenForRead() {            
            Debug.WriteLineIf(CompModSwitches.EventLog.TraceVerbose, "EventLog::OpenForRead");
            
            //Cannot allocate the readHandle if the object has been disposed, since finalization has been suppressed.
            if (this.disposed)
                throw new ObjectDisposedException(GetType().Name);
            
            if (Log == null || Log.Equals(string.Empty))
                throw new ArgumentException(SR.GetString(SR.MissingLogProperty));

            if (! Exists(logName, machineName) )        // do not open non-existing Log [alexvec]
                throw new InvalidOperationException( SR.GetString(SR.LogDoesNotExists, logName, machineName) );
            //Check environment before calling api
            SharedUtils.CheckEnvironment();

            // Clean up cache variables. 
            // [alexvec] The initilizing code is put here to guarantee, that first read of events
            //  	     from log file will start by filling up the cache buffer.
            lastSeenEntry = 0;
            lastSeenPos = 0;
            bytesCached = 0;
            firstCachedEntry = -1;

            readHandle = UnsafeNativeMethods.OpenEventLog(machineName, logName);
            if (readHandle == (IntPtr)0) {                 
                Win32Exception e = null;
                if (Marshal.GetLastWin32Error() != 0) {
                    e = CreateSafeWin32Exception();
                }
                
                throw new InvalidOperationException(SR.GetString(SR.CantOpenLog, logName.ToString(), machineName), e);                
            }                
        }

        /// <include file='doc\EventLog.uex' path='docs/doc[@for="EventLog.OpenForWrite"]/*' />
        /// <devdoc>
        ///     Opens the event log with write access
        /// </devdoc>
        private void OpenForWrite() {
            //Cannot allocate the writeHandle if the object has been disposed, since finalization has been suppressed.
            if (this.disposed)
                throw new ObjectDisposedException(GetType().Name);
        
            Debug.WriteLineIf(CompModSwitches.EventLog.TraceVerbose, "EventLog::OpenForWrite");
            if (sourceName == null || sourceName.Equals(string.Empty))
                throw new ArgumentException(SR.GetString(SR.NeedSourceToOpen));
                
            //Check environment before calling api
            SharedUtils.CheckEnvironment();

            writeHandle = UnsafeNativeMethods.RegisterEventSource( machineName, sourceName);
            if (writeHandle == (IntPtr)0) {
                Win32Exception e = null;
                if (Marshal.GetLastWin32Error() != 0) {
                    e = CreateSafeWin32Exception();
                }
                throw new InvalidOperationException(SR.GetString(SR.CantOpenLogAccess), e);
            }
        }

        /// <include file='doc\EventLog.uex' path='docs/doc[@for="EventLog.Reset"]/*' />
        private void Reset() {
            Debug.WriteLineIf(CompModSwitches.EventLog.TraceVerbose, "EventLog::Reset");
            // save the state we're in now
            bool openRead = IsOpenForRead;
            bool openWrite = IsOpenForWrite;
            bool isListening = registeredAsListener;

            // close everything down
            Close();
            cache = null;

            // and get us back into the same state as before
            if (openRead)
                OpenForRead();
            if (openWrite)
                OpenForWrite();
            if (isListening)
                StartListening();
        }

        private static void RemoveListenerComponent(EventLog component) {
            lock (typeof(EventLog)) {
                Debug.WriteLineIf(CompModSwitches.EventLog.TraceVerbose, "EventLog::RemoveListenerComponent(" + component.Log + ")");

                LogListeningInfo info = (LogListeningInfo) listenerInfos[component.Log.ToLower(CultureInfo.InvariantCulture)];
                Debug.Assert(info != null);

                // remove the requested component from the list.
                info.listeningComponents.Remove(component);
                if (info.listeningComponents.Count != 0)
                    return;

                // if that was the last interested compononent, destroy the handles and stop listening.

                info.handleOwner.Dispose();

                //Unregister the thread pool wait handle
                info.registeredWaitHandle.Unregister(info.waitHandle);
                // close the handle
                info.waitHandle.Close();

                listenerInfos[component.Log.ToLower(CultureInfo.InvariantCulture)] = null;
            }
        }

        /// <include file='doc\EventLog.uex' path='docs/doc[@for="EventLog.StartListening"]/*' />
        /// <devdoc>
        ///     Sets up the event monitoring mechanism.  We don't track event log changes
        ///     unless someone is interested, so we set this up on demand.
        /// </devdoc>
        private void StartListening() {
            // make sure we don't fire events for entries that are already there
            Debug.Assert(!registeredAsListener, "StartListening called with registeredAsListener true.");
            lastSeenCount = EntryCount + OldestEntryNumber;
            Debug.WriteLineIf(CompModSwitches.EventLog.TraceVerbose, "EventLog::StartListening: lastSeenCount = " + lastSeenCount);
            AddListenerComponent(this);
            registeredAsListener = true;
        }

        private void StartRaisingEvents() {
            if (!initializing && !monitoring && !DesignMode) {
                StartListening();
            }
            monitoring = true;
        }

        private static void StaticCompletionCallback(object context, bool wasSignaled) {
            LogListeningInfo info = (LogListeningInfo) context;

            // get a snapshot of the components to fire the event on
            EventLog[] interestedComponents = (EventLog[]) info.listeningComponents.ToArray(typeof(EventLog));

            Debug.WriteLineIf(CompModSwitches.EventLog.TraceVerbose, "EventLog::StaticCompletionCallback: notifying " + interestedComponents.Length + " components.");

            for (int i = 0; i < interestedComponents.Length; i++)
                ThreadPool.QueueUserWorkItem(new WaitCallback(interestedComponents[i].CompletionCallback));
        }

        /// <include file='doc\EventLog.uex' path='docs/doc[@for="EventLog.StopListening"]/*' />
        /// <devdoc>
        ///     Tears down the event listening mechanism.  This is called when the last
        ///     interested party removes their event handler.
        /// </devdoc>
        private void StopListening() {
            Debug.Assert(registeredAsListener, "StopListening called without StartListening.");
            RemoveListenerComponent(this);
            registeredAsListener = false;
        }

        /// <include file='doc\EventLog.uex' path='docs/doc[@for="EventLog.StopRaisingEvents"]/*' />
        /// <devdoc>
        /// </devdoc>
        private void StopRaisingEvents() {            
            if (!initializing && monitoring && !DesignMode) {
                StopListening();
            }
            monitoring = false;
        }

        // private void Trace(string method, string message) {
        //     Console.WriteLine("[" + Windows.GetCurrentThreadId().ToString() + "] EventLog(" + instanceNum.ToString() + ")::" + method + ": " + message);
        // }

        // CharIsPrintable used to be Char.IsPrintable, but Jay removed it and
        // is forcing people to use the Unicode categories themselves.  Copied
        // the code here.  -- BrianGru, 10/3/2000.
        private static bool CharIsPrintable(char c) {
            UnicodeCategory uc = Char.GetUnicodeCategory(c);
            return (!(uc == UnicodeCategory.Control) || (uc == UnicodeCategory.Format) || 
                    (uc == UnicodeCategory.LineSeparator) || (uc == UnicodeCategory.ParagraphSeparator) ||
            (uc == UnicodeCategory.OtherNotAssigned));
        }

        internal static bool ValidLogName(string logName) {
            //any space, backslash, asterisk, or question mark is bad
            //any non-printable characters are also bad
            foreach (char c in logName.ToCharArray())                
                if (!CharIsPrintable(c) || (c == '\\') || (c == '*') || (c == '?'))
                    return false;

            return true;
        }

        /// <include file='doc\EventLog.uex' path='docs/doc[@for="EventLog.WriteEvent"]/*' />
        /// <devdoc>
        ///     Logs an entry in the event log.
        /// </devdoc>
        private void WriteEvent(int eventID, short category, EventLogEntryType type, string[] strings,
                                byte[] rawData) {

            // check arguments
            if (strings == null)
                strings = new string[0];
            for (int i = 0; i < strings.Length; i++)
                if (strings[i] == null)
                    strings[i] = String.Empty;
            if (rawData == null)
                rawData = new byte[0];
            /*
            for (int i = 0; i < strings.Length; i++) {
                // MSDN sez there's a limit of 32K bytes for each string. The event log API
                // doesn't do any validation, so we'll do it here.
                if (strings[i] != null && strings[i].Length > 16384)
                    throw new ArgumentException(SR.GetString(SR.LogEntryTooLong, "16384"));
            }
            */
            if (eventID < 0 || eventID > ushort.MaxValue)
                throw new ArgumentException(SR.GetString(SR.EventID, eventID, 0, (int)ushort.MaxValue));
            if (Source.Length == 0)
                throw new ArgumentException(SR.GetString(SR.NeedSourceToWrite));
            string rightLogName = LogNameFromSourceName(Source, machineName);
            if (rightLogName != null && Log != null && String.Compare(rightLogName, Log, true, CultureInfo.InvariantCulture) != 0)
                throw new ArgumentException(SR.GetString(SR.LogSourceMismatch, Source.ToString(), Log.ToString(), rightLogName));

            if (!IsOpenForWrite)
                OpenForWrite();

            // pin each of the strings in memory
            IntPtr[] stringRoots = new IntPtr[strings.Length];
            GCHandle stringRootsHandle = new GCHandle();
            int strIndex = 0;
            try {
                for (strIndex = 0; strIndex < strings.Length; strIndex++)
                    stringRoots[strIndex] = Marshal.StringToCoTaskMemUni(strings[strIndex]);
            }
            catch (Exception e) {
                // if the alloc failed on one of them, make sure the ones before get
                // freed
                for (int j = 0; j < strIndex; j++)
                    Marshal.FreeCoTaskMem((IntPtr)stringRoots[j]);
                throw e;
            }

            try {
                byte[] sid = null;
                // actually report the event
                stringRootsHandle = GCHandle.Alloc(stringRoots, GCHandleType.Pinned);
                bool success = UnsafeNativeMethods.ReportEvent(new HandleRef(this, writeHandle), (short) type, category, eventID,
                                                     sid, (short) strings.Length, rawData.Length, new HandleRef(this, (INTPTR_INTPTRCAST)stringRootsHandle.AddrOfPinnedObject()), rawData);
                if (!success) {
                    //Trace("WriteEvent", "Throwing Win32Exception");
                    throw CreateSafeWin32Exception();
                }
            }
            finally {
                // now free the pinned strings
                for (int i = 0; i < strings.Length; i++)
                    Marshal.FreeCoTaskMem((IntPtr)stringRoots[i]);
                if (stringRootsHandle.IsAllocated) 
                    stringRootsHandle.Free();
            }
        }                         

        /// <include file='doc\EventLog.uex' path='docs/doc[@for="EventLog.WriteEntry"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Writes an information type entry with the given message text to the event log.
        ///    </para>
        /// </devdoc>
        public void WriteEntry(string message) {
            WriteEntry(message, EventLogEntryType.Information);
        }

        /// <include file='doc\EventLog.uex' path='docs/doc[@for="EventLog.WriteEntry1"]/*' />
        /// <devdoc>
        /// </devdoc>
        public static void WriteEntry(string source, string message) {
            WriteEntry(source, message, EventLogEntryType.Information);
        }

        /// <include file='doc\EventLog.uex' path='docs/doc[@for="EventLog.WriteEntry2"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Writes an entry of the specified <see cref='System.Diagnostics.EventLogEntryType'/> to the event log. Valid types are
        ///    <see langword='Error'/>, <see langword='Warning'/>, <see langword='Information'/>, 
        ///    <see langword='Success Audit'/>, and <see langword='Failure Audit'/>.
        ///    </para>
        /// </devdoc>
        public void WriteEntry(string message, EventLogEntryType type) {
            WriteEntry(message, type, (short) 0);
        }

        /// <include file='doc\EventLog.uex' path='docs/doc[@for="EventLog.WriteEntry3"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public static void WriteEntry(string source, string message, EventLogEntryType type) {
            WriteEntry(source, message, type, (short) 0);
        }

        /// <include file='doc\EventLog.uex' path='docs/doc[@for="EventLog.WriteEntry4"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Writes an entry of the specified <see cref='System.Diagnostics.EventLogEntryType'/>
        ///       and with the
        ///       user-defined <paramref name="eventID"/>
        ///       to
        ///       the event log.
        ///    </para>
        /// </devdoc>
        public void WriteEntry(string message, EventLogEntryType type, int eventID) {
            WriteEntry(message, type, eventID, 0);
        }

        /// <include file='doc\EventLog.uex' path='docs/doc[@for="EventLog.WriteEntry5"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public static void WriteEntry(string source, string message, EventLogEntryType type, int eventID) {
            WriteEntry(source, message, type, eventID, 0);
        }

        /// <include file='doc\EventLog.uex' path='docs/doc[@for="EventLog.WriteEntry6"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Writes an entry of the specified type with the
        ///       user-defined <paramref name="eventID"/> and <paramref name="category"/>
        ///       to the event log. The <paramref name="category"/>
        ///       can be used by the event viewer to filter events in the log.
        ///    </para>
        /// </devdoc>
        public void WriteEntry(string message, EventLogEntryType type, int eventID, short category) {
            WriteEntry(message, type, eventID, category, null);
        }

        /// <include file='doc\EventLog.uex' path='docs/doc[@for="EventLog.WriteEntry7"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public static void WriteEntry(string source, string message, EventLogEntryType type, int eventID, short category) {
            WriteEntry(source, message, type, eventID, category, null);
        }

        /// <include file='doc\EventLog.uex' path='docs/doc[@for="EventLog.WriteEntry8"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Writes an entry of the specified type with the
        ///       user-defined <paramref name="eventID"/> and <paramref name="category"/> to the event log, and appends binary data to
        ///       the message. The Event Viewer does not interpret this data; it
        ///       displays raw data only in a combined hexadecimal and text format.
        ///    </para>
        /// </devdoc>
        public void WriteEntry(string message, EventLogEntryType type, int eventID, short category,
                               byte[] rawData) {

            if (Source.Length == 0)
                throw new ArgumentException(SR.GetString(SR.NeedSourceToWrite));
                
            if (!Enum.IsDefined(typeof(EventLogEntryType), type)) 
                throw new InvalidEnumArgumentException("type", (int)type, typeof(EventLogEntryType));
                                                                                  
            if (!instrumentGranted) {
                EventLogPermission permission = new EventLogPermission(EventLogPermissionAccess.Instrument, this.machineName);
                permission.Demand();
                instrumentGranted = true;
            }                
                                                  
            if (!SourceExists(sourceName, machineName)) {                
                Mutex mutex = null; 
                int retries = 10;
                while (retries > 0 && mutex == null) {
                    try {
                        mutex = SharedUtils.EnterMutex(eventLogMutexName);
                    }
                    catch (ApplicationException) {
                        if (retries > 0) {
                            retries--;
                            Thread.Sleep(5);
                        }
                        else
                            throw;
                    }
                }
                
                try {                                    
                    Debug.Assert(mutex != null, "mutex should not be null here");
                    if (!SourceExists(sourceName, machineName)) {                
                        if (Log == null)
                            Log = "Application";
                        // we automatically add an entry in the registry if there's not already
                        // one there for this source
                        CreateEventSource(sourceName, Log, machineName, false);
                        // The user may have set a custom log and tried to read it before trying to
                        // write. Due to a quirk in the event log API, we would have opened the Application
                        // log to read (because the custom log wasn't there). Now that we've created
                        // the custom log, we should close so that when we re-open, we get a read
                        // handle on the _new_ log instead of the Application log.
                        Reset();
                    }
                }
                finally {
                    if (mutex != null) {
                        mutex.ReleaseMutex();
                        mutex.Close();
                    }                        
                }
            }
                            
            // now that the source has been hooked up to our DLL, we can use "normal"
            // (message-file driven) logging techniques.
            // Our DLL has 64K different entries; all of them just display the first
            // insertion string.
            WriteEvent(eventID, category, type, new string[] { message}, rawData);
        }

        /// <include file='doc\EventLog.uex' path='docs/doc[@for="EventLog.WriteEntry9"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public static void WriteEntry(string source, string message, EventLogEntryType type, int eventID, short category,
                               byte[] rawData) {                                                                       
            EventLog log = new EventLog();
            log.Source = source;
            log.WriteEntry(message, type, eventID, category, rawData);                                
        }

        private const int SEQUENTIAL_READ = 0x1;
        private const int SEEK_READ = 0x2;
        private const int FORWARDS_READ = 0x4;
        private const int BACKWARDS_READ = 0x8;

        // some possible return values from GetLastWin32Error().  Copied from winerror.h.
        private const int ERROR_INSUFFICIENT_BUFFER = 122;
        private const int ERROR_PROC_NOT_FOUND = 127;
        private const int ERROR_EVENTLOG_FILE_CHANGED = 1503;

        private const int WAIT_OBJECT_0 = 0;
        private const int INFINITE = -1;
        
        private class LogListeningInfo {
            public EventLog handleOwner;
            public RegisteredWaitHandle registeredWaitHandle;
            public WaitHandle waitHandle;
            public ArrayList listeningComponents = new ArrayList();
        }                 
                                                                                                                                                      
        private class EventLogHandle : WaitHandle {
            public EventLogHandle(IntPtr eventLogNativeHandle) {
                this.Handle = eventLogNativeHandle;
            }
        }                                                                                                                                              
                                                                                                                                                              
    }

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\services\monitoring\system\diagnosticts\performancecounterpermissionentrycollection.cs ===
//----------------------------------------------------
// <copyright file="PerformanceCounterPermissionEntryCollection.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Diagnostics {
    using System.Security.Permissions;
    using System.Collections;
    
    /// <include file='doc\PerformanceCounterPermissionEntryCollection.uex' path='docs/doc[@for="PerformanceCounterPermissionEntryCollection"]/*' />        
    [
    Serializable()
    ]
    public class PerformanceCounterPermissionEntryCollection : CollectionBase {        
        PerformanceCounterPermission owner;
        
        /// <include file='doc\PerformanceCounterPermissionEntryCollection.uex' path='docs/doc[@for="PerformanceCounterPermissionEntryCollection.PerformanceCounterPermissionEntryCollection"]/*' />        
        ///<internalonly/>   
        internal PerformanceCounterPermissionEntryCollection(PerformanceCounterPermission owner, ResourcePermissionBaseEntry[] entries) {
            this.owner = owner;
            for (int index = 0; index < entries.Length; ++index)
                this.InnerList.Add(new PerformanceCounterPermissionEntry(entries[index]));
        }                                                                                                              
                                                                                                            
        /// <include file='doc\PerformanceCounterPermissionEntryCollection.uex' path='docs/doc[@for="PerformanceCounterPermissionEntryCollection.this"]/*' />        
        public PerformanceCounterPermissionEntry this[int index] {
            get {
                return (PerformanceCounterPermissionEntry)List[index];
            }
            set {
                List[index] = value;
            }
            
        }
        
        /// <include file='doc\PerformanceCounterPermissionEntryCollection.uex' path='docs/doc[@for="PerformanceCounterPermissionEntryCollection.Add"]/*' />        
        public int Add(PerformanceCounterPermissionEntry value) {   
            return List.Add(value);
        }
        
        /// <include file='doc\PerformanceCounterPermissionEntryCollection.uex' path='docs/doc[@for="PerformanceCounterPermissionEntryCollection.AddRange"]/*' />        
        public void AddRange(PerformanceCounterPermissionEntry[] value) {            
            if (value == null) {
                throw new ArgumentNullException("value");
            }
            for (int i = 0; ((i) < (value.Length)); i = ((i) + (1))) {
                this.Add(value[i]);
            }
        }
    
        /// <include file='doc\PerformanceCounterPermissionEntryCollection.uex' path='docs/doc[@for="PerformanceCounterPermissionEntryCollection.AddRange1"]/*' />        
        public void AddRange(PerformanceCounterPermissionEntryCollection value) {            
            if (value == null) {
                throw new ArgumentNullException("value");
            }
            int currentCount = value.Count;
            for (int i = 0; i < currentCount; i = ((i) + (1))) {
                this.Add(value[i]);
            }
        }         
    
        /// <include file='doc\PerformanceCounterPermissionEntryCollection.uex' path='docs/doc[@for="PerformanceCounterPermissionEntryCollection.Contains"]/*' />        
        public bool Contains(PerformanceCounterPermissionEntry value) {            
            return List.Contains(value);
        }
    
        /// <include file='doc\PerformanceCounterPermissionEntryCollection.uex' path='docs/doc[@for="PerformanceCounterPermissionEntryCollection.CopyTo"]/*' />        
        public void CopyTo(PerformanceCounterPermissionEntry[] array, int index) {            
            List.CopyTo(array, index);
        }
    
        /// <include file='doc\PerformanceCounterPermissionEntryCollection.uex' path='docs/doc[@for="PerformanceCounterPermissionEntryCollection.IndexOf"]/*' />        
        public int IndexOf(PerformanceCounterPermissionEntry value) {            
            return List.IndexOf(value);
        }
        
        /// <include file='doc\PerformanceCounterPermissionEntryCollection.uex' path='docs/doc[@for="PerformanceCounterPermissionEntryCollection.Insert"]/*' />        
        public void Insert(int index, PerformanceCounterPermissionEntry value) {            
            List.Insert(index, value);
        }
                
        /// <include file='doc\PerformanceCounterPermissionEntryCollection.uex' path='docs/doc[@for="PerformanceCounterPermissionEntryCollection.Remove"]/*' />        
        public void Remove(PerformanceCounterPermissionEntry value) {
            List.Remove(value);                     
        }
        
        /// <include file='doc\PerformanceCounterPermissionEntryCollection.uex' path='docs/doc[@for="PerformanceCounterPermissionEntryCollection.OnClear"]/*' />        
        ///<internalonly/>                          
        protected override void OnClear() {   
            this.owner.Clear();         
        }
        
        /// <include file='doc\PerformanceCounterPermissionEntryCollection.uex' path='docs/doc[@for="PerformanceCounterPermissionEntryCollection.OnInsert"]/*' />        
        ///<internalonly/>                          
        protected override void OnInsert(int index, object value) {        
            this.owner.AddPermissionAccess((PerformanceCounterPermissionEntry)value);
        }
        
        /// <include file='doc\PerformanceCounterPermissionEntryCollection.uex' path='docs/doc[@for="PerformanceCounterPermissionEntryCollection.OnRemove"]/*' />
        ///<internalonly/>                          
        protected override void OnRemove(int index, object value) {
            this.owner.RemovePermissionAccess((PerformanceCounterPermissionEntry)value);
        }
                 
        /// <include file='doc\PerformanceCounterPermissionEntryCollection.uex' path='docs/doc[@for="PerformanceCounterPermissionEntryCollection.OnSet"]/*' />
        ///<internalonly/>                          
        protected override void OnSet(int index, object oldValue, object newValue) {     
            this.owner.RemovePermissionAccess((PerformanceCounterPermissionEntry)oldValue);
            this.owner.AddPermissionAccess((PerformanceCounterPermissionEntry)newValue);       
        } 
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\services\monitoring\system\diagnosticts\performancecounterpermissionattribute.cs ===
//------------------------------------------------------------------------------
// <copyright file="PerformanceCounterPermissionAttribute.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Diagnostics {
    using System.ComponentModel;
    using System.Security;
    using System.Security.Permissions;    
    
    /// <include file='doc\PerformanceCounterPermissionAttribute.uex' path='docs/doc[@for="PerformanceCounterPermissionAttribute"]/*' />
    [
    AttributeUsage(AttributeTargets.Method | AttributeTargets.Constructor | AttributeTargets.Class | AttributeTargets.Struct | AttributeTargets.Assembly | AttributeTargets.Event, AllowMultiple = true, Inherited = false ),
    Serializable()
    ]     
    public class PerformanceCounterPermissionAttribute : CodeAccessSecurityAttribute {        
        private string categoryName;
        private string machineName;
        private PerformanceCounterPermissionAccess permissionAccess;
        
        /// <include file='doc\PerformanceCounterPermissionAttribute.uex' path='docs/doc[@for="PerformanceCounterPermissionAttribute.PerformanceCounterPermissionAttribute"]/*' />
        public PerformanceCounterPermissionAttribute(SecurityAction action)
        : base(action) {
            this.categoryName = "*";
            this.machineName = ".";
            this.permissionAccess = PerformanceCounterPermissionAccess.Browse;
        }

        /// <include file='doc\PerformanceCounterPermissionAttribute.uex' path='docs/doc[@for="PerformanceCounterPermissionAttribute.CategoryName"]/*' />
        public string CategoryName {
            get {
                return this.categoryName;
            }
            
            set {
                if (value == null)
                    throw new ArgumentNullException("value");

                this.categoryName = value;                    
            }
        }

        /// <include file='doc\PerformanceCounterPermissionAttribute.uex' path='docs/doc[@for="PerformanceCounterPermissionAttribute.MachineName"]/*' />
        public string MachineName {
            get {
                return this.machineName;
            }
            
            set {
                if (!SyntaxCheck.CheckMachineName(value))
                    throw new ArgumentException(SR.GetString(SR.InvalidProperty, "MachineName", value));
                    
                this.machineName = value;                    
            }
        }
        
        /// <include file='doc\PerformanceCounterPermissionAttribute.uex' path='docs/doc[@for="PerformanceCounterPermissionAttribute.PermissionAccess"]/*' />                                
        public PerformanceCounterPermissionAccess PermissionAccess {            
            get {
                return this.permissionAccess;
            }
            
            set {
                this.permissionAccess = value;
            }
        }
              
        /// <include file='doc\PerformanceCounterPermissionAttribute.uex' path='docs/doc[@for="PerformanceCounterPermissionAttribute.CreatePermission"]/*' />
        public override IPermission CreatePermission() {            
            if (Unrestricted) 
                return new PerformanceCounterPermission(PermissionState.Unrestricted);
            
            return new PerformanceCounterPermission(this.PermissionAccess, this.MachineName, this.CategoryName);

        }
    }    
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\services\monitoring\system\diagnosticts\performancecounterlib.cs ===
//------------------------------------------------------------------------------
// <copyright file="PerformanceCounterLib.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>
//------------------------------------------------------------------------------


/**************************************************************************\
*
* Copyright (c) 1998-2002, Microsoft Corp.  All Rights Reserved.
*
* Module Name:
*
*   PerformanceCounterLib.cs
*
* Abstract:
*
* Revision History:
*
\**************************************************************************/
namespace System.Diagnostics {
    using System.Runtime.InteropServices;
    using System.Globalization;
    using System.Security.Permissions;
    using System.Security;
    using System.Text;
    using System.Threading;
    using System.Reflection;
    using System.Collections;
    using System.ComponentModel;
    using System.Collections.Specialized;
    using Microsoft.Win32;    
    using System.IO;

    internal class PerformanceCounterLib {     
        internal const string PerfShimName = "netfxperf.dll";
        internal const string OpenEntryPoint = "OpenPerformanceData";                   
        internal const string CollectEntryPoint = "CollectPerformanceData";                   
        internal const string CloseEntryPoint = "ClosePerformanceData";                 
        internal const string SingleInstanceName = "systemdiagnosticsperfcounterlibsingleinstance";
        private const string PerflibPath = "SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\Perflib";
        private const string ServicePath = "SYSTEM\\CurrentControlSet\\Services";                
        private const string categorySymbolPrefix = "OBJECT_";
        private const string conterSymbolPrefix = "DEVICE_COUNTER_";        
        private const string helpSufix = "_HELP";
        private const string nameSufix = "_NAME";
        private const string textDefinition = "[text]";
        private const string infoDefinition = "[info]";
        private const string languageDefinition = "[languages]";
        private const string objectDefinition = "[objects]";
        private const string driverNameKeyword = "drivername";
        private const string symbolFileKeyword = "symbolfile";
        private const string defineKeyword = "#define";        
        private const string languageKeyword = "language";
        private const string driverName = "perfcounter.dll";
        //The version of the mutex name is independent from the
        //assembly version.        
        private const string ManagerImplementedCategories = "{62C8FE65-4EBB-45e7-B440-6E39B2CDBF29}";
        private static readonly Guid ManagerGuid = new Guid("82840BE1-D273-11D2-B94A-00600893B17A");
        
        private static string computerName;                     
        private static string DllName = "netfxperf.dll";                
        private static string iniFilePath;
        private static string symbolFilePath;        
        private static string dllPath;        
                                                
        private PerformanceMonitor performanceMonitor;        
        private string machineName;
        private string localPerfLibPath;        
                
        private Hashtable customCategoryTable;
        private static Hashtable libraryTable;                        
        private Hashtable categoryTable;
        private Hashtable nameTable;
        private Hashtable helpTable;
        private readonly string CategoryTableLock = "CategoryTableLock";
        private readonly string NameTableLock = "NameTableLock";
        private readonly string HelpTableLock = "HelpTableLock";
                                                                            
        internal PerformanceCounterLib(string machineName, string lcid) {            
            this.machineName = machineName;            
            this.localPerfLibPath =  PerflibPath + "\\" +  lcid;                                    
        }

        /// <include file='doc\PerformanceCounterLib.uex' path='docs/doc[@for="PerformanceCounterLib.ComputerName"]/*' />
        /// <internalonly/>
        internal static string ComputerName {
            get {                
                if (computerName == null) {
                    lock (typeof(PerformanceCounterLib)) {
                        if (computerName == null) {
                            StringBuilder sb = new StringBuilder(256);
                            SafeNativeMethods.GetComputerName(sb, new int[] {sb.Capacity});
                            computerName = sb.ToString();
                        }                            
                    }                        
                }                    
                
                return computerName;
            }
        }

        private Hashtable CategoryTable {
            get {
                if (this.categoryTable == null) {
                    lock (this.CategoryTableLock) {
                        if (this.categoryTable == null) {                                                            
                            IntPtr perfData =  GetPerformanceData("Global");                        
                            IntPtr dataRef = perfData;
                            try {
                                NativeMethods.PERF_DATA_BLOCK dataBlock = new NativeMethods.PERF_DATA_BLOCK();
                                Marshal.PtrToStructure(dataRef, dataBlock);
                                dataRef = (IntPtr)((long)dataRef + dataBlock.HeaderLength);
                                int categoryNumber = dataBlock.NumObjectTypes;

                                // on some machines MSMQ claims to have 4 categories, even though it only has 2.
                                // This causes us to walk past the end of our data, potentially blowing up or reading
                                // data we shouldn't.  We use endPerfData to make sure we don't go past the end
                                // of the perf data.  (ASURT 137097)
                                long endPerfData = (long) perfData + dataBlock.TotalByteLength;
                                Hashtable tempCategoryTable = new Hashtable(categoryNumber, new CaseInsensitiveHashCodeProvider(CultureInfo.InvariantCulture), new CaseInsensitiveComparer(CultureInfo.InvariantCulture));
                                for (int index = 0; index < categoryNumber && ((long) dataRef < endPerfData); index++) {
                                    NativeMethods.PERF_OBJECT_TYPE perfObject = new NativeMethods.PERF_OBJECT_TYPE();
                                    Marshal.PtrToStructure(dataRef, perfObject);
                                    CategoryEntry newCategoryEntry = new CategoryEntry(perfObject);
                                    IntPtr nextRef =  (IntPtr)((long)dataRef + perfObject.TotalByteLength);             
                                    dataRef = (IntPtr)((long)dataRef + perfObject.HeaderLength);
                                                    
                                    int index3 = 0;                                                                                                            
                                    int previousCounterIndex = -1;
                                    //Need to filter out counters that are repeated, some providers might
                                    //return several adyacent copies of the same counter.
                                    for (int index2 = 0; index2 < newCategoryEntry.CounterIndexes.Length; ++ index2) {
                                        NativeMethods.PERF_COUNTER_DEFINITION perfCounter = new NativeMethods.PERF_COUNTER_DEFINITION();
                                        Marshal.PtrToStructure(dataRef, perfCounter);                                                             
                                        if (perfCounter.CounterNameTitleIndex != previousCounterIndex) {
                                            newCategoryEntry.CounterIndexes[index3] =  perfCounter.CounterNameTitleIndex;                                           
                                            newCategoryEntry.HelpIndexes[index3] = perfCounter.CounterHelpTitleIndex;  
                                            previousCounterIndex = perfCounter.CounterNameTitleIndex;
                                            ++ index3;
                                        }                            
                                        dataRef = (IntPtr)((long)dataRef + perfCounter.ByteLength);
                                    }
                                    
                                    //Lets adjust the entry counter arrays in case there were repeated copies
                                    if (index3 <  newCategoryEntry.CounterIndexes.Length) {
                                        int[] adjustedCounterIndexes = new int[index3];
                                        int[] adjustedHelpIndexes = new int[index3];
                                        Array.Copy(newCategoryEntry.CounterIndexes, adjustedCounterIndexes, index3);
                                        Array.Copy(newCategoryEntry.HelpIndexes, adjustedHelpIndexes, index3); 
                                        newCategoryEntry.CounterIndexes = adjustedCounterIndexes;
                                        newCategoryEntry.HelpIndexes = adjustedHelpIndexes;
                                    } 
                                    
                                    string categoryName = (string)this.NameTable[newCategoryEntry.NameIndex];
                                    if (categoryName != null)                                    
                                        tempCategoryTable[categoryName] = newCategoryEntry;                                                                                                                   
                                                         
                                    dataRef = nextRef;                                                            
                                }                                            
                                
                                this.categoryTable = tempCategoryTable;
                            }        
                            finally {
                                Marshal.FreeHGlobal(perfData);            
                            }                            
                        }                               
                    }   
                }                                                 
                
                return this.categoryTable;
            }
        }
        
        internal static string DllPath {
            get {
                if (dllPath == null) {
                    lock (typeof(PerformanceCounterLib)) {
                        if (dllPath == null) {
                            dllPath = SharedUtils.GetLatestBuildDllDirectory(".") + "perfcounter.dll";
                        }
                    }
                }
                
                return dllPath;
            }
        }

        internal Hashtable HelpTable {
            get {            
                if (this.helpTable == null) {
                    lock(this.HelpTableLock) {
                        if (this.helpTable == null)
                            this.helpTable = GetStringTable(true);                                                                                                                                                                                                        
                    }                            
                }                                                
                
                return this.helpTable;
            }
        }                
                            
        private static string IniFilePath {
            get {
                if (iniFilePath == null) {
                    lock (typeof(PerformanceCounterLib)) {
                        if (iniFilePath == null) {
                            //SECREVIEW: jruiz- need to assert Environment permissions here
                            //                        the environment check is not exposed as a public 
                            //                        method                        
                            EnvironmentPermission environmentPermission = new EnvironmentPermission(PermissionState.Unrestricted);                        
                            environmentPermission.Assert();                        
                            try {
                                iniFilePath = Path.GetTempFileName();                                                      
                            }
                            finally {  
                                 EnvironmentPermission.RevertAssert();                             
                            }                                                    
                        }                            
                    }
                } 
                
                return iniFilePath;
            }
        }
        
        internal Hashtable NameTable {
            get {            
                if (this.nameTable == null) {
                    lock(this.NameTableLock) {
                        if (this.nameTable == null)
                            this.nameTable = GetStringTable(false);                                                                                                                                                            
                    }                            
                }                                                
                
                return this.nameTable;
            }
        }
        
        private static string SymbolFilePath {
            get {
                if (symbolFilePath == null) {
                    lock (typeof(PerformanceCounterLib)) {
                        if (symbolFilePath == null) {
                            //SECREVIEW: jruiz- need to assert Environment permissions here
                            //                        the environment check is not exposed as a public 
                            //                        method                        
                            EnvironmentPermission environmentPermission = new EnvironmentPermission(PermissionState.Unrestricted);                        
                            environmentPermission.Assert();                        
                            try {
                                symbolFilePath = Path.GetTempFileName();                                                      
                            }
                            finally {  
                                 EnvironmentPermission.RevertAssert();                             
                            }                                                    
                        }                                                    
                    }                
                } 
                
                return symbolFilePath;
            }
        }
                                                                                                                                                                                                                  
        internal static bool CategoryExists(string machine, string category) {
            PerformanceCounterLib library = GetPerformanceCounterLib(machine, new CultureInfo(0x009));                 
            if (!library.CategoryExists(category)) {                
                if (CultureInfo.CurrentCulture.Parent.LCID != 0x009) {
                    library = GetPerformanceCounterLib(machine, CultureInfo.CurrentCulture.Parent);            
                    return library.CategoryExists(category);
                }                                    
                
                return false;
            }   
            return true;            
        }         
                                                   
        internal bool CategoryExists(string category) {            
            return CategoryTable.ContainsKey(category);
        }
                        
        internal static void CloseAllLibraries() {
            if (libraryTable != null) {
                foreach (PerformanceCounterLib library in libraryTable.Values) 
                    library.Close();                
                    
                libraryTable = null;                    
            }            
        }
                                                                                           
        internal static void CloseAllTables() {
            if (libraryTable != null) {
                foreach (PerformanceCounterLib library in libraryTable.Values) 
                    library.CloseTables();                                                                                        
            }            
            
            PerformanceCounterManager.FirstEntry = true;
        }                                                                                           

        
        internal void CloseTables() {
            this.nameTable = null;
            this.helpTable = null;                                      
            this.categoryTable = null;                                                                                                                                               
            this.customCategoryTable = null;                            
        }
                                                                                                   
        internal void Close() {            
            if (this.performanceMonitor != null) {
                this.performanceMonitor.Close();  
                this.performanceMonitor = null;
            }                
            
            CloseTables();                                               
        }
        
        internal static bool CounterExists(string machine, string category, string counter) {
            PerformanceCounterLib library = GetPerformanceCounterLib(machine, new CultureInfo(0x009));                 
            bool categoryExists = false;
            bool counterExists = library.CounterExists(category, counter, ref categoryExists);
            if (!categoryExists && CultureInfo.CurrentCulture.Parent.LCID != 0x009) {
                library = GetPerformanceCounterLib(machine, CultureInfo.CurrentCulture.Parent);  
                counterExists = library.CounterExists(category, counter, ref categoryExists);                                          
            }
            
            if (!categoryExists)
                throw new InvalidOperationException(SR.GetString(SR.MissingCategory));                                                    
                                        
            return counterExists;
        }                                                                                                         
                                                                                                         
        private bool CounterExists(string category, string counter, ref bool categoryExists) {                        
            categoryExists = false; 
            if (!CategoryTable.ContainsKey(category)) 
                return false;    
            else 
                categoryExists = true; 
                                                
            CategoryEntry entry = (CategoryEntry)this.CategoryTable[category];          
            for (int index = 0; index < entry.CounterIndexes.Length; ++ index) {
                int counterIndex = entry.CounterIndexes[index];
                string counterName = (string)this.NameTable[counterIndex];                    
                if (counterName == null)
                   counterName = String.Empty;
               
                if (String.Compare(counterName, counter, true, CultureInfo.InvariantCulture) == 0)              
                    return true;
            }                       
                        
            return false;
        }
        
        internal static Win32Exception CreateSafeWin32Exception(int errorCode) {
            Win32Exception newException = null;
            //SECREVIEW: Need to assert SecurtiyPermission, otherwise Win32Exception
            //                         will not be able to get the error message. At this point the right
            //                         permissions have already been demanded.
            SecurityPermission securityPermission = new SecurityPermission(PermissionState.Unrestricted);
            securityPermission.Assert();                            
            try {                
                newException = new Win32Exception(errorCode);               
            }
            finally {
                SecurityPermission.RevertAssert();
            }                       
                        
            return newException;        
        }
        
        private static void CreateIniFile(string categoryName, string categoryHelp, CounterCreationDataCollection creationData, string[] languageIds) {
            //SECREVIEW: PerformanceCounterPermission must have been demanded before
            FileIOPermission permission = new FileIOPermission(PermissionState.Unrestricted);
            permission.Assert();
            try {
                StreamWriter iniWriter = new StreamWriter(IniFilePath, false, Encoding.Unicode);                   
                try {
                    //NT4 won't be able to parse Unicode ini files without this
                    //extra white space.
                    iniWriter.WriteLine("");
                    iniWriter.WriteLine(infoDefinition);                
                    iniWriter.Write(driverNameKeyword);
                    iniWriter.Write("=");                    
                    iniWriter.WriteLine(categoryName);
                    iniWriter.Write(symbolFileKeyword);
                    iniWriter.Write("=");
                    iniWriter.WriteLine(Path.GetFileName(SymbolFilePath));
                    iniWriter.WriteLine("");

                    iniWriter.WriteLine(languageDefinition);                
                    foreach (string languageId in languageIds) {                     
                        iniWriter.Write(languageId);
                        iniWriter.Write("=");
                        iniWriter.Write(languageKeyword);
                        iniWriter.WriteLine(languageId);
                    }                        
                    iniWriter.WriteLine("");
                                                                              
                    iniWriter.WriteLine(objectDefinition);                
                    foreach (string languageId in languageIds) {                     
                        iniWriter.Write(categorySymbolPrefix);
                        iniWriter.Write("1_");
                        iniWriter.Write(languageId);
                        iniWriter.Write(nameSufix);
                        iniWriter.Write("=");
                        iniWriter.WriteLine(categoryName);                        
                    }                        
                    iniWriter.WriteLine("");
                                                            
                    iniWriter.WriteLine(textDefinition);                
                    foreach (string languageId in languageIds) {                     
                        iniWriter.Write(categorySymbolPrefix);
                        iniWriter.Write("1_");
                        iniWriter.Write(languageId);
                        iniWriter.Write(nameSufix);
                        iniWriter.Write("=");
                        iniWriter.WriteLine(categoryName);
                        iniWriter.Write(categorySymbolPrefix);
                        iniWriter.Write("1_");
                        iniWriter.Write(languageId);
                        iniWriter.Write(helpSufix);
                        iniWriter.Write("=");
                        if (categoryHelp == null || categoryHelp == String.Empty)                            
                            iniWriter.WriteLine(SR.GetString(SR.HelpNotAvailable));                                                                                                        
                        else                            
                            iniWriter.WriteLine(categoryHelp);
                        
                        
                        int counterIndex = 0;
                        foreach (CounterCreationData counterData in creationData) {
                            ++counterIndex;
                            iniWriter.WriteLine("");
                            iniWriter.Write(conterSymbolPrefix);
                            iniWriter.Write(counterIndex.ToString());
                            iniWriter.Write("_");
                            iniWriter.Write(languageId);
                            iniWriter.Write(nameSufix);
                            iniWriter.Write("=");
                            iniWriter.WriteLine(counterData.CounterName);
                            
                            iniWriter.Write(conterSymbolPrefix);
                            iniWriter.Write(counterIndex.ToString());
                            iniWriter.Write("_");
                            iniWriter.Write(languageId);
                            iniWriter.Write(helpSufix);
                            iniWriter.Write("=");
                            
                            if (counterData.CounterHelp == null || counterData.CounterHelp == String.Empty)
                                iniWriter.WriteLine(SR.GetString(SR.HelpNotAvailable));                                                                                                        
                            else                            
                                iniWriter.WriteLine(counterData.CounterHelp);                                                    
                        }                    
                    }
                    
                    iniWriter.WriteLine("");
                }
                finally {
                    iniWriter.Close();
                }                                        
            }
            finally {
                FileIOPermission.RevertAssert();                
            }                
        }
                        
        private static void CreateRegistryEntry(string machineName, string categoryName, CounterCreationDataCollection creationData, ref bool iniRegistered) {            
            RegistryKey baseKey = null;                                                                                                                                              
            RegistryKey serviceParentKey = null;                                                                                                                                              
            RegistryKey serviceKey = null;                                                                                                                                                                                        
            
            //SECREVIEW: Whoever is able to call this function, must already
            //                         have demmanded PerformanceCounterPermission
            //                         we can therefore assert the RegistryPermission.
            RegistryPermission registryPermission = new RegistryPermission(PermissionState.Unrestricted);
            registryPermission.Assert();
            try {            
                if (machineName == "." || String.Compare(machineName, ComputerName, true, CultureInfo.InvariantCulture) == 0)
                    serviceParentKey = Registry.LocalMachine.OpenSubKey(ServicePath, true);                                                         
                else {                    
                    baseKey = RegistryKey.OpenRemoteBaseKey(RegistryHive.LocalMachine, "\\\\" + machineName);                                                            
                    serviceParentKey = baseKey.OpenSubKey(ServicePath, true);                                        
                }
                
                serviceKey = serviceParentKey.OpenSubKey(categoryName + "\\Performance", true);
                if (serviceKey == null) 
                    serviceKey = serviceParentKey.CreateSubKey(categoryName + "\\Performance");                                                                                                              
                
                serviceKey.SetValue("Open","OpenPerformanceData");
                serviceKey.SetValue("Collect", "CollectPerformanceData");
                serviceKey.SetValue("Close","ClosePerformanceData");
                serviceKey.SetValue("Library", DllName);
                
                string [] counters = new string[creationData.Count];                
                string [] counterTypes = new string[creationData.Count];
                for (int i = 0; i < creationData.Count; i++) {
                    counters[i] = creationData[i].CounterName;                    
                    counterTypes[i] = ((int) creationData[i].CounterType).ToString();
                }
                
                serviceKey.SetValue("Counter Types", (object) counterTypes);
                serviceKey.SetValue("Counter Names", (object) counters);
                                
                object firstID = serviceKey.GetValue("First Counter");
                if (firstID != null)
                    iniRegistered  = true;
                else                    
                    iniRegistered  = false;
            }
            finally {                                
                if (baseKey != null)
                    baseKey.Close();
                                                                                             
                if (serviceKey != null)
                    serviceKey.Close();
                                                
                if (serviceParentKey != null)                    
                    serviceParentKey.Close();
                    
                RegistryPermission.RevertAssert();                    
            }            
        }
        
        private static void CreateSymbolFile(CounterCreationDataCollection creationData) {
            //SECREVIEW: PerformanceCounterPermission must have been demanded before
            FileIOPermission permission = new FileIOPermission(PermissionState.Unrestricted);
            permission.Assert();
            try {                
                StreamWriter symbolWriter = new StreamWriter(SymbolFilePath);
                try {
                    symbolWriter.Write(defineKeyword);
                    symbolWriter.Write(" ");
                    symbolWriter.Write(categorySymbolPrefix);
                    symbolWriter.WriteLine("1 0;");
                                                                                    
                    for (int counterIndex = 1; counterIndex <= creationData.Count; ++ counterIndex) {                        
                        symbolWriter.Write(defineKeyword);         
                        symbolWriter.Write(" ");
                        symbolWriter.Write(conterSymbolPrefix);
                        symbolWriter.Write(counterIndex.ToString());
                        symbolWriter.Write(" ");
                        symbolWriter.Write((counterIndex * 2).ToString());                        
                        symbolWriter.WriteLine(";");
                    }                  
                    
                    symbolWriter.WriteLine("");
                }
                finally {
                    symbolWriter.Close();
                }                                        
            }
            finally {
                FileIOPermission.RevertAssert();                
            }                
        }
        
        private static void DeleteRegistryEntry(string machineName, string categoryName) {
            RegistryKey baseKey = null;                           
            RegistryKey serviceKey = null;                                         
            //SECREVIEW: Whoever is able to call this function, must already
            //                         have demmanded PerformanceCounterPermission
            //                         we can therefore assert the RegistryPermission.
            RegistryPermission registryPermission = new RegistryPermission(PermissionState.Unrestricted);
            registryPermission.Assert();
            try {                                                    
                if (machineName == "." || String.Compare(machineName, ComputerName, true, CultureInfo.InvariantCulture) == 0) 
                    serviceKey = Registry.LocalMachine.OpenSubKey(ServicePath, true);                                                                                            
                else {
                    baseKey = RegistryKey.OpenRemoteBaseKey(RegistryHive.LocalMachine, "\\\\" + machineName);                                        
                    serviceKey = baseKey.OpenSubKey(ServicePath, true);                    
                }                                                                   
                
                serviceKey.DeleteSubKeyTree(categoryName);                                    
            }
            finally {                                                                                                           
                if (baseKey != null) 
                    baseKey.Close();                    
                                       
                if (serviceKey != null) 
                    serviceKey.Close();

                RegistryPermission.RevertAssert();                
            }              
        }
        
        private static void DeleteTemporaryFiles() {            
            try {   
                File.Delete(IniFilePath);
            }
            catch(Exception) {
            }
            
            try {
                File.Delete(SymbolFilePath);
            }
            catch(Exception) {
            }
        }                                                                                                                                                                                                                                           
               
        internal static string[] GetCategories(string machineName) {
            PerformanceCounterLib library = GetPerformanceCounterLib(machineName, CultureInfo.CurrentCulture.Parent);            
            string[] categories = library.GetCategories();
            if (categories.Length == 0 && CultureInfo.CurrentCulture.Parent.LCID != 0x009) {
                library = GetPerformanceCounterLib(machineName, new CultureInfo(0x009));            
                categories = library.GetCategories();
            }
                                            
            return categories; 
        }               
                                                                                                       
        internal string[] GetCategories() {            
            ICollection keys = CategoryTable.Keys;
            string[] categories = new string[keys.Count];
            keys.CopyTo(categories, 0);
            return categories;
        }
        
        internal static string GetCategoryHelp(string machine, string category) {
            PerformanceCounterLib library = GetPerformanceCounterLib(machine, new CultureInfo(0x009));                 
            string help = library.GetCategoryHelp(category);
            if (help == null && CultureInfo.CurrentCulture.Parent.LCID != 0x009) {
                library = GetPerformanceCounterLib(machine, CultureInfo.CurrentCulture.Parent);            
                help = library.GetCategoryHelp(category);
            }
            
            if (help == null)
                throw new InvalidOperationException(SR.GetString(SR.MissingCategory));
                                            
            return help;                
        }
        
        private string GetCategoryHelp(string category) {            
            CategoryEntry entry = (CategoryEntry)this.CategoryTable[category]; 
            if (entry == null)
                return null;
                           
            return (string)this.HelpTable[entry.HelpIndex];                            
        } 
                                                   
        internal static CategorySample GetCategorySample(string machine, string category) {
            PerformanceCounterLib library = GetPerformanceCounterLib(machine, new CultureInfo(0x009));                 
            CategorySample sample = library.GetCategorySample(category);
            if (sample == null && CultureInfo.CurrentCulture.Parent.LCID != 0x009) {
                library = GetPerformanceCounterLib(machine, CultureInfo.CurrentCulture.Parent);            
                sample = library.GetCategorySample(category);
            }                
            if (sample == null)
                throw new InvalidOperationException(SR.GetString(SR.MissingCategory));
                
            return sample;
        }                                  
                                                                                                                                        
        private CategorySample GetCategorySample(string category) {                        
            CategoryEntry entry = (CategoryEntry)this.CategoryTable[category];                                    
            if (entry == null)
                return null;
                
            CategorySample sample = null;
            IntPtr dataRef = GetPerformanceData(entry.NameIndex.ToString());                                     
            if (dataRef == (IntPtr)0)
                throw new InvalidOperationException(SR.GetString(SR.CantReadCategory, category));
                    
            try {                                                    
                sample = new CategorySample(dataRef, entry, this);                
                return sample;
            }            
            finally {
                if (dataRef != (IntPtr)0)
                    Marshal.FreeHGlobal(dataRef); 
            }                                   
        }

        internal static string[] GetCounters(string machine, string category) {
            PerformanceCounterLib library = GetPerformanceCounterLib(machine, new CultureInfo(0x009));                 
            bool categoryExists = false;
            string[] counters = library.GetCounters(category, ref categoryExists);
            if (!categoryExists && CultureInfo.CurrentCulture.Parent.LCID != 0x009) {
                library = GetPerformanceCounterLib(machine, CultureInfo.CurrentCulture.Parent);            
                counters = library.GetCounters(category, ref categoryExists);
            }
               
            if (!categoryExists)
                throw new InvalidOperationException(SR.GetString(SR.MissingCategory));             
                
            return counters;                
        }                                                                                                         
                                                                                 
        private string[] GetCounters(string category, ref bool categoryExists) {            
            categoryExists = false;
            CategoryEntry entry = (CategoryEntry)this.CategoryTable[category];            
            if (entry == null)
                return null;
            else            
                categoryExists = true;    
                                   
            int index2 = 0;          
            string[] counters = new string[entry.CounterIndexes.Length];
            for (int index = 0; index < counters.Length; ++ index) {
                int counterIndex = entry.CounterIndexes[index];                                 
                string counterName = (string)this.NameTable[counterIndex];                    
                if (counterName != null && counterName != String.Empty) {
                    counters[index2] = counterName;
                    ++index2;
                }                    
            }
                 
            //Lets adjust the array in case there were null entries                     
            if (index2 < counters.Length) {
                string[] adjustedCounters = new string[index2];
                Array.Copy(counters, adjustedCounters, index2);
                counters = adjustedCounters;
            }                 
                        
            return counters;
        }
                            
        internal static string GetCounterHelp(string machine, string category, string counter) {
            PerformanceCounterLib library = GetPerformanceCounterLib(machine, new CultureInfo(0x009));                 
            bool categoryExists = false;
            string help = library.GetCounterHelp(category, counter, ref categoryExists);
            if (!categoryExists && CultureInfo.CurrentCulture.Parent.LCID != 0x009) {
                library = GetPerformanceCounterLib(machine, CultureInfo.CurrentCulture.Parent);            
                help = library.GetCounterHelp(category, counter, ref categoryExists);
            }                    
            
            if (!categoryExists)    
                throw new InvalidOperationException(SR.GetString(SR.MissingCategoryDetail, category));
            
            return help;
        }                                  
                                                                 
        private string GetCounterHelp(string category, string counter, ref bool categoryExists) {            
            categoryExists = false;
            CategoryEntry entry = (CategoryEntry)this.CategoryTable[category];            
            if (entry == null)
                return null;
            else            
                categoryExists = true;    
                                
            int helpIndex = -1;
            for (int index = 0; index < entry.CounterIndexes.Length; ++ index) {
                int counterIndex = entry.CounterIndexes[index];                    
                string counterName = (string)this.NameTable[counterIndex];                    
                if (counterName == null)
                   counterName = String.Empty;
                   
                if (String.Compare(counterName, counter, true, CultureInfo.InvariantCulture) == 0) {
                    helpIndex = entry.HelpIndexes[index];   
                    break;
                }                
            }                                   
            
            if (helpIndex == -1) 
                throw new InvalidOperationException(SR.GetString(SR.MissingCounter, counter));
                            
            string help = (string)this.HelpTable[helpIndex];                                
            if (help == null)            
                return String.Empty;
            else
                return help;                
        }
        
        internal string GetCounterName(int index) {                        
            if (this.NameTable.ContainsKey(index))
                return (string)this.NameTable[index];
                
            return "";                            
        }
                
        private CustomCategoryEntry GetCustomCategory(string category) {
            RegistryKey key = null;            
            try {
                CustomCategoryEntry entry = null;
                if (this.customCategoryTable == null)
                    this.customCategoryTable = new Hashtable(new CaseInsensitiveHashCodeProvider(CultureInfo.InvariantCulture), new CaseInsensitiveComparer(CultureInfo.InvariantCulture));
                
                if (this.customCategoryTable.ContainsKey(category)) 
                    entry = (CustomCategoryEntry)this.customCategoryTable[category];
                else {  
                    //SECREVIEW: Whoever is able to call this function, must already
                    //                         have demmanded PerformanceCounterPermission
                    //                         we can therefore assert the RegistryPermission.
                    RegistryPermission registryPermission = new RegistryPermission(PermissionState.Unrestricted);
                    registryPermission.Assert();
                    try {                        
                        string keyPath = ServicePath + "\\" + category + "\\Performance";                        
                        if (machineName == "." || String.Compare(this.machineName, ComputerName, true, CultureInfo.InvariantCulture) == 0) {
                            key = Registry.LocalMachine.OpenSubKey(keyPath);                                                    
                        }                        
                        else {
                            RegistryKey baseKey = RegistryKey.OpenRemoteBaseKey(RegistryHive.LocalMachine, "\\\\" + this.machineName);                    
                            if (baseKey != null)
                                key =  baseKey.OpenSubKey(keyPath);                                                    
                        }   
                                    
                        if (key != null) {
                            object systemDllName = key.GetValue("Library");                                            
                            if (systemDllName != null && systemDllName is string && String.Compare((string)systemDllName, PerformanceCounterLib.PerfShimName, true, CultureInfo.InvariantCulture) == 0) {
                                string [] counterTypes = null;
                                string[] counterNames = null;
                                object countersData = key.GetValue("Counter Types");
                                if (countersData == null)                                                                                               
                                    counterTypes = new string[0];                                            
                                else {                                                                                                                    
                                    if (countersData is string[]) 
                                        counterTypes = (string[])countersData;
                                    else if (countersData is byte[]) 
                                        counterTypes = GetStrings((byte[])countersData);
                                    else
                                        counterTypes = new string[0];                                                                                                                                   
                                }
                                
                                countersData = key.GetValue("Counter Names");
                                if (countersData == null)                                                                                               
                                    counterNames = new string[0];                                            
                                else {                                                                                                                    
                                    if (countersData is string[]) 
                                        counterNames = (string[])countersData;
                                    else if (countersData is byte[]) 
                                        counterNames = GetStrings((byte[])countersData);
                                    else
                                        counterNames = new string[0];                                                                                                                                   
                                }
                                                                                                
                                object objectID = key.GetValue("First Counter");
                                string[] counterIndexes = new string[counterNames.Length];                                
                                if (objectID != null) {                                    
                                    int firstID = (int)objectID;                                           
                                    for (int index = 0; index < counterIndexes.Length; ++index) 
                                        counterIndexes[index] = (firstID + ((index + 1) * 2)).ToString();
                                
                                    entry = new CustomCategoryEntry(counterNames, counterIndexes, counterTypes);
                                    this.customCategoryTable[category] = entry;
                                }
                            }                                
                        }
                    }
                    finally {   
                        RegistryPermission.RevertAssert();
                    }
                }
                
                return entry;    
            }
            finally {
                if (key != null)
                    key.Close();
            }
        }
                                                                             
        private RegistryKey GetLibraryKey() {       
            return GetLibraryKey(false); 
        }                                                              
                                                                                                                                                  
        private RegistryKey GetLibraryKey(bool writable) {                                                                                                                              
            //SECREVIEW: Whoever is able to call this function, must already
            //                         have demmanded PerformanceCounterPermission
            //                         we can therefore assert the RegistryPermission.
            RegistryPermission registryPermission = new RegistryPermission(PermissionState.Unrestricted);
            registryPermission.Assert();
            try {
                if (String.Compare(this.machineName, ComputerName, true, CultureInfo.InvariantCulture) == 0)                     
                    return Registry.LocalMachine.OpenSubKey(localPerfLibPath, writable);                                                    
                else {
                    RegistryKey baseKey = RegistryKey.OpenRemoteBaseKey(RegistryHive.LocalMachine, "\\\\" + this.machineName);                    
                    return baseKey.OpenSubKey(localPerfLibPath, writable);                                                                                                                                            
                }           
            }
            finally {
                RegistryPermission.RevertAssert();
            }                                                                                      
        }

        private static string[] GetLanguageIds(string machineName) {            
            RegistryKey libraryParentKey = null;   
            RegistryKey baseKey = null;   
            string[] ids = new string[0];                                                                                                                                           
            RegistryPermission registryPermission = new RegistryPermission(PermissionState.Unrestricted);
            registryPermission.Assert();
            try {
                if (machineName == "." || String.Compare(machineName, ComputerName, true, CultureInfo.InvariantCulture) == 0)
                    libraryParentKey = Registry.LocalMachine.OpenSubKey(PerflibPath);                                                         
                else {                    
                    baseKey = RegistryKey.OpenRemoteBaseKey(RegistryHive.LocalMachine, "\\\\" + machineName);                                                            
                    libraryParentKey = baseKey.OpenSubKey(PerflibPath);                                        
                }                
                
                if (libraryParentKey != null)   
                    ids = libraryParentKey.GetSubKeyNames(); 
            }            
            finally {                
                if (libraryParentKey != null)
                    libraryParentKey.Close();
                    
                if (baseKey != null)
                    baseKey.Close();
                                                            
                RegistryPermission.RevertAssert();                    
            }            
            
            return ids;
        }                     
                                                                           
        internal static PerformanceCounterLib GetPerformanceCounterLib(string machineName, CultureInfo culture) {                    
            SharedUtils.CheckEnvironment();
                        
            string lcidString = culture.LCID.ToString("X3");
            if (machineName.CompareTo(".") == 0)
                machineName = ComputerName.ToLower(CultureInfo.InvariantCulture);
            else                
                machineName = machineName.ToLower(CultureInfo.InvariantCulture);                
            
            if (PerformanceCounterLib.libraryTable == null)
                PerformanceCounterLib.libraryTable = new Hashtable();
            
            string libraryKey = machineName + ":" + lcidString;
            if (PerformanceCounterLib.libraryTable.Contains(libraryKey))
                return (PerformanceCounterLib)PerformanceCounterLib.libraryTable[libraryKey];
            else {                
                PerformanceCounterLib library = new PerformanceCounterLib(machineName, lcidString);                    
                PerformanceCounterLib.libraryTable[libraryKey] = library;                            
                return library;
            }
        }                                                                     
                                                                                   
        internal IntPtr GetPerformanceData(string[] categories, int[] categoryIndexes) {                                     
            StringBuilder queryBuilder = new StringBuilder();
            for (int index = 0; index < categories.Length; ++index) {                
                CategoryEntry entry = (CategoryEntry)this.CategoryTable[categories[index]];
                if (entry != null) {                                        
                    if (queryBuilder.Length != 0)                       
                        queryBuilder.Append(" ");
                        
                    categoryIndexes[index] = entry.NameIndex;                         
                    queryBuilder.Append(entry.NameIndex.ToString());                                        
                }                    
            }
                             
            return this.GetPerformanceData(queryBuilder.ToString());              
        }         
                                                                     
        internal IntPtr GetPerformanceData(string item) {             
            if (this.performanceMonitor == null) {
                lock (this) {
                    if (this.performanceMonitor == null)
                        this.performanceMonitor = new PerformanceMonitor(this.machineName);
                }
            }                                    
                                                      
           return this.performanceMonitor.GetData(item);  
        }
        
        internal static string[] GetStrings(byte[] bytes) {
            //This was only added to allow setup, create
            //custom counters, without relying on the 
            //framework. They don't support registry
            //key hex(7) type.                       
            char[] blob = Encoding.Unicode.GetChars(bytes);
            ArrayList strings = new ArrayList();
            int cur = 0;
            int len = blob.Length;

            while (cur < len) {            
                int nextNull = cur;
                while (nextNull < len && blob[nextNull] != (char)0) 
                    nextNull++;
            
                if (nextNull >= len) 
                    strings.Add(new String(blob, cur, len-cur));
                else {                    
                    if (blob[nextNull] == (char)0 && nextNull-cur > 0) 
                        strings.Add(new String(blob, cur, nextNull-cur));                    
                }
                                                    
                cur = nextNull+1;
            }                
            
            return (string[])strings.ToArray(typeof(string));                                     
        }
                                                                  
        private Hashtable GetStringTable(bool isHelp) {
            Hashtable stringTable;
            RegistryKey libraryKey = GetLibraryKey();
            if (libraryKey == null) {
                //Couldn't find registry key, might be corrupt, or user might
                //be accessing a remote machine with different locale.                
                stringTable = new Hashtable();                
            }
            else {
                try {                                    
                    string[] names = null;
                    //SECREVIEW: Whoever is able to call this function, must already
                    //                         have demmanded PerformanceCounterPermission
                    //                         we can therefore assert the RegistryPermission.
                    RegistryPermission registryPermission = new RegistryPermission(PermissionState.Unrestricted);
                    registryPermission.Assert();
                    try {                        
                        if (!isHelp)
                            names = (string[])libraryKey.GetValue("Counter"); 
                        else                                            
                            names = (string[])libraryKey.GetValue("Help"); 
                    }           
                    finally {
                        RegistryPermission.RevertAssert();
                    }
                
                    if (names == null)                         
                        stringTable = new Hashtable();
                    else {                                                                                                                                                                                                                                                                                                                                                                  
                        stringTable = new Hashtable(names.Length/2);
                        for (int index = 0; index < (names.Length/2); ++ index) {
                            string nameString =  names[(index *2) + 1];
                            if (nameString == null)
                                nameString = String.Empty;
                             
                            stringTable[Int32.Parse(names[index * 2])] = nameString;
                        }                  
                    }                                                                                                      
                }                                                                            
                finally {
                    libraryKey.Close();
                }                                                
            }
                        
            return stringTable;
        }          
                          
        internal static bool IsCustomCategory(string machine, string category) {
            PerformanceCounterLib library = GetPerformanceCounterLib(machine, new CultureInfo(0x009));                 
            if (!library.IsCustomCategory(category)) {
                if (CultureInfo.CurrentCulture.Parent.LCID != 0x009) {
                    library = GetPerformanceCounterLib(machine, CultureInfo.CurrentCulture.Parent);            
                    return library.IsCustomCategory(category);
                }                                    
                
                return false;
            }   
            return true;             
        }                                  
                                                   
        private bool IsCustomCategory(string category) {
            CustomCategoryEntry entry = GetCustomCategory(category);
            if (entry != null)
                return true;
            
            return false;                
        }
                               
        internal static void RegisterCategory(string machineName, string categoryName, string categoryHelp, CounterCreationDataCollection creationData, string localizedIniFilePath) {                            
            bool iniRegistered = false;
            CreateRegistryEntry(machineName, categoryName, creationData, ref iniRegistered);
            if (!iniRegistered) 
                RegisterFiles(machineName, localizedIniFilePath, false);                                            
                                                
            CloseAllTables();            
        }
                    
        internal static void RegisterCategory(string machineName, string categoryName, string categoryHelp, CounterCreationDataCollection creationData) {                                                    
            try {
                bool iniRegistered = false;
                CreateRegistryEntry(machineName, categoryName, creationData, ref iniRegistered);
                if (!iniRegistered) {
                    string[] languageIds = GetLanguageIds(machineName);
                    CreateIniFile(categoryName, categoryHelp, creationData, languageIds);
                    CreateSymbolFile(creationData);      
                    RegisterFiles(machineName, IniFilePath, false);        
                }                                    
                CloseAllTables();
            }
            finally {
                DeleteTemporaryFiles();            
            }
        }
         
        private static void RegisterFiles(string machineName, string arg0, bool unregister) {
            StringBuilder commandLine = new StringBuilder();
            if (unregister) 
                commandLine.Append("unlodctr ");                
            else
                commandLine.Append("lodctr ");                
                
            if (machineName != "." && String.Compare(machineName, ComputerName, true, CultureInfo.InvariantCulture) != 0) {                    
                commandLine.Append("\\\\");
                commandLine.Append(machineName);
                commandLine.Append(" ");
            }                
            
            commandLine.Append("\"");
            commandLine.Append(arg0);
            commandLine.Append("\"");            
            
            int res = 0;
            if (unregister) {
                res = UnsafeNativeMethods.UnloadPerfCounterTextStrings(commandLine.ToString(), true);
                //jruiz- look at Q269225, unlodctr might return 2 when WMI is not installed.
                if (res == 2)
                    res = 0;                    
            }                
            else                
                res = UnsafeNativeMethods.LoadPerfCounterTextStrings(commandLine.ToString(), true);         
                            
            if (res != 0) 
                throw CreateSafeWin32Exception(res);                                
        }
                                                                                                                       
        internal static void UnregisterCategory(string machineName, string categoryName) {                                    
            RegisterFiles(machineName, categoryName, true);                
            DeleteRegistryEntry(machineName, categoryName);
            CloseAllTables();
        }          
    }  
        
    internal class PerformanceMonitor {
        private const int BUFFER_SIZE = 128000;
        private IntPtr perfDataKeyHandle;
        private string machineName;
        
        internal PerformanceMonitor(string machineName) {
            this.machineName = machineName;
            Init();
        }

        private void Init() {
           if (machineName != "." && String.Compare(machineName, PerformanceCounterLib.ComputerName, true, CultureInfo.InvariantCulture) != 0)  {                    
                IntPtr perfDataKeyHandleRef;
                int res = UnsafeNativeMethods.RegConnectRegistry("\\\\" + machineName, new HandleRef(this, (IntPtr)NativeMethods.HKEY_PERFORMANCE_DATA), out perfDataKeyHandleRef);
                if (res != NativeMethods.ERROR_SUCCESS)
                    throw PerformanceCounterLib.CreateSafeWin32Exception(res);                                
                    
                perfDataKeyHandle = perfDataKeyHandleRef;                        
            }
            else 
                perfDataKeyHandle = (IntPtr)NativeMethods.HKEY_PERFORMANCE_DATA;

            AppDomain.CurrentDomain.DomainUnload += new EventHandler(this.OnAppDomainUnload);
        }
                        
        internal void Close() {             
            if (perfDataKeyHandle != (IntPtr)0) {            
                SafeNativeMethods.RegCloseKey(new HandleRef(this, perfDataKeyHandle));
                perfDataKeyHandle = (IntPtr)0;
            }                                
        }                
                                     
        ~PerformanceMonitor() {
            this.Close();
        }        
                                             
        internal IntPtr GetData(string item) {    
            int currentSize = BUFFER_SIZE;
            int sizeRef = BUFFER_SIZE;
            int waitRetries = 10;
            int waitSleep = 0;
            IntPtr perfDataPointer = Marshal.AllocHGlobal((IntPtr)BUFFER_SIZE);                             
            lock (typeof(PerformanceCounterLib)) {
                bool done = false;

                // Sometimes RegQueryValueEx will fail because other threads are
                // accessing the registry.  We retry after waiting 0,10,20,40,... ms.
                do {
                    int res = 0;
                    new SecurityPermission(SecurityPermissionFlag.UnmanagedCode).Assert();
                    try {
                        res = UnsafeNativeMethods.RegQueryValueEx(new HandleRef(this, perfDataKeyHandle), item, null, null, new HandleRef(this, perfDataPointer), ref  sizeRef);
                     }                        
                    finally {
                        SecurityPermission.RevertAssert();                        
                    }                        
                    switch (res) {
                        case NativeMethods.ERROR_MORE_DATA:
                            currentSize = currentSize * 2;
                            sizeRef = currentSize;
                            Marshal.FreeHGlobal(perfDataPointer);
                            perfDataPointer = Marshal.AllocHGlobal((IntPtr)sizeRef);
                            break;
                        case NativeMethods.RPC_S_CALL_FAILED:
                        case NativeMethods.ERROR_INVALID_HANDLE:
                        case NativeMethods.RPC_S_SERVER_UNAVAILABLE:
                            Init();
                            goto case NativeMethods.WAIT_TIMEOUT;

                        case NativeMethods.WAIT_TIMEOUT:
                        case NativeMethods.ERROR_NOT_READY:
                        case NativeMethods.ERROR_LOCK_FAILED:
                            if (waitRetries == 0) {
                                Marshal.FreeHGlobal(perfDataPointer);
                                throw PerformanceCounterLib.CreateSafeWin32Exception(res);
                            }
                            --waitRetries;
                            if (waitSleep == 0) {
                                waitSleep = 10;
                            }
                            else {
                                System.Threading.Thread.Sleep(waitSleep);
                                waitSleep *= 2;
                            }
                            break;
                        case NativeMethods.ERROR_SUCCESS:
                            done = true;
                            break;
                        default:
                            Marshal.FreeHGlobal(perfDataPointer);
                            throw PerformanceCounterLib.CreateSafeWin32Exception(res);
                    }
                }
                while (!done);
            }                    

            return perfDataPointer;                                    
        }                                       
        
        private void OnAppDomainUnload(object sender, EventArgs args) {            
            this.Close();
        }
    }
             
    internal class CustomCategoryEntry {
        internal int[] CounterTypes;
        internal int[] CounterIndexes;
        internal string[] CounterNames;
        
        internal CustomCategoryEntry(string[] counterNames, string[] counterIndexes, string[] counterTypes) {
            this.CounterNames = counterNames;
            this.CounterIndexes = new int[counterNames.Length];
            this.CounterTypes = new int[counterNames.Length];
            for (int index = 0; index < counterNames.Length; ++ index) {
                this.CounterIndexes[index] = Int32.Parse(counterIndexes[index]);
                this.CounterTypes[index] = Int32.Parse(counterTypes[index]);
            } 
        }
    }
                  
    internal class CategoryEntry {            
        internal int NameIndex;
        internal int HelpIndex;
        internal int[] CounterIndexes;
        internal int[] HelpIndexes;
                
        internal CategoryEntry(NativeMethods.PERF_OBJECT_TYPE perfObject) {
            this.NameIndex = perfObject.ObjectNameTitleIndex;
            this.HelpIndex = perfObject.ObjectHelpTitleIndex;
            this.CounterIndexes = new int[perfObject.NumCounters];
            this.HelpIndexes = new int[perfObject.NumCounters];
        }                    
    }                                                                                                                                                                                         
         
    internal class CategorySample {            
        internal readonly long SystemFrequency;
        internal readonly long TimeStamp;
        internal readonly long TimeStamp100nSec;
        internal readonly long CounterFrequency;                        
        internal readonly long CounterTimeStamp;
        internal Hashtable CounterTable;  
        internal Hashtable InstanceNameTable;                  
        private CategoryEntry entry;
        private PerformanceCounterLib library;                        
                                                                                               
        internal CategorySample(IntPtr dataRef, CategoryEntry entry, PerformanceCounterLib library) {                                                                                                                                                                                                                                               
            this.entry = entry;               
            this.library = library;                        
            int categoryIndex = entry.NameIndex;            
            NativeMethods.PERF_DATA_BLOCK dataBlock = new NativeMethods.PERF_DATA_BLOCK();
            Marshal.PtrToStructure(dataRef, dataBlock);                                                                                                                                                           
            this.SystemFrequency = dataBlock.PerfFreq;                                        
            this.TimeStamp = dataBlock.PerfTime;            
            this.TimeStamp100nSec = dataBlock.PerfTime100nSec;
            dataRef = (IntPtr)((long)dataRef + dataBlock.HeaderLength);                
            int numPerfObjects = dataBlock.NumObjectTypes;            
            if (numPerfObjects == 0) {
                this.CounterTable = new Hashtable();                     
                this.InstanceNameTable = new Hashtable(new CaseInsensitiveHashCodeProvider(CultureInfo.InvariantCulture), new CaseInsensitiveComparer(CultureInfo.InvariantCulture));
                return;
            }                
                                                                                             
            //Need to find the right category, GetPerformanceData might return 
            //several of them.                
            NativeMethods.PERF_OBJECT_TYPE perfObject = null;
            bool foundCategory = false;            
            for (int index = 0; index < numPerfObjects; index++) {                
                perfObject = new NativeMethods.PERF_OBJECT_TYPE(); 
                Marshal.PtrToStructure(dataRef, perfObject);
                                
               if (perfObject.ObjectNameTitleIndex == categoryIndex) {
                    foundCategory = true;
                    break;
                }                        
                                    
                dataRef = (IntPtr)((long)dataRef + perfObject.TotalByteLength);
            }
            
            if (!foundCategory)
                throw new InvalidOperationException(SR.GetString(SR.CantReadCategoryIndex, categoryIndex.ToString()));
                                                                            
            this.CounterFrequency = perfObject.PerfFreq;                            
            this.CounterTimeStamp = perfObject.PerfTime;
            int counterNumber = perfObject.NumCounters;
            int instanceNumber = perfObject.NumInstances;            
            // Move pointer forward to end of PERF_OBJECT_TYPE
            dataRef = (IntPtr)((long)dataRef + perfObject.HeaderLength);
                                    
            CounterDefinitionSample[] samples = new CounterDefinitionSample[counterNumber];            
            this.CounterTable = new Hashtable(counterNumber);                     
            for (int index = 0; index < samples.Length; ++ index) {
                NativeMethods.PERF_COUNTER_DEFINITION perfCounter = new NativeMethods.PERF_COUNTER_DEFINITION();
                Marshal.PtrToStructure(dataRef, perfCounter);                  
                samples[index] = new CounterDefinitionSample(perfCounter, this, instanceNumber);                    
                dataRef = (IntPtr)((long)dataRef + perfCounter.ByteLength);
                //Need to discard bases. They will be hooked into the main counter.
                int currentSampleType = samples[index].CounterType;
                if (currentSampleType != NativeMethods.PERF_AVERAGE_BASE &&
                      currentSampleType != NativeMethods.PERF_COUNTER_MULTI_BASE &&
                      currentSampleType != NativeMethods.PERF_RAW_BASE  &&
                      currentSampleType != NativeMethods.PERF_SAMPLE_BASE)                         
                    this.CounterTable[samples[index].NameIndex] = samples[index];                                    
            }
            
            if (instanceNumber == -1) {
                this.InstanceNameTable = new Hashtable(1, new CaseInsensitiveHashCodeProvider(CultureInfo.InvariantCulture), new CaseInsensitiveComparer(CultureInfo.InvariantCulture));
                this.InstanceNameTable[PerformanceCounterLib.SingleInstanceName] = 0;
                            
                for (int index = 0; index < samples.Length; ++ index)  {                                                              
                    samples[index].SetInstanceValue(0, dataRef);
                    
                    if (samples[index].IsMultipleCounterType && index < (samples.Length -1)) 
                        samples[index].BaseCounterDefinitionSample = samples[index + 1];
                }                        
            }
            else {              
                string[] parentInstanceNames = null;                                                                                                                                         
                this.InstanceNameTable = new Hashtable(instanceNumber, new CaseInsensitiveHashCodeProvider(CultureInfo.InvariantCulture), new CaseInsensitiveComparer(CultureInfo.InvariantCulture));
                for (int i = 0; i < instanceNumber; i++) {                                    
                    NativeMethods.PERF_INSTANCE_DEFINITION perfInstance = new NativeMethods.PERF_INSTANCE_DEFINITION();
                    Marshal.PtrToStructure(dataRef, perfInstance);                                            
                    if (perfInstance.ParentObjectTitleIndex > 0 && parentInstanceNames == null)
                        parentInstanceNames = GetInstanceNamesFromIndex(perfInstance.ParentObjectTitleIndex);
                                        
                    string instanceName;                                                                                                                 
                    if (parentInstanceNames != null && perfInstance.ParentObjectInstance >= 0 && perfInstance.ParentObjectInstance < parentInstanceNames.Length - 1)                  
                        instanceName = parentInstanceNames[perfInstance.ParentObjectInstance] + "/" + Marshal.PtrToStringUni((IntPtr)((long)dataRef + perfInstance.NameOffset)); 
                    else                        
                        instanceName = Marshal.PtrToStringUni((IntPtr)((long)dataRef + perfInstance.NameOffset));                                          
                                                                                                                                                                            
                    //In some cases instance names are not unique (Process), same as perfmon
                    //generate a unique name.
                    string newInstanceName = instanceName;                            
                    int newInstanceNumber = 1;                    
                    while (true) {                            
                        if (!this.InstanceNameTable.ContainsKey(newInstanceName)) {                              
                            this.InstanceNameTable[newInstanceName] = i;
                            break;                                                 
                        }                                                                           
                        else {
                            newInstanceName =  instanceName + "#" + newInstanceNumber.ToString();
                            ++  newInstanceNumber;
                        }                               
                    } 
                                            
                    
                    dataRef = (IntPtr)((long)dataRef + perfInstance.ByteLength);                        
                    for (int index = 0; index < samples.Length; ++ index)
                        samples[index].SetInstanceValue(i, dataRef);                                               
                    
                    dataRef = (IntPtr)((long)dataRef + Marshal.ReadInt32(dataRef));
                }                    
                
                for (int index = 0; index < samples.Length; ++ index)  {                                              
                    if (samples[index].IsMultipleCounterType && index < (samples.Length -1)) 
                        samples[index].BaseCounterDefinitionSample = samples[index + 1];
                }                            
            }                                                                                                                               
        }
                                             
        internal void Dispose() {            
            if (CounterTable != null) {
                foreach (CounterDefinitionSample counterSample in CounterTable.Values)
                    counterSample.Dispose();
                
                CounterTable.Clear();
                CounterTable = null;
            }                            
            entry = null;
            library = null;                                    
        }                                                                                                 
                                                     
        internal string[] GetInstanceNamesFromIndex(int categoryIndex) {
            IntPtr dataPtr = library.GetPerformanceData(categoryIndex.ToString());
            try {
                IntPtr dataRef = dataPtr;
                NativeMethods.PERF_DATA_BLOCK dataBlock = new NativeMethods.PERF_DATA_BLOCK();
                Marshal.PtrToStructure(dataRef, dataBlock);                                                                                                                                                                       
                dataRef = (IntPtr)((long)dataRef + dataBlock.HeaderLength);                
                int numPerfObjects = dataBlock.NumObjectTypes;
                
                NativeMethods.PERF_OBJECT_TYPE perfObject = null;
                bool foundCategory = false;
                for (int index = 0; index < numPerfObjects; index++) {                
                    perfObject = new NativeMethods.PERF_OBJECT_TYPE();
                    Marshal.PtrToStructure(dataRef, perfObject);
                
                    if (perfObject.ObjectNameTitleIndex == categoryIndex) {
                        foundCategory = true;
                        break;
                    }                        
                                        
                    dataRef = (IntPtr)((long)dataRef + perfObject.TotalByteLength);
                }
                
                if (!foundCategory)
                    return new string[0];
                 
                int counterNumber = perfObject.NumCounters;
                int instanceNumber = perfObject.NumInstances;            
                dataRef = (IntPtr)((long)dataRef + perfObject.HeaderLength);
                
                if (instanceNumber == -1)
                    return new string[0];
                                                        
                CounterDefinitionSample[] samples = new CounterDefinitionSample[counterNumber];                        
                for (int index = 0; index < samples.Length; ++ index) {
                    NativeMethods.PERF_COUNTER_DEFINITION perfCounter = new NativeMethods.PERF_COUNTER_DEFINITION();
                    Marshal.PtrToStructure(dataRef, perfCounter);                                  
                    dataRef = (IntPtr)((long)dataRef + perfCounter.ByteLength);
                }   
                                       
                string[] instanceNames = new string[instanceNumber];
                for (int i = 0; i < instanceNumber; i++) {                
                    NativeMethods.PERF_INSTANCE_DEFINITION perfInstance = new NativeMethods.PERF_INSTANCE_DEFINITION();
                    Marshal.PtrToStructure(dataRef, perfInstance);                                            
                    instanceNames[i] =  Marshal.PtrToStringUni((IntPtr)((long)dataRef + perfInstance.NameOffset));                                                                                                                               
                    dataRef = (IntPtr)((long)dataRef + perfInstance.ByteLength);                                        
                    dataRef = (IntPtr)((long)dataRef + Marshal.ReadInt32(dataRef));
                }                                                
                
                return instanceNames;
            }
            finally {
                if (dataPtr != (IntPtr)0)
                    Marshal.FreeHGlobal(dataPtr);
            }                
        }
        
        internal CounterDefinitionSample GetCounterDefinitionSample(string counter) {                            
            for (int index = 0; index < this.entry.CounterIndexes.Length; ++ index) {
                int counterIndex = entry.CounterIndexes[index]; 
                string counterName = (string)this.library.NameTable[counterIndex];                    
                if (counterName != null) {                                  
                    if (String.Compare(counterName, counter, true, CultureInfo.InvariantCulture) == 0) {
                        CounterDefinitionSample sample = (CounterDefinitionSample)this.CounterTable[counterIndex];
                        if (sample == null) {                        
                            //This is a base counter and has not been added to the table
                            foreach (CounterDefinitionSample multiSample in this.CounterTable.Values) {
                                if (multiSample.BaseCounterDefinitionSample != null && 
                                    multiSample.BaseCounterDefinitionSample.NameIndex == counterIndex)                                        
                                    return multiSample.BaseCounterDefinitionSample;                                
                            }   
                                                        
                            throw new InvalidOperationException(SR.GetString(SR.CounterLayout));                                 
                        }                                                                         
                        return sample;
                    }                                                                                                       
                }                    
            }      
            
            throw new InvalidOperationException(SR.GetString(SR.CantReadCounter, counter));
        }            
        
        internal InstanceDataCollectionCollection ReadCategory() {
            InstanceDataCollectionCollection data = new InstanceDataCollectionCollection();
            for (int index = 0; index < this.entry.CounterIndexes.Length; ++ index) {
                int counterIndex = entry.CounterIndexes[index];  
                                  
                string name = (string)library.NameTable[counterIndex];               
                if (name != null && name != String.Empty) {                                                         
                    CounterDefinitionSample sample = (CounterDefinitionSample)this.CounterTable[counterIndex];                                                                    
                    if (sample != null)
                        //If the current index refers to a counter base,
                        //the sample will be null
                        data.Add(name, sample.ReadInstanceData(name));                                           
                }                    
            }      
            
            return data;
        }                               
    }
                                            
    internal class CounterDefinitionSample {
        internal readonly int NameIndex;
        internal readonly int CounterType;        
        internal CounterDefinitionSample BaseCounterDefinitionSample;
        internal bool IsSingleInstance;
                
        private readonly int size;
        private readonly int offset;            
        private long[] instanceValues;
        private WeakReference weakCategorySample;
        
        internal CounterDefinitionSample(NativeMethods.PERF_COUNTER_DEFINITION perfCounter, CategorySample categorySample, int instanceNumber) {
            this.NameIndex = perfCounter.CounterNameTitleIndex;
            this.CounterType = perfCounter.CounterType;                     
            this.offset = perfCounter.CounterOffset;
            this.size = perfCounter.CounterSize;                
            if (instanceNumber == -1) {
                this.IsSingleInstance = true;
                this.instanceValues = new long[1];
            }                
            else
                this.instanceValues = new long[instanceNumber];
                
            this.weakCategorySample = new WeakReference(categorySample);                                    
        }     
                                     
        internal void Dispose() {  
            this.BaseCounterDefinitionSample = null;         
            this.instanceValues = null;                        
        }                                            
                                                         
        internal bool IsMultipleCounterType {
          get {
                if ((this.CounterType == NativeMethods.PERF_AVERAGE_BULK) ||
                    (this.CounterType  == NativeMethods.PERF_AVERAGE_TIMER) ||
                    (this.CounterType  == NativeMethods.PERF_100NSEC_MULTI_TIMER) ||
                    (this.CounterType  == NativeMethods.PERF_100NSEC_MULTI_TIMER_INV) ||
                    (this.CounterType  == NativeMethods.PERF_COUNTER_MULTI_TIMER) ||
                    (this.CounterType  == NativeMethods.PERF_COUNTER_MULTI_TIMER_INV) ||
                    (this.CounterType  == NativeMethods.PERF_RAW_FRACTION) ||
                    (this.CounterType  == NativeMethods.PERF_SAMPLE_FRACTION) ||
                    (this.CounterType  == NativeMethods.PERF_SAMPLE_COUNTER))
                    return true;                    
    
                return false;
            }                       
        }              
                                                                                                                                
        private long ReadValue(IntPtr pointer) {
            if (this.size == 4) {
                return (long)(uint)Marshal.ReadInt32((IntPtr)((long)pointer + this.offset));
            }
            else if (this.size == 8) {
                return (long)Marshal.ReadInt64((IntPtr)((long)pointer + this.offset));
            }

            return -1;
        }        
                                                                                                                   
        internal CounterSample GetInstanceValue(string instanceName) {            
            CategorySample categorySample = (CategorySample)this.weakCategorySample.Target;
            
            if (!categorySample.InstanceNameTable.ContainsKey(instanceName))
                throw new InvalidOperationException(SR.GetString(SR.CantReadInstance, instanceName));
                                                     
            int index = (int)categorySample.InstanceNameTable[instanceName];                                     
            long rawValue = this.instanceValues[index];                                    
            long baseValue = 0;
            if (this.BaseCounterDefinitionSample != null) {
                CategorySample baseCategorySample = (CategorySample)this.BaseCounterDefinitionSample.weakCategorySample.Target;
                int baseIndex = (int)baseCategorySample.InstanceNameTable[instanceName];                                     
                baseValue = this.BaseCounterDefinitionSample.instanceValues[baseIndex];
            }                                                         

            return new CounterSample(rawValue,
                                                        baseValue,
                                                        categorySample.CounterFrequency,
                                                        categorySample.SystemFrequency,
                                                        categorySample.TimeStamp,                                                                                                                                                                                                                                                                                                                                                                                                        
                                                        categorySample.TimeStamp100nSec,
                                                        (PerformanceCounterType)this.CounterType,
                                                        categorySample.CounterTimeStamp);                        

        }
         
        internal InstanceDataCollection ReadInstanceData(string counterName) {
            InstanceDataCollection data = new InstanceDataCollection(counterName);
            CategorySample categorySample = (CategorySample)this.weakCategorySample.Target;
            
            string[] keys = new string[categorySample.InstanceNameTable.Count];
            categorySample.InstanceNameTable.Keys.CopyTo(keys, 0);
            int[] indexes = new int[categorySample.InstanceNameTable.Count];
            categorySample.InstanceNameTable.Values.CopyTo(indexes, 0);
            for (int index = 0; index < keys.Length; ++ index) {
                long baseValue = 0;
                if (this.BaseCounterDefinitionSample != null) {
                    CategorySample baseCategorySample = (CategorySample)this.BaseCounterDefinitionSample.weakCategorySample.Target;
                    int baseIndex = (int)baseCategorySample.InstanceNameTable[keys[index]];                                     
                    baseValue = this.BaseCounterDefinitionSample.instanceValues[baseIndex];                                    
                }                    
                    
                CounterSample sample = new CounterSample(this.instanceValues[indexes[index]],
                                                        baseValue,
                                                        categorySample.CounterFrequency,
                                                        categorySample.SystemFrequency,
                                                        categorySample.TimeStamp,                                                                                                                                                                                                                                                                                                                                                                                                        
                                                        categorySample.TimeStamp100nSec,
                                                        (PerformanceCounterType)this.CounterType,
                                                        categorySample.CounterTimeStamp);                        
                                                                                 
                data.Add(keys[index], new InstanceData(keys[index], sample));                                                            
            }
                                               
            return data;                           
        }
                                              
        internal CounterSample GetSingleValue() {    
            CategorySample categorySample = (CategorySample)this.weakCategorySample.Target;            
            long rawValue = this.instanceValues[0];                                    
            long baseValue = 0;
            if (this.BaseCounterDefinitionSample != null)                 
                baseValue = this.BaseCounterDefinitionSample.instanceValues[0];                            
                
            return new CounterSample(rawValue,
                                                        baseValue,
                                                        categorySample.CounterFrequency,
                                                        categorySample.SystemFrequency,
                                                        categorySample.TimeStamp,                                                                                                                                                                                                                                                                                                                                                                                                        
                                                        categorySample.TimeStamp100nSec,
                                                        (PerformanceCounterType)this.CounterType, 
                                                        categorySample.CounterTimeStamp);                                                        
        }                                                      
                                                                                  
        internal void SetInstanceValue(int index, IntPtr dataRef) {            
            long rawValue = ReadValue(dataRef);         
            this.instanceValues[index] = rawValue;                
        }                                                    
    }      
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\services\monitoring\system\diagnosticts\performancecounterpermissionentry.cs ===
//----------------------------------------------------
// <copyright file="PerformanceCounterPermissionEntry.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Diagnostics {
    using System.ComponentModel;
    using System.Security.Permissions;
    
    /// <include file='doc\PerformanceCounterPermissionEntry.uex' path='docs/doc[@for="PerformanceCounterPermissionEntry"]/*' />
    [
    Serializable()
    ]
    public class PerformanceCounterPermissionEntry {
        private string categoryName;
        private string machineName;
        private PerformanceCounterPermissionAccess permissionAccess;
                    
        /// <include file='doc\PerformanceCounterPermissionEntry.uex' path='docs/doc[@for="PerformanceCounterPermissionEntry.PerformanceCounterPermissionEntry"]/*' />
        public PerformanceCounterPermissionEntry(PerformanceCounterPermissionAccess permissionAccess, string machineName, string categoryName) {
            if (categoryName == null)
                throw new ArgumentNullException("categoryName");
            
            if (!SyntaxCheck.CheckMachineName(machineName))
                throw new ArgumentException(SR.GetString(SR.InvalidParameter, "MachineName", machineName));
                                            
            this.permissionAccess = permissionAccess;
            this.machineName = machineName;
            this.categoryName = categoryName;
        }
        
        /// <include file='doc\PerformanceCounterPermissionEntry.uex' path='docs/doc[@for="PerformanceCounterPermissionEntry.PerformanceCounterPermissionEntry1"]/*' />                                                                                                                                 
        ///<internalonly/> 
        internal PerformanceCounterPermissionEntry(ResourcePermissionBaseEntry baseEntry) {
            this.permissionAccess = (PerformanceCounterPermissionAccess)baseEntry.PermissionAccess;
            this.machineName = baseEntry.PermissionAccessPath[0]; 
            this.categoryName = baseEntry.PermissionAccessPath[1]; 
        }
        
        /// <include file='doc\PerformanceCounterPermissionEntry.uex' path='docs/doc[@for="PerformanceCounterPermissionEntry.CategoryName"]/*' />
        public string CategoryName {
            get {
                return this.categoryName;
            }                        
        }

        /// <include file='doc\PerformanceCounterPermissionEntry.uex' path='docs/doc[@for="PerformanceCounterPermissionEntry.MachineName"]/*' />                                                               
        public string MachineName {
            get {
                return this.machineName;
            }            
        }

        /// <include file='doc\PerformanceCounterPermissionEntry.uex' path='docs/doc[@for="PerformanceCounterPermissionEntry.PermissionAccess"]/*' />                                        
        public PerformanceCounterPermissionAccess PermissionAccess {            
            get {
                return this.permissionAccess;
            }            
        }           
        
        /// <include file='doc\PerformanceCounterPermissionEntry.uex' path='docs/doc[@for="PerformanceCounterPermissionEntry.GetBaseEntry"]/*' />                                                                                                                                 
        ///<internalonly/> 
        internal ResourcePermissionBaseEntry GetBaseEntry() {
            ResourcePermissionBaseEntry baseEntry = new ResourcePermissionBaseEntry((int)this.PermissionAccess, new string[] {this.MachineName, this.CategoryName});            
            return baseEntry;
        }  
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\services\monitoring\system\diagnosticts\performancecountertype.cs ===
//------------------------------------------------------------------------------
// <copyright file="PerformanceCounterType.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Diagnostics {    
    using System;
    using System.ComponentModel;
    using Microsoft.Win32;


    /// <include file='doc\PerformanceCounterType.uex' path='docs/doc[@for="PerformanceCounterType"]/*' />
    /// <devdoc>
    ///     Enum of friendly names to counter types (maps directory to the native types)
    /// </devdoc>
    [TypeConverterAttribute(typeof(AlphabeticalEnumConverter))]
    public enum PerformanceCounterType {
        /// <include file='doc\PerformanceCounterType.uex' path='docs/doc[@for="PerformanceCounterType.NumberOfItems32"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        NumberOfItems32 = NativeMethods.PERF_COUNTER_RAWCOUNT,
        /// <include file='doc\PerformanceCounterType.uex' path='docs/doc[@for="PerformanceCounterType.NumberOfItems64"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        NumberOfItems64 = NativeMethods.PERF_COUNTER_LARGE_RAWCOUNT,
        /// <include file='doc\PerformanceCounterType.uex' path='docs/doc[@for="PerformanceCounterType.NumberOfItemsHEX32"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        NumberOfItemsHEX32 = NativeMethods.PERF_COUNTER_RAWCOUNT_HEX,
        /// <include file='doc\PerformanceCounterType.uex' path='docs/doc[@for="PerformanceCounterType.NumberOfItemsHEX64"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        NumberOfItemsHEX64 = NativeMethods.PERF_COUNTER_LARGE_RAWCOUNT_HEX,
        /// <include file='doc\PerformanceCounterType.uex' path='docs/doc[@for="PerformanceCounterType.RateOfCountsPerSecond32"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        RateOfCountsPerSecond32 = NativeMethods.PERF_COUNTER_COUNTER,
        /// <include file='doc\PerformanceCounterType.uex' path='docs/doc[@for="PerformanceCounterType.RateOfCountsPerSecond64"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        RateOfCountsPerSecond64 = NativeMethods.PERF_COUNTER_BULK_COUNT,
        /// <include file='doc\PerformanceCounterType.uex' path='docs/doc[@for="PerformanceCounterType.CountPerTimeInterval32"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        CountPerTimeInterval32 = NativeMethods.PERF_COUNTER_QUEUELEN_TYPE,
        /// <include file='doc\PerformanceCounterType.uex' path='docs/doc[@for="PerformanceCounterType.CountPerTimeInterval64"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        CountPerTimeInterval64 = NativeMethods.PERF_COUNTER_LARGE_QUEUELEN_TYPE,
        /// <include file='doc\PerformanceCounterType.uex' path='docs/doc[@for="PerformanceCounterType.RawFraction"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        RawFraction = NativeMethods.PERF_RAW_FRACTION,
        /// <include file='doc\PerformanceCounterType.uex' path='docs/doc[@for="PerformanceCounterType.RawBase"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        RawBase = NativeMethods.PERF_RAW_BASE,
        
        /// <include file='doc\PerformanceCounterType.uex' path='docs/doc[@for="PerformanceCounterType.AverageTimer32"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        AverageTimer32 = NativeMethods.PERF_AVERAGE_TIMER,
        /// <include file='doc\PerformanceCounterType.uex' path='docs/doc[@for="PerformanceCounterType.AverageBase"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        AverageBase = NativeMethods.PERF_AVERAGE_BASE,
        /// <include file='doc\PerformanceCounterType.uex' path='docs/doc[@for="PerformanceCounterType.AverageCount64"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        AverageCount64 = NativeMethods.PERF_AVERAGE_BULK,
        
        /// <include file='doc\PerformanceCounterType.uex' path='docs/doc[@for="PerformanceCounterType.SampleFraction"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        SampleFraction = NativeMethods.PERF_SAMPLE_FRACTION,
        /// <include file='doc\PerformanceCounterType.uex' path='docs/doc[@for="PerformanceCounterType.SampleCounter"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        SampleCounter = NativeMethods.PERF_SAMPLE_COUNTER,
        /// <include file='doc\PerformanceCounterType.uex' path='docs/doc[@for="PerformanceCounterType.SampleBase"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        SampleBase = NativeMethods.PERF_SAMPLE_BASE,
        
        /// <include file='doc\PerformanceCounterType.uex' path='docs/doc[@for="PerformanceCounterType.CounterTimer"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        CounterTimer = NativeMethods.PERF_COUNTER_TIMER,
        /// <include file='doc\PerformanceCounterType.uex' path='docs/doc[@for="PerformanceCounterType.CounterTimerInverse"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        CounterTimerInverse = NativeMethods.PERF_COUNTER_TIMER_INV,
        /// <include file='doc\PerformanceCounterType.uex' path='docs/doc[@for="PerformanceCounterType.Timer100Ns"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        Timer100Ns = NativeMethods.PERF_100NSEC_TIMER,
        /// <include file='doc\PerformanceCounterType.uex' path='docs/doc[@for="PerformanceCounterType.Timer100NsInverse"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        Timer100NsInverse= NativeMethods.PERF_100NSEC_TIMER_INV,
        /// <include file='doc\PerformanceCounterType.uex' path='docs/doc[@for="PerformanceCounterType.ElapsedTime"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        ElapsedTime = NativeMethods.PERF_ELAPSED_TIME,
        /// <include file='doc\PerformanceCounterType.uex' path='docs/doc[@for="PerformanceCounterType.CounterMultiTimer"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        CounterMultiTimer = NativeMethods.PERF_COUNTER_MULTI_TIMER,
        /// <include file='doc\PerformanceCounterType.uex' path='docs/doc[@for="PerformanceCounterType.CounterMultiTimerInverse"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        CounterMultiTimerInverse = NativeMethods.PERF_COUNTER_MULTI_TIMER_INV,
        /// <include file='doc\PerformanceCounterType.uex' path='docs/doc[@for="PerformanceCounterType.CounterMultiTimer100Ns"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        CounterMultiTimer100Ns = NativeMethods.PERF_100NSEC_MULTI_TIMER,
        /// <include file='doc\PerformanceCounterType.uex' path='docs/doc[@for="PerformanceCounterType.CounterMultiTimer100NsInverse"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        CounterMultiTimer100NsInverse = NativeMethods.PERF_100NSEC_MULTI_TIMER_INV,
        /// <include file='doc\PerformanceCounterType.uex' path='docs/doc[@for="PerformanceCounterType.CounterMultiBase"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        CounterMultiBase = NativeMethods.PERF_COUNTER_MULTI_BASE,

        /// <include file='doc\PerformanceCounterType.uex' path='docs/doc[@for="PerformanceCounterType.CounterDelta32"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        CounterDelta32 = NativeMethods.PERF_COUNTER_DELTA,
        /// <include file='doc\PerformanceCounterType.uex' path='docs/doc[@for="PerformanceCounterType.CounterDelta64"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        CounterDelta64 = NativeMethods.PERF_COUNTER_LARGE_DELTA

        //Unsupported
//        NoData = NativeMethods.PERF_COUNTER_NODATA;
//        Label = NativeMethods.PERF_COUNTER_TEXT;
        	
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\services\monitoring\system\diagnosticts\process.cs ===
//------------------------------------------------------------------------------
// <copyright file="Process.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Diagnostics {
    using System.Text;
    using System.Threading;
    using System.Runtime.InteropServices;
    using System.ComponentModel;
    using System.ComponentModel.Design;
    using System.Diagnostics;
    using System;
    using System.Collections;
    using System.IO;
    using Microsoft.Win32;        
    using System.Collections.Specialized;
    using System.Globalization;
    using System.Security;
    using System.Security.Permissions;

    /// <include file='doc\Process.uex' path='docs/doc[@for="Process"]/*' />
    /// <devdoc>
    ///    <para>
    ///       Provides access to local and remote
    ///       processes. Enables you to start and stop system processes.
    ///    </para>
    /// </devdoc>
    [
    DefaultEvent("Exited"), 
    DefaultProperty("StartInfo"),
    Designer("System.Diagnostics.Design.ProcessDesigner, " + AssemblyRef.SystemDesign),
    // Disabling partial trust scenarios
    PermissionSet(SecurityAction.LinkDemand, Name="FullTrust"),
    PermissionSet(SecurityAction.InheritanceDemand, Name="FullTrust")
    ]
    public class Process : Component {

        //
        // FIELDS
        //

        bool haveProcessId;
        int processId;
        bool haveProcessHandle;
        IntPtr processHandle;
        bool isRemoteMachine;
        string machineName;
        ProcessInfo processInfo;
        ProcessThreadCollection threads;
        ProcessModuleCollection modules;
        bool haveMainWindow;
        IntPtr mainWindowHandle;
        string mainWindowTitle;
        bool haveWorkingSetLimits;
        IntPtr minWorkingSet;
        IntPtr maxWorkingSet;
        bool haveProcessorAffinity;
        IntPtr processorAffinity;
        bool havePriorityClass;
        ProcessPriorityClass priorityClass;
        ProcessStartInfo startInfo;
        bool watchForExit;
        bool watchingForExit;
        EventHandler onExited;
        bool exited;
        int exitCode;
        DateTime exitTime;
        bool haveExitTime;
        bool responding;
        bool haveResponding;
        bool priorityBoostEnabled;
        bool havePriorityBoostEnabled;
        bool raisedOnExited;
        RegisteredWaitHandle registeredWaitHandle;
        WaitHandle waitHandle;
        ISynchronizeInvoke synchronizingObject;
        StreamReader standardOutput;
        StreamWriter standardInput;
        StreamReader standardError;
        OperatingSystem operatingSystem;
        bool disposed;

#if DEBUG
        internal static TraceSwitch processTracing = new TraceSwitch("processTracing", "Controls debug output from Process component");
#else
        internal static TraceSwitch processTracing = null;
#endif

        //
        // CONSTRUCTORS
        //

        /// <include file='doc\Process.uex' path='docs/doc[@for="Process.Process"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Initializes a new instance of the <see cref='System.Diagnostics.Process'/> class.
        ///    </para>
        /// </devdoc>
        public Process() {
            machineName = ".";
        }        
        
        Process(string machineName, bool isRemoteMachine, int processId, ProcessInfo processInfo) : base() {
            if (!SyntaxCheck.CheckMachineName(machineName))
                throw new ArgumentException(SR.GetString(SR.InvalidParameter, "machineName", machineName));

            this.processInfo = processInfo;
            this.machineName = machineName;
            this.isRemoteMachine = isRemoteMachine;
            this.processId = processId;
            this.haveProcessId = true;

        }

        //
        // PROPERTIES
        //

        /// <include file='doc\Process.uex' path='docs/doc[@for="Process.Associated"]/*' />
        /// <devdoc>
        ///     Returns whether this process component is associated with a real process.
        /// </devdoc>
        /// <internalonly/>
        [Browsable(false), DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden), MonitoringDescription(SR.ProcessAssociated)]
        bool Associated {
            get {
                return haveProcessId || haveProcessHandle;
            }
        }

        /// <include file='doc\Process.uex' path='docs/doc[@for="Process.BasePriority"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets the base priority of
        ///       the associated process.
        ///    </para>
        /// </devdoc>
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden), MonitoringDescription(SR.ProcessBasePriority)]
        public int BasePriority {
            get {
                EnsureState(State.HaveProcessInfo);
                return processInfo.basePriority;
            }
        }

        /// <include file='doc\Process.uex' path='docs/doc[@for="Process.ExitCode"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets
        ///       the
        ///       value that was specified by the associated process when it was terminated.
        ///    </para>
        /// </devdoc>
        [Browsable(false),DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden), MonitoringDescription(SR.ProcessExitCode)]
        public int ExitCode {
            get {
                EnsureState(State.Exited);
                return exitCode;
            }
        }

        /// <include file='doc\Process.uex' path='docs/doc[@for="Process.HasExited"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets a
        ///       value indicating whether the associated process has been terminated.
        ///    </para>
        /// </devdoc>
        [Browsable(false), DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden), MonitoringDescription(SR.ProcessTerminated)]
        public bool HasExited {
            get {
                if (!exited) {
                    EnsureState(State.Associated);
                    IntPtr processHandle = (IntPtr)0;
                    try {
                        processHandle = GetProcessHandle(NativeMethods.PROCESS_QUERY_INFORMATION, false);
                        if (processHandle == NativeMethods.INVALID_HANDLE_VALUE) {
                            exited = true;
                        }
                        else {
                            int exitCode;
                            if (!NativeMethods.GetExitCodeProcess(new HandleRef(this, processHandle), out exitCode))
                                throw new Win32Exception();
                            if (exitCode != NativeMethods.STILL_ALIVE) {
                                this.exited = true;
                                this.exitCode = exitCode;
                            }
                        }
                    }
                    finally {
                        ReleaseProcessHandle(processHandle);
                    }
                    if (exited)
                        RaiseOnExited();
                }
                return exited;
            }
        }

        /// <include file='doc\Process.uex' path='docs/doc[@for="Process.ExitTime"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets the time that the associated process exited.
        ///    </para>
        /// </devdoc>
        [Browsable(false), DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden), MonitoringDescription(SR.ProcessExitTime)]
        public DateTime ExitTime {
            get {
                if (!haveExitTime) {
                    EnsureState(State.IsNt | State.Exited);
                    IntPtr processHandle = (IntPtr)0;
                    try {
                        processHandle = GetProcessHandle(NativeMethods.PROCESS_QUERY_INFORMATION, false);
                        long[] create = new long[1];
                        long[] exit = new long[1];
                        long[] kernel = new long[1];
                        long[] user = new long[1];
                        if (!NativeMethods.GetProcessTimes(new HandleRef(this, processHandle), create, exit, kernel, user))
                            throw new Win32Exception();
                        exitTime = DateTime.FromFileTime(exit[0]);
                        haveExitTime = true;
                    }
                    finally {
                        ReleaseProcessHandle(processHandle);
                    }
                }
                return exitTime;
            }
        }

        /// <include file='doc\Process.uex' path='docs/doc[@for="Process.Handle"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Returns the native handle for the associated process. The handle is only available
        ///       if this component started the process.
        ///    </para>
        /// </devdoc>
        [Browsable(false), DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden), MonitoringDescription(SR.ProcessHandle)]
        public IntPtr Handle {
            get {
                EnsureState(State.Associated);
                return OpenProcessHandle();
            }
        }

        /// <include file='doc\Process.uex' path='docs/doc[@for="Process.HandleCount"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets the number of handles that are associated
        ///       with the process.
        ///    </para>
        /// </devdoc>
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden), MonitoringDescription(SR.ProcessHandleCount)]
        public int HandleCount {
            get {
                EnsureState(State.HaveProcessInfo);
                return processInfo.handleCount;
            }
        }

        /// <include file='doc\Process.uex' path='docs/doc[@for="Process.Id"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets
        ///       the unique identifier for the associated process.
        ///    </para>
        /// </devdoc>
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden), MonitoringDescription(SR.ProcessId)]
        public int Id {
            get {
                EnsureState(State.HaveId);
                return processId;
            }
        }

        /// <include file='doc\Process.uex' path='docs/doc[@for="Process.MachineName"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets
        ///       the name of the computer on which the associated process is running.
        ///    </para>
        /// </devdoc>
        [Browsable(false), DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden), MonitoringDescription(SR.ProcessMachineName)]
        public string MachineName {
            get {
                EnsureState(State.Associated);
                return machineName;
            }
        }

        /// <include file='doc\Process.uex' path='docs/doc[@for="Process.MainWindowHandle"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Returns the window handle of the main window of the associated process.
        ///    </para>
        /// </devdoc>
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden), MonitoringDescription(SR.ProcessMainWindowHandle)]
        public IntPtr MainWindowHandle {
            get {
                if (!haveMainWindow) {
                    EnsureState(State.IsLocal | State.HaveProcessInfo);
                    mainWindowHandle = ProcessManager.GetMainWindowHandle(processInfo);
                    haveMainWindow = true;
                }
                return mainWindowHandle;
            }
        }

        /// <include file='doc\Process.uex' path='docs/doc[@for="Process.MainWindowTitle"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Returns the caption of the <see cref='System.Diagnostics.Process.MainWindowHandle'/> of
        ///       the process. If the handle is zero (0), then an empty string is returned.
        ///    </para>
        /// </devdoc>
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden), MonitoringDescription(SR.ProcessMainWindowTitle)]
        public string MainWindowTitle {
            get {
                if (mainWindowTitle == null) {
                    IntPtr handle = MainWindowHandle;
                    if (handle == (IntPtr)0) {
                        mainWindowTitle = String.Empty;
                    }
                    else {
                        int length = NativeMethods.GetWindowTextLength(new HandleRef(this, handle)) * 2;
                        StringBuilder builder = new StringBuilder(length);
                        NativeMethods.GetWindowText(new HandleRef(this, handle), builder, builder.Capacity);
                        mainWindowTitle = builder.ToString();
                    }
                }
                return mainWindowTitle;
            }
        }

        /// <include file='doc\Process.uex' path='docs/doc[@for="Process.MainModule"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets
        ///       the main module for the associated process.
        ///    </para>
        /// </devdoc>
        [Browsable(false), DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden), MonitoringDescription(SR.ProcessMainModule)]
        public ProcessModule MainModule {
            get {
                ProcessModuleCollection moduleCollection = Modules;
                if (moduleCollection.Count > 0) {
                    if (OperatingSystem.Platform == PlatformID.Win32NT) {
                        // on NT the first module is the main module
                        return moduleCollection[0];
                    }
                    else {
                        // on 9x we have to do a little more work
                        EnsureState(State.HaveProcessInfo);
                        foreach (ProcessModule pm in moduleCollection) {
                            if (pm.moduleInfo.Id == processInfo.mainModuleId)
                                return pm;
                        }
                    }
                }

                // We only get here if we couldn't find a main module.
                // This could be because
                //      1. The process hasn't finished loading the main module (most likely)
                //      2. There are no modules loaded (possible for certain OS processes)
                //      3. Possibly other?
                return null;
            }
        }

        /// <include file='doc\Process.uex' path='docs/doc[@for="Process.MaxWorkingSet"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets or sets the maximum allowable working set for the associated
        ///       process.
        ///    </para>
        /// </devdoc>
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden), MonitoringDescription(SR.ProcessMaxWorkingSet)]
        public IntPtr MaxWorkingSet {
            get {
                EnsureWorkingSetLimits();
                return maxWorkingSet;
            }
            set {
                SetWorkingSetLimits(null, value);
            }
        }

        /// <include file='doc\Process.uex' path='docs/doc[@for="Process.MinWorkingSet"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets or sets the minimum allowable working set for the associated
        ///       process.
        ///    </para>
        /// </devdoc>
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden), MonitoringDescription(SR.ProcessMinWorkingSet)]
        public IntPtr MinWorkingSet {
            get {
                EnsureWorkingSetLimits();
                return minWorkingSet;
            }
            set {
                SetWorkingSetLimits(value, null);
            }
        }

        /// <include file='doc\Process.uex' path='docs/doc[@for="Process.Modules"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets
        ///       the modules that have been loaded by the associated process.
        ///    </para>
        /// </devdoc>
        [Browsable(false), DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden), MonitoringDescription(SR.ProcessModules)]
        public ProcessModuleCollection Modules {
            get {
                if (modules == null) {
                    EnsureState(State.HaveId | State.IsLocal);
                    ModuleInfo[] moduleInfos = ProcessManager.GetModuleInfos(processId);
                    ProcessModule[] newModulesArray = new ProcessModule[moduleInfos.Length];
                    for (int i = 0; i < moduleInfos.Length; i++)
                        newModulesArray[i] = new ProcessModule(moduleInfos[i]);
                    ProcessModuleCollection newModules = new ProcessModuleCollection(newModulesArray);
                    modules = newModules;
                }
                return modules;
            }
        }

        /// <include file='doc\Process.uex' path='docs/doc[@for="Process.NonpagedSystemMemorySize"]/*' />
        /// <devdoc>
        ///     Returns the amount of memory that the system has allocated on behalf of the
        ///     associated process that can not be written to the virtual memory paging file.
        /// </devdoc>
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden), MonitoringDescription(SR.ProcessNonpagedSystemMemorySize)]
        public int NonpagedSystemMemorySize {
            get {
                EnsureState(State.HaveNtProcessInfo);
                return processInfo.poolNonpagedBytes;
            }
        }

        /// <include file='doc\Process.uex' path='docs/doc[@for="Process.PagedMemorySize"]/*' />
        /// <devdoc>
        ///     Returns the amount of memory that the associated process has allocated
        ///     that can be written to the virtual memory paging file.
        /// </devdoc>
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden), MonitoringDescription(SR.ProcessPagedMemorySize)]
        public int PagedMemorySize {
            get {
                EnsureState(State.HaveNtProcessInfo);
                return processInfo.pageFileBytes;
            }
        }

        /// <include file='doc\Process.uex' path='docs/doc[@for="Process.PagedSystemMemorySize"]/*' />
        /// <devdoc>
        ///     Returns the amount of memory that the system has allocated on behalf of the
        ///     associated process that can be written to the virtual memory paging file.
        /// </devdoc>
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden), MonitoringDescription(SR.ProcessPagedSystemMemorySize)]
        public int PagedSystemMemorySize {
            get {
                EnsureState(State.HaveNtProcessInfo);
                return processInfo.poolPagedBytes;
            }
        }

        /// <include file='doc\Process.uex' path='docs/doc[@for="Process.PeakPagedMemorySize"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Returns the maximum amount of memory that the associated process has
        ///       allocated that could be written to the virtual memory paging file.
        ///    </para>
        /// </devdoc>
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden), MonitoringDescription(SR.ProcessPeakPagedMemorySize)]
        public int PeakPagedMemorySize {
            get {
                EnsureState(State.HaveNtProcessInfo);
                return processInfo.pageFileBytesPeak;
            }
        }

        /// <include file='doc\Process.uex' path='docs/doc[@for="Process.PeakWorkingSet"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Returns the maximum amount of physical memory that the associated
        ///       process required at once.
        ///    </para>
        /// </devdoc>
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden), MonitoringDescription(SR.ProcessPeakWorkingSet)]
        public int PeakWorkingSet {
            get {
                EnsureState(State.HaveNtProcessInfo);
                return processInfo.workingSetPeak;
            }
        }

        /// <include file='doc\Process.uex' path='docs/doc[@for="Process.PeakVirtualMemorySize"]/*' />
        /// <devdoc>
        ///     Returns the maximum amount of virtual memory that the associated
        ///     process has requested.
        /// </devdoc>
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden), MonitoringDescription(SR.ProcessPeakVirtualMemorySize)]
        public int PeakVirtualMemorySize {
            get {
                EnsureState(State.HaveNtProcessInfo);
                return processInfo.virtualBytesPeak;
            }
        }

        private OperatingSystem OperatingSystem {
            get {
                if (operatingSystem == null)
                    operatingSystem = Environment.OSVersion;
                
                return operatingSystem;
            }
        }

        /// <include file='doc\Process.uex' path='docs/doc[@for="Process.PriorityBoostEnabled"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets or sets a value indicating whether the associated process priority
        ///       should be temporarily boosted by the operating system when the main window
        ///       has focus.
        ///    </para>
        /// </devdoc>
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden), MonitoringDescription(SR.ProcessPriorityBoostEnabled)]
        public bool PriorityBoostEnabled {
            get {
                EnsureState(State.IsNt);
                if (!havePriorityBoostEnabled) {
                    IntPtr processHandle = (IntPtr)0;
                    try {
                        processHandle = GetProcessHandle(NativeMethods.PROCESS_QUERY_INFORMATION);
                        bool disabled = false;
                        if (!NativeMethods.GetProcessPriorityBoost(new HandleRef(this, processHandle), out disabled))
                            throw new Win32Exception();
                        priorityBoostEnabled = !disabled;
                        havePriorityBoostEnabled = true;
                    }
                    finally {
                        ReleaseProcessHandle(processHandle);
                    }
                }
                return priorityBoostEnabled;
            }
            set {
                EnsureState(State.IsNt);
                IntPtr processHandle = (IntPtr)0;
                try {
                    processHandle = GetProcessHandle(NativeMethods.PROCESS_SET_INFORMATION);
                    if (!NativeMethods.SetProcessPriorityBoost(new HandleRef(this, processHandle), !value))
                        throw new Win32Exception();
                    priorityBoostEnabled = value;
                    havePriorityBoostEnabled = true;
                }
                finally {
                    ReleaseProcessHandle(processHandle);
                }
            }
        }

        /// <include file='doc\Process.uex' path='docs/doc[@for="Process.PriorityClass"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets or sets the overall priority category for the
        ///       associated process.
        ///    </para>
        /// </devdoc>
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden), MonitoringDescription(SR.ProcessPriorityClass)]
        public ProcessPriorityClass PriorityClass {
            get {
                if (!havePriorityClass) {
                    IntPtr processHandle = (IntPtr)0;
                    try {
                        processHandle = GetProcessHandle(NativeMethods.PROCESS_QUERY_INFORMATION);
                        int value = NativeMethods.GetPriorityClass(new HandleRef(this, processHandle));
                        if (value == 0) throw new Win32Exception();
                        priorityClass = (ProcessPriorityClass)value;
                        havePriorityClass = true;
                    }
                    finally {
                        ReleaseProcessHandle(processHandle);
                    }
                }
                return priorityClass;
            }
            set {
                if (!Enum.IsDefined(typeof(ProcessPriorityClass), value)) 
                    throw new InvalidEnumArgumentException("value", (int)value, typeof(ProcessPriorityClass));

                // BelowNormal and AboveNormal are only available on Win2k and greater.
                if (((value & (ProcessPriorityClass.BelowNormal | ProcessPriorityClass.AboveNormal)) != 0)   && 
                    (OperatingSystem.Platform != PlatformID.Win32NT ||
                     OperatingSystem.Version.Major < 5)) {

                    throw new PlatformNotSupportedException(SR.GetString(SR.PriorityClassNotSupported), null);
                }

                
                                    
                IntPtr processHandle = (IntPtr)0;

                try {
                    processHandle = GetProcessHandle(NativeMethods.PROCESS_SET_INFORMATION);
                    if (!NativeMethods.SetPriorityClass(new HandleRef(this, processHandle), (int)value))
                        throw new Win32Exception();
                    priorityClass = value;
                    havePriorityClass = true;
                }
                finally {
                    ReleaseProcessHandle(processHandle);
                }
            }
        }

        /// <include file='doc\Process.uex' path='docs/doc[@for="Process.PrivateMemorySize"]/*' />
        /// <devdoc>
        ///     Returns the number of bytes that the associated process has allocated that cannot
        ///     be shared with other processes.
        /// </devdoc>
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden), MonitoringDescription(SR.ProcessPrivateMemorySize)]
        public int PrivateMemorySize {
            get {
                EnsureState(State.HaveNtProcessInfo);
                return processInfo.privateBytes;
            }
        }

        /// <include file='doc\Process.uex' path='docs/doc[@for="Process.PrivilegedProcessorTime"]/*' />
        /// <devdoc>
        ///     Returns the amount of time the process has spent running code inside the operating
        ///     system core.
        /// </devdoc>
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden), MonitoringDescription(SR.ProcessPrivilegedProcessorTime)]
        public TimeSpan PrivilegedProcessorTime {
            get {
                EnsureState(State.HaveNtProcessInfo);
                return processInfo.privilegedTime;
            }
        }

        /// <include file='doc\Process.uex' path='docs/doc[@for="Process.ProcessName"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets
        ///       the friendly name of the process.
        ///    </para>
        /// </devdoc>
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden), MonitoringDescription(SR.ProcessProcessName)]
        public string ProcessName {
            get {
                EnsureState(State.HaveProcessInfo);
                String processName =  processInfo.processName;
				if (processName.Length == 15 && ProcessManager.IsNt) { // We may have the truncated name
					String mainModuleName = MainModule.ModuleName;
					if (mainModuleName != null) {
						processInfo.processName = Path.ChangeExtension(Path.GetFileName(mainModuleName), null);
					}
				}
				return processInfo.processName;
                //return Path.ChangeExtension(Path.GetFileName(MainModule.ModuleName), null);
            }
        }

        /// <include file='doc\Process.uex' path='docs/doc[@for="Process.ProcessorAffinity"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets
        ///       or sets which processors the threads in this process can be scheduled to run on.
        ///    </para>
        /// </devdoc>
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden), MonitoringDescription(SR.ProcessProcessorAffinity)]
        public IntPtr ProcessorAffinity {
            get {
                if (!haveProcessorAffinity) {
                    IntPtr processHandle = (IntPtr)0;
                    try {
                        processHandle = GetProcessHandle(NativeMethods.PROCESS_QUERY_INFORMATION);
                        IntPtr processAffinity;
                        IntPtr systemAffinity;
                        if (!NativeMethods.GetProcessAffinityMask(new HandleRef(this, processHandle), out processAffinity, out systemAffinity))
                            throw new Win32Exception();
                        processorAffinity = processAffinity;
                    }
                    finally {
                        ReleaseProcessHandle(processHandle);
                    }
                    haveProcessorAffinity = true;
                }
                return processorAffinity;
            }
            set {
                IntPtr processHandle = (IntPtr)0;
                try {
                    processHandle = GetProcessHandle(NativeMethods.PROCESS_SET_INFORMATION);
                    if (!NativeMethods.SetProcessAffinityMask(new HandleRef(this, processHandle), value)) 
                        throw new Win32Exception();
                        
                    processorAffinity = value;
                    haveProcessorAffinity = true;
                }
                finally {
                    ReleaseProcessHandle(processHandle);
                }
            }
        }

        /// <include file='doc\Process.uex' path='docs/doc[@for="Process.Responding"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets a value indicating whether or not the user
        ///       interface of the process is responding.
        ///    </para>
        /// </devdoc>
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden), MonitoringDescription(SR.ProcessResponding)]
        public bool Responding {
            get {
                if (!haveResponding) {
                    IntPtr mainWindow = MainWindowHandle;
                    if (mainWindow == (IntPtr)0) {
                        responding = true;
                    }
                    else {
                        IntPtr result;
                        responding = NativeMethods.SendMessageTimeout(new HandleRef(this, mainWindow), NativeMethods.WM_NULL, IntPtr.Zero, IntPtr.Zero, NativeMethods.SMTO_ABORTIFHUNG, 5000, out result) != (IntPtr)0;
                    }
                }
                return responding;
            }
        }

        /// <include file='doc\Process.uex' path='docs/doc[@for="Process.StartInfo"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets or sets the properties to pass into the <see cref='System.Diagnostics.Process.Start'/> method for the <see cref='System.Diagnostics.Process'/>
        ///       .
        ///    </para>
        /// </devdoc>
        [Browsable(false), DesignerSerializationVisibility(DesignerSerializationVisibility.Content), MonitoringDescription(SR.ProcessStartInfo)]
        public ProcessStartInfo StartInfo {
            get {
                if (startInfo == null)
                    startInfo = new ProcessStartInfo(this);
                return startInfo;
            }
            set {
                if (value == null) throw new ArgumentNullException("value");
                startInfo = value;
            }
        }

        /// <include file='doc\Process.uex' path='docs/doc[@for="Process.StartTime"]/*' />
        /// <devdoc>
        ///     Returns the time the associated process was started.
        /// </devdoc>
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden), MonitoringDescription(SR.ProcessStartTime)]
        public DateTime StartTime {
            get {
                EnsureState(State.HaveNtProcessInfo);
                return processInfo.startTime;
            }
        }

        /// <include file='doc\Process.uex' path='docs/doc[@for="Process.SynchronizingObject"]/*' />
        /// <devdoc>
        ///   Represents the object used to marshal the event handler
        ///   calls issued as a result of a Process exit. Normally 
        ///   this property will  be set when the component is placed 
        ///   inside a control or  a from, since those components are 
        ///   bound to a specific thread.
        /// </devdoc>
        [Browsable(false), DefaultValue(null), MonitoringDescription(SR.ProcessSynchronizingObject)]
        public ISynchronizeInvoke SynchronizingObject {
            get {
               if (this.synchronizingObject == null && DesignMode) {
                    IDesignerHost host = (IDesignerHost)GetService(typeof(IDesignerHost));
                    if (host != null) {
                        object baseComponent = host.RootComponent;
                        if (baseComponent != null && baseComponent is ISynchronizeInvoke)
                            this.synchronizingObject = (ISynchronizeInvoke)baseComponent;
                    }                        
                }

                return this.synchronizingObject;
            }
            
            set {
                this.synchronizingObject = value;
            }
        }        
        
        /// <include file='doc\Process.uex' path='docs/doc[@for="Process.Threads"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets the set of threads that are running in the associated
        ///       process.
        ///    </para>
        /// </devdoc>
        [Browsable(false), DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden), MonitoringDescription(SR.ProcessThreads)]
        public ProcessThreadCollection Threads {
            get {
                if (threads == null) {
                    EnsureState(State.HaveProcessInfo);
                    int count = processInfo.threadInfoList.Count;
                    ProcessThread[] newThreadsArray = new ProcessThread[count];
                    for (int i = 0; i < count; i++)
                        newThreadsArray[i] = new ProcessThread(isRemoteMachine, (ThreadInfo)processInfo.threadInfoList[i]);
                    ProcessThreadCollection newThreads = new ProcessThreadCollection(newThreadsArray);
                    threads = newThreads;
                }
                return threads;
            }
        }

        /// <include file='doc\Process.uex' path='docs/doc[@for="Process.TotalProcessorTime"]/*' />
        /// <devdoc>
        ///     Returns the amount of time the associated process has spent utilizing the CPU.
        ///     It is the sum of the <see cref='System.Diagnostics.Process.UserProcessorTime'/> and
        ///     <see cref='System.Diagnostics.Process.PrivilegedProcessorTime'/>.
        /// </devdoc>
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden), MonitoringDescription(SR.ProcessTotalProcessorTime)]
        public TimeSpan TotalProcessorTime {
            get {
                EnsureState(State.HaveNtProcessInfo);
                return processInfo.userTime + processInfo.privilegedTime;
            }
        }

        /// <include file='doc\Process.uex' path='docs/doc[@for="Process.UserProcessorTime"]/*' />
        /// <devdoc>
        ///     Returns the amount of time the associated process has spent running code
        ///     inside the application portion of the process (not the operating system core).
        /// </devdoc>
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden), MonitoringDescription(SR.ProcessUserProcessorTime)]
        public TimeSpan UserProcessorTime {
            get {
                EnsureState(State.HaveNtProcessInfo);
                return processInfo.userTime;
            }
        }

        /// <include file='doc\Process.uex' path='docs/doc[@for="Process.VirtualMemorySize"]/*' />
        /// <devdoc>
        ///     Returns the amount of virtual memory that the associated process has requested.
        /// </devdoc>
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden), MonitoringDescription(SR.ProcessVirtualMemorySize)]
        public int VirtualMemorySize {
            get {
                EnsureState(State.HaveNtProcessInfo);
                return processInfo.virtualBytes;
            }
        }

        /// <include file='doc\Process.uex' path='docs/doc[@for="Process.EnableRaisingEvents"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets or sets whether the <see cref='System.Diagnostics.Process.Exited'/>
        ///       event is fired
        ///       when the process terminates.
        ///    </para>
        /// </devdoc>
        [Browsable(false), DefaultValue(false), MonitoringDescription(SR.ProcessEnableRaisingEvents)]
        public bool EnableRaisingEvents {
            get {
                return watchForExit;
            }
            set {
                if (value != watchForExit) {
                    if (Associated) {
                        if (value) {
                            OpenProcessHandle();
                            EnsureWatchingForExit();
                        }
                        else
                            StopWatchingForExit();
                    }
                    watchForExit = value;
                }
            }
        }


        /// <include file='doc\Process.uex' path='docs/doc[@for="Process.StandardInput"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        [Browsable(false), DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden), MonitoringDescription(SR.ProcessStandardInput)]
        public StreamWriter StandardInput {
            get { 
                if (standardInput == null)
                    throw new InvalidOperationException(SR.GetString(SR.CantGetStandardIn));

                return standardInput;
            }
        }

        /// <include file='doc\Process.uex' path='docs/doc[@for="Process.StandardOutput"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        [Browsable(false), DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden), MonitoringDescription(SR.ProcessStandardOutput)]
        public StreamReader StandardOutput {
            get {
                if (standardOutput == null)
                    throw new InvalidOperationException(SR.GetString(SR.CantGetStandardOut));

                return standardOutput;
            }
        }

        /// <include file='doc\Process.uex' path='docs/doc[@for="Process.StandardError"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        [Browsable(false), DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden), MonitoringDescription(SR.ProcessStandardError)]
        public StreamReader StandardError {
            get { 
                if (standardError == null)
                    throw new InvalidOperationException(SR.GetString(SR.CantGetStandardError));

                return standardError;
            }
        }


        /// <include file='doc\Process.uex' path='docs/doc[@for="Process.WorkingSet"]/*' />
        /// <devdoc>
        ///     Returns the total amount of physical memory the associated process.
        /// </devdoc>
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden), MonitoringDescription(SR.ProcessWorkingSet)]
        public int WorkingSet {
            get {
                EnsureState(State.HaveNtProcessInfo);
                return processInfo.workingSet;
            }
        }

        //
        // METHODS
        //

        /// <include file='doc\Process.uex' path='docs/doc[@for="Process.Exited"]/*' />
        [Category("Behavior"), MonitoringDescription(SR.ProcessExited)]
        public event EventHandler Exited {
            add {
                onExited += value;
            }
            remove {
                onExited -= value;
            }
        }

        /// <include file='doc\Process.uex' path='docs/doc[@for="Process.CloseMainWindow"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Closes a process that has a user interface by sending a close message
        ///       to its main window.
        ///    </para>
        /// </devdoc>
        public bool CloseMainWindow() {
            IntPtr mainWindowHandle = MainWindowHandle;
            if (mainWindowHandle == (IntPtr)0) return false;
            int style = NativeMethods.GetWindowLong(new HandleRef(this, mainWindowHandle), NativeMethods.GWL_STYLE);
            if ((style & NativeMethods.WS_DISABLED) != 0) return false;
            NativeMethods.PostMessage(new HandleRef(this, mainWindowHandle), NativeMethods.WM_CLOSE, IntPtr.Zero, IntPtr.Zero);
            return true;
        }

        /// <include file='doc\Process.uex' path='docs/doc[@for="Process.ReleaseProcessHandle"]/*' />
        /// <devdoc>
        ///     Close the process handle if it has been removed.
        /// </devdoc>
        /// <internalonly/>
        void ReleaseProcessHandle(IntPtr handle) {
            if (haveProcessHandle && handle == processHandle) return;
            if (handle == (IntPtr)0) return;
            Debug.WriteLineIf(processTracing.TraceVerbose, "Process - CloseHandle(process)");
            SafeNativeMethods.CloseHandle(new HandleRef(this, handle));
        }

        /// <include file='doc\Process.uex' path='docs/doc[@for="Process.CompletionCallback"]/*' />
        /// <devdoc>
        ///     This is called from the threadpool when a proces exits.
        /// </devdoc>
        /// <internalonly/>
        private void CompletionCallback(object context, bool wasSignaled) {
            StopWatchingForExit();
            RaiseOnExited();      
        }

        /// <include file='doc\Process.uex' path='docs/doc[@for="Process.Dispose1"]/*' />
        /// <internalonly/>
        /// <devdoc>
        ///    <para>
        ///       Free any resources associated with this component.
        ///    </para>
        /// </devdoc>
        protected override void Dispose(bool disposing) {
            if (disposing) {
                //Dispose managed and unmanaged resources
                Close();
            }
            else {
                //Dispose unmanaged resources
                if (haveProcessHandle && processHandle != (IntPtr)0) {                    
                    Debug.WriteLineIf(processTracing.TraceVerbose, "Process - CloseHandle(process) in Dispose(false)");
                    SafeNativeMethods.CloseHandle(new HandleRef(this, processHandle));
                    processHandle = (IntPtr)0;
                }                    
            }
            
            this.disposed = true;
            base.Dispose(disposing);
        }

        /// <include file='doc\Process.uex' path='docs/doc[@for="Process.Close"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Frees any resources associated with this component.
        ///    </para>
        /// </devdoc>
        public void Close() {
            if (Associated) {
                if (haveProcessHandle) {
                    StopWatchingForExit();
                    Debug.WriteLineIf(processTracing.TraceVerbose, "Process - CloseHandle(process) in Close()");
                    SafeNativeMethods.CloseHandle(new HandleRef(this, processHandle));
                    processHandle = (IntPtr)0;
                    haveProcessHandle = false;
                }
                haveProcessId = false;
                isRemoteMachine = false;
                machineName = ".";
                raisedOnExited = false;
                
                //REVIEW: jruiz - Don't call close on the Readers and writers
                //since they might be referenced by somebody else while the 
                //process is still alive but this method called.
                standardOutput = null;
                standardInput = null;
                standardError = null;                

                Refresh();
            }
        }

        /// <include file='doc\Process.uex' path='docs/doc[@for="Process.EnsureState"]/*' />
        /// <devdoc>
        ///     Helper method for checking preconditions when accessing properties.
        /// </devdoc>
        /// <internalonly/>
        void EnsureState(State state) {
            if ((state & State.IsWin2k) != (State)0) {
                if (OperatingSystem.Platform != PlatformID.Win32NT || OperatingSystem.Version.Major < 5)
                    throw new PlatformNotSupportedException(SR.GetString(SR.Win2kRequired));
            }

            if ((state & State.IsNt) != (State)0) {
                if (OperatingSystem.Platform != PlatformID.Win32NT)
                    throw new PlatformNotSupportedException(SR.GetString(SR.WinNTRequired));
            }

            if ((state & State.Associated) != (State)0)
                if (!Associated)
                    throw new InvalidOperationException(SR.GetString(SR.NoAssociatedProcess));

            if ((state & State.HaveId) != (State)0) {
                if (!haveProcessId) {
                    if (haveProcessHandle)
                        SetProcessId(ProcessManager.GetProcessIdFromHandle(processHandle));
                    else {
                        EnsureState(State.Associated);
                        throw new InvalidOperationException(SR.GetString(SR.ProcessIdRequired));
                    }
                }
            }

            if ((state & State.IsLocal) != (State)0)
                if (isRemoteMachine)
                    throw new NotSupportedException(SR.GetString(SR.NotSupportedRemote));

            if ((state & State.HaveProcessInfo) != (State)0) {
                if (processInfo == null) {
                    if ((state & State.HaveId) == (State)0) EnsureState(State.HaveId);
                    ProcessInfo[] processInfos = ProcessManager.GetProcessInfos(machineName);
                    for (int i = 0; i < processInfos.Length; i++) {
                        if (processInfos[i].processId == processId) {
                            this.processInfo = processInfos[i];
                            break;
                        }
                    }
                    if (processInfo == null)
                        throw new InvalidOperationException(SR.GetString(SR.NoProcessInfo));
                }
            }

            if ((state & State.Exited) != (State)0) {
                if (!HasExited)
                    throw new InvalidOperationException(SR.GetString(SR.WaitTillExit));
                if (!haveProcessHandle)
                    throw new InvalidOperationException(SR.GetString(SR.NoProcessHandle));
            }
        }

        /// <include file='doc\Process.uex' path='docs/doc[@for="Process.EnsureWatchingForExit"]/*' />
        /// <devdoc>
        ///     Make sure we are watching for a process exit.
        /// </devdoc>
        /// <internalonly/>
        void EnsureWatchingForExit() {
            if (!watchingForExit) {
                Debug.Assert(haveProcessHandle, "Process.EnsureWatchingForExit called with no process handle");
                Debug.Assert(Associated, "Process.EnsureWatchingForExit called with no associated process");
                watchingForExit = true;
                try {
                    this.waitHandle = new ProcessWaitHandle();
                    this.waitHandle.Handle = processHandle;
                    this.registeredWaitHandle = ThreadPool.RegisterWaitForSingleObject(this.waitHandle,
                        new WaitOrTimerCallback(this.CompletionCallback), null, -1, true);                    
                }
                catch {
                    watchingForExit = false;
                    throw;
                }
            }
        }

        /// <include file='doc\Process.uex' path='docs/doc[@for="Process.EnsureWorkingSetLimits"]/*' />
        /// <devdoc>
        ///     Make sure we have obtained the min and max working set limits.
        /// </devdoc>
        /// <internalonly/>
        void EnsureWorkingSetLimits() {
            EnsureState(State.IsNt);
            if (!haveWorkingSetLimits) {
                IntPtr processHandle = (IntPtr)0;
                try {
                    processHandle = GetProcessHandle(NativeMethods.PROCESS_QUERY_INFORMATION);
                    IntPtr min;
                    IntPtr max;
                    if (!NativeMethods.GetProcessWorkingSetSize(new HandleRef(this, processHandle), out min, out max))
                        throw new Win32Exception();
                    minWorkingSet = min;
                    maxWorkingSet = max;
                    haveWorkingSetLimits = true;
                }
                finally {
                    ReleaseProcessHandle(processHandle);
                }
            }
        }

        /// <include file='doc\Process.uex' path='docs/doc[@for="Process.EnterDebugMode"]/*' />
        public static void EnterDebugMode() {
            if (ProcessManager.IsNt) {
                SetPrivilege("SeDebugPrivilege", NativeMethods.SE_PRIVILEGE_ENABLED);
            }
        }

        private static void SetPrivilege(string privilegeName, int attrib) {
            IntPtr hToken = (IntPtr)0;
            NativeMethods.LUID debugValue = new NativeMethods.LUID();

            // this is only a "pseudo handle" to the current process - no need to close it later
            IntPtr processHandle = NativeMethods.GetCurrentProcess();

            // get the process token so we can adjust the privilege on it.  We DO need to
            // close the token when we're done with it.
            if (!NativeMethods.OpenProcessToken(new HandleRef(null, processHandle), NativeMethods.TOKEN_ADJUST_PRIVILEGES, out hToken)) {
                throw new Win32Exception();
            }

            try {
                if (!NativeMethods.LookupPrivilegeValue(null, privilegeName, out debugValue)) {
                    throw new Win32Exception();
                }
                
                NativeMethods.TokenPrivileges tkp = new NativeMethods.TokenPrivileges();
                tkp.Luid = debugValue;
                tkp.Attributes = attrib;
    
                NativeMethods.AdjustTokenPrivileges(new HandleRef(null, hToken), false, tkp, 0, IntPtr.Zero, IntPtr.Zero);
    
                // AdjustTokenPrivileges can return true even if it failed to
                // set the privilege, so we need to use GetLastError
                if (Marshal.GetLastWin32Error() != NativeMethods.ERROR_SUCCESS)
                    throw new Win32Exception();
            }
            finally {
                Debug.WriteLineIf(processTracing.TraceVerbose, "Process - CloseHandle(processToken)");
                SafeNativeMethods.CloseHandle(new HandleRef(null, hToken));
            }
        }

        /// <include file='doc\Process.uex' path='docs/doc[@for="Process.LeaveDebugMode"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public static void LeaveDebugMode() {
            if (ProcessManager.IsNt) {
                SetPrivilege("SeDebugPrivilege", 0);
            }
        }

        /// <include file='doc\Process.uex' path='docs/doc[@for="Process.GetProcessById"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Returns a new <see cref='System.Diagnostics.Process'/> component given a process identifier and
        ///       the name of a computer in the network.
        ///    </para>
        /// </devdoc>
        public static Process GetProcessById(int processId, string machineName) {
            if (!ProcessManager.IsProcessRunning(processId, machineName)) throw new ArgumentException(SR.GetString(SR.MissingProccess, processId.ToString()));
            return new Process(machineName, ProcessManager.IsRemoteMachine(machineName), processId, null);
        }

        /// <include file='doc\Process.uex' path='docs/doc[@for="Process.GetProcessById1"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Returns a new <see cref='System.Diagnostics.Process'/> component given the
        ///       identifier of a process on the local computer.
        ///    </para>
        /// </devdoc>
        public static Process GetProcessById(int processId) {
            return GetProcessById(processId, ".");
        }

        /// <include file='doc\Process.uex' path='docs/doc[@for="Process.GetProcessesByName"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Creates an array of <see cref='System.Diagnostics.Process'/> components that are
        ///       associated
        ///       with process resources on the
        ///       local computer. These process resources share the specified process name.
        ///    </para>
        /// </devdoc>
        public static Process[] GetProcessesByName(string processName) {
            return GetProcessesByName(processName, ".");
        }

        /// <include file='doc\Process.uex' path='docs/doc[@for="Process.GetProcessesByName1"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Creates an array of <see cref='System.Diagnostics.Process'/> components that are associated with process resources on a
        ///       remote computer. These process resources share the specified process name.
        ///    </para>
        /// </devdoc>
        public static Process[] GetProcessesByName(string processName, string machineName) {
            if (processName == null) processName = String.Empty;
            ProcessInfo[] processInfos = ProcessManager.GetProcessInfos(machineName);
            ArrayList list = new ArrayList();
            for (int i = 0; i < processInfos.Length; i++) {
                ProcessInfo processInfo = processInfos[i];

                // NOTE: perf counters only keep track of the first 15 characters of the exe name.
                // Furthermore, it chops off the ".exe", if it's in the first 15 characters.  So,
                // for example, "myApp.exe" will be "myApp".  If the user has asked for a process
                // name that is less then 15 characters, than we can safely compare directly.
                // However, if the user asked about a process that has a name that is at least 15
                // characters, and there is a perf counter instance name that matches the first
                // 15 characters, we can't tell if it's a complete match or not.  In this case
                // we try to get the mainmodule of the process and compare directly with the filename.
                // In win9x we get the whole name, so we don't have to worry about it there.
                
                bool addToList = false;
                
                if (processName.Length < 15 || !ProcessManager.IsNt) {
                    // this should be the common case by far
                    addToList = (string.Compare(processName, processInfo.processName, true, CultureInfo.InvariantCulture) == 0);
                }
                else if (0 == string.Compare(processName, 0, processInfo.processName, 0, 15, true, CultureInfo.InvariantCulture)) {
                    // okay, this MIGHT be a match... now we'll compare the module name (which is quite expensive).  
                    try {
                        using (Process tempProcess = GetProcessById(processInfo.processId, machineName)) {
                            string mainModuleName = tempProcess.MainModule.ModuleName.ToLower(CultureInfo.InvariantCulture);
                            if (mainModuleName.EndsWith(".exe")) {
                                mainModuleName = mainModuleName.Substring(0, mainModuleName.Length - 4);
                            }
                            addToList = (string.Compare(processName, mainModuleName, true, CultureInfo.InvariantCulture) == 0);
                        }
                    }
                    catch (Exception) {
                        // Well, this looks like a match but we weren't able to look at the module
                        // name (probably an "Access Denied"), so we can't find out for sure.  Better
                        // to return it just in case.
                        addToList = true;
                    }
                }

                if (addToList) {
                    list.Add(new Process(machineName, ProcessManager.IsRemoteMachine(machineName), processInfo.processId, processInfo));
                }
            }
            Process[] temp = new Process[list.Count];
            list.CopyTo(temp, 0);
            return temp;
        }

        /// <include file='doc\Process.uex' path='docs/doc[@for="Process.GetProcesses"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Creates a new <see cref='System.Diagnostics.Process'/>
        ///       component for each process resource on the local computer.
        ///    </para>
        /// </devdoc>
        public static Process[] GetProcesses() {
            return GetProcesses(".");
        }

        /// <include file='doc\Process.uex' path='docs/doc[@for="Process.GetProcesses1"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Creates a new <see cref='System.Diagnostics.Process'/>
        ///       component for each
        ///       process resource on the specified computer.
        ///    </para>
        /// </devdoc>
        public static Process[] GetProcesses(string machineName) {
            bool isRemoteMachine = ProcessManager.IsRemoteMachine(machineName);
            ProcessInfo[] processInfos = ProcessManager.GetProcessInfos(machineName);
            Process[] processes = new Process[processInfos.Length];
            for (int i = 0; i < processInfos.Length; i++) {
                ProcessInfo processInfo = processInfos[i];
                processes[i] = new Process(machineName, isRemoteMachine, processInfo.processId, processInfo);
            }
            Debug.WriteLineIf(processTracing.TraceVerbose, "Process.GetProcesses(" + machineName + ")");
#if DEBUG
            if (processTracing.TraceVerbose) {
                Debug.Indent();
                for (int i = 0; i < processInfos.Length; i++) {
                    Debug.WriteLine(processes[i].Id + ": " + processes[i].ProcessName);
                }
                Debug.Unindent();
            }
#endif
            return processes;
        }

        /// <include file='doc\Process.uex' path='docs/doc[@for="Process.GetCurrentProcess"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Returns a new <see cref='System.Diagnostics.Process'/>
        ///       component and associates it with the current active process.
        ///    </para>
        /// </devdoc>
        public static Process GetCurrentProcess() {
            return new Process(".", false, NativeMethods.GetCurrentProcessId(), null);
        }

        /// <include file='doc\Process.uex' path='docs/doc[@for="Process.OnExited"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Raises the <see cref='System.Diagnostics.Process.Exited'/> event.
        ///    </para>
        /// </devdoc>
        protected void OnExited() {
            if (onExited != null) {
                if (this.SynchronizingObject != null && this.SynchronizingObject.InvokeRequired)
                    this.SynchronizingObject.BeginInvoke(this.onExited, new object[]{this, EventArgs.Empty});
                else                        
                   onExited(this, EventArgs.Empty);                
            }               
        }

        /// <include file='doc\Process.uex' path='docs/doc[@for="Process.GetProcessHandle"]/*' />
        /// <devdoc>
        ///     Gets a short-term handle to the process, with the given access.  If a handle exists,
        ///     then it is reused.
        /// </devdoc>
        /// <internalonly/>
        IntPtr GetProcessHandle(int access, bool throwIfExited) {
            Debug.WriteLineIf(processTracing.TraceVerbose, "GetProcessHandle(access = 0x" + access.ToString("X8") + ", throwIfExited = " + throwIfExited + ")");
#if DEBUG
            if (processTracing.TraceVerbose) {
                StackFrame calledFrom = new StackTrace(true).GetFrame(0);
                Debug.WriteLine("   called from " + calledFrom.GetFileName() + ", line " + calledFrom.GetFileLineNumber());
            }
#endif
            IntPtr handle = processHandle;
            if (haveProcessHandle) {
                if (throwIfExited) {
                    // Since haveProcessHandle is true, we know we have the process handle
                    // open with at least SYNCHRONIZE access, so we can wait on it with 
                    // zero timeout to see if the process has exited.
                    if (NativeMethods.WaitForSingleObject(new HandleRef(this, handle), 0) == NativeMethods.WAIT_OBJECT_0) {
                        if (haveProcessId)
                            throw new InvalidOperationException(SR.GetString(SR.ProcessHasExited, processId.ToString()));
                        else
                            throw new InvalidOperationException(SR.GetString(SR.ProcessHasExitedNoId));
                    }
                }
            }
            else {
                EnsureState(State.HaveId | State.IsLocal);
                handle = ProcessManager.OpenProcess(processId, access, throwIfExited);
                if (throwIfExited && (access & NativeMethods.PROCESS_QUERY_INFORMATION) != 0) {         
                    if (NativeMethods.GetExitCodeProcess(new HandleRef(this, handle), out exitCode) && exitCode != NativeMethods.STILL_ACTIVE) {
                        throw new InvalidOperationException(SR.GetString(SR.ProcessHasExited, processId.ToString()));
                    }
                }
            }

            return handle;
        }

        /// <include file='doc\Process.uex' path='docs/doc[@for="Process.GetProcessHandle1"]/*' />
        /// <devdoc>
        ///     Gets a short-term handle to the process, with the given access.  If a handle exists,
        ///     then it is reused.  If the process has exited, it throws an exception.
        /// </devdoc>
        /// <internalonly/>
        IntPtr GetProcessHandle(int access) {
            return GetProcessHandle(access, true);
        }

        /// <include file='doc\Process.uex' path='docs/doc[@for="Process.OpenProcessHandle"]/*' />
        /// <devdoc>
        ///     Opens a long-term handle to the process, with all access.  If a handle exists,
        ///     then it is reused.  If the process has exited, it throws an exception.
        /// </devdoc>
        /// <internalonly/>
        IntPtr OpenProcessHandle() {
            if (!haveProcessHandle) {
                //Cannot open a new process handle if the object has been disposed, since finalization has been suppressed.            
                if (this.disposed)
                    throw new ObjectDisposedException(GetType().Name);
                        
                SetProcessHandle(GetProcessHandle(NativeMethods.PROCESS_ALL_ACCESS));
            }                
            return processHandle;
        }

        /// <include file='doc\Process.uex' path='docs/doc[@for="Process.RaiseOnExited"]/*' />
        /// <devdoc>
        ///     Raise the Exited event, but make sure we don't do it more than once.
        /// </devdoc>
        /// <internalonly/>
        void RaiseOnExited() {
            if (!raisedOnExited) {
                lock (this) {
                    if (!raisedOnExited) {
                        raisedOnExited = true;
                        OnExited();
                    }
                }
            }
        }

        /// <include file='doc\Process.uex' path='docs/doc[@for="Process.Refresh"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Discards any information about the associated process
        ///       that has been cached inside the process component. After <see cref='System.Diagnostics.Process.Refresh'/> is called, the
        ///       first request for information for each property causes the process component
        ///       to obtain a new value from the associated process.
        ///    </para>
        /// </devdoc>
        public void Refresh() {
            processInfo = null;
            threads = null;
            modules = null;
            mainWindowTitle = null;
            exited = false;
            haveMainWindow = false;
            haveWorkingSetLimits = false;
            haveProcessorAffinity = false;
            havePriorityClass = false;
            haveExitTime = false;
            haveResponding = false;
            havePriorityBoostEnabled = false;
        }

        /// <include file='doc\Process.uex' path='docs/doc[@for="Process.SetProcessHandle"]/*' />
        /// <devdoc>
        ///     Helper to associate a process handle with this component.
        /// </devdoc>
        /// <internalonly/>
        void SetProcessHandle(IntPtr processHandle) {
            this.processHandle = processHandle;
            this.haveProcessHandle = true;
            if (watchForExit)
                EnsureWatchingForExit();
        }

        /// <include file='doc\Process.uex' path='docs/doc[@for="Process.SetProcessId"]/*' />
        /// <devdoc>
        ///     Helper to associate a process id with this component.
        /// </devdoc>
        /// <internalonly/>
        void SetProcessId(int processId) {
            this.processId = processId;
            this.haveProcessId = true;
        }

        /// <include file='doc\Process.uex' path='docs/doc[@for="Process.SetWorkingSetLimits"]/*' />
        /// <devdoc>
        ///     Helper to set minimum or maximum working set limits.
        /// </devdoc>
        /// <internalonly/>
        void SetWorkingSetLimits(object newMin, object newMax) {
            EnsureState(State.IsNt);

            IntPtr processHandle = (IntPtr)0;

            try {
                processHandle = GetProcessHandle(NativeMethods.PROCESS_QUERY_INFORMATION | NativeMethods.PROCESS_SET_QUOTA);
                IntPtr min;
                IntPtr max;
                if (!NativeMethods.GetProcessWorkingSetSize(new HandleRef(this, processHandle), out min, out max))
                    throw new Win32Exception();
                if (newMin != null) min = (IntPtr)newMin;
                if (newMax != null) max = (IntPtr)newMax;
                if ((long)min > (long)max) {
                    if (newMin != null) {
                        throw new ArgumentException(SR.GetString(SR.BadMinWorkset));
                    }
                    else {
                        throw new ArgumentException(SR.GetString(SR.BadMaxWorkset));
                    }
                }
                if (!NativeMethods.SetProcessWorkingSetSize(new HandleRef(this, processHandle), min, max))
                    throw new Win32Exception();
                // The value may be rounded/changed by the OS, so go get it
                if (!NativeMethods.GetProcessWorkingSetSize(new HandleRef(this, processHandle), out min, out max))
                    throw new Win32Exception();
                minWorkingSet = min;
                maxWorkingSet = max;
                haveWorkingSetLimits = true;
            }
            finally {
                ReleaseProcessHandle(processHandle);
            }
        }

        /// <include file='doc\Process.uex' path='docs/doc[@for="Process.Start"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Starts a process specified by the <see cref='System.Diagnostics.Process.StartInfo'/> property of this <see cref='System.Diagnostics.Process'/>
        ///       component and associates it with the
        ///    <see cref='System.Diagnostics.Process'/> . If a process resource is reused 
        ///       rather than started, the reused process is associated with this <see cref='System.Diagnostics.Process'/>
        ///       component.
        ///    </para>
        /// </devdoc>
        public bool Start() {
            Close();
            ProcessStartInfo startInfo = StartInfo;
            if (startInfo.FileName.Length == 0) 
                throw new InvalidOperationException(SR.GetString(SR.FileNameMissing));

            if (startInfo.UseShellExecute) {
                return StartWithShellExecuteEx(startInfo);
            } else {
                return StartWithCreateProcess(startInfo);
            }
        }


        //Instead of using anonimous pipes calling the Kernel32 CreatePipe function,
        //we implement our own CreatePipe routine for several reasons:
        //1. In order to have a non inherit pipe handle, when using Kernel32 create pipe function,
        //   the parent handle needs to be duplicated. If the child handle calls GetHandleType on
        //   the pipe handle, it will hang.
        //2. Anonimous pipes don't support overlapped IO, due to our thread pool based asynchrous
        //    model, using such handles would end up wasting a worker thread per pipe instance.  
        //    Overlapped IO is desirable, since it will take advantage of the NT completion port
        //    infrastructure.      
        private void CreatePipe(out IntPtr parentHandle, out IntPtr childHandle, bool parentInputs) {
            if (OperatingSystem.Platform != PlatformID.Win32NT) {
                NativeMethods.SecurityAttributes securityAttributesParent = new NativeMethods.SecurityAttributes();
                securityAttributesParent.bInheritHandle = true;
                
                IntPtr hTmp = (IntPtr)0;
                if (parentInputs) {
                    NativeMethods.IntCreatePipe(out childHandle, 
                                                          out hTmp, 
                                                          securityAttributesParent, 
                                                          0);
                                                          
                } 
                else {
                    NativeMethods.IntCreatePipe(out hTmp, 
                                                          out childHandle, 
                                                          securityAttributesParent, 
                                                          0);                                                                              
                }
                
                if (!NativeMethods.DuplicateHandle(new HandleRef(this, NativeMethods.GetCurrentProcess()), 
                                                                   new HandleRef(this, hTmp),
                                                                   new HandleRef(this, NativeMethods.GetCurrentProcess()), 
                                                                   out parentHandle,
                                                                   0, 
                                                                   false, 
                                                                   NativeMethods.DUPLICATE_SAME_ACCESS | 
                                                                   NativeMethods.DUPLICATE_CLOSE_SOURCE))
                                                                   
                throw new Win32Exception();


            }
            else {
                StringBuilder pipeNameBuilder = new StringBuilder();            
                pipeNameBuilder.Append("\\\\.\\pipe\\");                        
                if (SharedUtils.CurrentEnvironment == SharedUtils.W2kEnvironment)
                    pipeNameBuilder.Append("Global\\");
    
                pipeNameBuilder.Append(Guid.NewGuid().ToString());                               
                NativeMethods.SecurityAttributes securityAttributesParent = new NativeMethods.SecurityAttributes();
                securityAttributesParent.bInheritHandle = false;
                parentHandle = NativeMethods.CreateNamedPipe(
                                                                         pipeNameBuilder.ToString(), 
                                                                         NativeMethods.PIPE_ACCESS_DUPLEX |
                                                                         NativeMethods.FILE_FLAG_OVERLAPPED, 
                                                                         NativeMethods.PIPE_TYPE_BYTE | 
                                                                         NativeMethods.PIPE_READMODE_BYTE |                                                                                  
                                                                         NativeMethods.PIPE_WAIT, 
                                                                         NativeMethods.PIPE_UNLIMITED_INSTANCES, 
                                                                         4096, 
                                                                         4096, 
                                                                         0, 
                                                                         securityAttributesParent);
                if (parentHandle == NativeMethods.INVALID_HANDLE_VALUE)
                    throw new Win32Exception();
    
    
                NativeMethods.SecurityAttributes securityAttributesChild = new NativeMethods.SecurityAttributes();
                securityAttributesChild.bInheritHandle = true;
                int childAccess = NativeMethods.GENERIC_WRITE;
                if (parentInputs)
                    childAccess = NativeMethods.GENERIC_READ;
                
                childHandle = NativeMethods.CreateFile(
                                                                        pipeNameBuilder.ToString(),
                                                                        childAccess,  
                                                                        NativeMethods.FILE_SHARE_READ | 
                                                                        NativeMethods.FILE_SHARE_WRITE,
                                                                        securityAttributesChild,
                                                                        UnsafeNativeMethods.OPEN_EXISTING,
                                                                        NativeMethods.FILE_ATTRIBUTE_NORMAL | 
                                                                        NativeMethods.FILE_FLAG_OVERLAPPED,                                                                                
                                                                        NativeMethods.NullHandleRef);
    
                if (childHandle == NativeMethods.INVALID_HANDLE_VALUE)
                    throw new Win32Exception();        
            }                    
        }            
                            
        private bool StartWithCreateProcess(ProcessStartInfo startInfo) {
            
            // See knowledge base article Q190351 for an explanation of the following code.  Noteworthy tricky points:
            //    * the handles are duplicated as non-inheritable before they are passed to CreateProcess so
            //      that the child process can close them
            //    * CreateProcess allows you to redirrect all or none of the standard io handles, so we use
            //      GetStdHandle for the handles X for which RedirectStandardX == false
            //    * It is important to close our copy of the "child" ends of the pipes after we hand them of or 
            //      the read/writes will fail

            //Cannot start a new process and store its handle if the object has been disposed, since finalization has been suppressed.            
            if (this.disposed)
                throw new ObjectDisposedException(GetType().Name);

            NativeMethods.CreateProcessStartupInfo startupInfo = new NativeMethods.CreateProcessStartupInfo();
            NativeMethods.CreateProcessProcessInformation processInfo = new NativeMethods.CreateProcessProcessInformation();
            
            // Construct a StringBuilder with the appropriate command line
            // to pass to CreateProcess.  If the filename isn't already 
            // in quotes, we quote it here.  This prevents some security
            // problems (it specifies exactly which part of the string
            // is the file to execute).
            StringBuilder commandLine = new StringBuilder();
            string fileName = startInfo.FileName.Trim();
            string arguments = startInfo.Arguments;
            bool fileNameIsQuoted = (fileName.StartsWith("\"") && fileName.EndsWith("\""));
            if (!fileNameIsQuoted) commandLine.Append("\"");
            commandLine.Append(fileName);
            if (!fileNameIsQuoted) commandLine.Append("\"");
            if (arguments != null && arguments.Length > 0) {
                commandLine.Append(" ");
                commandLine.Append(arguments);
            }

            IntPtr hStdInReadPipe  = NativeMethods.INVALID_HANDLE_VALUE, hStdInWritePipe  = NativeMethods.INVALID_HANDLE_VALUE;
            IntPtr hStdOutReadPipe = NativeMethods.INVALID_HANDLE_VALUE, hStdOutWritePipe = NativeMethods.INVALID_HANDLE_VALUE;
            IntPtr hStdErrReadPipe = NativeMethods.INVALID_HANDLE_VALUE, hStdErrWritePipe = NativeMethods.INVALID_HANDLE_VALUE;
            bool needToCloseIn = false, needToCloseOut = false, needToCloseErr = false;
            GCHandle environmentHandle = new GCHandle();

            try {

                // set up the streams
                if (startInfo.RedirectStandardInput || startInfo.RedirectStandardOutput || startInfo.RedirectStandardError) {                        
                    if (startInfo.RedirectStandardInput) {
                        CreatePipe(out hStdInWritePipe, out hStdInReadPipe, true);                                                                                                                                    
                        needToCloseIn = true;
                    } else {
                        hStdInReadPipe = NativeMethods.GetStdHandle(NativeMethods.STD_INPUT_HANDLE);
                    }
    
                    if (startInfo.RedirectStandardOutput) {
                        CreatePipe(out hStdOutReadPipe, out hStdOutWritePipe, false);                                                                                                                                                                                    
                        needToCloseOut = true;
                    } else {
                        hStdOutWritePipe = NativeMethods.GetStdHandle(NativeMethods.STD_OUTPUT_HANDLE);
                    }
    
                    if (startInfo.RedirectStandardError) {
                        CreatePipe(out hStdErrReadPipe, out hStdErrWritePipe, false);                                                                                                                                                                                                                                    
                        needToCloseErr = true;
                    } else {
                        hStdErrWritePipe = NativeMethods.GetStdHandle(NativeMethods.STD_ERROR_HANDLE);
                    }
    
                    startupInfo.dwFlags = NativeMethods.STARTF_USESTDHANDLES;
                    startupInfo.hStdInput  = hStdInReadPipe;
                    startupInfo.hStdOutput = hStdOutWritePipe;
                    startupInfo.hStdError  = hStdErrWritePipe;        
                }
    
                // set up the creation flags paramater
                int creationFlags = 0;
                if (startInfo.CreateNoWindow)  creationFlags |= NativeMethods.CREATE_NO_WINDOW;               

                // set up the environment block parameter
                IntPtr environmentPtr = (IntPtr)0;
                if (startInfo.environmentVariables != null) {
                    string environmentString = EnvironmentBlock.ToString(startInfo.environmentVariables);
                    byte[] environmentBytes = null;
                    if (ProcessManager.IsNt) {
                        creationFlags |= NativeMethods.CREATE_UNICODE_ENVIRONMENT;                
                        environmentBytes = Encoding.Unicode.GetBytes(environmentString);
                    }
                    else {
                        // Encoding.Default is the encoding for the system's current ANSI code page.
                        environmentBytes = Encoding.Default.GetBytes(environmentString);
                    }
                    environmentHandle = GCHandle.Alloc(environmentBytes, GCHandleType.Pinned);
                    environmentPtr = environmentHandle.AddrOfPinnedObject();
                }

                string workingDirectory = startInfo.WorkingDirectory;
                if (workingDirectory == string.Empty)
                    workingDirectory = null;

                if (!NativeMethods.CreateProcess (
                        null,               // we don't need this since all the info is in commandLine
                        commandLine,        // pointer to the command line string
                        null,               // pointer to process security attributes, we don't need to inheriat the handle
                        null,               // pointer to thread security attributes
                        true,               // handle inheritance flag
                        creationFlags,      // creation flags
                        environmentPtr,     // pointer to new environment block
                        workingDirectory,   // pointer to current directory name
                        startupInfo,        // pointer to STARTUPINFO
                        processInfo         // pointer to PROCESS_INFORMATION
                    )) {
                    throw new Win32Exception();
                }
                 
            }
            finally {
                // free environment block
                if (environmentHandle.IsAllocated)
                    environmentHandle.Free();   
            
                // clean up handles
                if (processInfo.hThread != NativeMethods.INVALID_HANDLE_VALUE) {
                    Debug.WriteLineIf(processTracing.TraceVerbose, "Process - CloseHandle(hThread)");
                    SafeNativeMethods.CloseHandle(new HandleRef(this, processInfo.hThread));
                }
                if (needToCloseIn) {
                    Debug.WriteLineIf(processTracing.TraceVerbose, "Process - CloseHandle(stdIn)");
                    SafeNativeMethods.CloseHandle(new HandleRef(this, hStdInReadPipe));
                }
                if (needToCloseOut) {
                    Debug.WriteLineIf(processTracing.TraceVerbose, "Process - CloseHandle(stdOut)");
                    SafeNativeMethods.CloseHandle(new HandleRef(this, hStdOutWritePipe));
                }
                if (needToCloseErr) {
                    Debug.WriteLineIf(processTracing.TraceVerbose, "Process - CloseHandle(stdErr)");
                    SafeNativeMethods.CloseHandle(new HandleRef(this, hStdErrWritePipe));
                }
            }
            
            Encoding enc = null;
            if (startInfo.RedirectStandardInput) {
                enc = Encoding.GetEncoding(NativeMethods.GetConsoleCP()); 
                standardInput = new StreamWriter(new FileStream(hStdInWritePipe, FileAccess.Write, true, 4096, true), enc);
                standardInput.AutoFlush = true;
            }
            if (startInfo.RedirectStandardOutput) {
                enc = Encoding.GetEncoding(NativeMethods.GetConsoleOutputCP()); 
                standardOutput = new StreamReader(new FileStream(hStdOutReadPipe, FileAccess.Read, true, 4096, true), enc);
            }
            if (startInfo.RedirectStandardError) {
                enc = Encoding.GetEncoding(NativeMethods.GetConsoleOutputCP()); 
                standardError = new StreamReader(new FileStream(hStdErrReadPipe, FileAccess.Read, true, 4096, true), enc);
            }
            
            if (processInfo.hProcess != (IntPtr)0) {
                SetProcessHandle(processInfo.hProcess);
                SetProcessId(processInfo.dwProcessId);
                return true;
            }
            else
                return false;

        }

        private bool StartWithShellExecuteEx(ProcessStartInfo startInfo) {            
            
            //Cannot start a new process and store its handle if the object has been disposed, since finalization has been suppressed.            
            if (this.disposed)
                throw new ObjectDisposedException(GetType().Name);
        
            if (startInfo.RedirectStandardInput || startInfo.RedirectStandardOutput || startInfo.RedirectStandardError) {
                throw new InvalidOperationException(SR.GetString(SR.CantRedirectStreams));
            }

            // can't set env vars with ShellExecuteEx...
            if (startInfo.environmentVariables != null) {
                throw new InvalidOperationException(SR.GetString(SR.CantUseEnvVars));
            }

            //if (Thread.CurrentThread.ApartmentState != ApartmentState.STA) {
            //    throw new ThreadStateException(SR.GetString(SR.UseShellExecuteRequiresSTA));
            //}

            NativeMethods.ShellExecuteInfo shellExecuteInfo = new NativeMethods.ShellExecuteInfo();
            shellExecuteInfo.cbSize = Marshal.SizeOf(shellExecuteInfo);
            shellExecuteInfo.fMask = NativeMethods.SEE_MASK_NOCLOSEPROCESS;
            if (startInfo.ErrorDialog) {
                shellExecuteInfo.hwnd = startInfo.ErrorDialogParentHandle;
            }
            else {
                shellExecuteInfo.fMask |= NativeMethods.SEE_MASK_FLAG_NO_UI;
            }

            switch (startInfo.WindowStyle) {
                case ProcessWindowStyle.Hidden:
                    shellExecuteInfo.nShow = NativeMethods.SW_HIDE;
                    break;
                case ProcessWindowStyle.Minimized:
                    shellExecuteInfo.nShow = NativeMethods.SW_SHOWMINIMIZED;
                    break;
                case ProcessWindowStyle.Maximized:
                    shellExecuteInfo.nShow = NativeMethods.SW_SHOWMAXIMIZED;
                    break;
                default:
                    shellExecuteInfo.nShow = NativeMethods.SW_SHOWNORMAL;
                    break;
            }

            
            try {
                if (startInfo.FileName.Length != 0)
                    shellExecuteInfo.lpFile = Marshal.StringToHGlobalAuto(startInfo.FileName);
                if (startInfo.Verb.Length != 0)
                    shellExecuteInfo.lpVerb = Marshal.StringToHGlobalAuto(startInfo.Verb);
                if (startInfo.Arguments.Length != 0)
                    shellExecuteInfo.lpParameters = Marshal.StringToHGlobalAuto(startInfo.Arguments);
                if (startInfo.WorkingDirectory.Length != 0)
                    shellExecuteInfo.lpDirectory = Marshal.StringToHGlobalAuto(startInfo.WorkingDirectory);

                shellExecuteInfo.fMask |= NativeMethods.SEE_MASK_FLAG_DDEWAIT;

                if (!NativeMethods.ShellExecuteEx(shellExecuteInfo)) {
                    int error = Marshal.GetLastWin32Error();
                    if (error == 0) {
                        switch ((long)shellExecuteInfo.hInstApp) {
                            case NativeMethods.SE_ERR_FNF: error = NativeMethods.ERROR_FILE_NOT_FOUND; break;
                            case NativeMethods.SE_ERR_PNF: error = NativeMethods.ERROR_PATH_NOT_FOUND; break;
                            case NativeMethods.SE_ERR_ACCESSDENIED: error = NativeMethods.ERROR_ACCESS_DENIED; break;
                            case NativeMethods.SE_ERR_OOM: error = NativeMethods.ERROR_NOT_ENOUGH_MEMORY; break;
                            case NativeMethods.SE_ERR_DDEFAIL:
                            case NativeMethods.SE_ERR_DDEBUSY:
                            case NativeMethods.SE_ERR_DDETIMEOUT: error = NativeMethods.ERROR_DDE_FAIL; break;
                            case NativeMethods.SE_ERR_SHARE: error = NativeMethods.ERROR_SHARING_VIOLATION; break;
                            case NativeMethods.SE_ERR_NOASSOC: error = NativeMethods.ERROR_NO_ASSOCIATION; break;
                            case NativeMethods.SE_ERR_DLLNOTFOUND: error = NativeMethods.ERROR_DLL_NOT_FOUND; break;
                            default: error = (int)shellExecuteInfo.hInstApp; break;
                        }
                    }
                    throw new Win32Exception(error);
                }
            
            }
            finally {
                if (shellExecuteInfo.lpFile != (IntPtr)0) Marshal.FreeHGlobal(shellExecuteInfo.lpFile);
                if (shellExecuteInfo.lpVerb != (IntPtr)0) Marshal.FreeHGlobal(shellExecuteInfo.lpVerb);
                if (shellExecuteInfo.lpParameters != (IntPtr)0) Marshal.FreeHGlobal(shellExecuteInfo.lpParameters);
                if (shellExecuteInfo.lpDirectory != (IntPtr)0) Marshal.FreeHGlobal(shellExecuteInfo.lpDirectory);
            }
            

            if (shellExecuteInfo.hProcess != (IntPtr)0) {
                SetProcessHandle(shellExecuteInfo.hProcess);
                return true;
            }
            else
                return false;
        }

        /// <include file='doc\Process.uex' path='docs/doc[@for="Process.Start1"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Starts a process resource by specifying the name of a
        ///       document or application file. Associates the process resource with a new <see cref='System.Diagnostics.Process'/>
        ///       component.
        ///    </para>
        /// </devdoc>
        public static Process Start(string fileName) {
            return Start(new ProcessStartInfo(fileName));
        }

        /// <include file='doc\Process.uex' path='docs/doc[@for="Process.Start2"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Starts a process resource by specifying the name of an
        ///       application and a set of command line arguments. Associates the process resource
        ///       with a new <see cref='System.Diagnostics.Process'/>
        ///       component.
        ///    </para>
        /// </devdoc>
        public static Process Start(string fileName, string arguments) {
            return Start(new ProcessStartInfo(fileName, arguments));
        }

        /// <include file='doc\Process.uex' path='docs/doc[@for="Process.Start3"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Starts a process resource specified by the process start
        ///       information passed in, for example the file name of the process to start.
        ///       Associates the process resource with a new <see cref='System.Diagnostics.Process'/>
        ///       component.
        ///    </para>
        ///    <note type="rnotes">
        ///       This appears to be
        ///       wrong. Discuss with Krsysztof.
        ///    </note>
        /// </devdoc>
        public static Process Start(ProcessStartInfo startInfo) {
            Process process = new Process();
            if (startInfo == null) throw new ArgumentNullException("startInfo");
            process.StartInfo = startInfo;
            if (process.Start())
                return process;
            return null;
        }

        /// <include file='doc\Process.uex' path='docs/doc[@for="Process.Kill"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Stops the
        ///       associated process immediately.
        ///    </para>
        /// </devdoc>
        public void Kill() {
            IntPtr processHandle = (IntPtr)0;
            try {
                processHandle = GetProcessHandle(NativeMethods.PROCESS_TERMINATE);
                if (!NativeMethods.TerminateProcess(new HandleRef(this, processHandle), -1))
                    throw new Win32Exception();
            }
            finally {
                ReleaseProcessHandle(processHandle);
            }
        }

        /// <include file='doc\Process.uex' path='docs/doc[@for="Process.StopWatchingForExit"]/*' />
        /// <devdoc>
        ///     Make sure we are not watching for process exit.
        /// </devdoc>
        /// <internalonly/>
        void StopWatchingForExit() {
            if (watchingForExit) {
                lock (this) {
                    if (watchingForExit) {
                        watchingForExit = false;
                        registeredWaitHandle.Unregister(waitHandle);                
                        waitHandle = null;
                        registeredWaitHandle = null;
                    }
                }
            }
        }

        /// <include file='doc\Process.uex' path='docs/doc[@for="Process.ToString"]/*' />
        public override string ToString() {
            if (Associated)
                return String.Format("{0} ({1})", base.ToString(), this.ProcessName);
            else
                return base.ToString();
        }

        /// <include file='doc\Process.uex' path='docs/doc[@for="Process.WaitForExit"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Instructs the <see cref='System.Diagnostics.Process'/> component to wait the specified number of milliseconds for the associated process to exit.
        ///    </para>
        /// </devdoc>
        public bool WaitForExit(int milliseconds) {
            IntPtr processHandle = (IntPtr)0;
            bool exited;
            try {
                processHandle = GetProcessHandle(NativeMethods.SYNCHRONIZE, false);
                if (processHandle == NativeMethods.INVALID_HANDLE_VALUE)
                    exited = true;
                else {
                    int result = NativeMethods.WaitForSingleObject(new HandleRef(this, processHandle), milliseconds);
                    if (result == NativeMethods.WAIT_OBJECT_0)
                        exited = true;
                    else if (result == NativeMethods.WAIT_TIMEOUT)
                        exited = false;
                    else
                        throw new Win32Exception();
                }
            }
            finally {
                ReleaseProcessHandle(processHandle);
            }
            if (exited && watchForExit)
                RaiseOnExited();
            return exited;
        }

        /// <include file='doc\Process.uex' path='docs/doc[@for="Process.WaitForExit1"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Instructs the <see cref='System.Diagnostics.Process'/> component to wait
        ///       indefinitely for the associated process to exit.
        ///    </para>
        /// </devdoc>
        public void WaitForExit() {
            WaitForExit(Int32.MaxValue);
        }

        /// <include file='doc\Process.uex' path='docs/doc[@for="Process.WaitForInputIdle"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Causes the <see cref='System.Diagnostics.Process'/> component to wait the
        ///       specified number of milliseconds for the associated process to enter an
        ///       idle state.
        ///       This is only applicable for processes with a user interface,
        ///       therefore a message loop.
        ///    </para>
        /// </devdoc>
        public bool WaitForInputIdle(int milliseconds) {
            IntPtr processHandle = (IntPtr)0;
            bool idle;
            try {
                processHandle = GetProcessHandle(NativeMethods.SYNCHRONIZE | NativeMethods.PROCESS_QUERY_INFORMATION);
                int ret = NativeMethods.WaitForInputIdle(new HandleRef(this, processHandle), milliseconds);
                switch (ret) {
                    case NativeMethods.WAIT_OBJECT_0:
                        idle = true;
                        break;
                    case NativeMethods.WAIT_TIMEOUT:
                        idle = false;
                        break;
                    case NativeMethods.WAIT_FAILED:
                    default:
                        throw new InvalidOperationException(SR.GetString(SR.InputIdleUnkownError));
                }
            }
            finally {
                ReleaseProcessHandle(processHandle);
            }
            return idle;
        }

        /// <include file='doc\Process.uex' path='docs/doc[@for="Process.WaitForInputIdle1"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Instructs the <see cref='System.Diagnostics.Process'/> component to wait
        ///       indefinitely for the associated process to enter an idle state. This
        ///       is only applicable for processes with a user interface, therefore a message loop.
        ///    </para>
        /// </devdoc>
        public bool WaitForInputIdle() {
            return WaitForInputIdle(Int32.MaxValue);
        }

        /// <summary>
        ///     A desired internal state.
        /// </summary>
        /// <internalonly/>
        enum State {
            HaveId = 0x1,
            IsLocal = 0x2,
            IsNt = 0x4,
            HaveProcessInfo = 0x8,
            Exited = 0x10,
            Associated = 0x20,
            IsWin2k = 0x40,
            HaveNtProcessInfo = HaveProcessInfo | IsNt
        }
    }

    /// <include file='doc\Process.uex' path='docs/doc[@for="ProcessInfo"]/*' />
    /// <devdoc>
    ///     This data structure contains information about a process that is collected
    ///     in bulk by querying the operating system.  The reason to make this a separate
    ///     structure from the process component is so that we can throw it away all at once
    ///     when Refresh is called on the component.
    /// </devdoc>
    /// <internalonly/>
    internal class ProcessInfo {
        public ArrayList threadInfoList = new ArrayList();
        public int basePriority;
        public string processName;
        public int processId;
        public int handleCount;
        public int poolPagedBytes;
        public int poolNonpagedBytes;
        public TimeSpan privilegedTime;
        public TimeSpan userTime;
        public DateTime startTime;
        public int virtualBytes;
        public int virtualBytesPeak;
        public int workingSetPeak;
        public int workingSet;
        public int pageFileBytesPeak;
        public int pageFileBytes;
        public int privateBytes;
        public int mainModuleId; // used only for win9x - id is only for use with CreateToolHelp32
    }

    /// <include file='doc\Process.uex' path='docs/doc[@for="ThreadInfo"]/*' />
    /// <devdoc>
    ///     This data structure contains information about a thread in a process that
    ///     is collected in bulk by querying the operating system.  The reason to
    ///     make this a separate structure from the ProcessThread component is so that we
    ///     can throw it away all at once when Refresh is called on the component.
    /// </devdoc>
    /// <internalonly/>
    internal class ThreadInfo {
        public int threadId;
        public int processId;
        public int basePriority;
        public int currentPriority;
        public TimeSpan privilegedTime;
        public TimeSpan userTime;
        public DateTime startTime;
        public IntPtr startAddress;
        public ThreadState threadState;
        public ThreadWaitReason threadWaitReason;
    }

    /// <include file='doc\Process.uex' path='docs/doc[@for="ModuleInfo"]/*' />
    /// <devdoc>
    ///     This data structure contains information about a module in a process that
    ///     is collected in bulk by querying the operating system.  The reason to
    ///     make this a separate structure from the ProcessModule component is so that we
    ///     can throw it away all at once when Refresh is called on the component.
    /// </devdoc>
    /// <internalonly/>
    internal class ModuleInfo {
        public string baseName;
        public string fileName;
        public IntPtr baseOfDll;
        public IntPtr entryPoint;
        public int sizeOfImage;
        public int Id; // used only on win9x - for matching up with ProcessInfo.mainModuleId
    }

    /// <include file='doc\Process.uex' path='docs/doc[@for="MainWindowFinder"]/*' />
    /// <devdoc>
    ///     This class finds the main window of a process.  It needs to be
    ///     class because we need to store state while searching the set
    ///     of windows.
    /// </devdoc>
    /// <internalonly/>
    internal class MainWindowFinder {
        IntPtr bestHandle;
        int processId;

        public IntPtr FindMainWindow(int processId) {
            bestHandle = (IntPtr)0;
            this.processId = processId;
            NativeMethods.EnumThreadWindowsCallback callback = new NativeMethods.EnumThreadWindowsCallback(this.EnumWindowsCallback);
            NativeMethods.EnumWindows(callback, IntPtr.Zero);
            GC.KeepAlive(callback);
            return bestHandle;
        }

        bool IsMainWindow(IntPtr handle) {
            
            if (NativeMethods.GetWindow(new HandleRef(this, handle), NativeMethods.GW_OWNER) != (IntPtr)0 || !NativeMethods.IsWindowVisible(new HandleRef(this, handle)))
                return false;
            
            // ryanstu: should we use no window title to mean not a main window? (task man does)
            /*
            int length = NativeMethods.GetWindowTextLength(handle) * 2;
            StringBuilder builder = new StringBuilder(length);
            if (NativeMethods.GetWindowText(handle, builder, builder.Capacity) == 0)
                return false;
            if (builder.ToString() == string.Empty)
                return false;
            */

            return true;
        }

        bool EnumWindowsCallback(IntPtr handle, IntPtr extraParameter) {
            int processId;
            NativeMethods.GetWindowThreadProcessId(new HandleRef(this, handle), out processId);
            if (processId == this.processId) {
                if (IsMainWindow(handle)) {
                    bestHandle = handle;
                    return false;
                }
            }
            return true;
        }
    }

    /// <include file='doc\Process.uex' path='docs/doc[@for="ProcessManager"]/*' />
    /// <devdoc>
    ///     This static class is a platform independent Api for querying information
    ///     about processes, threads and modules.  It delegates to the platform
    ///     specific classes WinProcessManager for Win9x and NtProcessManager
    ///     for WinNt.
    /// </devdoc>
    /// <internalonly/>
    internal class ProcessManager {
        public static bool IsNt {
            get {
                return Environment.OSVersion.Platform == PlatformID.Win32NT;
            }
        }

        public static ProcessInfo[] GetProcessInfos(string machineName) {
            bool isRemoteMachine = IsRemoteMachine(machineName);
            if (IsNt)
                return NtProcessManager.GetProcessInfos(machineName, isRemoteMachine);
            else {
                if (isRemoteMachine)
                    throw new PlatformNotSupportedException(SR.GetString(SR.WinNTRequiredForRemote));
                return WinProcessManager.GetProcessInfos();
            }
        }

        public static int[] GetProcessIds() {
            if (IsNt)
                return NtProcessManager.GetProcessIds();
            else {
                return WinProcessManager.GetProcessIds();
            }
        }

        public static int[] GetProcessIds(string machineName) {
            if (IsRemoteMachine(machineName)) {
                if (IsNt) {
                    return NtProcessManager.GetProcessIds(machineName, true);
                }
                else {
                    throw new PlatformNotSupportedException(SR.GetString(SR.WinNTRequiredForRemote));
                }
            }
            else {
                return GetProcessIds();
            }
        }

        public static bool IsProcessRunning(int processId, string machineName) {
            return IsProcessRunning(processId, GetProcessIds(machineName));
        }

        public static bool IsProcessRunning(int processId) {
            return IsProcessRunning(processId, GetProcessIds());
        }

        static bool IsProcessRunning(int processId, int[] processIds) {
            for (int i = 0; i < processIds.Length; i++)
                if (processIds[i] == processId)
                    return true;
            return false;
        }

        public static int GetProcessIdFromHandle(IntPtr processHandle) {
            if (IsNt)
                return NtProcessManager.GetProcessIdFromHandle(processHandle);
            else
                throw new PlatformNotSupportedException(SR.GetString(SR.WinNTRequired));
        }

        public static IntPtr GetMainWindowHandle(ProcessInfo processInfo) {
            MainWindowFinder finder = new MainWindowFinder();
            return finder.FindMainWindow(processInfo.processId);
        }

        public static ModuleInfo[] GetModuleInfos(int processId) {
            if (IsNt)
                return NtProcessManager.GetModuleInfos(processId);
            else
                return WinProcessManager.GetModuleInfos(processId);
        }

        public static IntPtr OpenProcess(int processId, int access, bool throwIfExited) {
            IntPtr processHandle = NativeMethods.OpenProcess(access, false, processId);
            if (processHandle == (IntPtr)0) {
                if (processId == 0) throw new Win32Exception(5);
                int result = Marshal.GetLastWin32Error();
                if (!IsProcessRunning(processId)) {
                    if (throwIfExited)
                        throw new InvalidOperationException(SR.GetString(SR.ProcessHasExited, processId.ToString()));
                    else
                        return NativeMethods.INVALID_HANDLE_VALUE;
                }
                throw new Win32Exception(result);
            }
            return processHandle;
        }

        public static IntPtr OpenThread(int threadId, int access) {
            try {
                IntPtr threadHandle = NativeMethods.OpenThread(access, false, threadId);
                if (threadHandle == (IntPtr)0) {
                    int result = Marshal.GetLastWin32Error();
                    if (result == NativeMethods.ERROR_INVALID_PARAMETER)
                        throw new InvalidOperationException(SR.GetString(SR.ThreadExited, threadId.ToString()));
                    throw new Win32Exception(result);
                }
                return threadHandle;
            }
            catch (EntryPointNotFoundException x) {
                throw new PlatformNotSupportedException(SR.GetString(SR.Win2000Required), x);
            }
        }

        public static bool IsRemoteMachine(string machineName) {
            if (machineName == null)
                throw new ArgumentNullException("machineName");
            
            if (machineName.Length == 0)
                throw new ArgumentException(SR.GetString(SR.InvalidParameter, "machineName", machineName));
                        
            string baseName;
            if (machineName.StartsWith("\\"))
                baseName = machineName.Substring(2);
            else
                baseName = machineName;
            if (baseName.Equals(".")) return false;

            StringBuilder sb = new StringBuilder(256);
            SafeNativeMethods.GetComputerName(sb, new int[] {sb.Capacity});
            string computerName = sb.ToString();
            if (String.Compare(computerName, baseName, true, CultureInfo.InvariantCulture) == 0) return false;
            return true;
        }
    }

    /// <include file='doc\Process.uex' path='docs/doc[@for="WinProcessManager"]/*' />
    /// <devdoc>
    ///     This static class provides the process api for the Win9x platform.
    ///     We use the toolhelp32 api to query process, thread and module information.
    /// </devdoc>
    /// <internalonly/>
    internal class WinProcessManager {

        //Consider, V2, jruiz: This is expensive.  We should specialize getprocessinfos and only get 
        //                              the ids instead of getting all the info and then copying the ids out.
        public static int[] GetProcessIds() {
            ProcessInfo[] infos = GetProcessInfos();
            int[] ids = new int[infos.Length];
            for (int i = 0; i < infos.Length; i++) {
                ids[i] = infos[i].processId;
            }
            return ids;
        }

        public static ProcessInfo[] GetProcessInfos() {
            IntPtr handle = (IntPtr)(-1);
            GCHandle bufferHandle = new GCHandle();
            ArrayList threadInfos = new ArrayList();
            Hashtable processInfos = new Hashtable();

            try {
                handle = NativeMethods.CreateToolhelp32Snapshot(NativeMethods.TH32CS_SNAPPROCESS | NativeMethods.TH32CS_SNAPTHREAD, 0);
                if (handle == (IntPtr)(-1)) throw new Win32Exception();
                int entrySize = (int)Marshal.SizeOf(typeof(NativeMethods.WinProcessEntry));
                int bufferSize = entrySize + NativeMethods.WinProcessEntry.sizeofFileName;
                int[] buffer = new int[bufferSize / 4];
                bufferHandle = GCHandle.Alloc(buffer, GCHandleType.Pinned);
                IntPtr bufferPtr = bufferHandle.AddrOfPinnedObject();
                Marshal.WriteInt32(bufferPtr, bufferSize);

                HandleRef handleRef = new HandleRef(null, handle);
                
                if (NativeMethods.Process32First(handleRef, bufferPtr)) {
                    do {
                        NativeMethods.WinProcessEntry process = new NativeMethods.WinProcessEntry();
                        Marshal.PtrToStructure(bufferPtr, process);
                        ProcessInfo processInfo = new ProcessInfo();
                        String name = Marshal.PtrToStringAnsi((IntPtr)((long)bufferPtr + entrySize));  
                        processInfo.processName = Path.ChangeExtension(Path.GetFileName(name), null);
                        processInfo.handleCount = process.cntUsage;
                        processInfo.processId = process.th32ProcessID;
                        processInfo.basePriority = process.pcPriClassBase;
                        processInfo.mainModuleId = process.th32ModuleID;
                        processInfos.Add(processInfo.processId, processInfo);
                        Marshal.WriteInt32(bufferPtr, bufferSize);
                    }
                    while (NativeMethods.Process32Next(handleRef, bufferPtr));
                }
                
                NativeMethods.WinThreadEntry thread = new NativeMethods.WinThreadEntry();
                thread.dwSize = Marshal.SizeOf(thread);
                if (NativeMethods.Thread32First(handleRef, thread)) {
                    do {
                        ThreadInfo threadInfo = new ThreadInfo();
                        threadInfo.threadId = thread.th32ThreadID;
                        threadInfo.processId = thread.th32OwnerProcessID;
                        threadInfo.basePriority = thread.tpBasePri;
                        threadInfo.currentPriority = thread.tpBasePri + thread.tpDeltaPri;
                        threadInfos.Add(threadInfo);
                    }
                    while (NativeMethods.Thread32Next(handleRef, thread));
                }

                for (int i = 0; i < threadInfos.Count; i++) {
                    ThreadInfo threadInfo = (ThreadInfo)threadInfos[i];
                    ProcessInfo processInfo = (ProcessInfo)processInfos[threadInfo.processId];
                    if (processInfo != null) 
                        processInfo.threadInfoList.Add(threadInfo);
                    //else 
                    //    throw new InvalidOperationException(SR.GetString(SR.ProcessNotFound, threadInfo.threadId.ToString(), threadInfo.processId.ToString()));                   
                }
            }
            finally {
                if (bufferHandle.IsAllocated) bufferHandle.Free();
                Debug.WriteLineIf(Process.processTracing.TraceVerbose, "Process - CloseHandle(toolhelp32 snapshot handle)");
                if (handle != (IntPtr)(-1)) SafeNativeMethods.CloseHandle(new HandleRef(null, handle));
            }

            ProcessInfo[] temp = new ProcessInfo[processInfos.Values.Count];
            processInfos.Values.CopyTo(temp, 0);
            return temp;
        }

        public static ModuleInfo[] GetModuleInfos(int processId) {
            IntPtr handle = (IntPtr)(-1);
            GCHandle bufferHandle = new GCHandle();
            ArrayList moduleInfos = new ArrayList();

            try {
                handle = NativeMethods.CreateToolhelp32Snapshot(NativeMethods.TH32CS_SNAPMODULE, processId);
                if (handle == (IntPtr)(-1)) throw new Win32Exception();
                int entrySize = Marshal.SizeOf(typeof(NativeMethods.WinModuleEntry));
                int bufferSize = entrySize + NativeMethods.WinModuleEntry.sizeofFileName + NativeMethods.WinModuleEntry.sizeofModuleName;
                int[] buffer = new int[bufferSize / 4];
                bufferHandle = GCHandle.Alloc(buffer, GCHandleType.Pinned);
                IntPtr bufferPtr = bufferHandle.AddrOfPinnedObject();
                Marshal.WriteInt32(bufferPtr, bufferSize);

                HandleRef handleRef = new HandleRef(null, handle);

                if (NativeMethods.Module32First(handleRef, bufferPtr)) {
                    do {
                        NativeMethods.WinModuleEntry module = new NativeMethods.WinModuleEntry();
                        Marshal.PtrToStructure(bufferPtr, module);
                        ModuleInfo moduleInfo = new ModuleInfo();
                        moduleInfo.baseName = Marshal.PtrToStringAnsi((IntPtr)((long)bufferPtr + entrySize));
                        moduleInfo.fileName = Marshal.PtrToStringAnsi((IntPtr)((long)bufferPtr + entrySize + NativeMethods.WinModuleEntry.sizeofModuleName));
                        moduleInfo.baseOfDll = module.modBaseAddr;
                        moduleInfo.sizeOfImage = module.modBaseSize;
                        moduleInfo.Id = module.th32ModuleID;
                        moduleInfos.Add(moduleInfo);
                        Marshal.WriteInt32(bufferPtr, bufferSize);
                    }
                    while (NativeMethods.Module32Next(handleRef, bufferPtr));
                }
            }
            finally {
                if (bufferHandle.IsAllocated) bufferHandle.Free();
                Debug.WriteLineIf(Process.processTracing.TraceVerbose, "Process - CloseHandle(toolhelp32 snapshot handle)");
                if (handle != (IntPtr)(-1)) SafeNativeMethods.CloseHandle(new HandleRef(null, handle));
            }

            ModuleInfo[] temp = new ModuleInfo[moduleInfos.Count];
            moduleInfos.CopyTo(temp, 0);
            return temp;
        }
    }

    /// <include file='doc\Process.uex' path='docs/doc[@for="NtProcessManager"]/*' />
    /// <devdoc>
    ///     This static class provides the process api for the WinNt platform.
    ///     We use the performance counter api to query process and thread
    ///     information.  Module information is obtained using PSAPI.
    /// </devdoc>
    /// <internalonly/>
    internal class NtProcessManager {
        static Hashtable valueIds;

        static NtProcessManager() {
            valueIds = new Hashtable();
            valueIds.Add("Handle Count", ValueId.HandleCount);
            valueIds.Add("Pool Paged Bytes", ValueId.PoolPagedBytes);
            valueIds.Add("Pool Nonpaged Bytes", ValueId.PoolNonpagedBytes);
            valueIds.Add("Elapsed Time", ValueId.ElapsedTime);
            valueIds.Add("Virtual Bytes Peak", ValueId.VirtualBytesPeak);
            valueIds.Add("Virtual Bytes", ValueId.VirtualBytes);
            valueIds.Add("Private Bytes", ValueId.PrivateBytes);
            valueIds.Add("Page File Bytes", ValueId.PageFileBytes);
            valueIds.Add("Page File Bytes Peak", ValueId.PageFileBytesPeak);
            valueIds.Add("Working Set Peak", ValueId.WorkingSetPeak);
            valueIds.Add("Working Set", ValueId.WorkingSet);
            valueIds.Add("ID Thread", ValueId.ThreadId);
            valueIds.Add("ID Process", ValueId.ProcessId);
            valueIds.Add("Priority Base", ValueId.BasePriority);
            valueIds.Add("Priority Current", ValueId.CurrentPriority);
            valueIds.Add("% User Time", ValueId.UserTime);
            valueIds.Add("% Privileged Time", ValueId.PrivilegedTime);
            valueIds.Add("Start Address", ValueId.StartAddress);
            valueIds.Add("Thread State", ValueId.ThreadState);
            valueIds.Add("Thread Wait Reason", ValueId.ThreadWaitReason);
        }

        public static int[] GetProcessIds(string machineName, bool isRemoteMachine) {            
            ProcessInfo[] infos = GetProcessInfos(machineName, isRemoteMachine);
            int[] ids = new int[infos.Length];
            for (int i = 0; i < infos.Length; i++)
                ids[i] = infos[i].processId;
            return ids;
        }

        public static int[] GetProcessIds() {
            int[] processIds = new int[256];
            int size;
            for (;;) {
                if (!NativeMethods.EnumProcesses(processIds, processIds.Length * 4, out size))
                    throw new Win32Exception();
                if (size == processIds.Length * 4) {
                    processIds = new int[processIds.Length * 2];
                    continue;
                }
                break;
            }
            int[] ids = new int[size / 4];
            Array.Copy(processIds, ids, ids.Length);
            return ids;
        }

        public static ModuleInfo[] GetModuleInfos(int processId) {
            IntPtr processHandle = (IntPtr)0;

            try {
                processHandle = ProcessManager.OpenProcess(processId, NativeMethods.PROCESS_QUERY_INFORMATION | NativeMethods.PROCESS_VM_READ, true);
                IntPtr[] moduleHandles = new IntPtr[64];
                GCHandle moduleHandlesArrayHandle = new GCHandle();
                int moduleCount = 0;
                for (;;) {
                    bool enumResult;
                    try {
                        moduleHandlesArrayHandle = GCHandle.Alloc(moduleHandles, GCHandleType.Pinned);
                        enumResult = NativeMethods.EnumProcessModules(new HandleRef(null, processHandle), moduleHandlesArrayHandle.AddrOfPinnedObject(), moduleHandles.Length * IntPtr.Size, ref moduleCount);
                    }
                    finally {
                        moduleHandlesArrayHandle.Free();
                    }
                                            
                    if (!enumResult) {
                        throw new Win32Exception(HResults.EFail,SR.GetString(SR.EnumProcessModuleFailed));
                    }

                    moduleCount /= IntPtr.Size;
                    if (moduleCount <= moduleHandles.Length) break;
                    moduleHandles = new IntPtr[moduleHandles.Length * 2];
                }
                ArrayList moduleInfos = new ArrayList();
                
                int ret;
                for (int i = 0; i < moduleCount; i++) {
                    ModuleInfo moduleInfo = new ModuleInfo();
                    IntPtr moduleHandle = moduleHandles[i];
                    NativeMethods.NtModuleInfo ntModuleInfo = new NativeMethods.NtModuleInfo();
                    if (!NativeMethods.GetModuleInformation(new HandleRef(null, processHandle), new HandleRef(null, moduleHandle), ntModuleInfo, Marshal.SizeOf(ntModuleInfo)))
                        throw new Win32Exception();
                    moduleInfo.sizeOfImage = ntModuleInfo.SizeOfImage;
                    moduleInfo.entryPoint = ntModuleInfo.EntryPoint;
                    moduleInfo.baseOfDll = ntModuleInfo.BaseOfDll;

                    StringBuilder baseName = new StringBuilder(1024);
                    ret = NativeMethods.GetModuleBaseName(new HandleRef(null, processHandle), new HandleRef(null, moduleHandle), baseName, baseName.Capacity * 2);
                    if (ret == 0) throw new Win32Exception();
                    moduleInfo.baseName = baseName.ToString();

                    StringBuilder fileName = new StringBuilder(1024);
                    ret = NativeMethods.GetModuleFileNameEx(new HandleRef(null, processHandle), new HandleRef(null, moduleHandle), fileName, fileName.Capacity * 2);
                    if (ret == 0) throw new Win32Exception();
                    moduleInfo.fileName = fileName.ToString();

                    // smss.exe is started before the win32 subsystem so it get this funny "\systemroot\.." path.
                    // We change this to the actual path by appending "smss.exe" to GetSystemDirectory()
                    if (string.Compare(moduleInfo.fileName, "\\SystemRoot\\System32\\smss.exe", true, CultureInfo.InvariantCulture) == 0) {
                        moduleInfo.fileName = Path.Combine(Environment.SystemDirectory, "smss.exe");
                    }

                    moduleInfos.Add(moduleInfo);
                }
                ModuleInfo[] temp = new ModuleInfo[moduleInfos.Count];
                moduleInfos.CopyTo(temp, 0);
                return temp;
            }
            finally {
                Debug.WriteLineIf(Process.processTracing.TraceVerbose, "Process - CloseHandle(process)");
                if (processHandle != (IntPtr)0) SafeNativeMethods.CloseHandle(new HandleRef(null, processHandle));
            }
        }

        public static int GetProcessIdFromHandle(IntPtr processHandle) {
            NativeMethods.NtProcessBasicInfo info = new NativeMethods.NtProcessBasicInfo();
            int status = NativeMethods.NtQueryInformationProcess(new HandleRef(null, processHandle), NativeMethods.NtQueryProcessBasicInfo, info, (int)Marshal.SizeOf(info), null);
            if (status != 0)
                throw new InvalidOperationException(SR.GetString(SR.CantGetProcessId), new Win32Exception(status));
            return info.UniqueProcessId;
        }

        public static ProcessInfo[] GetProcessInfos(string machineName, bool isRemoteMachine) {
            // SECREVIEW: we demand unmanaged code here because PerformanceCounterLib doesn't demand
            // anything.  This is the only place we do GetPerformanceCounterLib, and it isn't cached.
            new SecurityPermission(SecurityPermissionFlag.UnmanagedCode).Demand();
            PerformanceCounterLib library = null;
            try {
                library = PerformanceCounterLib.GetPerformanceCounterLib(machineName, new CultureInfo(0x009));                            
            }
            catch(Exception e) {
                throw new InvalidOperationException(SR.GetString(SR.CouldntConnectToRemoteMachine), e);
            }
                            
            return GetProcessInfos(library);
        }

        static ProcessInfo[] GetProcessInfos(PerformanceCounterLib library) {
            ProcessInfo[] processInfos = new ProcessInfo[0] ;
            IntPtr dataPtr = (IntPtr)0;            
            
            int[] indexes = new int[2];                                
            int retryCount = 5;
            while (processInfos.Length == 0 && retryCount != 0) {                    
                try {
                    dataPtr = library.GetPerformanceData(new string[]{"Process", "Thread"}, indexes);
                    processInfos = GetProcessInfos(library, indexes[0], indexes[1], dataPtr);
                }
                catch (Exception e) {
                    throw new InvalidOperationException(SR.GetString(SR.CouldntGetRemoteProcesses), e);
                }                    
                finally {                        
                    if ((int)dataPtr != 0)
                        Marshal.FreeHGlobal(dataPtr);
                }
                                        
                --retryCount;                        
            }                    
        
            if (processInfos.Length == 0)
                throw new InvalidOperationException(SR.GetString(SR.ProcessDisabled));    
                
            return processInfos;                    
                        
        }

        static ProcessInfo[] GetProcessInfos(PerformanceCounterLib library, int processIndex, int threadIndex, IntPtr dataBlockPtr) {
            Debug.WriteLineIf(Process.processTracing.TraceVerbose, "GetProcessInfos()");
            Hashtable processInfos = new Hashtable();
            ArrayList threadInfos = new ArrayList();
            NativeMethods.PERF_DATA_BLOCK dataBlock = new NativeMethods.PERF_DATA_BLOCK();
            Marshal.PtrToStructure(dataBlockPtr, dataBlock);
            IntPtr typePtr = (IntPtr)((long)dataBlockPtr + dataBlock.HeaderLength);
            NativeMethods.PERF_INSTANCE_DEFINITION instance = new NativeMethods.PERF_INSTANCE_DEFINITION();
            NativeMethods.PERF_COUNTER_BLOCK counterBlock = new NativeMethods.PERF_COUNTER_BLOCK();                        
            for (int i = 0; i < dataBlock.NumObjectTypes; i++) {                
                NativeMethods.PERF_OBJECT_TYPE type = new NativeMethods.PERF_OBJECT_TYPE();
                Marshal.PtrToStructure(typePtr, type);
                IntPtr instancePtr = (IntPtr)((long)typePtr + type.DefinitionLength);
                IntPtr counterPtr = (IntPtr)((long)typePtr + type.HeaderLength);
                ArrayList counterList = new ArrayList();
                
                for (int j = 0; j < type.NumCounters; j++) {                    
                    NativeMethods.PERF_COUNTER_DEFINITION counter = new NativeMethods.PERF_COUNTER_DEFINITION();
                    Marshal.PtrToStructure(counterPtr, counter);
                    string counterName = library.GetCounterName(counter.CounterNameTitleIndex);

                    if (type.ObjectNameTitleIndex == processIndex)
                        counter.CounterNameTitlePtr = (int)GetValueId(counterName);
                    else if (type.ObjectNameTitleIndex == threadIndex)
                        counter.CounterNameTitlePtr = (int)GetValueId(counterName);
                    counterList.Add(counter);
                    counterPtr = (IntPtr)((long)counterPtr + counter.ByteLength);
                }
                NativeMethods.PERF_COUNTER_DEFINITION[] counters = new NativeMethods.PERF_COUNTER_DEFINITION[counterList.Count];
                counterList.CopyTo(counters, 0);
                for (int j = 0; j < type.NumInstances; j++) {
                    Marshal.PtrToStructure(instancePtr, instance);
                    IntPtr namePtr = (IntPtr)((long)instancePtr + instance.NameOffset);
                    string instanceName = Marshal.PtrToStringUni(namePtr);            
                    if (instanceName.Equals("_Total")) continue;
                    IntPtr counterBlockPtr = (IntPtr)((long)instancePtr + instance.ByteLength);
                    Marshal.PtrToStructure(counterBlockPtr, counterBlock);
                    if (type.ObjectNameTitleIndex == processIndex) {
                        ProcessInfo processInfo = GetProcessInfo(type, (IntPtr)((long)instancePtr + instance.ByteLength), counters);
                        if (processInfo.processId == 0 && string.Compare(instanceName, "Idle", true, CultureInfo.InvariantCulture) != 0) {
                            // Sometimes we'll get a process structure that is not completely filled in.
                            // We can catch some of these by looking for non-"idle" processes that have id 0
                            // and ignoring those.
                            Debug.WriteLineIf(Process.processTracing.TraceVerbose, "GetProcessInfos() - found a non-idle process with id 0; ignoring.");                           
                        }
                        else {
                            if (processInfos[processInfo.processId] != null) {
                                // We've found two entries in the perfcounters that claim to be the
                                // same process.  We throw an exception.  Is this really going to be
                                // helpfull to the user?  Should we just ignore?
                                Debug.WriteLineIf(Process.processTracing.TraceVerbose, "GetProcessInfos() - found a duplicate process id");
                            }
                            else {
                                // the performance counters keep a 15 character prefix of the exe name, and then delete the ".exe",
                                // if it's in the first 15.  The problem is that sometimes that will leave us with part of ".exe"
                                // at the end.  If instanceName ends in ".", ".e", or ".ex" we remove it.
                                string processName = instanceName;
                                if (processName.Length == 15) {
                                    if      (instanceName.EndsWith("."  )) processName = instanceName.Substring(0, 14);
                                    else if (instanceName.EndsWith(".e" )) processName = instanceName.Substring(0, 13);
                                    else if (instanceName.EndsWith(".ex")) processName = instanceName.Substring(0, 12);
                                }
                                processInfo.processName = processName;
                                processInfos.Add(processInfo.processId, processInfo);
                            }
                        }
                    }
                    else if (type.ObjectNameTitleIndex == threadIndex) {
                        ThreadInfo threadInfo = GetThreadInfo(type, (IntPtr)((long)instancePtr + instance.ByteLength), counters);
                        if (threadInfo.threadId != 0) threadInfos.Add(threadInfo);
                    }
                    instancePtr = (IntPtr)((long)instancePtr + instance.ByteLength + counterBlock.ByteLength);
                }                                
                
                typePtr = (IntPtr)((long)typePtr + type.TotalByteLength);
            }

            for (int i = 0; i < threadInfos.Count; i++) {
                ThreadInfo threadInfo = (ThreadInfo)threadInfos[i];
                ProcessInfo processInfo = (ProcessInfo)processInfos[threadInfo.processId];
                if (processInfo != null) {
                    processInfo.threadInfoList.Add(threadInfo);
                }
                //else {
                //    throw new InvalidOperationException(SR.GetString(SR.ProcessNotFound, threadInfo.threadId.ToString(), threadInfo.processId.ToString()));
                //}
            }
                        
            ProcessInfo[] temp = new ProcessInfo[processInfos.Values.Count];
            processInfos.Values.CopyTo(temp, 0);
            return temp;
        }

        static ThreadInfo GetThreadInfo(NativeMethods.PERF_OBJECT_TYPE type, IntPtr instancePtr, NativeMethods.PERF_COUNTER_DEFINITION[] counters) {
            ThreadInfo threadInfo = new ThreadInfo();
            for (int i = 0; i < counters.Length; i++) {
                NativeMethods.PERF_COUNTER_DEFINITION counter = counters[i];
                long value = ReadCounterValue(counter.CounterType, (IntPtr)((long)instancePtr + counter.CounterOffset));
                switch ((ValueId)counter.CounterNameTitlePtr) {
                    case ValueId.ProcessId:
                        threadInfo.processId = (int)value;
                        break;
                    case ValueId.ThreadId:
                        threadInfo.threadId = (int)value;
                        break;
                    case ValueId.BasePriority:
                        threadInfo.basePriority = (int)value;
                        break;
                    case ValueId.CurrentPriority:
                        threadInfo.currentPriority = (int)value;
                        break;
                    case ValueId.PrivilegedTime:
                        threadInfo.privilegedTime = new TimeSpan(value);
                        break;
                    case ValueId.UserTime:
                        threadInfo.userTime = new TimeSpan(value);
                        break;
                    case ValueId.ElapsedTime:
                        threadInfo.startTime = DateTime.Now.Subtract(GetElapsedTime(type, value));
                        break;
                    case ValueId.StartAddress:
                        threadInfo.startAddress = (IntPtr)value;
                        break;
                    case ValueId.ThreadState:
                        threadInfo.threadState = (ThreadState)value;
                        break;
                    case ValueId.ThreadWaitReason:
                        threadInfo.threadWaitReason = GetThreadWaitReason((int)value);
                        break;
                }
            }

            return threadInfo;
        }

        static ThreadWaitReason GetThreadWaitReason(int value) {
            switch (value) {
                case 0:
                case 7: return ThreadWaitReason.Executive;
                case 1:
                case 8: return ThreadWaitReason.FreePage;
                case 2:
                case 9: return ThreadWaitReason.PageIn;
                case 3:
                case 10: return ThreadWaitReason.SystemAllocation;
                case 4:
                case 11: return ThreadWaitReason.ExecutionDelay;
                case 5:
                case 12: return ThreadWaitReason.Suspended;
                case 6:
                case 13: return ThreadWaitReason.UserRequest;
                case 14: return ThreadWaitReason.EventPairHigh;;
                case 15: return ThreadWaitReason.EventPairLow;
                case 16: return ThreadWaitReason.LpcReceive;
                case 17: return ThreadWaitReason.LpcReply;
                case 18: return ThreadWaitReason.VirtualMemory;
                case 19: return ThreadWaitReason.PageOut;
                default: return ThreadWaitReason.Unknown;
            }
        }

        static ProcessInfo GetProcessInfo(NativeMethods.PERF_OBJECT_TYPE type, IntPtr instancePtr, NativeMethods.PERF_COUNTER_DEFINITION[] counters) {
            ProcessInfo processInfo = new ProcessInfo();
            for (int i = 0; i < counters.Length; i++) {
                NativeMethods.PERF_COUNTER_DEFINITION counter = counters[i];
                long value = ReadCounterValue(counter.CounterType, (IntPtr)((long)instancePtr + counter.CounterOffset));
                switch ((ValueId)counter.CounterNameTitlePtr) {
                    case ValueId.ProcessId:
                        processInfo.processId = (int)value;
                        break;
                    case ValueId.HandleCount:
                        processInfo.handleCount = (int)value;
                        break;
                    case ValueId.PoolPagedBytes:
                        processInfo.poolPagedBytes = (int)value;
                        break;
                    case ValueId.PoolNonpagedBytes:
                        processInfo.poolNonpagedBytes = (int)value;
                        break;
                    case ValueId.PrivilegedTime:
                        processInfo.privilegedTime = new TimeSpan(value);
                        break;
                    case ValueId.UserTime:
                        processInfo.userTime = new TimeSpan(value);
                        break;
                    case ValueId.ElapsedTime:
                        processInfo.startTime = DateTime.Now.Subtract(GetElapsedTime(type, value));
                        break;
                    case ValueId.VirtualBytes:
                        processInfo.virtualBytes = (int)value;
                        break;
                    case ValueId.VirtualBytesPeak:
                        processInfo.virtualBytesPeak = (int)value;
                        break;
                    case ValueId.WorkingSetPeak:
                        processInfo.workingSetPeak = (int)value;
                        break;
                    case ValueId.WorkingSet:
                        processInfo.workingSet = (int)value;
                        break;
                    case ValueId.PageFileBytesPeak:
                        processInfo.pageFileBytesPeak = (int)value;
                        break;
                    case ValueId.PageFileBytes:
                        processInfo.pageFileBytes = (int)value;
                        break;
                    case ValueId.PrivateBytes:
                        processInfo.privateBytes = (int)value;
                        break;
                    case ValueId.BasePriority:
                        processInfo.basePriority = (int)value;
                        break;
                }
            }
            return processInfo;
        }

        static TimeSpan GetElapsedTime(NativeMethods.PERF_OBJECT_TYPE type, long value) {
            return new TimeSpan((long)(((double)(type.PerfTime - value) / type.PerfFreq) * 10000000));
        }

        static ValueId GetValueId(string counterName) {
            if (counterName != null) {
                object id = valueIds[counterName];
                if (id != null)
                    return(ValueId)id;
            }
            return ValueId.Unknown;
        }

        static long ReadCounterValue(int counterType, IntPtr dataPtr) {
            if ((counterType & NativeMethods.NtPerfCounterSizeLarge) != 0)
                return Marshal.ReadInt64(dataPtr);
            else
                return(long)Marshal.ReadInt32(dataPtr);
        }

        enum ValueId {
            Unknown = -1,
            HandleCount,
            PoolPagedBytes,
            PoolNonpagedBytes,
            ElapsedTime,
            VirtualBytesPeak,
            VirtualBytes,
            PrivateBytes,
            PageFileBytes,
            PageFileBytesPeak,
            WorkingSetPeak,
            WorkingSet,
            ThreadId,
            ProcessId,
            BasePriority,
            CurrentPriority,
            UserTime,
            PrivilegedTime,
            StartAddress,
            ThreadState,
            ThreadWaitReason
        }
    }

    internal class EnvironmentBlock {
        public static void toStringDictionary(IntPtr bufferPtr, StringDictionary sd) {
            string[] subs;
            char[] splitter = new char[] {'='};
            string entry = Marshal.PtrToStringAnsi(bufferPtr);
            while (entry.Length > 0) {
                subs = entry.Split(splitter);
                if (subs.Length != 2) 
                    throw new InvalidOperationException(SR.GetString(SR.EnvironmentBlock));
                    
                sd.Add(subs[0], subs[1]);
                bufferPtr = (IntPtr)((long)bufferPtr + entry.Length + 1);
                entry = Marshal.PtrToStringAnsi(bufferPtr);
            }
        }

        public static string ToString(StringDictionary sd) {
            // get the keys
            string[] keys = new string[sd.Count];
            sd.Keys.CopyTo(keys, 0);
            
            // get the values
            string[] values = new string[sd.Count];
            sd.Values.CopyTo(values, 0);
            
            // sort both by the keys
            Array.Sort(keys, values, Comparer.Default);

            // create a list of null terminated "key=val" strings
            StringBuilder stringBuff = new StringBuilder();
            for (int i = 0; i < sd.Count; ++ i) {
                stringBuff.Append(keys[i]);
                stringBuff.Append('=');
                stringBuff.Append(values[i]);
                stringBuff.Append('\0');
            }
            // an extra null at the end indicates end of list.
            stringBuff.Append('\0');
            
            return stringBuff.ToString();
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\services\monitoring\system\diagnosticts\processthread.cs ===
//------------------------------------------------------------------------------
// <copyright file="ProcessThread.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Diagnostics {

    using System.Threading;
    using System.Runtime.InteropServices;
    using System.ComponentModel;
    using System.Diagnostics;
    using System;
    using System.Collections;
    using System.IO;
    using Microsoft.Win32;       
//    using System.Windows.Forms;

    /// <include file='doc\ProcessThread.uex' path='docs/doc[@for="ProcessThread"]/*' />
    /// <devdoc>
    ///    <para>
    ///       Represents a Win32 thread. This can be used to obtain
    ///       information about the thread, such as it's performance characteristics. This is
    ///       returned from the System.Diagnostics.Process.ProcessThread property of the System.Diagnostics.Process component.
    ///    </para>
    ///    <note type="rnotes">
    ///       I don't understand
    ///       the following comment associated with the previous sentence: "property of
    ///       Process component " Rather than just "processTHread". There is no such
    ///       member on Process. Do we mean 'threads'?
    ///    </note>
    /// </devdoc>
    [Designer("System.Diagnostics.Design.ProcessThreadDesigner, " + AssemblyRef.SystemDesign)]
    public class ProcessThread : Component {

        //
        // FIELDS
        //

        ThreadInfo threadInfo;
        bool isRemoteMachine;
        bool priorityBoostEnabled;
        bool havePriorityBoostEnabled;
        ThreadPriorityLevel priorityLevel;
        bool havePriorityLevel;

        //
        // CONSTRUCTORS
        //

        /// <include file='doc\ProcessThread.uex' path='docs/doc[@for="ProcessThread.ProcessThread"]/*' />
        /// <devdoc>
        ///     Internal constructor.
        /// </devdoc>
        /// <internalonly/>
        internal ProcessThread(bool isRemoteMachine, ThreadInfo threadInfo) {
            this.isRemoteMachine = isRemoteMachine;
            this.threadInfo = threadInfo;
        }

        //
        // PROPERTIES
        //

        /// <include file='doc\ProcessThread.uex' path='docs/doc[@for="ProcessThread.BasePriority"]/*' />
        /// <devdoc>
        ///     Returns the base priority of the thread which is computed by combining the
        ///     process priority class with the priority level of the associated thread.
        /// </devdoc>
        [MonitoringDescription(SR.ThreadBasePriority)]
        public int BasePriority {
            get {
                return threadInfo.basePriority;
            }
        }

        /// <include file='doc\ProcessThread.uex' path='docs/doc[@for="ProcessThread.CurrentPriority"]/*' />
        /// <devdoc>
        ///     The current priority indicates the actual priority of the associated thread,
        ///     which may deviate from the base priority based on how the OS is currently
        ///     scheduling the thread.
        /// </devdoc>
        [MonitoringDescription(SR.ThreadCurrentPriority)]
        public int CurrentPriority {
            get {
                return threadInfo.currentPriority;
            }
        }

        /// <include file='doc\ProcessThread.uex' path='docs/doc[@for="ProcessThread.Id"]/*' />
        /// <devdoc>
        ///     Returns the unique identifier for the associated thread.
        /// </devdoc>
        [MonitoringDescription(SR.ThreadId)]
        public int Id {
            get {
                return threadInfo.threadId;
            }
        }

        /// <include file='doc\ProcessThread.uex' path='docs/doc[@for="ProcessThread.IdealProcessor"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Sets the processor that this thread would ideally like to run on.
        ///    </para>
        /// </devdoc>
        [Browsable(false)]
        public int IdealProcessor {
            set {
                IntPtr threadHandle = (IntPtr)0;
                try {
                    threadHandle = OpenThreadHandle(NativeMethods.THREAD_SET_INFORMATION);
                    if (NativeMethods.SetThreadIdealProcessor(new HandleRef(this, threadHandle), value) < 0)
                        throw new Win32Exception();
                }
                finally {
                    CloseThreadHandle(threadHandle);
                }
            }
        }

        /// <include file='doc\ProcessThread.uex' path='docs/doc[@for="ProcessThread.PriorityBoostEnabled"]/*' />
        /// <devdoc>
        ///      Returns or sets whether this thread would like a priority boost if the user interacts
        ///      with user interface associated with this thread.
        /// </devdoc>
        [MonitoringDescription(SR.ThreadPriorityBoostEnabled)]
        public bool PriorityBoostEnabled {
            get {
                if (!havePriorityBoostEnabled) {
                    IntPtr threadHandle = (IntPtr)0;
                    try {
                        threadHandle = OpenThreadHandle(NativeMethods.THREAD_QUERY_INFORMATION);
                        bool disabled = false;
                        if (!NativeMethods.GetThreadPriorityBoost(new HandleRef(this, threadHandle), out disabled))
                            throw new Win32Exception();
                        priorityBoostEnabled = !disabled;
                        havePriorityBoostEnabled = true;
                    }
                    finally {
                        CloseThreadHandle(threadHandle);
                    }
                }
                return priorityBoostEnabled;
            }
            set {
                IntPtr threadHandle = (IntPtr)0;
                try {
                    threadHandle = OpenThreadHandle(NativeMethods.THREAD_SET_INFORMATION);
                    if (!NativeMethods.SetThreadPriorityBoost(new HandleRef(this, threadHandle), !value))
                        throw new Win32Exception();
                    priorityBoostEnabled = value;
                    havePriorityBoostEnabled = true;
                }
                finally {
                    CloseThreadHandle(threadHandle);
                }
            }
        }

        /// <include file='doc\ProcessThread.uex' path='docs/doc[@for="ProcessThread.PriorityLevel"]/*' />
        /// <devdoc>
        ///     Returns or sets the priority level of the associated thread.  The priority level is
        ///     not an absolute level, but instead contributes to the actual thread priority by
        ///     considering the priority class of the process.
        /// </devdoc>
        [MonitoringDescription(SR.ThreadPriorityLevel)]
        public ThreadPriorityLevel PriorityLevel {
            get {
                if (!havePriorityLevel) {
                    IntPtr threadHandle = (IntPtr)0;
                    try {
                        threadHandle = OpenThreadHandle(NativeMethods.THREAD_QUERY_INFORMATION);
                        int value = NativeMethods.GetThreadPriority(new HandleRef(this, threadHandle));
                        if (value == 0x7fffffff) throw new Win32Exception();
                        priorityLevel = (ThreadPriorityLevel)value;
                        havePriorityLevel = true;
                    }
                    finally {
                        CloseThreadHandle(threadHandle);
                    }
                }
                return priorityLevel;
            }
            set {            
                IntPtr threadHandle = (IntPtr)0;
                try {
                    threadHandle = OpenThreadHandle(NativeMethods.THREAD_SET_INFORMATION);
                    if (!NativeMethods.SetThreadPriority(new HandleRef(this, threadHandle), (int)value))
                        throw new Win32Exception();
                    priorityLevel = value;
                }
                finally {
                    CloseThreadHandle(threadHandle);
                }
            }
        }

        /// <include file='doc\ProcessThread.uex' path='docs/doc[@for="ProcessThread.PrivilegedProcessorTime"]/*' />
        /// <devdoc>
        ///     Returns the amount of time the thread has spent running code inside the operating
        ///     system core.
        /// </devdoc>
        [MonitoringDescription(SR.ThreadPrivilegedProcessorTime)]
        public TimeSpan PrivilegedProcessorTime {
            get {
                EnsureState(State.IsNt);
                return threadInfo.privilegedTime;
            }
        }

        /// <include file='doc\ProcessThread.uex' path='docs/doc[@for="ProcessThread.StartAddress"]/*' />
        /// <devdoc>
        ///     Returns the memory address of the function that was called when the associated
        ///     thread was started.
        /// </devdoc>
        [MonitoringDescription(SR.ThreadStartAddress)]
        public IntPtr StartAddress {
            get {
                EnsureState(State.IsNt);
                return threadInfo.startAddress;
            }
        }

        /// <include file='doc\ProcessThread.uex' path='docs/doc[@for="ProcessThread.StartTime"]/*' />
        /// <devdoc>
        ///     Returns the time the associated thread was started.
        /// </devdoc>
        [MonitoringDescription(SR.ThreadStartTime)]
        public DateTime StartTime {
            get {
                EnsureState(State.IsNt);
                return threadInfo.startTime;
            }
        }

        /// <include file='doc\ProcessThread.uex' path='docs/doc[@for="ProcessThread.ThreadState"]/*' />
        /// <devdoc>
        ///     Returns the current state of the associated thread, e.g. is it running, waiting, etc.
        /// </devdoc>
        [MonitoringDescription(SR.ThreadThreadState)]
        public ThreadState ThreadState {
            get {
                EnsureState(State.IsNt);
                return threadInfo.threadState;
            }
        }

        /// <include file='doc\ProcessThread.uex' path='docs/doc[@for="ProcessThread.TotalProcessorTime"]/*' />
        /// <devdoc>
        ///     Returns the amount of time the associated thread has spent utilizing the CPU.
        ///     It is the sum of the System.Diagnostics.ProcessThread.UserProcessorTime and
        ///     System.Diagnostics.ProcessThread.PrivilegedProcessorTime.
        /// </devdoc>
        [MonitoringDescription(SR.ThreadTotalProcessorTime)]
        public TimeSpan TotalProcessorTime {
            get {
                EnsureState(State.IsNt);
                return threadInfo.userTime + threadInfo.privilegedTime;
            }
        }

        /// <include file='doc\ProcessThread.uex' path='docs/doc[@for="ProcessThread.UserProcessorTime"]/*' />
        /// <devdoc>
        ///     Returns the amount of time the associated thread has spent running code
        ///     inside the application (not the operating system core).
        /// </devdoc>
        [MonitoringDescription(SR.ThreadUserProcessorTime)]
        public TimeSpan UserProcessorTime {
            get {
                EnsureState(State.IsNt);
                return threadInfo.userTime;
            }
        }

        /// <include file='doc\ProcessThread.uex' path='docs/doc[@for="ProcessThread.WaitReason"]/*' />
        /// <devdoc>
        ///     Returns the reason the associated thread is waiting, if any.
        /// </devdoc>
        [MonitoringDescription(SR.ThreadWaitReason)]
        public ThreadWaitReason WaitReason {
            get {
                EnsureState(State.IsNt);
                if (threadInfo.threadState != ThreadState.Wait) throw new InvalidOperationException(SR.GetString(SR.WaitReasonUnavailable));
                return threadInfo.threadWaitReason;
            }
        }

        //
        // METHODS
        //

        /// <include file='doc\ProcessThread.uex' path='docs/doc[@for="ProcessThread.CloseThreadHandle"]/*' />
        /// <devdoc>
        ///     Helper to close a thread handle.
        /// </devdoc>
        /// <internalonly/>
        void CloseThreadHandle(IntPtr handle) {
            if (handle != (IntPtr)0) SafeNativeMethods.CloseHandle(new HandleRef(this, handle));
        }

        /// <include file='doc\ProcessThread.uex' path='docs/doc[@for="ProcessThread.EnsureState"]/*' />
        /// <devdoc>
        ///     Helper to check preconditions for property access.
        /// </devdoc>
        void EnsureState(State state) {
            if ((state & State.IsLocal) != (State)0)
                if (isRemoteMachine)
                    throw new NotSupportedException(SR.GetString(SR.NotSupportedRemoteThread));

            if ((state & State.IsNt) != (State)0) {
                if (Environment.OSVersion.Platform != PlatformID.Win32NT)
                    throw new PlatformNotSupportedException(SR.GetString(SR.WinNTRequired));
            }
        }

        /// <include file='doc\ProcessThread.uex' path='docs/doc[@for="ProcessThread.OpenThreadHandle"]/*' />
        /// <devdoc>
        ///     Helper to open a thread handle.
        /// </devdoc>
        /// <internalonly/>
        IntPtr OpenThreadHandle(int access) {
            EnsureState(State.IsLocal);
            return ProcessManager.OpenThread(threadInfo.threadId, access);
        }

        /// <include file='doc\ProcessThread.uex' path='docs/doc[@for="ProcessThread.ResetIdealProcessor"]/*' />
        /// <devdoc>
        ///     Resets the ideal processor so there is no ideal processor for this thread (e.g.
        ///     any processor is ideal).
        /// </devdoc>
        public void ResetIdealProcessor() {
            // 32 means "any processor is fine"
            IdealProcessor = 32;
        }

        /// <include file='doc\ProcessThread.uex' path='docs/doc[@for="ProcessThread.ProcessorAffinity"]/*' />
        /// <devdoc>
        ///     Sets which processors the associated thread is allowed to be scheduled to run on.
        ///     Each processor is represented as a bit: bit 0 is processor one, bit 1 is processor
        ///     two, etc.  For example, the value 1 means run on processor one, 2 means run on
        ///     processor two, 3 means run on processor one or two.
        /// </devdoc>
        [Browsable(false)]
        public IntPtr ProcessorAffinity {
            set {
                IntPtr threadHandle = (IntPtr)0;
                try {
                    threadHandle = OpenThreadHandle(NativeMethods.THREAD_SET_INFORMATION | NativeMethods.THREAD_QUERY_INFORMATION);
                    if (!NativeMethods.SetThreadAffinityMask(new HandleRef(this, threadHandle), new HandleRef(this, value)))
                        throw new Win32Exception();
                }
                finally {
                    CloseThreadHandle(threadHandle);
                }
            }
        }

        /// <summary>
        ///      Preconditions for accessing properties.
        /// </summary>
        /// <internalonly/>
        enum State {
            IsLocal = 0x2,
            IsNt = 0x4
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\services\monitoring\system\diagnosticts\processmodulecollection.cs ===
//------------------------------------------------------------------------------
// <copyright file="ProcessModuleCollection.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Diagnostics {
    using System;
    using System.Collections;
    using System.Diagnostics;
    
    /// <include file='doc\ProcessModuleCollection.uex' path='docs/doc[@for="ProcessModuleCollection"]/*' />
    /// <devdoc>
    ///    <para>[To be supplied.]</para>
    /// </devdoc>
    public class ProcessModuleCollection : ReadOnlyCollectionBase {
        /// <include file='doc\ProcessModuleCollection.uex' path='docs/doc[@for="ProcessModuleCollection.ProcessModuleCollection"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        protected ProcessModuleCollection() {
        }
        
        /// <include file='doc\ProcessModuleCollection.uex' path='docs/doc[@for="ProcessModuleCollection.ProcessModuleCollection2"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public ProcessModuleCollection(ProcessModule[] processModules) {
            InnerList.AddRange(processModules);
        }

        /// <include file='doc\ProcessModuleCollection.uex' path='docs/doc[@for="ProcessModuleCollection.this"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public ProcessModule this[int index] {
            get { return (ProcessModule)InnerList[index]; }
        }
        
        internal int Add(ProcessModule module) {
            return InnerList.Add(module);
        }
        
        internal void Insert(int index, ProcessModule module) {
            InnerList.Insert(index, module);
        }
        
        /// <include file='doc\ProcessModuleCollection.uex' path='docs/doc[@for="ProcessModuleCollection.IndexOf"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public int IndexOf(ProcessModule module) {
            return InnerList.IndexOf(module);
        }
        
        /// <include file='doc\ProcessModuleCollection.uex' path='docs/doc[@for="ProcessModuleCollection.Contains"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public bool Contains(ProcessModule module) {
            return InnerList.Contains(module);
        }
        
        internal void Remove(ProcessModule module) {
            InnerList.Remove(module);
        }
        /// <include file='doc\ProcessModuleCollection.uex' path='docs/doc[@for="ProcessModuleCollection.CopyTo"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public void CopyTo(ProcessModule[] array, int index) {
            InnerList.CopyTo(array, index);
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\services\monitoring\system\diagnosticts\processwaithandle.cs ===
//------------------------------------------------------------------------------
// <copyright file="processwaithandle.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>
//------------------------------------------------------------------------------


/**************************************************************************\
*
* Copyright (c) 1998-2002, Microsoft Corp.  All Rights Reserved.
*
* Module Name:
*
*   processwaithandle.cs
*
* Abstract:
*
* Revision History:
*
\**************************************************************************/
using System;
using System.Threading;

namespace System.Diagnostics {
    internal class ProcessWaitHandle : WaitHandle {

        protected override void Dispose(bool explicitDisposing) {
            // WaitHandle.Dispose(bool) closes our handle - we
            // don't want to do that because Process.Dispose will
            // take care of it
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\services\monitoring\system\diagnosticts\processthreadcollection.cs ===
//------------------------------------------------------------------------------
// <copyright file="ProcessThreadCollection.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Diagnostics {

    using System.Collections;
    using System;
    using System.IO;
    using System.ComponentModel;
    using System.Diagnostics;

    /// <include file='doc\ProcessThreadCollection.uex' path='docs/doc[@for="ProcessThreadCollection"]/*' />
    /// <devdoc>
    ///    <para>[To be supplied.]</para>
    /// </devdoc>
    public class ProcessThreadCollection : ReadOnlyCollectionBase {
        /// <include file='doc\ProcessThreadCollection.uex' path='docs/doc[@for="ProcessThreadCollection.ProcessThreadCollection"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        protected ProcessThreadCollection() {
        }

        /// <include file='doc\ProcessThreadCollection.uex' path='docs/doc[@for="ProcessThreadCollection.ProcessThreadCollection2"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public ProcessThreadCollection(ProcessThread[] processThreads) {
            InnerList.AddRange(processThreads);
        }

        /// <include file='doc\ProcessThreadCollection.uex' path='docs/doc[@for="ProcessThreadCollection.this"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public ProcessThread this[int index] {
            get { return (ProcessThread)InnerList[index]; }
        }
        
        /// <include file='doc\ProcessThreadCollection.uex' path='docs/doc[@for="ProcessThreadCollection.Add"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public int Add(ProcessThread thread) {
            return InnerList.Add(thread);
        }
        
        /// <include file='doc\ProcessThreadCollection.uex' path='docs/doc[@for="ProcessThreadCollection.Insert"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public void Insert(int index, ProcessThread thread) {
            InnerList.Insert(index, thread);
        }
        
        /// <include file='doc\ProcessThreadCollection.uex' path='docs/doc[@for="ProcessThreadCollection.IndexOf"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public int IndexOf(ProcessThread thread) {
            return InnerList.IndexOf(thread);
        }
        
        /// <include file='doc\ProcessThreadCollection.uex' path='docs/doc[@for="ProcessThreadCollection.Contains"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public bool Contains(ProcessThread thread) {
            return InnerList.Contains(thread);
        }
        
        /// <include file='doc\ProcessThreadCollection.uex' path='docs/doc[@for="ProcessThreadCollection.Remove"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public void Remove(ProcessThread thread) {
            InnerList.Remove(thread);
        }
        
        /// <include file='doc\ProcessThreadCollection.uex' path='docs/doc[@for="ProcessThreadCollection.CopyTo"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public void CopyTo(ProcessThread[] array, int index) {
            InnerList.CopyTo(array, index);
        }
        
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\services\monitoring\system\diagnosticts\processmodule.cs ===
//------------------------------------------------------------------------------
// <copyright file="ProcessModule.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Diagnostics {
    using System.Diagnostics;
    using System;
    using System.Collections;
    using System.IO;
    using Microsoft.Win32;    
    using System.ComponentModel;
//    using System.Windows.Forms;

    /// <include file='doc\ProcessModule.uex' path='docs/doc[@for="ProcessModule"]/*' />
    /// <devdoc>
    ///     A process module component represents a DLL or EXE loaded into
    ///     a particular process.  Using this component, you can determine
    ///     information about the module.
    /// </devdoc>
    [Designer("System.Diagnostics.Design.ProcessModuleDesigner, " + AssemblyRef.SystemDesign)]
    public class ProcessModule : Component {
        internal ModuleInfo moduleInfo;
        FileVersionInfo fileVersionInfo;

        /// <include file='doc\ProcessModule.uex' path='docs/doc[@for="ProcessModule.ProcessModule"]/*' />
        /// <devdoc>
        ///     Initialize the module.
        /// </devdoc>
        /// <internalonly/>
        internal ProcessModule(ModuleInfo moduleInfo) {
            this.moduleInfo = moduleInfo;
        }

        /// <include file='doc\ProcessModule.uex' path='docs/doc[@for="ProcessModule.EnsureNtProcessInfo"]/*' />
        /// <devdoc>
        ///     Make sure we are running on NT.
        /// </devdoc>
        /// <internalonly/>
        internal void EnsureNtProcessInfo() {
            if (Environment.OSVersion.Platform != PlatformID.Win32NT)
                throw new PlatformNotSupportedException(SR.GetString(SR.WinNTRequired));
        }

        /// <include file='doc\ProcessModule.uex' path='docs/doc[@for="ProcessModule.ModuleName"]/*' />
        /// <devdoc>
        ///     Returns the name of the Module.
        /// </devdoc>
        [MonitoringDescription(SR.ProcModModuleName)]
        public string ModuleName {
            get {
                return moduleInfo.baseName;
            }
        }

        /// <include file='doc\ProcessModule.uex' path='docs/doc[@for="ProcessModule.FileName"]/*' />
        /// <devdoc>
        ///     Returns the full file path for the location of the module.
        /// </devdoc>
        [MonitoringDescription(SR.ProcModFileName)]
        public string FileName {
            get {
                return moduleInfo.fileName;
            }
        }

        /// <include file='doc\ProcessModule.uex' path='docs/doc[@for="ProcessModule.BaseAddress"]/*' />
        /// <devdoc>
        ///     Returns the memory address that the module was loaded at.
        /// </devdoc>
        [MonitoringDescription(SR.ProcModBaseAddress)]
        public IntPtr BaseAddress {
            get {
                return moduleInfo.baseOfDll;
            }
        }

        /// <include file='doc\ProcessModule.uex' path='docs/doc[@for="ProcessModule.ModuleMemorySize"]/*' />
        /// <devdoc>
        ///     Returns the amount of memory required to load the module.  This does
        ///     not include any additional memory allocations made by the module once
        ///     it is running; it only includes the size of the static code and data
        ///     in the module file.
        /// </devdoc>
        [MonitoringDescription(SR.ProcModModuleMemorySize)]
        public int ModuleMemorySize {
            get {
                return moduleInfo.sizeOfImage;
            }
        }

        /// <include file='doc\ProcessModule.uex' path='docs/doc[@for="ProcessModule.EntryPointAddress"]/*' />
        /// <devdoc>
        ///     Returns the memory address for function that runs when the module is
        ///     loaded and run.
        /// </devdoc>
        [MonitoringDescription(SR.ProcModEntryPointAddress)]
        public IntPtr EntryPointAddress {
            get {
                EnsureNtProcessInfo();
                return moduleInfo.entryPoint;
            }
        }

        /// <include file='doc\ProcessModule.uex' path='docs/doc[@for="ProcessModule.FileVersionInfo"]/*' />
        /// <devdoc>
        ///     Returns version information about the module.
        /// </devdoc>
        [Browsable(false)]
        public FileVersionInfo FileVersionInfo {
            get {
                if (fileVersionInfo == null)
                    fileVersionInfo = FileVersionInfo.GetVersionInfo(FileName);
                return fileVersionInfo;
            }
        }

        /// <include file='doc\ProcessModule.uex' path='docs/doc[@for="ProcessModule.ToString"]/*' />
        public override string ToString() {
            return String.Format("{0} ({1})", base.ToString(), this.ModuleName);
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\services\monitoring\system\diagnosticts\processwindowstyle.cs ===
//------------------------------------------------------------------------------
// <copyright file="ProcessWindowStyle.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Diagnostics {

    using System.Diagnostics;
    /// <include file='doc\ProcessWindowStyle.uex' path='docs/doc[@for="ProcessWindowStyle"]/*' />
    /// <devdoc>
    ///     A set of values indicating how the window should appear when starting
    ///     a process.
    /// </devdoc>
    public enum ProcessWindowStyle {
        /// <include file='doc\ProcessWindowStyle.uex' path='docs/doc[@for="ProcessWindowStyle.Normal"]/*' />
        /// <devdoc>
        ///     Show the window in a default location.
        /// </devdoc>
        Normal,

        /// <include file='doc\ProcessWindowStyle.uex' path='docs/doc[@for="ProcessWindowStyle.Hidden"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        Hidden,
        
        /// <include file='doc\ProcessWindowStyle.uex' path='docs/doc[@for="ProcessWindowStyle.Minimized"]/*' />
        /// <devdoc>
        ///     Show the window minimized.
        /// </devdoc>
        Minimized,
        
        /// <include file='doc\ProcessWindowStyle.uex' path='docs/doc[@for="ProcessWindowStyle.Maximized"]/*' />
        /// <devdoc>
        ///     Show the window maximized.
        /// </devdoc>
        Maximized
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\services\monitoring\system\diagnosticts\processstartinfo.cs ===
//------------------------------------------------------------------------------
// <copyright file="ProcessStartInfo.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Diagnostics {
    using System.Threading;
    using System.Runtime.InteropServices;
    using System.ComponentModel;
    using System.Diagnostics;
    using System;
    using System.Security;
    using System.Security.Permissions;
    using Microsoft.Win32;
    using System.IO;   
    using System.ComponentModel.Design;
    using System.Collections.Specialized;
    using System.Collections;
    using System.Globalization;
    

    /// <include file='doc\ProcessStartInfo.uex' path='docs/doc[@for="ProcessStartInfo"]/*' />
    /// <devdoc>
    ///     A set of values used to specify a process to start.  This is
    ///     used in conjunction with the <see cref='System.Diagnostics.Process'/>
    ///     component.
    /// </devdoc>

    [
    TypeConverter(typeof(ExpandableObjectConverter)),
    // Disabling partial trust scenarios
    PermissionSet(SecurityAction.LinkDemand, Name="FullTrust")
    ]
    public sealed class ProcessStartInfo {
        string fileName;
        string arguments;
        string directory;
        string verb;
        ProcessWindowStyle windowStyle;
        bool errorDialog;
        IntPtr errorDialogParentHandle;
        bool useShellExecute = true;
        bool redirectStandardInput = false;
        bool redirectStandardOutput = false;
        bool redirectStandardError = false;
        bool createNoWindow = false;
        WeakReference weakParentProcess;
        internal StringDictionary environmentVariables;

        /// <include file='doc\ProcessStartInfo.uex' path='docs/doc[@for="ProcessStartInfo.ProcessStartInfo"]/*' />
        /// <devdoc>
        ///     Default constructor.  At least the <see cref='System.Diagnostics.ProcessStartInfo.FileName'/>
        ///     property must be set before starting the process.
        /// </devdoc>
        public ProcessStartInfo() {
        }

        internal ProcessStartInfo(Process parent) {
            this.weakParentProcess = new WeakReference(parent);
        }

        /// <include file='doc\ProcessStartInfo.uex' path='docs/doc[@for="ProcessStartInfo.ProcessStartInfo1"]/*' />
        /// <devdoc>
        ///     Specifies the name of the application or document that is to be started.
        /// </devdoc>
        public ProcessStartInfo(string fileName) {
            this.fileName = fileName;
        }

        /// <include file='doc\ProcessStartInfo.uex' path='docs/doc[@for="ProcessStartInfo.ProcessStartInfo2"]/*' />
        /// <devdoc>
        ///     Specifies the name of the application that is to be started, as well as a set
        ///     of command line arguments to pass to the application.
        /// </devdoc>
        public ProcessStartInfo(string fileName, string arguments) {
            this.fileName = fileName;
            this.arguments = arguments;
        }

        /// <include file='doc\ProcessStartInfo.uex' path='docs/doc[@for="ProcessStartInfo.Verb"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Specifies the verb to use when opening the filename. For example, the "print"
        ///       verb will print a document specified using <see cref='System.Diagnostics.ProcessStartInfo.FileName'/>.
        ///       Each file extension has it's own set of verbs, which can be obtained using the
        ///    <see cref='System.Diagnostics.ProcessStartInfo.Verbs'/> property.
        ///       The default verb can be specified using "".
        ///    </para>
        ///    <note type="rnotes">
        ///       Discuss 'opening' vs. 'starting.' I think the part about the
        ///       default verb was a dev comment.
        ///       Find out what
        ///       that means.
        ///    </note>
        /// </devdoc>
        [DefaultValueAttribute(""), TypeConverter("System.Diagnostics.Design.VerbConverter, " + AssemblyRef.SystemDesign), MonitoringDescription(SR.ProcessVerb)]
        public string Verb {
            get {
                if (verb == null) return string.Empty;
                return verb;
            }
            set {
                verb = value;
            }
        }

        /// <include file='doc\ProcessStartInfo.uex' path='docs/doc[@for="ProcessStartInfo.Arguments"]/*' />
        /// <devdoc>
        ///     Specifies the set of command line arguments to use when starting the application.
        /// </devdoc>
        [
        DefaultValueAttribute(""), 
        MonitoringDescription(SR.ProcessArguments), 
        RecommendedAsConfigurable(true),
        TypeConverter("System.Diagnostics.Design.StringValueConverter, " + AssemblyRef.SystemDesign)
        ]
        public string Arguments {
            get {
                if (arguments == null) return string.Empty;
                return arguments;
            }
            set {
                arguments = value;
            }
        }

        /// <include file='doc\ProcessStartInfo.uex' path='docs/doc[@for="ProcessStartInfo.CreateNoWindow"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        [DefaultValue(false), MonitoringDescription(SR.ProcessCreateNoWindow) ]
        public bool CreateNoWindow {
            get { return createNoWindow; }
            set { createNoWindow = value; }
        }

        /// <include file='doc\ProcessStartInfo.uex' path='docs/doc[@for="ProcessStartInfo.EnvironmentVariables"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        [
            Editor("System.Diagnostics.Design.StringDictionaryEditor, " + AssemblyRef.SystemDesign, "System.Drawing.Design.UITypeEditor, " + AssemblyRef.SystemDrawing),
            DesignerSerializationVisibility(DesignerSerializationVisibility.Content),
            DefaultValue( null ), MonitoringDescription(SR.ProcessEnvironmentVariables)     
        ]
        public StringDictionary EnvironmentVariables {
            get { 
                if (environmentVariables == null) {
                    environmentVariables = new StringDictionary();
                    
                    // if not in design mode, initialize the child environment block with all the parent variables
                    if (!(this.weakParentProcess != null &&
                          this.weakParentProcess.IsAlive &&
                          ((Component)this.weakParentProcess.Target).Site != null &&
                          ((Component)this.weakParentProcess.Target).Site.DesignMode)) {
                        
                        foreach (DictionaryEntry entry in Environment.GetEnvironmentVariables())
                            environmentVariables.Add((string)entry.Key, (string)entry.Value);
                    }
                    
                }
                return environmentVariables; 
            }                        
        }

        /// <include file='doc\ProcessStartInfo.uex' path='docs/doc[@for="ProcessStartInfo.RedirectStandardInput"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        [DefaultValue(false), MonitoringDescription(SR.ProcessRedirectStandardInput) ]
        public bool RedirectStandardInput {
            get { return redirectStandardInput; }
            set { redirectStandardInput = value; }
        }
        
        /// <include file='doc\ProcessStartInfo.uex' path='docs/doc[@for="ProcessStartInfo.RedirectStandardOutput"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        [DefaultValue(false), MonitoringDescription(SR.ProcessRedirectStandardOutput)]
        public bool RedirectStandardOutput {
            get { return redirectStandardOutput; }
            set { redirectStandardOutput = value; }
        }
        
        /// <include file='doc\ProcessStartInfo.uex' path='docs/doc[@for="ProcessStartInfo.RedirectStandardError"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        [DefaultValue(false), MonitoringDescription(SR.ProcessRedirectStandardError)]
        public bool RedirectStandardError {
            get { return redirectStandardError; }
            set { redirectStandardError = value; }
        }

        /// <include file='doc\ProcessStartInfo.uex' path='docs/doc[@for="ProcessStartInfo.UseShellExecute"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        [DefaultValue(true), MonitoringDescription(SR.ProcessUseShellExecute)]
        public bool UseShellExecute {
            get { return useShellExecute; }
            set { useShellExecute = value; }
        }


        /// <include file='doc\ProcessStartInfo.uex' path='docs/doc[@for="ProcessStartInfo.Verbs"]/*' />
        /// <devdoc>
        ///     Returns the set of verbs associated with the file specified by the
        ///     <see cref='System.Diagnostics.ProcessStartInfo.FileName'/> property.
        /// </devdoc>
        [Browsable(false), DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        public string[] Verbs {
            get {
                ArrayList verbs = new ArrayList();
                RegistryKey key = null;
                string extension = Path.GetExtension(FileName);
                try {
                    if (extension != null && extension.Length > 0) {
                        key = Registry.ClassesRoot.OpenSubKey(extension);
                        if (key != null) {
                            string value = (string)key.GetValue(String.Empty);
                            key.Close();
                            key = Registry.ClassesRoot.OpenSubKey(value + "\\shell");
                            if (key != null) {
                                string[] names = key.GetSubKeyNames();
                                for (int i = 0; i < names.Length; i++)
                                    if (string.Compare(names[i], "new", true, CultureInfo.InvariantCulture) != 0)
                                        verbs.Add(names[i]);
                                key.Close();
                                key = null;
                            }
                        }
                    }
                }
                finally {
                    if (key != null) key.Close();
                }
                string[] temp = new string[verbs.Count];
                verbs.CopyTo(temp, 0);
                return temp;
            }
        }

        /// <include file='doc\ProcessStartInfo.uex' path='docs/doc[@for="ProcessStartInfo.FileName"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Returns or sets the application, document, or URL that is to be launched.
        ///    </para>
        ///    <note type="rnotes">
        ///       Was "started" rather
        ///       than "launched". Comment: "I am a bit affraid that customers will complain (be
        ///       confused) and will say that document and URL cannot be started." Discuss with
        ///       Krzysztof.
        ///    </note>
        /// </devdoc>
        [
        DefaultValue(""),
        Editor("System.Diagnostics.Design.StartFileNameEditor, " + AssemblyRef.SystemDesign, "System.Drawing.Design.UITypeEditor, " + AssemblyRef.SystemDrawing), 
        MonitoringDescription(SR.ProcessFileName),
        RecommendedAsConfigurable(true),
        TypeConverter("System.Diagnostics.Design.StringValueConverter, " + AssemblyRef.SystemDesign)
        ]
        public string FileName {
            get {
                if (fileName == null) return string.Empty;
                return fileName;
            }
            set { fileName = value;}
        }

        /// <include file='doc\ProcessStartInfo.uex' path='docs/doc[@for="ProcessStartInfo.WorkingDirectory"]/*' />
        /// <devdoc>
        ///     Returns or sets the initial directory for the process that is started.
        ///     Specify "" to if the default is desired.
        /// </devdoc>
        [
        DefaultValue(""), 
        MonitoringDescription(SR.ProcessWorkingDirectory), 
        Editor("System.Diagnostics.Design.WorkingDirectoryEditor, " + AssemblyRef.SystemDesign, "System.Drawing.Design.UITypeEditor, " + AssemblyRef.SystemDrawing),
        RecommendedAsConfigurable(true),
        TypeConverter("System.Diagnostics.Design.StringValueConverter, " + AssemblyRef.SystemDesign)
        ]
        public string WorkingDirectory {
            get {
                if (directory == null) return string.Empty;
                return directory;
            }
            set {
                directory = value;
            }
        }

        /// <include file='doc\ProcessStartInfo.uex' path='docs/doc[@for="ProcessStartInfo.ErrorDialog"]/*' />
        /// <devdoc>
        ///     Sets or returns whether or not an error dialog should be displayed to the user
        ///     if the process can not be started.
        /// </devdoc>
        [DefaultValueAttribute(false), MonitoringDescription(SR.ProcessErrorDialog)]
        public bool ErrorDialog {
            get { return errorDialog;}
            set { errorDialog = value;}
        }

        /// <include file='doc\ProcessStartInfo.uex' path='docs/doc[@for="ProcessStartInfo.ErrorDialogParentHandle"]/*' />
        /// <devdoc>
        ///     Sets or returns the window handle to use for the error dialog that is shown
        ///     when a process can not be started.  If <see cref='System.Diagnostics.ProcessStartInfo.ErrorDialog'/>
        ///     is true, this specifies the parent window for the dialog that is shown.  It is
        ///     useful to specify a parent in order to keep the dialog in front of the application.
        /// </devdoc>
        [Browsable(false), DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        public IntPtr ErrorDialogParentHandle {
            get { return errorDialogParentHandle;}
            set { errorDialogParentHandle = value;}
        }

        /// <include file='doc\ProcessStartInfo.uex' path='docs/doc[@for="ProcessStartInfo.WindowStyle"]/*' />
        /// <devdoc>
        ///     Sets or returns the style of window that should be used for the newly created process.
        /// </devdoc>
        [DefaultValueAttribute(System.Diagnostics.ProcessWindowStyle.Normal), MonitoringDescription(SR.ProcessWindowStyle)]
        public ProcessWindowStyle WindowStyle {
            get { return windowStyle;}
            set {
                if (!Enum.IsDefined(typeof(ProcessWindowStyle), value)) 
                    throw new InvalidEnumArgumentException("value", (int)value, typeof(ProcessWindowStyle));
                    
                windowStyle = value;
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\services\monitoring\system\diagnosticts\processpriorityclass.cs ===
//------------------------------------------------------------------------------
// <copyright file="ProcessPriorityClass.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Diagnostics {

    using System.Diagnostics;
    /// <include file='doc\ProcessPriorityClass.uex' path='docs/doc[@for="ProcessPriorityClass"]/*' />
    /// <devdoc>
    ///     A category of priority for a process.  Threads within a process
    ///     run at a priority which is relative to the process priority class.
    /// </devdoc>
    public enum ProcessPriorityClass {
        /// <include file='doc\ProcessPriorityClass.uex' path='docs/doc[@for="ProcessPriorityClass.Normal"]/*' />
        /// <devdoc>
        ///      Specify this class for a process with no special scheduling needs. 
        /// </devdoc>
        Normal = 0x20,
        
        /// <include file='doc\ProcessPriorityClass.uex' path='docs/doc[@for="ProcessPriorityClass.Idle"]/*' />
        /// <devdoc>
        ///     Specify this class for a process whose threads run only when the system is idle. 
        ///     The threads of the process are preempted by the threads of any process running in 
        ///     a higher priority class. An example is a screen saver. The idle-priority class is 
        ///     inherited by child processes.
        /// </devdoc>
        Idle = 0x40,
        
        /// <include file='doc\ProcessPriorityClass.uex' path='docs/doc[@for="ProcessPriorityClass.High"]/*' />
        /// <devdoc>
        ///     Specify this class for a process that performs time-critical tasks that must 
        ///     be executed immediately. The threads of the process preempt the threads of 
        ///     normal or idle priority class processes. An example is the Task List, which 
        ///     must respond quickly when called by the user, regardless of the load on the 
        ///     operating system. Use extreme care when using the high-priority class, because 
        ///     a high-priority class application can use nearly all available CPU time.
        /// </devdoc>
        High = 0x80,
        
        /// <include file='doc\ProcessPriorityClass.uex' path='docs/doc[@for="ProcessPriorityClass.RealTime"]/*' />
        /// <devdoc>
        ///     Specify this class for a process that has the highest possible priority. 
        ///     The threads of the process preempt the threads of all other processes, 
        ///     including operating system processes performing important tasks. For example, 
        ///     a real-time process that executes for more than a very brief interval can cause 
        ///     disk caches not to flush or cause the mouse to be unresponsive.
        /// </devdoc>
        RealTime = 0x100,

        /// <include file='doc\ProcessPriorityClass.uex' path='docs/doc[@for="ProcessPriorityClass.BelowNormal"]/*' />
        /// <devdoc>
        ///     Indicates a process that has priority above Idle but below Normal.
        /// </devdoc>
        BelowNormal = 0x4000,

        /// <include file='doc\ProcessPriorityClass.uex' path='docs/doc[@for="ProcessPriorityClass.AboveNormal"]/*' />
        /// <devdoc>
        ///     Indicates a process that has priority above Normal but below High.
        /// </devdoc>
        AboveNormal = 0x8000
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\services\monitoring\system\diagnosticts\sharedperformancecounter.cs ===
//------------------------------------------------------------------------------
// <copyright file="SharedPerformanceCounter.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------
                                                                          
namespace System.Diagnostics {
    using System;
    using System.Text;
    using System.Threading;
    using System.Collections;
    using System.Runtime.InteropServices;    
    using System.Security.Permissions;
    using System.Security;
    using Microsoft.Win32;
    
    internal class SharedPerformanceCounter {    
        internal static readonly string SingleInstanceName = "systemdiagnosticssharedsingleinstance";
        internal static int SingleInstanceHashCode = SingleInstanceName.GetHashCode();                
        private static readonly int MaxSpinCount = 10000;
        private static FileMapping fileMapping;        
        private IntPtr counterEntryPointer;       
        private string counterName;        
        private string instanceName;                         
        
        internal SharedPerformanceCounter(string categoryName, string counterName, string instanceName) {            
            this.counterName = counterName;
            this.instanceName = instanceName;
                            
            this.counterEntryPointer = GetCounter(categoryName, counterName, instanceName);                    
        }                                                                                                                                                                                                                                                   
        
        private static FileMapping FileView {            
            get {                                        
                if (fileMapping == null) {
                    int fileMappingSize = DiagnosticsConfiguration.PerfomanceCountersFileMappingSize;                                                                                                                   
                    lock(typeof(FileMapping)) {
                        if (fileMapping == null)
                            fileMapping = new FileMapping(fileMappingSize);
                    }                    
                }                    
                
                if (fileMapping.IsGhosted)
                    throw new InvalidOperationException(SR.GetString("SharedMemoryGhosted"));
                    
                return fileMapping;                    
            }                                
        }
                                      
        internal unsafe long Value {
            get {
                if (fileMapping.IsGhosted)
                    return 0;                     
                    
                CounterEntry* counterEntry = (CounterEntry*)this.counterEntryPointer;
                return counterEntry->Value;                                                                        
            }
            
            set {   
                if (fileMapping.IsGhosted)
                    return;                     
                
                CounterEntry* counterEntry = (CounterEntry*)this.counterEntryPointer;                 
                counterEntry->Value = value;
            }
        }                                                            
                                                                      
        private static unsafe int CreateCategory(int categoryNameHashCode, string categoryName, 
                                                                  int counterNameHashCode, string counterName, 
                                                                  int instanceNameHashCode, string instanceName) {    
            int categoryNameLength = (categoryName.Length + 1) * 2;                                    
            int instanceNameLength = (instanceName.Length + 1) * 2;
            int counterNameLength = (counterName.Length + 1) * 2;                                                                             
            IntPtr baseAddress =  FileView.FileViewAddress;
            int totalSize = sizeof(CategoryEntry) + sizeof(InstanceEntry) + sizeof(CounterEntry) + categoryNameLength + instanceNameLength + counterNameLength;
            //Need to guarantee that the location where we store the counter
            //value, is DWORD aligend, so 64 bit interlocked operations don't fail.
            if (totalSize % 8 != 0)
                totalSize = totalSize + (8 - (totalSize % 8));
            int freeMemoryOffset = SafeNativeMethods.InterlockedExchangeAdd(baseAddress, totalSize);            
            if (freeMemoryOffset + totalSize > FileView.FileMappingSize) {                                 
                throw new InvalidOperationException(SR.GetString(SR.CountersOOM));
            }                
                            
            CategoryEntry* newCategoryEntryPointer = (CategoryEntry*)((long)baseAddress + freeMemoryOffset);
            InstanceEntry* newInstanceEntryPointer = (InstanceEntry*)(newCategoryEntryPointer + 1);
            CounterEntry* newCounterEntryPointer = (CounterEntry*)(newInstanceEntryPointer + 1);
            newCategoryEntryPointer->CategoryNameOffset = freeMemoryOffset  + sizeof(CategoryEntry)  + sizeof(InstanceEntry) + sizeof(CounterEntry);
            newInstanceEntryPointer->InstanceNameOffset = newCategoryEntryPointer->CategoryNameOffset + categoryNameLength;
            newCounterEntryPointer->CounterNameOffset = newInstanceEntryPointer->InstanceNameOffset + instanceNameLength; 
                                                                                                                                           
            newCategoryEntryPointer->CategoryNameHashCode = categoryNameHashCode;            
            newCategoryEntryPointer->NextCategoryOffset = 0;                                    
            newCategoryEntryPointer->FirstInstanceOffset = (int)((long)newInstanceEntryPointer - (long)baseAddress);                                                                                                                        
            Marshal.Copy(categoryName.ToCharArray(), 0, (IntPtr)((long)baseAddress + newCategoryEntryPointer->CategoryNameOffset), categoryName.Length);                                                                                                                                                                                                                                                                                                                                         
            
            newInstanceEntryPointer->InstanceNameHashCode = instanceNameHashCode;  
            newInstanceEntryPointer->NextInstanceOffset = 0;
            newInstanceEntryPointer->FirstCounterOffset = (int)((long)newCounterEntryPointer - (long)baseAddress);                        
            newInstanceEntryPointer->RefCount = 1;                                   
            Marshal.Copy(instanceName.ToCharArray(), 0, (IntPtr)((long)baseAddress + newInstanceEntryPointer->InstanceNameOffset), instanceName.Length);                        
            
            newCounterEntryPointer->CounterNameHashCode = counterNameHashCode;
            newCounterEntryPointer->NextCounterOffset = 0;
            newCounterEntryPointer->Value = 0;            
            Marshal.Copy(counterName.ToCharArray(), 0, (IntPtr)((long)baseAddress + newCounterEntryPointer->CounterNameOffset), counterName.Length);                                                                               
                        
            return freeMemoryOffset;
        }

        private static unsafe int CreateCounter(int counterNameHashCode, string counterName) {                        
            int counterNameLength = (counterName.Length + 1) * 2;                                                                             
            IntPtr baseAddress =  FileView.FileViewAddress;
            int totalSize = sizeof(CounterEntry) + counterNameLength;            
            //Need to guarantee that the location where we store the counter
            //value, is DWORD aligend, so 64 bit interlocked operations don't fail.
            if (totalSize % 8 != 0)
                 totalSize = totalSize + (8 - (totalSize % 8));
            int freeMemoryOffset = SafeNativeMethods.InterlockedExchangeAdd(baseAddress, totalSize);            
            if (freeMemoryOffset + totalSize > FileView.FileMappingSize) {                
                throw new InvalidOperationException(SR.GetString(SR.CountersOOM));
            }                
            
            CounterEntry* newCounterEntryPointer = (CounterEntry*)((long)baseAddress + freeMemoryOffset);            
            
            newCounterEntryPointer->CounterNameOffset = freeMemoryOffset  + sizeof(CounterEntry);
            newCounterEntryPointer->CounterNameHashCode = counterNameHashCode;
            newCounterEntryPointer->NextCounterOffset = 0;
            newCounterEntryPointer->Value = 0;            
            Marshal.Copy(counterName.ToCharArray(), 0, (IntPtr)((long)baseAddress + newCounterEntryPointer->CounterNameOffset), counterName.Length);                                                                               
                        
            return freeMemoryOffset;
        }
        
        private static unsafe int CreateInstance(int counterNameHashCode, string counterName, 
                                                                  int instanceNameHashCode, string instanceName) {                                                
            int instanceNameLength = (instanceName.Length + 1) * 2;
            int counterNameLength = (counterName.Length + 1) * 2;                                                                             
            IntPtr baseAddress =  FileView.FileViewAddress;
            int totalSize = sizeof(InstanceEntry) + sizeof(CounterEntry) + instanceNameLength + counterNameLength;
            //Need to guarantee that the location where we store the counter
            //value, is DWORD aligend, so 64 bit interlocked operations don't fail.
            if (totalSize % 8 != 0)
                 totalSize = totalSize + (8 - (totalSize % 8));
            int freeMemoryOffset = SafeNativeMethods.InterlockedExchangeAdd(baseAddress, totalSize);            
            if (freeMemoryOffset + totalSize > FileView.FileMappingSize) {                
                throw new InvalidOperationException(SR.GetString(SR.CountersOOM));
            }                
                                 
            InstanceEntry* newInstanceEntryPointer = (InstanceEntry*)((long)baseAddress + freeMemoryOffset);            
            CounterEntry* newCounterEntryPointer = (CounterEntry*)(newInstanceEntryPointer + 1);
            newInstanceEntryPointer->InstanceNameOffset = freeMemoryOffset + sizeof(InstanceEntry) + sizeof(CounterEntry);             
            newCounterEntryPointer->CounterNameOffset = newInstanceEntryPointer->InstanceNameOffset + instanceNameLength; 
                        
            newInstanceEntryPointer->InstanceNameHashCode = instanceNameHashCode;  
            newInstanceEntryPointer->NextInstanceOffset = 0;
            newInstanceEntryPointer->FirstCounterOffset = (int)((long)newCounterEntryPointer - (long)baseAddress);                    
            newInstanceEntryPointer->RefCount = 1;            
            Marshal.Copy(instanceName.ToCharArray(), 0, (IntPtr)((long)baseAddress + newInstanceEntryPointer->InstanceNameOffset), instanceName.Length);                            
            
            newCounterEntryPointer->CounterNameHashCode = counterNameHashCode;
            newCounterEntryPointer->NextCounterOffset = 0;
            newCounterEntryPointer->Value = 0;            
            Marshal.Copy(counterName.ToCharArray(), 0, (IntPtr)((long)baseAddress + newCounterEntryPointer->CounterNameOffset), counterName.Length);                                                                               
                                    
            return freeMemoryOffset;
        }                    
        
        private static unsafe bool EnterCriticalSection(int* spinLockPointer) {
            return (SafeNativeMethods.InterlockedCompareExchange((IntPtr)spinLockPointer, 1, 0) == 0);                        
        }
        
        private static unsafe void WaitForCriticalSection(int* spinLockPointer) {            
            int spinCount = MaxSpinCount;
            while (*spinLockPointer != 0) {
                Thread.Sleep(1);
                --spinCount;
                if (spinCount == 0)
                    throw new InvalidOperationException(SR.GetString(SR.PossibleDeadlock));                    
            }                    
        }
         
        private static unsafe void ExitCriticalSection(int* spinLockPointer) {            
            *spinLockPointer = 0;
        }        

        public static unsafe long GetCounterValue(int categoryNameHashCode, string categoryName, 
                                                                   int counterNameHashCode, string counterName, 
                                                                   int instanceNameHashCode, string instanceName) {                      
                                                                               
            CategoryEntry* categoryPointer =  (CategoryEntry*)(ResolveOffset(4));
            if (!FindCategory(categoryNameHashCode, categoryName, categoryPointer, &categoryPointer))
                return 0;
                                                                                                                                                                   
            InstanceEntry* instancePointer = (InstanceEntry*)(ResolveOffset(categoryPointer->FirstInstanceOffset));                                                  
            if (!FindInstance(instanceNameHashCode, instanceName, instancePointer, &instancePointer))
                return 0;
    
            CounterEntry* counterPointer = (CounterEntry*)(ResolveOffset(instancePointer->FirstCounterOffset));                                                  
            if (!FindCounter(counterNameHashCode, counterName, counterPointer, &counterPointer))
                return 0;
                
            return counterPointer->Value;                    
        }
        
        internal static unsafe int GetNumberOfInstances(int categoryNameHashCode, string categoryName) {            
            CategoryEntry* categoryPointer =  (CategoryEntry*)(ResolveOffset(4));
            if (!FindCategory(categoryNameHashCode, categoryName, categoryPointer, &categoryPointer) ||
                categoryPointer->FirstInstanceOffset == 0)
                return 0;

            int count = 0;                 
            InstanceEntry* currentInstancePointer =  (InstanceEntry*)(ResolveOffset(categoryPointer->FirstInstanceOffset));
            if (currentInstancePointer->InstanceNameHashCode == SingleInstanceHashCode)
                return 0;
                
            for(;;){                       
                if (currentInstancePointer->RefCount > 0) 
                    ++ count;
                                                                    
                if (currentInstancePointer->NextInstanceOffset == 0)
                    break;
                else                                                                                                                                       
                    currentInstancePointer = (InstanceEntry*)(ResolveOffset(currentInstancePointer->NextInstanceOffset));                          
            }                                 
            
            return count;
        }
                                                  
        internal static unsafe string[] GetInstanceNames(int categoryNameHashCode, string categoryName) {
            IntPtr baseAddress =  FileView.FileViewAddress;
            CategoryEntry* categoryPointer =  (CategoryEntry*)(ResolveOffset(4));
            if (!FindCategory(categoryNameHashCode, categoryName, categoryPointer, &categoryPointer) ||
                categoryPointer->FirstInstanceOffset == 0)
                return new string[0];
            
            ArrayList instancesList = new ArrayList();
            InstanceEntry* currentInstancePointer =  (InstanceEntry*)(ResolveOffset(categoryPointer->FirstInstanceOffset));
            if (currentInstancePointer->InstanceNameHashCode == SingleInstanceHashCode)
                return new string[0];
                
            for(;;){                       
                if (currentInstancePointer->RefCount > 0) {                    
                    string instanceName = Marshal.PtrToStringUni((IntPtr)(ResolveOffset(currentInstancePointer->InstanceNameOffset)));
                    instancesList.Add(instanceName);       
                }
                                                    
                if (currentInstancePointer->NextInstanceOffset == 0)
                    break;
                else                                                                                                                                       
                    currentInstancePointer = (InstanceEntry*)(ResolveOffset(currentInstancePointer->NextInstanceOffset));                          
            }                                 
            
            string[] instancesNames = new string[instancesList.Count];                                         
            instancesList.CopyTo(instancesNames, 0);
            return instancesNames;
        }
                    
        private static unsafe IntPtr GetCounter(string categoryName, string counterName, string instanceName) {
            int categoryNameHashCode = categoryName.GetHashCode();
            int counterNameHashCode = counterName.GetHashCode();
            int instanceNameHashCode;
            if (instanceName != "" && instanceName != null) 
                instanceNameHashCode = instanceName.GetHashCode();                                            
            else {           
                instanceNameHashCode = SingleInstanceHashCode;                
                instanceName = SingleInstanceName;
            }                                                                    
                          
            CategoryEntry* categoryPointer =  (CategoryEntry*)(ResolveOffset(4));                  
            while (!FindCategory(categoryNameHashCode, categoryName, categoryPointer, &categoryPointer)) {                
                if (EnterCriticalSection(&(categoryPointer->SpinLock))) {
                    try {                                                    
                        int newCategoryOffset = CreateCategory(categoryNameHashCode, categoryName, counterNameHashCode, counterName, instanceNameHashCode, instanceName);
                        //If not the first category node, link it.
                        if (newCategoryOffset != 4)
                            categoryPointer->NextCategoryOffset = newCategoryOffset;                
                                                                                                      
                        return (IntPtr)(ResolveOffset(((InstanceEntry*)(ResolveOffset(((CategoryEntry*)(ResolveOffset(newCategoryOffset)))->FirstInstanceOffset)))->FirstCounterOffset));                        
                    }
                    finally {
                        ExitCriticalSection(&(categoryPointer->SpinLock));
                    }                
                }
            }
            
            InstanceEntry* instancePointer = (InstanceEntry*)(ResolveOffset(categoryPointer->FirstInstanceOffset));                                                  
            while (!FindInstance(instanceNameHashCode, instanceName, instancePointer, &instancePointer)) {                                
                if (EnterCriticalSection(&(instancePointer->SpinLock))) {
                    try {                    
                        int newInstanceOffset = CreateInstance(counterNameHashCode, counterName, instanceNameHashCode, instanceName);
                        //This will never be the first instance node, no need to check
                        instancePointer->NextInstanceOffset = newInstanceOffset;                                      
                        return (IntPtr)(ResolveOffset(((InstanceEntry*)(ResolveOffset(newInstanceOffset)))->FirstCounterOffset));                
                    }
                    finally {
                        ExitCriticalSection(&(instancePointer->SpinLock));
                    }                    
                }
            }
            
            CounterEntry* counterPointer = (CounterEntry*)(ResolveOffset(instancePointer->FirstCounterOffset));                                                  
            while (!FindCounter(counterNameHashCode, counterName, counterPointer, &counterPointer)) {                
                if (EnterCriticalSection(&(counterPointer->SpinLock))) {
                    try {                
                        int newCounterOffset =  CreateCounter(counterNameHashCode, counterName);                                       
                        //This will never be the first counter node, no need to check
                        counterPointer->NextCounterOffset = newCounterOffset;                                
                        return (IntPtr)(ResolveOffset(newCounterOffset));                                            
                    }
                    finally {
                        ExitCriticalSection(&(counterPointer->SpinLock));
                    }                                                 
                }
            } 
            
            return (IntPtr)counterPointer;
        }                                                                                                    
                                                                                                                                      
        private static unsafe bool FindCategory(int categoryNameHashCode, string categoryName, CategoryEntry* firstCategoryPointer, CategoryEntry** returnCategoryPointerReference) {            
            CategoryEntry* currentCategoryPointer = firstCategoryPointer;
            CategoryEntry* previousCategoryPointer = firstCategoryPointer;
            for(;;) {
                WaitForCriticalSection(&(currentCategoryPointer->SpinLock));
                if (currentCategoryPointer->CategoryNameHashCode == categoryNameHashCode) {
                    string currentCategoryName = Marshal.PtrToStringUni((IntPtr)(ResolveOffset(currentCategoryPointer->CategoryNameOffset)));
                    if (categoryName == currentCategoryName) { 
                        *returnCategoryPointerReference = currentCategoryPointer;                                                                
                        return true;   
                    }                          
                }   
                                
                previousCategoryPointer = currentCategoryPointer;
                if (currentCategoryPointer->NextCategoryOffset != 0) 
                    currentCategoryPointer = (CategoryEntry*)(ResolveOffset(currentCategoryPointer->NextCategoryOffset));
                else {
                    *returnCategoryPointerReference = previousCategoryPointer;
                    return false;            
                }                             
            }                        
        }  
                
        private static unsafe bool FindCounter(int counterNameHashCode, string counterName, CounterEntry* firstCounterPointer, CounterEntry** returnCounterPointerReference) {            
            CounterEntry* currentCounterPointer = firstCounterPointer;
            CounterEntry* previousCounterPointer = firstCounterPointer;
            for(;;) {
                WaitForCriticalSection(&(currentCounterPointer->SpinLock));
                if (currentCounterPointer->CounterNameHashCode == counterNameHashCode) {                    
                    string currentCounterName = Marshal.PtrToStringUni((IntPtr)(ResolveOffset(currentCounterPointer->CounterNameOffset)));
                    if (counterName == currentCounterName) { 
                        *returnCounterPointerReference = currentCounterPointer;
                        return true;   
                    }                        
                }   
                
                previousCounterPointer = currentCounterPointer;
                if (currentCounterPointer->NextCounterOffset != 0)
                    currentCounterPointer = (CounterEntry*)(ResolveOffset(currentCounterPointer->NextCounterOffset));
                else {
                    *returnCounterPointerReference = previousCounterPointer;
                    return false;            
                }                             
            }                        
        }                                                        
                       
        private static unsafe bool FindInstance(int instanceNameHashCode, string instanceName, InstanceEntry* firstInstancePointer, InstanceEntry** returnInstancePointerReference) {             
            InstanceEntry* currentInstancePointer = firstInstancePointer;
            InstanceEntry* previousInstancePointer = firstInstancePointer;
            for(;;) {
                WaitForCriticalSection(&(currentInstancePointer->SpinLock));
                if (currentInstancePointer->InstanceNameHashCode == instanceNameHashCode) {
                    string currentInstanceName = Marshal.PtrToStringUni((IntPtr)(ResolveOffset(currentInstancePointer->InstanceNameOffset)));
                    if (instanceName == currentInstanceName) { 
                        *returnInstancePointerReference = currentInstancePointer;
                        (*returnInstancePointerReference)->RefCount++;
                        return true;   
                    }                        
                }                    
                
                previousInstancePointer = currentInstancePointer;                         
                if (currentInstancePointer->NextInstanceOffset != 0)        
                    currentInstancePointer =  (InstanceEntry*)(ResolveOffset(currentInstancePointer->NextInstanceOffset));
                else {
                    *returnInstancePointerReference = previousInstancePointer;
                    return false;            
                }                                                     
            }                        
        }                                                        

        internal unsafe long IncrementBy(long value) {            
            if (fileMapping.IsGhosted)
                return 0;                     
            
            CounterEntry* counterEntry = (CounterEntry*)this.counterEntryPointer;                           
            long newValue;
            int spinCount = 10000;
            while (!EnterCriticalSection(&(counterEntry->SpinLock)) && spinCount > 0)                
                --spinCount;
            
            try {                                           
                newValue = counterEntry->Value + value;
                counterEntry->Value = newValue;                            
            }
            finally {            
                ExitCriticalSection(&(counterEntry->SpinLock));
            }
                            
            return newValue;
        }         

        internal unsafe long Increment() {
            if (fileMapping.IsGhosted)
                return 0;                     
                
            CounterEntry* counterEntry = (CounterEntry*)this.counterEntryPointer;                                                                                    
            return Interlocked.Increment(ref counterEntry->Value);
        }

        internal unsafe long Decrement() {
            if (fileMapping.IsGhosted)
                return 0;                     
                
            CounterEntry* counterEntry = (CounterEntry*)this.counterEntryPointer;                                                                                    
            return Interlocked.Decrement(ref counterEntry->Value);
        }
         
        internal static unsafe void RemoveInstance(string categoryName, string instanceName) {                           
            if (instanceName == "" || instanceName == null) 
                return;                
                
            int categoryNameHashCode = categoryName.GetHashCode();                                                                              
            int instanceNameHashCode = instanceName.GetHashCode();                             
            CategoryEntry* categoryPointer =  (CategoryEntry*)(ResolveOffset(4));
            if (!FindCategory(categoryNameHashCode, categoryName, categoryPointer, &categoryPointer))
                return;
                                                                                                                                                                   
            InstanceEntry* instancePointer = (InstanceEntry *)(ResolveOffset(categoryPointer->FirstInstanceOffset));                                                  
            if (!FindInstance(instanceNameHashCode, instanceName, instancePointer, &instancePointer))
                return ;
                
            while (!EnterCriticalSection(&(instancePointer->SpinLock)))
                WaitForCriticalSection(&(instancePointer->SpinLock));                
                
            try {                
                instancePointer->RefCount = 0;
                //Clear counter instance values
                CounterEntry* currentCounterPointer = null;
                
                if (instancePointer->FirstCounterOffset != 0)
                    currentCounterPointer = (CounterEntry*)(ResolveOffset(instancePointer->FirstCounterOffset));
                    
                while(currentCounterPointer != null) {                      
                    currentCounterPointer->Value = 0;                               
                    if (currentCounterPointer->NextCounterOffset != 0)
                        currentCounterPointer = (CounterEntry*)(ResolveOffset(currentCounterPointer->NextCounterOffset));                                                                                                                                                        
                    else
                        currentCounterPointer = null;                        
                }                
            }
            finally {
                ExitCriticalSection(&(instancePointer->SpinLock)); 
            }                                
        }                      

        private static long ResolveOffset(int offset) {    
            //It is very important to check the integrity of the shared memory
            //everytime a new address is resolved. 
            if (offset > FileView.FileMappingSize || offset < 0) 
                throw new InvalidOperationException(SR.GetString(SR.MappingCorrupted));            
            
            long address = (long)FileView.FileViewAddress + offset;
            
            return address;
        }
                                               
        private class FileMapping {
            internal int FileMappingSize;
            internal IntPtr FileViewAddress = (IntPtr)0;                    
            internal bool IsGhosted;
            private IntPtr fileMappingHandle = (IntPtr)0;                    
            //The version of the file mapping name is independent from the
            //assembly version.
            private static string FileMappingName = "netfxcustomperfcounters.1.0";            
                        
            public FileMapping(int fileMappingSize) {
                this.Initialize(fileMappingSize);
            }                        
            
            internal void Close() {
                if (fileMappingHandle != (IntPtr)0) 
                    SafeNativeMethods.CloseHandle(new HandleRef(this, fileMappingHandle));
                    
                if (FileViewAddress != (IntPtr)0) 
                    UnsafeNativeMethods.UnmapViewOfFile(new HandleRef(this, FileViewAddress));
                                    
                                                                                    
                FileViewAddress = (IntPtr)0;        
                fileMappingHandle = (IntPtr)0;               
            }            

            private unsafe void Initialize(int fileMappingSize) {               
                string mappingName = null;     
                SharedUtils.CheckEnvironment();           
                if (SharedUtils.CurrentEnvironment == SharedUtils.W2kEnvironment)
                    mappingName = "Global\\" +  FileMappingName; 
                else
                    mappingName = FileMappingName;                                                       

                IntPtr securityDescriptorPointer = IntPtr.Zero;
                try {
                    // The sddl string consists of these parts:
                    // D:           it's a DACL
                    // (A;;         this is an allow ACE
                    // FRFWGRGW;;;  allow file read, file write, generic read and generic write
                    // WD)          granted to Everyone
                    string sddlString = "D:(A;OICI;FRFWGRGW;;;WD)";
                    if (!UnsafeNativeMethods.ConvertStringSecurityDescriptorToSecurityDescriptor(sddlString, NativeMethods.SDDL_REVISION_1, 
                                                                                                    out securityDescriptorPointer, IntPtr.Zero))
                        throw new InvalidOperationException(SR.GetString(SR.SetSecurityDescriptorFailed));

                    NativeMethods.SECURITY_ATTRIBUTES securityAttributes = new NativeMethods.SECURITY_ATTRIBUTES();
                    securityAttributes.lpSecurityDescriptor = securityDescriptorPointer;
                    securityAttributes.bInheritHandle = false;

                    
                    fileMappingHandle = UnsafeNativeMethods.CreateFileMapping(new HandleRef(null, (IntPtr)(-1)), securityAttributes, NativeMethods.PAGE_READWRITE,
                                                                                                                0, fileMappingSize, mappingName);
                    int error = Marshal.GetLastWin32Error();
                    if (fileMappingHandle == (IntPtr)0 &&
                        (error == NativeMethods.ERROR_ALREADY_EXISTS || error == NativeMethods.ERROR_ACCESS_DENIED)) 
                        fileMappingHandle = UnsafeNativeMethods.OpenFileMapping(NativeMethods.FILE_MAP_WRITE, false, mappingName);
                                                                   
                }    
                finally {
                    SafeNativeMethods.LocalFree(securityDescriptorPointer);
                }
                                                                                                    
                if (fileMappingHandle == (IntPtr)0) 
                    throw new InvalidOperationException(SR.GetString(SR.CantCreateFileMapping));
                
                                
                FileViewAddress = UnsafeNativeMethods.MapViewOfFile(new HandleRef(this, fileMappingHandle), NativeMethods.FILE_MAP_WRITE, 0,0,0); 
                if (FileViewAddress == (IntPtr)0)                    
                    throw new InvalidOperationException(SR.GetString(SR.CantMapFileView));
                                                                                                                
                FileMappingSize = fileMappingSize;
                SafeNativeMethods.InterlockedCompareExchange(FileViewAddress, 4, 0);                   
                AppDomain.CurrentDomain.DomainUnload += new EventHandler(this.OnAppDomainUnload);                         
            }

            private void OnAppDomainUnload(object sender, EventArgs args) {                 
                this.IsGhosted = true;
                this.Close();
            }                                                                                                                                                                                                           
        }                              
                        
        private struct CategoryEntry {           
            public int SpinLock;
            public int CategoryNameHashCode;            
            public int CategoryNameOffset;
            public int FirstInstanceOffset;    
            public int NextCategoryOffset;            
        }                
                                          
        private struct InstanceEntry {        
            public int SpinLock;
            public int InstanceNameHashCode;
            public int InstanceNameOffset;                                    
            public int RefCount;            
            public int FirstCounterOffset;
            public int NextInstanceOffset;
        }        
                                                                                           
        private struct CounterEntry {            
            public int SpinLock;
            public int CounterNameHashCode;
            public int CounterNameOffset;
            public long Value;            
            public int NextCounterOffset;            
        }                
    }     
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\services\monitoring\system\diagnosticts\threadprioritylevel.cs ===
//------------------------------------------------------------------------------
// <copyright file="ThreadPriorityLevel.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Diagnostics {
    using System.Threading;

    using System.Diagnostics;
    /// <include file='doc\ThreadPriorityLevel.uex' path='docs/doc[@for="ThreadPriorityLevel"]/*' />
    /// <devdoc>
    ///     Specifies the priority level of a thread.  The priority level is not an absolute 
    ///     level, but instead contributes to the actual thread priority by considering the 
    ///     priority class of the process.
    /// </devdoc>
    public enum ThreadPriorityLevel {
    
        /// <include file='doc\ThreadPriorityLevel.uex' path='docs/doc[@for="ThreadPriorityLevel.Idle"]/*' />
        /// <devdoc>
        ///     Idle priority
        /// </devdoc>
        Idle = -15,
        
        /// <include file='doc\ThreadPriorityLevel.uex' path='docs/doc[@for="ThreadPriorityLevel.Lowest"]/*' />
        /// <devdoc>
        ///     Lowest priority
        /// </devdoc>
        Lowest = -2,
        
        /// <include file='doc\ThreadPriorityLevel.uex' path='docs/doc[@for="ThreadPriorityLevel.BelowNormal"]/*' />
        /// <devdoc>
        ///     Below normal priority
        /// </devdoc>
        BelowNormal = -1,
        
        /// <include file='doc\ThreadPriorityLevel.uex' path='docs/doc[@for="ThreadPriorityLevel.Normal"]/*' />
        /// <devdoc>
        ///     Normal priority
        /// </devdoc>
        Normal = 0,
        
        /// <include file='doc\ThreadPriorityLevel.uex' path='docs/doc[@for="ThreadPriorityLevel.AboveNormal"]/*' />
        /// <devdoc>
        ///     Above normal priority
        /// </devdoc>
        AboveNormal = 1,
        
        /// <include file='doc\ThreadPriorityLevel.uex' path='docs/doc[@for="ThreadPriorityLevel.Highest"]/*' />
        /// <devdoc>
        ///     Highest priority
        /// </devdoc>
        Highest = 2,
        
        /// <include file='doc\ThreadPriorityLevel.uex' path='docs/doc[@for="ThreadPriorityLevel.TimeCritical"]/*' />
        /// <devdoc>
        ///     Time critical priority
        /// </devdoc>
        TimeCritical = 15
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\services\monitoring\system\diagnosticts\threadwaitreason.cs ===
//------------------------------------------------------------------------------
// <copyright file="ThreadWaitReason.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Diagnostics {
    using System.Threading;

    using System.Diagnostics;
    /// <include file='doc\ThreadWaitReason.uex' path='docs/doc[@for="ThreadWaitReason"]/*' />
    /// <devdoc>
    ///     Specifies the reason a thread is waiting.
    /// </devdoc>
    public enum ThreadWaitReason {
    
        /// <include file='doc\ThreadWaitReason.uex' path='docs/doc[@for="ThreadWaitReason.Executive"]/*' />
        /// <devdoc>
        ///     Thread is waiting for the scheduler.
        /// </devdoc>
        Executive,
        
        /// <include file='doc\ThreadWaitReason.uex' path='docs/doc[@for="ThreadWaitReason.FreePage"]/*' />
        /// <devdoc>
        ///     Thread is waiting for a free virtual memory page.
        /// </devdoc>
        FreePage,
        
        /// <include file='doc\ThreadWaitReason.uex' path='docs/doc[@for="ThreadWaitReason.PageIn"]/*' />
        /// <devdoc>
        ///     Thread is waiting for a virtual memory page to arrive in memory.
        /// </devdoc>
        PageIn,
        
        /// <include file='doc\ThreadWaitReason.uex' path='docs/doc[@for="ThreadWaitReason.SystemAllocation"]/*' />
        /// <devdoc>
        ///     Thread is waiting for a system allocation.
        /// </devdoc>
        SystemAllocation,
        
        /// <include file='doc\ThreadWaitReason.uex' path='docs/doc[@for="ThreadWaitReason.ExecutionDelay"]/*' />
        /// <devdoc>
        ///     Thread execution is delayed.
        /// </devdoc>
        ExecutionDelay,

        /// <include file='doc\ThreadWaitReason.uex' path='docs/doc[@for="ThreadWaitReason.Suspended"]/*' />
        /// <devdoc>
        ///     Thread execution is suspended.
        /// </devdoc>
        Suspended,

        /// <include file='doc\ThreadWaitReason.uex' path='docs/doc[@for="ThreadWaitReason.UserRequest"]/*' />
        /// <devdoc>
        ///     Thread is waiting for a user request.
        /// </devdoc>
        UserRequest,

        /// <include file='doc\ThreadWaitReason.uex' path='docs/doc[@for="ThreadWaitReason.EventPairHigh"]/*' />
        /// <devdoc>
        ///     Thread is waiting for event pair high.
        /// </devdoc>
        EventPairHigh,
        
        /// <include file='doc\ThreadWaitReason.uex' path='docs/doc[@for="ThreadWaitReason.EventPairLow"]/*' />
        /// <devdoc>
        ///     Thread is waiting for event pair low.
        /// </devdoc>
        EventPairLow,
        
        /// <include file='doc\ThreadWaitReason.uex' path='docs/doc[@for="ThreadWaitReason.LpcReceive"]/*' />
        /// <devdoc>
        ///     Thread is waiting for a local procedure call to arrive.
        /// </devdoc>
        LpcReceive,
        
        /// <include file='doc\ThreadWaitReason.uex' path='docs/doc[@for="ThreadWaitReason.LpcReply"]/*' />
        /// <devdoc>
        ///     Thread is waiting for reply to a local procedure call to arrive.
        /// </devdoc>
        LpcReply,
        
        /// <include file='doc\ThreadWaitReason.uex' path='docs/doc[@for="ThreadWaitReason.VirtualMemory"]/*' />
        /// <devdoc>
        ///     Thread is waiting for virtual memory.
        /// </devdoc>
        VirtualMemory,
        
        /// <include file='doc\ThreadWaitReason.uex' path='docs/doc[@for="ThreadWaitReason.PageOut"]/*' />
        /// <devdoc>
        ///     Thread is waiting for a virtual memory page to be written to disk.
        /// </devdoc>
        PageOut,
        
        /// <include file='doc\ThreadWaitReason.uex' path='docs/doc[@for="ThreadWaitReason.Unknown"]/*' />
        /// <devdoc>
        ///     Thread is waiting for an unknown reason.
        /// </devdoc>
        Unknown
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\services\monitoring\system\diagnosticts\threadstate.cs ===
//------------------------------------------------------------------------------
// <copyright file="ThreadState.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Diagnostics {
    using System.Threading;

    using System.Diagnostics;
   
    /// <include file='doc\ThreadState.uex' path='docs/doc[@for="ThreadState"]/*' />
    /// <devdoc>
    ///     Specifies the execution state of a thread.
    /// </devdoc>
    public enum ThreadState {
        /// <include file='doc\ThreadState.uex' path='docs/doc[@for="ThreadState.Initialized"]/*' />
        /// <devdoc>
        ///     The thread has been initialized, but has not started yet.
        /// </devdoc>
        Initialized,
        
        /// <include file='doc\ThreadState.uex' path='docs/doc[@for="ThreadState.Ready"]/*' />
        /// <devdoc>
        ///     The thread is in ready state.
        /// </devdoc>
        Ready,
        
        /// <include file='doc\ThreadState.uex' path='docs/doc[@for="ThreadState.Running"]/*' />
        /// <devdoc>
        ///     The thread is running.
        /// </devdoc>
        Running,
        
        /// <include file='doc\ThreadState.uex' path='docs/doc[@for="ThreadState.Standby"]/*' />
        /// <devdoc>
        ///     The thread is in standby state.
        /// </devdoc>
        Standby,
        
        /// <include file='doc\ThreadState.uex' path='docs/doc[@for="ThreadState.Terminated"]/*' />
        /// <devdoc>
        ///     The thread has exited.
        /// </devdoc>
        Terminated,
        
        /// <include file='doc\ThreadState.uex' path='docs/doc[@for="ThreadState.Wait"]/*' />
        /// <devdoc>
        ///     The thread is waiting.
        /// </devdoc>
        Wait,
        
        /// <include file='doc\ThreadState.uex' path='docs/doc[@for="ThreadState.Transition"]/*' />
        /// <devdoc>
        ///     The thread is transitioning between states.
        /// </devdoc>
        Transition,
        
        /// <include file='doc\ThreadState.uex' path='docs/doc[@for="ThreadState.Unknown"]/*' />
        /// <devdoc>
        ///     The thread state is unknown.
        /// </devdoc>
        Unknown
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\services\monitoring\system\diagnosticts\design\categoryvalueconverter.cs ===
//------------------------------------------------------------------------------
// <copyright file="CategoryValueConverter.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Diagnostics.Design {
    using System.Runtime.Serialization.Formatters;
    using System.Globalization;
    using System.Diagnostics;
    using System;
    using System.Windows.Forms.ComponentModel;
    using System.ComponentModel;
    using System.ComponentModel.Design;
    using System.Collections;
    
    internal class CategoryValueConverter : TypeConverter {
        /// <include file='doc\CategoryValueConverter.uex' path='docs/doc[@for="CategoryValueConverter.values"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Provides a <see cref='System.ComponentModel.TypeConverter.StandardValuesCollection'/> that specifies the
        ///       possible values for the enumeration.
        ///    </para>
        /// </devdoc>
        private StandardValuesCollection values;
        private string previousMachineName;
        
        /// <include file='doc\CategoryValueConverter.uex' path='docs/doc[@for="CategoryValueConverter.CategoryValueConverter"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Initializes a new instance of the 'CategoryValueConverter' class for the given type.
        ///    </para>
        /// </devdoc>
        public CategoryValueConverter() {
        }
        
        public override bool CanConvertFrom(ITypeDescriptorContext context, Type sourceType) {
            if (sourceType == typeof(string)) {
                return true;
            }
            return base.CanConvertFrom(context, sourceType);
        }
        
        public override object ConvertFrom(ITypeDescriptorContext context, CultureInfo culture, object value) {
            if (value is string) {
                string text = ((string)value).Trim();
                return text;
            }
            return base.ConvertFrom(context, culture, value);
        }
        
        
        /// <include file='doc\CategoryValueConverter.uex' path='docs/doc[@for="CategoryValueConverter.GetStandardValues"]/*' />
        /// <internalonly/>
        /// <devdoc>
        ///    <para>Gets a collection of standard values for the data type this validator is
        ///       designed for.</para>
        /// </devdoc>
        public override StandardValuesCollection GetStandardValues(ITypeDescriptorContext context) {                        
            PerformanceCounter counter = (context == null) ? null : context.Instance as PerformanceCounter;
            string machineName = ".";
            if (counter != null) {
                machineName = counter.MachineName;
            }

            if (machineName == previousMachineName)
                return values;
            else
                previousMachineName = machineName;                    
            
            try {
                PerformanceCounter.CloseSharedResources();
                PerformanceCounterCategory[] cats = PerformanceCounterCategory.GetCategories(machineName);
    
                string[] retVal = new string[cats.Length];
    
                for (int i = 0; i < cats.Length; i++) {
                    retVal[i] = cats[i].CategoryName;
                }
    
                Array.Sort(retVal, Comparer.Default);
                values = new StandardValuesCollection(retVal);
            }
            catch (Exception) {
                values = null; 
            }                    
            
            return values;
        }
    
        /// <include file='doc\CategoryValueConverter.uex' path='docs/doc[@for="CategoryValueConverter.GetStandardValuesSupported"]/*' />
        /// <internalonly/>
        /// <devdoc>
        ///    <para>Gets a value indicating
        ///       whether this object
        ///       supports a standard set of values that can be picked
        ///       from a list using the specified context.</para>
        /// </devdoc>
        public override bool GetStandardValuesSupported(ITypeDescriptorContext context) {
            return true;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\services\monitoring\system\diagnosticts\design\countercreationdataconverter.cs ===
//------------------------------------------------------------------------------
// <copyright file="CounterCreationDataConverter.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Diagnostics.Design {
    using System.Runtime.Serialization.Formatters;

    using System.Diagnostics;
    using System;
    using System.ComponentModel;
    using System.ComponentModel.Design.Serialization;
    using System.Globalization;
    using System.Reflection;

    internal class CounterCreationDataConverter : ExpandableObjectConverter {

        /// <include file='doc\CounterCreationDataConverter.uex' path='docs/doc[@for="CounterCreationDataConverter.CanConvertTo"]/*' />
        /// <devdoc>
        ///    <para>Gets a value indicating whether this converter can
        ///       convert an object to the given destination type using the context.</para>
        /// </devdoc>
        public override bool CanConvertTo(ITypeDescriptorContext context, Type destinationType) {
            if (destinationType == typeof(InstanceDescriptor)) {
                return true;
            }
            return base.CanConvertTo(context, destinationType);
        }

        /// <include file='doc\CounterCreationDataConverter.uex' path='docs/doc[@for="CounterCreationDataConverter.ConvertTo"]/*' />
        /// <devdoc>
        ///      Converts the given object to another type.  The most common types to convert
        ///      are to and from a string object.  The default implementation will make a call
        ///      to ToString on the object if the object is valid and if the destination
        ///      type is string.  If this cannot convert to the desitnation type, this will
        ///      throw a NotSupportedException.
        /// </devdoc>
        public override object ConvertTo(ITypeDescriptorContext context, CultureInfo culture, object value, Type destinationType) {
            if (destinationType == null) {
                throw new ArgumentNullException("destinationType");
            }

            if (destinationType == typeof(InstanceDescriptor) && value is CounterCreationData) {
                CounterCreationData data = (CounterCreationData)value;
                ConstructorInfo ctor = typeof(CounterCreationData).GetConstructor(new Type[] {
                    typeof(string), typeof(string), typeof(PerformanceCounterType)});
                if (ctor != null) {
                    return new InstanceDescriptor(ctor, new object[] {
                        data.CounterName, data.CounterHelp, data.CounterType});
                }
            }
            
            return base.ConvertTo(context, culture, value, destinationType);
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\services\monitoring\system\diagnosticts\design\counternameconverter.cs ===
//------------------------------------------------------------------------------
// <copyright file="CounterNameConverter.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Diagnostics.Design {
    using System.Runtime.Serialization.Formatters;
    using System.Globalization;
    using System.Diagnostics;
    using System;
    using System.Windows.Forms.ComponentModel;
    using System.ComponentModel;
    using System.ComponentModel.Design;
    using System.Collections;
    
    internal class CounterNameConverter : TypeConverter {
        
        /// <include file='doc\CounterNameConverter.uex' path='docs/doc[@for="CounterNameConverter.CounterNameConverter"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Initializes a new instance of the 'CounterNameConverter' class for the given type.
        ///    </para>
        /// </devdoc>
        public CounterNameConverter() {
        }

        public override bool CanConvertFrom(ITypeDescriptorContext context, Type sourceType) {
            if (sourceType == typeof(string)) {
                return true;
            }
            return base.CanConvertFrom(context, sourceType);
        }
        
        public override object ConvertFrom(ITypeDescriptorContext context, CultureInfo culture, object value) {
            if (value is string) {
                string text = ((string)value).Trim();
                return text;
            }
            return base.ConvertFrom(context, culture, value);
        }                 
         
        /// <include file='doc\CounterNameConverter.uex' path='docs/doc[@for="CounterNameConverter.GetStandardValues"]/*' />
        /// <internalonly/>
        /// <devdoc>
        ///    <para>Gets a collection of standard values for the data type this validator is
        ///       designed for.</para>
        /// </devdoc>
        public override StandardValuesCollection GetStandardValues(ITypeDescriptorContext context) {        
            PerformanceCounter counter = (context == null) ? null : context.Instance as PerformanceCounter;

            string machineName = ".";
            string categoryName = String.Empty;
            if (counter != null) {
                machineName = counter.MachineName;
                categoryName = counter.CategoryName;
            }

            try {
                PerformanceCounterCategory cat = new PerformanceCounterCategory(categoryName, machineName);
                string[] instanceNames = cat.GetInstanceNames();
                PerformanceCounter[] counters = null;
                if (instanceNames.Length == 0)
                    counters = cat.GetCounters();
                else
                    counters = cat.GetCounters(instanceNames[0]);                                            

                string[] retVal = new string[counters.Length];

                for (int i = 0; i < counters.Length; i++) {
                    retVal[i] = counters[i].CounterName;
                }

                Array.Sort(retVal, Comparer.Default);
                return new StandardValuesCollection(retVal);
            }
            catch (Exception) {
                ; // do nothing
            }
            
            return null;
        }

        /// <include file='doc\CounterNameConverter.uex' path='docs/doc[@for="CounterNameConverter.GetStandardValuesSupported"]/*' />
        /// <internalonly/>
        /// <devdoc>
        ///    <para>Gets a value indicating
        ///       whether this object
        ///       supports a standard set of values that can be picked
        ///       from a list using the specified context.</para>
        /// </devdoc>
        public override bool GetStandardValuesSupported(ITypeDescriptorContext context) {
            return true;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\services\monitoring\system\diagnosticts\sharedutils.cs ===
//------------------------------------------------------------------------------
// <copyright file="SharedUtils.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Diagnostics {
    using System.Security.Permissions;
    using System.Security;    
    using System.Threading;
    using System.Text;
    using Microsoft.Win32;
    using System.Globalization;
    
    internal class SharedUtils {
        
        internal static readonly int UnknownEnvironment = 0;
        internal static readonly int W2kEnvironment = 1;
        internal static readonly int NtEnvironment = 2;
        internal static readonly int NonNtEnvironment = 3;        
        private static int environment = UnknownEnvironment;                

        internal static int CurrentEnvironment {
            get {
                if (environment == UnknownEnvironment) { 
                    lock (typeof(SharedUtils)) {
                        if (environment == UnknownEnvironment) {
                            //SECREVIEW: jruiz- need to assert Environment permissions here
                            //                        the environment check is not exposed as a public 
                            //                        method                        
                            EnvironmentPermission environmentPermission = new EnvironmentPermission(PermissionState.Unrestricted);                        
                            environmentPermission.Assert();                        
                            try {
                                if (Environment.OSVersion.Platform == PlatformID.Win32NT)  {
                                    if (Environment.OSVersion.Version.Major >= 5)
                                        environment = W2kEnvironment; 
                                    else
                                        environment = NtEnvironment; 
                                }                                
                                else                    
                                    environment = NonNtEnvironment;
                            }
                            finally {  
                                 EnvironmentPermission.RevertAssert();                             
                            }                                                    
                        }                
                    }
                }
            
                return environment;                        
            }                
        }               
                        
        internal static void CheckEnvironment() {            
            if (CurrentEnvironment == NonNtEnvironment)
                throw new PlatformNotSupportedException(SR.GetString(SR.WinNTRequired));
        }

        internal static void CheckNtEnvironment() {            
            if (CurrentEnvironment == NtEnvironment)
                throw new PlatformNotSupportedException(SR.GetString(SR.Win2000Required));
        }
        
        internal static Mutex EnterMutex(string name) {
            string mutexName = null;            
            if (CurrentEnvironment == W2kEnvironment)
                mutexName = "Global\\" +  name; 
            else
                mutexName = name;                                                 
                
            Mutex mutex = new Mutex(false, mutexName); 
            mutex.WaitOne();
            return mutex;
        }
        
        internal static string GetLatestBuildDllDirectory(string machineName) {            
            string dllDir = "";
            RegistryKey baseKey = null;
            RegistryKey complusReg = null;
            
            //SECREVIEW: This property is retrieved only when creationg a new category,
            //                          the calling code already demanded PerformanceCounterPermission.
            //                          Therefore the assert below is safe.
                                                
            //SECREVIEW: This property is retrieved only when creationg a new log,
            //                          the calling code already demanded EventLogPermission.
            //                          Therefore the assert below is safe.

            RegistryPermission registryPermission = new RegistryPermission(PermissionState.Unrestricted);
            registryPermission.Assert();

            try {
                if (machineName.Equals(".")) {
                    baseKey = Registry.LocalMachine;
                }
                else {
                    baseKey = RegistryKey.OpenRemoteBaseKey(RegistryHive.LocalMachine, machineName);
                }
                if (baseKey == null)
                    throw new InvalidOperationException(SR.GetString(SR.RegKeyMissingShort, "HKEY_LOCAL_MACHINE", machineName));

                complusReg = baseKey.OpenSubKey("SOFTWARE\\Microsoft\\.NETFramework"); 
                if (complusReg != null) {
                    string installRoot = (string)complusReg.GetValue("InstallRoot");
                    if (installRoot != null && installRoot != String.Empty) {                        
                        // the "policy" subkey contains a v{major}.{minor} subkey for each version installed
                        // first we figure out what version we are...
                        string majorVersionString = null;
                        Version ver = Environment.Version;
                        majorVersionString = "v" + ver.ToString(2);
                        RegistryKey v1Key = complusReg.OpenSubKey("policy\\" + majorVersionString);
                        string version = null;                            
                        if (v1Key != null) {
                            try {
                                version = (string)v1Key.GetValue("Version");
                                if (version == null) {
                                    string[] buildNumbers = v1Key.GetValueNames();
                                    for (int i = 0; i < buildNumbers.Length; i++) {
                                        // the key will look something like "0-2813", here we change it like "v1.0.2813"
                                        string newVersion = majorVersionString + "." + buildNumbers[i].Replace('-', '.');

                                        // this comparison is correct even the first time, when
                                        // version is null, because any string is "greater" then null
                                        if (string.Compare(newVersion, version, false, CultureInfo.InvariantCulture) > 0) {
                                            version = newVersion;
                                        }
                                    }
                                }                                                                            
                            }
                            finally {
                                v1Key.Close();
                            }
                        
                            if (version != null && version != String.Empty) {
                                StringBuilder installBuilder = new StringBuilder();
                                installBuilder.Append(installRoot);                                        
                                if (!installRoot.EndsWith("\\"))
                                    installBuilder.Append("\\");                                        
                                installBuilder.Append(version);
                                installBuilder.Append("\\");
                                dllDir = installBuilder.ToString();        
                            }                                                    
                        }                                 
                    }
                }
            }
            catch(Exception) {
                // ignore
            }
            finally {
                if (complusReg != null)
                    complusReg.Close();

                if (baseKey != null)
                    baseKey.Close();

                RegistryPermission.RevertAssert();                             
            }

            return dllDir;
        }                
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\services\monitoring\system\diagnosticts\design\instancenameconverter.cs ===
//------------------------------------------------------------------------------
// <copyright file="InstanceNameConverter.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Diagnostics.Design {
    using System.Runtime.Serialization.Formatters;
    using System.Globalization;
    using System.Diagnostics;
    using System;
    using System.Windows.Forms.ComponentModel;
    using System.ComponentModel;
    using System.ComponentModel.Design;
    using System.Collections;
    
    internal class InstanceNameConverter : TypeConverter {        
        
        /// <include file='doc\InstanceNameConverter.uex' path='docs/doc[@for="InstanceNameConverter.InstanceNameConverter"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Initializes a new instance of the 'InstanceNameConverter' class for the given type.
        ///    </para>
        /// </devdoc>
        public InstanceNameConverter() {
        }
        
        public override bool CanConvertFrom(ITypeDescriptorContext context, Type sourceType) {
            if (sourceType == typeof(string)) {
                return true;
            }
            return base.CanConvertFrom(context, sourceType);
        }
        
        public override object ConvertFrom(ITypeDescriptorContext context, CultureInfo culture, object value) {
            if (value is string) {
                string text = ((string)value).Trim();
                return text;
            }
            return base.ConvertFrom(context, culture, value);
        }
        
        
        /// <include file='doc\InstanceNameConverter.uex' path='docs/doc[@for="InstanceNameConverter.GetStandardValues"]/*' />
        /// <internalonly/>
        /// <devdoc>
        ///    <para>Gets a collection of standard values for the data type this validator is
        ///       designed for.</para>
        /// </devdoc>
        public override StandardValuesCollection GetStandardValues(ITypeDescriptorContext context) {            
            PerformanceCounter counter = (context == null) ? null : context.Instance as PerformanceCounter;
            string machineName = ".";
            string categoryName = String.Empty;
            if (counter != null) {
                machineName = counter.MachineName;
                categoryName = counter.CategoryName;
            }

            try {
                PerformanceCounterCategory cat = new PerformanceCounterCategory(categoryName, machineName);
                string[] retVal =cat.GetInstanceNames();
                Array.Sort(retVal, Comparer.Default);
                return new StandardValuesCollection(retVal);
            }
            catch(Exception) {
                ; // do nothing
            }                                                    
        
            return null;
        }
    
        /// <include file='doc\InstanceNameConverter.uex' path='docs/doc[@for="InstanceNameConverter.GetStandardValuesSupported"]/*' />
        /// <internalonly/>
        /// <devdoc>
        ///    <para>Gets a value indicating
        ///       whether this object
        ///       supports a standard set of values that can be picked
        ///       from a list using the specified context.</para>
        /// </devdoc>
        public override bool GetStandardValuesSupported(ITypeDescriptorContext context) {
            return true;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\services\monitoring\system\diagnosticts\design\stringdictionaryeditor.cs ===
//------------------------------------------------------------------------------
// <copyright file="StringDictionaryEditor.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>
//------------------------------------------------------------------------------


/**************************************************************************\
*
* Copyright (c) 1998-2002, Microsoft Corp.  All Rights Reserved.
*
* Module Name:
*
*   StringDictionaryEditor.cs
*
* Abstract:
*
* Revision History:
*
\**************************************************************************/

namespace System.Diagnostics.Design {
    
    using System.Runtime.InteropServices;

    using System.Diagnostics;
    using System;
    using System.IO;
    using System.Collections;
    using System.ComponentModel;
    using System.ComponentModel.Design;
    using System.Windows.Forms;
    using System.Drawing;
    using System.Drawing.Design;
    using System.Windows.Forms.ComponentModel;
    using System.Windows.Forms.Design;
    using System.Collections.Specialized;
    using System.Design;
    
    internal class EditableDictionaryEntry {
        public string _name;
        public string _value;

        public EditableDictionaryEntry(string name, string value) {
            _name = name;
            _value = value;
        }

        public string Name { 
            get { return _name; }
            set { _name = value; }
        }

        public string Value { 
            get { return _value; }
            set { _value = value; }
        }
    }
    
    internal class StringDictionaryEditor : CollectionEditor {
    
        public StringDictionaryEditor(Type type) : base(type) {}

        protected override Type CreateCollectionItemType() {
            return typeof(EditableDictionaryEntry);
        }

        protected override object CreateInstance(Type itemType) {
            return new EditableDictionaryEntry("name", "value");
        }

        protected override object SetItems(object editValue, object[] value) {
            StringDictionary dictionary = editValue as StringDictionary;

            if (dictionary == null) {
                throw new ArgumentNullException("editValue");
            }

            dictionary.Clear();

            foreach (EditableDictionaryEntry entry in value) {
                dictionary[entry.Name] = entry.Value;
            }

            return dictionary;
        }

        protected override object[] GetItems(object editValue) {
            if (editValue != null) {    
                
                StringDictionary dictionary = editValue as StringDictionary;
    
                if (dictionary == null) {
                    throw new ArgumentNullException("editValue");
                }
    
                object[] ret = new object[dictionary.Count];
                int pos = 0;
                foreach (DictionaryEntry entry in dictionary) {
                    EditableDictionaryEntry newEntry = new EditableDictionaryEntry((string)entry.Key, (string)entry.Value);
                    ret[pos++] = newEntry;
                }
                return ret;
            }

            return new object[0];
        }

        protected override CollectionForm CreateCollectionForm() {
            CollectionForm form = base.CreateCollectionForm();
            form.Text = SR.GetString(SR.StringDictionaryEditorTitle);
            form.CollectionEditable = true;
            return form;
        }

    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\services\monitoring\system\diagnosticts\design\verbconverter.cs ===
//------------------------------------------------------------------------------
// <copyright file="VerbConverter.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Diagnostics.Design {
    using System.Diagnostics;
    using System;
    using System.Design;
    using System.Windows.Forms.ComponentModel;
    using System.ComponentModel;
    using System.ComponentModel.Design;
    using System.Globalization;
        
    /// <include file='doc\VerbConverter.uex' path='docs/doc[@for="VerbConverter"]/*' />
    /// <devdoc>
    ///     Editor that shows a list of verbs based on the value of the FileName property.
    /// </devdoc>
    /// <internalonly/>
    internal class VerbConverter : TypeConverter {
        private const string DefaultVerb = SR.VerbEditorDefault;

        /// <include file='doc\VerbConverter.uex' path='docs/doc[@for="VerbConverter.VerbConverter"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Initializes a new instance of the 'VerbConverter' class for the given type.
        ///    </para>
        /// </devdoc>
        public VerbConverter() {
        }

        /// <include file='doc\VerbConverter.uex' path='docs/doc[@for="VerbConverter.CanConvertFrom"]/*' />
        /// <internalonly/>
        /// <devdoc>
        /// </devdoc>
        public override bool CanConvertFrom(ITypeDescriptorContext context, Type sourceType) {
            if (sourceType == typeof(string)) {
                return true;
            }
            return base.CanConvertFrom(context, sourceType);
        }
        
        /// <include file='doc\VerbConverter.uex' path='docs/doc[@for="VerbConverter.ConvertFrom"]/*' />
        /// <internalonly/>
        /// <devdoc>
        /// </devdoc>
        public override object ConvertFrom(ITypeDescriptorContext context, CultureInfo culture, object value) {
            if (value is string) {
                string text = ((string)value).Trim();
                return text;
            }
            return base.ConvertFrom(context, culture, value);
        }


        /// <include file='doc\VerbConverter.uex' path='docs/doc[@for="VerbConverter.GetStandardValues"]/*' />
        /// <internalonly/>
        /// <devdoc>
        ///    <para>Gets a collection of standard values for the data type this validator is
        ///       designed for.</para>
        /// </devdoc>
        public override StandardValuesCollection GetStandardValues(ITypeDescriptorContext context) {
            ProcessStartInfo info = (context == null) ? null : context.Instance as ProcessStartInfo;
            StandardValuesCollection values;
            if (info != null)
                values = new StandardValuesCollection(info.Verbs);
            else
                values = null;

            return values;
        }

        /// <include file='doc\VerbConverter.uex' path='docs/doc[@for="VerbConverter.GetStandardValuesSupported"]/*' />
        /// <internalonly/>
        /// <devdoc>
        ///    <para>Gets a value indicating
        ///       whether this object
        ///       supports a standard set of values that can be picked
        ///       from a list using the specified context.</para>
        /// </devdoc>
        public override bool GetStandardValuesSupported(ITypeDescriptorContext context) {
            return true;
        }
        
        public override bool GetStandardValuesExclusive(ITypeDescriptorContext context) {
            return false;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\services\servproc\system\serviceprocess\nativemethods.cs ===
//------------------------------------------------------------------------------
// <copyright file="NativeMethods.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.ServiceProcess {    
    using System;
    using System.Text;
    using System.Security;
    using System.Security.Permissions;
    using System.Runtime.InteropServices;
    
    internal class NativeMethods {
    
        public const int WM_POWERBROADCAST = 0x0218;
        public const int NO_ERROR = 0;
        public const int BROADCAST_QUERY_DENY = 0x424D5144;
        public const int PBT_APMBATTERYLOW = 0x0009;
        public const int PBT_APMOEMEVENT = 0x000B;
        public const int PBT_APMPOWERSTATUSCHANGE = 0x000A;
        public const int PBT_APMQUERYSUSPEND = 0x0000;
        public const int PBT_APMQUERYSUSPENDFAILED = 0x0002;
        public const int PBT_APMRESUMEAUTOMATIC = 0x0012;                                                               
        public const int PBT_APMRESUMECRITICAL = 0x0006;
        public const int PBT_APMRESUMESUSPEND = 0x0007;
        public const int PBT_APMSUSPEND = 0x0004;
                                                                       
        public const int ERROR_MORE_DATA = 234;
        public const int ERROR_INSUFFICIENT_BUFFER = 122;
        public const int MB_OK = 0x00000000;
        public const int MB_OKCANCEL = 0x00000001;
        public const int MB_ABORTRETRYIGNORE = 0x00000002;
        public const int MB_YESNOCANCEL = 0x00000003;
        public const int MB_YESNO = 0x00000004;
        public const int MB_RETRYCANCEL = 0x00000005;
        public const int MB_ICONHAND = 0x00000010;
        public const int MB_ICONQUESTION = 0x00000020;
        public const int MB_ICONEXCLAMATION = 0x00000030;
        public const int MB_ICONASTERISK = 0x00000040;
        public const int MB_USERICON = 0x00000080;
        public const int MB_ICONWARNING = 0x00000030;
        public const int MB_ICONERROR = 0x00000010;
        public const int MB_ICONINFORMATION = 0x00000040;
        public const int MB_DEFBUTTON1 = 0x00000000;
        public const int MB_DEFBUTTON2 = 0x00000100;
        public const int MB_DEFBUTTON3 = 0x00000200;
        public const int MB_DEFBUTTON4 = 0x00000300;
        public const int MB_APPLMODAL = 0x00000000;
        public const int MB_SYSTEMMODAL = 0x00001000;
        public const int MB_TASKMODAL = 0x00002000;
        public const int MB_HELP = 0x00004000;
        public const int MB_NOFOCUS = 0x00008000;
        public const int MB_SETFOREGROUND = 0x00010000;
        public const int MB_DEFAULT_DESKTOP_ONLY = 0x00020000;
        public const int MB_TOPMOST = 0x00040000;
        public const int MB_RIGHT = 0x00080000;
        public const int MB_RTLREADING = 0x00100000;
        public const int MB_SERVICE_NOTIFICATION = 0x00200000;
        // MB_SERVICE_NOTIFICATION = 0x00040000;
        public const int MB_SERVICE_NOTIFICATION_NT3X = 0x00040000;
        public const int MB_TYPEMASK = 0x0000000F;
        public const int MB_ICONMASK = 0x000000F0;
        public const int MB_DEFMASK = 0x00000F00;
        public const int MB_MODEMASK = 0x00003000;
        public const int MB_MISCMASK = 0x0000C000;
                                                
        public const int STANDARD_RIGHTS_DELETE = (0x00010000);
        public const int STANDARD_RIGHTS_REQUIRED = 0x000F0000;
        public const int SERVICE_NO_CHANGE = unchecked((int)0xffffffff);

        public const int ACCESS_TYPE_CHANGE_CONFIG = 0x0002;
        public const int ACCESS_TYPE_ENUMERATE_DEPENDENTS = 0x0008;
        public const int ACCESS_TYPE_INTERROGATE = 0x0080;
        public const int ACCESS_TYPE_PAUSE_CONTINUE = 0x0040;
        public const int ACCESS_TYPE_QUERY_CONFIG = 0x0001;
        public const int ACCESS_TYPE_QUERY_STATUS = 0x0004;
        public const int ACCESS_TYPE_START = 0x0010;
        public const int ACCESS_TYPE_STOP = 0x0020;
        public const int ACCESS_TYPE_USER_DEFINED_CONTROL = 0x0100;
        public const int ACCESS_TYPE_ALL = STANDARD_RIGHTS_REQUIRED |
                                                  ACCESS_TYPE_QUERY_CONFIG |
                                                  ACCESS_TYPE_CHANGE_CONFIG |
                                                  ACCESS_TYPE_QUERY_STATUS |
                                                  ACCESS_TYPE_ENUMERATE_DEPENDENTS |
                                                  ACCESS_TYPE_START |
                                                  ACCESS_TYPE_STOP |
                                                  ACCESS_TYPE_PAUSE_CONTINUE |
                                                  ACCESS_TYPE_INTERROGATE |
                                                  ACCESS_TYPE_USER_DEFINED_CONTROL;
        
        public const int ACCEPT_NETBINDCHANGE = 0x00000010;
        public const int ACCEPT_PAUSE_CONTINUE = 0x00000002;
        public const int ACCEPT_PARAMCHANGE = 0x00000008;
        public const int ACCEPT_POWEREVENT = 0x00000040;
        public const int ACCEPT_SHUTDOWN = 0x00000004;
        public const int ACCEPT_STOP = 0x00000001;
        
        public const int CONTROL_CONTINUE = 0x00000003;
        public const int CONTROL_INTERROGATE = 0x00000004;
        public const int CONTROL_NETBINDADD = 0x00000007;
        public const int CONTROL_NETBINDDISABLE = 0x0000000A;
        public const int CONTROL_NETBINDENABLE = 0x00000009;
        public const int CONTROL_NETBINDREMOVE = 0x00000008;
        public const int CONTROL_PARAMCHANGE = 0x00000006;
        public const int CONTROL_PAUSE = 0x00000002;
        public const int CONTROL_POWEREVENT = 0x0000000D;
        public const int CONTROL_SHUTDOWN = 0x00000005;
        public const int CONTROL_STOP = 0x00000001;

       [System.Runtime.InteropServices.ComVisible(false)]
        public enum StructFormat {
            Ansi = 1,
            Unicode = 2,
            Auto = 3,
        }
        
        public static readonly string DATABASE_ACTIVE = "ServicesActive";
        public static readonly string DATABASE_FAILED = "ServicesFailed";
        
        [StructLayout(LayoutKind.Sequential, CharSet=CharSet.Unicode)]
        public class ENUM_SERVICE_STATUS{
            public string serviceName = null;
            public string displayName = null;
            public int serviceType = 0;
            public int currentState = 0;
            public int controlsAccepted = 0;
            public int win32ExitCode = 0;
            public int serviceSpecificExitCode = 0;
            public int checkPoint = 0;
            public int waitHint = 0;
        }

        [StructLayout(LayoutKind.Sequential, CharSet=CharSet.Unicode)]
        public class ENUM_SERVICE_STATUS_PROCESS{
            public string serviceName = null;
            public string displayName = null;
            public int serviceType = 0;
            public int currentState = 0;
            public int controlsAccepted = 0;
            public int win32ExitCode = 0;
            public int serviceSpecificExitCode = 0;
            public int checkPoint = 0;
            public int waitHint = 0;
            public int processID = 0;
            public int serviceFlags = 0;
        }

        public const int ERROR_CONTROL_CRITICAL = 0x00000003;
        public const int ERROR_CONTROL_IGNORE = 0x00000000;
        public const int ERROR_CONTROL_NORMAL = 0x00000001;
        public const int ERROR_CONTROL_SEVERE = 0x00000002;                                 

        public const int SC_MANAGER_CONNECT = 0x0001;
        public const int SC_MANAGER_CREATE_SERVICE = 0x0002;
        public const int SC_MANAGER_ENUMERATE_SERVICE = 0x0004;
        public const int SC_MANAGER_LOCK = 0x0008;
        public const int SC_MANAGER_MODIFY_BOOT_CONFIG = 0x0020;
        public const int SC_MANAGER_QUERY_LOCK_STATUS = 0x0010;
        public const int SC_MANAGER_ALL   = STANDARD_RIGHTS_REQUIRED |
                                                   SC_MANAGER_CONNECT |
                                                   SC_MANAGER_CREATE_SERVICE |
                                                   SC_MANAGER_ENUMERATE_SERVICE |
                                                   SC_MANAGER_LOCK |
                                                   SC_MANAGER_QUERY_LOCK_STATUS |
                                                   SC_MANAGER_MODIFY_BOOT_CONFIG;
        public const int SC_ENUM_PROCESS_INFO = 0;

        [StructLayout(LayoutKind.Sequential)]
        public struct SERVICE_STATUS{
            public int serviceType;
            public int currentState;
            public int controlsAccepted;
            public int win32ExitCode;
            public int serviceSpecificExitCode;
            public int checkPoint;
            public int waitHint;

            /*
            public SERVICE_STATUS() {
                this.serviceType = SERVICE_TYPE_WIN32_OWN_PROCESS;
                this.currentState = STATE_START_PENDING;
                this.controlsAccepted = 0;
                this.win32ExitCode = 0;
                this.serviceSpecificExitCode = 0;
                this.checkPoint = 0;
                this.waitHint = 0;
            }
            */
        }

        [StructLayout(LayoutKind.Sequential)]
        public unsafe class QUERY_SERVICE_CONFIG {
            public int dwServiceType;
            public int dwStartType;
            public int dwErrorControl;
            public char *lpBinaryPathName;
            public char *lpLoadOrderGroup;
            public int dwTagId;
            public char *lpDependencies;
            public char *lpServiceStartName;
            public char *lpDisplayName;
        }
        
        public const int SERVICE_QUERY_CONFIG = 0x0001;
        public const int SERVICE_CHANGE_CONFIG = 0x0002;
        public const int SERVICE_QUERY_STATUS = 0x0004;
        public const int SERVICE_ENUMERATE_DEPENDENTS = 0x0008;
        public const int SERVICE_START = 0x0010;
        public const int SERVICE_STOP = 0x0020;
        public const int SERVICE_PAUSE_CONTINUE = 0x0040;
        public const int SERVICE_INTERROGATE = 0x0080;
        public const int SERVICE_USER_DEFINED_CONTROL = 0x0100;

        public const int SERVICE_ALL_ACCESS = STANDARD_RIGHTS_REQUIRED |
                                                     SERVICE_QUERY_CONFIG |
                                                     SERVICE_CHANGE_CONFIG |
                                                     SERVICE_QUERY_STATUS |
                                                     SERVICE_ENUMERATE_DEPENDENTS |
                                                     SERVICE_START |
                                                     SERVICE_STOP |
                                                     SERVICE_PAUSE_CONTINUE |
                                                     SERVICE_INTERROGATE |
                                                     SERVICE_USER_DEFINED_CONTROL;


        public const int SERVICE_TYPE_ADAPTER = 0x00000004;
        public const int SERVICE_TYPE_FILE_SYSTEM_DRIVER = 0x00000002;
        public const int SERVICE_TYPE_INTERACTIVE_PROCESS = 0x00000100;
        public const int SERVICE_TYPE_KERNEL_DRIVER = 0x00000001;
        public const int SERVICE_TYPE_RECOGNIZER_DRIVER = 0x00000008;
        public const int SERVICE_TYPE_WIN32_OWN_PROCESS = 0x00000010;
        public const int SERVICE_TYPE_WIN32_SHARE_PROCESS = 0x00000020;
        public const int SERVICE_TYPE_WIN32 = SERVICE_TYPE_WIN32_OWN_PROCESS |
                                                     SERVICE_TYPE_WIN32_SHARE_PROCESS;
        public const int SERVICE_TYPE_DRIVER = SERVICE_TYPE_KERNEL_DRIVER |
                                                      SERVICE_TYPE_FILE_SYSTEM_DRIVER |
                                                      SERVICE_TYPE_RECOGNIZER_DRIVER;
        public const int SERVICE_TYPE_ALL = SERVICE_TYPE_WIN32  |
                                                   SERVICE_TYPE_ADAPTER |
                                                   SERVICE_TYPE_DRIVER  |
                                                   SERVICE_TYPE_INTERACTIVE_PROCESS;        
       
        [StructLayout(LayoutKind.Sequential)]
        public class ENTRY{
            public IntPtr name;
            public Delegate callback;
        }
             
        public const int START_TYPE_AUTO = 0x00000002;
        public const int START_TYPE_BOOT = 0x00000000;
        public const int START_TYPE_DEMAND = 0x00000003;
        public const int START_TYPE_DISABLED = 0x00000004;
        public const int START_TYPE_SYSTEM = 0x00000001;
       
        public const int SERVICE_ACTIVE = 1;
        public const int SERVICE_INACTIVE = 2;
        public const int SERVICE_STATE_ALL = SERVICE_ACTIVE | SERVICE_INACTIVE;
       
        public const int STATE_CONTINUE_PENDING = 0x00000005;
        public const int STATE_PAUSED = 0x00000007;
        public const int STATE_PAUSE_PENDING = 0x00000006;
        public const int STATE_RUNNING = 0x00000004;
        public const int STATE_START_PENDING = 0x00000002;
        public const int STATE_STOPPED = 0x00000001;
        public const int STATE_STOP_PENDING = 0x00000003;
       
        public const int STATUS_ACTIVE = 0x00000001;
        public const int STATUS_INACTIVE = 0x00000002;
        public const int STATUS_ALL = STATUS_ACTIVE | STATUS_INACTIVE;

        public const int POLICY_VIEW_LOCAL_INFORMATION = 0x00000001;
        public const int POLICY_VIEW_AUDIT_INFORMATION = 0x00000002;
        public const int POLICY_GET_PRIVATE_INFORMATION = 0x00000004;
        public const int POLICY_TRUST_ADMIN = 0x00000008;
        public const int POLICY_CREATE_ACCOUNT = 0x00000010;
        public const int POLICY_CREATE_SECRET = 0x00000020;
        public const int POLICY_CREATE_PRIVILEGE = 0x00000040;
        public const int POLICY_SET_DEFAULT_QUOTA_LIMITS = 0x00000080;
        public const int POLICY_SET_AUDIT_REQUIREMENTS = 0x00000100;
        public const int POLICY_AUDIT_LOG_ADMIN = 0x00000200;
        public const int POLICY_SERVER_ADMIN = 0x00000400;
        public const int POLICY_LOOKUP_NAMES = 0x00000800;

        public const int POLICY_ALL_ACCESS = STANDARD_RIGHTS_REQUIRED |
                                                        POLICY_VIEW_LOCAL_INFORMATION    |
                                                        POLICY_VIEW_AUDIT_INFORMATION    |
                                                        POLICY_GET_PRIVATE_INFORMATION   |
                                                        POLICY_TRUST_ADMIN |
                                                        POLICY_CREATE_ACCOUNT |
                                                        POLICY_CREATE_SECRET |
                                                        POLICY_CREATE_PRIVILEGE |
                                                        POLICY_SET_DEFAULT_QUOTA_LIMITS |
                                                        POLICY_SET_AUDIT_REQUIREMENTS |
                                                        POLICY_AUDIT_LOG_ADMIN |
                                                        POLICY_SERVER_ADMIN;
        
        public const int STATUS_OBJECT_NAME_NOT_FOUND = -1073741772; //0xC0000034;

         [StructLayout(LayoutKind.Sequential, CharSet=CharSet.Unicode)]
         public class LSA_UNICODE_STRING {
            public short length;
            public short maximumLength;
            public string buffer;
         }
         
         [StructLayout(LayoutKind.Sequential, CharSet=CharSet.Unicode)]
         public class LSA_UNICODE_STRING_withPointer {
             public short length = 0;
             public short maximumLength = 0;
             public IntPtr pwstr = (IntPtr)0;
         }

        [StructLayout(LayoutKind.Sequential, CharSet=CharSet.Unicode)]
        public class LSA_OBJECT_ATTRIBUTES {
            public int length = 0;
            public int rootDirectory = 0;
            public int pointerLsaString = 0;
            public int attributes = 0;
            public int pointerSecurityDescriptor = 0;
            public int pointerSecurityQualityOfService = 0;
        }


        public delegate void ServiceMainCallback(int argCount, IntPtr argPointer);
        
        public delegate void ServiceControlCallback(int control);
        
        public delegate int ServiceControlCallbackEx(int control, int eventType, IntPtr eventData, IntPtr eventContext);
        
        [DllImport(ExternDll.Advapi32, CharSet=System.Runtime.InteropServices.CharSet.Unicode, SetLastError=true)]
        public extern static IntPtr OpenService(IntPtr databaseHandle, string serviceName, int access);
        
        [DllImport(ExternDll.Advapi32, CharSet=System.Runtime.InteropServices.CharSet.Unicode, SetLastError=true)]
        public extern static IntPtr RegisterServiceCtrlHandler(string serviceName, Delegate callback);
        
        [DllImport(ExternDll.Advapi32, CharSet=System.Runtime.InteropServices.CharSet.Unicode, SetLastError=true)]
        public extern static IntPtr RegisterServiceCtrlHandlerEx(string serviceName, Delegate callback, IntPtr userData);

        [DllImport(ExternDll.Advapi32, CharSet=System.Runtime.InteropServices.CharSet.Unicode, SetLastError=true)]
        public unsafe extern static bool SetServiceStatus(IntPtr serviceStatusHandle, SERVICE_STATUS *status);
        
        [DllImport(ExternDll.Advapi32, CharSet=System.Runtime.InteropServices.CharSet.Unicode, SetLastError=true)]
        public extern static bool StartServiceCtrlDispatcher(IntPtr entry);
        
        [DllImport(ExternDll.Advapi32, CharSet=System.Runtime.InteropServices.CharSet.Unicode, SetLastError=true)]
        public extern static IntPtr CreateService(IntPtr databaseHandle, string serviceName, string displayName,  int access,  int serviceType,
            int startType, int errorControl, string binaryPath, string loadOrderGroup, IntPtr pTagId, string dependencies,
            string servicesStartName, string password);       
            
        [DllImport(ExternDll.Advapi32, CharSet=System.Runtime.InteropServices.CharSet.Unicode, SetLastError=true)]
        public extern static bool DeleteService(IntPtr serviceHandle);               
        
        [DllImport(ExternDll.Advapi32, CharSet=System.Runtime.InteropServices.CharSet.Unicode, SetLastError=false)]
        public static extern int LsaOpenPolicy(NativeMethods.LSA_UNICODE_STRING systemName, IntPtr pointerObjectAttributes,
                                                            int desiredAccess,  out IntPtr pointerPolicyHandle);

        [DllImport(ExternDll.Advapi32, CharSet=System.Runtime.InteropServices.CharSet.Unicode, SetLastError=false)]
        public static extern int LsaAddAccountRights(IntPtr policyHandle, byte[] accountSid, NativeMethods.LSA_UNICODE_STRING userRights,
                                                            int countOfRights);
        
        [DllImport(ExternDll.Advapi32, CharSet=System.Runtime.InteropServices.CharSet.Unicode, SetLastError=false)]
        public static extern int LsaRemoveAccountRights(IntPtr policyHandle, byte[] accountSid, bool allRights, NativeMethods.LSA_UNICODE_STRING userRights, int countOfRights);

        [DllImport(ExternDll.Advapi32, CharSet=System.Runtime.InteropServices.CharSet.Unicode, SetLastError=false)]
        public static extern int LsaEnumerateAccountRights(IntPtr policyHandle, byte[] accountSid, out IntPtr pLsaUnicodeStringUserRights, out int RightsCount);
        
        [DllImport(ExternDll.Advapi32, CharSet=System.Runtime.InteropServices.CharSet.Unicode, SetLastError=true)]
        public static extern bool LookupAccountName(string systemName, string accountName,
            byte[] sid, int[] sidLen, char[] refDomainName, int[] domNameLen,
            [In, Out]int[] sidNameUse);                           

        
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\services\servproc\makefile.inc ===
!if 0
    -------------------------------------------------------------------------------------
        Don't modify... user variables are set in "sources"
    -------------------------------------------------------------------------------------
!endif
!if "$(LINKONLY)" != "1"
compileWithResGen: 
    $(ECHO_PROCESSING_CMD) Compile_With_ResGen
    if exist %URTSDKTARGET%\bin\resgen.exe %URTSDKTARGET%\bin\resgen.exe /compile Resources\System\ServiceProcess\Design\ServiceInstallerDialog.resx,$(O)\ServiceInstallerDialog.resources
    if not exist %URTSDKTARGET%\bin\resgen.exe copy Resources\System\ServiceProcess\Design\ServiceInstallerDialog.resources $(O)
!else
compileWithResGen: 
    echo Nothing to do this phase.
!endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\services\monitoring\system\diagnosticts\design\stringvalueconverter.cs ===
//------------------------------------------------------------------------------
// <copyright file="StringValueConverter.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

 namespace System.Diagnostics.Design {    
    using System;            
    using System.ComponentModel;
    using System.ComponentModel.Design;      
    using System.Globalization;        
    
    /// <internalonly/>
    internal class StringValueConverter : TypeConverter {        
                            
        /// <internalonly/>                               
        public override bool CanConvertFrom(ITypeDescriptorContext context, Type sourceType) {
            if (sourceType == typeof(string)) {
                return true;
            }
            return base.CanConvertFrom(context, sourceType);
        }                        
                                         
        /// <internalonly/>                 
        public override object ConvertFrom(ITypeDescriptorContext context, CultureInfo culture, object value) {
            if (value is string) {
                string text = ((string)value).Trim();
            
                if (text == String.Empty)
                    text = null;
                    
                return text;                        
            }
            
            return base.ConvertFrom(context, culture, value);                
        }        
    }                                                                                   
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\services\monitoring\system\diagnosticts\design\stringdictionarycodedomserializer.cs ===
//------------------------------------------------------------------------------
// <copyright file="StringDictionaryCodeDomSerializer.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

/*
 */
namespace System.Diagnostics.Design {

    using System;
    using System.Design;
    using System.CodeDom;
    using System.Collections;
    using System.ComponentModel;
    using System.ComponentModel.Design;
    using System.Diagnostics;
    using System.Reflection;
    using System.ComponentModel.Design.Serialization;
    using System.Collections.Specialized;
    
    /// <include file='doc\StringDictionaryCodeDomSerializer.uex' path='docs/doc[@for="StringDictionaryDomSerializer"]/*' />
    /// <devdoc>
    ///     This serializer serializes string dictionaries.
    /// </devdoc>
    internal class StringDictionaryCodeDomSerializer : CodeDomSerializer {
        
        /// <include file='doc\StringDictionaryCodeDomSerializer.uex' path='docs/doc[@for="StringDictionaryCodeDomSerializer.Deserialize"]/*' />
        /// <devdoc>
        ///     This method takes a CodeDomObject and deserializes into a real object.
        ///     We don't do anything here.
        /// </devdoc>
        public override object Deserialize(IDesignerSerializationManager manager, object codeObject) {
            Debug.Fail("Don't expect this to be called.");
            return null;
        }
            
        /// <include file='doc\StringDictionaryCodeDomSerializer.uex' path='docs/doc[@for="StringDictionaryCodeDomSerializer.Serialize"]/*' />
        /// <devdoc>
        ///     Serializes the given object into a CodeDom object.
        /// </devdoc>
        public override object Serialize(IDesignerSerializationManager manager, object value) {
            object result = null;
            
            StringDictionary dictionary = value as StringDictionary;
            if (dictionary != null) {
                object context = manager.Context.Current;
                        
                CodeValueExpression valueEx = context as CodeValueExpression;
                if (valueEx != null) {
                    if (valueEx.Value == value) {
                        context = valueEx.Expression;
                    }
                }
        
                // we can only serialize if we have a CodePropertyReferenceExpression
                CodePropertyReferenceExpression propRef = context as CodePropertyReferenceExpression;
                if (propRef != null) {
                    
                    // get the object with the property we're setting
                    object targetObject = DeserializeExpression(manager, null, propRef.TargetObject);
                    if (targetObject != null) {
                        
                        // get the PropertyDescriptor of the property we're setting
                        PropertyDescriptor prop = TypeDescriptor.GetProperties(targetObject)[propRef.PropertyName];
                        if (prop != null) {

                            // okay, we have the property and we have the StringDictionary, now we generate
                            // a line like this (c# example):
                            //      myObject.strDictProp["key"] = "value";
                            // for each key/value pair in the StringDictionary

                            CodeStatementCollection statements = new CodeStatementCollection();
                            CodeMethodReferenceExpression methodRef = new CodeMethodReferenceExpression(propRef, "Add");
            
                            foreach (DictionaryEntry entry in dictionary) {
                                // serialize the key (in most languages this will look like "key")
                                CodeExpression serializedKey = SerializeToExpression(manager, entry.Key);
                                
                                // serialize the value (in most languages this will look like "value")
                                CodeExpression serializedValue = SerializeToExpression(manager, entry.Value);
                                
                                // serialize the method call (prop.Add("key", "value"))
                                if (serializedKey != null && serializedValue != null) {
                                    CodeMethodInvokeExpression statement = new CodeMethodInvokeExpression();
                                    statement.Method = methodRef;
                                    statement.Parameters.Add(serializedKey);
                                    statement.Parameters.Add(serializedValue);
                                    statements.Add(statement);
                                }
                            }
                        
                            result = statements;                            
                        }
                    }
                }
            }
            else {
                // 'value' is not a StringDictionary.  What should we do?
            }
            
            return result;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\services\servproc\system\serviceprocess\powerbroadcaststatus.cs ===
//------------------------------------------------------------------------------
// <copyright file="PowerBroadcastStatus.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.ServiceProcess {
   using System;

    /// <include file='doc\PowerBroadcastStatus.uex' path='docs/doc[@for="PowerBroadcastStatus"]/*' />
    /// <devdoc>
    ///    <para>[To be supplied.]</para>
    /// </devdoc>
    public enum PowerBroadcastStatus {
        /// <include file='doc\PowerBroadcastStatus.uex' path='docs/doc[@for="PowerBroadcastStatus.BatteryLow"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        BatteryLow = NativeMethods.PBT_APMBATTERYLOW,
        /// <include file='doc\PowerBroadcastStatus.uex' path='docs/doc[@for="PowerBroadcastStatus.OemEvent"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        OemEvent = NativeMethods.PBT_APMOEMEVENT,
        /// <include file='doc\PowerBroadcastStatus.uex' path='docs/doc[@for="PowerBroadcastStatus.PowerStatusChange"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        PowerStatusChange = NativeMethods.PBT_APMPOWERSTATUSCHANGE,
        /// <include file='doc\PowerBroadcastStatus.uex' path='docs/doc[@for="PowerBroadcastStatus.QuerySuspend"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        QuerySuspend = NativeMethods.PBT_APMQUERYSUSPEND,
        /// <include file='doc\PowerBroadcastStatus.uex' path='docs/doc[@for="PowerBroadcastStatus.QuerySuspendFailed"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        QuerySuspendFailed = NativeMethods.PBT_APMQUERYSUSPENDFAILED,
        /// <include file='doc\PowerBroadcastStatus.uex' path='docs/doc[@for="PowerBroadcastStatus.ResumeAutomatic"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        ResumeAutomatic = NativeMethods.PBT_APMRESUMEAUTOMATIC,
        /// <include file='doc\PowerBroadcastStatus.uex' path='docs/doc[@for="PowerBroadcastStatus.ResumeCritical"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        ResumeCritical = NativeMethods.PBT_APMRESUMECRITICAL,
        /// <include file='doc\PowerBroadcastStatus.uex' path='docs/doc[@for="PowerBroadcastStatus.ResumeSuspend"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        ResumeSuspend = NativeMethods.PBT_APMRESUMESUSPEND,
        /// <include file='doc\PowerBroadcastStatus.uex' path='docs/doc[@for="PowerBroadcastStatus.Suspend"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        Suspend = NativeMethods.PBT_APMSUSPEND,
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\services\servproc\system\serviceprocess\safenativemethods.cs ===
//------------------------------------------------------------------------------
// <copyright file="SafeNativeMethods.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.ServiceProcess {    
    using System;
    using System.Text;
    using System.Security;
    using System.Security.Permissions;
    using System.Runtime.InteropServices;
    
    [
    ComVisible(false), 
    SuppressUnmanagedCodeSecurityAttribute()
    ]
    internal class SafeNativeMethods {
        [DllImport(ExternDll.User32, CharSet=System.Runtime.InteropServices.CharSet.Auto)]
        public static extern int MessageBox(IntPtr hWnd, String text, String caption, int type);
    
        [DllImport(ExternDll.Advapi32, CharSet=System.Runtime.InteropServices.CharSet.Unicode, SetLastError=true)]
        public extern static IntPtr OpenSCManager(string machineName, string databaseName, int access);        
        
        [DllImport(ExternDll.Advapi32, CharSet=System.Runtime.InteropServices.CharSet.Unicode, SetLastError=true)]
        public extern static bool CloseServiceHandle(IntPtr handle);        

        [DllImport(ExternDll.Advapi32, CharSet=System.Runtime.InteropServices.CharSet.Unicode, SetLastError=false)]
        public static extern int LsaClose(IntPtr objectHandle);
        
        [DllImport(ExternDll.Advapi32, SetLastError=false)]
        public static extern int LsaFreeMemory(IntPtr ptr);

        [DllImport(ExternDll.Advapi32, CharSet=System.Runtime.InteropServices.CharSet.Unicode, SetLastError=false)]
        public static extern int LsaNtStatusToWinError(int ntStatus);
        
        [DllImport(ExternDll.Advapi32, CharSet=System.Runtime.InteropServices.CharSet.Unicode, SetLastError=true)]
        public static extern bool GetServiceKeyName(IntPtr SCMHandle, string displayName, StringBuilder shortName, ref int shortNameLength);
        
        [DllImport(ExternDll.Advapi32, CharSet=System.Runtime.InteropServices.CharSet.Unicode, SetLastError=true)]
        public static extern bool GetServiceDisplayName(IntPtr SCMHandle, string shortName, StringBuilder displayName, ref int displayNameLength);                
        
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\services\servproc\system\serviceprocess\servicecontrollerpermissionaccess.cs ===
//------------------------------------------------------------------------------
// <copyright file="ServiceControllerPermissionAccess.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.ServiceProcess {

    /// <include file='doc\ServiceControllerPermissionAccess.uex' path='docs/doc[@for="ServiceControllerPermissionAccess"]/*' />
    /// <devdoc>
    ///    <para>[To be supplied.]</para>
    /// </devdoc>
    [Flags]         
    public enum ServiceControllerPermissionAccess {
        /// <include file='doc\ServiceControllerPermissionAccess.uex' path='docs/doc[@for="ServiceControllerPermissionAccess.None"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        None = 0,
        /// <include file='doc\ServiceControllerPermissionAccess.uex' path='docs/doc[@for="ServiceControllerPermissionAccess.Browse"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        Browse = 1 << 1,
        /// <include file='doc\ServiceControllerPermissionAccess.uex' path='docs/doc[@for="ServiceControllerPermissionAccess.Control"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        Control = 1 << 2 | Browse,
    }    
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\services\servproc\system\serviceprocess\serviceaccount.cs ===
//------------------------------------------------------------------------------
// <copyright file="ServiceAccount.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.ServiceProcess {
   using System;

    /// <include file='doc\ServiceAccount.uex' path='docs/doc[@for="ServiceAccount"]/*' />
    /// <devdoc>
    ///    <para>[To be supplied.]</para>
    /// </devdoc>
    public enum ServiceAccount {
        
        /// <include file='doc\ServiceAccount.uex' path='docs/doc[@for="ServiceAccount.LocalService"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        LocalService = 0,
        /// <include file='doc\ServiceAccount.uex' path='docs/doc[@for="ServiceAccount.NetworkService"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        NetworkService = 1,
        /// <include file='doc\ServiceAccount.uex' path='docs/doc[@for="ServiceAccount.LocalSystem"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        LocalSystem = 2,
        /// <include file='doc\ServiceAccount.uex' path='docs/doc[@for="ServiceAccount.User"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        User = 3,
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\services\servproc\system\serviceprocess\servicecontroller.cs ===
//------------------------------------------------------------------------------
// <copyright file="ServiceController.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

using INTPTR_INTCAST = System.Int32;
using INTPTR_INTPTRCAST = System.IntPtr;
           
namespace System.ServiceProcess {
    using System.Text;
    using System.Runtime.InteropServices;
    using System.ComponentModel;
    using System.Diagnostics;
    using System;
    using System.Collections;
    using System.Threading;
    using System.Globalization;
    using System.Security;
    using System.ServiceProcess.Design;
    using System.Security.Permissions;

    /// <include file='doc\ServiceController.uex' path='docs/doc[@for="ServiceController"]/*' />
    /// <devdoc>
    /// This class represents an NT service. It allows you to connect to a running or stopped service
    /// and manipulate it or get information about it.
    /// </devdoc>
    [Designer("System.ServiceProcess.Design.ServiceControllerDesigner, " + AssemblyRef.SystemDesign)]
    public class ServiceController : Component {
        private string machineName = ".";
        private string name = "";
        private string displayName = "";
        private string eitherName = "";
        private int commandsAccepted;
        private ServiceControllerStatus status;
        private IntPtr serviceManagerHandle;
        private bool statusGenerated;
        private bool controlGranted;
        private bool browseGranted;
        private ServiceController[] dependentServices;
        private ServiceController[] servicesDependedOn;
        private int type; 
        private bool disposed;       
        
        private const int DISPLAYNAMEBUFFERSIZE = 256;
        private static readonly int UnknownEnvironment = 0;
        private static readonly int NtEnvironment = 1;
        private static readonly int NonNtEnvironment = 2;
        private static int environment = UnknownEnvironment;

        /// <include file='doc\ServiceController.uex' path='docs/doc[@for="ServiceController.ServiceController"]/*' />
        /// <devdoc>
        ///     Creates a ServiceController object.
        /// </devdoc>
        public ServiceController() {                                    
            this.type = NativeMethods.SERVICE_TYPE_ALL;
        }

        /// <include file='doc\ServiceController.uex' path='docs/doc[@for="ServiceController.ServiceController1"]/*' />
        /// <devdoc>
        ///     Creates a ServiceController object, based on
        ///     service name.
        /// </devdoc>
        public ServiceController(string name) : this(name, ".") {
        }

        /// <include file='doc\ServiceController.uex' path='docs/doc[@for="ServiceController.ServiceController2"]/*' />
        /// <devdoc>
        ///     Creates a ServiceController object, based on
        ///     machine and service name.
        /// </devdoc>
        public ServiceController(string name, string machineName) {                
            if (!SyntaxCheck.CheckMachineName(machineName))
                throw new ArgumentException(Res.GetString(Res.BadMachineName, machineName));

            if (name == null || name.Length == 0)
                throw new ArgumentException(Res.GetString(Res.InvalidParameter, "name", name));                

            this.machineName = machineName;
            this.eitherName = name;
            this.type = NativeMethods.SERVICE_TYPE_ALL;
        }

        /// <include file='doc\ServiceController.uex' path='docs/doc[@for="ServiceController.ServiceController3"]/*' />
        /// <devdoc>
        /// Used by the GetServices and GetDevices methods. Avoids duplicating work by the static
        /// methods and our own GenerateInfo().
        /// </devdoc>
        /// <internalonly/>
        internal ServiceController(string machineName, NativeMethods.ENUM_SERVICE_STATUS status) {
            if (!SyntaxCheck.CheckMachineName(machineName))
                throw new ArgumentException(Res.GetString(Res.BadMachineName, machineName));

            this.machineName = machineName;
            this.name = status.serviceName;
            this.displayName = status.displayName;
            this.commandsAccepted = status.controlsAccepted;
            this.status = (ServiceControllerStatus)status.currentState;
            this.type = status.serviceType;
            this.statusGenerated = true;
        }

        /// <include file='doc\ServiceController.uex' path='docs/doc[@for="ServiceController.ServiceController4"]/*' />
        /// <devdoc>
        /// Used by the GetServicesInGroup method.
        /// </devdoc>
        /// <internalonly/>
        internal ServiceController(string machineName, NativeMethods.ENUM_SERVICE_STATUS_PROCESS status) {
            if (!SyntaxCheck.CheckMachineName(machineName))
                throw new ArgumentException(Res.GetString(Res.BadMachineName, machineName));

            this.machineName = machineName;
            this.name = status.serviceName;
            this.displayName = status.displayName;
            this.commandsAccepted = status.controlsAccepted;
            this.status = (ServiceControllerStatus)status.currentState;
            this.type = status.serviceType;
            this.statusGenerated = true;
        }

        /// <include file='doc\ServiceController.uex' path='docs/doc[@for="ServiceController.CanPauseAndContinue"]/*' />
        /// <devdoc>
        ///     Tells if the service referenced by this object can be paused.
        /// </devdoc>
        [
            DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden),
            ServiceProcessDescription(Res.SPCanPauseAndContinue)
        ]
        public bool CanPauseAndContinue {
            get {                
                GenerateStatus();
                return(this.commandsAccepted & NativeMethods.ACCEPT_PAUSE_CONTINUE) != 0;
            }
        }

        /// <include file='doc\ServiceController.uex' path='docs/doc[@for="ServiceController.CanShutdown"]/*' />
        /// <devdoc>
        ///     Tells if the service is notified when system shutdown occurs.
        /// </devdoc>
        [
            DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden),
            ServiceProcessDescription(Res.SPCanShutdown)
            ]
        public bool CanShutdown {
            get {                
                GenerateStatus();
                return(this.commandsAccepted & NativeMethods.ACCEPT_SHUTDOWN) != 0;
            }
        }

        /// <include file='doc\ServiceController.uex' path='docs/doc[@for="ServiceController.CanStop"]/*' />
        /// <devdoc>
        ///     Tells if the service referenced by this object can be stopped.
        /// </devdoc>
        [
            DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden),
            ServiceProcessDescription(Res.SPCanStop)
        ]
        public bool CanStop {
            get {                
                GenerateStatus();
                return(this.commandsAccepted & NativeMethods.ACCEPT_STOP) != 0;
            }
        }

        /// <include file='doc\ServiceController.uex' path='docs/doc[@for="ServiceController.DisplayName"]/*' />
        /// <devdoc>
        /// The descriptive name shown for this service in the Service applet.
        /// </devdoc>
        [
            ReadOnly(true), 
            DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden),
            ServiceProcessDescription(Res.SPDisplayName),        
        ]
        public string DisplayName {
            get {
                if (displayName.Length == 0 && (eitherName.Length > 0 || name.Length > 0))
                    GenerateNames();
                return this.displayName;
            }
            set {
                if (value == null)
                    throw new ArgumentNullException("value");

                if (string.Compare(value, displayName, true, CultureInfo.InvariantCulture) == 0) {
                    // they're just changing the casing. No need to close.
                    displayName = value;
                    return;
                }

                Close();
                displayName = value;
                name = "";
            }
        }

        /// <include file='doc\ServiceController.uex' path='docs/doc[@for="ServiceController.DependentServices"]/*' />
        /// <devdoc>
        /// The set of services that depend on this service. These are the services that will be stopped if
        /// this service is stopped.
        /// </devdoc>
        [
            DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden),
            ServiceProcessDescription(Res.SPDependentServices)
        ]
        public ServiceController[] DependentServices {
            get {
                if (!browseGranted) {
                    ServiceControllerPermission permission = new ServiceControllerPermission(
                                                                                            ServiceControllerPermissionAccess.Browse, machineName, ServiceName);
                    permission.Demand();                                                                                            
                    browseGranted = true;                        
                }                    
                
                if (dependentServices == null) {
                    IntPtr serviceHandle = GetServiceHandle(NativeMethods.SERVICE_ENUMERATE_DEPENDENTS);
                    try {
                        // figure out how big a buffer we need to get the info
                        int bytesNeeded = 0;
                        int numEnumerated = 0;
                        bool result = UnsafeNativeMethods.EnumDependentServices(serviceHandle, NativeMethods.SERVICE_STATE_ALL, (IntPtr)0, 0, 
                            ref bytesNeeded, ref numEnumerated);
                        if (result) {
                            dependentServices = new ServiceController[0];
                            return dependentServices;
                        }
                        if (Marshal.GetLastWin32Error() != NativeMethods.ERROR_MORE_DATA) 
                            throw CreateSafeWin32Exception();
                                
                        // allocate the buffer
                        IntPtr enumBuffer = Marshal.AllocHGlobal((IntPtr)bytesNeeded);
    
                        try {
                            // get all the info
                            result = UnsafeNativeMethods.EnumDependentServices(serviceHandle, NativeMethods.SERVICE_STATE_ALL, enumBuffer, bytesNeeded,
                                ref bytesNeeded, ref numEnumerated);
                            if (!result) 
                                throw CreateSafeWin32Exception();                    
    
                            // for each of the entries in the buffer, create a new ServiceController object.
                            dependentServices = new ServiceController[numEnumerated];
                            for (int i = 0; i < numEnumerated; i++) {
                                NativeMethods.ENUM_SERVICE_STATUS status = new NativeMethods.ENUM_SERVICE_STATUS();
                                IntPtr structPtr = (IntPtr)((long)enumBuffer + (i * Marshal.SizeOf(typeof(NativeMethods.ENUM_SERVICE_STATUS))));
                                Marshal.PtrToStructure(structPtr, status);                                
                                dependentServices[i] = new ServiceController(MachineName, status);
                            }
                        }
                        finally {
                            Marshal.FreeHGlobal(enumBuffer);
                        }
                    }
                    finally {                    
                        SafeNativeMethods.CloseServiceHandle(serviceHandle);
                    }
                }
                
                return dependentServices;
            }
        }

        /// <include file='doc\ServiceController.uex' path='docs/doc[@for="ServiceController.MachineName"]/*' />
        /// <devdoc>
        /// The name of the machine on which this service resides.
        /// </devdoc>
        [
            Browsable(false), 
            ServiceProcessDescription(Res.SPMachineName), 
            DefaultValue("."), 
            RecommendedAsConfigurable(true)
        ]
        public string MachineName {
            get {
                return this.machineName;
            }
            set {
                if (!SyntaxCheck.CheckMachineName(value))
                    throw new ArgumentException(Res.GetString(Res.BadMachineName, value));

                if (string.Compare(machineName, value, true, CultureInfo.InvariantCulture) == 0) {
                    // no need to close, because the most they're changing is the
                    // casing.
                    machineName = value;
                    return;
                }

                Close();
                machineName = value;
            }
        }

        /// <include file='doc\ServiceController.uex' path='docs/doc[@for="ServiceController.ServiceName"]/*' />
        /// <devdoc>
        ///     Returns the short name of the service referenced by this
        ///     object.
        /// </devdoc>
        [
            ReadOnly(true), 
            ServiceProcessDescription(Res.SPServiceName), 
            DefaultValue(""), 
            TypeConverter(typeof(ServiceNameConverter)), 
            RecommendedAsConfigurable(true)
        ]
        public string ServiceName {
            get {
                if (name.Length == 0 && (eitherName.Length > 0 || displayName.Length > 0))
                    GenerateNames();
                return this.name;
            }
            set {
                if (value == null)
                    throw new ArgumentNullException("value");
                
                if (string.Compare(value, name, true, CultureInfo.InvariantCulture) == 0) {
                    // they might be changing the casing, but the service we refer to
                    // is the same. No need to close.
                    name = value;
                    return;
                }

                if (!ValidServiceName(value)) 
                    throw new ArgumentException(Res.GetString(Res.ServiceName, value, ServiceBase.MaxNameLength.ToString()));

                Close();
                name = value;
                displayName = "";
            }
        }

        /// <include file='doc\ServiceController.uex' path='docs/doc[@for="ServiceController.ServicesDependedOn"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        [
            DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden),
            ServiceProcessDescription(Res.SPServicesDependedOn)
        ]
        public unsafe ServiceController[] ServicesDependedOn {
            get {
                if (!browseGranted) {
                    ServiceControllerPermission permission = new ServiceControllerPermission(
                                                                                            ServiceControllerPermissionAccess.Browse, machineName, ServiceName);
                    permission.Demand();                                                                                            
                    browseGranted = true;                        
                }                    
            
                if (servicesDependedOn != null)
                    return servicesDependedOn;

                IntPtr serviceHandle = GetServiceHandle(NativeMethods.SERVICE_QUERY_CONFIG);
                try {

                    int bytesNeeded = 0;
                    bool success = UnsafeNativeMethods.QueryServiceConfig(serviceHandle, (IntPtr)0, 0, out bytesNeeded);
                    if (success) {
                        servicesDependedOn = new ServiceController[0];
                        return servicesDependedOn;
                    }
                    if (Marshal.GetLastWin32Error() != NativeMethods.ERROR_INSUFFICIENT_BUFFER) 
                        throw CreateSafeWin32Exception();
                        
                    // get the info
                    IntPtr bufPtr = Marshal.AllocHGlobal((IntPtr)bytesNeeded);
                    try {
                        success = UnsafeNativeMethods.QueryServiceConfig(serviceHandle, bufPtr, bytesNeeded, out bytesNeeded);
                        if (!success) 
                            throw CreateSafeWin32Exception();                

                        NativeMethods.QUERY_SERVICE_CONFIG config = new NativeMethods.QUERY_SERVICE_CONFIG();
                        Marshal.PtrToStructure(bufPtr, config);
                        char *dependencyChar = config.lpDependencies;
                        Hashtable dependencyHash = new Hashtable();
                        
                        if (dependencyChar != null) {
                            // lpDependencies points to the start of multiple null-terminated strings. The list is
                            // double-null terminated.                            
                            StringBuilder dependencyName = new StringBuilder();
                            while (*dependencyChar != '\0') {
                                dependencyName.Append(*dependencyChar);
                                dependencyChar++;
                                if (*dependencyChar == '\0') {
                                    string dependencyNameStr = dependencyName.ToString();
                                    dependencyName = new StringBuilder();
                                    dependencyChar++;
                                    if (dependencyNameStr.StartsWith("+")) {
                                        // this entry is actually a service load group
                                        NativeMethods.ENUM_SERVICE_STATUS_PROCESS[] loadGroup = GetServicesInGroup(machineName, dependencyNameStr.Substring(1));
                                        foreach (NativeMethods.ENUM_SERVICE_STATUS_PROCESS groupMember in loadGroup) {
                                            if (!dependencyHash.Contains(groupMember.serviceName))
                                                dependencyHash.Add(groupMember.serviceName, new ServiceController(MachineName, groupMember));    
                                        }
                                    } else {
                                        if (!dependencyHash.Contains(dependencyNameStr))
                                            dependencyHash.Add(dependencyNameStr, new ServiceController(dependencyNameStr, MachineName));
                                    }
                                }
                            }                                
                        }

                        servicesDependedOn = new ServiceController[dependencyHash.Count];
                        dependencyHash.Values.CopyTo(servicesDependedOn, 0);

                        return servicesDependedOn;
                    }
                    finally {
                        Marshal.FreeHGlobal(bufPtr);
                    }
                }
                finally {
                    SafeNativeMethods.CloseServiceHandle(serviceHandle);
                }
            }
        }

        /// <include file='doc\ServiceController.uex' path='docs/doc[@for="ServiceController.Status"]/*' />
        /// <devdoc>
        ///     Gets the status of the service referenced by this
        ///     object, e.g., Running, Stopped, etc.
        /// </devdoc>
        [
            DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden),
            ServiceProcessDescription(Res.SPStatus)
        ]
        public ServiceControllerStatus Status {
            get {
                GenerateStatus();
                return this.status;
            }
        }

        /// <include file='doc\ServiceController.uex' path='docs/doc[@for="ServiceController.ServiceType"]/*' />
        /// <devdoc>
        ///     Gets the type of service that this object references.
        /// </devdoc>
        [
            DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden),
            ServiceProcessDescription(Res.SPServiceType)
        ]
        public ServiceType ServiceType {
            get {
                GenerateStatus();
                return (ServiceType) this.type;
            }
        }
        
        private static void CheckEnvironment() {
            if (environment == UnknownEnvironment) { 
                lock (typeof(EventLog)) {
                    if (environment == UnknownEnvironment) {
                        //SECREVIEW: jruiz- need to assert Environment permissions here
                        //                        the environment check is not exposed as a public 
                        //                        method                        
                        EnvironmentPermission environmentPermission = new EnvironmentPermission(PermissionState.Unrestricted);                        
                        environmentPermission.Assert();                        
                        try {
                            if (Environment.OSVersion.Platform == PlatformID.Win32NT)
                                environment = NtEnvironment; 
                            else                    
                                environment = NonNtEnvironment;
                        }
                        finally {  
                             EnvironmentPermission.RevertAssert();                             
                        }                                                    
                    }                
                }
            }                                                  
            
            if (environment == NonNtEnvironment)
                throw new PlatformNotSupportedException(Res.GetString(Res.CantControlOnWin9x));                                            
        }
        

        /// <include file='doc\ServiceController.uex' path='docs/doc[@for="ServiceController.Close"]/*' />
        /// <devdoc>
        ///     Disconnects this object from the service and frees any allocated
        ///     resources.
        /// </devdoc>
        public void Close() {
            if (this.serviceManagerHandle != (IntPtr)0)
                SafeNativeMethods.CloseServiceHandle(this.serviceManagerHandle);

            this.serviceManagerHandle = (IntPtr)0;
            this.statusGenerated = false;
            this.type = NativeMethods.SERVICE_TYPE_ALL;
            this.browseGranted = false;
            this.controlGranted = false;
        }
        
        private static Win32Exception CreateSafeWin32Exception() {
            Win32Exception newException = null;
            //SECREVIEW: Need to assert SecurtiyPermission, otherwise Win32Exception
            //                         will not be able to get the error message. At this point the right
            //                         permissions have already been demanded.
            SecurityPermission securityPermission = new SecurityPermission(PermissionState.Unrestricted);
            securityPermission.Assert();                            
            try {                
                newException = new Win32Exception();               
            }
            finally {
                SecurityPermission.RevertAssert();
            }                       
                        
            return newException;        
        }


        /// <include file='doc\ServiceController.uex' path='docs/doc[@for="ServiceController.Dispose1"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        protected override void Dispose(bool disposing) {
            // safe to call while finalizing or disposing
            //
            Close();
            this.disposed = true;
            base.Dispose(disposing);
        }
        
        private unsafe void GenerateStatus() {
            if (!statusGenerated) {
                if (!browseGranted) {
                    ServiceControllerPermission permission = new ServiceControllerPermission(
                                                                                            ServiceControllerPermissionAccess.Browse,  machineName, ServiceName);
                    permission.Demand();                                                                                            
                    browseGranted = true;                        
                }                    
            
                IntPtr serviceHandle = GetServiceHandle(NativeMethods.SERVICE_QUERY_STATUS);
                try {
                    NativeMethods.SERVICE_STATUS svcStatus = new NativeMethods.SERVICE_STATUS();
                    bool success = UnsafeNativeMethods.QueryServiceStatus(serviceHandle, &svcStatus);
                    if (!success) 
                        throw CreateSafeWin32Exception();            

                    commandsAccepted = svcStatus.controlsAccepted;
                    status = (ServiceControllerStatus) svcStatus.currentState;
                    type = svcStatus.serviceType;
                    statusGenerated = true;
                }
                finally {
                    SafeNativeMethods.CloseServiceHandle(serviceHandle);
                }
            }
        }

        private void GenerateNames() {
            if (machineName.Length == 0)
                throw new ArgumentException(Res.GetString(Res.NoMachineName));

            if (name.Length == 0) {
                // figure out the service name based on the information we have. If we don't have ServiceName,
                // we must either have DisplayName or the constructor parameter (eitherName).
                string userGivenName = eitherName;
                if (userGivenName.Length == 0)
                    userGivenName = displayName;
                if (userGivenName.Length == 0)
                    throw new InvalidOperationException(Res.GetString(Res.NoGivenName));                                

                int bufLen = DISPLAYNAMEBUFFERSIZE;
                StringBuilder buf = new StringBuilder(bufLen);
                bool success = SafeNativeMethods.GetServiceKeyName(GetDataBaseHandle(), userGivenName, buf, ref bufLen);
                if (success) {
                    name = buf.ToString();
                    displayName = userGivenName;
                    eitherName = "";
                }
                else {
                    success = SafeNativeMethods.GetServiceDisplayName(GetDataBaseHandle(), userGivenName, buf, ref bufLen);
                    if (!success && bufLen >= DISPLAYNAMEBUFFERSIZE) {
                        // DISPLAYNAMEBUFFERSIZE is total number of chars in buffer, buffLen is
                        // required chars for name, minus null terminator.  If we're here,
                        // we need a bigger buffer.
                        buf = new StringBuilder(++bufLen);
                        success = SafeNativeMethods.GetServiceDisplayName(GetDataBaseHandle(), userGivenName, buf, ref bufLen);
                    }
                    if (success) {
                        name = userGivenName;
                        displayName = buf.ToString();
                        eitherName = "";
                    }
                    else {
                        Exception inner = CreateSafeWin32Exception();                                        
                        throw new InvalidOperationException(Res.GetString(Res.NoService, userGivenName, machineName), inner);
                    }                        
                }
            }

            if (displayName.Length == 0) {
                // by this point we know we have ServiceName, so just figure DisplayName out from that.
                                
                int bufLen = DISPLAYNAMEBUFFERSIZE;
                StringBuilder buf = new StringBuilder(bufLen);
                bool success = SafeNativeMethods.GetServiceDisplayName(GetDataBaseHandle(), name, buf, ref bufLen);
                if (!success && bufLen >= DISPLAYNAMEBUFFERSIZE) {
                    // DISPLAYNAMEBUFFERSIZE is total number of chars in buffer, buffLen is
                    // required chars for name, minus null terminator.  If we're here,
                    // we need a bigger buffer.
                    buf = new StringBuilder(++bufLen);
                    success = SafeNativeMethods.GetServiceDisplayName(GetDataBaseHandle(), name, buf, ref bufLen);
                }
                if (!success) {
                    Exception inner = CreateSafeWin32Exception();                                        
                    throw new InvalidOperationException(Res.GetString(Res.NoDisplayName, this.name,this.machineName), inner);
                }                    
                displayName = buf.ToString();
            }
        }

        /// <include file='doc\ServiceController.uex' path='docs/doc[@for="ServiceController.GetDataBaseHandle"]/*' />
        /// <devdoc>
        /// </devdoc>
        /// <internalonly/>
        private IntPtr GetDataBaseHandle() {
            //Need to check the environment before tryong to access service database
            CheckEnvironment();
            if (this.serviceManagerHandle == (IntPtr)0) {
                //Cannot open the service manager handle if the object has been disposed, since finalization has been suppressed.
                if (this.disposed)
                    throw new ObjectDisposedException(GetType().Name);
                    
                if (this.MachineName.Equals(".") || this.MachineName.Length == 0)
                    this.serviceManagerHandle = SafeNativeMethods.OpenSCManager(null, null, NativeMethods.SC_MANAGER_ENUMERATE_SERVICE);
                else
                    this.serviceManagerHandle = SafeNativeMethods.OpenSCManager(MachineName, null, NativeMethods.SC_MANAGER_ENUMERATE_SERVICE);

                if (this.serviceManagerHandle == (IntPtr)0) {
                    Exception inner = CreateSafeWin32Exception();                                        
                    throw new InvalidOperationException(Res.GetString(Res.OpenSC, MachineName), inner);
                }
            }

            return this.serviceManagerHandle;
        }

        /// <include file='doc\ServiceController.uex' path='docs/doc[@for="ServiceController.GetDevices"]/*' />
        /// <devdoc>
        ///     Gets all the device-driver services on the local machine.
        /// </devdoc>
        public static ServiceController[] GetDevices() {
            return GetDevices(".");
        }

        /// <include file='doc\ServiceController.uex' path='docs/doc[@for="ServiceController.GetDevices1"]/*' />
        /// <devdoc>
        ///     Gets all the device-driver services in the machine specified.
        /// </devdoc>
        public static ServiceController[] GetDevices(string machineName) {
            return GetServicesOfType(machineName, NativeMethods.SERVICE_TYPE_DRIVER);
        }

        /// <include file='doc\ServiceController.uex' path='docs/doc[@for="ServiceController.GetServiceHandle"]/*' />
        /// <devdoc>
        /// Opens a handle for the current service. The handle must be closed with
        /// a call to NativeMethods.CloseServiceHandle().
        /// </devdoc>
        private IntPtr GetServiceHandle(int desiredAccess) {            
            IntPtr serviceManagerHandle = GetDataBaseHandle();

            IntPtr serviceHandle = UnsafeNativeMethods.OpenService(serviceManagerHandle, ServiceName, desiredAccess);
            if (serviceHandle == (IntPtr)0) {
                Exception inner = CreateSafeWin32Exception();                                                                     
                throw new InvalidOperationException(Res.GetString(Res.OpenService, ServiceName, MachineName), inner);
            }

            return serviceHandle;
        }

        /// <include file='doc\ServiceController.uex' path='docs/doc[@for="ServiceController.GetServices"]/*' />
        /// <devdoc>
        ///     Gets the services (not including device-driver services) on the local machine.
        /// </devdoc>
        public static ServiceController[] GetServices() {
            return GetServices(".");
        }

        /// <include file='doc\ServiceController.uex' path='docs/doc[@for="ServiceController.GetServices1"]/*' />
        /// <devdoc>
        ///     Gets the services (not including device-driver services) on the machine specified.
        /// </devdoc>
        public static ServiceController[] GetServices(string machineName) {
            return GetServicesOfType(machineName, NativeMethods.SERVICE_TYPE_WIN32);
        }

        
        /// <include file='doc\ServiceController.uex' path='docs/doc[@for="ServiceController.GetServicesInGroup"]/*' />
        /// <devdoc>
        /// Helper function for DependentServices.
        /// </devdoc>
        private NativeMethods.ENUM_SERVICE_STATUS_PROCESS[] GetServicesInGroup(string machineName, string group) {
            GetDataBaseHandle();           

            // Allocate memory
            //
            IntPtr memory = (IntPtr)0;
            int bytesNeeded;
            int servicesReturned;
            int resumeHandle = 0;

            UnsafeNativeMethods.EnumServicesStatusEx(serviceManagerHandle, NativeMethods.SC_ENUM_PROCESS_INFO, NativeMethods.SERVICE_TYPE_WIN32, NativeMethods.STATUS_ALL,
                                             (IntPtr)0, 0, out bytesNeeded, out servicesReturned, ref resumeHandle, group);

            memory = Marshal.AllocHGlobal((IntPtr)bytesNeeded);

            NativeMethods.ENUM_SERVICE_STATUS_PROCESS[] services;

            try {
                //
                // Get the set of services
                //
                UnsafeNativeMethods.EnumServicesStatusEx(serviceManagerHandle, NativeMethods.SC_ENUM_PROCESS_INFO, NativeMethods.SERVICE_TYPE_WIN32, NativeMethods.STATUS_ALL,
                                                 memory, bytesNeeded, out bytesNeeded, out servicesReturned, ref resumeHandle, group);
    
                int count = servicesReturned;
    
                //
                // Go through the block of memory it returned to us
                //
                services = new NativeMethods.ENUM_SERVICE_STATUS_PROCESS[count];
                for (int i = 0; i < count; i++) {
                    IntPtr structPtr = (IntPtr)((long)memory + (i * Marshal.SizeOf(typeof(NativeMethods.ENUM_SERVICE_STATUS_PROCESS))));
                    NativeMethods.ENUM_SERVICE_STATUS_PROCESS status = new NativeMethods.ENUM_SERVICE_STATUS_PROCESS();
                    Marshal.PtrToStructure(structPtr, status);   
                    services[i] = status;
                }
            }
            finally {
                //
                // Free the memory
                //
                Marshal.FreeHGlobal(memory);
            }

            return services;
        }
        

        /// <include file='doc\ServiceController.uex' path='docs/doc[@for="ServiceController.GetServicesOfType"]/*' />
        /// <devdoc>
        /// Helper function for GetDevices and GetServices.
        /// </devdoc>
        private static ServiceController[] GetServicesOfType(string machineName, int serviceType) {
            if (!SyntaxCheck.CheckMachineName(machineName))
                throw new ArgumentException(Res.GetString(Res.BadMachineName, machineName));
                    
            ServiceControllerPermission permission = new ServiceControllerPermission(
                                                                                            ServiceControllerPermissionAccess.Browse, machineName, "*");
            permission.Demand();                                                                                            
            
            
            //Need to check the environment before trying to access service database
            CheckEnvironment();
            
            //
            // Open the services database
            //
            IntPtr databaseHandle = (IntPtr)0;

            if (machineName.Equals(".") || machineName.Length == 0)
                databaseHandle = SafeNativeMethods.OpenSCManager(null, null, NativeMethods.SC_MANAGER_ENUMERATE_SERVICE);
            else
                databaseHandle = SafeNativeMethods.OpenSCManager(machineName, null, NativeMethods.SC_MANAGER_ENUMERATE_SERVICE);

            if (databaseHandle == (IntPtr)0)
                throw new InvalidOperationException(Res.GetString(Res.OpenSC, machineName));

            //
            // Allocate memory
            //
            IntPtr memory = (IntPtr)0;
            int bytesNeeded;
            int servicesReturned;
            int resumeHandle = 0;

            UnsafeNativeMethods.EnumServicesStatus(databaseHandle, serviceType , NativeMethods.STATUS_ALL,
                                             (IntPtr)0, 0, out bytesNeeded, out servicesReturned, ref resumeHandle);

            memory = Marshal.AllocHGlobal((IntPtr)bytesNeeded);

            ServiceController[] services;

            try {
    
                //
                // Get the set of services
                //
                UnsafeNativeMethods.EnumServicesStatus(databaseHandle, serviceType, NativeMethods.STATUS_ALL,
                                                 memory, bytesNeeded, out bytesNeeded, out servicesReturned, ref resumeHandle);
    
                int count = servicesReturned;
    
                // close the services database
                SafeNativeMethods.CloseServiceHandle(databaseHandle);
    
                //
                // Go through the block of memory it returned to us
                //
                services = new ServiceController[count];
                for (int i = 0; i < count; i++) {
                    IntPtr structPtr = (IntPtr)((long)memory + (i * Marshal.SizeOf(typeof(NativeMethods.ENUM_SERVICE_STATUS))));
                    NativeMethods.ENUM_SERVICE_STATUS status = new NativeMethods.ENUM_SERVICE_STATUS();
                    Marshal.PtrToStructure(structPtr, status);    
                    services[i] = new ServiceController(machineName, status);
                }
            }
            finally {
                //
                // Free the memory
                //
                Marshal.FreeHGlobal(memory);
            }


            return services;
        }

        /// <include file='doc\ServiceController.uex' path='docs/doc[@for="ServiceController.Pause"]/*' />
        /// <devdoc>
        ///     Suspends a service's operation.
        /// </devdoc>
        public unsafe void Pause() {
            if (!controlGranted) {
                ServiceControllerPermission permission = new ServiceControllerPermission(
                                                                                        ServiceControllerPermissionAccess.Control,  machineName, ServiceName);
                permission.Demand();                                                                                            
                controlGranted = true;                        
            }                    
                    
            IntPtr serviceHandle = GetServiceHandle(NativeMethods.SERVICE_PAUSE_CONTINUE);
            try {
                NativeMethods.SERVICE_STATUS status = new NativeMethods.SERVICE_STATUS();
                bool result = UnsafeNativeMethods.ControlService(serviceHandle,  NativeMethods.CONTROL_PAUSE, &status);
                if (!result) {
                    Exception inner = CreateSafeWin32Exception();                                           
                    throw new InvalidOperationException(Res.GetString(Res.PauseService, ServiceName, MachineName), inner);
                }
            }
            finally {
                SafeNativeMethods.CloseServiceHandle(serviceHandle);
            }
        }

        /// <include file='doc\ServiceController.uex' path='docs/doc[@for="ServiceController.Continue"]/*' />
        /// <devdoc>
        ///     Continues a service after it has been paused.
        /// </devdoc>
        public unsafe void Continue() {
            if (!controlGranted) {
                ServiceControllerPermission permission = new ServiceControllerPermission(
                                                                                        ServiceControllerPermissionAccess.Control,  machineName, ServiceName);
                permission.Demand();                                                                                            
                controlGranted = true;                        
            }                    
        
            IntPtr serviceHandle = GetServiceHandle(NativeMethods.SERVICE_PAUSE_CONTINUE);
            try {
                NativeMethods.SERVICE_STATUS status = new NativeMethods.SERVICE_STATUS();
                bool result = UnsafeNativeMethods.ControlService(serviceHandle,  NativeMethods.CONTROL_CONTINUE, &status);
                if (!result) {
                    Exception inner = CreateSafeWin32Exception();                                           
                    throw new InvalidOperationException(Res.GetString(Res.ResumeService, ServiceName, MachineName), inner);
                }
            }
            finally {
                SafeNativeMethods.CloseServiceHandle(serviceHandle);
            }
        }

        /// <include file='doc\ServiceController.uex' path='docs/doc[@for="ServiceController.ExecuteCommand"]/*' />
        /// <devdoc>
        ///     Executes a custom command on a Service
        /// </devdoc>
        public unsafe void ExecuteCommand(int command) {
            if (!controlGranted) {
                ServiceControllerPermission permission = new ServiceControllerPermission(
                                                                                        ServiceControllerPermissionAccess.Control,  machineName, ServiceName);
                permission.Demand();                                                                                            
                controlGranted = true;                        
            }                    
            
            IntPtr serviceHandle = GetServiceHandle(NativeMethods.SERVICE_USER_DEFINED_CONTROL);
            try {
                NativeMethods.SERVICE_STATUS status = new NativeMethods.SERVICE_STATUS();
                bool result = UnsafeNativeMethods.ControlService(serviceHandle,  command, &status);
                if (!result) {
                    Exception inner = CreateSafeWin32Exception();                                           
                    throw new InvalidOperationException(Res.GetString(Res.ControlService, ServiceName, MachineName), inner);
                }
            }
            finally {
                SafeNativeMethods.CloseServiceHandle(serviceHandle);
            }
        }

        /// <include file='doc\ServiceController.uex' path='docs/doc[@for="ServiceController.Refresh"]/*' />
        /// <devdoc>
        /// Refreshes all property values.
        /// </devdoc>
        public void Refresh() {
            statusGenerated = false;
            dependentServices = null;
            servicesDependedOn = null;
        }

        /// <include file='doc\ServiceController.uex' path='docs/doc[@for="ServiceController.Start"]/*' />
        /// <devdoc>
        /// Starts the service.
        /// </devdoc>
        public void Start() {
            Start(new string[0]);
        }

        /// <include file='doc\ServiceController.uex' path='docs/doc[@for="ServiceController.Start1"]/*' />
        /// <devdoc>
        ///     Starts a service in the machine specified.
        /// </devdoc>
        public void Start(string[] args) {
            if (!controlGranted) {
                ServiceControllerPermission permission = new ServiceControllerPermission(
                                                                                        ServiceControllerPermissionAccess.Control,  machineName, ServiceName);
                permission.Demand();                                                                                            
                controlGranted = true;                        
            }                    
            
            IntPtr serviceHandle = GetServiceHandle(NativeMethods.SERVICE_START);

            try {
                IntPtr[] argPtrs = new IntPtr[args.Length];
                int i = 0;
                try {
                    for (i = 0; i < args.Length; i++)
                        argPtrs[i] = Marshal.StringToHGlobalUni(args[i]);
                }
                catch (Exception e) {
                    for (int j = 0; j < i; j++)
                        Marshal.FreeHGlobal(argPtrs[i]);
                    throw e;
                }

                GCHandle argPtrsHandle = new GCHandle();
                try {
                    argPtrsHandle = GCHandle.Alloc(argPtrs, GCHandleType.Pinned);
                    bool result = UnsafeNativeMethods.StartService(serviceHandle, args.Length, (INTPTR_INTPTRCAST)argPtrsHandle.AddrOfPinnedObject());
                    if (!result) {
                        Exception inner = CreateSafeWin32Exception();                                        
                        throw new InvalidOperationException(Res.GetString(Res.CannotStart, ServiceName, MachineName), inner);
                    }                        
                }
                finally {
                    for (i = 0; i < args.Length; i++)
                        Marshal.FreeHGlobal(argPtrs[i]);
                    if (argPtrsHandle.IsAllocated)
                        argPtrsHandle.Free();
                }
            }
            finally {
                SafeNativeMethods.CloseServiceHandle(serviceHandle);
            }
        }

        /// <include file='doc\ServiceController.uex' path='docs/doc[@for="ServiceController.Stop"]/*' />
        /// <devdoc>
        ///     Stops the service. If any other services depend on this one for operation,
        ///     they will be stopped first. The DependentServices property lists this set
        ///     of services.
        /// </devdoc>
        public unsafe void Stop() {
            if (!controlGranted) {
                ServiceControllerPermission permission = new ServiceControllerPermission(
                                                                                        ServiceControllerPermissionAccess.Control,  machineName, ServiceName);
                permission.Demand();                                                                                            
                controlGranted = true;                        
            }                                                
        
            IntPtr serviceHandle = GetServiceHandle(NativeMethods.SERVICE_STOP);

            try {
                // Before stopping this service, stop all the dependent services that are running.
                // (It's OK not to cache the result of getting the DependentServices property because it caches on its own.)
                for (int i = 0; i < DependentServices.Length; i++) {
                    if (DependentServices[i].Status != ServiceControllerStatus.Stopped) {
                        DependentServices[i].Stop();
                        DependentServices[i].WaitForStatus(ServiceControllerStatus.Stopped, new TimeSpan(0, 0, 30));
                    }
                }

                NativeMethods.SERVICE_STATUS status = new NativeMethods.SERVICE_STATUS();
                bool result = UnsafeNativeMethods.ControlService(serviceHandle,  NativeMethods.CONTROL_STOP, &status);
                if (!result) {
                    Exception inner = CreateSafeWin32Exception();                                        
                    throw new InvalidOperationException(Res.GetString(Res.StopService, ServiceName, MachineName), inner);
                }
            }
            finally {
                SafeNativeMethods.CloseServiceHandle(serviceHandle);
            }
        }

        
        internal static bool ValidServiceName(string serviceName) {
            if (serviceName == null)
                return false;

            //not too long
            if (serviceName.Length > ServiceBase.MaxNameLength)
                return false;
            
            //no slashes or backslash allowed
            foreach (char c in serviceName.ToCharArray()) {                
                if ((c == '\\') || (c == '/'))
                    return false;
            }
                                
            return true;              
        }

        /// <include file='doc\ServiceController.uex' path='docs/doc[@for="ServiceController.WaitForStatus"]/*' />
        /// <devdoc>
        /// Waits infinitely until the service has reached the given status.
        /// </devdoc>
        public void WaitForStatus(ServiceControllerStatus desiredStatus) {
            WaitForStatus(desiredStatus, TimeSpan.MaxValue);
        }

        /// <include file='doc\ServiceController.uex' path='docs/doc[@for="ServiceController.WaitForStatus1"]/*' />
        /// <devdoc>
        /// Waits until the service has reached the given status or until the specified time
        /// has expired
        /// </devdoc>
        public void WaitForStatus(ServiceControllerStatus desiredStatus, TimeSpan timeout) {
            if (!Enum.IsDefined(typeof(ServiceControllerStatus), desiredStatus)) 
                    throw new InvalidEnumArgumentException("desiredStatus", (int)desiredStatus, typeof(ServiceControllerStatus));
                    
            DateTime start = DateTime.UtcNow;
            Refresh();
            while (Status != desiredStatus) {
                if (DateTime.UtcNow - start > timeout) 
                    throw new TimeoutException(Res.GetString(Res.Timeout));
                                    
                Thread.Sleep(250);
                Refresh();
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\services\servproc\system\serviceprocess\servicecontrollerpermissionentrycollection.cs ===
//----------------------------------------------------
// <copyright file="ServiceControllerPermissionEntryCollection.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.ServiceProcess {
    using System.Security.Permissions;
    using System.Collections;

    /// <include file='doc\ServiceControllerPermissionEntryCollection.uex' path='docs/doc[@for="ServiceControllerPermissionEntryCollection"]/*' />
    [
    Serializable()
    ]
    public class ServiceControllerPermissionEntryCollection : CollectionBase {
        ServiceControllerPermission owner;
        
        /// <include file='doc\ServiceControllerPermissionEntryCollection.uex' path='docs/doc[@for="ServiceControllerPermissionEntryCollection.ServiceControllerPermissionEntryCollection"]/*' />        
        ///<internalonly/>   
        internal ServiceControllerPermissionEntryCollection(ServiceControllerPermission owner, ResourcePermissionBaseEntry[] entries) {
            this.owner = owner;
            for (int index = 0; index < entries.Length; ++index)
                this.InnerList.Add(new ServiceControllerPermissionEntry(entries[index]));
        }                                                                                                             
                                                                                                            
        /// <include file='doc\ServiceControllerPermissionEntryCollection.uex' path='docs/doc[@for="ServiceControllerPermissionEntryCollection.this"]/*' />
        public ServiceControllerPermissionEntry this[int index] {
            get {
                return (ServiceControllerPermissionEntry)List[index];
            }
            set {
                List[index] = value;
            }
            
        }
        
        /// <include file='doc\ServiceControllerPermissionEntryCollection.uex' path='docs/doc[@for="ServiceControllerPermissionEntryCollection.Add"]/*' />        
        public int Add(ServiceControllerPermissionEntry value) {   
            return List.Add(value);
        }
        
        /// <include file='doc\ServiceControllerPermissionEntryCollection.uex' path='docs/doc[@for="ServiceControllerPermissionEntryCollection.AddRange"]/*' />        
        public void AddRange(ServiceControllerPermissionEntry[] value) {            
            if (value == null) {
                throw new ArgumentNullException("value");
            }
            for (int i = 0; ((i) < (value.Length)); i = ((i) + (1))) {
                this.Add(value[i]);
            }
        }
    
        /// <include file='doc\ServiceControllerPermissionEntryCollection.uex' path='docs/doc[@for="ServiceControllerPermissionEntryCollection.AddRange1"]/*' />        
        public void AddRange(ServiceControllerPermissionEntryCollection value) {            
            if (value == null) {
                throw new ArgumentNullException("value");
            }
            int currentCount = value.Count;
            for (int i = 0; i < currentCount; i = ((i) + (1))) {
                this.Add(value[i]);
            }
        }         
    
        /// <include file='doc\ServiceControllerPermissionEntryCollection.uex' path='docs/doc[@for="ServiceControllerPermissionEntryCollection.Contains"]/*' />        
        public bool Contains(ServiceControllerPermissionEntry value) {            
            return List.Contains(value);
        }
    
        /// <include file='doc\ServiceControllerPermissionEntryCollection.uex' path='docs/doc[@for="ServiceControllerPermissionEntryCollection.CopyTo"]/*' />        
        public void CopyTo(ServiceControllerPermissionEntry[] array, int index) {            
            List.CopyTo(array, index);
        }
    
        /// <include file='doc\ServiceControllerPermissionEntryCollection.uex' path='docs/doc[@for="ServiceControllerPermissionEntryCollection.IndexOf"]/*' />        
        public int IndexOf(ServiceControllerPermissionEntry value) {            
            return List.IndexOf(value);
        }
        
        /// <include file='doc\ServiceControllerPermissionEntryCollection.uex' path='docs/doc[@for="ServiceControllerPermissionEntryCollection.Insert"]/*' />        
        public void Insert(int index, ServiceControllerPermissionEntry value) {            
            List.Insert(index, value);
        }
                
        /// <include file='doc\ServiceControllerPermissionEntryCollection.uex' path='docs/doc[@for="ServiceControllerPermissionEntryCollection.Remove"]/*' />        
        public void Remove(ServiceControllerPermissionEntry value) {
            List.Remove(value);                     
        }
        
        /// <include file='doc\ServiceControllerPermissionEntryCollection.uex' path='docs/doc[@for="ServiceControllerPermissionEntryCollection.OnClear"]/*' />        
        ///<internalonly/>                          
        protected override void OnClear() {   
            this.owner.Clear();         
        }
        
        /// <include file='doc\ServiceControllerPermissionEntryCollection.uex' path='docs/doc[@for="ServiceControllerPermissionEntryCollection.OnInsert"]/*' />        
        ///<internalonly/>                          
        protected override void OnInsert(int index, object value) {        
            this.owner.AddPermissionAccess((ServiceControllerPermissionEntry)value);
        }
        
        /// <include file='doc\ServiceControllerPermissionEntryCollection.uex' path='docs/doc[@for="ServiceControllerPermissionEntryCollection.OnRemove"]/*' />
        ///<internalonly/>                          
        protected override void OnRemove(int index, object value) {
            this.owner.RemovePermissionAccess((ServiceControllerPermissionEntry)value);
        }
                 
        /// <include file='doc\ServiceControllerPermissionEntryCollection.uex' path='docs/doc[@for="ServiceControllerPermissionEntryCollection.OnSet"]/*' />
        ///<internalonly/>                          
        protected override void OnSet(int index, object oldValue, object newValue) {     
            this.owner.RemovePermissionAccess((ServiceControllerPermissionEntry)oldValue);
            this.owner.AddPermissionAccess((ServiceControllerPermissionEntry)newValue);       
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\services\servproc\system\serviceprocess\servicecontrollerpermission.cs ===
//------------------------------------------------------------------------------
// <copyright file="ServiceControllerPermission.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.ServiceProcess {
    using System;    
    using System.Security.Permissions;
                                                                        
    /// <include file='doc\ServiceControllerPermission.uex' path='docs/doc[@for="ServiceControllerPermission"]/*' />
    /// <devdoc>
    ///    <para>[To be supplied.]</para>
    /// </devdoc>
    [
    Serializable()
    ]
    public sealed class ServiceControllerPermission : ResourcePermissionBase {      
         private ServiceControllerPermissionEntryCollection innerCollection;
        
        /// <include file='doc\ServiceControllerPermission.uex' path='docs/doc[@for="ServiceControllerPermission.ServiceControllerPermission"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public ServiceControllerPermission() {
            SetNames();
        }                                                                
        
        /// <include file='doc\ServiceControllerPermission.uex' path='docs/doc[@for="ServiceControllerPermission.ServiceControllerPermission1"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public ServiceControllerPermission(PermissionState state) 
        : base(state) {
            SetNames();
        }
        
        /// <include file='doc\ServiceControllerPermission.uex' path='docs/doc[@for="ServiceControllerPermission.ServiceControllerPermission2"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public ServiceControllerPermission(ServiceControllerPermissionAccess permissionAccess, string machineName, string serviceName) {            
            SetNames();
            this.AddPermissionAccess(new ServiceControllerPermissionEntry(permissionAccess, machineName, serviceName));              
        }         
         
        /// <include file='doc\ServiceControllerPermission.uex' path='docs/doc[@for="ServiceControllerPermission.ServiceControllerPermission3"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public ServiceControllerPermission(ServiceControllerPermissionEntry[] permissionAccessEntries) {            
            if (permissionAccessEntries == null)
                throw new ArgumentNullException("permissionAccessEntries");
                
            SetNames();            
            for (int index = 0; index < permissionAccessEntries.Length; ++index)
                this.AddPermissionAccess(permissionAccessEntries[index]);                          
        }

        /// <include file='doc\ServiceControllerPermission.uex' path='docs/doc[@for="ServiceControllerPermission.PermissionEntries"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>                
        public ServiceControllerPermissionEntryCollection PermissionEntries {
            get {
                if (this.innerCollection == null)                     
                    this.innerCollection = new ServiceControllerPermissionEntryCollection(this, base.GetPermissionEntries()); 
                                                                           
                return this.innerCollection;                                                               
            }
        }

        /// <include file='doc\ServiceControllerPermission.uex' path='docs/doc[@for="ServiceControllerPermission.AddPermissionAccess"]/*' />                
        ///<internalonly/> 
        internal void AddPermissionAccess(ServiceControllerPermissionEntry entry) {
            base.AddPermissionAccess(entry.GetBaseEntry());
        }
        
        /// <include file='doc\ServiceControllerPermission.uex' path='docs/doc[@for="ServiceControllerPermission.Clear"]/*' />                        
        ///<internalonly/> 
        internal new void Clear() {
            base.Clear();
        }

        /// <include file='doc\ServiceControllerPermission.uex' path='docs/doc[@for="ServiceControllerPermission.RemovePermissionAccess"]/*' />                                                  
        ///<internalonly/> 
        internal void RemovePermissionAccess(ServiceControllerPermissionEntry entry) {
            base.RemovePermissionAccess(entry.GetBaseEntry());
        }                         
        
        private void SetNames() {
            this.PermissionAccessType = typeof(ServiceControllerPermissionAccess);            
            this.TagNames = new string[]{"Machine", "Service"};
        }    
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\services\servproc\system\serviceprocess\servicebase.cs ===
//------------------------------------------------------------------------------
// <copyright file="ServiceBase.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

/*
 */
namespace System.ServiceProcess {
    using System.Runtime.InteropServices;
    using System.ComponentModel;
    using System.Diagnostics;
    using System;    
    using System.Threading;    
    using System.IO;    
    using System.ServiceProcess;  
    using System.Reflection;

    /// <include file='doc\ServiceBase.uex' path='docs/doc[@for="ServiceBase"]/*' />
    /// <devdoc>
    /// <para>Provides a base class for a service that will exist as part of a service application. <see cref='System.ServiceProcess.ServiceBase'/>
    /// must
    /// be derived when creating a new service class.</para>
    /// </devdoc>
    [
    InstallerType(typeof(ServiceProcessInstaller)),
    Designer("Microsoft.VisualStudio.Install.UserNTServiceDesigner, " + AssemblyRef.MicrosoftVisualStudio, "System.ComponentModel.Design.IRootDesigner")
    ]
    public class ServiceBase : Component {
        private NativeMethods.SERVICE_STATUS status =  new NativeMethods.SERVICE_STATUS();
        private IntPtr statusHandle;
        private NativeMethods.ServiceControlCallback commandCallback;
        private NativeMethods.ServiceControlCallbackEx commandCallbackEx;
        private NativeMethods.ServiceMainCallback mainCallback;
        private IntPtr handleName;
        private ManualResetEvent startCompletedSignal;

        private int acceptedCommands;
        private bool autoLog;
        private string serviceName;
        private EventLog eventLog;
        private bool nameFrozen; // set to true once we've started running and ServiceName can't be changed any more.        
        private bool commandPropsFrozen; // set to true once we've use the Can... properties.
        private bool disposed;

        /// <include file='doc\ServiceBase.uex' path='docs/doc[@for="ServiceBase.MaxNameLength"]/*' />        
        /// <devdoc>
        ///    <para>
        ///       Indicates the maximum size for a service name.
        ///    </para>
        /// </devdoc>
        public const int MaxNameLength = 80;

        /// <include file='doc\ServiceBase.uex' path='docs/doc[@for="ServiceBase.ServiceBase"]/*' />
        /// <devdoc>
        /// <para>Creates a new instance of the <see cref='System.ServiceProcess.ServiceBase()'/> class.</para>
        /// </devdoc>
        public ServiceBase() {
            acceptedCommands = NativeMethods.ACCEPT_STOP;
            AutoLog = true;
            ServiceName = "";
        }

        /// <include file='doc\ServiceBase.uex' path='docs/doc[@for="ServiceBase.AutoLog"]/*' />
        /// <devdoc>
        ///    <para> Indicates whether to report Start, Stop, Pause,
        ///       and Continue commands
        ///       in
        ///       the
        ///       event
        ///       log.</para>
        /// </devdoc>
        [
        DefaultValue(true),
        ServiceProcessDescription(Res.SBAutoLog)
        ]
        public bool AutoLog {
            get {
                return autoLog;
            }
            set {
                autoLog = value;
            }
        }

         
        /// <include file='doc\ServiceBase.uex' path='docs/doc[@for="ServiceBase.CanHandlePowerEvent"]/*' />
        /// <devdoc>
        ///    <para> 
        ///         Indicates whether the service can be handle notifications on
        ///         computer power status changes.
        ///    </para>
        /// </devdoc>                      
        [DefaultValue(false)]
        public bool CanHandlePowerEvent {
            get {
                return (acceptedCommands & NativeMethods.ACCEPT_POWEREVENT) != 0;
            }
            set {
                if (commandPropsFrozen)
                    throw new InvalidOperationException(Res.GetString(Res.CannotChangeProperties));

                if (value)
                    acceptedCommands |= NativeMethods.ACCEPT_POWEREVENT;
                else
                    acceptedCommands &= ~NativeMethods.ACCEPT_POWEREVENT;
            }
        }
         
        /// <include file='doc\ServiceBase.uex' path='docs/doc[@for="ServiceBase.CanPauseAndContinue"]/*' />
        /// <devdoc>
        ///    <para> Indicates whether the service can be paused
        ///       and resumed.</para>
        /// </devdoc>
        [DefaultValue(false)]
        public bool CanPauseAndContinue {
            get {
                return(acceptedCommands & NativeMethods.ACCEPT_PAUSE_CONTINUE) != 0;
            }
            set {
                if (commandPropsFrozen)
                    throw new InvalidOperationException(Res.GetString(Res.CannotChangeProperties));

                if (value)
                    acceptedCommands |= NativeMethods.ACCEPT_PAUSE_CONTINUE;
                else
                    acceptedCommands &= ~NativeMethods.ACCEPT_PAUSE_CONTINUE;
            }
        }

        /// <include file='doc\ServiceBase.uex' path='docs/doc[@for="ServiceBase.CanShutdown"]/*' />
        /// <devdoc>
        ///    <para> Indicates whether the service should be notified when
        ///       the system is shutting down.</para>
        /// </devdoc>
        [DefaultValue(false)]
        public bool CanShutdown {
            get {
                return (acceptedCommands & NativeMethods.ACCEPT_SHUTDOWN) != 0;
            }
            set {
                if (commandPropsFrozen)
                    throw new InvalidOperationException(Res.GetString(Res.CannotChangeProperties));

                if (value)
                    acceptedCommands |= NativeMethods.ACCEPT_SHUTDOWN;
                else
                    acceptedCommands &= ~NativeMethods.ACCEPT_SHUTDOWN;
            }
        }

        /// <include file='doc\ServiceBase.uex' path='docs/doc[@for="ServiceBase.CanStop"]/*' />
        /// <devdoc>
        ///    <para> Indicates whether the service can be
        ///       stopped once it has started.</para>
        /// </devdoc>
        [DefaultValue(true)]
        public bool CanStop {
            get {
                return(acceptedCommands & NativeMethods.ACCEPT_STOP) != 0;
            }
            set {
                if (commandPropsFrozen)
                    throw new InvalidOperationException(Res.GetString(Res.CannotChangeProperties));

                if (value)
                    acceptedCommands |= NativeMethods.ACCEPT_STOP;
                else
                    acceptedCommands &= ~NativeMethods.ACCEPT_STOP;
            }
        }

        /// <include file='doc\ServiceBase.uex' path='docs/doc[@for="ServiceBase.EventLog"]/*' />
        /// <devdoc>
        /// <para>Indicates an <see cref='System.Diagnostics.EventLog'/> you can use to write noficiation of service command calls, such as
        ///    Start and Stop, to the Application event log. This property is read-only.</para>
        /// </devdoc>
        [Browsable(false), DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        public virtual EventLog EventLog {
            get {
                if (eventLog == null) {
                    eventLog = new EventLog();
                    eventLog.Source = ServiceName;
                    eventLog.Log = "Application";
                }
                return eventLog;
            }
        }

        /// <include file='doc\ServiceBase.uex' path='docs/doc[@for="ServiceBase.ServiceName"]/*' />
        /// <devdoc>
        ///    <para> Indicates the short name used to identify the service to the system.</para>
        /// </devdoc>
        [
        ServiceProcessDescription(Res.SBServiceName),
        TypeConverter("System.Diagnostics.Design.StringValueConverter, " + AssemblyRef.SystemDesign)
        ]
        public string ServiceName {
            get {
                return serviceName;
            }
            set {
                if (nameFrozen)
                    throw new InvalidOperationException(Res.GetString(Res.CannotChangeName));
                    
                if (!ServiceController.ValidServiceName(value)) 
                    throw new ArgumentException(Res.GetString(Res.ServiceName, value, ServiceBase.MaxNameLength.ToString()));

                    
                serviceName = value;
            }
        }

        /// <include file='doc\ServiceBase.uex' path='docs/doc[@for="ServiceBase.Dispose"]/*' />
        /// <devdoc>
        ///    <para>Disposes of the resources (other than memory) used by 
        ///       the <see cref='System.ServiceProcess.ServiceBase'/>
        ///       .</para>
        /// </devdoc>
        protected override void Dispose(bool disposing) {
            if (this.handleName != (IntPtr)0) {
                Marshal.FreeHGlobal(this.handleName);
                this.handleName = (IntPtr)0;
            }
            nameFrozen = false;
            commandPropsFrozen = false;
            this.disposed = true;
            base.Dispose(disposing);
        }
                                                  
        /// <include file='doc\ServiceBase.uex' path='docs/doc[@for="ServiceBase.OnContinue"]/*' />
        /// <devdoc>
        ///    <para> When implemented in a
        ///       derived class,
        ///       executes when a Continue command is sent to the service
        ///       by the
        ///       Service Control Manager. Specifies the actions to take when a
        ///       service resumes normal functioning after being paused.</para>
        /// </devdoc>
        protected virtual void OnContinue() {
        }

        /// <include file='doc\ServiceBase.uex' path='docs/doc[@for="ServiceBase.OnPause"]/*' />
        /// <devdoc>
        ///    <para> When implemented in a
        ///       derived class, executes when a Pause command is sent
        ///       to
        ///       the service by the Service Control Manager. Specifies the
        ///       actions to take when a service pauses.</para>
        /// </devdoc>
        protected virtual void OnPause() {
        }
    
    
        /// <include file='doc\ServiceBase.uex' path='docs/doc[@for="ServiceBase.OnPowerEvent"]/*' />
        /// <devdoc>
        ///    <para> 
        ///         When implemented in a derived class, executes when the computer's
        ///         power status has changed.
        ///    </para> 
        /// </devdoc>
        protected virtual bool OnPowerEvent(PowerBroadcastStatus powerStatus) {
            return true;
        }
                                                                                                                    
        /// <include file='doc\ServiceBase.uex' path='docs/doc[@for="ServiceBase.OnShutdown"]/*' />
        /// <devdoc>
        ///    <para>When implemented in a derived class,
        ///       executes when the system is shutting down.
        ///       Specifies what should
        ///       happen just prior
        ///       to the system shutting down.</para>
        /// </devdoc>
        protected virtual void OnShutdown() {
        }

        /// <include file='doc\ServiceBase.uex' path='docs/doc[@for="ServiceBase.OnStart"]/*' />
        /// <devdoc>
        ///    <para> When implemented in a
        ///       derived class, executes when a Start command is sent
        ///       to the service by the Service
        ///       Control Manager. Specifies the actions to take when the service starts.</para>
        ///    <note type="rnotes">
        ///       Tech review note:
        ///       except that the SCM does not allow passing arguments, so this overload will
        ///       never be called by the SCM in the current version. Question: Is this true even
        ///       when the string array is empty? What should we say, then. Can
        ///       a ServiceBase derived class only be called programmatically? Will
        ///       OnStart never be called if you use the SCM to start the service? What about
        ///       services that start automatically at boot-up?
        ///    </note>
        /// </devdoc>
        protected virtual void OnStart(string[] args) {
        }

        /// <include file='doc\ServiceBase.uex' path='docs/doc[@for="ServiceBase.OnStop"]/*' />
        /// <devdoc>
        ///    <para> When implemented in a
        ///       derived class, executes when a Stop command is sent to the
        ///       service by the Service Control Manager. Specifies the actions to take when a
        ///       service stops
        ///       running.</para>
        /// </devdoc>
        protected virtual void OnStop() {
        }

        /// <include file='doc\ServiceBase.uex' path='docs/doc[@for="ServiceBase.OnCustomCommand"]/*' />
        /// <devdoc>
        /// <para>When implemented in a derived class, <see cref='System.ServiceProcess.ServiceBase.OnCustomCommand'/>
        /// executes when a custom command is passed to
        /// the service. Specifies the actions to take when
        /// a command with the specified parameter value occurs.</para>
        /// <note type="rnotes">
        ///    Previously had "Passed to the
        ///    service by
        ///    the SCM", but the SCM doesn't pass custom commands. Do we want to indicate an
        ///    agent here? Would it be the ServiceController, or is there another way to pass
        ///    the int into the service? I thought that the SCM did pass it in, but
        ///    otherwise ignored it since it was an int it doesn't recognize. I was under the
        ///    impression that the difference was that the SCM didn't have default processing, so
        ///    it transmitted it without examining it or trying to performs its own
        ///    default behavior on it. Please correct where my understanding is wrong in the
        ///    second paragraph below--what, if any, contact does the SCM have with a
        ///    custom command?
        /// </note>
        /// </devdoc>
        protected virtual void OnCustomCommand(int command) {
        }

        /// <include file='doc\ServiceBase.uex' path='docs/doc[@for="ServiceBase.Run"]/*' />
        /// <devdoc>
        ///    <para>Provides the main entry point for an executable that 
        ///       contains multiple associated services. Loads the specified services into memory so they can be
        ///       started.</para>
        /// </devdoc>
        public static void Run(ServiceBase[] services) {
            if (services == null || services.Length == 0)
                throw new ArgumentException(Res.GetString(Res.NoServices));

            // check if we're on an NT OS
            if (Environment.OSVersion.Platform != PlatformID.Win32NT) {
                // if not NT, put up a message box and exit.
                string cantRunOnWin9x = Res.GetString(Res.CantRunOnWin9x);
                string cantRunOnWin9xTitle = Res.GetString(Res.CantRunOnWin9xTitle);
                LateBoundMessageBoxShow(cantRunOnWin9x, cantRunOnWin9xTitle);
                return;
            }

            IntPtr entriesPointer = Marshal.AllocHGlobal((IntPtr)((services.Length + 1) * Marshal.SizeOf(typeof(NativeMethods.ENTRY))));
            NativeMethods.ENTRY[] entries = new NativeMethods.ENTRY[services.Length];
            bool multipleServices = services.Length > 1;
            IntPtr structPtr = (IntPtr)0;
            for (int index = 0; index < services.Length; ++ index) {
                entries[index] = services[index].Initialize(multipleServices);
                structPtr = (IntPtr)((long)entriesPointer + Marshal.SizeOf(typeof(NativeMethods.ENTRY)) * index);
                Marshal.StructureToPtr(entries[index], structPtr, true);
            }
 
            NativeMethods.ENTRY lastEntry = new NativeMethods.ENTRY();
            lastEntry.callback = null;
            lastEntry.name = (IntPtr)0;
            structPtr = (IntPtr)((long)entriesPointer + Marshal.SizeOf(typeof(NativeMethods.ENTRY)) * services.Length);
            Marshal.StructureToPtr(lastEntry, structPtr, true);

            // While the service is running, this function will never return. It will return when the service
            // is stopped.
            bool res = NativeMethods.StartServiceCtrlDispatcher(entriesPointer);

            string errorMessage = "";
            if (!res) {
                errorMessage = new Win32Exception().Message;
                // This message will only print out if the exe is run at the command prompt - which is not
                // a valid thing to do.
                string cantStartFromCommandLine = Res.GetString(Res.CantStartFromCommandLine);

                if (LateBoundGetUserInteractive()) {
                    string cantStartFromCommandLineTitle = Res.GetString(Res.CantStartFromCommandLineTitle);
                    LateBoundMessageBoxShow(cantStartFromCommandLine, cantStartFromCommandLineTitle);
                }
                else
                    Console.WriteLine(cantStartFromCommandLine);
            }
            foreach (ServiceBase service in services) {
                service.Dispose();
                if (!res && service.EventLog.Source.Length != 0)
                    service.WriteEventLogEntry(Res.GetString(Res.StartFailed, errorMessage), EventLogEntryType.Error);
            }
        }

        /// <include file='doc\ServiceBase.uex' path='docs/doc[@for="ServiceBase.Run1"]/*' />
        /// <devdoc>
        ///    <para>Provides the main
        ///       entry point for an executable that contains a single
        ///       service. Loads the service into memory so it can be
        ///       started.</para>
        /// </devdoc>
        public static void Run(ServiceBase service) {
            Run(new ServiceBase[] { service});
        }

        /// <include file='doc\ServiceBase.uex' path='docs/doc[@for="ServiceBase.Initialize"]/*' />
        /// <devdoc>
        ///     Starts the service object, creates the objects and
        ///     allocates the memory needed.
        /// </devdoc>
        /// <internalonly/>
        internal NativeMethods.ENTRY Initialize(bool multipleServices) {
            //Cannot register the service with NT service manatger if the object has been disposed, since finalization has been suppressed.
            if (this.disposed)
                throw new ObjectDisposedException(GetType().Name);
                                
            if (multipleServices)
                status.serviceType = NativeMethods.SERVICE_TYPE_WIN32_OWN_PROCESS;
            else
                status.serviceType = NativeMethods.SERVICE_TYPE_WIN32_SHARE_PROCESS;
            status.currentState = NativeMethods.STATE_START_PENDING;
            status.controlsAccepted = 0;
            status.win32ExitCode = 0;
            status.serviceSpecificExitCode = 0;
            status.checkPoint = 0;
            status.waitHint = 0;

            NativeMethods.ENTRY entry = new NativeMethods.ENTRY();
            this.mainCallback = new NativeMethods.ServiceMainCallback(this.ServiceMainCallback);
            this.commandCallback = new NativeMethods.ServiceControlCallback(this.ServiceCommandCallback);
            this.commandCallbackEx = new NativeMethods.ServiceControlCallbackEx(this.ServiceCommandCallbackEx);
            this.handleName = Marshal.StringToHGlobalUni(this.ServiceName);
            nameFrozen = true;
            entry.callback = (Delegate)mainCallback;
            entry.name = this.handleName;
            return entry;
        }

        private static bool LateBoundGetUserInteractive() {
            bool userInteractive = false;
            try {
                Type sysInfo = Type.GetType("System.Windows.Forms.SystemInformation, " + AssemblyRef.SystemWindowsForms);
                userInteractive = (bool)sysInfo.InvokeMember("UserInteractive", BindingFlags.Public | BindingFlags.Static | BindingFlags.GetProperty, null, null, new object[] {});
            }
            catch {
                userInteractive = false;
            }

            return userInteractive;
        }

        private static void LateBoundMessageBoxShow(string message, string title) {
            Type messageBox = Type.GetType("System.Windows.Forms.MessageBox, " + AssemblyRef.SystemWindowsForms);
            messageBox.InvokeMember("Show", BindingFlags.Static | BindingFlags.Public | BindingFlags.InvokeMethod, null, null, new object[] { message, title });            
        }


        private int ServiceCommandCallbackEx(int command, int eventType, IntPtr eventData, IntPtr eventContext) {
            if (command != NativeMethods.CONTROL_POWEREVENT) 
                ServiceCommandCallback(command);
            else {            
                try {
                    PowerBroadcastStatus status = (PowerBroadcastStatus)eventType;
                    bool statusResult = OnPowerEvent(status);                    
                    WriteEventLogEntry(Res.GetString(Res.PowerEventOK));
                        
                    if (!statusResult) 
                        return NativeMethods.BROADCAST_QUERY_DENY;
                }
                catch (Exception e) {
                    WriteEventLogEntry(Res.GetString(Res.PowerEventFailed, e.ToString()), EventLogEntryType.Error);
                }                
            }   
            
            return NativeMethods.NO_ERROR;                                         
        }                                
                                
        /// <include file='doc\ServiceBase.uex' path='docs/doc[@for="ServiceBase.ServiceCommandCallback"]/*' />
        /// <devdoc>
        ///     Command Handler callback is called by NT .
        ///     Need to take specific action in response to each
        ///     command message. There is usually no need to override this method.
        ///     Instead, override OnStart, OnStop, OnCustomCommand, etc.
        /// </devdoc>
        /// <internalonly/>
        private unsafe void ServiceCommandCallback(int command) {
            fixed (NativeMethods.SERVICE_STATUS *pStatus = &status) {
                if (command == NativeMethods.CONTROL_INTERROGATE)
                    NativeMethods.SetServiceStatus(statusHandle, pStatus);
                else if (status.currentState != NativeMethods.STATE_CONTINUE_PENDING &&
                         status.currentState != NativeMethods.STATE_START_PENDING &&
                         status.currentState != NativeMethods.STATE_STOP_PENDING &&
                         status.currentState != NativeMethods.STATE_PAUSE_PENDING) {
                    switch (command) {
                        case NativeMethods.CONTROL_CONTINUE:
                            if (status.currentState == NativeMethods.STATE_PAUSED) {
                                status.currentState = NativeMethods.STATE_CONTINUE_PENDING;
                                NativeMethods.SetServiceStatus(statusHandle, pStatus);
                                try {
                                    OnContinue();
                                    WriteEventLogEntry(Res.GetString(Res.ContinueSuccessful));
                                }
                                catch (Exception e) {
                                    WriteEventLogEntry(Res.GetString(Res.ContinueFailed, e.ToString()), EventLogEntryType.Error);                                        
                                    status.currentState = NativeMethods.STATE_PAUSED;
                                    break;
                                }

                                status.currentState = NativeMethods.STATE_RUNNING;
                                NativeMethods.SetServiceStatus(statusHandle, pStatus);
                            }
                            break;
                        case NativeMethods.CONTROL_PAUSE:
                            if (status.currentState == NativeMethods.STATE_RUNNING) {
                                status.currentState = NativeMethods.STATE_PAUSE_PENDING;
                                NativeMethods.SetServiceStatus(statusHandle, pStatus);
                                try {
                                    OnPause();
                                    WriteEventLogEntry(Res.GetString(Res.PauseSuccessful));
                                }
                                catch (Exception e) {
                                    WriteEventLogEntry(Res.GetString(Res.PauseFailed, e.ToString()), EventLogEntryType.Error);                                        
                                    status.currentState = NativeMethods.STATE_RUNNING;                                        
                                    break;
                                }

                                status.currentState = NativeMethods.STATE_PAUSED;
                                NativeMethods.SetServiceStatus(statusHandle, pStatus);
                            }
                            break;
                        case NativeMethods.CONTROL_STOP:
                            int previousState = status.currentState;
                            if (status.currentState == NativeMethods.STATE_PAUSED || status.currentState == NativeMethods.STATE_RUNNING) {
                                status.currentState = NativeMethods.STATE_STOP_PENDING;
                                NativeMethods.SetServiceStatus(statusHandle, pStatus);
                                try {
                                    OnStop();
                                    WriteEventLogEntry(Res.GetString(Res.StopSuccessful));
                                }
                                catch (Exception e) {
                                    WriteEventLogEntry(Res.GetString(Res.StopFailed, e.ToString()), EventLogEntryType.Error);                                        
                                    status.currentState = previousState;                                        
                                    break;
                                }

                                status.currentState = NativeMethods.STATE_STOPPED;
                                NativeMethods.SetServiceStatus(statusHandle, pStatus);
                            }
                            break;
                        case NativeMethods.CONTROL_SHUTDOWN:
                            try {
                                OnShutdown();
                                WriteEventLogEntry(Res.GetString(Res.ShutdownOK));
                            }
                            catch (Exception e) {
                                WriteEventLogEntry(Res.GetString(Res.ShutdownFailed, e.ToString()), EventLogEntryType.Error);
                            }
                            break;                        
                        default:
                            try {
                                OnCustomCommand(command);
                                 WriteEventLogEntry(Res.GetString(Res.CommandSuccessful));
                            }
                            catch (Exception e) {
                                  WriteEventLogEntry(Res.GetString(Res.CommandFailed, e.ToString()), EventLogEntryType.Error);
                            }
			                break;
                    }
                }
            }
        }

        //Need to execute the start method on a thread pool thread.
        //Most applications will start asynchronous operations in the
        //OnStart method. If such a method is executed in MainCallback
        //thread, the async operations might get canceled immediately.
        private void ServiceQueuedMainCallback(object state) {
            string[] args = (string[])state;
            try {
                OnStart(args);
                WriteEventLogEntry(Res.GetString(Res.StartSuccessful));
                status.currentState = NativeMethods.STATE_RUNNING;
            }
            catch (Exception e) {
                WriteEventLogEntry(Res.GetString(Res.StartFailed, e.ToString()), EventLogEntryType.Error);
                status.currentState = NativeMethods.STATE_STOPPED;
            }
            
            startCompletedSignal.Set();
        }

        /// <include file='doc\ServiceBase.uex' path='docs/doc[@for="ServiceBase.ServiceMainCallback"]/*' />
        /// <devdoc>
        ///     ServiceMain callback is called by NT .
        ///     It is expected that we register the command handler,
        ///     and start the service at this point.
        ///     There is usually no need to override this method.
        /// </devdoc>
        /// <internalonly/>        
        private unsafe void ServiceMainCallback(int argCount, IntPtr argPointer) {
            fixed (NativeMethods.SERVICE_STATUS *pStatus = &status) {
                //Lets read the arguments
                // the last arg is always the service name. We don't want to pass that in.
                string[] args = new string[argCount-1];
                //Skip the size of the strings.
                argPointer = (IntPtr)((long)argPointer + 4*argCount);
                for (int index = 0; index < args.Length; ++ index) {
                    args[index] = Marshal.PtrToStringUni(argPointer);
                    argPointer = (IntPtr)((long)argPointer + (args[index].Length + 1) * 2);
                }

                if (Environment.OSVersion.Version.Major >= 5)
                    statusHandle = NativeMethods.RegisterServiceCtrlHandlerEx(ServiceName, (Delegate)this.commandCallbackEx, (IntPtr)0);
                else
                    statusHandle = NativeMethods.RegisterServiceCtrlHandler(ServiceName, (Delegate)this.commandCallback);
                    
                nameFrozen = true;
                if (statusHandle == (IntPtr)0) {
                    string errorMessage = new Win32Exception().Message;
                    WriteEventLogEntry(Res.GetString(Res.StartFailed, errorMessage), EventLogEntryType.Error);
                }

                status.controlsAccepted = acceptedCommands;
                commandPropsFrozen = true;
                if ((status.controlsAccepted & NativeMethods.ACCEPT_STOP) != 0)
                    status.controlsAccepted = status.controlsAccepted | NativeMethods.ACCEPT_SHUTDOWN;
                if (Environment.OSVersion.Version.Major < 5 )                    
                    status.controlsAccepted &= ~NativeMethods.ACCEPT_POWEREVENT;   // clear Power Event flag for NT4

                status.currentState = NativeMethods.STATE_START_PENDING;
                bool statusOK = NativeMethods.SetServiceStatus(statusHandle, pStatus);
                if (!statusOK) {
                    return;
                }

                //Need to execute the start method on a thread pool thread.
                //Most applications will start asynchronous operations in the
                //OnStart method. If such a method is executed in the current
                //thread, the async operations might get canceled immediately
                //since NT will terminate this thread right after this function
                //finishes.
                startCompletedSignal = new ManualResetEvent(false);
                ThreadPool.QueueUserWorkItem(new WaitCallback(this.ServiceQueuedMainCallback), args);
                startCompletedSignal.WaitOne();
                
                statusOK = NativeMethods.SetServiceStatus(statusHandle, pStatus);
                if (!statusOK) {
                    WriteEventLogEntry(Res.GetString(Res.StartFailed, new Win32Exception().Message), EventLogEntryType.Error);
                    status.currentState = NativeMethods.STATE_STOPPED;
                    NativeMethods.SetServiceStatus(statusHandle, pStatus);
                }
                
            }
        }
        
        private void WriteEventLogEntry(string message) {
            //EventLog failures shouldn't affect the service operation
            try {
                if (AutoLog)
                    this.EventLog.WriteEntry(message);
            }
            catch (Exception) {
            }
        }
        
        private void WriteEventLogEntry(string message, EventLogEntryType errorType) {
            //EventLog failures shouldn't affect the service operation
            try {
                if (AutoLog)
                    this.EventLog.WriteEntry(message, errorType);
            }
            catch (Exception) {
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\services\servproc\system\serviceprocess\servicecontrollerpermissionattribute.cs ===
//------------------------------------------------------------------------------
// <copyright file="ServiceControllerPermissionAttribute.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.ServiceProcess {
    using System.ComponentModel;
    using System.Security;
    using System.Security.Permissions;
    
    /// <include file='doc\ServiceControllerPermissionAttribute.uex' path='docs/doc[@for="ServiceControllerPermissionAttribute"]/*' />
    [
    AttributeUsage(AttributeTargets.Method | AttributeTargets.Constructor | AttributeTargets.Class | AttributeTargets.Struct | AttributeTargets.Assembly | AttributeTargets.Event, AllowMultiple = true, Inherited = false ),
    Serializable()
    ]     
    public class ServiceControllerPermissionAttribute : CodeAccessSecurityAttribute {
        private string machineName;
        private string serviceName;
        private ServiceControllerPermissionAccess permissionAccess;
        
        /// <include file='doc\ServiceControllerPermissionAttribute.uex' path='docs/doc[@for="ServiceControllerPermissionAttribute.ServiceControllerPermissionAttribute"]/*' />
        public ServiceControllerPermissionAttribute(SecurityAction action)
        : base(action) {
            this.machineName = ".";
            this.serviceName = "*";
            this.permissionAccess = ServiceControllerPermissionAccess.Browse;
        }        

        /// <include file='doc\ServiceControllerPermissionAttribute.uex' path='docs/doc[@for="ServiceControllerPermissionAttribute.MachineName"]/*' />
        public string MachineName {
            get {
                return this.machineName;
            }
            
            set {
                if (!SyntaxCheck.CheckMachineName(value))
                    throw new ArgumentException(Res.GetString(Res.BadMachineName, value));
                    
                this.machineName = value;                    
            }
        }
        
        /// <include file='doc\ServiceControllerPermissionAttribute.uex' path='docs/doc[@for="ServiceControllerPermissionAttribute.PermissionAccess"]/*' />
        public ServiceControllerPermissionAccess PermissionAccess {
            get {
                return this.permissionAccess;
            }
            
            set {
                this.permissionAccess = value;
            }
        }   
        
        /// <include file='doc\ServiceControllerPermissionAttribute.uex' path='docs/doc[@for="ServiceControllerPermissionAttribute.ServiceName"]/*' />
        public string ServiceName {
            get {
                return this.serviceName;
            }
            
            set {                                                                                                                                                                  
                if (value == null)
                    throw new ArgumentNullException("value");

                if (!ServiceController.ValidServiceName(value))
                   throw new ArgumentException(Res.GetString(Res.ServiceName, value, ServiceBase.MaxNameLength.ToString()));                                                
                                    
                this.serviceName = value;                                    
            }
        }                         
              
        /// <include file='doc\ServiceControllerPermissionAttribute.uex' path='docs/doc[@for="ServiceControllerPermissionAttribute.CreatePermission"]/*' />
        public override IPermission CreatePermission() {      
            if (Unrestricted) 
                return new ServiceControllerPermission(PermissionState.Unrestricted);
            
            return new ServiceControllerPermission(this.PermissionAccess, this.MachineName, this.ServiceName);
      
        }
    }    
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\services\servproc\system\serviceprocess\servicecontrollerpermissionentry.cs ===
//----------------------------------------------------
// <copyright file="ServiceControllerPermissionEntry.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.ServiceProcess {
    using System.ComponentModel;
    using System.Security.Permissions;
    
    /// <include file='doc\ServiceControllerPermissionEntry.uex' path='docs/doc[@for="ServiceControllerPermissionEntry"]/*' />
    [
    Serializable()
    ] 
    public class ServiceControllerPermissionEntry {
        private string machineName;
        private string serviceName;
        private ServiceControllerPermissionAccess permissionAccess;

        /// <include file='doc\ServiceControllerPermissionEntry.uex' path='docs/doc[@for="ServiceControllerPermissionEntry.ServiceControllerPermissionEntry"]/*' />               
        public ServiceControllerPermissionEntry() {
            this.machineName = ".";
            this.serviceName = "*";
            this.permissionAccess = ServiceControllerPermissionAccess.Browse;
        }
        
        /// <include file='doc\ServiceControllerPermissionEntry.uex' path='docs/doc[@for="ServiceControllerPermissionEntry.ServiceControllerPermissionEntry1"]/*' />                
        public ServiceControllerPermissionEntry(ServiceControllerPermissionAccess permissionAccess, string machineName, string serviceName) {
            if (serviceName == null)
                throw new ArgumentNullException("serviceName");

            if (!ServiceController.ValidServiceName(serviceName))
               throw new ArgumentException(Res.GetString(Res.ServiceName, serviceName, ServiceBase.MaxNameLength.ToString()));                               
            
            if (!SyntaxCheck.CheckMachineName(machineName))
                throw new ArgumentException(Res.GetString(Res.BadMachineName, machineName));
                                                          
            this.permissionAccess = permissionAccess;
            this.machineName = machineName;
            this.serviceName = serviceName;        
        }  
        
        /// <include file='doc\ServiceControllerPermissionEntry.uex' path='docs/doc[@for="ServiceControllerPermissionEntry.ServiceControllerPermissionEntry2"]/*' />                                                                                                                                 
        ///<internalonly/> 
        internal ServiceControllerPermissionEntry(ResourcePermissionBaseEntry baseEntry) {
            this.permissionAccess = (ServiceControllerPermissionAccess)baseEntry.PermissionAccess;
            this.machineName = baseEntry.PermissionAccessPath[0]; 
            this.serviceName = baseEntry.PermissionAccessPath[1];  
        }

        
        /// <include file='doc\ServiceControllerPermissionEntry.uex' path='docs/doc[@for="ServiceControllerPermissionEntry.MachineName"]/*' />                
        public string MachineName {
            get {
                return this.machineName;
            }            
        }
        
        /// <include file='doc\ServiceControllerPermissionEntry.uex' path='docs/doc[@for="ServiceControllerPermissionEntry.PermissionAccess"]/*' />                
        public ServiceControllerPermissionAccess PermissionAccess {
            get {
                return this.permissionAccess;
            }            
        }   
        
        /// <include file='doc\ServiceControllerPermissionEntry.uex' path='docs/doc[@for="ServiceControllerPermissionEntry.ServiceName"]/*' />                
        public string ServiceName {
            get {
                return this.serviceName;
            }                        
        }                         
        
        /// <include file='doc\ServiceControllerPermissionEntry.uex' path='docs/doc[@for="ServiceControllerPermissionEntry.GetBaseEntry"]/*' />                                                                                                                                 
        ///<internalonly/> 
        internal ResourcePermissionBaseEntry GetBaseEntry() {
            ResourcePermissionBaseEntry baseEntry = new ResourcePermissionBaseEntry((int)this.PermissionAccess, new string[] {this.MachineName, this.ServiceName});            
            return baseEntry;
        }         
    }        
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\services\servproc\system\serviceprocess\servicecontrollerstatus.cs ===
//------------------------------------------------------------------------------
// <copyright file="ServiceControllerStatus.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.ServiceProcess {

    using System.Diagnostics;

    using System;
    using System.ComponentModel;

    /// <include file='doc\ServiceControllerStatus.uex' path='docs/doc[@for="ServiceControllerStatus"]/*' />
    /// <devdoc>
    ///    <para>[To be supplied.]</para>
    /// </devdoc>
    public enum ServiceControllerStatus {
        /// <include file='doc\ServiceControllerStatus.uex' path='docs/doc[@for="ServiceControllerStatus.ContinuePending"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        ContinuePending = NativeMethods.STATE_CONTINUE_PENDING,
        /// <include file='doc\ServiceControllerStatus.uex' path='docs/doc[@for="ServiceControllerStatus.Paused"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        Paused = NativeMethods.STATE_PAUSED,
        /// <include file='doc\ServiceControllerStatus.uex' path='docs/doc[@for="ServiceControllerStatus.PausePending"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        PausePending = NativeMethods.STATE_PAUSE_PENDING,
        /// <include file='doc\ServiceControllerStatus.uex' path='docs/doc[@for="ServiceControllerStatus.Running"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        Running = NativeMethods.STATE_RUNNING,
        /// <include file='doc\ServiceControllerStatus.uex' path='docs/doc[@for="ServiceControllerStatus.StartPending"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        StartPending = NativeMethods.STATE_START_PENDING,
        /// <include file='doc\ServiceControllerStatus.uex' path='docs/doc[@for="ServiceControllerStatus.Stopped"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        Stopped = NativeMethods.STATE_STOPPED,
        /// <include file='doc\ServiceControllerStatus.uex' path='docs/doc[@for="ServiceControllerStatus.StopPending"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        StopPending = NativeMethods.STATE_STOP_PENDING,
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\services\servproc\system\serviceprocess\serviceinstaller.cs ===
//------------------------------------------------------------------------------
// <copyright file="ServiceInstaller.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

/*
* Copyright (c) 1999, Microsoft Corporation. All Rights Reserved.
* Information Contained Herein is Proprietary and Confidential.
*/
namespace System.ServiceProcess {
    using System.ComponentModel;
    using System.Diagnostics;
    using System;
    using System.Collections;
    using System.Configuration.Install;
    using System.IO;    
    using System.Threading;
    using System.Text;
    
    /// <include file='doc\ServiceInstaller.uex' path='docs/doc[@for="ServiceInstaller"]/*' />
    /// <devdoc>
    /// <para>Installs a class that extends <see cref='System.ServiceProcess.ServiceBase'/> to implement a service. This class is called 
    ///    by the install utility when installing a service application.</para>
    /// </devdoc>
    public class ServiceInstaller : ComponentInstaller {
        private const string NetworkServiceName = "NT AUTHORITY\\NetworkService";
        private const string LocalServiceName = "NT AUTHORITY\\LocalService";
        
        private EventLogInstaller eventLogInstaller;        
        private string serviceName = "";
        private string displayName = "";
        private string[] servicesDependedOn = new string[0];
        private ServiceStartMode startType = ServiceStartMode.Manual;
        private static bool environmentChecked = false;
        private static bool isWin9x = false;

        
        /// <include file='doc\ServiceInstaller.uex' path='docs/doc[@for="ServiceInstaller.ServiceInstaller"]/*' />
        /// <devdoc>
        /// <para>Initializes a new instance of the <see cref='System.ServiceProcess.ServiceInstaller'/> class.</para>
        /// </devdoc>
        public ServiceInstaller() : base() {
            
            // Create an EventLogInstaller and add it to our Installers collection to take
            // care of the service's EventLog property.
            eventLogInstaller = new EventLogInstaller();
            eventLogInstaller.Log = "Application";
            // we change these two later when our own properties are set.
            eventLogInstaller.Source = "";
            eventLogInstaller.UninstallAction = UninstallAction.Remove;
            
            Installers.Add(eventLogInstaller);
        }

        /// <include file='doc\ServiceInstaller.uex' path='docs/doc[@for="ServiceInstaller.DisplayName"]/*' />
        /// <devdoc>
        ///    <para>Indicates the friendly name that identifies the service to 
        ///       the user. </para>
        /// </devdoc>
        [DefaultValue("")]
        public string DisplayName {
            get {
                return displayName;
            }
            set {
                if (value == null)
                    value = "";
                displayName = value;
            }
        }
        
        /// <include file='doc\ServiceInstaller.uex' path='docs/doc[@for="ServiceInstaller.ServicesDependedOn"]/*' />
        /// <devdoc>
        ///    <para>Indicates the services that must be running in order for this service to run.</para>
        /// </devdoc>
        public string[] ServicesDependedOn {
            get {
                return servicesDependedOn;
            }
            set {
                if (value == null)
                    value = new string[0];
                servicesDependedOn = value;
            }
        }
        
        /// <include file='doc\ServiceInstaller.uex' path='docs/doc[@for="ServiceInstaller.ServiceName"]/*' />
        /// <devdoc>
        ///    <para>Indicates the name used by the system to identify 
        ///       this service. This property must be identical to the <see cref='System.ServiceProcess.ServiceBase.ServiceName' qualify='true'/> of the service you want to install.</para>
        /// </devdoc>
        [
        DefaultValue(""),
        TypeConverter("System.Diagnostics.Design.StringValueConverter, " + AssemblyRef.SystemDesign)
        ]
        public string ServiceName {
            get {
                return serviceName;
            }
            set {            
                if (value == null)
                    value = "";
                 
                if (!ServiceController.ValidServiceName(value)) 
                    throw new ArgumentException(Res.GetString(Res.ServiceName, value, ServiceBase.MaxNameLength.ToString()));
                                                           
                serviceName = value;
                eventLogInstaller.Source = value;
            }
        }
        
        /// <include file='doc\ServiceInstaller.uex' path='docs/doc[@for="ServiceInstaller.StartType"]/*' />
        /// <devdoc>
        ///    <para>Indicates how and when this service is started.</para>
        /// </devdoc>
        [DefaultValue(ServiceStartMode.Manual)]
        public ServiceStartMode StartType {
            get {
                return startType;
            }
            set {
                if (!Enum.IsDefined(typeof(ServiceStartMode), value)) 
                    throw new InvalidEnumArgumentException("value", (int)value, typeof(ServiceStartMode));
                    
                startType = value;
            }
        }

        internal static void CheckEnvironment() {
            if (environmentChecked) {
                if (isWin9x)
                     throw new PlatformNotSupportedException(Res.GetString(Res.CantControlOnWin9x));    
                
                return;                     
            }
            else {                        
                isWin9x =  Environment.OSVersion.Platform != PlatformID.Win32NT;                
                environmentChecked = true;
                                
                if (isWin9x)
                    throw new PlatformNotSupportedException(Res.GetString(Res.CantInstallOnWin9x));    
            }                
        }
        
                                                                                     
        /// <include file='doc\ServiceInstaller.uex' path='docs/doc[@for="ServiceInstaller.CopyFromComponent"]/*' />
        /// <devdoc>
        ///    <para> 
        ///       Copies properties from an instance of <see cref='System.ServiceProcess.ServiceBase'/>
        ///       to this installer.</para>
        /// </devdoc>
        public override void CopyFromComponent(IComponent component) {
            if (!(component is ServiceBase))
                throw new ArgumentException(Res.GetString(Res.NotAService));
            
            ServiceBase service = (ServiceBase) component;
            
            ServiceName = service.ServiceName;
        }
        
        /// <include file='doc\ServiceInstaller.uex' path='docs/doc[@for="ServiceInstaller.Install"]/*' />
        /// <devdoc>
        ///    <para>Installs the service by writing service application 
        ///       information to the registry. This method is meant to be used by installation
        ///       tools, which process the appropriate methods automatically.</para>
        /// </devdoc>
        public override void Install(IDictionary stateSaver) {            
            Context.LogMessage(Res.GetString(Res.InstallingService, ServiceName));
            try {
                CheckEnvironment();
                string userName = null;
                string password = null;
                // find the ServiceProcessInstaller for our process. It's either the
                // parent or one of our peers in the parent's Installers collection.
                ServiceProcessInstaller processInstaller = null;
                if (Parent is ServiceProcessInstaller) {
                    processInstaller = (ServiceProcessInstaller) Parent;
                } 
                else {
                    for (int i = 0; i < Parent.Installers.Count; i++) {
                        if (Parent.Installers[i] is ServiceProcessInstaller) {
                            processInstaller = (ServiceProcessInstaller) Parent.Installers[i];
                            break;
                        }
                    }
                }
                                    
                if (processInstaller == null)
                    throw new InvalidOperationException(Res.GetString(Res.NoInstaller));
                    
                switch (processInstaller.Account) {
                    case ServiceAccount.LocalService:
                        userName = LocalServiceName;
                        break;
                    case ServiceAccount.NetworkService:
                        userName = NetworkServiceName;
                        break;
                    case ServiceAccount.User:
                        userName = processInstaller.Username;
                        password = processInstaller.Password;
                        break;                        
                }
                
                // check all our parameters
                
                string moduleFileName = Context.Parameters["assemblypath"];
                if (moduleFileName == null || moduleFileName.Length == 0)
                    throw new InvalidOperationException(Res.GetString(Res.FileName));
    
                //Check service name
                if (!ValidateServiceName(ServiceName)) {
                    //Event Log cannot be used here, since the service doesn't exist yet.
                    throw new InvalidOperationException(Res.GetString(Res.ServiceName, ServiceName, ServiceBase.MaxNameLength.ToString()));
                }                
    
                // Check DisplayName length. 
                if (DisplayName.Length > 255) {
                    // MSDN suggests that 256 is the max length, but in
                    // fact anything over 255 causes problems.  
                    throw new ArgumentException(Res.GetString(Res.DisplayNameTooLong, DisplayName));
                }
    
                //Build servicesDependedOn string
                string servicesDependedOn = null;
                if (ServicesDependedOn.Length > 0) {
                    StringBuilder buff = new StringBuilder();
                    for (int i = 0; i < ServicesDependedOn.Length; ++ i) {
                        // we have to build a list of the services' short names. But the user
                        // might have used long names in the ServicesDependedOn property. Try
                        // to use ServiceController's logic to get the short name.
                        string tempServiceName = ServicesDependedOn[i];
                        try {
                            ServiceController svc = new ServiceController(tempServiceName, ".");
                            tempServiceName = svc.ServiceName;
                        }
                        catch {
                        }
                        //The servicesDependedOn need to be separated by a null
                        buff.Append(tempServiceName);
                        buff.Append('\0');
                    }
                    // an extra null at the end indicates end of list.
                    buff.Append('\0');

                    servicesDependedOn = buff.ToString();
                }
    
                // Open the service manager
                IntPtr serviceManagerHandle = SafeNativeMethods.OpenSCManager(null, null, NativeMethods.SC_MANAGER_ALL);
                IntPtr serviceHandle = IntPtr.Zero;
                if (serviceManagerHandle == IntPtr.Zero)
                    throw new InvalidOperationException(Res.GetString(Res.OpenSC, "."), new Win32Exception());
    
                int serviceType = NativeMethods.SERVICE_TYPE_WIN32_OWN_PROCESS;
                // count the number of UserNTServiceInstallers. More than one means we set the SHARE_PROCESS flag.
                int serviceInstallerCount = 0;
                for (int i = 0; i < Parent.Installers.Count; i++) {
                    if (Parent.Installers[i] is ServiceInstaller) {
                        serviceInstallerCount++;
                        if (serviceInstallerCount > 1)
                            break;
                    }
                }
                if (serviceInstallerCount > 1) {
                    serviceType = NativeMethods.SERVICE_TYPE_WIN32_SHARE_PROCESS;
                }
                
                try {
                    // Install the service
                    serviceHandle = NativeMethods.CreateService(serviceManagerHandle, ServiceName,
                        DisplayName, NativeMethods.ACCESS_TYPE_ALL, serviceType,
                        (int) StartType, NativeMethods.ERROR_CONTROL_NORMAL,
                        moduleFileName, null, IntPtr.Zero, servicesDependedOn, userName, password);
                    
                    if (serviceHandle == IntPtr.Zero)
                        throw new Win32Exception();
    
                    stateSaver["installed"] = true;
                }
                finally {
                    if (serviceHandle != IntPtr.Zero)
                        SafeNativeMethods.CloseServiceHandle(serviceHandle);
                        
                    SafeNativeMethods.CloseServiceHandle(serviceManagerHandle);
                }
                Context.LogMessage(Res.GetString(Res.InstallOK, ServiceName));
            }
            finally {
                base.Install(stateSaver);
            }        
        }

        /// <include file='doc\ServiceInstaller.uex' path='docs/doc[@for="ServiceInstaller.IsEquivalentInstaller"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public override bool IsEquivalentInstaller(ComponentInstaller otherInstaller) {
            ServiceInstaller other = otherInstaller as ServiceInstaller;
            
            if (other == null)
                return false;

            return other.ServiceName == ServiceName;
        }
        
        /// <include file='doc\ServiceInstaller.uex' path='docs/doc[@for="ServiceInstaller.RemoveService"]/*' />
        /// <devdoc>
        /// Called by Rollback and Uninstall to remove the service.
        /// </devdoc>
        private void RemoveService() {
            // try to stop the service before uninstalling it.
            try {
                using (ServiceController svc = new ServiceController(ServiceName)) {
                    if (svc.Status != ServiceControllerStatus.Stopped) {
                        Context.LogMessage(Res.GetString(Res.TryToStop, ServiceName));
                        svc.Stop();
                        int timeout = 10;
                        svc.Refresh();
                        while (svc.Status != ServiceControllerStatus.Stopped && timeout > 0) {
                            Thread.Sleep(1000);
                            svc.Refresh();
                            timeout--;
                        }
                    }
                }
            }
            catch {
            }

            Context.LogMessage(Res.GetString(Res.ServiceRemoving, ServiceName));
            IntPtr serviceManagerHandle = SafeNativeMethods.OpenSCManager(null, null, NativeMethods.SC_MANAGER_ALL);
            if (serviceManagerHandle == IntPtr.Zero)
                throw new Win32Exception();

            IntPtr serviceHandle = IntPtr.Zero;
            try {
                serviceHandle = NativeMethods.OpenService(serviceManagerHandle,
                    ServiceName, NativeMethods.STANDARD_RIGHTS_DELETE);
              
                if (serviceHandle == IntPtr.Zero)
                    throw new Win32Exception();

                NativeMethods.DeleteService(serviceHandle);
            }
            finally {
                if (serviceHandle != IntPtr.Zero)
                    SafeNativeMethods.CloseServiceHandle(serviceHandle);
                    
                SafeNativeMethods.CloseServiceHandle(serviceManagerHandle);
            }
            Context.LogMessage(Res.GetString(Res.ServiceRemoved, ServiceName));
        }

        /// <include file='doc\ServiceInstaller.uex' path='docs/doc[@for="ServiceInstaller.Rollback"]/*' />
        /// <devdoc>
        ///    <para>Rolls back service application information that was written to the registry 
        ///       by the installation procedure. This method is meant to be used by installation
        ///       tools, which process the appropriate methods automatically.</para>
        /// </devdoc>
        public override void Rollback(IDictionary savedState) {
            base.Rollback(savedState);
            
            object o = savedState["installed"];
            if (o == null || (bool) o == false)
                return;

            // remove the service
            RemoveService();
            
        }
        
        /// <include file='doc\ServiceInstaller.uex' path='docs/doc[@for="ServiceInstaller.ShouldSerializeServicesDependedOn"]/*' />
        /// <devdoc>
        /// <para> Indicates whether the <see cref='System.ServiceProcess.ServiceInstaller.ServicesDependedOn'/> property should be 
        ///    persisted, which corresponds to whether there are services that this service depends
        ///    on.</para>
        /// </devdoc>
        private bool ShouldSerializeServicesDependedOn() {
            if (servicesDependedOn != null && servicesDependedOn.Length > 0) {
                return true;
            }
            return false;
        }

        /// <include file='doc\ServiceInstaller.uex' path='docs/doc[@for="ServiceInstaller.Uninstall"]/*' />
        /// <devdoc>
        ///    <para>Uninstalls the service by removing information concerning it from the registry.</para>
        /// </devdoc>
        public override void Uninstall(IDictionary savedState) {
            base.Uninstall(savedState);
            
            RemoveService();
        }
        
        //Internal routine used to validate service names
        private static bool ValidateServiceName(string name) {
            //Name cannot be null, have 0 length or be longer than ServiceBase.MaxNameLength
            if (name == null || name.Length == 0 || name.Length > ServiceBase.MaxNameLength)
                return false;

            char[] chars = name.ToCharArray();
            for (int i = 0; i < chars.Length; ++ i) {
                //Invalid characters ASCII < 32, ASCII = '/', ASCII = '\'
                if (chars[i] < (char) 32 || chars[i] == '/' || chars[i] =='\\')
                    return false;
            }

            return true;
        }
    }
    
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\services\servproc\system\serviceprocess\serviceprocessinstaller.cs ===
//------------------------------------------------------------------------------
// <copyright file="ServiceProcessInstaller.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

/*
* Copyright (c) 1999, Microsoft Corporation. All Rights Reserved.
* Information Contained Herein is Proprietary and Confidential.
*/

using INTPTR_INTCAST = System.Int32;
using INTPTR_INTPTRCAST = System.IntPtr;

namespace System.ServiceProcess {
    using System.ServiceProcess.Design;
    using System.Runtime.InteropServices;
    using System.ComponentModel;
    using System.Diagnostics;   
    using System;
    using System.Collections;
    using System.Configuration.Install;    
    using System.Windows.Forms;
using System.Globalization;

    /// <include file='doc\ServiceProcessInstaller.uex' path='docs/doc[@for="ServiceProcessInstaller"]/*' />
    /// <devdoc>
    ///    <para>Installs an executable containing classes 
    ///       that extend <see cref='System.ServiceProcess.ServiceBase'/> . This class is called by the installation utility, InstallUtil.exe, when installing a service application.</para>
    /// </devdoc>
    public class ServiceProcessInstaller : ComponentInstaller {

        private ServiceAccount serviceAccount = ServiceAccount.User;
        private bool haveLoginInfo = false;
        private string password = null;
        private string username = null;
        private static bool helpPrinted = false;

        /// <include file='doc\ServiceProcessInstaller.uex' path='docs/doc[@for="ServiceProcessInstaller.HelpText"]/*' />
        /// <devdoc>
        ///    <para>Indicates help text displayed for service installation options.</para>
        /// </devdoc>
        public override string HelpText {
            get {
                if (helpPrinted)
                    return base.HelpText;
                else {
                    helpPrinted = true;
                    return Res.GetString(Res.HelpText) + "\r\n" + base.HelpText;
                }
            }
        }

        /// <include file='doc\ServiceProcessInstaller.uex' path='docs/doc[@for="ServiceProcessInstaller.Password"]/*' />
        /// <devdoc>
        ///    <para> Indicates the password associated with the user account under which
        ///       the service application will run.</para>
        /// </devdoc>
        [Browsable(false)]
        public string Password {
            get {
                if (!haveLoginInfo) {
                    GetLoginInfo();
                }

                return password;
            }
            set {
                haveLoginInfo = false;
                password = value;
            }
        }

        /// <include file='doc\ServiceProcessInstaller.uex' path='docs/doc[@for="ServiceProcessInstaller.Account"]/*' />
        /// <devdoc>
        ///    <para> 
        ///       Indicates the account type under which the service will run.</para>
        /// </devdoc>
        [
        DefaultValue(ServiceAccount.User)
        ]
        public ServiceAccount Account {
            get {
                if (!haveLoginInfo) {
                    GetLoginInfo();
                }

                return serviceAccount;
            }
            set {
                haveLoginInfo = false;
                serviceAccount = value;
            }
        }

        /// <include file='doc\ServiceProcessInstaller.uex' path='docs/doc[@for="ServiceProcessInstaller.Username"]/*' />
        /// <devdoc>
        ///    <para> Indicates the user account under which
        ///       the service application will run.</para>
        /// </devdoc>
        [
        TypeConverter("System.Diagnostics.Design.StringValueConverter, " + AssemblyRef.SystemDesign),
        Browsable(false)
        ]
        public string Username {
            get {
                if (!haveLoginInfo) {
                    GetLoginInfo();
                }

                return username;
            }
            set {
                haveLoginInfo = false;
                username = value;
            }
        }

        
        
        // Consider, V2, jruiz: implement this. How do you set the working directory
        // for a service?
        //public string InitialWorkingDirectory {
        //    get {                
        //    }
        //    set {
        //    }
        //}
        

        /// <include file='doc\ServiceProcessInstaller.uex' path='docs/doc[@for="ServiceProcessInstaller.AccountHasRight"]/*' />
        /// <devdoc>
        /// Enumerates through the rights of the given account and checks whether the given right
        /// is in the list.
        /// </devdoc>
        private static bool AccountHasRight(IntPtr policyHandle, byte[] accountSid, string rightName) {
            IntPtr pRights = (IntPtr)0;
            int rightsCount = 0;
            
            // This function gives us back a pointer to the start of an array of LSA_UNICODE_STRING structs (in pRights).
            int status = NativeMethods.LsaEnumerateAccountRights(policyHandle, accountSid, out pRights, out rightsCount);
            
            if (status == NativeMethods.STATUS_OBJECT_NAME_NOT_FOUND) {
                // this means that the accountSid has no specific rights 
                return false;
            }
            
            if (status != 0) {
                throw new Win32Exception(SafeNativeMethods.LsaNtStatusToWinError(status));
            }
            
            bool found = false;
            try {
                // look through the rights and see if the desired one is present.
                IntPtr pCurRights = pRights;
                for (int i = 0; i < rightsCount; i++) {
                    // Get this element in the array they gave us
                    NativeMethods.LSA_UNICODE_STRING_withPointer uStr = new NativeMethods.LSA_UNICODE_STRING_withPointer();
                    Marshal.PtrToStructure(pCurRights, uStr); // copy the buffer portion to an array & create a string from that
                    char[] rightChars = new char[uStr.length];                    
                    Marshal.Copy(uStr.pwstr, rightChars, 0, rightChars.Length);
                    string right = new string(rightChars, 0, rightChars.Length);
                    // see if this is the one we're looking for
                    if (string.Compare(right, rightName, false, CultureInfo.InvariantCulture) == 0) {
                        found = true;
                        break;
                    }
                    // move to the next element in the array
                    pCurRights = (IntPtr)((long)pCurRights + Marshal.SizeOf(typeof(NativeMethods.LSA_UNICODE_STRING)));
                }
            }
            finally {
                // make sure we free the memory they allocated for us
                SafeNativeMethods.LsaFreeMemory(pRights);
            }
            
            return found;
        }

        /// <include file='doc\ServiceProcessInstaller.uex' path='docs/doc[@for="ServiceProcessInstaller.CopyFromComponent"]/*' />
        /// <devdoc>
        /// <para>Implements the base class <see cref='System.Configuration.Install.ComponentInstaller.CopyFromComponent' qualify='true'/> method with no <see cref='System.ServiceProcess.ServiceProcessInstaller'/> class-specific behavior.</para>
        /// </devdoc>
        public override void CopyFromComponent(IComponent comp) {
            // we don't have any service-specific information.
        }

        private byte[] GetAccountSid(string accountName) {
            //Lookup SID
            byte[] newSid = new byte[256];
            int[] sidLen = new int[] {newSid.Length};
            char[] domName = new char[1024];
            int[] domNameLen = new int[] {domName.Length};
            int[] peUse = new int[1];
            bool success = NativeMethods.LookupAccountName(null, accountName,  newSid, sidLen, domName, domNameLen, peUse);
            if (!success)
                throw new Win32Exception();

            byte[] sid = new byte[sidLen[0]];
            System.Array.Copy(newSid, 0, sid, 0, sidLen[0]);
            return sid;
        }
        
        // This function contains all the logic to get the username and password
        // from some combination of command line arguments, hard-coded values,
        // and dialog box responses.  This function is called the first time
        // the Username, Password, or RunUnderSystemAccout property is retrieved.
        private void GetLoginInfo() {
            // if we're in design mode we won't have a context, etc.
            if (!this.DesignMode) {
                if (haveLoginInfo)
                    return;

                haveLoginInfo = true;
    
                // ask for the account to run under if necessary
                if (serviceAccount == ServiceAccount.User) {
                    if (Context.Parameters.ContainsKey("username")) {
                        username = Context.Parameters["username"];
                    }
                    if (Context.Parameters.ContainsKey("password")) {
                        password = Context.Parameters["password"];
                    }
                    if (username == null || username.Length == 0 || password == null) {
                        //display the dialog if we are not under unattended setup
                        if (!Context.Parameters.ContainsKey("unattended")) {
                            using (ServiceInstallerDialog dlg = new ServiceInstallerDialog()) {
                                if (username != null)
                                    dlg.Username = username;
                                dlg.ShowDialog();
                                switch (dlg.Result) {
                                    case ServiceInstallerDialogResult.Canceled:
                                        throw new InvalidOperationException(Res.GetString(Res.UserCanceledInstall, Context.Parameters["assemblypath"]));
                                    case ServiceInstallerDialogResult.UseSystem:
                                        username = null;
                                        password = null;
                                        serviceAccount = ServiceAccount.LocalSystem;
                                        break;
                                    case ServiceInstallerDialogResult.OK:
                                        username = dlg.Username;
                                        password = dlg.Password;
                                        break;
                                }
                            }
                        }
                        else {
                            throw new InvalidOperationException(Res.GetString(Res.UnattendedCannotPrompt, Context.Parameters["assemblypath"]));
                        }
                    }
                }               
            }
        }

        /// <include file='doc\ServiceProcessInstaller.uex' path='docs/doc[@for="ServiceProcessInstaller.GrantAccountRight"]/*' />
        /// <devdoc>
        /// Grants the named right to the given account.
        /// </devdoc>
        private static void GrantAccountRight(IntPtr policyHandle, byte[] accountSid, string rightName) {
            //Add Account Rights
            NativeMethods.LSA_UNICODE_STRING accountRights = new NativeMethods.LSA_UNICODE_STRING();
            accountRights.buffer = rightName;
            accountRights.length = (short)(accountRights.buffer.Length * 2);
            accountRights.maximumLength = (short)(accountRights.buffer.Length * 2);
            int result = NativeMethods.LsaAddAccountRights(policyHandle, accountSid, accountRights, 1);
            if (result != 0)
                throw new Win32Exception(SafeNativeMethods.LsaNtStatusToWinError(result));
        }
        
        /// <include file='doc\ServiceProcessInstaller.uex' path='docs/doc[@for="ServiceProcessInstaller.Install"]/*' />
        /// <devdoc>
        ///    <para>Writes service application information to the registry. 
        ///       This method is meant to be used by installation tools, which call the appropriate methods automatically.</para>
        /// </devdoc>
        public override void Install(IDictionary stateSaver) {            
            try {
                ServiceInstaller.CheckEnvironment();    		
                try {
                 
                    if (!haveLoginInfo) {
                        try {
                            GetLoginInfo();  // if the user hits "cancel" this will throw
                        } 
                        catch {
                            stateSaver["hadServiceLogonRight"] = true;  // this prevents rollback from trying to remove logonRights for the user
                            throw;
                        }
                    }
                }
                finally {
                    // save out that information (but not the password)
                    stateSaver["Account"] = Account;
                    if (Account == ServiceAccount.User)
                        stateSaver["Username"] = Username;
                }
            
                if (Account == ServiceAccount.User) {
                    // grant the right to run as a service to the given username. If we don't do this,
                    // the service will be unable to start under that account.
                    IntPtr policyHandle = OpenSecurityPolicy();
                    bool hasServiceLogonRight = true;  // we use 'true' here for the default because later in rollback we do
                                                       //   "if not hasServiceLogon revoke logon priviledge"
                    try {
                        byte[] sid = GetAccountSid(Username);
                        hasServiceLogonRight = AccountHasRight(policyHandle, sid, "SeServiceLogonRight");
                        if (!hasServiceLogonRight)
                            GrantAccountRight(policyHandle, sid, "SeServiceLogonRight");
                    }
                    finally {
                        stateSaver["hadServiceLogonRight"] = hasServiceLogonRight;
                        SafeNativeMethods.LsaClose(policyHandle);                    
                    }
                }
            }
            finally {
                // now install all the contained services. They will use the Username and Password properties to do
                // their installation.
                base.Install(stateSaver);
            }
        }

        /// <include file='doc\ServiceProcessInstaller.uex' path='docs/doc[@for="ServiceProcessInstaller.OpenSecurityPolicy"]/*' />
        /// <devdoc>
        /// Returns an LSA handle to the local machine's security policy. Call LsaClose when finished.
        /// </devdoc>
        private IntPtr OpenSecurityPolicy() {
            byte[] attribs = new byte[33];
            GCHandle attribsHandle = GCHandle.Alloc(attribs, GCHandleType.Pinned);
            try {
                IntPtr policyHandle;
                int result = 0;
                IntPtr attribsPointer =  attribsHandle.AddrOfPinnedObject();
                result = NativeMethods.LsaOpenPolicy(null, attribsPointer, NativeMethods.POLICY_CREATE_ACCOUNT | NativeMethods.POLICY_LOOKUP_NAMES, out policyHandle);
                if (result != 0)
                    throw new Win32Exception(SafeNativeMethods.LsaNtStatusToWinError(result));
                
                return policyHandle;
            }
            finally {
                attribsHandle.Free();
            }
        }
        
        private static void RemoveAccountRight(IntPtr policyHandle, byte[] accountSid, string rightName) {
            NativeMethods.LSA_UNICODE_STRING accountRights = new NativeMethods.LSA_UNICODE_STRING();
            accountRights.buffer = rightName;
            accountRights.length = (short) (accountRights.buffer.Length * 2);
            accountRights.maximumLength = accountRights.length;
            int result = NativeMethods.LsaRemoveAccountRights(policyHandle, accountSid, false, accountRights, 1);
            if (result != 0)
                throw new Win32Exception(SafeNativeMethods.LsaNtStatusToWinError(result));
        }
        
        /// <include file='doc\ServiceProcessInstaller.uex' path='docs/doc[@for="ServiceProcessInstaller.Rollback"]/*' />
        /// <devdoc>
        ///    <para>Rolls back service application information that was 
        ///       written to the registry by the installation procedure. This method is meant to be used by installation tools, which process
        ///       the appropriate methods automatically.</para>
        /// </devdoc>
        public override void Rollback(IDictionary savedState) {
            try {
                // remove the SeServiceLogonRight from the account if we added it.
                if (((ServiceAccount) savedState["Account"]) == ServiceAccount.User && !((bool) savedState["hadServiceLogonRight"])) {
                    string username = (string) savedState["Username"];
                    IntPtr policyHandle = OpenSecurityPolicy();
                    try {
                        byte[] sid = GetAccountSid(username);
                        RemoveAccountRight(policyHandle, sid, "SeServiceLogonRight");
                    }
                    finally {
                        SafeNativeMethods.LsaClose(policyHandle);
                    }
                }
            }
            finally {
                base.Rollback(savedState);
            }
        }

    }

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\services\servproc\system\serviceprocess\timeoutexception.cs ===
//------------------------------------------------------------------------------
// <copyright file="TimeoutException.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.ServiceProcess {
    using System;        
    using System.Runtime.Serialization;
    
    /// <include file='doc\TimeoutException.uex' path='docs/doc[@for="TimeoutException"]/*' />
    [Serializable]
    public class TimeoutException : SystemException {
        /// <include file='doc\TimeoutException.uex' path='docs/doc[@for="TimeoutException.TimeoutException"]/*' />
        public TimeoutException() : base() {
            HResult = HResults.ServiceControllerTimeout;
        }

        /// <include file='doc\TimeoutException.uex' path='docs/doc[@for="TimeoutException.TimeoutException1"]/*' />
        public TimeoutException(string message) : base(message) {
            HResult = HResults.ServiceControllerTimeout;
        }
     
        /// <internalonly/>        
        protected TimeoutException(SerializationInfo info, StreamingContext context) : base (info, context) {            
        }

    }        
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\services\servproc\system\serviceprocess\unsafenativemethods.cs ===
//------------------------------------------------------------------------------
// <copyright file="UnsafeNativeMethods.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.ServiceProcess {    
    using System;
    using System.Text;
    using System.Security;
    using System.Security.Permissions;
    using System.Runtime.InteropServices;
    
    [
    ComVisible(false), 
    SuppressUnmanagedCodeSecurityAttribute()
    ]
    internal class UnsafeNativeMethods {
        
        [DllImport(ExternDll.Advapi32, CharSet=System.Runtime.InteropServices.CharSet.Unicode, SetLastError=true)]
        public unsafe extern static bool ControlService(IntPtr serviceHandle, int control, NativeMethods.SERVICE_STATUS *pStatus);
                       
        [DllImport(ExternDll.Advapi32, CharSet=System.Runtime.InteropServices.CharSet.Unicode, SetLastError=true)]
        public extern static bool ChangeServiceConfig(IntPtr serviceHandle, int serviceType, int startType, int errorControl,
            string binaryPath, string loadOrderGroup, IntPtr pTagId, char[] dependencies, string userName,
            string password, string displayName);
                
        [DllImport(ExternDll.Advapi32, CharSet=System.Runtime.InteropServices.CharSet.Unicode, SetLastError=true)]
        public static extern unsafe bool QueryServiceStatus(IntPtr serviceHandle, NativeMethods.SERVICE_STATUS *pStatus);
                
        [DllImport(ExternDll.Advapi32, CharSet=System.Runtime.InteropServices.CharSet.Unicode, SetLastError=true)]
        public extern static bool EnumServicesStatus(IntPtr databaseHandle, int serviceType, int serviceState,
             IntPtr status, int size, out int bytesNeeded, out int servicesReturned, ref int resumeHandle);
        
        [DllImport(ExternDll.Advapi32, CharSet=System.Runtime.InteropServices.CharSet.Unicode, SetLastError=true)]
         public extern static bool EnumServicesStatusEx(IntPtr databaseHandle, int infolevel, int serviceType, int serviceState,
             IntPtr status, int size, out int bytesNeeded, out int servicesReturned, ref int resumeHandle, string group);                

        [DllImport(ExternDll.Advapi32, CharSet=System.Runtime.InteropServices.CharSet.Unicode, SetLastError=true)]
        public extern static IntPtr OpenService(IntPtr databaseHandle, string serviceName, int access);
         
        [DllImport(ExternDll.Advapi32, CharSet=System.Runtime.InteropServices.CharSet.Unicode, SetLastError=true)]
        public extern static bool StartService(IntPtr serviceHandle, int argNum, IntPtr argPtrs);
                                                
        [DllImport(ExternDll.Advapi32, CharSet=System.Runtime.InteropServices.CharSet.Unicode, SetLastError=true)]
        public extern static bool EnumDependentServices(IntPtr serviceHandle, int serviceState, IntPtr bufferOfENUM_SERVICE_STATUS,
            int bufSize, ref int bytesNeeded, ref int numEnumerated);
            
        [DllImport(ExternDll.Advapi32, CharSet=System.Runtime.InteropServices.CharSet.Unicode, SetLastError=true)]
        public extern static bool QueryServiceConfig(IntPtr serviceHandle, IntPtr query_service_config_ptr, int bufferSize, out int bytesNeeded);                                                
                    
    }                                                                                                                                                                          
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\services\servproc\system\serviceprocess\servicestartmode.cs ===
//------------------------------------------------------------------------------
// <copyright file="ServiceStartMode.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

/*
 */
namespace System.ServiceProcess {

    using System.Diagnostics;

    using System;

    /// <include file='doc\ServiceStartMode.uex' path='docs/doc[@for="ServiceStartMode"]/*' />
    /// <devdoc>
    ///    <para>[To be supplied.]</para>
    /// </devdoc>
    public enum ServiceStartMode {

        /// <include file='doc\ServiceStartMode.uex' path='docs/doc[@for="ServiceStartMode.Manual"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        Manual = NativeMethods.START_TYPE_DEMAND,
        /// <include file='doc\ServiceStartMode.uex' path='docs/doc[@for="ServiceStartMode.Automatic"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        Automatic = NativeMethods.START_TYPE_AUTO,
        /// <include file='doc\ServiceStartMode.uex' path='docs/doc[@for="ServiceStartMode.Disabled"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        Disabled = NativeMethods.START_TYPE_DISABLED,

    }

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\services\servproc\system\serviceprocess\servicetype.cs ===
//------------------------------------------------------------------------------
// <copyright file="ServiceType.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.ServiceProcess {

    using System.Diagnostics;

    using System;
    using System.ComponentModel;

    /// <include file='doc\ServiceType.uex' path='docs/doc[@for="ServiceType"]/*' />
    /// <devdoc>
    ///    <para>[To be supplied.]</para>
    /// </devdoc>
    [Flags]
    public enum ServiceType {
        /// <include file='doc\ServiceType.uex' path='docs/doc[@for="ServiceType.Adapter"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        Adapter = NativeMethods.SERVICE_TYPE_ADAPTER,
        /// <include file='doc\ServiceType.uex' path='docs/doc[@for="ServiceType.FileSystemDriver"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        FileSystemDriver = NativeMethods.SERVICE_TYPE_FILE_SYSTEM_DRIVER,
        /// <include file='doc\ServiceType.uex' path='docs/doc[@for="ServiceType.InteractiveProcess"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        InteractiveProcess = NativeMethods.SERVICE_TYPE_INTERACTIVE_PROCESS,
        /// <include file='doc\ServiceType.uex' path='docs/doc[@for="ServiceType.KernelDriver"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        KernelDriver = NativeMethods.SERVICE_TYPE_KERNEL_DRIVER,
        /// <include file='doc\ServiceType.uex' path='docs/doc[@for="ServiceType.RecognizerDriver"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        RecognizerDriver = NativeMethods.SERVICE_TYPE_RECOGNIZER_DRIVER,
        /// <include file='doc\ServiceType.uex' path='docs/doc[@for="ServiceType.Win32OwnProcess"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        Win32OwnProcess = NativeMethods.SERVICE_TYPE_WIN32_OWN_PROCESS,
        /// <include file='doc\ServiceType.uex' path='docs/doc[@for="ServiceType.Win32ShareProcess"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        Win32ShareProcess = NativeMethods.SERVICE_TYPE_WIN32_SHARE_PROCESS,
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\services\servproc\system\serviceprocess\serviceprocessdescriptionattribute.cs ===
//------------------------------------------------------------------------------
// <copyright file="ServiceProcessDescriptionAttribute.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.ServiceProcess {


    using System;
    using System.ComponentModel;   

    /// <include file='doc\ServiceProcessDescriptionAttribute.uex' path='docs/doc[@for="ServiceProcessDescriptionAttribute"]/*' />
    /// <devdoc>
    ///     DescriptionAttribute marks a property, event, or extender with a
    ///     description. Visual designers can display this description when referencing
    ///     the member.
    /// </devdoc>
    [AttributeUsage(AttributeTargets.All)]
    public class ServiceProcessDescriptionAttribute : DescriptionAttribute {

        private bool replaced = false;

        /// <include file='doc\ServiceProcessDescriptionAttribute.uex' path='docs/doc[@for="ServiceProcessDescriptionAttribute.ServiceProcessDescriptionAttribute"]/*' />
        /// <devdoc>
        ///     Constructs a new sys description.
        /// </devdoc>
        public ServiceProcessDescriptionAttribute(string description) : base(description) {
        }

        /// <include file='doc\ServiceProcessDescriptionAttribute.uex' path='docs/doc[@for="ServiceProcessDescriptionAttribute.Description"]/*' />
        /// <devdoc>
        ///     Retrieves the description text.
        /// </devdoc>
        public override string Description {
            get {
                if (!replaced) {
                    replaced = true;
                    DescriptionValue = Res.GetString(base.Description);
                }
                return base.Description;
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\services\timers\system\timers\elapsedeventargs.cs ===
//------------------------------------------------------------------------------
// <copyright file="ElapsedEventArgs.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Timers {

    using System;
    using System.Diagnostics;
    
    /// <include file='doc\ElapsedEventArgs.uex' path='docs/doc[@for="ElapsedEventArgs"]/*' />
    public class ElapsedEventArgs : EventArgs {   
        private DateTime signalTime;
        
        internal ElapsedEventArgs(int low, int high) {        
            long fileTime = (long)((((ulong)high) << 32) | (((ulong)low) & 0xffffffff));
            this.signalTime = DateTime.FromFileTime(fileTime);                        
        }
    
        /// <include file='doc\ElapsedEventArgs.uex' path='docs/doc[@for="ElapsedEventArgs.SignalTime"]/*' />
        public DateTime SignalTime {
            get {
                return this.signalTime;
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\services\timers\system\timers\elapsedeventhandler.cs ===
//------------------------------------------------------------------------------
// <copyright file="ElapsedEventHandler.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Timers {

    using System;
    using System.Diagnostics;
    
    /// <include file='doc\ElapsedEventHandler.uex' path='docs/doc[@for="ElapsedEventHandler"]/*' />
    public delegate void ElapsedEventHandler(object sender, ElapsedEventArgs e);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\services\servproc\system\serviceprocess\design\servicenameconverter.cs ===
//------------------------------------------------------------------------------
// <copyright file="ServiceNameConverter.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------
  
namespace System.ServiceProcess.Design {
    using System.ServiceProcess;                                                    
    using System.ComponentModel;
    using System.Diagnostics;
    using System;            
    using System.ComponentModel.Design.Serialization;
    using System.Reflection;
    using System.Collections; 
    using System.Globalization;
    
    internal class ServiceNameConverter : TypeConverter {
        private StandardValuesCollection values;
        private string previousMachineName;
    
        public override bool CanConvertFrom(ITypeDescriptorContext context, Type sourceType) {
            if (sourceType == typeof(string)) {
                return true;
            }
            return base.CanConvertFrom(context, sourceType);
        }
        
        public override object ConvertFrom(ITypeDescriptorContext context, CultureInfo culture, object value) {
            if (value is string) {
                string text = ((string)value).Trim();
                return text;
            }
            return base.ConvertFrom(context, culture, value);
        }
        
        public override StandardValuesCollection GetStandardValues(ITypeDescriptorContext context) {                    
            ServiceController owner = (context == null) ? null : context.Instance as ServiceController;
            string machineName = ".";
            if (owner != null) 
                machineName = owner.MachineName;                        
        
            if (values == null || machineName != previousMachineName) {                
                try {
                    ServiceController[] installedServices = ServiceController.GetServices(machineName);
                    string[] serviceNames = new string[installedServices.Length];
                    for (int i = 0; i < installedServices.Length; i++) {
                        serviceNames[i] = installedServices[i].ServiceName;
                    }
                            
                    values = new StandardValuesCollection(serviceNames);
                    previousMachineName = machineName;
                }                
                catch(Exception) {
                    //Do Nothing
                }
            }
            return values;
        }        

        public override bool GetStandardValuesExclusive(ITypeDescriptorContext context) {
            return false;
        }

        public override bool GetStandardValuesSupported(ITypeDescriptorContext context) {
            return true;
        }
    }   
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\services\servproc\system\serviceprocess\design\serviceinstallerdialog.cs ===
//------------------------------------------------------------------------------
// <copyright file="ServiceInstallerDialog.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

/*
* Copyright (c) 1999, Microsoft Corporation. All Rights Reserved.
* Information Contained Herein is Proprietary and Confidential.
*/
namespace System.ServiceProcess.Design {

    using System.Diagnostics;
    using System;
    using System.Drawing;
    using System.Collections;
    using System.ComponentModel;
    using System.Windows.Forms;

    /// <include file='doc\ServiceInstallerDialog.uex' path='docs/doc[@for="ServiceInstallerDialogResult"]/*' />
    /// <devdoc>
    ///    <para>[To be supplied.]</para>
    /// </devdoc>
    public enum ServiceInstallerDialogResult {
        /// <include file='doc\ServiceInstallerDialog.uex' path='docs/doc[@for="ServiceInstallerDialogResult.OK"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        OK,
        /// <include file='doc\ServiceInstallerDialog.uex' path='docs/doc[@for="ServiceInstallerDialogResult.UseSystem"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        UseSystem,
        /// <include file='doc\ServiceInstallerDialog.uex' path='docs/doc[@for="ServiceInstallerDialogResult.Canceled"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        Canceled,
    }

    /// <include file='doc\ServiceInstallerDialog.uex' path='docs/doc[@for="ServiceInstallerDialog"]/*' />
    /// <devdoc>
    ///    <para>[To be supplied.]</para>
    /// </devdoc>
    public class ServiceInstallerDialog : Form {

        private System.Windows.Forms.Button okButton;
        
        private System.Windows.Forms.TextBox passwordEdit;
        
        private System.Windows.Forms.Button cancelButton;
        
        private System.Windows.Forms.TextBox confirmPassword;
        
        private System.Windows.Forms.TextBox usernameEdit;
        
        private System.Windows.Forms.Label label1;
        
        private System.Windows.Forms.Label label2;
        
        private System.Windows.Forms.Label label3;
                        
        private ServiceInstallerDialogResult result = ServiceInstallerDialogResult.OK;

        /// <include file='doc\ServiceInstallerDialog.uex' path='docs/doc[@for="ServiceInstallerDialog.ServiceInstallerDialog"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public ServiceInstallerDialog() {
            this.InitializeComponent();
        }

        /// <include file='doc\ServiceInstallerDialog.uex' path='docs/doc[@for="ServiceInstallerDialog.Password"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public string Password {
                get {
                    return passwordEdit.Text;
                }
                set {
                    passwordEdit.Text = value;
                }
        }
    
        /// <include file='doc\ServiceInstallerDialog.uex' path='docs/doc[@for="ServiceInstallerDialog.Result"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public ServiceInstallerDialogResult Result {
                get {
                    return result;
                }
        }
    
        /// <include file='doc\ServiceInstallerDialog.uex' path='docs/doc[@for="ServiceInstallerDialog.Username"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public string Username {
                get {
                    return usernameEdit.Text;
                }
                set {
                    usernameEdit.Text = value;
                }
        }
                
        /// <include file='doc\ServiceInstallerDialog.uex' path='docs/doc[@for="ServiceInstallerDialog.Main"]/*' />
        [System.STAThreadAttribute()]
        public static void Main() {
            System.Windows.Forms.Application.Run(new ServiceInstallerDialog());
        }
        
        private void InitializeComponent() {
            System.Resources.ResourceManager resources = new System.Resources.ResourceManager(typeof(ServiceInstallerDialog));
            this.okButton = new System.Windows.Forms.Button();
            this.passwordEdit = new System.Windows.Forms.TextBox();
            this.cancelButton = new System.Windows.Forms.Button();
            this.confirmPassword = new System.Windows.Forms.TextBox();
            this.usernameEdit = new System.Windows.Forms.TextBox();
            this.label1 = new System.Windows.Forms.Label();
            this.label2 = new System.Windows.Forms.Label();
            this.label3 = new System.Windows.Forms.Label();
            this.okButton.Location = ((System.Drawing.Point)(resources.GetObject("okButton.Location")));
            this.okButton.Size = ((System.Drawing.Size)(resources.GetObject("okButton.Size")));
            this.okButton.TabIndex = ((int)(resources.GetObject("okButton.TabIndex")));
            this.okButton.Text = resources.GetString("okButton.Text");
            this.okButton.Click += new System.EventHandler(this.okButton_Click);
            this.okButton.DialogResult = DialogResult.OK;
            this.passwordEdit.Location = ((System.Drawing.Point)(resources.GetObject("passwordEdit.Location")));
            this.passwordEdit.PasswordChar = '*';
            this.passwordEdit.Size = ((System.Drawing.Size)(resources.GetObject("passwordEdit.Size")));
            this.passwordEdit.TabIndex = ((int)(resources.GetObject("passwordEdit.TabIndex")));
            this.passwordEdit.Text = resources.GetString("passwordEdit.Text");
            this.cancelButton.Location = ((System.Drawing.Point)(resources.GetObject("cancelButton.Location")));
            this.cancelButton.Size = ((System.Drawing.Size)(resources.GetObject("cancelButton.Size")));
            this.cancelButton.TabIndex = ((int)(resources.GetObject("cancelButton.TabIndex")));
            this.cancelButton.Text = resources.GetString("cancelButton.Text");
            this.cancelButton.Click += new System.EventHandler(this.cancelButton_Click);
            this.cancelButton.DialogResult = DialogResult.Cancel;
            this.confirmPassword.Location = ((System.Drawing.Point)(resources.GetObject("confirmPassword.Location")));
            this.confirmPassword.PasswordChar = '*';
            this.confirmPassword.Size = ((System.Drawing.Size)(resources.GetObject("confirmPassword.Size")));
            this.confirmPassword.TabIndex = ((int)(resources.GetObject("confirmPassword.TabIndex")));
            this.confirmPassword.Text = resources.GetString("confirmPassword.Text");
            this.usernameEdit.Location = ((System.Drawing.Point)(resources.GetObject("usernameEdit.Location")));
            this.usernameEdit.Size = ((System.Drawing.Size)(resources.GetObject("usernameEdit.Size")));
            this.usernameEdit.TabIndex = ((int)(resources.GetObject("usernameEdit.TabIndex")));
            this.usernameEdit.Text = resources.GetString("usernameEdit.Text");
            this.label1.AutoSize = true;
            this.label1.Location = ((System.Drawing.Point)(resources.GetObject("label1.Location")));
            this.label1.Size = ((System.Drawing.Size)(resources.GetObject("label1.Size")));
            this.label1.TabIndex = ((int)(resources.GetObject("label1.TabIndex")));
            this.label1.Text = resources.GetString("label1.Text");
            this.label2.AutoSize = true;
            this.label2.Location = ((System.Drawing.Point)(resources.GetObject("label2.Location")));
            this.label2.Size = ((System.Drawing.Size)(resources.GetObject("label2.Size")));
            this.label2.TabIndex = ((int)(resources.GetObject("label2.TabIndex")));
            this.label2.Text = resources.GetString("label2.Text");
            this.label3.AutoSize = true;
            this.label3.Location = ((System.Drawing.Point)(resources.GetObject("label3.Location")));
            this.label3.TabIndex = ((int)(resources.GetObject("label3.TabIndex")));
            this.label3.Text = resources.GetString("label3.Text");
            this.AcceptButton = this.okButton;
            this.AutoScaleBaseSize = new System.Drawing.Size(5, 13);            
            this.CancelButton = this.cancelButton;
            this.ClientSize = ((System.Drawing.Size)(resources.GetObject("$this.ClientSize")));
            this.ControlBox = false;
            this.Controls.AddRange(new System.Windows.Forms.Control[] {this.cancelButton,
                        this.okButton,
                        this.confirmPassword,
                        this.passwordEdit,
                        this.usernameEdit,
                        this.label3,
                        this.label2,
                        this.label1});
            this.FormBorderStyle = System.Windows.Forms.FormBorderStyle.FixedDialog;                        
            this.ShowInTaskbar = false;
            this.MaximizeBox = false;
            this.MinimizeBox = false;
            this.Name = "Win32Form1";
            this.ShowInTaskbar = false;
            this.StartPosition = FormStartPosition.CenterScreen;
            this.Icon = null;
            this.Text = resources.GetString("$this.Text");
        }   

        private void cancelButton_Click(object sender, EventArgs e) {
                result = ServiceInstallerDialogResult.Canceled;
                DialogResult = DialogResult.Cancel;
        }
    
        private void okButton_Click(object sender, EventArgs e) {
                result = ServiceInstallerDialogResult.OK;
                if (passwordEdit.Text == confirmPassword.Text)
                DialogResult = DialogResult.OK;
                else {
                    DialogResult = DialogResult.None;
                    MessageBox.Show(Res.GetString(Res.Label_MissmatchedPasswords), Res.GetString(Res.Label_SetServiceLogin), MessageBoxButtons.OK, MessageBoxIcon.Exclamation);
                    passwordEdit.Text = string.Empty;
                    confirmPassword.Text = string.Empty;
                    passwordEdit.Focus();
                }
                // Consider, V2, jruiz: check to make sure the password is correct for the given account.                
        }        
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\services\web\makefile.inc ===
!if 0
    -------------------------------------------------------------------------------------
        Don't modify... user variables are set in "sources"
    -------------------------------------------------------------------------------------
!endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\services\timers\system\timers\timersdescriptionattribute.cs ===
//------------------------------------------------------------------------------
// <copyright file="TimersDescriptionAttribute.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Timers{


    using System;
    using System.ComponentModel;   

    /// <include file='doc\TimersDescriptionAttribute.uex' path='docs/doc[@for="TimersDescriptionAttribute"]/*' />
    /// <devdoc>
    ///     DescriptionAttribute marks a property, event, or extender with a
    ///     description. Visual designers can display this description when referencing
    ///     the member.
    /// </devdoc>
    [AttributeUsage(AttributeTargets.All)]
    public class TimersDescriptionAttribute : DescriptionAttribute {

        private bool replaced = false;

        /// <include file='doc\TimersDescriptionAttribute.uex' path='docs/doc[@for="TimersDescriptionAttribute.TimersDescriptionAttribute"]/*' />
        /// <devdoc>
        ///     Constructs a new sys description.
        /// </devdoc>
        public TimersDescriptionAttribute(string description) : base(description) {
        }

        /// <include file='doc\TimersDescriptionAttribute.uex' path='docs/doc[@for="TimersDescriptionAttribute.Description"]/*' />
        /// <devdoc>
        ///     Retrieves the description text.
        /// </devdoc>
        public override string Description {
            get {
                if (!replaced) {
                    replaced = true;
                    DescriptionValue = SR.GetString(base.Description);
                }
                return base.Description;
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\services\web\system\web\services\safenativemethods.cs ===
//------------------------------------------------------------------------------
// <copyright file="SafeNativeMethods.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Web.Services {
    using System.Runtime.InteropServices;
    using System;
    using System.Security.Permissions;
    using System.Collections;
    using System.IO;
    using System.Text;

    [
    System.Runtime.InteropServices.ComVisible(false), 
    System.Security.SuppressUnmanagedCodeSecurityAttribute()
    ]
    internal class SafeNativeMethods {
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\services\web\system\componentmodel\compmodswitches.cs ===
//------------------------------------------------------------------------------
// <copyright file="Component.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.ComponentModel {
    using System.Diagnostics;

    /// <internalonly/>
    internal sealed class CompModSwitches {
        private static BooleanSwitch dynamicDiscoVirtualSearch;
        private static TraceSwitch dynamicDiscoSearcher;
        private static BooleanSwitch disableRemoteDebugging;
        private static TraceSwitch remote;

        public static BooleanSwitch DisableRemoteDebugging {
            get {
                if (disableRemoteDebugging == null) {
                    disableRemoteDebugging = new BooleanSwitch("Remote.Disable", "Disable remote debugging for web methods.");
                }
                return disableRemoteDebugging;
            }
        }         
                
        public static TraceSwitch DynamicDiscoverySearcher {
            get {
                if (dynamicDiscoSearcher == null) {
                    dynamicDiscoSearcher = new TraceSwitch("DynamicDiscoverySearcher", "Enable tracing for the DynamicDiscoverySearcher class.");
                }
                return dynamicDiscoSearcher;
            }
        }                                                                                
                                                                        
        public static BooleanSwitch DynamicDiscoveryVirtualSearch {
            get {
                if (dynamicDiscoVirtualSearch == null) {
                    dynamicDiscoVirtualSearch = new BooleanSwitch("DynamicDiscoveryVirtualSearch", "Force virtual search for DiscoveryRequestHandler class.");
                }
                return dynamicDiscoVirtualSearch;
            }
        }                                                                                                                                                
        
        public static TraceSwitch Remote {
            get {
                if (remote == null) {
                    remote = new TraceSwitch("Microsoft.WFC.Remote", "Enable tracing for remote method calls.");
                }
                return remote;
            }
        }
        
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\services\timers\system\timers\timer.cs ===
//------------------------------------------------------------------------------
// <copyright file="Timer.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Timers {

    using System.Runtime.InteropServices;
    using System.Security;
    using System.Security.Permissions;
    using System.Threading;
    using System.ComponentModel;
    using System.ComponentModel.Design;
    using System;        
    using Microsoft.Win32;

    /// <include file='doc\Timer.uex' path='docs/doc[@for="Timer"]/*' />
    /// <devdoc>
    ///    <para>Handles recurring events in an application.</para>
    /// </devdoc>
    [
    DefaultProperty("Interval"),
    DefaultEvent("Elapsed")
    ]
    public class Timer : Component, ISupportInitialize {
        private double interval;
        private bool  enabled;
        private bool initializing;
        private bool delayedEnable;                
        private ElapsedEventHandler onIntervalElapsed;
        private IntPtr handle;
        private bool autoReset;               
        private ISynchronizeInvoke synchronizingObject;  
        private SafeNativeMethods.TimerAPCProc apcCallback;
        private WaitCallback threadPoolCallback;
        private bool disposed;
                
        /// <include file='doc\Timer.uex' path='docs/doc[@for="Timer.Timer"]/*' />
        /// <devdoc>
        /// <para>Initializes a new instance of the <see cref='System.Timers.Timer'/> class, with the properties
        ///    set to initial values.</para>
        /// </devdoc>
        public Timer()
        : base() {
            interval = 100;
            enabled = false;
            autoReset = true;
            initializing = false;
            delayedEnable = false;
        }

        /// <include file='doc\Timer.uex' path='docs/doc[@for="Timer.Timer1"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Initializes a new instance of the <see cref='System.Timers.Timer'/> class, setting the <see cref='System.Timers.Timer.Interval'/> property to the specified period.
        ///    </para>
        /// </devdoc>
        public Timer(double interval)
        : this() {
            if (interval <= 0)
                throw new ArgumentException(SR.GetString(SR.InvalidParameter, "interval", interval));

            this.interval = interval;
        }

        /// <include file='doc\Timer.uex' path='docs/doc[@for="Timer.AutoReset"]/*' />
        /// <devdoc>
        /// <para>Gets or sets a value indicating whether the Timer raises the Tick event each time the specified
        /// Interval has elapsed,
        ///    when Enabled is set to true.</para>
        /// </devdoc>
        [Category("Behavior"),  TimersDescription(SR.TimerAutoReset), DefaultValue(true)]
        public bool AutoReset {
            get {
                return this.autoReset;
            }

            set {
                if (DesignMode)
                     this.autoReset = value;
                else if (this.autoReset != value) {
                     this.autoReset = value;
                     if (this.handle != (IntPtr)0) 
                        WaitableTimer.Set(this.handle, this.interval, this.autoReset, this.apcCallback);                                                                                                                                                                                                                                   
                 }
            }
        }

        /// <include file='doc\Timer.uex' path='docs/doc[@for="Timer.Enabled"]/*' />
        /// <devdoc>
        /// <para>Gets or sets a value indicating whether the <see cref='System.Timers.Timer'/>
        /// is able
        /// to raise events at a defined interval.</para>
        /// </devdoc>
        //jruiz - The default value by design is false, don't change it.
        [Category("Behavior"), TimersDescription(SR.TimerEnabled), DefaultValue(false)]
        public bool Enabled {
            get {
                return this.enabled;
            }

            set {
                if (DesignMode) {
                    this.delayedEnable = value;            
                    this.enabled = value; 
                }                    
                else if (initializing)
                    this.delayedEnable = value;            
                else if (enabled != value) {                                                                                                     
                    if (!value) {                                           
                        if (this.handle != (IntPtr)0) {
                            SafeNativeMethods.CancelWaitableTimer(new HandleRef(this, this.handle));
                            SafeNativeMethods.CloseHandle(new HandleRef(this, this.handle));
                            this.handle = (IntPtr)0;                                                        
                        }    
                        this.enabled = value;                        
                    }
                    else {                          
                        if (this.handle == (IntPtr)0) {                                        
                            //Cannot create a new system waitable timer if the object has been disposed, since finalization has been suppressed.
                            if (this.disposed)
                                throw new ObjectDisposedException(GetType().Name);
                                
                            string id = "ServerTimer" + this.GetHashCode().ToString() + (new Random()).Next().ToString();                            
                            this.handle = SafeNativeMethods.CreateWaitableTimer(null, false, id);                                                                
                            if (this.apcCallback == null)
                                this.apcCallback = new SafeNativeMethods.TimerAPCProc(this.TimerAPCCallback);
                                
                            if (this.threadPoolCallback == null)                                
                                this.threadPoolCallback = new WaitCallback(this.TimerThreadPoolCallback);
                        }   
                        
                        // Setting enabled here before calling Set first,which triggers an asynchronous chain of events. The listener worker thread
                        // will make an APC request which can fire (WaitableTimer callback) and make a call to TimerThreadPoolCallback on a threadpool thread.
                        // The TimerThreadPoolCallback can then set the enabled = false and we can land up in a race where enabled is set to true corrupting the state of the timer.
                        // The timer is then unusable subsequently when Start is called. Hence the order of the statments here, hence we are setting enabled to true here first.
                        this.enabled = value;
                        WaitableTimer.Set(this.handle, this.interval, this.autoReset, this.apcCallback);                                                                                                                                                                                  
                    }                        

                }                                                     
          }
        }


        
        
        /// <include file='doc\Timer.uex' path='docs/doc[@for="Timer.Interval"]/*' />
        /// <devdoc>
        ///    <para>Gets or
        ///       sets the interval on which
        ///       to raise events.</para>
        /// </devdoc>
        [Category("Behavior"), TimersDescription(SR.TimerInterval), DefaultValue(100d), RecommendedAsConfigurable(true)]
        public double Interval {
            get {
                return this.interval;
            }

            set {
                if (value <= 0)
                    throw new ArgumentException(SR.GetString(SR.TimerInvalidInterval, value, 0));
                                
                this.interval = value;                
                if (this.handle != (IntPtr)0)
                    WaitableTimer.Set(this.handle, this.interval, this.autoReset, this.apcCallback);                                                                                                                                                                                                                                                           
            }
        }      


        /// <include file='doc\Timer.uex' path='docs/doc[@for="Timer.Tick"]/*' />
        /// <devdoc>
        /// <para>Occurs when the <see cref='System.Timers.Timer.Interval'/> has
        ///    elapsed.</para>
        /// </devdoc>
        [Category("Behavior"), TimersDescription(SR.TimerIntervalElapsed)]
        public event ElapsedEventHandler Elapsed {
            add {
                onIntervalElapsed += value;
            }
            remove {
                onIntervalElapsed -= value;
            }
        }

        /// <include file='doc\Timer.uex' path='docs/doc[@for="Timer.Site"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Sets the enable property in design mode to true by default.
        ///    </para>
        /// </devdoc>                              
        /// <internalonly/>
        public override ISite Site {
            set {
                base.Site = value;
                if (this.DesignMode)
                    this.enabled= true;
            }
            
            get {
                return base.Site;
            }
        }


        /// <include file='doc\Timer.uex' path='docs/doc[@for="Timer.SynchronizingObject"]/*' />
        /// <devdoc>
        ///    <para>Gets or sets the object used to marshal event-handler calls that are issued when
        ///       an interval has elapsed.</para>
        /// </devdoc>
        [DefaultValue(null), TimersDescription(SR.TimerSynchronizingObject)]
        public ISynchronizeInvoke SynchronizingObject {
            get {
                if (this.synchronizingObject == null && DesignMode) {
                    IDesignerHost host = (IDesignerHost)GetService(typeof(IDesignerHost));
                    if (host != null) {
                        object baseComponent = host.RootComponent;
                        if (baseComponent != null && baseComponent is ISynchronizeInvoke)
                            this.synchronizingObject = (ISynchronizeInvoke)baseComponent;
                    }                        
                }
            
                return this.synchronizingObject;
            }
            
            set {
                this.synchronizingObject = value;
            }
        }                  
        
        /// <include file='doc\Timer.uex' path='docs/doc[@for="Timer.BeginInit"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Notifies
        ///       the object that initialization is beginning and tells it to stand by.
        ///    </para>
        /// </devdoc>
        public void BeginInit() {
            this.Close();
            this.initializing = true;
        }
                
        /// <include file='doc\Timer.uex' path='docs/doc[@for="Timer.Close"]/*' />
        /// <devdoc>
        ///    <para>Disposes of the resources (other than memory) used by
        ///       the <see cref='System.Timers.Timer'/>.</para>
        /// </devdoc>
        public void Close() {                  
            initializing = false;
            delayedEnable = false;
            enabled = false;
                                        
            if (this.handle != (IntPtr)0) {
                SafeNativeMethods.CancelWaitableTimer(new HandleRef(this, this.handle));
                SafeNativeMethods.CloseHandle(new HandleRef(this, this.handle));
                this.handle = (IntPtr)0;
            }                                            
        }                                

        /// <include file='doc\Timer.uex' path='docs/doc[@for="Timer.Dispose1"]/*' />
        /// <internalonly/>
        /// <devdoc>        
        /// </devdoc>
        protected override void Dispose(bool disposing) {            
            Close();                        
            this.disposed = true;
            base.Dispose(disposing);
        }      
         
        /// <include file='doc\Timer.uex' path='docs/doc[@for="Timer.EndInit"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Notifies the object that initialization is complete.
        ///    </para>
        /// </devdoc>
        public void EndInit() {
            this.initializing = false;            
            this.Enabled = this.delayedEnable;
        }        

        /// <include file='doc\Timer.uex' path='docs/doc[@for="Timer.Start"]/*' />
        /// <devdoc>
        /// <para>Starts the timing by setting <see cref='System.Timers.Timer.Enabled'/> to <see langword='true'/>.</para>
        /// </devdoc>
        public void Start() {
            Enabled = true;
        }

        /// <include file='doc\Timer.uex' path='docs/doc[@for="Timer.Stop"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Stops the timing by setting <see cref='System.Timers.Timer.Enabled'/> to <see langword='false'/>.
        ///    </para>
        /// </devdoc>
        public void Stop() {
            Enabled = false;
        }
        
        private void TimerAPCCallback(IntPtr data, int lowValue, int highValue) {
            ElapsedEventArgs args = new ElapsedEventArgs(lowValue, highValue);
            ThreadPool.QueueUserWorkItem(this.threadPoolCallback , args);           
        }                
                
        private void TimerThreadPoolCallback(object state) {
            if (!this.autoReset)
                this.enabled = false;

            try {                                            
                if (this.onIntervalElapsed != null) {
                    if (this.SynchronizingObject != null && this.SynchronizingObject.InvokeRequired)
                        this.SynchronizingObject.BeginInvoke(this.onIntervalElapsed, new object[]{this, state});
                    else                        
                       this.onIntervalElapsed(this, (ElapsedEventArgs)state);                                   
                }
            }
            catch (Exception) {             
            }            
        }
                        
        private class WaitableTimer {
            private static bool exit = false;                                    
            private static AutoResetEvent settingSignal = new AutoResetEvent(false);
            private static AutoResetEvent doneSignal = new AutoResetEvent(false);
            private static double nextInterval;
            private static bool nextAutoReset;            
            private static IntPtr nextHandle;
            private static SafeNativeMethods.TimerAPCProc nextOwnerCallback;
            private static Thread listenerThread;
                                                                                                                                                   
            public static void Set(IntPtr handle, double interval, bool autoReset, SafeNativeMethods.TimerAPCProc ownerCallback) {                
                lock(typeof(WaitableTimer)) {
                    nextInterval = interval;
                    nextHandle = handle;
                    nextAutoReset = autoReset;
                    nextOwnerCallback = ownerCallback;
                    if (listenerThread == null) {
                        AppDomain.CurrentDomain.DomainUnload += new EventHandler(OnAppDomainUnload);                         
                        listenerThread = new Thread(new ThreadStart(ListenerThread));
                        listenerThread.IsBackground = true;
                        listenerThread.Start();
                    }                    
                    settingSignal.Set();
                    doneSignal.WaitOne();                                
                }
            } 
            
            private static void ListenerThread() {
                while (!exit) {                
                    settingSignal.WaitOne();
                    if (!exit) {
                        long[] info = new long[1];
                        info[0] = (long)(-10000 * nextInterval);
                        if (nextAutoReset) 
                            SafeNativeMethods.SetWaitableTimer(new HandleRef(null, nextHandle), info, (int)Math.Ceiling(nextInterval), nextOwnerCallback, NativeMethods.NullHandleRef, false);                                                                 
                        else                                
                            SafeNativeMethods.SetWaitableTimer(new HandleRef(null, nextHandle), info, 0, nextOwnerCallback, NativeMethods.NullHandleRef, false);                        

                        doneSignal.Set();
                    }                                       
                }                    
            }     
            
            private static void OnAppDomainUnload(object sender, EventArgs args) {                 
                exit = true;
                settingSignal.Set();
            }                   
        }                    
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\services\web\system\web\services\unsafenativemethods.cs ===
//------------------------------------------------------------------------------
// <copyright file="UnsafeNativeMethods.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Web.Services {
    using System;
    using System.Runtime.InteropServices;
    using System.Security.Permissions;
    using System.Web.Services.Interop;
    using System.Security;    

    [ComVisible(false), SuppressUnmanagedCodeSecurity,
    SecurityPermission(SecurityAction.LinkDemand, Flags=SecurityPermissionFlag.UnmanagedCode)]

    internal class UnsafeNativeMethods {

        [DllImport(ExternDll.Ole32, ExactSpelling=true)]
        internal static extern int CoCreateInstance([In] ref Guid clsid,
                                                    [MarshalAs(UnmanagedType.Interface)] object punkOuter,
                                                    int context,
                                                    [In] ref Guid iid,
                                                    [MarshalAs(UnmanagedType.Interface)] out object punk);

        internal static INotifySink2 RegisterNotifySource(INotifyConnection2 connection, INotifySource2 source) {
            return connection.RegisterNotifySource(source);
        }                                                    

        internal static void UnregisterNotifySource(INotifyConnection2 connection, INotifySource2 source) {
            connection.UnregisterNotifySource(source);
        }   
        
        internal static void OnSyncCallOut(INotifySink2 sink, CallId callId, out IntPtr out_ppBuffer, ref int inout_pBufferSize) {
            sink.OnSyncCallOut(callId, out out_ppBuffer, ref inout_pBufferSize);
        }

        internal static void OnSyncCallEnter(INotifySink2 sink, CallId callId, byte[] in_pBuffer, int in_BufferSize) {
            sink.OnSyncCallEnter(callId, in_pBuffer, in_BufferSize);
        }
        
        internal static void OnSyncCallReturn(INotifySink2 sink, CallId callId, byte[] in_pBuffer, int in_BufferSize) {
            sink.OnSyncCallReturn(callId, in_pBuffer, in_BufferSize);
        }

        internal static void OnSyncCallExit(INotifySink2 sink, CallId callId, out IntPtr out_ppBuffer, ref int inout_pBufferSize) {
            sink.OnSyncCallExit(callId, out out_ppBuffer, ref inout_pBufferSize);
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\services\web\system\web\services\nativemethods.cs ===
#if false
//------------------------------------------------------------------------------
// <copyright file="NativeMethods.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Web.Services {
    using System.Runtime.InteropServices;
    using System;
    using System.Security.Permissions;
    using System.Collections;
    using System.IO;
    using System.Text;

    [System.Runtime.InteropServices.ComVisible(false)]
    internal class NativeMethods {

        internal const string Kernel32Name = "kernel32.dll";

        [DllImport(Kernel32Name, CharSet=System.Runtime.InteropServices.CharSet.Auto)]
        internal static extern int GetModuleFileName(int hModule, StringBuilder buffer, int length);
        [DllImport(Kernel32Name, CharSet=System.Runtime.InteropServices.CharSet.Auto)]
        internal static extern int GetModuleHandle(String modName);
    }
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\services\web\system\web\services\webmethodattribute.cs ===
//------------------------------------------------------------------------------
// <copyright file="WebMethodAttribute.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Web.Services {

    using System;
    using System.Reflection;
    using System.Collections;
    using System.Web.Util;
    using System.Web.Services.Protocols;
    using System.Xml.Serialization;
    using System.EnterpriseServices;

    /// <include file='doc\WebMethodAttribute.uex' path='docs/doc[@for="WebMethodAttribute"]/*' />
    /// <devdoc>
    ///    <para> The WebMethod attribute must be placed on a method in a Web Service class to mark it as available
    ///       to be called via the Web. The method and class must be marked public and must run inside of
    ///       an ASP.NET Web application.</para>
    /// </devdoc>
    [AttributeUsage(AttributeTargets.Method)]
    public sealed class WebMethodAttribute : Attribute {
        private int transactionOption; // this is an int to prevent system.enterpriseservices.dll from getting loaded
        private bool enableSession;
        private int cacheDuration;
        private bool bufferResponse;
        private string description;
        private string messageName;

        /// <include file='doc\WebMethodAttribute.uex' path='docs/doc[@for="WebMethodAttribute.WebMethodAttribute"]/*' />
        /// <devdoc>
        /// <para>Initializes a new instance of the <see cref='System.Web.Services.WebMethodAttribute'/> 
        /// class.</para>
        /// </devdoc>
        public WebMethodAttribute() {
            enableSession = false;
            transactionOption = 0; // TransactionOption.Disabled
            cacheDuration = 0;
            bufferResponse = true;
        }

        /// <include file='doc\WebMethodAttribute.uex' path='docs/doc[@for="WebMethodAttribute.WebMethodAttribute1"]/*' />
        /// <devdoc>
        /// <para>Initializes a new instance of the <see cref='System.Web.Services.WebMethodAttribute'/> 
        /// class.</para>
        /// </devdoc>
        public WebMethodAttribute(bool enableSession) 
            : this() {
            this.enableSession = enableSession;
        }

        /// <include file='doc\WebMethodAttribute.uex' path='docs/doc[@for="WebMethodAttribute.WebMethodAttribute2"]/*' />
        /// <devdoc>
        /// <para>Initializes a new instance of the <see cref='System.Web.Services.WebMethodAttribute'/> 
        /// class.</para>
        /// </devdoc>
        public WebMethodAttribute(bool enableSession, TransactionOption transactionOption) 
            : this() {
            this.enableSession = enableSession;
            this.transactionOption = (int)transactionOption;
        }

        /// <include file='doc\WebMethodAttribute.uex' path='docs/doc[@for="WebMethodAttribute.WebMethodAttribute3"]/*' />
        /// <devdoc>
        /// <para>Initializes a new instance of the <see cref='System.Web.Services.WebMethodAttribute'/> 
        /// class.</para>
        /// </devdoc>
        public WebMethodAttribute(bool enableSession, TransactionOption transactionOption, int cacheDuration) {
            this.enableSession = enableSession;
            this.transactionOption = (int)transactionOption;
            this.cacheDuration = cacheDuration;
            bufferResponse = true;
        }

        /// <include file='doc\WebMethodAttribute.uex' path='docs/doc[@for="WebMethodAttribute.WebMethodAttribute4"]/*' />
        /// <devdoc>
        /// <para>Initializes a new instance of the <see cref='System.Web.Services.WebMethodAttribute'/> 
        /// class.</para>
        /// </devdoc>
        public WebMethodAttribute(bool enableSession, TransactionOption transactionOption, int cacheDuration, bool bufferResponse) {
            this.enableSession = enableSession;
            this.transactionOption = (int)transactionOption;
            this.cacheDuration = cacheDuration;
            this.bufferResponse = bufferResponse;
        }

        /// <include file='doc\WebMethodAttribute.uex' path='docs/doc[@for="WebMethodAttribute.Description"]/*' />
        /// <devdoc>
        ///    <para> A message that describes the Web service method. 
        ///       The message is used in description files generated for a Web Service, such as the Service Contract and the Service Description page.</para>
        /// </devdoc>
        public string Description {
            get {
                return (description == null) ? string.Empty : description;
            }

            set {
                description = value;
            }
        }

        /// <include file='doc\WebMethodAttribute.uex' path='docs/doc[@for="WebMethodAttribute.EnableSession"]/*' />
        /// <devdoc>
        ///    <para>Indicates wheter session state is enabled for a Web service Method. The default is false.</para>
        /// </devdoc>
        public bool EnableSession {
            get {
                return enableSession;
            }

            set {
                enableSession = value;
            }
        }

        /// <include file='doc\WebMethodAttribute.uex' path='docs/doc[@for="WebMethodAttribute.CacheDuration"]/*' />
        /// <devdoc>
        ///    <para>Indicates the number of seconds the response should be cached. Defaults to 0 (no caching).
        ///          Should be used with caution when requests are likely to be very large.</para>
        /// </devdoc>
        public int CacheDuration {
            get {
                return cacheDuration;
            }

            set {
                cacheDuration = value;
            }
        }

        /// <include file='doc\WebMethodAttribute.uex' path='docs/doc[@for="WebMethodAttribute.BufferResponse"]/*' />
        /// <devdoc>
        ///    <para>Indicates whether the response for this request should be buffered. Defaults to false.</para>
        /// </devdoc>
        public bool BufferResponse {
            get {
                return bufferResponse;
            }

            set {
                bufferResponse = value;
            }
        }

        /// <include file='doc\WebMethodAttribute.uex' path='docs/doc[@for="WebMethodAttribute.TransactionOption"]/*' />
        /// <devdoc>
        ///    <para> 
        ///       Indicates the transaction participation mode of a Web Service Method. </para>
        /// </devdoc>
        public TransactionOption TransactionOption {            
            get {
                return (TransactionOption)transactionOption;
            }    
            set {
                transactionOption = (int)value;
            }                                        
        }

        internal bool TransactionEnabled {
            get {
                return transactionOption != 0;
            }
        }

        /// <include file='doc\WebMethodAttribute.uex' path='docs/doc[@for="WebMethodAttribute.MessageName"]/*' />
        /// <devdoc>
        ///    <para>The name used for the request and response message containing the 
        ///    data passed to and returned from this method.</para>
        /// </devdoc>
        public string MessageName {
            get {
                return messageName == null ? string.Empty : messageName;
            }

            set {
                messageName = value;
            }
        }
    }

    internal class WebMethodReflector {
        internal static WebMethodAttribute GetAttribute(LogicalMethodInfo method) {
            object[] attrs = method.GetCustomAttributes(typeof(WebMethodAttribute));
            if (attrs.Length == 0) return new WebMethodAttribute();
            return (WebMethodAttribute)attrs[0];
        }

        internal static LogicalMethodInfo[] GetMethods(Type type) {
            ArrayList list = new ArrayList();
            MethodInfo[] methods = type.GetMethods();
            for (int i = 0; i < methods.Length; i++) {
                if (methods[i].GetCustomAttributes(typeof(WebMethodAttribute), false).Length > 0) {
                    list.Add(methods[i]);
                }
            }
            return LogicalMethodInfo.Create((MethodInfo[])list.ToArray(typeof(MethodInfo)));
        }

        internal static void IncludeTypes(LogicalMethodInfo[] methods, XmlReflectionImporter importer) {
            for (int i = 0; i < methods.Length; i++) {
                LogicalMethodInfo method = methods[i];
                importer.IncludeTypes(method.DeclaringType);
                importer.IncludeTypes(method.CustomAttributeProvider);
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\services\web\system\web\services\webservice.cs ===
//------------------------------------------------------------------------------
// <copyright file="WebService.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

/*
 */
namespace System.Web.Services {

    using System.Diagnostics;
    using System.Web;
    using System.ComponentModel;
    using System.Web.SessionState;
    using System.Web.Services.Protocols;
    using System.Security.Principal;
    using System.Security.Permissions;

    /// <include file='doc\WebService.uex' path='docs/doc[@for="WebService"]/*' />
    /// <devdoc>
    ///    <para>Defines the
    ///       optional base class for Web Services, which provides direct access to common
    ///       ASP.NET objects, like those for application and session state.</para>
    /// </devdoc>
    public class WebService : MarshalByValueComponent {

        private HttpContext context;

        /// <include file='doc\WebService.uex' path='docs/doc[@for="WebService.Application"]/*' />
        /// <devdoc>
        ///    <para>Gets a
        ///       reference to the application object for the current HTTP request.</para>
        /// </devdoc>
        [Browsable(false), DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden), Description("The ASP.NET application object for the current request.")]
        public HttpApplicationState Application {
            [AspNetHostingPermission(SecurityAction.LinkDemand, Level=AspNetHostingPermissionLevel.Minimal)]
            get {
                return Context.Application;
            }
        }

        /// <include file='doc\WebService.uex' path='docs/doc[@for="WebService.Context"]/*' />
        /// <devdoc>
        ///    <para>Gets the ASP.NET Context object for the current request,
        ///       which encapsulates all HTTP-specific context
        ///       used by the HTTP server to process Web requests.</para>
        /// </devdoc>
        [Browsable(false), DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden), WebServicesDescription(Res.WebServiceContext)]
        public HttpContext Context {
            [AspNetHostingPermission(SecurityAction.LinkDemand, Level=AspNetHostingPermissionLevel.Minimal)]
            get {
                if (context == null)
                    context = HttpContext.Current;
                if (context == null)
                    throw new InvalidOperationException(Res.GetString(Res.WebMissingHelpContext));
                return context;
            }
        }

        /// <include file='doc\WebService.uex' path='docs/doc[@for="WebService.Session"]/*' />
        /// <devdoc>
        /// <para>Gets a reference to the <see cref='T:System.Web.HttpSessionState'/>
        /// instance for the current request.</para>
        /// </devdoc>
        [Browsable(false), DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden), WebServicesDescription(Res.WebServiceSession)]
        public HttpSessionState Session {
            [AspNetHostingPermission(SecurityAction.LinkDemand, Level=AspNetHostingPermissionLevel.Minimal)]
            get {
                return Context.Session;
            }
        }

        /// <include file='doc\WebService.uex' path='docs/doc[@for="WebService.Server"]/*' />
        /// <devdoc>
        /// <para>Gets a reference to the <see cref='T:System.Web.HttpServerUtility'/>
        /// for the current request.</para>
        /// </devdoc>
        [Browsable(false), DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden), WebServicesDescription(Res.WebServiceServer)]
        public HttpServerUtility Server {
            [AspNetHostingPermission(SecurityAction.LinkDemand, Level=AspNetHostingPermissionLevel.Minimal)]
            get {
                return Context.Server;
            }
        }       

        /// <include file='doc\WebService.uex' path='docs/doc[@for="WebService.User"]/*' />
        /// <devdoc>
        ///    <para>Gets the ASP.NET server User object, used for authorizing the request.</para>
        /// </devdoc>
        [Browsable(false), DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden), WebServicesDescription(Res.WebServiceUser)]
        public IPrincipal User {
            [AspNetHostingPermission(SecurityAction.LinkDemand, Level=AspNetHostingPermissionLevel.Minimal)]
            get {
                return Context.User;
            }
        }

        /// <include file='doc\WebService.uex' path='docs/doc[@for="WebService.SoapVersion"]/*' />
        //[Browsable(false), DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden), WebServicesDescription(Res.WebServiceSoapVersion)]
        // SOAP12: made this internal
        internal SoapProtocolVersion SoapVersion {
            [AspNetHostingPermission(SecurityAction.LinkDemand, Level=AspNetHostingPermissionLevel.Minimal)]
            get {
                object o = Context.Items[SoapVersionContextSlot];
                if (o != null && o is SoapProtocolVersion)
                    return (SoapProtocolVersion)o;
                else
                    return SoapProtocolVersion.Default;
            }
        }

        internal static readonly string SoapVersionContextSlot = "WebServiceSoapVersion";

        internal void SetContext(HttpContext context) {
            this.context = context;
        }

    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\services\web\system\web\services\webserviceattribute.cs ===
//------------------------------------------------------------------------------
// <copyright file="WebServiceAttribute.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Web.Services {

    using System;
    using System.Web.Services.Protocols;

    /// <include file='doc\WebServiceAttribute.uex' path='docs/doc[@for="WebServiceAttribute"]/*' />
    /// <devdoc>
    ///    <para> The WebService attribute may be used to add additional information to a
    ///       Web Service, such as a string describing its functionality. The attribute is not required for a Web Service to
    ///       be published and executed.</para>
    /// </devdoc>
    [AttributeUsage(AttributeTargets.Class)]
    public sealed class WebServiceAttribute : Attribute {
        string description;
        string ns = DefaultNamespace;
        string name;

        /// <include file='doc\WebServiceAttribute.uex' path='docs/doc[@for="WebServiceAttribute.WebServiceAttribute"]/*' />
        /// <devdoc>
        ///    Initializes a new instance of the <see cref='System.Web.Services.WebServiceAttribute'/> class.
        /// </devdoc>
        public WebServiceAttribute() {
        }

        /// <include file='doc\WebServiceAttribute.uex' path='docs/doc[@for="WebServiceAttribute.Description"]/*' />
        /// <devdoc>
        ///    A descriptive message for the Web Service. The message
        ///    is used when generating description documents for the Web Service, such as the
        ///    Sevice Contract and the Service Description page.
        /// </devdoc>
        public string Description {
            get {
                return (description == null) ? string.Empty : description;
            }

            set {
                description = value;
            }
        }

        /// <include file='doc\WebServiceAttribute.uex' path='docs/doc[@for="WebServiceAttribute.Namespace"]/*' />
        /// <devdoc>
        /// The default XML namespace to use for the web service.
        /// </devdoc>
        public string Namespace {
            get {
                return ns;
            }
            set {
                ns = value;
            }
        }

        /// <include file='doc\WebServiceAttribute.uex' path='docs/doc[@for="WebServiceAttribute.Name"]/*' />
        /// <devdoc>
        /// The name to use for the web service in the service description.
        /// </devdoc>
        public string Name {
            get {
                return name == null ? string.Empty : name;
            }
            set {
                name = value;
            }
        }

        /// <include file='doc\WebServiceAttribute.uex' path='docs/doc[@for="WebServiceAttribute.DefaultNamespace"]/*' />
        /// <devdoc>
        /// The default value for the XmlNamespace property.
        /// </devdoc>
        public const string DefaultNamespace = "http://tempuri.org/";
    }

    internal class WebServiceReflector {
        internal static WebServiceAttribute GetAttribute(Type type) {
            object[] attrs = type.GetCustomAttributes(typeof(WebServiceAttribute), false);
            if (attrs.Length == 0) return new WebServiceAttribute();
            return (WebServiceAttribute)attrs[0];
        }

        internal static WebServiceAttribute GetAttribute(LogicalMethodInfo[] methodInfos) {
            if (methodInfos.Length == 0) return new WebServiceAttribute();
            Type mostDerived = GetMostDerivedType(methodInfos);
            return GetAttribute(mostDerived);
        }

        internal static Type GetMostDerivedType(LogicalMethodInfo[] methodInfos) {
            if (methodInfos.Length == 0) return null;
            Type mostDerived = methodInfos[0].DeclaringType;
            for (int i = 1; i < methodInfos.Length; i++) {
                Type derived = methodInfos[i].DeclaringType;
                if (derived.IsSubclassOf(mostDerived)) {
                    mostDerived = derived;
                }
            }
            return mostDerived;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\services\web\system\web\services\webservicesdescriptionattribute.cs ===
//------------------------------------------------------------------------------
// <copyright file="WebServicesDescriptionAttribute.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Web.Services {


    using System;
    using System.ComponentModel;   

    /// <include file='doc\WebServicesDescriptionAttribute.uex' path='docs/doc[@for="WebServicesDescriptionAttribute"]/*' />
    /// <devdoc>
    ///     DescriptionAttribute marks a property, event, or extender with a
    ///     description. Visual designers can display this description when referencing
    ///     the member.
    /// </devdoc>
    [AttributeUsage(AttributeTargets.All)]
    internal class WebServicesDescriptionAttribute : DescriptionAttribute {

        private bool replaced = false;

        /// <include file='doc\WebServicesDescriptionAttribute.uex' path='docs/doc[@for="WebServicesDescriptionAttribute.WebServicesDescriptionAttribute"]/*' />
        /// <devdoc>
        ///     Constructs a new sys description.
        /// </devdoc>
        internal WebServicesDescriptionAttribute(string description) : base(description) {
        }

        /// <include file='doc\WebServicesDescriptionAttribute.uex' path='docs/doc[@for="WebServicesDescriptionAttribute.Description"]/*' />
        /// <devdoc>
        ///     Retrieves the description text.
        /// </devdoc>
        public override string Description {
            get {
                if (!replaced) {
                    replaced = true;
                    DescriptionValue = Res.GetString(base.Description);
                }
                return base.Description;
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\services\web\system\web\services\webservicebindingattribute.cs ===
//------------------------------------------------------------------------------
// <copyright file="WebServiceBindingAttribute.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Web.Services {

    using System;
    using System.Web.Services.Protocols;

    /// <include file='doc\WebServiceBindingAttribute.uex' path='docs/doc[@for="WebServiceBindingAttribute"]/*' />
    /// <devdoc>
    ///    <para>[To be supplied.]</para>
    /// </devdoc>
    [AttributeUsage(AttributeTargets.Class, AllowMultiple=true)]
    public sealed class WebServiceBindingAttribute : Attribute {
        string name;
        string ns;
        string location;

        /// <include file='doc\WebServiceBindingAttribute.uex' path='docs/doc[@for="WebServiceBindingAttribute.WebServiceBindingAttribute"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public WebServiceBindingAttribute() {
        }

        /// <include file='doc\WebServiceBindingAttribute.uex' path='docs/doc[@for="WebServiceBindingAttribute.WebServiceBindingAttribute1"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public WebServiceBindingAttribute(string name) {
            this.name = name;
        }

        /// <include file='doc\WebServiceBindingAttribute.uex' path='docs/doc[@for="WebServiceBindingAttribute.WebServiceBindingAttribute2"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public WebServiceBindingAttribute(string name, string ns) {
            this.name = name;
            this.ns = ns;
        }

        /// <include file='doc\WebServiceBindingAttribute.uex' path='docs/doc[@for="WebServiceBindingAttribute.WebServiceBindingAttribute3"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public WebServiceBindingAttribute(string name, string ns, string location) {
            this.name = name;
            this.ns = ns;
            this.location = location;
        }

        /// <include file='doc\WebServiceBindingAttribute.uex' path='docs/doc[@for="WebServiceBindingAttribute.Location"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public string Location {
            get { return location == null ? string.Empty : location; }
            set { location = value; }
        }

        /// <include file='doc\WebServiceBindingAttribute.uex' path='docs/doc[@for="WebServiceBindingAttribute.Name"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public string Name {
            get { return name == null ? string.Empty : name; }
            set { name = value; }
        }

        /// <include file='doc\WebServiceBindingAttribute.uex' path='docs/doc[@for="WebServiceBindingAttribute.Namespace"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public string Namespace {
            get { return ns == null ? string.Empty : ns; }
            set { ns = value; }
        }
    }

    internal class WebServiceBindingReflector {
        internal static WebServiceBindingAttribute GetAttribute(Type type) {
            for (; type != null; type = type.BaseType) {
                object[] attrs = type.GetCustomAttributes(typeof(WebServiceBindingAttribute), false);
                if (attrs.Length == 0) continue;
                if (attrs.Length > 1) throw new ArgumentException(Res.GetString(Res.OnlyOneWebServiceBindingAttributeMayBeSpecified1, type.FullName), "type");
                return (WebServiceBindingAttribute)attrs[0];
            }
            return null;
        }

        internal static WebServiceBindingAttribute GetAttribute(LogicalMethodInfo methodInfo, string binding) {
            Type type = methodInfo.DeclaringType;
            object[] attrs = type.GetCustomAttributes(typeof(WebServiceBindingAttribute), false);
            foreach (WebServiceBindingAttribute attr in attrs) {
                if (attr.Name == binding) {
                    return attr;
                }
            }
            throw new ArgumentException(Res.GetString(Res.TypeIsMissingWebServiceBindingAttributeThat2, type.FullName, binding), "methodInfo");
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\services\web\system\web\services\configuration\webservicesconfigurationsectionhandler.cs ===
//------------------------------------------------------------------------------
// <copyright file="WebServicesConfigurationSectionHandler.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Web.Services.Configuration {

    using System;
    using System.Collections;
    using System.Configuration;
    using System.Diagnostics;
    using System.Xml;
    using System.Security.Permissions;
    using System.Web.Configuration;
    using System.IO;

    /// <include file='doc\WebServicesConfigurationSectionHandler.uex' path='docs/doc[@for="WebServicesConfigurationSectionHandler"]/*' />
    /// <devdoc>
    ///    The configuration section handler for the
    ///    webServices section of the Config.Web configuration file. The section handler
    ///    participates in the resolution of configuration settings between the
    ///    &lt;webServices&gt; and &lt;/webServices&gt;portion of a Config.Web.
    /// </devdoc>
    internal sealed class WebServicesConfigurationSectionHandler : IConfigurationSectionHandler {

        /// <include file='doc\WebServicesConfigurationSectionHandler.uex' path='docs/doc[@for="WebServicesConfigurationSectionHandler.Create"]/*' />
        /// <devdoc>
        ///    <para>Parses the configuration settings between the 
        ///       &lt;webServices&gt; and &lt;/webServices&gt; portion of a Config.Web to populate
        ///       the values of a 'WebServicesConfiguration' object and returning it.
        ///    </para>
        /// </devdoc>
        // SECURITY: we need to assert this permission since the fields we're setting here
        // are on internal class WebServicesConfiguration
        [ReflectionPermission(SecurityAction.Assert, Flags = ReflectionPermissionFlag.MemberAccess)]
        public object Create(object parent, object configContext, XmlNode section) {
            WebServicesConfiguration config = new WebServicesConfiguration();
            WebServicesConfiguration parentConfig = (WebServicesConfiguration)parent;

            // CONSIDER, yannc: perhaps we should just get rid of reflection by dropping the table driven approach?
            if (parentConfig != null)
                config.InitializeFromParent(parentConfig);
                
            foreach (XmlNode child in section.ChildNodes) {
                // skip whitespace and comments
                if (child.NodeType == XmlNodeType.Comment || child.NodeType == XmlNodeType.Whitespace)
                    continue;
                    
                // reject nonelements
                if (child.NodeType != XmlNodeType.Element)
                    throw new ConfigurationException(Res.GetString(Res.WebConfigMissingElement), child);

                string listName = child.Name;

                ConfigField field = ConfigField.FindByElementName(listName);
                if (field == null) throw new ConfigurationException(Res.GetString(Res.WebConfigInvalidSection, listName),  child);

                if (field.Kind == ConfigFieldKind.WsdlHelpGenerator) {
                    ProcessWsdlHelpGenerator(child, configContext, config);
                }
                else if (field.Kind == ConfigFieldKind.Types) {
                    ArrayList list = new ArrayList((Type[])field.GetValue(config));
                    ProcessElementList(child.ChildNodes, listName, list, "type", typeof(Type));
                    field.SetValue(config, list.ToArray(typeof(Type)));
                }
                else if (field.Kind == ConfigFieldKind.SoapExtensionTypes) {
                    ArrayList list = new ArrayList((SoapExtensionType[])field.GetValue(config));
                    ProcessElementList(child.ChildNodes, listName, list, "type", typeof(SoapExtensionType));
                    field.SetValue(config, list.ToArray(typeof(SoapExtensionType)));
                }
                else if (field.Kind == ConfigFieldKind.NameString) {
                    ArrayList list = new ArrayList((string[])field.GetValue(config));
                    ProcessElementList(child.ChildNodes, listName, list, "name", typeof(String));
                    field.SetValue(config, list.ToArray(typeof(String)));
                }
                HandlerBase.CheckForUnrecognizedAttributes(child);
            }
            HandlerBase.CheckForUnrecognizedAttributes(section);

            return config;
        }

        void ProcessWsdlHelpGenerator(XmlNode child, object configContext, WebServicesConfiguration config) {
            string href = null;
            XmlNode attribute = HandlerBase.GetAndRemoveRequiredStringAttribute(child, "href", ref href);

            // If we're not running in the context of a web application then skip this setting.
            HttpConfigurationContext httpConfigContext = configContext as HttpConfigurationContext;            
            if (httpConfigContext == null)
                return;

            if (href == null) 
                throw new ConfigurationException(Res.GetString(Res.Missing_required_attribute, attribute, child.Name), child);

            if (href.Length == 0)
                return;
            
            HandlerBase.CheckForChildNodes(child);
            
            HttpContext context = HttpContext.Current;

            // There can be no context in the case of webless test because the client
            // runs in the same app domain as ASP.NET so we get an httpconfig object but no context.
            if (context == null)
                return;

            string virtualPath = httpConfigContext.VirtualPath;
            string path;
            bool isMachineConfig = virtualPath == null;
            // If the help page is not in the web app directory hierarchy (the case 
            // for those specified in machine.config like DefaultWsdlHelpGenerator.aspx)
            // then we can't construct a true virtual path. This means that certain web 
            // form features that rely on relative paths won't work.
            if (isMachineConfig)
                virtualPath = context.Request.ApplicationPath;
            if (virtualPath[virtualPath.Length-1] != '/')
                virtualPath += "/";
            virtualPath += href;
            if (isMachineConfig)
                path = Path.Combine(GetConfigurationDirectory(), href);
            else
                path = context.Request.MapPath(virtualPath);                

            config.WsdlHelpGeneratorPath = path;
            config.WsdlHelpGeneratorVirtualPath = virtualPath;
        }

        [FileIOPermission(SecurityAction.Assert, Unrestricted=true)]
        private string GetConfigurationDirectory() {
            return HttpRuntime.MachineConfigurationDirectory;
        }

        void ProcessElementList(XmlNodeList children, String listName, ArrayList list, string attributeName, Type itemType) {
            foreach (XmlNode listNode in children) {
                // skip whitespace and comments
                if (listNode.NodeType == XmlNodeType.Comment || listNode.NodeType == XmlNodeType.Whitespace)
                    continue;
        
                // reject nonelements
                if (listNode.NodeType != XmlNodeType.Element)
                    throw new ConfigurationException(Res.GetString(Res.WebConfigMissingElement), listNode);

                switch (listNode.Name) {
                    case "add":
                    case "remove":
                    case "clear":
                        break;
                    default:
                        throw new ConfigurationException(Res.GetString(Res.WebConfigUnrecognizedElement, listNode.Name, listName), listNode);
                }

                if (listNode.Name == "clear") {
                    HandlerBase.CheckForUnrecognizedAttributes(listNode);
                    HandlerBase.CheckForChildNodes(listNode);
                    list.Clear();
                    continue;
                }
                object value = null;

                bool soapExtensionType = false;
                if (itemType == typeof(Type)){
                        Type t = null;
                        HandlerBase.GetAndRemoveRequiredTypeAttribute(listNode, attributeName, ref t);
                        value = t;
                }
                else if (itemType == typeof(string)){
                        string s = null;
                        HandlerBase.GetAndRemoveRequiredStringAttribute(listNode, attributeName, ref s);
                        value = s;
                        if (listName == "protocols" && WebServicesConfiguration.GetProtocol(s) == ProtocolsEnum.Unknown) 
                            throw new ConfigurationException(Res.GetString(Res.UnknownWebServicesProtocolInConfigFile1, s), listNode);
                }
                else if (itemType ==  typeof(SoapExtensionType)){
                        SoapExtensionType extension = new SoapExtensionType();
                        int group = 1; // "low" is default
                        int priority = 0;

                        HandlerBase.GetAndRemoveRequiredTypeAttribute(listNode, attributeName, ref extension.Type);
                        if (listNode.Name == "add") {
                            HandlerBase.GetAndRemoveIntegerAttribute(listNode, "priority", ref priority);
                            HandlerBase.GetAndRemoveIntegerAttribute(listNode, "group", ref group);
                        }
                        
                        if (priority < 0) throw new ConfigurationException(Res.GetString(Res.WebConfigInvalidExtensionPriority, priority), listNode);
                        extension.Priority = priority;

                        switch (group) {
                            case 0: 
                                extension.Group = SoapExtensionType.PriorityGroup.High;
                                break;
                            case 1:
                                extension.Group = SoapExtensionType.PriorityGroup.Low;
                                break;
                            default:
                                throw new ConfigurationException(Res.GetString(Res.WebConfigInvalidExtensionGroup, group), listNode);
                        }

                        value = extension;
                        soapExtensionType = true;
                }
                else {
                        throw new ConfigurationException(Res.GetString(Res.InternalConfigurationError0));
                }

                if (listNode.Name == "add") {
                    if (soapExtensionType || !list.Contains(value))
                        list.Add(value);
                }
                else if (listNode.Name == "remove") {
                    if (soapExtensionType) {
                        // need to remove all occurrences
                        SoapExtensionType ext = (SoapExtensionType)value;
                        ArrayList removals = new ArrayList();
                        foreach (object o in list) {
                            if (o is SoapExtensionType && ((SoapExtensionType)o).Type == ext.Type)
                                removals.Add(o);
                        }
                        foreach (object o in removals) {
                            list.Remove(o);
                        }
                    }
                    else
                        list.Remove(value);
                }
                HandlerBase.CheckForUnrecognizedAttributes(listNode);
                HandlerBase.CheckForChildNodes(listNode);
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\services\web\system\web\services\configuration\xmlformatextensionpointattribute.cs ===
//------------------------------------------------------------------------------
// <copyright file="XmlFormatExtensionPointAttribute.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Web.Services.Configuration {

    using System;

    /// <include file='doc\XmlFormatExtensionPointAttribute.uex' path='docs/doc[@for="XmlFormatExtensionPointAttribute"]/*' />
    /// <devdoc>
    ///    <para>[To be supplied.]</para>
    /// </devdoc>
    [AttributeUsage(AttributeTargets.Class)]
    public sealed class XmlFormatExtensionPointAttribute : Attribute {
        string name;
        bool allowElements = true;

        /// <include file='doc\XmlFormatExtensionPointAttribute.uex' path='docs/doc[@for="XmlFormatExtensionPointAttribute.XmlFormatExtensionPointAttribute"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public XmlFormatExtensionPointAttribute(string memberName) {
            this.name = memberName;
        }

        /// <include file='doc\XmlFormatExtensionPointAttribute.uex' path='docs/doc[@for="XmlFormatExtensionPointAttribute.MemberName"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public string MemberName {
            get { return name == null ? string.Empty : name; }
            set { name = value; }
        }

        /// <include file='doc\XmlFormatExtensionPointAttribute.uex' path='docs/doc[@for="XmlFormatExtensionPointAttribute.AllowElements"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public bool AllowElements {
            get { return allowElements; }
            set { allowElements = value; }
        }
    }


}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\services\web\system\web\services\configuration\xmlformatextensionattribute.cs ===
//------------------------------------------------------------------------------
// <copyright file="XmlFormatExtensionAttribute.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Web.Services.Configuration {

    using System;

    /// <include file='doc\XmlFormatExtensionAttribute.uex' path='docs/doc[@for="XmlFormatExtensionAttribute"]/*' />
    /// <devdoc>
    ///    <para>[To be supplied.]</para>
    /// </devdoc>
    [AttributeUsage(AttributeTargets.Class)]
    public sealed class XmlFormatExtensionAttribute : Attribute {
        Type[] types;
        string name;
        string ns;

        /// <include file='doc\XmlFormatExtensionAttribute.uex' path='docs/doc[@for="XmlFormatExtensionAttribute.XmlFormatExtensionAttribute"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public XmlFormatExtensionAttribute() {
        }

        /// <include file='doc\XmlFormatExtensionAttribute.uex' path='docs/doc[@for="XmlFormatExtensionAttribute.XmlFormatExtensionAttribute2"]/*' />
        public XmlFormatExtensionAttribute(string elementName, string ns, Type extensionPoint1) : this(elementName, ns, new Type[] {extensionPoint1}) {
        }
        /// <include file='doc\XmlFormatExtensionAttribute.uex' path='docs/doc[@for="XmlFormatExtensionAttribute.XmlFormatExtensionAttribute3"]/*' />
        public XmlFormatExtensionAttribute(string elementName, string ns, Type extensionPoint1, Type extensionPoint2) : this(elementName, ns, new Type[] {extensionPoint1, extensionPoint2}) {
        }
        /// <include file='doc\XmlFormatExtensionAttribute.uex' path='docs/doc[@for="XmlFormatExtensionAttribute.XmlFormatExtensionAttribute4"]/*' />
        public XmlFormatExtensionAttribute(string elementName, string ns, Type extensionPoint1, Type extensionPoint2, Type extensionPoint3) : this(elementName, ns, new Type[] {extensionPoint1, extensionPoint2, extensionPoint3}) {
        }
        /// <include file='doc\XmlFormatExtensionAttribute.uex' path='docs/doc[@for="XmlFormatExtensionAttribute.XmlFormatExtensionAttribute5"]/*' />
        public XmlFormatExtensionAttribute(string elementName, string ns, Type extensionPoint1, Type extensionPoint2, Type extensionPoint3, Type extensionPoint4) : this(elementName, ns, new Type[] {extensionPoint1, extensionPoint2, extensionPoint3, extensionPoint4}) {
        }

        /// <include file='doc\XmlFormatExtensionAttribute.uex' path='docs/doc[@for="XmlFormatExtensionAttribute.XmlFormatExtensionAttribute1"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public XmlFormatExtensionAttribute(string elementName, string ns, Type[] extensionPoints) {
            this.name = elementName;
            this.ns = ns;
            this.types = extensionPoints;
        }

        /// <include file='doc\XmlFormatExtensionAttribute.uex' path='docs/doc[@for="XmlFormatExtensionAttribute.ExtensionPoints"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public Type[] ExtensionPoints {
            get { return types == null ? new Type[0] : types; }
            set { types = value; }
        }

        /// <include file='doc\XmlFormatExtensionAttribute.uex' path='docs/doc[@for="XmlFormatExtensionAttribute.Namespace"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public string Namespace {
            get { return ns == null ? string.Empty : ns; }
            set { ns = value; }
        }

        /// <include file='doc\XmlFormatExtensionAttribute.uex' path='docs/doc[@for="XmlFormatExtensionAttribute.ElementName"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public string ElementName {
            get { return name == null ? string.Empty : name; }
            set { name = value; }
        }
    }

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\services\web\system\web\services\configuration\handlerbase.cs ===
//------------------------------------------------------------------------------
// <copyright file="HandlerBase.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

//
// HandlerBase contains static helper functions for consistent XML parsing 
// behavior and error messages.
//
// Copyright (c) 1998 Microsoft Corporation
//

#if !LIB

namespace System.Web.Services.Configuration {

    using System.Configuration;
    using System.Globalization;
    using System.Xml;


    internal class HandlerBase {


        //
        // XML Attribute Helpers
        //

        private static XmlNode GetAndRemoveAttribute(XmlNode node, string attrib, bool fRequired) {
            XmlNode a = node.Attributes.RemoveNamedItem(attrib);

            // If the attribute is required and was not present, throw
            if (fRequired && a == null) {
                throw new ConfigurationException(
                    Res.GetString(Res.Missing_required_attribute, attrib, node.Name),
                    node);
            }

            return a;
        }

        private static XmlNode GetAndRemoveStringAttributeInternal(XmlNode node, string attrib, bool fRequired, ref string val) {
            XmlNode a = GetAndRemoveAttribute(node, attrib, fRequired);
            if (a != null)
                val = a.Value;

            return a;
        }

        internal static XmlNode GetAndRemoveStringAttribute(XmlNode node, string attrib, ref string val) {
            return GetAndRemoveStringAttributeInternal(node, attrib, false /*fRequired*/, ref val);
        }

        internal static XmlNode GetAndRemoveRequiredStringAttribute(XmlNode node, string attrib, ref string val) {
            return GetAndRemoveStringAttributeInternal(node, attrib, true /*fRequired*/, ref val);
        }

        // input.Xml cursor must be at a true/false XML attribute
        private static XmlNode GetAndRemoveBooleanAttributeInternal(XmlNode node, string attrib, bool fRequired, ref bool val) {
            XmlNode a = GetAndRemoveAttribute(node, attrib, fRequired);
            if (a != null) {
                try {
                    val = bool.Parse(a.Value);
                }
                catch (Exception e) {
                    throw new ConfigurationException(
                                    Res.GetString(Res.Invalid_boolean_attribute, a.Name),
                                    e, a);
                }
            }

            return a;
        }

        internal static XmlNode GetAndRemoveRequiredBooleanAttribute(XmlNode node, string attrib, ref bool val) {
            return GetAndRemoveBooleanAttributeInternal(node, attrib, true /*fRequired*/, ref val);
        }

        // input.Xml cursor must be an integer XML attribute
        private static XmlNode GetAndRemoveIntegerAttributeInternal(XmlNode node, string attrib, bool fRequired, ref int val) {
            XmlNode a = GetAndRemoveAttribute(node, attrib, fRequired);
            if (a != null) {
                try {
                    val = int.Parse(a.Value, CultureInfo.InvariantCulture);
                }
                catch (Exception e) {
                    throw new ConfigurationException(
                        Res.GetString(Res.Invalid_integer_attribute, a.Name),
                        e, a);
                }
            }

            return a;
        }

        internal static XmlNode GetAndRemoveIntegerAttribute(XmlNode node, string attrib, ref int val) {
            return GetAndRemoveIntegerAttributeInternal(node, attrib, false /*fRequired*/, ref val);
        }

        private static XmlNode GetAndRemoveTypeAttributeInternal(XmlNode node, string attrib, bool fRequired, ref Type val) {
            XmlNode a = GetAndRemoveAttribute(node, attrib, fRequired);

            if (a != null) {
                try {
                    val = Type.GetType(a.Value, true /*throwOnError*/);
                }
                catch (Exception e) {
                    throw new ConfigurationException(
                        Res.GetString(Res.Invalid_type_attribute, a.Name),
                        e, a);
                }
            }

            return a;
        }

        internal static XmlNode GetAndRemoveRequiredTypeAttribute(XmlNode node, string attrib, ref Type val) {
            return GetAndRemoveTypeAttributeInternal(node, attrib, true /*fRequired*/, ref val);
        }

        internal static void CheckForUnrecognizedAttributes(XmlNode node) {
            if (node.Attributes.Count != 0) {
                throw new ConfigurationException(
                                Res.GetString(Res.Config_base_unrecognized_attribute, node.Attributes[0].Name),
                                node);                
            }
        }

        internal static void CheckForChildNodes(XmlNode node) {
            if (node.HasChildNodes) {
                throw new ConfigurationException(
                                Res.GetString(Res.Config_base_no_child_nodes),
                                node.FirstChild);                
            }
        }

#if false // dead code
        internal static XmlNode GetAndRemoveBooleanAttribute(XmlNode node, string attrib, ref bool val) {
            return GetAndRemoveBooleanAttributeInternal(node, attrib, false /*fRequired*/, ref val);
        }

        internal static XmlNode GetAndRemoveRequiredIntegerAttribute(XmlNode node, string attrib, ref int val) {
            return GetAndRemoveIntegerAttributeInternal(node, attrib, true /*fRequired*/, ref val);
        }

        private static XmlNode GetAndRemovePositiveIntegerAttributeInternal(XmlNode node, string attrib, bool fRequired, ref int val) {
            XmlNode a = GetAndRemoveIntegerAttributeInternal(node, attrib, fRequired, ref val);

            if (a != null && val < 0) {
                throw new ConfigurationException(
                    Res.GetString(Res.Invalid_positive_integer_attribute, attrib),
                    node);
            }

            return a;
        }

        internal static XmlNode GetAndRemovePositiveIntegerAttribute(XmlNode node, string attrib, ref int val) {
            return GetAndRemovePositiveIntegerAttributeInternal(node, attrib, false /*fRequired*/, ref val);
        }

        internal static XmlNode GetAndRemoveRequiredPositiveIntegerAttribute(XmlNode node, string attrib, ref int val) {
            return GetAndRemovePositiveIntegerAttributeInternal(node, attrib, false /*fRequired*/, ref val);
        }

        internal static XmlNode GetAndRemoveTypeAttribute(XmlNode node, string attrib, ref Type val) {
            return GetAndRemoveTypeAttributeInternal(node, attrib, false /*fRequired*/, ref val);
        }

        // if attribute not found return null
        internal static string RemoveAttribute(XmlNode node, string name) {

            XmlNode attribute = node.Attributes.RemoveNamedItem(name);

            if (attribute != null) {
                return attribute.Value;
            }

            return null;
        }

        // if attr not found throw standard message - "attribute x required"
        internal static string RemoveRequiredAttribute(XmlNode node, string name) {
            XmlNode attribute = node.Attributes.RemoveNamedItem(name);

            if (attribute == null) {
                throw new ConfigurationException(
                                Res.GetString(Res.Config_base_required_attribute_missing, name),
                                node);                
            }

            if (attribute.Value == string.Empty) {
                throw new ConfigurationException(
                                Res.GetString(Res.Config_base_required_attribute_empty, name),
                                node);                
            }

            return attribute.Value;
        }



        //
        // XML Element Helpers
        //

        internal static void CheckForNonElement(XmlNode node) {
            if (node.NodeType != XmlNodeType.Element) {
                throw new ConfigurationException(
                                Res.GetString(Res.Config_base_elements_only),
                                node);                
            }
        }


        internal static bool IsIgnorableAlsoCheckForNonElement(XmlNode node) {
            if (node.NodeType == XmlNodeType.Comment || node.NodeType == XmlNodeType.Whitespace) {
                return true;
            }

			CheckForNonElement(node);

			return false;
        }

        internal static void ThrowUnrecognizedElement(XmlNode node) {
            throw new ConfigurationException(
                            Res.GetString(Res.Config_base_unrecognized_element),
                            node);
        }
#endif
        // 
        // Parse Helpers
        // 

        // CONSIDER: ParseBool
        // CONSIDER: ParseInt
        // CONSIDER: more
    }
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\services\web\system\web\services\configuration\xmlformatextensionprefixattribute.cs ===
//------------------------------------------------------------------------------
// <copyright file="XmlFormatExtensionPrefixAttribute.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Web.Services.Configuration {

    using System;

    /// <include file='doc\XmlFormatExtensionPrefixAttribute.uex' path='docs/doc[@for="XmlFormatExtensionPrefixAttribute"]/*' />
    /// <devdoc>
    ///    <para>[To be supplied.]</para>
    /// </devdoc>
    [AttributeUsage(AttributeTargets.Class, AllowMultiple=true)]
    public sealed class XmlFormatExtensionPrefixAttribute : Attribute {
        string prefix;
        string ns;

        /// <include file='doc\XmlFormatExtensionPrefixAttribute.uex' path='docs/doc[@for="XmlFormatExtensionPrefixAttribute.XmlFormatExtensionPrefixAttribute"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public XmlFormatExtensionPrefixAttribute() {
        }

        /// <include file='doc\XmlFormatExtensionPrefixAttribute.uex' path='docs/doc[@for="XmlFormatExtensionPrefixAttribute.XmlFormatExtensionPrefixAttribute1"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public XmlFormatExtensionPrefixAttribute(string prefix, string ns) {
            this.prefix = prefix;
            this.ns = ns;
        }

        /// <include file='doc\XmlFormatExtensionPrefixAttribute.uex' path='docs/doc[@for="XmlFormatExtensionPrefixAttribute.Prefix"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public string Prefix {
            get { return prefix == null ? string.Empty : prefix; }
            set { prefix = value; }
        }

        /// <include file='doc\XmlFormatExtensionPrefixAttribute.uex' path='docs/doc[@for="XmlFormatExtensionPrefixAttribute.Namespace"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public string Namespace {
            get { return ns == null ? string.Empty : ns; }
            set { ns = value; }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\services\web\system\web\services\configuration\webservicesconfiguration.cs ===
//------------------------------------------------------------------------------
// <copyright file="WebServicesConfiguration.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Web.Services.Configuration {

    using System.Collections;
    using System;
    using System.Xml.Serialization;
    using System.Configuration;
    using System.Web.Configuration;
    using System.Web.Services.Description;
    using System.Web.Services.Protocols;
    using System.Web.Services.Discovery;
    using System.Diagnostics;
    using System.Runtime.InteropServices;
    using System.Reflection;
    using System.Xml;
    using System.Globalization;
    
    /// <include file='doc\WebServicesConfiguration.uex' path='docs/doc[@for="WebServicesConfiguration"]/*' />
    /// <devdoc>
    ///    <para>Contains configuration information for the web service runtime. The information is loaded from the webServices section
    ///       of the machine.config or web.config configuration file.</para>
    /// </devdoc>
    internal class WebServicesConfiguration {
        static Type[] emptyTypeArray = new Type[0];
        static String[] emptyStringArray = new String[0];
        static SoapExtensionType[] emptySoapExtensionTypeArray = new SoapExtensionType[0];
        internal bool internalDefaultsInitialized;
        ProtocolsEnum enabledProtocols;

        // To add a value/section to web services configuraton, do the following:
        // - add it to the Fields array
        // - add a member variable
        // - add a default value in SetDefaults
        // - use existing ConfigFieldKinds, or invent new ones as necessary
        // - Update InitializeFromParent to copy new property from parent to child config

        static ConfigField[] fields = new ConfigField[] {
//            new ConfigField("ProtocolTypes", "protocolTypes", ConfigFieldKind.Types),
//            new ConfigField("ReturnWriterTypes", "returnWriterTypes", ConfigFieldKind.Types),
//            new ConfigField("ParameterReaderTypes", "parameterReaderTypes", ConfigFieldKind.Types),
//            new ConfigField("ProtocolReflectorTypes", "protocolReflectorTypes", ConfigFieldKind.Types),
//            new ConfigField("MimeReflectorTypes", "mimeReflectorTypes", ConfigFieldKind.Types),
//            new ConfigField("ProtocolImporterTypes", "protocolImporterTypes", ConfigFieldKind.Types),
//            new ConfigField("MimeImporterTypes", "mimeImporterTypes", ConfigFieldKind.Types),
            new ConfigField("Protocols", "protocols", ConfigFieldKind.NameString),
            new ConfigField("WsdlHelpGeneratorPath", "wsdlHelpGenerator", ConfigFieldKind.WsdlHelpGenerator),
            new ConfigField("SoapExtensionTypes", "soapExtensionTypes", ConfigFieldKind.SoapExtensionTypes),
            new ConfigField("SoapExtensionImporterTypes", "soapExtensionImporterTypes", ConfigFieldKind.Types),
            new ConfigField("SoapExtensionReflectorTypes", "soapExtensionReflectorTypes", ConfigFieldKind.Types),
            new ConfigField("SoapTransportImporterTypes", "soapTransportImporterTypes", ConfigFieldKind.Types),
            new ConfigField("ServiceDescriptionFormatExtensionTypes", "serviceDescriptionFormatExtensionTypes", ConfigFieldKind.Types),
        };

        static Type[] protocolReflectorTypes;
        static Type[] protocolImporterTypes;
        static Type[] returnWriterTypes;
        static Type[] parameterReaderTypes;
        static Type[] mimeReflectorTypes;
        static Type[] mimeImporterTypes;
        static Type[] soapTransportImporterTypes;
        static Type[] defaultFormatTypes;
        static Type[] discoveryReferenceTypes;
        
        String[] protocols = emptyStringArray;
        ServerProtocolFactory[] serverProtocolFactories = null;
        string wsdlHelpGeneratorPath;
        string wsdlHelpGeneratorVirtualPath;
        SoapExtensionType[] soapExtensionTypes = emptySoapExtensionTypeArray;
        Type[] soapExtensionImporterTypes = emptyTypeArray;
        Type[] soapExtensionReflectorTypes = emptyTypeArray;
        

        Type[] serviceDescriptionFormatExtensionTypes = emptyTypeArray;


        internal bool ServiceDescriptionExtended {
            get {
                return serviceDescriptionFormatExtensionTypes != defaultFormatTypes;
            }
        }

        internal static ConfigField[] Fields {
            get {
                return fields;
            }
        }
        
        internal ProtocolsEnum EnabledProtocols {
            get { return enabledProtocols; }
        }

        internal String[] Protocols {
            get {
                return protocols;
            }

            set {
                protocols = value;
            }
        }

        /// <include file='doc\WebServicesConfiguration.uex' path='docs/doc[@for="WebServicesConfiguration.ServerProtocolFactories"]/*' />
        /// <devdoc>
        ///    <para>An array of all protocols capable of accessing Web Services on the server.</para>
        /// </devdoc>
        
        internal ServerProtocolFactory[] ServerProtocolFactories {
            get {
                return serverProtocolFactories;
            }
        }

        /// <include file='doc\WebServicesConfiguration.uex' path='docs/doc[@for="WebServicesConfiguration.ReturnWriterTypes"]/*' />
        /// <devdoc>
        ///    <para> An array of object
        ///       serialization formats for returning data to a Web Service client.</para>
        /// </devdoc>
        internal Type[] ReturnWriterTypes {
            get {
                return returnWriterTypes;
            }
            set {
                returnWriterTypes = value;
            }
        }

        /// <include file='doc\WebServicesConfiguration.uex' path='docs/doc[@for="WebServicesConfiguration.ParameterReaderTypes"]/*' />
        /// <devdoc>
        ///    <para>An array of types that deserialize parameters sent from a
        ///       Web Service clients to the server.</para>
        /// </devdoc>
        internal Type[] ParameterReaderTypes {
            get {
                return parameterReaderTypes;
            }
            set {
                parameterReaderTypes = value;
            }
        }

        /// <include file='doc\WebServicesConfiguration.uex' path='docs/doc[@for="WebServicesConfiguration.ProtocolReflectorTypes"]/*' />
        /// <devdoc>
        ///    <para>An array of types that generate a Service Contract from a class.</para>
        /// </devdoc>
        internal Type[] ProtocolReflectorTypes {
            get {
                return protocolReflectorTypes;
            }
            set {
                protocolReflectorTypes = value;
            }
        }

        /// <include file='doc\WebServicesConfiguration.uex' path='docs/doc[@for="WebServicesConfiguration.MimeReflectorTypes"]/*' />
        /// <devdoc>
        ///    <para>An array of types that convert Web Service Method 
        ///       parameters and return data types into MIME types, which are used in
        ///       the generation of a Service Contract for a given Web Service.</para>
        /// </devdoc>
        internal Type[] MimeReflectorTypes {
            get {
                return mimeReflectorTypes;
            }
            set {
                mimeReflectorTypes = value;
            }
        }

        /// <include file='doc\WebServicesConfiguration.uex' path='docs/doc[@for="WebServicesConfiguration.ProtocolImporterTypes"]/*' />
        /// <devdoc>
        ///    <para>An array of types that generate a client proxy from a Service Contract.</para>
        /// </devdoc>
        internal Type[] ProtocolImporterTypes {
            get {
                return protocolImporterTypes;
            }
            set {
                protocolImporterTypes = value;
            }
        }

        /// <include file='doc\WebServicesConfiguration.uex' path='docs/doc[@for="WebServicesConfiguration.MimeImporterTypes"]/*' />
        /// <devdoc>
        ///    An array of types that convert MIME types
        ///    representing Web Service Method parameters and return data types in a Service Contract
        ///    for into language specific data types, which are used in the generation of a
        ///    client proxy from a Service Contract.
        /// </devdoc>
        internal Type[] MimeImporterTypes {
            get {
                return mimeImporterTypes;
            }
            set {
                mimeImporterTypes = value;
            }
        }
        internal string WsdlHelpGeneratorPath {
            get {
                return wsdlHelpGeneratorPath;
            }
            set {
                wsdlHelpGeneratorPath = value;
            }
        }

        internal string WsdlHelpGeneratorVirtualPath {
            get {
                return wsdlHelpGeneratorVirtualPath;
            }
            set {
                wsdlHelpGeneratorVirtualPath = value;
            }
        }

        /// <include file='doc\WebServicesConfiguration.uex' path='docs/doc[@for="WebServicesConfiguration.SoapExtensionTypes"]/*' />
        /// <devdoc>
        ///    <para>An array of types that describe a SOAP Extension.</para>
        /// </devdoc>
        internal SoapExtensionType[] SoapExtensionTypes {
            get {
                return soapExtensionTypes;
            }
            set {
                soapExtensionTypes = value;
            }
        }

        /// <include file='doc\WebServicesConfiguration.uex' path='docs/doc[@for="WebServicesConfiguration.SoapExtensionImporterTypes"]/*' />
        /// <devdoc>
        ///    <para>An array of types that generate SOAP headers in a client 
        ///       proxy from a Service Contract.</para>
        /// </devdoc>
        internal Type[] SoapExtensionImporterTypes {
            get {
                return soapExtensionImporterTypes;
            }
            set {
                soapExtensionImporterTypes = value;
            }
        }

        /// <include file='doc\WebServicesConfiguration.uex' path='docs/doc[@for="WebServicesConfiguration.SoapExtensionReflectorTypes"]/*' />
        /// <devdoc>
        ///    <para>An array of types that generate SOAP headers in
        ///       a client proxy from a Service Contract.</para>
        /// </devdoc>
        internal Type[] SoapExtensionReflectorTypes {
            get {
                return soapExtensionReflectorTypes;
            }
            set {
                soapExtensionReflectorTypes = value;
            }
        }

        internal Type[] SoapTransportImporterTypes {
            get {
                return soapTransportImporterTypes;
            }
            set {
                soapTransportImporterTypes = value;
            }
        }
        /// <include file='doc\WebServicesConfiguration.uex' path='docs/doc[@for="WebServicesConfiguration.DiscoveryReferenceTypes"]/*' />
        /// <devdoc>
        ///    An array of types that represent elements
        ///    in a Discovery document.
        /// </devdoc>
        internal Type[] DiscoveryReferenceTypes {
            get {
                return discoveryReferenceTypes;
            }
        }

        internal Type[] ServiceDescriptionFormatExtensionTypes {
            get {
                return serviceDescriptionFormatExtensionTypes;
            }
            set {
                serviceDescriptionFormatExtensionTypes = value;
            }
        }

        internal static ProtocolsEnum GetProtocol(string protocolName) {
            ProtocolsEnum protocol;
            switch (protocolName) {
                case "HttpPost":
                    protocol = ProtocolsEnum.HttpPost; 
                    break;
                case "HttpGet":
                    protocol = ProtocolsEnum.HttpGet; 
                    break;
                case "HttpSoap":
                    protocol = ProtocolsEnum.HttpSoap; 
                    break;
                case "HttpSoap1.2":
                    protocol = ProtocolsEnum.HttpSoap12; 
                    break;
                case "Documentation":
                    protocol = ProtocolsEnum.Documentation; 
                    break;
                case "HttpPostLocalhost":
                    protocol = ProtocolsEnum.HttpPostLocalhost;
                    break;
                default:
                    protocol = ProtocolsEnum.Unknown;
                    break;
            }
            return protocol;
        }
        
        // used with private reflection by wsdl.exe and webserviceutil.exe
        void TurnOnGetAndPost() {
            bool needPost = (enabledProtocols & ProtocolsEnum.HttpPost) == 0;
            bool needGet = (enabledProtocols & ProtocolsEnum.HttpGet) == 0;
            if (!needGet && !needPost)
                return;
                
            ArrayList importers = new ArrayList(ProtocolImporterTypes);
            ArrayList reflectors = new ArrayList(ProtocolReflectorTypes);
            if (needPost) {
                importers.Add(typeof(HttpPostProtocolImporter));
                reflectors.Add(typeof(HttpPostProtocolReflector));
            }
            if (needGet) {
                importers.Add(typeof(HttpGetProtocolImporter));
                reflectors.Add(typeof(HttpGetProtocolReflector));
            }
            ProtocolImporterTypes = (Type[]) importers.ToArray(typeof(Type));
            ProtocolReflectorTypes = (Type[]) reflectors.ToArray(typeof(Type));
            enabledProtocols |= ProtocolsEnum.HttpGet | ProtocolsEnum.HttpPost;
        }

        // Set our hard-coded defaults. In some cases we need to merge in
        // our hard-coded defaults with those already loaded from the config system.
        void SetInternalDefaults() {
            for (int i = 0; i < Protocols.Length; i++) {
                enabledProtocols |= GetProtocol(Protocols[i]);
            }

            // SOAP12: disable soap 1.2 by removing it from the enum
            enabledProtocols &= (~ProtocolsEnum.HttpSoap12);

            ArrayList serverProtocolFactoryList = new ArrayList();
            // These are order sensitive. We want SOAP to go first for perf
            // and Discovery (?wsdl and ?disco) should go before Documentation
            // both soap versions are handled by the same factory
            if ((enabledProtocols & ProtocolsEnum.AnyHttpSoap) != 0)
                serverProtocolFactoryList.Add(new SoapServerProtocolFactory());
            if ((enabledProtocols & ProtocolsEnum.HttpPost) != 0)
                serverProtocolFactoryList.Add(new HttpPostServerProtocolFactory());
            if ((enabledProtocols & ProtocolsEnum.HttpPostLocalhost) != 0)
                serverProtocolFactoryList.Add(new HttpPostLocalhostServerProtocolFactory());
            if ((enabledProtocols & ProtocolsEnum.HttpGet) != 0)
                serverProtocolFactoryList.Add(new HttpGetServerProtocolFactory());            
            if ((enabledProtocols & ProtocolsEnum.Documentation) != 0) {
                serverProtocolFactoryList.Add(new DiscoveryServerProtocolFactory());
                serverProtocolFactoryList.Add(new DocumentationServerProtocolFactory());
            }
            serverProtocolFactories = (ServerProtocolFactory[])serverProtocolFactoryList.ToArray(typeof(ServerProtocolFactory));
            
            ArrayList protocolReflectorList = new ArrayList();
            ArrayList protocolImporterList = new ArrayList();
            
            // order is important for soap: 1.2 must come after 1.1
            if ((enabledProtocols & ProtocolsEnum.HttpSoap) != 0) {
                protocolReflectorList.Add(typeof(SoapProtocolReflector));
                protocolImporterList.Add(typeof(SoapProtocolImporter));
            }
            if ((enabledProtocols & ProtocolsEnum.HttpSoap12) != 0) {
                protocolReflectorList.Add(typeof(Soap12ProtocolReflector));
                protocolImporterList.Add(typeof(Soap12ProtocolImporter));
            }
            if ((enabledProtocols & ProtocolsEnum.HttpGet) != 0) {
                protocolReflectorList.Add(typeof(HttpGetProtocolReflector));
                protocolImporterList.Add(typeof(HttpGetProtocolImporter));
            }
            if ((enabledProtocols & ProtocolsEnum.HttpPost) != 0) {
                protocolReflectorList.Add(typeof(HttpPostProtocolReflector));
                protocolImporterList.Add(typeof(HttpPostProtocolImporter));
            }

            ProtocolReflectorTypes = (Type[]) protocolReflectorList.ToArray(typeof(Type));
            ProtocolImporterTypes = (Type[]) protocolImporterList.ToArray(typeof(Type));         

            // Initialize static data
            if (defaultFormatTypes == null) {
                lock (typeof(WebServicesConfiguration)){ 
                    if (defaultFormatTypes == null) {
                        ReturnWriterTypes = new Type[] { typeof(XmlReturnWriter) };
                        ParameterReaderTypes = new Type[] { typeof(UrlParameterReader), typeof(HtmlFormParameterReader) };
                        MimeReflectorTypes = new Type[] { typeof(MimeXmlReflector), typeof(MimeFormReflector) };            
                        MimeImporterTypes = new Type[] { typeof(MimeXmlImporter), typeof(MimeFormImporter), typeof(MimeTextImporter) };
                        SoapTransportImporterTypes = new Type[] { typeof(SoapHttpTransportImporter) };
                        discoveryReferenceTypes = new Type[] { typeof(DiscoveryDocumentReference), typeof(ContractReference), typeof(SchemaReference), typeof(System.Web.Services.Discovery.SoapBinding)};
                        defaultFormatTypes = new Type[] {
                                                    typeof(HttpAddressBinding),
                                                    typeof(HttpBinding),
                                                    typeof(HttpOperationBinding),
                                                    typeof(HttpUrlEncodedBinding),
                                                    typeof(HttpUrlReplacementBinding),
                                                    typeof(MimeContentBinding),
                                                    typeof(MimeXmlBinding),
                                                    typeof(MimeMultipartRelatedBinding),
                                                    typeof(MimeTextBinding),
                                                    typeof(System.Web.Services.Description.SoapBinding),
                                                    typeof(SoapOperationBinding),
                                                    typeof(SoapBodyBinding),
                                                    typeof(SoapFaultBinding),
                                                    typeof(SoapHeaderBinding),
                                                    typeof(SoapAddressBinding),
                                                    // SOAP12: WSDL soap12 binding disabled
                                                    /*typeof(Soap12Binding),
                                                    typeof(Soap12OperationBinding),
                                                    typeof(Soap12BodyBinding),
                                                    typeof(Soap12FaultBinding),
                                                    typeof(Soap12HeaderBinding),
                                                    typeof(Soap12AddressBinding),*/
                        };
                    }
                }
            }

            // Merge hard-coded ServiceDescriptionFormatTypes with custom ones from config
            if (serviceDescriptionFormatExtensionTypes.Length == 0)
                ServiceDescriptionFormatExtensionTypes = defaultFormatTypes;
            else {
                Type[] formatTypes = new Type[defaultFormatTypes.Length + serviceDescriptionFormatExtensionTypes.Length];
                Array.Copy(defaultFormatTypes, formatTypes, defaultFormatTypes.Length);
                Array.Copy(serviceDescriptionFormatExtensionTypes, 0, formatTypes, defaultFormatTypes.Length, serviceDescriptionFormatExtensionTypes.Length);
                ServiceDescriptionFormatExtensionTypes = formatTypes;
            }            

            internalDefaultsInitialized = true;
        }


        private XmlSerializer discoveryDocumentSerializer = null;

        internal static void LoadXmlFormatExtensions(Type[] extensionTypes, XmlAttributeOverrides overrides, XmlSerializerNamespaces namespaces) {
            Hashtable table = new Hashtable();
            foreach (Type extensionType in extensionTypes) {
                object[] attrs = extensionType.GetCustomAttributes(typeof(XmlFormatExtensionAttribute), false);
                if (attrs.Length == 0)
                    throw new ArgumentException(Res.GetString(Res.RequiredXmlFormatExtensionAttributeIsMissing1, extensionType.FullName), "extensionTypes");
                XmlFormatExtensionAttribute extensionAttr = (XmlFormatExtensionAttribute)attrs[0];
                foreach (Type extensionPointType in extensionAttr.ExtensionPoints) {
                    XmlAttributes xmlAttrs = (XmlAttributes)table[extensionPointType];
                    if (xmlAttrs == null) {
                        xmlAttrs = new XmlAttributes();
                        table.Add(extensionPointType, xmlAttrs);
                    }
                    XmlElementAttribute xmlAttr = new XmlElementAttribute(extensionAttr.ElementName, extensionType);
                    xmlAttr.Namespace = extensionAttr.Namespace;
                    xmlAttrs.XmlElements.Add(xmlAttr);
                }
                attrs = extensionType.GetCustomAttributes(typeof(XmlFormatExtensionPrefixAttribute), false);
                string[] prefixes = new string[attrs.Length];
                Hashtable nsDefs = new Hashtable();
                for (int i = 0; i < attrs.Length; i++) {
                    XmlFormatExtensionPrefixAttribute prefixAttr = (XmlFormatExtensionPrefixAttribute)attrs[i];
                    prefixes[i] = prefixAttr.Prefix;
                    nsDefs.Add(prefixAttr.Prefix, prefixAttr.Namespace);
                }
                Array.Sort(prefixes, InvariantComparer.Default);
                for (int i = 0; i < prefixes.Length; i++) {
                    namespaces.Add(prefixes[i], (string)nsDefs[prefixes[i]]);
                }
            }
            foreach (Type extensionPointType in table.Keys) {
                XmlFormatExtensionPointAttribute attr = GetExtensionPointAttribute(extensionPointType);
                XmlAttributes xmlAttrs = (XmlAttributes)table[extensionPointType];
                if (attr.AllowElements) {
                    xmlAttrs.XmlAnyElements.Add(new XmlAnyElementAttribute());
                }
                overrides.Add(extensionPointType, attr.MemberName, xmlAttrs);
            }
        }

        static XmlFormatExtensionPointAttribute GetExtensionPointAttribute(Type type) {
            object[] attrs = type.GetCustomAttributes(typeof(XmlFormatExtensionPointAttribute), false);
            if (attrs.Length == 0)
                throw new ArgumentException(Res.GetString(Res.TheSyntaxOfTypeMayNotBeExtended1, type.FullName), "type");
            return (XmlFormatExtensionPointAttribute)attrs[0];
        }

        /// <include file='doc\WebServicesConfiguration.uex' path='docs/doc[@for="WebServicesConfiguration.DiscoveryDocumentSerializer"]/*' />
        /// <devdoc>
        ///    <para>Indicates a XmlSerializer that can be used to
        ///       read and write any DiscoveryDocument.</para>
        /// </devdoc>
        internal XmlSerializer DiscoveryDocumentSerializer {
            get {
                if (discoveryDocumentSerializer == null) {
                    XmlAttributeOverrides attrOverrides = new XmlAttributeOverrides();
                    XmlAttributes attrs = new XmlAttributes();
                    foreach (Type discoveryReferenceType in DiscoveryReferenceTypes) {
                        object[] xmlElementAttribs = discoveryReferenceType.GetCustomAttributes(typeof(XmlRootAttribute), false);
                        if (xmlElementAttribs.Length == 0)
                            throw new InvalidOperationException(Res.GetString(Res.WebMissingCustomAttribute, discoveryReferenceType.FullName, "XmlRoot"));
                        string name = ((XmlRootAttribute) xmlElementAttribs[0]).ElementName;
                        string ns = ((XmlRootAttribute) xmlElementAttribs[0]).Namespace;
                        XmlElementAttribute attr = new XmlElementAttribute(name, discoveryReferenceType);
                        attr.Namespace = ns;
                        attrs.XmlElements.Add(attr);
                    }
                    attrOverrides.Add(typeof(DiscoveryDocument), "References", attrs);
                    discoveryDocumentSerializer = new DiscoveryDocumentSerializer();
                    //discoveryDocumentSerializer = new XmlSerializer(typeof(DiscoveryDocument), attrOverrides);
                }
                return discoveryDocumentSerializer;
            }
        }

        /// <include file='doc\WebServicesConfiguration.uex' path='docs/doc[@for="WebServicesConfiguration.Current"]/*' />
        /// <devdoc>
        ///    <para>Gets the current copy of the WebServices configuration.</para>
        /// </devdoc>
        internal static WebServicesConfiguration Current {
            get {
                // Get the config object from HttpContext if we are on the server.
                // Do not cache the config object because it is context dependent and 
                // the config system caches it for us anyways.
                WebServicesConfiguration config;
                HttpContext context = HttpContext.Current;
                if (context != null)
                    config = (WebServicesConfiguration) context.GetConfig("system.web/webServices");
                else
                    config = (WebServicesConfiguration) ConfigurationSettings.GetConfig("system.web/webServices");

                if (config == null) throw new ConfigurationException(Res.GetString(Res.WebConfigMissingSection));
                
                if (!config.internalDefaultsInitialized) {
                    lock (config) {
                        if (!config.internalDefaultsInitialized)
                            config.SetInternalDefaults();                        
                    }
                }                
                
                return config;        
            }
        }    
        
        internal void InitializeFromParent(WebServicesConfiguration parentConfig) {
            Protocols = parentConfig.Protocols;
            WsdlHelpGeneratorPath = parentConfig.WsdlHelpGeneratorPath;
            WsdlHelpGeneratorVirtualPath = parentConfig.WsdlHelpGeneratorVirtualPath;
            SoapExtensionTypes = parentConfig.SoapExtensionTypes;
            SoapExtensionImporterTypes = parentConfig.SoapExtensionImporterTypes;
            SoapExtensionReflectorTypes = parentConfig.SoapExtensionReflectorTypes;
            SoapTransportImporterTypes = parentConfig.SoapTransportImporterTypes;
            ServiceDescriptionFormatExtensionTypes = parentConfig.ServiceDescriptionFormatExtensionTypes;
        }
    }

      [Flags]
    internal enum ProtocolsEnum {
        Unknown             = 0x0,
        HttpSoap            = 0x1,
        HttpGet             = 0x2,
        HttpPost            = 0x4,
        Documentation       = 0x8,
        HttpPostLocalhost   = 0x10,
        HttpSoap12          = 0x20, 

        // composite flag
        AnyHttpSoap         = 0x21,
    }

    internal class SoapExtensionType {
        internal enum PriorityGroup {
            High = 0,
            Low = 1
        }
        internal Type Type;
        internal int Priority = 0;
        internal PriorityGroup Group = PriorityGroup.Low;
    }

    internal enum ConfigFieldKind {
        Types,  // An element containing a list of types (Type[]), with add/remove/clear
        SoapExtensionTypes,   // same as Types but with element attributes priority and ???
        WsdlHelpGenerator,   // 
        NameString, // An element containing a list of elements (add/remove/clear) with name attribute
    }

    internal class ConfigField {
        string elementName;
        ConfigFieldKind kind;
        PropertyInfo field;

        internal ConfigField(string fieldName, string elementName, ConfigFieldKind kind) {
            this.elementName = elementName;
            this.kind = kind;
            field = typeof(WebServicesConfiguration).GetProperty(fieldName, BindingFlags.Instance | BindingFlags.Static | BindingFlags.Public | BindingFlags.NonPublic);
        }

        internal void SetValue(WebServicesConfiguration config, object value) {
            field.SetValue(config, value, null);
        }

        internal object GetValue(WebServicesConfiguration config) {
            return field.GetValue(config, null);
        }

        /* dead code
        internal string ElementName {
            get { return elementName; }
        }
        */

        internal ConfigFieldKind Kind {
            get { return kind; }
        }

        internal static ConfigField FindByElementName(string elementName) {
            foreach (ConfigField field in WebServicesConfiguration.Fields) {
                if (field.elementName == elementName) {
                    return field;
                }
            }
            return null;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\services\web\system\web\services\description\httpgetprotocolreflector.cs ===
//------------------------------------------------------------------------------
// <copyright file="HttpGetProtocolReflector.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------
namespace System.Web.Services.Description {

    using System.Web.Services;
    using System.Web.Services.Protocols;
    using System.Xml.Serialization;
    using System.Xml.Schema;
    using System.Collections;
    using System;
    using System.Reflection;

    internal class HttpGetProtocolReflector : HttpProtocolReflector {
        public override string ProtocolName { 
            get { return "HttpGet"; } 
        }

        protected override void BeginClass() {
            HttpBinding httpBinding = new HttpBinding();
            httpBinding.Verb = "GET";
            Binding.Extensions.Add(httpBinding);

            HttpAddressBinding httpAddressBinding = new HttpAddressBinding();
            httpAddressBinding.Location = ServiceUrl;
            Port.Extensions.Add(httpAddressBinding);
        }

        protected override bool ReflectMethod() {
            if (!ReflectUrlParameters()) return false;
            if (!ReflectMimeReturn()) return false;
            HttpOperationBinding httpOperationBinding = new HttpOperationBinding();
            httpOperationBinding.Location = MethodUrl;
            OperationBinding.Extensions.Add(httpOperationBinding);
            return true;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\services\web\system\web\services\description\httpgetprotocolimporter.cs ===
//------------------------------------------------------------------------------
// <copyright file="HttpGetProtocolImporter.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------
namespace System.Web.Services.Description {
    using System.Web.Services.Protocols;

    internal class HttpGetProtocolImporter : HttpProtocolImporter {

        public HttpGetProtocolImporter() : base(false) { }

        public override string ProtocolName {
            get { return "HttpGet"; }
        }

        internal override Type BaseClass { 
            get {
                if (Style == ServiceDescriptionImportStyle.Client) {
                    return typeof(HttpGetClientProtocol);
                }
                else {
                    return typeof(WebService);
                }
            }
        }

        protected override bool IsBindingSupported() {
            HttpBinding httpBinding = (HttpBinding)Binding.Extensions.Find(typeof(HttpBinding));
            if (httpBinding == null) return false;
            if (httpBinding.Verb != "GET") return false;
            return true;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\services\web\system\web\services\description\httppostprotocolimporter.cs ===
//------------------------------------------------------------------------------
// <copyright file="HttpPostProtocolImporter.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------
namespace System.Web.Services.Description {
    using System.Web.Services.Protocols;

    internal class HttpPostProtocolImporter : HttpProtocolImporter {

        public HttpPostProtocolImporter() : base(true) { }

        public override string ProtocolName {
            get { return "HttpPost"; }
        }

        internal override Type BaseClass { 
            get {
                if (Style == ServiceDescriptionImportStyle.Client) {
                    return typeof(HttpPostClientProtocol);
                }
                else {
                    return typeof(WebService);
                }
            }
        }
        protected override bool IsBindingSupported() {
            HttpBinding httpBinding = (HttpBinding)Binding.Extensions.Find(typeof(HttpBinding));
            if (httpBinding == null) return false;
            if (httpBinding.Verb != "POST") return false;
            return true;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\services\web\system\web\services\description\httpformatextensions.cs ===
//------------------------------------------------------------------------------
// <copyright file="HttpFormatExtensions.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>
//------------------------------------------------------------------------------


/**************************************************************************\
*
* Copyright (c) 1998-2002, Microsoft Corp.  All Rights Reserved.
*
* Module Name:
*
*   HttpFormatExtensions.cs
*
* Abstract:
*
* Revision History:
*
\**************************************************************************/
namespace System.Web.Services.Description {
    using System.Xml.Serialization;
    using System.Web.Services.Configuration;

    /// <include file='doc\HttpFormatExtensions.uex' path='docs/doc[@for="HttpAddressBinding"]/*' />
    [XmlFormatExtension("address", HttpBinding.Namespace, typeof(Port))]
    public sealed class HttpAddressBinding : ServiceDescriptionFormatExtension {
        string location;

        /// <include file='doc\HttpFormatExtensions.uex' path='docs/doc[@for="HttpAddressBinding.Location"]/*' />
        [XmlAttribute("location")]
        public string Location {
            get { return location == null ? string.Empty : location; }
            set { location = value; }
        }
    }

    /// <include file='doc\HttpFormatExtensions.uex' path='docs/doc[@for="HttpBinding"]/*' />
    [XmlFormatExtension("binding", HttpBinding.Namespace, typeof(Binding))]
    [XmlFormatExtensionPrefix("http", HttpBinding.Namespace)]
    public sealed class HttpBinding : ServiceDescriptionFormatExtension {
        string verb;

        /// <include file='doc\HttpFormatExtensions.uex' path='docs/doc[@for="HttpBinding.Namespace"]/*' />
        public const string Namespace="http://schemas.xmlsoap.org/wsdl/http/";

        /// <include file='doc\HttpFormatExtensions.uex' path='docs/doc[@for="HttpBinding.Verb"]/*' />
        [XmlAttribute("verb", DataType="NMTOKEN")]
        public string Verb {
            get { return verb; }
            set { verb = value; }
        }
    }

    /// <include file='doc\HttpFormatExtensions.uex' path='docs/doc[@for="HttpOperationBinding"]/*' />
    [XmlFormatExtension("operation", HttpBinding.Namespace, typeof(OperationBinding))]
    public sealed class HttpOperationBinding : ServiceDescriptionFormatExtension {
        string location;

        /// <include file='doc\HttpFormatExtensions.uex' path='docs/doc[@for="HttpOperationBinding.Location"]/*' />
        [XmlAttribute("location")]
        public string Location {
            get { return location == null ? string.Empty : location; }
            set { location = value; }
        }
    }

    /// <include file='doc\HttpFormatExtensions.uex' path='docs/doc[@for="HttpUrlEncodedBinding"]/*' />
    [XmlFormatExtension("urlEncoded", HttpBinding.Namespace, typeof(InputBinding))]
    public sealed class HttpUrlEncodedBinding : ServiceDescriptionFormatExtension {
    }

    /// <include file='doc\HttpFormatExtensions.uex' path='docs/doc[@for="HttpUrlReplacementBinding"]/*' />
    [XmlFormatExtension("urlReplacement", HttpBinding.Namespace, typeof(InputBinding))]
    public sealed class HttpUrlReplacementBinding : ServiceDescriptionFormatExtension {
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\services\web\system\web\services\description\httpprotocolreflector.cs ===
//------------------------------------------------------------------------------
// <copyright file="HttpProtocolReflector.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Web.Services.Description {

    using System.Web.Services;
    using System.Web.Services.Protocols;
    using System.Xml;
    using System.Xml.Serialization;
    using System.Xml.Schema;
    using System.Collections;
    using System;
    using System.Reflection;
    using System.Web.Services.Configuration;

    internal abstract class HttpProtocolReflector : ProtocolReflector {
        MimeReflector[] reflectors;

        protected HttpProtocolReflector() {
            Type[] reflectorTypes = WebServicesConfiguration.Current.MimeReflectorTypes;
            reflectors = new MimeReflector[reflectorTypes.Length];
            for (int i = 0; i < reflectors.Length; i++) {
                MimeReflector reflector = (MimeReflector)Activator.CreateInstance(reflectorTypes[i]);
                reflector.ReflectionContext = this;
                reflectors[i] = reflector;
            }
        }

        protected bool ReflectMimeParameters() {
            bool handled = false;
            for (int i = 0; i < reflectors.Length; i++) {
                if (reflectors[i].ReflectParameters())
                    handled = true;
            }
            return handled;
        }

        protected bool ReflectMimeReturn() {
            if (Method.ReturnType == typeof(void)) {
                Message outputMessage = OutputMessage;
                return true;
            }
            bool handled = false;
            for (int i = 0; i < reflectors.Length; i++) {
                if (reflectors[i].ReflectReturn()) {
                    handled = true;
                    break;
                }
            }
            return handled;
        }

        protected bool ReflectUrlParameters() {
            if (!HttpServerProtocol.AreUrlParametersSupported(Method))
                return false;
            ReflectStringParametersMessage();
            OperationBinding.Input.Extensions.Add(new HttpUrlEncodedBinding());
            return true;
        }

        internal void ReflectStringParametersMessage() {
            Message inputMessage = InputMessage;
            foreach (ParameterInfo parameterInfo in Method.InParameters) {
                MessagePart part = new MessagePart();
                part.Name = parameterInfo.Name;
                if (parameterInfo.ParameterType.IsArray) {
                    string typeNs = DefaultNamespace;
                    if (typeNs.EndsWith("/"))
                        typeNs += "AbstractTypes";
                    else
                        typeNs += "/AbstractTypes";
                    string typeName = "StringArray";
                    XmlSchema schema = ServiceDescription.Types.Schemas[typeNs];
                    if (schema == null) {
                        schema = new XmlSchema();
                        schema.TargetNamespace = typeNs;
                        ServiceDescription.Types.Schemas.Add(schema);
                       
                        XmlSchemaElement element = new XmlSchemaElement();
                        element.Name = "String";
                        element.SchemaTypeName = new XmlQualifiedName("string", XmlSchema.Namespace);
                        element.MinOccurs = decimal.Zero;
                        element.MaxOccurs = decimal.MaxValue;
                        XmlSchemaSequence all = new XmlSchemaSequence();
                        all.Items.Add(element);

                        XmlSchemaComplexContentRestriction restriction = new XmlSchemaComplexContentRestriction();
                        restriction.BaseTypeName = new XmlQualifiedName(Soap.ArrayType, Soap.Encoding);
                        restriction.Particle = all;

                        XmlSchemaImport import = new XmlSchemaImport();
                        import.Namespace = restriction.BaseTypeName.Namespace;
                        
                        XmlSchemaComplexContent model = new XmlSchemaComplexContent();
                        model.Content = restriction;

                        XmlSchemaComplexType type = new XmlSchemaComplexType();
                        type.Name = typeName;
                        type.ContentModel = model;

                        schema.Items.Add(type);
                        schema.Includes.Add(import);
                    }
                    part.Type = new XmlQualifiedName(typeName, typeNs);
                }
                else {
                    part.Type = new XmlQualifiedName("string", XmlSchema.Namespace);
                }
                inputMessage.Parts.Add(part);
            }
        }

        internal string MethodUrl {
            get {
                WebMethodAttribute methodAttribute = WebMethodReflector.GetAttribute(Method);
                string name = methodAttribute.MessageName;
                if (name.Length == 0) name = Method.Name;
                return "/" + name;
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\services\web\system\web\services\description\mimeformatextensions.cs ===
//------------------------------------------------------------------------------
// <copyright file="MimeFormatExtensions.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>
//------------------------------------------------------------------------------


/**************************************************************************\
*
* Copyright (c) 1998-2002, Microsoft Corp.  All Rights Reserved.
*
* Module Name:
*
*   MimeFormatExtensions.cs
*
* Abstract:
*
* Revision History:
*
\**************************************************************************/
namespace System.Web.Services.Description {
    using System.Xml.Serialization;
    using System.Collections;
    using System.ComponentModel;
    using System.Web.Services.Configuration;

    /// <include file='doc\MimeFormatExtensions.uex' path='docs/doc[@for="MimeContentBinding"]/*' />
    [XmlFormatExtension("content", MimeContentBinding.Namespace, typeof(MimePart), typeof(InputBinding), typeof(OutputBinding))]
    [XmlFormatExtensionPrefix("mime", MimeContentBinding.Namespace)]
    public sealed class MimeContentBinding : ServiceDescriptionFormatExtension {
        string type;
        string part;

        /// <include file='doc\MimeFormatExtensions.uex' path='docs/doc[@for="MimeContentBinding.Part"]/*' />
        [XmlAttribute("part", DataType="NMTOKEN")]
        public string Part {
            get { return part; }
            set { part = value; }
        }

        /// <include file='doc\MimeFormatExtensions.uex' path='docs/doc[@for="MimeContentBinding.Type"]/*' />
        [XmlAttribute("type")]
        public string Type {
            get { return type == null ? string.Empty : type; }
            set { type = value; }
        }

        /// <include file='doc\MimeFormatExtensions.uex' path='docs/doc[@for="MimeContentBinding.Namespace"]/*' />
        public const string Namespace="http://schemas.xmlsoap.org/wsdl/mime/";
    }

    /// <include file='doc\MimeFormatExtensions.uex' path='docs/doc[@for="MimePart"]/*' />
    [XmlFormatExtensionPoint("Extensions")]
    public sealed class MimePart : ServiceDescriptionFormatExtension {
        ServiceDescriptionFormatExtensionCollection extensions;

        /// <include file='doc\MimeFormatExtensions.uex' path='docs/doc[@for="MimePart.Extensions"]/*' />
        [XmlIgnore]
        public ServiceDescriptionFormatExtensionCollection Extensions { 
            get { if (extensions == null) extensions = new ServiceDescriptionFormatExtensionCollection(this); return extensions; }
        }
    }

    /// <include file='doc\MimeFormatExtensions.uex' path='docs/doc[@for="MimeMultipartRelatedBinding"]/*' />
    [XmlFormatExtension("multipartRelated", MimeContentBinding.Namespace, typeof(InputBinding), typeof(OutputBinding))]
    public sealed class MimeMultipartRelatedBinding : ServiceDescriptionFormatExtension {
        MimePartCollection parts = new MimePartCollection();

        /// <include file='doc\MimeFormatExtensions.uex' path='docs/doc[@for="MimeMultipartRelatedBinding.Parts"]/*' />
        [XmlElement("part")]
        public MimePartCollection Parts {
            get { return parts; }
        }
    }

    /// <include file='doc\MimeFormatExtensions.uex' path='docs/doc[@for="MimeXmlBinding"]/*' />
    [XmlFormatExtension("mimeXml", MimeContentBinding.Namespace, typeof(MimePart), typeof(InputBinding), typeof(OutputBinding))]
    public sealed class MimeXmlBinding : ServiceDescriptionFormatExtension {
        string part;

        /// <include file='doc\MimeFormatExtensions.uex' path='docs/doc[@for="MimeXmlBinding.Part"]/*' />
        [XmlAttribute("part", DataType="NMTOKEN")]
        public string Part {
            get { return part; }
            set { part = value; }
        }
    }

    /// <include file='doc\MimeFormatExtensions.uex' path='docs/doc[@for="MimePartCollection"]/*' />
    public sealed class MimePartCollection : CollectionBase {
        
        /// <include file='doc\MimeFormatExtensions.uex' path='docs/doc[@for="MimePartCollection.this"]/*' />
        public MimePart this[int index] {
            get { return (MimePart)List[index]; }
            set { List[index] = value; }
        }
        
        /// <include file='doc\MimeFormatExtensions.uex' path='docs/doc[@for="MimePartCollection.Add"]/*' />
        public int Add(MimePart mimePart) {
            return List.Add(mimePart);
        }
        
        /// <include file='doc\MimeFormatExtensions.uex' path='docs/doc[@for="MimePartCollection.Insert"]/*' />
        public void Insert(int index, MimePart mimePart) {
            List.Insert(index, mimePart);
        }
        
        /// <include file='doc\MimeFormatExtensions.uex' path='docs/doc[@for="MimePartCollection.IndexOf"]/*' />
        public int IndexOf(MimePart mimePart) {
            return List.IndexOf(mimePart);
        }
        
        /// <include file='doc\MimeFormatExtensions.uex' path='docs/doc[@for="MimePartCollection.Contains"]/*' />
        public bool Contains(MimePart mimePart) {
            return List.Contains(mimePart);
        }
        
        /// <include file='doc\MimeFormatExtensions.uex' path='docs/doc[@for="MimePartCollection.Remove"]/*' />
        public void Remove(MimePart mimePart) {
            List.Remove(mimePart);
        }
        
        /// <include file='doc\MimeFormatExtensions.uex' path='docs/doc[@for="MimePartCollection.CopyTo"]/*' />
        public void CopyTo(MimePart[] array, int index) {
            List.CopyTo(array, index);
        }
    }

    /// <include file='doc\MimeFormatExtensions.uex' path='docs/doc[@for="MimeTextBinding"]/*' />
    [XmlFormatExtension("text", MimeTextBinding.Namespace, typeof(InputBinding), typeof(OutputBinding), typeof(MimePart))]
    [XmlFormatExtensionPrefix("tm", MimeTextBinding.Namespace)]
    public sealed class MimeTextBinding : ServiceDescriptionFormatExtension {
        MimeTextMatchCollection matches = new MimeTextMatchCollection();

        /// <include file='doc\MimeFormatExtensions.uex' path='docs/doc[@for="MimeTextBinding.Namespace"]/*' />
        public const string Namespace = "http://microsoft.com/wsdl/mime/textMatching/";

        /// <include file='doc\MimeFormatExtensions.uex' path='docs/doc[@for="MimeTextBinding.Matches"]/*' />
        [XmlElement("match", typeof(MimeTextMatch))]
        public MimeTextMatchCollection Matches {
            get { return matches; }
        }
    }

    /// <include file='doc\MimeFormatExtensions.uex' path='docs/doc[@for="MimeTextMatch"]/*' />
    public sealed class MimeTextMatch {
        string name;
        string type;
        int repeats = 1;
        string pattern;
        int group = 1;
        int capture = 0;
        bool ignoreCase = false;
        MimeTextMatchCollection matches = new MimeTextMatchCollection();

        /// <include file='doc\MimeFormatExtensions.uex' path='docs/doc[@for="MimeTextMatch.Name"]/*' />
        [XmlAttribute("name")]
        public string Name {
            get { return name == null ? string.Empty : name; }
            set { name = value; }
        }

        /// <include file='doc\MimeFormatExtensions.uex' path='docs/doc[@for="MimeTextMatch.Type"]/*' />
        [XmlAttribute("type")]
        public string Type {
            get { return type == null ? string.Empty : type; }
            set { type = value; }
        }

        /// <include file='doc\MimeFormatExtensions.uex' path='docs/doc[@for="MimeTextMatch.Group"]/*' />
        [XmlAttribute("group"), DefaultValue(1)]
        public int Group {
            get { return group; }
            set { 
                if (value < 0) throw new ArgumentException(Res.GetString(Res.WebNegativeValue, "group"));
                group = value; 
            }
        }

        /// <include file='doc\MimeFormatExtensions.uex' path='docs/doc[@for="MimeTextMatch.Capture"]/*' />
        [XmlAttribute("capture"), DefaultValue(0)]
        public int Capture {
            get { return capture; }
            set { 
                if (value < 0) throw new ArgumentException(Res.GetString(Res.WebNegativeValue, "capture"));
                capture = value; 
            }
        }

        /// <include file='doc\MimeFormatExtensions.uex' path='docs/doc[@for="MimeTextMatch.Repeats"]/*' />
        [XmlIgnore()]
        public int Repeats {
            get { return repeats; }
            set { 
                if (value < 0) throw new ArgumentException(Res.GetString(Res.WebNegativeValue, "repeats"));
                repeats = value; 
            }
        }

        /// <include file='doc\MimeFormatExtensions.uex' path='docs/doc[@for="MimeTextMatch.RepeatsString"]/*' />
        [XmlAttribute("repeats"), DefaultValue("1")]
        public string RepeatsString {
            get { return repeats == int.MaxValue ? "*" : repeats.ToString(); }
            set { 
                if (value == "*") 
                    repeats = int.MaxValue;
                else 
                    Repeats = int.Parse(value);  // pass through our setter for arg checking
            }
        }

        /// <include file='doc\MimeFormatExtensions.uex' path='docs/doc[@for="MimeTextMatch.Pattern"]/*' />
        [XmlAttribute("pattern")]
        public string Pattern {
            get { return pattern == null ? string.Empty : pattern; }
            set { this.pattern = value; }
        }

        /// <include file='doc\MimeFormatExtensions.uex' path='docs/doc[@for="MimeTextMatch.IgnoreCase"]/*' />
        [XmlAttribute("ignoreCase")]
        public bool IgnoreCase {
            get { return ignoreCase; }
            set { ignoreCase = value; }
        }

        /// <include file='doc\MimeFormatExtensions.uex' path='docs/doc[@for="MimeTextMatch.Matches"]/*' />   
        [XmlElement("match")]
        public MimeTextMatchCollection Matches {
            get { return matches; }
        }
    }

    /// <include file='doc\MimeFormatExtensions.uex' path='docs/doc[@for="MimeTextMatchCollection"]/*' />
    public sealed class MimeTextMatchCollection : CollectionBase {
        
        /// <include file='doc\MimeFormatExtensions.uex' path='docs/doc[@for="MimeTextMatchCollection.this"]/*' />
        public MimeTextMatch this[int index] {
            get { return (MimeTextMatch)List[index]; }
            set { List[index] = value; }
        }
        
        /// <include file='doc\MimeFormatExtensions.uex' path='docs/doc[@for="MimeTextMatchCollection.Add"]/*' />
        public int Add(MimeTextMatch match) {
            return List.Add(match);
        }
        
        /// <include file='doc\MimeFormatExtensions.uex' path='docs/doc[@for="MimeTextMatchCollection.Insert"]/*' />
        public void Insert(int index, MimeTextMatch match) {
            List.Insert(index, match);
        }
        
        /// <include file='doc\MimeFormatExtensions.uex' path='docs/doc[@for="MimeTextMatchCollection.IndexOf"]/*' />
        public int IndexOf(MimeTextMatch match) {
            return List.IndexOf(match);
        }
        
        /// <include file='doc\MimeFormatExtensions.uex' path='docs/doc[@for="MimeTextMatchCollection.Contains"]/*' />
        public bool Contains(MimeTextMatch match) {
            return List.Contains(match);
        }
        
        /// <include file='doc\MimeFormatExtensions.uex' path='docs/doc[@for="MimeTextMatchCollection.Remove"]/*' />
        public void Remove(MimeTextMatch match) {
            List.Remove(match);
        }
        
        /// <include file='doc\MimeFormatExtensions.uex' path='docs/doc[@for="MimeTextMatchCollection.CopyTo"]/*' />
        public void CopyTo(MimeTextMatch[] array, int index) {
            List.CopyTo(array, index);
        }
        
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\services\web\system\web\services\description\mimeanyimporter.cs ===
//------------------------------------------------------------------------------
// <copyright file="MimeAnyImporter.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Web.Services.Description {

    using System.Web.Services;
    using System.Web.Services.Protocols;
    using System.IO;


    internal class MimeAnyImporter : MimeImporter {

        internal override MimeParameterCollection ImportParameters() {
            return null;
        }

        internal override MimeReturn ImportReturn() {
            if (ImportContext.OperationBinding.Output.Extensions.Count == 0) return null;
            MimeReturn importedReturn = new MimeReturn();
            importedReturn.TypeName = typeof(Stream).FullName;
            importedReturn.ReaderType = typeof(AnyReturnReader);
            return importedReturn;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\services\web\system\web\services\description\httppostprotocolreflector.cs ===
//------------------------------------------------------------------------------
// <copyright file="HttpPostProtocolReflector.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------
namespace System.Web.Services.Description {

    using System.Web.Services;
    using System.Web.Services.Protocols;
    using System.Xml.Serialization;
    using System.Xml.Schema;
    using System.Collections;
    using System;
    using System.Reflection;

    internal class HttpPostProtocolReflector : HttpProtocolReflector {
        //HttpPostProtocolInfo protocolInfo;

        //internal HttpPostProtocolInfoReflector() {
            //protocolInfo = new HttpPostProtocolInfo();
            //protocolInfo.Service = new HttpPostServiceInfo();
        //}

        public override string ProtocolName { 
            get { return "HttpPost"; } 
        }

        protected override void BeginClass() {
            HttpBinding httpBinding = new HttpBinding();
            httpBinding.Verb = "POST";
            Binding.Extensions.Add(httpBinding);

            HttpAddressBinding httpAddressBinding = new HttpAddressBinding();
            httpAddressBinding.Location = ServiceUrl;
            Port.Extensions.Add(httpAddressBinding);
        }

        protected override bool ReflectMethod() {
            if (!ReflectMimeParameters()) return false;
            if (!ReflectMimeReturn()) return false;
            HttpOperationBinding httpOperationBinding = new HttpOperationBinding();
            httpOperationBinding.Location = MethodUrl;
            OperationBinding.Extensions.Add(httpOperationBinding);
            return true;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\services\web\system\web\services\description\mimeformreflector.cs ===
//------------------------------------------------------------------------------
// <copyright file="MimeFormReflector.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Web.Services.Description {

    using System.Web.Services;
    using System.Web.Services.Protocols;
    using System.Xml.Serialization;
    using System.Xml.Schema;
    using System.Collections;
    using System;
    using System.Reflection;

    internal class MimeFormReflector : MimeReflector {
        internal override bool ReflectParameters() {
            if (!HtmlFormParameterReader.IsSupported(ReflectionContext.Method))
                return false;
            ReflectionContext.ReflectStringParametersMessage();
            MimeContentBinding mimeContentBinding = new MimeContentBinding();
            mimeContentBinding.Type = HtmlFormParameterReader.MimeType;
            ReflectionContext.OperationBinding.Input.Extensions.Add(mimeContentBinding);
            return true;
        }

        internal override bool ReflectReturn() {
            return false;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\services\web\system\web\services\description\mimeformimporter.cs ===
//------------------------------------------------------------------------------
// <copyright file="MimeFormImporter.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------
namespace System.Web.Services.Description {
    using System.Web.Services.Protocols;
    using System.Globalization;
    
    internal class MimeFormImporter : MimeImporter {

        internal override MimeParameterCollection ImportParameters() {
            MimeContentBinding mimeContentBinding = (MimeContentBinding)ImportContext.OperationBinding.Input.Extensions.Find(typeof(MimeContentBinding));
            if (mimeContentBinding == null) return null;
            if (string.Compare(mimeContentBinding.Type, HtmlFormParameterReader.MimeType, true, CultureInfo.InvariantCulture) != 0) return null;
            MimeParameterCollection parameters = ImportContext.ImportStringParametersMessage();
            if (parameters == null) return null;
            parameters.WriterType = typeof(HtmlFormParameterWriter);
            return parameters;
        }

        internal override MimeReturn ImportReturn() {
            return null;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\services\web\system\web\services\description\mimeimporter.cs ===
//------------------------------------------------------------------------------
// <copyright file="MimeImporter.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Web.Services.Description {

    using System.Web.Services;
    using System.Web.Services.Protocols;
    using System.Xml.Serialization;
    using System.Xml.Schema;
    using System.Collections;
    using System;
    using System.Reflection;
    using System.CodeDom;

    internal abstract class MimeImporter {
        HttpProtocolImporter protocol;

        internal abstract MimeParameterCollection ImportParameters();
        internal abstract MimeReturn ImportReturn();

        internal virtual void GenerateCode(MimeReturn[] importedReturns, MimeParameterCollection[] importedParameters) {
        }

        internal virtual void AddClassMetadata(CodeTypeDeclaration codeClass) {
        }

        internal HttpProtocolImporter ImportContext {
            get { return protocol; }
            set { protocol = value; }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\services\web\system\web\services\description\httpprotocolimporter.cs ===
//------------------------------------------------------------------------------
// <copyright file="HttpProtocolImporter.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------
namespace System.Web.Services.Description {

    using System.Web.Services;
    using System.Web.Services.Protocols;
    using System.Xml;
    using System.Xml.Serialization;
    using System.Xml.Schema;
    using System.Collections;
    using System;
    using System.Reflection;
    using System.CodeDom;
    using System.CodeDom.Compiler;
    using System.Web.Services.Configuration;
    using System.Diagnostics;
    using System.ComponentModel;

    // CONSIDER, erikc, remove this intermediate structure; no longer needed
    internal class HttpMethodInfo {
        internal MimeParameterCollection UrlParameters;
        internal MimeParameterCollection MimeParameters;
        internal MimeReturn MimeReturn;
        internal string Name;
        internal string Href;
    }

    internal abstract class HttpProtocolImporter : ProtocolImporter {
        CodeIdentifiers methodNames = new CodeIdentifiers();
        MimeImporter[] importers;
        ArrayList[] importedParameters;
        ArrayList[] importedReturns;
        bool hasInputPayload;
        ArrayList codeClasses = new ArrayList();

        internal CodeIdentifiers MethodNames {
            get { return methodNames; }
        }

        protected HttpProtocolImporter(bool hasInputPayload) {
            Type[] importerTypes = WebServicesConfiguration.Current.MimeImporterTypes;
            importers = new MimeImporter[importerTypes.Length];
            importedParameters = new ArrayList[importerTypes.Length];
            importedReturns = new ArrayList[importerTypes.Length];
            for (int i = 0; i < importers.Length; i++) {
                MimeImporter importer = (MimeImporter)Activator.CreateInstance(importerTypes[i]);
                importer.ImportContext = this;
                importedParameters[i] = new ArrayList();
                importedReturns[i] = new ArrayList();
                importers[i] = importer;
            }
            this.hasInputPayload = hasInputPayload;
        }

        // CONSIDER, yannc, add warnings for unrecognized mime stuff in v2.
        MimeParameterCollection ImportMimeParameters() {
            for (int i = 0; i < importers.Length; i++) {
                MimeParameterCollection importedParameters = importers[i].ImportParameters();
                if (importedParameters != null) {
                    this.importedParameters[i].Add(importedParameters);
                    return importedParameters;
                }
            }
            return null;
        }

        MimeReturn ImportMimeReturn() {
            MimeReturn importedReturn;
            if (OperationBinding.Output.Extensions.Count == 0) {
                importedReturn = new MimeReturn();
                importedReturn.TypeName = typeof(void).FullName;
                return importedReturn;
            }
            for (int i = 0; i < importers.Length; i++) {
                importedReturn = importers[i].ImportReturn();
                if (importedReturn != null) {
                    this.importedReturns[i].Add(importedReturn);
                    return importedReturn;
                }
            }
            return null;
        }

        MimeParameterCollection ImportUrlParameters() {
            // CONSIDER, erikc, support HttpUrlReplacementBinding
            HttpUrlEncodedBinding httpUrlEncodedBinding = (HttpUrlEncodedBinding)OperationBinding.Input.Extensions.Find(typeof(HttpUrlEncodedBinding));
            if (httpUrlEncodedBinding == null) return new MimeParameterCollection();
            return ImportStringParametersMessage();
        }

        internal MimeParameterCollection ImportStringParametersMessage() {
            MimeParameterCollection parameters = new MimeParameterCollection();
            foreach (MessagePart part in InputMessage.Parts) {
                MimeParameter parameter = ImportUrlParameter(part);
                if (parameter == null) return null;
                parameters.Add(parameter);
            }
            return parameters;
        }

        MimeParameter ImportUrlParameter(MessagePart part) {
            // CONSIDER, check to see that it's a primitive type
            MimeParameter parameter = new MimeParameter();
            parameter.Name = CodeIdentifier.MakeValid(part.Name);
            parameter.TypeName = IsRepeatingParameter(part) ? typeof(string[]).FullName : typeof(string).FullName;
            return parameter;
        }

        bool IsRepeatingParameter(MessagePart part) {
            XmlSchemaComplexType type = (XmlSchemaComplexType)Schemas.Find(part.Type, typeof(XmlSchemaComplexType));
            if (type == null) return false;
            if (type.ContentModel == null) return false;
            if (type.ContentModel.Content == null) throw new ArgumentException(Res.GetString(Res.Missing2, type.Name, type.ContentModel.GetType().Name), "part");
            if (type.ContentModel.Content is XmlSchemaComplexContentExtension) {
                return ((XmlSchemaComplexContentExtension)type.ContentModel.Content).BaseTypeName == new XmlQualifiedName(Soap.ArrayType, Soap.Encoding);
            }
            else if (type.ContentModel.Content is XmlSchemaComplexContentRestriction) {
                return ((XmlSchemaComplexContentRestriction)type.ContentModel.Content).BaseTypeName == new XmlQualifiedName(Soap.ArrayType, Soap.Encoding);
            }
            return false;
        }

        static void AppendMetadata(CodeAttributeDeclarationCollection from, CodeAttributeDeclarationCollection to) {
            foreach (CodeAttributeDeclaration attr in from) to.Add(attr);
        }

        CodeMemberMethod GenerateMethod(HttpMethodInfo method) {

            MimeParameterCollection parameters = method.MimeParameters != null ? method.MimeParameters : method.UrlParameters;

            string[] parameterTypeNames = new string[parameters.Count];
            string[] parameterNames = new string[parameters.Count];

            for (int i = 0; i < parameters.Count; i++) {
                MimeParameter param = parameters[i];
                parameterNames[i] = param.Name;
                parameterTypeNames[i] = param.TypeName;
            }

            CodeAttributeDeclarationCollection metadata = new CodeAttributeDeclarationCollection();
            
            CodeExpression[] formatterTypes = new CodeExpression[2];

            if (method.MimeReturn.ReaderType == null) {
                formatterTypes[0] = new CodeTypeOfExpression(typeof(NopReturnReader).FullName);
            }
            else {
                formatterTypes[0] = new CodeTypeOfExpression(method.MimeReturn.ReaderType.FullName);
            }

            if (method.MimeParameters != null)
                formatterTypes[1] = new CodeTypeOfExpression(method.MimeParameters.WriterType.FullName);
            else
                formatterTypes[1] = new CodeTypeOfExpression(typeof(UrlParameterWriter).FullName);

            WebCodeGenerator.AddCustomAttribute(metadata, typeof(HttpMethodAttribute), formatterTypes, new string[0], new CodeExpression[0]);


            CodeMemberMethod mainCodeMethod = WebCodeGenerator.AddMethod(this.CodeTypeDeclaration, method.Name, new CodeFlags[parameterTypeNames.Length], parameterTypeNames, parameterNames, 
                                        method.MimeReturn.TypeName, metadata, 
                                        CodeFlags.IsPublic | (Style == ServiceDescriptionImportStyle.Client ? 0 : CodeFlags.IsAbstract));

            AppendMetadata(method.MimeReturn.Attributes, mainCodeMethod.ReturnTypeCustomAttributes);

            mainCodeMethod.Comments.Add(new CodeCommentStatement("<remarks/>", true));

            for (int i = 0; i < parameters.Count; i++) {
                AppendMetadata(parameters[i].Attributes, mainCodeMethod.Parameters[i].CustomAttributes);
            }

            if (Style == ServiceDescriptionImportStyle.Client) {
                CodeExpression[] invokeParams = new CodeExpression[3];
                CreateInvokeParams(invokeParams, method, parameterNames);
                CodeExpression invoke = new CodeMethodInvokeExpression(new CodeThisReferenceExpression(), "Invoke", invokeParams);
                if (method.MimeReturn.ReaderType != null)
                    invoke = new CodeCastExpression(method.MimeReturn.TypeName, invoke);
                if (method.MimeReturn.ReaderType != null)
                    mainCodeMethod.Statements.Add(new CodeMethodReturnStatement(invoke));
                else
                    mainCodeMethod.Statements.Add(new CodeExpressionStatement(invoke));

                metadata = new CodeAttributeDeclarationCollection();

                string[] asyncParameterTypeNames = new string[parameterTypeNames.Length + 2];
                parameterTypeNames.CopyTo(asyncParameterTypeNames, 0);
                asyncParameterTypeNames[parameterTypeNames.Length] = typeof(AsyncCallback).FullName;
                asyncParameterTypeNames[parameterTypeNames.Length + 1] = typeof(object).FullName;

                string[] asyncParameterNames = new string[parameterNames.Length + 2];
                parameterNames.CopyTo(asyncParameterNames, 0);
                asyncParameterNames[parameterNames.Length] = "callback";
                asyncParameterNames[parameterNames.Length + 1] = "asyncState";

                CodeMemberMethod beginCodeMethod = WebCodeGenerator.AddMethod(this.CodeTypeDeclaration, "Begin" + method.Name, new CodeFlags[asyncParameterTypeNames.Length], 
                                            asyncParameterTypeNames, asyncParameterNames, 
                                            typeof(IAsyncResult).FullName, metadata, CodeFlags.IsPublic);
                beginCodeMethod.Comments.Add(new CodeCommentStatement("<remarks/>", true));
                
                invokeParams = new CodeExpression[5];
                CreateInvokeParams(invokeParams, method, parameterNames);

                invokeParams[3] = new CodeArgumentReferenceExpression( "callback");
                invokeParams[4] = new CodeArgumentReferenceExpression( "asyncState");

                invoke = new CodeMethodInvokeExpression(new CodeThisReferenceExpression(), "BeginInvoke", invokeParams);
                beginCodeMethod.Statements.Add(new CodeMethodReturnStatement(invoke));

                CodeMemberMethod endCodeMethod = WebCodeGenerator.AddMethod(this.CodeTypeDeclaration, "End" + method.Name, new CodeFlags[1], 
                                            new string[] { typeof(IAsyncResult).FullName },
                                            new string[] { "asyncResult" },
                                            method.MimeReturn.TypeName, metadata, CodeFlags.IsPublic);
                endCodeMethod.Comments.Add(new CodeCommentStatement("<remarks/>", true));

                CodeExpression expr = new CodeArgumentReferenceExpression( "asyncResult");
                invoke = new CodeMethodInvokeExpression(new CodeThisReferenceExpression(), "EndInvoke", new CodeExpression[] { expr });
                if (method.MimeReturn.ReaderType != null)
                    invoke = new CodeCastExpression(method.MimeReturn.TypeName, invoke);
                if (method.MimeReturn.ReaderType != null)
                    endCodeMethod.Statements.Add(new CodeMethodReturnStatement(invoke));
                else
                    endCodeMethod.Statements.Add(new CodeExpressionStatement(invoke));
            }

            return mainCodeMethod;
        }

        void CreateInvokeParams(CodeExpression[] invokeParams, HttpMethodInfo method, string[] parameterNames) {
            invokeParams[0] = new CodePrimitiveExpression(method.Name);

            CodeExpression left = new CodePropertyReferenceExpression(new CodeThisReferenceExpression(), "Url");
            CodeExpression right = new CodePrimitiveExpression(method.Href);
            invokeParams[1] = new CodeBinaryOperatorExpression(left, CodeBinaryOperatorType.Add, right);

            CodeExpression[] values = new CodeExpression[parameterNames.Length];
            for (int i = 0; i < parameterNames.Length; i++) {
                values[i] = new CodeArgumentReferenceExpression( parameterNames[i]);
            }
            invokeParams[2] = new CodeArrayCreateExpression(typeof(object).FullName, values);
        }

        protected override bool IsOperationFlowSupported(OperationFlow flow) {
            return flow == OperationFlow.RequestResponse;
        }

        // CONSIDER, erikc, warnings when can't handle a method
        // CONSIDER, erikc, handle POST with query string parameters as well
        protected override CodeMemberMethod GenerateMethod() {
            HttpOperationBinding httpOperationBinding = (HttpOperationBinding)OperationBinding.Extensions.Find(typeof(HttpOperationBinding));
            if (httpOperationBinding == null) throw OperationBindingSyntaxException(Res.GetString(Res.MissingHttpOperationElement0));

            HttpMethodInfo method = new HttpMethodInfo();

            if (hasInputPayload) {
                method.MimeParameters = ImportMimeParameters();
                if (method.MimeParameters == null) {
                    UnsupportedOperationWarning(Res.GetString(Res.NoInputMIMEFormatsWereRecognized0));
                    return null;
                }
            }
            else {
                method.UrlParameters = ImportUrlParameters();
                if (method.UrlParameters == null) {
                    UnsupportedOperationWarning(Res.GetString(Res.NoInputHTTPFormatsWereRecognized0));
                    return null;
                }
            }
            method.MimeReturn = ImportMimeReturn();
            if (method.MimeReturn == null) {
                UnsupportedOperationWarning(Res.GetString(Res.NoOutputMIMEFormatsWereRecognized0));
                return null;
            }
            method.Name = MethodNames.AddUnique(MethodName, method);
            method.Href = httpOperationBinding.Location;
            return GenerateMethod(method);
        }

        protected override CodeTypeDeclaration BeginClass() {
            methodNames.Clear();
            CodeAttributeDeclarationCollection metadata = new CodeAttributeDeclarationCollection();
            if (Style == ServiceDescriptionImportStyle.Client) {
                WebCodeGenerator.AddCustomAttribute(metadata, typeof(DebuggerStepThroughAttribute), new CodeExpression[0]);
                WebCodeGenerator.AddCustomAttribute(metadata, typeof(DesignerCategoryAttribute), new CodeExpression[] { new CodePrimitiveExpression("code") });
            }

            Type[] requiredTypes = new Type[] { typeof(SoapDocumentMethodAttribute), typeof(XmlAttributeAttribute), typeof(WebService), typeof(Object), typeof(DebuggerStepThroughAttribute), typeof(DesignerCategoryAttribute) };
            WebCodeGenerator.AddImports(this.CodeNamespace, WebCodeGenerator.GetNamespacesForTypes(requiredTypes));
            CodeTypeDeclaration codeClass = WebCodeGenerator.CreateClass(this.ClassName, BaseClass.FullName, 
                new string[0], metadata, CodeFlags.IsPublic | (Style == ServiceDescriptionImportStyle.Client ? 0 : CodeFlags.IsAbstract));

            codeClass.Comments.Add(new CodeCommentStatement("<remarks/>", true));

            CodeConstructor ctor = WebCodeGenerator.AddConstructor(codeClass, new string[0], new string[0], null, CodeFlags.IsPublic);
            ctor.Comments.Add(new CodeCommentStatement("<remarks/>", true));

            HttpAddressBinding httpAddressBinding = Port == null ? null : (HttpAddressBinding)Port.Extensions.Find(typeof(HttpAddressBinding));
            string url =  (httpAddressBinding != null) ? httpAddressBinding.Location : null;
            ServiceDescription serviceDescription = Binding.ServiceDescription;
            ProtocolImporterUtil.GenerateConstructorStatements(ctor, url, serviceDescription.AppSettingUrlKey, serviceDescription.AppSettingBaseUrl);

            codeClasses.Add(codeClass);
            return codeClass;
        }

        protected override void EndNamespace() { 
            for (int i = 0; i < importers.Length; i++) {
                importers[i].GenerateCode((MimeReturn[])importedReturns[i].ToArray(typeof(MimeReturn)), 
                                          (MimeParameterCollection[])importedParameters[i].ToArray(typeof(MimeParameterCollection))); 
            }

            foreach (CodeTypeDeclaration codeClass in codeClasses) {
                if (codeClass.CustomAttributes == null)
                    codeClass.CustomAttributes = new CodeAttributeDeclarationCollection();

                for (int i = 0; i < importers.Length; i++) {
                    importers[i].AddClassMetadata(codeClass);
                }
            }
            CodeGenerator.ValidateIdentifiers(CodeNamespace);
        }

        internal abstract Type BaseClass { get; }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\services\web\system\web\services\description\mimeparameter.cs ===
//------------------------------------------------------------------------------
// <copyright file="MimeParameter.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Web.Services.Description {

    using System.Web.Services;
    using System.Web.Services.Protocols;
    using System.Xml.Serialization;
    using System.Xml.Schema;
    using System.Collections;
    using System;
    using System.Reflection;
    using System.CodeDom;

    internal class MimeParameter {
        string name;
        string typeName;
        CodeAttributeDeclarationCollection attrs;

        internal string Name {
            get { return name == null ? string.Empty : name; }
            set { name = value; }
        }

        internal string TypeName {
            get { return typeName == null ? string.Empty : typeName; }
            set { typeName = value; }
        }

        internal CodeAttributeDeclarationCollection Attributes {
            get { 
                if (attrs == null)
                    attrs = new CodeAttributeDeclarationCollection();
                return attrs; 
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\services\web\system\web\services\description\mimereflector.cs ===
//------------------------------------------------------------------------------
// <copyright file="MimeReflector.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Web.Services.Description {

    using System.Web.Services;
    using System.Web.Services.Protocols;
    using System.Xml.Serialization;
    using System.Xml.Schema;
    using System.Collections;
    using System;
    using System.Reflection;

    internal abstract class MimeReflector {
        HttpProtocolReflector protocol;

        internal abstract bool ReflectParameters();
        internal abstract bool ReflectReturn();

        internal HttpProtocolReflector ReflectionContext {
            get { return protocol; }
            set { protocol = value; }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\services\web\system\web\services\description\mimereturn.cs ===
//------------------------------------------------------------------------------
// <copyright file="MimeReturn.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Web.Services.Description {

    using System.Web.Services;
    using System.Web.Services.Protocols;
    using System.Xml.Serialization;
    using System.Xml.Schema;
    using System.Collections;
    using System;
    using System.Reflection;
    using System.CodeDom;

    internal class MimeReturn {
        string typeName;
        Type readerType;
        CodeAttributeDeclarationCollection attrs;

        internal string TypeName {
            get { return typeName == null ? string.Empty : typeName; }
            set { typeName = value; }
        }

        internal Type ReaderType {
            get { return readerType; }
            set { readerType = value; }
        }

        internal CodeAttributeDeclarationCollection Attributes {
            get { 
                if (attrs == null)
                    attrs = new CodeAttributeDeclarationCollection();
                return attrs; 
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\services\web\system\web\services\description\mimeparameters.cs ===
//------------------------------------------------------------------------------
// <copyright file="MimeParameters.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Web.Services.Description {

    using System.Web.Services;
    using System.Web.Services.Protocols;
    using System.Xml.Serialization;
    using System.Xml.Schema;
    using System.Collections;
    using System;
    using System.Reflection;

    internal class MimeParameterCollection : CollectionBase {
        Type writerType;

        internal Type WriterType {
            get { return writerType; }
            set { writerType = value; }
        }
        
        internal MimeParameter this[int index] {
            get { return (MimeParameter)List[index]; }
            set { List[index] = value; }
        }
        
        internal int Add(MimeParameter parameter) {
            return List.Add(parameter);
        }
        
        internal void Insert(int index, MimeParameter parameter) {
            List.Insert(index, parameter);
        }
        
        internal int IndexOf(MimeParameter parameter) {
            return List.IndexOf(parameter);
        }
        
        internal bool Contains(MimeParameter parameter) {
            return List.Contains(parameter);
        }
        
        internal void Remove(MimeParameter parameter) {
            List.Remove(parameter);
        }
        
        internal void CopyTo(MimeParameter[] array, int index) {
            List.CopyTo(array, index);
        }
        
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\services\web\system\web\services\description\mimetextimporter.cs ===
//------------------------------------------------------------------------------
// <copyright file="MimeTextImporter.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>
//------------------------------------------------------------------------------


/**************************************************************************\
*
* Copyright (c) 1998-2002, Microsoft Corp.  All Rights Reserved.
*
* Module Name:
*
*   MimeTextImporter.cs
*
* Abstract:
*
* Revision History:
*
\**************************************************************************/
namespace System.Web.Services.Description {

    using System.Web.Services;
    using System.Web.Services.Protocols;
    using System.Collections;
    using System;
    using System.Reflection;
    using System.CodeDom;
    using System.Xml.Serialization;

    internal class MimeTextReturn : MimeReturn {
        MimeTextBinding textBinding;

        internal MimeTextBinding TextBinding {
            get { return textBinding; }
            set { textBinding = value; }
        }
    }

    internal class MimeTextImporter : MimeImporter {
        string methodName;

        internal override MimeParameterCollection ImportParameters() {
            return null;
        }

        internal override MimeReturn ImportReturn() {
            MimeTextBinding mimeTextBinding = (MimeTextBinding)ImportContext.OperationBinding.Output.Extensions.Find(typeof(MimeTextBinding));
            if (mimeTextBinding == null) return null;
            if (mimeTextBinding.Matches.Count == 0) {
                ImportContext.UnsupportedOperationBindingWarning(Res.GetString(Res.MissingMatchElement0));
                return null;
            }
            methodName = CodeIdentifier.MakeValid(ImportContext.OperationBinding.Name);

            MimeTextReturn importedReturn = new MimeTextReturn();
            importedReturn.TypeName = ImportContext.ClassNames.AddUnique(methodName + "Matches", mimeTextBinding);
            importedReturn.TextBinding = mimeTextBinding;
            importedReturn.ReaderType = typeof(TextReturnReader);
            return importedReturn;
        }

        internal override void GenerateCode(MimeReturn[] importedReturns, MimeParameterCollection[] importedParameters) { 
            for (int i = 0; i < importedReturns.Length; i++) {
                if (importedReturns[i] is MimeTextReturn) {  
                    GenerateCode((MimeTextReturn)importedReturns[i]);
                }
            }
        }

        void GenerateCode(MimeTextReturn importedReturn) {
            GenerateCode(importedReturn.TypeName, importedReturn.TextBinding.Matches);
        }

        void GenerateCode(string typeName, MimeTextMatchCollection matches) {
            CodeIdentifiers members = new CodeIdentifiers();
            CodeTypeDeclaration codeClass = WebCodeGenerator.AddClass(ImportContext.CodeNamespace, typeName, string.Empty, new string[0], null, CodeFlags.IsPublic);

            string[] fieldTypeNames = new string[matches.Count];
            for (int i = 0; i < matches.Count; i++) {
                MimeTextMatch match = matches[i];
                string name = members.AddUnique(CodeIdentifier.MakeValid(match.Name.Length == 0 ? methodName + "Match" : match.Name), match);
                CodeAttributeDeclarationCollection metadata = new CodeAttributeDeclarationCollection();
                if (match.Pattern.Length == 0) throw new ArgumentException(Res.GetString(Res.WebTextMatchMissingPattern));

                CodeExpression pattern = new CodePrimitiveExpression(match.Pattern);
                int numPropValues = 0;
                if (match.Group != 1) 
                    numPropValues++;
                if (match.Capture != 0)
                    numPropValues++;
                if (match.IgnoreCase)
                    numPropValues++;
                if (match.Repeats != 1 && match.Repeats != int.MaxValue)
                    numPropValues++;
                CodeExpression[] propertyValues = new CodeExpression[numPropValues];
                string[] propertyNames = new string[propertyValues.Length];
                numPropValues = 0;
                if (match.Group != 1) {
                    propertyValues[numPropValues] = new CodePrimitiveExpression(match.Group);
                    propertyNames[numPropValues] = "Group";
                    numPropValues++;
                }
                if (match.Capture != 0) {
                    propertyValues[numPropValues] = new CodePrimitiveExpression(match.Capture);
                    propertyNames[numPropValues] = "Capture";
                    numPropValues++;
                }
                if (match.IgnoreCase) {
                    propertyValues[numPropValues] = new CodePrimitiveExpression(match.IgnoreCase);
                    propertyNames[numPropValues] = "IgnoreCase";
                    numPropValues++;
                }
                if (match.Repeats != 1 && match.Repeats != int.MaxValue) {
                    propertyValues[numPropValues] = new CodePrimitiveExpression(match.Repeats);
                    propertyNames[numPropValues] = "MaxRepeats";
                    numPropValues++;
                }
                WebCodeGenerator.AddCustomAttribute(metadata, typeof(MatchAttribute), new CodeExpression[] { pattern }, propertyNames, propertyValues);

                string fieldTypeName;
                if (match.Matches.Count > 0) {
                    fieldTypeName = ImportContext.ClassNames.AddUnique(CodeIdentifier.MakeValid(match.Type.Length == 0 ? name : match.Type), match);
                    fieldTypeNames[i] = fieldTypeName;
                }
                else {
                    fieldTypeName = typeof(string).FullName;
                }
                if (match.Repeats != 1)
                    fieldTypeName += "[]";
                
                CodeMemberField field = WebCodeGenerator.AddField(codeClass, fieldTypeName, name, null, metadata, CodeFlags.IsPublic);
                
                if (match.Matches.Count == 0 && match.Type.Length > 0) {
                    ImportContext.Warnings |= ServiceDescriptionImportWarnings.OptionalExtensionsIgnored;
                    ProtocolImporter.AddWarningComment(field.Comments, Res.GetString(Res.WebTextMatchIgnoredTypeWarning));
                }
            }

            for (int i = 0; i < fieldTypeNames.Length; i++) {
                string fieldTypeName = fieldTypeNames[i];
                if (fieldTypeName != null) {
                    GenerateCode(fieldTypeName, matches[i].Matches);
                }
            }
        }

    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\services\web\system\web\services\description\mimexmlimporter.cs ===
//------------------------------------------------------------------------------
// <copyright file="MimeXmlImporter.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------
namespace System.Web.Services.Description {
    using System.Web.Services.Protocols;
    using System.Xml.Serialization;
    using System.Xml.Schema;
    using System.Xml;
    using System.CodeDom;

    internal class MimeXmlReturn : MimeReturn {
        XmlTypeMapping mapping;

        internal XmlTypeMapping TypeMapping {
            get { return mapping; }
            set { mapping = value; }
        }
    }

    internal class MimeXmlImporter : MimeImporter {
        XmlSchemaImporter importer;
        XmlCodeExporter exporter;

        internal override MimeParameterCollection ImportParameters() {
            return null;
        }

        internal override MimeReturn ImportReturn() {
            MimeContentBinding mimeContentBinding = (MimeContentBinding)ImportContext.OperationBinding.Output.Extensions.Find(typeof(MimeContentBinding));
            if (mimeContentBinding != null) {
                if (!ContentType.MatchesBase(mimeContentBinding.Type, ContentType.TextXml)) {
                     return null;
                }
                MimeReturn importedReturn = new MimeReturn();
                importedReturn.TypeName = typeof(XmlElement).FullName;
                importedReturn.ReaderType = typeof(XmlReturnReader);
                return importedReturn;
            }
            
            MimeXmlBinding mimeXmlBinding = (MimeXmlBinding)ImportContext.OperationBinding.Output.Extensions.Find(typeof(MimeXmlBinding));
            if (mimeXmlBinding != null) {
                MimeXmlReturn importedReturn = new MimeXmlReturn();
                MessagePart part;
                switch (ImportContext.OutputMessage.Parts.Count) {
                    case 0: 
                        throw new InvalidOperationException(Res.GetString(Res.MessageHasNoParts1, ImportContext.InputMessage.Name));
                    case 1: 
                        if (mimeXmlBinding.Part == null || mimeXmlBinding.Part.Length == 0) {
                            part = ImportContext.OutputMessage.Parts[0];
                        }
                        else {
                            part = ImportContext.OutputMessage.FindPartByName(mimeXmlBinding.Part);
                        }
                        break;
                    default:
                        part = ImportContext.OutputMessage.FindPartByName(mimeXmlBinding.Part);
                        break;
                }
                importedReturn.TypeMapping = Importer.ImportTypeMapping(part.Element);
                importedReturn.TypeName = importedReturn.TypeMapping.TypeFullName;
                importedReturn.ReaderType = typeof(XmlReturnReader);
                Exporter.AddMappingMetadata(importedReturn.Attributes, importedReturn.TypeMapping, string.Empty);
                return importedReturn;
            }
            return null;
        }

        XmlSchemaImporter Importer {
            get {
                if (importer == null)
                    importer = new XmlSchemaImporter(ImportContext.ConcreteSchemas);
                return importer;
            }
        }

        XmlCodeExporter Exporter {
            get {
                if (exporter == null)
                    exporter = new XmlCodeExporter(ImportContext.CodeNamespace);
                return exporter;
            }
        }

        internal override void GenerateCode(MimeReturn[] importedReturns, MimeParameterCollection[] importedParameters) { 
            for (int i = 0; i < importedReturns.Length; i++) {
                if (importedReturns[i] is MimeXmlReturn) {
                    GenerateCode((MimeXmlReturn)importedReturns[i]);
                }
            }
        }

        void GenerateCode(MimeXmlReturn importedReturn) {
            Exporter.ExportTypeMapping(importedReturn.TypeMapping);
        }

        internal override void AddClassMetadata(CodeTypeDeclaration codeClass) {
            foreach (CodeAttributeDeclaration attribute in Exporter.IncludeMetadata) {
                codeClass.CustomAttributes.Add(attribute);
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\services\web\system\web\services\description\mimexmlreflector.cs ===
//------------------------------------------------------------------------------
// <copyright file="MimeXmlReflector.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Web.Services.Description {

    using System.Web.Services;
    using System.Web.Services.Protocols;
    using System.Xml.Serialization;
    using System.Xml.Schema;
    using System.Collections;
    using System;
    using System.Reflection;
    using System.Xml;

    internal class MimeXmlReflector : MimeReflector {
        internal override bool ReflectParameters() {
            return false;
        }

        internal override bool ReflectReturn() {
            MessagePart part = new MessagePart();
            part.Name = "Body";
            ReflectionContext.OutputMessage.Parts.Add(part);

            if (typeof(XmlNode).IsAssignableFrom(ReflectionContext.Method.ReturnType)) {
                MimeContentBinding mimeContentBinding = new MimeContentBinding();
                mimeContentBinding.Type = "text/xml";
                mimeContentBinding.Part = part.Name;
                ReflectionContext.OperationBinding.Output.Extensions.Add(mimeContentBinding);
            }
            else {
                MimeXmlBinding mimeXmlBinding = new MimeXmlBinding();
                mimeXmlBinding.Part = part.Name;

                LogicalMethodInfo methodInfo = ReflectionContext.Method;
                XmlAttributes a = new XmlAttributes(methodInfo.ReturnTypeCustomAttributeProvider);
                XmlTypeMapping xmlTypeMapping = ReflectionContext.ReflectionImporter.ImportTypeMapping(methodInfo.ReturnType, a.XmlRoot);
                ReflectionContext.SchemaExporter.ExportTypeMapping(xmlTypeMapping);
                part.Element = new XmlQualifiedName(xmlTypeMapping.ElementName, xmlTypeMapping.Namespace);
                ReflectionContext.OperationBinding.Output.Extensions.Add(mimeXmlBinding);
            }

            return true;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\services\web\system\web\services\description\protocolimporter.cs ===
//------------------------------------------------------------------------------
// <copyright file="ProtocolImporter.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Web.Services.Description {

    using System.Web.Services;
    using System.Web.Services.Protocols;
    using System.Xml.Serialization;
    using System.Xml.Schema;
    using System.Collections;
    using System;
    using System.Reflection;
    using System.CodeDom;
    using System.CodeDom.Compiler;
    using System.Text;
    using System.Xml;
    using System.Web.Services.Configuration;
    using System.Configuration; 
    using System.Security.Permissions;

    /// <include file='doc\ProtocolImporter.uex' path='docs/doc[@for="ProtocolImporter"]/*' />
    /// <devdoc>
    ///    <para>[To be supplied.]</para>
    /// </devdoc>
    [PermissionSet(SecurityAction.InheritanceDemand, Name="FullTrust")]
    [PermissionSet(SecurityAction.LinkDemand, Name="FullTrust")]
    public abstract class ProtocolImporter {
        ServiceDescriptionImporter importer;
        CodeNamespace codeNamespace;
        CodeTypeDeclaration codeClass;
        ServiceDescriptionImportWarnings warnings;
        Port port;
        PortType portType;
        Binding binding;
        Operation operation;
        OperationBinding operationBinding;
        CodeIdentifiers identifiers;
        Service service;
        Message inputMessage;
        Message outputMessage;
        string className;
        int bindingCount;
        bool anyPorts;

        internal void Initialize(ServiceDescriptionImporter importer) {
            this.importer = importer;
        }

        /// <include file='doc\ProtocolImporter.uex' path='docs/doc[@for="ProtocolImporter.ServiceDescriptions"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public ServiceDescriptionCollection ServiceDescriptions {
            get { return importer.ServiceDescriptions; }
        }

        /// <include file='doc\ProtocolImporter.uex' path='docs/doc[@for="ProtocolImporter.Schemas"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public XmlSchemas Schemas {
            get { return importer.AllSchemas; }
        }

        /// <include file='doc\ProtocolImporter.uex' path='docs/doc[@for="ProtocolImporter.AbstractSchemas"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public XmlSchemas AbstractSchemas {
            get { return importer.AbstractSchemas; }
        }

        /// <include file='doc\ProtocolImporter.uex' path='docs/doc[@for="ProtocolImporter.ConcreteSchemas"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public XmlSchemas ConcreteSchemas {
            get { return importer.ConcreteSchemas; }
        }

        /// <include file='doc\ProtocolImporter.uex' path='docs/doc[@for="ProtocolImporter.CodeNamespace"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public CodeNamespace CodeNamespace {
            get { return codeNamespace; }
        }

        /// <include file='doc\ProtocolImporter.uex' path='docs/doc[@for="ProtocolImporter.CodeTypeDeclaration"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public CodeTypeDeclaration CodeTypeDeclaration {
            get { return codeClass; }
        }

        /// <include file='doc\ProtocolImporter.uex' path='docs/doc[@for="ProtocolImporter.Style"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public ServiceDescriptionImportStyle Style {
            get { return importer.Style; }
        }

        /// <include file='doc\ProtocolImporter.uex' path='docs/doc[@for="ProtocolImporter.Warnings"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public ServiceDescriptionImportWarnings Warnings {
            get { return warnings; }
            set { warnings = value; }
        }

        /// <include file='doc\ProtocolImporter.uex' path='docs/doc[@for="ProtocolImporter.ClassNames"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public CodeIdentifiers ClassNames {
            get { return identifiers; }
        }

        /// <include file='doc\ProtocolImporter.uex' path='docs/doc[@for="ProtocolImporter.MethodName"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public string MethodName {
            get {
                // We don't attempt to make this unique because of method overloading
                return CodeIdentifier.MakeValid(Operation.Name); 
            }
        }

        /// <include file='doc\ProtocolImporter.uex' path='docs/doc[@for="ProtocolImporter.ClassName"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public string ClassName {
            get { return className; }
        }

        /// <include file='doc\ProtocolImporter.uex' path='docs/doc[@for="ProtocolImporter.Port"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public Port Port {
            get { return port; }
        }

        /// <include file='doc\ProtocolImporter.uex' path='docs/doc[@for="ProtocolImporter.PortType"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public PortType PortType {
            get { return portType; }
        }

        /// <include file='doc\ProtocolImporter.uex' path='docs/doc[@for="ProtocolImporter.Binding"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public Binding Binding {
            get { return binding; }
        }

        /// <include file='doc\ProtocolImporter.uex' path='docs/doc[@for="ProtocolImporter.Service"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public Service Service {
            get { return service; }
        }

        internal ServiceDescriptionImporter ServiceImporter {
            get { return importer; }
        }

        /// <include file='doc\ProtocolImporter.uex' path='docs/doc[@for="ProtocolImporter.Operation"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public Operation Operation {
            get { return operation; }
        }

        /// <include file='doc\ProtocolImporter.uex' path='docs/doc[@for="ProtocolImporter.OperationBinding"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public OperationBinding OperationBinding {
            get { return operationBinding; }
        }

        /// <include file='doc\ProtocolImporter.uex' path='docs/doc[@for="ProtocolImporter.InputMessage"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public Message InputMessage {
            get { return inputMessage; }
        }

        /// <include file='doc\ProtocolImporter.uex' path='docs/doc[@for="ProtocolImporter.OutputMessage"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public Message OutputMessage {
            get { return outputMessage; }
        }

        internal bool GenerateCode(CodeNamespace codeNamespace) {
            bindingCount = 0;
            anyPorts = false;

            this.codeNamespace = codeNamespace;

            Hashtable supportedBindings = new Hashtable();
            Hashtable unsupportedBindings = new Hashtable();

            // look for ports with bindings
            foreach (ServiceDescription serviceDescription in ServiceDescriptions) {
                foreach (Service service in serviceDescription.Services) {
                    foreach (Port port in service.Ports) {
                        Binding binding = ServiceDescriptions.GetBinding(port.Binding);
                        if (supportedBindings.Contains(binding))
                            continue;
                        PortType portType = ServiceDescriptions.GetPortType(binding.Type);
                        MoveToBinding(service, port, binding, portType);
                        if (IsBindingSupported()) {
                            bindingCount++;
                            anyPorts = true;
                            supportedBindings.Add(binding, binding);
                        }
                        else if (binding != null) unsupportedBindings[binding] = binding;
                    }
                }
            }

            // no ports, look for bindings
            if (bindingCount == 0) {
                foreach (ServiceDescription serviceDescription in ServiceDescriptions) {
                    foreach (Binding binding in serviceDescription.Bindings) {
                        if (unsupportedBindings.Contains(binding)) continue;
                        PortType portType = ServiceDescriptions.GetPortType(binding.Type);
                        MoveToBinding(binding, portType);
                        if (IsBindingSupported()) {
                            bindingCount++;
                        }
                    }
                }
            }

            // give up if no bindings
            if (bindingCount == 0) {
                // if we generated comments return true so that the comments get written
                return codeNamespace.Comments.Count > 0;
            }

            this.identifiers = new CodeIdentifiers();
            BeginNamespace();

            supportedBindings.Clear();
            foreach (ServiceDescription serviceDescription in ServiceDescriptions) {
                if (anyPorts) {
                    foreach (Service service in serviceDescription.Services) {
                        foreach (Port port in service.Ports) {
                            Binding binding = ServiceDescriptions.GetBinding(port.Binding);
                            PortType portType = ServiceDescriptions.GetPortType(binding.Type);
                            MoveToBinding(service, port, binding, portType);
                            if (IsBindingSupported() && !supportedBindings.Contains(binding)) {
                                GenerateClassForBinding();
                                supportedBindings.Add(binding, binding);
                            }
                        }
                    }
                }
                else {
                    foreach (Binding binding in serviceDescription.Bindings) {
                        PortType portType = ServiceDescriptions.GetPortType(binding.Type);
                        MoveToBinding(binding, portType);
                        if (IsBindingSupported()) {
                            GenerateClassForBinding();
                        }
                    }
                }
            }

            EndNamespace();
            return true;
        }

        void MoveToBinding(Binding binding, PortType portType) {
            this.service = null;
            this.port = null;
            this.portType = portType;
            this.binding = binding;
        }

        void MoveToBinding(Service service, Port port, Binding binding, PortType portType) {
            this.service = service;
            this.port = port;
            this.portType = portType;
            this.binding = binding;
        }

        void MoveToOperation(Operation operation) {
            this.operation = operation;

            operationBinding = null;
            foreach (OperationBinding b in binding.Operations) {
                if (operation.IsBoundBy(b)) {
                    if (operationBinding != null) throw OperationSyntaxException(Res.GetString(Res.DuplicateInputOutputNames0));
                    operationBinding = b;
                }
            }
            if (operationBinding == null) {
                throw OperationSyntaxException(Res.GetString(Res.MissingBinding0));
            }
            //NOTE: The following two excepions would never happen since IsBoundBy checks these conditions already.
            if (operation.Messages.Input != null && operationBinding.Input == null) {
                throw OperationSyntaxException(Res.GetString(Res.MissingInputBinding0));
            }
            if (operation.Messages.Output != null && operationBinding.Output == null) {
                throw OperationSyntaxException(Res.GetString(Res.MissingOutputBinding0));
            }

            this.inputMessage = operation.Messages.Input == null ? null : ServiceDescriptions.GetMessage(operation.Messages.Input.Message);
            this.outputMessage = operation.Messages.Output == null ? null : ServiceDescriptions.GetMessage(operation.Messages.Output.Message);
        }

        void GenerateClassForBinding() {
            try {
                if (bindingCount == 1 && service != null) {
                    // If there is only one binding, then use the name of the service
                    className = service.Name;
                }
                else {
                    // If multiple bindings, then use the name of the binding
                    className = binding.Name;
                }

                className = identifiers.AddUnique(CodeIdentifier.MakeValid(className), null);

                this.codeClass = BeginClass();

                for (int i = 0; i < portType.Operations.Count; i++) {
                    MoveToOperation(portType.Operations[i]);

                    if (!IsOperationFlowSupported(operation.Messages.Flow)) {
                        // CONSIDER, erikc, consider just flipping the "Client" direction for solicitresponse/notify?
                        switch (operation.Messages.Flow) {
                            case OperationFlow.SolicitResponse:
                                UnsupportedOperationWarning(Res.GetString(Res.SolicitResponseIsNotSupported0));
                                continue;
                            case OperationFlow.RequestResponse:
                                UnsupportedOperationWarning(Res.GetString(Res.RequestResponseIsNotSupported0));
                                continue;
                            case OperationFlow.OneWay:
                                UnsupportedOperationWarning(Res.GetString(Res.OneWayIsNotSupported0));
                                continue;
                            case OperationFlow.Notification:
                                UnsupportedOperationWarning(Res.GetString(Res.NotificationIsNotSupported0));
                                continue;
                        }
                    }

                    CodeMemberMethod method;
                    try {
                        method = GenerateMethod();
                    }
                    catch (Exception e) {
                        throw new InvalidOperationException(Res.GetString(Res.UnableToImportOperation1, operation.Name), e);
                    }

                    if (method != null) {
                        AddExtensionWarningComments(codeClass.Comments, operationBinding.Extensions);
                        if (operationBinding.Input != null) AddExtensionWarningComments(codeClass.Comments, operationBinding.Input.Extensions);
                        if (operationBinding.Output != null) AddExtensionWarningComments(codeClass.Comments, operationBinding.Output.Extensions);
                    }
                }

                EndClass();

                if (portType.Operations.Count == 0)
                    NoMethodsGeneratedWarning();

                AddExtensionWarningComments(codeClass.Comments, binding.Extensions);
                if (port != null) AddExtensionWarningComments(codeClass.Comments, port.Extensions);

                codeNamespace.Types.Add(codeClass);
            }
            catch (Exception e) {
                throw new InvalidOperationException(Res.GetString(Res.UnableToImportBindingFromNamespace2, binding.Name, binding.ServiceDescription.TargetNamespace), e);
            }
        }

        /// <include file='doc\ProtocolImporter.uex' path='docs/doc[@for="ProtocolImporter.AddExtensionWarningComments"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public void AddExtensionWarningComments(CodeCommentStatementCollection comments, ServiceDescriptionFormatExtensionCollection extensions) {
            foreach (object item in extensions) {
                if (!extensions.IsHandled(item)) {
                    string name = null;
                    string ns = null;
                    if (item is XmlElement) {
                        XmlElement element = (XmlElement)item;
                        name = element.LocalName;
                        ns = element.NamespaceURI;
                    }
                    else if (item is ServiceDescriptionFormatExtension) {
                        XmlFormatExtensionAttribute[] attrs = (XmlFormatExtensionAttribute[])item.GetType().GetCustomAttributes(typeof(XmlFormatExtensionAttribute), false);
                        if (attrs.Length > 0) {
                            name = attrs[0].ElementName;
                            ns = attrs[0].Namespace;
                        }
                    }
                    if (name != null) {
                        if (extensions.IsRequired(item)) {
                            warnings |= ServiceDescriptionImportWarnings.RequiredExtensionsIgnored;
                            AddWarningComment(comments, Res.GetString(Res.WebServiceDescriptionIgnoredRequired, name, ns));
                        }
                        else {
                            warnings |= ServiceDescriptionImportWarnings.OptionalExtensionsIgnored;
                            AddWarningComment(comments, Res.GetString(Res.WebServiceDescriptionIgnoredOptional, name, ns));
                        }
                    }
                }
            }
        }

        /// <include file='doc\ProtocolImporter.uex' path='docs/doc[@for="ProtocolImporter.UnsupportedBindingWarning"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public void UnsupportedBindingWarning(string text) {
            AddWarningComment(codeClass == null ? codeNamespace.Comments : codeClass.Comments, Res.GetString(Res.TheBinding0FromNamespace1WasIgnored2, Binding.Name, Binding.ServiceDescription.TargetNamespace, text));
            warnings |= ServiceDescriptionImportWarnings.UnsupportedBindingsIgnored;
        }

        /// <include file='doc\ProtocolImporter.uex' path='docs/doc[@for="ProtocolImporter.UnsupportedOperationWarning"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public void UnsupportedOperationWarning(string text) {
            AddWarningComment(codeClass == null ? codeNamespace.Comments : codeClass.Comments, Res.GetString(Res.TheOperation0FromNamespace1WasIgnored2, operation.Name, operation.PortType.ServiceDescription.TargetNamespace, text));
            warnings |= ServiceDescriptionImportWarnings.UnsupportedOperationsIgnored;
        }

        /// <include file='doc\ProtocolImporter.uex' path='docs/doc[@for="ProtocolImporter.UnsupportedOperationBindingWarning"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public void UnsupportedOperationBindingWarning(string text) {
            AddWarningComment(codeClass == null ? codeNamespace.Comments : codeClass.Comments, Res.GetString(Res.TheOperationBinding0FromNamespace1WasIgnored, operationBinding.Name, operationBinding.Binding.ServiceDescription.TargetNamespace, text));
            warnings |= ServiceDescriptionImportWarnings.UnsupportedOperationsIgnored;
        }

        void NoMethodsGeneratedWarning() {
            AddWarningComment(codeClass.Comments, Res.GetString(Res.NoMethodsWereFoundInTheWSDLForThisProtocol));
            warnings |= ServiceDescriptionImportWarnings.NoMethodsGenerated;
        }

        internal static void AddWarningComment(CodeCommentStatementCollection comments, string text) {
            comments.Add(new CodeCommentStatement("CODEGEN: " + text));
        }

        /// <include file='doc\ProtocolImporter.uex' path='docs/doc[@for="ProtocolImporter.OperationSyntaxException"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public Exception OperationSyntaxException(string text) {
            return new Exception(Res.GetString(Res.TheOperationFromNamespaceHadInvalidSyntax3,
                                               operation.Name,
                                               operation.PortType.Name,
                                               operation.PortType.ServiceDescription.TargetNamespace,
                                               text));
        }

        /// <include file='doc\ProtocolImporter.uex' path='docs/doc[@for="ProtocolImporter.OperationBindingSyntaxException"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public Exception OperationBindingSyntaxException(string text) {
            return new Exception(Res.GetString(Res.TheOperationBindingFromNamespaceHadInvalid3, operationBinding.Name, operationBinding.Binding.ServiceDescription.TargetNamespace, text));
        }

        /// <include file='doc\ProtocolImporter.uex' path='docs/doc[@for="ProtocolImporter.ProtocolName"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public abstract string ProtocolName { get; }

        // These overridable methods have no parameters.  The subclass uses properties on this
        // base object to obtain the information.  This allows us to grow the set of
        // information passed to the methods over time w/o breaking anyone.   They are protected
        // instead of public because this object is passed to extensions and we don't want
        // those calling these methods.
        /// <include file='doc\ProtocolImporter.uex' path='docs/doc[@for="ProtocolImporter.BeginNamespace"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        protected virtual void BeginNamespace() { }
        /// <include file='doc\ProtocolImporter.uex' path='docs/doc[@for="ProtocolImporter.IsBindingSupported"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        protected abstract bool IsBindingSupported();
        /// <include file='doc\ProtocolImporter.uex' path='docs/doc[@for="ProtocolImporter.IsOperationFlowSupported"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        protected abstract bool IsOperationFlowSupported(OperationFlow flow);
        /// <include file='doc\ProtocolImporter.uex' path='docs/doc[@for="ProtocolImporter.BeginClass"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        protected abstract CodeTypeDeclaration BeginClass();
        /// <include file='doc\ProtocolImporter.uex' path='docs/doc[@for="ProtocolImporter.GenerateMethod"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        protected abstract CodeMemberMethod GenerateMethod();
        /// <include file='doc\ProtocolImporter.uex' path='docs/doc[@for="ProtocolImporter.EndClass"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        protected virtual void EndClass() { }
        /// <include file='doc\ProtocolImporter.uex' path='docs/doc[@for="ProtocolImporter.EndNamespace"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        protected virtual void EndNamespace() { 
            CodeGenerator.ValidateIdentifiers(codeNamespace);
        }
    }

    internal class ProtocolImporterUtil {
        internal static void GenerateConstructorStatements(CodeConstructor ctor, string url, string appSettingUrlKey, string appSettingBaseUrl) {
            CodeExpression value; 
            bool generateFixedUrlAssignment = (url != null && url.Length > 0);
            bool generateConfigUrlAssignment = appSettingUrlKey != null && appSettingUrlKey.Length > 0;
            CodeAssignStatement assignUrlStatement = null;

            if (!generateFixedUrlAssignment && !generateConfigUrlAssignment)
                return;

            // this.Url property
            CodePropertyReferenceExpression urlPropertyReference = new CodePropertyReferenceExpression(new CodeThisReferenceExpression(), "Url");

            if (generateFixedUrlAssignment) {
                value = new CodePrimitiveExpression(url);
                assignUrlStatement = new CodeAssignStatement(urlPropertyReference, value);
            }

            if (generateFixedUrlAssignment && !generateConfigUrlAssignment) {
                ctor.Statements.Add(assignUrlStatement);
            }
            else if (generateConfigUrlAssignment) {
                // urlSetting local variable
                CodeVariableReferenceExpression urlSettingReference = new CodeVariableReferenceExpression("urlSetting");                

                // Generate: string urlSetting = System.Configuration.ConfigurationSettings.AppSettings["<appSettingUrlKey>"];
                CodeTypeReferenceExpression codeTypeReference = new CodeTypeReferenceExpression(typeof(ConfigurationSettings));
                CodePropertyReferenceExpression propertyReference = new CodePropertyReferenceExpression(codeTypeReference, "AppSettings");
                value = new CodeIndexerExpression(propertyReference, new CodeExpression[] { new CodePrimitiveExpression(appSettingUrlKey) });
                ctor.Statements.Add(new CodeVariableDeclarationStatement(typeof(string), "urlSetting", value));

                if (appSettingBaseUrl == null || appSettingBaseUrl.Length == 0) {
                    // Generate: this.Url = urlSetting;
                    value = urlSettingReference;
                }
                else {
                    // Generate: this.Url = "http://localhost/mywebapplication/simple.asmx";
                    if (url == null || url.Length == 0)
                        throw new ArgumentException(Res.GetString(Res.IfAppSettingBaseUrlArgumentIsSpecifiedThen0));
                    string relativeUrl = new Uri(appSettingBaseUrl).MakeRelative(new Uri(url));
                    CodeExpression[] parameters = new CodeExpression[] { urlSettingReference, new CodePrimitiveExpression(relativeUrl) };
                    value = new CodeMethodInvokeExpression(new CodeTypeReferenceExpression(typeof(System.String)), "Concat", parameters);                
                }
                CodeStatement[] trueStatements = new CodeStatement[] { new CodeAssignStatement(urlPropertyReference, value) };        

                // Generate: if (urlSetting != null) { <truestatement> } else { <falsestatement> }
                CodeBinaryOperatorExpression checkIfNull = new CodeBinaryOperatorExpression(urlSettingReference, CodeBinaryOperatorType.IdentityInequality, new CodePrimitiveExpression(null));
                if (generateFixedUrlAssignment)
                    ctor.Statements.Add(new CodeConditionStatement(checkIfNull, trueStatements, new CodeStatement[] { assignUrlStatement }));
                else
                    ctor.Statements.Add(new CodeConditionStatement(checkIfNull, trueStatements));
            }

        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\services\web\system\web\services\description\servicedescriptions.cs ===
//------------------------------------------------------------------------------
// <copyright file="ServiceDescriptions.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Web.Services.Description {

    using System.Xml;
    using System.Xml.Serialization;
    using System.Xml.Schema;
    using System.Collections;
    using System;
    using System.IO;
    using System.ComponentModel;

    /// <include file='doc\ServiceDescriptions.uex' path='docs/doc[@for="ServiceDescriptionCollection"]/*' />
    /// <devdoc>
    ///    <para>[To be supplied.]</para>
    /// </devdoc>
    public sealed class ServiceDescriptionCollection : ServiceDescriptionBaseCollection {
        /// <include file='doc\ServiceDescriptions.uex' path='docs/doc[@for="ServiceDescriptionCollection.ServiceDescriptionCollection"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public ServiceDescriptionCollection() : base(null) { }
        
        /// <include file='doc\ServiceDescriptions.uex' path='docs/doc[@for="ServiceDescriptionCollection.this"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public ServiceDescription this[int index] {
            get { return (ServiceDescription)List[index]; }
            set { List[index] = value; }
        }
        
        /// <include file='doc\ServiceDescriptions.uex' path='docs/doc[@for="ServiceDescriptionCollection.this1"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public ServiceDescription this[string ns] {
            get { return (ServiceDescription)Table[ns]; }
        }

        /// <include file='doc\ServiceDescriptions.uex' path='docs/doc[@for="ServiceDescriptionCollection.Add"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public int Add(ServiceDescription serviceDescription) {
            return List.Add(serviceDescription);
        }
        
        /// <include file='doc\ServiceDescriptions.uex' path='docs/doc[@for="ServiceDescriptionCollection.Insert"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public void Insert(int index, ServiceDescription serviceDescription) {
            List.Insert(index, serviceDescription);
        }
        
        /// <include file='doc\ServiceDescriptions.uex' path='docs/doc[@for="ServiceDescriptionCollection.IndexOf"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public int IndexOf(ServiceDescription serviceDescription) {
            return List.IndexOf(serviceDescription);
        }
        
        /// <include file='doc\ServiceDescriptions.uex' path='docs/doc[@for="ServiceDescriptionCollection.Contains"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public bool Contains(ServiceDescription serviceDescription) {
            return List.Contains(serviceDescription);
        }
        
        /// <include file='doc\ServiceDescriptions.uex' path='docs/doc[@for="ServiceDescriptionCollection.Remove"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public void Remove(ServiceDescription serviceDescription) {
            List.Remove(serviceDescription);
        }
        
        /// <include file='doc\ServiceDescriptions.uex' path='docs/doc[@for="ServiceDescriptionCollection.CopyTo"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public void CopyTo(ServiceDescription[] array, int index) {
            List.CopyTo(array, index);
        }

        /// <include file='doc\ServiceDescriptions.uex' path='docs/doc[@for="ServiceDescriptionCollection.GetKey"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        protected override string GetKey(object value) {
            string ns = ((ServiceDescription)value).TargetNamespace;
            if (ns == null || ns.Length == 0) 
                return null;
            return ns;
        }

        Exception ItemNotFound(XmlQualifiedName name, string type) {
            return new Exception(Res.GetString(Res.WebDescriptionMissingItem, type, name.Name, name.Namespace));
        }

        /// <include file='doc\ServiceDescriptions.uex' path='docs/doc[@for="ServiceDescriptionCollection.GetMessage"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public Message GetMessage(XmlQualifiedName name) {
            Message message = GetServiceDescription(name).Messages[name.Name];
            if (message == null) throw ItemNotFound(name, "message");
            return message;
        }

        /// <include file='doc\ServiceDescriptions.uex' path='docs/doc[@for="ServiceDescriptionCollection.GetPortType"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public PortType GetPortType(XmlQualifiedName name) {
            PortType portType = GetServiceDescription(name).PortTypes[name.Name];
            if (portType == null) throw ItemNotFound(name, "portType");
            return portType;
        }

        /// <include file='doc\ServiceDescriptions.uex' path='docs/doc[@for="ServiceDescriptionCollection.GetService"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public Service GetService(XmlQualifiedName name) {
            Service service = GetServiceDescription(name).Services[name.Name];
            if (service == null) throw ItemNotFound(name, "service");
            return service;
        }

        /// <include file='doc\ServiceDescriptions.uex' path='docs/doc[@for="ServiceDescriptionCollection.GetBinding"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public Binding GetBinding(XmlQualifiedName name) {
            Binding binding = GetServiceDescription(name).Bindings[name.Name];
            if (binding == null) throw ItemNotFound(name, "binding");
            return binding;
        }

        ServiceDescription GetServiceDescription(XmlQualifiedName name) {
            ServiceDescription serviceDescription = this[name.Namespace];
            if (serviceDescription == null) {
                throw new ArgumentException(Res.GetString(Res.WebDescriptionMissing, name.ToString(), name.Namespace), "name");
            }
            return serviceDescription;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\services\web\system\web\services\description\servicedescriptionserializer.cs ===
//------------------------------------------------------------------------------
// <copyright file="ServiceDescriptionSerializer.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>
//------------------------------------------------------------------------------


/**************************************************************************\
*
* Copyright (c) 1998-2002, Microsoft Corp.  All Rights Reserved.
*
* Module Name:
*
*   ServiceDescriptionSerializer.cs
*
* Abstract:
*
* Revision History:
*
\**************************************************************************/
namespace System.Web.Services.Description{
internal class ServiceDescriptionSerializationWriter : System.Xml.Serialization.XmlSerializationWriter {

        void Write1_ServiceDescription(string n, string ns, System.Web.Services.Description.ServiceDescription o, bool isNullable, bool needType) {
            if ((object)o == null) {
                if (isNullable) WriteNullTagLiteral(n, ns);
                return;
            }
            if (!needType) {
                System.Type t = o.GetType();
                if (t == typeof(System.Web.Services.Description.ServiceDescription))
                    ;
                else {
                    throw CreateUnknownTypeException(o);
                }
            }
            WriteStartElement(n, ns, o);
            if (needType) WriteXsiType(@"ServiceDescription", @"http://schemas.xmlsoap.org/wsdl/");
            WriteAttribute(@"targetNamespace", @"", (System.String)o.@TargetNamespace);
            WriteAttribute(@"name", @"", FromXmlNmToken((System.String)o.@Name));
            if (((System.String)o.@Documentation) != @"") {
                WriteElementString(@"documentation", @"http://schemas.xmlsoap.org/wsdl/", ((System.String)o.@Documentation));
            }
            {
                System.Web.Services.Description.ImportCollection a = (System.Web.Services.Description.ImportCollection)o.@Imports;
                if (a != null) {
                    for (int ia = 0; ia < a.Count; ia++) {
                        Write4_Import(@"import", @"http://schemas.xmlsoap.org/wsdl/", ((System.Web.Services.Description.Import)a[ia]), false, false);
                    }
                }
            }
            Write5_Types(@"types", @"http://schemas.xmlsoap.org/wsdl/", ((System.Web.Services.Description.Types)o.@Types), false, false);
            {
                System.Web.Services.Description.MessageCollection a = (System.Web.Services.Description.MessageCollection)o.@Messages;
                if (a != null) {
                    for (int ia = 0; ia < a.Count; ia++) {
                        Write68_Message(@"message", @"http://schemas.xmlsoap.org/wsdl/", ((System.Web.Services.Description.Message)a[ia]), false, false);
                    }
                }
            }
            {
                System.Web.Services.Description.PortTypeCollection a = (System.Web.Services.Description.PortTypeCollection)o.@PortTypes;
                if (a != null) {
                    for (int ia = 0; ia < a.Count; ia++) {
                        Write70_PortType(@"portType", @"http://schemas.xmlsoap.org/wsdl/", ((System.Web.Services.Description.PortType)a[ia]), false, false);
                    }
                }
            }
            {
                System.Web.Services.Description.BindingCollection a = (System.Web.Services.Description.BindingCollection)o.@Bindings;
                if (a != null) {
                    for (int ia = 0; ia < a.Count; ia++) {
                        Write76_Binding(@"binding", @"http://schemas.xmlsoap.org/wsdl/", ((System.Web.Services.Description.Binding)a[ia]), false, false);
                    }
                }
            }
            {
                System.Web.Services.Description.ServiceCollection a = (System.Web.Services.Description.ServiceCollection)o.@Services;
                if (a != null) {
                    for (int ia = 0; ia < a.Count; ia++) {
                        Write104_Service(@"service", @"http://schemas.xmlsoap.org/wsdl/", ((System.Web.Services.Description.Service)a[ia]), false, false);
                    }
                }
            }
            WriteEndElement(o);
        }

        void Write2_DocumentableItem(string n, string ns, System.Web.Services.Description.DocumentableItem o, bool isNullable, bool needType) {
            if ((object)o == null) {
                if (isNullable) WriteNullTagLiteral(n, ns);
                return;
            }
            if (!needType) {
                System.Type t = o.GetType();
                if (t == typeof(System.Web.Services.Description.DocumentableItem))
                    ;
                else if (t == typeof(System.Web.Services.Description.Port)) {
                    Write105_Port(n, ns, (System.Web.Services.Description.Port)o, isNullable, true);
                    return;
                }
                else if (t == typeof(System.Web.Services.Description.Service)) {
                    Write104_Service(n, ns, (System.Web.Services.Description.Service)o, isNullable, true);
                    return;
                }
                else if (t == typeof(System.Web.Services.Description.MessageBinding)) {
                    Write86_MessageBinding(n, ns, (System.Web.Services.Description.MessageBinding)o, isNullable, true);
                    return;
                }
                else if (t == typeof(System.Web.Services.Description.FaultBinding)) {
                    Write102_FaultBinding(n, ns, (System.Web.Services.Description.FaultBinding)o, isNullable, true);
                    return;
                }
                else if (t == typeof(System.Web.Services.Description.OutputBinding)) {
                    Write101_OutputBinding(n, ns, (System.Web.Services.Description.OutputBinding)o, isNullable, true);
                    return;
                }
                else if (t == typeof(System.Web.Services.Description.InputBinding)) {
                    Write85_InputBinding(n, ns, (System.Web.Services.Description.InputBinding)o, isNullable, true);
                    return;
                }
                else if (t == typeof(System.Web.Services.Description.OperationBinding)) {
                    Write82_OperationBinding(n, ns, (System.Web.Services.Description.OperationBinding)o, isNullable, true);
                    return;
                }
                else if (t == typeof(System.Web.Services.Description.Binding)) {
                    Write76_Binding(n, ns, (System.Web.Services.Description.Binding)o, isNullable, true);
                    return;
                }
                else if (t == typeof(System.Web.Services.Description.OperationMessage)) {
                    Write73_OperationMessage(n, ns, (System.Web.Services.Description.OperationMessage)o, isNullable, true);
                    return;
                }
                else if (t == typeof(System.Web.Services.Description.OperationFault)) {
                    Write75_OperationFault(n, ns, (System.Web.Services.Description.OperationFault)o, isNullable, true);
                    return;
                }
                else if (t == typeof(System.Web.Services.Description.OperationOutput)) {
                    Write74_OperationOutput(n, ns, (System.Web.Services.Description.OperationOutput)o, isNullable, true);
                    return;
                }
                else if (t == typeof(System.Web.Services.Description.OperationInput)) {
                    Write72_OperationInput(n, ns, (System.Web.Services.Description.OperationInput)o, isNullable, true);
                    return;
                }
                else if (t == typeof(System.Web.Services.Description.Operation)) {
                    Write71_Operation(n, ns, (System.Web.Services.Description.Operation)o, isNullable, true);
                    return;
                }
                else if (t == typeof(System.Web.Services.Description.PortType)) {
                    Write70_PortType(n, ns, (System.Web.Services.Description.PortType)o, isNullable, true);
                    return;
                }
                else if (t == typeof(System.Web.Services.Description.MessagePart)) {
                    Write69_MessagePart(n, ns, (System.Web.Services.Description.MessagePart)o, isNullable, true);
                    return;
                }
                else if (t == typeof(System.Web.Services.Description.Message)) {
                    Write68_Message(n, ns, (System.Web.Services.Description.Message)o, isNullable, true);
                    return;
                }
                else if (t == typeof(System.Web.Services.Description.Types)) {
                    Write5_Types(n, ns, (System.Web.Services.Description.Types)o, isNullable, true);
                    return;
                }
                else if (t == typeof(System.Web.Services.Description.Import)) {
                    Write4_Import(n, ns, (System.Web.Services.Description.Import)o, isNullable, true);
                    return;
                }
                else if (t == typeof(System.Web.Services.Description.ServiceDescription)) {
                    Write1_ServiceDescription(n, ns, (System.Web.Services.Description.ServiceDescription)o, isNullable, true);
                    return;
                }
                else {
                    throw CreateUnknownTypeException(o);
                }
            }
        }

        void Write3_Object(string n, string ns, System.Object o, bool isNullable, bool needType) {
            if ((object)o == null) {
                if (isNullable) WriteNullTagLiteral(n, ns);
                return;
            }
            if (!needType) {
                System.Type t = o.GetType();
                if (t == typeof(System.Object))
                    ;
                else if (t == typeof(System.Web.Services.Description.MimeTextMatch)) {
                    Write96_MimeTextMatch(n, ns, (System.Web.Services.Description.MimeTextMatch)o, isNullable, true);
                    return;
                }
                else if (t == typeof(System.Web.Services.Description.ServiceDescriptionFormatExtension)) {
                    Write95_ServiceDescriptionFormatExtension(n, ns, (System.Web.Services.Description.ServiceDescriptionFormatExtension)o, isNullable, true);
                    return;
                }
                else if (t == typeof(System.Web.Services.Description.MimeTextBinding)) {
                    Write94_MimeTextBinding(n, ns, (System.Web.Services.Description.MimeTextBinding)o, isNullable, true);
                    return;
                }
                else if (t == typeof(System.Web.Services.Description.ServiceDescriptionFormatExtension)) {
                    Write90_ServiceDescriptionFormatExtension(n, ns, (System.Web.Services.Description.ServiceDescriptionFormatExtension)o, isNullable, true);
                    return;
                }
                else if (t == typeof(System.Web.Services.Description.MimePart)) {
                    Write93_MimePart(n, ns, (System.Web.Services.Description.MimePart)o, isNullable, true);
                    return;
                }
                else if (t == typeof(System.Web.Services.Description.MimeMultipartRelatedBinding)) {
                    Write92_MimeMultipartRelatedBinding(n, ns, (System.Web.Services.Description.MimeMultipartRelatedBinding)o, isNullable, true);
                    return;
                }
                else if (t == typeof(System.Web.Services.Description.MimeXmlBinding)) {
                    Write91_MimeXmlBinding(n, ns, (System.Web.Services.Description.MimeXmlBinding)o, isNullable, true);
                    return;
                }
                else if (t == typeof(System.Web.Services.Description.MimeContentBinding)) {
                    Write89_MimeContentBinding(n, ns, (System.Web.Services.Description.MimeContentBinding)o, isNullable, true);
                    return;
                }
                else if (t == typeof(System.Web.Services.Description.ServiceDescriptionFormatExtension)) {
                    Write80_ServiceDescriptionFormatExtension(n, ns, (System.Web.Services.Description.ServiceDescriptionFormatExtension)o, isNullable, true);
                    return;
                }
                else if (t == typeof(System.Web.Services.Description.SoapAddressBinding)) {
                    Write107_SoapAddressBinding(n, ns, (System.Web.Services.Description.SoapAddressBinding)o, isNullable, true);
                    return;
                }
                else if (t == typeof(System.Web.Services.Description.SoapFaultBinding)) {
                    Write103_SoapFaultBinding(n, ns, (System.Web.Services.Description.SoapFaultBinding)o, isNullable, true);
                    return;
                }
                else if (t == typeof(System.Web.Services.Description.SoapHeaderFaultBinding)) {
                    Write100_SoapHeaderFaultBinding(n, ns, (System.Web.Services.Description.SoapHeaderFaultBinding)o, isNullable, true);
                    return;
                }
                else if (t == typeof(System.Web.Services.Description.SoapHeaderBinding)) {
                    Write99_SoapHeaderBinding(n, ns, (System.Web.Services.Description.SoapHeaderBinding)o, isNullable, true);
                    return;
                }
                else if (t == typeof(System.Web.Services.Description.SoapBodyBinding)) {
                    Write97_SoapBodyBinding(n, ns, (System.Web.Services.Description.SoapBodyBinding)o, isNullable, true);
                    return;
                }
                else if (t == typeof(System.Web.Services.Description.SoapOperationBinding)) {
                    Write84_SoapOperationBinding(n, ns, (System.Web.Services.Description.SoapOperationBinding)o, isNullable, true);
                    return;
                }
                else if (t == typeof(System.Web.Services.Description.SoapBinding)) {
                    Write79_SoapBinding(n, ns, (System.Web.Services.Description.SoapBinding)o, isNullable, true);
                    return;
                }
                else if (t == typeof(System.Web.Services.Description.ServiceDescriptionFormatExtension)) {
                    Write78_ServiceDescriptionFormatExtension(n, ns, (System.Web.Services.Description.ServiceDescriptionFormatExtension)o, isNullable, true);
                    return;
                }
                else if (t == typeof(System.Web.Services.Description.HttpAddressBinding)) {
                    Write106_HttpAddressBinding(n, ns, (System.Web.Services.Description.HttpAddressBinding)o, isNullable, true);
                    return;
                }
                else if (t == typeof(System.Web.Services.Description.HttpUrlReplacementBinding)) {
                    Write88_HttpUrlReplacementBinding(n, ns, (System.Web.Services.Description.HttpUrlReplacementBinding)o, isNullable, true);
                    return;
                }
                else if (t == typeof(System.Web.Services.Description.HttpUrlEncodedBinding)) {
                    Write87_HttpUrlEncodedBinding(n, ns, (System.Web.Services.Description.HttpUrlEncodedBinding)o, isNullable, true);
                    return;
                }
                else if (t == typeof(System.Web.Services.Description.HttpOperationBinding)) {
                    Write83_HttpOperationBinding(n, ns, (System.Web.Services.Description.HttpOperationBinding)o, isNullable, true);
                    return;
                }
                else if (t == typeof(System.Web.Services.Description.HttpBinding)) {
                    Write77_HttpBinding(n, ns, (System.Web.Services.Description.HttpBinding)o, isNullable, true);
                    return;
                }
                else if (t == typeof(System.Xml.Schema.XmlSchemaObject)) {
                    Write7_XmlSchemaObject(n, ns, (System.Xml.Schema.XmlSchemaObject)o, isNullable, true);
                    return;
                }
                else if (t == typeof(System.Xml.Schema.XmlSchemaDocumentation)) {
                    Write17_XmlSchemaDocumentation(n, ns, (System.Xml.Schema.XmlSchemaDocumentation)o, isNullable, true);
                    return;
                }
                else if (t == typeof(System.Xml.Schema.XmlSchemaAppInfo)) {
                    Write16_XmlSchemaAppInfo(n, ns, (System.Xml.Schema.XmlSchemaAppInfo)o, isNullable, true);
                    return;
                }
                else if (t == typeof(System.Xml.Schema.XmlSchemaAnnotation)) {
                    Write15_XmlSchemaAnnotation(n, ns, (System.Xml.Schema.XmlSchemaAnnotation)o, isNullable, true);
                    return;
                }
                else if (t == typeof(System.Xml.Schema.XmlSchemaAnnotated)) {
                    Write14_XmlSchemaAnnotated(n, ns, (System.Xml.Schema.XmlSchemaAnnotated)o, isNullable, true);
                    return;
                }
                else if (t == typeof(System.Xml.Schema.XmlSchemaNotation)) {
                    Write67_XmlSchemaNotation(n, ns, (System.Xml.Schema.XmlSchemaNotation)o, isNullable, true);
                    return;
                }
                else if (t == typeof(System.Xml.Schema.XmlSchemaGroup)) {
                    Write64_XmlSchemaGroup(n, ns, (System.Xml.Schema.XmlSchemaGroup)o, isNullable, true);
                    return;
                }
                else if (t == typeof(System.Xml.Schema.XmlSchemaXPath)) {
                    Write54_XmlSchemaXPath(n, ns, (System.Xml.Schema.XmlSchemaXPath)o, isNullable, true);
                    return;
                }
                else if (t == typeof(System.Xml.Schema.XmlSchemaIdentityConstraint)) {
                    Write53_XmlSchemaIdentityConstraint(n, ns, (System.Xml.Schema.XmlSchemaIdentityConstraint)o, isNullable, true);
                    return;
                }
                else if (t == typeof(System.Xml.Schema.XmlSchemaKey)) {
                    Write56_XmlSchemaKey(n, ns, (System.Xml.Schema.XmlSchemaKey)o, isNullable, true);
                    return;
                }
                else if (t == typeof(System.Xml.Schema.XmlSchemaUnique)) {
                    Write55_XmlSchemaUnique(n, ns, (System.Xml.Schema.XmlSchemaUnique)o, isNullable, true);
                    return;
                }
                else if (t == typeof(System.Xml.Schema.XmlSchemaKeyref)) {
                    Write52_XmlSchemaKeyref(n, ns, (System.Xml.Schema.XmlSchemaKeyref)o, isNullable, true);
                    return;
                }
                else if (t == typeof(System.Xml.Schema.XmlSchemaParticle)) {
                    Write49_XmlSchemaParticle(n, ns, (System.Xml.Schema.XmlSchemaParticle)o, isNullable, true);
                    return;
                }
                else if (t == typeof(System.Xml.Schema.XmlSchemaGroupRef)) {
                    Write57_XmlSchemaGroupRef(n, ns, (System.Xml.Schema.XmlSchemaGroupRef)o, isNullable, true);
                    return;
                }
                else if (t == typeof(System.Xml.Schema.XmlSchemaElement)) {
                    Write51_XmlSchemaElement(n, ns, (System.Xml.Schema.XmlSchemaElement)o, isNullable, true);
                    return;
                }
                else if (t == typeof(System.Xml.Schema.XmlSchemaAny)) {
                    Write50_XmlSchemaAny(n, ns, (System.Xml.Schema.XmlSchemaAny)o, isNullable, true);
                    return;
                }
                else if (t == typeof(System.Xml.Schema.XmlSchemaGroupBase)) {
                    Write48_XmlSchemaGroupBase(n, ns, (System.Xml.Schema.XmlSchemaGroupBase)o, isNullable, true);
                    return;
                }
                else if (t == typeof(System.Xml.Schema.XmlSchemaAll)) {
                    Write59_XmlSchemaAll(n, ns, (System.Xml.Schema.XmlSchemaAll)o, isNullable, true);
                    return;
                }
                else if (t == typeof(System.Xml.Schema.XmlSchemaChoice)) {
                    Write58_XmlSchemaChoice(n, ns, (System.Xml.Schema.XmlSchemaChoice)o, isNullable, true);
                    return;
                }
                else if (t == typeof(System.Xml.Schema.XmlSchemaSequence)) {
                    Write47_XmlSchemaSequence(n, ns, (System.Xml.Schema.XmlSchemaSequence)o, isNullable, true);
                    return;
                }
                else if (t == typeof(System.Xml.Schema.XmlSchemaContent)) {
                    Write46_XmlSchemaContent(n, ns, (System.Xml.Schema.XmlSchemaContent)o, isNullable, true);
                    return;
                }
                else if (t == typeof(System.Xml.Schema.XmlSchemaSimpleContentExtension)) {
                    Write63_XmlSchemaSimpleContentExtension(n, ns, (System.Xml.Schema.XmlSchemaSimpleContentExtension)o, isNullable, true);
                    return;
                }
                else if (t == typeof(System.Xml.Schema.XmlSchemaSimpleContentRestriction)) {
                    Write62_XmlSchemaSimpleContentRestriction(n, ns, (System.Xml.Schema.XmlSchemaSimpleContentRestriction)o, isNullable, true);
                    return;
                }
                else if (t == typeof(System.Xml.Schema.XmlSchemaComplexContentRestriction)) {
                    Write60_XmlSchemaComplexContentRestriction(n, ns, (System.Xml.Schema.XmlSchemaComplexContentRestriction)o, isNullable, true);
                    return;
                }
                else if (t == typeof(System.Xml.Schema.XmlSchemaComplexContentExtension)) {
                    Write45_XmlSchemaComplexContentExtension(n, ns, (System.Xml.Schema.XmlSchemaComplexContentExtension)o, isNullable, true);
                    return;
                }
                else if (t == typeof(System.Xml.Schema.XmlSchemaContentModel)) {
                    Write44_XmlSchemaContentModel(n, ns, (System.Xml.Schema.XmlSchemaContentModel)o, isNullable, true);
                    return;
                }
                else if (t == typeof(System.Xml.Schema.XmlSchemaSimpleContent)) {
                    Write61_XmlSchemaSimpleContent(n, ns, (System.Xml.Schema.XmlSchemaSimpleContent)o, isNullable, true);
                    return;
                }
                else if (t == typeof(System.Xml.Schema.XmlSchemaComplexContent)) {
                    Write43_XmlSchemaComplexContent(n, ns, (System.Xml.Schema.XmlSchemaComplexContent)o, isNullable, true);
                    return;
                }
                else if (t == typeof(System.Xml.Schema.XmlSchemaAnyAttribute)) {
                    Write40_XmlSchemaAnyAttribute(n, ns, (System.Xml.Schema.XmlSchemaAnyAttribute)o, isNullable, true);
                    return;
                }
                else if (t == typeof(System.Xml.Schema.XmlSchemaAttributeGroupRef)) {
                    Write39_XmlSchemaAttributeGroupRef(n, ns, (System.Xml.Schema.XmlSchemaAttributeGroupRef)o, isNullable, true);
                    return;
                }
                else if (t == typeof(System.Xml.Schema.XmlSchemaAttribute)) {
                    Write37_XmlSchemaAttribute(n, ns, (System.Xml.Schema.XmlSchemaAttribute)o, isNullable, true);
                    return;
                }
                else if (t == typeof(System.Xml.Schema.XmlSchemaAttributeGroup)) {
                    Write36_XmlSchemaAttributeGroup(n, ns, (System.Xml.Schema.XmlSchemaAttributeGroup)o, isNullable, true);
                    return;
                }
                else if (t == typeof(System.Xml.Schema.XmlSchemaFacet)) {
                    Write23_XmlSchemaFacet(n, ns, (System.Xml.Schema.XmlSchemaFacet)o, isNullable, true);
                    return;
                }
                else if (t == typeof(System.Xml.Schema.XmlSchemaMinExclusiveFacet)) {
                    Write32_XmlSchemaMinExclusiveFacet(n, ns, (System.Xml.Schema.XmlSchemaMinExclusiveFacet)o, isNullable, true);
                    return;
                }
                else if (t == typeof(System.Xml.Schema.XmlSchemaMinInclusiveFacet)) {
                    Write31_XmlSchemaMinInclusiveFacet(n, ns, (System.Xml.Schema.XmlSchemaMinInclusiveFacet)o, isNullable, true);
                    return;
                }
                else if (t == typeof(System.Xml.Schema.XmlSchemaMaxExclusiveFacet)) {
                    Write30_XmlSchemaMaxExclusiveFacet(n, ns, (System.Xml.Schema.XmlSchemaMaxExclusiveFacet)o, isNullable, true);
                    return;
                }
                else if (t == typeof(System.Xml.Schema.XmlSchemaMaxInclusiveFacet)) {
                    Write29_XmlSchemaMaxInclusiveFacet(n, ns, (System.Xml.Schema.XmlSchemaMaxInclusiveFacet)o, isNullable, true);
                    return;
                }
                else if (t == typeof(System.Xml.Schema.XmlSchemaEnumerationFacet)) {
                    Write28_XmlSchemaEnumerationFacet(n, ns, (System.Xml.Schema.XmlSchemaEnumerationFacet)o, isNullable, true);
                    return;
                }
                else if (t == typeof(System.Xml.Schema.XmlSchemaPatternFacet)) {
                    Write27_XmlSchemaPatternFacet(n, ns, (System.Xml.Schema.XmlSchemaPatternFacet)o, isNullable, true);
                    return;
                }
                else if (t == typeof(System.Xml.Schema.XmlSchemaWhiteSpaceFacet)) {
                    Write25_XmlSchemaWhiteSpaceFacet(n, ns, (System.Xml.Schema.XmlSchemaWhiteSpaceFacet)o, isNullable, true);
                    return;
                }
                else if (t == typeof(System.Xml.Schema.XmlSchemaNumericFacet)) {
                    Write22_XmlSchemaNumericFacet(n, ns, (System.Xml.Schema.XmlSchemaNumericFacet)o, isNullable, true);
                    return;
                }
                else if (t == typeof(System.Xml.Schema.XmlSchemaFractionDigitsFacet)) {
                    Write34_XmlSchemaFractionDigitsFacet(n, ns, (System.Xml.Schema.XmlSchemaFractionDigitsFacet)o, isNullable, true);
                    return;
                }
                else if (t == typeof(System.Xml.Schema.XmlSchemaTotalDigitsFacet)) {
                    Write33_XmlSchemaTotalDigitsFacet(n, ns, (System.Xml.Schema.XmlSchemaTotalDigitsFacet)o, isNullable, true);
                    return;
                }
                else if (t == typeof(System.Xml.Schema.XmlSchemaMaxLengthFacet)) {
                    Write26_XmlSchemaMaxLengthFacet(n, ns, (System.Xml.Schema.XmlSchemaMaxLengthFacet)o, isNullable, true);
                    return;
                }
                else if (t == typeof(System.Xml.Schema.XmlSchemaLengthFacet)) {
                    Write24_XmlSchemaLengthFacet(n, ns, (System.Xml.Schema.XmlSchemaLengthFacet)o, isNullable, true);
                    return;
                }
                else if (t == typeof(System.Xml.Schema.XmlSchemaMinLengthFacet)) {
                    Write21_XmlSchemaMinLengthFacet(n, ns, (System.Xml.Schema.XmlSchemaMinLengthFacet)o, isNullable, true);
                    return;
                }
                else if (t == typeof(System.Xml.Schema.XmlSchemaSimpleTypeContent)) {
                    Write19_XmlSchemaSimpleTypeContent(n, ns, (System.Xml.Schema.XmlSchemaSimpleTypeContent)o, isNullable, true);
                    return;
                }
                else if (t == typeof(System.Xml.Schema.XmlSchemaSimpleTypeUnion)) {
                    Write35_XmlSchemaSimpleTypeUnion(n, ns, (System.Xml.Schema.XmlSchemaSimpleTypeUnion)o, isNullable, true);
                    return;
                }
                else if (t == typeof(System.Xml.Schema.XmlSchemaSimpleTypeRestriction)) {
                    Write20_XmlSchemaSimpleTypeRestriction(n, ns, (System.Xml.Schema.XmlSchemaSimpleTypeRestriction)o, isNullable, true);
                    return;
                }
                else if (t == typeof(System.Xml.Schema.XmlSchemaSimpleTypeList)) {
                    Write18_XmlSchemaSimpleTypeList(n, ns, (System.Xml.Schema.XmlSchemaSimpleTypeList)o, isNullable, true);
                    return;
                }
                else if (t == typeof(System.Xml.Schema.XmlSchemaType)) {
                    Write13_XmlSchemaType(n, ns, (System.Xml.Schema.XmlSchemaType)o, isNullable, true);
                    return;
                }
                else if (t == typeof(System.Xml.Schema.XmlSchemaComplexType)) {
                    Write42_XmlSchemaComplexType(n, ns, (System.Xml.Schema.XmlSchemaComplexType)o, isNullable, true);
                    return;
                }
                else if (t == typeof(System.Xml.Schema.XmlSchemaSimpleType)) {
                    Write12_XmlSchemaSimpleType(n, ns, (System.Xml.Schema.XmlSchemaSimpleType)o, isNullable, true);
                    return;
                }
                else if (t == typeof(System.Xml.Schema.XmlSchemaExternal)) {
                    Write11_XmlSchemaExternal(n, ns, (System.Xml.Schema.XmlSchemaExternal)o, isNullable, true);
                    return;
                }
                else if (t == typeof(System.Xml.Schema.XmlSchemaInclude)) {
                    Write66_XmlSchemaInclude(n, ns, (System.Xml.Schema.XmlSchemaInclude)o, isNullable, true);
                    return;
                }
                else if (t == typeof(System.Xml.Schema.XmlSchemaImport)) {
                    Write65_XmlSchemaImport(n, ns, (System.Xml.Schema.XmlSchemaImport)o, isNullable, true);
                    return;
                }
                else if (t == typeof(System.Xml.Schema.XmlSchemaRedefine)) {
                    Write10_XmlSchemaRedefine(n, ns, (System.Xml.Schema.XmlSchemaRedefine)o, isNullable, true);
                    return;
                }
                else if (t == typeof(System.Xml.Schema.XmlSchema)) {
                    Write6_XmlSchema(n, ns, (System.Xml.Schema.XmlSchema)o, isNullable, true);
                    return;
                }
                else if (t == typeof(System.Web.Services.Description.DocumentableItem)) {
                    Write2_DocumentableItem(n, ns, (System.Web.Services.Description.DocumentableItem)o, isNullable, true);
                    return;
                }
                else if (t == typeof(System.Web.Services.Description.Port)) {
                    Write105_Port(n, ns, (System.Web.Services.Description.Port)o, isNullable, true);
                    return;
                }
                else if (t == typeof(System.Web.Services.Description.Service)) {
                    Write104_Service(n, ns, (System.Web.Services.Description.Service)o, isNullable, true);
                    return;
                }
                else if (t == typeof(System.Web.Services.Description.MessageBinding)) {
                    Write86_MessageBinding(n, ns, (System.Web.Services.Description.MessageBinding)o, isNullable, true);
                    return;
                }
                else if (t == typeof(System.Web.Services.Description.FaultBinding)) {
                    Write102_FaultBinding(n, ns, (System.Web.Services.Description.FaultBinding)o, isNullable, true);
                    return;
                }
                else if (t == typeof(System.Web.Services.Description.OutputBinding)) {
                    Write101_OutputBinding(n, ns, (System.Web.Services.Description.OutputBinding)o, isNullable, true);
                    return;
                }
                else if (t == typeof(System.Web.Services.Description.InputBinding)) {
                    Write85_InputBinding(n, ns, (System.Web.Services.Description.InputBinding)o, isNullable, true);
                    return;
                }
                else if (t == typeof(System.Web.Services.Description.OperationBinding)) {
                    Write82_OperationBinding(n, ns, (System.Web.Services.Description.OperationBinding)o, isNullable, true);
                    return;
                }
                else if (t == typeof(System.Web.Services.Description.Binding)) {
                    Write76_Binding(n, ns, (System.Web.Services.Description.Binding)o, isNullable, true);
                    return;
                }
                else if (t == typeof(System.Web.Services.Description.OperationMessage)) {
                    Write73_OperationMessage(n, ns, (System.Web.Services.Description.OperationMessage)o, isNullable, true);
                    return;
                }
                else if (t == typeof(System.Web.Services.Description.OperationFault)) {
                    Write75_OperationFault(n, ns, (System.Web.Services.Description.OperationFault)o, isNullable, true);
                    return;
                }
                else if (t == typeof(System.Web.Services.Description.OperationOutput)) {
                    Write74_OperationOutput(n, ns, (System.Web.Services.Description.OperationOutput)o, isNullable, true);
                    return;
                }
                else if (t == typeof(System.Web.Services.Description.OperationInput)) {
                    Write72_OperationInput(n, ns, (System.Web.Services.Description.OperationInput)o, isNullable, true);
                    return;
                }
                else if (t == typeof(System.Web.Services.Description.Operation)) {
                    Write71_Operation(n, ns, (System.Web.Services.Description.Operation)o, isNullable, true);
                    return;
                }
                else if (t == typeof(System.Web.Services.Description.PortType)) {
                    Write70_PortType(n, ns, (System.Web.Services.Description.PortType)o, isNullable, true);
                    return;
                }
                else if (t == typeof(System.Web.Services.Description.MessagePart)) {
                    Write69_MessagePart(n, ns, (System.Web.Services.Description.MessagePart)o, isNullable, true);
                    return;
                }
                else if (t == typeof(System.Web.Services.Description.Message)) {
                    Write68_Message(n, ns, (System.Web.Services.Description.Message)o, isNullable, true);
                    return;
                }
                else if (t == typeof(System.Web.Services.Description.Types)) {
                    Write5_Types(n, ns, (System.Web.Services.Description.Types)o, isNullable, true);
                    return;
                }
                else if (t == typeof(System.Web.Services.Description.Import)) {
                    Write4_Import(n, ns, (System.Web.Services.Description.Import)o, isNullable, true);
                    return;
                }
                else if (t == typeof(System.Web.Services.Description.ServiceDescription)) {
                    Write1_ServiceDescription(n, ns, (System.Web.Services.Description.ServiceDescription)o, isNullable, true);
                    return;
                }
                else if (t == typeof(System.Xml.Schema.XmlSchemaForm)) {
                    Writer.WriteStartElement(n, ns);
                    WriteXsiType(@"XmlSchemaForm", @"http://www.w3.org/2001/XMLSchema");
                    Writer.WriteString(Write8_XmlSchemaForm((System.Xml.Schema.XmlSchemaForm)o));
                    Writer.WriteEndElement();
                    return;
                }
                else if (t == typeof(System.Xml.Schema.XmlSchemaDerivationMethod)) {
                    Writer.WriteStartElement(n, ns);
                    WriteXsiType(@"XmlSchemaDerivationMethod", @"http://www.w3.org/2001/XMLSchema");
                    Writer.WriteString(Write9_XmlSchemaDerivationMethod((System.Xml.Schema.XmlSchemaDerivationMethod)o));
                    Writer.WriteEndElement();
                    return;
                }
                else if (t == typeof(System.Xml.Schema.XmlSchemaUse)) {
                    Writer.WriteStartElement(n, ns);
                    WriteXsiType(@"XmlSchemaUse", @"http://www.w3.org/2001/XMLSchema");
                    Writer.WriteString(Write38_XmlSchemaUse((System.Xml.Schema.XmlSchemaUse)o));
                    Writer.WriteEndElement();
                    return;
                }
                else if (t == typeof(System.Xml.Schema.XmlSchemaContentProcessing)) {
                    Writer.WriteStartElement(n, ns);
                    WriteXsiType(@"XmlSchemaContentProcessing", @"http://www.w3.org/2001/XMLSchema");
                    Writer.WriteString(Write41_XmlSchemaContentProcessing((System.Xml.Schema.XmlSchemaContentProcessing)o));
                    Writer.WriteEndElement();
                    return;
                }
                else if (t == typeof(System.Web.Services.Description.SoapBindingStyle)) {
                    Writer.WriteStartElement(n, ns);
                    WriteXsiType(@"SoapBindingStyle", @"http://schemas.xmlsoap.org/wsdl/soap/");
                    Writer.WriteString(Write81_SoapBindingStyle((System.Web.Services.Description.SoapBindingStyle)o));
                    Writer.WriteEndElement();
                    return;
                }
                else if (t == typeof(System.Web.Services.Description.SoapBindingUse)) {
                    Writer.WriteStartElement(n, ns);
                    WriteXsiType(@"SoapBindingUse", @"http://schemas.xmlsoap.org/wsdl/soap/");
                    Writer.WriteString(Write98_SoapBindingUse((System.Web.Services.Description.SoapBindingUse)o));
                    Writer.WriteEndElement();
                    return;
                }
                else {
                    WriteTypedPrimitive(n, ns, o, true);
                    return;
                }
            }
            WriteStartElement(n, ns, o);
            WriteEndElement(o);
        }

        void Write4_Import(string n, string ns, System.Web.Services.Description.Import o, bool isNullable, bool needType) {
            if ((object)o == null) {
                if (isNullable) WriteNullTagLiteral(n, ns);
                return;
            }
            if (!needType) {
                System.Type t = o.GetType();
                if (t == typeof(System.Web.Services.Description.Import))
                    ;
                else {
                    throw CreateUnknownTypeException(o);
                }
            }
            WriteStartElement(n, ns, o);
            if (needType) WriteXsiType(@"Import", @"http://schemas.xmlsoap.org/wsdl/");
            WriteAttribute(@"namespace", @"", (System.String)o.@Namespace);
            WriteAttribute(@"location", @"", (System.String)o.@Location);
            if (((System.String)o.@Documentation) != @"") {
                WriteElementString(@"documentation", @"http://schemas.xmlsoap.org/wsdl/", ((System.String)o.@Documentation));
            }
            WriteEndElement(o);
        }

        void Write5_Types(string n, string ns, System.Web.Services.Description.Types o, bool isNullable, bool needType) {
            if ((object)o == null) {
                if (isNullable) WriteNullTagLiteral(n, ns);
                return;
            }
            if (!needType) {
                System.Type t = o.GetType();
                if (t == typeof(System.Web.Services.Description.Types))
                    ;
                else {
                    throw CreateUnknownTypeException(o);
                }
            }
            WriteStartElement(n, ns, o);
            if (needType) WriteXsiType(@"Types", @"http://schemas.xmlsoap.org/wsdl/");
            if (((System.String)o.@Documentation) != @"") {
                WriteElementString(@"documentation", @"http://schemas.xmlsoap.org/wsdl/", ((System.String)o.@Documentation));
            }
            {
                System.Xml.Serialization.XmlSchemas a = (System.Xml.Serialization.XmlSchemas)o.@Schemas;
                if (a != null) {
                    for (int ia = 0; ia < a.Count; ia++) {
                        Write6_XmlSchema(@"schema", @"http://www.w3.org/2001/XMLSchema", ((System.Xml.Schema.XmlSchema)a[ia]), false, false);
                    }
                }
            }
            WriteEndElement(o);
        }

        void Write6_XmlSchema(string n, string ns, System.Xml.Schema.XmlSchema o, bool isNullable, bool needType) {
            if ((object)o == null) {
                if (isNullable) WriteNullTagLiteral(n, ns);
                return;
            }
            if (!needType) {
                System.Type t = o.GetType();
                if (t == typeof(System.Xml.Schema.XmlSchema))
                    ;
                else {
                    throw CreateUnknownTypeException(o);
                }
            }
            WriteStartElement(n, ns, o);
            if (needType) WriteXsiType(@"XmlSchema", @"http://www.w3.org/2001/XMLSchema");
            WriteNamespaceDeclarations(o.@Namespaces);
            if ((System.Xml.Schema.XmlSchemaForm)o.@AttributeFormDefault != System.Xml.Schema.XmlSchemaForm.@None) {
                WriteAttribute(@"attributeFormDefault", @"", Write8_XmlSchemaForm((System.Xml.Schema.XmlSchemaForm)o.@AttributeFormDefault));
            }
            if ((System.Xml.Schema.XmlSchemaDerivationMethod)o.@BlockDefault != (System.Xml.Schema.XmlSchemaDerivationMethod.@None)) {
                WriteAttribute(@"blockDefault", @"", Write9_XmlSchemaDerivationMethod((System.Xml.Schema.XmlSchemaDerivationMethod)o.@BlockDefault));
            }
            if ((System.Xml.Schema.XmlSchemaDerivationMethod)o.@FinalDefault != (System.Xml.Schema.XmlSchemaDerivationMethod.@None)) {
                WriteAttribute(@"finalDefault", @"", Write9_XmlSchemaDerivationMethod((System.Xml.Schema.XmlSchemaDerivationMethod)o.@FinalDefault));
            }
            if ((System.Xml.Schema.XmlSchemaForm)o.@ElementFormDefault != System.Xml.Schema.XmlSchemaForm.@None) {
                WriteAttribute(@"elementFormDefault", @"", Write8_XmlSchemaForm((System.Xml.Schema.XmlSchemaForm)o.@ElementFormDefault));
            }
            WriteAttribute(@"targetNamespace", @"", (System.String)o.@TargetNamespace);
            WriteAttribute(@"version", @"", (System.String)o.@Version);
            WriteAttribute(@"id", @"", (System.String)o.@Id);
            {
                System.Xml.XmlAttribute[] a = (System.Xml.XmlAttribute[])o.@UnhandledAttributes;
                if (a != null) {
                    for (int i = 0; i < a.Length; i++) {
                        System.Xml.XmlAttribute ai = (System.Xml.XmlAttribute)a[i];
                        WriteXmlAttribute(ai, o);
                    }
                }
            }
            {
                System.Xml.Schema.XmlSchemaObjectCollection a = (System.Xml.Schema.XmlSchemaObjectCollection)o.@Includes;
                if (a != null) {
                    for (int ia = 0; ia < a.Count; ia++) {
                        System.Xml.Schema.XmlSchemaObject ai = a[ia];
                        {
                            if (ai is System.Xml.Schema.XmlSchemaImport) {
                                Write65_XmlSchemaImport(@"import", @"http://www.w3.org/2001/XMLSchema", ((System.Xml.Schema.XmlSchemaImport)ai), false, false);
                            }
                            else if (ai is System.Xml.Schema.XmlSchemaRedefine) {
                                Write10_XmlSchemaRedefine(@"redefine", @"http://www.w3.org/2001/XMLSchema", ((System.Xml.Schema.XmlSchemaRedefine)ai), false, false);
                            }
                            else if (ai is System.Xml.Schema.XmlSchemaInclude) {
                                Write66_XmlSchemaInclude(@"include", @"http://www.w3.org/2001/XMLSchema", ((System.Xml.Schema.XmlSchemaInclude)ai), false, false);
                            }
                            else {
                                if (ai != null) {
                                    throw CreateUnknownTypeException(ai);
                                }
                            }
                        }
                    }
                }
            }
            {
                System.Xml.Schema.XmlSchemaObjectCollection a = (System.Xml.Schema.XmlSchemaObjectCollection)o.@Items;
                if (a != null) {
                    for (int ia = 0; ia < a.Count; ia++) {
                        System.Xml.Schema.XmlSchemaObject ai = a[ia];
                        {
                            if (ai is System.Xml.Schema.XmlSchemaSimpleType) {
                                Write12_XmlSchemaSimpleType(@"simpleType", @"http://www.w3.org/2001/XMLSchema", ((System.Xml.Schema.XmlSchemaSimpleType)ai), false, false);
                            }
                            else if (ai is System.Xml.Schema.XmlSchemaNotation) {
                                Write67_XmlSchemaNotation(@"notation", @"http://www.w3.org/2001/XMLSchema", ((System.Xml.Schema.XmlSchemaNotation)ai), false, false);
                            }
                            else if (ai is System.Xml.Schema.XmlSchemaAttribute) {
                                Write37_XmlSchemaAttribute(@"attribute", @"http://www.w3.org/2001/XMLSchema", ((System.Xml.Schema.XmlSchemaAttribute)ai), false, false);
                            }
                            else if (ai is System.Xml.Schema.XmlSchemaElement) {
                                Write51_XmlSchemaElement(@"element", @"http://www.w3.org/2001/XMLSchema", ((System.Xml.Schema.XmlSchemaElement)ai), false, false);
                            }
                            else if (ai is System.Xml.Schema.XmlSchemaGroup) {
                                Write64_XmlSchemaGroup(@"group", @"http://www.w3.org/2001/XMLSchema", ((System.Xml.Schema.XmlSchemaGroup)ai), false, false);
                            }
                            else if (ai is System.Xml.Schema.XmlSchemaAttributeGroup) {
                                Write36_XmlSchemaAttributeGroup(@"attributeGroup", @"http://www.w3.org/2001/XMLSchema", ((System.Xml.Schema.XmlSchemaAttributeGroup)ai), false, false);
                            }
                            else if (ai is System.Xml.Schema.XmlSchemaComplexType) {
                                Write42_XmlSchemaComplexType(@"complexType", @"http://www.w3.org/2001/XMLSchema", ((System.Xml.Schema.XmlSchemaComplexType)ai), false, false);
                            }
                            else if (ai is System.Xml.Schema.XmlSchemaAnnotation) {
                                Write15_XmlSchemaAnnotation(@"annotation", @"http://www.w3.org/2001/XMLSchema", ((System.Xml.Schema.XmlSchemaAnnotation)ai), false, false);
                            }
                            else {
                                if (ai != null) {
                                    throw CreateUnknownTypeException(ai);
                                }
                            }
                        }
                    }
                }
            }
            WriteEndElement(o);
        }

        void Write7_XmlSchemaObject(string n, string ns, System.Xml.Schema.XmlSchemaObject o, bool isNullable, bool needType) {
            if ((object)o == null) {
                if (isNullable) WriteNullTagLiteral(n, ns);
                return;
            }
            if (!needType) {
                System.Type t = o.GetType();
                if (t == typeof(System.Xml.Schema.XmlSchemaObject))
                    ;
                else if (t == typeof(System.Xml.Schema.XmlSchemaDocumentation)) {
                    Write17_XmlSchemaDocumentation(n, ns, (System.Xml.Schema.XmlSchemaDocumentation)o, isNullable, true);
                    return;
                }
                else if (t == typeof(System.Xml.Schema.XmlSchemaAppInfo)) {
                    Write16_XmlSchemaAppInfo(n, ns, (System.Xml.Schema.XmlSchemaAppInfo)o, isNullable, true);
                    return;
                }
                else if (t == typeof(System.Xml.Schema.XmlSchemaAnnotation)) {
                    Write15_XmlSchemaAnnotation(n, ns, (System.Xml.Schema.XmlSchemaAnnotation)o, isNullable, true);
                    return;
                }
                else if (t == typeof(System.Xml.Schema.XmlSchemaAnnotated)) {
                    Write14_XmlSchemaAnnotated(n, ns, (System.Xml.Schema.XmlSchemaAnnotated)o, isNullable, true);
                    return;
                }
                else if (t == typeof(System.Xml.Schema.XmlSchemaNotation)) {
                    Write67_XmlSchemaNotation(n, ns, (System.Xml.Schema.XmlSchemaNotation)o, isNullable, true);
                    return;
                }
                else if (t == typeof(System.Xml.Schema.XmlSchemaGroup)) {
                    Write64_XmlSchemaGroup(n, ns, (System.Xml.Schema.XmlSchemaGroup)o, isNullable, true);
                    return;
                }
                else if (t == typeof(System.Xml.Schema.XmlSchemaXPath)) {
                    Write54_XmlSchemaXPath(n, ns, (System.Xml.Schema.XmlSchemaXPath)o, isNullable, true);
                    return;
                }
                else if (t == typeof(System.Xml.Schema.XmlSchemaIdentityConstraint)) {
                    Write53_XmlSchemaIdentityConstraint(n, ns, (System.Xml.Schema.XmlSchemaIdentityConstraint)o, isNullable, true);
                    return;
                }
                else if (t == typeof(System.Xml.Schema.XmlSchemaKey)) {
                    Write56_XmlSchemaKey(n, ns, (System.Xml.Schema.XmlSchemaKey)o, isNullable, true);
                    return;
                }
                else if (t == typeof(System.Xml.Schema.XmlSchemaUnique)) {
                    Write55_XmlSchemaUnique(n, ns, (System.Xml.Schema.XmlSchemaUnique)o, isNullable, true);
                    return;
                }
                else if (t == typeof(System.Xml.Schema.XmlSchemaKeyref)) {
                    Write52_XmlSchemaKeyref(n, ns, (System.Xml.Schema.XmlSchemaKeyref)o, isNullable, true);
                    return;
                }
                else if (t == typeof(System.Xml.Schema.XmlSchemaParticle)) {
                    Write49_XmlSchemaParticle(n, ns, (System.Xml.Schema.XmlSchemaParticle)o, isNullable, true);
                    return;
                }
                else if (t == typeof(System.Xml.Schema.XmlSchemaGroupRef)) {
                    Write57_XmlSchemaGroupRef(n, ns, (System.Xml.Schema.XmlSchemaGroupRef)o, isNullable, true);
                    return;
                }
                else if (t == typeof(System.Xml.Schema.XmlSchemaElement)) {
                    Write51_XmlSchemaElement(n, ns, (System.Xml.Schema.XmlSchemaElement)o, isNullable, true);
                    return;
                }
                else if (t == typeof(System.Xml.Schema.XmlSchemaAny)) {
                    Write50_XmlSchemaAny(n, ns, (System.Xml.Schema.XmlSchemaAny)o, isNullable, true);
                    return;
                }
                else if (t == typeof(System.Xml.Schema.XmlSchemaGroupBase)) {
                    Write48_XmlSchemaGroupBase(n, ns, (System.Xml.Schema.XmlSchemaGroupBase)o, isNullable, true);
                    return;
                }
                else if (t == typeof(System.Xml.Schema.XmlSchemaAll)) {
                    Write59_XmlSchemaAll(n, ns, (System.Xml.Schema.XmlSchemaAll)o, isNullable, true);
                    return;
                }
                else if (t == typeof(System.Xml.Schema.XmlSchemaChoice)) {
                    Write58_XmlSchemaChoice(n, ns, (System.Xml.Schema.XmlSchemaChoice)o, isNullable, true);
                    return;
                }
                else if (t == typeof(System.Xml.Schema.XmlSchemaSequence)) {
                    Write47_XmlSchemaSequence(n, ns, (System.Xml.Schema.XmlSchemaSequence)o, isNullable, true);
                    return;
                }
                else if (t == typeof(System.Xml.Schema.XmlSchemaContent)) {
                    Write46_XmlSchemaContent(n, ns, (System.Xml.Schema.XmlSchemaContent)o, isNullable, true);
                    return;
                }
                else if (t == typeof(System.Xml.Schema.XmlSchemaSimpleContentExtension)) {
                    Write63_XmlSchemaSimpleContentExtension(n, ns, (System.Xml.Schema.XmlSchemaSimpleContentExtension)o, isNullable, true);
                    return;
                }
                else if (t == typeof(System.Xml.Schema.XmlSchemaSimpleContentRestriction)) {
                    Write62_XmlSchemaSimpleContentRestriction(n, ns, (System.Xml.Schema.XmlSchemaSimpleContentRestriction)o, isNullable, true);
                    return;
                }
                else if (t == typeof(System.Xml.Schema.XmlSchemaComplexContentRestriction)) {
                    Write60_XmlSchemaComplexContentRestriction(n, ns, (System.Xml.Schema.XmlSchemaComplexContentRestriction)o, isNullable, true);
                    return;
                }
                else if (t == typeof(System.Xml.Schema.XmlSchemaComplexContentExtension)) {
                    Write45_XmlSchemaComplexContentExtension(n, ns, (System.Xml.Schema.XmlSchemaComplexContentExtension)o, isNullable, true);
                    return;
                }
                else if (t == typeof(System.Xml.Schema.XmlSchemaContentModel)) {
                    Write44_XmlSchemaContentModel(n, ns, (System.Xml.Schema.XmlSchemaContentModel)o, isNullable, true);
                    return;
                }
                else if (t == typeof(System.Xml.Schema.XmlSchemaSimpleContent)) {
                    Write61_XmlSchemaSimpleContent(n, ns, (System.Xml.Schema.XmlSchemaSimpleContent)o, isNullable, true);
                    return;
                }
                else if (t == typeof(System.Xml.Schema.XmlSchemaComplexContent)) {
                    Write43_XmlSchemaComplexContent(n, ns, (System.Xml.Schema.XmlSchemaComplexContent)o, isNullable, true);
                    return;
                }
                else if (t == typeof(System.Xml.Schema.XmlSchemaAnyAttribute)) {
                    Write40_XmlSchemaAnyAttribute(n, ns, (System.Xml.Schema.XmlSchemaAnyAttribute)o, isNullable, true);
                    return;
                }
                else if (t == typeof(System.Xml.Schema.XmlSchemaAttributeGroupRef)) {
                    Write39_XmlSchemaAttributeGroupRef(n, ns, (System.Xml.Schema.XmlSchemaAttributeGroupRef)o, isNullable, true);
                    return;
                }
                else if (t == typeof(System.Xml.Schema.XmlSchemaAttribute)) {
                    Write37_XmlSchemaAttribute(n, ns, (System.Xml.Schema.XmlSchemaAttribute)o, isNullable, true);
                    return;
                }
                else if (t == typeof(System.Xml.Schema.XmlSchemaAttributeGroup)) {
                    Write36_XmlSchemaAttributeGroup(n, ns, (System.Xml.Schema.XmlSchemaAttributeGroup)o, isNullable, true);
                    return;
                }
                else if (t == typeof(System.Xml.Schema.XmlSchemaFacet)) {
                    Write23_XmlSchemaFacet(n, ns, (System.Xml.Schema.XmlSchemaFacet)o, isNullable, true);
                    return;
                }
                else if (t == typeof(System.Xml.Schema.XmlSchemaMinExclusiveFacet)) {
                    Write32_XmlSchemaMinExclusiveFacet(n, ns, (System.Xml.Schema.XmlSchemaMinExclusiveFacet)o, isNullable, true);
                    return;
                }
                else if (t == typeof(System.Xml.Schema.XmlSchemaMinInclusiveFacet)) {
                    Write31_XmlSchemaMinInclusiveFacet(n, ns, (System.Xml.Schema.XmlSchemaMinInclusiveFacet)o, isNullable, true);
                    return;
                }
                else if (t == typeof(System.Xml.Schema.XmlSchemaMaxExclusiveFacet)) {
                    Write30_XmlSchemaMaxExclusiveFacet(n, ns, (System.Xml.Schema.XmlSchemaMaxExclusiveFacet)o, isNullable, true);
                    return;
                }
                else if (t == typeof(System.Xml.Schema.XmlSchemaMaxInclusiveFacet)) {
                    Write29_XmlSchemaMaxInclusiveFacet(n, ns, (System.Xml.Schema.XmlSchemaMaxInclusiveFacet)o, isNullable, true);
                    return;
                }
                else if (t == typeof(System.Xml.Schema.XmlSchemaEnumerationFacet)) {
                    Write28_XmlSchemaEnumerationFacet(n, ns, (System.Xml.Schema.XmlSchemaEnumerationFacet)o, isNullable, true);
                    return;
                }
                else if (t == typeof(System.Xml.Schema.XmlSchemaPatternFacet)) {
                    Write27_XmlSchemaPatternFacet(n, ns, (System.Xml.Schema.XmlSchemaPatternFacet)o, isNullable, true);
                    return;
                }
                else if (t == typeof(System.Xml.Schema.XmlSchemaWhiteSpaceFacet)) {
                    Write25_XmlSchemaWhiteSpaceFacet(n, ns, (System.Xml.Schema.XmlSchemaWhiteSpaceFacet)o, isNullable, true);
                    return;
                }
                else if (t == typeof(System.Xml.Schema.XmlSchemaNumericFacet)) {
                    Write22_XmlSchemaNumericFacet(n, ns, (System.Xml.Schema.XmlSchemaNumericFacet)o, isNullable, true);
                    return;
                }
                else if (t == typeof(System.Xml.Schema.XmlSchemaFractionDigitsFacet)) {
                    Write34_XmlSchemaFractionDigitsFacet(n, ns, (System.Xml.Schema.XmlSchemaFractionDigitsFacet)o, isNullable, true);
                    return;
                }
                else if (t == typeof(System.Xml.Schema.XmlSchemaTotalDigitsFacet)) {
                    Write33_XmlSchemaTotalDigitsFacet(n, ns, (System.Xml.Schema.XmlSchemaTotalDigitsFacet)o, isNullable, true);
                    return;
                }
                else if (t == typeof(System.Xml.Schema.XmlSchemaMaxLengthFacet)) {
                    Write26_XmlSchemaMaxLengthFacet(n, ns, (System.Xml.Schema.XmlSchemaMaxLengthFacet)o, isNullable, true);
                    return;
                }
                else if (t == typeof(System.Xml.Schema.XmlSchemaLengthFacet)) {
                    Write24_XmlSchemaLengthFacet(n, ns, (System.Xml.Schema.XmlSchemaLengthFacet)o, isNullable, true);
                    return;
                }
                else if (t == typeof(System.Xml.Schema.XmlSchemaMinLengthFacet)) {
                    Write21_XmlSchemaMinLengthFacet(n, ns, (System.Xml.Schema.XmlSchemaMinLengthFacet)o, isNullable, true);
                    return;
                }
                else if (t == typeof(System.Xml.Schema.XmlSchemaSimpleTypeContent)) {
                    Write19_XmlSchemaSimpleTypeContent(n, ns, (System.Xml.Schema.XmlSchemaSimpleTypeContent)o, isNullable, true);
                    return;
                }
                else if (t == typeof(System.Xml.Schema.XmlSchemaSimpleTypeUnion)) {
                    Write35_XmlSchemaSimpleTypeUnion(n, ns, (System.Xml.Schema.XmlSchemaSimpleTypeUnion)o, isNullable, true);
                    return;
                }
                else if (t == typeof(System.Xml.Schema.XmlSchemaSimpleTypeRestriction)) {
                    Write20_XmlSchemaSimpleTypeRestriction(n, ns, (System.Xml.Schema.XmlSchemaSimpleTypeRestriction)o, isNullable, true);
                    return;
                }
                else if (t == typeof(System.Xml.Schema.XmlSchemaSimpleTypeList)) {
                    Write18_XmlSchemaSimpleTypeList(n, ns, (System.Xml.Schema.XmlSchemaSimpleTypeList)o, isNullable, true);
                    return;
                }
                else if (t == typeof(System.Xml.Schema.XmlSchemaType)) {
                    Write13_XmlSchemaType(n, ns, (System.Xml.Schema.XmlSchemaType)o, isNullable, true);
                    return;
                }
                else if (t == typeof(System.Xml.Schema.XmlSchemaComplexType)) {
                    Write42_XmlSchemaComplexType(n, ns, (System.Xml.Schema.XmlSchemaComplexType)o, isNullable, true);
                    return;
                }
                else if (t == typeof(System.Xml.Schema.XmlSchemaSimpleType)) {
                    Write12_XmlSchemaSimpleType(n, ns, (System.Xml.Schema.XmlSchemaSimpleType)o, isNullable, true);
                    return;
                }
                else if (t == typeof(System.Xml.Schema.XmlSchemaExternal)) {
                    Write11_XmlSchemaExternal(n, ns, (System.Xml.Schema.XmlSchemaExternal)o, isNullable, true);
                    return;
                }
                else if (t == typeof(System.Xml.Schema.XmlSchemaInclude)) {
                    Write66_XmlSchemaInclude(n, ns, (System.Xml.Schema.XmlSchemaInclude)o, isNullable, true);
                    return;
                }
                else if (t == typeof(System.Xml.Schema.XmlSchemaImport)) {
                    Write65_XmlSchemaImport(n, ns, (System.Xml.Schema.XmlSchemaImport)o, isNullable, true);
                    return;
                }
                else if (t == typeof(System.Xml.Schema.XmlSchemaRedefine)) {
                    Write10_XmlSchemaRedefine(n, ns, (System.Xml.Schema.XmlSchemaRedefine)o, isNullable, true);
                    return;
                }
                else if (t == typeof(System.Xml.Schema.XmlSchema)) {
                    Write6_XmlSchema(n, ns, (System.Xml.Schema.XmlSchema)o, isNullable, true);
                    return;
                }
                else {
                    throw CreateUnknownTypeException(o);
                }
            }
        }

        string Write8_XmlSchemaForm(System.Xml.Schema.XmlSchemaForm v) {
            string s = null;
            switch (v) {
                case System.Xml.Schema.XmlSchemaForm.@Qualified: s = @"qualified"; break;
                case System.Xml.Schema.XmlSchemaForm.@Unqualified: s = @"unqualified"; break;
                default: s = ((System.Int64)v).ToString(); break;
            }
            return s;
        }

        string Write9_XmlSchemaDerivationMethod(System.Xml.Schema.XmlSchemaDerivationMethod v) {
            string s = null;
            switch (v) {
                case System.Xml.Schema.XmlSchemaDerivationMethod.@Empty: s = @""; break;
                case System.Xml.Schema.XmlSchemaDerivationMethod.@Substitution: s = @"substitution"; break;
                case System.Xml.Schema.XmlSchemaDerivationMethod.@Extension: s = @"extension"; break;
                case System.Xml.Schema.XmlSchemaDerivationMethod.@Restriction: s = @"restriction"; break;
                case System.Xml.Schema.XmlSchemaDerivationMethod.@List: s = @"list"; break;
                case System.Xml.Schema.XmlSchemaDerivationMethod.@Union: s = @"union"; break;
                case System.Xml.Schema.XmlSchemaDerivationMethod.@All: s = @"#all"; break;
                default: s = FromEnum((System.Int64)v, new System.String[] {@"", 
                    @"substitution", 
                    @"extension", 
                    @"restriction", 
                    @"list", 
                    @"union", 
                    @"#all"}, new System.Int64[] {(System.Int64)System.Xml.Schema.XmlSchemaDerivationMethod.@Empty, 
                    (System.Int64)System.Xml.Schema.XmlSchemaDerivationMethod.@Substitution, 
                    (System.Int64)System.Xml.Schema.XmlSchemaDerivationMethod.@Extension, 
                    (System.Int64)System.Xml.Schema.XmlSchemaDerivationMethod.@Restriction, 
                    (System.Int64)System.Xml.Schema.XmlSchemaDerivationMethod.@List, 
                    (System.Int64)System.Xml.Schema.XmlSchemaDerivationMethod.@Union, 
                    (System.Int64)System.Xml.Schema.XmlSchemaDerivationMethod.@All}); break;
            }
            return s;
        }

        void Write10_XmlSchemaRedefine(string n, string ns, System.Xml.Schema.XmlSchemaRedefine o, bool isNullable, bool needType) {
            if ((object)o == null) {
                if (isNullable) WriteNullTagLiteral(n, ns);
                return;
            }
            if (!needType) {
                System.Type t = o.GetType();
                if (t == typeof(System.Xml.Schema.XmlSchemaRedefine))
                    ;
                else {
                    throw CreateUnknownTypeException(o);
                }
            }
            WriteStartElement(n, ns, o);
            if (needType) WriteXsiType(@"XmlSchemaRedefine", @"http://www.w3.org/2001/XMLSchema");
            WriteNamespaceDeclarations(o.@Namespaces);
            WriteAttribute(@"schemaLocation", @"", (System.String)o.@SchemaLocation);
            WriteAttribute(@"id", @"", (System.String)o.@Id);
            {
                System.Xml.XmlAttribute[] a = (System.Xml.XmlAttribute[])o.@UnhandledAttributes;
                if (a != null) {
                    for (int i = 0; i < a.Length; i++) {
                        System.Xml.XmlAttribute ai = (System.Xml.XmlAttribute)a[i];
                        WriteXmlAttribute(ai, o);
                    }
                }
            }
            {
                System.Xml.Schema.XmlSchemaObjectCollection a = (System.Xml.Schema.XmlSchemaObjectCollection)o.@Items;
                if (a != null) {
                    for (int ia = 0; ia < a.Count; ia++) {
                        System.Xml.Schema.XmlSchemaObject ai = a[ia];
                        {
                            if (ai is System.Xml.Schema.XmlSchemaComplexType) {
                                Write42_XmlSchemaComplexType(@"complexType", @"http://www.w3.org/2001/XMLSchema", ((System.Xml.Schema.XmlSchemaComplexType)ai), false, false);
                            }
                            else if (ai is System.Xml.Schema.XmlSchemaAttributeGroup) {
                                Write36_XmlSchemaAttributeGroup(@"attributeGroup", @"http://www.w3.org/2001/XMLSchema", ((System.Xml.Schema.XmlSchemaAttributeGroup)ai), false, false);
                            }
                            else if (ai is System.Xml.Schema.XmlSchemaGroup) {
                                Write64_XmlSchemaGroup(@"group", @"http://www.w3.org/2001/XMLSchema", ((System.Xml.Schema.XmlSchemaGroup)ai), false, false);
                            }
                            else if (ai is System.Xml.Schema.XmlSchemaSimpleType) {
                                Write12_XmlSchemaSimpleType(@"simpleType", @"http://www.w3.org/2001/XMLSchema", ((System.Xml.Schema.XmlSchemaSimpleType)ai), false, false);
                            }
                            else if (ai is System.Xml.Schema.XmlSchemaAnnotation) {
                                Write15_XmlSchemaAnnotation(@"annotation", @"http://www.w3.org/2001/XMLSchema", ((System.Xml.Schema.XmlSchemaAnnotation)ai), false, false);
                            }
                            else {
                                if (ai != null) {
                                    throw CreateUnknownTypeException(ai);
                                }
                            }
                        }
                    }
                }
            }
            WriteEndElement(o);
        }

        void Write11_XmlSchemaExternal(string n, string ns, System.Xml.Schema.XmlSchemaExternal o, bool isNullable, bool needType) {
            if ((object)o == null) {
                if (isNullable) WriteNullTagLiteral(n, ns);
                return;
            }
            if (!needType) {
                System.Type t = o.GetType();
                if (t == typeof(System.Xml.Schema.XmlSchemaExternal))
                    ;
                else if (t == typeof(System.Xml.Schema.XmlSchemaInclude)) {
                    Write66_XmlSchemaInclude(n, ns, (System.Xml.Schema.XmlSchemaInclude)o, isNullable, true);
                    return;
                }
                else if (t == typeof(System.Xml.Schema.XmlSchemaImport)) {
                    Write65_XmlSchemaImport(n, ns, (System.Xml.Schema.XmlSchemaImport)o, isNullable, true);
                    return;
                }
                else if (t == typeof(System.Xml.Schema.XmlSchemaRedefine)) {
                    Write10_XmlSchemaRedefine(n, ns, (System.Xml.Schema.XmlSchemaRedefine)o, isNullable, true);
                    return;
                }
                else {
                    throw CreateUnknownTypeException(o);
                }
            }
        }

        void Write12_XmlSchemaSimpleType(string n, string ns, System.Xml.Schema.XmlSchemaSimpleType o, bool isNullable, bool needType) {
            if ((object)o == null) {
                if (isNullable) WriteNullTagLiteral(n, ns);
                return;
            }
            if (!needType) {
                System.Type t = o.GetType();
                if (t == typeof(System.Xml.Schema.XmlSchemaSimpleType))
                    ;
                else {
                    throw CreateUnknownTypeException(o);
                }
            }
            WriteStartElement(n, ns, o);
            if (needType) WriteXsiType(@"XmlSchemaSimpleType", @"http://www.w3.org/2001/XMLSchema");
            WriteNamespaceDeclarations(o.@Namespaces);
            WriteAttribute(@"id", @"", (System.String)o.@Id);
            {
                System.Xml.XmlAttribute[] a = (System.Xml.XmlAttribute[])o.@UnhandledAttributes;
                if (a != null) {
                    for (int i = 0; i < a.Length; i++) {
                        System.Xml.XmlAttribute ai = (System.Xml.XmlAttribute)a[i];
                        WriteXmlAttribute(ai, o);
                    }
                }
            }
            WriteAttribute(@"name", @"", (System.String)o.@Name);
            if ((System.Xml.Schema.XmlSchemaDerivationMethod)o.@Final != (System.Xml.Schema.XmlSchemaDerivationMethod.@None)) {
                WriteAttribute(@"final", @"", Write9_XmlSchemaDerivationMethod((System.Xml.Schema.XmlSchemaDerivationMethod)o.@Final));
            }
            Write15_XmlSchemaAnnotation(@"annotation", @"http://www.w3.org/2001/XMLSchema", ((System.Xml.Schema.XmlSchemaAnnotation)o.@Annotation), false, false);
            {
                if (o.@Content is System.Xml.Schema.XmlSchemaSimpleTypeList) {
                    Write18_XmlSchemaSimpleTypeList(@"list", @"http://www.w3.org/2001/XMLSchema", ((System.Xml.Schema.XmlSchemaSimpleTypeList)o.@Content), false, false);
                }
                else if (o.@Content is System.Xml.Schema.XmlSchemaSimpleTypeRestriction) {
                    Write20_XmlSchemaSimpleTypeRestriction(@"restriction", @"http://www.w3.org/2001/XMLSchema", ((System.Xml.Schema.XmlSchemaSimpleTypeRestriction)o.@Content), false, false);
                }
                else if (o.@Content is System.Xml.Schema.XmlSchemaSimpleTypeUnion) {
                    Write35_XmlSchemaSimpleTypeUnion(@"union", @"http://www.w3.org/2001/XMLSchema", ((System.Xml.Schema.XmlSchemaSimpleTypeUnion)o.@Content), false, false);
                }
                else {
                    if (o.@Content != null) {
                        throw CreateUnknownTypeException(o.@Content);
                    }
                }
            }
            WriteEndElement(o);
        }

        void Write13_XmlSchemaType(string n, string ns, System.Xml.Schema.XmlSchemaType o, bool isNullable, bool needType) {
            if ((object)o == null) {
                if (isNullable) WriteNullTagLiteral(n, ns);
                return;
            }
            if (!needType) {
                System.Type t = o.GetType();
                if (t == typeof(System.Xml.Schema.XmlSchemaType))
                    ;
                else if (t == typeof(System.Xml.Schema.XmlSchemaComplexType)) {
                    Write42_XmlSchemaComplexType(n, ns, (System.Xml.Schema.XmlSchemaComplexType)o, isNullable, true);
                    return;
                }
                else if (t == typeof(System.Xml.Schema.XmlSchemaSimpleType)) {
                    Write12_XmlSchemaSimpleType(n, ns, (System.Xml.Schema.XmlSchemaSimpleType)o, isNullable, true);
                    return;
                }
                else {
                    throw CreateUnknownTypeException(o);
                }
            }
            WriteStartElement(n, ns, o);
            if (needType) WriteXsiType(@"XmlSchemaType", @"http://www.w3.org/2001/XMLSchema");
            WriteNamespaceDeclarations(o.@Namespaces);
            WriteAttribute(@"id", @"", (System.String)o.@Id);
            {
                System.Xml.XmlAttribute[] a = (System.Xml.XmlAttribute[])o.@UnhandledAttributes;
                if (a != null) {
                    for (int i = 0; i < a.Length; i++) {
                        System.Xml.XmlAttribute ai = (System.Xml.XmlAttribute)a[i];
                        WriteXmlAttribute(ai, o);
                    }
                }
            }
            WriteAttribute(@"name", @"", (System.String)o.@Name);
            if ((System.Xml.Schema.XmlSchemaDerivationMethod)o.@Final != (System.Xml.Schema.XmlSchemaDerivationMethod.@None)) {
                WriteAttribute(@"final", @"", Write9_XmlSchemaDerivationMethod((System.Xml.Schema.XmlSchemaDerivationMethod)o.@Final));
            }
            Write15_XmlSchemaAnnotation(@"annotation", @"http://www.w3.org/2001/XMLSchema", ((System.Xml.Schema.XmlSchemaAnnotation)o.@Annotation), false, false);
            WriteEndElement(o);
        }

        void Write14_XmlSchemaAnnotated(string n, string ns, System.Xml.Schema.XmlSchemaAnnotated o, bool isNullable, bool needType) {
            if ((object)o == null) {
                if (isNullable) WriteNullTagLiteral(n, ns);
                return;
            }
            if (!needType) {
                System.Type t = o.GetType();
                if (t == typeof(System.Xml.Schema.XmlSchemaAnnotated))
                    ;
                else if (t == typeof(System.Xml.Schema.XmlSchemaNotation)) {
                    Write67_XmlSchemaNotation(n, ns, (System.Xml.Schema.XmlSchemaNotation)o, isNullable, true);
                    return;
                }
                else if (t == typeof(System.Xml.Schema.XmlSchemaGroup)) {
                    Write64_XmlSchemaGroup(n, ns, (System.Xml.Schema.XmlSchemaGroup)o, isNullable, true);
                    return;
                }
                else if (t == typeof(System.Xml.Schema.XmlSchemaXPath)) {
                    Write54_XmlSchemaXPath(n, ns, (System.Xml.Schema.XmlSchemaXPath)o, isNullable, true);
                    return;
                }
                else if (t == typeof(System.Xml.Schema.XmlSchemaIdentityConstraint)) {
                    Write53_XmlSchemaIdentityConstraint(n, ns, (System.Xml.Schema.XmlSchemaIdentityConstraint)o, isNullable, true);
                    return;
                }
                else if (t == typeof(System.Xml.Schema.XmlSchemaKey)) {
                    Write56_XmlSchemaKey(n, ns, (System.Xml.Schema.XmlSchemaKey)o, isNullable, true);
                    return;
                }
                else if (t == typeof(System.Xml.Schema.XmlSchemaUnique)) {
                    Write55_XmlSchemaUnique(n, ns, (System.Xml.Schema.XmlSchemaUnique)o, isNullable, true);
                    return;
                }
                else if (t == typeof(System.Xml.Schema.XmlSchemaKeyref)) {
                    Write52_XmlSchemaKeyref(n, ns, (System.Xml.Schema.XmlSchemaKeyref)o, isNullable, true);
                    return;
                }
                else if (t == typeof(System.Xml.Schema.XmlSchemaParticle)) {
                    Write49_XmlSchemaParticle(n, ns, (System.Xml.Schema.XmlSchemaParticle)o, isNullable, true);
                    return;
                }
                else if (t == typeof(System.Xml.Schema.XmlSchemaGroupRef)) {
                    Write57_XmlSchemaGroupRef(n, ns, (System.Xml.Schema.XmlSchemaGroupRef)o, isNullable, true);
                    return;
                }
                else if (t == typeof(System.Xml.Schema.XmlSchemaElement)) {
                    Write51_XmlSchemaElement(n, ns, (System.Xml.Schema.XmlSchemaElement)o, isNullable, true);
                    return;
                }
                else if (t == typeof(System.Xml.Schema.XmlSchemaAny)) {
                    Write50_XmlSchemaAny(n, ns, (System.Xml.Schema.XmlSchemaAny)o, isNullable, true);
                    return;
                }
                else if (t == typeof(System.Xml.Schema.XmlSchemaGroupBase)) {
                    Write48_XmlSchemaGroupBase(n, ns, (System.Xml.Schema.XmlSchemaGroupBase)o, isNullable, true);
                    return;
                }
                else if (t == typeof(System.Xml.Schema.XmlSchemaAll)) {
                    Write59_XmlSchemaAll(n, ns, (System.Xml.Schema.XmlSchemaAll)o, isNullable, true);
                    return;
                }
                else if (t == typeof(System.Xml.Schema.XmlSchemaChoice)) {
                    Write58_XmlSchemaChoice(n, ns, (System.Xml.Schema.XmlSchemaChoice)o, isNullable, true);
                    return;
                }
                else if (t == typeof(System.Xml.Schema.XmlSchemaSequence)) {
                    Write47_XmlSchemaSequence(n, ns, (System.Xml.Schema.XmlSchemaSequence)o, isNullable, true);
                    return;
                }
                else if (t == typeof(System.Xml.Schema.XmlSchemaContent)) {
                    Write46_XmlSchemaContent(n, ns, (System.Xml.Schema.XmlSchemaContent)o, isNullable, true);
                    return;
                }
                else if (t == typeof(System.Xml.Schema.XmlSchemaSimpleContentExtension)) {
                    Write63_XmlSchemaSimpleContentExtension(n, ns, (System.Xml.Schema.XmlSchemaSimpleContentExtension)o, isNullable, true);
                    return;
                }
                else if (t == typeof(System.Xml.Schema.XmlSchemaSimpleContentRestriction)) {
                    Write62_XmlSchemaSimpleContentRestriction(n, ns, (System.Xml.Schema.XmlSchemaSimpleContentRestriction)o, isNullable, true);
                    return;
                }
                else if (t == typeof(System.Xml.Schema.XmlSchemaComplexContentRestriction)) {
                    Write60_XmlSchemaComplexContentRestriction(n, ns, (System.Xml.Schema.XmlSchemaComplexContentRestriction)o, isNullable, true);
                    return;
                }
                else if (t == typeof(System.Xml.Schema.XmlSchemaComplexContentExtension)) {
                    Write45_XmlSchemaComplexContentExtension(n, ns, (System.Xml.Schema.XmlSchemaComplexContentExtension)o, isNullable, true);
                    return;
                }
                else if (t == typeof(System.Xml.Schema.XmlSchemaContentModel)) {
                    Write44_XmlSchemaContentModel(n, ns, (System.Xml.Schema.XmlSchemaContentModel)o, isNullable, true);
                    return;
                }
                else if (t == typeof(System.Xml.Schema.XmlSchemaSimpleContent)) {
                    Write61_XmlSchemaSimpleContent(n, ns, (System.Xml.Schema.XmlSchemaSimpleContent)o, isNullable, true);
                    return;
                }
                else if (t == typeof(System.Xml.Schema.XmlSchemaComplexContent)) {
                    Write43_XmlSchemaComplexContent(n, ns, (System.Xml.Schema.XmlSchemaComplexContent)o, isNullable, true);
                    return;
                }
                else if (t == typeof(System.Xml.Schema.XmlSchemaAnyAttribute)) {
                    Write40_XmlSchemaAnyAttribute(n, ns, (System.Xml.Schema.XmlSchemaAnyAttribute)o, isNullable, true);
                    return;
                }
                else if (t == typeof(System.Xml.Schema.XmlSchemaAttributeGroupRef)) {
                    Write39_XmlSchemaAttributeGroupRef(n, ns, (System.Xml.Schema.XmlSchemaAttributeGroupRef)o, isNullable, true);
                    return;
                }
                else if (t == typeof(System.Xml.Schema.XmlSchemaAttribute)) {
                    Write37_XmlSchemaAttribute(n, ns, (System.Xml.Schema.XmlSchemaAttribute)o, isNullable, true);
                    return;
                }
                else if (t == typeof(System.Xml.Schema.XmlSchemaAttributeGroup)) {
                    Write36_XmlSchemaAttributeGroup(n, ns, (System.Xml.Schema.XmlSchemaAttributeGroup)o, isNullable, true);
                    return;
                }
                else if (t == typeof(System.Xml.Schema.XmlSchemaFacet)) {
                    Write23_XmlSchemaFacet(n, ns, (System.Xml.Schema.XmlSchemaFacet)o, isNullable, true);
                    return;
                }
                else if (t == typeof(System.Xml.Schema.XmlSchemaMinExclusiveFacet)) {
                    Write32_XmlSchemaMinExclusiveFacet(n, ns, (System.Xml.Schema.XmlSchemaMinExclusiveFacet)o, isNullable, true);
                    return;
                }
                else if (t == typeof(System.Xml.Schema.XmlSchemaMinInclusiveFacet)) {
                    Write31_XmlSchemaMinInclusiveFacet(n, ns, (System.Xml.Schema.XmlSchemaMinInclusiveFacet)o, isNullable, true);
                    return;
                }
                else if (t == typeof(System.Xml.Schema.XmlSchemaMaxExclusiveFacet)) {
                    Write30_XmlSchemaMaxExclusiveFacet(n, ns, (System.Xml.Schema.XmlSchemaMaxExclusiveFacet)o, isNullable, true);
                    return;
                }
                else if (t == typeof(System.Xml.Schema.XmlSchemaMaxInclusiveFacet)) {
                    Write29_XmlSchemaMaxInclusiveFacet(n, ns, (System.Xml.Schema.XmlSchemaMaxInclusiveFacet)o, isNullable, true);
                    return;
                }
                else if (t == typeof(System.Xml.Schema.XmlSchemaEnumerationFacet)) {
                    Write28_XmlSchemaEnumerationFacet(n, ns, (System.Xml.Schema.XmlSchemaEnumerationFacet)o, isNullable, true);
                    return;
                }
                else if (t == typeof(System.Xml.Schema.XmlSchemaPatternFacet)) {
                    Write27_XmlSchemaPatternFacet(n, ns, (System.Xml.Schema.XmlSchemaPatternFacet)o, isNullable, true);
                    return;
                }
                else if (t == typeof(System.Xml.Schema.XmlSchemaWhiteSpaceFacet)) {
                    Write25_XmlSchemaWhiteSpaceFacet(n, ns, (System.Xml.Schema.XmlSchemaWhiteSpaceFacet)o, isNullable, true);
                    return;
                }
                else if (t == typeof(System.Xml.Schema.XmlSchemaNumericFacet)) {
                    Write22_XmlSchemaNumericFacet(n, ns, (System.Xml.Schema.XmlSchemaNumericFacet)o, isNullable, true);
                    return;
                }
                else if (t == typeof(System.Xml.Schema.XmlSchemaFractionDigitsFacet)) {
                    Write34_XmlSchemaFractionDigitsFacet(n, ns, (System.Xml.Schema.XmlSchemaFractionDigitsFacet)o, isNullable, true);
                    return;
                }
                else if (t == typeof(System.Xml.Schema.XmlSchemaTotalDigitsFacet)) {
                    Write33_XmlSchemaTotalDigitsFacet(n, ns, (System.Xml.Schema.XmlSchemaTotalDigitsFacet)o, isNullable, true);
                    return;
                }
                else if (t == typeof(System.Xml.Schema.XmlSchemaMaxLengthFacet)) {
                    Write26_XmlSchemaMaxLengthFacet(n, ns, (System.Xml.Schema.XmlSchemaMaxLengthFacet)o, isNullable, true);
                    return;
                }
                else if (t == typeof(System.Xml.Schema.XmlSchemaLengthFacet)) {
                    Write24_XmlSchemaLengthFacet(n, ns, (System.Xml.Schema.XmlSchemaLengthFacet)o, isNullable, true);
                    return;
                }
                else if (t == typeof(System.Xml.Schema.XmlSchemaMinLengthFacet)) {
                    Write21_XmlSchemaMinLengthFacet(n, ns, (System.Xml.Schema.XmlSchemaMinLengthFacet)o, isNullable, true);
                    return;
                }
                else if (t == typeof(System.Xml.Schema.XmlSchemaSimpleTypeContent)) {
                    Write19_XmlSchemaSimpleTypeContent(n, ns, (System.Xml.Schema.XmlSchemaSimpleTypeContent)o, isNullable, true);
                    return;
                }
                else if (t == typeof(System.Xml.Schema.XmlSchemaSimpleTypeUnion)) {
                    Write35_XmlSchemaSimpleTypeUnion(n, ns, (System.Xml.Schema.XmlSchemaSimpleTypeUnion)o, isNullable, true);
                    return;
                }
                else if (t == typeof(System.Xml.Schema.XmlSchemaSimpleTypeRestriction)) {
                    Write20_XmlSchemaSimpleTypeRestriction(n, ns, (System.Xml.Schema.XmlSchemaSimpleTypeRestriction)o, isNullable, true);
                    return;
                }
                else if (t == typeof(System.Xml.Schema.XmlSchemaSimpleTypeList)) {
                    Write18_XmlSchemaSimpleTypeList(n, ns, (System.Xml.Schema.XmlSchemaSimpleTypeList)o, isNullable, true);
                    return;
                }
                else if (t == typeof(System.Xml.Schema.XmlSchemaType)) {
                    Write13_XmlSchemaType(n, ns, (System.Xml.Schema.XmlSchemaType)o, isNullable, true);
                    return;
                }
                else if (t == typeof(System.Xml.Schema.XmlSchemaComplexType)) {
                    Write42_XmlSchemaComplexType(n, ns, (System.Xml.Schema.XmlSchemaComplexType)o, isNullable, true);
                    return;
                }
                else if (t == typeof(System.Xml.Schema.XmlSchemaSimpleType)) {
                    Write12_XmlSchemaSimpleType(n, ns, (System.Xml.Schema.XmlSchemaSimpleType)o, isNullable, true);
                    return;
                }
                else {
                    throw CreateUnknownTypeException(o);
                }
            }
            WriteStartElement(n, ns, o);
            if (needType) WriteXsiType(@"XmlSchemaAnnotated", @"http://www.w3.org/2001/XMLSchema");
            WriteNamespaceDeclarations(o.@Namespaces);
            WriteAttribute(@"id", @"", (System.String)o.@Id);
            {
                System.Xml.XmlAttribute[] a = (System.Xml.XmlAttribute[])o.@UnhandledAttributes;
                if (a != null) {
                    for (int i = 0; i < a.Length; i++) {
                        System.Xml.XmlAttribute ai = (System.Xml.XmlAttribute)a[i];
                        WriteXmlAttribute(ai, o);
                    }
                }
            }
            Write15_XmlSchemaAnnotation(@"annotation", @"http://www.w3.org/2001/XMLSchema", ((System.Xml.Schema.XmlSchemaAnnotation)o.@Annotation), false, false);
            WriteEndElement(o);
        }

        void Write15_XmlSchemaAnnotation(string n, string ns, System.Xml.Schema.XmlSchemaAnnotation o, bool isNullable, bool needType) {
            if ((object)o == null) {
                if (isNullable) WriteNullTagLiteral(n, ns);
                return;
            }
            if (!needType) {
                System.Type t = o.GetType();
                if (t == typeof(System.Xml.Schema.XmlSchemaAnnotation))
                    ;
                else {
                    throw CreateUnknownTypeException(o);
                }
            }
            WriteStartElement(n, ns, o);
            if (needType) WriteXsiType(@"XmlSchemaAnnotation", @"http://www.w3.org/2001/XMLSchema");
            WriteNamespaceDeclarations(o.@Namespaces);
            WriteAttribute(@"id", @"", (System.String)o.@Id);
            {
                System.Xml.XmlAttribute[] a = (System.Xml.XmlAttribute[])o.@UnhandledAttributes;
                if (a != null) {
                    for (int i = 0; i < a.Length; i++) {
                        System.Xml.XmlAttribute ai = (System.Xml.XmlAttribute)a[i];
                        WriteXmlAttribute(ai, o);
                    }
                }
            }
            {
                System.Xml.Schema.XmlSchemaObjectCollection a = (System.Xml.Schema.XmlSchemaObjectCollection)o.@Items;
                if (a != null) {
                    for (int ia = 0; ia < a.Count; ia++) {
                        System.Xml.Schema.XmlSchemaObject ai = a[ia];
                        {
                            if (ai is System.Xml.Schema.XmlSchemaAppInfo) {
                                Write16_XmlSchemaAppInfo(@"appinfo", @"http://www.w3.org/2001/XMLSchema", ((System.Xml.Schema.XmlSchemaAppInfo)ai), false, false);
                            }
                            else if (ai is System.Xml.Schema.XmlSchemaDocumentation) {
                                Write17_XmlSchemaDocumentation(@"documentation", @"http://www.w3.org/2001/XMLSchema", ((System.Xml.Schema.XmlSchemaDocumentation)ai), false, false);
                            }
                            else {
                                if (ai != null) {
                                    throw CreateUnknownTypeException(ai);
                                }
                            }
                        }
                    }
                }
            }
            WriteEndElement(o);
        }

        void Write16_XmlSchemaAppInfo(string n, string ns, System.Xml.Schema.XmlSchemaAppInfo o, bool isNullable, bool needType) {
            if ((object)o == null) {
                if (isNullable) WriteNullTagLiteral(n, ns);
                return;
            }
            if (!needType) {
                System.Type t = o.GetType();
                if (t == typeof(System.Xml.Schema.XmlSchemaAppInfo))
                    ;
                else {
                    throw CreateUnknownTypeException(o);
                }
            }
            WriteStartElement(n, ns, o);
            if (needType) WriteXsiType(@"XmlSchemaAppInfo", @"http://www.w3.org/2001/XMLSchema");
            WriteNamespaceDeclarations(o.@Namespaces);
            WriteAttribute(@"source", @"", (System.String)o.@Source);
            {
                System.Xml.XmlNode[] a = (System.Xml.XmlNode[])o.@Markup;
                if (a != null) {
                    for (int ia = 0; ia < a.Length; ia++) {
                        System.Xml.XmlNode ai = a[ia];
                        {
                            if (ai is System.Xml.XmlElement) {
                                System.Xml.XmlElement elem = (System.Xml.XmlElement)ai;
                                WriteElementLiteral(elem, @"", "", false, true);
                            }
                            else if (ai is System.Xml.XmlNode) {
                                ((System.Xml.XmlNode)ai).WriteTo(Writer);
                            }
                            else {
                                if (ai != null) {
                                    throw CreateUnknownTypeException(ai);
                                }
                            }
                        }
                    }
                }
            }
            WriteEndElement(o);
        }

        void Write17_XmlSchemaDocumentation(string n, string ns, System.Xml.Schema.XmlSchemaDocumentation o, bool isNullable, bool needType) {
            if ((object)o == null) {
                if (isNullable) WriteNullTagLiteral(n, ns);
                return;
            }
            if (!needType) {
                System.Type t = o.GetType();
                if (t == typeof(System.Xml.Schema.XmlSchemaDocumentation))
                    ;
                else {
                    throw CreateUnknownTypeException(o);
                }
            }
            WriteStartElement(n, ns, o);
            if (needType) WriteXsiType(@"XmlSchemaDocumentation", @"http://www.w3.org/2001/XMLSchema");
            WriteNamespaceDeclarations(o.@Namespaces);
            WriteAttribute(@"source", @"", (System.String)o.@Source);
            WriteAttribute(@"lang", @"http://www.w3.org/XML/1998/namespace", (System.String)o.@Language);
            {
                System.Xml.XmlNode[] a = (System.Xml.XmlNode[])o.@Markup;
                if (a != null) {
                    for (int ia = 0; ia < a.Length; ia++) {
                        System.Xml.XmlNode ai = a[ia];
                        {
                            if (ai is System.Xml.XmlElement) {
                                System.Xml.XmlElement elem = (System.Xml.XmlElement)ai;
                                WriteElementLiteral(elem, @"", "", false, true);
                            }
                            else if (ai is System.Xml.XmlNode) {
                                ((System.Xml.XmlNode)ai).WriteTo(Writer);
                            }
                            else {
                                if (ai != null) {
                                    throw CreateUnknownTypeException(ai);
                                }
                            }
                        }
                    }
                }
            }
            WriteEndElement(o);
        }

        void Write18_XmlSchemaSimpleTypeList(string n, string ns, System.Xml.Schema.XmlSchemaSimpleTypeList o, bool isNullable, bool needType) {
            if ((object)o == null) {
                if (isNullable) WriteNullTagLiteral(n, ns);
                return;
            }
            if (!needType) {
                System.Type t = o.GetType();
                if (t == typeof(System.Xml.Schema.XmlSchemaSimpleTypeList))
                    ;
                else {
                    throw CreateUnknownTypeException(o);
                }
            }
            WriteStartElement(n, ns, o);
            if (needType) WriteXsiType(@"XmlSchemaSimpleTypeList", @"http://www.w3.org/2001/XMLSchema");
            WriteNamespaceDeclarations(o.@Namespaces);
            WriteAttribute(@"id", @"", (System.String)o.@Id);
            {
                System.Xml.XmlAttribute[] a = (System.Xml.XmlAttribute[])o.@UnhandledAttributes;
                if (a != null) {
                    for (int i = 0; i < a.Length; i++) {
                        System.Xml.XmlAttribute ai = (System.Xml.XmlAttribute)a[i];
                        WriteXmlAttribute(ai, o);
                    }
                }
            }
            WriteAttribute(@"itemType", @"", FromXmlQualifiedName((System.Xml.XmlQualifiedName)o.@ItemTypeName));
            Write15_XmlSchemaAnnotation(@"annotation", @"http://www.w3.org/2001/XMLSchema", ((System.Xml.Schema.XmlSchemaAnnotation)o.@Annotation), false, false);
            Write12_XmlSchemaSimpleType(@"simpleType", @"http://www.w3.org/2001/XMLSchema", ((System.Xml.Schema.XmlSchemaSimpleType)o.@ItemType), false, false);
            WriteEndElement(o);
        }

        void Write19_XmlSchemaSimpleTypeContent(string n, string ns, System.Xml.Schema.XmlSchemaSimpleTypeContent o, bool isNullable, bool needType) {
            if ((object)o == null) {
                if (isNullable) WriteNullTagLiteral(n, ns);
                return;
            }
            if (!needType) {
                System.Type t = o.GetType();
                if (t == typeof(System.Xml.Schema.XmlSchemaSimpleTypeContent))
                    ;
                else if (t == typeof(System.Xml.Schema.XmlSchemaSimpleTypeUnion)) {
                    Write35_XmlSchemaSimpleTypeUnion(n, ns, (System.Xml.Schema.XmlSchemaSimpleTypeUnion)o, isNullable, true);
                    return;
                }
                else if (t == typeof(System.Xml.Schema.XmlSchemaSimpleTypeRestriction)) {
                    Write20_XmlSchemaSimpleTypeRestriction(n, ns, (System.Xml.Schema.XmlSchemaSimpleTypeRestriction)o, isNullable, true);
                    return;
                }
                else if (t == typeof(System.Xml.Schema.XmlSchemaSimpleTypeList)) {
                    Write18_XmlSchemaSimpleTypeList(n, ns, (System.Xml.Schema.XmlSchemaSimpleTypeList)o, isNullable, true);
                    return;
                }
                else {
                    throw CreateUnknownTypeException(o);
                }
            }
        }

        void Write20_XmlSchemaSimpleTypeRestriction(string n, string ns, System.Xml.Schema.XmlSchemaSimpleTypeRestriction o, bool isNullable, bool needType) {
            if ((object)o == null) {
                if (isNullable) WriteNullTagLiteral(n, ns);
                return;
            }
            if (!needType) {
                System.Type t = o.GetType();
                if (t == typeof(System.Xml.Schema.XmlSchemaSimpleTypeRestriction))
                    ;
                else {
                    throw CreateUnknownTypeException(o);
                }
            }
            WriteStartElement(n, ns, o);
            if (needType) WriteXsiType(@"XmlSchemaSimpleTypeRestriction", @"http://www.w3.org/2001/XMLSchema");
            WriteNamespaceDeclarations(o.@Namespaces);
            WriteAttribute(@"id", @"", (System.String)o.@Id);
            {
                System.Xml.XmlAttribute[] a = (System.Xml.XmlAttribute[])o.@UnhandledAttributes;
                if (a != null) {
                    for (int i = 0; i < a.Length; i++) {
                        System.Xml.XmlAttribute ai = (System.Xml.XmlAttribute)a[i];
                        WriteXmlAttribute(ai, o);
                    }
                }
            }
            WriteAttribute(@"base", @"", FromXmlQualifiedName((System.Xml.XmlQualifiedName)o.@BaseTypeName));
            Write15_XmlSchemaAnnotation(@"annotation", @"http://www.w3.org/2001/XMLSchema", ((System.Xml.Schema.XmlSchemaAnnotation)o.@Annotation), false, false);
            Write12_XmlSchemaSimpleType(@"simpleType", @"http://www.w3.org/2001/XMLSchema", ((System.Xml.Schema.XmlSchemaSimpleType)o.@BaseType), false, false);
            {
                System.Xml.Schema.XmlSchemaObjectCollection a = (System.Xml.Schema.XmlSchemaObjectCollection)o.@Facets;
                if (a != null) {
                    for (int ia = 0; ia < a.Count; ia++) {
                        System.Xml.Schema.XmlSchemaObject ai = a[ia];
                        {
                            if (ai is System.Xml.Schema.XmlSchemaLengthFacet) {
                                Write24_XmlSchemaLengthFacet(@"length", @"http://www.w3.org/2001/XMLSchema", ((System.Xml.Schema.XmlSchemaLengthFacet)ai), false, false);
                            }
                            else if (ai is System.Xml.Schema.XmlSchemaMaxInclusiveFacet) {
                                Write29_XmlSchemaMaxInclusiveFacet(@"maxInclusive", @"http://www.w3.org/2001/XMLSchema", ((System.Xml.Schema.XmlSchemaMaxInclusiveFacet)ai), false, false);
                            }
                            else if (ai is System.Xml.Schema.XmlSchemaMaxExclusiveFacet) {
                                Write30_XmlSchemaMaxExclusiveFacet(@"maxExclusive", @"http://www.w3.org/2001/XMLSchema", ((System.Xml.Schema.XmlSchemaMaxExclusiveFacet)ai), false, false);
                            }
                            else if (ai is System.Xml.Schema.XmlSchemaFractionDigitsFacet) {
                                Write34_XmlSchemaFractionDigitsFacet(@"fractionDigits", @"http://www.w3.org/2001/XMLSchema", ((System.Xml.Schema.XmlSchemaFractionDigitsFacet)ai), false, false);
                            }
                            else if (ai is System.Xml.Schema.XmlSchemaEnumerationFacet) {
                                Write28_XmlSchemaEnumerationFacet(@"enumeration", @"http://www.w3.org/2001/XMLSchema", ((System.Xml.Schema.XmlSchemaEnumerationFacet)ai), false, false);
                            }
                            else if (ai is System.Xml.Schema.XmlSchemaTotalDigitsFacet) {
                                Write33_XmlSchemaTotalDigitsFacet(@"totalDigits", @"http://www.w3.org/2001/XMLSchema", ((System.Xml.Schema.XmlSchemaTotalDigitsFacet)ai), false, false);
                            }
                            else if (ai is System.Xml.Schema.XmlSchemaMinLengthFacet) {
                                Write21_XmlSchemaMinLengthFacet(@"minLength", @"http://www.w3.org/2001/XMLSchema", ((System.Xml.Schema.XmlSchemaMinLengthFacet)ai), false, false);
                            }
                            else if (ai is System.Xml.Schema.XmlSchemaMinExclusiveFacet) {
                                Write32_XmlSchemaMinExclusiveFacet(@"minExclusive", @"http://www.w3.org/2001/XMLSchema", ((System.Xml.Schema.XmlSchemaMinExclusiveFacet)ai), false, false);
                            }
                            else if (ai is System.Xml.Schema.XmlSchemaMinInclusiveFacet) {
                                Write31_XmlSchemaMinInclusiveFacet(@"minInclusive", @"http://www.w3.org/2001/XMLSchema", ((System.Xml.Schema.XmlSchemaMinInclusiveFacet)ai), false, false);
                            }
                            else if (ai is System.Xml.Schema.XmlSchemaMaxLengthFacet) {
                                Write26_XmlSchemaMaxLengthFacet(@"maxLength", @"http://www.w3.org/2001/XMLSchema", ((System.Xml.Schema.XmlSchemaMaxLengthFacet)ai), false, false);
                            }
                            else if (ai is System.Xml.Schema.XmlSchemaWhiteSpaceFacet) {
                                Write25_XmlSchemaWhiteSpaceFacet(@"whiteSpace", @"http://www.w3.org/2001/XMLSchema", ((System.Xml.Schema.XmlSchemaWhiteSpaceFacet)ai), false, false);
                            }
                            else if (ai is System.Xml.Schema.XmlSchemaPatternFacet) {
                                Write27_XmlSchemaPatternFacet(@"pattern", @"http://www.w3.org/2001/XMLSchema", ((System.Xml.Schema.XmlSchemaPatternFacet)ai), false, false);
                            }
                            else {
                                if (ai != null) {
                                    throw CreateUnknownTypeException(ai);
                                }
                            }
                        }
                    }
                }
            }
            WriteEndElement(o);
        }

        void Write21_XmlSchemaMinLengthFacet(string n, string ns, System.Xml.Schema.XmlSchemaMinLengthFacet o, bool isNullable, bool needType) {
            if ((object)o == null) {
                if (isNullable) WriteNullTagLiteral(n, ns);
                return;
            }
            if (!needType) {
                System.Type t = o.GetType();
                if (t == typeof(System.Xml.Schema.XmlSchemaMinLengthFacet))
                    ;
                else {
                    throw CreateUnknownTypeException(o);
                }
            }
            WriteStartElement(n, ns, o);
            if (needType) WriteXsiType(@"XmlSchemaMinLengthFacet", @"http://www.w3.org/2001/XMLSchema");
            WriteNamespaceDeclarations(o.@Namespaces);
            WriteAttribute(@"id", @"", (System.String)o.@Id);
            {
                System.Xml.XmlAttribute[] a = (System.Xml.XmlAttribute[])o.@UnhandledAttributes;
                if (a != null) {
                    for (int i = 0; i < a.Length; i++) {
                        System.Xml.XmlAttribute ai = (System.Xml.XmlAttribute)a[i];
                        WriteXmlAttribute(ai, o);
                    }
                }
            }
            WriteAttribute(@"value", @"", (System.String)o.@Value);
            if ((System.Boolean)o.@IsFixed != false) {
                WriteAttribute(@"fixed", @"", System.Xml.XmlConvert.ToString((System.Boolean)(System.Boolean)o.@IsFixed));
            }
            Write15_XmlSchemaAnnotation(@"annotation", @"http://www.w3.org/2001/XMLSchema", ((System.Xml.Schema.XmlSchemaAnnotation)o.@Annotation), false, false);
            WriteEndElement(o);
        }

        void Write22_XmlSchemaNumericFacet(string n, string ns, System.Xml.Schema.XmlSchemaNumericFacet o, bool isNullable, bool needType) {
            if ((object)o == null) {
                if (isNullable) WriteNullTagLiteral(n, ns);
                return;
            }
            if (!needType) {
                System.Type t = o.GetType();
                if (t == typeof(System.Xml.Schema.XmlSchemaNumericFacet))
                    ;
                else if (t == typeof(System.Xml.Schema.XmlSchemaFractionDigitsFacet)) {
                    Write34_XmlSchemaFractionDigitsFacet(n, ns, (System.Xml.Schema.XmlSchemaFractionDigitsFacet)o, isNullable, true);
                    return;
                }
                else if (t == typeof(System.Xml.Schema.XmlSchemaTotalDigitsFacet)) {
                    Write33_XmlSchemaTotalDigitsFacet(n, ns, (System.Xml.Schema.XmlSchemaTotalDigitsFacet)o, isNullable, true);
                    return;
                }
                else if (t == typeof(System.Xml.Schema.XmlSchemaMaxLengthFacet)) {
                    Write26_XmlSchemaMaxLengthFacet(n, ns, (System.Xml.Schema.XmlSchemaMaxLengthFacet)o, isNullable, true);
                    return;
                }
                else if (t == typeof(System.Xml.Schema.XmlSchemaLengthFacet)) {
                    Write24_XmlSchemaLengthFacet(n, ns, (System.Xml.Schema.XmlSchemaLengthFacet)o, isNullable, true);
                    return;
                }
                else if (t == typeof(System.Xml.Schema.XmlSchemaMinLengthFacet)) {
                    Write21_XmlSchemaMinLengthFacet(n, ns, (System.Xml.Schema.XmlSchemaMinLengthFacet)o, isNullable, true);
                    return;
                }
                else {
                    throw CreateUnknownTypeException(o);
                }
            }
        }

        void Write23_XmlSchemaFacet(string n, string ns, System.Xml.Schema.XmlSchemaFacet o, bool isNullable, bool needType) {
            if ((object)o == null) {
                if (isNullable) WriteNullTagLiteral(n, ns);
                return;
            }
            if (!needType) {
                System.Type t = o.GetType();
                if (t == typeof(System.Xml.Schema.XmlSchemaFacet))
                    ;
                else if (t == typeof(System.Xml.Schema.XmlSchemaMinExclusiveFacet)) {
                    Write32_XmlSchemaMinExclusiveFacet(n, ns, (System.Xml.Schema.XmlSchemaMinExclusiveFacet)o, isNullable, true);
                    return;
                }
                else if (t == typeof(System.Xml.Schema.XmlSchemaMinInclusiveFacet)) {
                    Write31_XmlSchemaMinInclusiveFacet(n, ns, (System.Xml.Schema.XmlSchemaMinInclusiveFacet)o, isNullable, true);
                    return;
                }
                else if (t == typeof(System.Xml.Schema.XmlSchemaMaxExclusiveFacet)) {
                    Write30_XmlSchemaMaxExclusiveFacet(n, ns, (System.Xml.Schema.XmlSchemaMaxExclusiveFacet)o, isNullable, true);
                    return;
                }
                else if (t == typeof(System.Xml.Schema.XmlSchemaMaxInclusiveFacet)) {
                    Write29_XmlSchemaMaxInclusiveFacet(n, ns, (System.Xml.Schema.XmlSchemaMaxInclusiveFacet)o, isNullable, true);
                    return;
                }
                else if (t == typeof(System.Xml.Schema.XmlSchemaEnumerationFacet)) {
                    Write28_XmlSchemaEnumerationFacet(n, ns, (System.Xml.Schema.XmlSchemaEnumerationFacet)o, isNullable, true);
                    return;
                }
                else if (t == typeof(System.Xml.Schema.XmlSchemaPatternFacet)) {
                    Write27_XmlSchemaPatternFacet(n, ns, (System.Xml.Schema.XmlSchemaPatternFacet)o, isNullable, true);
                    return;
                }
                else if (t == typeof(System.Xml.Schema.XmlSchemaWhiteSpaceFacet)) {
                    Write25_XmlSchemaWhiteSpaceFacet(n, ns, (System.Xml.Schema.XmlSchemaWhiteSpaceFacet)o, isNullable, true);
                    return;
                }
                else if (t == typeof(System.Xml.Schema.XmlSchemaNumericFacet)) {
                    Write22_XmlSchemaNumericFacet(n, ns, (System.Xml.Schema.XmlSchemaNumericFacet)o, isNullable, true);
                    return;
                }
                else if (t == typeof(System.Xml.Schema.XmlSchemaFractionDigitsFacet)) {
                    Write34_XmlSchemaFractionDigitsFacet(n, ns, (System.Xml.Schema.XmlSchemaFractionDigitsFacet)o, isNullable, true);
                    return;
                }
                else if (t == typeof(System.Xml.Schema.XmlSchemaTotalDigitsFacet)) {
                    Write33_XmlSchemaTotalDigitsFacet(n, ns, (System.Xml.Schema.XmlSchemaTotalDigitsFacet)o, isNullable, true);
                    return;
                }
                else if (t == typeof(System.Xml.Schema.XmlSchemaMaxLengthFacet)) {
                    Write26_XmlSchemaMaxLengthFacet(n, ns, (System.Xml.Schema.XmlSchemaMaxLengthFacet)o, isNullable, true);
                    return;
                }
                else if (t == typeof(System.Xml.Schema.XmlSchemaLengthFacet)) {
                    Write24_XmlSchemaLengthFacet(n, ns, (System.Xml.Schema.XmlSchemaLengthFacet)o, isNullable, true);
                    return;
                }
                else if (t == typeof(System.Xml.Schema.XmlSchemaMinLengthFacet)) {
                    Write21_XmlSchemaMinLengthFacet(n, ns, (System.Xml.Schema.XmlSchemaMinLengthFacet)o, isNullable, true);
                    return;
                }
                else {
                    throw CreateUnknownTypeException(o);
                }
            }
        }

        void Write24_XmlSchemaLengthFacet(string n, string ns, System.Xml.Schema.XmlSchemaLengthFacet o, bool isNullable, bool needType) {
            if ((object)o == null) {
                if (isNullable) WriteNullTagLiteral(n, ns);
                return;
            }
            if (!needType) {
                System.Type t = o.GetType();
                if (t == typeof(System.Xml.Schema.XmlSchemaLengthFacet))
                    ;
                else {
                    throw CreateUnknownTypeException(o);
                }
            }
            WriteStartElement(n, ns, o);
            if (needType) WriteXsiType(@"XmlSchemaLengthFacet", @"http://www.w3.org/2001/XMLSchema");
            WriteNamespaceDeclarations(o.@Namespaces);
            WriteAttribute(@"id", @"", (System.String)o.@Id);
            {
                System.Xml.XmlAttribute[] a = (System.Xml.XmlAttribute[])o.@UnhandledAttributes;
                if (a != null) {
                    for (int i = 0; i < a.Length; i++) {
                        System.Xml.XmlAttribute ai = (System.Xml.XmlAttribute)a[i];
                        WriteXmlAttribute(ai, o);
                    }
                }
            }
            WriteAttribute(@"value", @"", (System.String)o.@Value);
            if ((System.Boolean)o.@IsFixed != false) {
                WriteAttribute(@"fixed", @"", System.Xml.XmlConvert.ToString((System.Boolean)(System.Boolean)o.@IsFixed));
            }
            Write15_XmlSchemaAnnotation(@"annotation", @"http://www.w3.org/2001/XMLSchema", ((System.Xml.Schema.XmlSchemaAnnotation)o.@Annotation), false, false);
            WriteEndElement(o);
        }

        void Write25_XmlSchemaWhiteSpaceFacet(string n, string ns, System.Xml.Schema.XmlSchemaWhiteSpaceFacet o, bool isNullable, bool needType) {
            if ((object)o == null) {
                if (isNullable) WriteNullTagLiteral(n, ns);
                return;
            }
            if (!needType) {
                System.Type t = o.GetType();
                if (t == typeof(System.Xml.Schema.XmlSchemaWhiteSpaceFacet))
                    ;
                else {
                    throw CreateUnknownTypeException(o);
                }
            }
            WriteStartElement(n, ns, o);
            if (needType) WriteXsiType(@"XmlSchemaWhiteSpaceFacet", @"http://www.w3.org/2001/XMLSchema");
            WriteNamespaceDeclarations(o.@Namespaces);
            WriteAttribute(@"id", @"", (System.String)o.@Id);
            {
                System.Xml.XmlAttribute[] a = (System.Xml.XmlAttribute[])o.@UnhandledAttributes;
                if (a != null) {
                    for (int i = 0; i < a.Length; i++) {
                        System.Xml.XmlAttribute ai = (System.Xml.XmlAttribute)a[i];
                        WriteXmlAttribute(ai, o);
                    }
                }
            }
            WriteAttribute(@"value", @"", (System.String)o.@Value);
            if ((System.Boolean)o.@IsFixed != false) {
                WriteAttribute(@"fixed", @"", System.Xml.XmlConvert.ToString((System.Boolean)(System.Boolean)o.@IsFixed));
            }
            Write15_XmlSchemaAnnotation(@"annotation", @"http://www.w3.org/2001/XMLSchema", ((System.Xml.Schema.XmlSchemaAnnotation)o.@Annotation), false, false);
            WriteEndElement(o);
        }

        void Write26_XmlSchemaMaxLengthFacet(string n, string ns, System.Xml.Schema.XmlSchemaMaxLengthFacet o, bool isNullable, bool needType) {
            if ((object)o == null) {
                if (isNullable) WriteNullTagLiteral(n, ns);
                return;
            }
            if (!needType) {
                System.Type t = o.GetType();
                if (t == typeof(System.Xml.Schema.XmlSchemaMaxLengthFacet))
                    ;
                else {
                    throw CreateUnknownTypeException(o);
                }
            }
            WriteStartElement(n, ns, o);
            if (needType) WriteXsiType(@"XmlSchemaMaxLengthFacet", @"http://www.w3.org/2001/XMLSchema");
            WriteNamespaceDeclarations(o.@Namespaces);
            WriteAttribute(@"id", @"", (System.String)o.@Id);
            {
                System.Xml.XmlAttribute[] a = (System.Xml.XmlAttribute[])o.@UnhandledAttributes;
                if (a != null) {
                    for (int i = 0; i < a.Length; i++) {
                        System.Xml.XmlAttribute ai = (System.Xml.XmlAttribute)a[i];
                        WriteXmlAttribute(ai, o);
                    }
                }
            }
            WriteAttribute(@"value", @"", (System.String)o.@Value);
            if ((System.Boolean)o.@IsFixed != false) {
                WriteAttribute(@"fixed", @"", System.Xml.XmlConvert.ToString((System.Boolean)(System.Boolean)o.@IsFixed));
            }
            Write15_XmlSchemaAnnotation(@"annotation", @"http://www.w3.org/2001/XMLSchema", ((System.Xml.Schema.XmlSchemaAnnotation)o.@Annotation), false, false);
            WriteEndElement(o);
        }

        void Write27_XmlSchemaPatternFacet(string n, string ns, System.Xml.Schema.XmlSchemaPatternFacet o, bool isNullable, bool needType) {
            if ((object)o == null) {
                if (isNullable) WriteNullTagLiteral(n, ns);
                return;
            }
            if (!needType) {
                System.Type t = o.GetType();
                if (t == typeof(System.Xml.Schema.XmlSchemaPatternFacet))
                    ;
                else {
                    throw CreateUnknownTypeException(o);
                }
            }
            WriteStartElement(n, ns, o);
            if (needType) WriteXsiType(@"XmlSchemaPatternFacet", @"http://www.w3.org/2001/XMLSchema");
            WriteNamespaceDeclarations(o.@Namespaces);
            WriteAttribute(@"id", @"", (System.String)o.@Id);
            {
                System.Xml.XmlAttribute[] a = (System.Xml.XmlAttribute[])o.@UnhandledAttributes;
                if (a != null) {
                    for (int i = 0; i < a.Length; i++) {
                        System.Xml.XmlAttribute ai = (System.Xml.XmlAttribute)a[i];
                        WriteXmlAttribute(ai, o);
                    }
                }
            }
            WriteAttribute(@"value", @"", (System.String)o.@Value);
            if ((System.Boolean)o.@IsFixed != false) {
                WriteAttribute(@"fixed", @"", System.Xml.XmlConvert.ToString((System.Boolean)(System.Boolean)o.@IsFixed));
            }
            Write15_XmlSchemaAnnotation(@"annotation", @"http://www.w3.org/2001/XMLSchema", ((System.Xml.Schema.XmlSchemaAnnotation)o.@Annotation), false, false);
            WriteEndElement(o);
        }

        void Write28_XmlSchemaEnumerationFacet(string n, string ns, System.Xml.Schema.XmlSchemaEnumerationFacet o, bool isNullable, bool needType) {
            if ((object)o == null) {
                if (isNullable) WriteNullTagLiteral(n, ns);
                return;
            }
            if (!needType) {
                System.Type t = o.GetType();
                if (t == typeof(System.Xml.Schema.XmlSchemaEnumerationFacet))
                    ;
                else {
                    throw CreateUnknownTypeException(o);
                }
            }
            WriteStartElement(n, ns, o);
            if (needType) WriteXsiType(@"XmlSchemaEnumerationFacet", @"http://www.w3.org/2001/XMLSchema");
            WriteNamespaceDeclarations(o.@Namespaces);
            WriteAttribute(@"id", @"", (System.String)o.@Id);
            {
                System.Xml.XmlAttribute[] a = (System.Xml.XmlAttribute[])o.@UnhandledAttributes;
                if (a != null) {
                    for (int i = 0; i < a.Length; i++) {
                        System.Xml.XmlAttribute ai = (System.Xml.XmlAttribute)a[i];
                        WriteXmlAttribute(ai, o);
                    }
                }
            }
            WriteAttribute(@"value", @"", (System.String)o.@Value);
            if ((System.Boolean)o.@IsFixed != false) {
                WriteAttribute(@"fixed", @"", System.Xml.XmlConvert.ToString((System.Boolean)(System.Boolean)o.@IsFixed));
            }
            Write15_XmlSchemaAnnotation(@"annotation", @"http://www.w3.org/2001/XMLSchema", ((System.Xml.Schema.XmlSchemaAnnotation)o.@Annotation), false, false);
            WriteEndElement(o);
        }

        void Write29_XmlSchemaMaxInclusiveFacet(string n, string ns, System.Xml.Schema.XmlSchemaMaxInclusiveFacet o, bool isNullable, bool needType) {
            if ((object)o == null) {
                if (isNullable) WriteNullTagLiteral(n, ns);
                return;
            }
            if (!needType) {
                System.Type t = o.GetType();
                if (t == typeof(System.Xml.Schema.XmlSchemaMaxInclusiveFacet))
                    ;
                else {
                    throw CreateUnknownTypeException(o);
                }
            }
            WriteStartElement(n, ns, o);
            if (needType) WriteXsiType(@"XmlSchemaMaxInclusiveFacet", @"http://www.w3.org/2001/XMLSchema");
            WriteNamespaceDeclarations(o.@Namespaces);
            WriteAttribute(@"id", @"", (System.String)o.@Id);
            {
                System.Xml.XmlAttribute[] a = (System.Xml.XmlAttribute[])o.@UnhandledAttributes;
                if (a != null) {
                    for (int i = 0; i < a.Length; i++) {
                        System.Xml.XmlAttribute ai = (System.Xml.XmlAttribute)a[i];
                        WriteXmlAttribute(ai, o);
                    }
                }
            }
            WriteAttribute(@"value", @"", (System.String)o.@Value);
            if ((System.Boolean)o.@IsFixed != false) {
                WriteAttribute(@"fixed", @"", System.Xml.XmlConvert.ToString((System.Boolean)(System.Boolean)o.@IsFixed));
            }
            Write15_XmlSchemaAnnotation(@"annotation", @"http://www.w3.org/2001/XMLSchema", ((System.Xml.Schema.XmlSchemaAnnotation)o.@Annotation), false, false);
            WriteEndElement(o);
        }

        void Write30_XmlSchemaMaxExclusiveFacet(string n, string ns, System.Xml.Schema.XmlSchemaMaxExclusiveFacet o, bool isNullable, bool needType) {
            if ((object)o == null) {
                if (isNullable) WriteNullTagLiteral(n, ns);
                return;
            }
            if (!needType) {
                System.Type t = o.GetType();
                if (t == typeof(System.Xml.Schema.XmlSchemaMaxExclusiveFacet))
                    ;
                else {
                    throw CreateUnknownTypeException(o);
                }
            }
            WriteStartElement(n, ns, o);
            if (needType) WriteXsiType(@"XmlSchemaMaxExclusiveFacet", @"http://www.w3.org/2001/XMLSchema");
            WriteNamespaceDeclarations(o.@Namespaces);
            WriteAttribute(@"id", @"", (System.String)o.@Id);
            {
                System.Xml.XmlAttribute[] a = (System.Xml.XmlAttribute[])o.@UnhandledAttributes;
                if (a != null) {
                    for (int i = 0; i < a.Length; i++) {
                        System.Xml.XmlAttribute ai = (System.Xml.XmlAttribute)a[i];
                        WriteXmlAttribute(ai, o);
                    }
                }
            }
            WriteAttribute(@"value", @"", (System.String)o.@Value);
            if ((System.Boolean)o.@IsFixed != false) {
                WriteAttribute(@"fixed", @"", System.Xml.XmlConvert.ToString((System.Boolean)(System.Boolean)o.@IsFixed));
            }
            Write15_XmlSchemaAnnotation(@"annotation", @"http://www.w3.org/2001/XMLSchema", ((System.Xml.Schema.XmlSchemaAnnotation)o.@Annotation), false, false);
            WriteEndElement(o);
        }

        void Write31_XmlSchemaMinInclusiveFacet(string n, string ns, System.Xml.Schema.XmlSchemaMinInclusiveFacet o, bool isNullable, bool needType) {
            if ((object)o == null) {
                if (isNullable) WriteNullTagLiteral(n, ns);
                return;
            }
            if (!needType) {
                System.Type t = o.GetType();
                if (t == typeof(System.Xml.Schema.XmlSchemaMinInclusiveFacet))
                    ;
                else {
                    throw CreateUnknownTypeException(o);
                }
            }
            WriteStartElement(n, ns, o);
            if (needType) WriteXsiType(@"XmlSchemaMinInclusiveFacet", @"http://www.w3.org/2001/XMLSchema");
            WriteNamespaceDeclarations(o.@Namespaces);
            WriteAttribute(@"id", @"", (System.String)o.@Id);
            {
                System.Xml.XmlAttribute[] a = (System.Xml.XmlAttribute[])o.@UnhandledAttributes;
                if (a != null) {
                    for (int i = 0; i < a.Length; i++) {
                        System.Xml.XmlAttribute ai = (System.Xml.XmlAttribute)a[i];
                        WriteXmlAttribute(ai, o);
                    }
                }
            }
            WriteAttribute(@"value", @"", (System.String)o.@Value);
            if ((System.Boolean)o.@IsFixed != false) {
                WriteAttribute(@"fixed", @"", System.Xml.XmlConvert.ToString((System.Boolean)(System.Boolean)o.@IsFixed));
            }
            Write15_XmlSchemaAnnotation(@"annotation", @"http://www.w3.org/2001/XMLSchema", ((System.Xml.Schema.XmlSchemaAnnotation)o.@Annotation), false, false);
            WriteEndElement(o);
        }

        void Write32_XmlSchemaMinExclusiveFacet(string n, string ns, System.Xml.Schema.XmlSchemaMinExclusiveFacet o, bool isNullable, bool needType) {
            if ((object)o == null) {
                if (isNullable) WriteNullTagLiteral(n, ns);
                return;
            }
            if (!needType) {
                System.Type t = o.GetType();
                if (t == typeof(System.Xml.Schema.XmlSchemaMinExclusiveFacet))
                    ;
                else {
                    throw CreateUnknownTypeException(o);
                }
            }
            WriteStartElement(n, ns, o);
            if (needType) WriteXsiType(@"XmlSchemaMinExclusiveFacet", @"http://www.w3.org/2001/XMLSchema");
            WriteNamespaceDeclarations(o.@Namespaces);
            WriteAttribute(@"id", @"", (System.String)o.@Id);
            {
                System.Xml.XmlAttribute[] a = (System.Xml.XmlAttribute[])o.@UnhandledAttributes;
                if (a != null) {
                    for (int i = 0; i < a.Length; i++) {
                        System.Xml.XmlAttribute ai = (System.Xml.XmlAttribute)a[i];
                        WriteXmlAttribute(ai, o);
                    }
                }
            }
            WriteAttribute(@"value", @"", (System.String)o.@Value);
            if ((System.Boolean)o.@IsFixed != false) {
                WriteAttribute(@"fixed", @"", System.Xml.XmlConvert.ToString((System.Boolean)(System.Boolean)o.@IsFixed));
            }
            Write15_XmlSchemaAnnotation(@"annotation", @"http://www.w3.org/2001/XMLSchema", ((System.Xml.Schema.XmlSchemaAnnotation)o.@Annotation), false, false);
            WriteEndElement(o);
        }

        void Write33_XmlSchemaTotalDigitsFacet(string n, string ns, System.Xml.Schema.XmlSchemaTotalDigitsFacet o, bool isNullable, bool needType) {
            if ((object)o == null) {
                if (isNullable) WriteNullTagLiteral(n, ns);
                return;
            }
            if (!needType) {
                System.Type t = o.GetType();
                if (t == typeof(System.Xml.Schema.XmlSchemaTotalDigitsFacet))
                    ;
                else {
                    throw CreateUnknownTypeException(o);
                }
            }
            WriteStartElement(n, ns, o);
            if (needType) WriteXsiType(@"XmlSchemaTotalDigitsFacet", @"http://www.w3.org/2001/XMLSchema");
            WriteNamespaceDeclarations(o.@Namespaces);
            WriteAttribute(@"id", @"", (System.String)o.@Id);
            {
                System.Xml.XmlAttribute[] a = (System.Xml.XmlAttribute[])o.@UnhandledAttributes;
                if (a != null) {
                    for (int i = 0; i < a.Length; i++) {
                        System.Xml.XmlAttribute ai = (System.Xml.XmlAttribute)a[i];
                        WriteXmlAttribute(ai, o);
                    }
                }
            }
            WriteAttribute(@"value", @"", (System.String)o.@Value);
            if ((System.Boolean)o.@IsFixed != false) {
                WriteAttribute(@"fixed", @"", System.Xml.XmlConvert.ToString((System.Boolean)(System.Boolean)o.@IsFixed));
            }
            Write15_XmlSchemaAnnotation(@"annotation", @"http://www.w3.org/2001/XMLSchema", ((System.Xml.Schema.XmlSchemaAnnotation)o.@Annotation), false, false);
            WriteEndElement(o);
        }

        void Write34_XmlSchemaFractionDigitsFacet(string n, string ns, System.Xml.Schema.XmlSchemaFractionDigitsFacet o, bool isNullable, bool needType) {
            if ((object)o == null) {
                if (isNullable) WriteNullTagLiteral(n, ns);
                return;
            }
            if (!needType) {
                System.Type t = o.GetType();
                if (t == typeof(System.Xml.Schema.XmlSchemaFractionDigitsFacet))
                    ;
                else {
                    throw CreateUnknownTypeException(o);
                }
            }
            WriteStartElement(n, ns, o);
            if (needType) WriteXsiType(@"XmlSchemaFractionDigitsFacet", @"http://www.w3.org/2001/XMLSchema");
            WriteNamespaceDeclarations(o.@Namespaces);
            WriteAttribute(@"id", @"", (System.String)o.@Id);
            {
                System.Xml.XmlAttribute[] a = (System.Xml.XmlAttribute[])o.@UnhandledAttributes;
                if (a != null) {
                    for (int i = 0; i < a.Length; i++) {
                        System.Xml.XmlAttribute ai = (System.Xml.XmlAttribute)a[i];
                        WriteXmlAttribute(ai, o);
                    }
                }
            }
            WriteAttribute(@"value", @"", (System.String)o.@Value);
            if ((System.Boolean)o.@IsFixed != false) {
                WriteAttribute(@"fixed", @"", System.Xml.XmlConvert.ToString((System.Boolean)(System.Boolean)o.@IsFixed));
            }
            Write15_XmlSchemaAnnotation(@"annotation", @"http://www.w3.org/2001/XMLSchema", ((System.Xml.Schema.XmlSchemaAnnotation)o.@Annotation), false, false);
            WriteEndElement(o);
        }

        void Write35_XmlSchemaSimpleTypeUnion(string n, string ns, System.Xml.Schema.XmlSchemaSimpleTypeUnion o, bool isNullable, bool needType) {
            if ((object)o == null) {
                if (isNullable) WriteNullTagLiteral(n, ns);
                return;
            }
            if (!needType) {
                System.Type t = o.GetType();
                if (t == typeof(System.Xml.Schema.XmlSchemaSimpleTypeUnion))
                    ;
                else {
                    throw CreateUnknownTypeException(o);
                }
            }
            WriteStartElement(n, ns, o);
            if (needType) WriteXsiType(@"XmlSchemaSimpleTypeUnion", @"http://www.w3.org/2001/XMLSchema");
            WriteNamespaceDeclarations(o.@Namespaces);
            WriteAttribute(@"id", @"", (System.String)o.@Id);
            {
                System.Xml.XmlAttribute[] a = (System.Xml.XmlAttribute[])o.@UnhandledAttributes;
                if (a != null) {
                    for (int i = 0; i < a.Length; i++) {
                        System.Xml.XmlAttribute ai = (System.Xml.XmlAttribute)a[i];
                        WriteXmlAttribute(ai, o);
                    }
                }
            }
            {
                System.Xml.XmlQualifiedName[] a = (System.Xml.XmlQualifiedName[])o.@MemberTypes;
                if (a != null) {
                    System.Text.StringBuilder sb = new System.Text.StringBuilder();
                    for (int i = 0; i < a.Length; i++) {
                        System.Xml.XmlQualifiedName ai = (System.Xml.XmlQualifiedName)a[i];
                        if (i != 0) sb.Append(" ");
                        sb.Append(FromXmlQualifiedName(ai));
                    }
                    if (sb.Length != 0) {
                        WriteAttribute(@"memberTypes", @"", sb.ToString());
                    }
                }
            }
            Write15_XmlSchemaAnnotation(@"annotation", @"http://www.w3.org/2001/XMLSchema", ((System.Xml.Schema.XmlSchemaAnnotation)o.@Annotation), false, false);
            {
                System.Xml.Schema.XmlSchemaObjectCollection a = (System.Xml.Schema.XmlSchemaObjectCollection)o.@BaseTypes;
                if (a != null) {
                    for (int ia = 0; ia < a.Count; ia++) {
                        Write12_XmlSchemaSimpleType(@"simpleType", @"http://www.w3.org/2001/XMLSchema", ((System.Xml.Schema.XmlSchemaSimpleType)a[ia]), false, false);
                    }
                }
            }
            WriteEndElement(o);
        }

        void Write36_XmlSchemaAttributeGroup(string n, string ns, System.Xml.Schema.XmlSchemaAttributeGroup o, bool isNullable, bool needType) {
            if ((object)o == null) {
                if (isNullable) WriteNullTagLiteral(n, ns);
                return;
            }
            if (!needType) {
                System.Type t = o.GetType();
                if (t == typeof(System.Xml.Schema.XmlSchemaAttributeGroup))
                    ;
                else {
                    throw CreateUnknownTypeException(o);
                }
            }
            WriteStartElement(n, ns, o);
            if (needType) WriteXsiType(@"XmlSchemaAttributeGroup", @"http://www.w3.org/2001/XMLSchema");
            WriteNamespaceDeclarations(o.@Namespaces);
            WriteAttribute(@"id", @"", (System.String)o.@Id);
            {
                System.Xml.XmlAttribute[] a = (System.Xml.XmlAttribute[])o.@UnhandledAttributes;
                if (a != null) {
                    for (int i = 0; i < a.Length; i++) {
                        System.Xml.XmlAttribute ai = (System.Xml.XmlAttribute)a[i];
                        WriteXmlAttribute(ai, o);
                    }
                }
            }
            WriteAttribute(@"name", @"", (System.String)o.@Name);
            Write15_XmlSchemaAnnotation(@"annotation", @"http://www.w3.org/2001/XMLSchema", ((System.Xml.Schema.XmlSchemaAnnotation)o.@Annotation), false, false);
            {
                System.Xml.Schema.XmlSchemaObjectCollection a = (System.Xml.Schema.XmlSchemaObjectCollection)o.@Attributes;
                if (a != null) {
                    for (int ia = 0; ia < a.Count; ia++) {
                        System.Xml.Schema.XmlSchemaObject ai = a[ia];
                        {
                            if (ai is System.Xml.Schema.XmlSchemaAttribute) {
                                Write37_XmlSchemaAttribute(@"attribute", @"http://www.w3.org/2001/XMLSchema", ((System.Xml.Schema.XmlSchemaAttribute)ai), false, false);
                            }
                            else if (ai is System.Xml.Schema.XmlSchemaAttributeGroupRef) {
                                Write39_XmlSchemaAttributeGroupRef(@"attributeGroup", @"http://www.w3.org/2001/XMLSchema", ((System.Xml.Schema.XmlSchemaAttributeGroupRef)ai), false, false);
                            }
                            else {
                                if (ai != null) {
                                    throw CreateUnknownTypeException(ai);
                                }
                            }
                        }
                    }
                }
            }
            Write40_XmlSchemaAnyAttribute(@"anyAttribute", @"http://www.w3.org/2001/XMLSchema", ((System.Xml.Schema.XmlSchemaAnyAttribute)o.@AnyAttribute), false, false);
            WriteEndElement(o);
        }

        void Write37_XmlSchemaAttribute(string n, string ns, System.Xml.Schema.XmlSchemaAttribute o, bool isNullable, bool needType) {
            if ((object)o == null) {
                if (isNullable) WriteNullTagLiteral(n, ns);
                return;
            }
            if (!needType) {
                System.Type t = o.GetType();
                if (t == typeof(System.Xml.Schema.XmlSchemaAttribute))
                    ;
                else {
                    throw CreateUnknownTypeException(o);
                }
            }
            WriteStartElement(n, ns, o);
            if (needType) WriteXsiType(@"XmlSchemaAttribute", @"http://www.w3.org/2001/XMLSchema");
            WriteNamespaceDeclarations(o.@Namespaces);
            WriteAttribute(@"id", @"", (System.String)o.@Id);
            {
                System.Xml.XmlAttribute[] a = (System.Xml.XmlAttribute[])o.@UnhandledAttributes;
                if (a != null) {
                    for (int i = 0; i < a.Length; i++) {
                        System.Xml.XmlAttribute ai = (System.Xml.XmlAttribute)a[i];
                        WriteXmlAttribute(ai, o);
                    }
                }
            }
            if ((System.String)o.@DefaultValue != null) {
                WriteAttribute(@"default", @"", (System.String)o.@DefaultValue);
            }
            if ((System.String)o.@FixedValue != null) {
                WriteAttribute(@"fixed", @"", (System.String)o.@FixedValue);
            }
            if ((System.Xml.Schema.XmlSchemaForm)o.@Form != System.Xml.Schema.XmlSchemaForm.@None) {
                WriteAttribute(@"form", @"", Write8_XmlSchemaForm((System.Xml.Schema.XmlSchemaForm)o.@Form));
            }
            WriteAttribute(@"name", @"", (System.String)o.@Name);
            WriteAttribute(@"ref", @"", FromXmlQualifiedName((System.Xml.XmlQualifiedName)o.@RefName));
            WriteAttribute(@"type", @"", FromXmlQualifiedName((System.Xml.XmlQualifiedName)o.@SchemaTypeName));
            if ((System.Xml.Schema.XmlSchemaUse)o.@Use != System.Xml.Schema.XmlSchemaUse.@None) {
                WriteAttribute(@"use", @"", Write38_XmlSchemaUse((System.Xml.Schema.XmlSchemaUse)o.@Use));
            }
            Write15_XmlSchemaAnnotation(@"annotation", @"http://www.w3.org/2001/XMLSchema", ((System.Xml.Schema.XmlSchemaAnnotation)o.@Annotation), false, false);
            Write12_XmlSchemaSimpleType(@"simpleType", @"http://www.w3.org/2001/XMLSchema", ((System.Xml.Schema.XmlSchemaSimpleType)o.@SchemaType), false, false);
            WriteEndElement(o);
        }

        string Write38_XmlSchemaUse(System.Xml.Schema.XmlSchemaUse v) {
            string s = null;
            switch (v) {
                case System.Xml.Schema.XmlSchemaUse.@Optional: s = @"optional"; break;
                case System.Xml.Schema.XmlSchemaUse.@Prohibited: s = @"prohibited"; break;
                case System.Xml.Schema.XmlSchemaUse.@Required: s = @"required"; break;
                default: s = ((System.Int64)v).ToString(); break;
            }
            return s;
        }

        void Write39_XmlSchemaAttributeGroupRef(string n, string ns, System.Xml.Schema.XmlSchemaAttributeGroupRef o, bool isNullable, bool needType) {
            if ((object)o == null) {
                if (isNullable) WriteNullTagLiteral(n, ns);
                return;
            }
            if (!needType) {
                System.Type t = o.GetType();
                if (t == typeof(System.Xml.Schema.XmlSchemaAttributeGroupRef))
                    ;
                else {
                    throw CreateUnknownTypeException(o);
                }
            }
            WriteStartElement(n, ns, o);
            if (needType) WriteXsiType(@"XmlSchemaAttributeGroupRef", @"http://www.w3.org/2001/XMLSchema");
            WriteNamespaceDeclarations(o.@Namespaces);
            WriteAttribute(@"id", @"", (System.String)o.@Id);
            {
                System.Xml.XmlAttribute[] a = (System.Xml.XmlAttribute[])o.@UnhandledAttributes;
                if (a != null) {
                    for (int i = 0; i < a.Length; i++) {
                        System.Xml.XmlAttribute ai = (System.Xml.XmlAttribute)a[i];
                        WriteXmlAttribute(ai, o);
                    }
                }
            }
            WriteAttribute(@"ref", @"", FromXmlQualifiedName((System.Xml.XmlQualifiedName)o.@RefName));
            Write15_XmlSchemaAnnotation(@"annotation", @"http://www.w3.org/2001/XMLSchema", ((System.Xml.Schema.XmlSchemaAnnotation)o.@Annotation), false, false);
            WriteEndElement(o);
        }

        void Write40_XmlSchemaAnyAttribute(string n, string ns, System.Xml.Schema.XmlSchemaAnyAttribute o, bool isNullable, bool needType) {
            if ((object)o == null) {
                if (isNullable) WriteNullTagLiteral(n, ns);
                return;
            }
            if (!needType) {
                System.Type t = o.GetType();
                if (t == typeof(System.Xml.Schema.XmlSchemaAnyAttribute))
                    ;
                else {
                    throw CreateUnknownTypeException(o);
                }
            }
            WriteStartElement(n, ns, o);
            if (needType) WriteXsiType(@"XmlSchemaAnyAttribute", @"http://www.w3.org/2001/XMLSchema");
            WriteNamespaceDeclarations(o.@Namespaces);
            WriteAttribute(@"id", @"", (System.String)o.@Id);
            {
                System.Xml.XmlAttribute[] a = (System.Xml.XmlAttribute[])o.@UnhandledAttributes;
                if (a != null) {
                    for (int i = 0; i < a.Length; i++) {
                        System.Xml.XmlAttribute ai = (System.Xml.XmlAttribute)a[i];
                        WriteXmlAttribute(ai, o);
                    }
                }
            }
            WriteAttribute(@"namespace", @"", (System.String)o.@Namespace);
            if ((System.Xml.Schema.XmlSchemaContentProcessing)o.@ProcessContents != System.Xml.Schema.XmlSchemaContentProcessing.@None) {
                WriteAttribute(@"processContents", @"", Write41_XmlSchemaContentProcessing((System.Xml.Schema.XmlSchemaContentProcessing)o.@ProcessContents));
            }
            Write15_XmlSchemaAnnotation(@"annotation", @"http://www.w3.org/2001/XMLSchema", ((System.Xml.Schema.XmlSchemaAnnotation)o.@Annotation), false, false);
            WriteEndElement(o);
        }

        string Write41_XmlSchemaContentProcessing(System.Xml.Schema.XmlSchemaContentProcessing v) {
            string s = null;
            switch (v) {
                case System.Xml.Schema.XmlSchemaContentProcessing.@Skip: s = @"skip"; break;
                case System.Xml.Schema.XmlSchemaContentProcessing.@Lax: s = @"lax"; break;
                case System.Xml.Schema.XmlSchemaContentProcessing.@Strict: s = @"strict"; break;
                default: s = ((System.Int64)v).ToString(); break;
            }
            return s;
        }

        void Write42_XmlSchemaComplexType(string n, string ns, System.Xml.Schema.XmlSchemaComplexType o, bool isNullable, bool needType) {
            if ((object)o == null) {
                if (isNullable) WriteNullTagLiteral(n, ns);
                return;
            }
            if (!needType) {
                System.Type t = o.GetType();
                if (t == typeof(System.Xml.Schema.XmlSchemaComplexType))
                    ;
                else {
                    throw CreateUnknownTypeException(o);
                }
            }
            WriteStartElement(n, ns, o);
            if (needType) WriteXsiType(@"XmlSchemaComplexType", @"http://www.w3.org/2001/XMLSchema");
            WriteNamespaceDeclarations(o.@Namespaces);
            WriteAttribute(@"id", @"", (System.String)o.@Id);
            {
                System.Xml.XmlAttribute[] a = (System.Xml.XmlAttribute[])o.@UnhandledAttributes;
                if (a != null) {
                    for (int i = 0; i < a.Length; i++) {
                        System.Xml.XmlAttribute ai = (System.Xml.XmlAttribute)a[i];
                        WriteXmlAttribute(ai, o);
                    }
                }
            }
            WriteAttribute(@"name", @"", (System.String)o.@Name);
            if ((System.Xml.Schema.XmlSchemaDerivationMethod)o.@Final != (System.Xml.Schema.XmlSchemaDerivationMethod.@None)) {
                WriteAttribute(@"final", @"", Write9_XmlSchemaDerivationMethod((System.Xml.Schema.XmlSchemaDerivationMethod)o.@Final));
            }
            if ((System.Boolean)o.@IsAbstract != false) {
                WriteAttribute(@"abstract", @"", System.Xml.XmlConvert.ToString((System.Boolean)(System.Boolean)o.@IsAbstract));
            }
            if ((System.Xml.Schema.XmlSchemaDerivationMethod)o.@Block != (System.Xml.Schema.XmlSchemaDerivationMethod.@None)) {
                WriteAttribute(@"block", @"", Write9_XmlSchemaDerivationMethod((System.Xml.Schema.XmlSchemaDerivationMethod)o.@Block));
            }
            if ((System.Boolean)o.@IsMixed != false) {
                WriteAttribute(@"mixed", @"", System.Xml.XmlConvert.ToString((System.Boolean)(System.Boolean)o.@IsMixed));
            }
            Write15_XmlSchemaAnnotation(@"annotation", @"http://www.w3.org/2001/XMLSchema", ((System.Xml.Schema.XmlSchemaAnnotation)o.@Annotation), false, false);
            {
                if (o.@ContentModel is System.Xml.Schema.XmlSchemaComplexContent) {
                    Write43_XmlSchemaComplexContent(@"complexContent", @"http://www.w3.org/2001/XMLSchema", ((System.Xml.Schema.XmlSchemaComplexContent)o.@ContentModel), false, false);
                }
                else if (o.@ContentModel is System.Xml.Schema.XmlSchemaSimpleContent) {
                    Write61_XmlSchemaSimpleContent(@"simpleContent", @"http://www.w3.org/2001/XMLSchema", ((System.Xml.Schema.XmlSchemaSimpleContent)o.@ContentModel), false, false);
                }
                else {
                    if (o.@ContentModel != null) {
                        throw CreateUnknownTypeException(o.@ContentModel);
                    }
                }
            }
            {
                if (o.@Particle is System.Xml.Schema.XmlSchemaSequence) {
                    Write47_XmlSchemaSequence(@"sequence", @"http://www.w3.org/2001/XMLSchema", ((System.Xml.Schema.XmlSchemaSequence)o.@Particle), false, false);
                }
                else if (o.@Particle is System.Xml.Schema.XmlSchemaChoice) {
                    Write58_XmlSchemaChoice(@"choice", @"http://www.w3.org/2001/XMLSchema", ((System.Xml.Schema.XmlSchemaChoice)o.@Particle), false, false);
                }
                else if (o.@Particle is System.Xml.Schema.XmlSchemaGroupRef) {
                    Write57_XmlSchemaGroupRef(@"group", @"http://www.w3.org/2001/XMLSchema", ((System.Xml.Schema.XmlSchemaGroupRef)o.@Particle), false, false);
                }
                else if (o.@Particle is System.Xml.Schema.XmlSchemaAll) {
                    Write59_XmlSchemaAll(@"all", @"http://www.w3.org/2001/XMLSchema", ((System.Xml.Schema.XmlSchemaAll)o.@Particle), false, false);
                }
                else {
                    if (o.@Particle != null) {
                        throw CreateUnknownTypeException(o.@Particle);
                    }
                }
            }
            {
                System.Xml.Schema.XmlSchemaObjectCollection a = (System.Xml.Schema.XmlSchemaObjectCollection)o.@Attributes;
                if (a != null) {
                    for (int ia = 0; ia < a.Count; ia++) {
                        System.Xml.Schema.XmlSchemaObject ai = a[ia];
                        {
                            if (ai is System.Xml.Schema.XmlSchemaAttribute) {
                                Write37_XmlSchemaAttribute(@"attribute", @"http://www.w3.org/2001/XMLSchema", ((System.Xml.Schema.XmlSchemaAttribute)ai), false, false);
                            }
                            else if (ai is System.Xml.Schema.XmlSchemaAttributeGroupRef) {
                                Write39_XmlSchemaAttributeGroupRef(@"attributeGroup", @"http://www.w3.org/2001/XMLSchema", ((System.Xml.Schema.XmlSchemaAttributeGroupRef)ai), false, false);
                            }
                            else {
                                if (ai != null) {
                                    throw CreateUnknownTypeException(ai);
                                }
                            }
                        }
                    }
                }
            }
            Write40_XmlSchemaAnyAttribute(@"anyAttribute", @"http://www.w3.org/2001/XMLSchema", ((System.Xml.Schema.XmlSchemaAnyAttribute)o.@AnyAttribute), false, false);
            WriteEndElement(o);
        }

        void Write43_XmlSchemaComplexContent(string n, string ns, System.Xml.Schema.XmlSchemaComplexContent o, bool isNullable, bool needType) {
            if ((object)o == null) {
                if (isNullable) WriteNullTagLiteral(n, ns);
                return;
            }
            if (!needType) {
                System.Type t = o.GetType();
                if (t == typeof(System.Xml.Schema.XmlSchemaComplexContent))
                    ;
                else {
                    throw CreateUnknownTypeException(o);
                }
            }
            WriteStartElement(n, ns, o);
            if (needType) WriteXsiType(@"XmlSchemaComplexContent", @"http://www.w3.org/2001/XMLSchema");
            WriteNamespaceDeclarations(o.@Namespaces);
            WriteAttribute(@"id", @"", (System.String)o.@Id);
            {
                System.Xml.XmlAttribute[] a = (System.Xml.XmlAttribute[])o.@UnhandledAttributes;
                if (a != null) {
                    for (int i = 0; i < a.Length; i++) {
                        System.Xml.XmlAttribute ai = (System.Xml.XmlAttribute)a[i];
                        WriteXmlAttribute(ai, o);
                    }
                }
            }
            WriteAttribute(@"mixed", @"", System.Xml.XmlConvert.ToString((System.Boolean)(System.Boolean)o.@IsMixed));
            Write15_XmlSchemaAnnotation(@"annotation", @"http://www.w3.org/2001/XMLSchema", ((System.Xml.Schema.XmlSchemaAnnotation)o.@Annotation), false, false);
            {
                if (o.@Content is System.Xml.Schema.XmlSchemaComplexContentRestriction) {
                    Write60_XmlSchemaComplexContentRestriction(@"restriction", @"http://www.w3.org/2001/XMLSchema", ((System.Xml.Schema.XmlSchemaComplexContentRestriction)o.@Content), false, false);
                }
                else if (o.@Content is System.Xml.Schema.XmlSchemaComplexContentExtension) {
                    Write45_XmlSchemaComplexContentExtension(@"extension", @"http://www.w3.org/2001/XMLSchema", ((System.Xml.Schema.XmlSchemaComplexContentExtension)o.@Content), false, false);
                }
                else {
                    if (o.@Content != null) {
                        throw CreateUnknownTypeException(o.@Content);
                    }
                }
            }
            WriteEndElement(o);
        }

        void Write44_XmlSchemaContentModel(string n, string ns, System.Xml.Schema.XmlSchemaContentModel o, bool isNullable, bool needType) {
            if ((object)o == null) {
                if (isNullable) WriteNullTagLiteral(n, ns);
                return;
            }
            if (!needType) {
                System.Type t = o.GetType();
                if (t == typeof(System.Xml.Schema.XmlSchemaContentModel))
                    ;
                else if (t == typeof(System.Xml.Schema.XmlSchemaSimpleContent)) {
                    Write61_XmlSchemaSimpleContent(n, ns, (System.Xml.Schema.XmlSchemaSimpleContent)o, isNullable, true);
                    return;
                }
                else if (t == typeof(System.Xml.Schema.XmlSchemaComplexContent)) {
                    Write43_XmlSchemaComplexContent(n, ns, (System.Xml.Schema.XmlSchemaComplexContent)o, isNullable, true);
                    return;
                }
                else {
                    throw CreateUnknownTypeException(o);
                }
            }
        }

        void Write45_XmlSchemaComplexContentExtension(string n, string ns, System.Xml.Schema.XmlSchemaComplexContentExtension o, bool isNullable, bool needType) {
            if ((object)o == null) {
                if (isNullable) WriteNullTagLiteral(n, ns);
                return;
            }
            if (!needType) {
                System.Type t = o.GetType();
                if (t == typeof(System.Xml.Schema.XmlSchemaComplexContentExtension))
                    ;
                else {
                    throw CreateUnknownTypeException(o);
                }
            }
            WriteStartElement(n, ns, o);
            if (needType) WriteXsiType(@"XmlSchemaComplexContentExtension", @"http://www.w3.org/2001/XMLSchema");
            WriteNamespaceDeclarations(o.@Namespaces);
            WriteAttribute(@"id", @"", (System.String)o.@Id);
            {
                System.Xml.XmlAttribute[] a = (System.Xml.XmlAttribute[])o.@UnhandledAttributes;
                if (a != null) {
                    for (int i = 0; i < a.Length; i++) {
                        System.Xml.XmlAttribute ai = (System.Xml.XmlAttribute)a[i];
                        WriteXmlAttribute(ai, o);
                    }
                }
            }
            WriteAttribute(@"base", @"", FromXmlQualifiedName((System.Xml.XmlQualifiedName)o.@BaseTypeName));
            Write15_XmlSchemaAnnotation(@"annotation", @"http://www.w3.org/2001/XMLSchema", ((System.Xml.Schema.XmlSchemaAnnotation)o.@Annotation), false, false);
            {
                if (o.@Particle is System.Xml.Schema.XmlSchemaSequence) {
                    Write47_XmlSchemaSequence(@"sequence", @"http://www.w3.org/2001/XMLSchema", ((System.Xml.Schema.XmlSchemaSequence)o.@Particle), false, false);
                }
                else if (o.@Particle is System.Xml.Schema.XmlSchemaChoice) {
                    Write58_XmlSchemaChoice(@"choice", @"http://www.w3.org/2001/XMLSchema", ((System.Xml.Schema.XmlSchemaChoice)o.@Particle), false, false);
                }
                else if (o.@Particle is System.Xml.Schema.XmlSchemaGroupRef) {
                    Write57_XmlSchemaGroupRef(@"group", @"http://www.w3.org/2001/XMLSchema", ((System.Xml.Schema.XmlSchemaGroupRef)o.@Particle), false, false);
                }
                else if (o.@Particle is System.Xml.Schema.XmlSchemaAll) {
                    Write59_XmlSchemaAll(@"all", @"http://www.w3.org/2001/XMLSchema", ((System.Xml.Schema.XmlSchemaAll)o.@Particle), false, false);
                }
                else {
                    if (o.@Particle != null) {
                        throw CreateUnknownTypeException(o.@Particle);
                    }
                }
            }
            {
                System.Xml.Schema.XmlSchemaObjectCollection a = (System.Xml.Schema.XmlSchemaObjectCollection)o.@Attributes;
                if (a != null) {
                    for (int ia = 0; ia < a.Count; ia++) {
                        System.Xml.Schema.XmlSchemaObject ai = a[ia];
                        {
                            if (ai is System.Xml.Schema.XmlSchemaAttribute) {
                                Write37_XmlSchemaAttribute(@"attribute", @"http://www.w3.org/2001/XMLSchema", ((System.Xml.Schema.XmlSchemaAttribute)ai), false, false);
                            }
                            else if (ai is System.Xml.Schema.XmlSchemaAttributeGroupRef) {
                                Write39_XmlSchemaAttributeGroupRef(@"attributeGroup", @"http://www.w3.org/2001/XMLSchema", ((System.Xml.Schema.XmlSchemaAttributeGroupRef)ai), false, false);
                            }
                            else {
                                if (ai != null) {
                                    throw CreateUnknownTypeException(ai);
                                }
                            }
                        }
                    }
                }
            }
            Write40_XmlSchemaAnyAttribute(@"anyAttribute", @"http://www.w3.org/2001/XMLSchema", ((System.Xml.Schema.XmlSchemaAnyAttribute)o.@AnyAttribute), false, false);
            WriteEndElement(o);
        }

        void Write46_XmlSchemaContent(string n, string ns, System.Xml.Schema.XmlSchemaContent o, bool isNullable, bool needType) {
            if ((object)o == null) {
                if (isNullable) WriteNullTagLiteral(n, ns);
                return;
            }
            if (!needType) {
                System.Type t = o.GetType();
                if (t == typeof(System.Xml.Schema.XmlSchemaContent))
                    ;
                else if (t == typeof(System.Xml.Schema.XmlSchemaSimpleContentExtension)) {
                    Write63_XmlSchemaSimpleContentExtension(n, ns, (System.Xml.Schema.XmlSchemaSimpleContentExtension)o, isNullable, true);
                    return;
                }
                else if (t == typeof(System.Xml.Schema.XmlSchemaSimpleContentRestriction)) {
                    Write62_XmlSchemaSimpleContentRestriction(n, ns, (System.Xml.Schema.XmlSchemaSimpleContentRestriction)o, isNullable, true);
                    return;
                }
                else if (t == typeof(System.Xml.Schema.XmlSchemaComplexContentRestriction)) {
                    Write60_XmlSchemaComplexContentRestriction(n, ns, (System.Xml.Schema.XmlSchemaComplexContentRestriction)o, isNullable, true);
                    return;
                }
                else if (t == typeof(System.Xml.Schema.XmlSchemaComplexContentExtension)) {
                    Write45_XmlSchemaComplexContentExtension(n, ns, (System.Xml.Schema.XmlSchemaComplexContentExtension)o, isNullable, true);
                    return;
                }
                else {
                    throw CreateUnknownTypeException(o);
                }
            }
        }

        void Write47_XmlSchemaSequence(string n, string ns, System.Xml.Schema.XmlSchemaSequence o, bool isNullable, bool needType) {
            if ((object)o == null) {
                if (isNullable) WriteNullTagLiteral(n, ns);
                return;
            }
            if (!needType) {
                System.Type t = o.GetType();
                if (t == typeof(System.Xml.Schema.XmlSchemaSequence))
                    ;
                else {
                    throw CreateUnknownTypeException(o);
                }
            }
            WriteStartElement(n, ns, o);
            if (needType) WriteXsiType(@"XmlSchemaSequence", @"http://www.w3.org/2001/XMLSchema");
            WriteNamespaceDeclarations(o.@Namespaces);
            WriteAttribute(@"id", @"", (System.String)o.@Id);
            {
                System.Xml.XmlAttribute[] a = (System.Xml.XmlAttribute[])o.@UnhandledAttributes;
                if (a != null) {
                    for (int i = 0; i < a.Length; i++) {
                        System.Xml.XmlAttribute ai = (System.Xml.XmlAttribute)a[i];
                        WriteXmlAttribute(ai, o);
                    }
                }
            }
            WriteAttribute(@"minOccurs", @"", (System.String)o.@MinOccursString);
            WriteAttribute(@"maxOccurs", @"", (System.String)o.@MaxOccursString);
            Write15_XmlSchemaAnnotation(@"annotation", @"http://www.w3.org/2001/XMLSchema", ((System.Xml.Schema.XmlSchemaAnnotation)o.@Annotation), false, false);
            {
                System.Xml.Schema.XmlSchemaObjectCollection a = (System.Xml.Schema.XmlSchemaObjectCollection)o.@Items;
                if (a != null) {
                    for (int ia = 0; ia < a.Count; ia++) {
                        System.Xml.Schema.XmlSchemaObject ai = a[ia];
                        {
                            if (ai is System.Xml.Schema.XmlSchemaSequence) {
                                Write47_XmlSchemaSequence(@"sequence", @"http://www.w3.org/2001/XMLSchema", ((System.Xml.Schema.XmlSchemaSequence)ai), false, false);
                            }
                            else if (ai is System.Xml.Schema.XmlSchemaChoice) {
                                Write58_XmlSchemaChoice(@"choice", @"http://www.w3.org/2001/XMLSchema", ((System.Xml.Schema.XmlSchemaChoice)ai), false, false);
                            }
                            else if (ai is System.Xml.Schema.XmlSchemaGroupRef) {
                                Write57_XmlSchemaGroupRef(@"group", @"http://www.w3.org/2001/XMLSchema", ((System.Xml.Schema.XmlSchemaGroupRef)ai), false, false);
                            }
                            else if (ai is System.Xml.Schema.XmlSchemaElement) {
                                Write51_XmlSchemaElement(@"element", @"http://www.w3.org/2001/XMLSchema", ((System.Xml.Schema.XmlSchemaElement)ai), false, false);
                            }
                            else if (ai is System.Xml.Schema.XmlSchemaAny) {
                                Write50_XmlSchemaAny(@"any", @"http://www.w3.org/2001/XMLSchema", ((System.Xml.Schema.XmlSchemaAny)ai), false, false);
                            }
                            else {
                                if (ai != null) {
                                    throw CreateUnknownTypeException(ai);
                                }
                            }
                        }
                    }
                }
            }
            WriteEndElement(o);
        }

        void Write48_XmlSchemaGroupBase(string n, string ns, System.Xml.Schema.XmlSchemaGroupBase o, bool isNullable, bool needType) {
            if ((object)o == null) {
                if (isNullable) WriteNullTagLiteral(n, ns);
                return;
            }
            if (!needType) {
                System.Type t = o.GetType();
                if (t == typeof(System.Xml.Schema.XmlSchemaGroupBase))
                    ;
                else if (t == typeof(System.Xml.Schema.XmlSchemaAll)) {
                    Write59_XmlSchemaAll(n, ns, (System.Xml.Schema.XmlSchemaAll)o, isNullable, true);
                    return;
                }
                else if (t == typeof(System.Xml.Schema.XmlSchemaChoice)) {
                    Write58_XmlSchemaChoice(n, ns, (System.Xml.Schema.XmlSchemaChoice)o, isNullable, true);
                    return;
                }
                else if (t == typeof(System.Xml.Schema.XmlSchemaSequence)) {
                    Write47_XmlSchemaSequence(n, ns, (System.Xml.Schema.XmlSchemaSequence)o, isNullable, true);
                    return;
                }
                else {
                    throw CreateUnknownTypeException(o);
                }
            }
        }

        void Write49_XmlSchemaParticle(string n, string ns, System.Xml.Schema.XmlSchemaParticle o, bool isNullable, bool needType) {
            if ((object)o == null) {
                if (isNullable) WriteNullTagLiteral(n, ns);
                return;
            }
            if (!needType) {
                System.Type t = o.GetType();
                if (t == typeof(System.Xml.Schema.XmlSchemaParticle))
                    ;
                else if (t == typeof(System.Xml.Schema.XmlSchemaGroupRef)) {
                    Write57_XmlSchemaGroupRef(n, ns, (System.Xml.Schema.XmlSchemaGroupRef)o, isNullable, true);
                    return;
                }
                else if (t == typeof(System.Xml.Schema.XmlSchemaElement)) {
                    Write51_XmlSchemaElement(n, ns, (System.Xml.Schema.XmlSchemaElement)o, isNullable, true);
                    return;
                }
                else if (t == typeof(System.Xml.Schema.XmlSchemaAny)) {
                    Write50_XmlSchemaAny(n, ns, (System.Xml.Schema.XmlSchemaAny)o, isNullable, true);
                    return;
                }
                else if (t == typeof(System.Xml.Schema.XmlSchemaGroupBase)) {
                    Write48_XmlSchemaGroupBase(n, ns, (System.Xml.Schema.XmlSchemaGroupBase)o, isNullable, true);
                    return;
                }
                else if (t == typeof(System.Xml.Schema.XmlSchemaAll)) {
                    Write59_XmlSchemaAll(n, ns, (System.Xml.Schema.XmlSchemaAll)o, isNullable, true);
                    return;
                }
                else if (t == typeof(System.Xml.Schema.XmlSchemaChoice)) {
                    Write58_XmlSchemaChoice(n, ns, (System.Xml.Schema.XmlSchemaChoice)o, isNullable, true);
                    return;
                }
                else if (t == typeof(System.Xml.Schema.XmlSchemaSequence)) {
                    Write47_XmlSchemaSequence(n, ns, (System.Xml.Schema.XmlSchemaSequence)o, isNullable, true);
                    return;
                }
                else {
                    throw CreateUnknownTypeException(o);
                }
            }
        }

        void Write50_XmlSchemaAny(string n, string ns, System.Xml.Schema.XmlSchemaAny o, bool isNullable, bool needType) {
            if ((object)o == null) {
                if (isNullable) WriteNullTagLiteral(n, ns);
                return;
            }
            if (!needType) {
                System.Type t = o.GetType();
                if (t == typeof(System.Xml.Schema.XmlSchemaAny))
                    ;
                else {
                    throw CreateUnknownTypeException(o);
                }
            }
            WriteStartElement(n, ns, o);
            if (needType) WriteXsiType(@"XmlSchemaAny", @"http://www.w3.org/2001/XMLSchema");
            WriteNamespaceDeclarations(o.@Namespaces);
            WriteAttribute(@"id", @"", (System.String)o.@Id);
            {
                System.Xml.XmlAttribute[] a = (System.Xml.XmlAttribute[])o.@UnhandledAttributes;
                if (a != null) {
                    for (int i = 0; i < a.Length; i++) {
                        System.Xml.XmlAttribute ai = (System.Xml.XmlAttribute)a[i];
                        WriteXmlAttribute(ai, o);
                    }
                }
            }
            WriteAttribute(@"minOccurs", @"", (System.String)o.@MinOccursString);
            WriteAttribute(@"maxOccurs", @"", (System.String)o.@MaxOccursString);
            WriteAttribute(@"namespace", @"", (System.String)o.@Namespace);
            if ((System.Xml.Schema.XmlSchemaContentProcessing)o.@ProcessContents != System.Xml.Schema.XmlSchemaContentProcessing.@None) {
                WriteAttribute(@"processContents", @"", Write41_XmlSchemaContentProcessing((System.Xml.Schema.XmlSchemaContentProcessing)o.@ProcessContents));
            }
            Write15_XmlSchemaAnnotation(@"annotation", @"http://www.w3.org/2001/XMLSchema", ((System.Xml.Schema.XmlSchemaAnnotation)o.@Annotation), false, false);
            WriteEndElement(o);
        }

        void Write51_XmlSchemaElement(string n, string ns, System.Xml.Schema.XmlSchemaElement o, bool isNullable, bool needType) {
            if ((object)o == null) {
                if (isNullable) WriteNullTagLiteral(n, ns);
                return;
            }
            if (!needType) {
                System.Type t = o.GetType();
                if (t == typeof(System.Xml.Schema.XmlSchemaElement))
                    ;
                else {
                    throw CreateUnknownTypeException(o);
                }
            }
            WriteStartElement(n, ns, o);
            if (needType) WriteXsiType(@"XmlSchemaElement", @"http://www.w3.org/2001/XMLSchema");
            WriteNamespaceDeclarations(o.@Namespaces);
            WriteAttribute(@"id", @"", (System.String)o.@Id);
            {
                System.Xml.XmlAttribute[] a = (System.Xml.XmlAttribute[])o.@UnhandledAttributes;
                if (a != null) {
                    for (int i = 0; i < a.Length; i++) {
                        System.Xml.XmlAttribute ai = (System.Xml.XmlAttribute)a[i];
                        WriteXmlAttribute(ai, o);
                    }
                }
            }
            WriteAttribute(@"minOccurs", @"", (System.String)o.@MinOccursString);
            WriteAttribute(@"maxOccurs", @"", (System.String)o.@MaxOccursString);
            if ((System.Boolean)o.@IsAbstract != false) {
                WriteAttribute(@"abstract", @"", System.Xml.XmlConvert.ToString((System.Boolean)(System.Boolean)o.@IsAbstract));
            }
            if ((System.Xml.Schema.XmlSchemaDerivationMethod)o.@Block != (System.Xml.Schema.XmlSchemaDerivationMethod.@None)) {
                WriteAttribute(@"block", @"", Write9_XmlSchemaDerivationMethod((System.Xml.Schema.XmlSchemaDerivationMethod)o.@Block));
            }
            if ((System.String)o.@DefaultValue != null) {
                WriteAttribute(@"default", @"", (System.String)o.@DefaultValue);
            }
            if ((System.Xml.Schema.XmlSchemaDerivationMethod)o.@Final != (System.Xml.Schema.XmlSchemaDerivationMethod.@None)) {
                WriteAttribute(@"final", @"", Write9_XmlSchemaDerivationMethod((System.Xml.Schema.XmlSchemaDerivationMethod)o.@Final));
            }
            if ((System.String)o.@FixedValue != null) {
                WriteAttribute(@"fixed", @"", (System.String)o.@FixedValue);
            }
            if ((System.Xml.Schema.XmlSchemaForm)o.@Form != System.Xml.Schema.XmlSchemaForm.@None) {
                WriteAttribute(@"form", @"", Write8_XmlSchemaForm((System.Xml.Schema.XmlSchemaForm)o.@Form));
            }
            if ((System.String)o.@Name != @"") {
                WriteAttribute(@"name", @"", (System.String)o.@Name);
            }
            if ((System.Boolean)o.@IsNillable != false) {
                WriteAttribute(@"nillable", @"", System.Xml.XmlConvert.ToString((System.Boolean)(System.Boolean)o.@IsNillable));
            }
            WriteAttribute(@"ref", @"", FromXmlQualifiedName((System.Xml.XmlQualifiedName)o.@RefName));
            WriteAttribute(@"substitutionGroup", @"", FromXmlQualifiedName((System.Xml.XmlQualifiedName)o.@SubstitutionGroup));
            WriteAttribute(@"type", @"", FromXmlQualifiedName((System.Xml.XmlQualifiedName)o.@SchemaTypeName));
            Write15_XmlSchemaAnnotation(@"annotation", @"http://www.w3.org/2001/XMLSchema", ((System.Xml.Schema.XmlSchemaAnnotation)o.@Annotation), false, false);
            {
                if (o.@SchemaType is System.Xml.Schema.XmlSchemaComplexType) {
                    Write42_XmlSchemaComplexType(@"complexType", @"http://www.w3.org/2001/XMLSchema", ((System.Xml.Schema.XmlSchemaComplexType)o.@SchemaType), false, false);
                }
                else if (o.@SchemaType is System.Xml.Schema.XmlSchemaSimpleType) {
                    Write12_XmlSchemaSimpleType(@"simpleType", @"http://www.w3.org/2001/XMLSchema", ((System.Xml.Schema.XmlSchemaSimpleType)o.@SchemaType), false, false);
                }
                else {
                    if (o.@SchemaType != null) {
                        throw CreateUnknownTypeException(o.@SchemaType);
                    }
                }
            }
            {
                System.Xml.Schema.XmlSchemaObjectCollection a = (System.Xml.Schema.XmlSchemaObjectCollection)o.@Constraints;
                if (a != null) {
                    for (int ia = 0; ia < a.Count; ia++) {
                        System.Xml.Schema.XmlSchemaObject ai = a[ia];
                        {
                            if (ai is System.Xml.Schema.XmlSchemaKeyref) {
                                Write52_XmlSchemaKeyref(@"keyref", @"http://www.w3.org/2001/XMLSchema", ((System.Xml.Schema.XmlSchemaKeyref)ai), false, false);
                            }
                            else if (ai is System.Xml.Schema.XmlSchemaUnique) {
                                Write55_XmlSchemaUnique(@"unique", @"http://www.w3.org/2001/XMLSchema", ((System.Xml.Schema.XmlSchemaUnique)ai), false, false);
                            }
                            else if (ai is System.Xml.Schema.XmlSchemaKey) {
                                Write56_XmlSchemaKey(@"key", @"http://www.w3.org/2001/XMLSchema", ((System.Xml.Schema.XmlSchemaKey)ai), false, false);
                            }
                            else {
                                if (ai != null) {
                                    throw CreateUnknownTypeException(ai);
                                }
                            }
                        }
                    }
                }
            }
            WriteEndElement(o);
        }

        void Write52_XmlSchemaKeyref(string n, string ns, System.Xml.Schema.XmlSchemaKeyref o, bool isNullable, bool needType) {
            if ((object)o == null) {
                if (isNullable) WriteNullTagLiteral(n, ns);
                return;
            }
            if (!needType) {
                System.Type t = o.GetType();
                if (t == typeof(System.Xml.Schema.XmlSchemaKeyref))
                    ;
                else {
                    throw CreateUnknownTypeException(o);
                }
            }
            WriteStartElement(n, ns, o);
            if (needType) WriteXsiType(@"XmlSchemaKeyref", @"http://www.w3.org/2001/XMLSchema");
            WriteNamespaceDeclarations(o.@Namespaces);
            WriteAttribute(@"id", @"", (System.String)o.@Id);
            {
                System.Xml.XmlAttribute[] a = (System.Xml.XmlAttribute[])o.@UnhandledAttributes;
                if (a != null) {
                    for (int i = 0; i < a.Length; i++) {
                        System.Xml.XmlAttribute ai = (System.Xml.XmlAttribute)a[i];
                        WriteXmlAttribute(ai, o);
                    }
                }
            }
            WriteAttribute(@"name", @"", (System.String)o.@Name);
            WriteAttribute(@"refer", @"", FromXmlQualifiedName((System.Xml.XmlQualifiedName)o.@Refer));
            Write15_XmlSchemaAnnotation(@"annotation", @"http://www.w3.org/2001/XMLSchema", ((System.Xml.Schema.XmlSchemaAnnotation)o.@Annotation), false, false);
            Write54_XmlSchemaXPath(@"selector", @"http://www.w3.org/2001/XMLSchema", ((System.Xml.Schema.XmlSchemaXPath)o.@Selector), false, false);
            {
                System.Xml.Schema.XmlSchemaObjectCollection a = (System.Xml.Schema.XmlSchemaObjectCollection)o.@Fields;
                if (a != null) {
                    for (int ia = 0; ia < a.Count; ia++) {
                        Write54_XmlSchemaXPath(@"field", @"http://www.w3.org/2001/XMLSchema", ((System.Xml.Schema.XmlSchemaXPath)a[ia]), false, false);
                    }
                }
            }
            WriteEndElement(o);
        }

        void Write53_XmlSchemaIdentityConstraint(string n, string ns, System.Xml.Schema.XmlSchemaIdentityConstraint o, bool isNullable, bool needType) {
            if ((object)o == null) {
                if (isNullable) WriteNullTagLiteral(n, ns);
                return;
            }
            if (!needType) {
                System.Type t = o.GetType();
                if (t == typeof(System.Xml.Schema.XmlSchemaIdentityConstraint))
                    ;
                else if (t == typeof(System.Xml.Schema.XmlSchemaKey)) {
                    Write56_XmlSchemaKey(n, ns, (System.Xml.Schema.XmlSchemaKey)o, isNullable, true);
                    return;
                }
                else if (t == typeof(System.Xml.Schema.XmlSchemaUnique)) {
                    Write55_XmlSchemaUnique(n, ns, (System.Xml.Schema.XmlSchemaUnique)o, isNullable, true);
                    return;
                }
                else if (t == typeof(System.Xml.Schema.XmlSchemaKeyref)) {
                    Write52_XmlSchemaKeyref(n, ns, (System.Xml.Schema.XmlSchemaKeyref)o, isNullable, true);
                    return;
                }
                else {
                    throw CreateUnknownTypeException(o);
                }
            }
            WriteStartElement(n, ns, o);
            if (needType) WriteXsiType(@"XmlSchemaIdentityConstraint", @"http://www.w3.org/2001/XMLSchema");
            WriteNamespaceDeclarations(o.@Namespaces);
            WriteAttribute(@"id", @"", (System.String)o.@Id);
            {
                System.Xml.XmlAttribute[] a = (System.Xml.XmlAttribute[])o.@UnhandledAttributes;
                if (a != null) {
                    for (int i = 0; i < a.Length; i++) {
                        System.Xml.XmlAttribute ai = (System.Xml.XmlAttribute)a[i];
                        WriteXmlAttribute(ai, o);
                    }
                }
            }
            WriteAttribute(@"name", @"", (System.String)o.@Name);
            Write15_XmlSchemaAnnotation(@"annotation", @"http://www.w3.org/2001/XMLSchema", ((System.Xml.Schema.XmlSchemaAnnotation)o.@Annotation), false, false);
            Write54_XmlSchemaXPath(@"selector", @"http://www.w3.org/2001/XMLSchema", ((System.Xml.Schema.XmlSchemaXPath)o.@Selector), false, false);
            {
                System.Xml.Schema.XmlSchemaObjectCollection a = (System.Xml.Schema.XmlSchemaObjectCollection)o.@Fields;
                if (a != null) {
                    for (int ia = 0; ia < a.Count; ia++) {
                        Write54_XmlSchemaXPath(@"field", @"http://www.w3.org/2001/XMLSchema", ((System.Xml.Schema.XmlSchemaXPath)a[ia]), false, false);
                    }
                }
            }
            WriteEndElement(o);
        }

        void Write54_XmlSchemaXPath(string n, string ns, System.Xml.Schema.XmlSchemaXPath o, bool isNullable, bool needType) {
            if ((object)o == null) {
                if (isNullable) WriteNullTagLiteral(n, ns);
                return;
            }
            if (!needType) {
                System.Type t = o.GetType();
                if (t == typeof(System.Xml.Schema.XmlSchemaXPath))
                    ;
                else {
                    throw CreateUnknownTypeException(o);
                }
            }
            WriteStartElement(n, ns, o);
            if (needType) WriteXsiType(@"XmlSchemaXPath", @"http://www.w3.org/2001/XMLSchema");
            WriteNamespaceDeclarations(o.@Namespaces);
            WriteAttribute(@"id", @"", (System.String)o.@Id);
            {
                System.Xml.XmlAttribute[] a = (System.Xml.XmlAttribute[])o.@UnhandledAttributes;
                if (a != null) {
                    for (int i = 0; i < a.Length; i++) {
                        System.Xml.XmlAttribute ai = (System.Xml.XmlAttribute)a[i];
                        WriteXmlAttribute(ai, o);
                    }
                }
            }
            if ((System.String)o.@XPath != @"") {
                WriteAttribute(@"xpath", @"", (System.String)o.@XPath);
            }
            Write15_XmlSchemaAnnotation(@"annotation", @"http://www.w3.org/2001/XMLSchema", ((System.Xml.Schema.XmlSchemaAnnotation)o.@Annotation), false, false);
            WriteEndElement(o);
        }

        void Write55_XmlSchemaUnique(string n, string ns, System.Xml.Schema.XmlSchemaUnique o, bool isNullable, bool needType) {
            if ((object)o == null) {
                if (isNullable) WriteNullTagLiteral(n, ns);
                return;
            }
            if (!needType) {
                System.Type t = o.GetType();
                if (t == typeof(System.Xml.Schema.XmlSchemaUnique))
                    ;
                else {
                    throw CreateUnknownTypeException(o);
                }
            }
            WriteStartElement(n, ns, o);
            if (needType) WriteXsiType(@"XmlSchemaUnique", @"http://www.w3.org/2001/XMLSchema");
            WriteNamespaceDeclarations(o.@Namespaces);
            WriteAttribute(@"id", @"", (System.String)o.@Id);
            {
                System.Xml.XmlAttribute[] a = (System.Xml.XmlAttribute[])o.@UnhandledAttributes;
                if (a != null) {
                    for (int i = 0; i < a.Length; i++) {
                        System.Xml.XmlAttribute ai = (System.Xml.XmlAttribute)a[i];
                        WriteXmlAttribute(ai, o);
                    }
                }
            }
            WriteAttribute(@"name", @"", (System.String)o.@Name);
            Write15_XmlSchemaAnnotation(@"annotation", @"http://www.w3.org/2001/XMLSchema", ((System.Xml.Schema.XmlSchemaAnnotation)o.@Annotation), false, false);
            Write54_XmlSchemaXPath(@"selector", @"http://www.w3.org/2001/XMLSchema", ((System.Xml.Schema.XmlSchemaXPath)o.@Selector), false, false);
            {
                System.Xml.Schema.XmlSchemaObjectCollection a = (System.Xml.Schema.XmlSchemaObjectCollection)o.@Fields;
                if (a != null) {
                    for (int ia = 0; ia < a.Count; ia++) {
                        Write54_XmlSchemaXPath(@"field", @"http://www.w3.org/2001/XMLSchema", ((System.Xml.Schema.XmlSchemaXPath)a[ia]), false, false);
                    }
                }
            }
            WriteEndElement(o);
        }

        void Write56_XmlSchemaKey(string n, string ns, System.Xml.Schema.XmlSchemaKey o, bool isNullable, bool needType) {
            if ((object)o == null) {
                if (isNullable) WriteNullTagLiteral(n, ns);
                return;
            }
            if (!needType) {
                System.Type t = o.GetType();
                if (t == typeof(System.Xml.Schema.XmlSchemaKey))
                    ;
                else {
                    throw CreateUnknownTypeException(o);
                }
            }
            WriteStartElement(n, ns, o);
            if (needType) WriteXsiType(@"XmlSchemaKey", @"http://www.w3.org/2001/XMLSchema");
            WriteNamespaceDeclarations(o.@Namespaces);
            WriteAttribute(@"id", @"", (System.String)o.@Id);
            {
                System.Xml.XmlAttribute[] a = (System.Xml.XmlAttribute[])o.@UnhandledAttributes;
                if (a != null) {
                    for (int i = 0; i < a.Length; i++) {
                        System.Xml.XmlAttribute ai = (System.Xml.XmlAttribute)a[i];
                        WriteXmlAttribute(ai, o);
                    }
                }
            }
            WriteAttribute(@"name", @"", (System.String)o.@Name);
            Write15_XmlSchemaAnnotation(@"annotation", @"http://www.w3.org/2001/XMLSchema", ((System.Xml.Schema.XmlSchemaAnnotation)o.@Annotation), false, false);
            Write54_XmlSchemaXPath(@"selector", @"http://www.w3.org/2001/XMLSchema", ((System.Xml.Schema.XmlSchemaXPath)o.@Selector), false, false);
            {
                System.Xml.Schema.XmlSchemaObjectCollection a = (System.Xml.Schema.XmlSchemaObjectCollection)o.@Fields;
                if (a != null) {
                    for (int ia = 0; ia < a.Count; ia++) {
                        Write54_XmlSchemaXPath(@"field", @"http://www.w3.org/2001/XMLSchema", ((System.Xml.Schema.XmlSchemaXPath)a[ia]), false, false);
                    }
                }
            }
            WriteEndElement(o);
        }

        void Write57_XmlSchemaGroupRef(string n, string ns, System.Xml.Schema.XmlSchemaGroupRef o, bool isNullable, bool needType) {
            if ((object)o == null) {
                if (isNullable) WriteNullTagLiteral(n, ns);
                return;
            }
            if (!needType) {
                System.Type t = o.GetType();
                if (t == typeof(System.Xml.Schema.XmlSchemaGroupRef))
                    ;
                else {
                    throw CreateUnknownTypeException(o);
                }
            }
            WriteStartElement(n, ns, o);
            if (needType) WriteXsiType(@"XmlSchemaGroupRef", @"http://www.w3.org/2001/XMLSchema");
            WriteNamespaceDeclarations(o.@Namespaces);
            WriteAttribute(@"id", @"", (System.String)o.@Id);
            {
                System.Xml.XmlAttribute[] a = (System.Xml.XmlAttribute[])o.@UnhandledAttributes;
                if (a != null) {
                    for (int i = 0; i < a.Length; i++) {
                        System.Xml.XmlAttribute ai = (System.Xml.XmlAttribute)a[i];
                        WriteXmlAttribute(ai, o);
                    }
                }
            }
            WriteAttribute(@"minOccurs", @"", (System.String)o.@MinOccursString);
            WriteAttribute(@"maxOccurs", @"", (System.String)o.@MaxOccursString);
            WriteAttribute(@"ref", @"", FromXmlQualifiedName((System.Xml.XmlQualifiedName)o.@RefName));
            Write15_XmlSchemaAnnotation(@"annotation", @"http://www.w3.org/2001/XMLSchema", ((System.Xml.Schema.XmlSchemaAnnotation)o.@Annotation), false, false);
            WriteEndElement(o);
        }

        void Write58_XmlSchemaChoice(string n, string ns, System.Xml.Schema.XmlSchemaChoice o, bool isNullable, bool needType) {
            if ((object)o == null) {
                if (isNullable) WriteNullTagLiteral(n, ns);
                return;
            }
            if (!needType) {
                System.Type t = o.GetType();
                if (t == typeof(System.Xml.Schema.XmlSchemaChoice))
                    ;
                else {
                    throw CreateUnknownTypeException(o);
                }
            }
            WriteStartElement(n, ns, o);
            if (needType) WriteXsiType(@"XmlSchemaChoice", @"http://www.w3.org/2001/XMLSchema");
            WriteNamespaceDeclarations(o.@Namespaces);
            WriteAttribute(@"id", @"", (System.String)o.@Id);
            {
                System.Xml.XmlAttribute[] a = (System.Xml.XmlAttribute[])o.@UnhandledAttributes;
                if (a != null) {
                    for (int i = 0; i < a.Length; i++) {
                        System.Xml.XmlAttribute ai = (System.Xml.XmlAttribute)a[i];
                        WriteXmlAttribute(ai, o);
                    }
                }
            }
            WriteAttribute(@"minOccurs", @"", (System.String)o.@MinOccursString);
            WriteAttribute(@"maxOccurs", @"", (System.String)o.@MaxOccursString);
            Write15_XmlSchemaAnnotation(@"annotation", @"http://www.w3.org/2001/XMLSchema", ((System.Xml.Schema.XmlSchemaAnnotation)o.@Annotation), false, false);
            {
                System.Xml.Schema.XmlSchemaObjectCollection a = (System.Xml.Schema.XmlSchemaObjectCollection)o.@Items;
                if (a != null) {
                    for (int ia = 0; ia < a.Count; ia++) {
                        System.Xml.Schema.XmlSchemaObject ai = a[ia];
                        {
                            if (ai is System.Xml.Schema.XmlSchemaSequence) {
                                Write47_XmlSchemaSequence(@"sequence", @"http://www.w3.org/2001/XMLSchema", ((System.Xml.Schema.XmlSchemaSequence)ai), false, false);
                            }
                            else if (ai is System.Xml.Schema.XmlSchemaChoice) {
                                Write58_XmlSchemaChoice(@"choice", @"http://www.w3.org/2001/XMLSchema", ((System.Xml.Schema.XmlSchemaChoice)ai), false, false);
                            }
                            else if (ai is System.Xml.Schema.XmlSchemaGroupRef) {
                                Write57_XmlSchemaGroupRef(@"group", @"http://www.w3.org/2001/XMLSchema", ((System.Xml.Schema.XmlSchemaGroupRef)ai), false, false);
                            }
                            else if (ai is System.Xml.Schema.XmlSchemaElement) {
                                Write51_XmlSchemaElement(@"element", @"http://www.w3.org/2001/XMLSchema", ((System.Xml.Schema.XmlSchemaElement)ai), false, false);
                            }
                            else if (ai is System.Xml.Schema.XmlSchemaAny) {
                                Write50_XmlSchemaAny(@"any", @"http://www.w3.org/2001/XMLSchema", ((System.Xml.Schema.XmlSchemaAny)ai), false, false);
                            }
                            else {
                                if (ai != null) {
                                    throw CreateUnknownTypeException(ai);
                                }
                            }
                        }
                    }
                }
            }
            WriteEndElement(o);
        }

        void Write59_XmlSchemaAll(string n, string ns, System.Xml.Schema.XmlSchemaAll o, bool isNullable, bool needType) {
            if ((object)o == null) {
                if (isNullable) WriteNullTagLiteral(n, ns);
                return;
            }
            if (!needType) {
                System.Type t = o.GetType();
                if (t == typeof(System.Xml.Schema.XmlSchemaAll))
                    ;
                else {
                    throw CreateUnknownTypeException(o);
                }
            }
            WriteStartElement(n, ns, o);
            if (needType) WriteXsiType(@"XmlSchemaAll", @"http://www.w3.org/2001/XMLSchema");
            WriteNamespaceDeclarations(o.@Namespaces);
            WriteAttribute(@"id", @"", (System.String)o.@Id);
            {
                System.Xml.XmlAttribute[] a = (System.Xml.XmlAttribute[])o.@UnhandledAttributes;
                if (a != null) {
                    for (int i = 0; i < a.Length; i++) {
                        System.Xml.XmlAttribute ai = (System.Xml.XmlAttribute)a[i];
                        WriteXmlAttribute(ai, o);
                    }
                }
            }
            WriteAttribute(@"minOccurs", @"", (System.String)o.@MinOccursString);
            WriteAttribute(@"maxOccurs", @"", (System.String)o.@MaxOccursString);
            Write15_XmlSchemaAnnotation(@"annotation", @"http://www.w3.org/2001/XMLSchema", ((System.Xml.Schema.XmlSchemaAnnotation)o.@Annotation), false, false);
            {
                System.Xml.Schema.XmlSchemaObjectCollection a = (System.Xml.Schema.XmlSchemaObjectCollection)o.@Items;
                if (a != null) {
                    for (int ia = 0; ia < a.Count; ia++) {
                        Write51_XmlSchemaElement(@"element", @"http://www.w3.org/2001/XMLSchema", ((System.Xml.Schema.XmlSchemaElement)a[ia]), false, false);
                    }
                }
            }
            WriteEndElement(o);
        }

        void Write60_XmlSchemaComplexContentRestriction(string n, string ns, System.Xml.Schema.XmlSchemaComplexContentRestriction o, bool isNullable, bool needType) {
            if ((object)o == null) {
                if (isNullable) WriteNullTagLiteral(n, ns);
                return;
            }
            if (!needType) {
                System.Type t = o.GetType();
                if (t == typeof(System.Xml.Schema.XmlSchemaComplexContentRestriction))
                    ;
                else {
                    throw CreateUnknownTypeException(o);
                }
            }
            WriteStartElement(n, ns, o);
            if (needType) WriteXsiType(@"XmlSchemaComplexContentRestriction", @"http://www.w3.org/2001/XMLSchema");
            WriteNamespaceDeclarations(o.@Namespaces);
            WriteAttribute(@"id", @"", (System.String)o.@Id);
            {
                System.Xml.XmlAttribute[] a = (System.Xml.XmlAttribute[])o.@UnhandledAttributes;
                if (a != null) {
                    for (int i = 0; i < a.Length; i++) {
                        System.Xml.XmlAttribute ai = (System.Xml.XmlAttribute)a[i];
                        WriteXmlAttribute(ai, o);
                    }
                }
            }
            WriteAttribute(@"base", @"", FromXmlQualifiedName((System.Xml.XmlQualifiedName)o.@BaseTypeName));
            Write15_XmlSchemaAnnotation(@"annotation", @"http://www.w3.org/2001/XMLSchema", ((System.Xml.Schema.XmlSchemaAnnotation)o.@Annotation), false, false);
            {
                if (o.@Particle is System.Xml.Schema.XmlSchemaSequence) {
                    Write47_XmlSchemaSequence(@"sequence", @"http://www.w3.org/2001/XMLSchema", ((System.Xml.Schema.XmlSchemaSequence)o.@Particle), false, false);
                }
                else if (o.@Particle is System.Xml.Schema.XmlSchemaChoice) {
                    Write58_XmlSchemaChoice(@"choice", @"http://www.w3.org/2001/XMLSchema", ((System.Xml.Schema.XmlSchemaChoice)o.@Particle), false, false);
                }
                else if (o.@Particle is System.Xml.Schema.XmlSchemaGroupRef) {
                    Write57_XmlSchemaGroupRef(@"group", @"http://www.w3.org/2001/XMLSchema", ((System.Xml.Schema.XmlSchemaGroupRef)o.@Particle), false, false);
                }
                else if (o.@Particle is System.Xml.Schema.XmlSchemaAll) {
                    Write59_XmlSchemaAll(@"all", @"http://www.w3.org/2001/XMLSchema", ((System.Xml.Schema.XmlSchemaAll)o.@Particle), false, false);
                }
                else {
                    if (o.@Particle != null) {
                        throw CreateUnknownTypeException(o.@Particle);
                    }
                }
            }
            {
                System.Xml.Schema.XmlSchemaObjectCollection a = (System.Xml.Schema.XmlSchemaObjectCollection)o.@Attributes;
                if (a != null) {
                    for (int ia = 0; ia < a.Count; ia++) {
                        System.Xml.Schema.XmlSchemaObject ai = a[ia];
                        {
                            if (ai is System.Xml.Schema.XmlSchemaAttribute) {
                                Write37_XmlSchemaAttribute(@"attribute", @"http://www.w3.org/2001/XMLSchema", ((System.Xml.Schema.XmlSchemaAttribute)ai), false, false);
                            }
                            else if (ai is System.Xml.Schema.XmlSchemaAttributeGroupRef) {
                                Write39_XmlSchemaAttributeGroupRef(@"attributeGroup", @"http://www.w3.org/2001/XMLSchema", ((System.Xml.Schema.XmlSchemaAttributeGroupRef)ai), false, false);
                            }
                            else {
                                if (ai != null) {
                                    throw CreateUnknownTypeException(ai);
                                }
                            }
                        }
                    }
                }
            }
            Write40_XmlSchemaAnyAttribute(@"anyAttribute", @"http://www.w3.org/2001/XMLSchema", ((System.Xml.Schema.XmlSchemaAnyAttribute)o.@AnyAttribute), false, false);
            WriteEndElement(o);
        }

        void Write61_XmlSchemaSimpleContent(string n, string ns, System.Xml.Schema.XmlSchemaSimpleContent o, bool isNullable, bool needType) {
            if ((object)o == null) {
                if (isNullable) WriteNullTagLiteral(n, ns);
                return;
            }
            if (!needType) {
                System.Type t = o.GetType();
                if (t == typeof(System.Xml.Schema.XmlSchemaSimpleContent))
                    ;
                else {
                    throw CreateUnknownTypeException(o);
                }
            }
            WriteStartElement(n, ns, o);
            if (needType) WriteXsiType(@"XmlSchemaSimpleContent", @"http://www.w3.org/2001/XMLSchema");
            WriteNamespaceDeclarations(o.@Namespaces);
            WriteAttribute(@"id", @"", (System.String)o.@Id);
            {
                System.Xml.XmlAttribute[] a = (System.Xml.XmlAttribute[])o.@UnhandledAttributes;
                if (a != null) {
                    for (int i = 0; i < a.Length; i++) {
                        System.Xml.XmlAttribute ai = (System.Xml.XmlAttribute)a[i];
                        WriteXmlAttribute(ai, o);
                    }
                }
            }
            Write15_XmlSchemaAnnotation(@"annotation", @"http://www.w3.org/2001/XMLSchema", ((System.Xml.Schema.XmlSchemaAnnotation)o.@Annotation), false, false);
            {
                if (o.@Content is System.Xml.Schema.XmlSchemaSimpleContentRestriction) {
                    Write62_XmlSchemaSimpleContentRestriction(@"restriction", @"http://www.w3.org/2001/XMLSchema", ((System.Xml.Schema.XmlSchemaSimpleContentRestriction)o.@Content), false, false);
                }
                else if (o.@Content is System.Xml.Schema.XmlSchemaSimpleContentExtension) {
                    Write63_XmlSchemaSimpleContentExtension(@"extension", @"http://www.w3.org/2001/XMLSchema", ((System.Xml.Schema.XmlSchemaSimpleContentExtension)o.@Content), false, false);
                }
                else {
                    if (o.@Content != null) {
                        throw CreateUnknownTypeException(o.@Content);
                    }
                }
            }
            WriteEndElement(o);
        }

        void Write62_XmlSchemaSimpleContentRestriction(string n, string ns, System.Xml.Schema.XmlSchemaSimpleContentRestriction o, bool isNullable, bool needType) {
            if ((object)o == null) {
                if (isNullable) WriteNullTagLiteral(n, ns);
                return;
            }
            if (!needType) {
                System.Type t = o.GetType();
                if (t == typeof(System.Xml.Schema.XmlSchemaSimpleContentRestriction))
                    ;
                else {
                    throw CreateUnknownTypeException(o);
                }
            }
            WriteStartElement(n, ns, o);
            if (needType) WriteXsiType(@"XmlSchemaSimpleContentRestriction", @"http://www.w3.org/2001/XMLSchema");
            WriteNamespaceDeclarations(o.@Namespaces);
            WriteAttribute(@"id", @"", (System.String)o.@Id);
            {
                System.Xml.XmlAttribute[] a = (System.Xml.XmlAttribute[])o.@UnhandledAttributes;
                if (a != null) {
                    for (int i = 0; i < a.Length; i++) {
                        System.Xml.XmlAttribute ai = (System.Xml.XmlAttribute)a[i];
                        WriteXmlAttribute(ai, o);
                    }
                }
            }
            WriteAttribute(@"base", @"", FromXmlQualifiedName((System.Xml.XmlQualifiedName)o.@BaseTypeName));
            Write15_XmlSchemaAnnotation(@"annotation", @"http://www.w3.org/2001/XMLSchema", ((System.Xml.Schema.XmlSchemaAnnotation)o.@Annotation), false, false);
            Write12_XmlSchemaSimpleType(@"simpleType", @"http://www.w3.org/2001/XMLSchema", ((System.Xml.Schema.XmlSchemaSimpleType)o.@BaseType), false, false);
            {
                System.Xml.Schema.XmlSchemaObjectCollection a = (System.Xml.Schema.XmlSchemaObjectCollection)o.@Facets;
                if (a != null) {
                    for (int ia = 0; ia < a.Count; ia++) {
                        System.Xml.Schema.XmlSchemaObject ai = a[ia];
                        {
                            if (ai is System.Xml.Schema.XmlSchemaLengthFacet) {
                                Write24_XmlSchemaLengthFacet(@"length", @"http://www.w3.org/2001/XMLSchema", ((System.Xml.Schema.XmlSchemaLengthFacet)ai), false, false);
                            }
                            else if (ai is System.Xml.Schema.XmlSchemaMaxInclusiveFacet) {
                                Write29_XmlSchemaMaxInclusiveFacet(@"maxInclusive", @"http://www.w3.org/2001/XMLSchema", ((System.Xml.Schema.XmlSchemaMaxInclusiveFacet)ai), false, false);
                            }
                            else if (ai is System.Xml.Schema.XmlSchemaMaxExclusiveFacet) {
                                Write30_XmlSchemaMaxExclusiveFacet(@"maxExclusive", @"http://www.w3.org/2001/XMLSchema", ((System.Xml.Schema.XmlSchemaMaxExclusiveFacet)ai), false, false);
                            }
                            else if (ai is System.Xml.Schema.XmlSchemaFractionDigitsFacet) {
                                Write34_XmlSchemaFractionDigitsFacet(@"fractionDigits", @"http://www.w3.org/2001/XMLSchema", ((System.Xml.Schema.XmlSchemaFractionDigitsFacet)ai), false, false);
                            }
                            else if (ai is System.Xml.Schema.XmlSchemaEnumerationFacet) {
                                Write28_XmlSchemaEnumerationFacet(@"enumeration", @"http://www.w3.org/2001/XMLSchema", ((System.Xml.Schema.XmlSchemaEnumerationFacet)ai), false, false);
                            }
                            else if (ai is System.Xml.Schema.XmlSchemaWhiteSpaceFacet) {
                                Write25_XmlSchemaWhiteSpaceFacet(@"whiteSpace", @"http://www.w3.org/2001/XMLSchema", ((System.Xml.Schema.XmlSchemaWhiteSpaceFacet)ai), false, false);
                            }
                            else if (ai is System.Xml.Schema.XmlSchemaTotalDigitsFacet) {
                                Write33_XmlSchemaTotalDigitsFacet(@"totalDigits", @"http://www.w3.org/2001/XMLSchema", ((System.Xml.Schema.XmlSchemaTotalDigitsFacet)ai), false, false);
                            }
                            else if (ai is System.Xml.Schema.XmlSchemaMinLengthFacet) {
                                Write21_XmlSchemaMinLengthFacet(@"minLength", @"http://www.w3.org/2001/XMLSchema", ((System.Xml.Schema.XmlSchemaMinLengthFacet)ai), false, false);
                            }
                            else if (ai is System.Xml.Schema.XmlSchemaMinExclusiveFacet) {
                                Write32_XmlSchemaMinExclusiveFacet(@"minExclusive", @"http://www.w3.org/2001/XMLSchema", ((System.Xml.Schema.XmlSchemaMinExclusiveFacet)ai), false, false);
                            }
                            else if (ai is System.Xml.Schema.XmlSchemaMinInclusiveFacet) {
                                Write31_XmlSchemaMinInclusiveFacet(@"minInclusive", @"http://www.w3.org/2001/XMLSchema", ((System.Xml.Schema.XmlSchemaMinInclusiveFacet)ai), false, false);
                            }
                            else if (ai is System.Xml.Schema.XmlSchemaMaxLengthFacet) {
                                Write26_XmlSchemaMaxLengthFacet(@"maxLength", @"http://www.w3.org/2001/XMLSchema", ((System.Xml.Schema.XmlSchemaMaxLengthFacet)ai), false, false);
                            }
                            else if (ai is System.Xml.Schema.XmlSchemaPatternFacet) {
                                Write27_XmlSchemaPatternFacet(@"pattern", @"http://www.w3.org/2001/XMLSchema", ((System.Xml.Schema.XmlSchemaPatternFacet)ai), false, false);
                            }
                            else {
                                if (ai != null) {
                                    throw CreateUnknownTypeException(ai);
                                }
                            }
                        }
                    }
                }
            }
            {
                System.Xml.Schema.XmlSchemaObjectCollection a = (System.Xml.Schema.XmlSchemaObjectCollection)o.@Attributes;
                if (a != null) {
                    for (int ia = 0; ia < a.Count; ia++) {
                        System.Xml.Schema.XmlSchemaObject ai = a[ia];
                        {
                            if (ai is System.Xml.Schema.XmlSchemaAttribute) {
                                Write37_XmlSchemaAttribute(@"attribute", @"http://www.w3.org/2001/XMLSchema", ((System.Xml.Schema.XmlSchemaAttribute)ai), false, false);
                            }
                            else if (ai is System.Xml.Schema.XmlSchemaAttributeGroupRef) {
                                Write39_XmlSchemaAttributeGroupRef(@"attributeGroup", @"http://www.w3.org/2001/XMLSchema", ((System.Xml.Schema.XmlSchemaAttributeGroupRef)ai), false, false);
                            }
                            else {
                                if (ai != null) {
                                    throw CreateUnknownTypeException(ai);
                                }
                            }
                        }
                    }
                }
            }
            Write40_XmlSchemaAnyAttribute(@"anyAttribute", @"http://www.w3.org/2001/XMLSchema", ((System.Xml.Schema.XmlSchemaAnyAttribute)o.@AnyAttribute), false, false);
            WriteEndElement(o);
        }

        void Write63_XmlSchemaSimpleContentExtension(string n, string ns, System.Xml.Schema.XmlSchemaSimpleContentExtension o, bool isNullable, bool needType) {
            if ((object)o == null) {
                if (isNullable) WriteNullTagLiteral(n, ns);
                return;
            }
            if (!needType) {
                System.Type t = o.GetType();
                if (t == typeof(System.Xml.Schema.XmlSchemaSimpleContentExtension))
                    ;
                else {
                    throw CreateUnknownTypeException(o);
                }
            }
            WriteStartElement(n, ns, o);
            if (needType) WriteXsiType(@"XmlSchemaSimpleContentExtension", @"http://www.w3.org/2001/XMLSchema");
            WriteNamespaceDeclarations(o.@Namespaces);
            WriteAttribute(@"id", @"", (System.String)o.@Id);
            {
                System.Xml.XmlAttribute[] a = (System.Xml.XmlAttribute[])o.@UnhandledAttributes;
                if (a != null) {
                    for (int i = 0; i < a.Length; i++) {
                        System.Xml.XmlAttribute ai = (System.Xml.XmlAttribute)a[i];
                        WriteXmlAttribute(ai, o);
                    }
                }
            }
            WriteAttribute(@"base", @"", FromXmlQualifiedName((System.Xml.XmlQualifiedName)o.@BaseTypeName));
            Write15_XmlSchemaAnnotation(@"annotation", @"http://www.w3.org/2001/XMLSchema", ((System.Xml.Schema.XmlSchemaAnnotation)o.@Annotation), false, false);
            {
                System.Xml.Schema.XmlSchemaObjectCollection a = (System.Xml.Schema.XmlSchemaObjectCollection)o.@Attributes;
                if (a != null) {
                    for (int ia = 0; ia < a.Count; ia++) {
                        System.Xml.Schema.XmlSchemaObject ai = a[ia];
                        {
                            if (ai is System.Xml.Schema.XmlSchemaAttribute) {
                                Write37_XmlSchemaAttribute(@"attribute", @"http://www.w3.org/2001/XMLSchema", ((System.Xml.Schema.XmlSchemaAttribute)ai), false, false);
                            }
                            else if (ai is System.Xml.Schema.XmlSchemaAttributeGroupRef) {
                                Write39_XmlSchemaAttributeGroupRef(@"attributeGroup", @"http://www.w3.org/2001/XMLSchema", ((System.Xml.Schema.XmlSchemaAttributeGroupRef)ai), false, false);
                            }
                            else {
                                if (ai != null) {
                                    throw CreateUnknownTypeException(ai);
                                }
                            }
                        }
                    }
                }
            }
            Write40_XmlSchemaAnyAttribute(@"anyAttribute", @"http://www.w3.org/2001/XMLSchema", ((System.Xml.Schema.XmlSchemaAnyAttribute)o.@AnyAttribute), false, false);
            WriteEndElement(o);
        }

        void Write64_XmlSchemaGroup(string n, string ns, System.Xml.Schema.XmlSchemaGroup o, bool isNullable, bool needType) {
            if ((object)o == null) {
                if (isNullable) WriteNullTagLiteral(n, ns);
                return;
            }
            if (!needType) {
                System.Type t = o.GetType();
                if (t == typeof(System.Xml.Schema.XmlSchemaGroup))
                    ;
                else {
                    throw CreateUnknownTypeException(o);
                }
            }
            WriteStartElement(n, ns, o);
            if (needType) WriteXsiType(@"XmlSchemaGroup", @"http://www.w3.org/2001/XMLSchema");
            WriteNamespaceDeclarations(o.@Namespaces);
            WriteAttribute(@"id", @"", (System.String)o.@Id);
            {
                System.Xml.XmlAttribute[] a = (System.Xml.XmlAttribute[])o.@UnhandledAttributes;
                if (a != null) {
                    for (int i = 0; i < a.Length; i++) {
                        System.Xml.XmlAttribute ai = (System.Xml.XmlAttribute)a[i];
                        WriteXmlAttribute(ai, o);
                    }
                }
            }
            WriteAttribute(@"name", @"", (System.String)o.@Name);
            Write15_XmlSchemaAnnotation(@"annotation", @"http://www.w3.org/2001/XMLSchema", ((System.Xml.Schema.XmlSchemaAnnotation)o.@Annotation), false, false);
            {
                if (o.@Particle is System.Xml.Schema.XmlSchemaSequence) {
                    Write47_XmlSchemaSequence(@"sequence", @"http://www.w3.org/2001/XMLSchema", ((System.Xml.Schema.XmlSchemaSequence)o.@Particle), false, false);
                }
                else if (o.@Particle is System.Xml.Schema.XmlSchemaChoice) {
                    Write58_XmlSchemaChoice(@"choice", @"http://www.w3.org/2001/XMLSchema", ((System.Xml.Schema.XmlSchemaChoice)o.@Particle), false, false);
                }
                else if (o.@Particle is System.Xml.Schema.XmlSchemaAll) {
                    Write59_XmlSchemaAll(@"all", @"http://www.w3.org/2001/XMLSchema", ((System.Xml.Schema.XmlSchemaAll)o.@Particle), false, false);
                }
                else {
                    if (o.@Particle != null) {
                        throw CreateUnknownTypeException(o.@Particle);
                    }
                }
            }
            WriteEndElement(o);
        }

        void Write65_XmlSchemaImport(string n, string ns, System.Xml.Schema.XmlSchemaImport o, bool isNullable, bool needType) {
            if ((object)o == null) {
                if (isNullable) WriteNullTagLiteral(n, ns);
                return;
            }
            if (!needType) {
                System.Type t = o.GetType();
                if (t == typeof(System.Xml.Schema.XmlSchemaImport))
                    ;
                else {
                    throw CreateUnknownTypeException(o);
                }
            }
            WriteStartElement(n, ns, o);
            if (needType) WriteXsiType(@"XmlSchemaImport", @"http://www.w3.org/2001/XMLSchema");
            WriteNamespaceDeclarations(o.@Namespaces);
            WriteAttribute(@"schemaLocation", @"", (System.String)o.@SchemaLocation);
            WriteAttribute(@"id", @"", (System.String)o.@Id);
            {
                System.Xml.XmlAttribute[] a = (System.Xml.XmlAttribute[])o.@UnhandledAttributes;
                if (a != null) {
                    for (int i = 0; i < a.Length; i++) {
                        System.Xml.XmlAttribute ai = (System.Xml.XmlAttribute)a[i];
                        WriteXmlAttribute(ai, o);
                    }
                }
            }
            WriteAttribute(@"namespace", @"", (System.String)o.@Namespace);
            Write15_XmlSchemaAnnotation(@"annotation", @"http://www.w3.org/2001/XMLSchema", ((System.Xml.Schema.XmlSchemaAnnotation)o.@Annotation), false, false);
            WriteEndElement(o);
        }

        void Write66_XmlSchemaInclude(string n, string ns, System.Xml.Schema.XmlSchemaInclude o, bool isNullable, bool needType) {
            if ((object)o == null) {
                if (isNullable) WriteNullTagLiteral(n, ns);
                return;
            }
            if (!needType) {
                System.Type t = o.GetType();
                if (t == typeof(System.Xml.Schema.XmlSchemaInclude))
                    ;
                else {
                    throw CreateUnknownTypeException(o);
                }
            }
            WriteStartElement(n, ns, o);
            if (needType) WriteXsiType(@"XmlSchemaInclude", @"http://www.w3.org/2001/XMLSchema");
            WriteNamespaceDeclarations(o.@Namespaces);
            WriteAttribute(@"schemaLocation", @"", (System.String)o.@SchemaLocation);
            WriteAttribute(@"id", @"", (System.String)o.@Id);
            {
                System.Xml.XmlAttribute[] a = (System.Xml.XmlAttribute[])o.@UnhandledAttributes;
                if (a != null) {
                    for (int i = 0; i < a.Length; i++) {
                        System.Xml.XmlAttribute ai = (System.Xml.XmlAttribute)a[i];
                        WriteXmlAttribute(ai, o);
                    }
                }
            }
            Write15_XmlSchemaAnnotation(@"annotation", @"http://www.w3.org/2001/XMLSchema", ((System.Xml.Schema.XmlSchemaAnnotation)o.@Annotation), false, false);
            WriteEndElement(o);
        }

        void Write67_XmlSchemaNotation(string n, string ns, System.Xml.Schema.XmlSchemaNotation o, bool isNullable, bool needType) {
            if ((object)o == null) {
                if (isNullable) WriteNullTagLiteral(n, ns);
                return;
            }
            if (!needType) {
                System.Type t = o.GetType();
                if (t == typeof(System.Xml.Schema.XmlSchemaNotation))
                    ;
                else {
                    throw CreateUnknownTypeException(o);
                }
            }
            WriteStartElement(n, ns, o);
            if (needType) WriteXsiType(@"XmlSchemaNotation", @"http://www.w3.org/2001/XMLSchema");
            WriteNamespaceDeclarations(o.@Namespaces);
            WriteAttribute(@"id", @"", (System.String)o.@Id);
            {
                System.Xml.XmlAttribute[] a = (System.Xml.XmlAttribute[])o.@UnhandledAttributes;
                if (a != null) {
                    for (int i = 0; i < a.Length; i++) {
                        System.Xml.XmlAttribute ai = (System.Xml.XmlAttribute)a[i];
                        WriteXmlAttribute(ai, o);
                    }
                }
            }
            WriteAttribute(@"name", @"", (System.String)o.@Name);
            WriteAttribute(@"public", @"", (System.String)o.@Public);
            WriteAttribute(@"system", @"", (System.String)o.@System);
            Write15_XmlSchemaAnnotation(@"annotation", @"http://www.w3.org/2001/XMLSchema", ((System.Xml.Schema.XmlSchemaAnnotation)o.@Annotation), false, false);
            WriteEndElement(o);
        }

        void Write68_Message(string n, string ns, System.Web.Services.Description.Message o, bool isNullable, bool needType) {
            if ((object)o == null) {
                if (isNullable) WriteNullTagLiteral(n, ns);
                return;
            }
            if (!needType) {
                System.Type t = o.GetType();
                if (t == typeof(System.Web.Services.Description.Message))
                    ;
                else {
                    throw CreateUnknownTypeException(o);
                }
            }
            WriteStartElement(n, ns, o);
            if (needType) WriteXsiType(@"Message", @"http://schemas.xmlsoap.org/wsdl/");
            WriteAttribute(@"name", @"", FromXmlNCName((System.String)o.@Name));
            if (((System.String)o.@Documentation) != @"") {
                WriteElementString(@"documentation", @"http://schemas.xmlsoap.org/wsdl/", ((System.String)o.@Documentation));
            }
            {
                System.Web.Services.Description.MessagePartCollection a = (System.Web.Services.Description.MessagePartCollection)o.@Parts;
                if (a != null) {
                    for (int ia = 0; ia < a.Count; ia++) {
                        Write69_MessagePart(@"part", @"http://schemas.xmlsoap.org/wsdl/", ((System.Web.Services.Description.MessagePart)a[ia]), false, false);
                    }
                }
            }
            WriteEndElement(o);
        }

        void Write69_MessagePart(string n, string ns, System.Web.Services.Description.MessagePart o, bool isNullable, bool needType) {
            if ((object)o == null) {
                if (isNullable) WriteNullTagLiteral(n, ns);
                return;
            }
            if (!needType) {
                System.Type t = o.GetType();
                if (t == typeof(System.Web.Services.Description.MessagePart))
                    ;
                else {
                    throw CreateUnknownTypeException(o);
                }
            }
            WriteStartElement(n, ns, o);
            if (needType) WriteXsiType(@"MessagePart", @"http://schemas.xmlsoap.org/wsdl/");
            WriteAttribute(@"name", @"", FromXmlNmToken((System.String)o.@Name));
            WriteAttribute(@"element", @"", FromXmlQualifiedName((System.Xml.XmlQualifiedName)o.@Element));
            WriteAttribute(@"type", @"", FromXmlQualifiedName((System.Xml.XmlQualifiedName)o.@Type));
            if (((System.String)o.@Documentation) != @"") {
                WriteElementString(@"documentation", @"http://schemas.xmlsoap.org/wsdl/", ((System.String)o.@Documentation));
            }
            WriteEndElement(o);
        }

        void Write70_PortType(string n, string ns, System.Web.Services.Description.PortType o, bool isNullable, bool needType) {
            if ((object)o == null) {
                if (isNullable) WriteNullTagLiteral(n, ns);
                return;
            }
            if (!needType) {
                System.Type t = o.GetType();
                if (t == typeof(System.Web.Services.Description.PortType))
                    ;
                else {
                    throw CreateUnknownTypeException(o);
                }
            }
            WriteStartElement(n, ns, o);
            if (needType) WriteXsiType(@"PortType", @"http://schemas.xmlsoap.org/wsdl/");
            WriteAttribute(@"name", @"", FromXmlNCName((System.String)o.@Name));
            if (((System.String)o.@Documentation) != @"") {
                WriteElementString(@"documentation", @"http://schemas.xmlsoap.org/wsdl/", ((System.String)o.@Documentation));
            }
            {
                System.Web.Services.Description.OperationCollection a = (System.Web.Services.Description.OperationCollection)o.@Operations;
                if (a != null) {
                    for (int ia = 0; ia < a.Count; ia++) {
                        Write71_Operation(@"operation", @"http://schemas.xmlsoap.org/wsdl/", ((System.Web.Services.Description.Operation)a[ia]), false, false);
                    }
                }
            }
            WriteEndElement(o);
        }

        void Write71_Operation(string n, string ns, System.Web.Services.Description.Operation o, bool isNullable, bool needType) {
            if ((object)o == null) {
                if (isNullable) WriteNullTagLiteral(n, ns);
                return;
            }
            if (!needType) {
                System.Type t = o.GetType();
                if (t == typeof(System.Web.Services.Description.Operation))
                    ;
                else {
                    throw CreateUnknownTypeException(o);
                }
            }
            WriteStartElement(n, ns, o);
            if (needType) WriteXsiType(@"Operation", @"http://schemas.xmlsoap.org/wsdl/");
            WriteAttribute(@"name", @"", FromXmlNCName((System.String)o.@Name));
            if ((System.String)o.@ParameterOrderString != @"") {
                WriteAttribute(@"parameterOrder", @"", (System.String)o.@ParameterOrderString);
            }
            if (((System.String)o.@Documentation) != @"") {
                WriteElementString(@"documentation", @"http://schemas.xmlsoap.org/wsdl/", ((System.String)o.@Documentation));
            }
            {
                System.Web.Services.Description.OperationMessageCollection a = (System.Web.Services.Description.OperationMessageCollection)o.@Messages;
                if (a != null) {
                    for (int ia = 0; ia < a.Count; ia++) {
                        System.Web.Services.Description.OperationMessage ai = a[ia];
                        {
                            if (ai is System.Web.Services.Description.OperationOutput) {
                                Write74_OperationOutput(@"output", @"http://schemas.xmlsoap.org/wsdl/", ((System.Web.Services.Description.OperationOutput)ai), false, false);
                            }
                            else if (ai is System.Web.Services.Description.OperationInput) {
                                Write72_OperationInput(@"input", @"http://schemas.xmlsoap.org/wsdl/", ((System.Web.Services.Description.OperationInput)ai), false, false);
                            }
                            else {
                                if (ai != null) {
                                    throw CreateUnknownTypeException(ai);
                                }
                            }
                        }
                    }
                }
            }
            {
                System.Web.Services.Description.OperationFaultCollection a = (System.Web.Services.Description.OperationFaultCollection)o.@Faults;
                if (a != null) {
                    for (int ia = 0; ia < a.Count; ia++) {
                        Write75_OperationFault(@"fault", @"http://schemas.xmlsoap.org/wsdl/", ((System.Web.Services.Description.OperationFault)a[ia]), false, false);
                    }
                }
            }
            WriteEndElement(o);
        }

        void Write72_OperationInput(string n, string ns, System.Web.Services.Description.OperationInput o, bool isNullable, bool needType) {
            if ((object)o == null) {
                if (isNullable) WriteNullTagLiteral(n, ns);
                return;
            }
            if (!needType) {
                System.Type t = o.GetType();
                if (t == typeof(System.Web.Services.Description.OperationInput))
                    ;
                else {
                    throw CreateUnknownTypeException(o);
                }
            }
            WriteStartElement(n, ns, o);
            if (needType) WriteXsiType(@"OperationInput", @"http://schemas.xmlsoap.org/wsdl/");
            WriteAttribute(@"name", @"", FromXmlNmToken((System.String)o.@Name));
            WriteAttribute(@"message", @"", FromXmlQualifiedName((System.Xml.XmlQualifiedName)o.@Message));
            if (((System.String)o.@Documentation) != @"") {
                WriteElementString(@"documentation", @"http://schemas.xmlsoap.org/wsdl/", ((System.String)o.@Documentation));
            }
            WriteEndElement(o);
        }

        void Write73_OperationMessage(string n, string ns, System.Web.Services.Description.OperationMessage o, bool isNullable, bool needType) {
            if ((object)o == null) {
                if (isNullable) WriteNullTagLiteral(n, ns);
                return;
            }
            if (!needType) {
                System.Type t = o.GetType();
                if (t == typeof(System.Web.Services.Description.OperationMessage))
                    ;
                else if (t == typeof(System.Web.Services.Description.OperationFault)) {
                    Write75_OperationFault(n, ns, (System.Web.Services.Description.OperationFault)o, isNullable, true);
                    return;
                }
                else if (t == typeof(System.Web.Services.Description.OperationOutput)) {
                    Write74_OperationOutput(n, ns, (System.Web.Services.Description.OperationOutput)o, isNullable, true);
                    return;
                }
                else if (t == typeof(System.Web.Services.Description.OperationInput)) {
                    Write72_OperationInput(n, ns, (System.Web.Services.Description.OperationInput)o, isNullable, true);
                    return;
                }
                else {
                    throw CreateUnknownTypeException(o);
                }
            }
        }

        void Write74_OperationOutput(string n, string ns, System.Web.Services.Description.OperationOutput o, bool isNullable, bool needType) {
            if ((object)o == null) {
                if (isNullable) WriteNullTagLiteral(n, ns);
                return;
            }
            if (!needType) {
                System.Type t = o.GetType();
                if (t == typeof(System.Web.Services.Description.OperationOutput))
                    ;
                else {
                    throw CreateUnknownTypeException(o);
                }
            }
            WriteStartElement(n, ns, o);
            if (needType) WriteXsiType(@"OperationOutput", @"http://schemas.xmlsoap.org/wsdl/");
            WriteAttribute(@"name", @"", FromXmlNmToken((System.String)o.@Name));
            WriteAttribute(@"message", @"", FromXmlQualifiedName((System.Xml.XmlQualifiedName)o.@Message));
            if (((System.String)o.@Documentation) != @"") {
                WriteElementString(@"documentation", @"http://schemas.xmlsoap.org/wsdl/", ((System.String)o.@Documentation));
            }
            WriteEndElement(o);
        }

        void Write75_OperationFault(string n, string ns, System.Web.Services.Description.OperationFault o, bool isNullable, bool needType) {
            if ((object)o == null) {
                if (isNullable) WriteNullTagLiteral(n, ns);
                return;
            }
            if (!needType) {
                System.Type t = o.GetType();
                if (t == typeof(System.Web.Services.Description.OperationFault))
                    ;
                else {
                    throw CreateUnknownTypeException(o);
                }
            }
            WriteStartElement(n, ns, o);
            if (needType) WriteXsiType(@"OperationFault", @"http://schemas.xmlsoap.org/wsdl/");
            WriteAttribute(@"name", @"", FromXmlNmToken((System.String)o.@Name));
            WriteAttribute(@"message", @"", FromXmlQualifiedName((System.Xml.XmlQualifiedName)o.@Message));
            if (((System.String)o.@Documentation) != @"") {
                WriteElementString(@"documentation", @"http://schemas.xmlsoap.org/wsdl/", ((System.String)o.@Documentation));
            }
            WriteEndElement(o);
        }

        void Write76_Binding(string n, string ns, System.Web.Services.Description.Binding o, bool isNullable, bool needType) {
            if ((object)o == null) {
                if (isNullable) WriteNullTagLiteral(n, ns);
                return;
            }
            if (!needType) {
                System.Type t = o.GetType();
                if (t == typeof(System.Web.Services.Description.Binding))
                    ;
                else {
                    throw CreateUnknownTypeException(o);
                }
            }
            WriteStartElement(n, ns, o);
            if (needType) WriteXsiType(@"Binding", @"http://schemas.xmlsoap.org/wsdl/");
            WriteAttribute(@"name", @"", FromXmlNCName((System.String)o.@Name));
            WriteAttribute(@"type", @"", FromXmlQualifiedName((System.Xml.XmlQualifiedName)o.@Type));
            if (((System.String)o.@Documentation) != @"") {
                WriteElementString(@"documentation", @"http://schemas.xmlsoap.org/wsdl/", ((System.String)o.@Documentation));
            }
            {
                System.Web.Services.Description.ServiceDescriptionFormatExtensionCollection a = (System.Web.Services.Description.ServiceDescriptionFormatExtensionCollection)o.@Extensions;
                if (a != null) {
                    for (int ia = 0; ia < a.Count; ia++) {
                        System.Object ai = a[ia];
                        {
                            if (ai is System.Web.Services.Description.HttpBinding) {
                                Write77_HttpBinding(@"binding", @"http://schemas.xmlsoap.org/wsdl/http/", ((System.Web.Services.Description.HttpBinding)ai), false, false);
                            }
                            else if (ai is System.Web.Services.Description.SoapBinding) {
                                Write79_SoapBinding(@"binding", @"http://schemas.xmlsoap.org/wsdl/soap/", ((System.Web.Services.Description.SoapBinding)ai), false, false);
                            }
                            else if (ai is System.Xml.XmlElement) {
                                System.Xml.XmlElement elem = (System.Xml.XmlElement)ai;
                                WriteElementLiteral(elem, @"", "", false, true);
                            }
                            else {
                                if (ai != null) {
                                    throw CreateUnknownTypeException(ai);
                                }
                            }
                        }
                    }
                }
            }
            {
                System.Web.Services.Description.OperationBindingCollection a = (System.Web.Services.Description.OperationBindingCollection)o.@Operations;
                if (a != null) {
                    for (int ia = 0; ia < a.Count; ia++) {
                        Write82_OperationBinding(@"operation", @"http://schemas.xmlsoap.org/wsdl/", ((System.Web.Services.Description.OperationBinding)a[ia]), false, false);
                    }
                }
            }
            WriteEndElement(o);
        }

        void Write77_HttpBinding(string n, string ns, System.Web.Services.Description.HttpBinding o, bool isNullable, bool needType) {
            if ((object)o == null) {
                if (isNullable) WriteNullTagLiteral(n, ns);
                return;
            }
            if (!needType) {
                System.Type t = o.GetType();
                if (t == typeof(System.Web.Services.Description.HttpBinding))
                    ;
                else {
                    throw CreateUnknownTypeException(o);
                }
            }
            WriteStartElement(n, ns, o);
            if (needType) WriteXsiType(@"HttpBinding", @"http://schemas.xmlsoap.org/wsdl/http/");
            if ((System.Boolean)o.@Required != false) {
                WriteAttribute(@"required", @"http://schemas.xmlsoap.org/wsdl/", System.Xml.XmlConvert.ToString((System.Boolean)(System.Boolean)o.@Required));
            }
            WriteAttribute(@"verb", @"", FromXmlNmToken((System.String)o.@Verb));
            WriteEndElement(o);
        }

        void Write78_ServiceDescriptionFormatExtension(string n, string ns, System.Web.Services.Description.ServiceDescriptionFormatExtension o, bool isNullable, bool needType) {
            if ((object)o == null) {
                if (isNullable) WriteNullTagLiteral(n, ns);
                return;
            }
            if (!needType) {
                System.Type t = o.GetType();
                if (t == typeof(System.Web.Services.Description.ServiceDescriptionFormatExtension))
                    ;
                else if (t == typeof(System.Web.Services.Description.HttpAddressBinding)) {
                    Write106_HttpAddressBinding(n, ns, (System.Web.Services.Description.HttpAddressBinding)o, isNullable, true);
                    return;
                }
                else if (t == typeof(System.Web.Services.Description.HttpUrlReplacementBinding)) {
                    Write88_HttpUrlReplacementBinding(n, ns, (System.Web.Services.Description.HttpUrlReplacementBinding)o, isNullable, true);
                    return;
                }
                else if (t == typeof(System.Web.Services.Description.HttpUrlEncodedBinding)) {
                    Write87_HttpUrlEncodedBinding(n, ns, (System.Web.Services.Description.HttpUrlEncodedBinding)o, isNullable, true);
                    return;
                }
                else if (t == typeof(System.Web.Services.Description.HttpOperationBinding)) {
                    Write83_HttpOperationBinding(n, ns, (System.Web.Services.Description.HttpOperationBinding)o, isNullable, true);
                    return;
                }
                else if (t == typeof(System.Web.Services.Description.HttpBinding)) {
                    Write77_HttpBinding(n, ns, (System.Web.Services.Description.HttpBinding)o, isNullable, true);
                    return;
                }
                else {
                    throw CreateUnknownTypeException(o);
                }
            }
        }

        void Write79_SoapBinding(string n, string ns, System.Web.Services.Description.SoapBinding o, bool isNullable, bool needType) {
            if ((object)o == null) {
                if (isNullable) WriteNullTagLiteral(n, ns);
                return;
            }
            if (!needType) {
                System.Type t = o.GetType();
                if (t == typeof(System.Web.Services.Description.SoapBinding))
                    ;
                else {
                    throw CreateUnknownTypeException(o);
                }
            }
            WriteStartElement(n, ns, o);
            if (needType) WriteXsiType(@"SoapBinding", @"http://schemas.xmlsoap.org/wsdl/soap/");
            if ((System.Boolean)o.@Required != false) {
                WriteAttribute(@"required", @"http://schemas.xmlsoap.org/wsdl/", System.Xml.XmlConvert.ToString((System.Boolean)(System.Boolean)o.@Required));
            }
            WriteAttribute(@"transport", @"", (System.String)o.@Transport);
            if ((System.Web.Services.Description.SoapBindingStyle)o.@Style != System.Web.Services.Description.SoapBindingStyle.@Default) {
                WriteAttribute(@"style", @"", Write81_SoapBindingStyle((System.Web.Services.Description.SoapBindingStyle)o.@Style));
            }
            WriteEndElement(o);
        }

        void Write80_ServiceDescriptionFormatExtension(string n, string ns, System.Web.Services.Description.ServiceDescriptionFormatExtension o, bool isNullable, bool needType) {
            if ((object)o == null) {
                if (isNullable) WriteNullTagLiteral(n, ns);
                return;
            }
            if (!needType) {
                System.Type t = o.GetType();
                if (t == typeof(System.Web.Services.Description.ServiceDescriptionFormatExtension))
                    ;
                else if (t == typeof(System.Web.Services.Description.SoapAddressBinding)) {
                    Write107_SoapAddressBinding(n, ns, (System.Web.Services.Description.SoapAddressBinding)o, isNullable, true);
                    return;
                }
                else if (t == typeof(System.Web.Services.Description.SoapFaultBinding)) {
                    Write103_SoapFaultBinding(n, ns, (System.Web.Services.Description.SoapFaultBinding)o, isNullable, true);
                    return;
                }
                else if (t == typeof(System.Web.Services.Description.SoapHeaderFaultBinding)) {
                    Write100_SoapHeaderFaultBinding(n, ns, (System.Web.Services.Description.SoapHeaderFaultBinding)o, isNullable, true);
                    return;
                }
                else if (t == typeof(System.Web.Services.Description.SoapHeaderBinding)) {
                    Write99_SoapHeaderBinding(n, ns, (System.Web.Services.Description.SoapHeaderBinding)o, isNullable, true);
                    return;
                }
                else if (t == typeof(System.Web.Services.Description.SoapBodyBinding)) {
                    Write97_SoapBodyBinding(n, ns, (System.Web.Services.Description.SoapBodyBinding)o, isNullable, true);
                    return;
                }
                else if (t == typeof(System.Web.Services.Description.SoapOperationBinding)) {
                    Write84_SoapOperationBinding(n, ns, (System.Web.Services.Description.SoapOperationBinding)o, isNullable, true);
                    return;
                }
                else if (t == typeof(System.Web.Services.Description.SoapBinding)) {
                    Write79_SoapBinding(n, ns, (System.Web.Services.Description.SoapBinding)o, isNullable, true);
                    return;
                }
                else {
                    throw CreateUnknownTypeException(o);
                }
            }
        }

        string Write81_SoapBindingStyle(System.Web.Services.Description.SoapBindingStyle v) {
            string s = null;
            switch (v) {
                case System.Web.Services.Description.SoapBindingStyle.@Document: s = @"document"; break;
                case System.Web.Services.Description.SoapBindingStyle.@Rpc: s = @"rpc"; break;
                default: s = ((System.Int64)v).ToString(); break;
            }
            return s;
        }

        void Write82_OperationBinding(string n, string ns, System.Web.Services.Description.OperationBinding o, bool isNullable, bool needType) {
            if ((object)o == null) {
                if (isNullable) WriteNullTagLiteral(n, ns);
                return;
            }
            if (!needType) {
                System.Type t = o.GetType();
                if (t == typeof(System.Web.Services.Description.OperationBinding))
                    ;
                else {
                    throw CreateUnknownTypeException(o);
                }
            }
            WriteStartElement(n, ns, o);
            if (needType) WriteXsiType(@"OperationBinding", @"http://schemas.xmlsoap.org/wsdl/");
            WriteAttribute(@"name", @"", FromXmlNCName((System.String)o.@Name));
            if (((System.String)o.@Documentation) != @"") {
                WriteElementString(@"documentation", @"http://schemas.xmlsoap.org/wsdl/", ((System.String)o.@Documentation));
            }
            {
                System.Web.Services.Description.ServiceDescriptionFormatExtensionCollection a = (System.Web.Services.Description.ServiceDescriptionFormatExtensionCollection)o.@Extensions;
                if (a != null) {
                    for (int ia = 0; ia < a.Count; ia++) {
                        System.Object ai = a[ia];
                        {
                            if (ai is System.Web.Services.Description.SoapOperationBinding) {
                                Write84_SoapOperationBinding(@"operation", @"http://schemas.xmlsoap.org/wsdl/soap/", ((System.Web.Services.Description.SoapOperationBinding)ai), false, false);
                            }
                            else if (ai is System.Web.Services.Description.HttpOperationBinding) {
                                Write83_HttpOperationBinding(@"operation", @"http://schemas.xmlsoap.org/wsdl/http/", ((System.Web.Services.Description.HttpOperationBinding)ai), false, false);
                            }
                            else if (ai is System.Xml.XmlElement) {
                                System.Xml.XmlElement elem = (System.Xml.XmlElement)ai;
                                WriteElementLiteral(elem, @"", "", false, true);
                            }
                            else {
                                if (ai != null) {
                                    throw CreateUnknownTypeException(ai);
                                }
                            }
                        }
                    }
                }
            }
            Write85_InputBinding(@"input", @"http://schemas.xmlsoap.org/wsdl/", ((System.Web.Services.Description.InputBinding)o.@Input), false, false);
            Write101_OutputBinding(@"output", @"http://schemas.xmlsoap.org/wsdl/", ((System.Web.Services.Description.OutputBinding)o.@Output), false, false);
            {
                System.Web.Services.Description.FaultBindingCollection a = (System.Web.Services.Description.FaultBindingCollection)o.@Faults;
                if (a != null) {
                    for (int ia = 0; ia < a.Count; ia++) {
                        Write102_FaultBinding(@"fault", @"http://schemas.xmlsoap.org/wsdl/", ((System.Web.Services.Description.FaultBinding)a[ia]), false, false);
                    }
                }
            }
            WriteEndElement(o);
        }

        void Write83_HttpOperationBinding(string n, string ns, System.Web.Services.Description.HttpOperationBinding o, bool isNullable, bool needType) {
            if ((object)o == null) {
                if (isNullable) WriteNullTagLiteral(n, ns);
                return;
            }
            if (!needType) {
                System.Type t = o.GetType();
                if (t == typeof(System.Web.Services.Description.HttpOperationBinding))
                    ;
                else {
                    throw CreateUnknownTypeException(o);
                }
            }
            WriteStartElement(n, ns, o);
            if (needType) WriteXsiType(@"HttpOperationBinding", @"http://schemas.xmlsoap.org/wsdl/http/");
            if ((System.Boolean)o.@Required != false) {
                WriteAttribute(@"required", @"http://schemas.xmlsoap.org/wsdl/", System.Xml.XmlConvert.ToString((System.Boolean)(System.Boolean)o.@Required));
            }
            WriteAttribute(@"location", @"", (System.String)o.@Location);
            WriteEndElement(o);
        }

        void Write84_SoapOperationBinding(string n, string ns, System.Web.Services.Description.SoapOperationBinding o, bool isNullable, bool needType) {
            if ((object)o == null) {
                if (isNullable) WriteNullTagLiteral(n, ns);
                return;
            }
            if (!needType) {
                System.Type t = o.GetType();
                if (t == typeof(System.Web.Services.Description.SoapOperationBinding))
                    ;
                else {
                    throw CreateUnknownTypeException(o);
                }
            }
            WriteStartElement(n, ns, o);
            if (needType) WriteXsiType(@"SoapOperationBinding", @"http://schemas.xmlsoap.org/wsdl/soap/");
            if ((System.Boolean)o.@Required != false) {
                WriteAttribute(@"required", @"http://schemas.xmlsoap.org/wsdl/", System.Xml.XmlConvert.ToString((System.Boolean)(System.Boolean)o.@Required));
            }
            WriteAttribute(@"soapAction", @"", (System.String)o.@SoapAction);
            if ((System.Web.Services.Description.SoapBindingStyle)o.@Style != System.Web.Services.Description.SoapBindingStyle.@Default) {
                WriteAttribute(@"style", @"", Write81_SoapBindingStyle((System.Web.Services.Description.SoapBindingStyle)o.@Style));
            }
            WriteEndElement(o);
        }

        void Write85_InputBinding(string n, string ns, System.Web.Services.Description.InputBinding o, bool isNullable, bool needType) {
            if ((object)o == null) {
                if (isNullable) WriteNullTagLiteral(n, ns);
                return;
            }
            if (!needType) {
                System.Type t = o.GetType();
                if (t == typeof(System.Web.Services.Description.InputBinding))
                    ;
                else {
                    throw CreateUnknownTypeException(o);
                }
            }
            WriteStartElement(n, ns, o);
            if (needType) WriteXsiType(@"InputBinding", @"http://schemas.xmlsoap.org/wsdl/");
            WriteAttribute(@"name", @"", FromXmlNmToken((System.String)o.@Name));
            if (((System.String)o.@Documentation) != @"") {
                WriteElementString(@"documentation", @"http://schemas.xmlsoap.org/wsdl/", ((System.String)o.@Documentation));
            }
            {
                System.Web.Services.Description.ServiceDescriptionFormatExtensionCollection a = (System.Web.Services.Description.ServiceDescriptionFormatExtensionCollection)o.@Extensions;
                if (a != null) {
                    for (int ia = 0; ia < a.Count; ia++) {
                        System.Object ai = a[ia];
                        {
                            if (ai is System.Web.Services.Description.MimeTextBinding) {
                                Write94_MimeTextBinding(@"text", @"http://microsoft.com/wsdl/mime/textMatching/", ((System.Web.Services.Description.MimeTextBinding)ai), false, false);
                            }
                            else if (ai is System.Web.Services.Description.SoapBodyBinding) {
                                Write97_SoapBodyBinding(@"body", @"http://schemas.xmlsoap.org/wsdl/soap/", ((System.Web.Services.Description.SoapBodyBinding)ai), false, false);
                            }
                            else if (ai is System.Web.Services.Description.MimeContentBinding) {
                                Write89_MimeContentBinding(@"content", @"http://schemas.xmlsoap.org/wsdl/mime/", ((System.Web.Services.Description.MimeContentBinding)ai), false, false);
                            }
                            else if (ai is System.Web.Services.Description.SoapHeaderBinding) {
                                Write99_SoapHeaderBinding(@"header", @"http://schemas.xmlsoap.org/wsdl/soap/", ((System.Web.Services.Description.SoapHeaderBinding)ai), false, false);
                            }
                            else if (ai is System.Web.Services.Description.MimeXmlBinding) {
                                Write91_MimeXmlBinding(@"mimeXml", @"http://schemas.xmlsoap.org/wsdl/mime/", ((System.Web.Services.Description.MimeXmlBinding)ai), false, false);
                            }
                            else if (ai is System.Web.Services.Description.HttpUrlReplacementBinding) {
                                Write88_HttpUrlReplacementBinding(@"urlReplacement", @"http://schemas.xmlsoap.org/wsdl/http/", ((System.Web.Services.Description.HttpUrlReplacementBinding)ai), false, false);
                            }
                            else if (ai is System.Web.Services.Description.HttpUrlEncodedBinding) {
                                Write87_HttpUrlEncodedBinding(@"urlEncoded", @"http://schemas.xmlsoap.org/wsdl/http/", ((System.Web.Services.Description.HttpUrlEncodedBinding)ai), false, false);
                            }
                            else if (ai is System.Web.Services.Description.MimeMultipartRelatedBinding) {
                                Write92_MimeMultipartRelatedBinding(@"multipartRelated", @"http://schemas.xmlsoap.org/wsdl/mime/", ((System.Web.Services.Description.MimeMultipartRelatedBinding)ai), false, false);
                            }
                            else if (ai is System.Xml.XmlElement) {
                                System.Xml.XmlElement elem = (System.Xml.XmlElement)ai;
                                WriteElementLiteral(elem, @"", "", false, true);
                            }
                            else {
                                if (ai != null) {
                                    throw CreateUnknownTypeException(ai);
                                }
                            }
                        }
                    }
                }
            }
            WriteEndElement(o);
        }

        void Write86_MessageBinding(string n, string ns, System.Web.Services.Description.MessageBinding o, bool isNullable, bool needType) {
            if ((object)o == null) {
                if (isNullable) WriteNullTagLiteral(n, ns);
                return;
            }
            if (!needType) {
                System.Type t = o.GetType();
                if (t == typeof(System.Web.Services.Description.MessageBinding))
                    ;
                else if (t == typeof(System.Web.Services.Description.FaultBinding)) {
                    Write102_FaultBinding(n, ns, (System.Web.Services.Description.FaultBinding)o, isNullable, true);
                    return;
                }
                else if (t == typeof(System.Web.Services.Description.OutputBinding)) {
                    Write101_OutputBinding(n, ns, (System.Web.Services.Description.OutputBinding)o, isNullable, true);
                    return;
                }
                else if (t == typeof(System.Web.Services.Description.InputBinding)) {
                    Write85_InputBinding(n, ns, (System.Web.Services.Description.InputBinding)o, isNullable, true);
                    return;
                }
                else {
                    throw CreateUnknownTypeException(o);
                }
            }
        }

        void Write87_HttpUrlEncodedBinding(string n, string ns, System.Web.Services.Description.HttpUrlEncodedBinding o, bool isNullable, bool needType) {
            if ((object)o == null) {
                if (isNullable) WriteNullTagLiteral(n, ns);
                return;
            }
            if (!needType) {
                System.Type t = o.GetType();
                if (t == typeof(System.Web.Services.Description.HttpUrlEncodedBinding))
                    ;
                else {
                    throw CreateUnknownTypeException(o);
                }
            }
            WriteStartElement(n, ns, o);
            if (needType) WriteXsiType(@"HttpUrlEncodedBinding", @"http://schemas.xmlsoap.org/wsdl/http/");
            if ((System.Boolean)o.@Required != false) {
                WriteAttribute(@"required", @"http://schemas.xmlsoap.org/wsdl/", System.Xml.XmlConvert.ToString((System.Boolean)(System.Boolean)o.@Required));
            }
            WriteEndElement(o);
        }

        void Write88_HttpUrlReplacementBinding(string n, string ns, System.Web.Services.Description.HttpUrlReplacementBinding o, bool isNullable, bool needType) {
            if ((object)o == null) {
                if (isNullable) WriteNullTagLiteral(n, ns);
                return;
            }
            if (!needType) {
                System.Type t = o.GetType();
                if (t == typeof(System.Web.Services.Description.HttpUrlReplacementBinding))
                    ;
                else {
                    throw CreateUnknownTypeException(o);
                }
            }
            WriteStartElement(n, ns, o);
            if (needType) WriteXsiType(@"HttpUrlReplacementBinding", @"http://schemas.xmlsoap.org/wsdl/http/");
            if ((System.Boolean)o.@Required != false) {
                WriteAttribute(@"required", @"http://schemas.xmlsoap.org/wsdl/", System.Xml.XmlConvert.ToString((System.Boolean)(System.Boolean)o.@Required));
            }
            WriteEndElement(o);
        }

        void Write89_MimeContentBinding(string n, string ns, System.Web.Services.Description.MimeContentBinding o, bool isNullable, bool needType) {
            if ((object)o == null) {
                if (isNullable) WriteNullTagLiteral(n, ns);
                return;
            }
            if (!needType) {
                System.Type t = o.GetType();
                if (t == typeof(System.Web.Services.Description.MimeContentBinding))
                    ;
                else {
                    throw CreateUnknownTypeException(o);
                }
            }
            WriteStartElement(n, ns, o);
            if (needType) WriteXsiType(@"MimeContentBinding", @"http://schemas.xmlsoap.org/wsdl/mime/");
            if ((System.Boolean)o.@Required != false) {
                WriteAttribute(@"required", @"http://schemas.xmlsoap.org/wsdl/", System.Xml.XmlConvert.ToString((System.Boolean)(System.Boolean)o.@Required));
            }
            WriteAttribute(@"part", @"", FromXmlNmToken((System.String)o.@Part));
            WriteAttribute(@"type", @"", (System.String)o.@Type);
            WriteEndElement(o);
        }

        void Write90_ServiceDescriptionFormatExtension(string n, string ns, System.Web.Services.Description.ServiceDescriptionFormatExtension o, bool isNullable, bool needType) {
            if ((object)o == null) {
                if (isNullable) WriteNullTagLiteral(n, ns);
                return;
            }
            if (!needType) {
                System.Type t = o.GetType();
                if (t == typeof(System.Web.Services.Description.ServiceDescriptionFormatExtension))
                    ;
                else if (t == typeof(System.Web.Services.Description.MimePart)) {
                    Write93_MimePart(n, ns, (System.Web.Services.Description.MimePart)o, isNullable, true);
                    return;
                }
                else if (t == typeof(System.Web.Services.Description.MimeMultipartRelatedBinding)) {
                    Write92_MimeMultipartRelatedBinding(n, ns, (System.Web.Services.Description.MimeMultipartRelatedBinding)o, isNullable, true);
                    return;
                }
                else if (t == typeof(System.Web.Services.Description.MimeXmlBinding)) {
                    Write91_MimeXmlBinding(n, ns, (System.Web.Services.Description.MimeXmlBinding)o, isNullable, true);
                    return;
                }
                else if (t == typeof(System.Web.Services.Description.MimeContentBinding)) {
                    Write89_MimeContentBinding(n, ns, (System.Web.Services.Description.MimeContentBinding)o, isNullable, true);
                    return;
                }
                else {
                    throw CreateUnknownTypeException(o);
                }
            }
        }

        void Write91_MimeXmlBinding(string n, string ns, System.Web.Services.Description.MimeXmlBinding o, bool isNullable, bool needType) {
            if ((object)o == null) {
                if (isNullable) WriteNullTagLiteral(n, ns);
                return;
            }
            if (!needType) {
                System.Type t = o.GetType();
                if (t == typeof(System.Web.Services.Description.MimeXmlBinding))
                    ;
                else {
                    throw CreateUnknownTypeException(o);
                }
            }
            WriteStartElement(n, ns, o);
            if (needType) WriteXsiType(@"MimeXmlBinding", @"http://schemas.xmlsoap.org/wsdl/mime/");
            if ((System.Boolean)o.@Required != false) {
                WriteAttribute(@"required", @"http://schemas.xmlsoap.org/wsdl/", System.Xml.XmlConvert.ToString((System.Boolean)(System.Boolean)o.@Required));
            }
            WriteAttribute(@"part", @"", FromXmlNmToken((System.String)o.@Part));
            WriteEndElement(o);
        }

        void Write92_MimeMultipartRelatedBinding(string n, string ns, System.Web.Services.Description.MimeMultipartRelatedBinding o, bool isNullable, bool needType) {
            if ((object)o == null) {
                if (isNullable) WriteNullTagLiteral(n, ns);
                return;
            }
            if (!needType) {
                System.Type t = o.GetType();
                if (t == typeof(System.Web.Services.Description.MimeMultipartRelatedBinding))
                    ;
                else {
                    throw CreateUnknownTypeException(o);
                }
            }
            WriteStartElement(n, ns, o);
            if (needType) WriteXsiType(@"MimeMultipartRelatedBinding", @"http://schemas.xmlsoap.org/wsdl/mime/");
            if ((System.Boolean)o.@Required != false) {
                WriteAttribute(@"required", @"http://schemas.xmlsoap.org/wsdl/", System.Xml.XmlConvert.ToString((System.Boolean)(System.Boolean)o.@Required));
            }
            {
                System.Web.Services.Description.MimePartCollection a = (System.Web.Services.Description.MimePartCollection)o.@Parts;
                if (a != null) {
                    for (int ia = 0; ia < a.Count; ia++) {
                        Write93_MimePart(@"part", @"http://schemas.xmlsoap.org/wsdl/mime/", ((System.Web.Services.Description.MimePart)a[ia]), false, false);
                    }
                }
            }
            WriteEndElement(o);
        }

        void Write93_MimePart(string n, string ns, System.Web.Services.Description.MimePart o, bool isNullable, bool needType) {
            if ((object)o == null) {
                if (isNullable) WriteNullTagLiteral(n, ns);
                return;
            }
            if (!needType) {
                System.Type t = o.GetType();
                if (t == typeof(System.Web.Services.Description.MimePart))
                    ;
                else {
                    throw CreateUnknownTypeException(o);
                }
            }
            WriteStartElement(n, ns, o);
            if (needType) WriteXsiType(@"MimePart", @"http://schemas.xmlsoap.org/wsdl/mime/");
            if ((System.Boolean)o.@Required != false) {
                WriteAttribute(@"required", @"http://schemas.xmlsoap.org/wsdl/", System.Xml.XmlConvert.ToString((System.Boolean)(System.Boolean)o.@Required));
            }
            {
                System.Web.Services.Description.ServiceDescriptionFormatExtensionCollection a = (System.Web.Services.Description.ServiceDescriptionFormatExtensionCollection)o.@Extensions;
                if (a != null) {
                    for (int ia = 0; ia < a.Count; ia++) {
                        System.Object ai = a[ia];
                        {
                            if (ai is System.Web.Services.Description.SoapBodyBinding) {
                                Write97_SoapBodyBinding(@"body", @"http://schemas.xmlsoap.org/wsdl/soap/", ((System.Web.Services.Description.SoapBodyBinding)ai), false, false);
                            }
                            else if (ai is System.Web.Services.Description.MimeXmlBinding) {
                                Write91_MimeXmlBinding(@"mimeXml", @"http://schemas.xmlsoap.org/wsdl/mime/", ((System.Web.Services.Description.MimeXmlBinding)ai), false, false);
                            }
                            else if (ai is System.Web.Services.Description.MimeContentBinding) {
                                Write89_MimeContentBinding(@"content", @"http://schemas.xmlsoap.org/wsdl/mime/", ((System.Web.Services.Description.MimeContentBinding)ai), false, false);
                            }
                            else if (ai is System.Web.Services.Description.MimeTextBinding) {
                                Write94_MimeTextBinding(@"text", @"http://microsoft.com/wsdl/mime/textMatching/", ((System.Web.Services.Description.MimeTextBinding)ai), false, false);
                            }
                            else if (ai is System.Xml.XmlElement) {
                                System.Xml.XmlElement elem = (System.Xml.XmlElement)ai;
                                WriteElementLiteral(elem, @"", "", false, true);
                            }
                            else {
                                if (ai != null) {
                                    throw CreateUnknownTypeException(ai);
                                }
                            }
                        }
                    }
                }
            }
            WriteEndElement(o);
        }

        void Write94_MimeTextBinding(string n, string ns, System.Web.Services.Description.MimeTextBinding o, bool isNullable, bool needType) {
            if ((object)o == null) {
                if (isNullable) WriteNullTagLiteral(n, ns);
                return;
            }
            if (!needType) {
                System.Type t = o.GetType();
                if (t == typeof(System.Web.Services.Description.MimeTextBinding))
                    ;
                else {
                    throw CreateUnknownTypeException(o);
                }
            }
            WriteStartElement(n, ns, o);
            if (needType) WriteXsiType(@"MimeTextBinding", @"http://microsoft.com/wsdl/mime/textMatching/");
            if ((System.Boolean)o.@Required != false) {
                WriteAttribute(@"required", @"http://schemas.xmlsoap.org/wsdl/", System.Xml.XmlConvert.ToString((System.Boolean)(System.Boolean)o.@Required));
            }
            {
                System.Web.Services.Description.MimeTextMatchCollection a = (System.Web.Services.Description.MimeTextMatchCollection)o.@Matches;
                if (a != null) {
                    for (int ia = 0; ia < a.Count; ia++) {
                        Write96_MimeTextMatch(@"match", @"http://microsoft.com/wsdl/mime/textMatching/", ((System.Web.Services.Description.MimeTextMatch)a[ia]), false, false);
                    }
                }
            }
            WriteEndElement(o);
        }

        void Write95_ServiceDescriptionFormatExtension(string n, string ns, System.Web.Services.Description.ServiceDescriptionFormatExtension o, bool isNullable, bool needType) {
            if ((object)o == null) {
                if (isNullable) WriteNullTagLiteral(n, ns);
                return;
            }
            if (!needType) {
                System.Type t = o.GetType();
                if (t == typeof(System.Web.Services.Description.ServiceDescriptionFormatExtension))
                    ;
                else if (t == typeof(System.Web.Services.Description.MimeTextBinding)) {
                    Write94_MimeTextBinding(n, ns, (System.Web.Services.Description.MimeTextBinding)o, isNullable, true);
                    return;
                }
                else {
                    throw CreateUnknownTypeException(o);
                }
            }
        }

        void Write96_MimeTextMatch(string n, string ns, System.Web.Services.Description.MimeTextMatch o, bool isNullable, bool needType) {
            if ((object)o == null) {
                if (isNullable) WriteNullTagLiteral(n, ns);
                return;
            }
            if (!needType) {
                System.Type t = o.GetType();
                if (t == typeof(System.Web.Services.Description.MimeTextMatch))
                    ;
                else {
                    throw CreateUnknownTypeException(o);
                }
            }
            WriteStartElement(n, ns, o);
            if (needType) WriteXsiType(@"MimeTextMatch", @"http://microsoft.com/wsdl/mime/textMatching/");
            WriteAttribute(@"name", @"", (System.String)o.@Name);
            WriteAttribute(@"type", @"", (System.String)o.@Type);
            if ((System.Int32)o.@Group != 1) {
                WriteAttribute(@"group", @"", System.Xml.XmlConvert.ToString((System.Int32)(System.Int32)o.@Group));
            }
            if ((System.Int32)o.@Capture != 0) {
                WriteAttribute(@"capture", @"", System.Xml.XmlConvert.ToString((System.Int32)(System.Int32)o.@Capture));
            }
            if ((System.String)o.@RepeatsString != @"1") {
                WriteAttribute(@"repeats", @"", (System.String)o.@RepeatsString);
            }
            WriteAttribute(@"pattern", @"", (System.String)o.@Pattern);
            WriteAttribute(@"ignoreCase", @"", System.Xml.XmlConvert.ToString((System.Boolean)(System.Boolean)o.@IgnoreCase));
            {
                System.Web.Services.Description.MimeTextMatchCollection a = (System.Web.Services.Description.MimeTextMatchCollection)o.@Matches;
                if (a != null) {
                    for (int ia = 0; ia < a.Count; ia++) {
                        Write96_MimeTextMatch(@"match", @"http://microsoft.com/wsdl/mime/textMatching/", ((System.Web.Services.Description.MimeTextMatch)a[ia]), false, false);
                    }
                }
            }
            WriteEndElement(o);
        }

        void Write97_SoapBodyBinding(string n, string ns, System.Web.Services.Description.SoapBodyBinding o, bool isNullable, bool needType) {
            if ((object)o == null) {
                if (isNullable) WriteNullTagLiteral(n, ns);
                return;
            }
            if (!needType) {
                System.Type t = o.GetType();
                if (t == typeof(System.Web.Services.Description.SoapBodyBinding))
                    ;
                else {
                    throw CreateUnknownTypeException(o);
                }
            }
            WriteStartElement(n, ns, o);
            if (needType) WriteXsiType(@"SoapBodyBinding", @"http://schemas.xmlsoap.org/wsdl/soap/");
            if ((System.Boolean)o.@Required != false) {
                WriteAttribute(@"required", @"http://schemas.xmlsoap.org/wsdl/", System.Xml.XmlConvert.ToString((System.Boolean)(System.Boolean)o.@Required));
            }
            if ((System.Web.Services.Description.SoapBindingUse)o.@Use != System.Web.Services.Description.SoapBindingUse.@Default) {
                WriteAttribute(@"use", @"", Write98_SoapBindingUse((System.Web.Services.Description.SoapBindingUse)o.@Use));
            }
            if ((System.String)o.@Namespace != @"") {
                WriteAttribute(@"namespace", @"", (System.String)o.@Namespace);
            }
            if ((System.String)o.@Encoding != @"") {
                WriteAttribute(@"encodingStyle", @"", (System.String)o.@Encoding);
            }
            WriteAttribute(@"parts", @"", FromXmlNmTokens((System.String)o.@PartsString));
            WriteEndElement(o);
        }

        string Write98_SoapBindingUse(System.Web.Services.Description.SoapBindingUse v) {
            string s = null;
            switch (v) {
                case System.Web.Services.Description.SoapBindingUse.@Encoded: s = @"encoded"; break;
                case System.Web.Services.Description.SoapBindingUse.@Literal: s = @"literal"; break;
                default: s = ((System.Int64)v).ToString(); break;
            }
            return s;
        }

        void Write99_SoapHeaderBinding(string n, string ns, System.Web.Services.Description.SoapHeaderBinding o, bool isNullable, bool needType) {
            if ((object)o == null) {
                if (isNullable) WriteNullTagLiteral(n, ns);
                return;
            }
            if (!needType) {
                System.Type t = o.GetType();
                if (t == typeof(System.Web.Services.Description.SoapHeaderBinding))
                    ;
                else {
                    throw CreateUnknownTypeException(o);
                }
            }
            WriteStartElement(n, ns, o);
            if (needType) WriteXsiType(@"SoapHeaderBinding", @"http://schemas.xmlsoap.org/wsdl/soap/");
            if ((System.Boolean)o.@Required != false) {
                WriteAttribute(@"required", @"http://schemas.xmlsoap.org/wsdl/", System.Xml.XmlConvert.ToString((System.Boolean)(System.Boolean)o.@Required));
            }
            WriteAttribute(@"message", @"", FromXmlQualifiedName((System.Xml.XmlQualifiedName)o.@Message));
            WriteAttribute(@"part", @"", FromXmlNmToken((System.String)o.@Part));
            if ((System.Web.Services.Description.SoapBindingUse)o.@Use != System.Web.Services.Description.SoapBindingUse.@Default) {
                WriteAttribute(@"use", @"", Write98_SoapBindingUse((System.Web.Services.Description.SoapBindingUse)o.@Use));
            }
            if ((System.String)o.@Encoding != @"") {
                WriteAttribute(@"encodingStyle", @"", (System.String)o.@Encoding);
            }
            if ((System.String)o.@Namespace != @"") {
                WriteAttribute(@"namespace", @"", (System.String)o.@Namespace);
            }
            Write100_SoapHeaderFaultBinding(@"headerfault", @"http://schemas.xmlsoap.org/wsdl/soap/", ((System.Web.Services.Description.SoapHeaderFaultBinding)o.@Fault), false, false);
            WriteEndElement(o);
        }

        void Write100_SoapHeaderFaultBinding(string n, string ns, System.Web.Services.Description.SoapHeaderFaultBinding o, bool isNullable, bool needType) {
            if ((object)o == null) {
                if (isNullable) WriteNullTagLiteral(n, ns);
                return;
            }
            if (!needType) {
                System.Type t = o.GetType();
                if (t == typeof(System.Web.Services.Description.SoapHeaderFaultBinding))
                    ;
                else {
                    throw CreateUnknownTypeException(o);
                }
            }
            WriteStartElement(n, ns, o);
            if (needType) WriteXsiType(@"SoapHeaderFaultBinding", @"http://schemas.xmlsoap.org/wsdl/soap/");
            if ((System.Boolean)o.@Required != false) {
                WriteAttribute(@"required", @"http://schemas.xmlsoap.org/wsdl/", System.Xml.XmlConvert.ToString((System.Boolean)(System.Boolean)o.@Required));
            }
            WriteAttribute(@"message", @"", FromXmlQualifiedName((System.Xml.XmlQualifiedName)o.@Message));
            WriteAttribute(@"part", @"", FromXmlNmToken((System.String)o.@Part));
            if ((System.Web.Services.Description.SoapBindingUse)o.@Use != System.Web.Services.Description.SoapBindingUse.@Default) {
                WriteAttribute(@"use", @"", Write98_SoapBindingUse((System.Web.Services.Description.SoapBindingUse)o.@Use));
            }
            if ((System.String)o.@Encoding != @"") {
                WriteAttribute(@"encodingStyle", @"", (System.String)o.@Encoding);
            }
            if ((System.String)o.@Namespace != @"") {
                WriteAttribute(@"namespace", @"", (System.String)o.@Namespace);
            }
            WriteEndElement(o);
        }

        void Write101_OutputBinding(string n, string ns, System.Web.Services.Description.OutputBinding o, bool isNullable, bool needType) {
            if ((object)o == null) {
                if (isNullable) WriteNullTagLiteral(n, ns);
                return;
            }
            if (!needType) {
                System.Type t = o.GetType();
                if (t == typeof(System.Web.Services.Description.OutputBinding))
                    ;
                else {
                    throw CreateUnknownTypeException(o);
                }
            }
            WriteStartElement(n, ns, o);
            if (needType) WriteXsiType(@"OutputBinding", @"http://schemas.xmlsoap.org/wsdl/");
            WriteAttribute(@"name", @"", FromXmlNmToken((System.String)o.@Name));
            if (((System.String)o.@Documentation) != @"") {
                WriteElementString(@"documentation", @"http://schemas.xmlsoap.org/wsdl/", ((System.String)o.@Documentation));
            }
            {
                System.Web.Services.Description.ServiceDescriptionFormatExtensionCollection a = (System.Web.Services.Description.ServiceDescriptionFormatExtensionCollection)o.@Extensions;
                if (a != null) {
                    for (int ia = 0; ia < a.Count; ia++) {
                        System.Object ai = a[ia];
                        {
                            if (ai is System.Web.Services.Description.SoapHeaderBinding) {
                                Write99_SoapHeaderBinding(@"header", @"http://schemas.xmlsoap.org/wsdl/soap/", ((System.Web.Services.Description.SoapHeaderBinding)ai), false, false);
                            }
                            else if (ai is System.Web.Services.Description.MimeMultipartRelatedBinding) {
                                Write92_MimeMultipartRelatedBinding(@"multipartRelated", @"http://schemas.xmlsoap.org/wsdl/mime/", ((System.Web.Services.Description.MimeMultipartRelatedBinding)ai), false, false);
                            }
                            else if (ai is System.Web.Services.Description.SoapBodyBinding) {
                                Write97_SoapBodyBinding(@"body", @"http://schemas.xmlsoap.org/wsdl/soap/", ((System.Web.Services.Description.SoapBodyBinding)ai), false, false);
                            }
                            else if (ai is System.Web.Services.Description.MimeXmlBinding) {
                                Write91_MimeXmlBinding(@"mimeXml", @"http://schemas.xmlsoap.org/wsdl/mime/", ((System.Web.Services.Description.MimeXmlBinding)ai), false, false);
                            }
                            else if (ai is System.Web.Services.Description.MimeContentBinding) {
                                Write89_MimeContentBinding(@"content", @"http://schemas.xmlsoap.org/wsdl/mime/", ((System.Web.Services.Description.MimeContentBinding)ai), false, false);
                            }
                            else if (ai is System.Web.Services.Description.MimeTextBinding) {
                                Write94_MimeTextBinding(@"text", @"http://microsoft.com/wsdl/mime/textMatching/", ((System.Web.Services.Description.MimeTextBinding)ai), false, false);
                            }
                            else if (ai is System.Xml.XmlElement) {
                                System.Xml.XmlElement elem = (System.Xml.XmlElement)ai;
                                WriteElementLiteral(elem, @"", "", false, true);
                            }
                            else {
                                if (ai != null) {
                                    throw CreateUnknownTypeException(ai);
                                }
                            }
                        }
                    }
                }
            }
            WriteEndElement(o);
        }

        void Write102_FaultBinding(string n, string ns, System.Web.Services.Description.FaultBinding o, bool isNullable, bool needType) {
            if ((object)o == null) {
                if (isNullable) WriteNullTagLiteral(n, ns);
                return;
            }
            if (!needType) {
                System.Type t = o.GetType();
                if (t == typeof(System.Web.Services.Description.FaultBinding))
                    ;
                else {
                    throw CreateUnknownTypeException(o);
                }
            }
            WriteStartElement(n, ns, o);
            if (needType) WriteXsiType(@"FaultBinding", @"http://schemas.xmlsoap.org/wsdl/");
            WriteAttribute(@"name", @"", FromXmlNmToken((System.String)o.@Name));
            if (((System.String)o.@Documentation) != @"") {
                WriteElementString(@"documentation", @"http://schemas.xmlsoap.org/wsdl/", ((System.String)o.@Documentation));
            }
            {
                System.Web.Services.Description.ServiceDescriptionFormatExtensionCollection a = (System.Web.Services.Description.ServiceDescriptionFormatExtensionCollection)o.@Extensions;
                if (a != null) {
                    for (int ia = 0; ia < a.Count; ia++) {
                        System.Object ai = a[ia];
                        {
                            if (ai is System.Web.Services.Description.SoapFaultBinding) {
                                Write103_SoapFaultBinding(@"fault", @"http://schemas.xmlsoap.org/wsdl/soap/", ((System.Web.Services.Description.SoapFaultBinding)ai), false, false);
                            }
                            else if (ai is System.Xml.XmlElement) {
                                System.Xml.XmlElement elem = (System.Xml.XmlElement)ai;
                                WriteElementLiteral(elem, @"", "", false, true);
                            }
                            else {
                                if (ai != null) {
                                    throw CreateUnknownTypeException(ai);
                                }
                            }
                        }
                    }
                }
            }
            WriteEndElement(o);
        }

        void Write103_SoapFaultBinding(string n, string ns, System.Web.Services.Description.SoapFaultBinding o, bool isNullable, bool needType) {
            if ((object)o == null) {
                if (isNullable) WriteNullTagLiteral(n, ns);
                return;
            }
            if (!needType) {
                System.Type t = o.GetType();
                if (t == typeof(System.Web.Services.Description.SoapFaultBinding))
                    ;
                else {
                    throw CreateUnknownTypeException(o);
                }
            }
            WriteStartElement(n, ns, o);
            if (needType) WriteXsiType(@"SoapFaultBinding", @"http://schemas.xmlsoap.org/wsdl/soap/");
            if ((System.Boolean)o.@Required != false) {
                WriteAttribute(@"required", @"http://schemas.xmlsoap.org/wsdl/", System.Xml.XmlConvert.ToString((System.Boolean)(System.Boolean)o.@Required));
            }
            if ((System.Web.Services.Description.SoapBindingUse)o.@Use != System.Web.Services.Description.SoapBindingUse.@Default) {
                WriteAttribute(@"use", @"", Write98_SoapBindingUse((System.Web.Services.Description.SoapBindingUse)o.@Use));
            }
            WriteAttribute(@"namespace", @"", (System.String)o.@Namespace);
            WriteAttribute(@"encodingStyle", @"", (System.String)o.@Encoding);
            WriteEndElement(o);
        }

        void Write104_Service(string n, string ns, System.Web.Services.Description.Service o, bool isNullable, bool needType) {
            if ((object)o == null) {
                if (isNullable) WriteNullTagLiteral(n, ns);
                return;
            }
            if (!needType) {
                System.Type t = o.GetType();
                if (t == typeof(System.Web.Services.Description.Service))
                    ;
                else {
                    throw CreateUnknownTypeException(o);
                }
            }
            WriteStartElement(n, ns, o);
            if (needType) WriteXsiType(@"Service", @"http://schemas.xmlsoap.org/wsdl/");
            WriteAttribute(@"name", @"", FromXmlNCName((System.String)o.@Name));
            if (((System.String)o.@Documentation) != @"") {
                WriteElementString(@"documentation", @"http://schemas.xmlsoap.org/wsdl/", ((System.String)o.@Documentation));
            }
            {
                System.Web.Services.Description.PortCollection a = (System.Web.Services.Description.PortCollection)o.@Ports;
                if (a != null) {
                    for (int ia = 0; ia < a.Count; ia++) {
                        Write105_Port(@"port", @"http://schemas.xmlsoap.org/wsdl/", ((System.Web.Services.Description.Port)a[ia]), false, false);
                    }
                }
            }
            WriteEndElement(o);
        }

        void Write105_Port(string n, string ns, System.Web.Services.Description.Port o, bool isNullable, bool needType) {
            if ((object)o == null) {
                if (isNullable) WriteNullTagLiteral(n, ns);
                return;
            }
            if (!needType) {
                System.Type t = o.GetType();
                if (t == typeof(System.Web.Services.Description.Port))
                    ;
                else {
                    throw CreateUnknownTypeException(o);
                }
            }
            WriteStartElement(n, ns, o);
            if (needType) WriteXsiType(@"Port", @"http://schemas.xmlsoap.org/wsdl/");
            WriteAttribute(@"name", @"", FromXmlNCName((System.String)o.@Name));
            WriteAttribute(@"binding", @"", FromXmlQualifiedName((System.Xml.XmlQualifiedName)o.@Binding));
            if (((System.String)o.@Documentation) != @"") {
                WriteElementString(@"documentation", @"http://schemas.xmlsoap.org/wsdl/", ((System.String)o.@Documentation));
            }
            {
                System.Web.Services.Description.ServiceDescriptionFormatExtensionCollection a = (System.Web.Services.Description.ServiceDescriptionFormatExtensionCollection)o.@Extensions;
                if (a != null) {
                    for (int ia = 0; ia < a.Count; ia++) {
                        System.Object ai = a[ia];
                        {
                            if (ai is System.Web.Services.Description.SoapAddressBinding) {
                                Write107_SoapAddressBinding(@"address", @"http://schemas.xmlsoap.org/wsdl/soap/", ((System.Web.Services.Description.SoapAddressBinding)ai), false, false);
                            }
                            else if (ai is System.Web.Services.Description.HttpAddressBinding) {
                                Write106_HttpAddressBinding(@"address", @"http://schemas.xmlsoap.org/wsdl/http/", ((System.Web.Services.Description.HttpAddressBinding)ai), false, false);
                            }
                            else if (ai is System.Xml.XmlElement) {
                                System.Xml.XmlElement elem = (System.Xml.XmlElement)ai;
                                WriteElementLiteral(elem, @"", "", false, true);
                            }
                            else {
                                if (ai != null) {
                                    throw CreateUnknownTypeException(ai);
                                }
                            }
                        }
                    }
                }
            }
            WriteEndElement(o);
        }

        void Write106_HttpAddressBinding(string n, string ns, System.Web.Services.Description.HttpAddressBinding o, bool isNullable, bool needType) {
            if ((object)o == null) {
                if (isNullable) WriteNullTagLiteral(n, ns);
                return;
            }
            if (!needType) {
                System.Type t = o.GetType();
                if (t == typeof(System.Web.Services.Description.HttpAddressBinding))
                    ;
                else {
                    throw CreateUnknownTypeException(o);
                }
            }
            WriteStartElement(n, ns, o);
            if (needType) WriteXsiType(@"HttpAddressBinding", @"http://schemas.xmlsoap.org/wsdl/http/");
            if ((System.Boolean)o.@Required != false) {
                WriteAttribute(@"required", @"http://schemas.xmlsoap.org/wsdl/", System.Xml.XmlConvert.ToString((System.Boolean)(System.Boolean)o.@Required));
            }
            WriteAttribute(@"location", @"", (System.String)o.@Location);
            WriteEndElement(o);
        }

        void Write107_SoapAddressBinding(string n, string ns, System.Web.Services.Description.SoapAddressBinding o, bool isNullable, bool needType) {
            if ((object)o == null) {
                if (isNullable) WriteNullTagLiteral(n, ns);
                return;
            }
            if (!needType) {
                System.Type t = o.GetType();
                if (t == typeof(System.Web.Services.Description.SoapAddressBinding))
                    ;
                else {
                    throw CreateUnknownTypeException(o);
                }
            }
            WriteStartElement(n, ns, o);
            if (needType) WriteXsiType(@"SoapAddressBinding", @"http://schemas.xmlsoap.org/wsdl/soap/");
            if ((System.Boolean)o.@Required != false) {
                WriteAttribute(@"required", @"http://schemas.xmlsoap.org/wsdl/", System.Xml.XmlConvert.ToString((System.Boolean)(System.Boolean)o.@Required));
            }
            WriteAttribute(@"location", @"", (System.String)o.@Location);
            WriteEndElement(o);
        }

        protected override void InitCallbacks() {
        }

        public void Write108_definitions(object o) {
            WriteStartDocument();
            if (o == null) {
                WriteNullTagLiteral(@"definitions", @"http://schemas.xmlsoap.org/wsdl/");
                return;
            }
            TopLevelElement();
            Write1_ServiceDescription(@"definitions", @"http://schemas.xmlsoap.org/wsdl/", ((System.Web.Services.Description.ServiceDescription)o), true, false);
        }
    }
    internal class ServiceDescriptionSerializationReader : System.Xml.Serialization.XmlSerializationReader {

        System.Web.Services.Description.ServiceDescription Read1_ServiceDescription(bool isNullable, bool checkType) {
            if (isNullable && ReadNull()) return null;
            if (checkType) {
                System.Xml.XmlQualifiedName t = GetXsiType();
                if (t == null || ((object) ((System.Xml.XmlQualifiedName)t).Name == (object)id1_ServiceDescription && (object) ((System.Xml.XmlQualifiedName)t).Namespace == (object)id2_httpschemasxmlsoaporgwsdl))
                    ;
                else
                    throw CreateUnknownTypeException((System.Xml.XmlQualifiedName)t);
            }
            System.Web.Services.Description.ServiceDescription o = new System.Web.Services.Description.ServiceDescription();
            System.Web.Services.Description.ImportCollection a_1 = (System.Web.Services.Description.ImportCollection)o.@Imports;
            System.Web.Services.Description.MessageCollection a_3 = (System.Web.Services.Description.MessageCollection)o.@Messages;
            System.Web.Services.Description.PortTypeCollection a_4 = (System.Web.Services.Description.PortTypeCollection)o.@PortTypes;
            System.Web.Services.Description.BindingCollection a_5 = (System.Web.Services.Description.BindingCollection)o.@Bindings;
            System.Web.Services.Description.ServiceCollection a_6 = (System.Web.Services.Description.ServiceCollection)o.@Services;
            bool[] paramsRead = new bool[9];
            while (Reader.MoveToNextAttribute()) {
                if (!paramsRead[7] && ((object) Reader.LocalName == (object)id3_targetNamespace && (object) Reader.NamespaceURI == (object)id4_Item)) {
                    o.@TargetNamespace = Reader.Value;
                    paramsRead[7] = true;
                }
                else if (!paramsRead[8] && ((object) Reader.LocalName == (object)id5_name && (object) Reader.NamespaceURI == (object)id4_Item)) {
                    o.@Name = ToXmlNmToken(Reader.Value);
                    paramsRead[8] = true;
                }
                else if (!IsXmlnsAttribute(Reader.Name)) {
                    UnknownNode((object)o);
                }
            }
            Reader.MoveToElement();
            if (Reader.IsEmptyElement) {
                Reader.Skip();
                return o;
            }
            Reader.ReadStartElement();
            Reader.MoveToContent();
            while (Reader.NodeType != System.Xml.XmlNodeType.EndElement) {
                if (Reader.NodeType == System.Xml.XmlNodeType.Element) {
                    if (!paramsRead[0] && ((object) Reader.LocalName == (object)id6_documentation && (object) Reader.NamespaceURI == (object)id2_httpschemasxmlsoaporgwsdl)) {
                        o.@Documentation = Reader.ReadElementString();
                        paramsRead[0] = true;
                    }
                    else if (((object) Reader.LocalName == (object)id7_import && (object) Reader.NamespaceURI == (object)id2_httpschemasxmlsoaporgwsdl)) {
                        if ((object)(a_1) == null) Reader.Skip(); else a_1.Add(Read4_Import(false, true));
                    }
                    else if (!paramsRead[2] && ((object) Reader.LocalName == (object)id8_types && (object) Reader.NamespaceURI == (object)id2_httpschemasxmlsoaporgwsdl)) {
                        o.@Types = Read5_Types(false, true);
                        paramsRead[2] = true;
                    }
                    else if (((object) Reader.LocalName == (object)id9_message && (object) Reader.NamespaceURI == (object)id2_httpschemasxmlsoaporgwsdl)) {
                        if ((object)(a_3) == null) Reader.Skip(); else a_3.Add(Read68_Message(false, true));
                    }
                    else if (((object) Reader.LocalName == (object)id10_portType && (object) Reader.NamespaceURI == (object)id2_httpschemasxmlsoaporgwsdl)) {
                        if ((object)(a_4) == null) Reader.Skip(); else a_4.Add(Read70_PortType(false, true));
                    }
                    else if (((object) Reader.LocalName == (object)id11_binding && (object) Reader.NamespaceURI == (object)id2_httpschemasxmlsoaporgwsdl)) {
                        if ((object)(a_5) == null) Reader.Skip(); else a_5.Add(Read76_Binding(false, true));
                    }
                    else if (((object) Reader.LocalName == (object)id12_service && (object) Reader.NamespaceURI == (object)id2_httpschemasxmlsoaporgwsdl)) {
                        if ((object)(a_6) == null) Reader.Skip(); else a_6.Add(Read104_Service(false, true));
                    }
                    else {
                        UnknownNode((object)o);
                    }
                }
                else {
                    UnknownNode((object)o);
                }
                Reader.MoveToContent();
            }
            ReadEndElement();
            return o;
        }

        System.Web.Services.Description.DocumentableItem Read2_DocumentableItem(bool isNullable, bool checkType) {
            if (isNullable && ReadNull()) return null;
            if (checkType) {
                System.Xml.XmlQualifiedName t = GetXsiType();
                if (t == null || ((object) ((System.Xml.XmlQualifiedName)t).Name == (object)id13_DocumentableItem && (object) ((System.Xml.XmlQualifiedName)t).Namespace == (object)id2_httpschemasxmlsoaporgwsdl))
                    ;
                else if (((object) ((System.Xml.XmlQualifiedName)t).Name == (object)id14_Port && (object) ((System.Xml.XmlQualifiedName)t).Namespace == (object)id2_httpschemasxmlsoaporgwsdl))
                    return Read105_Port(isNullable, false);
                else if (((object) ((System.Xml.XmlQualifiedName)t).Name == (object)id15_Service && (object) ((System.Xml.XmlQualifiedName)t).Namespace == (object)id2_httpschemasxmlsoaporgwsdl))
                    return Read104_Service(isNullable, false);
                else if (((object) ((System.Xml.XmlQualifiedName)t).Name == (object)id16_MessageBinding && (object) ((System.Xml.XmlQualifiedName)t).Namespace == (object)id2_httpschemasxmlsoaporgwsdl))
                    return Read86_MessageBinding(isNullable, false);
                else if (((object) ((System.Xml.XmlQualifiedName)t).Name == (object)id17_FaultBinding && (object) ((System.Xml.XmlQualifiedName)t).Namespace == (object)id2_httpschemasxmlsoaporgwsdl))
                    return Read102_FaultBinding(isNullable, false);
                else if (((object) ((System.Xml.XmlQualifiedName)t).Name == (object)id18_OutputBinding && (object) ((System.Xml.XmlQualifiedName)t).Namespace == (object)id2_httpschemasxmlsoaporgwsdl))
                    return Read101_OutputBinding(isNullable, false);
                else if (((object) ((System.Xml.XmlQualifiedName)t).Name == (object)id19_InputBinding && (object) ((System.Xml.XmlQualifiedName)t).Namespace == (object)id2_httpschemasxmlsoaporgwsdl))
                    return Read85_InputBinding(isNullable, false);
                else if (((object) ((System.Xml.XmlQualifiedName)t).Name == (object)id20_OperationBinding && (object) ((System.Xml.XmlQualifiedName)t).Namespace == (object)id2_httpschemasxmlsoaporgwsdl))
                    return Read82_OperationBinding(isNullable, false);
                else if (((object) ((System.Xml.XmlQualifiedName)t).Name == (object)id21_Binding && (object) ((System.Xml.XmlQualifiedName)t).Namespace == (object)id2_httpschemasxmlsoaporgwsdl))
                    return Read76_Binding(isNullable, false);
                else if (((object) ((System.Xml.XmlQualifiedName)t).Name == (object)id22_OperationMessage && (object) ((System.Xml.XmlQualifiedName)t).Namespace == (object)id2_httpschemasxmlsoaporgwsdl))
                    return Read73_OperationMessage(isNullable, false);
                else if (((object) ((System.Xml.XmlQualifiedName)t).Name == (object)id23_OperationFault && (object) ((System.Xml.XmlQualifiedName)t).Namespace == (object)id2_httpschemasxmlsoaporgwsdl))
                    return Read75_OperationFault(isNullable, false);
                else if (((object) ((System.Xml.XmlQualifiedName)t).Name == (object)id24_OperationOutput && (object) ((System.Xml.XmlQualifiedName)t).Namespace == (object)id2_httpschemasxmlsoaporgwsdl))
                    return Read74_OperationOutput(isNullable, false);
                else if (((object) ((System.Xml.XmlQualifiedName)t).Name == (object)id25_OperationInput && (object) ((System.Xml.XmlQualifiedName)t).Namespace == (object)id2_httpschemasxmlsoaporgwsdl))
                    return Read72_OperationInput(isNullable, false);
                else if (((object) ((System.Xml.XmlQualifiedName)t).Name == (object)id26_Operation && (object) ((System.Xml.XmlQualifiedName)t).Namespace == (object)id2_httpschemasxmlsoaporgwsdl))
                    return Read71_Operation(isNullable, false);
                else if (((object) ((System.Xml.XmlQualifiedName)t).Name == (object)id27_PortType && (object) ((System.Xml.XmlQualifiedName)t).Namespace == (object)id2_httpschemasxmlsoaporgwsdl))
                    return Read70_PortType(isNullable, false);
                else if (((object) ((System.Xml.XmlQualifiedName)t).Name == (object)id28_MessagePart && (object) ((System.Xml.XmlQualifiedName)t).Namespace == (object)id2_httpschemasxmlsoaporgwsdl))
                    return Read69_MessagePart(isNullable, false);
                else if (((object) ((System.Xml.XmlQualifiedName)t).Name == (object)id29_Message && (object) ((System.Xml.XmlQualifiedName)t).Namespace == (object)id2_httpschemasxmlsoaporgwsdl))
                    return Read68_Message(isNullable, false);
                else if (((object) ((System.Xml.XmlQualifiedName)t).Name == (object)id30_Types && (object) ((System.Xml.XmlQualifiedName)t).Namespace == (object)id2_httpschemasxmlsoaporgwsdl))
                    return Read5_Types(isNullable, false);
                else if (((object) ((System.Xml.XmlQualifiedName)t).Name == (object)id31_Import && (object) ((System.Xml.XmlQualifiedName)t).Namespace == (object)id2_httpschemasxmlsoaporgwsdl))
                    return Read4_Import(isNullable, false);
                else if (((object) ((System.Xml.XmlQualifiedName)t).Name == (object)id1_ServiceDescription && (object) ((System.Xml.XmlQualifiedName)t).Namespace == (object)id2_httpschemasxmlsoaporgwsdl))
                    return Read1_ServiceDescription(isNullable, false);
                else
                    throw CreateUnknownTypeException((System.Xml.XmlQualifiedName)t);
            }
            throw CreateAbstractTypeException(@"DocumentableItem", @"http://schemas.xmlsoap.org/wsdl/");
        }

        System.Object Read3_Object(bool isNullable, bool checkType) {
            if (isNullable && ReadNull()) return null;
            if (checkType) {
                System.Xml.XmlQualifiedName t = GetXsiType();
                if (t == null)
                    return ReadTypedPrimitive(new System.Xml.XmlQualifiedName("anyType", "http://www.w3.org/2001/XMLSchema"));
                else if (((object) ((System.Xml.XmlQualifiedName)t).Name == (object)id32_MimeTextMatch && (object) ((System.Xml.XmlQualifiedName)t).Namespace == (object)id33_httpmicrosoftcomwsdlmimetextMatching))
                    return Read96_MimeTextMatch(isNullable, false);
                else if (((object) ((System.Xml.XmlQualifiedName)t).Name == (object)id34_ServiceDescriptionFormatExtension && (object) ((System.Xml.XmlQualifiedName)t).Namespace == (object)id33_httpmicrosoftcomwsdlmimetextMatching))
                    return Read95_ServiceDescriptionFormatExtension(isNullable, false);
                else if (((object) ((System.Xml.XmlQualifiedName)t).Name == (object)id35_MimeTextBinding && (object) ((System.Xml.XmlQualifiedName)t).Namespace == (object)id33_httpmicrosoftcomwsdlmimetextMatching))
                    return Read94_MimeTextBinding(isNullable, false);
                else if (((object) ((System.Xml.XmlQualifiedName)t).Name == (object)id34_ServiceDescriptionFormatExtension && (object) ((System.Xml.XmlQualifiedName)t).Namespace == (object)id36_httpschemasxmlsoaporgwsdlmime))
                    return Read90_ServiceDescriptionFormatExtension(isNullable, false);
                else if (((object) ((System.Xml.XmlQualifiedName)t).Name == (object)id37_MimePart && (object) ((System.Xml.XmlQualifiedName)t).Namespace == (object)id36_httpschemasxmlsoaporgwsdlmime))
                    return Read93_MimePart(isNullable, false);
                else if (((object) ((System.Xml.XmlQualifiedName)t).Name == (object)id38_MimeMultipartRelatedBinding && (object) ((System.Xml.XmlQualifiedName)t).Namespace == (object)id36_httpschemasxmlsoaporgwsdlmime))
                    return Read92_MimeMultipartRelatedBinding(isNullable, false);
                else if (((object) ((System.Xml.XmlQualifiedName)t).Name == (object)id39_MimeXmlBinding && (object) ((System.Xml.XmlQualifiedName)t).Namespace == (object)id36_httpschemasxmlsoaporgwsdlmime))
                    return Read91_MimeXmlBinding(isNullable, false);
                else if (((object) ((System.Xml.XmlQualifiedName)t).Name == (object)id40_MimeContentBinding && (object) ((System.Xml.XmlQualifiedName)t).Namespace == (object)id36_httpschemasxmlsoaporgwsdlmime))
                    return Read89_MimeContentBinding(isNullable, false);
                else if (((object) ((System.Xml.XmlQualifiedName)t).Name == (object)id34_ServiceDescriptionFormatExtension && (object) ((System.Xml.XmlQualifiedName)t).Namespace == (object)id41_httpschemasxmlsoaporgwsdlsoap))
                    return Read80_ServiceDescriptionFormatExtension(isNullable, false);
                else if (((object) ((System.Xml.XmlQualifiedName)t).Name == (object)id42_SoapAddressBinding && (object) ((System.Xml.XmlQualifiedName)t).Namespace == (object)id41_httpschemasxmlsoaporgwsdlsoap))
                    return Read107_SoapAddressBinding(isNullable, false);
                else if (((object) ((System.Xml.XmlQualifiedName)t).Name == (object)id43_SoapFaultBinding && (object) ((System.Xml.XmlQualifiedName)t).Namespace == (object)id41_httpschemasxmlsoaporgwsdlsoap))
                    return Read103_SoapFaultBinding(isNullable, false);
                else if (((object) ((System.Xml.XmlQualifiedName)t).Name == (object)id44_SoapHeaderFaultBinding && (object) ((System.Xml.XmlQualifiedName)t).Namespace == (object)id41_httpschemasxmlsoaporgwsdlsoap))
                    return Read100_SoapHeaderFaultBinding(isNullable, false);
                else if (((object) ((System.Xml.XmlQualifiedName)t).Name == (object)id45_SoapHeaderBinding && (object) ((System.Xml.XmlQualifiedName)t).Namespace == (object)id41_httpschemasxmlsoaporgwsdlsoap))
                    return Read99_SoapHeaderBinding(isNullable, false);
                else if (((object) ((System.Xml.XmlQualifiedName)t).Name == (object)id46_SoapBodyBinding && (object) ((System.Xml.XmlQualifiedName)t).Namespace == (object)id41_httpschemasxmlsoaporgwsdlsoap))
                    return Read97_SoapBodyBinding(isNullable, false);
                else if (((object) ((System.Xml.XmlQualifiedName)t).Name == (object)id47_SoapOperationBinding && (object) ((System.Xml.XmlQualifiedName)t).Namespace == (object)id41_httpschemasxmlsoaporgwsdlsoap))
                    return Read84_SoapOperationBinding(isNullable, false);
                else if (((object) ((System.Xml.XmlQualifiedName)t).Name == (object)id48_SoapBinding && (object) ((System.Xml.XmlQualifiedName)t).Namespace == (object)id41_httpschemasxmlsoaporgwsdlsoap))
                    return Read79_SoapBinding(isNullable, false);
                else if (((object) ((System.Xml.XmlQualifiedName)t).Name == (object)id34_ServiceDescriptionFormatExtension && (object) ((System.Xml.XmlQualifiedName)t).Namespace == (object)id49_httpschemasxmlsoaporgwsdlhttp))
                    return Read78_ServiceDescriptionFormatExtension(isNullable, false);
                else if (((object) ((System.Xml.XmlQualifiedName)t).Name == (object)id50_HttpAddressBinding && (object) ((System.Xml.XmlQualifiedName)t).Namespace == (object)id49_httpschemasxmlsoaporgwsdlhttp))
                    return Read106_HttpAddressBinding(isNullable, false);
                else if (((object) ((System.Xml.XmlQualifiedName)t).Name == (object)id51_HttpUrlReplacementBinding && (object) ((System.Xml.XmlQualifiedName)t).Namespace == (object)id49_httpschemasxmlsoaporgwsdlhttp))
                    return Read88_HttpUrlReplacementBinding(isNullable, false);
                else if (((object) ((System.Xml.XmlQualifiedName)t).Name == (object)id52_HttpUrlEncodedBinding && (object) ((System.Xml.XmlQualifiedName)t).Namespace == (object)id49_httpschemasxmlsoaporgwsdlhttp))
                    return Read87_HttpUrlEncodedBinding(isNullable, false);
                else if (((object) ((System.Xml.XmlQualifiedName)t).Name == (object)id53_HttpOperationBinding && (object) ((System.Xml.XmlQualifiedName)t).Namespace == (object)id49_httpschemasxmlsoaporgwsdlhttp))
                    return Read83_HttpOperationBinding(isNullable, false);
                else if (((object) ((System.Xml.XmlQualifiedName)t).Name == (object)id54_HttpBinding && (object) ((System.Xml.XmlQualifiedName)t).Namespace == (object)id49_httpschemasxmlsoaporgwsdlhttp))
                    return Read77_HttpBinding(isNullable, false);
                else if (((object) ((System.Xml.XmlQualifiedName)t).Name == (object)id55_XmlSchemaObject && (object) ((System.Xml.XmlQualifiedName)t).Namespace == (object)id56_httpwwww3org2001XMLSchema))
                    return Read7_XmlSchemaObject(isNullable, false);
                else if (((object) ((System.Xml.XmlQualifiedName)t).Name == (object)id57_XmlSchemaDocumentation && (object) ((System.Xml.XmlQualifiedName)t).Namespace == (object)id56_httpwwww3org2001XMLSchema))
                    return Read17_XmlSchemaDocumentation(isNullable, false);
                else if (((object) ((System.Xml.XmlQualifiedName)t).Name == (object)id58_XmlSchemaAppInfo && (object) ((System.Xml.XmlQualifiedName)t).Namespace == (object)id56_httpwwww3org2001XMLSchema))
                    return Read16_XmlSchemaAppInfo(isNullable, false);
                else if (((object) ((System.Xml.XmlQualifiedName)t).Name == (object)id59_XmlSchemaAnnotation && (object) ((System.Xml.XmlQualifiedName)t).Namespace == (object)id56_httpwwww3org2001XMLSchema))
                    return Read15_XmlSchemaAnnotation(isNullable, false);
                else if (((object) ((System.Xml.XmlQualifiedName)t).Name == (object)id60_XmlSchemaAnnotated && (object) ((System.Xml.XmlQualifiedName)t).Namespace == (object)id56_httpwwww3org2001XMLSchema))
                    return Read14_XmlSchemaAnnotated(isNullable, false);
                else if (((object) ((System.Xml.XmlQualifiedName)t).Name == (object)id61_XmlSchemaNotation && (object) ((System.Xml.XmlQualifiedName)t).Namespace == (object)id56_httpwwww3org2001XMLSchema))
                    return Read67_XmlSchemaNotation(isNullable, false);
                else if (((object) ((System.Xml.XmlQualifiedName)t).Name == (object)id62_XmlSchemaGroup && (object) ((System.Xml.XmlQualifiedName)t).Namespace == (object)id56_httpwwww3org2001XMLSchema))
                    return Read64_XmlSchemaGroup(isNullable, false);
                else if (((object) ((System.Xml.XmlQualifiedName)t).Name == (object)id63_XmlSchemaXPath && (object) ((System.Xml.XmlQualifiedName)t).Namespace == (object)id56_httpwwww3org2001XMLSchema))
                    return Read54_XmlSchemaXPath(isNullable, false);
                else if (((object) ((System.Xml.XmlQualifiedName)t).Name == (object)id64_XmlSchemaIdentityConstraint && (object) ((System.Xml.XmlQualifiedName)t).Namespace == (object)id56_httpwwww3org2001XMLSchema))
                    return Read53_XmlSchemaIdentityConstraint(isNullable, false);
                else if (((object) ((System.Xml.XmlQualifiedName)t).Name == (object)id65_XmlSchemaKey && (object) ((System.Xml.XmlQualifiedName)t).Namespace == (object)id56_httpwwww3org2001XMLSchema))
                    return Read56_XmlSchemaKey(isNullable, false);
                else if (((object) ((System.Xml.XmlQualifiedName)t).Name == (object)id66_XmlSchemaUnique && (object) ((System.Xml.XmlQualifiedName)t).Namespace == (object)id56_httpwwww3org2001XMLSchema))
                    return Read55_XmlSchemaUnique(isNullable, false);
                else if (((object) ((System.Xml.XmlQualifiedName)t).Name == (object)id67_XmlSchemaKeyref && (object) ((System.Xml.XmlQualifiedName)t).Namespace == (object)id56_httpwwww3org2001XMLSchema))
                    return Read52_XmlSchemaKeyref(isNullable, false);
                else if (((object) ((System.Xml.XmlQualifiedName)t).Name == (object)id68_XmlSchemaParticle && (object) ((System.Xml.XmlQualifiedName)t).Namespace == (object)id56_httpwwww3org2001XMLSchema))
                    return Read49_XmlSchemaParticle(isNullable, false);
                else if (((object) ((System.Xml.XmlQualifiedName)t).Name == (object)id69_XmlSchemaGroupRef && (object) ((System.Xml.XmlQualifiedName)t).Namespace == (object)id56_httpwwww3org2001XMLSchema))
                    return Read57_XmlSchemaGroupRef(isNullable, false);
                else if (((object) ((System.Xml.XmlQualifiedName)t).Name == (object)id70_XmlSchemaElement && (object) ((System.Xml.XmlQualifiedName)t).Namespace == (object)id56_httpwwww3org2001XMLSchema))
                    return Read51_XmlSchemaElement(isNullable, false);
                else if (((object) ((System.Xml.XmlQualifiedName)t).Name == (object)id71_XmlSchemaAny && (object) ((System.Xml.XmlQualifiedName)t).Namespace == (object)id56_httpwwww3org2001XMLSchema))
                    return Read50_XmlSchemaAny(isNullable, false);
                else if (((object) ((System.Xml.XmlQualifiedName)t).Name == (object)id72_XmlSchemaGroupBase && (object) ((System.Xml.XmlQualifiedName)t).Namespace == (object)id56_httpwwww3org2001XMLSchema))
                    return Read48_XmlSchemaGroupBase(isNullable, false);
                else if (((object) ((System.Xml.XmlQualifiedName)t).Name == (object)id73_XmlSchemaAll && (object) ((System.Xml.XmlQualifiedName)t).Namespace == (object)id56_httpwwww3org2001XMLSchema))
                    return Read59_XmlSchemaAll(isNullable, false);
                else if (((object) ((System.Xml.XmlQualifiedName)t).Name == (object)id74_XmlSchemaChoice && (object) ((System.Xml.XmlQualifiedName)t).Namespace == (object)id56_httpwwww3org2001XMLSchema))
                    return Read58_XmlSchemaChoice(isNullable, false);
                else if (((object) ((System.Xml.XmlQualifiedName)t).Name == (object)id75_XmlSchemaSequence && (object) ((System.Xml.XmlQualifiedName)t).Namespace == (object)id56_httpwwww3org2001XMLSchema))
                    return Read47_XmlSchemaSequence(isNullable, false);
                else if (((object) ((System.Xml.XmlQualifiedName)t).Name == (object)id76_XmlSchemaContent && (object) ((System.Xml.XmlQualifiedName)t).Namespace == (object)id56_httpwwww3org2001XMLSchema))
                    return Read46_XmlSchemaContent(isNullable, false);
                else if (((object) ((System.Xml.XmlQualifiedName)t).Name == (object)id77_XmlSchemaSimpleContentExtension && (object) ((System.Xml.XmlQualifiedName)t).Namespace == (object)id56_httpwwww3org2001XMLSchema))
                    return Read63_XmlSchemaSimpleContentExtension(isNullable, false);
                else if (((object) ((System.Xml.XmlQualifiedName)t).Name == (object)id78_XmlSchemaSimpleContentRestriction && (object) ((System.Xml.XmlQualifiedName)t).Namespace == (object)id56_httpwwww3org2001XMLSchema))
                    return Read62_XmlSchemaSimpleContentRestriction(isNullable, false);
                else if (((object) ((System.Xml.XmlQualifiedName)t).Name == (object)id79_XmlSchemaComplexContentRestriction && (object) ((System.Xml.XmlQualifiedName)t).Namespace == (object)id56_httpwwww3org2001XMLSchema))
                    return Read60_XmlSchemaComplexContentRestriction(isNullable, false);
                else if (((object) ((System.Xml.XmlQualifiedName)t).Name == (object)id80_XmlSchemaComplexContentExtension && (object) ((System.Xml.XmlQualifiedName)t).Namespace == (object)id56_httpwwww3org2001XMLSchema))
                    return Read45_XmlSchemaComplexContentExtension(isNullable, false);
                else if (((object) ((System.Xml.XmlQualifiedName)t).Name == (object)id81_XmlSchemaContentModel && (object) ((System.Xml.XmlQualifiedName)t).Namespace == (object)id56_httpwwww3org2001XMLSchema))
                    return Read44_XmlSchemaContentModel(isNullable, false);
                else if (((object) ((System.Xml.XmlQualifiedName)t).Name == (object)id82_XmlSchemaSimpleContent && (object) ((System.Xml.XmlQualifiedName)t).Namespace == (object)id56_httpwwww3org2001XMLSchema))
                    return Read61_XmlSchemaSimpleContent(isNullable, false);
                else if (((object) ((System.Xml.XmlQualifiedName)t).Name == (object)id83_XmlSchemaComplexContent && (object) ((System.Xml.XmlQualifiedName)t).Namespace == (object)id56_httpwwww3org2001XMLSchema))
                    return Read43_XmlSchemaComplexContent(isNullable, false);
                else if (((object) ((System.Xml.XmlQualifiedName)t).Name == (object)id84_XmlSchemaAnyAttribute && (object) ((System.Xml.XmlQualifiedName)t).Namespace == (object)id56_httpwwww3org2001XMLSchema))
                    return Read40_XmlSchemaAnyAttribute(isNullable, false);
                else if (((object) ((System.Xml.XmlQualifiedName)t).Name == (object)id85_XmlSchemaAttributeGroupRef && (object) ((System.Xml.XmlQualifiedName)t).Namespace == (object)id56_httpwwww3org2001XMLSchema))
                    return Read39_XmlSchemaAttributeGroupRef(isNullable, false);
                else if (((object) ((System.Xml.XmlQualifiedName)t).Name == (object)id86_XmlSchemaAttribute && (object) ((System.Xml.XmlQualifiedName)t).Namespace == (object)id56_httpwwww3org2001XMLSchema))
                    return Read37_XmlSchemaAttribute(isNullable, false);
                else if (((object) ((System.Xml.XmlQualifiedName)t).Name == (object)id87_XmlSchemaAttributeGroup && (object) ((System.Xml.XmlQualifiedName)t).Namespace == (object)id56_httpwwww3org2001XMLSchema))
                    return Read36_XmlSchemaAttributeGroup(isNullable, false);
                else if (((object) ((System.Xml.XmlQualifiedName)t).Name == (object)id88_XmlSchemaFacet && (object) ((System.Xml.XmlQualifiedName)t).Namespace == (object)id56_httpwwww3org2001XMLSchema))
                    return Read23_XmlSchemaFacet(isNullable, false);
                else if (((object) ((System.Xml.XmlQualifiedName)t).Name == (object)id89_XmlSchemaMinExclusiveFacet && (object) ((System.Xml.XmlQualifiedName)t).Namespace == (object)id56_httpwwww3org2001XMLSchema))
                    return Read32_XmlSchemaMinExclusiveFacet(isNullable, false);
                else if (((object) ((System.Xml.XmlQualifiedName)t).Name == (object)id90_XmlSchemaMinInclusiveFacet && (object) ((System.Xml.XmlQualifiedName)t).Namespace == (object)id56_httpwwww3org2001XMLSchema))
                    return Read31_XmlSchemaMinInclusiveFacet(isNullable, false);
                else if (((object) ((System.Xml.XmlQualifiedName)t).Name == (object)id91_XmlSchemaMaxExclusiveFacet && (object) ((System.Xml.XmlQualifiedName)t).Namespace == (object)id56_httpwwww3org2001XMLSchema))
                    return Read30_XmlSchemaMaxExclusiveFacet(isNullable, false);
                else if (((object) ((System.Xml.XmlQualifiedName)t).Name == (object)id92_XmlSchemaMaxInclusiveFacet && (object) ((System.Xml.XmlQualifiedName)t).Namespace == (object)id56_httpwwww3org2001XMLSchema))
                    return Read29_XmlSchemaMaxInclusiveFacet(isNullable, false);
                else if (((object) ((System.Xml.XmlQualifiedName)t).Name == (object)id93_XmlSchemaEnumerationFacet && (object) ((System.Xml.XmlQualifiedName)t).Namespace == (object)id56_httpwwww3org2001XMLSchema))
                    return Read28_XmlSchemaEnumerationFacet(isNullable, false);
                else if (((object) ((System.Xml.XmlQualifiedName)t).Name == (object)id94_XmlSchemaPatternFacet && (object) ((System.Xml.XmlQualifiedName)t).Namespace == (object)id56_httpwwww3org2001XMLSchema))
                    return Read27_XmlSchemaPatternFacet(isNullable, false);
                else if (((object) ((System.Xml.XmlQualifiedName)t).Name == (object)id95_XmlSchemaWhiteSpaceFacet && (object) ((System.Xml.XmlQualifiedName)t).Namespace == (object)id56_httpwwww3org2001XMLSchema))
                    return Read25_XmlSchemaWhiteSpaceFacet(isNullable, false);
                else if (((object) ((System.Xml.XmlQualifiedName)t).Name == (object)id96_XmlSchemaNumericFacet && (object) ((System.Xml.XmlQualifiedName)t).Namespace == (object)id56_httpwwww3org2001XMLSchema))
                    return Read22_XmlSchemaNumericFacet(isNullable, false);
                else if (((object) ((System.Xml.XmlQualifiedName)t).Name == (object)id97_XmlSchemaFractionDigitsFacet && (object) ((System.Xml.XmlQualifiedName)t).Namespace == (object)id56_httpwwww3org2001XMLSchema))
                    return Read34_XmlSchemaFractionDigitsFacet(isNullable, false);
                else if (((object) ((System.Xml.XmlQualifiedName)t).Name == (object)id98_XmlSchemaTotalDigitsFacet && (object) ((System.Xml.XmlQualifiedName)t).Namespace == (object)id56_httpwwww3org2001XMLSchema))
                    return Read33_XmlSchemaTotalDigitsFacet(isNullable, false);
                else if (((object) ((System.Xml.XmlQualifiedName)t).Name == (object)id99_XmlSchemaMaxLengthFacet && (object) ((System.Xml.XmlQualifiedName)t).Namespace == (object)id56_httpwwww3org2001XMLSchema))
                    return Read26_XmlSchemaMaxLengthFacet(isNullable, false);
                else if (((object) ((System.Xml.XmlQualifiedName)t).Name == (object)id100_XmlSchemaLengthFacet && (object) ((System.Xml.XmlQualifiedName)t).Namespace == (object)id56_httpwwww3org2001XMLSchema))
                    return Read24_XmlSchemaLengthFacet(isNullable, false);
                else if (((object) ((System.Xml.XmlQualifiedName)t).Name == (object)id101_XmlSchemaMinLengthFacet && (object) ((System.Xml.XmlQualifiedName)t).Namespace == (object)id56_httpwwww3org2001XMLSchema))
                    return Read21_XmlSchemaMinLengthFacet(isNullable, false);
                else if (((object) ((System.Xml.XmlQualifiedName)t).Name == (object)id102_XmlSchemaSimpleTypeContent && (object) ((System.Xml.XmlQualifiedName)t).Namespace == (object)id56_httpwwww3org2001XMLSchema))
                    return Read19_XmlSchemaSimpleTypeContent(isNullable, false);
                else if (((object) ((System.Xml.XmlQualifiedName)t).Name == (object)id103_XmlSchemaSimpleTypeUnion && (object) ((System.Xml.XmlQualifiedName)t).Namespace == (object)id56_httpwwww3org2001XMLSchema))
                    return Read35_XmlSchemaSimpleTypeUnion(isNullable, false);
                else if (((object) ((System.Xml.XmlQualifiedName)t).Name == (object)id104_XmlSchemaSimpleTypeRestriction && (object) ((System.Xml.XmlQualifiedName)t).Namespace == (object)id56_httpwwww3org2001XMLSchema))
                    return Read20_XmlSchemaSimpleTypeRestriction(isNullable, false);
                else if (((object) ((System.Xml.XmlQualifiedName)t).Name == (object)id105_XmlSchemaSimpleTypeList && (object) ((System.Xml.XmlQualifiedName)t).Namespace == (object)id56_httpwwww3org2001XMLSchema))
                    return Read18_XmlSchemaSimpleTypeList(isNullable, false);
                else if (((object) ((System.Xml.XmlQualifiedName)t).Name == (object)id106_XmlSchemaType && (object) ((System.Xml.XmlQualifiedName)t).Namespace == (object)id56_httpwwww3org2001XMLSchema))
                    return Read13_XmlSchemaType(isNullable, false);
                else if (((object) ((System.Xml.XmlQualifiedName)t).Name == (object)id107_XmlSchemaComplexType && (object) ((System.Xml.XmlQualifiedName)t).Namespace == (object)id56_httpwwww3org2001XMLSchema))
                    return Read42_XmlSchemaComplexType(isNullable, false);
                else if (((object) ((System.Xml.XmlQualifiedName)t).Name == (object)id108_XmlSchemaSimpleType && (object) ((System.Xml.XmlQualifiedName)t).Namespace == (object)id56_httpwwww3org2001XMLSchema))
                    return Read12_XmlSchemaSimpleType(isNullable, false);
                else if (((object) ((System.Xml.XmlQualifiedName)t).Name == (object)id109_XmlSchemaExternal && (object) ((System.Xml.XmlQualifiedName)t).Namespace == (object)id56_httpwwww3org2001XMLSchema))
                    return Read11_XmlSchemaExternal(isNullable, false);
                else if (((object) ((System.Xml.XmlQualifiedName)t).Name == (object)id110_XmlSchemaInclude && (object) ((System.Xml.XmlQualifiedName)t).Namespace == (object)id56_httpwwww3org2001XMLSchema))
                    return Read66_XmlSchemaInclude(isNullable, false);
                else if (((object) ((System.Xml.XmlQualifiedName)t).Name == (object)id111_XmlSchemaImport && (object) ((System.Xml.XmlQualifiedName)t).Namespace == (object)id56_httpwwww3org2001XMLSchema))
                    return Read65_XmlSchemaImport(isNullable, false);
                else if (((object) ((System.Xml.XmlQualifiedName)t).Name == (object)id112_XmlSchemaRedefine && (object) ((System.Xml.XmlQualifiedName)t).Namespace == (object)id56_httpwwww3org2001XMLSchema))
                    return Read10_XmlSchemaRedefine(isNullable, false);
                else if (((object) ((System.Xml.XmlQualifiedName)t).Name == (object)id113_XmlSchema && (object) ((System.Xml.XmlQualifiedName)t).Namespace == (object)id56_httpwwww3org2001XMLSchema))
                    return Read6_XmlSchema(isNullable, false);
                else if (((object) ((System.Xml.XmlQualifiedName)t).Name == (object)id13_DocumentableItem && (object) ((System.Xml.XmlQualifiedName)t).Namespace == (object)id2_httpschemasxmlsoaporgwsdl))
                    return Read2_DocumentableItem(isNullable, false);
                else if (((object) ((System.Xml.XmlQualifiedName)t).Name == (object)id14_Port && (object) ((System.Xml.XmlQualifiedName)t).Namespace == (object)id2_httpschemasxmlsoaporgwsdl))
                    return Read105_Port(isNullable, false);
                else if (((object) ((System.Xml.XmlQualifiedName)t).Name == (object)id15_Service && (object) ((System.Xml.XmlQualifiedName)t).Namespace == (object)id2_httpschemasxmlsoaporgwsdl))
                    return Read104_Service(isNullable, false);
                else if (((object) ((System.Xml.XmlQualifiedName)t).Name == (object)id16_MessageBinding && (object) ((System.Xml.XmlQualifiedName)t).Namespace == (object)id2_httpschemasxmlsoaporgwsdl))
                    return Read86_MessageBinding(isNullable, false);
                else if (((object) ((System.Xml.XmlQualifiedName)t).Name == (object)id17_FaultBinding && (object) ((System.Xml.XmlQualifiedName)t).Namespace == (object)id2_httpschemasxmlsoaporgwsdl))
                    return Read102_FaultBinding(isNullable, false);
                else if (((object) ((System.Xml.XmlQualifiedName)t).Name == (object)id18_OutputBinding && (object) ((System.Xml.XmlQualifiedName)t).Namespace == (object)id2_httpschemasxmlsoaporgwsdl))
                    return Read101_OutputBinding(isNullable, false);
                else if (((object) ((System.Xml.XmlQualifiedName)t).Name == (object)id19_InputBinding && (object) ((System.Xml.XmlQualifiedName)t).Namespace == (object)id2_httpschemasxmlsoaporgwsdl))
                    return Read85_InputBinding(isNullable, false);
                else if (((object) ((System.Xml.XmlQualifiedName)t).Name == (object)id20_OperationBinding && (object) ((System.Xml.XmlQualifiedName)t).Namespace == (object)id2_httpschemasxmlsoaporgwsdl))
                    return Read82_OperationBinding(isNullable, false);
                else if (((object) ((System.Xml.XmlQualifiedName)t).Name == (object)id21_Binding && (object) ((System.Xml.XmlQualifiedName)t).Namespace == (object)id2_httpschemasxmlsoaporgwsdl))
                    return Read76_Binding(isNullable, false);
                else if (((object) ((System.Xml.XmlQualifiedName)t).Name == (object)id22_OperationMessage && (object) ((System.Xml.XmlQualifiedName)t).Namespace == (object)id2_httpschemasxmlsoaporgwsdl))
                    return Read73_OperationMessage(isNullable, false);
                else if (((object) ((System.Xml.XmlQualifiedName)t).Name == (object)id23_OperationFault && (object) ((System.Xml.XmlQualifiedName)t).Namespace == (object)id2_httpschemasxmlsoaporgwsdl))
                    return Read75_OperationFault(isNullable, false);
                else if (((object) ((System.Xml.XmlQualifiedName)t).Name == (object)id24_OperationOutput && (object) ((System.Xml.XmlQualifiedName)t).Namespace == (object)id2_httpschemasxmlsoaporgwsdl))
                    return Read74_OperationOutput(isNullable, false);
                else if (((object) ((System.Xml.XmlQualifiedName)t).Name == (object)id25_OperationInput && (object) ((System.Xml.XmlQualifiedName)t).Namespace == (object)id2_httpschemasxmlsoaporgwsdl))
                    return Read72_OperationInput(isNullable, false);
                else if (((object) ((System.Xml.XmlQualifiedName)t).Name == (object)id26_Operation && (object) ((System.Xml.XmlQualifiedName)t).Namespace == (object)id2_httpschemasxmlsoaporgwsdl))
                    return Read71_Operation(isNullable, false);
                else if (((object) ((System.Xml.XmlQualifiedName)t).Name == (object)id27_PortType && (object) ((System.Xml.XmlQualifiedName)t).Namespace == (object)id2_httpschemasxmlsoaporgwsdl))
                    return Read70_PortType(isNullable, false);
                else if (((object) ((System.Xml.XmlQualifiedName)t).Name == (object)id28_MessagePart && (object) ((System.Xml.XmlQualifiedName)t).Namespace == (object)id2_httpschemasxmlsoaporgwsdl))
                    return Read69_MessagePart(isNullable, false);
                else if (((object) ((System.Xml.XmlQualifiedName)t).Name == (object)id29_Message && (object) ((System.Xml.XmlQualifiedName)t).Namespace == (object)id2_httpschemasxmlsoaporgwsdl))
                    return Read68_Message(isNullable, false);
                else if (((object) ((System.Xml.XmlQualifiedName)t).Name == (object)id30_Types && (object) ((System.Xml.XmlQualifiedName)t).Namespace == (object)id2_httpschemasxmlsoaporgwsdl))
                    return Read5_Types(isNullable, false);
                else if (((object) ((System.Xml.XmlQualifiedName)t).Name == (object)id31_Import && (object) ((System.Xml.XmlQualifiedName)t).Namespace == (object)id2_httpschemasxmlsoaporgwsdl))
                    return Read4_Import(isNullable, false);
                else if (((object) ((System.Xml.XmlQualifiedName)t).Name == (object)id1_ServiceDescription && (object) ((System.Xml.XmlQualifiedName)t).Namespace == (object)id2_httpschemasxmlsoaporgwsdl))
                    return Read1_ServiceDescription(isNullable, false);
                else if (((object) ((System.Xml.XmlQualifiedName)t).Name == (object)id114_XmlSchemaForm && (object) ((System.Xml.XmlQualifiedName)t).Namespace == (object)id56_httpwwww3org2001XMLSchema)) {
                    Reader.ReadStartElement();
                    object e = Read8_XmlSchemaForm(Reader.ReadString());
                    ReadEndElement();
                    return e;
                }
                else if (((object) ((System.Xml.XmlQualifiedName)t).Name == (object)id115_XmlSchemaDerivationMethod && (object) ((System.Xml.XmlQualifiedName)t).Namespace == (object)id56_httpwwww3org2001XMLSchema)) {
                    Reader.ReadStartElement();
                    object e = Read9_XmlSchemaDerivationMethod(Reader.ReadString());
                    ReadEndElement();
                    return e;
                }
                else if (((object) ((System.Xml.XmlQualifiedName)t).Name == (object)id116_XmlSchemaUse && (object) ((System.Xml.XmlQualifiedName)t).Namespace == (object)id56_httpwwww3org2001XMLSchema)) {
                    Reader.ReadStartElement();
                    object e = Read38_XmlSchemaUse(Reader.ReadString());
                    ReadEndElement();
                    return e;
                }
                else if (((object) ((System.Xml.XmlQualifiedName)t).Name == (object)id117_XmlSchemaContentProcessing && (object) ((System.Xml.XmlQualifiedName)t).Namespace == (object)id56_httpwwww3org2001XMLSchema)) {
                    Reader.ReadStartElement();
                    object e = Read41_XmlSchemaContentProcessing(Reader.ReadString());
                    ReadEndElement();
                    return e;
                }
                else if (((object) ((System.Xml.XmlQualifiedName)t).Name == (object)id118_SoapBindingStyle && (object) ((System.Xml.XmlQualifiedName)t).Namespace == (object)id41_httpschemasxmlsoaporgwsdlsoap)) {
                    Reader.ReadStartElement();
                    object e = Read81_SoapBindingStyle(Reader.ReadString());
                    ReadEndElement();
                    return e;
                }
                else if (((object) ((System.Xml.XmlQualifiedName)t).Name == (object)id119_SoapBindingUse && (object) ((System.Xml.XmlQualifiedName)t).Namespace == (object)id41_httpschemasxmlsoaporgwsdlsoap)) {
                    Reader.ReadStartElement();
                    object e = Read98_SoapBindingUse(Reader.ReadString());
                    ReadEndElement();
                    return e;
                }
                else
                    return ReadTypedPrimitive((System.Xml.XmlQualifiedName)t);
            }
            System.Object o = new System.Object();
            bool[] paramsRead = new bool[0];
            while (Reader.MoveToNextAttribute()) {
                if (!IsXmlnsAttribute(Reader.Name)) {
                    UnknownNode((object)o);
                }
            }
            Reader.MoveToElement();
            if (Reader.IsEmptyElement) {
                Reader.Skip();
                return o;
            }
            Reader.ReadStartElement();
            Reader.MoveToContent();
            while (Reader.NodeType != System.Xml.XmlNodeType.EndElement) {
                if (Reader.NodeType == System.Xml.XmlNodeType.Element) {
                    UnknownNode((object)o);
                }
                else {
                    UnknownNode((object)o);
                }
                Reader.MoveToContent();
            }
            ReadEndElement();
            return o;
        }

        System.Web.Services.Description.Import Read4_Import(bool isNullable, bool checkType) {
            if (isNullable && ReadNull()) return null;
            if (checkType) {
                System.Xml.XmlQualifiedName t = GetXsiType();
                if (t == null || ((object) ((System.Xml.XmlQualifiedName)t).Name == (object)id31_Import && (object) ((System.Xml.XmlQualifiedName)t).Namespace == (object)id2_httpschemasxmlsoaporgwsdl))
                    ;
                else
                    throw CreateUnknownTypeException((System.Xml.XmlQualifiedName)t);
            }
            System.Web.Services.Description.Import o = new System.Web.Services.Description.Import();
            bool[] paramsRead = new bool[3];
            while (Reader.MoveToNextAttribute()) {
                if (!paramsRead[1] && ((object) Reader.LocalName == (object)id120_namespace && (object) Reader.NamespaceURI == (object)id4_Item)) {
                    o.@Namespace = Reader.Value;
                    paramsRead[1] = true;
                }
                else if (!paramsRead[2] && ((object) Reader.LocalName == (object)id121_location && (object) Reader.NamespaceURI == (object)id4_Item)) {
                    o.@Location = Reader.Value;
                    paramsRead[2] = true;
                }
                else if (!IsXmlnsAttribute(Reader.Name)) {
                    UnknownNode((object)o);
                }
            }
            Reader.MoveToElement();
            if (Reader.IsEmptyElement) {
                Reader.Skip();
                return o;
            }
            Reader.ReadStartElement();
            Reader.MoveToContent();
            while (Reader.NodeType != System.Xml.XmlNodeType.EndElement) {
                if (Reader.NodeType == System.Xml.XmlNodeType.Element) {
                    if (!paramsRead[0] && ((object) Reader.LocalName == (object)id6_documentation && (object) Reader.NamespaceURI == (object)id2_httpschemasxmlsoaporgwsdl)) {
                        o.@Documentation = Reader.ReadElementString();
                        paramsRead[0] = true;
                    }
                    else {
                        UnknownNode((object)o);
                    }
                }
                else {
                    UnknownNode((object)o);
                }
                Reader.MoveToContent();
            }
            ReadEndElement();
            return o;
        }

        System.Web.Services.Description.Types Read5_Types(bool isNullable, bool checkType) {
            if (isNullable && ReadNull()) return null;
            if (checkType) {
                System.Xml.XmlQualifiedName t = GetXsiType();
                if (t == null || ((object) ((System.Xml.XmlQualifiedName)t).Name == (object)id30_Types && (object) ((System.Xml.XmlQualifiedName)t).Namespace == (object)id2_httpschemasxmlsoaporgwsdl))
                    ;
                else
                    throw CreateUnknownTypeException((System.Xml.XmlQualifiedName)t);
            }
            System.Web.Services.Description.Types o = new System.Web.Services.Description.Types();
            System.Xml.Serialization.XmlSchemas a_1 = (System.Xml.Serialization.XmlSchemas)o.@Schemas;
            bool[] paramsRead = new bool[2];
            while (Reader.MoveToNextAttribute()) {
                if (!IsXmlnsAttribute(Reader.Name)) {
                    UnknownNode((object)o);
                }
            }
            Reader.MoveToElement();
            if (Reader.IsEmptyElement) {
                Reader.Skip();
                return o;
            }
            Reader.ReadStartElement();
            Reader.MoveToContent();
            while (Reader.NodeType != System.Xml.XmlNodeType.EndElement) {
                if (Reader.NodeType == System.Xml.XmlNodeType.Element) {
                    if (!paramsRead[0] && ((object) Reader.LocalName == (object)id6_documentation && (object) Reader.NamespaceURI == (object)id2_httpschemasxmlsoaporgwsdl)) {
                        o.@Documentation = Reader.ReadElementString();
                        paramsRead[0] = true;
                    }
                    else if (((object) Reader.LocalName == (object)id122_schema && (object) Reader.NamespaceURI == (object)id56_httpwwww3org2001XMLSchema)) {
                        if ((object)(a_1) == null) Reader.Skip(); else a_1.Add(Read6_XmlSchema(false, true));
                    }
                    else {
                        UnknownNode((object)o);
                    }
                }
                else {
                    UnknownNode((object)o);
                }
                Reader.MoveToContent();
            }
            ReadEndElement();
            return o;
        }

        System.Xml.Schema.XmlSchema Read6_XmlSchema(bool isNullable, bool checkType) {
            if (isNullable && ReadNull()) return null;
            if (checkType) {
                System.Xml.XmlQualifiedName t = GetXsiType();
                if (t == null || ((object) ((System.Xml.XmlQualifiedName)t).Name == (object)id113_XmlSchema && (object) ((System.Xml.XmlQualifiedName)t).Namespace == (object)id56_httpwwww3org2001XMLSchema))
                    ;
                else
                    throw CreateUnknownTypeException((System.Xml.XmlQualifiedName)t);
            }
            System.Xml.Schema.XmlSchema o = new System.Xml.Schema.XmlSchema();
            System.Xml.Schema.XmlSchemaObjectCollection a_7 = (System.Xml.Schema.XmlSchemaObjectCollection)o.@Includes;
            System.Xml.Schema.XmlSchemaObjectCollection a_8 = (System.Xml.Schema.XmlSchemaObjectCollection)o.@Items;
            System.Xml.XmlAttribute[] a_10 = null;
            int ca_10 = 0;
            bool[] paramsRead = new bool[11];
            while (Reader.MoveToNextAttribute()) {
                if (!paramsRead[1] && ((object) Reader.LocalName == (object)id123_attributeFormDefault && (object) Reader.NamespaceURI == (object)id4_Item)) {
                    o.@AttributeFormDefault = Read8_XmlSchemaForm(Reader.Value);
                    paramsRead[1] = true;
                }
                else if (!paramsRead[2] && ((object) Reader.LocalName == (object)id124_blockDefault && (object) Reader.NamespaceURI == (object)id4_Item)) {
                    o.@BlockDefault = Read9_XmlSchemaDerivationMethod(Reader.Value);
                    paramsRead[2] = true;
                }
                else if (!paramsRead[3] && ((object) Reader.LocalName == (object)id125_finalDefault && (object) Reader.NamespaceURI == (object)id4_Item)) {
                    o.@FinalDefault = Read9_XmlSchemaDerivationMethod(Reader.Value);
                    paramsRead[3] = true;
                }
                else if (!paramsRead[4] && ((object) Reader.LocalName == (object)id126_elementFormDefault && (object) Reader.NamespaceURI == (object)id4_Item)) {
                    o.@ElementFormDefault = Read8_XmlSchemaForm(Reader.Value);
                    paramsRead[4] = true;
                }
                else if (!paramsRead[5] && ((object) Reader.LocalName == (object)id3_targetNamespace && (object) Reader.NamespaceURI == (object)id4_Item)) {
                    o.@TargetNamespace = Reader.Value;
                    paramsRead[5] = true;
                }
                else if (!paramsRead[6] && ((object) Reader.LocalName == (object)id127_version && (object) Reader.NamespaceURI == (object)id4_Item)) {
                    o.@Version = Reader.Value;
                    paramsRead[6] = true;
                }
                else if (!paramsRead[9] && ((object) Reader.LocalName == (object)id128_id && (object) Reader.NamespaceURI == (object)id4_Item)) {
                    o.@Id = Reader.Value;
                    paramsRead[9] = true;
                }
                else if (IsXmlnsAttribute(Reader.Name)) {
                    if (o.@Namespaces == null) o.@Namespaces = new System.Xml.Serialization.XmlSerializerNamespaces();
                    o.@Namespaces.Add(Reader.Name.Length == 5 ? "" : Reader.LocalName, Reader.Value);
                }
                else {
                    System.Xml.XmlAttribute attr = (System.Xml.XmlAttribute) Document.ReadNode(Reader);
                    ParseWsdlArrayType(attr);
                    a_10 = (System.Xml.XmlAttribute[])EnsureArrayIndex(a_10, ca_10, typeof(System.Xml.XmlAttribute));a_10[ca_10++] = attr;
                }
            }
            o.@UnhandledAttributes = (System.Xml.XmlAttribute[])ShrinkArray(a_10, ca_10, typeof(System.Xml.XmlAttribute), true);
            Reader.MoveToElement();
            if (Reader.IsEmptyElement) {
                Reader.Skip();
                o.@UnhandledAttributes = (System.Xml.XmlAttribute[])ShrinkArray(a_10, ca_10, typeof(System.Xml.XmlAttribute), true);
                return o;
            }
            Reader.ReadStartElement();
            Reader.MoveToContent();
            while (Reader.NodeType != System.Xml.XmlNodeType.EndElement) {
                if (Reader.NodeType == System.Xml.XmlNodeType.Element) {
                    if (((object) Reader.LocalName == (object)id7_import && (object) Reader.NamespaceURI == (object)id56_httpwwww3org2001XMLSchema)) {
                        if ((object)(a_7) == null) Reader.Skip(); else a_7.Add(Read65_XmlSchemaImport(false, true));
                    }
                    else if (((object) Reader.LocalName == (object)id129_redefine && (object) Reader.NamespaceURI == (object)id56_httpwwww3org2001XMLSchema)) {
                        if ((object)(a_7) == null) Reader.Skip(); else a_7.Add(Read10_XmlSchemaRedefine(false, true));
                    }
                    else if (((object) Reader.LocalName == (object)id130_include && (object) Reader.NamespaceURI == (object)id56_httpwwww3org2001XMLSchema)) {
                        if ((object)(a_7) == null) Reader.Skip(); else a_7.Add(Read66_XmlSchemaInclude(false, true));
                    }
                    else if (((object) Reader.LocalName == (object)id131_simpleType && (object) Reader.NamespaceURI == (object)id56_httpwwww3org2001XMLSchema)) {
                        if ((object)(a_8) == null) Reader.Skip(); else a_8.Add(Read12_XmlSchemaSimpleType(false, true));
                    }
                    else if (((object) Reader.LocalName == (object)id132_notation && (object) Reader.NamespaceURI == (object)id56_httpwwww3org2001XMLSchema)) {
                        if ((object)(a_8) == null) Reader.Skip(); else a_8.Add(Read67_XmlSchemaNotation(false, true));
                    }
                    else if (((object) Reader.LocalName == (object)id133_attribute && (object) Reader.NamespaceURI == (object)id56_httpwwww3org2001XMLSchema)) {
                        if ((object)(a_8) == null) Reader.Skip(); else a_8.Add(Read37_XmlSchemaAttribute(false, true));
                    }
                    else if (((object) Reader.LocalName == (object)id134_element && (object) Reader.NamespaceURI == (object)id56_httpwwww3org2001XMLSchema)) {
                        if ((object)(a_8) == null) Reader.Skip(); else a_8.Add(Read51_XmlSchemaElement(false, true));
                    }
                    else if (((object) Reader.LocalName == (object)id135_group && (object) Reader.NamespaceURI == (object)id56_httpwwww3org2001XMLSchema)) {
                        if ((object)(a_8) == null) Reader.Skip(); else a_8.Add(Read64_XmlSchemaGroup(false, true));
                    }
                    else if (((object) Reader.LocalName == (object)id136_attributeGroup && (object) Reader.NamespaceURI == (object)id56_httpwwww3org2001XMLSchema)) {
                        if ((object)(a_8) == null) Reader.Skip(); else a_8.Add(Read36_XmlSchemaAttributeGroup(false, true));
                    }
                    else if (((object) Reader.LocalName == (object)id137_complexType && (object) Reader.NamespaceURI == (object)id56_httpwwww3org2001XMLSchema)) {
                        if ((object)(a_8) == null) Reader.Skip(); else a_8.Add(Read42_XmlSchemaComplexType(false, true));
                    }
                    else if (((object) Reader.LocalName == (object)id138_annotation && (object) Reader.NamespaceURI == (object)id56_httpwwww3org2001XMLSchema)) {
                        if ((object)(a_8) == null) Reader.Skip(); else a_8.Add(Read15_XmlSchemaAnnotation(false, true));
                    }
                    else {
                        UnknownNode((object)o);
                    }
                }
                else {
                    UnknownNode((object)o);
                }
                Reader.MoveToContent();
            }
            o.@UnhandledAttributes = (System.Xml.XmlAttribute[])ShrinkArray(a_10, ca_10, typeof(System.Xml.XmlAttribute), true);
            ReadEndElement();
            return o;
        }

        System.Xml.Schema.XmlSchemaObject Read7_XmlSchemaObject(bool isNullable, bool checkType) {
            if (isNullable && ReadNull()) return null;
            if (checkType) {
                System.Xml.XmlQualifiedName t = GetXsiType();
                if (t == null || ((object) ((System.Xml.XmlQualifiedName)t).Name == (object)id55_XmlSchemaObject && (object) ((System.Xml.XmlQualifiedName)t).Namespace == (object)id56_httpwwww3org2001XMLSchema))
                    ;
                else if (((object) ((System.Xml.XmlQualifiedName)t).Name == (object)id57_XmlSchemaDocumentation && (object) ((System.Xml.XmlQualifiedName)t).Namespace == (object)id56_httpwwww3org2001XMLSchema))
                    return Read17_XmlSchemaDocumentation(isNullable, false);
                else if (((object) ((System.Xml.XmlQualifiedName)t).Name == (object)id58_XmlSchemaAppInfo && (object) ((System.Xml.XmlQualifiedName)t).Namespace == (object)id56_httpwwww3org2001XMLSchema))
                    return Read16_XmlSchemaAppInfo(isNullable, false);
                else if (((object) ((System.Xml.XmlQualifiedName)t).Name == (object)id59_XmlSchemaAnnotation && (object) ((System.Xml.XmlQualifiedName)t).Namespace == (object)id56_httpwwww3org2001XMLSchema))
                    return Read15_XmlSchemaAnnotation(isNullable, false);
                else if (((object) ((System.Xml.XmlQualifiedName)t).Name == (object)id60_XmlSchemaAnnotated && (object) ((System.Xml.XmlQualifiedName)t).Namespace == (object)id56_httpwwww3org2001XMLSchema))
                    return Read14_XmlSchemaAnnotated(isNullable, false);
                else if (((object) ((System.Xml.XmlQualifiedName)t).Name == (object)id61_XmlSchemaNotation && (object) ((System.Xml.XmlQualifiedName)t).Namespace == (object)id56_httpwwww3org2001XMLSchema))
                    return Read67_XmlSchemaNotation(isNullable, false);
                else if (((object) ((System.Xml.XmlQualifiedName)t).Name == (object)id62_XmlSchemaGroup && (object) ((System.Xml.XmlQualifiedName)t).Namespace == (object)id56_httpwwww3org2001XMLSchema))
                    return Read64_XmlSchemaGroup(isNullable, false);
                else if (((object) ((System.Xml.XmlQualifiedName)t).Name == (object)id63_XmlSchemaXPath && (object) ((System.Xml.XmlQualifiedName)t).Namespace == (object)id56_httpwwww3org2001XMLSchema))
                    return Read54_XmlSchemaXPath(isNullable, false);
                else if (((object) ((System.Xml.XmlQualifiedName)t).Name == (object)id64_XmlSchemaIdentityConstraint && (object) ((System.Xml.XmlQualifiedName)t).Namespace == (object)id56_httpwwww3org2001XMLSchema))
                    return Read53_XmlSchemaIdentityConstraint(isNullable, false);
                else if (((object) ((System.Xml.XmlQualifiedName)t).Name == (object)id65_XmlSchemaKey && (object) ((System.Xml.XmlQualifiedName)t).Namespace == (object)id56_httpwwww3org2001XMLSchema))
                    return Read56_XmlSchemaKey(isNullable, false);
                else if (((object) ((System.Xml.XmlQualifiedName)t).Name == (object)id66_XmlSchemaUnique && (object) ((System.Xml.XmlQualifiedName)t).Namespace == (object)id56_httpwwww3org2001XMLSchema))
                    return Read55_XmlSchemaUnique(isNullable, false);
                else if (((object) ((System.Xml.XmlQualifiedName)t).Name == (object)id67_XmlSchemaKeyref && (object) ((System.Xml.XmlQualifiedName)t).Namespace == (object)id56_httpwwww3org2001XMLSchema))
                    return Read52_XmlSchemaKeyref(isNullable, false);
                else if (((object) ((System.Xml.XmlQualifiedName)t).Name == (object)id68_XmlSchemaParticle && (object) ((System.Xml.XmlQualifiedName)t).Namespace == (object)id56_httpwwww3org2001XMLSchema))
                    return Read49_XmlSchemaParticle(isNullable, false);
                else if (((object) ((System.Xml.XmlQualifiedName)t).Name == (object)id69_XmlSchemaGroupRef && (object) ((System.Xml.XmlQualifiedName)t).Namespace == (object)id56_httpwwww3org2001XMLSchema))
                    return Read57_XmlSchemaGroupRef(isNullable, false);
                else if (((object) ((System.Xml.XmlQualifiedName)t).Name == (object)id70_XmlSchemaElement && (object) ((System.Xml.XmlQualifiedName)t).Namespace == (object)id56_httpwwww3org2001XMLSchema))
                    return Read51_XmlSchemaElement(isNullable, false);
                else if (((object) ((System.Xml.XmlQualifiedName)t).Name == (object)id71_XmlSchemaAny && (object) ((System.Xml.XmlQualifiedName)t).Namespace == (object)id56_httpwwww3org2001XMLSchema))
                    return Read50_XmlSchemaAny(isNullable, false);
                else if (((object) ((System.Xml.XmlQualifiedName)t).Name == (object)id72_XmlSchemaGroupBase && (object) ((System.Xml.XmlQualifiedName)t).Namespace == (object)id56_httpwwww3org2001XMLSchema))
                    return Read48_XmlSchemaGroupBase(isNullable, false);
                else if (((object) ((System.Xml.XmlQualifiedName)t).Name == (object)id73_XmlSchemaAll && (object) ((System.Xml.XmlQualifiedName)t).Namespace == (object)id56_httpwwww3org2001XMLSchema))
                    return Read59_XmlSchemaAll(isNullable, false);
                else if (((object) ((System.Xml.XmlQualifiedName)t).Name == (object)id74_XmlSchemaChoice && (object) ((System.Xml.XmlQualifiedName)t).Namespace == (object)id56_httpwwww3org2001XMLSchema))
                    return Read58_XmlSchemaChoice(isNullable, false);
                else if (((object) ((System.Xml.XmlQualifiedName)t).Name == (object)id75_XmlSchemaSequence && (object) ((System.Xml.XmlQualifiedName)t).Namespace == (object)id56_httpwwww3org2001XMLSchema))
                    return Read47_XmlSchemaSequence(isNullable, false);
                else if (((object) ((System.Xml.XmlQualifiedName)t).Name == (object)id76_XmlSchemaContent && (object) ((System.Xml.XmlQualifiedName)t).Namespace == (object)id56_httpwwww3org2001XMLSchema))
                    return Read46_XmlSchemaContent(isNullable, false);
                else if (((object) ((System.Xml.XmlQualifiedName)t).Name == (object)id77_XmlSchemaSimpleContentExtension && (object) ((System.Xml.XmlQualifiedName)t).Namespace == (object)id56_httpwwww3org2001XMLSchema))
                    return Read63_XmlSchemaSimpleContentExtension(isNullable, false);
                else if (((object) ((System.Xml.XmlQualifiedName)t).Name == (object)id78_XmlSchemaSimpleContentRestriction && (object) ((System.Xml.XmlQualifiedName)t).Namespace == (object)id56_httpwwww3org2001XMLSchema))
                    return Read62_XmlSchemaSimpleContentRestriction(isNullable, false);
                else if (((object) ((System.Xml.XmlQualifiedName)t).Name == (object)id79_XmlSchemaComplexContentRestriction && (object) ((System.Xml.XmlQualifiedName)t).Namespace == (object)id56_httpwwww3org2001XMLSchema))
                    return Read60_XmlSchemaComplexContentRestriction(isNullable, false);
                else if (((object) ((System.Xml.XmlQualifiedName)t).Name == (object)id80_XmlSchemaComplexContentExtension && (object) ((System.Xml.XmlQualifiedName)t).Namespace == (object)id56_httpwwww3org2001XMLSchema))
                    return Read45_XmlSchemaComplexContentExtension(isNullable, false);
                else if (((object) ((System.Xml.XmlQualifiedName)t).Name == (object)id81_XmlSchemaContentModel && (object) ((System.Xml.XmlQualifiedName)t).Namespace == (object)id56_httpwwww3org2001XMLSchema))
                    return Read44_XmlSchemaContentModel(isNullable, false);
                else if (((object) ((System.Xml.XmlQualifiedName)t).Name == (object)id82_XmlSchemaSimpleContent && (object) ((System.Xml.XmlQualifiedName)t).Namespace == (object)id56_httpwwww3org2001XMLSchema))
                    return Read61_XmlSchemaSimpleContent(isNullable, false);
                else if (((object) ((System.Xml.XmlQualifiedName)t).Name == (object)id83_XmlSchemaComplexContent && (object) ((System.Xml.XmlQualifiedName)t).Namespace == (object)id56_httpwwww3org2001XMLSchema))
                    return Read43_XmlSchemaComplexContent(isNullable, false);
                else if (((object) ((System.Xml.XmlQualifiedName)t).Name == (object)id84_XmlSchemaAnyAttribute && (object) ((System.Xml.XmlQualifiedName)t).Namespace == (object)id56_httpwwww3org2001XMLSchema))
                    return Read40_XmlSchemaAnyAttribute(isNullable, false);
                else if (((object) ((System.Xml.XmlQualifiedName)t).Name == (object)id85_XmlSchemaAttributeGroupRef && (object) ((System.Xml.XmlQualifiedName)t).Namespace == (object)id56_httpwwww3org2001XMLSchema))
                    return Read39_XmlSchemaAttributeGroupRef(isNullable, false);
                else if (((object) ((System.Xml.XmlQualifiedName)t).Name == (object)id86_XmlSchemaAttribute && (object) ((System.Xml.XmlQualifiedName)t).Namespace == (object)id56_httpwwww3org2001XMLSchema))
                    return Read37_XmlSchemaAttribute(isNullable, false);
                else if (((object) ((System.Xml.XmlQualifiedName)t).Name == (object)id87_XmlSchemaAttributeGroup && (object) ((System.Xml.XmlQualifiedName)t).Namespace == (object)id56_httpwwww3org2001XMLSchema))
                    return Read36_XmlSchemaAttributeGroup(isNullable, false);
                else if (((object) ((System.Xml.XmlQualifiedName)t).Name == (object)id88_XmlSchemaFacet && (object) ((System.Xml.XmlQualifiedName)t).Namespace == (object)id56_httpwwww3org2001XMLSchema))
                    return Read23_XmlSchemaFacet(isNullable, false);
                else if (((object) ((System.Xml.XmlQualifiedName)t).Name == (object)id89_XmlSchemaMinExclusiveFacet && (object) ((System.Xml.XmlQualifiedName)t).Namespace == (object)id56_httpwwww3org2001XMLSchema))
                    return Read32_XmlSchemaMinExclusiveFacet(isNullable, false);
                else if (((object) ((System.Xml.XmlQualifiedName)t).Name == (object)id90_XmlSchemaMinInclusiveFacet && (object) ((System.Xml.XmlQualifiedName)t).Namespace == (object)id56_httpwwww3org2001XMLSchema))
                    return Read31_XmlSchemaMinInclusiveFacet(isNullable, false);
                else if (((object) ((System.Xml.XmlQualifiedName)t).Name == (object)id91_XmlSchemaMaxExclusiveFacet && (object) ((System.Xml.XmlQualifiedName)t).Namespace == (object)id56_httpwwww3org2001XMLSchema))
                    return Read30_XmlSchemaMaxExclusiveFacet(isNullable, false);
                else if (((object) ((System.Xml.XmlQualifiedName)t).Name == (object)id92_XmlSchemaMaxInclusiveFacet && (object) ((System.Xml.XmlQualifiedName)t).Namespace == (object)id56_httpwwww3org2001XMLSchema))
                    return Read29_XmlSchemaMaxInclusiveFacet(isNullable, false);
                else if (((object) ((System.Xml.XmlQualifiedName)t).Name == (object)id93_XmlSchemaEnumerationFacet && (object) ((System.Xml.XmlQualifiedName)t).Namespace == (object)id56_httpwwww3org2001XMLSchema))
                    return Read28_XmlSchemaEnumerationFacet(isNullable, false);
                else if (((object) ((System.Xml.XmlQualifiedName)t).Name == (object)id94_XmlSchemaPatternFacet && (object) ((System.Xml.XmlQualifiedName)t).Namespace == (object)id56_httpwwww3org2001XMLSchema))
                    return Read27_XmlSchemaPatternFacet(isNullable, false);
                else if (((object) ((System.Xml.XmlQualifiedName)t).Name == (object)id95_XmlSchemaWhiteSpaceFacet && (object) ((System.Xml.XmlQualifiedName)t).Namespace == (object)id56_httpwwww3org2001XMLSchema))
                    return Read25_XmlSchemaWhiteSpaceFacet(isNullable, false);
                else if (((object) ((System.Xml.XmlQualifiedName)t).Name == (object)id96_XmlSchemaNumericFacet && (object) ((System.Xml.XmlQualifiedName)t).Namespace == (object)id56_httpwwww3org2001XMLSchema))
                    return Read22_XmlSchemaNumericFacet(isNullable, false);
                else if (((object) ((System.Xml.XmlQualifiedName)t).Name == (object)id97_XmlSchemaFractionDigitsFacet && (object) ((System.Xml.XmlQualifiedName)t).Namespace == (object)id56_httpwwww3org2001XMLSchema))
                    return Read34_XmlSchemaFractionDigitsFacet(isNullable, false);
                else if (((object) ((System.Xml.XmlQualifiedName)t).Name == (object)id98_XmlSchemaTotalDigitsFacet && (object) ((System.Xml.XmlQualifiedName)t).Namespace == (object)id56_httpwwww3org2001XMLSchema))
                    return Read33_XmlSchemaTotalDigitsFacet(isNullable, false);
                else if (((object) ((System.Xml.XmlQualifiedName)t).Name == (object)id99_XmlSchemaMaxLengthFacet && (object) ((System.Xml.XmlQualifiedName)t).Namespace == (object)id56_httpwwww3org2001XMLSchema))
                    return Read26_XmlSchemaMaxLengthFacet(isNullable, false);
                else if (((object) ((System.Xml.XmlQualifiedName)t).Name == (object)id100_XmlSchemaLengthFacet && (object) ((System.Xml.XmlQualifiedName)t).Namespace == (object)id56_httpwwww3org2001XMLSchema))
                    return Read24_XmlSchemaLengthFacet(isNullable, false);
                else if (((object) ((System.Xml.XmlQualifiedName)t).Name == (object)id101_XmlSchemaMinLengthFacet && (object) ((System.Xml.XmlQualifiedName)t).Namespace == (object)id56_httpwwww3org2001XMLSchema))
                    return Read21_XmlSchemaMinLengthFacet(isNullable, false);
                else if (((object) ((System.Xml.XmlQualifiedName)t).Name == (object)id102_XmlSchemaSimpleTypeContent && (object) ((System.Xml.XmlQualifiedName)t).Namespace == (object)id56_httpwwww3org2001XMLSchema))
                    return Read19_XmlSchemaSimpleTypeContent(isNullable, false);
                else if (((object) ((System.Xml.XmlQualifiedName)t).Name == (object)id103_XmlSchemaSimpleTypeUnion && (object) ((System.Xml.XmlQualifiedName)t).Namespace == (object)id56_httpwwww3org2001XMLSchema))
                    return Read35_XmlSchemaSimpleTypeUnion(isNullable, false);
                else if (((object) ((System.Xml.XmlQualifiedName)t).Name == (object)id104_XmlSchemaSimpleTypeRestriction && (object) ((System.Xml.XmlQualifiedName)t).Namespace == (object)id56_httpwwww3org2001XMLSchema))
                    return Read20_XmlSchemaSimpleTypeRestriction(isNullable, false);
                else if (((object) ((System.Xml.XmlQualifiedName)t).Name == (object)id105_XmlSchemaSimpleTypeList && (object) ((System.Xml.XmlQualifiedName)t).Namespace == (object)id56_httpwwww3org2001XMLSchema))
                    return Read18_XmlSchemaSimpleTypeList(isNullable, false);
                else if (((object) ((System.Xml.XmlQualifiedName)t).Name == (object)id106_XmlSchemaType && (object) ((System.Xml.XmlQualifiedName)t).Namespace == (object)id56_httpwwww3org2001XMLSchema))
                    return Read13_XmlSchemaType(isNullable, false);
                else if (((object) ((System.Xml.XmlQualifiedName)t).Name == (object)id107_XmlSchemaComplexType && (object) ((System.Xml.XmlQualifiedName)t).Namespace == (object)id56_httpwwww3org2001XMLSchema))
                    return Read42_XmlSchemaComplexType(isNullable, false);
                else if (((object) ((System.Xml.XmlQualifiedName)t).Name == (object)id108_XmlSchemaSimpleType && (object) ((System.Xml.XmlQualifiedName)t).Namespace == (object)id56_httpwwww3org2001XMLSchema))
                    return Read12_XmlSchemaSimpleType(isNullable, false);
                else if (((object) ((System.Xml.XmlQualifiedName)t).Name == (object)id109_XmlSchemaExternal && (object) ((System.Xml.XmlQualifiedName)t).Namespace == (object)id56_httpwwww3org2001XMLSchema))
                    return Read11_XmlSchemaExternal(isNullable, false);
                else if (((object) ((System.Xml.XmlQualifiedName)t).Name == (object)id110_XmlSchemaInclude && (object) ((System.Xml.XmlQualifiedName)t).Namespace == (object)id56_httpwwww3org2001XMLSchema))
                    return Read66_XmlSchemaInclude(isNullable, false);
                else if (((object) ((System.Xml.XmlQualifiedName)t).Name == (object)id111_XmlSchemaImport && (object) ((System.Xml.XmlQualifiedName)t).Namespace == (object)id56_httpwwww3org2001XMLSchema))
                    return Read65_XmlSchemaImport(isNullable, false);
                else if (((object) ((System.Xml.XmlQualifiedName)t).Name == (object)id112_XmlSchemaRedefine && (object) ((System.Xml.XmlQualifiedName)t).Namespace == (object)id56_httpwwww3org2001XMLSchema))
                    return Read10_XmlSchemaRedefine(isNullable, false);
                else if (((object) ((System.Xml.XmlQualifiedName)t).Name == (object)id113_XmlSchema && (object) ((System.Xml.XmlQualifiedName)t).Namespace == (object)id56_httpwwww3org2001XMLSchema))
                    return Read6_XmlSchema(isNullable, false);
                else
                    throw CreateUnknownTypeException((System.Xml.XmlQualifiedName)t);
            }
            throw CreateAbstractTypeException(@"XmlSchemaObject", @"http://www.w3.org/2001/XMLSchema");
        }

        System.Xml.Schema.XmlSchemaForm Read8_XmlSchemaForm(string s) {
            switch (s) {
                case @"qualified": return System.Xml.Schema.XmlSchemaForm.@Qualified;
                case @"unqualified": return System.Xml.Schema.XmlSchemaForm.@Unqualified;
                default: throw CreateUnknownConstantException(s, typeof(System.Xml.Schema.XmlSchemaForm));
            }
        }

        System.Collections.Hashtable _XmlSchemaDerivationMethodValues;

        internal System.Collections.Hashtable XmlSchemaDerivationMethodValues {
            get {
                if ((object)_XmlSchemaDerivationMethodValues == null) {
                    System.Collections.Hashtable h = new System.Collections.Hashtable();
                    h.Add(@"", (System.Int64)System.Xml.Schema.XmlSchemaDerivationMethod.@Empty);
                    h.Add(@"substitution", (System.Int64)System.Xml.Schema.XmlSchemaDerivationMethod.@Substitution);
                    h.Add(@"extension", (System.Int64)System.Xml.Schema.XmlSchemaDerivationMethod.@Extension);
                    h.Add(@"restriction", (System.Int64)System.Xml.Schema.XmlSchemaDerivationMethod.@Restriction);
                    h.Add(@"list", (System.Int64)System.Xml.Schema.XmlSchemaDerivationMethod.@List);
                    h.Add(@"union", (System.Int64)System.Xml.Schema.XmlSchemaDerivationMethod.@Union);
                    h.Add(@"#all", (System.Int64)System.Xml.Schema.XmlSchemaDerivationMethod.@All);
                    _XmlSchemaDerivationMethodValues = h;
                }
                return _XmlSchemaDerivationMethodValues;
            }
        }

        System.Xml.Schema.XmlSchemaDerivationMethod Read9_XmlSchemaDerivationMethod(string s) {
            return (System.Xml.Schema.XmlSchemaDerivationMethod)ToEnum(s, XmlSchemaDerivationMethodValues, @"System.Xml.Schema.XmlSchemaDerivationMethod");
        }

        System.Xml.Schema.XmlSchemaRedefine Read10_XmlSchemaRedefine(bool isNullable, bool checkType) {
            if (isNullable && ReadNull()) return null;
            if (checkType) {
                System.Xml.XmlQualifiedName t = GetXsiType();
                if (t == null || ((object) ((System.Xml.XmlQualifiedName)t).Name == (object)id112_XmlSchemaRedefine && (object) ((System.Xml.XmlQualifiedName)t).Namespace == (object)id56_httpwwww3org2001XMLSchema))
                    ;
                else
                    throw CreateUnknownTypeException((System.Xml.XmlQualifiedName)t);
            }
            System.Xml.Schema.XmlSchemaRedefine o = new System.Xml.Schema.XmlSchemaRedefine();
            System.Xml.XmlAttribute[] a_3 = null;
            int ca_3 = 0;
            System.Xml.Schema.XmlSchemaObjectCollection a_4 = (System.Xml.Schema.XmlSchemaObjectCollection)o.@Items;
            bool[] paramsRead = new bool[5];
            while (Reader.MoveToNextAttribute()) {
                if (!paramsRead[1] && ((object) Reader.LocalName == (object)id139_schemaLocation && (object) Reader.NamespaceURI == (object)id4_Item)) {
                    o.@SchemaLocation = Reader.Value;
                    paramsRead[1] = true;
                }
                else if (!paramsRead[2] && ((object) Reader.LocalName == (object)id128_id && (object) Reader.NamespaceURI == (object)id4_Item)) {
                    o.@Id = Reader.Value;
                    paramsRead[2] = true;
                }
                else if (IsXmlnsAttribute(Reader.Name)) {
                    if (o.@Namespaces == null) o.@Namespaces = new System.Xml.Serialization.XmlSerializerNamespaces();
                    o.@Namespaces.Add(Reader.Name.Length == 5 ? "" : Reader.LocalName, Reader.Value);
                }
                else {
                    System.Xml.XmlAttribute attr = (System.Xml.XmlAttribute) Document.ReadNode(Reader);
                    ParseWsdlArrayType(attr);
                    a_3 = (System.Xml.XmlAttribute[])EnsureArrayIndex(a_3, ca_3, typeof(System.Xml.XmlAttribute));a_3[ca_3++] = attr;
                }
            }
            o.@UnhandledAttributes = (System.Xml.XmlAttribute[])ShrinkArray(a_3, ca_3, typeof(System.Xml.XmlAttribute), true);
            Reader.MoveToElement();
            if (Reader.IsEmptyElement) {
                Reader.Skip();
                o.@UnhandledAttributes = (System.Xml.XmlAttribute[])ShrinkArray(a_3, ca_3, typeof(System.Xml.XmlAttribute), true);
                return o;
            }
            Reader.ReadStartElement();
            Reader.MoveToContent();
            while (Reader.NodeType != System.Xml.XmlNodeType.EndElement) {
                if (Reader.NodeType == System.Xml.XmlNodeType.Element) {
                    if (((object) Reader.LocalName == (object)id137_complexType && (object) Reader.NamespaceURI == (object)id56_httpwwww3org2001XMLSchema)) {
                        if ((object)(a_4) == null) Reader.Skip(); else a_4.Add(Read42_XmlSchemaComplexType(false, true));
                    }
                    else if (((object) Reader.LocalName == (object)id136_attributeGroup && (object) Reader.NamespaceURI == (object)id56_httpwwww3org2001XMLSchema)) {
                        if ((object)(a_4) == null) Reader.Skip(); else a_4.Add(Read36_XmlSchemaAttributeGroup(false, true));
                    }
                    else if (((object) Reader.LocalName == (object)id135_group && (object) Reader.NamespaceURI == (object)id56_httpwwww3org2001XMLSchema)) {
                        if ((object)(a_4) == null) Reader.Skip(); else a_4.Add(Read64_XmlSchemaGroup(false, true));
                    }
                    else if (((object) Reader.LocalName == (object)id131_simpleType && (object) Reader.NamespaceURI == (object)id56_httpwwww3org2001XMLSchema)) {
                        if ((object)(a_4) == null) Reader.Skip(); else a_4.Add(Read12_XmlSchemaSimpleType(false, true));
                    }
                    else if (((object) Reader.LocalName == (object)id138_annotation && (object) Reader.NamespaceURI == (object)id56_httpwwww3org2001XMLSchema)) {
                        if ((object)(a_4) == null) Reader.Skip(); else a_4.Add(Read15_XmlSchemaAnnotation(false, true));
                    }
                    else {
                        UnknownNode((object)o);
                    }
                }
                else {
                    UnknownNode((object)o);
                }
                Reader.MoveToContent();
            }
            o.@UnhandledAttributes = (System.Xml.XmlAttribute[])ShrinkArray(a_3, ca_3, typeof(System.Xml.XmlAttribute), true);
            ReadEndElement();
            return o;
        }

        System.Xml.Schema.XmlSchemaExternal Read11_XmlSchemaExternal(bool isNullable, bool checkType) {
            if (isNullable && ReadNull()) return null;
            if (checkType) {
                System.Xml.XmlQualifiedName t = GetXsiType();
                if (t == null || ((object) ((System.Xml.XmlQualifiedName)t).Name == (object)id109_XmlSchemaExternal && (object) ((System.Xml.XmlQualifiedName)t).Namespace == (object)id56_httpwwww3org2001XMLSchema))
                    ;
                else if (((object) ((System.Xml.XmlQualifiedName)t).Name == (object)id110_XmlSchemaInclude && (object) ((System.Xml.XmlQualifiedName)t).Namespace == (object)id56_httpwwww3org2001XMLSchema))
                    return Read66_XmlSchemaInclude(isNullable, false);
                else if (((object) ((System.Xml.XmlQualifiedName)t).Name == (object)id111_XmlSchemaImport && (object) ((System.Xml.XmlQualifiedName)t).Namespace == (object)id56_httpwwww3org2001XMLSchema))
                    return Read65_XmlSchemaImport(isNullable, false);
                else if (((object) ((System.Xml.XmlQualifiedName)t).Name == (object)id112_XmlSchemaRedefine && (object) ((System.Xml.XmlQualifiedName)t).Namespace == (object)id56_httpwwww3org2001XMLSchema))
                    return Read10_XmlSchemaRedefine(isNullable, false);
                else
                    throw CreateUnknownTypeException((System.Xml.XmlQualifiedName)t);
            }
            throw CreateAbstractTypeException(@"XmlSchemaExternal", @"http://www.w3.org/2001/XMLSchema");
        }

        System.Xml.Schema.XmlSchemaSimpleType Read12_XmlSchemaSimpleType(bool isNullable, bool checkType) {
            if (isNullable && ReadNull()) return null;
            if (checkType) {
                System.Xml.XmlQualifiedName t = GetXsiType();
                if (t == null || ((object) ((System.Xml.XmlQualifiedName)t).Name == (object)id108_XmlSchemaSimpleType && (object) ((System.Xml.XmlQualifiedName)t).Namespace == (object)id56_httpwwww3org2001XMLSchema))
                    ;
                else
                    throw CreateUnknownTypeException((System.Xml.XmlQualifiedName)t);
            }
            System.Xml.Schema.XmlSchemaSimpleType o = new System.Xml.Schema.XmlSchemaSimpleType();
            System.Xml.XmlAttribute[] a_3 = null;
            int ca_3 = 0;
            bool[] paramsRead = new bool[7];
            while (Reader.MoveToNextAttribute()) {
                if (!paramsRead[1] && ((object) Reader.LocalName == (object)id128_id && (object) Reader.NamespaceURI == (object)id4_Item)) {
                    o.@Id = Reader.Value;
                    paramsRead[1] = true;
                }
                else if (!paramsRead[4] && ((object) Reader.LocalName == (object)id5_name && (object) Reader.NamespaceURI == (object)id4_Item)) {
                    o.@Name = Reader.Value;
                    paramsRead[4] = true;
                }
                else if (!paramsRead[5] && ((object) Reader.LocalName == (object)id140_final && (object) Reader.NamespaceURI == (object)id4_Item)) {
                    o.@Final = Read9_XmlSchemaDerivationMethod(Reader.Value);
                    paramsRead[5] = true;
                }
                else if (IsXmlnsAttribute(Reader.Name)) {
                    if (o.@Namespaces == null) o.@Namespaces = new System.Xml.Serialization.XmlSerializerNamespaces();
                    o.@Namespaces.Add(Reader.Name.Length == 5 ? "" : Reader.LocalName, Reader.Value);
                }
                else {
                    System.Xml.XmlAttribute attr = (System.Xml.XmlAttribute) Document.ReadNode(Reader);
                    ParseWsdlArrayType(attr);
                    a_3 = (System.Xml.XmlAttribute[])EnsureArrayIndex(a_3, ca_3, typeof(System.Xml.XmlAttribute));a_3[ca_3++] = attr;
                }
            }
            o.@UnhandledAttributes = (System.Xml.XmlAttribute[])ShrinkArray(a_3, ca_3, typeof(System.Xml.XmlAttribute), true);
            Reader.MoveToElement();
            if (Reader.IsEmptyElement) {
                Reader.Skip();
                o.@UnhandledAttributes = (System.Xml.XmlAttribute[])ShrinkArray(a_3, ca_3, typeof(System.Xml.XmlAttribute), true);
                return o;
            }
            Reader.ReadStartElement();
            Reader.MoveToContent();
            while (Reader.NodeType != System.Xml.XmlNodeType.EndElement) {
                if (Reader.NodeType == System.Xml.XmlNodeType.Element) {
                    if (!paramsRead[2] && ((object) Reader.LocalName == (object)id138_annotation && (object) Reader.NamespaceURI == (object)id56_httpwwww3org2001XMLSchema)) {
                        o.@Annotation = Read15_XmlSchemaAnnotation(false, true);
                        paramsRead[2] = true;
                    }
                    else if (!paramsRead[6] && ((object) Reader.LocalName == (object)id141_list && (object) Reader.NamespaceURI == (object)id56_httpwwww3org2001XMLSchema)) {
                        o.@Content = Read18_XmlSchemaSimpleTypeList(false, true);
                        paramsRead[6] = true;
                    }
                    else if (!paramsRead[6] && ((object) Reader.LocalName == (object)id142_restriction && (object) Reader.NamespaceURI == (object)id56_httpwwww3org2001XMLSchema)) {
                        o.@Content = Read20_XmlSchemaSimpleTypeRestriction(false, true);
                        paramsRead[6] = true;
                    }
                    else if (!paramsRead[6] && ((object) Reader.LocalName == (object)id143_union && (object) Reader.NamespaceURI == (object)id56_httpwwww3org2001XMLSchema)) {
                        o.@Content = Read35_XmlSchemaSimpleTypeUnion(false, true);
                        paramsRead[6] = true;
                    }
                    else {
                        UnknownNode((object)o);
                    }
                }
                else {
                    UnknownNode((object)o);
                }
                Reader.MoveToContent();
            }
            o.@UnhandledAttributes = (System.Xml.XmlAttribute[])ShrinkArray(a_3, ca_3, typeof(System.Xml.XmlAttribute), true);
            ReadEndElement();
            return o;
        }

        System.Xml.Schema.XmlSchemaType Read13_XmlSchemaType(bool isNullable, bool checkType) {
            if (isNullable && ReadNull()) return null;
            if (checkType) {
                System.Xml.XmlQualifiedName t = GetXsiType();
                if (t == null || ((object) ((System.Xml.XmlQualifiedName)t).Name == (object)id106_XmlSchemaType && (object) ((System.Xml.XmlQualifiedName)t).Namespace == (object)id56_httpwwww3org2001XMLSchema))
                    ;
                else if (((object) ((System.Xml.XmlQualifiedName)t).Name == (object)id107_XmlSchemaComplexType && (object) ((System.Xml.XmlQualifiedName)t).Namespace == (object)id56_httpwwww3org2001XMLSchema))
                    return Read42_XmlSchemaComplexType(isNullable, false);
                else if (((object) ((System.Xml.XmlQualifiedName)t).Name == (object)id108_XmlSchemaSimpleType && (object) ((System.Xml.XmlQualifiedName)t).Namespace == (object)id56_httpwwww3org2001XMLSchema))
                    return Read12_XmlSchemaSimpleType(isNullable, false);
                else
                    throw CreateUnknownTypeException((System.Xml.XmlQualifiedName)t);
            }
            System.Xml.Schema.XmlSchemaType o = new System.Xml.Schema.XmlSchemaType();
            System.Xml.XmlAttribute[] a_3 = null;
            int ca_3 = 0;
            bool[] paramsRead = new bool[6];
            while (Reader.MoveToNextAttribute()) {
                if (!paramsRead[1] && ((object) Reader.LocalName == (object)id128_id && (object) Reader.NamespaceURI == (object)id4_Item)) {
                    o.@Id = Reader.Value;
                    paramsRead[1] = true;
                }
                else if (!paramsRead[4] && ((object) Reader.LocalName == (object)id5_name && (object) Reader.NamespaceURI == (object)id4_Item)) {
                    o.@Name = Reader.Value;
                    paramsRead[4] = true;
                }
                else if (!paramsRead[5] && ((object) Reader.LocalName == (object)id140_final && (object) Reader.NamespaceURI == (object)id4_Item)) {
                    o.@Final = Read9_XmlSchemaDerivationMethod(Reader.Value);
                    paramsRead[5] = true;
                }
                else if (IsXmlnsAttribute(Reader.Name)) {
                    if (o.@Namespaces == null) o.@Namespaces = new System.Xml.Serialization.XmlSerializerNamespaces();
                    o.@Namespaces.Add(Reader.Name.Length == 5 ? "" : Reader.LocalName, Reader.Value);
                }
                else {
                    System.Xml.XmlAttribute attr = (System.Xml.XmlAttribute) Document.ReadNode(Reader);
                    ParseWsdlArrayType(attr);
                    a_3 = (System.Xml.XmlAttribute[])EnsureArrayIndex(a_3, ca_3, typeof(System.Xml.XmlAttribute));a_3[ca_3++] = attr;
                }
            }
            o.@UnhandledAttributes = (System.Xml.XmlAttribute[])ShrinkArray(a_3, ca_3, typeof(System.Xml.XmlAttribute), true);
            Reader.MoveToElement();
            if (Reader.IsEmptyElement) {
                Reader.Skip();
                o.@UnhandledAttributes = (System.Xml.XmlAttribute[])ShrinkArray(a_3, ca_3, typeof(System.Xml.XmlAttribute), true);
                return o;
            }
            Reader.ReadStartElement();
            Reader.MoveToContent();
            while (Reader.NodeType != System.Xml.XmlNodeType.EndElement) {
                if (Reader.NodeType == System.Xml.XmlNodeType.Element) {
                    if (!paramsRead[2] && ((object) Reader.LocalName == (object)id138_annotation && (object) Reader.NamespaceURI == (object)id56_httpwwww3org2001XMLSchema)) {
                        o.@Annotation = Read15_XmlSchemaAnnotation(false, true);
                        paramsRead[2] = true;
                    }
                    else {
                        UnknownNode((object)o);
                    }
                }
                else {
                    UnknownNode((object)o);
                }
                Reader.MoveToContent();
            }
            o.@UnhandledAttributes = (System.Xml.XmlAttribute[])ShrinkArray(a_3, ca_3, typeof(System.Xml.XmlAttribute), true);
            ReadEndElement();
            return o;
        }

        System.Xml.Schema.XmlSchemaAnnotated Read14_XmlSchemaAnnotated(bool isNullable, bool checkType) {
            if (isNullable && ReadNull()) return null;
            if (checkType) {
                System.Xml.XmlQualifiedName t = GetXsiType();
                if (t == null || ((object) ((System.Xml.XmlQualifiedName)t).Name == (object)id60_XmlSchemaAnnotated && (object) ((System.Xml.XmlQualifiedName)t).Namespace == (object)id56_httpwwww3org2001XMLSchema))
                    ;
                else if (((object) ((System.Xml.XmlQualifiedName)t).Name == (object)id61_XmlSchemaNotation && (object) ((System.Xml.XmlQualifiedName)t).Namespace == (object)id56_httpwwww3org2001XMLSchema))
                    return Read67_XmlSchemaNotation(isNullable, false);
                else if (((object) ((System.Xml.XmlQualifiedName)t).Name == (object)id62_XmlSchemaGroup && (object) ((System.Xml.XmlQualifiedName)t).Namespace == (object)id56_httpwwww3org2001XMLSchema))
                    return Read64_XmlSchemaGroup(isNullable, false);
                else if (((object) ((System.Xml.XmlQualifiedName)t).Name == (object)id63_XmlSchemaXPath && (object) ((System.Xml.XmlQualifiedName)t).Namespace == (object)id56_httpwwww3org2001XMLSchema))
                    return Read54_XmlSchemaXPath(isNullable, false);
                else if (((object) ((System.Xml.XmlQualifiedName)t).Name == (object)id64_XmlSchemaIdentityConstraint && (object) ((System.Xml.XmlQualifiedName)t).Namespace == (object)id56_httpwwww3org2001XMLSchema))
                    return Read53_XmlSchemaIdentityConstraint(isNullable, false);
                else if (((object) ((System.Xml.XmlQualifiedName)t).Name == (object)id65_XmlSchemaKey && (object) ((System.Xml.XmlQualifiedName)t).Namespace == (object)id56_httpwwww3org2001XMLSchema))
                    return Read56_XmlSchemaKey(isNullable, false);
                else if (((object) ((System.Xml.XmlQualifiedName)t).Name == (object)id66_XmlSchemaUnique && (object) ((System.Xml.XmlQualifiedName)t).Namespace == (object)id56_httpwwww3org2001XMLSchema))
                    return Read55_XmlSchemaUnique(isNullable, false);
                else if (((object) ((System.Xml.XmlQualifiedName)t).Name == (object)id67_XmlSchemaKeyref && (object) ((System.Xml.XmlQualifiedName)t).Namespace == (object)id56_httpwwww3org2001XMLSchema))
                    return Read52_XmlSchemaKeyref(isNullable, false);
                else if (((object) ((System.Xml.XmlQualifiedName)t).Name == (object)id68_XmlSchemaParticle && (object) ((System.Xml.XmlQualifiedName)t).Namespace == (object)id56_httpwwww3org2001XMLSchema))
                    return Read49_XmlSchemaParticle(isNullable, false);
                else if (((object) ((System.Xml.XmlQualifiedName)t).Name == (object)id69_XmlSchemaGroupRef && (object) ((System.Xml.XmlQualifiedName)t).Namespace == (object)id56_httpwwww3org2001XMLSchema))
                    return Read57_XmlSchemaGroupRef(isNullable, false);
                else if (((object) ((System.Xml.XmlQualifiedName)t).Name == (object)id70_XmlSchemaElement && (object) ((System.Xml.XmlQualifiedName)t).Namespace == (object)id56_httpwwww3org2001XMLSchema))
                    return Read51_XmlSchemaElement(isNullable, false);
                else if (((object) ((System.Xml.XmlQualifiedName)t).Name == (object)id71_XmlSchemaAny && (object) ((System.Xml.XmlQualifiedName)t).Namespace == (object)id56_httpwwww3org2001XMLSchema))
                    return Read50_XmlSchemaAny(isNullable, false);
                else if (((object) ((System.Xml.XmlQualifiedName)t).Name == (object)id72_XmlSchemaGroupBase && (object) ((System.Xml.XmlQualifiedName)t).Namespace == (object)id56_httpwwww3org2001XMLSchema))
                    return Read48_XmlSchemaGroupBase(isNullable, false);
                else if (((object) ((System.Xml.XmlQualifiedName)t).Name == (object)id73_XmlSchemaAll && (object) ((System.Xml.XmlQualifiedName)t).Namespace == (object)id56_httpwwww3org2001XMLSchema))
                    return Read59_XmlSchemaAll(isNullable, false);
                else if (((object) ((System.Xml.XmlQualifiedName)t).Name == (object)id74_XmlSchemaChoice && (object) ((System.Xml.XmlQualifiedName)t).Namespace == (object)id56_httpwwww3org2001XMLSchema))
                    return Read58_XmlSchemaChoice(isNullable, false);
                else if (((object) ((System.Xml.XmlQualifiedName)t).Name == (object)id75_XmlSchemaSequence && (object) ((System.Xml.XmlQualifiedName)t).Namespace == (object)id56_httpwwww3org2001XMLSchema))
                    return Read47_XmlSchemaSequence(isNullable, false);
                else if (((object) ((System.Xml.XmlQualifiedName)t).Name == (object)id76_XmlSchemaContent && (object) ((System.Xml.XmlQualifiedName)t).Namespace == (object)id56_httpwwww3org2001XMLSchema))
                    return Read46_XmlSchemaContent(isNullable, false);
                else if (((object) ((System.Xml.XmlQualifiedName)t).Name == (object)id77_XmlSchemaSimpleContentExtension && (object) ((System.Xml.XmlQualifiedName)t).Namespace == (object)id56_httpwwww3org2001XMLSchema))
                    return Read63_XmlSchemaSimpleContentExtension(isNullable, false);
                else if (((object) ((System.Xml.XmlQualifiedName)t).Name == (object)id78_XmlSchemaSimpleContentRestriction && (object) ((System.Xml.XmlQualifiedName)t).Namespace == (object)id56_httpwwww3org2001XMLSchema))
                    return Read62_XmlSchemaSimpleContentRestriction(isNullable, false);
                else if (((object) ((System.Xml.XmlQualifiedName)t).Name == (object)id79_XmlSchemaComplexContentRestriction && (object) ((System.Xml.XmlQualifiedName)t).Namespace == (object)id56_httpwwww3org2001XMLSchema))
                    return Read60_XmlSchemaComplexContentRestriction(isNullable, false);
                else if (((object) ((System.Xml.XmlQualifiedName)t).Name == (object)id80_XmlSchemaComplexContentExtension && (object) ((System.Xml.XmlQualifiedName)t).Namespace == (object)id56_httpwwww3org2001XMLSchema))
                    return Read45_XmlSchemaComplexContentExtension(isNullable, false);
                else if (((object) ((System.Xml.XmlQualifiedName)t).Name == (object)id81_XmlSchemaContentModel && (object) ((System.Xml.XmlQualifiedName)t).Namespace == (object)id56_httpwwww3org2001XMLSchema))
                    return Read44_XmlSchemaContentModel(isNullable, false);
                else if (((object) ((System.Xml.XmlQualifiedName)t).Name == (object)id82_XmlSchemaSimpleContent && (object) ((System.Xml.XmlQualifiedName)t).Namespace == (object)id56_httpwwww3org2001XMLSchema))
                    return Read61_XmlSchemaSimpleContent(isNullable, false);
                else if (((object) ((System.Xml.XmlQualifiedName)t).Name == (object)id83_XmlSchemaComplexContent && (object) ((System.Xml.XmlQualifiedName)t).Namespace == (object)id56_httpwwww3org2001XMLSchema))
                    return Read43_XmlSchemaComplexContent(isNullable, false);
                else if (((object) ((System.Xml.XmlQualifiedName)t).Name == (object)id84_XmlSchemaAnyAttribute && (object) ((System.Xml.XmlQualifiedName)t).Namespace == (object)id56_httpwwww3org2001XMLSchema))
                    return Read40_XmlSchemaAnyAttribute(isNullable, false);
                else if (((object) ((System.Xml.XmlQualifiedName)t).Name == (object)id85_XmlSchemaAttributeGroupRef && (object) ((System.Xml.XmlQualifiedName)t).Namespace == (object)id56_httpwwww3org2001XMLSchema))
                    return Read39_XmlSchemaAttributeGroupRef(isNullable, false);
                else if (((object) ((System.Xml.XmlQualifiedName)t).Name == (object)id86_XmlSchemaAttribute && (object) ((System.Xml.XmlQualifiedName)t).Namespace == (object)id56_httpwwww3org2001XMLSchema))
                    return Read37_XmlSchemaAttribute(isNullable, false);
                else if (((object) ((System.Xml.XmlQualifiedName)t).Name == (object)id87_XmlSchemaAttributeGroup && (object) ((System.Xml.XmlQualifiedName)t).Namespace == (object)id56_httpwwww3org2001XMLSchema))
                    return Read36_XmlSchemaAttributeGroup(isNullable, false);
                else if (((object) ((System.Xml.XmlQualifiedName)t).Name == (object)id88_XmlSchemaFacet && (object) ((System.Xml.XmlQualifiedName)t).Namespace == (object)id56_httpwwww3org2001XMLSchema))
                    return Read23_XmlSchemaFacet(isNullable, false);
                else if (((object) ((System.Xml.XmlQualifiedName)t).Name == (object)id89_XmlSchemaMinExclusiveFacet && (object) ((System.Xml.XmlQualifiedName)t).Namespace == (object)id56_httpwwww3org2001XMLSchema))
                    return Read32_XmlSchemaMinExclusiveFacet(isNullable, false);
                else if (((object) ((System.Xml.XmlQualifiedName)t).Name == (object)id90_XmlSchemaMinInclusiveFacet && (object) ((System.Xml.XmlQualifiedName)t).Namespace == (object)id56_httpwwww3org2001XMLSchema))
                    return Read31_XmlSchemaMinInclusiveFacet(isNullable, false);
                else if (((object) ((System.Xml.XmlQualifiedName)t).Name == (object)id91_XmlSchemaMaxExclusiveFacet && (object) ((System.Xml.XmlQualifiedName)t).Namespace == (object)id56_httpwwww3org2001XMLSchema))
                    return Read30_XmlSchemaMaxExclusiveFacet(isNullable, false);
                else if (((object) ((System.Xml.XmlQualifiedName)t).Name == (object)id92_XmlSchemaMaxInclusiveFacet && (object) ((System.Xml.XmlQualifiedName)t).Namespace == (object)id56_httpwwww3org2001XMLSchema))
                    return Read29_XmlSchemaMaxInclusiveFacet(isNullable, false);
                else if (((object) ((System.Xml.XmlQualifiedName)t).Name == (object)id93_XmlSchemaEnumerationFacet && (object) ((System.Xml.XmlQualifiedName)t).Namespace == (object)id56_httpwwww3org2001XMLSchema))
                    return Read28_XmlSchemaEnumerationFacet(isNullable, false);
                else if (((object) ((System.Xml.XmlQualifiedName)t).Name == (object)id94_XmlSchemaPatternFacet && (object) ((System.Xml.XmlQualifiedName)t).Namespace == (object)id56_httpwwww3org2001XMLSchema))
                    return Read27_XmlSchemaPatternFacet(isNullable, false);
                else if (((object) ((System.Xml.XmlQualifiedName)t).Name == (object)id95_XmlSchemaWhiteSpaceFacet && (object) ((System.Xml.XmlQualifiedName)t).Namespace == (object)id56_httpwwww3org2001XMLSchema))
                    return Read25_XmlSchemaWhiteSpaceFacet(isNullable, false);
                else if (((object) ((System.Xml.XmlQualifiedName)t).Name == (object)id96_XmlSchemaNumericFacet && (object) ((System.Xml.XmlQualifiedName)t).Namespace == (object)id56_httpwwww3org2001XMLSchema))
                    return Read22_XmlSchemaNumericFacet(isNullable, false);
                else if (((object) ((System.Xml.XmlQualifiedName)t).Name == (object)id97_XmlSchemaFractionDigitsFacet && (object) ((System.Xml.XmlQualifiedName)t).Namespace == (object)id56_httpwwww3org2001XMLSchema))
                    return Read34_XmlSchemaFractionDigitsFacet(isNullable, false);
                else if (((object) ((System.Xml.XmlQualifiedName)t).Name == (object)id98_XmlSchemaTotalDigitsFacet && (object) ((System.Xml.XmlQualifiedName)t).Namespace == (object)id56_httpwwww3org2001XMLSchema))
                    return Read33_XmlSchemaTotalDigitsFacet(isNullable, false);
                else if (((object) ((System.Xml.XmlQualifiedName)t).Name == (object)id99_XmlSchemaMaxLengthFacet && (object) ((System.Xml.XmlQualifiedName)t).Namespace == (object)id56_httpwwww3org2001XMLSchema))
                    return Read26_XmlSchemaMaxLengthFacet(isNullable, false);
                else if (((object) ((System.Xml.XmlQualifiedName)t).Name == (object)id100_XmlSchemaLengthFacet && (object) ((System.Xml.XmlQualifiedName)t).Namespace == (object)id56_httpwwww3org2001XMLSchema))
                    return Read24_XmlSchemaLengthFacet(isNullable, false);
                else if (((object) ((System.Xml.XmlQualifiedName)t).Name == (object)id101_XmlSchemaMinLengthFacet && (object) ((System.Xml.XmlQualifiedName)t).Namespace == (object)id56_httpwwww3org2001XMLSchema))
                    return Read21_XmlSchemaMinLengthFacet(isNullable, false);
                else if (((object) ((System.Xml.XmlQualifiedName)t).Name == (object)id102_XmlSchemaSimpleTypeContent && (object) ((System.Xml.XmlQualifiedName)t).Namespace == (object)id56_httpwwww3org2001XMLSchema))
                    return Read19_XmlSchemaSimpleTypeContent(isNullable, false);
                else if (((object) ((System.Xml.XmlQualifiedName)t).Name == (object)id103_XmlSchemaSimpleTypeUnion && (object) ((System.Xml.XmlQualifiedName)t).Namespace == (object)id56_httpwwww3org2001XMLSchema))
                    return Read35_XmlSchemaSimpleTypeUnion(isNullable, false);
                else if (((object) ((System.Xml.XmlQualifiedName)t).Name == (object)id104_XmlSchemaSimpleTypeRestriction && (object) ((System.Xml.XmlQualifiedName)t).Namespace == (object)id56_httpwwww3org2001XMLSchema))
                    return Read20_XmlSchemaSimpleTypeRestriction(isNullable, false);
                else if (((object) ((System.Xml.XmlQualifiedName)t).Name == (object)id105_XmlSchemaSimpleTypeList && (object) ((System.Xml.XmlQualifiedName)t).Namespace == (object)id56_httpwwww3org2001XMLSchema))
                    return Read18_XmlSchemaSimpleTypeList(isNullable, false);
                else if (((object) ((System.Xml.XmlQualifiedName)t).Name == (object)id106_XmlSchemaType && (object) ((System.Xml.XmlQualifiedName)t).Namespace == (object)id56_httpwwww3org2001XMLSchema))
                    return Read13_XmlSchemaType(isNullable, false);
                else if (((object) ((System.Xml.XmlQualifiedName)t).Name == (object)id107_XmlSchemaComplexType && (object) ((System.Xml.XmlQualifiedName)t).Namespace == (object)id56_httpwwww3org2001XMLSchema))
                    return Read42_XmlSchemaComplexType(isNullable, false);
                else if (((object) ((System.Xml.XmlQualifiedName)t).Name == (object)id108_XmlSchemaSimpleType && (object) ((System.Xml.XmlQualifiedName)t).Namespace == (object)id56_httpwwww3org2001XMLSchema))
                    return Read12_XmlSchemaSimpleType(isNullable, false);
                else
                    throw CreateUnknownTypeException((System.Xml.XmlQualifiedName)t);
            }
            System.Xml.Schema.XmlSchemaAnnotated o = new System.Xml.Schema.XmlSchemaAnnotated();
            System.Xml.XmlAttribute[] a_3 = null;
            int ca_3 = 0;
            bool[] paramsRead = new bool[4];
            while (Reader.MoveToNextAttribute()) {
                if (!paramsRead[1] && ((object) Reader.LocalName == (object)id128_id && (object) Reader.NamespaceURI == (object)id4_Item)) {
                    o.@Id = Reader.Value;
                    paramsRead[1] = true;
                }
                else if (IsXmlnsAttribute(Reader.Name)) {
                    if (o.@Namespaces == null) o.@Namespaces = new System.Xml.Serialization.XmlSerializerNamespaces();
                    o.@Namespaces.Add(Reader.Name.Length == 5 ? "" : Reader.LocalName, Reader.Value);
                }
                else {
                    System.Xml.XmlAttribute attr = (System.Xml.XmlAttribute) Document.ReadNode(Reader);
                    ParseWsdlArrayType(attr);
                    a_3 = (System.Xml.XmlAttribute[])EnsureArrayIndex(a_3, ca_3, typeof(System.Xml.XmlAttribute));a_3[ca_3++] = attr;
                }
            }
            o.@UnhandledAttributes = (System.Xml.XmlAttribute[])ShrinkArray(a_3, ca_3, typeof(System.Xml.XmlAttribute), true);
            Reader.MoveToElement();
            if (Reader.IsEmptyElement) {
                Reader.Skip();
                o.@UnhandledAttributes = (System.Xml.XmlAttribute[])ShrinkArray(a_3, ca_3, typeof(System.Xml.XmlAttribute), true);
                return o;
            }
            Reader.ReadStartElement();
            Reader.MoveToContent();
            while (Reader.NodeType != System.Xml.XmlNodeType.EndElement) {
                if (Reader.NodeType == System.Xml.XmlNodeType.Element) {
                    if (!paramsRead[2] && ((object) Reader.LocalName == (object)id138_annotation && (object) Reader.NamespaceURI == (object)id56_httpwwww3org2001XMLSchema)) {
                        o.@Annotation = Read15_XmlSchemaAnnotation(false, true);
                        paramsRead[2] = true;
                    }
                    else {
                        UnknownNode((object)o);
                    }
                }
                else {
                    UnknownNode((object)o);
                }
                Reader.MoveToContent();
            }
            o.@UnhandledAttributes = (System.Xml.XmlAttribute[])ShrinkArray(a_3, ca_3, typeof(System.Xml.XmlAttribute), true);
            ReadEndElement();
            return o;
        }

        System.Xml.Schema.XmlSchemaAnnotation Read15_XmlSchemaAnnotation(bool isNullable, bool checkType) {
            if (isNullable && ReadNull()) return null;
            if (checkType) {
                System.Xml.XmlQualifiedName t = GetXsiType();
                if (t == null || ((object) ((System.Xml.XmlQualifiedName)t).Name == (object)id59_XmlSchemaAnnotation && (object) ((System.Xml.XmlQualifiedName)t).Namespace == (object)id56_httpwwww3org2001XMLSchema))
                    ;
                else
                    throw CreateUnknownTypeException((System.Xml.XmlQualifiedName)t);
            }
            System.Xml.Schema.XmlSchemaAnnotation o = new System.Xml.Schema.XmlSchemaAnnotation();
            System.Xml.Schema.XmlSchemaObjectCollection a_2 = (System.Xml.Schema.XmlSchemaObjectCollection)o.@Items;
            System.Xml.XmlAttribute[] a_3 = null;
            int ca_3 = 0;
            bool[] paramsRead = new bool[4];
            while (Reader.MoveToNextAttribute()) {
                if (!paramsRead[1] && ((object) Reader.LocalName == (object)id128_id && (object) Reader.NamespaceURI == (object)id4_Item)) {
                    o.@Id = Reader.Value;
                    paramsRead[1] = true;
                }
                else if (IsXmlnsAttribute(Reader.Name)) {
                    if (o.@Namespaces == null) o.@Namespaces = new System.Xml.Serialization.XmlSerializerNamespaces();
                    o.@Namespaces.Add(Reader.Name.Length == 5 ? "" : Reader.LocalName, Reader.Value);
                }
                else {
                    System.Xml.XmlAttribute attr = (System.Xml.XmlAttribute) Document.ReadNode(Reader);
                    ParseWsdlArrayType(attr);
                    a_3 = (System.Xml.XmlAttribute[])EnsureArrayIndex(a_3, ca_3, typeof(System.Xml.XmlAttribute));a_3[ca_3++] = attr;
                }
            }
            o.@UnhandledAttributes = (System.Xml.XmlAttribute[])ShrinkArray(a_3, ca_3, typeof(System.Xml.XmlAttribute), true);
            Reader.MoveToElement();
            if (Reader.IsEmptyElement) {
                Reader.Skip();
                o.@UnhandledAttributes = (System.Xml.XmlAttribute[])ShrinkArray(a_3, ca_3, typeof(System.Xml.XmlAttribute), true);
                return o;
            }
            Reader.ReadStartElement();
            Reader.MoveToContent();
            while (Reader.NodeType != System.Xml.XmlNodeType.EndElement) {
                if (Reader.NodeType == System.Xml.XmlNodeType.Element) {
                    if (((object) Reader.LocalName == (object)id144_appinfo && (object) Reader.NamespaceURI == (object)id56_httpwwww3org2001XMLSchema)) {
                        if ((object)(a_2) == null) Reader.Skip(); else a_2.Add(Read16_XmlSchemaAppInfo(false, true));
                    }
                    else if (((object) Reader.LocalName == (object)id6_documentation && (object) Reader.NamespaceURI == (object)id56_httpwwww3org2001XMLSchema)) {
                        if ((object)(a_2) == null) Reader.Skip(); else a_2.Add(Read17_XmlSchemaDocumentation(false, true));
                    }
                    else {
                        UnknownNode((object)o);
                    }
                }
                else {
                    UnknownNode((object)o);
                }
                Reader.MoveToContent();
            }
            o.@UnhandledAttributes = (System.Xml.XmlAttribute[])ShrinkArray(a_3, ca_3, typeof(System.Xml.XmlAttribute), true);
            ReadEndElement();
            return o;
        }

        System.Xml.Schema.XmlSchemaAppInfo Read16_XmlSchemaAppInfo(bool isNullable, bool checkType) {
            if (isNullable && ReadNull()) return null;
            if (checkType) {
                System.Xml.XmlQualifiedName t = GetXsiType();
                if (t == null || ((object) ((System.Xml.XmlQualifiedName)t).Name == (object)id58_XmlSchemaAppInfo && (object) ((System.Xml.XmlQualifiedName)t).Namespace == (object)id56_httpwwww3org2001XMLSchema))
                    ;
                else
                    throw CreateUnknownTypeException((System.Xml.XmlQualifiedName)t);
            }
            System.Xml.Schema.XmlSchemaAppInfo o = new System.Xml.Schema.XmlSchemaAppInfo();
            System.Xml.XmlNode[] a_2 = null;
            int ca_2 = 0;
            bool[] paramsRead = new bool[3];
            while (Reader.MoveToNextAttribute()) {
                if (!paramsRead[1] && ((object) Reader.LocalName == (object)id145_source && (object) Reader.NamespaceURI == (object)id4_Item)) {
                    o.@Source = Reader.Value;
                    paramsRead[1] = true;
                }
                else if (IsXmlnsAttribute(Reader.Name)) {
                    if (o.@Namespaces == null) o.@Namespaces = new System.Xml.Serialization.XmlSerializerNamespaces();
                    o.@Namespaces.Add(Reader.Name.Length == 5 ? "" : Reader.LocalName, Reader.Value);
                }
                else {
                    UnknownNode((object)o);
                }
            }
            Reader.MoveToElement();
            if (Reader.IsEmptyElement) {
                Reader.Skip();
                o.@Markup = (System.Xml.XmlNode[])ShrinkArray(a_2, ca_2, typeof(System.Xml.XmlNode), true);
                o.@Markup = (System.Xml.XmlNode[])ShrinkArray(a_2, ca_2, typeof(System.Xml.XmlNode), true);
                o.@Markup = (System.Xml.XmlNode[])ShrinkArray(a_2, ca_2, typeof(System.Xml.XmlNode), true);
                return o;
            }
            Reader.ReadStartElement();
            Reader.MoveToContent();
            while (Reader.NodeType != System.Xml.XmlNodeType.EndElement) {
                string t = null;
                if (Reader.NodeType == System.Xml.XmlNodeType.Element) {
                    a_2 = (System.Xml.XmlNode[])EnsureArrayIndex(a_2, ca_2, typeof(System.Xml.XmlNode));a_2[ca_2++] = (System.Xml.XmlNode)ReadXmlNode(false);
                }
                else if (Reader.NodeType == System.Xml.XmlNodeType.Text || 
                Reader.NodeType == System.Xml.XmlNodeType.CDATA || 
                Reader.NodeType == System.Xml.XmlNodeType.Whitespace || 
                Reader.NodeType == System.Xml.XmlNodeType.SignificantWhitespace) {
                    a_2 = (System.Xml.XmlNode[])EnsureArrayIndex(a_2, ca_2, typeof(System.Xml.XmlNode));a_2[ca_2++] = (System.Xml.XmlNode)Document.CreateTextNode(Reader.ReadString());
                }
                else {
                    UnknownNode((object)o);
                }
                Reader.MoveToContent();
            }
            o.@Markup = (System.Xml.XmlNode[])ShrinkArray(a_2, ca_2, typeof(System.Xml.XmlNode), true);
            o.@Markup = (System.Xml.XmlNode[])ShrinkArray(a_2, ca_2, typeof(System.Xml.XmlNode), true);
            o.@Markup = (System.Xml.XmlNode[])ShrinkArray(a_2, ca_2, typeof(System.Xml.XmlNode), true);
            ReadEndElement();
            return o;
        }

        System.Xml.Schema.XmlSchemaDocumentation Read17_XmlSchemaDocumentation(bool isNullable, bool checkType) {
            if (isNullable && ReadNull()) return null;
            if (checkType) {
                System.Xml.XmlQualifiedName t = GetXsiType();
                if (t == null || ((object) ((System.Xml.XmlQualifiedName)t).Name == (object)id57_XmlSchemaDocumentation && (object) ((System.Xml.XmlQualifiedName)t).Namespace == (object)id56_httpwwww3org2001XMLSchema))
                    ;
                else
                    throw CreateUnknownTypeException((System.Xml.XmlQualifiedName)t);
            }
            System.Xml.Schema.XmlSchemaDocumentation o = new System.Xml.Schema.XmlSchemaDocumentation();
            System.Xml.XmlNode[] a_3 = null;
            int ca_3 = 0;
            bool[] paramsRead = new bool[4];
            while (Reader.MoveToNextAttribute()) {
                if (!paramsRead[1] && ((object) Reader.LocalName == (object)id145_source && (object) Reader.NamespaceURI == (object)id4_Item)) {
                    o.@Source = Reader.Value;
                    paramsRead[1] = true;
                }
                else if (!paramsRead[2] && ((object) Reader.LocalName == (object)id146_lang && (object) Reader.NamespaceURI == (object)id147_httpwwww3orgXML1998namespace)) {
                    o.@Language = Reader.Value;
                    paramsRead[2] = true;
                }
                else if (IsXmlnsAttribute(Reader.Name)) {
                    if (o.@Namespaces == null) o.@Namespaces = new System.Xml.Serialization.XmlSerializerNamespaces();
                    o.@Namespaces.Add(Reader.Name.Length == 5 ? "" : Reader.LocalName, Reader.Value);
                }
                else {
                    UnknownNode((object)o);
                }
            }
            Reader.MoveToElement();
            if (Reader.IsEmptyElement) {
                Reader.Skip();
                o.@Markup = (System.Xml.XmlNode[])ShrinkArray(a_3, ca_3, typeof(System.Xml.XmlNode), true);
                o.@Markup = (System.Xml.XmlNode[])ShrinkArray(a_3, ca_3, typeof(System.Xml.XmlNode), true);
                o.@Markup = (System.Xml.XmlNode[])ShrinkArray(a_3, ca_3, typeof(System.Xml.XmlNode), true);
                return o;
            }
            Reader.ReadStartElement();
            Reader.MoveToContent();
            while (Reader.NodeType != System.Xml.XmlNodeType.EndElement) {
                string t = null;
                if (Reader.NodeType == System.Xml.XmlNodeType.Element) {
                    a_3 = (System.Xml.XmlNode[])EnsureArrayIndex(a_3, ca_3, typeof(System.Xml.XmlNode));a_3[ca_3++] = (System.Xml.XmlNode)ReadXmlNode(false);
                }
                else if (Reader.NodeType == System.Xml.XmlNodeType.Text || 
                Reader.NodeType == System.Xml.XmlNodeType.CDATA || 
                Reader.NodeType == System.Xml.XmlNodeType.Whitespace || 
                Reader.NodeType == System.Xml.XmlNodeType.SignificantWhitespace) {
                    a_3 = (System.Xml.XmlNode[])EnsureArrayIndex(a_3, ca_3, typeof(System.Xml.XmlNode));a_3[ca_3++] = (System.Xml.XmlNode)Document.CreateTextNode(Reader.ReadString());
                }
                else {
                    UnknownNode((object)o);
                }
                Reader.MoveToContent();
            }
            o.@Markup = (System.Xml.XmlNode[])ShrinkArray(a_3, ca_3, typeof(System.Xml.XmlNode), true);
            o.@Markup = (System.Xml.XmlNode[])ShrinkArray(a_3, ca_3, typeof(System.Xml.XmlNode), true);
            o.@Markup = (System.Xml.XmlNode[])ShrinkArray(a_3, ca_3, typeof(System.Xml.XmlNode), true);
            ReadEndElement();
            return o;
        }

        System.Xml.Schema.XmlSchemaSimpleTypeList Read18_XmlSchemaSimpleTypeList(bool isNullable, bool checkType) {
            if (isNullable && ReadNull()) return null;
            if (checkType) {
                System.Xml.XmlQualifiedName t = GetXsiType();
                if (t == null || ((object) ((System.Xml.XmlQualifiedName)t).Name == (object)id105_XmlSchemaSimpleTypeList && (object) ((System.Xml.XmlQualifiedName)t).Namespace == (object)id56_httpwwww3org2001XMLSchema))
                    ;
                else
                    throw CreateUnknownTypeException((System.Xml.XmlQualifiedName)t);
            }
            System.Xml.Schema.XmlSchemaSimpleTypeList o = new System.Xml.Schema.XmlSchemaSimpleTypeList();
            System.Xml.XmlAttribute[] a_3 = null;
            int ca_3 = 0;
            bool[] paramsRead = new bool[6];
            while (Reader.MoveToNextAttribute()) {
                if (!paramsRead[1] && ((object) Reader.LocalName == (object)id128_id && (object) Reader.NamespaceURI == (object)id4_Item)) {
                    o.@Id = Reader.Value;
                    paramsRead[1] = true;
                }
                else if (!paramsRead[4] && ((object) Reader.LocalName == (object)id148_itemType && (object) Reader.NamespaceURI == (object)id4_Item)) {
                    o.@ItemTypeName = ToXmlQualifiedName(Reader.Value);
                    paramsRead[4] = true;
                }
                else if (IsXmlnsAttribute(Reader.Name)) {
                    if (o.@Namespaces == null) o.@Namespaces = new System.Xml.Serialization.XmlSerializerNamespaces();
                    o.@Namespaces.Add(Reader.Name.Length == 5 ? "" : Reader.LocalName, Reader.Value);
                }
                else {
                    System.Xml.XmlAttribute attr = (System.Xml.XmlAttribute) Document.ReadNode(Reader);
                    ParseWsdlArrayType(attr);
                    a_3 = (System.Xml.XmlAttribute[])EnsureArrayIndex(a_3, ca_3, typeof(System.Xml.XmlAttribute));a_3[ca_3++] = attr;
                }
            }
            o.@UnhandledAttributes = (System.Xml.XmlAttribute[])ShrinkArray(a_3, ca_3, typeof(System.Xml.XmlAttribute), true);
            Reader.MoveToElement();
            if (Reader.IsEmptyElement) {
                Reader.Skip();
                o.@UnhandledAttributes = (System.Xml.XmlAttribute[])ShrinkArray(a_3, ca_3, typeof(System.Xml.XmlAttribute), true);
                return o;
            }
            Reader.ReadStartElement();
            Reader.MoveToContent();
            while (Reader.NodeType != System.Xml.XmlNodeType.EndElement) {
                if (Reader.NodeType == System.Xml.XmlNodeType.Element) {
                    if (!paramsRead[2] && ((object) Reader.LocalName == (object)id138_annotation && (object) Reader.NamespaceURI == (object)id56_httpwwww3org2001XMLSchema)) {
                        o.@Annotation = Read15_XmlSchemaAnnotation(false, true);
                        paramsRead[2] = true;
                    }
                    else if (!paramsRead[5] && ((object) Reader.LocalName == (object)id131_simpleType && (object) Reader.NamespaceURI == (object)id56_httpwwww3org2001XMLSchema)) {
                        o.@ItemType = Read12_XmlSchemaSimpleType(false, true);
                        paramsRead[5] = true;
                    }
                    else {
                        UnknownNode((object)o);
                    }
                }
                else {
                    UnknownNode((object)o);
                }
                Reader.MoveToContent();
            }
            o.@UnhandledAttributes = (System.Xml.XmlAttribute[])ShrinkArray(a_3, ca_3, typeof(System.Xml.XmlAttribute), true);
            ReadEndElement();
            return o;
        }

        System.Xml.Schema.XmlSchemaSimpleTypeContent Read19_XmlSchemaSimpleTypeContent(bool isNullable, bool checkType) {
            if (isNullable && ReadNull()) return null;
            if (checkType) {
                System.Xml.XmlQualifiedName t = GetXsiType();
                if (t == null || ((object) ((System.Xml.XmlQualifiedName)t).Name == (object)id102_XmlSchemaSimpleTypeContent && (object) ((System.Xml.XmlQualifiedName)t).Namespace == (object)id56_httpwwww3org2001XMLSchema))
                    ;
                else if (((object) ((System.Xml.XmlQualifiedName)t).Name == (object)id103_XmlSchemaSimpleTypeUnion && (object) ((System.Xml.XmlQualifiedName)t).Namespace == (object)id56_httpwwww3org2001XMLSchema))
                    return Read35_XmlSchemaSimpleTypeUnion(isNullable, false);
                else if (((object) ((System.Xml.XmlQualifiedName)t).Name == (object)id104_XmlSchemaSimpleTypeRestriction && (object) ((System.Xml.XmlQualifiedName)t).Namespace == (object)id56_httpwwww3org2001XMLSchema))
                    return Read20_XmlSchemaSimpleTypeRestriction(isNullable, false);
                else if (((object) ((System.Xml.XmlQualifiedName)t).Name == (object)id105_XmlSchemaSimpleTypeList && (object) ((System.Xml.XmlQualifiedName)t).Namespace == (object)id56_httpwwww3org2001XMLSchema))
                    return Read18_XmlSchemaSimpleTypeList(isNullable, false);
                else
                    throw CreateUnknownTypeException((System.Xml.XmlQualifiedName)t);
            }
            throw CreateAbstractTypeException(@"XmlSchemaSimpleTypeContent", @"http://www.w3.org/2001/XMLSchema");
        }

        System.Xml.Schema.XmlSchemaSimpleTypeRestriction Read20_XmlSchemaSimpleTypeRestriction(bool isNullable, bool checkType) {
            if (isNullable && ReadNull()) return null;
            if (checkType) {
                System.Xml.XmlQualifiedName t = GetXsiType();
                if (t == null || ((object) ((System.Xml.XmlQualifiedName)t).Name == (object)id104_XmlSchemaSimpleTypeRestriction && (object) ((System.Xml.XmlQualifiedName)t).Namespace == (object)id56_httpwwww3org2001XMLSchema))
                    ;
                else
                    throw CreateUnknownTypeException((System.Xml.XmlQualifiedName)t);
            }
            System.Xml.Schema.XmlSchemaSimpleTypeRestriction o = new System.Xml.Schema.XmlSchemaSimpleTypeRestriction();
            System.Xml.XmlAttribute[] a_3 = null;
            int ca_3 = 0;
            System.Xml.Schema.XmlSchemaObjectCollection a_6 = (System.Xml.Schema.XmlSchemaObjectCollection)o.@Facets;
            bool[] paramsRead = new bool[7];
            while (Reader.MoveToNextAttribute()) {
                if (!paramsRead[1] && ((object) Reader.LocalName == (object)id128_id && (object) Reader.NamespaceURI == (object)id4_Item)) {
                    o.@Id = Reader.Value;
                    paramsRead[1] = true;
                }
                else if (!paramsRead[4] && ((object) Reader.LocalName == (object)id149_base && (object) Reader.NamespaceURI == (object)id4_Item)) {
                    o.@BaseTypeName = ToXmlQualifiedName(Reader.Value);
                    paramsRead[4] = true;
                }
                else if (IsXmlnsAttribute(Reader.Name)) {
                    if (o.@Namespaces == null) o.@Namespaces = new System.Xml.Serialization.XmlSerializerNamespaces();
                    o.@Namespaces.Add(Reader.Name.Length == 5 ? "" : Reader.LocalName, Reader.Value);
                }
                else {
                    System.Xml.XmlAttribute attr = (System.Xml.XmlAttribute) Document.ReadNode(Reader);
                    ParseWsdlArrayType(attr);
                    a_3 = (System.Xml.XmlAttribute[])EnsureArrayIndex(a_3, ca_3, typeof(System.Xml.XmlAttribute));a_3[ca_3++] = attr;
                }
            }
            o.@UnhandledAttributes = (System.Xml.XmlAttribute[])ShrinkArray(a_3, ca_3, typeof(System.Xml.XmlAttribute), true);
            Reader.MoveToElement();
            if (Reader.IsEmptyElement) {
                Reader.Skip();
                o.@UnhandledAttributes = (System.Xml.XmlAttribute[])ShrinkArray(a_3, ca_3, typeof(System.Xml.XmlAttribute), true);
                return o;
            }
            Reader.ReadStartElement();
            Reader.MoveToContent();
            while (Reader.NodeType != System.Xml.XmlNodeType.EndElement) {
                if (Reader.NodeType == System.Xml.XmlNodeType.Element) {
                    if (!paramsRead[2] && ((object) Reader.LocalName == (object)id138_annotation && (object) Reader.NamespaceURI == (object)id56_httpwwww3org2001XMLSchema)) {
                        o.@Annotation = Read15_XmlSchemaAnnotation(false, true);
                        paramsRead[2] = true;
                    }
                    else if (!paramsRead[5] && ((object) Reader.LocalName == (object)id131_simpleType && (object) Reader.NamespaceURI == (object)id56_httpwwww3org2001XMLSchema)) {
                        o.@BaseType = Read12_XmlSchemaSimpleType(false, true);
                        paramsRead[5] = true;
                    }
                    else if (((object) Reader.LocalName == (object)id150_length && (object) Reader.NamespaceURI == (object)id56_httpwwww3org2001XMLSchema)) {
                        if ((object)(a_6) == null) Reader.Skip(); else a_6.Add(Read24_XmlSchemaLengthFacet(false, true));
                    }
                    else if (((object) Reader.LocalName == (object)id151_maxInclusive && (object) Reader.NamespaceURI == (object)id56_httpwwww3org2001XMLSchema)) {
                        if ((object)(a_6) == null) Reader.Skip(); else a_6.Add(Read29_XmlSchemaMaxInclusiveFacet(false, true));
                    }
                    else if (((object) Reader.LocalName == (object)id152_maxExclusive && (object) Reader.NamespaceURI == (object)id56_httpwwww3org2001XMLSchema)) {
                        if ((object)(a_6) == null) Reader.Skip(); else a_6.Add(Read30_XmlSchemaMaxExclusiveFacet(false, true));
                    }
                    else if (((object) Reader.LocalName == (object)id153_fractionDigits && (object) Reader.NamespaceURI == (object)id56_httpwwww3org2001XMLSchema)) {
                        if ((object)(a_6) == null) Reader.Skip(); else a_6.Add(Read34_XmlSchemaFractionDigitsFacet(false, true));
                    }
                    else if (((object) Reader.LocalName == (object)id154_enumeration && (object) Reader.NamespaceURI == (object)id56_httpwwww3org2001XMLSchema)) {
                        if ((object)(a_6) == null) Reader.Skip(); else a_6.Add(Read28_XmlSchemaEnumerationFacet(false, true));
                    }
                    else if (((object) Reader.LocalName == (object)id155_totalDigits && (object) Reader.NamespaceURI == (object)id56_httpwwww3org2001XMLSchema)) {
                        if ((object)(a_6) == null) Reader.Skip(); else a_6.Add(Read33_XmlSchemaTotalDigitsFacet(false, true));
                    }
                    else if (((object) Reader.LocalName == (object)id156_minLength && (object) Reader.NamespaceURI == (object)id56_httpwwww3org2001XMLSchema)) {
                        if ((object)(a_6) == null) Reader.Skip(); else a_6.Add(Read21_XmlSchemaMinLengthFacet(false, true));
                    }
                    else if (((object) Reader.LocalName == (object)id157_minExclusive && (object) Reader.NamespaceURI == (object)id56_httpwwww3org2001XMLSchema)) {
                        if ((object)(a_6) == null) Reader.Skip(); else a_6.Add(Read32_XmlSchemaMinExclusiveFacet(false, true));
                    }
                    else if (((object) Reader.LocalName == (object)id158_minInclusive && (object) Reader.NamespaceURI == (object)id56_httpwwww3org2001XMLSchema)) {
                        if ((object)(a_6) == null) Reader.Skip(); else a_6.Add(Read31_XmlSchemaMinInclusiveFacet(false, true));
                    }
                    else if (((object) Reader.LocalName == (object)id159_maxLength && (object) Reader.NamespaceURI == (object)id56_httpwwww3org2001XMLSchema)) {
                        if ((object)(a_6) == null) Reader.Skip(); else a_6.Add(Read26_XmlSchemaMaxLengthFacet(false, true));
                    }
                    else if (((object) Reader.LocalName == (object)id160_whiteSpace && (object) Reader.NamespaceURI == (object)id56_httpwwww3org2001XMLSchema)) {
                        if ((object)(a_6) == null) Reader.Skip(); else a_6.Add(Read25_XmlSchemaWhiteSpaceFacet(false, true));
                    }
                    else if (((object) Reader.LocalName == (object)id161_pattern && (object) Reader.NamespaceURI == (object)id56_httpwwww3org2001XMLSchema)) {
                        if ((object)(a_6) == null) Reader.Skip(); else a_6.Add(Read27_XmlSchemaPatternFacet(false, true));
                    }
                    else {
                        UnknownNode((object)o);
                    }
                }
                else {
                    UnknownNode((object)o);
                }
                Reader.MoveToContent();
            }
            o.@UnhandledAttributes = (System.Xml.XmlAttribute[])ShrinkArray(a_3, ca_3, typeof(System.Xml.XmlAttribute), true);
            ReadEndElement();
            return o;
        }

        System.Xml.Schema.XmlSchemaMinLengthFacet Read21_XmlSchemaMinLengthFacet(bool isNullable, bool checkType) {
            if (isNullable && ReadNull()) return null;
            if (checkType) {
                System.Xml.XmlQualifiedName t = GetXsiType();
                if (t == null || ((object) ((System.Xml.XmlQualifiedName)t).Name == (object)id101_XmlSchemaMinLengthFacet && (object) ((System.Xml.XmlQualifiedName)t).Namespace == (object)id56_httpwwww3org2001XMLSchema))
                    ;
                else
                    throw CreateUnknownTypeException((System.Xml.XmlQualifiedName)t);
            }
            System.Xml.Schema.XmlSchemaMinLengthFacet o = new System.Xml.Schema.XmlSchemaMinLengthFacet();
            System.Xml.XmlAttribute[] a_3 = null;
            int ca_3 = 0;
            bool[] paramsRead = new bool[6];
            while (Reader.MoveToNextAttribute()) {
                if (!paramsRead[1] && ((object) Reader.LocalName == (object)id128_id && (object) Reader.NamespaceURI == (object)id4_Item)) {
                    o.@Id = Reader.Value;
                    paramsRead[1] = true;
                }
                else if (!paramsRead[4] && ((object) Reader.LocalName == (object)id162_value && (object) Reader.NamespaceURI == (object)id4_Item)) {
                    o.@Value = Reader.Value;
                    paramsRead[4] = true;
                }
                else if (!paramsRead[5] && ((object) Reader.LocalName == (object)id163_fixed && (object) Reader.NamespaceURI == (object)id4_Item)) {
                    o.@IsFixed = System.Xml.XmlConvert.ToBoolean(Reader.Value);
                    paramsRead[5] = true;
                }
                else if (IsXmlnsAttribute(Reader.Name)) {
                    if (o.@Namespaces == null) o.@Namespaces = new System.Xml.Serialization.XmlSerializerNamespaces();
                    o.@Namespaces.Add(Reader.Name.Length == 5 ? "" : Reader.LocalName, Reader.Value);
                }
                else {
                    System.Xml.XmlAttribute attr = (System.Xml.XmlAttribute) Document.ReadNode(Reader);
                    ParseWsdlArrayType(attr);
                    a_3 = (System.Xml.XmlAttribute[])EnsureArrayIndex(a_3, ca_3, typeof(System.Xml.XmlAttribute));a_3[ca_3++] = attr;
                }
            }
            o.@UnhandledAttributes = (System.Xml.XmlAttribute[])ShrinkArray(a_3, ca_3, typeof(System.Xml.XmlAttribute), true);
            Reader.MoveToElement();
            if (Reader.IsEmptyElement) {
                Reader.Skip();
                o.@UnhandledAttributes = (System.Xml.XmlAttribute[])ShrinkArray(a_3, ca_3, typeof(System.Xml.XmlAttribute), true);
                return o;
            }
            Reader.ReadStartElement();
            Reader.MoveToContent();
            while (Reader.NodeType != System.Xml.XmlNodeType.EndElement) {
                if (Reader.NodeType == System.Xml.XmlNodeType.Element) {
                    if (!paramsRead[2] && ((object) Reader.LocalName == (object)id138_annotation && (object) Reader.NamespaceURI == (object)id56_httpwwww3org2001XMLSchema)) {
                        o.@Annotation = Read15_XmlSchemaAnnotation(false, true);
                        paramsRead[2] = true;
                    }
                    else {
                        UnknownNode((object)o);
                    }
                }
                else {
                    UnknownNode((object)o);
                }
                Reader.MoveToContent();
            }
            o.@UnhandledAttributes = (System.Xml.XmlAttribute[])ShrinkArray(a_3, ca_3, typeof(System.Xml.XmlAttribute), true);
            ReadEndElement();
            return o;
        }

        System.Xml.Schema.XmlSchemaNumericFacet Read22_XmlSchemaNumericFacet(bool isNullable, bool checkType) {
            if (isNullable && ReadNull()) return null;
            if (checkType) {
                System.Xml.XmlQualifiedName t = GetXsiType();
                if (t == null || ((object) ((System.Xml.XmlQualifiedName)t).Name == (object)id96_XmlSchemaNumericFacet && (object) ((System.Xml.XmlQualifiedName)t).Namespace == (object)id56_httpwwww3org2001XMLSchema))
                    ;
                else if (((object) ((System.Xml.XmlQualifiedName)t).Name == (object)id97_XmlSchemaFractionDigitsFacet && (object) ((System.Xml.XmlQualifiedName)t).Namespace == (object)id56_httpwwww3org2001XMLSchema))
                    return Read34_XmlSchemaFractionDigitsFacet(isNullable, false);
                else if (((object) ((System.Xml.XmlQualifiedName)t).Name == (object)id98_XmlSchemaTotalDigitsFacet && (object) ((System.Xml.XmlQualifiedName)t).Namespace == (object)id56_httpwwww3org2001XMLSchema))
                    return Read33_XmlSchemaTotalDigitsFacet(isNullable, false);
                else if (((object) ((System.Xml.XmlQualifiedName)t).Name == (object)id99_XmlSchemaMaxLengthFacet && (object) ((System.Xml.XmlQualifiedName)t).Namespace == (object)id56_httpwwww3org2001XMLSchema))
                    return Read26_XmlSchemaMaxLengthFacet(isNullable, false);
                else if (((object) ((System.Xml.XmlQualifiedName)t).Name == (object)id100_XmlSchemaLengthFacet && (object) ((System.Xml.XmlQualifiedName)t).Namespace == (object)id56_httpwwww3org2001XMLSchema))
                    return Read24_XmlSchemaLengthFacet(isNullable, false);
                else if (((object) ((System.Xml.XmlQualifiedName)t).Name == (object)id101_XmlSchemaMinLengthFacet && (object) ((System.Xml.XmlQualifiedName)t).Namespace == (object)id56_httpwwww3org2001XMLSchema))
                    return Read21_XmlSchemaMinLengthFacet(isNullable, false);
                else
                    throw CreateUnknownTypeException((System.Xml.XmlQualifiedName)t);
            }
            throw CreateAbstractTypeException(@"XmlSchemaNumericFacet", @"http://www.w3.org/2001/XMLSchema");
        }

        System.Xml.Schema.XmlSchemaFacet Read23_XmlSchemaFacet(bool isNullable, bool checkType) {
            if (isNullable && ReadNull()) return null;
            if (checkType) {
                System.Xml.XmlQualifiedName t = GetXsiType();
                if (t == null || ((object) ((System.Xml.XmlQualifiedName)t).Name == (object)id88_XmlSchemaFacet && (object) ((System.Xml.XmlQualifiedName)t).Namespace == (object)id56_httpwwww3org2001XMLSchema))
                    ;
                else if (((object) ((System.Xml.XmlQualifiedName)t).Name == (object)id89_XmlSchemaMinExclusiveFacet && (object) ((System.Xml.XmlQualifiedName)t).Namespace == (object)id56_httpwwww3org2001XMLSchema))
                    return Read32_XmlSchemaMinExclusiveFacet(isNullable, false);
                else if (((object) ((System.Xml.XmlQualifiedName)t).Name == (object)id90_XmlSchemaMinInclusiveFacet && (object) ((System.Xml.XmlQualifiedName)t).Namespace == (object)id56_httpwwww3org2001XMLSchema))
                    return Read31_XmlSchemaMinInclusiveFacet(isNullable, false);
                else if (((object) ((System.Xml.XmlQualifiedName)t).Name == (object)id91_XmlSchemaMaxExclusiveFacet && (object) ((System.Xml.XmlQualifiedName)t).Namespace == (object)id56_httpwwww3org2001XMLSchema))
                    return Read30_XmlSchemaMaxExclusiveFacet(isNullable, false);
                else if (((object) ((System.Xml.XmlQualifiedName)t).Name == (object)id92_XmlSchemaMaxInclusiveFacet && (object) ((System.Xml.XmlQualifiedName)t).Namespace == (object)id56_httpwwww3org2001XMLSchema))
                    return Read29_XmlSchemaMaxInclusiveFacet(isNullable, false);
                else if (((object) ((System.Xml.XmlQualifiedName)t).Name == (object)id93_XmlSchemaEnumerationFacet && (object) ((System.Xml.XmlQualifiedName)t).Namespace == (object)id56_httpwwww3org2001XMLSchema))
                    return Read28_XmlSchemaEnumerationFacet(isNullable, false);
                else if (((object) ((System.Xml.XmlQualifiedName)t).Name == (object)id94_XmlSchemaPatternFacet && (object) ((System.Xml.XmlQualifiedName)t).Namespace == (object)id56_httpwwww3org2001XMLSchema))
                    return Read27_XmlSchemaPatternFacet(isNullable, false);
                else if (((object) ((System.Xml.XmlQualifiedName)t).Name == (object)id95_XmlSchemaWhiteSpaceFacet && (object) ((System.Xml.XmlQualifiedName)t).Namespace == (object)id56_httpwwww3org2001XMLSchema))
                    return Read25_XmlSchemaWhiteSpaceFacet(isNullable, false);
                else if (((object) ((System.Xml.XmlQualifiedName)t).Name == (object)id96_XmlSchemaNumericFacet && (object) ((System.Xml.XmlQualifiedName)t).Namespace == (object)id56_httpwwww3org2001XMLSchema))
                    return Read22_XmlSchemaNumericFacet(isNullable, false);
                else if (((object) ((System.Xml.XmlQualifiedName)t).Name == (object)id97_XmlSchemaFractionDigitsFacet && (object) ((System.Xml.XmlQualifiedName)t).Namespace == (object)id56_httpwwww3org2001XMLSchema))
                    return Read34_XmlSchemaFractionDigitsFacet(isNullable, false);
                else if (((object) ((System.Xml.XmlQualifiedName)t).Name == (object)id98_XmlSchemaTotalDigitsFacet && (object) ((System.Xml.XmlQualifiedName)t).Namespace == (object)id56_httpwwww3org2001XMLSchema))
                    return Read33_XmlSchemaTotalDigitsFacet(isNullable, false);
                else if (((object) ((System.Xml.XmlQualifiedName)t).Name == (object)id99_XmlSchemaMaxLengthFacet && (object) ((System.Xml.XmlQualifiedName)t).Namespace == (object)id56_httpwwww3org2001XMLSchema))
                    return Read26_XmlSchemaMaxLengthFacet(isNullable, false);
                else if (((object) ((System.Xml.XmlQualifiedName)t).Name == (object)id100_XmlSchemaLengthFacet && (object) ((System.Xml.XmlQualifiedName)t).Namespace == (object)id56_httpwwww3org2001XMLSchema))
                    return Read24_XmlSchemaLengthFacet(isNullable, false);
                else if (((object) ((System.Xml.XmlQualifiedName)t).Name == (object)id101_XmlSchemaMinLengthFacet && (object) ((System.Xml.XmlQualifiedName)t).Namespace == (object)id56_httpwwww3org2001XMLSchema))
                    return Read21_XmlSchemaMinLengthFacet(isNullable, false);
                else
                    throw CreateUnknownTypeException((System.Xml.XmlQualifiedName)t);
            }
            throw CreateAbstractTypeException(@"XmlSchemaFacet", @"http://www.w3.org/2001/XMLSchema");
        }

        System.Xml.Schema.XmlSchemaLengthFacet Read24_XmlSchemaLengthFacet(bool isNullable, bool checkType) {
            if (isNullable && ReadNull()) return null;
            if (checkType) {
                System.Xml.XmlQualifiedName t = GetXsiType();
                if (t == null || ((object) ((System.Xml.XmlQualifiedName)t).Name == (object)id100_XmlSchemaLengthFacet && (object) ((System.Xml.XmlQualifiedName)t).Namespace == (object)id56_httpwwww3org2001XMLSchema))
                    ;
                else
                    throw CreateUnknownTypeException((System.Xml.XmlQualifiedName)t);
            }
            System.Xml.Schema.XmlSchemaLengthFacet o = new System.Xml.Schema.XmlSchemaLengthFacet();
            System.Xml.XmlAttribute[] a_3 = null;
            int ca_3 = 0;
            bool[] paramsRead = new bool[6];
            while (Reader.MoveToNextAttribute()) {
                if (!paramsRead[1] && ((object) Reader.LocalName == (object)id128_id && (object) Reader.NamespaceURI == (object)id4_Item)) {
                    o.@Id = Reader.Value;
                    paramsRead[1] = true;
                }
                else if (!paramsRead[4] && ((object) Reader.LocalName == (object)id162_value && (object) Reader.NamespaceURI == (object)id4_Item)) {
                    o.@Value = Reader.Value;
                    paramsRead[4] = true;
                }
                else if (!paramsRead[5] && ((object) Reader.LocalName == (object)id163_fixed && (object) Reader.NamespaceURI == (object)id4_Item)) {
                    o.@IsFixed = System.Xml.XmlConvert.ToBoolean(Reader.Value);
                    paramsRead[5] = true;
                }
                else if (IsXmlnsAttribute(Reader.Name)) {
                    if (o.@Namespaces == null) o.@Namespaces = new System.Xml.Serialization.XmlSerializerNamespaces();
                    o.@Namespaces.Add(Reader.Name.Length == 5 ? "" : Reader.LocalName, Reader.Value);
                }
                else {
                    System.Xml.XmlAttribute attr = (System.Xml.XmlAttribute) Document.ReadNode(Reader);
                    ParseWsdlArrayType(attr);
                    a_3 = (System.Xml.XmlAttribute[])EnsureArrayIndex(a_3, ca_3, typeof(System.Xml.XmlAttribute));a_3[ca_3++] = attr;
                }
            }
            o.@UnhandledAttributes = (System.Xml.XmlAttribute[])ShrinkArray(a_3, ca_3, typeof(System.Xml.XmlAttribute), true);
            Reader.MoveToElement();
            if (Reader.IsEmptyElement) {
                Reader.Skip();
                o.@UnhandledAttributes = (System.Xml.XmlAttribute[])ShrinkArray(a_3, ca_3, typeof(System.Xml.XmlAttribute), true);
                return o;
            }
            Reader.ReadStartElement();
            Reader.MoveToContent();
            while (Reader.NodeType != System.Xml.XmlNodeType.EndElement) {
                if (Reader.NodeType == System.Xml.XmlNodeType.Element) {
                    if (!paramsRead[2] && ((object) Reader.LocalName == (object)id138_annotation && (object) Reader.NamespaceURI == (object)id56_httpwwww3org2001XMLSchema)) {
                        o.@Annotation = Read15_XmlSchemaAnnotation(false, true);
                        paramsRead[2] = true;
                    }
                    else {
                        UnknownNode((object)o);
                    }
                }
                else {
                    UnknownNode((object)o);
                }
                Reader.MoveToContent();
            }
            o.@UnhandledAttributes = (System.Xml.XmlAttribute[])ShrinkArray(a_3, ca_3, typeof(System.Xml.XmlAttribute), true);
            ReadEndElement();
            return o;
        }

        System.Xml.Schema.XmlSchemaWhiteSpaceFacet Read25_XmlSchemaWhiteSpaceFacet(bool isNullable, bool checkType) {
            if (isNullable && ReadNull()) return null;
            if (checkType) {
                System.Xml.XmlQualifiedName t = GetXsiType();
                if (t == null || ((object) ((System.Xml.XmlQualifiedName)t).Name == (object)id95_XmlSchemaWhiteSpaceFacet && (object) ((System.Xml.XmlQualifiedName)t).Namespace == (object)id56_httpwwww3org2001XMLSchema))
                    ;
                else
                    throw CreateUnknownTypeException((System.Xml.XmlQualifiedName)t);
            }
            System.Xml.Schema.XmlSchemaWhiteSpaceFacet o = new System.Xml.Schema.XmlSchemaWhiteSpaceFacet();
            System.Xml.XmlAttribute[] a_3 = null;
            int ca_3 = 0;
            bool[] paramsRead = new bool[6];
            while (Reader.MoveToNextAttribute()) {
                if (!paramsRead[1] && ((object) Reader.LocalName == (object)id128_id && (object) Reader.NamespaceURI == (object)id4_Item)) {
                    o.@Id = Reader.Value;
                    paramsRead[1] = true;
                }
                else if (!paramsRead[4] && ((object) Reader.LocalName == (object)id162_value && (object) Reader.NamespaceURI == (object)id4_Item)) {
                    o.@Value = Reader.Value;
                    paramsRead[4] = true;
                }
                else if (!paramsRead[5] && ((object) Reader.LocalName == (object)id163_fixed && (object) Reader.NamespaceURI == (object)id4_Item)) {
                    o.@IsFixed = System.Xml.XmlConvert.ToBoolean(Reader.Value);
                    paramsRead[5] = true;
                }
                else if (IsXmlnsAttribute(Reader.Name)) {
                    if (o.@Namespaces == null) o.@Namespaces = new System.Xml.Serialization.XmlSerializerNamespaces();
                    o.@Namespaces.Add(Reader.Name.Length == 5 ? "" : Reader.LocalName, Reader.Value);
                }
                else {
                    System.Xml.XmlAttribute attr = (System.Xml.XmlAttribute) Document.ReadNode(Reader);
                    ParseWsdlArrayType(attr);
                    a_3 = (System.Xml.XmlAttribute[])EnsureArrayIndex(a_3, ca_3, typeof(System.Xml.XmlAttribute));a_3[ca_3++] = attr;
                }
            }
            o.@UnhandledAttributes = (System.Xml.XmlAttribute[])ShrinkArray(a_3, ca_3, typeof(System.Xml.XmlAttribute), true);
            Reader.MoveToElement();
            if (Reader.IsEmptyElement) {
                Reader.Skip();
                o.@UnhandledAttributes = (System.Xml.XmlAttribute[])ShrinkArray(a_3, ca_3, typeof(System.Xml.XmlAttribute), true);
                return o;
            }
            Reader.ReadStartElement();
            Reader.MoveToContent();
            while (Reader.NodeType != System.Xml.XmlNodeType.EndElement) {
                if (Reader.NodeType == System.Xml.XmlNodeType.Element) {
                    if (!paramsRead[2] && ((object) Reader.LocalName == (object)id138_annotation && (object) Reader.NamespaceURI == (object)id56_httpwwww3org2001XMLSchema)) {
                        o.@Annotation = Read15_XmlSchemaAnnotation(false, true);
                        paramsRead[2] = true;
                    }
                    else {
                        UnknownNode((object)o);
                    }
                }
                else {
                    UnknownNode((object)o);
                }
                Reader.MoveToContent();
            }
            o.@UnhandledAttributes = (System.Xml.XmlAttribute[])ShrinkArray(a_3, ca_3, typeof(System.Xml.XmlAttribute), true);
            ReadEndElement();
            return o;
        }

        System.Xml.Schema.XmlSchemaMaxLengthFacet Read26_XmlSchemaMaxLengthFacet(bool isNullable, bool checkType) {
            if (isNullable && ReadNull()) return null;
            if (checkType) {
                System.Xml.XmlQualifiedName t = GetXsiType();
                if (t == null || ((object) ((System.Xml.XmlQualifiedName)t).Name == (object)id99_XmlSchemaMaxLengthFacet && (object) ((System.Xml.XmlQualifiedName)t).Namespace == (object)id56_httpwwww3org2001XMLSchema))
                    ;
                else
                    throw CreateUnknownTypeException((System.Xml.XmlQualifiedName)t);
            }
            System.Xml.Schema.XmlSchemaMaxLengthFacet o = new System.Xml.Schema.XmlSchemaMaxLengthFacet();
            System.Xml.XmlAttribute[] a_3 = null;
            int ca_3 = 0;
            bool[] paramsRead = new bool[6];
            while (Reader.MoveToNextAttribute()) {
                if (!paramsRead[1] && ((object) Reader.LocalName == (object)id128_id && (object) Reader.NamespaceURI == (object)id4_Item)) {
                    o.@Id = Reader.Value;
                    paramsRead[1] = true;
                }
                else if (!paramsRead[4] && ((object) Reader.LocalName == (object)id162_value && (object) Reader.NamespaceURI == (object)id4_Item)) {
                    o.@Value = Reader.Value;
                    paramsRead[4] = true;
                }
                else if (!paramsRead[5] && ((object) Reader.LocalName == (object)id163_fixed && (object) Reader.NamespaceURI == (object)id4_Item)) {
                    o.@IsFixed = System.Xml.XmlConvert.ToBoolean(Reader.Value);
                    paramsRead[5] = true;
                }
                else if (IsXmlnsAttribute(Reader.Name)) {
                    if (o.@Namespaces == null) o.@Namespaces = new System.Xml.Serialization.XmlSerializerNamespaces();
                    o.@Namespaces.Add(Reader.Name.Length == 5 ? "" : Reader.LocalName, Reader.Value);
                }
                else {
                    System.Xml.XmlAttribute attr = (System.Xml.XmlAttribute) Document.ReadNode(Reader);
                    ParseWsdlArrayType(attr);
                    a_3 = (System.Xml.XmlAttribute[])EnsureArrayIndex(a_3, ca_3, typeof(System.Xml.XmlAttribute));a_3[ca_3++] = attr;
                }
            }
            o.@UnhandledAttributes = (System.Xml.XmlAttribute[])ShrinkArray(a_3, ca_3, typeof(System.Xml.XmlAttribute), true);
            Reader.MoveToElement();
            if (Reader.IsEmptyElement) {
                Reader.Skip();
                o.@UnhandledAttributes = (System.Xml.XmlAttribute[])ShrinkArray(a_3, ca_3, typeof(System.Xml.XmlAttribute), true);
                return o;
            }
            Reader.ReadStartElement();
            Reader.MoveToContent();
            while (Reader.NodeType != System.Xml.XmlNodeType.EndElement) {
                if (Reader.NodeType == System.Xml.XmlNodeType.Element) {
                    if (!paramsRead[2] && ((object) Reader.LocalName == (object)id138_annotation && (object) Reader.NamespaceURI == (object)id56_httpwwww3org2001XMLSchema)) {
                        o.@Annotation = Read15_XmlSchemaAnnotation(false, true);
                        paramsRead[2] = true;
                    }
                    else {
                        UnknownNode((object)o);
                    }
                }
                else {
                    UnknownNode((object)o);
                }
                Reader.MoveToContent();
            }
            o.@UnhandledAttributes = (System.Xml.XmlAttribute[])ShrinkArray(a_3, ca_3, typeof(System.Xml.XmlAttribute), true);
            ReadEndElement();
            return o;
        }

        System.Xml.Schema.XmlSchemaPatternFacet Read27_XmlSchemaPatternFacet(bool isNullable, bool checkType) {
            if (isNullable && ReadNull()) return null;
            if (checkType) {
                System.Xml.XmlQualifiedName t = GetXsiType();
                if (t == null || ((object) ((System.Xml.XmlQualifiedName)t).Name == (object)id94_XmlSchemaPatternFacet && (object) ((System.Xml.XmlQualifiedName)t).Namespace == (object)id56_httpwwww3org2001XMLSchema))
                    ;
                else
                    throw CreateUnknownTypeException((System.Xml.XmlQualifiedName)t);
            }
            System.Xml.Schema.XmlSchemaPatternFacet o = new System.Xml.Schema.XmlSchemaPatternFacet();
            System.Xml.XmlAttribute[] a_3 = null;
            int ca_3 = 0;
            bool[] paramsRead = new bool[6];
            while (Reader.MoveToNextAttribute()) {
                if (!paramsRead[1] && ((object) Reader.LocalName == (object)id128_id && (object) Reader.NamespaceURI == (object)id4_Item)) {
                    o.@Id = Reader.Value;
                    paramsRead[1] = true;
                }
                else if (!paramsRead[4] && ((object) Reader.LocalName == (object)id162_value && (object) Reader.NamespaceURI == (object)id4_Item)) {
                    o.@Value = Reader.Value;
                    paramsRead[4] = true;
                }
                else if (!paramsRead[5] && ((object) Reader.LocalName == (object)id163_fixed && (object) Reader.NamespaceURI == (object)id4_Item)) {
                    o.@IsFixed = System.Xml.XmlConvert.ToBoolean(Reader.Value);
                    paramsRead[5] = true;
                }
                else if (IsXmlnsAttribute(Reader.Name)) {
                    if (o.@Namespaces == null) o.@Namespaces = new System.Xml.Serialization.XmlSerializerNamespaces();
                    o.@Namespaces.Add(Reader.Name.Length == 5 ? "" : Reader.LocalName, Reader.Value);
                }
                else {
                    System.Xml.XmlAttribute attr = (System.Xml.XmlAttribute) Document.ReadNode(Reader);
                    ParseWsdlArrayType(attr);
                    a_3 = (System.Xml.XmlAttribute[])EnsureArrayIndex(a_3, ca_3, typeof(System.Xml.XmlAttribute));a_3[ca_3++] = attr;
                }
            }
            o.@UnhandledAttributes = (System.Xml.XmlAttribute[])ShrinkArray(a_3, ca_3, typeof(System.Xml.XmlAttribute), true);
            Reader.MoveToElement();
            if (Reader.IsEmptyElement) {
                Reader.Skip();
                o.@UnhandledAttributes = (System.Xml.XmlAttribute[])ShrinkArray(a_3, ca_3, typeof(System.Xml.XmlAttribute), true);
                return o;
            }
            Reader.ReadStartElement();
            Reader.MoveToContent();
            while (Reader.NodeType != System.Xml.XmlNodeType.EndElement) {
                if (Reader.NodeType == System.Xml.XmlNodeType.Element) {
                    if (!paramsRead[2] && ((object) Reader.LocalName == (object)id138_annotation && (object) Reader.NamespaceURI == (object)id56_httpwwww3org2001XMLSchema)) {
                        o.@Annotation = Read15_XmlSchemaAnnotation(false, true);
                        paramsRead[2] = true;
                    }
                    else {
                        UnknownNode((object)o);
                    }
                }
                else {
                    UnknownNode((object)o);
                }
                Reader.MoveToContent();
            }
            o.@UnhandledAttributes = (System.Xml.XmlAttribute[])ShrinkArray(a_3, ca_3, typeof(System.Xml.XmlAttribute), true);
            ReadEndElement();
            return o;
        }

        System.Xml.Schema.XmlSchemaEnumerationFacet Read28_XmlSchemaEnumerationFacet(bool isNullable, bool checkType) {
            if (isNullable && ReadNull()) return null;
            if (checkType) {
                System.Xml.XmlQualifiedName t = GetXsiType();
                if (t == null || ((object) ((System.Xml.XmlQualifiedName)t).Name == (object)id93_XmlSchemaEnumerationFacet && (object) ((System.Xml.XmlQualifiedName)t).Namespace == (object)id56_httpwwww3org2001XMLSchema))
                    ;
                else
                    throw CreateUnknownTypeException((System.Xml.XmlQualifiedName)t);
            }
            System.Xml.Schema.XmlSchemaEnumerationFacet o = new System.Xml.Schema.XmlSchemaEnumerationFacet();
            System.Xml.XmlAttribute[] a_3 = null;
            int ca_3 = 0;
            bool[] paramsRead = new bool[6];
            while (Reader.MoveToNextAttribute()) {
                if (!paramsRead[1] && ((object) Reader.LocalName == (object)id128_id && (object) Reader.NamespaceURI == (object)id4_Item)) {
                    o.@Id = Reader.Value;
                    paramsRead[1] = true;
                }
                else if (!paramsRead[4] && ((object) Reader.LocalName == (object)id162_value && (object) Reader.NamespaceURI == (object)id4_Item)) {
                    o.@Value = Reader.Value;
                    paramsRead[4] = true;
                }
                else if (!paramsRead[5] && ((object) Reader.LocalName == (object)id163_fixed && (object) Reader.NamespaceURI == (object)id4_Item)) {
                    o.@IsFixed = System.Xml.XmlConvert.ToBoolean(Reader.Value);
                    paramsRead[5] = true;
                }
                else if (IsXmlnsAttribute(Reader.Name)) {
                    if (o.@Namespaces == null) o.@Namespaces = new System.Xml.Serialization.XmlSerializerNamespaces();
                    o.@Namespaces.Add(Reader.Name.Length == 5 ? "" : Reader.LocalName, Reader.Value);
                }
                else {
                    System.Xml.XmlAttribute attr = (System.Xml.XmlAttribute) Document.ReadNode(Reader);
                    ParseWsdlArrayType(attr);
                    a_3 = (System.Xml.XmlAttribute[])EnsureArrayIndex(a_3, ca_3, typeof(System.Xml.XmlAttribute));a_3[ca_3++] = attr;
                }
            }
            o.@UnhandledAttributes = (System.Xml.XmlAttribute[])ShrinkArray(a_3, ca_3, typeof(System.Xml.XmlAttribute), true);
            Reader.MoveToElement();
            if (Reader.IsEmptyElement) {
                Reader.Skip();
                o.@UnhandledAttributes = (System.Xml.XmlAttribute[])ShrinkArray(a_3, ca_3, typeof(System.Xml.XmlAttribute), true);
                return o;
            }
            Reader.ReadStartElement();
            Reader.MoveToContent();
            while (Reader.NodeType != System.Xml.XmlNodeType.EndElement) {
                if (Reader.NodeType == System.Xml.XmlNodeType.Element) {
                    if (!paramsRead[2] && ((object) Reader.LocalName == (object)id138_annotation && (object) Reader.NamespaceURI == (object)id56_httpwwww3org2001XMLSchema)) {
                        o.@Annotation = Read15_XmlSchemaAnnotation(false, true);
                        paramsRead[2] = true;
                    }
                    else {
                        UnknownNode((object)o);
                    }
                }
                else {
                    UnknownNode((object)o);
                }
                Reader.MoveToContent();
            }
            o.@UnhandledAttributes = (System.Xml.XmlAttribute[])ShrinkArray(a_3, ca_3, typeof(System.Xml.XmlAttribute), true);
            ReadEndElement();
            return o;
        }

        System.Xml.Schema.XmlSchemaMaxInclusiveFacet Read29_XmlSchemaMaxInclusiveFacet(bool isNullable, bool checkType) {
            if (isNullable && ReadNull()) return null;
            if (checkType) {
                System.Xml.XmlQualifiedName t = GetXsiType();
                if (t == null || ((object) ((System.Xml.XmlQualifiedName)t).Name == (object)id92_XmlSchemaMaxInclusiveFacet && (object) ((System.Xml.XmlQualifiedName)t).Namespace == (object)id56_httpwwww3org2001XMLSchema))
                    ;
                else
                    throw CreateUnknownTypeException((System.Xml.XmlQualifiedName)t);
            }
            System.Xml.Schema.XmlSchemaMaxInclusiveFacet o = new System.Xml.Schema.XmlSchemaMaxInclusiveFacet();
            System.Xml.XmlAttribute[] a_3 = null;
            int ca_3 = 0;
            bool[] paramsRead = new bool[6];
            while (Reader.MoveToNextAttribute()) {
                if (!paramsRead[1] && ((object) Reader.LocalName == (object)id128_id && (object) Reader.NamespaceURI == (object)id4_Item)) {
                    o.@Id = Reader.Value;
                    paramsRead[1] = true;
                }
                else if (!paramsRead[4] && ((object) Reader.LocalName == (object)id162_value && (object) Reader.NamespaceURI == (object)id4_Item)) {
                    o.@Value = Reader.Value;
                    paramsRead[4] = true;
                }
                else if (!paramsRead[5] && ((object) Reader.LocalName == (object)id163_fixed && (object) Reader.NamespaceURI == (object)id4_Item)) {
                    o.@IsFixed = System.Xml.XmlConvert.ToBoolean(Reader.Value);
                    paramsRead[5] = true;
                }
                else if (IsXmlnsAttribute(Reader.Name)) {
                    if (o.@Namespaces == null) o.@Namespaces = new System.Xml.Serialization.XmlSerializerNamespaces();
                    o.@Namespaces.Add(Reader.Name.Length == 5 ? "" : Reader.LocalName, Reader.Value);
                }
                else {
                    System.Xml.XmlAttribute attr = (System.Xml.XmlAttribute) Document.ReadNode(Reader);
                    ParseWsdlArrayType(attr);
                    a_3 = (System.Xml.XmlAttribute[])EnsureArrayIndex(a_3, ca_3, typeof(System.Xml.XmlAttribute));a_3[ca_3++] = attr;
                }
            }
            o.@UnhandledAttributes = (System.Xml.XmlAttribute[])ShrinkArray(a_3, ca_3, typeof(System.Xml.XmlAttribute), true);
            Reader.MoveToElement();
            if (Reader.IsEmptyElement) {
                Reader.Skip();
                o.@UnhandledAttributes = (System.Xml.XmlAttribute[])ShrinkArray(a_3, ca_3, typeof(System.Xml.XmlAttribute), true);
                return o;
            }
            Reader.ReadStartElement();
            Reader.MoveToContent();
            while (Reader.NodeType != System.Xml.XmlNodeType.EndElement) {
                if (Reader.NodeType == System.Xml.XmlNodeType.Element) {
                    if (!paramsRead[2] && ((object) Reader.LocalName == (object)id138_annotation && (object) Reader.NamespaceURI == (object)id56_httpwwww3org2001XMLSchema)) {
                        o.@Annotation = Read15_XmlSchemaAnnotation(false, true);
                        paramsRead[2] = true;
                    }
                    else {
                        UnknownNode((object)o);
                    }
                }
                else {
                    UnknownNode((object)o);
                }
                Reader.MoveToContent();
            }
            o.@UnhandledAttributes = (System.Xml.XmlAttribute[])ShrinkArray(a_3, ca_3, typeof(System.Xml.XmlAttribute), true);
            ReadEndElement();
            return o;
        }

        System.Xml.Schema.XmlSchemaMaxExclusiveFacet Read30_XmlSchemaMaxExclusiveFacet(bool isNullable, bool checkType) {
            if (isNullable && ReadNull()) return null;
            if (checkType) {
                System.Xml.XmlQualifiedName t = GetXsiType();
                if (t == null || ((object) ((System.Xml.XmlQualifiedName)t).Name == (object)id91_XmlSchemaMaxExclusiveFacet && (object) ((System.Xml.XmlQualifiedName)t).Namespace == (object)id56_httpwwww3org2001XMLSchema))
                    ;
                else
                    throw CreateUnknownTypeException((System.Xml.XmlQualifiedName)t);
            }
            System.Xml.Schema.XmlSchemaMaxExclusiveFacet o = new System.Xml.Schema.XmlSchemaMaxExclusiveFacet();
            System.Xml.XmlAttribute[] a_3 = null;
            int ca_3 = 0;
            bool[] paramsRead = new bool[6];
            while (Reader.MoveToNextAttribute()) {
                if (!paramsRead[1] && ((object) Reader.LocalName == (object)id128_id && (object) Reader.NamespaceURI == (object)id4_Item)) {
                    o.@Id = Reader.Value;
                    paramsRead[1] = true;
                }
                else if (!paramsRead[4] && ((object) Reader.LocalName == (object)id162_value && (object) Reader.NamespaceURI == (object)id4_Item)) {
                    o.@Value = Reader.Value;
                    paramsRead[4] = true;
                }
                else if (!paramsRead[5] && ((object) Reader.LocalName == (object)id163_fixed && (object) Reader.NamespaceURI == (object)id4_Item)) {
                    o.@IsFixed = System.Xml.XmlConvert.ToBoolean(Reader.Value);
                    paramsRead[5] = true;
                }
                else if (IsXmlnsAttribute(Reader.Name)) {
                    if (o.@Namespaces == null) o.@Namespaces = new System.Xml.Serialization.XmlSerializerNamespaces();
                    o.@Namespaces.Add(Reader.Name.Length == 5 ? "" : Reader.LocalName, Reader.Value);
                }
                else {
                    System.Xml.XmlAttribute attr = (System.Xml.XmlAttribute) Document.ReadNode(Reader);
                    ParseWsdlArrayType(attr);
                    a_3 = (System.Xml.XmlAttribute[])EnsureArrayIndex(a_3, ca_3, typeof(System.Xml.XmlAttribute));a_3[ca_3++] = attr;
                }
            }
            o.@UnhandledAttributes = (System.Xml.XmlAttribute[])ShrinkArray(a_3, ca_3, typeof(System.Xml.XmlAttribute), true);
            Reader.MoveToElement();
            if (Reader.IsEmptyElement) {
                Reader.Skip();
                o.@UnhandledAttributes = (System.Xml.XmlAttribute[])ShrinkArray(a_3, ca_3, typeof(System.Xml.XmlAttribute), true);
                return o;
            }
            Reader.ReadStartElement();
            Reader.MoveToContent();
            while (Reader.NodeType != System.Xml.XmlNodeType.EndElement) {
                if (Reader.NodeType == System.Xml.XmlNodeType.Element) {
                    if (!paramsRead[2] && ((object) Reader.LocalName == (object)id138_annotation && (object) Reader.NamespaceURI == (object)id56_httpwwww3org2001XMLSchema)) {
                        o.@Annotation = Read15_XmlSchemaAnnotation(false, true);
                        paramsRead[2] = true;
                    }
                    else {
                        UnknownNode((object)o);
                    }
                }
                else {
                    UnknownNode((object)o);
                }
                Reader.MoveToContent();
            }
            o.@UnhandledAttributes = (System.Xml.XmlAttribute[])ShrinkArray(a_3, ca_3, typeof(System.Xml.XmlAttribute), true);
            ReadEndElement();
            return o;
        }

        System.Xml.Schema.XmlSchemaMinInclusiveFacet Read31_XmlSchemaMinInclusiveFacet(bool isNullable, bool checkType) {
            if (isNullable && ReadNull()) return null;
            if (checkType) {
                System.Xml.XmlQualifiedName t = GetXsiType();
                if (t == null || ((object) ((System.Xml.XmlQualifiedName)t).Name == (object)id90_XmlSchemaMinInclusiveFacet && (object) ((System.Xml.XmlQualifiedName)t).Namespace == (object)id56_httpwwww3org2001XMLSchema))
                    ;
                else
                    throw CreateUnknownTypeException((System.Xml.XmlQualifiedName)t);
            }
            System.Xml.Schema.XmlSchemaMinInclusiveFacet o = new System.Xml.Schema.XmlSchemaMinInclusiveFacet();
            System.Xml.XmlAttribute[] a_3 = null;
            int ca_3 = 0;
            bool[] paramsRead = new bool[6];
            while (Reader.MoveToNextAttribute()) {
                if (!paramsRead[1] && ((object) Reader.LocalName == (object)id128_id && (object) Reader.NamespaceURI == (object)id4_Item)) {
                    o.@Id = Reader.Value;
                    paramsRead[1] = true;
                }
                else if (!paramsRead[4] && ((object) Reader.LocalName == (object)id162_value && (object) Reader.NamespaceURI == (object)id4_Item)) {
                    o.@Value = Reader.Value;
                    paramsRead[4] = true;
                }
                else if (!paramsRead[5] && ((object) Reader.LocalName == (object)id163_fixed && (object) Reader.NamespaceURI == (object)id4_Item)) {
                    o.@IsFixed = System.Xml.XmlConvert.ToBoolean(Reader.Value);
                    paramsRead[5] = true;
                }
                else if (IsXmlnsAttribute(Reader.Name)) {
                    if (o.@Namespaces == null) o.@Namespaces = new System.Xml.Serialization.XmlSerializerNamespaces();
                    o.@Namespaces.Add(Reader.Name.Length == 5 ? "" : Reader.LocalName, Reader.Value);
                }
                else {
                    System.Xml.XmlAttribute attr = (System.Xml.XmlAttribute) Document.ReadNode(Reader);
                    ParseWsdlArrayType(attr);
                    a_3 = (System.Xml.XmlAttribute[])EnsureArrayIndex(a_3, ca_3, typeof(System.Xml.XmlAttribute));a_3[ca_3++] = attr;
                }
            }
            o.@UnhandledAttributes = (System.Xml.XmlAttribute[])ShrinkArray(a_3, ca_3, typeof(System.Xml.XmlAttribute), true);
            Reader.MoveToElement();
            if (Reader.IsEmptyElement) {
                Reader.Skip();
                o.@UnhandledAttributes = (System.Xml.XmlAttribute[])ShrinkArray(a_3, ca_3, typeof(System.Xml.XmlAttribute), true);
                return o;
            }
            Reader.ReadStartElement();
            Reader.MoveToContent();
            while (Reader.NodeType != System.Xml.XmlNodeType.EndElement) {
                if (Reader.NodeType == System.Xml.XmlNodeType.Element) {
                    if (!paramsRead[2] && ((object) Reader.LocalName == (object)id138_annotation && (object) Reader.NamespaceURI == (object)id56_httpwwww3org2001XMLSchema)) {
                        o.@Annotation = Read15_XmlSchemaAnnotation(false, true);
                        paramsRead[2] = true;
                    }
                    else {
                        UnknownNode((object)o);
                    }
                }
                else {
                    UnknownNode((object)o);
                }
                Reader.MoveToContent();
            }
            o.@UnhandledAttributes = (System.Xml.XmlAttribute[])ShrinkArray(a_3, ca_3, typeof(System.Xml.XmlAttribute), true);
            ReadEndElement();
            return o;
        }

        System.Xml.Schema.XmlSchemaMinExclusiveFacet Read32_XmlSchemaMinExclusiveFacet(bool isNullable, bool checkType) {
            if (isNullable && ReadNull()) return null;
            if (checkType) {
                System.Xml.XmlQualifiedName t = GetXsiType();
                if (t == null || ((object) ((System.Xml.XmlQualifiedName)t).Name == (object)id89_XmlSchemaMinExclusiveFacet && (object) ((System.Xml.XmlQualifiedName)t).Namespace == (object)id56_httpwwww3org2001XMLSchema))
                    ;
                else
                    throw CreateUnknownTypeException((System.Xml.XmlQualifiedName)t);
            }
            System.Xml.Schema.XmlSchemaMinExclusiveFacet o = new System.Xml.Schema.XmlSchemaMinExclusiveFacet();
            System.Xml.XmlAttribute[] a_3 = null;
            int ca_3 = 0;
            bool[] paramsRead = new bool[6];
            while (Reader.MoveToNextAttribute()) {
                if (!paramsRead[1] && ((object) Reader.LocalName == (object)id128_id && (object) Reader.NamespaceURI == (object)id4_Item)) {
                    o.@Id = Reader.Value;
                    paramsRead[1] = true;
                }
                else if (!paramsRead[4] && ((object) Reader.LocalName == (object)id162_value && (object) Reader.NamespaceURI == (object)id4_Item)) {
                    o.@Value = Reader.Value;
                    paramsRead[4] = true;
                }
                else if (!paramsRead[5] && ((object) Reader.LocalName == (object)id163_fixed && (object) Reader.NamespaceURI == (object)id4_Item)) {
                    o.@IsFixed = System.Xml.XmlConvert.ToBoolean(Reader.Value);
                    paramsRead[5] = true;
                }
                else if (IsXmlnsAttribute(Reader.Name)) {
                    if (o.@Namespaces == null) o.@Namespaces = new System.Xml.Serialization.XmlSerializerNamespaces();
                    o.@Namespaces.Add(Reader.Name.Length == 5 ? "" : Reader.LocalName, Reader.Value);
                }
                else {
                    System.Xml.XmlAttribute attr = (System.Xml.XmlAttribute) Document.ReadNode(Reader);
                    ParseWsdlArrayType(attr);
                    a_3 = (System.Xml.XmlAttribute[])EnsureArrayIndex(a_3, ca_3, typeof(System.Xml.XmlAttribute));a_3[ca_3++] = attr;
                }
            }
            o.@UnhandledAttributes = (System.Xml.XmlAttribute[])ShrinkArray(a_3, ca_3, typeof(System.Xml.XmlAttribute), true);
            Reader.MoveToElement();
            if (Reader.IsEmptyElement) {
                Reader.Skip();
                o.@UnhandledAttributes = (System.Xml.XmlAttribute[])ShrinkArray(a_3, ca_3, typeof(System.Xml.XmlAttribute), true);
                return o;
            }
            Reader.ReadStartElement();
            Reader.MoveToContent();
            while (Reader.NodeType != System.Xml.XmlNodeType.EndElement) {
                if (Reader.NodeType == System.Xml.XmlNodeType.Element) {
                    if (!paramsRead[2] && ((object) Reader.LocalName == (object)id138_annotation && (object) Reader.NamespaceURI == (object)id56_httpwwww3org2001XMLSchema)) {
                        o.@Annotation = Read15_XmlSchemaAnnotation(false, true);
                        paramsRead[2] = true;
                    }
                    else {
                        UnknownNode((object)o);
                    }
                }
                else {
                    UnknownNode((object)o);
                }
                Reader.MoveToContent();
            }
            o.@UnhandledAttributes = (System.Xml.XmlAttribute[])ShrinkArray(a_3, ca_3, typeof(System.Xml.XmlAttribute), true);
            ReadEndElement();
            return o;
        }

        System.Xml.Schema.XmlSchemaTotalDigitsFacet Read33_XmlSchemaTotalDigitsFacet(bool isNullable, bool checkType) {
            if (isNullable && ReadNull()) return null;
            if (checkType) {
                System.Xml.XmlQualifiedName t = GetXsiType();
                if (t == null || ((object) ((System.Xml.XmlQualifiedName)t).Name == (object)id98_XmlSchemaTotalDigitsFacet && (object) ((System.Xml.XmlQualifiedName)t).Namespace == (object)id56_httpwwww3org2001XMLSchema))
                    ;
                else
                    throw CreateUnknownTypeException((System.Xml.XmlQualifiedName)t);
            }
            System.Xml.Schema.XmlSchemaTotalDigitsFacet o = new System.Xml.Schema.XmlSchemaTotalDigitsFacet();
            System.Xml.XmlAttribute[] a_3 = null;
            int ca_3 = 0;
            bool[] paramsRead = new bool[6];
            while (Reader.MoveToNextAttribute()) {
                if (!paramsRead[1] && ((object) Reader.LocalName == (object)id128_id && (object) Reader.NamespaceURI == (object)id4_Item)) {
                    o.@Id = Reader.Value;
                    paramsRead[1] = true;
                }
                else if (!paramsRead[4] && ((object) Reader.LocalName == (object)id162_value && (object) Reader.NamespaceURI == (object)id4_Item)) {
                    o.@Value = Reader.Value;
                    paramsRead[4] = true;
                }
                else if (!paramsRead[5] && ((object) Reader.LocalName == (object)id163_fixed && (object) Reader.NamespaceURI == (object)id4_Item)) {
                    o.@IsFixed = System.Xml.XmlConvert.ToBoolean(Reader.Value);
                    paramsRead[5] = true;
                }
                else if (IsXmlnsAttribute(Reader.Name)) {
                    if (o.@Namespaces == null) o.@Namespaces = new System.Xml.Serialization.XmlSerializerNamespaces();
                    o.@Namespaces.Add(Reader.Name.Length == 5 ? "" : Reader.LocalName, Reader.Value);
                }
                else {
                    System.Xml.XmlAttribute attr = (System.Xml.XmlAttribute) Document.ReadNode(Reader);
                    ParseWsdlArrayType(attr);
                    a_3 = (System.Xml.XmlAttribute[])EnsureArrayIndex(a_3, ca_3, typeof(System.Xml.XmlAttribute));a_3[ca_3++] = attr;
                }
            }
            o.@UnhandledAttributes = (System.Xml.XmlAttribute[])ShrinkArray(a_3, ca_3, typeof(System.Xml.XmlAttribute), true);
            Reader.MoveToElement();
            if (Reader.IsEmptyElement) {
                Reader.Skip();
                o.@UnhandledAttributes = (System.Xml.XmlAttribute[])ShrinkArray(a_3, ca_3, typeof(System.Xml.XmlAttribute), true);
                return o;
            }
            Reader.ReadStartElement();
            Reader.MoveToContent();
            while (Reader.NodeType != System.Xml.XmlNodeType.EndElement) {
                if (Reader.NodeType == System.Xml.XmlNodeType.Element) {
                    if (!paramsRead[2] && ((object) Reader.LocalName == (object)id138_annotation && (object) Reader.NamespaceURI == (object)id56_httpwwww3org2001XMLSchema)) {
                        o.@Annotation = Read15_XmlSchemaAnnotation(false, true);
                        paramsRead[2] = true;
                    }
                    else {
                        UnknownNode((object)o);
                    }
                }
                else {
                    UnknownNode((object)o);
                }
                Reader.MoveToContent();
            }
            o.@UnhandledAttributes = (System.Xml.XmlAttribute[])ShrinkArray(a_3, ca_3, typeof(System.Xml.XmlAttribute), true);
            ReadEndElement();
            return o;
        }

        System.Xml.Schema.XmlSchemaFractionDigitsFacet Read34_XmlSchemaFractionDigitsFacet(bool isNullable, bool checkType) {
            if (isNullable && ReadNull()) return null;
            if (checkType) {
                System.Xml.XmlQualifiedName t = GetXsiType();
                if (t == null || ((object) ((System.Xml.XmlQualifiedName)t).Name == (object)id97_XmlSchemaFractionDigitsFacet && (object) ((System.Xml.XmlQualifiedName)t).Namespace == (object)id56_httpwwww3org2001XMLSchema))
                    ;
                else
                    throw CreateUnknownTypeException((System.Xml.XmlQualifiedName)t);
            }
            System.Xml.Schema.XmlSchemaFractionDigitsFacet o = new System.Xml.Schema.XmlSchemaFractionDigitsFacet();
            System.Xml.XmlAttribute[] a_3 = null;
            int ca_3 = 0;
            bool[] paramsRead = new bool[6];
            while (Reader.MoveToNextAttribute()) {
                if (!paramsRead[1] && ((object) Reader.LocalName == (object)id128_id && (object) Reader.NamespaceURI == (object)id4_Item)) {
                    o.@Id = Reader.Value;
                    paramsRead[1] = true;
                }
                else if (!paramsRead[4] && ((object) Reader.LocalName == (object)id162_value && (object) Reader.NamespaceURI == (object)id4_Item)) {
                    o.@Value = Reader.Value;
                    paramsRead[4] = true;
                }
                else if (!paramsRead[5] && ((object) Reader.LocalName == (object)id163_fixed && (object) Reader.NamespaceURI == (object)id4_Item)) {
                    o.@IsFixed = System.Xml.XmlConvert.ToBoolean(Reader.Value);
                    paramsRead[5] = true;
                }
                else if (IsXmlnsAttribute(Reader.Name)) {
                    if (o.@Namespaces == null) o.@Namespaces = new System.Xml.Serialization.XmlSerializerNamespaces();
                    o.@Namespaces.Add(Reader.Name.Length == 5 ? "" : Reader.LocalName, Reader.Value);
                }
                else {
                    System.Xml.XmlAttribute attr = (System.Xml.XmlAttribute) Document.ReadNode(Reader);
                    ParseWsdlArrayType(attr);
                    a_3 = (System.Xml.XmlAttribute[])EnsureArrayIndex(a_3, ca_3, typeof(System.Xml.XmlAttribute));a_3[ca_3++] = attr;
                }
            }
            o.@UnhandledAttributes = (System.Xml.XmlAttribute[])ShrinkArray(a_3, ca_3, typeof(System.Xml.XmlAttribute), true);
            Reader.MoveToElement();
            if (Reader.IsEmptyElement) {
                Reader.Skip();
                o.@UnhandledAttributes = (System.Xml.XmlAttribute[])ShrinkArray(a_3, ca_3, typeof(System.Xml.XmlAttribute), true);
                return o;
            }
            Reader.ReadStartElement();
            Reader.MoveToContent();
            while (Reader.NodeType != System.Xml.XmlNodeType.EndElement) {
                if (Reader.NodeType == System.Xml.XmlNodeType.Element) {
                    if (!paramsRead[2] && ((object) Reader.LocalName == (object)id138_annotation && (object) Reader.NamespaceURI == (object)id56_httpwwww3org2001XMLSchema)) {
                        o.@Annotation = Read15_XmlSchemaAnnotation(false, true);
                        paramsRead[2] = true;
                    }
                    else {
                        UnknownNode((object)o);
                    }
                }
                else {
                    UnknownNode((object)o);
                }
                Reader.MoveToContent();
            }
            o.@UnhandledAttributes = (System.Xml.XmlAttribute[])ShrinkArray(a_3, ca_3, typeof(System.Xml.XmlAttribute), true);
            ReadEndElement();
            return o;
        }

        System.Xml.Schema.XmlSchemaSimpleTypeUnion Read35_XmlSchemaSimpleTypeUnion(bool isNullable, bool checkType) {
            if (isNullable && ReadNull()) return null;
            if (checkType) {
                System.Xml.XmlQualifiedName t = GetXsiType();
                if (t == null || ((object) ((System.Xml.XmlQualifiedName)t).Name == (object)id103_XmlSchemaSimpleTypeUnion && (object) ((System.Xml.XmlQualifiedName)t).Namespace == (object)id56_httpwwww3org2001XMLSchema))
                    ;
                else
                    throw CreateUnknownTypeException((System.Xml.XmlQualifiedName)t);
            }
            System.Xml.Schema.XmlSchemaSimpleTypeUnion o = new System.Xml.Schema.XmlSchemaSimpleTypeUnion();
            System.Xml.XmlAttribute[] a_3 = null;
            int ca_3 = 0;
            System.Xml.Schema.XmlSchemaObjectCollection a_4 = (System.Xml.Schema.XmlSchemaObjectCollection)o.@BaseTypes;
            System.Xml.XmlQualifiedName[] a_5 = null;
            int ca_5 = 0;
            bool[] paramsRead = new bool[6];
            while (Reader.MoveToNextAttribute()) {
                if (!paramsRead[1] && ((object) Reader.LocalName == (object)id128_id && (object) Reader.NamespaceURI == (object)id4_Item)) {
                    o.@Id = Reader.Value;
                    paramsRead[1] = true;
                }
                else if (((object) Reader.LocalName == (object)id164_memberTypes && (object) Reader.NamespaceURI == (object)id4_Item)) {
                    string listValues = Reader.Value;
                    string[] vals = listValues.Split(null);
                    for (int i = 0; i < vals.Length; i++) {
                        a_5 = (System.Xml.XmlQualifiedName[])EnsureArrayIndex(a_5, ca_5, typeof(System.Xml.XmlQualifiedName));a_5[ca_5++] = ToXmlQualifiedName(vals[i]);
                    }
                }
                else if (IsXmlnsAttribute(Reader.Name)) {
                    if (o.@Namespaces == null) o.@Namespaces = new System.Xml.Serialization.XmlSerializerNamespaces();
                    o.@Namespaces.Add(Reader.Name.Length == 5 ? "" : Reader.LocalName, Reader.Value);
                }
                else {
                    System.Xml.XmlAttribute attr = (System.Xml.XmlAttribute) Document.ReadNode(Reader);
                    ParseWsdlArrayType(attr);
                    a_3 = (System.Xml.XmlAttribute[])EnsureArrayIndex(a_3, ca_3, typeof(System.Xml.XmlAttribute));a_3[ca_3++] = attr;
                }
            }
            o.@UnhandledAttributes = (System.Xml.XmlAttribute[])ShrinkArray(a_3, ca_3, typeof(System.Xml.XmlAttribute), true);
            o.@MemberTypes = (System.Xml.XmlQualifiedName[])ShrinkArray(a_5, ca_5, typeof(System.Xml.XmlQualifiedName), true);
            Reader.MoveToElement();
            if (Reader.IsEmptyElement) {
                Reader.Skip();
                o.@UnhandledAttributes = (System.Xml.XmlAttribute[])ShrinkArray(a_3, ca_3, typeof(System.Xml.XmlAttribute), true);
                o.@MemberTypes = (System.Xml.XmlQualifiedName[])ShrinkArray(a_5, ca_5, typeof(System.Xml.XmlQualifiedName), true);
                return o;
            }
            Reader.ReadStartElement();
            Reader.MoveToContent();
            while (Reader.NodeType != System.Xml.XmlNodeType.EndElement) {
                if (Reader.NodeType == System.Xml.XmlNodeType.Element) {
                    if (!paramsRead[2] && ((object) Reader.LocalName == (object)id138_annotation && (object) Reader.NamespaceURI == (object)id56_httpwwww3org2001XMLSchema)) {
                        o.@Annotation = Read15_XmlSchemaAnnotation(false, true);
                        paramsRead[2] = true;
                    }
                    else if (((object) Reader.LocalName == (object)id131_simpleType && (object) Reader.NamespaceURI == (object)id56_httpwwww3org2001XMLSchema)) {
                        if ((object)(a_4) == null) Reader.Skip(); else a_4.Add(Read12_XmlSchemaSimpleType(false, true));
                    }
                    else {
                        UnknownNode((object)o);
                    }
                }
                else {
                    UnknownNode((object)o);
                }
                Reader.MoveToContent();
            }
            o.@UnhandledAttributes = (System.Xml.XmlAttribute[])ShrinkArray(a_3, ca_3, typeof(System.Xml.XmlAttribute), true);
            o.@MemberTypes = (System.Xml.XmlQualifiedName[])ShrinkArray(a_5, ca_5, typeof(System.Xml.XmlQualifiedName), true);
            ReadEndElement();
            return o;
        }

        System.Xml.Schema.XmlSchemaAttributeGroup Read36_XmlSchemaAttributeGroup(bool isNullable, bool checkType) {
            if (isNullable && ReadNull()) return null;
            if (checkType) {
                System.Xml.XmlQualifiedName t = GetXsiType();
                if (t == null || ((object) ((System.Xml.XmlQualifiedName)t).Name == (object)id87_XmlSchemaAttributeGroup && (object) ((System.Xml.XmlQualifiedName)t).Namespace == (object)id56_httpwwww3org2001XMLSchema))
                    ;
                else
                    throw CreateUnknownTypeException((System.Xml.XmlQualifiedName)t);
            }
            System.Xml.Schema.XmlSchemaAttributeGroup o = new System.Xml.Schema.XmlSchemaAttributeGroup();
            System.Xml.XmlAttribute[] a_3 = null;
            int ca_3 = 0;
            System.Xml.Schema.XmlSchemaObjectCollection a_5 = (System.Xml.Schema.XmlSchemaObjectCollection)o.@Attributes;
            bool[] paramsRead = new bool[7];
            while (Reader.MoveToNextAttribute()) {
                if (!paramsRead[1] && ((object) Reader.LocalName == (object)id128_id && (object) Reader.NamespaceURI == (object)id4_Item)) {
                    o.@Id = Reader.Value;
                    paramsRead[1] = true;
                }
                else if (!paramsRead[4] && ((object) Reader.LocalName == (object)id5_name && (object) Reader.NamespaceURI == (object)id4_Item)) {
                    o.@Name = Reader.Value;
                    paramsRead[4] = true;
                }
                else if (IsXmlnsAttribute(Reader.Name)) {
                    if (o.@Namespaces == null) o.@Namespaces = new System.Xml.Serialization.XmlSerializerNamespaces();
                    o.@Namespaces.Add(Reader.Name.Length == 5 ? "" : Reader.LocalName, Reader.Value);
                }
                else {
                    System.Xml.XmlAttribute attr = (System.Xml.XmlAttribute) Document.ReadNode(Reader);
                    ParseWsdlArrayType(attr);
                    a_3 = (System.Xml.XmlAttribute[])EnsureArrayIndex(a_3, ca_3, typeof(System.Xml.XmlAttribute));a_3[ca_3++] = attr;
                }
            }
            o.@UnhandledAttributes = (System.Xml.XmlAttribute[])ShrinkArray(a_3, ca_3, typeof(System.Xml.XmlAttribute), true);
            Reader.MoveToElement();
            if (Reader.IsEmptyElement) {
                Reader.Skip();
                o.@UnhandledAttributes = (System.Xml.XmlAttribute[])ShrinkArray(a_3, ca_3, typeof(System.Xml.XmlAttribute), true);
                return o;
            }
            Reader.ReadStartElement();
            Reader.MoveToContent();
            while (Reader.NodeType != System.Xml.XmlNodeType.EndElement) {
                if (Reader.NodeType == System.Xml.XmlNodeType.Element) {
                    if (!paramsRead[2] && ((object) Reader.LocalName == (object)id138_annotation && (object) Reader.NamespaceURI == (object)id56_httpwwww3org2001XMLSchema)) {
                        o.@Annotation = Read15_XmlSchemaAnnotation(false, true);
                        paramsRead[2] = true;
                    }
                    else if (((object) Reader.LocalName == (object)id133_attribute && (object) Reader.NamespaceURI == (object)id56_httpwwww3org2001XMLSchema)) {
                        if ((object)(a_5) == null) Reader.Skip(); else a_5.Add(Read37_XmlSchemaAttribute(false, true));
                    }
                    else if (((object) Reader.LocalName == (object)id136_attributeGroup && (object) Reader.NamespaceURI == (object)id56_httpwwww3org2001XMLSchema)) {
                        if ((object)(a_5) == null) Reader.Skip(); else a_5.Add(Read39_XmlSchemaAttributeGroupRef(false, true));
                    }
                    else if (!paramsRead[6] && ((object) Reader.LocalName == (object)id165_anyAttribute && (object) Reader.NamespaceURI == (object)id56_httpwwww3org2001XMLSchema)) {
                        o.@AnyAttribute = Read40_XmlSchemaAnyAttribute(false, true);
                        paramsRead[6] = true;
                    }
                    else {
                        UnknownNode((object)o);
                    }
                }
                else {
                    UnknownNode((object)o);
                }
                Reader.MoveToContent();
            }
            o.@UnhandledAttributes = (System.Xml.XmlAttribute[])ShrinkArray(a_3, ca_3, typeof(System.Xml.XmlAttribute), true);
            ReadEndElement();
            return o;
        }

        System.Xml.Schema.XmlSchemaAttribute Read37_XmlSchemaAttribute(bool isNullable, bool checkType) {
            if (isNullable && ReadNull()) return null;
            if (checkType) {
                System.Xml.XmlQualifiedName t = GetXsiType();
                if (t == null || ((object) ((System.Xml.XmlQualifiedName)t).Name == (object)id86_XmlSchemaAttribute && (object) ((System.Xml.XmlQualifiedName)t).Namespace == (object)id56_httpwwww3org2001XMLSchema))
                    ;
                else
                    throw CreateUnknownTypeException((System.Xml.XmlQualifiedName)t);
            }
            System.Xml.Schema.XmlSchemaAttribute o = new System.Xml.Schema.XmlSchemaAttribute();
            System.Xml.XmlAttribute[] a_3 = null;
            int ca_3 = 0;
            bool[] paramsRead = new bool[12];
            while (Reader.MoveToNextAttribute()) {
                if (!paramsRead[1] && ((object) Reader.LocalName == (object)id128_id && (object) Reader.NamespaceURI == (object)id4_Item)) {
                    o.@Id = Reader.Value;
                    paramsRead[1] = true;
                }
                else if (!paramsRead[4] && ((object) Reader.LocalName == (object)id166_default && (object) Reader.NamespaceURI == (object)id4_Item)) {
                    o.@DefaultValue = Reader.Value;
                    paramsRead[4] = true;
                }
                else if (!paramsRead[5] && ((object) Reader.LocalName == (object)id163_fixed && (object) Reader.NamespaceURI == (object)id4_Item)) {
                    o.@FixedValue = Reader.Value;
                    paramsRead[5] = true;
                }
                else if (!paramsRead[6] && ((object) Reader.LocalName == (object)id167_form && (object) Reader.NamespaceURI == (object)id4_Item)) {
                    o.@Form = Read8_XmlSchemaForm(Reader.Value);
                    paramsRead[6] = true;
                }
                else if (!paramsRead[7] && ((object) Reader.LocalName == (object)id5_name && (object) Reader.NamespaceURI == (object)id4_Item)) {
                    o.@Name = Reader.Value;
                    paramsRead[7] = true;
                }
                else if (!paramsRead[8] && ((object) Reader.LocalName == (object)id168_ref && (object) Reader.NamespaceURI == (object)id4_Item)) {
                    o.@RefName = ToXmlQualifiedName(Reader.Value);
                    paramsRead[8] = true;
                }
                else if (!paramsRead[9] && ((object) Reader.LocalName == (object)id169_type && (object) Reader.NamespaceURI == (object)id4_Item)) {
                    o.@SchemaTypeName = ToXmlQualifiedName(Reader.Value);
                    paramsRead[9] = true;
                }
                else if (!paramsRead[11] && ((object) Reader.LocalName == (object)id170_use && (object) Reader.NamespaceURI == (object)id4_Item)) {
                    o.@Use = Read38_XmlSchemaUse(Reader.Value);
                    paramsRead[11] = true;
                }
                else if (IsXmlnsAttribute(Reader.Name)) {
                    if (o.@Namespaces == null) o.@Namespaces = new System.Xml.Serialization.XmlSerializerNamespaces();
                    o.@Namespaces.Add(Reader.Name.Length == 5 ? "" : Reader.LocalName, Reader.Value);
                }
                else {
                    System.Xml.XmlAttribute attr = (System.Xml.XmlAttribute) Document.ReadNode(Reader);
                    ParseWsdlArrayType(attr);
                    a_3 = (System.Xml.XmlAttribute[])EnsureArrayIndex(a_3, ca_3, typeof(System.Xml.XmlAttribute));a_3[ca_3++] = attr;
                }
            }
            o.@UnhandledAttributes = (System.Xml.XmlAttribute[])ShrinkArray(a_3, ca_3, typeof(System.Xml.XmlAttribute), true);
            Reader.MoveToElement();
            if (Reader.IsEmptyElement) {
                Reader.Skip();
                o.@UnhandledAttributes = (System.Xml.XmlAttribute[])ShrinkArray(a_3, ca_3, typeof(System.Xml.XmlAttribute), true);
                return o;
            }
            Reader.ReadStartElement();
            Reader.MoveToContent();
            while (Reader.NodeType != System.Xml.XmlNodeType.EndElement) {
                if (Reader.NodeType == System.Xml.XmlNodeType.Element) {
                    if (!paramsRead[2] && ((object) Reader.LocalName == (object)id138_annotation && (object) Reader.NamespaceURI == (object)id56_httpwwww3org2001XMLSchema)) {
                        o.@Annotation = Read15_XmlSchemaAnnotation(false, true);
                        paramsRead[2] = true;
                    }
                    else if (!paramsRead[10] && ((object) Reader.LocalName == (object)id131_simpleType && (object) Reader.NamespaceURI == (object)id56_httpwwww3org2001XMLSchema)) {
                        o.@SchemaType = Read12_XmlSchemaSimpleType(false, true);
                        paramsRead[10] = true;
                    }
                    else {
                        UnknownNode((object)o);
                    }
                }
                else {
                    UnknownNode((object)o);
                }
                Reader.MoveToContent();
            }
            o.@UnhandledAttributes = (System.Xml.XmlAttribute[])ShrinkArray(a_3, ca_3, typeof(System.Xml.XmlAttribute), true);
            ReadEndElement();
            return o;
        }

        System.Xml.Schema.XmlSchemaUse Read38_XmlSchemaUse(string s) {
            switch (s) {
                case @"optional": return System.Xml.Schema.XmlSchemaUse.@Optional;
                case @"prohibited": return System.Xml.Schema.XmlSchemaUse.@Prohibited;
                case @"required": return System.Xml.Schema.XmlSchemaUse.@Required;
                default: throw CreateUnknownConstantException(s, typeof(System.Xml.Schema.XmlSchemaUse));
            }
        }

        System.Xml.Schema.XmlSchemaAttributeGroupRef Read39_XmlSchemaAttributeGroupRef(bool isNullable, bool checkType) {
            if (isNullable && ReadNull()) return null;
            if (checkType) {
                System.Xml.XmlQualifiedName t = GetXsiType();
                if (t == null || ((object) ((System.Xml.XmlQualifiedName)t).Name == (object)id85_XmlSchemaAttributeGroupRef && (object) ((System.Xml.XmlQualifiedName)t).Namespace == (object)id56_httpwwww3org2001XMLSchema))
                    ;
                else
                    throw CreateUnknownTypeException((System.Xml.XmlQualifiedName)t);
            }
            System.Xml.Schema.XmlSchemaAttributeGroupRef o = new System.Xml.Schema.XmlSchemaAttributeGroupRef();
            System.Xml.XmlAttribute[] a_3 = null;
            int ca_3 = 0;
            bool[] paramsRead = new bool[5];
            while (Reader.MoveToNextAttribute()) {
                if (!paramsRead[1] && ((object) Reader.LocalName == (object)id128_id && (object) Reader.NamespaceURI == (object)id4_Item)) {
                    o.@Id = Reader.Value;
                    paramsRead[1] = true;
                }
                else if (!paramsRead[4] && ((object) Reader.LocalName == (object)id168_ref && (object) Reader.NamespaceURI == (object)id4_Item)) {
                    o.@RefName = ToXmlQualifiedName(Reader.Value);
                    paramsRead[4] = true;
                }
                else if (IsXmlnsAttribute(Reader.Name)) {
                    if (o.@Namespaces == null) o.@Namespaces = new System.Xml.Serialization.XmlSerializerNamespaces();
                    o.@Namespaces.Add(Reader.Name.Length == 5 ? "" : Reader.LocalName, Reader.Value);
                }
                else {
                    System.Xml.XmlAttribute attr = (System.Xml.XmlAttribute) Document.ReadNode(Reader);
                    ParseWsdlArrayType(attr);
                    a_3 = (System.Xml.XmlAttribute[])EnsureArrayIndex(a_3, ca_3, typeof(System.Xml.XmlAttribute));a_3[ca_3++] = attr;
                }
            }
            o.@UnhandledAttributes = (System.Xml.XmlAttribute[])ShrinkArray(a_3, ca_3, typeof(System.Xml.XmlAttribute), true);
            Reader.MoveToElement();
            if (Reader.IsEmptyElement) {
                Reader.Skip();
                o.@UnhandledAttributes = (System.Xml.XmlAttribute[])ShrinkArray(a_3, ca_3, typeof(System.Xml.XmlAttribute), true);
                return o;
            }
            Reader.ReadStartElement();
            Reader.MoveToContent();
            while (Reader.NodeType != System.Xml.XmlNodeType.EndElement) {
                if (Reader.NodeType == System.Xml.XmlNodeType.Element) {
                    if (!paramsRead[2] && ((object) Reader.LocalName == (object)id138_annotation && (object) Reader.NamespaceURI == (object)id56_httpwwww3org2001XMLSchema)) {
                        o.@Annotation = Read15_XmlSchemaAnnotation(false, true);
                        paramsRead[2] = true;
                    }
                    else {
                        UnknownNode((object)o);
                    }
                }
                else {
                    UnknownNode((object)o);
                }
                Reader.MoveToContent();
            }
            o.@UnhandledAttributes = (System.Xml.XmlAttribute[])ShrinkArray(a_3, ca_3, typeof(System.Xml.XmlAttribute), true);
            ReadEndElement();
            return o;
        }

        System.Xml.Schema.XmlSchemaAnyAttribute Read40_XmlSchemaAnyAttribute(bool isNullable, bool checkType) {
            if (isNullable && ReadNull()) return null;
            if (checkType) {
                System.Xml.XmlQualifiedName t = GetXsiType();
                if (t == null || ((object) ((System.Xml.XmlQualifiedName)t).Name == (object)id84_XmlSchemaAnyAttribute && (object) ((System.Xml.XmlQualifiedName)t).Namespace == (object)id56_httpwwww3org2001XMLSchema))
                    ;
                else
                    throw CreateUnknownTypeException((System.Xml.XmlQualifiedName)t);
            }
            System.Xml.Schema.XmlSchemaAnyAttribute o = new System.Xml.Schema.XmlSchemaAnyAttribute();
            System.Xml.XmlAttribute[] a_3 = null;
            int ca_3 = 0;
            bool[] paramsRead = new bool[6];
            while (Reader.MoveToNextAttribute()) {
                if (!paramsRead[1] && ((object) Reader.LocalName == (object)id128_id && (object) Reader.NamespaceURI == (object)id4_Item)) {
                    o.@Id = Reader.Value;
                    paramsRead[1] = true;
                }
                else if (!paramsRead[4] && ((object) Reader.LocalName == (object)id120_namespace && (object) Reader.NamespaceURI == (object)id4_Item)) {
                    o.@Namespace = Reader.Value;
                    paramsRead[4] = true;
                }
                else if (!paramsRead[5] && ((object) Reader.LocalName == (object)id171_processContents && (object) Reader.NamespaceURI == (object)id4_Item)) {
                    o.@ProcessContents = Read41_XmlSchemaContentProcessing(Reader.Value);
                    paramsRead[5] = true;
                }
                else if (IsXmlnsAttribute(Reader.Name)) {
                    if (o.@Namespaces == null) o.@Namespaces = new System.Xml.Serialization.XmlSerializerNamespaces();
                    o.@Namespaces.Add(Reader.Name.Length == 5 ? "" : Reader.LocalName, Reader.Value);
                }
                else {
                    System.Xml.XmlAttribute attr = (System.Xml.XmlAttribute) Document.ReadNode(Reader);
                    ParseWsdlArrayType(attr);
                    a_3 = (System.Xml.XmlAttribute[])EnsureArrayIndex(a_3, ca_3, typeof(System.Xml.XmlAttribute));a_3[ca_3++] = attr;
                }
            }
            o.@UnhandledAttributes = (System.Xml.XmlAttribute[])ShrinkArray(a_3, ca_3, typeof(System.Xml.XmlAttribute), true);
            Reader.MoveToElement();
            if (Reader.IsEmptyElement) {
                Reader.Skip();
                o.@UnhandledAttributes = (System.Xml.XmlAttribute[])ShrinkArray(a_3, ca_3, typeof(System.Xml.XmlAttribute), true);
                return o;
            }
            Reader.ReadStartElement();
            Reader.MoveToContent();
            while (Reader.NodeType != System.Xml.XmlNodeType.EndElement) {
                if (Reader.NodeType == System.Xml.XmlNodeType.Element) {
                    if (!paramsRead[2] && ((object) Reader.LocalName == (object)id138_annotation && (object) Reader.NamespaceURI == (object)id56_httpwwww3org2001XMLSchema)) {
                        o.@Annotation = Read15_XmlSchemaAnnotation(false, true);
                        paramsRead[2] = true;
                    }
                    else {
                        UnknownNode((object)o);
                    }
                }
                else {
                    UnknownNode((object)o);
                }
                Reader.MoveToContent();
            }
            o.@UnhandledAttributes = (System.Xml.XmlAttribute[])ShrinkArray(a_3, ca_3, typeof(System.Xml.XmlAttribute), true);
            ReadEndElement();
            return o;
        }

        System.Xml.Schema.XmlSchemaContentProcessing Read41_XmlSchemaContentProcessing(string s) {
            switch (s) {
                case @"skip": return System.Xml.Schema.XmlSchemaContentProcessing.@Skip;
                case @"lax": return System.Xml.Schema.XmlSchemaContentProcessing.@Lax;
                case @"strict": return System.Xml.Schema.XmlSchemaContentProcessing.@Strict;
                default: throw CreateUnknownConstantException(s, typeof(System.Xml.Schema.XmlSchemaContentProcessing));
            }
        }

        System.Xml.Schema.XmlSchemaComplexType Read42_XmlSchemaComplexType(bool isNullable, bool checkType) {
            if (isNullable && ReadNull()) return null;
            if (checkType) {
                System.Xml.XmlQualifiedName t = GetXsiType();
                if (t == null || ((object) ((System.Xml.XmlQualifiedName)t).Name == (object)id107_XmlSchemaComplexType && (object) ((System.Xml.XmlQualifiedName)t).Namespace == (object)id56_httpwwww3org2001XMLSchema))
                    ;
                else
                    throw CreateUnknownTypeException((System.Xml.XmlQualifiedName)t);
            }
            System.Xml.Schema.XmlSchemaComplexType o = new System.Xml.Schema.XmlSchemaComplexType();
            System.Xml.XmlAttribute[] a_3 = null;
            int ca_3 = 0;
            System.Xml.Schema.XmlSchemaObjectCollection a_11 = (System.Xml.Schema.XmlSchemaObjectCollection)o.@Attributes;
            bool[] paramsRead = new bool[13];
            while (Reader.MoveToNextAttribute()) {
                if (!paramsRead[1] && ((object) Reader.LocalName == (object)id128_id && (object) Reader.NamespaceURI == (object)id4_Item)) {
                    o.@Id = Reader.Value;
                    paramsRead[1] = true;
                }
                else if (!paramsRead[4] && ((object) Reader.LocalName == (object)id5_name && (object) Reader.NamespaceURI == (object)id4_Item)) {
                    o.@Name = Reader.Value;
                    paramsRead[4] = true;
                }
                else if (!paramsRead[5] && ((object) Reader.LocalName == (object)id140_final && (object) Reader.NamespaceURI == (object)id4_Item)) {
                    o.@Final = Read9_XmlSchemaDerivationMethod(Reader.Value);
                    paramsRead[5] = true;
                }
                else if (!paramsRead[6] && ((object) Reader.LocalName == (object)id172_abstract && (object) Reader.NamespaceURI == (object)id4_Item)) {
                    o.@IsAbstract = System.Xml.XmlConvert.ToBoolean(Reader.Value);
                    paramsRead[6] = true;
                }
                else if (!paramsRead[7] && ((object) Reader.LocalName == (object)id173_block && (object) Reader.NamespaceURI == (object)id4_Item)) {
                    o.@Block = Read9_XmlSchemaDerivationMethod(Reader.Value);
                    paramsRead[7] = true;
                }
                else if (!paramsRead[8] && ((object) Reader.LocalName == (object)id174_mixed && (object) Reader.NamespaceURI == (object)id4_Item)) {
                    o.@IsMixed = System.Xml.XmlConvert.ToBoolean(Reader.Value);
                    paramsRead[8] = true;
                }
                else if (IsXmlnsAttribute(Reader.Name)) {
                    if (o.@Namespaces == null) o.@Namespaces = new System.Xml.Serialization.XmlSerializerNamespaces();
                    o.@Namespaces.Add(Reader.Name.Length == 5 ? "" : Reader.LocalName, Reader.Value);
                }
                else {
                    System.Xml.XmlAttribute attr = (System.Xml.XmlAttribute) Document.ReadNode(Reader);
                    ParseWsdlArrayType(attr);
                    a_3 = (System.Xml.XmlAttribute[])EnsureArrayIndex(a_3, ca_3, typeof(System.Xml.XmlAttribute));a_3[ca_3++] = attr;
                }
            }
            o.@UnhandledAttributes = (System.Xml.XmlAttribute[])ShrinkArray(a_3, ca_3, typeof(System.Xml.XmlAttribute), true);
            Reader.MoveToElement();
            if (Reader.IsEmptyElement) {
                Reader.Skip();
                o.@UnhandledAttributes = (System.Xml.XmlAttribute[])ShrinkArray(a_3, ca_3, typeof(System.Xml.XmlAttribute), true);
                return o;
            }
            Reader.ReadStartElement();
            Reader.MoveToContent();
            while (Reader.NodeType != System.Xml.XmlNodeType.EndElement) {
                if (Reader.NodeType == System.Xml.XmlNodeType.Element) {
                    if (!paramsRead[2] && ((object) Reader.LocalName == (object)id138_annotation && (object) Reader.NamespaceURI == (object)id56_httpwwww3org2001XMLSchema)) {
                        o.@Annotation = Read15_XmlSchemaAnnotation(false, true);
                        paramsRead[2] = true;
                    }
                    else if (!paramsRead[9] && ((object) Reader.LocalName == (object)id175_complexContent && (object) Reader.NamespaceURI == (object)id56_httpwwww3org2001XMLSchema)) {
                        o.@ContentModel = Read43_XmlSchemaComplexContent(false, true);
                        paramsRead[9] = true;
                    }
                    else if (!paramsRead[9] && ((object) Reader.LocalName == (object)id176_simpleContent && (object) Reader.NamespaceURI == (object)id56_httpwwww3org2001XMLSchema)) {
                        o.@ContentModel = Read61_XmlSchemaSimpleContent(false, true);
                        paramsRead[9] = true;
                    }
                    else if (!paramsRead[10] && ((object) Reader.LocalName == (object)id177_sequence && (object) Reader.NamespaceURI == (object)id56_httpwwww3org2001XMLSchema)) {
                        o.@Particle = Read47_XmlSchemaSequence(false, true);
                        paramsRead[10] = true;
                    }
                    else if (!paramsRead[10] && ((object) Reader.LocalName == (object)id178_choice && (object) Reader.NamespaceURI == (object)id56_httpwwww3org2001XMLSchema)) {
                        o.@Particle = Read58_XmlSchemaChoice(false, true);
                        paramsRead[10] = true;
                    }
                    else if (!paramsRead[10] && ((object) Reader.LocalName == (object)id135_group && (object) Reader.NamespaceURI == (object)id56_httpwwww3org2001XMLSchema)) {
                        o.@Particle = Read57_XmlSchemaGroupRef(false, true);
                        paramsRead[10] = true;
                    }
                    else if (!paramsRead[10] && ((object) Reader.LocalName == (object)id179_all && (object) Reader.NamespaceURI == (object)id56_httpwwww3org2001XMLSchema)) {
                        o.@Particle = Read59_XmlSchemaAll(false, true);
                        paramsRead[10] = true;
                    }
                    else if (((object) Reader.LocalName == (object)id133_attribute && (object) Reader.NamespaceURI == (object)id56_httpwwww3org2001XMLSchema)) {
                        if ((object)(a_11) == null) Reader.Skip(); else a_11.Add(Read37_XmlSchemaAttribute(false, true));
                    }
                    else if (((object) Reader.LocalName == (object)id136_attributeGroup && (object) Reader.NamespaceURI == (object)id56_httpwwww3org2001XMLSchema)) {
                        if ((object)(a_11) == null) Reader.Skip(); else a_11.Add(Read39_XmlSchemaAttributeGroupRef(false, true));
                    }
                    else if (!paramsRead[12] && ((object) Reader.LocalName == (object)id165_anyAttribute && (object) Reader.NamespaceURI == (object)id56_httpwwww3org2001XMLSchema)) {
                        o.@AnyAttribute = Read40_XmlSchemaAnyAttribute(false, true);
                        paramsRead[12] = true;
                    }
                    else {
                        UnknownNode((object)o);
                    }
                }
                else {
                    UnknownNode((object)o);
                }
                Reader.MoveToContent();
            }
            o.@UnhandledAttributes = (System.Xml.XmlAttribute[])ShrinkArray(a_3, ca_3, typeof(System.Xml.XmlAttribute), true);
            ReadEndElement();
            return o;
        }

        System.Xml.Schema.XmlSchemaComplexContent Read43_XmlSchemaComplexContent(bool isNullable, bool checkType) {
            if (isNullable && ReadNull()) return null;
            if (checkType) {
                System.Xml.XmlQualifiedName t = GetXsiType();
                if (t == null || ((object) ((System.Xml.XmlQualifiedName)t).Name == (object)id83_XmlSchemaComplexContent && (object) ((System.Xml.XmlQualifiedName)t).Namespace == (object)id56_httpwwww3org2001XMLSchema))
                    ;
                else
                    throw CreateUnknownTypeException((System.Xml.XmlQualifiedName)t);
            }
            System.Xml.Schema.XmlSchemaComplexContent o = new System.Xml.Schema.XmlSchemaComplexContent();
            System.Xml.XmlAttribute[] a_3 = null;
            int ca_3 = 0;
            bool[] paramsRead = new bool[6];
            while (Reader.MoveToNextAttribute()) {
                if (!paramsRead[1] && ((object) Reader.LocalName == (object)id128_id && (object) Reader.NamespaceURI == (object)id4_Item)) {
                    o.@Id = Reader.Value;
                    paramsRead[1] = true;
                }
                else if (!paramsRead[4] && ((object) Reader.LocalName == (object)id174_mixed && (object) Reader.NamespaceURI == (object)id4_Item)) {
                    o.@IsMixed = System.Xml.XmlConvert.ToBoolean(Reader.Value);
                    paramsRead[4] = true;
                }
                else if (IsXmlnsAttribute(Reader.Name)) {
                    if (o.@Namespaces == null) o.@Namespaces = new System.Xml.Serialization.XmlSerializerNamespaces();
                    o.@Namespaces.Add(Reader.Name.Length == 5 ? "" : Reader.LocalName, Reader.Value);
                }
                else {
                    System.Xml.XmlAttribute attr = (System.Xml.XmlAttribute) Document.ReadNode(Reader);
                    ParseWsdlArrayType(attr);
                    a_3 = (System.Xml.XmlAttribute[])EnsureArrayIndex(a_3, ca_3, typeof(System.Xml.XmlAttribute));a_3[ca_3++] = attr;
                }
            }
            o.@UnhandledAttributes = (System.Xml.XmlAttribute[])ShrinkArray(a_3, ca_3, typeof(System.Xml.XmlAttribute), true);
            Reader.MoveToElement();
            if (Reader.IsEmptyElement) {
                Reader.Skip();
                o.@UnhandledAttributes = (System.Xml.XmlAttribute[])ShrinkArray(a_3, ca_3, typeof(System.Xml.XmlAttribute), true);
                return o;
            }
            Reader.ReadStartElement();
            Reader.MoveToContent();
            while (Reader.NodeType != System.Xml.XmlNodeType.EndElement) {
                if (Reader.NodeType == System.Xml.XmlNodeType.Element) {
                    if (!paramsRead[2] && ((object) Reader.LocalName == (object)id138_annotation && (object) Reader.NamespaceURI == (object)id56_httpwwww3org2001XMLSchema)) {
                        o.@Annotation = Read15_XmlSchemaAnnotation(false, true);
                        paramsRead[2] = true;
                    }
                    else if (!paramsRead[5] && ((object) Reader.LocalName == (object)id142_restriction && (object) Reader.NamespaceURI == (object)id56_httpwwww3org2001XMLSchema)) {
                        o.@Content = Read60_XmlSchemaComplexContentRestriction(false, true);
                        paramsRead[5] = true;
                    }
                    else if (!paramsRead[5] && ((object) Reader.LocalName == (object)id180_extension && (object) Reader.NamespaceURI == (object)id56_httpwwww3org2001XMLSchema)) {
                        o.@Content = Read45_XmlSchemaComplexContentExtension(false, true);
                        paramsRead[5] = true;
                    }
                    else {
                        UnknownNode((object)o);
                    }
                }
                else {
                    UnknownNode((object)o);
                }
                Reader.MoveToContent();
            }
            o.@UnhandledAttributes = (System.Xml.XmlAttribute[])ShrinkArray(a_3, ca_3, typeof(System.Xml.XmlAttribute), true);
            ReadEndElement();
            return o;
        }

        System.Xml.Schema.XmlSchemaContentModel Read44_XmlSchemaContentModel(bool isNullable, bool checkType) {
            if (isNullable && ReadNull()) return null;
            if (checkType) {
                System.Xml.XmlQualifiedName t = GetXsiType();
                if (t == null || ((object) ((System.Xml.XmlQualifiedName)t).Name == (object)id81_XmlSchemaContentModel && (object) ((System.Xml.XmlQualifiedName)t).Namespace == (object)id56_httpwwww3org2001XMLSchema))
                    ;
                else if (((object) ((System.Xml.XmlQualifiedName)t).Name == (object)id82_XmlSchemaSimpleContent && (object) ((System.Xml.XmlQualifiedName)t).Namespace == (object)id56_httpwwww3org2001XMLSchema))
                    return Read61_XmlSchemaSimpleContent(isNullable, false);
                else if (((object) ((System.Xml.XmlQualifiedName)t).Name == (object)id83_XmlSchemaComplexContent && (object) ((System.Xml.XmlQualifiedName)t).Namespace == (object)id56_httpwwww3org2001XMLSchema))
                    return Read43_XmlSchemaComplexContent(isNullable, false);
                else
                    throw CreateUnknownTypeException((System.Xml.XmlQualifiedName)t);
            }
            throw CreateAbstractTypeException(@"XmlSchemaContentModel", @"http://www.w3.org/2001/XMLSchema");
        }

        System.Xml.Schema.XmlSchemaComplexContentExtension Read45_XmlSchemaComplexContentExtension(bool isNullable, bool checkType) {
            if (isNullable && ReadNull()) return null;
            if (checkType) {
                System.Xml.XmlQualifiedName t = GetXsiType();
                if (t == null || ((object) ((System.Xml.XmlQualifiedName)t).Name == (object)id80_XmlSchemaComplexContentExtension && (object) ((System.Xml.XmlQualifiedName)t).Namespace == (object)id56_httpwwww3org2001XMLSchema))
                    ;
                else
                    throw CreateUnknownTypeException((System.Xml.XmlQualifiedName)t);
            }
            System.Xml.Schema.XmlSchemaComplexContentExtension o = new System.Xml.Schema.XmlSchemaComplexContentExtension();
            System.Xml.XmlAttribute[] a_3 = null;
            int ca_3 = 0;
            System.Xml.Schema.XmlSchemaObjectCollection a_6 = (System.Xml.Schema.XmlSchemaObjectCollection)o.@Attributes;
            bool[] paramsRead = new bool[8];
            while (Reader.MoveToNextAttribute()) {
                if (!paramsRead[1] && ((object) Reader.LocalName == (object)id128_id && (object) Reader.NamespaceURI == (object)id4_Item)) {
                    o.@Id = Reader.Value;
                    paramsRead[1] = true;
                }
                else if (!paramsRead[4] && ((object) Reader.LocalName == (object)id149_base && (object) Reader.NamespaceURI == (object)id4_Item)) {
                    o.@BaseTypeName = ToXmlQualifiedName(Reader.Value);
                    paramsRead[4] = true;
                }
                else if (IsXmlnsAttribute(Reader.Name)) {
                    if (o.@Namespaces == null) o.@Namespaces = new System.Xml.Serialization.XmlSerializerNamespaces();
                    o.@Namespaces.Add(Reader.Name.Length == 5 ? "" : Reader.LocalName, Reader.Value);
                }
                else {
                    System.Xml.XmlAttribute attr = (System.Xml.XmlAttribute) Document.ReadNode(Reader);
                    ParseWsdlArrayType(attr);
                    a_3 = (System.Xml.XmlAttribute[])EnsureArrayIndex(a_3, ca_3, typeof(System.Xml.XmlAttribute));a_3[ca_3++] = attr;
                }
            }
            o.@UnhandledAttributes = (System.Xml.XmlAttribute[])ShrinkArray(a_3, ca_3, typeof(System.Xml.XmlAttribute), true);
            Reader.MoveToElement();
            if (Reader.IsEmptyElement) {
                Reader.Skip();
                o.@UnhandledAttributes = (System.Xml.XmlAttribute[])ShrinkArray(a_3, ca_3, typeof(System.Xml.XmlAttribute), true);
                return o;
            }
            Reader.ReadStartElement();
            Reader.MoveToContent();
            while (Reader.NodeType != System.Xml.XmlNodeType.EndElement) {
                if (Reader.NodeType == System.Xml.XmlNodeType.Element) {
                    if (!paramsRead[2] && ((object) Reader.LocalName == (object)id138_annotation && (object) Reader.NamespaceURI == (object)id56_httpwwww3org2001XMLSchema)) {
                        o.@Annotation = Read15_XmlSchemaAnnotation(false, true);
                        paramsRead[2] = true;
                    }
                    else if (!paramsRead[5] && ((object) Reader.LocalName == (object)id177_sequence && (object) Reader.NamespaceURI == (object)id56_httpwwww3org2001XMLSchema)) {
                        o.@Particle = Read47_XmlSchemaSequence(false, true);
                        paramsRead[5] = true;
                    }
                    else if (!paramsRead[5] && ((object) Reader.LocalName == (object)id178_choice && (object) Reader.NamespaceURI == (object)id56_httpwwww3org2001XMLSchema)) {
                        o.@Particle = Read58_XmlSchemaChoice(false, true);
                        paramsRead[5] = true;
                    }
                    else if (!paramsRead[5] && ((object) Reader.LocalName == (object)id135_group && (object) Reader.NamespaceURI == (object)id56_httpwwww3org2001XMLSchema)) {
                        o.@Particle = Read57_XmlSchemaGroupRef(false, true);
                        paramsRead[5] = true;
                    }
                    else if (!paramsRead[5] && ((object) Reader.LocalName == (object)id179_all && (object) Reader.NamespaceURI == (object)id56_httpwwww3org2001XMLSchema)) {
                        o.@Particle = Read59_XmlSchemaAll(false, true);
                        paramsRead[5] = true;
                    }
                    else if (((object) Reader.LocalName == (object)id133_attribute && (object) Reader.NamespaceURI == (object)id56_httpwwww3org2001XMLSchema)) {
                        if ((object)(a_6) == null) Reader.Skip(); else a_6.Add(Read37_XmlSchemaAttribute(false, true));
                    }
                    else if (((object) Reader.LocalName == (object)id136_attributeGroup && (object) Reader.NamespaceURI == (object)id56_httpwwww3org2001XMLSchema)) {
                        if ((object)(a_6) == null) Reader.Skip(); else a_6.Add(Read39_XmlSchemaAttributeGroupRef(false, true));
                    }
                    else if (!paramsRead[7] && ((object) Reader.LocalName == (object)id165_anyAttribute && (object) Reader.NamespaceURI == (object)id56_httpwwww3org2001XMLSchema)) {
                        o.@AnyAttribute = Read40_XmlSchemaAnyAttribute(false, true);
                        paramsRead[7] = true;
                    }
                    else {
                        UnknownNode((object)o);
                    }
                }
                else {
                    UnknownNode((object)o);
                }
                Reader.MoveToContent();
            }
            o.@UnhandledAttributes = (System.Xml.XmlAttribute[])ShrinkArray(a_3, ca_3, typeof(System.Xml.XmlAttribute), true);
            ReadEndElement();
            return o;
        }

        System.Xml.Schema.XmlSchemaContent Read46_XmlSchemaContent(bool isNullable, bool checkType) {
            if (isNullable && ReadNull()) return null;
            if (checkType) {
                System.Xml.XmlQualifiedName t = GetXsiType();
                if (t == null || ((object) ((System.Xml.XmlQualifiedName)t).Name == (object)id76_XmlSchemaContent && (object) ((System.Xml.XmlQualifiedName)t).Namespace == (object)id56_httpwwww3org2001XMLSchema))
                    ;
                else if (((object) ((System.Xml.XmlQualifiedName)t).Name == (object)id77_XmlSchemaSimpleContentExtension && (object) ((System.Xml.XmlQualifiedName)t).Namespace == (object)id56_httpwwww3org2001XMLSchema))
                    return Read63_XmlSchemaSimpleContentExtension(isNullable, false);
                else if (((object) ((System.Xml.XmlQualifiedName)t).Name == (object)id78_XmlSchemaSimpleContentRestriction && (object) ((System.Xml.XmlQualifiedName)t).Namespace == (object)id56_httpwwww3org2001XMLSchema))
                    return Read62_XmlSchemaSimpleContentRestriction(isNullable, false);
                else if (((object) ((System.Xml.XmlQualifiedName)t).Name == (object)id79_XmlSchemaComplexContentRestriction && (object) ((System.Xml.XmlQualifiedName)t).Namespace == (object)id56_httpwwww3org2001XMLSchema))
                    return Read60_XmlSchemaComplexContentRestriction(isNullable, false);
                else if (((object) ((System.Xml.XmlQualifiedName)t).Name == (object)id80_XmlSchemaComplexContentExtension && (object) ((System.Xml.XmlQualifiedName)t).Namespace == (object)id56_httpwwww3org2001XMLSchema))
                    return Read45_XmlSchemaComplexContentExtension(isNullable, false);
                else
                    throw CreateUnknownTypeException((System.Xml.XmlQualifiedName)t);
            }
            throw CreateAbstractTypeException(@"XmlSchemaContent", @"http://www.w3.org/2001/XMLSchema");
        }

        System.Xml.Schema.XmlSchemaSequence Read47_XmlSchemaSequence(bool isNullable, bool checkType) {
            if (isNullable && ReadNull()) return null;
            if (checkType) {
                System.Xml.XmlQualifiedName t = GetXsiType();
                if (t == null || ((object) ((System.Xml.XmlQualifiedName)t).Name == (object)id75_XmlSchemaSequence && (object) ((System.Xml.XmlQualifiedName)t).Namespace == (object)id56_httpwwww3org2001XMLSchema))
                    ;
                else
                    throw CreateUnknownTypeException((System.Xml.XmlQualifiedName)t);
            }
            System.Xml.Schema.XmlSchemaSequence o = new System.Xml.Schema.XmlSchemaSequence();
            System.Xml.XmlAttribute[] a_3 = null;
            int ca_3 = 0;
            System.Xml.Schema.XmlSchemaObjectCollection a_6 = (System.Xml.Schema.XmlSchemaObjectCollection)o.@Items;
            bool[] paramsRead = new bool[7];
            while (Reader.MoveToNextAttribute()) {
                if (!paramsRead[1] && ((object) Reader.LocalName == (object)id128_id && (object) Reader.NamespaceURI == (object)id4_Item)) {
                    o.@Id = Reader.Value;
                    paramsRead[1] = true;
                }
                else if (!paramsRead[4] && ((object) Reader.LocalName == (object)id181_minOccurs && (object) Reader.NamespaceURI == (object)id4_Item)) {
                    o.@MinOccursString = Reader.Value;
                    paramsRead[4] = true;
                }
                else if (!paramsRead[5] && ((object) Reader.LocalName == (object)id182_maxOccurs && (object) Reader.NamespaceURI == (object)id4_Item)) {
                    o.@MaxOccursString = Reader.Value;
                    paramsRead[5] = true;
                }
                else if (IsXmlnsAttribute(Reader.Name)) {
                    if (o.@Namespaces == null) o.@Namespaces = new System.Xml.Serialization.XmlSerializerNamespaces();
                    o.@Namespaces.Add(Reader.Name.Length == 5 ? "" : Reader.LocalName, Reader.Value);
                }
                else {
                    System.Xml.XmlAttribute attr = (System.Xml.XmlAttribute) Document.ReadNode(Reader);
                    ParseWsdlArrayType(attr);
                    a_3 = (System.Xml.XmlAttribute[])EnsureArrayIndex(a_3, ca_3, typeof(System.Xml.XmlAttribute));a_3[ca_3++] = attr;
                }
            }
            o.@UnhandledAttributes = (System.Xml.XmlAttribute[])ShrinkArray(a_3, ca_3, typeof(System.Xml.XmlAttribute), true);
            Reader.MoveToElement();
            if (Reader.IsEmptyElement) {
                Reader.Skip();
                o.@UnhandledAttributes = (System.Xml.XmlAttribute[])ShrinkArray(a_3, ca_3, typeof(System.Xml.XmlAttribute), true);
                return o;
            }
            Reader.ReadStartElement();
            Reader.MoveToContent();
            while (Reader.NodeType != System.Xml.XmlNodeType.EndElement) {
                if (Reader.NodeType == System.Xml.XmlNodeType.Element) {
                    if (!paramsRead[2] && ((object) Reader.LocalName == (object)id138_annotation && (object) Reader.NamespaceURI == (object)id56_httpwwww3org2001XMLSchema)) {
                        o.@Annotation = Read15_XmlSchemaAnnotation(false, true);
                        paramsRead[2] = true;
                    }
                    else if (((object) Reader.LocalName == (object)id177_sequence && (object) Reader.NamespaceURI == (object)id56_httpwwww3org2001XMLSchema)) {
                        if ((object)(a_6) == null) Reader.Skip(); else a_6.Add(Read47_XmlSchemaSequence(false, true));
                    }
                    else if (((object) Reader.LocalName == (object)id178_choice && (object) Reader.NamespaceURI == (object)id56_httpwwww3org2001XMLSchema)) {
                        if ((object)(a_6) == null) Reader.Skip(); else a_6.Add(Read58_XmlSchemaChoice(false, true));
                    }
                    else if (((object) Reader.LocalName == (object)id135_group && (object) Reader.NamespaceURI == (object)id56_httpwwww3org2001XMLSchema)) {
                        if ((object)(a_6) == null) Reader.Skip(); else a_6.Add(Read57_XmlSchemaGroupRef(false, true));
                    }
                    else if (((object) Reader.LocalName == (object)id134_element && (object) Reader.NamespaceURI == (object)id56_httpwwww3org2001XMLSchema)) {
                        if ((object)(a_6) == null) Reader.Skip(); else a_6.Add(Read51_XmlSchemaElement(false, true));
                    }
                    else if (((object) Reader.LocalName == (object)id183_any && (object) Reader.NamespaceURI == (object)id56_httpwwww3org2001XMLSchema)) {
                        if ((object)(a_6) == null) Reader.Skip(); else a_6.Add(Read50_XmlSchemaAny(false, true));
                    }
                    else {
                        UnknownNode((object)o);
                    }
                }
                else {
                    UnknownNode((object)o);
                }
                Reader.MoveToContent();
            }
            o.@UnhandledAttributes = (System.Xml.XmlAttribute[])ShrinkArray(a_3, ca_3, typeof(System.Xml.XmlAttribute), true);
            ReadEndElement();
            return o;
        }

        System.Xml.Schema.XmlSchemaGroupBase Read48_XmlSchemaGroupBase(bool isNullable, bool checkType) {
            if (isNullable && ReadNull()) return null;
            if (checkType) {
                System.Xml.XmlQualifiedName t = GetXsiType();
                if (t == null || ((object) ((System.Xml.XmlQualifiedName)t).Name == (object)id72_XmlSchemaGroupBase && (object) ((System.Xml.XmlQualifiedName)t).Namespace == (object)id56_httpwwww3org2001XMLSchema))
                    ;
                else if (((object) ((System.Xml.XmlQualifiedName)t).Name == (object)id73_XmlSchemaAll && (object) ((System.Xml.XmlQualifiedName)t).Namespace == (object)id56_httpwwww3org2001XMLSchema))
                    return Read59_XmlSchemaAll(isNullable, false);
                else if (((object) ((System.Xml.XmlQualifiedName)t).Name == (object)id74_XmlSchemaChoice && (object) ((System.Xml.XmlQualifiedName)t).Namespace == (object)id56_httpwwww3org2001XMLSchema))
                    return Read58_XmlSchemaChoice(isNullable, false);
                else if (((object) ((System.Xml.XmlQualifiedName)t).Name == (object)id75_XmlSchemaSequence && (object) ((System.Xml.XmlQualifiedName)t).Namespace == (object)id56_httpwwww3org2001XMLSchema))
                    return Read47_XmlSchemaSequence(isNullable, false);
                else
                    throw CreateUnknownTypeException((System.Xml.XmlQualifiedName)t);
            }
            throw CreateAbstractTypeException(@"XmlSchemaGroupBase", @"http://www.w3.org/2001/XMLSchema");
        }

        System.Xml.Schema.XmlSchemaParticle Read49_XmlSchemaParticle(bool isNullable, bool checkType) {
            if (isNullable && ReadNull()) return null;
            if (checkType) {
                System.Xml.XmlQualifiedName t = GetXsiType();
                if (t == null || ((object) ((System.Xml.XmlQualifiedName)t).Name == (object)id68_XmlSchemaParticle && (object) ((System.Xml.XmlQualifiedName)t).Namespace == (object)id56_httpwwww3org2001XMLSchema))
                    ;
                else if (((object) ((System.Xml.XmlQualifiedName)t).Name == (object)id69_XmlSchemaGroupRef && (object) ((System.Xml.XmlQualifiedName)t).Namespace == (object)id56_httpwwww3org2001XMLSchema))
                    return Read57_XmlSchemaGroupRef(isNullable, false);
                else if (((object) ((System.Xml.XmlQualifiedName)t).Name == (object)id70_XmlSchemaElement && (object) ((System.Xml.XmlQualifiedName)t).Namespace == (object)id56_httpwwww3org2001XMLSchema))
                    return Read51_XmlSchemaElement(isNullable, false);
                else if (((object) ((System.Xml.XmlQualifiedName)t).Name == (object)id71_XmlSchemaAny && (object) ((System.Xml.XmlQualifiedName)t).Namespace == (object)id56_httpwwww3org2001XMLSchema))
                    return Read50_XmlSchemaAny(isNullable, false);
                else if (((object) ((System.Xml.XmlQualifiedName)t).Name == (object)id72_XmlSchemaGroupBase && (object) ((System.Xml.XmlQualifiedName)t).Namespace == (object)id56_httpwwww3org2001XMLSchema))
                    return Read48_XmlSchemaGroupBase(isNullable, false);
                else if (((object) ((System.Xml.XmlQualifiedName)t).Name == (object)id73_XmlSchemaAll && (object) ((System.Xml.XmlQualifiedName)t).Namespace == (object)id56_httpwwww3org2001XMLSchema))
                    return Read59_XmlSchemaAll(isNullable, false);
                else if (((object) ((System.Xml.XmlQualifiedName)t).Name == (object)id74_XmlSchemaChoice && (object) ((System.Xml.XmlQualifiedName)t).Namespace == (object)id56_httpwwww3org2001XMLSchema))
                    return Read58_XmlSchemaChoice(isNullable, false);
                else if (((object) ((System.Xml.XmlQualifiedName)t).Name == (object)id75_XmlSchemaSequence && (object) ((System.Xml.XmlQualifiedName)t).Namespace == (object)id56_httpwwww3org2001XMLSchema))
                    return Read47_XmlSchemaSequence(isNullable, false);
                else
                    throw CreateUnknownTypeException((System.Xml.XmlQualifiedName)t);
            }
            throw CreateAbstractTypeException(@"XmlSchemaParticle", @"http://www.w3.org/2001/XMLSchema");
        }

        System.Xml.Schema.XmlSchemaAny Read50_XmlSchemaAny(bool isNullable, bool checkType) {
            if (isNullable && ReadNull()) return null;
            if (checkType) {
                System.Xml.XmlQualifiedName t = GetXsiType();
                if (t == null || ((object) ((System.Xml.XmlQualifiedName)t).Name == (object)id71_XmlSchemaAny && (object) ((System.Xml.XmlQualifiedName)t).Namespace == (object)id56_httpwwww3org2001XMLSchema))
                    ;
                else
                    throw CreateUnknownTypeException((System.Xml.XmlQualifiedName)t);
            }
            System.Xml.Schema.XmlSchemaAny o = new System.Xml.Schema.XmlSchemaAny();
            System.Xml.XmlAttribute[] a_3 = null;
            int ca_3 = 0;
            bool[] paramsRead = new bool[8];
            while (Reader.MoveToNextAttribute()) {
                if (!paramsRead[1] && ((object) Reader.LocalName == (object)id128_id && (object) Reader.NamespaceURI == (object)id4_Item)) {
                    o.@Id = Reader.Value;
                    paramsRead[1] = true;
                }
                else if (!paramsRead[4] && ((object) Reader.LocalName == (object)id181_minOccurs && (object) Reader.NamespaceURI == (object)id4_Item)) {
                    o.@MinOccursString = Reader.Value;
                    paramsRead[4] = true;
                }
                else if (!paramsRead[5] && ((object) Reader.LocalName == (object)id182_maxOccurs && (object) Reader.NamespaceURI == (object)id4_Item)) {
                    o.@MaxOccursString = Reader.Value;
                    paramsRead[5] = true;
                }
                else if (!paramsRead[6] && ((object) Reader.LocalName == (object)id120_namespace && (object) Reader.NamespaceURI == (object)id4_Item)) {
                    o.@Namespace = Reader.Value;
                    paramsRead[6] = true;
                }
                else if (!paramsRead[7] && ((object) Reader.LocalName == (object)id171_processContents && (object) Reader.NamespaceURI == (object)id4_Item)) {
                    o.@ProcessContents = Read41_XmlSchemaContentProcessing(Reader.Value);
                    paramsRead[7] = true;
                }
                else if (IsXmlnsAttribute(Reader.Name)) {
                    if (o.@Namespaces == null) o.@Namespaces = new System.Xml.Serialization.XmlSerializerNamespaces();
                    o.@Namespaces.Add(Reader.Name.Length == 5 ? "" : Reader.LocalName, Reader.Value);
                }
                else {
                    System.Xml.XmlAttribute attr = (System.Xml.XmlAttribute) Document.ReadNode(Reader);
                    ParseWsdlArrayType(attr);
                    a_3 = (System.Xml.XmlAttribute[])EnsureArrayIndex(a_3, ca_3, typeof(System.Xml.XmlAttribute));a_3[ca_3++] = attr;
                }
            }
            o.@UnhandledAttributes = (System.Xml.XmlAttribute[])ShrinkArray(a_3, ca_3, typeof(System.Xml.XmlAttribute), true);
            Reader.MoveToElement();
            if (Reader.IsEmptyElement) {
                Reader.Skip();
                o.@UnhandledAttributes = (System.Xml.XmlAttribute[])ShrinkArray(a_3, ca_3, typeof(System.Xml.XmlAttribute), true);
                return o;
            }
            Reader.ReadStartElement();
            Reader.MoveToContent();
            while (Reader.NodeType != System.Xml.XmlNodeType.EndElement) {
                if (Reader.NodeType == System.Xml.XmlNodeType.Element) {
                    if (!paramsRead[2] && ((object) Reader.LocalName == (object)id138_annotation && (object) Reader.NamespaceURI == (object)id56_httpwwww3org2001XMLSchema)) {
                        o.@Annotation = Read15_XmlSchemaAnnotation(false, true);
                        paramsRead[2] = true;
                    }
                    else {
                        UnknownNode((object)o);
                    }
                }
                else {
                    UnknownNode((object)o);
                }
                Reader.MoveToContent();
            }
            o.@UnhandledAttributes = (System.Xml.XmlAttribute[])ShrinkArray(a_3, ca_3, typeof(System.Xml.XmlAttribute), true);
            ReadEndElement();
            return o;
        }

        System.Xml.Schema.XmlSchemaElement Read51_XmlSchemaElement(bool isNullable, bool checkType) {
            if (isNullable && ReadNull()) return null;
            if (checkType) {
                System.Xml.XmlQualifiedName t = GetXsiType();
                if (t == null || ((object) ((System.Xml.XmlQualifiedName)t).Name == (object)id70_XmlSchemaElement && (object) ((System.Xml.XmlQualifiedName)t).Namespace == (object)id56_httpwwww3org2001XMLSchema))
                    ;
                else
                    throw CreateUnknownTypeException((System.Xml.XmlQualifiedName)t);
            }
            System.Xml.Schema.XmlSchemaElement o = new System.Xml.Schema.XmlSchemaElement();
            System.Xml.XmlAttribute[] a_3 = null;
            int ca_3 = 0;
            System.Xml.Schema.XmlSchemaObjectCollection a_18 = (System.Xml.Schema.XmlSchemaObjectCollection)o.@Constraints;
            bool[] paramsRead = new bool[19];
            while (Reader.MoveToNextAttribute()) {
                if (!paramsRead[1] && ((object) Reader.LocalName == (object)id128_id && (object) Reader.NamespaceURI == (object)id4_Item)) {
                    o.@Id = Reader.Value;
                    paramsRead[1] = true;
                }
                else if (!paramsRead[4] && ((object) Reader.LocalName == (object)id181_minOccurs && (object) Reader.NamespaceURI == (object)id4_Item)) {
                    o.@MinOccursString = Reader.Value;
                    paramsRead[4] = true;
                }
                else if (!paramsRead[5] && ((object) Reader.LocalName == (object)id182_maxOccurs && (object) Reader.NamespaceURI == (object)id4_Item)) {
                    o.@MaxOccursString = Reader.Value;
                    paramsRead[5] = true;
                }
                else if (!paramsRead[6] && ((object) Reader.LocalName == (object)id172_abstract && (object) Reader.NamespaceURI == (object)id4_Item)) {
                    o.@IsAbstract = System.Xml.XmlConvert.ToBoolean(Reader.Value);
                    paramsRead[6] = true;
                }
                else if (!paramsRead[7] && ((object) Reader.LocalName == (object)id173_block && (object) Reader.NamespaceURI == (object)id4_Item)) {
                    o.@Block = Read9_XmlSchemaDerivationMethod(Reader.Value);
                    paramsRead[7] = true;
                }
                else if (!paramsRead[8] && ((object) Reader.LocalName == (object)id166_default && (object) Reader.NamespaceURI == (object)id4_Item)) {
                    o.@DefaultValue = Reader.Value;
                    paramsRead[8] = true;
                }
                else if (!paramsRead[9] && ((object) Reader.LocalName == (object)id140_final && (object) Reader.NamespaceURI == (object)id4_Item)) {
                    o.@Final = Read9_XmlSchemaDerivationMethod(Reader.Value);
                    paramsRead[9] = true;
                }
                else if (!paramsRead[10] && ((object) Reader.LocalName == (object)id163_fixed && (object) Reader.NamespaceURI == (object)id4_Item)) {
                    o.@FixedValue = Reader.Value;
                    paramsRead[10] = true;
                }
                else if (!paramsRead[11] && ((object) Reader.LocalName == (object)id167_form && (object) Reader.NamespaceURI == (object)id4_Item)) {
                    o.@Form = Read8_XmlSchemaForm(Reader.Value);
                    paramsRead[11] = true;
                }
                else if (!paramsRead[12] && ((object) Reader.LocalName == (object)id5_name && (object) Reader.NamespaceURI == (object)id4_Item)) {
                    o.@Name = Reader.Value;
                    paramsRead[12] = true;
                }
                else if (!paramsRead[13] && ((object) Reader.LocalName == (object)id184_nillable && (object) Reader.NamespaceURI == (object)id4_Item)) {
                    o.@IsNillable = System.Xml.XmlConvert.ToBoolean(Reader.Value);
                    paramsRead[13] = true;
                }
                else if (!paramsRead[14] && ((object) Reader.LocalName == (object)id168_ref && (object) Reader.NamespaceURI == (object)id4_Item)) {
                    o.@RefName = ToXmlQualifiedName(Reader.Value);
                    paramsRead[14] = true;
                }
                else if (!paramsRead[15] && ((object) Reader.LocalName == (object)id185_substitutionGroup && (object) Reader.NamespaceURI == (object)id4_Item)) {
                    o.@SubstitutionGroup = ToXmlQualifiedName(Reader.Value);
                    paramsRead[15] = true;
                }
                else if (!paramsRead[16] && ((object) Reader.LocalName == (object)id169_type && (object) Reader.NamespaceURI == (object)id4_Item)) {
                    o.@SchemaTypeName = ToXmlQualifiedName(Reader.Value);
                    paramsRead[16] = true;
                }
                else if (IsXmlnsAttribute(Reader.Name)) {
                    if (o.@Namespaces == null) o.@Namespaces = new System.Xml.Serialization.XmlSerializerNamespaces();
                    o.@Namespaces.Add(Reader.Name.Length == 5 ? "" : Reader.LocalName, Reader.Value);
                }
                else {
                    System.Xml.XmlAttribute attr = (System.Xml.XmlAttribute) Document.ReadNode(Reader);
                    ParseWsdlArrayType(attr);
                    a_3 = (System.Xml.XmlAttribute[])EnsureArrayIndex(a_3, ca_3, typeof(System.Xml.XmlAttribute));a_3[ca_3++] = attr;
                }
            }
            o.@UnhandledAttributes = (System.Xml.XmlAttribute[])ShrinkArray(a_3, ca_3, typeof(System.Xml.XmlAttribute), true);
            Reader.MoveToElement();
            if (Reader.IsEmptyElement) {
                Reader.Skip();
                o.@UnhandledAttributes = (System.Xml.XmlAttribute[])ShrinkArray(a_3, ca_3, typeof(System.Xml.XmlAttribute), true);
                return o;
            }
            Reader.ReadStartElement();
            Reader.MoveToContent();
            while (Reader.NodeType != System.Xml.XmlNodeType.EndElement) {
                if (Reader.NodeType == System.Xml.XmlNodeType.Element) {
                    if (!paramsRead[2] && ((object) Reader.LocalName == (object)id138_annotation && (object) Reader.NamespaceURI == (object)id56_httpwwww3org2001XMLSchema)) {
                        o.@Annotation = Read15_XmlSchemaAnnotation(false, true);
                        paramsRead[2] = true;
                    }
                    else if (!paramsRead[17] && ((object) Reader.LocalName == (object)id137_complexType && (object) Reader.NamespaceURI == (object)id56_httpwwww3org2001XMLSchema)) {
                        o.@SchemaType = Read42_XmlSchemaComplexType(false, true);
                        paramsRead[17] = true;
                    }
                    else if (!paramsRead[17] && ((object) Reader.LocalName == (object)id131_simpleType && (object) Reader.NamespaceURI == (object)id56_httpwwww3org2001XMLSchema)) {
                        o.@SchemaType = Read12_XmlSchemaSimpleType(false, true);
                        paramsRead[17] = true;
                    }
                    else if (((object) Reader.LocalName == (object)id186_keyref && (object) Reader.NamespaceURI == (object)id56_httpwwww3org2001XMLSchema)) {
                        if ((object)(a_18) == null) Reader.Skip(); else a_18.Add(Read52_XmlSchemaKeyref(false, true));
                    }
                    else if (((object) Reader.LocalName == (object)id187_unique && (object) Reader.NamespaceURI == (object)id56_httpwwww3org2001XMLSchema)) {
                        if ((object)(a_18) == null) Reader.Skip(); else a_18.Add(Read55_XmlSchemaUnique(false, true));
                    }
                    else if (((object) Reader.LocalName == (object)id188_key && (object) Reader.NamespaceURI == (object)id56_httpwwww3org2001XMLSchema)) {
                        if ((object)(a_18) == null) Reader.Skip(); else a_18.Add(Read56_XmlSchemaKey(false, true));
                    }
                    else {
                        UnknownNode((object)o);
                    }
                }
                else {
                    UnknownNode((object)o);
                }
                Reader.MoveToContent();
            }
            o.@UnhandledAttributes = (System.Xml.XmlAttribute[])ShrinkArray(a_3, ca_3, typeof(System.Xml.XmlAttribute), true);
            ReadEndElement();
            return o;
        }

        System.Xml.Schema.XmlSchemaKeyref Read52_XmlSchemaKeyref(bool isNullable, bool checkType) {
            if (isNullable && ReadNull()) return null;
            if (checkType) {
                System.Xml.XmlQualifiedName t = GetXsiType();
                if (t == null || ((object) ((System.Xml.XmlQualifiedName)t).Name == (object)id67_XmlSchemaKeyref && (object) ((System.Xml.XmlQualifiedName)t).Namespace == (object)id56_httpwwww3org2001XMLSchema))
                    ;
                else
                    throw CreateUnknownTypeException((System.Xml.XmlQualifiedName)t);
            }
            System.Xml.Schema.XmlSchemaKeyref o = new System.Xml.Schema.XmlSchemaKeyref();
            System.Xml.XmlAttribute[] a_3 = null;
            int ca_3 = 0;
            System.Xml.Schema.XmlSchemaObjectCollection a_6 = (System.Xml.Schema.XmlSchemaObjectCollection)o.@Fields;
            bool[] paramsRead = new bool[8];
            while (Reader.MoveToNextAttribute()) {
                if (!paramsRead[1] && ((object) Reader.LocalName == (object)id128_id && (object) Reader.NamespaceURI == (object)id4_Item)) {
                    o.@Id = Reader.Value;
                    paramsRead[1] = true;
                }
                else if (!paramsRead[4] && ((object) Reader.LocalName == (object)id5_name && (object) Reader.NamespaceURI == (object)id4_Item)) {
                    o.@Name = Reader.Value;
                    paramsRead[4] = true;
                }
                else if (!paramsRead[7] && ((object) Reader.LocalName == (object)id189_refer && (object) Reader.NamespaceURI == (object)id4_Item)) {
                    o.@Refer = ToXmlQualifiedName(Reader.Value);
                    paramsRead[7] = true;
                }
                else if (IsXmlnsAttribute(Reader.Name)) {
                    if (o.@Namespaces == null) o.@Namespaces = new System.Xml.Serialization.XmlSerializerNamespaces();
                    o.@Namespaces.Add(Reader.Name.Length == 5 ? "" : Reader.LocalName, Reader.Value);
                }
                else {
                    System.Xml.XmlAttribute attr = (System.Xml.XmlAttribute) Document.ReadNode(Reader);
                    ParseWsdlArrayType(attr);
                    a_3 = (System.Xml.XmlAttribute[])EnsureArrayIndex(a_3, ca_3, typeof(System.Xml.XmlAttribute));a_3[ca_3++] = attr;
                }
            }
            o.@UnhandledAttributes = (System.Xml.XmlAttribute[])ShrinkArray(a_3, ca_3, typeof(System.Xml.XmlAttribute), true);
            Reader.MoveToElement();
            if (Reader.IsEmptyElement) {
                Reader.Skip();
                o.@UnhandledAttributes = (System.Xml.XmlAttribute[])ShrinkArray(a_3, ca_3, typeof(System.Xml.XmlAttribute), true);
                return o;
            }
            Reader.ReadStartElement();
            Reader.MoveToContent();
            while (Reader.NodeType != System.Xml.XmlNodeType.EndElement) {
                if (Reader.NodeType == System.Xml.XmlNodeType.Element) {
                    if (!paramsRead[2] && ((object) Reader.LocalName == (object)id138_annotation && (object) Reader.NamespaceURI == (object)id56_httpwwww3org2001XMLSchema)) {
                        o.@Annotation = Read15_XmlSchemaAnnotation(false, true);
                        paramsRead[2] = true;
                    }
                    else if (!paramsRead[5] && ((object) Reader.LocalName == (object)id190_selector && (object) Reader.NamespaceURI == (object)id56_httpwwww3org2001XMLSchema)) {
                        o.@Selector = Read54_XmlSchemaXPath(false, true);
                        paramsRead[5] = true;
                    }
                    else if (((object) Reader.LocalName == (object)id191_field && (object) Reader.NamespaceURI == (object)id56_httpwwww3org2001XMLSchema)) {
                        if ((object)(a_6) == null) Reader.Skip(); else a_6.Add(Read54_XmlSchemaXPath(false, true));
                    }
                    else {
                        UnknownNode((object)o);
                    }
                }
                else {
                    UnknownNode((object)o);
                }
                Reader.MoveToContent();
            }
            o.@UnhandledAttributes = (System.Xml.XmlAttribute[])ShrinkArray(a_3, ca_3, typeof(System.Xml.XmlAttribute), true);
            ReadEndElement();
            return o;
        }

        System.Xml.Schema.XmlSchemaIdentityConstraint Read53_XmlSchemaIdentityConstraint(bool isNullable, bool checkType) {
            if (isNullable && ReadNull()) return null;
            if (checkType) {
                System.Xml.XmlQualifiedName t = GetXsiType();
                if (t == null || ((object) ((System.Xml.XmlQualifiedName)t).Name == (object)id64_XmlSchemaIdentityConstraint && (object) ((System.Xml.XmlQualifiedName)t).Namespace == (object)id56_httpwwww3org2001XMLSchema))
                    ;
                else if (((object) ((System.Xml.XmlQualifiedName)t).Name == (object)id65_XmlSchemaKey && (object) ((System.Xml.XmlQualifiedName)t).Namespace == (object)id56_httpwwww3org2001XMLSchema))
                    return Read56_XmlSchemaKey(isNullable, false);
                else if (((object) ((System.Xml.XmlQualifiedName)t).Name == (object)id66_XmlSchemaUnique && (object) ((System.Xml.XmlQualifiedName)t).Namespace == (object)id56_httpwwww3org2001XMLSchema))
                    return Read55_XmlSchemaUnique(isNullable, false);
                else if (((object) ((System.Xml.XmlQualifiedName)t).Name == (object)id67_XmlSchemaKeyref && (object) ((System.Xml.XmlQualifiedName)t).Namespace == (object)id56_httpwwww3org2001XMLSchema))
                    return Read52_XmlSchemaKeyref(isNullable, false);
                else
                    throw CreateUnknownTypeException((System.Xml.XmlQualifiedName)t);
            }
            System.Xml.Schema.XmlSchemaIdentityConstraint o = new System.Xml.Schema.XmlSchemaIdentityConstraint();
            System.Xml.XmlAttribute[] a_3 = null;
            int ca_3 = 0;
            System.Xml.Schema.XmlSchemaObjectCollection a_6 = (System.Xml.Schema.XmlSchemaObjectCollection)o.@Fields;
            bool[] paramsRead = new bool[7];
            while (Reader.MoveToNextAttribute()) {
                if (!paramsRead[1] && ((object) Reader.LocalName == (object)id128_id && (object) Reader.NamespaceURI == (object)id4_Item)) {
                    o.@Id = Reader.Value;
                    paramsRead[1] = true;
                }
                else if (!paramsRead[4] && ((object) Reader.LocalName == (object)id5_name && (object) Reader.NamespaceURI == (object)id4_Item)) {
                    o.@Name = Reader.Value;
                    paramsRead[4] = true;
                }
                else if (IsXmlnsAttribute(Reader.Name)) {
                    if (o.@Namespaces == null) o.@Namespaces = new System.Xml.Serialization.XmlSerializerNamespaces();
                    o.@Namespaces.Add(Reader.Name.Length == 5 ? "" : Reader.LocalName, Reader.Value);
                }
                else {
                    System.Xml.XmlAttribute attr = (System.Xml.XmlAttribute) Document.ReadNode(Reader);
                    ParseWsdlArrayType(attr);
                    a_3 = (System.Xml.XmlAttribute[])EnsureArrayIndex(a_3, ca_3, typeof(System.Xml.XmlAttribute));a_3[ca_3++] = attr;
                }
            }
            o.@UnhandledAttributes = (System.Xml.XmlAttribute[])ShrinkArray(a_3, ca_3, typeof(System.Xml.XmlAttribute), true);
            Reader.MoveToElement();
            if (Reader.IsEmptyElement) {
                Reader.Skip();
                o.@UnhandledAttributes = (System.Xml.XmlAttribute[])ShrinkArray(a_3, ca_3, typeof(System.Xml.XmlAttribute), true);
                return o;
            }
            Reader.ReadStartElement();
            Reader.MoveToContent();
            while (Reader.NodeType != System.Xml.XmlNodeType.EndElement) {
                if (Reader.NodeType == System.Xml.XmlNodeType.Element) {
                    if (!paramsRead[2] && ((object) Reader.LocalName == (object)id138_annotation && (object) Reader.NamespaceURI == (object)id56_httpwwww3org2001XMLSchema)) {
                        o.@Annotation = Read15_XmlSchemaAnnotation(false, true);
                        paramsRead[2] = true;
                    }
                    else if (!paramsRead[5] && ((object) Reader.LocalName == (object)id190_selector && (object) Reader.NamespaceURI == (object)id56_httpwwww3org2001XMLSchema)) {
                        o.@Selector = Read54_XmlSchemaXPath(false, true);
                        paramsRead[5] = true;
                    }
                    else if (((object) Reader.LocalName == (object)id191_field && (object) Reader.NamespaceURI == (object)id56_httpwwww3org2001XMLSchema)) {
                        if ((object)(a_6) == null) Reader.Skip(); else a_6.Add(Read54_XmlSchemaXPath(false, true));
                    }
                    else {
                        UnknownNode((object)o);
                    }
                }
                else {
                    UnknownNode((object)o);
                }
                Reader.MoveToContent();
            }
            o.@UnhandledAttributes = (System.Xml.XmlAttribute[])ShrinkArray(a_3, ca_3, typeof(System.Xml.XmlAttribute), true);
            ReadEndElement();
            return o;
        }

        System.Xml.Schema.XmlSchemaXPath Read54_XmlSchemaXPath(bool isNullable, bool checkType) {
            if (isNullable && ReadNull()) return null;
            if (checkType) {
                System.Xml.XmlQualifiedName t = GetXsiType();
                if (t == null || ((object) ((System.Xml.XmlQualifiedName)t).Name == (object)id63_XmlSchemaXPath && (object) ((System.Xml.XmlQualifiedName)t).Namespace == (object)id56_httpwwww3org2001XMLSchema))
                    ;
                else
                    throw CreateUnknownTypeException((System.Xml.XmlQualifiedName)t);
            }
            System.Xml.Schema.XmlSchemaXPath o = new System.Xml.Schema.XmlSchemaXPath();
            System.Xml.XmlAttribute[] a_3 = null;
            int ca_3 = 0;
            bool[] paramsRead = new bool[5];
            while (Reader.MoveToNextAttribute()) {
                if (!paramsRead[1] && ((object) Reader.LocalName == (object)id128_id && (object) Reader.NamespaceURI == (object)id4_Item)) {
                    o.@Id = Reader.Value;
                    paramsRead[1] = true;
                }
                else if (!paramsRead[4] && ((object) Reader.LocalName == (object)id192_xpath && (object) Reader.NamespaceURI == (object)id4_Item)) {
                    o.@XPath = Reader.Value;
                    paramsRead[4] = true;
                }
                else if (IsXmlnsAttribute(Reader.Name)) {
                    if (o.@Namespaces == null) o.@Namespaces = new System.Xml.Serialization.XmlSerializerNamespaces();
                    o.@Namespaces.Add(Reader.Name.Length == 5 ? "" : Reader.LocalName, Reader.Value);
                }
                else {
                    System.Xml.XmlAttribute attr = (System.Xml.XmlAttribute) Document.ReadNode(Reader);
                    ParseWsdlArrayType(attr);
                    a_3 = (System.Xml.XmlAttribute[])EnsureArrayIndex(a_3, ca_3, typeof(System.Xml.XmlAttribute));a_3[ca_3++] = attr;
                }
            }
            o.@UnhandledAttributes = (System.Xml.XmlAttribute[])ShrinkArray(a_3, ca_3, typeof(System.Xml.XmlAttribute), true);
            Reader.MoveToElement();
            if (Reader.IsEmptyElement) {
                Reader.Skip();
                o.@UnhandledAttributes = (System.Xml.XmlAttribute[])ShrinkArray(a_3, ca_3, typeof(System.Xml.XmlAttribute), true);
                return o;
            }
            Reader.ReadStartElement();
            Reader.MoveToContent();
            while (Reader.NodeType != System.Xml.XmlNodeType.EndElement) {
                if (Reader.NodeType == System.Xml.XmlNodeType.Element) {
                    if (!paramsRead[2] && ((object) Reader.LocalName == (object)id138_annotation && (object) Reader.NamespaceURI == (object)id56_httpwwww3org2001XMLSchema)) {
                        o.@Annotation = Read15_XmlSchemaAnnotation(false, true);
                        paramsRead[2] = true;
                    }
                    else {
                        UnknownNode((object)o);
                    }
                }
                else {
                    UnknownNode((object)o);
                }
                Reader.MoveToContent();
            }
            o.@UnhandledAttributes = (System.Xml.XmlAttribute[])ShrinkArray(a_3, ca_3, typeof(System.Xml.XmlAttribute), true);
            ReadEndElement();
            return o;
        }

        System.Xml.Schema.XmlSchemaUnique Read55_XmlSchemaUnique(bool isNullable, bool checkType) {
            if (isNullable && ReadNull()) return null;
            if (checkType) {
                System.Xml.XmlQualifiedName t = GetXsiType();
                if (t == null || ((object) ((System.Xml.XmlQualifiedName)t).Name == (object)id66_XmlSchemaUnique && (object) ((System.Xml.XmlQualifiedName)t).Namespace == (object)id56_httpwwww3org2001XMLSchema))
                    ;
                else
                    throw CreateUnknownTypeException((System.Xml.XmlQualifiedName)t);
            }
            System.Xml.Schema.XmlSchemaUnique o = new System.Xml.Schema.XmlSchemaUnique();
            System.Xml.XmlAttribute[] a_3 = null;
            int ca_3 = 0;
            System.Xml.Schema.XmlSchemaObjectCollection a_6 = (System.Xml.Schema.XmlSchemaObjectCollection)o.@Fields;
            bool[] paramsRead = new bool[7];
            while (Reader.MoveToNextAttribute()) {
                if (!paramsRead[1] && ((object) Reader.LocalName == (object)id128_id && (object) Reader.NamespaceURI == (object)id4_Item)) {
                    o.@Id = Reader.Value;
                    paramsRead[1] = true;
                }
                else if (!paramsRead[4] && ((object) Reader.LocalName == (object)id5_name && (object) Reader.NamespaceURI == (object)id4_Item)) {
                    o.@Name = Reader.Value;
                    paramsRead[4] = true;
                }
                else if (IsXmlnsAttribute(Reader.Name)) {
                    if (o.@Namespaces == null) o.@Namespaces = new System.Xml.Serialization.XmlSerializerNamespaces();
                    o.@Namespaces.Add(Reader.Name.Length == 5 ? "" : Reader.LocalName, Reader.Value);
                }
                else {
                    System.Xml.XmlAttribute attr = (System.Xml.XmlAttribute) Document.ReadNode(Reader);
                    ParseWsdlArrayType(attr);
                    a_3 = (System.Xml.XmlAttribute[])EnsureArrayIndex(a_3, ca_3, typeof(System.Xml.XmlAttribute));a_3[ca_3++] = attr;
                }
            }
            o.@UnhandledAttributes = (System.Xml.XmlAttribute[])ShrinkArray(a_3, ca_3, typeof(System.Xml.XmlAttribute), true);
            Reader.MoveToElement();
            if (Reader.IsEmptyElement) {
                Reader.Skip();
                o.@UnhandledAttributes = (System.Xml.XmlAttribute[])ShrinkArray(a_3, ca_3, typeof(System.Xml.XmlAttribute), true);
                return o;
            }
            Reader.ReadStartElement();
            Reader.MoveToContent();
            while (Reader.NodeType != System.Xml.XmlNodeType.EndElement) {
                if (Reader.NodeType == System.Xml.XmlNodeType.Element) {
                    if (!paramsRead[2] && ((object) Reader.LocalName == (object)id138_annotation && (object) Reader.NamespaceURI == (object)id56_httpwwww3org2001XMLSchema)) {
                        o.@Annotation = Read15_XmlSchemaAnnotation(false, true);
                        paramsRead[2] = true;
                    }
                    else if (!paramsRead[5] && ((object) Reader.LocalName == (object)id190_selector && (object) Reader.NamespaceURI == (object)id56_httpwwww3org2001XMLSchema)) {
                        o.@Selector = Read54_XmlSchemaXPath(false, true);
                        paramsRead[5] = true;
                    }
                    else if (((object) Reader.LocalName == (object)id191_field && (object) Reader.NamespaceURI == (object)id56_httpwwww3org2001XMLSchema)) {
                        if ((object)(a_6) == null) Reader.Skip(); else a_6.Add(Read54_XmlSchemaXPath(false, true));
                    }
                    else {
                        UnknownNode((object)o);
                    }
                }
                else {
                    UnknownNode((object)o);
                }
                Reader.MoveToContent();
            }
            o.@UnhandledAttributes = (System.Xml.XmlAttribute[])ShrinkArray(a_3, ca_3, typeof(System.Xml.XmlAttribute), true);
            ReadEndElement();
            return o;
        }

        System.Xml.Schema.XmlSchemaKey Read56_XmlSchemaKey(bool isNullable, bool checkType) {
            if (isNullable && ReadNull()) return null;
            if (checkType) {
                System.Xml.XmlQualifiedName t = GetXsiType();
                if (t == null || ((object) ((System.Xml.XmlQualifiedName)t).Name == (object)id65_XmlSchemaKey && (object) ((System.Xml.XmlQualifiedName)t).Namespace == (object)id56_httpwwww3org2001XMLSchema))
                    ;
                else
                    throw CreateUnknownTypeException((System.Xml.XmlQualifiedName)t);
            }
            System.Xml.Schema.XmlSchemaKey o = new System.Xml.Schema.XmlSchemaKey();
            System.Xml.XmlAttribute[] a_3 = null;
            int ca_3 = 0;
            System.Xml.Schema.XmlSchemaObjectCollection a_6 = (System.Xml.Schema.XmlSchemaObjectCollection)o.@Fields;
            bool[] paramsRead = new bool[7];
            while (Reader.MoveToNextAttribute()) {
                if (!paramsRead[1] && ((object) Reader.LocalName == (object)id128_id && (object) Reader.NamespaceURI == (object)id4_Item)) {
                    o.@Id = Reader.Value;
                    paramsRead[1] = true;
                }
                else if (!paramsRead[4] && ((object) Reader.LocalName == (object)id5_name && (object) Reader.NamespaceURI == (object)id4_Item)) {
                    o.@Name = Reader.Value;
                    paramsRead[4] = true;
                }
                else if (IsXmlnsAttribute(Reader.Name)) {
                    if (o.@Namespaces == null) o.@Namespaces = new System.Xml.Serialization.XmlSerializerNamespaces();
                    o.@Namespaces.Add(Reader.Name.Length == 5 ? "" : Reader.LocalName, Reader.Value);
                }
                else {
                    System.Xml.XmlAttribute attr = (System.Xml.XmlAttribute) Document.ReadNode(Reader);
                    ParseWsdlArrayType(attr);
                    a_3 = (System.Xml.XmlAttribute[])EnsureArrayIndex(a_3, ca_3, typeof(System.Xml.XmlAttribute));a_3[ca_3++] = attr;
                }
            }
            o.@UnhandledAttributes = (System.Xml.XmlAttribute[])ShrinkArray(a_3, ca_3, typeof(System.Xml.XmlAttribute), true);
            Reader.MoveToElement();
            if (Reader.IsEmptyElement) {
                Reader.Skip();
                o.@UnhandledAttributes = (System.Xml.XmlAttribute[])ShrinkArray(a_3, ca_3, typeof(System.Xml.XmlAttribute), true);
                return o;
            }
            Reader.ReadStartElement();
            Reader.MoveToContent();
            while (Reader.NodeType != System.Xml.XmlNodeType.EndElement) {
                if (Reader.NodeType == System.Xml.XmlNodeType.Element) {
                    if (!paramsRead[2] && ((object) Reader.LocalName == (object)id138_annotation && (object) Reader.NamespaceURI == (object)id56_httpwwww3org2001XMLSchema)) {
                        o.@Annotation = Read15_XmlSchemaAnnotation(false, true);
                        paramsRead[2] = true;
                    }
                    else if (!paramsRead[5] && ((object) Reader.LocalName == (object)id190_selector && (object) Reader.NamespaceURI == (object)id56_httpwwww3org2001XMLSchema)) {
                        o.@Selector = Read54_XmlSchemaXPath(false, true);
                        paramsRead[5] = true;
                    }
                    else if (((object) Reader.LocalName == (object)id191_field && (object) Reader.NamespaceURI == (object)id56_httpwwww3org2001XMLSchema)) {
                        if ((object)(a_6) == null) Reader.Skip(); else a_6.Add(Read54_XmlSchemaXPath(false, true));
                    }
                    else {
                        UnknownNode((object)o);
                    }
                }
                else {
                    UnknownNode((object)o);
                }
                Reader.MoveToContent();
            }
            o.@UnhandledAttributes = (System.Xml.XmlAttribute[])ShrinkArray(a_3, ca_3, typeof(System.Xml.XmlAttribute), true);
            ReadEndElement();
            return o;
        }

        System.Xml.Schema.XmlSchemaGroupRef Read57_XmlSchemaGroupRef(bool isNullable, bool checkType) {
            if (isNullable && ReadNull()) return null;
            if (checkType) {
                System.Xml.XmlQualifiedName t = GetXsiType();
                if (t == null || ((object) ((System.Xml.XmlQualifiedName)t).Name == (object)id69_XmlSchemaGroupRef && (object) ((System.Xml.XmlQualifiedName)t).Namespace == (object)id56_httpwwww3org2001XMLSchema))
                    ;
                else
                    throw CreateUnknownTypeException((System.Xml.XmlQualifiedName)t);
            }
            System.Xml.Schema.XmlSchemaGroupRef o = new System.Xml.Schema.XmlSchemaGroupRef();
            System.Xml.XmlAttribute[] a_3 = null;
            int ca_3 = 0;
            bool[] paramsRead = new bool[7];
            while (Reader.MoveToNextAttribute()) {
                if (!paramsRead[1] && ((object) Reader.LocalName == (object)id128_id && (object) Reader.NamespaceURI == (object)id4_Item)) {
                    o.@Id = Reader.Value;
                    paramsRead[1] = true;
                }
                else if (!paramsRead[4] && ((object) Reader.LocalName == (object)id181_minOccurs && (object) Reader.NamespaceURI == (object)id4_Item)) {
                    o.@MinOccursString = Reader.Value;
                    paramsRead[4] = true;
                }
                else if (!paramsRead[5] && ((object) Reader.LocalName == (object)id182_maxOccurs && (object) Reader.NamespaceURI == (object)id4_Item)) {
                    o.@MaxOccursString = Reader.Value;
                    paramsRead[5] = true;
                }
                else if (!paramsRead[6] && ((object) Reader.LocalName == (object)id168_ref && (object) Reader.NamespaceURI == (object)id4_Item)) {
                    o.@RefName = ToXmlQualifiedName(Reader.Value);
                    paramsRead[6] = true;
                }
                else if (IsXmlnsAttribute(Reader.Name)) {
                    if (o.@Namespaces == null) o.@Namespaces = new System.Xml.Serialization.XmlSerializerNamespaces();
                    o.@Namespaces.Add(Reader.Name.Length == 5 ? "" : Reader.LocalName, Reader.Value);
                }
                else {
                    System.Xml.XmlAttribute attr = (System.Xml.XmlAttribute) Document.ReadNode(Reader);
                    ParseWsdlArrayType(attr);
                    a_3 = (System.Xml.XmlAttribute[])EnsureArrayIndex(a_3, ca_3, typeof(System.Xml.XmlAttribute));a_3[ca_3++] = attr;
                }
            }
            o.@UnhandledAttributes = (System.Xml.XmlAttribute[])ShrinkArray(a_3, ca_3, typeof(System.Xml.XmlAttribute), true);
            Reader.MoveToElement();
            if (Reader.IsEmptyElement) {
                Reader.Skip();
                o.@UnhandledAttributes = (System.Xml.XmlAttribute[])ShrinkArray(a_3, ca_3, typeof(System.Xml.XmlAttribute), true);
                return o;
            }
            Reader.ReadStartElement();
            Reader.MoveToContent();
            while (Reader.NodeType != System.Xml.XmlNodeType.EndElement) {
                if (Reader.NodeType == System.Xml.XmlNodeType.Element) {
                    if (!paramsRead[2] && ((object) Reader.LocalName == (object)id138_annotation && (object) Reader.NamespaceURI == (object)id56_httpwwww3org2001XMLSchema)) {
                        o.@Annotation = Read15_XmlSchemaAnnotation(false, true);
                        paramsRead[2] = true;
                    }
                    else {
                        UnknownNode((object)o);
                    }
                }
                else {
                    UnknownNode((object)o);
                }
                Reader.MoveToContent();
            }
            o.@UnhandledAttributes = (System.Xml.XmlAttribute[])ShrinkArray(a_3, ca_3, typeof(System.Xml.XmlAttribute), true);
            ReadEndElement();
            return o;
        }

        System.Xml.Schema.XmlSchemaChoice Read58_XmlSchemaChoice(bool isNullable, bool checkType) {
            if (isNullable && ReadNull()) return null;
            if (checkType) {
                System.Xml.XmlQualifiedName t = GetXsiType();
                if (t == null || ((object) ((System.Xml.XmlQualifiedName)t).Name == (object)id74_XmlSchemaChoice && (object) ((System.Xml.XmlQualifiedName)t).Namespace == (object)id56_httpwwww3org2001XMLSchema))
                    ;
                else
                    throw CreateUnknownTypeException((System.Xml.XmlQualifiedName)t);
            }
            System.Xml.Schema.XmlSchemaChoice o = new System.Xml.Schema.XmlSchemaChoice();
            System.Xml.XmlAttribute[] a_3 = null;
            int ca_3 = 0;
            System.Xml.Schema.XmlSchemaObjectCollection a_6 = (System.Xml.Schema.XmlSchemaObjectCollection)o.@Items;
            bool[] paramsRead = new bool[7];
            while (Reader.MoveToNextAttribute()) {
                if (!paramsRead[1] && ((object) Reader.LocalName == (object)id128_id && (object) Reader.NamespaceURI == (object)id4_Item)) {
                    o.@Id = Reader.Value;
                    paramsRead[1] = true;
                }
                else if (!paramsRead[4] && ((object) Reader.LocalName == (object)id181_minOccurs && (object) Reader.NamespaceURI == (object)id4_Item)) {
                    o.@MinOccursString = Reader.Value;
                    paramsRead[4] = true;
                }
                else if (!paramsRead[5] && ((object) Reader.LocalName == (object)id182_maxOccurs && (object) Reader.NamespaceURI == (object)id4_Item)) {
                    o.@MaxOccursString = Reader.Value;
                    paramsRead[5] = true;
                }
                else if (IsXmlnsAttribute(Reader.Name)) {
                    if (o.@Namespaces == null) o.@Namespaces = new System.Xml.Serialization.XmlSerializerNamespaces();
                    o.@Namespaces.Add(Reader.Name.Length == 5 ? "" : Reader.LocalName, Reader.Value);
                }
                else {
                    System.Xml.XmlAttribute attr = (System.Xml.XmlAttribute) Document.ReadNode(Reader);
                    ParseWsdlArrayType(attr);
                    a_3 = (System.Xml.XmlAttribute[])EnsureArrayIndex(a_3, ca_3, typeof(System.Xml.XmlAttribute));a_3[ca_3++] = attr;
                }
            }
            o.@UnhandledAttributes = (System.Xml.XmlAttribute[])ShrinkArray(a_3, ca_3, typeof(System.Xml.XmlAttribute), true);
            Reader.MoveToElement();
            if (Reader.IsEmptyElement) {
                Reader.Skip();
                o.@UnhandledAttributes = (System.Xml.XmlAttribute[])ShrinkArray(a_3, ca_3, typeof(System.Xml.XmlAttribute), true);
                return o;
            }
            Reader.ReadStartElement();
            Reader.MoveToContent();
            while (Reader.NodeType != System.Xml.XmlNodeType.EndElement) {
                if (Reader.NodeType == System.Xml.XmlNodeType.Element) {
                    if (!paramsRead[2] && ((object) Reader.LocalName == (object)id138_annotation && (object) Reader.NamespaceURI == (object)id56_httpwwww3org2001XMLSchema)) {
                        o.@Annotation = Read15_XmlSchemaAnnotation(false, true);
                        paramsRead[2] = true;
                    }
                    else if (((object) Reader.LocalName == (object)id177_sequence && (object) Reader.NamespaceURI == (object)id56_httpwwww3org2001XMLSchema)) {
                        if ((object)(a_6) == null) Reader.Skip(); else a_6.Add(Read47_XmlSchemaSequence(false, true));
                    }
                    else if (((object) Reader.LocalName == (object)id178_choice && (object) Reader.NamespaceURI == (object)id56_httpwwww3org2001XMLSchema)) {
                        if ((object)(a_6) == null) Reader.Skip(); else a_6.Add(Read58_XmlSchemaChoice(false, true));
                    }
                    else if (((object) Reader.LocalName == (object)id135_group && (object) Reader.NamespaceURI == (object)id56_httpwwww3org2001XMLSchema)) {
                        if ((object)(a_6) == null) Reader.Skip(); else a_6.Add(Read57_XmlSchemaGroupRef(false, true));
                    }
                    else if (((object) Reader.LocalName == (object)id134_element && (object) Reader.NamespaceURI == (object)id56_httpwwww3org2001XMLSchema)) {
                        if ((object)(a_6) == null) Reader.Skip(); else a_6.Add(Read51_XmlSchemaElement(false, true));
                    }
                    else if (((object) Reader.LocalName == (object)id183_any && (object) Reader.NamespaceURI == (object)id56_httpwwww3org2001XMLSchema)) {
                        if ((object)(a_6) == null) Reader.Skip(); else a_6.Add(Read50_XmlSchemaAny(false, true));
                    }
                    else {
                        UnknownNode((object)o);
                    }
                }
                else {
                    UnknownNode((object)o);
                }
                Reader.MoveToContent();
            }
            o.@UnhandledAttributes = (System.Xml.XmlAttribute[])ShrinkArray(a_3, ca_3, typeof(System.Xml.XmlAttribute), true);
            ReadEndElement();
            return o;
        }

        System.Xml.Schema.XmlSchemaAll Read59_XmlSchemaAll(bool isNullable, bool checkType) {
            if (isNullable && ReadNull()) return null;
            if (checkType) {
                System.Xml.XmlQualifiedName t = GetXsiType();
                if (t == null || ((object) ((System.Xml.XmlQualifiedName)t).Name == (object)id73_XmlSchemaAll && (object) ((System.Xml.XmlQualifiedName)t).Namespace == (object)id56_httpwwww3org2001XMLSchema))
                    ;
                else
                    throw CreateUnknownTypeException((System.Xml.XmlQualifiedName)t);
            }
            System.Xml.Schema.XmlSchemaAll o = new System.Xml.Schema.XmlSchemaAll();
            System.Xml.XmlAttribute[] a_3 = null;
            int ca_3 = 0;
            System.Xml.Schema.XmlSchemaObjectCollection a_6 = (System.Xml.Schema.XmlSchemaObjectCollection)o.@Items;
            bool[] paramsRead = new bool[7];
            while (Reader.MoveToNextAttribute()) {
                if (!paramsRead[1] && ((object) Reader.LocalName == (object)id128_id && (object) Reader.NamespaceURI == (object)id4_Item)) {
                    o.@Id = Reader.Value;
                    paramsRead[1] = true;
                }
                else if (!paramsRead[4] && ((object) Reader.LocalName == (object)id181_minOccurs && (object) Reader.NamespaceURI == (object)id4_Item)) {
                    o.@MinOccursString = Reader.Value;
                    paramsRead[4] = true;
                }
                else if (!paramsRead[5] && ((object) Reader.LocalName == (object)id182_maxOccurs && (object) Reader.NamespaceURI == (object)id4_Item)) {
                    o.@MaxOccursString = Reader.Value;
                    paramsRead[5] = true;
                }
                else if (IsXmlnsAttribute(Reader.Name)) {
                    if (o.@Namespaces == null) o.@Namespaces = new System.Xml.Serialization.XmlSerializerNamespaces();
                    o.@Namespaces.Add(Reader.Name.Length == 5 ? "" : Reader.LocalName, Reader.Value);
                }
                else {
                    System.Xml.XmlAttribute attr = (System.Xml.XmlAttribute) Document.ReadNode(Reader);
                    ParseWsdlArrayType(attr);
                    a_3 = (System.Xml.XmlAttribute[])EnsureArrayIndex(a_3, ca_3, typeof(System.Xml.XmlAttribute));a_3[ca_3++] = attr;
                }
            }
            o.@UnhandledAttributes = (System.Xml.XmlAttribute[])ShrinkArray(a_3, ca_3, typeof(System.Xml.XmlAttribute), true);
            Reader.MoveToElement();
            if (Reader.IsEmptyElement) {
                Reader.Skip();
                o.@UnhandledAttributes = (System.Xml.XmlAttribute[])ShrinkArray(a_3, ca_3, typeof(System.Xml.XmlAttribute), true);
                return o;
            }
            Reader.ReadStartElement();
            Reader.MoveToContent();
            while (Reader.NodeType != System.Xml.XmlNodeType.EndElement) {
                if (Reader.NodeType == System.Xml.XmlNodeType.Element) {
                    if (!paramsRead[2] && ((object) Reader.LocalName == (object)id138_annotation && (object) Reader.NamespaceURI == (object)id56_httpwwww3org2001XMLSchema)) {
                        o.@Annotation = Read15_XmlSchemaAnnotation(false, true);
                        paramsRead[2] = true;
                    }
                    else if (((object) Reader.LocalName == (object)id134_element && (object) Reader.NamespaceURI == (object)id56_httpwwww3org2001XMLSchema)) {
                        if ((object)(a_6) == null) Reader.Skip(); else a_6.Add(Read51_XmlSchemaElement(false, true));
                    }
                    else {
                        UnknownNode((object)o);
                    }
                }
                else {
                    UnknownNode((object)o);
                }
                Reader.MoveToContent();
            }
            o.@UnhandledAttributes = (System.Xml.XmlAttribute[])ShrinkArray(a_3, ca_3, typeof(System.Xml.XmlAttribute), true);
            ReadEndElement();
            return o;
        }

        System.Xml.Schema.XmlSchemaComplexContentRestriction Read60_XmlSchemaComplexContentRestriction(bool isNullable, bool checkType) {
            if (isNullable && ReadNull()) return null;
            if (checkType) {
                System.Xml.XmlQualifiedName t = GetXsiType();
                if (t == null || ((object) ((System.Xml.XmlQualifiedName)t).Name == (object)id79_XmlSchemaComplexContentRestriction && (object) ((System.Xml.XmlQualifiedName)t).Namespace == (object)id56_httpwwww3org2001XMLSchema))
                    ;
                else
                    throw CreateUnknownTypeException((System.Xml.XmlQualifiedName)t);
            }
            System.Xml.Schema.XmlSchemaComplexContentRestriction o = new System.Xml.Schema.XmlSchemaComplexContentRestriction();
            System.Xml.XmlAttribute[] a_3 = null;
            int ca_3 = 0;
            System.Xml.Schema.XmlSchemaObjectCollection a_6 = (System.Xml.Schema.XmlSchemaObjectCollection)o.@Attributes;
            bool[] paramsRead = new bool[8];
            while (Reader.MoveToNextAttribute()) {
                if (!paramsRead[1] && ((object) Reader.LocalName == (object)id128_id && (object) Reader.NamespaceURI == (object)id4_Item)) {
                    o.@Id = Reader.Value;
                    paramsRead[1] = true;
                }
                else if (!paramsRead[4] && ((object) Reader.LocalName == (object)id149_base && (object) Reader.NamespaceURI == (object)id4_Item)) {
                    o.@BaseTypeName = ToXmlQualifiedName(Reader.Value);
                    paramsRead[4] = true;
                }
                else if (IsXmlnsAttribute(Reader.Name)) {
                    if (o.@Namespaces == null) o.@Namespaces = new System.Xml.Serialization.XmlSerializerNamespaces();
                    o.@Namespaces.Add(Reader.Name.Length == 5 ? "" : Reader.LocalName, Reader.Value);
                }
                else {
                    System.Xml.XmlAttribute attr = (System.Xml.XmlAttribute) Document.ReadNode(Reader);
                    ParseWsdlArrayType(attr);
                    a_3 = (System.Xml.XmlAttribute[])EnsureArrayIndex(a_3, ca_3, typeof(System.Xml.XmlAttribute));a_3[ca_3++] = attr;
                }
            }
            o.@UnhandledAttributes = (System.Xml.XmlAttribute[])ShrinkArray(a_3, ca_3, typeof(System.Xml.XmlAttribute), true);
            Reader.MoveToElement();
            if (Reader.IsEmptyElement) {
                Reader.Skip();
                o.@UnhandledAttributes = (System.Xml.XmlAttribute[])ShrinkArray(a_3, ca_3, typeof(System.Xml.XmlAttribute), true);
                return o;
            }
            Reader.ReadStartElement();
            Reader.MoveToContent();
            while (Reader.NodeType != System.Xml.XmlNodeType.EndElement) {
                if (Reader.NodeType == System.Xml.XmlNodeType.Element) {
                    if (!paramsRead[2] && ((object) Reader.LocalName == (object)id138_annotation && (object) Reader.NamespaceURI == (object)id56_httpwwww3org2001XMLSchema)) {
                        o.@Annotation = Read15_XmlSchemaAnnotation(false, true);
                        paramsRead[2] = true;
                    }
                    else if (!paramsRead[5] && ((object) Reader.LocalName == (object)id177_sequence && (object) Reader.NamespaceURI == (object)id56_httpwwww3org2001XMLSchema)) {
                        o.@Particle = Read47_XmlSchemaSequence(false, true);
                        paramsRead[5] = true;
                    }
                    else if (!paramsRead[5] && ((object) Reader.LocalName == (object)id178_choice && (object) Reader.NamespaceURI == (object)id56_httpwwww3org2001XMLSchema)) {
                        o.@Particle = Read58_XmlSchemaChoice(false, true);
                        paramsRead[5] = true;
                    }
                    else if (!paramsRead[5] && ((object) Reader.LocalName == (object)id135_group && (object) Reader.NamespaceURI == (object)id56_httpwwww3org2001XMLSchema)) {
                        o.@Particle = Read57_XmlSchemaGroupRef(false, true);
                        paramsRead[5] = true;
                    }
                    else if (!paramsRead[5] && ((object) Reader.LocalName == (object)id179_all && (object) Reader.NamespaceURI == (object)id56_httpwwww3org2001XMLSchema)) {
                        o.@Particle = Read59_XmlSchemaAll(false, true);
                        paramsRead[5] = true;
                    }
                    else if (((object) Reader.LocalName == (object)id133_attribute && (object) Reader.NamespaceURI == (object)id56_httpwwww3org2001XMLSchema)) {
                        if ((object)(a_6) == null) Reader.Skip(); else a_6.Add(Read37_XmlSchemaAttribute(false, true));
                    }
                    else if (((object) Reader.LocalName == (object)id136_attributeGroup && (object) Reader.NamespaceURI == (object)id56_httpwwww3org2001XMLSchema)) {
                        if ((object)(a_6) == null) Reader.Skip(); else a_6.Add(Read39_XmlSchemaAttributeGroupRef(false, true));
                    }
                    else if (!paramsRead[7] && ((object) Reader.LocalName == (object)id165_anyAttribute && (object) Reader.NamespaceURI == (object)id56_httpwwww3org2001XMLSchema)) {
                        o.@AnyAttribute = Read40_XmlSchemaAnyAttribute(false, true);
                        paramsRead[7] = true;
                    }
                    else {
                        UnknownNode((object)o);
                    }
                }
                else {
                    UnknownNode((object)o);
                }
                Reader.MoveToContent();
            }
            o.@UnhandledAttributes = (System.Xml.XmlAttribute[])ShrinkArray(a_3, ca_3, typeof(System.Xml.XmlAttribute), true);
            ReadEndElement();
            return o;
        }

        System.Xml.Schema.XmlSchemaSimpleContent Read61_XmlSchemaSimpleContent(bool isNullable, bool checkType) {
            if (isNullable && ReadNull()) return null;
            if (checkType) {
                System.Xml.XmlQualifiedName t = GetXsiType();
                if (t == null || ((object) ((System.Xml.XmlQualifiedName)t).Name == (object)id82_XmlSchemaSimpleContent && (object) ((System.Xml.XmlQualifiedName)t).Namespace == (object)id56_httpwwww3org2001XMLSchema))
                    ;
                else
                    throw CreateUnknownTypeException((System.Xml.XmlQualifiedName)t);
            }
            System.Xml.Schema.XmlSchemaSimpleContent o = new System.Xml.Schema.XmlSchemaSimpleContent();
            System.Xml.XmlAttribute[] a_3 = null;
            int ca_3 = 0;
            bool[] paramsRead = new bool[5];
            while (Reader.MoveToNextAttribute()) {
                if (!paramsRead[1] && ((object) Reader.LocalName == (object)id128_id && (object) Reader.NamespaceURI == (object)id4_Item)) {
                    o.@Id = Reader.Value;
                    paramsRead[1] = true;
                }
                else if (IsXmlnsAttribute(Reader.Name)) {
                    if (o.@Namespaces == null) o.@Namespaces = new System.Xml.Serialization.XmlSerializerNamespaces();
                    o.@Namespaces.Add(Reader.Name.Length == 5 ? "" : Reader.LocalName, Reader.Value);
                }
                else {
                    System.Xml.XmlAttribute attr = (System.Xml.XmlAttribute) Document.ReadNode(Reader);
                    ParseWsdlArrayType(attr);
                    a_3 = (System.Xml.XmlAttribute[])EnsureArrayIndex(a_3, ca_3, typeof(System.Xml.XmlAttribute));a_3[ca_3++] = attr;
                }
            }
            o.@UnhandledAttributes = (System.Xml.XmlAttribute[])ShrinkArray(a_3, ca_3, typeof(System.Xml.XmlAttribute), true);
            Reader.MoveToElement();
            if (Reader.IsEmptyElement) {
                Reader.Skip();
                o.@UnhandledAttributes = (System.Xml.XmlAttribute[])ShrinkArray(a_3, ca_3, typeof(System.Xml.XmlAttribute), true);
                return o;
            }
            Reader.ReadStartElement();
            Reader.MoveToContent();
            while (Reader.NodeType != System.Xml.XmlNodeType.EndElement) {
                if (Reader.NodeType == System.Xml.XmlNodeType.Element) {
                    if (!paramsRead[2] && ((object) Reader.LocalName == (object)id138_annotation && (object) Reader.NamespaceURI == (object)id56_httpwwww3org2001XMLSchema)) {
                        o.@Annotation = Read15_XmlSchemaAnnotation(false, true);
                        paramsRead[2] = true;
                    }
                    else if (!paramsRead[4] && ((object) Reader.LocalName == (object)id142_restriction && (object) Reader.NamespaceURI == (object)id56_httpwwww3org2001XMLSchema)) {
                        o.@Content = Read62_XmlSchemaSimpleContentRestriction(false, true);
                        paramsRead[4] = true;
                    }
                    else if (!paramsRead[4] && ((object) Reader.LocalName == (object)id180_extension && (object) Reader.NamespaceURI == (object)id56_httpwwww3org2001XMLSchema)) {
                        o.@Content = Read63_XmlSchemaSimpleContentExtension(false, true);
                        paramsRead[4] = true;
                    }
                    else {
                        UnknownNode((object)o);
                    }
                }
                else {
                    UnknownNode((object)o);
                }
                Reader.MoveToContent();
            }
            o.@UnhandledAttributes = (System.Xml.XmlAttribute[])ShrinkArray(a_3, ca_3, typeof(System.Xml.XmlAttribute), true);
            ReadEndElement();
            return o;
        }

        System.Xml.Schema.XmlSchemaSimpleContentRestriction Read62_XmlSchemaSimpleContentRestriction(bool isNullable, bool checkType) {
            if (isNullable && ReadNull()) return null;
            if (checkType) {
                System.Xml.XmlQualifiedName t = GetXsiType();
                if (t == null || ((object) ((System.Xml.XmlQualifiedName)t).Name == (object)id78_XmlSchemaSimpleContentRestriction && (object) ((System.Xml.XmlQualifiedName)t).Namespace == (object)id56_httpwwww3org2001XMLSchema))
                    ;
                else
                    throw CreateUnknownTypeException((System.Xml.XmlQualifiedName)t);
            }
            System.Xml.Schema.XmlSchemaSimpleContentRestriction o = new System.Xml.Schema.XmlSchemaSimpleContentRestriction();
            System.Xml.XmlAttribute[] a_3 = null;
            int ca_3 = 0;
            System.Xml.Schema.XmlSchemaObjectCollection a_6 = (System.Xml.Schema.XmlSchemaObjectCollection)o.@Facets;
            System.Xml.Schema.XmlSchemaObjectCollection a_7 = (System.Xml.Schema.XmlSchemaObjectCollection)o.@Attributes;
            bool[] paramsRead = new bool[9];
            while (Reader.MoveToNextAttribute()) {
                if (!paramsRead[1] && ((object) Reader.LocalName == (object)id128_id && (object) Reader.NamespaceURI == (object)id4_Item)) {
                    o.@Id = Reader.Value;
                    paramsRead[1] = true;
                }
                else if (!paramsRead[4] && ((object) Reader.LocalName == (object)id149_base && (object) Reader.NamespaceURI == (object)id4_Item)) {
                    o.@BaseTypeName = ToXmlQualifiedName(Reader.Value);
                    paramsRead[4] = true;
                }
                else if (IsXmlnsAttribute(Reader.Name)) {
                    if (o.@Namespaces == null) o.@Namespaces = new System.Xml.Serialization.XmlSerializerNamespaces();
                    o.@Namespaces.Add(Reader.Name.Length == 5 ? "" : Reader.LocalName, Reader.Value);
                }
                else {
                    System.Xml.XmlAttribute attr = (System.Xml.XmlAttribute) Document.ReadNode(Reader);
                    ParseWsdlArrayType(attr);
                    a_3 = (System.Xml.XmlAttribute[])EnsureArrayIndex(a_3, ca_3, typeof(System.Xml.XmlAttribute));a_3[ca_3++] = attr;
                }
            }
            o.@UnhandledAttributes = (System.Xml.XmlAttribute[])ShrinkArray(a_3, ca_3, typeof(System.Xml.XmlAttribute), true);
            Reader.MoveToElement();
            if (Reader.IsEmptyElement) {
                Reader.Skip();
                o.@UnhandledAttributes = (System.Xml.XmlAttribute[])ShrinkArray(a_3, ca_3, typeof(System.Xml.XmlAttribute), true);
                return o;
            }
            Reader.ReadStartElement();
            Reader.MoveToContent();
            while (Reader.NodeType != System.Xml.XmlNodeType.EndElement) {
                if (Reader.NodeType == System.Xml.XmlNodeType.Element) {
                    if (!paramsRead[2] && ((object) Reader.LocalName == (object)id138_annotation && (object) Reader.NamespaceURI == (object)id56_httpwwww3org2001XMLSchema)) {
                        o.@Annotation = Read15_XmlSchemaAnnotation(false, true);
                        paramsRead[2] = true;
                    }
                    else if (!paramsRead[5] && ((object) Reader.LocalName == (object)id131_simpleType && (object) Reader.NamespaceURI == (object)id56_httpwwww3org2001XMLSchema)) {
                        o.@BaseType = Read12_XmlSchemaSimpleType(false, true);
                        paramsRead[5] = true;
                    }
                    else if (((object) Reader.LocalName == (object)id150_length && (object) Reader.NamespaceURI == (object)id56_httpwwww3org2001XMLSchema)) {
                        if ((object)(a_6) == null) Reader.Skip(); else a_6.Add(Read24_XmlSchemaLengthFacet(false, true));
                    }
                    else if (((object) Reader.LocalName == (object)id151_maxInclusive && (object) Reader.NamespaceURI == (object)id56_httpwwww3org2001XMLSchema)) {
                        if ((object)(a_6) == null) Reader.Skip(); else a_6.Add(Read29_XmlSchemaMaxInclusiveFacet(false, true));
                    }
                    else if (((object) Reader.LocalName == (object)id152_maxExclusive && (object) Reader.NamespaceURI == (object)id56_httpwwww3org2001XMLSchema)) {
                        if ((object)(a_6) == null) Reader.Skip(); else a_6.Add(Read30_XmlSchemaMaxExclusiveFacet(false, true));
                    }
                    else if (((object) Reader.LocalName == (object)id153_fractionDigits && (object) Reader.NamespaceURI == (object)id56_httpwwww3org2001XMLSchema)) {
                        if ((object)(a_6) == null) Reader.Skip(); else a_6.Add(Read34_XmlSchemaFractionDigitsFacet(false, true));
                    }
                    else if (((object) Reader.LocalName == (object)id154_enumeration && (object) Reader.NamespaceURI == (object)id56_httpwwww3org2001XMLSchema)) {
                        if ((object)(a_6) == null) Reader.Skip(); else a_6.Add(Read28_XmlSchemaEnumerationFacet(false, true));
                    }
                    else if (((object) Reader.LocalName == (object)id160_whiteSpace && (object) Reader.NamespaceURI == (object)id56_httpwwww3org2001XMLSchema)) {
                        if ((object)(a_6) == null) Reader.Skip(); else a_6.Add(Read25_XmlSchemaWhiteSpaceFacet(false, true));
                    }
                    else if (((object) Reader.LocalName == (object)id155_totalDigits && (object) Reader.NamespaceURI == (object)id56_httpwwww3org2001XMLSchema)) {
                        if ((object)(a_6) == null) Reader.Skip(); else a_6.Add(Read33_XmlSchemaTotalDigitsFacet(false, true));
                    }
                    else if (((object) Reader.LocalName == (object)id156_minLength && (object) Reader.NamespaceURI == (object)id56_httpwwww3org2001XMLSchema)) {
                        if ((object)(a_6) == null) Reader.Skip(); else a_6.Add(Read21_XmlSchemaMinLengthFacet(false, true));
                    }
                    else if (((object) Reader.LocalName == (object)id157_minExclusive && (object) Reader.NamespaceURI == (object)id56_httpwwww3org2001XMLSchema)) {
                        if ((object)(a_6) == null) Reader.Skip(); else a_6.Add(Read32_XmlSchemaMinExclusiveFacet(false, true));
                    }
                    else if (((object) Reader.LocalName == (object)id158_minInclusive && (object) Reader.NamespaceURI == (object)id56_httpwwww3org2001XMLSchema)) {
                        if ((object)(a_6) == null) Reader.Skip(); else a_6.Add(Read31_XmlSchemaMinInclusiveFacet(false, true));
                    }
                    else if (((object) Reader.LocalName == (object)id159_maxLength && (object) Reader.NamespaceURI == (object)id56_httpwwww3org2001XMLSchema)) {
                        if ((object)(a_6) == null) Reader.Skip(); else a_6.Add(Read26_XmlSchemaMaxLengthFacet(false, true));
                    }
                    else if (((object) Reader.LocalName == (object)id161_pattern && (object) Reader.NamespaceURI == (object)id56_httpwwww3org2001XMLSchema)) {
                        if ((object)(a_6) == null) Reader.Skip(); else a_6.Add(Read27_XmlSchemaPatternFacet(false, true));
                    }
                    else if (((object) Reader.LocalName == (object)id133_attribute && (object) Reader.NamespaceURI == (object)id56_httpwwww3org2001XMLSchema)) {
                        if ((object)(a_7) == null) Reader.Skip(); else a_7.Add(Read37_XmlSchemaAttribute(false, true));
                    }
                    else if (((object) Reader.LocalName == (object)id136_attributeGroup && (object) Reader.NamespaceURI == (object)id56_httpwwww3org2001XMLSchema)) {
                        if ((object)(a_7) == null) Reader.Skip(); else a_7.Add(Read39_XmlSchemaAttributeGroupRef(false, true));
                    }
                    else if (!paramsRead[8] && ((object) Reader.LocalName == (object)id165_anyAttribute && (object) Reader.NamespaceURI == (object)id56_httpwwww3org2001XMLSchema)) {
                        o.@AnyAttribute = Read40_XmlSchemaAnyAttribute(false, true);
                        paramsRead[8] = true;
                    }
                    else {
                        UnknownNode((object)o);
                    }
                }
                else {
                    UnknownNode((object)o);
                }
                Reader.MoveToContent();
            }
            o.@UnhandledAttributes = (System.Xml.XmlAttribute[])ShrinkArray(a_3, ca_3, typeof(System.Xml.XmlAttribute), true);
            ReadEndElement();
            return o;
        }

        System.Xml.Schema.XmlSchemaSimpleContentExtension Read63_XmlSchemaSimpleContentExtension(bool isNullable, bool checkType) {
            if (isNullable && ReadNull()) return null;
            if (checkType) {
                System.Xml.XmlQualifiedName t = GetXsiType();
                if (t == null || ((object) ((System.Xml.XmlQualifiedName)t).Name == (object)id77_XmlSchemaSimpleContentExtension && (object) ((System.Xml.XmlQualifiedName)t).Namespace == (object)id56_httpwwww3org2001XMLSchema))
                    ;
                else
                    throw CreateUnknownTypeException((System.Xml.XmlQualifiedName)t);
            }
            System.Xml.Schema.XmlSchemaSimpleContentExtension o = new System.Xml.Schema.XmlSchemaSimpleContentExtension();
            System.Xml.XmlAttribute[] a_3 = null;
            int ca_3 = 0;
            System.Xml.Schema.XmlSchemaObjectCollection a_5 = (System.Xml.Schema.XmlSchemaObjectCollection)o.@Attributes;
            bool[] paramsRead = new bool[7];
            while (Reader.MoveToNextAttribute()) {
                if (!paramsRead[1] && ((object) Reader.LocalName == (object)id128_id && (object) Reader.NamespaceURI == (object)id4_Item)) {
                    o.@Id = Reader.Value;
                    paramsRead[1] = true;
                }
                else if (!paramsRead[4] && ((object) Reader.LocalName == (object)id149_base && (object) Reader.NamespaceURI == (object)id4_Item)) {
                    o.@BaseTypeName = ToXmlQualifiedName(Reader.Value);
                    paramsRead[4] = true;
                }
                else if (IsXmlnsAttribute(Reader.Name)) {
                    if (o.@Namespaces == null) o.@Namespaces = new System.Xml.Serialization.XmlSerializerNamespaces();
                    o.@Namespaces.Add(Reader.Name.Length == 5 ? "" : Reader.LocalName, Reader.Value);
                }
                else {
                    System.Xml.XmlAttribute attr = (System.Xml.XmlAttribute) Document.ReadNode(Reader);
                    ParseWsdlArrayType(attr);
                    a_3 = (System.Xml.XmlAttribute[])EnsureArrayIndex(a_3, ca_3, typeof(System.Xml.XmlAttribute));a_3[ca_3++] = attr;
                }
            }
            o.@UnhandledAttributes = (System.Xml.XmlAttribute[])ShrinkArray(a_3, ca_3, typeof(System.Xml.XmlAttribute), true);
            Reader.MoveToElement();
            if (Reader.IsEmptyElement) {
                Reader.Skip();
                o.@UnhandledAttributes = (System.Xml.XmlAttribute[])ShrinkArray(a_3, ca_3, typeof(System.Xml.XmlAttribute), true);
                return o;
            }
            Reader.ReadStartElement();
            Reader.MoveToContent();
            while (Reader.NodeType != System.Xml.XmlNodeType.EndElement) {
                if (Reader.NodeType == System.Xml.XmlNodeType.Element) {
                    if (!paramsRead[2] && ((object) Reader.LocalName == (object)id138_annotation && (object) Reader.NamespaceURI == (object)id56_httpwwww3org2001XMLSchema)) {
                        o.@Annotation = Read15_XmlSchemaAnnotation(false, true);
                        paramsRead[2] = true;
                    }
                    else if (((object) Reader.LocalName == (object)id133_attribute && (object) Reader.NamespaceURI == (object)id56_httpwwww3org2001XMLSchema)) {
                        if ((object)(a_5) == null) Reader.Skip(); else a_5.Add(Read37_XmlSchemaAttribute(false, true));
                    }
                    else if (((object) Reader.LocalName == (object)id136_attributeGroup && (object) Reader.NamespaceURI == (object)id56_httpwwww3org2001XMLSchema)) {
                        if ((object)(a_5) == null) Reader.Skip(); else a_5.Add(Read39_XmlSchemaAttributeGroupRef(false, true));
                    }
                    else if (!paramsRead[6] && ((object) Reader.LocalName == (object)id165_anyAttribute && (object) Reader.NamespaceURI == (object)id56_httpwwww3org2001XMLSchema)) {
                        o.@AnyAttribute = Read40_XmlSchemaAnyAttribute(false, true);
                        paramsRead[6] = true;
                    }
                    else {
                        UnknownNode((object)o);
                    }
                }
                else {
                    UnknownNode((object)o);
                }
                Reader.MoveToContent();
            }
            o.@UnhandledAttributes = (System.Xml.XmlAttribute[])ShrinkArray(a_3, ca_3, typeof(System.Xml.XmlAttribute), true);
            ReadEndElement();
            return o;
        }

        System.Xml.Schema.XmlSchemaGroup Read64_XmlSchemaGroup(bool isNullable, bool checkType) {
            if (isNullable && ReadNull()) return null;
            if (checkType) {
                System.Xml.XmlQualifiedName t = GetXsiType();
                if (t == null || ((object) ((System.Xml.XmlQualifiedName)t).Name == (object)id62_XmlSchemaGroup && (object) ((System.Xml.XmlQualifiedName)t).Namespace == (object)id56_httpwwww3org2001XMLSchema))
                    ;
                else
                    throw CreateUnknownTypeException((System.Xml.XmlQualifiedName)t);
            }
            System.Xml.Schema.XmlSchemaGroup o = new System.Xml.Schema.XmlSchemaGroup();
            System.Xml.XmlAttribute[] a_3 = null;
            int ca_3 = 0;
            bool[] paramsRead = new bool[6];
            while (Reader.MoveToNextAttribute()) {
                if (!paramsRead[1] && ((object) Reader.LocalName == (object)id128_id && (object) Reader.NamespaceURI == (object)id4_Item)) {
                    o.@Id = Reader.Value;
                    paramsRead[1] = true;
                }
                else if (!paramsRead[4] && ((object) Reader.LocalName == (object)id5_name && (object) Reader.NamespaceURI == (object)id4_Item)) {
                    o.@Name = Reader.Value;
                    paramsRead[4] = true;
                }
                else if (IsXmlnsAttribute(Reader.Name)) {
                    if (o.@Namespaces == null) o.@Namespaces = new System.Xml.Serialization.XmlSerializerNamespaces();
                    o.@Namespaces.Add(Reader.Name.Length == 5 ? "" : Reader.LocalName, Reader.Value);
                }
                else {
                    System.Xml.XmlAttribute attr = (System.Xml.XmlAttribute) Document.ReadNode(Reader);
                    ParseWsdlArrayType(attr);
                    a_3 = (System.Xml.XmlAttribute[])EnsureArrayIndex(a_3, ca_3, typeof(System.Xml.XmlAttribute));a_3[ca_3++] = attr;
                }
            }
            o.@UnhandledAttributes = (System.Xml.XmlAttribute[])ShrinkArray(a_3, ca_3, typeof(System.Xml.XmlAttribute), true);
            Reader.MoveToElement();
            if (Reader.IsEmptyElement) {
                Reader.Skip();
                o.@UnhandledAttributes = (System.Xml.XmlAttribute[])ShrinkArray(a_3, ca_3, typeof(System.Xml.XmlAttribute), true);
                return o;
            }
            Reader.ReadStartElement();
            Reader.MoveToContent();
            while (Reader.NodeType != System.Xml.XmlNodeType.EndElement) {
                if (Reader.NodeType == System.Xml.XmlNodeType.Element) {
                    if (!paramsRead[2] && ((object) Reader.LocalName == (object)id138_annotation && (object) Reader.NamespaceURI == (object)id56_httpwwww3org2001XMLSchema)) {
                        o.@Annotation = Read15_XmlSchemaAnnotation(false, true);
                        paramsRead[2] = true;
                    }
                    else if (!paramsRead[5] && ((object) Reader.LocalName == (object)id177_sequence && (object) Reader.NamespaceURI == (object)id56_httpwwww3org2001XMLSchema)) {
                        o.@Particle = Read47_XmlSchemaSequence(false, true);
                        paramsRead[5] = true;
                    }
                    else if (!paramsRead[5] && ((object) Reader.LocalName == (object)id178_choice && (object) Reader.NamespaceURI == (object)id56_httpwwww3org2001XMLSchema)) {
                        o.@Particle = Read58_XmlSchemaChoice(false, true);
                        paramsRead[5] = true;
                    }
                    else if (!paramsRead[5] && ((object) Reader.LocalName == (object)id179_all && (object) Reader.NamespaceURI == (object)id56_httpwwww3org2001XMLSchema)) {
                        o.@Particle = Read59_XmlSchemaAll(false, true);
                        paramsRead[5] = true;
                    }
                    else {
                        UnknownNode((object)o);
                    }
                }
                else {
                    UnknownNode((object)o);
                }
                Reader.MoveToContent();
            }
            o.@UnhandledAttributes = (System.Xml.XmlAttribute[])ShrinkArray(a_3, ca_3, typeof(System.Xml.XmlAttribute), true);
            ReadEndElement();
            return o;
        }

        System.Xml.Schema.XmlSchemaImport Read65_XmlSchemaImport(bool isNullable, bool checkType) {
            if (isNullable && ReadNull()) return null;
            if (checkType) {
                System.Xml.XmlQualifiedName t = GetXsiType();
                if (t == null || ((object) ((System.Xml.XmlQualifiedName)t).Name == (object)id111_XmlSchemaImport && (object) ((System.Xml.XmlQualifiedName)t).Namespace == (object)id56_httpwwww3org2001XMLSchema))
                    ;
                else
                    throw CreateUnknownTypeException((System.Xml.XmlQualifiedName)t);
            }
            System.Xml.Schema.XmlSchemaImport o = new System.Xml.Schema.XmlSchemaImport();
            System.Xml.XmlAttribute[] a_3 = null;
            int ca_3 = 0;
            bool[] paramsRead = new bool[6];
            while (Reader.MoveToNextAttribute()) {
                if (!paramsRead[1] && ((object) Reader.LocalName == (object)id139_schemaLocation && (object) Reader.NamespaceURI == (object)id4_Item)) {
                    o.@SchemaLocation = Reader.Value;
                    paramsRead[1] = true;
                }
                else if (!paramsRead[2] && ((object) Reader.LocalName == (object)id128_id && (object) Reader.NamespaceURI == (object)id4_Item)) {
                    o.@Id = Reader.Value;
                    paramsRead[2] = true;
                }
                else if (!paramsRead[4] && ((object) Reader.LocalName == (object)id120_namespace && (object) Reader.NamespaceURI == (object)id4_Item)) {
                    o.@Namespace = Reader.Value;
                    paramsRead[4] = true;
                }
                else if (IsXmlnsAttribute(Reader.Name)) {
                    if (o.@Namespaces == null) o.@Namespaces = new System.Xml.Serialization.XmlSerializerNamespaces();
                    o.@Namespaces.Add(Reader.Name.Length == 5 ? "" : Reader.LocalName, Reader.Value);
                }
                else {
                    System.Xml.XmlAttribute attr = (System.Xml.XmlAttribute) Document.ReadNode(Reader);
                    ParseWsdlArrayType(attr);
                    a_3 = (System.Xml.XmlAttribute[])EnsureArrayIndex(a_3, ca_3, typeof(System.Xml.XmlAttribute));a_3[ca_3++] = attr;
                }
            }
            o.@UnhandledAttributes = (System.Xml.XmlAttribute[])ShrinkArray(a_3, ca_3, typeof(System.Xml.XmlAttribute), true);
            Reader.MoveToElement();
            if (Reader.IsEmptyElement) {
                Reader.Skip();
                o.@UnhandledAttributes = (System.Xml.XmlAttribute[])ShrinkArray(a_3, ca_3, typeof(System.Xml.XmlAttribute), true);
                return o;
            }
            Reader.ReadStartElement();
            Reader.MoveToContent();
            while (Reader.NodeType != System.Xml.XmlNodeType.EndElement) {
                if (Reader.NodeType == System.Xml.XmlNodeType.Element) {
                    if (!paramsRead[5] && ((object) Reader.LocalName == (object)id138_annotation && (object) Reader.NamespaceURI == (object)id56_httpwwww3org2001XMLSchema)) {
                        o.@Annotation = Read15_XmlSchemaAnnotation(false, true);
                        paramsRead[5] = true;
                    }
                    else {
                        UnknownNode((object)o);
                    }
                }
                else {
                    UnknownNode((object)o);
                }
                Reader.MoveToContent();
            }
            o.@UnhandledAttributes = (System.Xml.XmlAttribute[])ShrinkArray(a_3, ca_3, typeof(System.Xml.XmlAttribute), true);
            ReadEndElement();
            return o;
        }

        System.Xml.Schema.XmlSchemaInclude Read66_XmlSchemaInclude(bool isNullable, bool checkType) {
            if (isNullable && ReadNull()) return null;
            if (checkType) {
                System.Xml.XmlQualifiedName t = GetXsiType();
                if (t == null || ((object) ((System.Xml.XmlQualifiedName)t).Name == (object)id110_XmlSchemaInclude && (object) ((System.Xml.XmlQualifiedName)t).Namespace == (object)id56_httpwwww3org2001XMLSchema))
                    ;
                else
                    throw CreateUnknownTypeException((System.Xml.XmlQualifiedName)t);
            }
            System.Xml.Schema.XmlSchemaInclude o = new System.Xml.Schema.XmlSchemaInclude();
            System.Xml.XmlAttribute[] a_3 = null;
            int ca_3 = 0;
            bool[] paramsRead = new bool[5];
            while (Reader.MoveToNextAttribute()) {
                if (!paramsRead[1] && ((object) Reader.LocalName == (object)id139_schemaLocation && (object) Reader.NamespaceURI == (object)id4_Item)) {
                    o.@SchemaLocation = Reader.Value;
                    paramsRead[1] = true;
                }
                else if (!paramsRead[2] && ((object) Reader.LocalName == (object)id128_id && (object) Reader.NamespaceURI == (object)id4_Item)) {
                    o.@Id = Reader.Value;
                    paramsRead[2] = true;
                }
                else if (IsXmlnsAttribute(Reader.Name)) {
                    if (o.@Namespaces == null) o.@Namespaces = new System.Xml.Serialization.XmlSerializerNamespaces();
                    o.@Namespaces.Add(Reader.Name.Length == 5 ? "" : Reader.LocalName, Reader.Value);
                }
                else {
                    System.Xml.XmlAttribute attr = (System.Xml.XmlAttribute) Document.ReadNode(Reader);
                    ParseWsdlArrayType(attr);
                    a_3 = (System.Xml.XmlAttribute[])EnsureArrayIndex(a_3, ca_3, typeof(System.Xml.XmlAttribute));a_3[ca_3++] = attr;
                }
            }
            o.@UnhandledAttributes = (System.Xml.XmlAttribute[])ShrinkArray(a_3, ca_3, typeof(System.Xml.XmlAttribute), true);
            Reader.MoveToElement();
            if (Reader.IsEmptyElement) {
                Reader.Skip();
                o.@UnhandledAttributes = (System.Xml.XmlAttribute[])ShrinkArray(a_3, ca_3, typeof(System.Xml.XmlAttribute), true);
                return o;
            }
            Reader.ReadStartElement();
            Reader.MoveToContent();
            while (Reader.NodeType != System.Xml.XmlNodeType.EndElement) {
                if (Reader.NodeType == System.Xml.XmlNodeType.Element) {
                    if (!paramsRead[4] && ((object) Reader.LocalName == (object)id138_annotation && (object) Reader.NamespaceURI == (object)id56_httpwwww3org2001XMLSchema)) {
                        o.@Annotation = Read15_XmlSchemaAnnotation(false, true);
                        paramsRead[4] = true;
                    }
                    else {
                        UnknownNode((object)o);
                    }
                }
                else {
                    UnknownNode((object)o);
                }
                Reader.MoveToContent();
            }
            o.@UnhandledAttributes = (System.Xml.XmlAttribute[])ShrinkArray(a_3, ca_3, typeof(System.Xml.XmlAttribute), true);
            ReadEndElement();
            return o;
        }

        System.Xml.Schema.XmlSchemaNotation Read67_XmlSchemaNotation(bool isNullable, bool checkType) {
            if (isNullable && ReadNull()) return null;
            if (checkType) {
                System.Xml.XmlQualifiedName t = GetXsiType();
                if (t == null || ((object) ((System.Xml.XmlQualifiedName)t).Name == (object)id61_XmlSchemaNotation && (object) ((System.Xml.XmlQualifiedName)t).Namespace == (object)id56_httpwwww3org2001XMLSchema))
                    ;
                else
                    throw CreateUnknownTypeException((System.Xml.XmlQualifiedName)t);
            }
            System.Xml.Schema.XmlSchemaNotation o = new System.Xml.Schema.XmlSchemaNotation();
            System.Xml.XmlAttribute[] a_3 = null;
            int ca_3 = 0;
            bool[] paramsRead = new bool[7];
            while (Reader.MoveToNextAttribute()) {
                if (!paramsRead[1] && ((object) Reader.LocalName == (object)id128_id && (object) Reader.NamespaceURI == (object)id4_Item)) {
                    o.@Id = Reader.Value;
                    paramsRead[1] = true;
                }
                else if (!paramsRead[4] && ((object) Reader.LocalName == (object)id5_name && (object) Reader.NamespaceURI == (object)id4_Item)) {
                    o.@Name = Reader.Value;
                    paramsRead[4] = true;
                }
                else if (!paramsRead[5] && ((object) Reader.LocalName == (object)id193_public && (object) Reader.NamespaceURI == (object)id4_Item)) {
                    o.@Public = Reader.Value;
                    paramsRead[5] = true;
                }
                else if (!paramsRead[6] && ((object) Reader.LocalName == (object)id194_system && (object) Reader.NamespaceURI == (object)id4_Item)) {
                    o.@System = Reader.Value;
                    paramsRead[6] = true;
                }
                else if (IsXmlnsAttribute(Reader.Name)) {
                    if (o.@Namespaces == null) o.@Namespaces = new System.Xml.Serialization.XmlSerializerNamespaces();
                    o.@Namespaces.Add(Reader.Name.Length == 5 ? "" : Reader.LocalName, Reader.Value);
                }
                else {
                    System.Xml.XmlAttribute attr = (System.Xml.XmlAttribute) Document.ReadNode(Reader);
                    ParseWsdlArrayType(attr);
                    a_3 = (System.Xml.XmlAttribute[])EnsureArrayIndex(a_3, ca_3, typeof(System.Xml.XmlAttribute));a_3[ca_3++] = attr;
                }
            }
            o.@UnhandledAttributes = (System.Xml.XmlAttribute[])ShrinkArray(a_3, ca_3, typeof(System.Xml.XmlAttribute), true);
            Reader.MoveToElement();
            if (Reader.IsEmptyElement) {
                Reader.Skip();
                o.@UnhandledAttributes = (System.Xml.XmlAttribute[])ShrinkArray(a_3, ca_3, typeof(System.Xml.XmlAttribute), true);
                return o;
            }
            Reader.ReadStartElement();
            Reader.MoveToContent();
            while (Reader.NodeType != System.Xml.XmlNodeType.EndElement) {
                if (Reader.NodeType == System.Xml.XmlNodeType.Element) {
                    if (!paramsRead[2] && ((object) Reader.LocalName == (object)id138_annotation && (object) Reader.NamespaceURI == (object)id56_httpwwww3org2001XMLSchema)) {
                        o.@Annotation = Read15_XmlSchemaAnnotation(false, true);
                        paramsRead[2] = true;
                    }
                    else {
                        UnknownNode((object)o);
                    }
                }
                else {
                    UnknownNode((object)o);
                }
                Reader.MoveToContent();
            }
            o.@UnhandledAttributes = (System.Xml.XmlAttribute[])ShrinkArray(a_3, ca_3, typeof(System.Xml.XmlAttribute), true);
            ReadEndElement();
            return o;
        }

        System.Web.Services.Description.Message Read68_Message(bool isNullable, bool checkType) {
            if (isNullable && ReadNull()) return null;
            if (checkType) {
                System.Xml.XmlQualifiedName t = GetXsiType();
                if (t == null || ((object) ((System.Xml.XmlQualifiedName)t).Name == (object)id29_Message && (object) ((System.Xml.XmlQualifiedName)t).Namespace == (object)id2_httpschemasxmlsoaporgwsdl))
                    ;
                else
                    throw CreateUnknownTypeException((System.Xml.XmlQualifiedName)t);
            }
            System.Web.Services.Description.Message o = new System.Web.Services.Description.Message();
            System.Web.Services.Description.MessagePartCollection a_1 = (System.Web.Services.Description.MessagePartCollection)o.@Parts;
            bool[] paramsRead = new bool[3];
            while (Reader.MoveToNextAttribute()) {
                if (!paramsRead[2] && ((object) Reader.LocalName == (object)id5_name && (object) Reader.NamespaceURI == (object)id4_Item)) {
                    o.@Name = ToXmlNCName(Reader.Value);
                    paramsRead[2] = true;
                }
                else if (!IsXmlnsAttribute(Reader.Name)) {
                    UnknownNode((object)o);
                }
            }
            Reader.MoveToElement();
            if (Reader.IsEmptyElement) {
                Reader.Skip();
                return o;
            }
            Reader.ReadStartElement();
            Reader.MoveToContent();
            while (Reader.NodeType != System.Xml.XmlNodeType.EndElement) {
                if (Reader.NodeType == System.Xml.XmlNodeType.Element) {
                    if (!paramsRead[0] && ((object) Reader.LocalName == (object)id6_documentation && (object) Reader.NamespaceURI == (object)id2_httpschemasxmlsoaporgwsdl)) {
                        o.@Documentation = Reader.ReadElementString();
                        paramsRead[0] = true;
                    }
                    else if (((object) Reader.LocalName == (object)id195_part && (object) Reader.NamespaceURI == (object)id2_httpschemasxmlsoaporgwsdl)) {
                        if ((object)(a_1) == null) Reader.Skip(); else a_1.Add(Read69_MessagePart(false, true));
                    }
                    else {
                        UnknownNode((object)o);
                    }
                }
                else {
                    UnknownNode((object)o);
                }
                Reader.MoveToContent();
            }
            ReadEndElement();
            return o;
        }

        System.Web.Services.Description.MessagePart Read69_MessagePart(bool isNullable, bool checkType) {
            if (isNullable && ReadNull()) return null;
            if (checkType) {
                System.Xml.XmlQualifiedName t = GetXsiType();
                if (t == null || ((object) ((System.Xml.XmlQualifiedName)t).Name == (object)id28_MessagePart && (object) ((System.Xml.XmlQualifiedName)t).Namespace == (object)id2_httpschemasxmlsoaporgwsdl))
                    ;
                else
                    throw CreateUnknownTypeException((System.Xml.XmlQualifiedName)t);
            }
            System.Web.Services.Description.MessagePart o = new System.Web.Services.Description.MessagePart();
            bool[] paramsRead = new bool[4];
            while (Reader.MoveToNextAttribute()) {
                if (!paramsRead[1] && ((object) Reader.LocalName == (object)id5_name && (object) Reader.NamespaceURI == (object)id4_Item)) {
                    o.@Name = ToXmlNmToken(Reader.Value);
                    paramsRead[1] = true;
                }
                else if (!paramsRead[2] && ((object) Reader.LocalName == (object)id134_element && (object) Reader.NamespaceURI == (object)id4_Item)) {
                    o.@Element = ToXmlQualifiedName(Reader.Value);
                    paramsRead[2] = true;
                }
                else if (!paramsRead[3] && ((object) Reader.LocalName == (object)id169_type && (object) Reader.NamespaceURI == (object)id4_Item)) {
                    o.@Type = ToXmlQualifiedName(Reader.Value);
                    paramsRead[3] = true;
                }
                else if (!IsXmlnsAttribute(Reader.Name)) {
                    UnknownNode((object)o);
                }
            }
            Reader.MoveToElement();
            if (Reader.IsEmptyElement) {
                Reader.Skip();
                return o;
            }
            Reader.ReadStartElement();
            Reader.MoveToContent();
            while (Reader.NodeType != System.Xml.XmlNodeType.EndElement) {
                if (Reader.NodeType == System.Xml.XmlNodeType.Element) {
                    if (!paramsRead[0] && ((object) Reader.LocalName == (object)id6_documentation && (object) Reader.NamespaceURI == (object)id2_httpschemasxmlsoaporgwsdl)) {
                        o.@Documentation = Reader.ReadElementString();
                        paramsRead[0] = true;
                    }
                    else {
                        UnknownNode((object)o);
                    }
                }
                else {
                    UnknownNode((object)o);
                }
                Reader.MoveToContent();
            }
            ReadEndElement();
            return o;
        }

        System.Web.Services.Description.PortType Read70_PortType(bool isNullable, bool checkType) {
            if (isNullable && ReadNull()) return null;
            if (checkType) {
                System.Xml.XmlQualifiedName t = GetXsiType();
                if (t == null || ((object) ((System.Xml.XmlQualifiedName)t).Name == (object)id27_PortType && (object) ((System.Xml.XmlQualifiedName)t).Namespace == (object)id2_httpschemasxmlsoaporgwsdl))
                    ;
                else
                    throw CreateUnknownTypeException((System.Xml.XmlQualifiedName)t);
            }
            System.Web.Services.Description.PortType o = new System.Web.Services.Description.PortType();
            System.Web.Services.Description.OperationCollection a_1 = (System.Web.Services.Description.OperationCollection)o.@Operations;
            bool[] paramsRead = new bool[3];
            while (Reader.MoveToNextAttribute()) {
                if (!paramsRead[2] && ((object) Reader.LocalName == (object)id5_name && (object) Reader.NamespaceURI == (object)id4_Item)) {
                    o.@Name = ToXmlNCName(Reader.Value);
                    paramsRead[2] = true;
                }
                else if (!IsXmlnsAttribute(Reader.Name)) {
                    UnknownNode((object)o);
                }
            }
            Reader.MoveToElement();
            if (Reader.IsEmptyElement) {
                Reader.Skip();
                return o;
            }
            Reader.ReadStartElement();
            Reader.MoveToContent();
            while (Reader.NodeType != System.Xml.XmlNodeType.EndElement) {
                if (Reader.NodeType == System.Xml.XmlNodeType.Element) {
                    if (!paramsRead[0] && ((object) Reader.LocalName == (object)id6_documentation && (object) Reader.NamespaceURI == (object)id2_httpschemasxmlsoaporgwsdl)) {
                        o.@Documentation = Reader.ReadElementString();
                        paramsRead[0] = true;
                    }
                    else if (((object) Reader.LocalName == (object)id196_operation && (object) Reader.NamespaceURI == (object)id2_httpschemasxmlsoaporgwsdl)) {
                        if ((object)(a_1) == null) Reader.Skip(); else a_1.Add(Read71_Operation(false, true));
                    }
                    else {
                        UnknownNode((object)o);
                    }
                }
                else {
                    UnknownNode((object)o);
                }
                Reader.MoveToContent();
            }
            ReadEndElement();
            return o;
        }

        System.Web.Services.Description.Operation Read71_Operation(bool isNullable, bool checkType) {
            if (isNullable && ReadNull()) return null;
            if (checkType) {
                System.Xml.XmlQualifiedName t = GetXsiType();
                if (t == null || ((object) ((System.Xml.XmlQualifiedName)t).Name == (object)id26_Operation && (object) ((System.Xml.XmlQualifiedName)t).Namespace == (object)id2_httpschemasxmlsoaporgwsdl))
                    ;
                else
                    throw CreateUnknownTypeException((System.Xml.XmlQualifiedName)t);
            }
            System.Web.Services.Description.Operation o = new System.Web.Services.Description.Operation();
            System.Web.Services.Description.OperationMessageCollection a_3 = (System.Web.Services.Description.OperationMessageCollection)o.@Messages;
            System.Web.Services.Description.OperationFaultCollection a_4 = (System.Web.Services.Description.OperationFaultCollection)o.@Faults;
            bool[] paramsRead = new bool[5];
            while (Reader.MoveToNextAttribute()) {
                if (!paramsRead[1] && ((object) Reader.LocalName == (object)id5_name && (object) Reader.NamespaceURI == (object)id4_Item)) {
                    o.@Name = ToXmlNCName(Reader.Value);
                    paramsRead[1] = true;
                }
                else if (!paramsRead[2] && ((object) Reader.LocalName == (object)id197_parameterOrder && (object) Reader.NamespaceURI == (object)id4_Item)) {
                    o.@ParameterOrderString = Reader.Value;
                    paramsRead[2] = true;
                }
                else if (!IsXmlnsAttribute(Reader.Name)) {
                    UnknownNode((object)o);
                }
            }
            Reader.MoveToElement();
            if (Reader.IsEmptyElement) {
                Reader.Skip();
                return o;
            }
            Reader.ReadStartElement();
            Reader.MoveToContent();
            while (Reader.NodeType != System.Xml.XmlNodeType.EndElement) {
                if (Reader.NodeType == System.Xml.XmlNodeType.Element) {
                    if (!paramsRead[0] && ((object) Reader.LocalName == (object)id6_documentation && (object) Reader.NamespaceURI == (object)id2_httpschemasxmlsoaporgwsdl)) {
                        o.@Documentation = Reader.ReadElementString();
                        paramsRead[0] = true;
                    }
                    else if (((object) Reader.LocalName == (object)id198_output && (object) Reader.NamespaceURI == (object)id2_httpschemasxmlsoaporgwsdl)) {
                        if ((object)(a_3) == null) Reader.Skip(); else a_3.Add(Read74_OperationOutput(false, true));
                    }
                    else if (((object) Reader.LocalName == (object)id199_input && (object) Reader.NamespaceURI == (object)id2_httpschemasxmlsoaporgwsdl)) {
                        if ((object)(a_3) == null) Reader.Skip(); else a_3.Add(Read72_OperationInput(false, true));
                    }
                    else if (((object) Reader.LocalName == (object)id200_fault && (object) Reader.NamespaceURI == (object)id2_httpschemasxmlsoaporgwsdl)) {
                        if ((object)(a_4) == null) Reader.Skip(); else a_4.Add(Read75_OperationFault(false, true));
                    }
                    else {
                        UnknownNode((object)o);
                    }
                }
                else {
                    UnknownNode((object)o);
                }
                Reader.MoveToContent();
            }
            ReadEndElement();
            return o;
        }

        System.Web.Services.Description.OperationInput Read72_OperationInput(bool isNullable, bool checkType) {
            if (isNullable && ReadNull()) return null;
            if (checkType) {
                System.Xml.XmlQualifiedName t = GetXsiType();
                if (t == null || ((object) ((System.Xml.XmlQualifiedName)t).Name == (object)id25_OperationInput && (object) ((System.Xml.XmlQualifiedName)t).Namespace == (object)id2_httpschemasxmlsoaporgwsdl))
                    ;
                else
                    throw CreateUnknownTypeException((System.Xml.XmlQualifiedName)t);
            }
            System.Web.Services.Description.OperationInput o = new System.Web.Services.Description.OperationInput();
            bool[] paramsRead = new bool[3];
            while (Reader.MoveToNextAttribute()) {
                if (!paramsRead[1] && ((object) Reader.LocalName == (object)id5_name && (object) Reader.NamespaceURI == (object)id4_Item)) {
                    o.@Name = ToXmlNmToken(Reader.Value);
                    paramsRead[1] = true;
                }
                else if (!paramsRead[2] && ((object) Reader.LocalName == (object)id9_message && (object) Reader.NamespaceURI == (object)id4_Item)) {
                    o.@Message = ToXmlQualifiedName(Reader.Value);
                    paramsRead[2] = true;
                }
                else if (!IsXmlnsAttribute(Reader.Name)) {
                    UnknownNode((object)o);
                }
            }
            Reader.MoveToElement();
            if (Reader.IsEmptyElement) {
                Reader.Skip();
                return o;
            }
            Reader.ReadStartElement();
            Reader.MoveToContent();
            while (Reader.NodeType != System.Xml.XmlNodeType.EndElement) {
                if (Reader.NodeType == System.Xml.XmlNodeType.Element) {
                    if (!paramsRead[0] && ((object) Reader.LocalName == (object)id6_documentation && (object) Reader.NamespaceURI == (object)id2_httpschemasxmlsoaporgwsdl)) {
                        o.@Documentation = Reader.ReadElementString();
                        paramsRead[0] = true;
                    }
                    else {
                        UnknownNode((object)o);
                    }
                }
                else {
                    UnknownNode((object)o);
                }
                Reader.MoveToContent();
            }
            ReadEndElement();
            return o;
        }

        System.Web.Services.Description.OperationMessage Read73_OperationMessage(bool isNullable, bool checkType) {
            if (isNullable && ReadNull()) return null;
            if (checkType) {
                System.Xml.XmlQualifiedName t = GetXsiType();
                if (t == null || ((object) ((System.Xml.XmlQualifiedName)t).Name == (object)id22_OperationMessage && (object) ((System.Xml.XmlQualifiedName)t).Namespace == (object)id2_httpschemasxmlsoaporgwsdl))
                    ;
                else if (((object) ((System.Xml.XmlQualifiedName)t).Name == (object)id23_OperationFault && (object) ((System.Xml.XmlQualifiedName)t).Namespace == (object)id2_httpschemasxmlsoaporgwsdl))
                    return Read75_OperationFault(isNullable, false);
                else if (((object) ((System.Xml.XmlQualifiedName)t).Name == (object)id24_OperationOutput && (object) ((System.Xml.XmlQualifiedName)t).Namespace == (object)id2_httpschemasxmlsoaporgwsdl))
                    return Read74_OperationOutput(isNullable, false);
                else if (((object) ((System.Xml.XmlQualifiedName)t).Name == (object)id25_OperationInput && (object) ((System.Xml.XmlQualifiedName)t).Namespace == (object)id2_httpschemasxmlsoaporgwsdl))
                    return Read72_OperationInput(isNullable, false);
                else
                    throw CreateUnknownTypeException((System.Xml.XmlQualifiedName)t);
            }
            throw CreateAbstractTypeException(@"OperationMessage", @"http://schemas.xmlsoap.org/wsdl/");
        }

        System.Web.Services.Description.OperationOutput Read74_OperationOutput(bool isNullable, bool checkType) {
            if (isNullable && ReadNull()) return null;
            if (checkType) {
                System.Xml.XmlQualifiedName t = GetXsiType();
                if (t == null || ((object) ((System.Xml.XmlQualifiedName)t).Name == (object)id24_OperationOutput && (object) ((System.Xml.XmlQualifiedName)t).Namespace == (object)id2_httpschemasxmlsoaporgwsdl))
                    ;
                else
                    throw CreateUnknownTypeException((System.Xml.XmlQualifiedName)t);
            }
            System.Web.Services.Description.OperationOutput o = new System.Web.Services.Description.OperationOutput();
            bool[] paramsRead = new bool[3];
            while (Reader.MoveToNextAttribute()) {
                if (!paramsRead[1] && ((object) Reader.LocalName == (object)id5_name && (object) Reader.NamespaceURI == (object)id4_Item)) {
                    o.@Name = ToXmlNmToken(Reader.Value);
                    paramsRead[1] = true;
                }
                else if (!paramsRead[2] && ((object) Reader.LocalName == (object)id9_message && (object) Reader.NamespaceURI == (object)id4_Item)) {
                    o.@Message = ToXmlQualifiedName(Reader.Value);
                    paramsRead[2] = true;
                }
                else if (!IsXmlnsAttribute(Reader.Name)) {
                    UnknownNode((object)o);
                }
            }
            Reader.MoveToElement();
            if (Reader.IsEmptyElement) {
                Reader.Skip();
                return o;
            }
            Reader.ReadStartElement();
            Reader.MoveToContent();
            while (Reader.NodeType != System.Xml.XmlNodeType.EndElement) {
                if (Reader.NodeType == System.Xml.XmlNodeType.Element) {
                    if (!paramsRead[0] && ((object) Reader.LocalName == (object)id6_documentation && (object) Reader.NamespaceURI == (object)id2_httpschemasxmlsoaporgwsdl)) {
                        o.@Documentation = Reader.ReadElementString();
                        paramsRead[0] = true;
                    }
                    else {
                        UnknownNode((object)o);
                    }
                }
                else {
                    UnknownNode((object)o);
                }
                Reader.MoveToContent();
            }
            ReadEndElement();
            return o;
        }

        System.Web.Services.Description.OperationFault Read75_OperationFault(bool isNullable, bool checkType) {
            if (isNullable && ReadNull()) return null;
            if (checkType) {
                System.Xml.XmlQualifiedName t = GetXsiType();
                if (t == null || ((object) ((System.Xml.XmlQualifiedName)t).Name == (object)id23_OperationFault && (object) ((System.Xml.XmlQualifiedName)t).Namespace == (object)id2_httpschemasxmlsoaporgwsdl))
                    ;
                else
                    throw CreateUnknownTypeException((System.Xml.XmlQualifiedName)t);
            }
            System.Web.Services.Description.OperationFault o = new System.Web.Services.Description.OperationFault();
            bool[] paramsRead = new bool[3];
            while (Reader.MoveToNextAttribute()) {
                if (!paramsRead[1] && ((object) Reader.LocalName == (object)id5_name && (object) Reader.NamespaceURI == (object)id4_Item)) {
                    o.@Name = ToXmlNmToken(Reader.Value);
                    paramsRead[1] = true;
                }
                else if (!paramsRead[2] && ((object) Reader.LocalName == (object)id9_message && (object) Reader.NamespaceURI == (object)id4_Item)) {
                    o.@Message = ToXmlQualifiedName(Reader.Value);
                    paramsRead[2] = true;
                }
                else if (!IsXmlnsAttribute(Reader.Name)) {
                    UnknownNode((object)o);
                }
            }
            Reader.MoveToElement();
            if (Reader.IsEmptyElement) {
                Reader.Skip();
                return o;
            }
            Reader.ReadStartElement();
            Reader.MoveToContent();
            while (Reader.NodeType != System.Xml.XmlNodeType.EndElement) {
                if (Reader.NodeType == System.Xml.XmlNodeType.Element) {
                    if (!paramsRead[0] && ((object) Reader.LocalName == (object)id6_documentation && (object) Reader.NamespaceURI == (object)id2_httpschemasxmlsoaporgwsdl)) {
                        o.@Documentation = Reader.ReadElementString();
                        paramsRead[0] = true;
                    }
                    else {
                        UnknownNode((object)o);
                    }
                }
                else {
                    UnknownNode((object)o);
                }
                Reader.MoveToContent();
            }
            ReadEndElement();
            return o;
        }

        System.Web.Services.Description.Binding Read76_Binding(bool isNullable, bool checkType) {
            if (isNullable && ReadNull()) return null;
            if (checkType) {
                System.Xml.XmlQualifiedName t = GetXsiType();
                if (t == null || ((object) ((System.Xml.XmlQualifiedName)t).Name == (object)id21_Binding && (object) ((System.Xml.XmlQualifiedName)t).Namespace == (object)id2_httpschemasxmlsoaporgwsdl))
                    ;
                else
                    throw CreateUnknownTypeException((System.Xml.XmlQualifiedName)t);
            }
            System.Web.Services.Description.Binding o = new System.Web.Services.Description.Binding();
            System.Web.Services.Description.ServiceDescriptionFormatExtensionCollection a_1 = (System.Web.Services.Description.ServiceDescriptionFormatExtensionCollection)o.@Extensions;
            System.Web.Services.Description.OperationBindingCollection a_2 = (System.Web.Services.Description.OperationBindingCollection)o.@Operations;
            bool[] paramsRead = new bool[5];
            while (Reader.MoveToNextAttribute()) {
                if (!paramsRead[3] && ((object) Reader.LocalName == (object)id5_name && (object) Reader.NamespaceURI == (object)id4_Item)) {
                    o.@Name = ToXmlNCName(Reader.Value);
                    paramsRead[3] = true;
                }
                else if (!paramsRead[4] && ((object) Reader.LocalName == (object)id169_type && (object) Reader.NamespaceURI == (object)id4_Item)) {
                    o.@Type = ToXmlQualifiedName(Reader.Value);
                    paramsRead[4] = true;
                }
                else if (!IsXmlnsAttribute(Reader.Name)) {
                    UnknownNode((object)o);
                }
            }
            Reader.MoveToElement();
            if (Reader.IsEmptyElement) {
                Reader.Skip();
                return o;
            }
            Reader.ReadStartElement();
            Reader.MoveToContent();
            while (Reader.NodeType != System.Xml.XmlNodeType.EndElement) {
                if (Reader.NodeType == System.Xml.XmlNodeType.Element) {
                    if (!paramsRead[0] && ((object) Reader.LocalName == (object)id6_documentation && (object) Reader.NamespaceURI == (object)id2_httpschemasxmlsoaporgwsdl)) {
                        o.@Documentation = Reader.ReadElementString();
                        paramsRead[0] = true;
                    }
                    else if (((object) Reader.LocalName == (object)id11_binding && (object) Reader.NamespaceURI == (object)id49_httpschemasxmlsoaporgwsdlhttp)) {
                        if ((object)(a_1) == null) Reader.Skip(); else a_1.Add(Read77_HttpBinding(false, true));
                    }
                    else if (((object) Reader.LocalName == (object)id11_binding && (object) Reader.NamespaceURI == (object)id41_httpschemasxmlsoaporgwsdlsoap)) {
                        if ((object)(a_1) == null) Reader.Skip(); else a_1.Add(Read79_SoapBinding(false, true));
                    }
                    else if (((object) Reader.LocalName == (object)id196_operation && (object) Reader.NamespaceURI == (object)id2_httpschemasxmlsoaporgwsdl)) {
                        if ((object)(a_2) == null) Reader.Skip(); else a_2.Add(Read82_OperationBinding(false, true));
                    }
                    else {
                        a_1.Add((System.Xml.XmlElement)ReadXmlNode(false));
                    }
                }
                else {
                    UnknownNode((object)o);
                }
                Reader.MoveToContent();
            }
            ReadEndElement();
            return o;
        }

        System.Web.Services.Description.HttpBinding Read77_HttpBinding(bool isNullable, bool checkType) {
            if (isNullable && ReadNull()) return null;
            if (checkType) {
                System.Xml.XmlQualifiedName t = GetXsiType();
                if (t == null || ((object) ((System.Xml.XmlQualifiedName)t).Name == (object)id54_HttpBinding && (object) ((System.Xml.XmlQualifiedName)t).Namespace == (object)id49_httpschemasxmlsoaporgwsdlhttp))
                    ;
                else
                    throw CreateUnknownTypeException((System.Xml.XmlQualifiedName)t);
            }
            System.Web.Services.Description.HttpBinding o = new System.Web.Services.Description.HttpBinding();
            bool[] paramsRead = new bool[2];
            while (Reader.MoveToNextAttribute()) {
                if (!paramsRead[0] && ((object) Reader.LocalName == (object)id201_required && (object) Reader.NamespaceURI == (object)id2_httpschemasxmlsoaporgwsdl)) {
                    o.@Required = System.Xml.XmlConvert.ToBoolean(Reader.Value);
                    paramsRead[0] = true;
                }
                else if (!paramsRead[1] && ((object) Reader.LocalName == (object)id202_verb && (object) Reader.NamespaceURI == (object)id4_Item)) {
                    o.@Verb = ToXmlNmToken(Reader.Value);
                    paramsRead[1] = true;
                }
                else if (!IsXmlnsAttribute(Reader.Name)) {
                    UnknownNode((object)o);
                }
            }
            Reader.MoveToElement();
            if (Reader.IsEmptyElement) {
                Reader.Skip();
                return o;
            }
            Reader.ReadStartElement();
            Reader.MoveToContent();
            while (Reader.NodeType != System.Xml.XmlNodeType.EndElement) {
                if (Reader.NodeType == System.Xml.XmlNodeType.Element) {
                    UnknownNode((object)o);
                }
                else {
                    UnknownNode((object)o);
                }
                Reader.MoveToContent();
            }
            ReadEndElement();
            return o;
        }

        System.Web.Services.Description.ServiceDescriptionFormatExtension Read78_ServiceDescriptionFormatExtension(bool isNullable, bool checkType) {
            if (isNullable && ReadNull()) return null;
            if (checkType) {
                System.Xml.XmlQualifiedName t = GetXsiType();
                if (t == null || ((object) ((System.Xml.XmlQualifiedName)t).Name == (object)id34_ServiceDescriptionFormatExtension && (object) ((System.Xml.XmlQualifiedName)t).Namespace == (object)id49_httpschemasxmlsoaporgwsdlhttp))
                    ;
                else if (((object) ((System.Xml.XmlQualifiedName)t).Name == (object)id50_HttpAddressBinding && (object) ((System.Xml.XmlQualifiedName)t).Namespace == (object)id49_httpschemasxmlsoaporgwsdlhttp))
                    return Read106_HttpAddressBinding(isNullable, false);
                else if (((object) ((System.Xml.XmlQualifiedName)t).Name == (object)id51_HttpUrlReplacementBinding && (object) ((System.Xml.XmlQualifiedName)t).Namespace == (object)id49_httpschemasxmlsoaporgwsdlhttp))
                    return Read88_HttpUrlReplacementBinding(isNullable, false);
                else if (((object) ((System.Xml.XmlQualifiedName)t).Name == (object)id52_HttpUrlEncodedBinding && (object) ((System.Xml.XmlQualifiedName)t).Namespace == (object)id49_httpschemasxmlsoaporgwsdlhttp))
                    return Read87_HttpUrlEncodedBinding(isNullable, false);
                else if (((object) ((System.Xml.XmlQualifiedName)t).Name == (object)id53_HttpOperationBinding && (object) ((System.Xml.XmlQualifiedName)t).Namespace == (object)id49_httpschemasxmlsoaporgwsdlhttp))
                    return Read83_HttpOperationBinding(isNullable, false);
                else if (((object) ((System.Xml.XmlQualifiedName)t).Name == (object)id54_HttpBinding && (object) ((System.Xml.XmlQualifiedName)t).Namespace == (object)id49_httpschemasxmlsoaporgwsdlhttp))
                    return Read77_HttpBinding(isNullable, false);
                else
                    throw CreateUnknownTypeException((System.Xml.XmlQualifiedName)t);
            }
            throw CreateAbstractTypeException(@"ServiceDescriptionFormatExtension", @"http://schemas.xmlsoap.org/wsdl/http/");
        }

        System.Web.Services.Description.SoapBinding Read79_SoapBinding(bool isNullable, bool checkType) {
            if (isNullable && ReadNull()) return null;
            if (checkType) {
                System.Xml.XmlQualifiedName t = GetXsiType();
                if (t == null || ((object) ((System.Xml.XmlQualifiedName)t).Name == (object)id48_SoapBinding && (object) ((System.Xml.XmlQualifiedName)t).Namespace == (object)id41_httpschemasxmlsoaporgwsdlsoap))
                    ;
                else
                    throw CreateUnknownTypeException((System.Xml.XmlQualifiedName)t);
            }
            System.Web.Services.Description.SoapBinding o = new System.Web.Services.Description.SoapBinding();
            bool[] paramsRead = new bool[3];
            while (Reader.MoveToNextAttribute()) {
                if (!paramsRead[0] && ((object) Reader.LocalName == (object)id201_required && (object) Reader.NamespaceURI == (object)id2_httpschemasxmlsoaporgwsdl)) {
                    o.@Required = System.Xml.XmlConvert.ToBoolean(Reader.Value);
                    paramsRead[0] = true;
                }
                else if (!paramsRead[1] && ((object) Reader.LocalName == (object)id203_transport && (object) Reader.NamespaceURI == (object)id4_Item)) {
                    o.@Transport = Reader.Value;
                    paramsRead[1] = true;
                }
                else if (!paramsRead[2] && ((object) Reader.LocalName == (object)id204_style && (object) Reader.NamespaceURI == (object)id4_Item)) {
                    o.@Style = Read81_SoapBindingStyle(Reader.Value);
                    paramsRead[2] = true;
                }
                else if (!IsXmlnsAttribute(Reader.Name)) {
                    UnknownNode((object)o);
                }
            }
            Reader.MoveToElement();
            if (Reader.IsEmptyElement) {
                Reader.Skip();
                return o;
            }
            Reader.ReadStartElement();
            Reader.MoveToContent();
            while (Reader.NodeType != System.Xml.XmlNodeType.EndElement) {
                if (Reader.NodeType == System.Xml.XmlNodeType.Element) {
                    UnknownNode((object)o);
                }
                else {
                    UnknownNode((object)o);
                }
                Reader.MoveToContent();
            }
            ReadEndElement();
            return o;
        }

        System.Web.Services.Description.ServiceDescriptionFormatExtension Read80_ServiceDescriptionFormatExtension(bool isNullable, bool checkType) {
            if (isNullable && ReadNull()) return null;
            if (checkType) {
                System.Xml.XmlQualifiedName t = GetXsiType();
                if (t == null || ((object) ((System.Xml.XmlQualifiedName)t).Name == (object)id34_ServiceDescriptionFormatExtension && (object) ((System.Xml.XmlQualifiedName)t).Namespace == (object)id41_httpschemasxmlsoaporgwsdlsoap))
                    ;
                else if (((object) ((System.Xml.XmlQualifiedName)t).Name == (object)id42_SoapAddressBinding && (object) ((System.Xml.XmlQualifiedName)t).Namespace == (object)id41_httpschemasxmlsoaporgwsdlsoap))
                    return Read107_SoapAddressBinding(isNullable, false);
                else if (((object) ((System.Xml.XmlQualifiedName)t).Name == (object)id43_SoapFaultBinding && (object) ((System.Xml.XmlQualifiedName)t).Namespace == (object)id41_httpschemasxmlsoaporgwsdlsoap))
                    return Read103_SoapFaultBinding(isNullable, false);
                else if (((object) ((System.Xml.XmlQualifiedName)t).Name == (object)id44_SoapHeaderFaultBinding && (object) ((System.Xml.XmlQualifiedName)t).Namespace == (object)id41_httpschemasxmlsoaporgwsdlsoap))
                    return Read100_SoapHeaderFaultBinding(isNullable, false);
                else if (((object) ((System.Xml.XmlQualifiedName)t).Name == (object)id45_SoapHeaderBinding && (object) ((System.Xml.XmlQualifiedName)t).Namespace == (object)id41_httpschemasxmlsoaporgwsdlsoap))
                    return Read99_SoapHeaderBinding(isNullable, false);
                else if (((object) ((System.Xml.XmlQualifiedName)t).Name == (object)id46_SoapBodyBinding && (object) ((System.Xml.XmlQualifiedName)t).Namespace == (object)id41_httpschemasxmlsoaporgwsdlsoap))
                    return Read97_SoapBodyBinding(isNullable, false);
                else if (((object) ((System.Xml.XmlQualifiedName)t).Name == (object)id47_SoapOperationBinding && (object) ((System.Xml.XmlQualifiedName)t).Namespace == (object)id41_httpschemasxmlsoaporgwsdlsoap))
                    return Read84_SoapOperationBinding(isNullable, false);
                else if (((object) ((System.Xml.XmlQualifiedName)t).Name == (object)id48_SoapBinding && (object) ((System.Xml.XmlQualifiedName)t).Namespace == (object)id41_httpschemasxmlsoaporgwsdlsoap))
                    return Read79_SoapBinding(isNullable, false);
                else
                    throw CreateUnknownTypeException((System.Xml.XmlQualifiedName)t);
            }
            throw CreateAbstractTypeException(@"ServiceDescriptionFormatExtension", @"http://schemas.xmlsoap.org/wsdl/soap/");
        }

        System.Web.Services.Description.SoapBindingStyle Read81_SoapBindingStyle(string s) {
            switch (s) {
                case @"document": return System.Web.Services.Description.SoapBindingStyle.@Document;
                case @"rpc": return System.Web.Services.Description.SoapBindingStyle.@Rpc;
                default: throw CreateUnknownConstantException(s, typeof(System.Web.Services.Description.SoapBindingStyle));
            }
        }

        System.Web.Services.Description.OperationBinding Read82_OperationBinding(bool isNullable, bool checkType) {
            if (isNullable && ReadNull()) return null;
            if (checkType) {
                System.Xml.XmlQualifiedName t = GetXsiType();
                if (t == null || ((object) ((System.Xml.XmlQualifiedName)t).Name == (object)id20_OperationBinding && (object) ((System.Xml.XmlQualifiedName)t).Namespace == (object)id2_httpschemasxmlsoaporgwsdl))
                    ;
                else
                    throw CreateUnknownTypeException((System.Xml.XmlQualifiedName)t);
            }
            System.Web.Services.Description.OperationBinding o = new System.Web.Services.Description.OperationBinding();
            System.Web.Services.Description.ServiceDescriptionFormatExtensionCollection a_2 = (System.Web.Services.Description.ServiceDescriptionFormatExtensionCollection)o.@Extensions;
            System.Web.Services.Description.FaultBindingCollection a_5 = (System.Web.Services.Description.FaultBindingCollection)o.@Faults;
            bool[] paramsRead = new bool[6];
            while (Reader.MoveToNextAttribute()) {
                if (!paramsRead[1] && ((object) Reader.LocalName == (object)id5_name && (object) Reader.NamespaceURI == (object)id4_Item)) {
                    o.@Name = ToXmlNCName(Reader.Value);
                    paramsRead[1] = true;
                }
                else if (!IsXmlnsAttribute(Reader.Name)) {
                    UnknownNode((object)o);
                }
            }
            Reader.MoveToElement();
            if (Reader.IsEmptyElement) {
                Reader.Skip();
                return o;
            }
            Reader.ReadStartElement();
            Reader.MoveToContent();
            while (Reader.NodeType != System.Xml.XmlNodeType.EndElement) {
                if (Reader.NodeType == System.Xml.XmlNodeType.Element) {
                    if (!paramsRead[0] && ((object) Reader.LocalName == (object)id6_documentation && (object) Reader.NamespaceURI == (object)id2_httpschemasxmlsoaporgwsdl)) {
                        o.@Documentation = Reader.ReadElementString();
                        paramsRead[0] = true;
                    }
                    else if (((object) Reader.LocalName == (object)id196_operation && (object) Reader.NamespaceURI == (object)id41_httpschemasxmlsoaporgwsdlsoap)) {
                        if ((object)(a_2) == null) Reader.Skip(); else a_2.Add(Read84_SoapOperationBinding(false, true));
                    }
                    else if (((object) Reader.LocalName == (object)id196_operation && (object) Reader.NamespaceURI == (object)id49_httpschemasxmlsoaporgwsdlhttp)) {
                        if ((object)(a_2) == null) Reader.Skip(); else a_2.Add(Read83_HttpOperationBinding(false, true));
                    }
                    else if (!paramsRead[3] && ((object) Reader.LocalName == (object)id199_input && (object) Reader.NamespaceURI == (object)id2_httpschemasxmlsoaporgwsdl)) {
                        o.@Input = Read85_InputBinding(false, true);
                        paramsRead[3] = true;
                    }
                    else if (!paramsRead[4] && ((object) Reader.LocalName == (object)id198_output && (object) Reader.NamespaceURI == (object)id2_httpschemasxmlsoaporgwsdl)) {
                        o.@Output = Read101_OutputBinding(false, true);
                        paramsRead[4] = true;
                    }
                    else if (((object) Reader.LocalName == (object)id200_fault && (object) Reader.NamespaceURI == (object)id2_httpschemasxmlsoaporgwsdl)) {
                        if ((object)(a_5) == null) Reader.Skip(); else a_5.Add(Read102_FaultBinding(false, true));
                    }
                    else {
                        a_2.Add((System.Xml.XmlElement)ReadXmlNode(false));
                    }
                }
                else {
                    UnknownNode((object)o);
                }
                Reader.MoveToContent();
            }
            ReadEndElement();
            return o;
        }

        System.Web.Services.Description.HttpOperationBinding Read83_HttpOperationBinding(bool isNullable, bool checkType) {
            if (isNullable && ReadNull()) return null;
            if (checkType) {
                System.Xml.XmlQualifiedName t = GetXsiType();
                if (t == null || ((object) ((System.Xml.XmlQualifiedName)t).Name == (object)id53_HttpOperationBinding && (object) ((System.Xml.XmlQualifiedName)t).Namespace == (object)id49_httpschemasxmlsoaporgwsdlhttp))
                    ;
                else
                    throw CreateUnknownTypeException((System.Xml.XmlQualifiedName)t);
            }
            System.Web.Services.Description.HttpOperationBinding o = new System.Web.Services.Description.HttpOperationBinding();
            bool[] paramsRead = new bool[2];
            while (Reader.MoveToNextAttribute()) {
                if (!paramsRead[0] && ((object) Reader.LocalName == (object)id201_required && (object) Reader.NamespaceURI == (object)id2_httpschemasxmlsoaporgwsdl)) {
                    o.@Required = System.Xml.XmlConvert.ToBoolean(Reader.Value);
                    paramsRead[0] = true;
                }
                else if (!paramsRead[1] && ((object) Reader.LocalName == (object)id121_location && (object) Reader.NamespaceURI == (object)id4_Item)) {
                    o.@Location = Reader.Value;
                    paramsRead[1] = true;
                }
                else if (!IsXmlnsAttribute(Reader.Name)) {
                    UnknownNode((object)o);
                }
            }
            Reader.MoveToElement();
            if (Reader.IsEmptyElement) {
                Reader.Skip();
                return o;
            }
            Reader.ReadStartElement();
            Reader.MoveToContent();
            while (Reader.NodeType != System.Xml.XmlNodeType.EndElement) {
                if (Reader.NodeType == System.Xml.XmlNodeType.Element) {
                    UnknownNode((object)o);
                }
                else {
                    UnknownNode((object)o);
                }
                Reader.MoveToContent();
            }
            ReadEndElement();
            return o;
        }

        System.Web.Services.Description.SoapOperationBinding Read84_SoapOperationBinding(bool isNullable, bool checkType) {
            if (isNullable && ReadNull()) return null;
            if (checkType) {
                System.Xml.XmlQualifiedName t = GetXsiType();
                if (t == null || ((object) ((System.Xml.XmlQualifiedName)t).Name == (object)id47_SoapOperationBinding && (object) ((System.Xml.XmlQualifiedName)t).Namespace == (object)id41_httpschemasxmlsoaporgwsdlsoap))
                    ;
                else
                    throw CreateUnknownTypeException((System.Xml.XmlQualifiedName)t);
            }
            System.Web.Services.Description.SoapOperationBinding o = new System.Web.Services.Description.SoapOperationBinding();
            bool[] paramsRead = new bool[3];
            while (Reader.MoveToNextAttribute()) {
                if (!paramsRead[0] && ((object) Reader.LocalName == (object)id201_required && (object) Reader.NamespaceURI == (object)id2_httpschemasxmlsoaporgwsdl)) {
                    o.@Required = System.Xml.XmlConvert.ToBoolean(Reader.Value);
                    paramsRead[0] = true;
                }
                else if (!paramsRead[1] && ((object) Reader.LocalName == (object)id205_soapAction && (object) Reader.NamespaceURI == (object)id4_Item)) {
                    o.@SoapAction = Reader.Value;
                    paramsRead[1] = true;
                }
                else if (!paramsRead[2] && ((object) Reader.LocalName == (object)id204_style && (object) Reader.NamespaceURI == (object)id4_Item)) {
                    o.@Style = Read81_SoapBindingStyle(Reader.Value);
                    paramsRead[2] = true;
                }
                else if (!IsXmlnsAttribute(Reader.Name)) {
                    UnknownNode((object)o);
                }
            }
            Reader.MoveToElement();
            if (Reader.IsEmptyElement) {
                Reader.Skip();
                return o;
            }
            Reader.ReadStartElement();
            Reader.MoveToContent();
            while (Reader.NodeType != System.Xml.XmlNodeType.EndElement) {
                if (Reader.NodeType == System.Xml.XmlNodeType.Element) {
                    UnknownNode((object)o);
                }
                else {
                    UnknownNode((object)o);
                }
                Reader.MoveToContent();
            }
            ReadEndElement();
            return o;
        }

        System.Web.Services.Description.InputBinding Read85_InputBinding(bool isNullable, bool checkType) {
            if (isNullable && ReadNull()) return null;
            if (checkType) {
                System.Xml.XmlQualifiedName t = GetXsiType();
                if (t == null || ((object) ((System.Xml.XmlQualifiedName)t).Name == (object)id19_InputBinding && (object) ((System.Xml.XmlQualifiedName)t).Namespace == (object)id2_httpschemasxmlsoaporgwsdl))
                    ;
                else
                    throw CreateUnknownTypeException((System.Xml.XmlQualifiedName)t);
            }
            System.Web.Services.Description.InputBinding o = new System.Web.Services.Description.InputBinding();
            System.Web.Services.Description.ServiceDescriptionFormatExtensionCollection a_2 = (System.Web.Services.Description.ServiceDescriptionFormatExtensionCollection)o.@Extensions;
            bool[] paramsRead = new bool[3];
            while (Reader.MoveToNextAttribute()) {
                if (!paramsRead[1] && ((object) Reader.LocalName == (object)id5_name && (object) Reader.NamespaceURI == (object)id4_Item)) {
                    o.@Name = ToXmlNmToken(Reader.Value);
                    paramsRead[1] = true;
                }
                else if (!IsXmlnsAttribute(Reader.Name)) {
                    UnknownNode((object)o);
                }
            }
            Reader.MoveToElement();
            if (Reader.IsEmptyElement) {
                Reader.Skip();
                return o;
            }
            Reader.ReadStartElement();
            Reader.MoveToContent();
            while (Reader.NodeType != System.Xml.XmlNodeType.EndElement) {
                if (Reader.NodeType == System.Xml.XmlNodeType.Element) {
                    if (!paramsRead[0] && ((object) Reader.LocalName == (object)id6_documentation && (object) Reader.NamespaceURI == (object)id2_httpschemasxmlsoaporgwsdl)) {
                        o.@Documentation = Reader.ReadElementString();
                        paramsRead[0] = true;
                    }
                    else if (((object) Reader.LocalName == (object)id206_text && (object) Reader.NamespaceURI == (object)id33_httpmicrosoftcomwsdlmimetextMatching)) {
                        if ((object)(a_2) == null) Reader.Skip(); else a_2.Add(Read94_MimeTextBinding(false, true));
                    }
                    else if (((object) Reader.LocalName == (object)id207_body && (object) Reader.NamespaceURI == (object)id41_httpschemasxmlsoaporgwsdlsoap)) {
                        if ((object)(a_2) == null) Reader.Skip(); else a_2.Add(Read97_SoapBodyBinding(false, true));
                    }
                    else if (((object) Reader.LocalName == (object)id208_content && (object) Reader.NamespaceURI == (object)id36_httpschemasxmlsoaporgwsdlmime)) {
                        if ((object)(a_2) == null) Reader.Skip(); else a_2.Add(Read89_MimeContentBinding(false, true));
                    }
                    else if (((object) Reader.LocalName == (object)id209_header && (object) Reader.NamespaceURI == (object)id41_httpschemasxmlsoaporgwsdlsoap)) {
                        if ((object)(a_2) == null) Reader.Skip(); else a_2.Add(Read99_SoapHeaderBinding(false, true));
                    }
                    else if (((object) Reader.LocalName == (object)id210_mimeXml && (object) Reader.NamespaceURI == (object)id36_httpschemasxmlsoaporgwsdlmime)) {
                        if ((object)(a_2) == null) Reader.Skip(); else a_2.Add(Read91_MimeXmlBinding(false, true));
                    }
                    else if (((object) Reader.LocalName == (object)id211_urlReplacement && (object) Reader.NamespaceURI == (object)id49_httpschemasxmlsoaporgwsdlhttp)) {
                        if ((object)(a_2) == null) Reader.Skip(); else a_2.Add(Read88_HttpUrlReplacementBinding(false, true));
                    }
                    else if (((object) Reader.LocalName == (object)id212_urlEncoded && (object) Reader.NamespaceURI == (object)id49_httpschemasxmlsoaporgwsdlhttp)) {
                        if ((object)(a_2) == null) Reader.Skip(); else a_2.Add(Read87_HttpUrlEncodedBinding(false, true));
                    }
                    else if (((object) Reader.LocalName == (object)id213_multipartRelated && (object) Reader.NamespaceURI == (object)id36_httpschemasxmlsoaporgwsdlmime)) {
                        if ((object)(a_2) == null) Reader.Skip(); else a_2.Add(Read92_MimeMultipartRelatedBinding(false, true));
                    }
                    else {
                        a_2.Add((System.Xml.XmlElement)ReadXmlNode(false));
                    }
                }
                else {
                    UnknownNode((object)o);
                }
                Reader.MoveToContent();
            }
            ReadEndElement();
            return o;
        }

        System.Web.Services.Description.MessageBinding Read86_MessageBinding(bool isNullable, bool checkType) {
            if (isNullable && ReadNull()) return null;
            if (checkType) {
                System.Xml.XmlQualifiedName t = GetXsiType();
                if (t == null || ((object) ((System.Xml.XmlQualifiedName)t).Name == (object)id16_MessageBinding && (object) ((System.Xml.XmlQualifiedName)t).Namespace == (object)id2_httpschemasxmlsoaporgwsdl))
                    ;
                else if (((object) ((System.Xml.XmlQualifiedName)t).Name == (object)id17_FaultBinding && (object) ((System.Xml.XmlQualifiedName)t).Namespace == (object)id2_httpschemasxmlsoaporgwsdl))
                    return Read102_FaultBinding(isNullable, false);
                else if (((object) ((System.Xml.XmlQualifiedName)t).Name == (object)id18_OutputBinding && (object) ((System.Xml.XmlQualifiedName)t).Namespace == (object)id2_httpschemasxmlsoaporgwsdl))
                    return Read101_OutputBinding(isNullable, false);
                else if (((object) ((System.Xml.XmlQualifiedName)t).Name == (object)id19_InputBinding && (object) ((System.Xml.XmlQualifiedName)t).Namespace == (object)id2_httpschemasxmlsoaporgwsdl))
                    return Read85_InputBinding(isNullable, false);
                else
                    throw CreateUnknownTypeException((System.Xml.XmlQualifiedName)t);
            }
            throw CreateAbstractTypeException(@"MessageBinding", @"http://schemas.xmlsoap.org/wsdl/");
        }

        System.Web.Services.Description.HttpUrlEncodedBinding Read87_HttpUrlEncodedBinding(bool isNullable, bool checkType) {
            if (isNullable && ReadNull()) return null;
            if (checkType) {
                System.Xml.XmlQualifiedName t = GetXsiType();
                if (t == null || ((object) ((System.Xml.XmlQualifiedName)t).Name == (object)id52_HttpUrlEncodedBinding && (object) ((System.Xml.XmlQualifiedName)t).Namespace == (object)id49_httpschemasxmlsoaporgwsdlhttp))
                    ;
                else
                    throw CreateUnknownTypeException((System.Xml.XmlQualifiedName)t);
            }
            System.Web.Services.Description.HttpUrlEncodedBinding o = new System.Web.Services.Description.HttpUrlEncodedBinding();
            bool[] paramsRead = new bool[1];
            while (Reader.MoveToNextAttribute()) {
                if (!paramsRead[0] && ((object) Reader.LocalName == (object)id201_required && (object) Reader.NamespaceURI == (object)id2_httpschemasxmlsoaporgwsdl)) {
                    o.@Required = System.Xml.XmlConvert.ToBoolean(Reader.Value);
                    paramsRead[0] = true;
                }
                else if (!IsXmlnsAttribute(Reader.Name)) {
                    UnknownNode((object)o);
                }
            }
            Reader.MoveToElement();
            if (Reader.IsEmptyElement) {
                Reader.Skip();
                return o;
            }
            Reader.ReadStartElement();
            Reader.MoveToContent();
            while (Reader.NodeType != System.Xml.XmlNodeType.EndElement) {
                if (Reader.NodeType == System.Xml.XmlNodeType.Element) {
                    UnknownNode((object)o);
                }
                else {
                    UnknownNode((object)o);
                }
                Reader.MoveToContent();
            }
            ReadEndElement();
            return o;
        }

        System.Web.Services.Description.HttpUrlReplacementBinding Read88_HttpUrlReplacementBinding(bool isNullable, bool checkType) {
            if (isNullable && ReadNull()) return null;
            if (checkType) {
                System.Xml.XmlQualifiedName t = GetXsiType();
                if (t == null || ((object) ((System.Xml.XmlQualifiedName)t).Name == (object)id51_HttpUrlReplacementBinding && (object) ((System.Xml.XmlQualifiedName)t).Namespace == (object)id49_httpschemasxmlsoaporgwsdlhttp))
                    ;
                else
                    throw CreateUnknownTypeException((System.Xml.XmlQualifiedName)t);
            }
            System.Web.Services.Description.HttpUrlReplacementBinding o = new System.Web.Services.Description.HttpUrlReplacementBinding();
            bool[] paramsRead = new bool[1];
            while (Reader.MoveToNextAttribute()) {
                if (!paramsRead[0] && ((object) Reader.LocalName == (object)id201_required && (object) Reader.NamespaceURI == (object)id2_httpschemasxmlsoaporgwsdl)) {
                    o.@Required = System.Xml.XmlConvert.ToBoolean(Reader.Value);
                    paramsRead[0] = true;
                }
                else if (!IsXmlnsAttribute(Reader.Name)) {
                    UnknownNode((object)o);
                }
            }
            Reader.MoveToElement();
            if (Reader.IsEmptyElement) {
                Reader.Skip();
                return o;
            }
            Reader.ReadStartElement();
            Reader.MoveToContent();
            while (Reader.NodeType != System.Xml.XmlNodeType.EndElement) {
                if (Reader.NodeType == System.Xml.XmlNodeType.Element) {
                    UnknownNode((object)o);
                }
                else {
                    UnknownNode((object)o);
                }
                Reader.MoveToContent();
            }
            ReadEndElement();
            return o;
        }

        System.Web.Services.Description.MimeContentBinding Read89_MimeContentBinding(bool isNullable, bool checkType) {
            if (isNullable && ReadNull()) return null;
            if (checkType) {
                System.Xml.XmlQualifiedName t = GetXsiType();
                if (t == null || ((object) ((System.Xml.XmlQualifiedName)t).Name == (object)id40_MimeContentBinding && (object) ((System.Xml.XmlQualifiedName)t).Namespace == (object)id36_httpschemasxmlsoaporgwsdlmime))
                    ;
                else
                    throw CreateUnknownTypeException((System.Xml.XmlQualifiedName)t);
            }
            System.Web.Services.Description.MimeContentBinding o = new System.Web.Services.Description.MimeContentBinding();
            bool[] paramsRead = new bool[3];
            while (Reader.MoveToNextAttribute()) {
                if (!paramsRead[0] && ((object) Reader.LocalName == (object)id201_required && (object) Reader.NamespaceURI == (object)id2_httpschemasxmlsoaporgwsdl)) {
                    o.@Required = System.Xml.XmlConvert.ToBoolean(Reader.Value);
                    paramsRead[0] = true;
                }
                else if (!paramsRead[1] && ((object) Reader.LocalName == (object)id195_part && (object) Reader.NamespaceURI == (object)id4_Item)) {
                    o.@Part = ToXmlNmToken(Reader.Value);
                    paramsRead[1] = true;
                }
                else if (!paramsRead[2] && ((object) Reader.LocalName == (object)id169_type && (object) Reader.NamespaceURI == (object)id4_Item)) {
                    o.@Type = Reader.Value;
                    paramsRead[2] = true;
                }
                else if (!IsXmlnsAttribute(Reader.Name)) {
                    UnknownNode((object)o);
                }
            }
            Reader.MoveToElement();
            if (Reader.IsEmptyElement) {
                Reader.Skip();
                return o;
            }
            Reader.ReadStartElement();
            Reader.MoveToContent();
            while (Reader.NodeType != System.Xml.XmlNodeType.EndElement) {
                if (Reader.NodeType == System.Xml.XmlNodeType.Element) {
                    UnknownNode((object)o);
                }
                else {
                    UnknownNode((object)o);
                }
                Reader.MoveToContent();
            }
            ReadEndElement();
            return o;
        }

        System.Web.Services.Description.ServiceDescriptionFormatExtension Read90_ServiceDescriptionFormatExtension(bool isNullable, bool checkType) {
            if (isNullable && ReadNull()) return null;
            if (checkType) {
                System.Xml.XmlQualifiedName t = GetXsiType();
                if (t == null || ((object) ((System.Xml.XmlQualifiedName)t).Name == (object)id34_ServiceDescriptionFormatExtension && (object) ((System.Xml.XmlQualifiedName)t).Namespace == (object)id36_httpschemasxmlsoaporgwsdlmime))
                    ;
                else if (((object) ((System.Xml.XmlQualifiedName)t).Name == (object)id37_MimePart && (object) ((System.Xml.XmlQualifiedName)t).Namespace == (object)id36_httpschemasxmlsoaporgwsdlmime))
                    return Read93_MimePart(isNullable, false);
                else if (((object) ((System.Xml.XmlQualifiedName)t).Name == (object)id38_MimeMultipartRelatedBinding && (object) ((System.Xml.XmlQualifiedName)t).Namespace == (object)id36_httpschemasxmlsoaporgwsdlmime))
                    return Read92_MimeMultipartRelatedBinding(isNullable, false);
                else if (((object) ((System.Xml.XmlQualifiedName)t).Name == (object)id39_MimeXmlBinding && (object) ((System.Xml.XmlQualifiedName)t).Namespace == (object)id36_httpschemasxmlsoaporgwsdlmime))
                    return Read91_MimeXmlBinding(isNullable, false);
                else if (((object) ((System.Xml.XmlQualifiedName)t).Name == (object)id40_MimeContentBinding && (object) ((System.Xml.XmlQualifiedName)t).Namespace == (object)id36_httpschemasxmlsoaporgwsdlmime))
                    return Read89_MimeContentBinding(isNullable, false);
                else
                    throw CreateUnknownTypeException((System.Xml.XmlQualifiedName)t);
            }
            throw CreateAbstractTypeException(@"ServiceDescriptionFormatExtension", @"http://schemas.xmlsoap.org/wsdl/mime/");
        }

        System.Web.Services.Description.MimeXmlBinding Read91_MimeXmlBinding(bool isNullable, bool checkType) {
            if (isNullable && ReadNull()) return null;
            if (checkType) {
                System.Xml.XmlQualifiedName t = GetXsiType();
                if (t == null || ((object) ((System.Xml.XmlQualifiedName)t).Name == (object)id39_MimeXmlBinding && (object) ((System.Xml.XmlQualifiedName)t).Namespace == (object)id36_httpschemasxmlsoaporgwsdlmime))
                    ;
                else
                    throw CreateUnknownTypeException((System.Xml.XmlQualifiedName)t);
            }
            System.Web.Services.Description.MimeXmlBinding o = new System.Web.Services.Description.MimeXmlBinding();
            bool[] paramsRead = new bool[2];
            while (Reader.MoveToNextAttribute()) {
                if (!paramsRead[0] && ((object) Reader.LocalName == (object)id201_required && (object) Reader.NamespaceURI == (object)id2_httpschemasxmlsoaporgwsdl)) {
                    o.@Required = System.Xml.XmlConvert.ToBoolean(Reader.Value);
                    paramsRead[0] = true;
                }
                else if (!paramsRead[1] && ((object) Reader.LocalName == (object)id195_part && (object) Reader.NamespaceURI == (object)id4_Item)) {
                    o.@Part = ToXmlNmToken(Reader.Value);
                    paramsRead[1] = true;
                }
                else if (!IsXmlnsAttribute(Reader.Name)) {
                    UnknownNode((object)o);
                }
            }
            Reader.MoveToElement();
            if (Reader.IsEmptyElement) {
                Reader.Skip();
                return o;
            }
            Reader.ReadStartElement();
            Reader.MoveToContent();
            while (Reader.NodeType != System.Xml.XmlNodeType.EndElement) {
                if (Reader.NodeType == System.Xml.XmlNodeType.Element) {
                    UnknownNode((object)o);
                }
                else {
                    UnknownNode((object)o);
                }
                Reader.MoveToContent();
            }
            ReadEndElement();
            return o;
        }

        System.Web.Services.Description.MimeMultipartRelatedBinding Read92_MimeMultipartRelatedBinding(bool isNullable, bool checkType) {
            if (isNullable && ReadNull()) return null;
            if (checkType) {
                System.Xml.XmlQualifiedName t = GetXsiType();
                if (t == null || ((object) ((System.Xml.XmlQualifiedName)t).Name == (object)id38_MimeMultipartRelatedBinding && (object) ((System.Xml.XmlQualifiedName)t).Namespace == (object)id36_httpschemasxmlsoaporgwsdlmime))
                    ;
                else
                    throw CreateUnknownTypeException((System.Xml.XmlQualifiedName)t);
            }
            System.Web.Services.Description.MimeMultipartRelatedBinding o = new System.Web.Services.Description.MimeMultipartRelatedBinding();
            System.Web.Services.Description.MimePartCollection a_1 = (System.Web.Services.Description.MimePartCollection)o.@Parts;
            bool[] paramsRead = new bool[2];
            while (Reader.MoveToNextAttribute()) {
                if (!paramsRead[0] && ((object) Reader.LocalName == (object)id201_required && (object) Reader.NamespaceURI == (object)id2_httpschemasxmlsoaporgwsdl)) {
                    o.@Required = System.Xml.XmlConvert.ToBoolean(Reader.Value);
                    paramsRead[0] = true;
                }
                else if (!IsXmlnsAttribute(Reader.Name)) {
                    UnknownNode((object)o);
                }
            }
            Reader.MoveToElement();
            if (Reader.IsEmptyElement) {
                Reader.Skip();
                return o;
            }
            Reader.ReadStartElement();
            Reader.MoveToContent();
            while (Reader.NodeType != System.Xml.XmlNodeType.EndElement) {
                if (Reader.NodeType == System.Xml.XmlNodeType.Element) {
                    if (((object) Reader.LocalName == (object)id195_part && (object) Reader.NamespaceURI == (object)id36_httpschemasxmlsoaporgwsdlmime)) {
                        if ((object)(a_1) == null) Reader.Skip(); else a_1.Add(Read93_MimePart(false, true));
                    }
                    else {
                        UnknownNode((object)o);
                    }
                }
                else {
                    UnknownNode((object)o);
                }
                Reader.MoveToContent();
            }
            ReadEndElement();
            return o;
        }

        System.Web.Services.Description.MimePart Read93_MimePart(bool isNullable, bool checkType) {
            if (isNullable && ReadNull()) return null;
            if (checkType) {
                System.Xml.XmlQualifiedName t = GetXsiType();
                if (t == null || ((object) ((System.Xml.XmlQualifiedName)t).Name == (object)id37_MimePart && (object) ((System.Xml.XmlQualifiedName)t).Namespace == (object)id36_httpschemasxmlsoaporgwsdlmime))
                    ;
                else
                    throw CreateUnknownTypeException((System.Xml.XmlQualifiedName)t);
            }
            System.Web.Services.Description.MimePart o = new System.Web.Services.Description.MimePart();
            System.Web.Services.Description.ServiceDescriptionFormatExtensionCollection a_1 = (System.Web.Services.Description.ServiceDescriptionFormatExtensionCollection)o.@Extensions;
            bool[] paramsRead = new bool[2];
            while (Reader.MoveToNextAttribute()) {
                if (!paramsRead[0] && ((object) Reader.LocalName == (object)id201_required && (object) Reader.NamespaceURI == (object)id2_httpschemasxmlsoaporgwsdl)) {
                    o.@Required = System.Xml.XmlConvert.ToBoolean(Reader.Value);
                    paramsRead[0] = true;
                }
                else if (!IsXmlnsAttribute(Reader.Name)) {
                    UnknownNode((object)o);
                }
            }
            Reader.MoveToElement();
            if (Reader.IsEmptyElement) {
                Reader.Skip();
                return o;
            }
            Reader.ReadStartElement();
            Reader.MoveToContent();
            while (Reader.NodeType != System.Xml.XmlNodeType.EndElement) {
                if (Reader.NodeType == System.Xml.XmlNodeType.Element) {
                    if (((object) Reader.LocalName == (object)id207_body && (object) Reader.NamespaceURI == (object)id41_httpschemasxmlsoaporgwsdlsoap)) {
                        if ((object)(a_1) == null) Reader.Skip(); else a_1.Add(Read97_SoapBodyBinding(false, true));
                    }
                    else if (((object) Reader.LocalName == (object)id210_mimeXml && (object) Reader.NamespaceURI == (object)id36_httpschemasxmlsoaporgwsdlmime)) {
                        if ((object)(a_1) == null) Reader.Skip(); else a_1.Add(Read91_MimeXmlBinding(false, true));
                    }
                    else if (((object) Reader.LocalName == (object)id208_content && (object) Reader.NamespaceURI == (object)id36_httpschemasxmlsoaporgwsdlmime)) {
                        if ((object)(a_1) == null) Reader.Skip(); else a_1.Add(Read89_MimeContentBinding(false, true));
                    }
                    else if (((object) Reader.LocalName == (object)id206_text && (object) Reader.NamespaceURI == (object)id33_httpmicrosoftcomwsdlmimetextMatching)) {
                        if ((object)(a_1) == null) Reader.Skip(); else a_1.Add(Read94_MimeTextBinding(false, true));
                    }
                    else {
                        a_1.Add((System.Xml.XmlElement)ReadXmlNode(false));
                    }
                }
                else {
                    UnknownNode((object)o);
                }
                Reader.MoveToContent();
            }
            ReadEndElement();
            return o;
        }

        System.Web.Services.Description.MimeTextBinding Read94_MimeTextBinding(bool isNullable, bool checkType) {
            if (isNullable && ReadNull()) return null;
            if (checkType) {
                System.Xml.XmlQualifiedName t = GetXsiType();
                if (t == null || ((object) ((System.Xml.XmlQualifiedName)t).Name == (object)id35_MimeTextBinding && (object) ((System.Xml.XmlQualifiedName)t).Namespace == (object)id33_httpmicrosoftcomwsdlmimetextMatching))
                    ;
                else
                    throw CreateUnknownTypeException((System.Xml.XmlQualifiedName)t);
            }
            System.Web.Services.Description.MimeTextBinding o = new System.Web.Services.Description.MimeTextBinding();
            System.Web.Services.Description.MimeTextMatchCollection a_1 = (System.Web.Services.Description.MimeTextMatchCollection)o.@Matches;
            bool[] paramsRead