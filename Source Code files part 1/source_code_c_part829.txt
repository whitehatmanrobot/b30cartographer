PE )

// Flags for GenBitReg()
//
#define FLG_BITREG_CLEAR            ( 0x00000000 )
#define FLG_BITREG_SET              ( 0x00000001 )
#define FLG_BITREG_TYPE_BINARY      ( 0x00000000 )
#define FLG_BITREG_TYPE_DWORD       ( 0x00000002 )


RETERR WINAPI GenSURegSetValueEx(HKEY hkeyRoot, LPCSTR szSubKey,
						 LPCSTR lpszValueName, DWORD dwValType,
						 LPBYTE lpszValue, DWORD dwValSize, UINT uFlags );

// A devnode is just a DWORD and this is easier than
// having to include configmg.h for everybody
RETERR WINAPI GenInfLCToDevNode(ATOM atInfFileName, LPSTR lpszSectionName,
								BOOL bInstallSec, UINT InfType,
								DWORD dnDevNode);

// Bit fields for GenInstall() (for wFlags parameter) -- these can be OR-ed!

#define GENINSTALL_DO_REGSRCPATH    64

// Remove temporarily because of incompatibilities with INET16.DLL #define GENINSTALL_DO_FILES    (1 | GENINSTALL_DO_REGSRCPATH)
#define GENINSTALL_DO_FILES     1
#define GENINSTALL_DO_INI       2
#define GENINSTALL_DO_REG       4
#define GENINSTALL_DO_INI2REG   8
#define GENINSTALL_DO_CFGAUTO   16
#define GENINSTALL_DO_LOGCONFIG 32
//
// careful:  64 is already used above
//
#define GENINSTALL_DO_IME       128
#define GENINSTALL_DO_PERUSER   256
#define GENINSTALL_DO_UNDO      512

#define GENINSTALL_DO_INIREG    (GENINSTALL_DO_INI | \
								 GENINSTALL_DO_REG | \
								 GENINSTALL_DO_INI2REG)

#define GENINSTALL_DO_ALL       (GENINSTALL_DO_FILES | \
									GENINSTALL_DO_INIREG | \
									GENINSTALL_DO_CFGAUTO | \
									GENINSTALL_DO_LOGCONFIG | \
									GENINSTALL_DO_REGSRCPATH | \
									GENINSTALL_DO_IME | \
									GENINSTALL_DO_PERUSER)



#endif // NOGENINSTALL



#ifndef NODEVICENSTALL
/***************************************************************************/
//
// Device Installer prototypes and definitions
//
/***************************************************************************/

/*******************************************************************************
*   AUTODOC
*   @doc    EXTERNAL SETUPX DEVICE_INSTALLER
*
*   @typee    _ERR_DEVICE_INSTALL | Error return codes for Device Installation
*   APIs.
*
*   @emem ERR_DI_INVALID_DEVICE_ID | Incorrectly formed device ID.
*
*   @emem ERR_DI_INVALID_COMPATIBLE_DEVICE_LIST | Invalid compatible device list.
*
*   @emem ERR_DI_REG_API | Error returned by one of the registry API.
*
*   @emem ERR_DI_LOW_MEM | Insufficient memory to complete.
*
*   @emem ERR_DI_BAD_DEV_INFO | A passed in DEVICE_INFO struct is invalid.
*
*   @emem ERR_DI_INVALID_CLASS_INSTALLER | The class installer is listed incorrecrly
*   in the registry, or points to an invalid class installer.
*
*   @emem ERR_DI_DO_DEFAULT | Do the default action for the requested operation.
*
*   @emem ERR_DI_USER_CANCEL | The user cancelled the operation.
*
*   @emem ERR_DI_NOFILECOPY | No need to copy files (in install).
*
*   @emem ERR_DI_BAD_CLASS_INFO | A passed in CLASS_INFO struct is invalid.
*
*   @emem ERR_DI_BAD_INF | An invalid INF file was encountered.
*
*   @emem ERR_DI_BAD_MOVEDEV_PARAMS | A passed in MOVEDEVICE_PARAMS struct was
*   invalid.
*
*   @emem ERR_DI_NO_INF | No INF found on supplied OEM path.
*
*   @emem ERR_DI_BAD_PROPCHANGE_PARAMS | A passed in PROPCHANGE_PARMS struct was
*   invalid.
*
*   @emem ERR_DI_BAD_SELECTDEVICE_PARAMS | A passed in SELECTEDEVICE_PARAMS struct
*   was invalid.
*
*   @emem ERR_DI_BAD_REMOVEDEVICE_PARAMS | A passed in REMOVEDEVICE_PARAMS struct
*   was invalid.
*
*   @emem ERR_DI_BAD_UNREMOVEDEVICE_PARAMS | A passed in UNREMOVEDEVICE_PARAMS struct
*   was invalid.
*
*   @emem ERR_DI_BAD_ENABLECLASS_PARAMS | A passed in ENABLECLASS_PARAMS struct
*   was invalid.
*
*   @emem ERR_DI_FAIL_QUERY | The queried action should not take place.
*
*   @emem ERR_DI_API_ERROR | One of the Device installation APIs was called
*   incorrectly or with invalid parameters.
*
*   @emem ERR_DI_BAD_PATH | An OEM path was specified incorrectly.
*
*   @emem ERR_DI_NOUPDATE | No Drivers Were updated
*
*   @emem ERR_DI_NODATE    | A driver's date/time stamp in the INF could not be found
*
*   @emem ERR_DI_NOVERSION | A driver's version the INF could not be found
*
*
*******************************************************************************/
enum _ERR_DEVICE_INSTALL
{
	ERR_DI_INVALID_DEVICE_ID = DI_ERROR,    // Incorrectly formed device IDF
	ERR_DI_INVALID_COMPATIBLE_DEVICE_LIST,  // Invalid compatible device list
	ERR_DI_REG_API,                         // Error returned by Reg API.
	ERR_DI_LOW_MEM,                         // Insufficient memory to complete
	ERR_DI_BAD_DEV_INFO,                    // Device Info struct invalid
	ERR_DI_INVALID_CLASS_INSTALLER,         // Registry entry / DLL invalid
	ERR_DI_DO_DEFAULT,                      // Take default action
	ERR_DI_USER_CANCEL,                     // the user cancelled the operation
	ERR_DI_NOFILECOPY,                      // No need to copy files (in install)
	ERR_DI_BAD_CLASS_INFO,                  // Class Info Struct invalid
	ERR_DI_BAD_INF,                         // Bad INF file encountered
	ERR_DI_BAD_MOVEDEV_PARAMS,              // Bad Move Device Params struct
	ERR_DI_NO_INF,                          // No INF found on OEM disk
	ERR_DI_BAD_PROPCHANGE_PARAMS,           // Bad property change param struct
	ERR_DI_BAD_SELECTDEVICE_PARAMS,         // Bad Select Device Parameters
	ERR_DI_BAD_REMOVEDEVICE_PARAMS,         // Bad Remove Device Parameters
	ERR_DI_BAD_ENABLECLASS_PARAMS,          // Bad Enable Class Parameters
	ERR_DI_FAIL_QUERY,                      // Fail the Enable Class query
	ERR_DI_API_ERROR,                       // DI API called incorrectly
	ERR_DI_BAD_PATH,                        // An OEM path was specified incorrectly
	ERR_DI_BAD_UNREMOVEDEVICE_PARAMS,       // Bad Unremove Device Parameters
	ERR_DI_NOUPDATE,                        // No Drivers Were updated
	ERR_DI_NODATE,                          // The driver does not have a Date stamp in the INF
	ERR_DI_NOVERSION,                       // There is not version string in the INF
	ERR_DI_DONT_INSTALL,                    // Don't upgrade the current driver
	ERR_DI_NO_DIGITAL_SIGNATURE_CATALOG,    // Catalog is not digitally signed
	ERR_DI_NO_DIGITAL_SIGNATURE_INF,        // Inf is not digitally signed
	ERR_DI_NO_DIGITAL_SIGNATURE_FILE,       // A file is not digitally signed
};

/*******************************************************************************
*   AUTODOC
*   @doc    EXTERNAL SETUPX DEVICE_INSTALLER
*
*   @types    DRIVER_INFO | This structure contains the information necessary
*   to present the user with a select device dialog.
*
*   @field WORD | cbSize | Size of this structure in bytes.
*
*   @field struct _DRIVER_INFO FAR | *lpNextInfo | Pointer to the next DRIVER_INFO
*   struct in a linked list.
*
*   @field LPSTR | lpszDescription | Pointer to the description of the device being
*   supported by this driver.
*
*   @field LPSTR | lpszMfgName | Pointer to the name of the manufacture of this
*   driver.
*
*   @field LPSTR | lpszProviderName | Pointer to provider of this driver if the
*   lpdi->Flags has the DI_MULTMFGS flag set.
*
*   @field WORD | Rank | The Rank match of this driver.  Ranks go from 0 to n, where 0
*   is the most compatible.
*
*   @field DWORD | dwFlags | Flags that control the use of this driver node.  These
*   are the same as the flags defined for a DRIVER_NODE.
*       @flag DNF_DUPDESC           | This driver has the same device description
*       from by more than one provider.
*       @flag DNF_OLDDRIVER         | Driver node specifies old/current driver
*       @flag DNF_EXCLUDEFROMLIST   | If set, this driver node will not be displayed
*       in any driver select dialogs.
*       @flag DNF_NODRIVER          | Set if we want to install no driver e.g no mouse drv
*       @flag DNF_CLASS_DRIVER      | Set if this driver is in the class driver list
*       @flag DNF_COMPATIBLE_DRIVER | Set if this driver is in the compatible driver list
*       @flag DNF_INET_DRIVER       | Set if this driver is being installed from the Internet
*       @flag DNF_CURRENT_DRIVER    | Set if this driver is the one currently being used.
*       @flag DNF_CLASS_DRIVER      | Set if this driver is in the class driver list
*       @flag DNF_COMPATIBLE_DRIVER | Set if this driver is in the compatible driver list
*       @flag DNF_INET_DRIVER       | Set if this driver is being installed from the Internet
*       @flag DNF_CURRENT_DRIVER    | Set if this driver is the one currently being used.
*
*   @field LPARAM | lpReserved | Reserved for use by the Device Installer.
*
*   @field DWORD | dwPrivateData | Reserved for use by the Device Installer.
*
*******************************************************************************/
typedef struct _DRIVER_INFO
{
	WORD                        cbSize;                     // Size of this structure in bytes
	struct _DRIVER_INFO FAR*    lpNextInfo;
	LPSTR                       lpszDescription;
	LPSTR                       lpszMfgName;
	LPSTR                       lpszProviderName;           // ONLY valid if DI_MULTMFGS is set in the LPDI
	WORD                        Rank;
	DWORD                       dwFlags;
	LPARAM                      lpReserved;
	DWORD                       dwPrivateData;
	WORD                        wDate;                      // Driver Date
	LPSTR                       lpszVersion;
} DRIVER_INFO, *PDRIVER_INFO, FAR *LPDRIVER_INFO;

/*******************************************************************************
*   AUTODOC
*   @doc    EXTERNAL SETUPX DEVICE_INSTALLER
*
*   @types    DRIVER_NODE | This strucure represents a driver which can be
*   installed for a specific device.
*
*   @field struct _DRIVER_NODE FAR* | lpNextDN | Pointer to the next driver node
*   in a list.
*
*   @field UINT | Rank | The Rank match of this driver.  Ranks go from 0 to n, where 0
*   is the most compatible.
*
*   @field UINT | InfType | Type of INF this driver cam from.  This will
*   be either INFTYPE_TEXT or INFTYPE_EXECUTABLE
*
*   @field unsigned | InfDate | DOS date stamp of the INF file.
*
*   @field LPSTR | lpszDescription | Pointer to a the descriptrion of the device being
*   supported by this driver.
*
*   @field LPSTR | lpszSectionName | Pointer to the name of INF install section for
*   this driver.
*
*   @field ATOM  | atInfFileName | Global ATOM containing the name of the INF file.
*
*   @field ATOM  | atMfgName | Global ATOM containing the name of this driver's
*   manufacture.
*
*   @field ATOM  | atProviderName | Global ATOM containing the name of this driver's
*   provider.
*
*   @field DWORD | Flags | Flags that control functions using this DRIVER_NODE
*       @flag DNF_DUPDESC           | This driver has the same device description
*       from by more than one provider.
*       @flag DNF_OLDDRIVER         | Driver node specifies old/current driver
*       @flag DNF_EXCLUDEFROMLIST   | If set, this driver node will not be displayed
*       in any driver select dialogs.
*       @flag DNF_NODRIVER          | Set if we want to install no driver e.g no mouse drv
*       @flag DNF_CONVERTEDLPINFO   | Set if this Driver Node was converted from an Info Node.
*       Setting this flag will cause the cleanup functions to explicitly delete it.
*
*   @field DWORD | dwPrivateData | Reserved
*
*   @field LPSTR | lpszDrvDescription | Pointer to a driver description.
*
*   @field LPSTR | lpszHardwareID | Pointer to a list of Plug-and-Play hardware IDs for
*   this driver.
*
*   @field LPSTR | lpszCompatIDs | Pointer to a list of Plug-and-Play compatible IDs for
*   this driver.
*
*******************************************************************************/
typedef struct _DRIVER_NODE {
	struct _DRIVER_NODE FAR* lpNextDN;
	UINT    Rank;
	UINT    InfType;
	unsigned    InfDate;
	LPSTR   lpszDescription;        // Compatibility: Contains the Device Desc.
	LPSTR   lpszSectionName;
	ATOM    atInfFileName;
	ATOM    atMfgName;
	ATOM    atProviderName;
	DWORD   Flags;
	DWORD   dwPrivateData;
	LPSTR   lpszDrvDescription;     // New contains an driver description
	LPSTR   lpszHardwareID;
	LPSTR   lpszCompatIDs;
	unsigned    DriverDate;
	LPSTR   lpszInfPath;
	LPARAM  lpReserved;
}   DRIVER_NODE, NEAR* PDRIVER_NODE, FAR* LPDRIVER_NODE, FAR* FAR* LPLPDRIVER_NODE;

#define DNF_DUPDESC             0x00000001   // Multiple providers have same desc
#define DNF_OLDDRIVER           0x00000002   // Driver node specifies old/current driver
#define DNF_EXCLUDEFROMLIST     0x00000004
#define DNF_NODRIVER            0x00000008   // if we want to install no driver e.g no mouse drv

#define DNF_CONVERTEDLPINFO     0x00000010  // Set if the Driver Node is a Converted Info Node

#define DNF_CLASS_DRIVER        0x00000020  // Driver node represents a class driver
#define DNF_COMPATIBLE_DRIVER   0x00000040  // Driver node represents a compatible driver
#define DNF_INET_DRIVER         0x00000080  // Driver comes from an Inetnet source
#define DNF_CURRENT_DRIVER      0x00000100  // Driver is the current one for a device
#define DNF_INDEXED_DRIVER      0x00000200  // Driver is specified in the Windows Driver Index file
#define DNF_DRIVER_VERIFIED     0x00000400  // Driver has been verified
#define DNF_DRIVER_SIGNED       0x00000800  // Driver is digitally signed
#define DNF_WIN2K_SECTION		0x00001000  // Driver install section is Win2000 INF section

// possible types of "INF" files
#define INFTYPE_WIN4        1
#define INFTYPE_WIN3        2
#define INFTYPE_COMBIDRV    3
#define INFTYPE_PPD         4
#define INFTYPE_WPD     5
#define INFTYPE_CLASS_SPEC1 6
#define INFTYPE_CLASS_SPEC2 7
#define INFTYPE_CLASS_SPEC3 8
#define INFTYPE_CLASS_SPEC4 9


#define MAX_CLASS_NAME_LEN   32
#define MAX_DRIVER_INST_LEN  10
#define MAX_GUID_STR 50                     // Big enough to hold a GUID string

// NOTE:  Keep this in sync with confimg.h in \DDK\INC
#define MAX_DEVNODE_ID_LEN  256

/*******************************************************************************
*   AUTODOC
*   @doc    EXTERNAL SETUPX DEVICE_INSTALLER
*
*   @types    DEVICE_INFO | This is the basic data structure for most Device
*   installation APIs.  A DEVICE_INFO represents a device that is being installed
*   on the system, or an installed device that is being modified in some way.
*
*   @field UINT | cbSize | Size of the DEVICE_INFO struct.
*
*   @field struct _DEVICE_INFO FAR | *lpNextDi | Pointer to the next DEVICE_INFO struct
*   in a linked list.
*
*   @field char | szDescription[LINE_LEN] | Buffer containing the description of the
*   device.
*
*   @field DWORD | dnDevnode | If set, this contains the address of the DevNode associated
*   with the device.
*
*   @field HKEY | hRegKey | An opened registry key that contains the device's registry
*   subkey.  This is usually HKEY_LOCAL_MACHINE.
*
*   @field char | szRegSubkey[MAX_DEVNODE_ID_LEN] | Buffer containing the device's
*   hardware registry subkey.  This is key is rooted in hRegKey, and is ususally some
*   place in the \\ENUM branch.
*
*   @field char | szClassName[MAX_CLASS_NAME_LEN] | Buffer containing the device's
*   class name. (Can be a GUID str)
*
*   @field DWORD | Flags | Flags for controlling installation and U/I functions. Some
*   flags can be set prior to calling device installer APIs, and other are set
*   automatically during the processing of some APIs.
*       @flag DI_SHOWOEM                  | Set if OEM disk support should be allowed
*       @flag DI_SHOWCOMPAT               | Will be set if only a compatible driver list
*       is being displayed by DiSelectDevice.
*       @flag DI_SHOWCLASS                | Will be set if only a Class driver list is
*       is being displayed by DiSelectDevice.
*       @flag DI_SHOWALL                  | Will be set if both a compatible driver list
*       and a class driver list are being shown by DiSelectDevice.
*       @flag DI_NOVCP                    | Set if no VCP (Virtual Copy Procedure) is
*       desired during DiInstallDevice.
*       @flag DI_DIDCOMPAT                | Will be set if DiBuildCompatDrvList has been
*       done, and lpCompatDrvList points to this device's compatible driver list.
*       @flag DI_DIDCLASS                 | Will be set if DiBuildClassDrvList has been
*       done, and lpClassDrvList points to this device's class driver list.
*       @flag DI_AUTOASSIGNRES            | Unused.
*       @flag DI_NEEDRESTART              | Will be set if the device requires a restart
*       of Windows after installation or a state change.
*       @flag DI_NEEDREBOOT               | Will be set if the device requires a reboot
*       of the machine after installation or a state change.
*       @flag DI_NOBROWSE                 | Set to diable browsing when selecting an OEM
*       disk path.
*       @flag DI_MULTMFGS                 | Will be set if a class driver list, or class
*       info list contains multiple manufactures.
*       @flag DI_DISABLED                 | Unused.
*       @flag DI_GENERALPAGE_ADDED        | Set by a property page provider if a general
*       properties page has been added to the device's property sheet.
*       @flag DI_RESOURCEPAGE_ADDED       | Set by a property page provider if a resource
*       properties page has been added to the device's property sheet.
*       @flag DI_PROPERTIES_CHANGE        | Set if a device's properties have been changed
*       and require an update of the Device Manager's U/I.
*       @flag DI_INF_IS_SORTED            | Set if the INF containing drivers for this
*       device is in sorted order.
*       @flag DI_ENUMSINGLEINF            | Set if DiBuildCompatDrvList and
*       DiBuildlassDrvList should only search the INF file specificed by atDriverPath.
*       @flag DI_DONOTCALLCONFIGMG        | Set if the configuration manager should not
*       be called during DiInstallDevice.
*       @flag DI_INSTALLDISABLED          | Set if the device should be installed in a
*       disabled state by default.
*       @flag DI_CLASSONLY                | Set if this DEVICE_INFO struct contains only
*       a class name.
*       @flag DI_CLASSINSTALLPARAMS       | Set if the lpClassIntallParams field points to
*       a class install parameter block.
*       @flag DI_NODI_DEFAULTACTION       | Set if DiCallClassInstaller should not
*       perform any default action if the class installer return ERR_DI_DO_DEFAULT, or
*       there is not class installer.
*       @flag DI_QUIETINSTALL             | Set if device install API should be as
*       silent as possible using default choices whereever possible.
*       @flag DI_NOFILECOPY               | Set if DiInstallDevice should skip file
*       copying.
*       @flag DI_FORCECOPY                | Set if DiInstallDevice should always
*       copy file, even if they are present on the system.
*       @flag DI_DRIVERPAGE_ADDED         | Set by a property page provider if a driver
*       properties page has been added to the device's property sheet.
*       @flag DI_USECI_SELECTSTRINGS      | Set if class installer provided strings
*       should be used during DiSelectDevice.
*       @flag DI_OVERRIDE_INFFLAGS        | Unused.
*       @flag DI_PROPS_NOCHANGEUSAGE      | Set if there should be no Enable/Disable
*       capability on the device's general property page.
*       @flag DI_NOSELECTICONS            | Set if no small icons should be used during
*       DiSelectDevice.
*       @flag DI_NOWRITE_IDS              | Set if DiInstallDevice should not write
*       the device's hardware and compatible IDs to the registry.
*
*   @field HWND | hwndParent | Window handle that will own U/I dialogs related to this
*   device.
*
*   @field LPDRIVER_NODE | lpCompatDrvList | Pointer to a linked list of DRIVER_NODES
*   representing the compatible drivers for this device.
*
*   @field LPDRIVER_NODE | lpClassDrvList | Pointer to a linked list of DRIVER_NODES
*   representing all drivers of this device's class.
*
*   @field LPDRIVER_NODE | lpSelectedDriver | Pointer to a single DRIVER_NODE that
*   has been selected as the driver for this device.
*
*   @field ATOM | atDriverPath | Global ATOM containing the path to this device's INF
*   file.  This is set only of the driver came from an OEM INF file.  This will be
*   0 if the INF is a standard Windows INF file.
*
*   @field ATOM | atTempInfFile | Global ATOM containing the name of a temporary INF
*   file for this device's drivers.  This is set if the drivers came from an old style
*   INF file and have been converted.
*
*   @field HINSTANCE | hinstClassInstaller | Class installer module instance.
*
*   @field HINSTANCE | hinstClassPropProvidor | Class Property Providor module instance.
*
*   @field HINSTANCE | hinstDevicePropProvidor | Device Property Providor module instance.
*
*   @field HINSTANCE | hinstBasicPropProvidor | Basic Property Providor module instance.
*
*   @field FARPROC | fpClassInstaller | Procedure address of class install function.
*
*   @field FARPROC | fpClassEnumPropPages | Procedure address of the Class property
*   provider page enumeration function.
*
*   @field FARPROC | fpDeviceEnumPropPages | Procedure address of the Device property
*   provider page enumeration function.
*
*   @field FARPROC | fpEnumBasicProperties | Procedure address of the Basic device
*   property provider page enumeration function.
*
*   @field DWORD | dwSetupReserved | Reserved for use by Setup.
*
*   @field DWORD | dwClassInstallReserved | Reserved for use by Class Installers.
*
*   @field GENCALLBACKPROC | gicpGenInstallCallBack | Procedure address of a GenInstall
*   call back function.  This would be set if the class installer wanted to handle
*   GenInstall callbacks during DiInstallDevice.
*
*   @field LPARAM | gicplParam | lParam for the GenInstall Callback.
*
*   @field UINT | InfType | The type of INF file being used.  This will be INFTYPE_TEXT
*   or INFTYPE_EXECUTABLE.
*
*   @field HINSTANCE | hinstPrivateProblemHandler | Module handle for the device's
*   private problem procedure.
*
*   @field FARPROC | fpPrivateProblemHandler | Procedure address of the device's
*   private problem handler.
*
*   @field LPARAM | lpClassInstallParams | Pointer to a class install parameter block.
*   Class installer parameters are specific to the class install functions.
*
*   @field struct _DEVICE_INFO FAR | *lpdiChildList | Pointer to a linked list of
*   DRIVER_INFO structs representing children of this device.
*
*   @field DWORD | dwFlagsEx | Additional control flags.
*       @flag DI_FLAGSEX_USEOLDINFSEARCH  | Set if INF Search functions should not use
*       indexed searching.
*       @flag DI_FLAGSEX_AUTOSELECTRANK0  | Set if DiSelectDevice should automatically
*       select rank 0 match drivers.
*       @flag DI_FLAGSEX_CI_FAILED        | Will be set internally if there was a
*       failure to load or call a class installer.
*       @flag DI_FLAGSEX_DIDINFOLIST      | Will be set if DiBuildCompatDrvInfoList has
*       been called, and this device's compatible driver Info list has been built.
*       @flag DI_FLAGSEX_DIDCOMPATINFO    | Will be set if DiBuildClassDrvInfoList has
*       been called, and this device's class driver Info list has been built.
*       @flag DI_FLAGSEX_FILTERCLASSES    | If set, DiBuildClassDrvList, and
*       DiBuildClassDrvInfoList will check for Class inclusion filters.  This means
*       devices will not be included in the list, if their class is marked as a
*       NoInstallClass class.
*       @flag DI_FLAGSEX_SETFAILEDINSTALL | If set, then if DiInstallDevice installs
*       a NULL driver, it will also set the FAILEDINSTALL config flag
*       @flag DI_FLAGSEX_DEVICECHANGE | If set, the device manager will rebuild it
*       tree of devices after the device property sheet is closed.
*       @flag DI_FLAGSEX_ALWAYSWRITEIDS | If set, and the flag, DI_NOWRITE_ID is clear
*       (ie that flag takes higher precedance) then always write Hardare and Compat
*       ids, even if they allready exist
*       @flag DI_FLAGSEX_ALLOWEXCLUDEDDRVS | If set, DiSelectDevice will display drivers
*       that have the Exlude From Select state
*       @flag DI_FLAGSEX_NOUIONQUERYREMOVE | If setup, DiInstallDevice will prevent
*       U/I warnings during a query removal.  Any U/I wanings that would have been
*       displayed will be silently failed.
*   @field LPDRIVER_INFO | lpCompatDrvInfoList | Pointer to a linked list of
*   DRIVER_INFO structs that are compatible with this device.
*
*   @field LPDRIVER_INFO | lpClassDrvInfoList | Pointer to a linked list of
*   DRIVER_INFO structs representing all drivers for this device's class.
*
*******************************************************************************/
typedef struct _DEVICE_INFO
{
	UINT                        cbSize;
	struct _DEVICE_INFO FAR     *lpNextDi;
	char                        szDescription[LINE_LEN];
	DWORD                       dnDevnode;
	HKEY                        hRegKey;
	char                        szRegSubkey[MAX_DEVNODE_ID_LEN];
	char                        szClassName[MAX_CLASS_NAME_LEN];
	DWORD                       Flags;
	HWND                        hwndParent;
	LPDRIVER_NODE               lpCompatDrvList;
	LPDRIVER_NODE               lpClassDrvList;
	LPDRIVER_NODE               lpSelectedDriver;
	ATOM                        atDriverPath;
	ATOM                        atTempInfFile;
	HINSTANCE                   hinstClassInstaller;
	HINSTANCE                   hinstClassPropProvidor;
	HINSTANCE                   hinstDevicePropProvidor;
	HINSTANCE                   hinstBasicPropProvidor;
	FARPROC                     fpClassInstaller;
	FARPROC                     fpClassEnumPropPages;
	FARPROC                     fpDeviceEnumPropPages;
	FARPROC                     fpEnumBasicProperties;
	DWORD                       dwSetupReserved;
	DWORD                       dwClassInstallReserved;
	GENCALLBACKPROC             gicpGenInstallCallBack;

	LPARAM                      gicplParam;
	UINT                        InfType;

	HINSTANCE                   hinstPrivateProblemHandler;
	FARPROC                     fpPrivateProblemHandler;
	LPARAM                      lpClassInstallParams;
	struct _DEVICE_INFO FAR     *lpdiChildList;
	DWORD                       dwFlagsEx;
	LPDRIVER_INFO               lpCompatDrvInfoList;
	LPDRIVER_INFO               lpClassDrvInfoList;
	char                        szClassGUID[MAX_GUID_STR];
} DEVICE_INFO, FAR * LPDEVICE_INFO, FAR * FAR * LPLPDEVICE_INFO;

#define ASSERT_DI_STRUC(lpdi) if (lpdi->cbSize != sizeof(DEVICE_INFO)) return (ERR_DI_BAD_DEV_INFO)

typedef struct _CLASS_INFO
{
	UINT        cbSize;
	struct _CLASS_INFO FAR* lpNextCi;
	LPDEVICE_INFO   lpdi;
	char                szDescription[LINE_LEN];
	char        szClassName[MAX_CLASS_NAME_LEN];
} CLASS_INFO, FAR * LPCLASS_INFO, FAR * FAR * LPLPCLASS_INFO;
#define ASSERT_CI_STRUC(lpci) if (lpci->cbSize != sizeof(CLASS_INFO)) return (ERR_DI_BAD_CLASS_INFO)


// flags for device choosing (InFlags)
#define DI_SHOWOEM                  0x00000001L     // support Other... button
#define DI_SHOWCOMPAT               0x00000002L     // show compatibility list
#define DI_SHOWCLASS                0x00000004L     // show class list
#define DI_SHOWALL                  0x00000007L
#define DI_NOVCP                    0x00000008L     // Don't do vcpOpen/vcpClose.
#define DI_DIDCOMPAT                0x00000010L     // Searched for compatible devices
#define DI_DIDCLASS                 0x00000020L     // Searched for class devices
#define DI_AUTOASSIGNRES            0x00000040L    // No UI for resources if possible

// flags returned by DiInstallDevice to indicate need to reboot/restart
#define DI_NEEDRESTART              0x00000080L     // Restart required to take effect
#define DI_NEEDREBOOT               0x00000100L     // Reboot required to take effect

// flags for device installation
#define DI_NOBROWSE                 0x00000200L     // no Browse... in InsertDisk

// Flags set by DiBuildClassDrvList
#define DI_MULTMFGS                 0x00000400L     // Set if multiple manufacturers in
													// class driver list
// Flag indicates that device is disabled
#define DI_DISABLED                 0x00000800L     // Set if device disabled

// Flags for Device/Class Properties
#define DI_GENERALPAGE_ADDED        0x00001000L
#define DI_RESOURCEPAGE_ADDED       0x00002000L

// Flag to indicate the setting properties for this Device (or class) caused a change
// so the Dev Mgr UI probably needs to be updatd.
#define DI_PROPERTIES_CHANGE        0x00004000L

// Flag to indicate that the sorting from the INF file should be used.
#define DI_INF_IS_SORTED            0x00008000L

#define DI_ENUMSINGLEINF            0x00010000L

// The following flags can be used to install a device disabled
// and to prevent CONFIGMG being called when a device is installed
#define DI_DONOTCALLCONFIGMG        0x00020000L
#define DI_INSTALLDISABLED          0x00040000L

// This flag is set of this LPDI is really just an LPCI, ie
// it only contains class info, NO DRIVER/DEVICE INFO
#define DI_CLASSONLY                0x00080000L

// This flag is set if the Class Install params are valid
#define DI_CLASSINSTALLPARAMS       0x00100000L

// This flag is set if the caller of DiCallClassInstaller does NOT
// want the internal default action performed if the Class installer
// return ERR_DI_DO_DEFAULT
#define DI_NODI_DEFAULTACTION       0x00200000L

// ISSUE-2002/01/16-roelfc. This is a hack for M6 Net setup. Net Setup does not work correctly
// if we process devnode syncronously.  This WILL be removed for M7 when
// Net setup is fixed to work with DiInstallDevice
#define DI_NOSYNCPROCESSING         0x00400000L

// flags for device installation
#define DI_QUIETINSTALL             0x00800000L     // don't confuse the user with
													// questions or excess info
#define DI_NOFILECOPY               0x01000000L     // No file Copy necessary
#define DI_FORCECOPY                0x02000000L     // Force files to be copied from install path
#define DI_DRIVERPAGE_ADDED         0x04000000L     // Prop providor added Driver page.
#define DI_USECI_SELECTSTRINGS      0x08000000L     // Use Class Installer Provided strings in the Select Device Dlg
#define DI_OVERRIDE_INFFLAGS        0x10000000L     // Override INF flags
#define DI_PROPS_NOCHANGEUSAGE      0x20000000L     // No Enable/Disable in General Props

#define DI_NOSELECTICONS        0x40000000L     // No small icons in select device dialogs

#define DI_NOWRITE_IDS          0x80000000L     // Don't write HW & Compat IDs on install

#define DI_FLAGSEX_USEOLDINFSEARCH  0x00000001L  // Inf Search functions should not use Index Search
#define DI_FLAGSEX_AUTOSELECTRANK0  0x00000002L  // DiSelectDevice doesn't propmt user if rank 0 match
#define DI_FLAGSEX_CI_FAILED        0x00000004L  // Failed to Load/Call class installer

#define DI_FLAGSEX_DIDINFOLIST      0x00000010L  // Did the Class Info List
#define DI_FLAGSEX_DIDCOMPATINFO    0x00000020L  // Did the Compat Info List

#define DI_FLAGSEX_FILTERCLASSES        0x00000040L
#define DI_FLAGSEX_SETFAILEDINSTALL     0x00000080L
#define DI_FLAGSEX_DEVICECHANGE         0x00000100L
#define DI_FLAGSEX_ALWAYSWRITEIDS       0x00000200L
#define DI_FLAGSEX_ALLOWEXCLUDEDDRVS    0x00000800L
#define DI_FLAGSEX_NOUIONQUERYREMOVE    0x00001000L
#define DI_FLAGSEX_RESERVED1            0x00002000L // Reserved for setupapi
#define DI_FLAGSEX_RESERVED2            0x00004000L // Reserved for setupapi
#define DI_FLAGSEX_RESERVED3            0x00008000L // Reserved for setupapi
#define DI_FLAGSEX_RESERVED4            0x00010000L // Reserved for setupapi
#define DI_FLAGSEX_INET_DRIVER          0x00020000L
#define DI_FLAGSEX_RESERVED5            0x00040000L // Reserved for setupapi

// Defines for class installer functions
#define DIF_SELECTDEVICE            0x0001
#define DIF_INSTALLDEVICE           0x0002
#define DIF_ASSIGNRESOURCES         0x0003
#define DIF_PROPERTIES              0x0004
#define DIF_REMOVE                  0x0005
#define DIF_FIRSTTIMESETUP          0x0006
#define DIF_FOUNDDEVICE             0x0007
#define DIF_SELECTCLASSDRIVERS      0x0008
#define DIF_VALIDATECLASSDRIVERS    0x0009
#define DIF_INSTALLCLASSDRIVERS     0x000A
#define DIF_CALCDISKSPACE           0x000B
#define DIF_DESTROYPRIVATEDATA      0x000C
#define DIF_VALIDATEDRIVER          0x000D
#define DIF_MOVEDEVICE              0x000E
#define DIF_DETECT                  0x000F
#define DIF_INSTALLWIZARD           0x0010
#define DIF_DESTROYWIZARDDATA       0x0011
#define DIF_PROPERTYCHANGE          0x0012
#define DIF_ENABLECLASS             0x0013
#define DIF_DETECTVERIFY            0x0014
#define DIF_INSTALLDEVICEFILES      0x0015
#define DIF_UNREMOVE                0x0016
#define DIF_SELECTBESTCOMPATDRV     0x0017
#define DIF_ALLOW_INSTALL           0x0018

typedef UINT        DI_FUNCTION;    // Function type for device installer

/*******************************************************************************
*   AUTODOC
*   @doc    EXTERNAL SETUPX DEVICE_INSTALLER
*
*   @types    ENABLECLASS_PARAMS | DIF_ENABLECLASS class install parameters
*
*   @field UINT | cbSize | Size of the ENABLECLASS_PARAMS struct.
*
*   @field LPSTR | szClass | The class that is being enabled.
*
*   @field WORD | wEnableMsg | Specifies the stage of enabling.
*   Can be one of:
*
*   @const ENABLECLASS_QUERY | The class is about to be enabled.  Return
*   ERR_DI_DO_DEFAULT to allow the class to be enabled, or ERR_DI_FAIL_QUERY
*   to prevent the class from being enabled.
*
*   @const ENABLECLASS_SUCCESS | The enabling of the class has succeeded,
*   return ERR_DI_DO_DEFAULT.
*
*   @const ENABLECLASS_FAILURE | The enabling of the class has failed,
*   return ERR_DI_DO_DEFAULT.
*
*******************************************************************************/
// DIF_ENABLECLASS parameter struct.
typedef struct _ENABLECLASS_PARAMS
{
	UINT            cbSize;
	LPSTR           szClass;
	WORD            wEnableMsg;
} ENABLECLASS_PARAMS, FAR * LPENABLECLASS_PARAMS;
#define ASSERT_ENABLECLASSPARAMS_STRUC(lpecp) if (lpecp->cbSize != sizeof(ENABLECLASS_PARAMS)) return (ERR_DI_BAD_ENABLECLASS_PARAMS)

#define ENABLECLASS_QUERY   0
#define ENABLECLASS_SUCCESS 1
#define ENABLECLASS_FAILURE 2

/*******************************************************************************
*   AUTODOC
*   @doc    EXTERNAL SETUPX DEVICE_INSTALLER
*
*   @types    MOVEDEV_PARAMS | DIF_MOVEDEVICE class install parameters
*
*   @field UINT | cbSize | Size of the MOVDEV_PARAMS struct.
*
*   @field LPDEVICE_INFO | lpdiOldDev  | Pointer to the device that is being
*   moved.
*
*******************************************************************************/
typedef struct _MOVEDEV_PARAMS
{
	UINT            cbSize;
	LPDEVICE_INFO   lpdiOldDev;     // References the Device Begin Moved
} MOVEDEV_PARAMS, FAR * LPMOVEDEV_PARAMS;
#define ASSERT_MOVEDEVPARAMS_STRUC(lpmdp) if (lpmdp->cbSize != sizeof(MOVEDEV_PARAMS)) return (ERR_DI_BAD_MOVEDEV_PARAMS)

/*******************************************************************************
*   AUTODOC
*   @doc    EXTERNAL SETUPX DEVICE_INSTALLER
*
*   @types    PROPCHANGE_PARAMS | DIF_PROPCHANGE class install parameters
*
*   @field UINT | cbSize | Size of the PROPCHANGE_PARAMS struct.
*
*   @field DWORD | dwStateChange | State change action. See DiChangeState for details.
*
*   @field DWORD | dwFlags | Flags specific to the type of state change.
*
*   @field DWORD | dwConfigID | Configuration ID for config specific changes.
*
*   @xref DiChangeState.
*
*******************************************************************************/
typedef struct _PROPCHANGE_PARAMS
{
	UINT            cbSize;
	DWORD           dwStateChange;
	DWORD           dwFlags;
	DWORD           dwConfigID;
} PROPCHANGE_PARAMS, FAR * LPPROPCHANGE_PARAMS;
#define ASSERT_PROPCHANGEPARAMS_STRUC(lpmdp) if (lpmdp->cbSize != sizeof(PROPCHANGE_PARAMS)) return (ERR_DI_BAD_PROPCHANGE_PARAMS)

#define MAX_TITLE_LEN           60
#define MAX_INSTRUCTION_LEN     256
#define MAX_LABEL_LEN           30
/*******************************************************************************
*   AUTODOC
*   @doc    EXTERNAL SETUPX DEVICE_INSTALLER
*
*   @types    SELECTDEVICE_PARAMS | DIF_SELECTDEVICE class install parameters
*
*   @field UINT | cbSize | Size of the SELECTDEVICE_PARAMS struct.
*
*   @field char | szTitle[MAX_TITLE_LEN] | Buffer containing a class installer
*   provided title for the Select Device dialogs.
*
*   @field char | szInstructions[MAX_INSTRUCTION_LEN] |  Buffer containing
*   class installer provided Select Device instructions.
*
*   @field char | szListLabel[MAX_LABEL_LEN] | Buffer containing a lable
*   of the Select Device list of drivers.
*
*******************************************************************************/
typedef struct _SELECTDEVICE_PARAMS
{
	UINT            cbSize;
	char            szTitle[MAX_TITLE_LEN];
	char            szInstructions[MAX_INSTRUCTION_LEN];
	char            szListLabel[MAX_LABEL_LEN];
} SELECTDEVICE_PARAMS, FAR * LPSELECTDEVICE_PARAMS;
#define ASSERT_SELECTDEVICEPARAMS_STRUC(p) if (p->cbSize != sizeof(SELECTDEVICE_PARAMS)) return (ERR_DI_BAD_SELECTDEVICE_PARAMS)

#define DI_REMOVEDEVICE_GLOBAL                  0x00000001
#define DI_REMOVEDEVICE_CONFIGSPECIFIC          0x00000002
/*******************************************************************************
*   AUTODOC
*   @doc    EXTERNAL SETUPX DEVICE_INSTALLER
*
*   @types    REMOVEDEVICE_PARAMS | DIF_REMOVE class install parameters
*
*   @field UINT | cbSize | Size of the REMOVEDEVICE_PARAMS struct.
*
*   @field DWORD | dwFlags | Flags indicating the type of removal to perform.
*       @flag DI_REMOVEDEVICE_GLOBAL         | The device will be removed globally.
*       @flag DI_REMOVEDEVICE_CONFIGSPECIFIC | The device will be removed from only
*       the specified configuration.
*
*   @field DWORD | dwConfigID |  If DI_REMOVEDEVICE_CONFIGSPECIFIC is set, then
*   this is the configuration the device will be removed from. 0 means the current
*   config.
*
*******************************************************************************/
typedef struct _REMOVEDEVICE_PARAMS
{
	UINT            cbSize;
	DWORD           dwFlags;
	DWORD           dwConfigID;
} REMOVEDEVICE_PARAMS, FAR * LPREMOVEDEVICE_PARAMS;
#define ASSERT_REMOVEDPARAMS_STRUC(p) if (p->cbSize != sizeof(REMOVEDEVICE_PARAMS)) return (ERR_DI_BAD_REMOVEDEVICE_PARAMS)

#define DI_UNREMOVEDEVICE_CONFIGSPECIFIC        0x00000002
/*******************************************************************************
*   AUTODOC
*   @doc    EXTERNAL SETUPX DEVICE_INSTALLER
*
*   @types    UNREMOVEDEVICE_PARAMS | DIF_UNREMOVE class install parameters
*
*   @field UINT | cbSize | Size of the UNREMOVEDEVICE_PARAMS struct.
*
*   @field DWORD | dwFlags | Flags indicating the type of removal to perform.
*       @flag DI_UNREMOVEDEVICE_CONFIGSPECIFIC | The device will be unremoved from only
*       the specified configuration.
*
*   @field DWORD | dwConfigID |  If DI_UNREMOVEDEVICE_CONFIGSPECIFIC is set, then
*   this is the configuration the device will be removed from. 0 means the current
*   config.
*
*******************************************************************************/
typedef struct _UNREMOVEDEVICE_PARAMS
{
	UINT            cbSize;
	DWORD           dwFlags;
	DWORD           dwConfigID;
} UNREMOVEDEVICE_PARAMS, FAR * LPUNREMOVEDEVICE_PARAMS;
#define ASSERT_UNREMOVEDPARAMS_STRUC(p) if (p->cbSize != sizeof(UNREMOVEDEVICE_PARAMS)) return (ERR_DI_BAD_UNREMOVEDEVICE_PARAMS)

/*******************************************************************************
*   AUTODOC
*   @doc    EXTERNAL SETUPX DEVICE_INSTALLER
*
*   @type NONE | Dynamic Hardware Install Wizard Constants | Constants that are
*   used when adding custom pages to the hardware install wizard.
*
*   @const MAX_INSTALLWIZARD_DYNAPAGES | The maximum number of dynamic hardware
*   installation wizard pages that can be added by a class installer.
*
*   @const IDD_DYNAWIZ_FIRSTPAGE | Resource ID for the first page that the install
*   wizard will go to after adding the class installer pages.
*
*   @const IDD_DYNAWIZ_SELECT_PREVPAGE | Resource ID for the page that the Select
*   Device page will go back to.
*
*   @const IDD_DYNAWIZ_SELECT_NEXTPAGE | Resource ID for the page that the Select
*   Device page will go forward to.
*
*   @const IDD_DYNAWIZ_ANALYZE_PREVPAGE | Resource ID for the page that the Analyze
*   page will go back to. This will only be used in the event that there is a
*   problem (i.e a conflict), and the user selects Back from the analyze page.
*
*   @const IDD_DYNAWIZ_ANALYZE_NEXTPAGE | Resource ID for the page that the Analyze
*   page will go to if it continues forward.  The wAnalyzeResult in the
*   INSTALLWIZARDDATA struct will contain the anaysis results.
*
*   @const IDD_DYNAWIZ_INSTALLDETECTED_PREVPAGE | Resource ID for that page that the
*   Install detected devices page will go back to.
*
*   @const IDD_DYNAWIZ_INSTALLDETECTED_NEXTPAGE | Resource ID for the page that the
*   Install detected devices page will go forward to.
*
*   @const IDD_DYNAWIZ_INSTALLDETECTED_NODEVS | Resource ID for the page that the
*   Install detected devices page will go to in the event that no devices are
*   detected.
*
*   @const IDD_DYNAWIZ_SELECTDEV_PAGE | Resource ID of the hardware install wizard's
*   select device page.  This ID can be used to go directly to the hardware install
*   wizard's select device page.
*
*   @const IDD_DYNAWIZ_ANALYZEDEV_PAGE | Resource ID of the hardware install wizard's
*   device analysis page.  This ID can be use to go directly to the hardware install
*   wizard's analysis page.
*
*   @const IDD_DYNAWIZ_INSTALLDETECTEDDEVS_PAGE | Resource ID of the hardware install
*   wizard's install detected devices page.  This ID can be use to go directly to
*   the hardware install wizard's install detected devices page.
*
*   @const IDD_DYNAWIZ_SELECTCLASS_PAGE | Resource ID of the hardware install wizard's
*   select class page.  This ID can be use to go directly to the hardware install
*   wizard's select class page.
*
*******************************************************************************/
// DIF_INSTALLWIZARD  Wizard Data
#define MAX_INSTALLWIZARD_DYNAPAGES             20

// Use this ID for the first page that the install wizard should dynamically jump to.
#define IDD_DYNAWIZ_FIRSTPAGE                   10000

// Use this ID for the page that the Select Device dialog should go back to
#define IDD_DYNAWIZ_SELECT_PREVPAGE             10001

// Use this ID for the page that the Select Device dialog should go to next
#define IDD_DYNAWIZ_SELECT_NEXTPAGE             10002

// Use this ID for the page that the Analyze dialog should go back to
// This will only be used in the event that there is a problem, and the user
// selects Back from the analyze proc.
#define IDD_DYNAWIZ_ANALYZE_PREVPAGE            10003

// Use this ID for the page that the Analyze dialog should go to if it continue from
// the analyze proc.  the wAnalyzeResult in the INSTALLDATA struct will
// contain the anaysis results.
#define IDD_DYNAWIZ_ANALYZE_NEXTPAGE            10004

// This dialog will be selected if the user chooses back from the
// Install Detected Devices dialog.
#define IDD_DYNAWIZ_INSTALLDETECTED_PREVPAGE    10006

// This dialog will be selected if the user chooses Next from the
// Install Detected Devices dialog.
#define IDD_DYNAWIZ_INSTALLDETECTED_NEXTPAGE    10007

// This is the ID of the dialog to select if detection does not
// find any new devices
#define IDD_DYNAWIZ_INSTALLDETECTED_NODEVS      10008

// This is the ID of the Select Device Wizard page.
#define IDD_DYNAWIZ_SELECTDEV_PAGE              10009

// This is the ID of the Analyze Device Wizard page.
#define IDD_DYNAWIZ_ANALYZEDEV_PAGE             10010

// This is the ID of the Install Detected Devs Wizard page.
#define IDD_DYNAWIZ_INSTALLDETECTEDDEVS_PAGE    10011

// This is the ID of the Select Class Wizard page.
#define IDD_DYNAWIZ_SELECTCLASS_PAGE            10012

// This flag is set if a Class installer has added pages to the
// install wizard.
#define DYNAWIZ_FLAG_PAGESADDED             0x00000001

// The following flags will control the button states when displaying
// the InstallDetectedDevs dialog.
#define DYNAWIZ_FLAG_INSTALLDET_NEXT        0x00000002
#define DYNAWIZ_FLAG_INSTALLDET_PREV        0x00000004

// Set this flag if you jump to the analyze page, and want it to
// handle conflicts for you.  NOTE.  You will not get control back
// in the event of a conflict if you set this flag.
#define DYNAWIZ_FLAG_ANALYZE_HANDLECONFLICT 0x00000008

#define ANALYZE_FACTDEF_OK      1
#define ANALYZE_STDCFG_OK       2
#define ANALYZE_CONFLICT        3
#define ANALYZE_NORESOURCES     4
#define ANALYZE_ERROR           5
#define ANALYZE_PNP_DEV         6
#define ANALYZE_PCMCIA_DEV      7

/*******************************************************************************
*   AUTODOC
*   @doc    EXTERNAL SETUPX DEVICE_INSTALLER
*
*   @types    INSTALLWIZARDDATA | DIF_INSTALLWIZARD class install parameters. This
*   struct is used by class installers to extend the operation of the hardware
*   installation wizard by adding custom pages.
*
*   @field UINT | cbSize | Size of the INSTALLWIZARDDATA struct.
*
*   @field LPDEVICE_INFO | lpdiOriginal | Pointer to the Original DEVICE_INFO
*   struct at the start of the manual installation.
*
*   @field LPDEVICE_INFO | lpdiSelected | Pointer to the current DEVICE_INFO struct
*   that is being manually selected.
*
*   @field DWORD | dwFlags | Flags that control the operation of the hardware
*   installation wizard.  There are currently none defined.
*
*   @field LPVOID | lpConfigData | Pointer to configuration data for analysis to
*   determine if the selected device can be installed with no conflicts.
*
*   @field WORD | wAnalyzeResult | Results of analysis to determine if the device
*   can be installed with no problems.  The following values are defined:
*       @flag ANALYZE_FACTDEF_OK    | The device can be installed using its factory
*       default settings.
*       @flag ANALYZE_STDCFG_OK     | The device can be installed using a configuration
*       specified in one if its basic logical configurations.  The user will probably
*       have to set jumpers or switches on the hardware to match the settings determined
*       by the install wizard.
*       @flag ANALYZE_CONFLICT      | The device cannot be installed without causing a
*       conflict with another device.
*       @flag ANALYZE_NORESOURCES   | The device does not require any resources, so it
*       can be installed witth no conflicts.
*       @flag ANALYZE_ERROR         | There was an error during analysis.
*       @flag ANALYZE_PNP_DEV       | The device has a least one softsettable logical
*       configurations, allowing it to be automatically configured.  Additionally the
*       device will be enumerated by one of the standard bus enumerators, so it does
*       not require manual installation, except to pre-copy driver files.
*
*   @field HPROPSHEETPAGE | hpsDynamicPages[MAX_INSTALLWIZARD_DYNAPAGES] | An
*   array of property sheet page handles.  The class installer would use this array
*   to create custom wizard pages, and insert their handles into this array.
*
*   @field WORD | wNumDynaPages | The number of pages inserted into the hpsDynamicPages
*   array.
*
*   @field DWORD | dwDynaWizFlags | Flags that control the behavior of the
*   installation wizard whtn dynamic pages have been added.
*       @flag DYNAWIZ_FLAG_PAGESADDED | Will be set by the install wizard if the
*       class installer adds custom pages.
*       @flag DYNAWIZ_FLAG_INSTALLDET_NEXT | If set, the install wizard will allow
*       going forward from the detected devices page, otherwise finish will
*       be the default option for the detected devices page.
*       @flag DYNAWIZ_FLAG_INSTALLDET_PREV | If set, the install wizard will allow
*       going back from the detected devices page.
*       @flag DYNAWIZ_FLAG_ANALYZE_HANDLECONFLICT | If set, the class installer will
*       handle the case where the selected device cannot be installed because of
*       a conflict.
*
*   @field DWORD | dwPrivateFlags | Flags that may be defined and used by the class
*   installer.
*
*   @field LPARAM | lpPrivateData | Pointer to private reference data defined and
*   set by the class installer.
*
*   @field LPSTR | lpExtraRunDllParams | Pointer to a string containing extra
*   parameters passed to the hardware install rundll function.
*
*   @field HWND | hwndWizardDlg | Window handle of the install wizard top level
*   window.
*
*******************************************************************************/
typedef struct InstallWizardData_tag
{
	UINT                    cbSize;

	LPDEVICE_INFO           lpdiOriginal;
	LPDEVICE_INFO           lpdiSelected;
	DWORD                   dwFlags;
	LPVOID                  lpConfigData;
	WORD                    wAnalyzeResult;

	// The following fields are used when a Class Installer Extends the Install Wizard
	HPROPSHEETPAGE          hpsDynamicPages[MAX_INSTALLWIZARD_DYNAPAGES];
	WORD                    wNumDynaPages;
	DWORD                   dwDynaWizFlags;
	DWORD                   dwPrivateFlags;
	LPARAM                  lpPrivateData;
	LPSTR                   lpExtraRunDllParams;
	HWND                    hwndWizardDlg;
} INSTALLWIZDATA, * PINSTALLWIZDATA , FAR *LPINSTALLWIZDATA;

RETERR WINAPI DiCreateDeviceInfo(
	LPLPDEVICE_INFO lplpdi,     // Ptr to ptr to dev info
	LPCSTR      lpszDescription,    // If non-null then description string
	DWORD       hDevnode,       // ISSUE-2002/01/16-roelfc -- MAKE A DEVNODE
	HKEY        hkey,       // Registry hkey for dev info
	LPCSTR      lpszRegsubkey,  // If non-null then reg subkey string
	LPCSTR      lpszClassName,  // If non-null then class name string
	HWND        hwndParent);    // If non-null then hwnd of parent

RETERR WINAPI DiGetClassDevs(
	LPLPDEVICE_INFO lplpdi,     // Ptr to ptr to dev info
	LPCSTR      lpszClassName,  // Must be name of class
	HWND        hwndParent,     // If non-null then hwnd of parent
	int         iFlags);        // Options

RETERR WINAPI DiGetClassDevsEx(
	LPLPDEVICE_INFO lplpdi,     // Ptr to ptr to dev info
	LPCSTR      lpszClassName,  // Must be name of class
	LPCSTR      lpszEnumerator, // Must be name of enumerator, or NULL
	HWND        hwndParent,     // If non-null then hwnd of parent
	int         iFlags);        // Options

DWORD WINAPI DiGetDriverSigningMode
(
    LPDRIVER_NODE   lpdn
);

#define DIGCF_DEFAULT           0x0001  // NOT IMPLEMENTED!
#define DIGCF_PRESENT           0x0002
#define DIGCF_ALLCLASSES        0x0004
#define DIGCF_PROFILE           0x0008

// API to return the Class name of an INF File
RETERR WINAPI DiGetINFClass(LPSTR lpszMWDPath, UINT InfType, LPSTR lpszClassName, DWORD dwcbClassName);

RETERR WINAPI PASCAL DiCreateDevRegKey(
	LPDEVICE_INFO   lpdi,
	LPHKEY      lphk,
	HINF        hinf,
	LPCSTR      lpszInfSection,
	int         iFlags);

RETERR WINAPI PASCAL DiDeleteDevRegKey(LPDEVICE_INFO lpdi, int  iFlags);


RETERR WINAPI PASCAL DiOpenDevRegKey(
	LPDEVICE_INFO   lpdi,
	LPHKEY      lphk,
	int         iFlags);

#define DIREG_DEV   0x0001      // Open/Create/Delete device key
#define DIREG_DRV   0x0002      // Open/Create/Delete driver key
#define DIREG_BOTH  0x0004      // Delete both driver and Device key

RETERR WINAPI DiReadRegLogConf
(
	LPDEVICE_INFO       lpdi,
	LPSTR               lpszConfigName,
	LPBYTE FAR          *lplpbLogConf,
	LPDWORD             lpdwSize
);

RETERR WINAPI DiReadRegConf
(
	LPDEVICE_INFO       lpdi,
	LPBYTE FAR          *lplpbLogConf,
	LPDWORD             lpdwSize,
	DWORD               dwFlags
);

#define DIREGLC_FORCEDCONFIG        0x00000001
#define DIREGLC_BOOTCONFIG          0x00000002

RETERR WINAPI DiCopyRegSubKeyValue
(
	HKEY    hkKey,
	LPSTR   lpszFromSubKey,
	LPSTR   lpszToSubKey,
	LPSTR   lpszValueToCopy
);

RETERR WINAPI DiDestroyClassInfoList(LPCLASS_INFO lpci);
RETERR WINAPI DiBuildClassInfoList(LPLPCLASS_INFO lplpci);

#define DIBCI_NOINSTALLCLASS        0x000000001
#define DIBCI_NODISPLAYCLASS        0x000000002

RETERR WINAPI DiBuildClassInfoListEx(LPLPCLASS_INFO lplpci, DWORD dwFlags);
RETERR WINAPI DiGetDeviceClassInfo(LPLPCLASS_INFO lplpci, LPDEVICE_INFO lpdi);

RETERR WINAPI DiDestroyDeviceInfoList(LPDEVICE_INFO lpdi);
RETERR WINAPI DiSelectDevice( LPDEVICE_INFO lpdi );
RETERR WINAPI DiSelectOEMDrv(HWND hDlg, LPDEVICE_INFO lpdi);

// Callback for diInstallDevice vcpOpen.  Basically calls vcpUICallback for everthing
// except when DI_FORCECOPY is active, in which case copies get defaulted to
// VCPN_FORCE
LRESULT CALLBACK diInstallDeviceUICallbackProc(LPVOID lpvObj, UINT uMsg, WPARAM wParam, LPARAM lParam, LPARAM lparamRef);
RETERR WINAPI DiInstallDevice( LPDEVICE_INFO lpdi );
RETERR WINAPI DiInstallDriverFiles(LPDEVICE_INFO lpdi);

RETERR WINAPI DiRemoveDevice( LPDEVICE_INFO lpdi );
RETERR WINAPI DiUnremoveDevice( LPDEVICE_INFO lpdi );
RETERR WINAPI DiAskForOEMDisk(LPDEVICE_INFO lpdi);

RETERR WINAPI DiCallClassInstaller(DI_FUNCTION diFctn, LPDEVICE_INFO lpdi);

BOOL WINAPI DiBuildDriverIndex(BOOL bUI);
BOOL WINAPI DiAddSingleInfToDrvIdx(LPSTR lpszInfName, WORD InfType, BOOL bCreate);
BOOL WINAPI DiDeleteSingleInfFromDrvIdx(LPSTR lpszInfPath);

RETERR WINAPI DiBuildCompatDrvList(LPDEVICE_INFO lpdi);
LPDRIVER_NODE   WINAPI DiSelectBestCompatDrv(LPDEVICE_INFO lpdi, LPDRIVER_NODE lpdnCurrent);

// Given list of drivers returns the newest, may be used by class installers when 
// called by DiSelectBestCompatDrv.
LPDRIVER_NODE WINAPI DiPickBestDriver(LPDRIVER_NODE lpdnList); 

RETERR WINAPI DiBuildClassDrvList(LPDEVICE_INFO lpdi);
RETERR WINAPI DiBuildCompatDrvInfoList(LPDEVICE_INFO lpdi);
RETERR WINAPI DiBuildClassDrvInfoList(LPDEVICE_INFO lpdi);
RETERR WINAPI DiDestroyDrvInfoList(LPDRIVER_INFO lpInfo);
LPDRIVER_NODE WINAPI DiConvertDriverInfoToDriverNode(LPDEVICE_INFO lpdi, LPDRIVER_INFO lpInfo);

typedef RETERR (CALLBACK *OLDINFPROC)(HINF hinf, LPCSTR lpszNewInf, LPARAM lParam);
RETERR WINAPI DiBuildClassDrvListFromOldInf(LPDEVICE_INFO lpdi, LPCSTR lpszSection, OLDINFPROC lpfnOldInfProc, LPARAM lParam);

RETERR WINAPI DiDestroyDriverNodeList(LPDRIVER_NODE lpdn);

RETERR  WINAPI  DiMoveDuplicateDevNode(LPDEVICE_INFO lpdiNewDev);

// The following export will load a dll and find the specified proc name
typedef RETERR (FAR PASCAL *DIINSTALLERPROPERTIES)(LPDEVICE_INFO);

RETERR WINAPI GetFctn(HKEY hk, LPSTR lpszRegVal, LPSTR lpszDefProcName,
					  HINSTANCE FAR * lphinst, FARPROC FAR *lplpfn);

RETERR
WINAPI
DiCreateDriverNode(
	LPLPDRIVER_NODE lplpdn,
	UINT    Rank,
	UINT    InfType,
	unsigned    InfDate,
	LPCSTR  lpszDevDescription,
	LPCSTR  lpszDrvDescription,
	LPCSTR  lpszProviderName,
	LPCSTR  lpszMfgName,
	LPCSTR  lpszInfFileName,
	LPCSTR  lpszSectionName,
	DWORD   dwPrivateData);

RETERR WINAPI DiLoadClassIcon(
	LPCSTR  szClassName,
	HICON FAR *lphiLargeIcon,
	int FAR *lpiMiniIconIndex);


RETERR WINAPI DiInstallDrvSection(
	LPCSTR  lpszInfFileName,
	LPCSTR  lpszSection,
	LPCSTR  lpszClassName,
	LPCSTR  lpszDescription,
	DWORD   dwFlags);


RETERR WINAPI DiChangeState(LPDEVICE_INFO lpdi, DWORD dwStateChange, DWORD dwFlags, LPARAM lParam);

#define DICS_ENABLE                 0x00000001
#define DICS_DISABLE                0x00000002
#define DICS_PROPCHANGE         0x00000003
#define DICS_START          0x00000004
#define DICS_STOP           0x00000005

#define DICS_FLAG_GLOBAL            0x00000001
#define DICS_FLAG_CONFIGSPECIFIC    0x00000002
#define DICS_FLAG_CONFIGGENERAL     0x00000004

RETERR WINAPI DiInstallClass(LPCSTR lpszInfFileName, DWORD dwFlags);

RETERR WINAPI DiOpenClassRegKey(LPHKEY lphk, LPCSTR lpszClassName);

// support routine for dealing with class mini icons
#define DMI_MASK            0x0001
#define DMI_BKCOLOR         0x0002
#define DMI_USERECT         0x0004
int WINAPI PASCAL DiDrawMiniIcon(HDC hdc, RECT rcLine, int iMiniIcon, DWORD flags);
BOOL WINAPI DiGetClassBitmapIndex(LPCSTR lpszClass, int FAR *lpiMiniIconIndex);

// internal calls for display class
#define DISPLAY_SETMODE_SUCCESS     0x0001
#define DISPLAY_SETMODE_DRVCHANGE   0x0002
#define DISPLAY_SETMODE_FONTCHANGE  0x0004

UINT WINAPI Display_SetMode(LPDEVICE_INFO lpdi, UINT uColorRes, int iXRes, int iYRes);
RETERR WINAPI Display_ClassInstaller(DI_FUNCTION diFctn, LPDEVICE_INFO lpdi);
RETERR WINAPI Display_OpenFontSizeKey(LPHKEY lphkFontSize);
BOOL WINAPI Display_SetFontSize(LPCSTR lpszFontSize);

RETERR WINAPI DiIsThereNeedToCopy(HWND hwnd, DWORD dwFlags);

#define DINTC_NOCOPYDEFAULT     0x00000001

// API for the mouse class installer
RETERR WINAPI Mouse_ClassInstaller(DI_FUNCTION diFctn, LPDEVICE_INFO lpdi);
#endif // NODEVICEINSTALL

// API for determining if a Driver file is currently part of VMM32.VxD
BOOL WINAPI bIsFileInVMM32
(
	LPSTR   lpszFileName
);

// API for determining if a display is a primary or secondary
BOOL WINAPI Display_IsSecondDisplay(
	LPDEVICE_INFO lpdi
	);

// Japanese Keyboard Support
LONG _export WINAPI GetJapaneseKeyboardType();
#define JP_101KBD       0
#define JP_AXKBD        1
#define JP_106KBD       2
#define JP_003KBD       3
#define JP_001KBD       4
#define JP_TB_DESKTOP   5
#define JP_TB_LAPTOP    6
#define JP_TB_NOTEBOOK  7


#ifndef NOUSERINTERFACE
/***************************************************************************/
//
// User Interface prototypes and definitions
//
/***************************************************************************/

BOOL WINAPI UiMakeDlgNonBold(HWND hDlg);
VOID WINAPI UiDeleteNonBoldFont(HWND hDlg);

#endif

/***************************************************************************/
//
// setup reg DB calls, use just like those in kernel
//
/***************************************************************************/

DWORD WINAPI SURegOpenKey(HKEY hKey, LPCSTR lpszSubKey, HKEY FAR *lphkResult);
DWORD WINAPI SURegCloseKey(HKEY hKey);
DWORD WINAPI SURegCreateKey(HKEY hKey, LPCSTR lpszSubKey, HKEY FAR *lphkResult);
DWORD WINAPI SURegDeleteKey(HKEY hKey, LPCSTR lpszSubKey);
DWORD WINAPI SURegEnumKey(HKEY hKey, DWORD dwIdx, LPSTR lpszBuffer, DWORD dwBufSize);
DWORD WINAPI SURegQueryValue16(HKEY hKey, LPCSTR lpszSubKey, LPSTR lpValueBuf, DWORD FAR *ldwBufSize);
DWORD WINAPI SURegSetValue16(HKEY hKey, LPCSTR lpszSubKey, DWORD dwType, LPCBYTE lpszValue, DWORD dwValSize);
DWORD WINAPI SURegDeleteValue(HKEY hKey,LPCSTR lpszValue);
DWORD WINAPI SURegEnumValue(HKEY hKey,DWORD dwIdx, LPCSTR lpszValue, DWORD FAR *lpcbValue, DWORD FAR *lpdwReserved, DWORD FAR *lpdwType, LPBYTE lpbData, DWORD FAR *lpcbData);
DWORD WINAPI SURegQueryValueEx(HKEY hKey,LPCSTR lpszValueName, DWORD FAR *lpdwReserved,DWORD FAR *lpdwType,LPSTR lpValueBuf, DWORD FAR *ldwBufSize);
DWORD WINAPI SURegSetValueEx(HKEY hKey,LPCSTR lpszValueName, DWORD dwReserved, DWORD dwType, LPBYTE lpszValue, DWORD dwValSize);
DWORD WINAPI SURegSaveKey(HKEY hKey, LPCSTR lpszFileName, LPVOID lpsa);
DWORD WINAPI SURegLoadKey(HKEY hKey, LPCSTR lpszSubKey, LPCSTR lpszFileName);
DWORD WINAPI SURegUnLoadKey(HKEY hKey, LPCSTR lpszSubKey);

DWORD WINAPI SURegFlush(VOID);
DWORD WINAPI SURegInit(VOID);    // should be called before any other Reg APIs

/***************************************************************************/
// setup FormatMessage support
/***************************************************************************/
#define MB_LOG  (UINT)-1
#define MB_DBG  (UINT)-2

UINT FAR CDECL suFormatMessage(HINSTANCE hAppInst, LPCSTR lpcFormat, LPSTR szMessage, UINT uSize,
	...);
UINT WINAPI suvFormatMessage(HINSTANCE hAppInst, LPCSTR lpcFormat, LPSTR szMessage, UINT uSize,
	LPVOID FAR * lpArgs);
int WINCAPI _loadds suFormatMessageBox(HINSTANCE hAppInst, HWND hwndParent, LPCSTR lpcText, LPCSTR lpcTitle,
	UINT uStyle, ...);

WORD WINAPI suErrorToIds( WORD Value, WORD Class );

/***************************************************************************/
// setup Version Conflict support
/***************************************************************************/

LPVOID WINAPI suVerConflictInit(BOOL fYesToLangMismatch);
void WINAPI suVerConflictTerm(LPVOID lpvData);
LRESULT WINAPI suVerConflict(HWND hwnd, LPVCPVERCONFLICT lpvc, BOOL bBackup, LPVOID lpvData);
int WINAPI sxCompareDosAppVer( LPCSTR lpszOldFileSpec, LPCSTR lpszNewFileSpec);


/***************************************************************************/
// setup Help support
/***************************************************************************/

BOOL WINAPI suHelp( HWND hwndApp, HWND hwndDlg );

//***************************************************************************/
// setup Emergency Boot Disk (EBD) creation fn.
//***************************************************************************/

RETERR WINAPI suCreateEBD( HWND hWnd, VIFPROC CopyCallbackProc, LPARAM lpuii, int nCreateEBD );

//***************************************************************************
// Misc SETUPX.DLL support functions.
//***************************************************************************
enum  SU_ACTIONS                        // Actions msgs for Setupx()    /* ;Internal */
{                                                                       /* ;Internal */
	SUX_REGINIT,                        // Intialize registry           /* ;Internal */
	SUX_DBGLEVEL,                       // Set debug level              /* ;Internal */
	SUX_SETUPFLG,                       // Set fIsSetup flag            /* ;Internal */
	SUX_FASTSETUP,                      // Setupx => checking less mode /* ;Internal */
	SUX_FORCEREGFLUSH,                  // Call kRegFlush               /* ;Internal */
	SUX_TPSFLUSH,                       // Call TPS_Flush() fns.        /* ;Internal */
	SUX_DBGHFILE,                       // File to write messages to    /* ;Internal */
	SUX_LOADSTORELDIDS,                 // Load/store setup's LDID's    /* ;Internal */
	SUX_ENABLEREGFLUSH,                 // Enable/Disable SURegFlush() if fIsSetup  /* ;Internal */
	SUX_SETUNCPATHFUNC,                 // NOW UNUSED!!                   /* ;Internal */
	SUX_SETTRUEDISKFREEFUNC,            // Set TRUE disk free func      /* ;Internal */
	SUX_ISFLOPPYBOOT,                   // Set TRUE if floppy boot disk /* ;Internal */
	SUX_BISVER4,                        // returns bIsVer4(CHICAGO) flag/* ;Internal */
	SUX_SETCTLCALLBACKFUNC,             // Set ctlCopyCallBackProc Func /* ;Internal */
	SUX_GETCTLCALLBACKFUNC,             // Get ctlCopyCallBackProc Func /* ;Internal */
	SUX_BISMULTICFG,                    // returns SETUPX's gfMultiCfg  /* ;Internal */
	SUX_DUMPDSINFO,                     // Dumps diskspace info         /* ;Internal */
	SUX_INFCACHEOFF,                    // Turns INF file caching on/off/* ;Internal */
	SUX_SETFCDROMDRIVEEXISTS,           // Set CDRomDriveExists func    /* ;Internal */
	SUX_ALLOCRMBUFFERS,                 // Allocate real mode buffers   /* ;Internal */
	SUX_FREERMBUFFERS,                  // Free real mode buffers       /* ;Internal */
	SUX_DODOSEBDWORK,                   // Do DOS EBD Work              /* ;Internal */
        SUX_SETNETDITIP                     // Set Help Text during Setup   /* ;Internal */               
};                                                                      /* ;Internal */

RETERR WINAPI Setupx( UINT uMsg, WPARAM wParam, LPARAM lParam );        /* ;Internal */

RETERR WINAPI SUStoreLdidPath( LOGDISKID ldid, LPSTR lpszPath );        /* ;Internal */

BOOL WINAPI sxIsSBSServerFile( LPVIRTNODE lpVn );                       /* ;Internal */

BOOL WINAPI sxMakeUNCPath( LPSTR lpszPath );                            /* ;Internal */

typedef RETERR (CALLBACK* FBFPROC)(LPCSTR lpszFileName, LPVOID lpVoid); /* ;Internal */
RETERR WINAPI sxFindBatchFiles(HTP,int,FBFPROC,LPVOID);         /* ;Internal */

RETERR WINAPI SUGetSetSetupFlags(LPDWORD lpdwFlags, BOOL bSet);

RETERR WINAPI CfgSetupMerge( int uFlags );
BOOL WINAPI sxIsMSDOS7Running();
BOOL WINAPI IsPanEuropean();

// structure for the LPARAM argument to Setupx() for SUX_REGINIT action.    ;Internal
typedef struct _REGINIT_S { /* setupx - reg_init */                     /* ;Internal */
	LPSTR       lpszSystemFile;         // reg's base SYSTEM filename   /* ;Internal */
	LOGDISKID   ldidSystemFile;         // ldid for SYSTEM filename     /* ;Internal */
	LPSTR       lpszUserFile;           // reg's base USER filename     /* ;Internal */
	LOGDISKID   ldidUserFile;           // ldid for USER filename       /* ;Internal */
	LPSTR       lpszClassesFile;        // reg's base CLASSES filename  /* ;Internal */
	LOGDISKID   ldidClassesFile;        // ldid for CLASSES filename    /* ;Internal */
} REGINIT_S, FAR *LPREGINIT;                                            /* ;Internal */

#ifndef LPLPSTR
	typedef LPSTR (FAR *LPLPSTR);
#endif


#define         CFG_PARSE_BUFLEN 1024    // Buf sized passed line obj funcs      /* ;Internal */

LPLPSTR WINAPI  CfgParseLine( LPCSTR szLine, LPSTR Buf );                       /* ;Internal */
BOOL    WINAPI  CfgSetAutoProcess( int TrueFalse );                             /* ;Internal */
void    WINAPI  CfgObjToStr( LPLPSTR apszObj, LPSTR szLine );                   /* ;Internal */
LPLPSTR WINAPI  CfgLnToObj( HTP hSection, int Offset, int Origin, LPSTR Buf );  /* ;Internal */
LPLPSTR WINAPI  CfgObjFindKeyCmd( HTP hSec, LPCSTR szKey, LPCSTR szCmd,         /* ;Internal */
								  int Offset, int Origin, LPSTR Buf );          /* ;Internal */
LPCSTR WINAPI   WildCardStrCmpi( LPCSTR szKey, LPCSTR szLine, LPCSTR szDelims ); /* ;Internal */
RETERR WINAPI   GenMapRootRegStr2Key( LPCSTR szRegRoot, HKEY hRegRelKey,        /* ;Internal */
														HKEY FAR *lphkeyRoot ); /* ;Internal */


//***************************************************************************
//
// ENUMS for accessing config.sys/autoexec.bat line objects using the
// array returned by ParseConfigLine()..
//
//***************************************************************************

enum    CFGLINE_STRINGS                     // Config.sys/autoexec.bat objects
{
	CFG_KEYLEAD,                            // Keyword leading whitespaces
	CFG_KEYWORD,                            // Keyword
	CFG_KEYTRAIL,                           // Keyword trailing delimiters
	CFG_UMBINFO,                            // Load high info
	CFG_DRVLETTER,                          // Drive letter for cmd path
	CFG_PATH,                               // Command path
	CFG_COMMAND,                            // Command base name
	CFG_EXT,                                // Command extension including '.'
	CFG_ARGS,                               // Command arguments
	CFG_FREE,                               // Free area at end of buffer
	CFG_END
};

/*---------------------------------------------------------------------------*
 *                  SUB String Data
 *---------------------------------------------------------------------------*/

/*******************************************************************************
*   AUTODOC
*   @doc    EXTERNAL SETUPX DEVICE_INSTALLER
*
*   @types    SUBSTR_DATA | Data structure used to manage substrings.
*   struct is used by class installers to extend the operation of the hardware
*   installation wizard by adding custom pages.
*
*   @field LPSTR | lpFirstSubstr | Pointer to the first substring in the list.
*
*   @field LPSTR | lpCurSubstr | Pointer to the current substring in the list.
*
*   @field LPSTR | lpLastSubstr | Pointer to the last substring in the list.
*
*   @xref InitSubstrData
*   @xref GetFirstSubstr
*   @xref GetNextSubstr
*
*******************************************************************************/
typedef struct _SUBSTR_DATA {
	LPSTR lpFirstSubstr;
	LPSTR lpCurSubstr;
	LPSTR lpLastSubstr;
}   SUBSTR_DATA;


typedef SUBSTR_DATA*        PSUBSTR_DATA;
typedef SUBSTR_DATA NEAR*   NPSUBSTR_DATA;
typedef SUBSTR_DATA FAR*    LPSUBSTR_DATA;

BOOL WINAPI InitSubstrData(LPSUBSTR_DATA lpSubstrData, LPSTR lpStr);
BOOL WINAPI GetFirstSubstr(LPSUBSTR_DATA lpSubstrData);
BOOL WINAPI GetNextSubstr(LPSUBSTR_DATA lpSubStrData);
BOOL WINAPI InitSubstrDataEx(LPSUBSTR_DATA lpssd, LPSTR lpString, char chDelim);  /* ;Internal */

BOOL WINAPI FirstBootMoveToDOSSTART(LPSTR lpszCmd, BOOL fRemark);
BOOL WINAPI DOSOptEnableCurCfg(LPCSTR lpszOptKey);

/*---------------------------------------------------------------------------*
 *                  Misc. Di functions
 *---------------------------------------------------------------------------*/
BOOL WINAPI DiBuildPotentialDuplicatesList
(
	LPDEVICE_INFO   lpdi,
	LPSTR           lpDuplicateList,
	DWORD           cbSize,
	LPDWORD         lpcbData,
	LPSTR           lpstrDupType
);

BOOL _loadds WINAPI WalkSubtree(DWORD dnRoot, LPSTR szDrvLet);

// PID
BOOL _loadds WINAPI PidConstruct( LPSTR lpszProductType, LPSTR lpszPID, LPSTR lpszUPI, int iAction);
BOOL _loadds WINAPI PidValidate( LPSTR lpszProductType, LPSTR lpszPID);
int _loadds WINAPI WriteDMFBootData(int iDrive, LPSTR pData, int cb);

// FirstRunScreens
RETERR WINAPI DoFirstRunScreens();

BOOL WINAPI GetSetupInfo(LPSTR lpszName, DWORD cbName, LPSTR lpszOrg, DWORD cbOrg, LPSTR lpszOemId, DWORD cbOemId, BOOL * lpbIntlSet);
BOOL WINAPI SetSetupInfo(LPCSTR lpcszName, LPCSTR lpcszOrg, LPCSTR lpcszProdType, LPCSTR lpcszPid2, LPCSTR lpcszPid3, LPBYTE lpPid3);
BOOL WINAPI StampUser(LPCSTR lpcszName, LPCSTR lpcszOrg, LPCSTR lpcszPid2);

BOOL WINAPI GetProductType(LPSTR lpszProduct, LPDWORD lpdwSkuFlags);

// Audit mode flags.
//

#define SX_AUDIT_NONE           0x00000000
#define SX_AUDIT_NONRESTORE     0x00000001
#define SX_AUDIT_RESTORE        0x00000002
#define SX_AUDIT_ENDUSER        0x00000003
#define SX_AUDIT_AUTO           0x00000100
#define SX_AUDIT_RESTORATIVE    0x00000200
#define SX_AUDIT_ALLOWMANUAL    0x00000400
#define SX_AUDIT_ALLOWENDUSER   0x00000800
#define SX_AUDIT_MODES          0x000000FF
#define SX_AUDIT_FLAGS          0x0000FF00
#define SX_AUDIT_INVALID        0xFFFFFFFF

// These four audt mode defines need to go away.
//
#define NO_AUDIT                0
#define NONE_RESTORE_AUDIT      1
#define RESTORE_AUDIT           2
#define SIMULATE_ENDUSER        3

DWORD WINAPI GetAuditMode();
BOOL WINAPI SetAuditMode(DWORD dwAuditFlags);

// Wizard97 Fonts
VOID WINAPI InitWiz97Font(HWND hwndCtrl, BOOL bBig);

// Migration DLLs
#define SU_MIGRATE_PREINFLOAD    0x00000001	// before the setup INFs are loaded
#define SU_MIGRATE_POSTINFLOAD   0x00000002	// after the setup INFs are loaded
#define SU_MIGRATE_DISKSPACE     0x00000010	// request for the amount of additional diskspace needed
#define SU_MIGRATE_PREQUEUE      0x00000100	// before the INFs are processed and files are queued
#define SU_MIGRATE_POSTQUEUE     0x00000200	// after INFs are processed
#define SU_MIGRATE_REBOOT        0x00000400	// just before we are going to reboot for the 1st time
#define SU_MIGRATE_PRERUNONCE    0x00010000	// before any runonce items are processed
#define SU_MIGRATE_POSTRUNONCE   0x00020000	// after all runonce items are processed
DWORD WINAPI sxCallMigrationDLLs( DWORD dwStage, LPARAM lParam );
void WINAPI _loadds sxCallMigrationDLLs_RunDll(HWND, HINSTANCE, LPSTR, int);

//Count Down Dlg
int WINAPI SxShowRebootDlg(UINT, HWND);
void WINAPI _loadds SxShowRebootDlg_RunDll(HWND, HINSTANCE, LPSTR, int);

BOOL WINAPI CopyInfFile( LPSTR, LPSTR, UINT );

BOOL WINAPI IsWindowsFile( LPSTR lpszFile );

RETERR WINAPI VerifySelectedDriver(LPDEVICE_INFO lpdi, BOOL FAR *pbYesToAll);

//Dialog positioning function and defn's(wPosFlags)
#define DLG_CENTERV         0x01
#define DLG_CENTERH         0x02
#define DLG_CENTER          DLG_CENTERV | DLG_CENTERH
#define DLG_TOP             0x04
#define DLG_BOTTOM          0x08
#define DLG_RIGHT           0x10
#define DLG_LEFT            0x20
BOOL WINAPI uiPositionDialog( HWND hwndDlg, WORD wPosFlags );

//***************************************************************************
#endif      // SETUPX_INC
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\hnw\win95\netdi.h ===
//**********************************************************************
//
//  NETDI.H
//
//  Copyright (c) 1995 - Microsoft Corp.
//  All rights reserved.
//  Microsoft Confidential
//
// Public include file for Chicago Network Device Installer services.
//
//**********************************************************************

#ifndef _INC_NETDI
#define _INC_NETDI          // NETDI.H signature
#include <prsht.h>          // Property sheet API
#include <setupx.h>         // Device Installer API

// Return error codes for NDI_ messages.
#define NDI_ERROR           (1200)  // ISSUE-2002/01/16-roelfc: see setupx.h for error #
enum _ERR_NET_DEVICE_INSTALL
{
    ERR_NDI_ERROR               = NDI_ERROR,  // generic failure
    ERR_NDI_INVALID_HNDI,
    ERR_NDI_INVALID_DEVICE_INFO,
    ERR_NDI_INVALID_DRIVER_PROC,
    ERR_NDI_LOW_MEM,
    ERR_NDI_REG_API,
    ERR_NDI_NOTBOUND,
    ERR_NDI_NO_MATCH,
    ERR_NDI_INVALID_NETCLASS,
    ERR_NDI_INSTANCE_ONCE,
    ERR_NDI_CANCEL,
    ERR_NDI_NO_DEFAULT,
};

// Network Driver Info Handle
DECLARE_HANDLE(HNDI);

// Network Driver Installer Callback
typedef RETERR (CALLBACK* NDIPROC)(HNDI, UINT, WPARAM, LPARAM);
RETERR WINAPI DefNdiProc(HNDI,UINT,WPARAM,LPARAM);

// Network Driver Installer Messages
#define NDI_NULL                0x0000
#define NDI_CREATE              0x0001
#define NDI_DESTROY             0x0002
#define NDI_VALIDATE            0x0003
#define NDI_INSTALL             0x0004
// johnri 3/8/84 removed-using property sheets only
//#define NDI_ASSIGNRESOURCES     0x0005
#define NDI_HASPROPPAGES        0x0005
#define NDI_ADDPROPPAGES        0x0006
// lpapp = (LPNDIADDPROPPAGES)lParam;
typedef BOOL (CALLBACK* LPFNADDNDIPROPPAGE)(LPCPROPSHEETPAGE,LPARAM,BOOL);
typedef struct tagNDIADDPROPPAGES
{
    LPFNADDNDIPROPPAGE      lpfnAddNdiPropPage;
    LPARAM                  lParam;
} NDIADDPROPPAGES, FAR* LPNDIADDPROPPAGES;

#define NDI_REMOVE              0x0007
#define NDI_FIRSTTIMESETUP      0x0008
#define NDI_QUERY_BIND          0x0009
#define NDI_NOTIFY_BIND         0x000A
#define NDI_NOTIFY_UNBIND       0x000B
#define NDI_GETTEXT             0x000C
#define NDI_SETTEXT             0x000D
#define NDI_SYSTEMCHANGE        0x000E 

#define NDI_NDICREATE           0x0040
#define NDI_NDIDESTROY          0x0041

// Messages above NDI_INSTALLER are reserved for installer dlls
#define NDI_INSTALLER           0x8000

// Ndi_Create: lParam flags:
#define NDI_CREATE_BATCHMODE    0x00000001
#define NDI_CREATE_NODISPLAY    0x00000002
#define NDI_CREATE_WORKSTATION  0x00000004

// General NDI management
HNDI   WINAPI NdiGetFirst(VOID);
HNDI   WINAPI NdiGetNext(HNDI hndi);
HNDI   WINAPI NdiFindNdi(HNDI ndiRelation, WORD wNetClass, LPCSTR lpszDeviceId);
RETERR WINAPI NdiIsNdi(HNDI hndi);
RETERR WINAPI NdiCallInstaller(HNDI hndi,UINT,WPARAM,LPARAM);
RETERR WINAPI NdiAddNewDriver(HNDI FAR* lphndi, LPDEVICE_INFO lpdi, LPCSTR lpszDeviceID, UINT uFlags);
    #define NDI_ADD_NO_DISELECT 0x0001

HNDI   WINAPI NdiFindDefNdi( WORD wNetClass );
RETERR WINAPI NdiSetDefNdi( HNDI ndi );
RETERR WINAPI NdiClrDefNdi( HNDI ndi );
HNDI   WINAPI NdiChooseCandidateDefNdi( HNDI ndi, WORD wClass );
RETERR WINAPI NdiNeedReboot ( HNDI ndi, DWORD wRebootType );
RETERR WINAPI CreateNdiFromDeviceId (LPCSTR szId);

// Device Manager
RETERR WINAPI NdiValidate(HNDI hndi, HWND hwndParent);
RETERR WINAPI NdiInstall(HNDI hndi);
RETERR WINAPI NdiRemove(HNDI hndi);
RETERR WINAPI NdiProperties(HNDI hndi, HWND hwndParent);

// Bindings
RETERR WINAPI NdiBind(HNDI hndiLower, HNDI hndiUpper);
RETERR WINAPI NdiUnbind(HNDI hndiLower, HNDI hndiUpper);
RETERR WINAPI NdiQueryBind(HNDI hndiLower, HNDI hndiUpper, UINT uBindType);
RETERR WINAPI NdiIsBound(HNDI hndiLower, HNDI hndiUpper);
RETERR WINAPI NdiGetBinding(HNDI hndi, HNDI FAR* lphndi, UINT uBindType);
enum _NDIBIND {
    NDIBIND_UPPER       = 1,
    NDIBIND_UPPER_FIRST = NDIBIND_UPPER,
    NDIBIND_UPPER_NEXT,
    NDIBIND_LOWER,
    NDIBIND_LOWER_FIRST = NDIBIND_LOWER,
    NDIBIND_LOWER_NEXT};

// Ndi_SystemChange object properties
RETERR WINAPI NdiSystemChange(UINT uTypeOfChange, HNDI hndi);
enum _NDISYTEMCHANGE {  //lpwClass
    NDISYSTEMCHANGE_ADD,
    NDISYSTEMCHANGE_REMOVE};

// General NDI Object Properties
RETERR WINAPI NdiGetText(HNDI hndi, LPSTR, UINT);
RETERR WINAPI NdiSetText(HNDI hndi, LPSTR);
RETERR WINAPI NdiGetDeviceInfo(HNDI hndi, LPLPDEVICE_INFO);
RETERR WINAPI NdiGetClass(HNDI hndi, LPWORD lpwClass);
enum _NDICLASS {    // lpwClass
    NDI_CLASS_NET,
    NDI_CLASS_TRANS,
    NDI_CLASS_CLIENT,
    NDI_CLASS_SERVICE};
RETERR WINAPI NdiGetProperties(HNDI hndi, LPVOID FAR* lplpvProperties);
RETERR WINAPI NdiSetProperties(HNDI hndi, LPVOID lpvProperties);
RETERR WINAPI NdiGetOwnerWindow(HNDI hndi, HWND FAR* lphwnd);
RETERR WINAPI NdiGetDeviceId(HNDI hndi, LPSTR, UINT);
RETERR WINAPI NdiGetFlags(HNDI hndi, LPDWORD lpdwFlags);
// hiword is reserved for internal use
    #define NDIF_ADDED                  0x00000001
    #define NDIF_REMOVED                0x00000002
    #define NDIF_MODIFIED_BINDINGS      0x00000004
    #define NDIF_MODIFIED_PROPERTIES    0x00000008
    #define NDIF_SAVE_MASK              0x0000000F
    #define NDIF_DEFAULT                0x00000010
    #define NDIF_INVISIBLE              0x00000020
    #define NDIF_HAS_PARAMS             0x00000040

// Interfaces
RETERR WINAPI NdiCompareInterface(HNDI ndi, UINT uRelation, HNDI ndi2, UINT uRelation2);
RETERR WINAPI NdiGetInterface(HNDI ndi, UINT uRelation, UINT index, LPSTR lpsz, UINT cbSizeOflpsz);
RETERR WINAPI NdiAddInterface(HNDI ndi, UINT uRelation, LPCSTR lpsz);
RETERR WINAPI NdiRemoveInterface(HNDI ndi, UINT uRelation, LPCSTR lpsz);
enum _NDIEDGERELATION {
    NDI_EDGE_ALL=100,               // used to free all edges and marker for first in edge class
    NDI_EDGE_UPPER,
    NDI_EDGE_LOWER,
    NDI_EDGE_UPPERRANGE,
    NDI_EDGE_LOWERRANGE,
    NDI_EDGE_REQUIRELOWER,
    NDI_EDGE_REQUIREANY,
    NDI_EDGE_EXCLUDELOWER,
    NDI_EDGE_EXCLUDEANY,
    NDI_EDGE_ORGUPPER,
    NDI_EDGE_ORGLOWER,
    NDI_EDGE_END,                   // marker only for end of edges
    NDI_COMATIBLE_ALL=200,          // used to free all edges and marker for first in compatible class
    NDI_COMPATIBLE_REQUIREDUPPER,
    NDI_COMPATIBLE_REQUIREDLOWER,
    NDI_COMPATIBLE_REQUIREDALL,
    NDI_COMPATIBLE_REQUIREDANY,
    NDI_COMPATIBLE_EXCLUDEUPPER,
    NDI_COMPATIBLE_EXCLUDELOWER,
    NDI_COMPATIBLE_EXCLUDEALL,
    NDI_COMPATIBLE_END };           // marker only for end of edges

// Driver Registry Access
RETERR WINAPI NdiRegOpenKey(HNDI hndi, LPCSTR lpszSubKey, LPHKEY lphk);
RETERR WINAPI NdiRegCreateKey(HNDI hndi, LPCSTR lpszSubKey, LPHKEY lphk);
RETERR WINAPI NdiRegCloseKey(HKEY hkey);
RETERR WINAPI NdiRegQueryValue(HNDI hndi, LPCSTR lpszSubKey, LPCSTR lpszValueName, LPSTR lpValue, DWORD cbValue);
RETERR WINAPI NdiRegSetValue(HNDI hndi, LPCSTR lpszSubKey, LPCSTR lpszValueName, DWORD dwType, LPCSTR lpValue, DWORD cbValue);
RETERR WINAPI NdiRegDeleteValue(HNDI hndi,LPCSTR lpszSubKey, LPCSTR lpszValueName);

// Entry point called by NETCPL.
RETERR WINAPI NdiCplProperties(HWND hwndCpl);

#endif // _INC_NETDI
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\hnw\win95\ras1.h ===
/* Copyright (c) 1992-1996, Microsoft Corporation, all rights reserved
**
** ras.h
** Remote Access external API
** Public header for external API clients
**
** WINVER values in this file:
**      WINVER < 0x400 = Windows NT 3.5, Windows NT 3.51
**      WINVER = 0x400 = Windows 95, Windows NT SUR (default)
**      WINVER > 0x400 = Windows NT SUR enhancements
*/

#ifndef _RAS_H_
#define _RAS_H_

#ifdef __cplusplus
extern "C" {
#endif

#ifndef UNLEN
#include <lmcons.h>
#endif

#include <pshpack4.h>

#define RAS_MaxDeviceType     16
#define RAS_MaxPhoneNumber    128
#define RAS_MaxIpAddress      15
#define RAS_MaxIpxAddress     21

#if (WINVER >= 0x400)
#define RAS_MaxEntryName      256
#define RAS_MaxDeviceName     128
#define RAS_MaxCallbackNumber RAS_MaxPhoneNumber
#else
#define RAS_MaxEntryName      20
#define RAS_MaxDeviceName     32
#define RAS_MaxCallbackNumber 48
#endif

#define RAS_MaxAreaCode       10
#define RAS_MaxPadType        32
#define RAS_MaxX25Address     200
#define RAS_MaxFacilities     200
#define RAS_MaxUserData       200

DECLARE_HANDLE( HRASCONN );
#define LPHRASCONN HRASCONN*


/* Identifies an active RAS connection.  (See RasEnumConnections)
*/
#define RASCONNW struct tagRASCONNW
RASCONNW
{
    DWORD    dwSize;
    HRASCONN hrasconn;
    WCHAR    szEntryName[ RAS_MaxEntryName + 1 ];

#if (WINVER >= 0x400)
    WCHAR    szDeviceType[ RAS_MaxDeviceType + 1 ];
    WCHAR    szDeviceName[ RAS_MaxDeviceName + 1 ];
#endif
#if (WINVER >= 0x401)
    WCHAR    szPhonebook [ MAX_PATH ];
    DWORD    dwSubEntry;
#endif
};

#define RASCONNA struct tagRASCONNA
RASCONNA
{
    DWORD    dwSize;
    HRASCONN hrasconn;
    CHAR     szEntryName[ RAS_MaxEntryName + 1 ];

#if (WINVER >= 0x400)
    CHAR     szDeviceType[ RAS_MaxDeviceType + 1 ];
    CHAR     szDeviceName[ RAS_MaxDeviceName + 1 ];
#endif
#if (WINVER >= 0x401)
    CHAR     szPhonebook [ MAX_PATH ];
    DWORD    dwSubEntry;
#endif
};

#ifdef UNICODE
#define RASCONN RASCONNW
#else
#define RASCONN RASCONNA
#endif

#define LPRASCONNW RASCONNW*
#define LPRASCONNA RASCONNA*
#define LPRASCONN  RASCONN*


/* Enumerates intermediate states to a connection.  (See RasDial)
*/
#define RASCS_PAUSED 0x1000
#define RASCS_DONE   0x2000

#define RASCONNSTATE enum tagRASCONNSTATE
RASCONNSTATE
{
    RASCS_OpenPort = 0,
    RASCS_PortOpened,
    RASCS_ConnectDevice,
    RASCS_DeviceConnected,
    RASCS_AllDevicesConnected,
    RASCS_Authenticate,
    RASCS_AuthNotify,
    RASCS_AuthRetry,
    RASCS_AuthCallback,
    RASCS_AuthChangePassword,
    RASCS_AuthProject,
    RASCS_AuthLinkSpeed,
    RASCS_AuthAck,
    RASCS_ReAuthenticate,
    RASCS_Authenticated,
    RASCS_PrepareForCallback,
    RASCS_WaitForModemReset,
    RASCS_WaitForCallback,
    RASCS_Projected,

#if (WINVER >= 0x400)
    RASCS_StartAuthentication,
    RASCS_CallbackComplete,
    RASCS_LogonNetwork,
#endif
    RASCS_SubEntryConnected,
    RASCS_SubEntryDisconnected,

    RASCS_Interactive = RASCS_PAUSED,
    RASCS_RetryAuthentication,
    RASCS_CallbackSetByCaller,
    RASCS_PasswordExpired,

    RASCS_Connected = RASCS_DONE,
    RASCS_Disconnected
};

#define LPRASCONNSTATE RASCONNSTATE*


/* Describes the status of a RAS connection.  (See RasConnectionStatus)
*/
#define RASCONNSTATUSW struct tagRASCONNSTATUSW
RASCONNSTATUSW
{
    DWORD        dwSize;
    RASCONNSTATE rasconnstate;
    DWORD        dwError;
    WCHAR        szDeviceType[ RAS_MaxDeviceType + 1 ];
    WCHAR        szDeviceName[ RAS_MaxDeviceName + 1 ];
#if (WINVER >= 0x401)
    WCHAR        szPhoneNumber[ RAS_MaxPhoneNumber + 1 ];
#endif
};

#define RASCONNSTATUSA struct tagRASCONNSTATUSA
RASCONNSTATUSA
{
    DWORD        dwSize;
    RASCONNSTATE rasconnstate;
    DWORD        dwError;
    CHAR         szDeviceType[ RAS_MaxDeviceType + 1 ];
    CHAR         szDeviceName[ RAS_MaxDeviceName + 1 ];
#if (WINVER >= 0x401)
    CHAR         szPhoneNumber[ RAS_MaxPhoneNumber + 1 ];
#endif
};

#ifdef UNICODE
#define RASCONNSTATUS RASCONNSTATUSW
#else
#define RASCONNSTATUS RASCONNSTATUSA
#endif

#define LPRASCONNSTATUSW RASCONNSTATUSW*
#define LPRASCONNSTATUSA RASCONNSTATUSA*
#define LPRASCONNSTATUS  RASCONNSTATUS*


/* Describes connection establishment parameters.  (See RasDial)
*/
#define RASDIALPARAMSW struct tagRASDIALPARAMSW
RASDIALPARAMSW
{
    DWORD dwSize;
    WCHAR szEntryName[ RAS_MaxEntryName + 1 ];
    WCHAR szPhoneNumber[ RAS_MaxPhoneNumber + 1 ];
    WCHAR szCallbackNumber[ RAS_MaxCallbackNumber + 1 ];
    WCHAR szUserName[ UNLEN + 1 ];
    WCHAR szPassword[ PWLEN + 1 ];
    WCHAR szDomain[ DNLEN + 1 ];
#if (WINVER >= 0x401)
    DWORD dwSubEntry;
    DWORD dwCallbackId;
#endif
};

#define RASDIALPARAMSA struct tagRASDIALPARAMSA
RASDIALPARAMSA
{
    DWORD dwSize;
    CHAR  szEntryName[ RAS_MaxEntryName + 1 ];
    CHAR  szPhoneNumber[ RAS_MaxPhoneNumber + 1 ];
    CHAR  szCallbackNumber[ RAS_MaxCallbackNumber + 1 ];
    CHAR  szUserName[ UNLEN + 1 ];
    CHAR  szPassword[ PWLEN + 1 ];
    CHAR  szDomain[ DNLEN + 1 ];
#if (WINVER >= 0x401)
    DWORD dwSubEntry;
    DWORD dwCallbackId;
#endif
};

#ifdef UNICODE
#define RASDIALPARAMS RASDIALPARAMSW
#else
#define RASDIALPARAMS RASDIALPARAMSA
#endif

#define LPRASDIALPARAMSW RASDIALPARAMSW*
#define LPRASDIALPARAMSA RASDIALPARAMSA*
#define LPRASDIALPARAMS  RASDIALPARAMS*


/* Describes extended connection establishment options.  (See RasDial)
*/
#define RASDIALEXTENSIONS struct tagRASDIALEXTENSIONS
RASDIALEXTENSIONS
{
    DWORD dwSize;
    DWORD dwfOptions;
    HWND  hwndParent;
    DWORD reserved;
};

#define LPRASDIALEXTENSIONS RASDIALEXTENSIONS*

/* 'dwfOptions' bit flags.
*/
#define RDEOPT_UsePrefixSuffix           0x00000001
#define RDEOPT_PausedStates              0x00000002
#define RDEOPT_IgnoreModemSpeaker        0x00000004
#define RDEOPT_SetModemSpeaker           0x00000008
#define RDEOPT_IgnoreSoftwareCompression 0x00000010
#define RDEOPT_SetSoftwareCompression    0x00000020
#define RDEOPT_DisableConnectedUI        0x00000040
#define RDEOPT_DisableReconnectUI        0x00000080
#define RDEOPT_DisableReconnect          0x00000100
#define RDEOPT_NoUser                    0x00000200
#define RDEOPT_PauseOnScript             0x00000400


/* Describes an enumerated RAS phone book entry name.  (See RasEntryEnum)
*/
#define RASENTRYNAMEW struct tagRASENTRYNAMEW
RASENTRYNAMEW
{
    DWORD dwSize;
    WCHAR szEntryName[ RAS_MaxEntryName + 1 ];
};

#define RASENTRYNAMEA struct tagRASENTRYNAMEA
RASENTRYNAMEA
{
    DWORD dwSize;
    CHAR  szEntryName[ RAS_MaxEntryName + 1 ];
};

#ifdef UNICODE
#define RASENTRYNAME RASENTRYNAMEW
#else
#define RASENTRYNAME RASENTRYNAMEA
#endif

#define LPRASENTRYNAMEW RASENTRYNAMEW*
#define LPRASENTRYNAMEA RASENTRYNAMEA*
#define LPRASENTRYNAME  RASENTRYNAME*


/* Protocol code to projection data structure mapping.
*/
#define RASPROJECTION enum tagRASPROJECTION
RASPROJECTION
{
    RASP_Amb = 0x10000,
    RASP_PppNbf = 0x803F,
    RASP_PppIpx = 0x802B,
    RASP_PppIp = 0x8021,
#if (WINVER >= 0x40A)
    RASP_PppCcp = 0x80FD,
#endif
    RASP_PppLcp = 0xC021,
    RASP_Slip = 0x20000
};

#define LPRASPROJECTION RASPROJECTION*


/* Describes the result of a RAS AMB (Authentication Message Block)
** projection.  This protocol is used with NT 3.1 and OS/2 1.3 downlevel
** RAS servers.
*/
#define RASAMBW struct tagRASAMBW
RASAMBW
{
    DWORD dwSize;
    DWORD dwError;
    WCHAR szNetBiosError[ NETBIOS_NAME_LEN + 1 ];
    BYTE  bLana;
};

#define RASAMBA struct tagRASAMBA
RASAMBA
{
    DWORD dwSize;
    DWORD dwError;
    CHAR  szNetBiosError[ NETBIOS_NAME_LEN + 1 ];
    BYTE  bLana;
};

#ifdef UNICODE
#define RASAMB RASAMBW
#else
#define RASAMB RASAMBA
#endif

#define LPRASAMBW RASAMBW*
#define LPRASAMBA RASAMBA*
#define LPRASAMB  RASAMB*


/* Describes the result of a PPP NBF (NetBEUI) projection.
*/
#define RASPPPNBFW struct tagRASPPPNBFW
RASPPPNBFW
{
    DWORD dwSize;
    DWORD dwError;
    DWORD dwNetBiosError;
    WCHAR szNetBiosError[ NETBIOS_NAME_LEN + 1 ];
    WCHAR szWorkstationName[ NETBIOS_NAME_LEN + 1 ];
    BYTE  bLana;
};

#define RASPPPNBFA struct tagRASPPPNBFA
RASPPPNBFA
{
    DWORD dwSize;
    DWORD dwError;
    DWORD dwNetBiosError;
    CHAR  szNetBiosError[ NETBIOS_NAME_LEN + 1 ];
    CHAR  szWorkstationName[ NETBIOS_NAME_LEN + 1 ];
    BYTE  bLana;
};

#ifdef UNICODE
#define RASPPPNBF RASPPPNBFW
#else
#define RASPPPNBF RASPPPNBFA
#endif

#define LPRASPPPNBFW RASPPPNBFW*
#define LPRASPPPNBFA RASPPPNBFA*
#define LPRASPPPNBF  RASPPPNBF*


/* Describes the results of a PPP IPX (Internetwork Packet Exchange)
** projection.
*/
#define RASPPPIPXW struct tagRASIPXW
RASPPPIPXW
{
    DWORD dwSize;
    DWORD dwError;
    WCHAR szIpxAddress[ RAS_MaxIpxAddress + 1 ];
};


#define RASPPPIPXA struct tagRASPPPIPXA
RASPPPIPXA
{
    DWORD dwSize;
    DWORD dwError;
    CHAR  szIpxAddress[ RAS_MaxIpxAddress + 1 ];
};

#ifdef UNICODE
#define RASPPPIPX RASPPPIPXW
#else
#define RASPPPIPX RASPPPIPXA
#endif

#define LPRASPPPIPXW RASPPPIPXW*
#define LPRASPPPIPXA RASPPPIPXA*
#define LPRASPPPIPX  RASPPPIPX*


/* Describes the results of a PPP IP (Internet) projection.
*/
#define RASPPPIPW struct tagRASPPPIPW
RASPPPIPW
{
    DWORD dwSize;
    DWORD dwError;
    WCHAR szIpAddress[ RAS_MaxIpAddress + 1 ];

#ifndef WINNT35COMPATIBLE

    /* This field was added between Windows NT 3.51 beta and Windows NT 3.51
    ** final, and between Windows 95 M8 beta and Windows 95 final.  If you do
    ** not require the server address and wish to retrieve PPP IP information
    ** from Windows NT 3.5 or early Windows NT 3.51 betas, or on early Windows
    ** 95 betas, define WINNT35COMPATIBLE.
    **
    ** The server IP address is not provided by all PPP implementations,
    ** though Windows NT server's do provide it.
    */
    WCHAR szServerIpAddress[ RAS_MaxIpAddress + 1 ];

#endif
};

#define RASPPPIPA struct tagRASPPPIPA
RASPPPIPA
{
    DWORD dwSize;
    DWORD dwError;
    CHAR  szIpAddress[ RAS_MaxIpAddress + 1 ];

#ifndef WINNT35COMPATIBLE

    /* See RASPPPIPW comment.
    */
    CHAR  szServerIpAddress[ RAS_MaxIpAddress + 1 ];

#endif
};

#ifdef UNICODE
#define RASPPPIP RASPPPIPW
#else
#define RASPPPIP RASPPPIPA
#endif

#define LPRASPPPIPW RASPPPIPW*
#define LPRASPPPIPA RASPPPIPA*
#define LPRASPPPIP  RASPPPIP*


#if (WINVER >= 0x40A)

/* Describes the results of a PPP CCP (Compression Control Protocol) projection.
*/

/* RASPPPCCP 'dwCompressionAlgorithm' values.
*/
#define RASCCPCA_MPPC         0x00000012
#define RASCCPCA_STAC         0x00000011

/* RASPPPCCP 'dwOptions' values.
*/
#define RASCCPO_Compression   0x00000001
#define RASCCPO_Encryption1   0x00000010
#define RASCCPO_Encryption2   0x00000020
#define RASCCPO_Encryption3   0x00000040

#define RASPPPCCPW struct tagRASCCPW
RASPPPCCPW
{
    DWORD dwSize;
    DWORD dwError;
    DWORD dwCompressionAlgorithm;
    DWORD dwOptions;
    DWORD dwServerCompressionAlgorithm;
    DWORD dwServerOptions;
};


#define RASPPPCCPA struct tagRASPPPCCPA
RASPPPCCPA
{
    DWORD dwSize;
    DWORD dwError;
    DWORD dwCompressionAlgorithm;
    DWORD dwOptions;
    DWORD dwServerCompressionAlgorithm;
    DWORD dwServerOptions;
};

#ifdef UNICODE
#define RASPPPCCP RASPPPCCPW
#else
#define RASPPPCCP RASPPPCCPA
#endif

#define LPRASPPPCCPW RASPPPCCPW*
#define LPRASPPPCCPA RASPPPCCPA*
#define LPRASPPPCCP  RASPPPCCP*


/* Describes the results of a PPP LCP (Link Control Protocol) projection.
*/

/* RASPPPLCP 'dwAuthenticatonProtocol' values.
*/
#define RASLCPAP_PAP          0xC023
#define RASLCPAP_SPAP         0xC027
#define RASLCPAP_SPAP_OLD     0xC123
#define RASLCPAP_CHAP         0xC223
#define RASLCPAP_EAP          0xC227

/* RASPPPLCP 'dwAuthenticatonData' values.
*/
#define RASLCPAD_CHAP_MD5     0x05
#define RASLCPAD_CHAP_MS      0x80

#define RASPPPLCPW struct tagRASLCPW
RASPPPLCPW
{
    DWORD dwSize;
    DWORD dwError;
    DWORD dwAuthenticationProtocol;
    DWORD dwAuthenticationData;
    DWORD dwServerAuthenticationProtocol;
    DWORD dwServerAuthenticationData;
    BOOL  fMultilink;
};


#define RASPPPLCPA struct tagRASPPPLCPA
RASPPPLCPA
{
    DWORD dwSize;
    DWORD dwError;
    DWORD dwAuthenticationProtocol;
    DWORD dwAuthenticationData;
    DWORD dwServerAuthenticationProtocol;
    DWORD dwServerAuthenticationData;
    BOOL fMultilink;
};

#ifdef UNICODE
#define RASPPPLCP RASPPPLCPW
#else
#define RASPPPLCP RASPPPLCPA
#endif

#define LPRASPPPLCPW RASPPPLCPW*
#define LPRASPPPLCPA RASPPPLCPA*
#define LPRASPPPLCP  RASPPPLCP*

#else
/* Describes the results of a PPP LCP/multi-link negotiation.
*/

#define RASPPPLCP struct tagRASPPPLCP
RASPPPLCP
{
    DWORD dwSize;
    BOOL  fBundled;
};

#define LPRASPPPLCP RASPPPLCP*


#endif








/* Describes the results of a SLIP (Serial Line IP) projection.
*/
#define RASSLIPW struct tagRASSLIPW
RASSLIPW
{
    DWORD dwSize;
    DWORD dwError;
    WCHAR szIpAddress[ RAS_MaxIpAddress + 1 ];
};


#define RASSLIPA struct tagRASSLIPA
RASSLIPA
{
    DWORD dwSize;
    DWORD dwError;
    CHAR  szIpAddress[ RAS_MaxIpAddress + 1 ];
};

#ifdef UNICODE
#define RASSLIP RASSLIPW
#else
#define RASSLIP RASSLIPA
#endif

#define LPRASSLIPW RASSLIPW*
#define LPRASSLIPA RASSLIPA*
#define LPRASSLIP  RASSLIP*


/* If using RasDial message notifications, get the notification message code
** by passing this string to the RegisterWindowMessageA() API.
** WM_RASDIALEVENT is used only if a unique message cannot be registered.
*/
#define RASDIALEVENT    "RasDialEvent"
#define WM_RASDIALEVENT 0xCCCD

/* Prototypes for caller's RasDial callback handler.  Arguments are the
** message ID (currently always WM_RASDIALEVENT), the current RASCONNSTATE and
** the error that has occurred (or 0 if none).  Extended arguments are the
** handle of the RAS connection and an extended error code.
**
** For RASDIALFUNC2, subsequent callback notifications for all
** subentries can be cancelled by returning FALSE.
*/
typedef VOID (WINAPI *RASDIALFUNC)( UINT, RASCONNSTATE, DWORD );
typedef VOID (WINAPI *RASDIALFUNC1)( HRASCONN, UINT, RASCONNSTATE, DWORD, DWORD );
typedef DWORD (WINAPI *RASDIALFUNC2)( DWORD, DWORD, HRASCONN, UINT, RASCONNSTATE, DWORD, DWORD );


/* Information describing a RAS-capable device.
*/
#define RASDEVINFOW struct tagRASDEVINFOW
RASDEVINFOW
{
    DWORD    dwSize;
    WCHAR    szDeviceType[ RAS_MaxDeviceType + 1 ];
    WCHAR    szDeviceName[ RAS_MaxDeviceName + 1 ];
};

#define RASDEVINFOA struct tagRASDEVINFOA
RASDEVINFOA
{
    DWORD    dwSize;
    CHAR     szDeviceType[ RAS_MaxDeviceType + 1 ];
    CHAR     szDeviceName[ RAS_MaxDeviceName + 1 ];
};

#ifdef UNICODE
#define RASDEVINFO RASDEVINFOW
#else
#define RASDEVINFO RASDEVINFOA
#endif

#define LPRASDEVINFOW RASDEVINFOW*
#define LPRASDEVINFOA RASDEVINFOA*
#define LPRASDEVINFO  RASDEVINFO*

/* RAS country information (currently retrieved from TAPI).
*/
#define RASCTRYINFO struct RASCTRYINFO
RASCTRYINFO
{
    DWORD   dwSize;
    DWORD   dwCountryID;
    DWORD   dwNextCountryID;
    DWORD   dwCountryCode;
    DWORD   dwCountryNameOffset;
};

/* There is currently no difference between
** RASCTRYINFOA and RASCTRYINFOW.  This may
** change in the future.
*/
#define RASCTRYINFOW   RASCTRYINFO
#define RASCTRYINFOA   RASCTRYINFO

#define LPRASCTRYINFOW RASCTRYINFOW*
#define LPRASCTRYINFOA RASCTRYINFOW*
#define LPRASCTRYINFO  RASCTRYINFO*

/* A RAS IP address.
*/
#define RASIPADDR struct RASIPADDR
RASIPADDR
{
    BYTE a;
    BYTE b;
    BYTE c;
    BYTE d;
};

#define LPRASIPADDR RASIPADDR*

/* A RAS phone book entry.
*/
#define RASENTRYA struct tagRASENTRYA
RASENTRYA
{
    DWORD       dwSize;
    DWORD       dwfOptions;
    //
    // Location/phone number.
    //
    DWORD       dwCountryID;
    DWORD       dwCountryCode;
    CHAR        szAreaCode[ RAS_MaxAreaCode + 1 ];
    CHAR        szLocalPhoneNumber[ RAS_MaxPhoneNumber + 1 ];
    DWORD       dwAlternateOffset;
    //
    // PPP/Ip
    //
    RASIPADDR   ipaddr;
    RASIPADDR   ipaddrDns;
    RASIPADDR   ipaddrDnsAlt;
    RASIPADDR   ipaddrWins;
    RASIPADDR   ipaddrWinsAlt;
    //
    // Framing
    //
    DWORD       dwFrameSize;
    DWORD       dwfNetProtocols;
    DWORD       dwFramingProtocol;
    //
    // Scripting
    //
    CHAR        szScript[ MAX_PATH ];
    //
    // AutoDial
    //
    CHAR        szAutodialDll[ MAX_PATH ];
    CHAR        szAutodialFunc[ MAX_PATH ];
    //
    // Device
    //
    CHAR        szDeviceType[ RAS_MaxDeviceType + 1 ];
    CHAR        szDeviceName[ RAS_MaxDeviceName + 1 ];
    //
    // X.25
    //
    CHAR        szX25PadType[ RAS_MaxPadType + 1 ];
    CHAR        szX25Address[ RAS_MaxX25Address + 1 ];
    CHAR        szX25Facilities[ RAS_MaxFacilities + 1 ];
    CHAR        szX25UserData[ RAS_MaxUserData + 1 ];
    DWORD       dwChannels;
    //
    // Reserved
    //
    DWORD       dwReserved1;
    DWORD       dwReserved2;
#if (WINVER >= 0x401)
    //
    // Multilink
    //
    DWORD       dwSubEntries;
    DWORD       dwDialMode;
    DWORD       dwDialExtraPercent;
    DWORD       dwDialExtraSampleSeconds;
    DWORD       dwHangUpExtraPercent;
    DWORD       dwHangUpExtraSampleSeconds;
    //
    // Idle timeout
    //
    DWORD       dwIdleDisconnectSeconds;
#endif
};

#define RASENTRYW struct tagRASENTRYW
RASENTRYW
{
    DWORD       dwSize;
    DWORD       dwfOptions;
    //
    // Location/phone number
    //
    DWORD       dwCountryID;
    DWORD       dwCountryCode;
    WCHAR       szAreaCode[ RAS_MaxAreaCode + 1 ];
    WCHAR       szLocalPhoneNumber[ RAS_MaxPhoneNumber + 1 ];
    DWORD       dwAlternateOffset;
    //
    // PPP/Ip
    //
    RASIPADDR   ipaddr;
    RASIPADDR   ipaddrDns;
    RASIPADDR   ipaddrDnsAlt;
    RASIPADDR   ipaddrWins;
    RASIPADDR   ipaddrWinsAlt;
    //
    // Framing
    //
    DWORD       dwFrameSize;
    DWORD       dwfNetProtocols;
    DWORD       dwFramingProtocol;
    //
    // Scripting
    //
    WCHAR       szScript[ MAX_PATH ];
    //
    // AutoDial
    //
    WCHAR       szAutodialDll[ MAX_PATH ];
    WCHAR       szAutodialFunc[ MAX_PATH ];
    //
    // Device
    //
    WCHAR       szDeviceType[ RAS_MaxDeviceType + 1 ];
    WCHAR       szDeviceName[ RAS_MaxDeviceName + 1 ];
    //
    // X.25
    //
    WCHAR       szX25PadType[ RAS_MaxPadType + 1 ];
    WCHAR       szX25Address[ RAS_MaxX25Address + 1 ];
    WCHAR       szX25Facilities[ RAS_MaxFacilities + 1 ];
    WCHAR       szX25UserData[ RAS_MaxUserData + 1 ];
    DWORD       dwChannels;
    //
    // Reserved
    //
    DWORD       dwReserved1;
    DWORD       dwReserved2;
#if (WINVER >= 0x401)
    //
    // Multilink
    //
    DWORD       dwSubEntries;
    DWORD       dwDialMode;
    DWORD       dwDialExtraPercent;
    DWORD       dwDialExtraSampleSeconds;
    DWORD       dwHangUpExtraPercent;
    DWORD       dwHangUpExtraSampleSeconds;
    //
    // Idle timeout
    //
    DWORD       dwIdleDisconnectSeconds;
#endif
};

#ifdef UNICODE
#define RASENTRY RASENTRYW
#else
#define RASENTRY RASENTRYA
#endif

#define LPRASENTRYW RASENTRYW*
#define LPRASENTRYA RASENTRYA*
#define LPRASENTRY  RASENTRY*

/* RASENTRY 'dwfOptions' bit flags.
*/
#define RASEO_UseCountryAndAreaCodes    0x00000001
#define RASEO_SpecificIpAddr            0x00000002
#define RASEO_SpecificNameServers       0x00000004
#define RASEO_IpHeaderCompression       0x00000008
#define RASEO_RemoteDefaultGateway      0x00000010
#define RASEO_DisableLcpExtensions      0x00000020
#define RASEO_TerminalBeforeDial        0x00000040
#define RASEO_TerminalAfterDial         0x00000080
#define RASEO_ModemLights               0x00000100
#define RASEO_SwCompression             0x00000200
#define RASEO_RequireEncryptedPw        0x00000400
#define RASEO_RequireMsEncryptedPw      0x00000800
#define RASEO_RequireDataEncryption     0x00001000
#define RASEO_NetworkLogon              0x00002000
#define RASEO_UseLogonCredentials       0x00004000
#define RASEO_PromoteAlternates         0x00008000
#if (WINVER >= 0x401)
#define RASEO_SecureLocalFiles          0x00010000
#endif

/* RASENTRY 'dwProtocols' bit flags.
*/
#define RASNP_NetBEUI                   0x00000001
#define RASNP_Ipx                       0x00000002
#define RASNP_Ip                        0x00000004

/* RASENTRY 'dwFramingProtocols' bit flags.
*/
#define RASFP_Ppp                       0x00000001
#define RASFP_Slip                      0x00000002
#define RASFP_Ras                       0x00000004

/* RASENTRY 'szDeviceType' default strings.
*/
#define RASDT_Modem                     TEXT("modem")
#define RASDT_Isdn                      TEXT("isdn")
#define RASDT_X25                       TEXT("x25")

/* Old AutoDial DLL function prototype.
**
** This prototype is documented for backward-compatibility
** purposes only.  It is superceded by the RASADFUNCA
** and RASADFUNCW definitions below.  DO NOT USE THIS
** PROTOTYPE IN NEW CODE.  SUPPORT FOR IT MAY BE REMOVED
** IN FUTURE VERSIONS OF RAS.
*/
typedef BOOL (WINAPI *ORASADFUNC)( HWND, LPSTR, DWORD, LPDWORD );

#if (WINVER >= 0x401)
/* Flags for RasConnectionNotification().
*/
#define RASCN_Connection        0x00000001
#define RASCN_Disconnection     0x00000002
#define RASCN_BandwidthAdded    0x00000004
#define RASCN_BandwidthRemoved  0x00000008

/* RASENTRY 'dwDialMode' values.
*/
#define RASEDM_DialAll                  1
#define RASEDM_DialAsNeeded             2

/* RASENTRY 'dwIdleDisconnectSeconds' constants.
*/
#define RASIDS_Disabled                 0xffffffff
#define RASIDS_UseGlobalValue           0

/* AutoDial DLL function parameter block.
*/
#define RASADPARAMS struct tagRASADPARAMS
RASADPARAMS
{
    DWORD       dwSize;
    HWND        hwndOwner;
    DWORD       dwFlags;
    LONG        xDlg;
    LONG        yDlg;
};

#define LPRASADPARAMS RASADPARAMS*

/* AutoDial DLL function parameter block 'dwFlags.'
*/
#define RASADFLG_PositionDlg            0x00000001

/* Prototype AutoDial DLL function.
*/
typedef BOOL (WINAPI *RASADFUNCA)( LPSTR, LPSTR, LPRASADPARAMS, LPDWORD );
typedef BOOL (WINAPI *RASADFUNCW)( LPWSTR, LPWSTR, LPRASADPARAMS, LPDWORD );

#ifdef UNICODE
#define RASADFUNC RASADFUNCW
#else
#define RASADFUNC RASADFUNCA
#endif

/* A RAS phone book multilinked sub-entry.
*/
#define RASSUBENTRYA struct tagRASSUBENTRYA
RASSUBENTRYA
{
    DWORD       dwSize;
    DWORD       dwfFlags;
    //
    // Device
    //
    CHAR        szDeviceType[ RAS_MaxDeviceType + 1 ];
    CHAR        szDeviceName[ RAS_MaxDeviceName + 1 ];
    //
    // Phone numbers
    //
    CHAR        szLocalPhoneNumber[ RAS_MaxPhoneNumber + 1 ];
    DWORD       dwAlternateOffset;
};

#define RASSUBENTRYW struct tagRASSUBENTRYW
RASSUBENTRYW
{
    DWORD       dwSize;
    DWORD       dwfFlags;
    //
    // Device
    //
    WCHAR       szDeviceType[ RAS_MaxDeviceType + 1 ];
    WCHAR       szDeviceName[ RAS_MaxDeviceName + 1 ];
    //
    // Phone numbers
    //
    WCHAR       szLocalPhoneNumber[ RAS_MaxPhoneNumber + 1 ];
    DWORD       dwAlternateOffset;
};

#ifdef UNICODE
#define RASSUBENTRY RASSUBENTRYW
#else
#define RASSUBENTRY RASSUBENTRYA
#endif

#define LPRASSUBENTRYW RASSUBENTRYW*
#define LPRASSUBENTRYA RASSUBENTRYA*
#define LPRASSUBENTRY  RASSUBENTRY*

/* Ras{Get,Set}Credentials structure.  These calls
** supercede Ras{Get,Set}EntryDialParams.
*/
#define RASCREDENTIALSA struct tagRASCREDENTIALSA
RASCREDENTIALSA
{
    DWORD dwSize;
    DWORD dwMask;
    CHAR szUserName[ UNLEN + 1 ];
    CHAR szPassword[ PWLEN + 1 ];
    CHAR szDomain[ DNLEN + 1 ];
};

#define RASCREDENTIALSW struct tagRASCREDENTIALSW
RASCREDENTIALSW
{
    DWORD dwSize;
    DWORD dwMask;
    WCHAR szUserName[ UNLEN + 1 ];
    WCHAR szPassword[ PWLEN + 1 ];
    WCHAR szDomain[ DNLEN + 1 ];
};

#ifdef UNICODE
#define RASCREDENTIALS RASCREDENTIALSW
#else
#define RASCREDENTIALS RASCREDENTIALSA
#endif

#define LPRASCREDENTIALSW RASCREDENTIALSW*
#define LPRASCREDENTIALSA RASCREDENTIALSA*
#define LPRASCREDENTIALS  RASCREDENTIALS*

/* RASCREDENTIALS 'dwMask' values.
*/
#define RASCM_UserName       0x00000001
#define RASCM_Password       0x00000002
#define RASCM_Domain         0x00000004

/* AutoDial address properties.
*/
#define RASAUTODIALENTRYA struct tagRASAUTODIALENTRYA
RASAUTODIALENTRYA
{
    DWORD dwSize;
    DWORD dwFlags;
    DWORD dwDialingLocation;
    CHAR szEntry[ RAS_MaxEntryName + 1];
};

#define RASAUTODIALENTRYW struct tagRASAUTODIALENTRYW
RASAUTODIALENTRYW
{
    DWORD dwSize;
    DWORD dwFlags;
    DWORD dwDialingLocation;
    WCHAR szEntry[ RAS_MaxEntryName + 1];
};

#ifdef UNICODE
#define RASAUTODIALENTRY RASAUTODIALENTRYW
#else
#define RASAUTODIALENTRY RASAUTODIALENTRYA
#endif

#define LPRASAUTODIALENTRYW RASAUTODIALENTRYW*
#define LPRASAUTODIALENTRYA RASAUTODIALENTRYA*
#define LPRASAUTODIALENTRY  RASAUTODIALENTRY*

/* AutoDial control parameter values for
** Ras{Get,Set}AutodialParam.
*/
#define RASADP_DisableConnectionQuery           0
#define RASADP_LoginSessionDisable              1
#define RASADP_SavedAddressesLimit              2
#define RASADP_FailedConnectionTimeout          3
#define RASADP_ConnectionQueryTimeout           4

#endif // (WINVER >= 0x401)


/* External RAS API function prototypes.
*/
DWORD APIENTRY RasDialA( LPRASDIALEXTENSIONS, LPSTR, LPRASDIALPARAMSA, DWORD,
                   LPVOID, LPHRASCONN );

DWORD APIENTRY RasDialW( LPRASDIALEXTENSIONS, LPWSTR, LPRASDIALPARAMSW, DWORD,
                   LPVOID, LPHRASCONN );

DWORD APIENTRY RasEnumConnectionsA( LPRASCONNA, LPDWORD, LPDWORD );

DWORD APIENTRY RasEnumConnectionsW( LPRASCONNW, LPDWORD, LPDWORD );

DWORD APIENTRY RasEnumEntriesA( LPSTR, LPSTR, LPRASENTRYNAMEA, LPDWORD,
                   LPDWORD );

DWORD APIENTRY RasEnumEntriesW( LPWSTR, LPWSTR, LPRASENTRYNAMEW, LPDWORD,
                   LPDWORD );

DWORD APIENTRY RasGetConnectStatusA( HRASCONN, LPRASCONNSTATUSA );

DWORD APIENTRY RasGetConnectStatusW( HRASCONN, LPRASCONNSTATUSW );

DWORD APIENTRY RasGetErrorStringA( UINT, LPSTR, DWORD );

DWORD APIENTRY RasGetErrorStringW( UINT, LPWSTR, DWORD );

DWORD APIENTRY RasHangUpA( HRASCONN );

DWORD APIENTRY RasHangUpW( HRASCONN );

DWORD APIENTRY RasGetProjectionInfoA( HRASCONN, RASPROJECTION, LPVOID,
                   LPDWORD );

DWORD APIENTRY RasGetProjectionInfoW( HRASCONN, RASPROJECTION, LPVOID,
                   LPDWORD );

DWORD APIENTRY RasCreatePhonebookEntryA( HWND, LPSTR );

DWORD APIENTRY RasCreatePhonebookEntryW( HWND, LPWSTR );

DWORD APIENTRY RasEditPhonebookEntryA( HWND, LPSTR, LPSTR );

DWORD APIENTRY RasEditPhonebookEntryW( HWND, LPWSTR, LPWSTR );

DWORD APIENTRY RasSetEntryDialParamsA( LPSTR, LPRASDIALPARAMSA, BOOL );

DWORD APIENTRY RasSetEntryDialParamsW( LPWSTR, LPRASDIALPARAMSW, BOOL );

DWORD APIENTRY RasGetEntryDialParamsA( LPSTR, LPRASDIALPARAMSA, LPBOOL );

DWORD APIENTRY RasGetEntryDialParamsW( LPWSTR, LPRASDIALPARAMSW, LPBOOL );

DWORD APIENTRY RasEnumDevicesA( LPRASDEVINFOA, LPDWORD, LPDWORD );

DWORD APIENTRY RasEnumDevicesW( LPRASDEVINFOW, LPDWORD, LPDWORD );

DWORD APIENTRY RasGetCountryInfoA( LPRASCTRYINFOA, LPDWORD );

DWORD APIENTRY RasGetCountryInfoW( LPRASCTRYINFOW, LPDWORD );

DWORD APIENTRY RasGetEntryPropertiesA( LPSTR, LPSTR, LPRASENTRYA, LPDWORD, LPBYTE, LPDWORD );

DWORD APIENTRY RasGetEntryPropertiesW( LPWSTR, LPWSTR, LPRASENTRYW, LPDWORD, LPBYTE, LPDWORD );

DWORD APIENTRY RasSetEntryPropertiesA( LPSTR, LPSTR, LPRASENTRYA, DWORD, LPBYTE, DWORD );

DWORD APIENTRY RasSetEntryPropertiesW( LPWSTR, LPWSTR, LPRASENTRYW, DWORD, LPBYTE, DWORD );

DWORD APIENTRY RasRenameEntryA( LPSTR, LPSTR, LPSTR );

DWORD APIENTRY RasRenameEntryW( LPWSTR, LPWSTR, LPWSTR );

DWORD APIENTRY RasDeleteEntryA( LPSTR, LPSTR );

DWORD APIENTRY RasDeleteEntryW( LPWSTR, LPWSTR );

DWORD APIENTRY RasValidateEntryNameA( LPSTR, LPSTR );

DWORD APIENTRY RasValidateEntryNameW( LPWSTR, LPWSTR );

#if (WINVER >= 0x401)
DWORD APIENTRY RasGetSubEntryHandleA( HRASCONN, DWORD, LPHRASCONN );

DWORD APIENTRY RasGetSubEntryHandleW( HRASCONN, DWORD, LPHRASCONN );

DWORD APIENTRY RasGetCredentialsA( LPSTR, LPSTR, LPRASCREDENTIALSA);

DWORD APIENTRY RasGetCredentialsW( LPWSTR, LPWSTR, LPRASCREDENTIALSW );

DWORD APIENTRY RasSetCredentialsA( LPSTR, LPSTR, LPRASCREDENTIALSA, BOOL );

DWORD APIENTRY RasSetCredentialsW( LPWSTR, LPWSTR, LPRASCREDENTIALSW, BOOL );

DWORD APIENTRY RasConnectionNotificationA( HRASCONN, HANDLE, DWORD );

DWORD APIENTRY RasConnectionNotificationW( HRASCONN, HANDLE, DWORD );

DWORD APIENTRY RasGetSubEntryPropertiesA( LPSTR, LPSTR, DWORD,
                    LPRASSUBENTRYA, LPDWORD, LPBYTE, LPDWORD );

DWORD APIENTRY RasGetSubEntryPropertiesW( LPWSTR, LPWSTR, DWORD,
                    LPRASSUBENTRYW, LPDWORD, LPBYTE, LPDWORD );

DWORD APIENTRY RasSetSubEntryPropertiesA( LPSTR, LPSTR, DWORD,
                    LPRASSUBENTRYA, DWORD, LPBYTE, DWORD );

DWORD APIENTRY RasSetSubEntryPropertiesW( LPWSTR, LPWSTR, DWORD,
                    LPRASSUBENTRYW, DWORD, LPBYTE, DWORD );

DWORD APIENTRY RasDeleteSubEntryA( LPSTR, LPSTR, DWORD );

DWORD APIENTRY RasDeleteSubEntryW( LPWSTR, LPWSTR, DWORD );

DWORD APIENTRY RasGetAutodialAddressA( LPSTR, LPDWORD, LPRASAUTODIALENTRYA,
                    LPDWORD, LPDWORD );

DWORD APIENTRY RasGetAutodialAddressW( LPWSTR, LPDWORD, LPRASAUTODIALENTRYW,
                    LPDWORD, LPDWORD);

DWORD APIENTRY RasSetAutodialAddressA( LPSTR, DWORD, LPRASAUTODIALENTRYA,
                    DWORD, DWORD );

DWORD APIENTRY RasSetAutodialAddressW( LPWSTR, DWORD, LPRASAUTODIALENTRYW,
                    DWORD, DWORD );

DWORD APIENTRY RasEnumAutodialAddressesA( LPSTR *, LPDWORD, LPDWORD );

DWORD APIENTRY RasEnumAutodialAddressesW( LPWSTR *, LPDWORD, LPDWORD );

DWORD APIENTRY RasGetAutodialEnableA( DWORD, LPBOOL );

DWORD APIENTRY RasGetAutodialEnableW( DWORD, LPBOOL );

DWORD APIENTRY RasSetAutodialEnableA( DWORD, BOOL );

DWORD APIENTRY RasSetAutodialEnableW( DWORD, BOOL );

DWORD APIENTRY RasGetAutodialParamA( DWORD, LPVOID, LPDWORD );

DWORD APIENTRY RasGetAutodialParamW( DWORD, LPVOID, LPDWORD );

DWORD APIENTRY RasSetAutodialParamA( DWORD, LPVOID, DWORD );

DWORD APIENTRY RasSetAutodialParamW( DWORD, LPVOID, DWORD );
#endif


#ifdef UNICODE
#define RasDial                 RasDialW
#define RasEnumConnections      RasEnumConnectionsW
#define RasEnumEntries          RasEnumEntriesW
#define RasGetConnectStatus     RasGetConnectStatusW
#define RasGetErrorString       RasGetErrorStringW
#define RasHangUp               RasHangUpW
#define RasGetProjectionInfo    RasGetProjectionInfoW
#define RasCreatePhonebookEntry RasCreatePhonebookEntryW
#define RasEditPhonebookEntry   RasEditPhonebookEntryW
#define RasSetEntryDialParams   RasSetEntryDialParamsW
#define RasGetEntryDialParams   RasGetEntryDialParamsW
#define RasEnumDevices          RasEnumDevicesW
#define RasGetCountryInfo       RasGetCountryInfoW
#define RasGetEntryProperties   RasGetEntryPropertiesW
#define RasSetEntryProperties   RasSetEntryPropertiesW
#define RasRenameEntry          RasRenameEntryW
#define RasDeleteEntry          RasDeleteEntryW
#define RasValidateEntryName    RasValidateEntryNameW
#if (WINVER >= 0x401)
#define RasGetSubEntryHandle        RasGetSubEntryHandleW
#define RasConnectionNotification   RasConnectionNotificationW
#define RasGetSubEntryProperties    RasGetSubEntryPropertiesW
#define RasSetSubEntryProperties    RasSetSubEntryPropertiesW
#define RasDeleteSubEntry           RasDeleteSubEntryW
#define RasGetCredentials           RasGetCredentialsW
#define RasSetCredentials           RasSetCredentialsW
#define RasGetAutodialAddress       RasGetAutodialAddressW
#define RasSetAutodialAddress       RasSetAutodialAddressW
#define RasEnumAutodialAddresses    RasEnumAutodialAddressesW
#define RasGetAutodialEnable        RasGetAutodialEnableW
#define RasSetAutodialEnable        RasSetAutodialEnableW
#define RasGetAutodialParam         RasGetAutodialParamW
#define RasSetAutodialParam         RasSetAutodialParamW
#endif
#else
#define RasDial                 RasDialA
#define RasEnumConnections      RasEnumConnectionsA
#define RasEnumEntries          RasEnumEntriesA
#define RasGetConnectStatus     RasGetConnectStatusA
#define RasGetErrorString       RasGetErrorStringA
#define RasHangUp               RasHangUpA
#define RasGetProjectionInfo    RasGetProjectionInfoA
#define RasCreatePhonebookEntry RasCreatePhonebookEntryA
#define RasEditPhonebookEntry   RasEditPhonebookEntryA
#define RasSetEntryDialParams   RasSetEntryDialParamsA
#define RasGetEntryDialParams   RasGetEntryDialParamsA
#define RasEnumDevices          RasEnumDevicesA
#define RasGetCountryInfo       RasGetCountryInfoA
#define RasGetEntryProperties   RasGetEntryPropertiesA
#define RasSetEntryProperties   RasSetEntryPropertiesA
#define RasRenameEntry          RasRenameEntryA
#define RasDeleteEntry          RasDeleteEntryA
#define RasValidateEntryName    RasValidateEntryNameA
#if (WINVER >= 0x401)
#define RasGetSubEntryHandle        RasGetSubEntryHandleA
#define RasConnectionNotification   RasConnectionNotificationA
#define RasGetSubEntryProperties    RasGetSubEntryPropertiesA
#define RasSetSubEntryProperties    RasSetSubEntryPropertiesA
#define RasDeleteSubEntry           RasDeleteSubEntryA
#define RasGetCredentials           RasGetCredentialsA
#define RasSetCredentials           RasSetCredentialsA
#define RasGetAutodialAddress       RasGetAutodialAddressA
#define RasSetAutodialAddress       RasSetAutodialAddressA
#define RasEnumAutodialAddresses    RasEnumAutodialAddressesA
#define RasGetAutodialEnable        RasGetAutodialEnableA
#define RasSetAutodialEnable        RasSetAutodialEnableA
#define RasGetAutodialParam         RasGetAutodialParamA
#define RasSetAutodialParam         RasSetAutodialParamA
#endif
#endif

#ifdef __cplusplus
}
#endif

#include <poppack.h>

#endif // _RAS_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\hnw\win95\setupx1.h ===
//**********************************************************************
//
// SETUPX.H
//
//  Copyright (c) 1993 - Microsoft Corp.
//  All rights reserved.
//  Microsoft Confidential
//
// Putlic include file for Chicago Setup services.
//
// 12/1/93      DONALDM     Added LPCLASS_INFO, and function protos for
//                          exports in SETUP4.DLL
// 12/4/94      DONALDM     Moved SHELL.H include and Chicago specific
//                          helper functions to SETUP4.H
//**********************************************************************

#ifndef SETUPX_INC
#define SETUPX_INC   1                   // SETUPX.H signature

typedef UINT RETERR;             // Return Error code type.

#define OK 0                     // success error code

#define IP_ERROR       (100)    // Inf parsing
#define TP_ERROR       (200)    // Text processing module
#define VCP_ERROR      (300)    // Virtual copy module
#define GEN_ERROR      (400)    // Generic Installer
#define DI_ERROR       (500)    // Device Installer

// err2ids mappings
enum ERR_MAPPINGS {
	E2I_VCPM,			// Maps VCPM to strings
	E2I_SETUPX,			// Maps setupx returns to strings
	E2I_SETUPX_MODULE,	// Maps setupx returns to appropriate module
	E2I_DOS_SOLUTION,	// Maps DOS Extended errors to solutions
	E2I_DOS_REASON,		// Maps DOS extended errors to strings.
	E2I_DOS_MEDIA,		// Maps DOS extended errors to media icon.
};

#ifndef NOVCP

/***************************************************************************/
//
// Logical Disk ID definitions
//
/***************************************************************************/

// DECLARE_HANDLE(VHSTR);			/* VHSTR = VirtCopy Handle to STRing */
typedef UINT VHSTR;         /* VirtCopy Handle to String */

VHSTR	WINAPI vsmStringAdd(LPCSTR lpszName);
int	WINAPI vsmStringDelete(VHSTR vhstr);
VHSTR	WINAPI vsmStringFind(LPCSTR lpszName);
int	WINAPI vsmGetStringName(VHSTR vhstr, LPSTR lpszBuffer, int cbBuffer);
int	WINAPI vsmStringCompare(VHSTR vhstrA, VHSTR vhstrB);
LPCSTR	WINAPI vsmGetStringRawName(VHSTR vhstr);
void	WINAPI vsmStringCompact(void);

typedef UINT LOGDISKID;          /* ldid */

// Logical Disk Descriptor: Structure which describes the physical attributes
// of a logical disk. Every logical disk is assigned a logical disk
// identifier (LDID), and is described by a logical disk descriptor (LDD).
//
// The cbSize structure member must always be set to sizeof(LOGDISKDESC_S),
// but all other unused structure members should be NULL or 0. No validation
// is performed on the size of string arrays; all string pointers, if
// non-NULL and they are to receive a string, must point at string arrays
// whose sizes are as follows:
//      sizeof( szPath )    = MAX_PATH_LEN
//      sizeof( szVolLabel) = MAX_FILENAME_LEN
//      sizeof( szName )    = MAX_STRING_LEN
#define MAX_PATH_LEN        260     // Max. path length.
#define MAX_FILENAME_LEN    20      // Max. filename length. ( > sizeof( "x:\\12345678.123" )


typedef struct _LOGDISKDESC_S { /* ldd */
    WORD        cbSize;                 // Size of this structure (bytes)
    LOGDISKID   ldid;                   // Logical Disk ID.
    LPSTR       pszPath;                // Ptr. to associated Path string.
    LPSTR       pszVolLabel;            // Ptr. to Volume Label string.
    LPSTR       pszDiskName;            // Ptr. to Disk Name string.
    WORD        wVolTime;               // Volume label modification time.
    WORD        wVolDate;               // Volume label modification date.
    DWORD       dwSerNum;               // Disk serial number.
    WORD        wFlags;                 // Flags.
} LOGDISKDESC_S, FAR *LPLOGDISKDESC;


// Range for pre-defined LDIDs.
#define LDID_PREDEF_START   0x0001  // Start of range
#define LDID_PREDEF_END     0x7FFF  // End of range

// Range for dynamically assigned LDIDs.
#define LDID_ASSIGN_START   0x8000  // Start of range
#define LDID_ASSIGN_END     0xBFFF  // End of range

// Pre-defined Logical Disk Identifiers (LDID).
//
#define LDID_NULL       0               // Null (undefined) LDID.
#define LDID_ABSOLUTE   ((UINT)-1)      // Absolute path

// source path of windows install, this is typically A:\ or a net drive
#define LDID_SRCPATH    1   // source of instilation
// temporary setup directory used by setup, this is only valid durring
// regular install
#define LDID_SETUPTEMP  2   // temporary setup dir for install
// path to uninstall location, this is where we backup files that will
// be overwritten
#define LDID_UNINSTALL  3   // uninstall (backup) dir.
// backup path for the copy engine, this should not be used
#define LDID_BACKUP     4   // ISSUE-2002/01/16-roelfc: backup dir for the copy engine, not used

// windows directory, this is the destinatio of the insallation
#define LDID_WIN        10  // destination Windows dir.
#define LDID_SYS        11  // destination Windows System dir.
#define LDID_IOS        12  // destination Windows Iosubsys dir.
#define LDID_CMD        13  // destination Windows Command (DOS) dir.
#define LDID_CPL        14  // destination Windows Control Panel dir.
#define LDID_PRINT      15  // destination Windows Printer dir.
#define LDID_MAIL       16  // destination Mail dir.
#define LDID_INF        17  // destination Windows *.INF dir.
// ISSUE-2002/01/16-roelfc: do we need the shared dir for net install?

#define LDID_BOOT       30  // Root dir of boot drive
#define LDID_BOOT_HOST  31  // Root dir of boot drive host
#define LDID_OLD_WIN    33  // old windows directory (if it exists)
#define LDID_OLD_DOS    34  // old dos directory (if it exists)

// Convert Ascii drive letter to Integer drive number ('A'=1, 'B'=2, ...).
#define DriveAtoI( chDrv )      ((int)(chDrv & 31))

// Convert Integer drive number to Ascii drive letter (1='A', 2='B', ...).
#define DriveItoA( iDrv )       ((char) (iDrv - 1 + 'A'))


// ISSUE-2002/01/16-roelfc: change the names of these

RETERR WINAPI CtlSetLdd     ( LPLOGDISKDESC );
RETERR WINAPI CtlGetLdd     ( LPLOGDISKDESC );
RETERR WINAPI CtlFindLdd    ( LPLOGDISKDESC );
RETERR WINAPI CtlAddLdd     ( LPLOGDISKDESC );
RETERR WINAPI CtlDelLdd     ( LOGDISKID  );
RETERR WINAPI CtlGetLddPath ( LOGDISKID, LPSTR );


/***************************************************************************/
//
// Virtual File Copy definitions
//
/***************************************************************************/


typedef DWORD LPEXPANDVTBL;         /* ISSUE-2002/01/16-roelfc -- clean this up */

enum _ERR_VCP
{
    ERR_VCP_IOFAIL = (VCP_ERROR + 1),       // File I/O failure
    ERR_VCP_STRINGTOOLONG,                  // String length limit exceeded
    ERR_VCP_NOMEM,                          // Insufficient memory to comply
    ERR_VCP_NOVHSTR,                        // No string handles available
    ERR_VCP_OVERFLOW,                       // Reference count would overflow
    ERR_VCP_BADARG,                         // Invalid argument to function
    ERR_VCP_UNINIT,                         // String library not initialized
    ERR_VCP_NOTFOUND , 						// String not found in string table
    ERR_VCP_BUSY,                           // Can't do that now
    ERR_VCP_INTERRUPTED,                    // User interrupted operation
    ERR_VCP_BADDEST,                        // Invalid destination directory
    ERR_VCP_SKIPPED,                        // User skipped operation
    ERR_VCP_IO,                             // Hardware error encountered
    ERR_VCP_LOCKED,                         // List is locked
    ERR_VCP_WRONGDISK,                      // The wrong disk is in the drive
    ERR_VCP_CHANGEMODE,                     //
    ERR_VCP_LDDINVALID,                // Logical Disk ID Invalid.
    ERR_VCP_LDDFIND,                   // Logical Disk ID not found.
    ERR_VCP_LDDUNINIT,                 // Logical Disk Descriptor Uninitialized.
    ERR_VCP_LDDPATH_INVALID,
    ERR_VCP_NOEXPANSION,				// Failed to load expansion dll
    ERR_VCP_NOTOPEN,					// Copy session not open
};


/*****************************************************************************
 *              Structures
 *****************************************************************************/

/*---------------------------------------------------------------------------*
 *                  VCPPROGRESS
 *---------------------------------------------------------------------------*/

typedef struct tagVCPPROGRESS { /* prg */
    DWORD   dwSoFar;            /* Number of units copied so far */
    DWORD   dwTotal;            /* Number of units to copy */
} VCPPROGRESS, FAR *LPVCPPROGRESS;

/*---------------------------------------------------------------------------*
 *                  VCPDISKINFO
 *---------------------------------------------------------------------------*/

/*  ISSUE-2002/01/16-roelfc:                                       ;Internal
 *  I currently don't use wVolumeTime, wVolumeDate or              ;Internal
 *  dwSerialNumber.  We may not want to use dwSerialNumber because ;Internal
 *  it means that any disk other than the factory originals will be;Internal
 *  suspected of being tampered with, since the serial number      ;Internal
 *  won't match.  Similar with the time/date stamp on the          ;Internal
 *  volume label.  Or maybe that's what we want to do.             ;Internal
 */                                                             /* ;Internal */
                                                                /* ;Internal */

typedef struct tagVCPDISKINFO {
    WORD        cbSize;         /* Size of this structure in bytes */
    LOGDISKID   ldid;           /* Logical disk ID */
    VHSTR       vhstrRoot;      /* Location of root directory */
    VHSTR       vhstrVolumeLabel;/* Volume label */
    VHSTR		vhstrDiskName;	// Printed name on the disk.
    WORD        wVolumeTime;    /* Volume label modification time */
    WORD        wVolumeDate;    /* Volume label modification date */
    DWORD       dwSerialNumber; /* Disk serial number */
    WORD        fl;             /* Flags */
    LPARAM      lparamRef;      /* Reference data for client */

    VCPPROGRESS prgFileRead;    /* Progress info */
    VCPPROGRESS prgByteRead;

    VCPPROGRESS prgFileWrite;
    VCPPROGRESS prgByteWrite;

} VCPDISKINFO, FAR *LPVCPDISKINFO;

#define VDIFL_VALID     0x0001  /* Fields are valid from a prev. call */
#define VDIFL_EXISTS    0x0002  /* Disk exists; do not format */

RETERR WINAPI DiskInfoFromLdid(LOGDISKID ldid, LPVCPDISKINFO lpdi);


/*---------------------------------------------------------------------------*
 *                  VCPFILESPEC
 *---------------------------------------------------------------------------*/

typedef struct tagVCPFILESPEC { /* vfs */
    LOGDISKID   ldid;           /* Logical disk */
    VHSTR       vhstrDir;       /* Directory withing logical disk */
    VHSTR       vhstrFileName;  /* Filename within directory */
} VCPFILESPEC, FAR *LPVCPFILESPEC;

/*---------------------------------------------------------------------------*
 *              VCPFATTR
 *---------------------------------------------------------------------------*/

/*
 * ISSUE-2002/01/16-roelfc -- explain diffce between llenIn and llenOut wrt compression.
 */
typedef struct tagVCPFATTR {
    UINT    uiMDate;            /* Modification date */
    UINT    uiMTime;            /* Modification time */
    UINT    uiADate;            /* Access date */
    UINT    uiATime;            /* Access time */
    UINT    uiAttr;             /* File attribute bits */
    DWORD   llenIn;             /* Original file length */
    DWORD   llenOut;            /* Final file length */
                                /* (after decompression) */
} VCPFATTR, FAR *LPVCPFATTR;

/*---------------------------------------------------------------------------*
 *                  VIRTNODEEX
 *---------------------------------------------------------------------------*/
typedef struct tagVIRTNODEEX
{    /* vnex */
    HFILE			hFileSrc;
    HFILE			hFileDst;
    VCPFATTR		fAttr;
    WORD			dosError;	// The first/last error encountered
    VHSTR			vhstrFileName;	// The original destination name.
    WPARAM          vcpm;   // The message that was being processed.
} VIRTNODEEX, FAR *LPCVIRTNODEEX, FAR *LPVIRTNODEEX ;


/*---------------------------------------------------------------------------*
 *                  VIRTNODE
 *---------------------------------------------------------------------------*/

/* WARNING!                                                        ;Internal
 *  All fields through but not including                           ;Internal
 *  fl are memcmp'd to determine if we have a duplicate copy       ;Internal
 *  request.                                                       ;Internal
 *                                                                 ;Internal
 *  Do not insert fields before fl unless you want them to be      ;Internal
 *  compared; conversely, if you add a new field that needs to     ;Internal
 *  be compared, make sure it goes before fl.                      ;Internal
 *                                                                 ;Internal
 *  And don't change any of the fields once Windows 4.0 ships.     ;Internal
 */                                                             /* ;Internal */
                                                                /* ;Internal */
typedef struct tagVIRTNODE {    /* vn */
    WORD            cbSize;
    VCPFILESPEC     vfsSrc;
    VCPFILESPEC     vfsDst;
    WORD            fl;
    LPARAM          lParam;
    LPEXPANDVTBL    lpExpandVtbl;
    LPVIRTNODEEX	lpvnex;
} VIRTNODE, FAR *LPCVIRTNODE, FAR *LPVIRTNODE ;


/*---------------------------------------------------------------------------*
 *              VCPDESTINFO
 *---------------------------------------------------------------------------*/

typedef struct tagVCPDESTINFO { /* destinfo */
    WORD    flDevAttr;          /* Device attributes */
    LONG    cbCapacity;         /* Disk capacity */
    WORD    cbCluster;          /* Bytes per cluster */
    WORD    cRootDir;           /* Size of root directory */
} VCPDESTINFO, FAR *LPVCPDESTINFO;

#define DIFL_FIXED      0x0001  /* Nonremoveable media */
#define DIFL_CHANGELINE 0x0002  /* Change line support */

// Now also used by the virtnode as we dont have copy nodes any more.
// #define CNFL_BACKUP             0x0001  /* This is a backup node */
#define CNFL_DELETEONFAILURE    0x0002  /* Dest should be deleted on failure */
#define CNFL_RENAMEONSUCCESS    0x0004  /* Dest needs to be renamed */
#define CNFL_CONTINUATION       0x0008  /* Dest is continued onto difft disk */
#define CNFL_SKIPPED            0x0010  /* User asked to skip file */
#define CNFL_IGNOREERRORS		0x0020  // An error has occured on this file already
#define	CNFL_RETRYFILE			0x0040	// Retry the file (error ocurred)

// ISSUE-2002/01/16-roelfc: verify the use and usefullness of these flags

// #define VNFL_UNIQUE         0x0000  /* Default */
#define VNFL_MULTIPLEOK     0x0100  /* Do not search PATH for duplicates */
#define VNFL_DESTROYOLD     0x0200  /* Do not back up files */
#define VNFL_NOW            0x0400  /* Use by vcp Flush */
#define VNFL_DELETE         0x0800  // A delete node
#define VNFL_RENAME			0x1000  // A rename node
    /* Read-only flag bits */
#define VNFL_CREATED        0x2000  /* VCPM_NODECREATE has been sent */
#define VNFL_REJECTED       0x4000  /* Node has been rejected */
#define VNFL_VALIDVQCFLAGS  0xff00  /* ;Internal */

/*---------------------------------------------------------------------------*
 *                  VCPSTATUS
 *---------------------------------------------------------------------------*/

typedef struct tagVCPSTATUS {   /* vstat */
    WORD    cbSize;             /* Size of this structure */

    VCPPROGRESS prgDiskRead;
    VCPPROGRESS prgFileRead;
    VCPPROGRESS prgByteRead;

    VCPPROGRESS prgDiskWrite;
    VCPPROGRESS prgFileWrite;
    VCPPROGRESS prgByteWrite;

    LPVCPDISKINFO lpvdiIn;      /* Current input disk */
    LPVCPDISKINFO lpvdiOut;     /* Current output disk */
    LPVIRTNODE    lpvn;            /* Current file */

} VCPSTATUS, FAR *LPVCPSTATUS;

/*---------------------------------------------------------------------------*
 *                  VCPVERCONFLICT
 *---------------------------------------------------------------------------*/

typedef struct tagVCPVERCONFLICT {

    LPCSTR  lpszOldFileName;
    LPCSTR  lpszNewFileName;
    DWORD   dwConflictType;     /* Same values as VerInstallFiles */
    LPVOID  lpvinfoOld;         /* Version information resources */
    LPVOID  lpvinfoNew;
    WORD    wAttribOld;         /* File attributes for original */
    LPARAM  lparamRef;          /* Reference data for callback */

} VCPVERCONFLICT, FAR *LPVCPVERCONFLICT;

/*****************************************************************************
 *              Callback functions
 *****************************************************************************/

typedef LRESULT (CALLBACK *VIFPROC)(LPVOID lpvObj, UINT uMsg, WPARAM wParam, LPARAM lParam, LPARAM lparamRef);

LRESULT CALLBACK vcpDefCallbackProc(LPVOID lpvObj, UINT uMsg, WPARAM wParam, LPARAM lParam, LPARAM lparamRef);

// callback for default UI.
// lparamRef --> a VCPUIINFO structure
LRESULT CALLBACK vcpUICallbackProc(LPVOID lpvObj, UINT uMsg, WPARAM wParam, LPARAM lParam, LPARAM lparamRef);

/*---------------------------------------------------------------------------*
 *                  VCPUIINFO
 *
 * This structure is passed in as the lparamRef of vcpUICallbackProc.
 *
 * on using vcpUICallbackProc:
 * - to use, have vcpUICallbackProc as the callback for vcpOpen with
 *   an appropriately filled in VCPUIINFO structure as the lparamRef.
 *
 * - based on flags, hwndProgress is created and maintained
 * - lpfnStatCallback is called with only status messages
 *     returning VCPM_ABORT indicates that the copy should be aborted
 * - if hwndProgress is non-NULL, the control with idProgress will
 *     receive progress gauge messages as appropriate
 *
 *---------------------------------------------------------------------------*/
#define VCPUI_CREATEPROGRESS 0x0001 // callback should create and manage progress gauge dialog
#define VCPUI_NOBROWSE       0x0002 // no browse button in InsertDisk
#define VCPUI_RENAMEREQUIRED 0x0004 // as a result of a file being in use at copy, reboot required

typedef struct {
    UINT flags;
    HWND hwndParent;			// window of parent
    HWND hwndProgress;          // window to get progress updates (nonzero ids)
    UINT idPGauge;              // id for progress gauge
    VIFPROC lpfnStatCallback;	// callback for status info (or NULL)
    LPARAM lUserData;			// caller definable data
    LOGDISKID ldidCurrent;		// reserved.  do not touch.
} VCPUIINFO, FAR *LPVCPUIINFO;

/******************************************************************************
 *          Callback notification codes
 *****************************************************************************/

/* ISSUE-2002/01/16-roelfc -- VCPN_ABORT should match VCPERROR_INTERRUPTED */

#define VCPN_OK         0       /* All is hunky-dory */
#define VCPN_PROCEED        0   /* The same as VCPN_OK */

#define VCPN_ABORT      (-1)    /* Cancel current operation */
#define VCPN_RETRY      (-2)    /* Retry current operation */
#define VCPN_IGNORE     (-3)    /* Ignore error and continue */
#define VCPN_SKIP       (-4)    /* Skip this file and continue */
#define VCPN_FORCE      (-5)    /* Force an action */
#define VCPN_DEFER      (-6)    /* Save the action for later */
#define VCPN_FAIL       (-7)    /* Return failure back to caller */
#define VCPN_RETRYFILE  (-8)    // An error ocurred during file copy, do it again.

/*****************************************************************************
 *          Callback message numbers
 *****************************************************************************/

#define VCPM_CLASSOF(uMsg)  HIBYTE(uMsg)
#define VCPM_TYPEOF(uMsg)   (0x00FF & (uMsg))   // LOBYTE(uMsg)

/*---------------------------------------------------------------------------*
 *          ERRORs
 *---------------------------------------------------------------------------*/

#define VCPM_ERRORCLASSDELTA    0x80
#define VCPM_ERRORDELTA         0x8000      /* Where the errors go */

/*---------------------------------------------------------------------------*
 *          Disk information callbacks
 *---------------------------------------------------------------------------*/

#define VCPM_DISKCLASS      0x01
#define VCPM_DISKFIRST      0x0100
#define VCPM_DISKLAST       0x01FF

enum tagVCPM_DISK {

    VCPM_DISKCREATEINFO = VCPM_DISKFIRST,
    VCPM_DISKGETINFO,
    VCPM_DISKDESTROYINFO,
    VCPM_DISKPREPINFO,

    VCPM_DISKENSURE,
    VCPM_DISKPROMPT,

    VCPM_DISKFORMATBEGIN,
    VCPM_DISKFORMATTING,
    VCPM_DISKFORMATEND,

    /* Remaining messages reserved for future use */
};

/*---------------------------------------------------------------------------*
 *          File copy callbacks
 *---------------------------------------------------------------------------*/

// ISSUE-2002/01/16-roelfc: this needs to be merged back with other internal errors
#define VCPERROR_IO         (VCP_ERROR - ERR_VCP_IO)            /* Hardware error encountered */

#define VCPM_FILEINCLASS    0x02
#define VCPM_FILEOUTCLASS   0x03
#define VCPM_FILEFIRSTIN    0x0200
#define VCPM_FILEFIRSTOUT   0x0300
#define VCPM_FILELAST       0x03FF

enum tagVCPM_FILE {
    VCPM_FILEOPENIN = VCPM_FILEFIRSTIN,
    VCPM_FILEGETFATTR,
    VCPM_FILECLOSEIN,
    VCPM_FILECOPY,

    VCPM_FILEOPENOUT = VCPM_FILEFIRSTOUT,
    VCPM_FILESETFATTR,
    VCPM_FILECLOSEOUT,
    VCPM_FILEFINALIZE,
    VCPM_FILEDELETE,
    VCPM_FILERENAME,
    /* Remaining messages reserved for future use */
};

/*---------------------------------------------------------------------------*
 *          VIRTNODE callbacks
 *---------------------------------------------------------------------------*/

#define VCPM_NODECLASS  0x04
#define VCPM_NODEFIRST  0x0400
#define VCPM_NODELAST   0x04FF

enum tagVCPM_NODE {
    VCPM_NODECREATE = VCPM_NODEFIRST,
    VCPM_NODEACCEPT,
    VCPM_NODEREJECT,
    VCPM_NODEDESTROY,
    VCPM_NODECHANGEDESTDIR,
    VCPM_NODECOMPARE,
    /* Remaining messages reserved for future use */
};

/*---------------------------------------------------------------------------*
 *          TALLY callbacks
 *---------------------------------------------------------------------------*/

#define VCPM_TALLYCLASS     0x05
#define VCPM_TALLYFIRST     0x0500
#define VCPM_TALLYLAST      0x05FF

enum tagVCPM_TALLY {
    VCPM_TALLYSTART = VCPM_TALLYFIRST,
    VCPM_TALLYEND,
    VCPM_TALLYFILE,
    VCPM_TALLYDISK,
    /* Remaining messages reserved for future use */
};

/*---------------------------------------------------------------------------*
 *          VER callbacks
 *---------------------------------------------------------------------------*/

#define VCPM_VERCLASS       0x06
#define VCPM_VERFIRST       0x0600
#define VCPM_VERLAST        0x06FF

enum tagVCPM_VER {
    VCPM_VERCHECK = VCPM_VERFIRST,
    VCPM_VERCHECKDONE,
    VCPM_VERRESOLVECONFLICT,
    /* Remaining messages reserved for future use */
};

/*---------------------------------------------------------------------------*
 *          VSTAT callbacks
 *---------------------------------------------------------------------------*/

#define VCPM_VSTATCLASS     0x07
#define VCPM_VSTATFIRST     0x0700
#define VCPM_VSTATLAST      0x07FF

enum tagVCPM_VSTAT {
    VCPM_VSTATSTART = VCPM_VSTATFIRST,
    VCPM_VSTATEND,
    VCPM_VSTATREAD,
    VCPM_VSTATWRITE,
    VCPM_VSTATNEWDISK,

    VCPM_VSTATCLOSESTART,	// Start of VCP close
    VCPM_VSTATCLOSEEND,		// upon leaving VCP close
    VCPM_VSTATBACKUPSTART,	// Backup is beginning
    VCPM_VSTATBACKUPEND,	// Backup is finished
    VCPM_VSTATRENAMESTART,	// Rename phase start/end
    VCPM_VSTATRENAMEEND,
    VCPM_VSTATCOPYSTART,	// Acutal copy phase
    VCPM_VSTATCOPYEND,
    VCPM_VSTATDELETESTART,	// Delete phase
    VCPM_VSTATDELETEEND,
    VCPM_VSTATPATHCHECKSTART,	// Check for valid paths
    VCPM_VSTATPATHCHECKEND,
    /* Remaining messages reserved for future use */
};

/*---------------------------------------------------------------------------*
 *          Destination info callbacks
 *---------------------------------------------------------------------------*/

/* ISSUE-2002/01/16-roelfc -- find a reasonable message range for this */
#define VCPM_PATHCLASS      0x08
#define VCPM_PATHFIRST      0x0800
#define VCPM_PATHLAST       0x08FF

enum tagVCPM_PATH{
	VCPM_BUILDPATH = VCPM_PATHFIRST,
	VCPM_UNIQUEPATH,
	VCPM_CHECKPATH,
};

// #define VCPM_BUILDPATH      0x83


/*****************************************************************************/

RETERR WINAPI VcpOpen(VIFPROC vifproc, LPARAM lparamMsgRef);

RETERR WINAPI VcpClose(WORD fl, LPCSTR lpszBackupDest);

RETERR WINAPI VcpFlush(WORD fl, LPCSTR lpszBackupDest);

#define VCPFL_ABANDON           0x0000  /* Abandon all pending file copies */
#define VCPFL_BACKUP            0x0001  /* Perform backup */
#define VCPFL_COPY              0x0002  /* Copy files */
#define VCPFL_BACKUPANDCOPY     (VCPFL_BACKUP | VCPFL_COPY)
#define VCPFL_INSPECIFIEDORDER  0x0004  /* Do not sort before copying */
#define VCPFL_DELETE			0x0008
#define VCPFL_RENAME			0x0010

typedef int (CALLBACK *VCPENUMPROC)(LPVIRTNODE lpvn, LPARAM lparamRef);

int WINAPI vcpEnumFiles(VCPENUMPROC vep, LPARAM lparamRef);

/* Flag bits that can be set via VcpQueueCopy */


// Various Lparams for files
#define VNLP_SYSCRITICAL	0x0001	// This file cannot be skipped

// VcpEnumFiles Flags.

#define VEN_OP      0x00ff      /* Operation field */

#define VEN_NOP     0x0000      /* Do nothing */
#define VEN_DELETE  0x0001      /* Delete current item */
#define VEN_SET     0x0002      /* Change value of current item */
#define VEN_ADVANCE 0x0003      /* Move to head of list */      /* ;Internal */

#define VEN_FL      0xff00      /* Flags field */

#define VEN_STOP    0x0100      /* Stop enumeration after this item */
#define VEN_ERROR   0x8000      /* Stop enumeration after this item
                                 * and ignore the OP field */



// ISSUE-2002/01/16-roelfc: add the other VCP stuff necessary to use this

// ISSUE-2002/01/16-roelfc: remove the lpsz*Dir fields, make overload the LDID with them

RETERR WINAPI VcpQueueCopy(LPCSTR lpszSrcFileName, LPCSTR lpszDstFileName,
                LPCSTR lpszSrcDir, LPCSTR lpszDstDir,
                LOGDISKID ldidSrc, LOGDISKID ldidDst,
                LPEXPANDVTBL lpExpandVtbl, WORD fl,
                LPARAM lParam);

RETERR WINAPI VcpQueueDelete( LPCSTR lpszDstFileName,
                              LPCSTR lpszDstDir,
                              LOGDISKID ldidDst,
                              LPARAM lParamRef );

RETERR WINAPI VcpQueueRename( LPCSTR      lpszSrcFileName,
                            LPCSTR      lpszDstFileName,
                            LPCSTR      lpszSrcDir,
                            LPCSTR      lpszDstDir,
                            LOGDISKID   ldidSrc,
                            LOGDISKID   ldidDst,
                            LPARAM      lParam );

#endif // NOVCP



#ifndef NOINF
/***************************************************************************/
//
// Inf Parser API declaration and definitions
//
/***************************************************************************/

enum _ERR_IP
{
    ERR_IP_INVALID_FILENAME = (IP_ERROR + 1),
    ERR_IP_ALLOC_ERR,
    ERR_IP_INVALID_SECT_NAME,
    ERR_IP_OUT_OF_HANDLES,
    ERR_IP_INF_NOT_FOUND,
    ERR_IP_INVALID_INFFILE,
    ERR_IP_INVALID_HINF,
    ERR_IP_INVALID_FIELD,
    ERR_IP_SECT_NOT_FOUND,
    ERR_IP_END_OF_SECTION,
    ERR_IP_PROFILE_NOT_FOUND,
    ERR_IP_LINE_NOT_FOUND,
    ERR_IP_FILEREAD,
    ERR_IP_TOOMANYINFFILES,
    ERR_IP_INVALID_SAVERESTORE,
    ERR_IP_INVALID_INFTYPE
};

#define INFTYPE_TEXT                0
#define INFTYPE_EXECUTABLE          1

#define MAX_SECT_NAME_LEN    32

typedef struct _INF NEAR * HINF;
typedef struct _INFLINE FAR * HINFLINE;            // tolken to inf line

RETERR  WINAPI IpOpen(LPCSTR pszFileSpec, HINF FAR * lphInf);
RETERR  WINAPI IpOpenEx(LPCSTR pszFileSpec, HINF FAR * lphInf, UINT InfType);
RETERR  WINAPI IpOpenAppend(LPCSTR pszFileSpec, HINF hInf);
RETERR  WINAPI IpOpenAppendEx(LPCSTR pszFileSpec, HINF hInf, UINT InfType);
RETERR  WINAPI IpSaveRestorePosition(HINF hInf, BOOL bSave);
RETERR  WINAPI IpClose(HINF hInf);
RETERR  WINAPI IpGetLineCount(HINF hInf, LPCSTR lpszSection, int FAR * lpCount);
RETERR  WINAPI IpFindFirstLine(HINF hInf, LPCSTR lpszSect, LPCSTR lpszKey, HINFLINE FAR * lphRet);
RETERR  WINAPI IpFindNextLine(HINF hInf, HINFLINE FAR * lphRet);
RETERR  WINAPI IpFindNextMatchLine(HINF hInf, LPCSTR lpszKey, HINFLINE FAR * lphRet);
RETERR  WINAPI IpGetProfileString(HINF hInf, LPCSTR lpszSec, LPCSTR lpszKey, LPSTR lpszBuf, int iBufSize);
RETERR  WINAPI IpGetFieldCount(HINF hInf, HINFLINE hInfLine, int FAR * lpCount);
RETERR  WINAPI IpGetFileName(HINF hInf, LPSTR lpszBuf, int iBufSize);
RETERR  WINAPI IpGetIntField(HINF hInf, HINFLINE hInfLine, int iField, int FAR * lpVal);
RETERR  WINAPI IpGetLongField(HINF hInf, HINFLINE hInfLine, int iField, long FAR * lpVal);
RETERR  WINAPI IpGetStringField(HINF hInf, HINFLINE hInfLine, int iField, LPSTR lpBuf, int iBufSize, int FAR * lpuCount);

#endif // NOINF



#ifndef NOTEXTPROC
/***************************************************************************/
//
// Text processing API declaration and definitions
//
/***************************************************************************/

/* Relative/absolute positioning */
#define SEC_SET 1       // Absolute positioning (relative to the start)
#define SEC_END 2       // Realtive to the end
#define SEC_CUR 3       // Relative to the current line.

#define SEC_OPENALWAYS          1   // Always open a section, no error if it does not exist
#define SEC_OPENEXISTING        2   // Open an existing section, an error given if it does not exist.
#define SEC_OPENNEWALWAYS       3   // Open a section (present or not) and discard its contents.
#define SEC_OPENNEWEXISTING     4   // Open an existing section (discarding its contents). Error if not existing

// Flags for TP_OpenFile() to specify how to handle various differences in file types
#define TP_WS_IGNORE    0    // Use only "=" as key delimiter (.INI)
#define TP_WS_KEEP      1    // Use autoexec/config.sys key delimiters

// The following are simple errors
enum {
    ERR_TP_NOT_FOUND = (TP_ERROR + 1), 	// line, section, file etc.
        			// not necessarily terminal
    ERR_TP_NO_MEM,		// couldn't perform request - generally terminal
    ERR_TP_READ,		// could not read the disc - terminal
    ERR_TP_WRITE,		// could not write the data - terminal.
    ERR_TP_INVALID_REQUEST,	// Multitude of sins - not necessarily terminal.
    ERR_TP_INVALID_LINE         // Invalid line from DELETE_LINE etc.
};

/* Data handles */
DECLARE_HANDLE(HTP);
typedef HTP FAR * LPHTP;

/* File handles */
DECLARE_HANDLE(HFN);
typedef HFN FAR * LPHFN;

typedef UINT TFLAG;
typedef UINT LINENUM, FAR * LPLINENUM;

#define LINE_LEN        256     // ISSUE-2002/01/16-roelfc: max line length?
#define SECTION_LEN     32      // ISSUE-2002/01/16-roelfc: max length of a section name?
#define MAX_STRING_LEN  512     // ISSUE-2002/01/16-roelfc: review this

/* Function prototypes */
RETERR  WINAPI TpOpenFile(LPCSTR Filename, LPHFN phFile, TFLAG Flag);
RETERR  WINAPI TpCloseFile(HFN hFile);
RETERR  WINAPI TpOpenSection(HFN hfile, LPHTP phSection, LPCSTR Section, TFLAG flag);
RETERR  WINAPI TpCloseSection(HTP Section);
RETERR  WINAPI TpCommitSection(HFN hFile, HTP hSection, LPCSTR Section, TFLAG flag);
LINENUM WINAPI TpGetLine(HTP hSection, LPCSTR key, LPCSTR value, int rel, int orig, LPLINENUM lpLineNum );
LINENUM WINAPI TpGetNextLine(HTP hSection, LPCSTR key, LPCSTR value, LPLINENUM lpLineNum );
RETERR  WINAPI TpInsertLine(HTP hSection, LPCSTR key, LPCSTR value, int rel, int orig, TFLAG flag);
RETERR  WINAPI TpReplaceLine(HTP hSection, LPCSTR key, LPCSTR value, int rel, int orig, TFLAG flag);
RETERR  WINAPI TpDeleteLine(HTP hSection, int rel, int orig,TFLAG flag);
RETERR  WINAPI TpMoveLine(HTP hSection, int src_rel, int src_orig, int dest_rel, int dest_orig, TFLAG flag);
RETERR  WINAPI TpGetLineContents(HTP hSection, LPSTR buffer, UINT bufsize, UINT FAR * lpActualSize,int rel, int orig, TFLAG flag);
RETERR  WINAPI TpEnumerateSectionNames(LPCSTR Filename, LPCSTR Section, LPSTR buffer, UINT bufsize, UINT FAR * lpActualSize, TFLAG flag);
RETERR  WINAPI TpGetRawSection(LPSTR Filename, LPSTR Section, LPSTR buffer, UINT bufsize, UINT FAR * lpActualSize, TFLAG flag);
RETERR  WINAPI TpWriteRawSection(LPSTR Filename, LPSTR Section, LPCSTR buffer, TFLAG flag);

// UINT    WINAPI TpGetWindowsDirectory(LPSTR lpDest, UINT size);
// UINT    WINAPI TpGetSystemDirectory(LPSTR lpDest, UINT size);

int  WINAPI TpGetPrivateProfileString(LPCSTR lpszSect, LPCSTR lpszKey, LPCSTR lpszDefault, LPSTR lpszReturn, int nSize, LPCSTR lpszFile);
int  WINAPI TpWritePrivateProfileString(LPCSTR lpszSect, LPCSTR lpszKey, LPCSTR lpszString, LPCSTR lpszFile);
int  WINAPI TpGetProfileString(LPCSTR lpszSect, LPCSTR lpszKey, LPCSTR lpszDefault, LPSTR lpszReturn, int nSize);
BOOL WINAPI TpWriteProfileString(LPCSTR lpszSect , LPCSTR lpszKey , LPCSTR lpszString);

#endif // NOTEXTPROC



#ifndef NOGENINSTALL
/***************************************************************************/
//
// Generic Installer prototypes and definitions
//
/***************************************************************************/

enum _ERR_GENERIC
{
    ERR_GEN_ERROR_EXIT= GEN_ERROR,       // Exit due to error.
    ERR_GEN_LOW_MEM,                     // Insufficient Memory.
    ERR_GEN_MEM_OTHER,                   // Unable to lock memory, etc.
    ERR_GEN_FILE_OPEN,                   // File not found.
    ERR_GEN_FILE_COPY,                   // Cannot copy file.
    ERR_GEN_FILE_DEL,                    // Cannot delete file.
    ERR_GEN_FILE_REN,                    // Cannot delete file.
    ERR_GEN_INVALID_FILE,                // Invalid file.
    ERR_GEN_REG_API,                     // Error returned by Reg API.

};

// The cbSize field will always be set to sizeof(GENCALLBACKINFO_S).
// All unused fields (for the operation) will be not be initialized.
// For example, when the operation is GENO_DELFILE, the Src fields will
// not have any sensible values (Dst fields will be set correctly) as
// VcpQueueDelete only accepts Dst parameters.
//
/***************************************************************************
 * GenCallbackINFO structure passed to GenInstall CallBack functions.
 ***************************************************************************/
typedef struct _GENCALLBACKINFO_S { /* gen-callback struc */
    WORD         cbSize;                 // Size of this structure (bytes).
    WORD         wOperation;             // Operation being performed.
    LOGDISKID    ldidSrc;                // Logical Disk ID for Source.
    LPCSTR       pszSrcSubDir;           // Source sub-dir off of the LDID.
    LPCSTR       pszSrcFileName;         // Source file name (base name).
    LOGDISKID    ldidDst;                // Logical Disk ID for Dest.
    LPCSTR       pszDstSubDir;           // Dest. sub-dir off of the LDID.
    LPCSTR       pszDstFileName;         // Dest. file name (base name).
    LPEXPANDVTBL lpExpandVtbl;           // ISSUE-2002/01/16-roelfc: Needed? NULL right now!
    WORD         wflags;                 // flags for VcpQueueCopy.
    LPARAM       lParam;                 // LPARAM to the Vcp API.
} GENCALLBACKINFO_S, FAR *LPGENCALLBACKINFO;

/***************************************************************************
 * GenCallback notification codes -- callback proc returns 1 of foll. values.
 ***************************************************************************/
#define GENN_OK         0       /* All is hunky-dory. Do the VCP operation */
#define GENN_PROCEED    0       /* The same as GENN_OK */

#define GENN_ABORT      (-1)    /* Cancel current GenInstall altogether */
#define GENN_SKIP       (-2)    /* Skip this file and continue */

/***************************************************************************
 * VCP Operation being performed by GenInstall() -- wOperation values in
 * GENCALLBACKINFO structure above.
 ***************************************************************************/
#define GENO_COPYFILE   1       /* VCP copyfile being done */
#define GENO_DELFILE    2       /* VCP delfile being done */
#define GENO_RENFILE    3       /* VCP renfile being done */


typedef LRESULT (CALLBACK *GENCALLBACKPROC)(LPGENCALLBACKINFO lpGenInfo,
															LPARAM lparamRef);

RETERR WINAPI GenInstall( HINF hinfFile, LPCSTR szInstallSection, WORD wFlags );
RETERR WINAPI GenInstallEx( HINF hInf, LPCSTR szInstallSection, WORD wFlags,
								HKEY hRegKey, GENCALLBACKPROC CallbackProc,
								LPARAM lparam);
RETERR WINAPI GenWinInitRename(LPCSTR szNew, LPSTR szOld, LOGDISKID ldid);
RETERR WINAPI GenCopyLogConfig2Reg(HINF hInf, HKEY hRegKey,
												LPCSTR szLogConfigSection);
void   WINAPI GenFormStrWithoutPlaceHolders( LPSTR szDst, LPCSTR szSrc,
																HINF hInf ) ;

// Bit fields for GenInstall() (for wFlags parameter) -- these can be OR-ed!
#define GENINSTALL_DO_FILES		1
#define	GENINSTALL_DO_INI		2
#define	GENINSTALL_DO_REG		4
#define GENINSTALL_DO_CFGAUTO	8
#define GENINSTALL_DO_LOGCONFIG	16
#define	GENINSTALL_DO_INIREG	(GENINSTALL_DO_INI | GENINSTALL_DO_REG)
#define GENINSTALL_DO_ALL		(GENINSTALL_DO_FILES | \
									GENINSTALL_DO_INIREG | \
									GENINSTALL_DO_CFGAUTO | \
									GENINSTALL_DO_LOGCONFIG)

#endif // NOGENINSTALL



#ifndef NODEVICENSTALL
/***************************************************************************/
//
// Device Installer prototypes and definitions
//
/***************************************************************************/

enum _ERR_DEVICE_INSTALL
{
    ERR_DI_INVALID_DEVICE_ID = DI_ERROR,    // Incorrectly formed device IDF
    ERR_DI_INVALID_COMPATIBLE_DEVICE_LIST,  // Invalid compatible device list
    ERR_DI_REG_API,                         // Error returned by Reg API.
    ERR_DI_LOW_MEM,			    // Insufficient memory to complete
    ERR_DI_BAD_DEV_INFO,		    // Device Info struct invalid
    ERR_DI_INVALID_CLASS_INSTALLER,	    // Registry entry / DLL invalid
    ERR_DI_DO_DEFAULT,			    // Take default action
    ERR_DI_USER_CANCEL,			    // the user cancelled the operation
    ERR_DI_NOFILECOPY,			    // No need to copy files (in install)
    ERR_DI_BAD_CLASS_INFO,          // Class Info Struct invalid

};



typedef struct _DRIVER_NODE {
    struct _DRIVER_NODE FAR* lpNextDN;
    UINT	Rank;
    UINT	InfType;
    unsigned	InfDate;
    LPSTR	lpszDescription;
    LPSTR	lpszSectionName;
    ATOM	atInfFileName;
    ATOM	atMfgName;
    ATOM	atProviderName;
    DWORD	Flags;
    DWORD	dwPrivateData;
}   DRIVER_NODE, NEAR* PDRIVER_NODE, FAR* LPDRIVER_NODE, FAR* FAR* LPLPDRIVER_NODE;

#define DNF_DUPDESC    0x00000001	// Multiple providers have same desc

// possible types of "INF" files
#define INFTYPE_WIN4        1
#define INFTYPE_WIN3        2
#define INFTYPE_COMBIDRV    3
#define INFTYPE_PPD         4
#define INFTYPE_WPD	    5
#define INFTYPE_CLASS_SPEC1 6
#define INFTYPE_CLASS_SPEC2 7
#define INFTYPE_CLASS_SPEC3 8
#define INFTYPE_CLASS_SPEC4 9


#define MAX_CLASS_NAME_LEN   32


typedef struct _DEVICE_INFO
{
    UINT		cbSize;
    struct _DEVICE_INFO FAR* lpNextDi;
    char                szDescription[LINE_LEN];
    DWORD		dnDevnode;
    HKEY		hRegKey;
    char		szRegSubkey[100]; //~~~~
    char		szClassName[MAX_CLASS_NAME_LEN];
    DWORD		Flags;
    HWND		hwndParent;
    LPDRIVER_NODE	lpCompatDrvList;
    LPDRIVER_NODE	lpClassDrvList;
    LPDRIVER_NODE	lpSelectedDriver;
    UINT		cbDriverPathLen;
    LPSTR		lpszDriverPath;
} DEVICE_INFO, FAR * LPDEVICE_INFO, FAR * FAR * LPLPDEVICE_INFO;

#define ASSERT_DI_STRUC(lpdi) if (lpdi->cbSize != sizeof(DEVICE_INFO)) return (ERR_DI_BAD_DEV_INFO)

typedef struct _CLASS_INFO
{
    UINT		cbSize;
    struct _CLASS_INFO FAR* lpNextCi;
    LPDEVICE_INFO	lpdi;
    char                szDescription[LINE_LEN];
    char		szClassName[MAX_CLASS_NAME_LEN];
} CLASS_INFO, FAR * LPCLASS_INFO, FAR * FAR * LPLPCLASS_INFO;
#define ASSERT_CI_STRUC(lpci) if (lpci->cbSize != sizeof(CLASS_INFO)) return (ERR_DI_BAD_CLASS_INFO)


// flags for device choosing (InFlags)
#define DI_SHOWOEM	0x0001		// support Other... button
#define DI_SHOWCOMPAT	0x0002		// show compatibility list
#define DI_SHOWCLASS	0x0004		// show class list
#define DI_SHOWALL	0x0007
#define DI_NOVCP	0x0008	    // Don't do vcpOpen/vcpClose.
#define DI_DIDCOMPAT	0x0010		// Searched for compatible devices
#define DI_DIDCLASS	0x0020		// Searched for class devices
#define DI_AUTOASSIGNRES 0x0040 	// No UI for resources if possible

// flags returned by DiInstallDevice to indicate need to reboot/restart
#define DI_NEEDRESTART	0x0080		// Restart required to take effect
#define DI_NEEDREBOOT	0x0100		// Reboot required to take effect

// flags for device installation
#define DI_NOBROWSE	0x0200		// no Browse... in InsertDisk

// Flags set by DiBuildClassDrvList
#define DI_MULTMFGS	0x0400		// Set if multiple manufacturers in
					// class driver list
// Flag indicates that device is disabled
#define DI_DISABLED	0x0800		// Set if device disabled

// Flags for Device/Class Properties
#define DI_GENERALPAGE_ADDED    0x1000
#define DI_RESOURCEPAGE_ADDED   0x2000

// Defines for class installer functions
#define DIF_SELECTDEVICE		0x0001
#define DIF_INSTALLDEVICE		0x0002
#define DIF_ASSIGNRESOURCES		0x0003
#define DIF_PROPERTIES			0x0004
#define DIF_REMOVE			0x0005
#define DIF_FIRSTTIMESETUP		0x0006
#define DIF_FOUNDDEVICE 		0x0007

typedef UINT		DI_FUNCTION;	// Function type for device installer

RETERR WINAPI DiCreateDeviceInfo(
    LPLPDEVICE_INFO lplpdi,		// Ptr to ptr to dev info
    LPCSTR	    lpszDescription,	// If non-null then description string
    DWORD	    hDevnode,		// ISSUE-2002/01/16-roelfc -- MAKE A DEVNODE
    HKEY	    hkey,		// Registry hkey for dev info
    LPCSTR	    lpszRegsubkey,	// If non-null then reg subkey string
    LPCSTR	    lpszClassName,	// If non-null then class name string
    HWND	    hwndParent);	// If non-null then hwnd of parent

RETERR WINAPI DiGetClassDevs(
    LPLPDEVICE_INFO lplpdi,		// Ptr to ptr to dev info
    LPCSTR	    lpszClassName,	// Must be name of class
    HWND	    hwndParent, 	// If non-null then hwnd of parent
    int 	    iFlags);		// Options

#define DIGCF_DEFAULT			0x0001	// NOT IMPLEMENTED!
#define DIGCF_PRESENT			0x0002
#define DIGCF_ALLCLASSES		0x0004

RETERR WINAPI PASCAL DiCreateDevRegKey(
    LPDEVICE_INFO   lpdi,
    LPHKEY	    lphk,
    HINF	    hinf,
    LPCSTR	    lpszInfSection,
    int 	    iFlags);
    
RETERR WINAPI PASCAL DiDeleteDevRegKey(LPDEVICE_INFO lpdi, int  iFlags);


RETERR WINAPI PASCAL DiOpenDevRegKey(
    LPDEVICE_INFO   lpdi,
    LPHKEY	    lphk,
    int 	    iFlags);

#define DIREG_DEV	0x0001		// Open/Create device key
#define DIREG_DRV	0x0002		// Open/Create driver key


RETERR WINAPI DiDestroyClassInfoList(LPCLASS_INFO lpci);
RETERR WINAPI DiBuildClassInfoList(LPLPCLASS_INFO lplpci);
RETERR WINAPI DiGetDeviceClassInfo(LPLPCLASS_INFO lplpci, LPDEVICE_INFO lpdi);

RETERR WINAPI DiDestroyDeviceInfoList(LPDEVICE_INFO lpdi);
RETERR WINAPI DiSelectDevice( LPDEVICE_INFO lpdi );
RETERR WINAPI DiInstallDevice( LPDEVICE_INFO lpdi );
RETERR WINAPI DiRemoveDevice( LPDEVICE_INFO lpdi );
RETERR WINAPI DiAssignResources( LPDEVICE_INFO lpdi );
RETERR WINAPI DiAskForOEMDisk(LPDEVICE_INFO lpdi);

RETERR WINAPI DiCallClassInstaller(DI_FUNCTION diFctn, LPDEVICE_INFO lpdi);

RETERR WINAPI DiBuildCompatDrvList(LPDEVICE_INFO lpdi);
RETERR WINAPI DiBuildClassDrvList(LPDEVICE_INFO lpdi);

RETERR WINAPI DiDestroyDriverNodeList(LPDRIVER_NODE lpdn);

// The following export will load a dll and find the specified proc name
typedef RETERR (FAR PASCAL *DIINSTALLERPROPERTIES)(LPDEVICE_INFO);

RETERR WINAPI DiGetInstallerFcn(HKEY hk, LPSTR lpszRegVal, LPSTR lpszDefProcName,
                        HINSTANCE FAR * lphinst, FARPROC FAR * lplpfn);


RETERR
WINAPI
DiCreateDriverNode(
    LPLPDRIVER_NODE lplpdn,
    UINT	Rank,
    UINT	InfType,
    unsigned	InfDate,
    LPCSTR	lpszDescription,
    LPCSTR	lpszProviderName,
    LPCSTR	lpszMfgName,
    LPCSTR	lpszInfFileName,
    LPCSTR	lpszSectionName,
    DWORD	dwPrivateData);


RETERR WINAPI DiLoadClassIcon(
    LPCSTR  szClassName,
    HICON FAR *lphiLargeIcon,
    int FAR *lpiMiniIconIndex);


RETERR WINAPI DiInstallDrvSection(
    LPCSTR  lpszInfFileName,
    LPCSTR  lpszSection,
    LPCSTR  lpszClassName,
    LPCSTR  lpszDescription,
    DWORD   dwFlags);


RETERR WINAPI DiChangeState(LPDEVICE_INFO lpdi, DWORD dwStateChange);

#define DISC_ENABLE	0x00000001
#define DISC_DISABLE	0x00000002
#define DISC_PROPCHANGE 0x00000003

RETERR WINAPI DiInstallClass(LPCSTR lpszInfFileName, DWORD dwFlags);

RETERR WINAPI DiOpenClassRegKey(LPHKEY lphk, LPCSTR lpszClassName);

// support routine for dealing with class mini icons
int WINAPI PASCAL DiDrawMiniIcon(HDC hdc, RECT rcLine, int iMiniIcon, UINT flags);

// internal calls for display class
#define DISPLAY_SETMODE_SUCCESS		0x0001
#define DISPLAY_SETMODE_DRVCHANGE	0x0002
#define DISPLAY_SETMODE_FONTCHANGE	0x0004

UINT WINAPI Display_SetMode(LPDEVICE_INFO lpdi, UINT uColorRes, int iXRes, int iYRes);
RETERR WINAPI Display_ClassInstaller(DI_FUNCTION diFctn, LPDEVICE_INFO lpdi);
RETERR WINAPI Display_OpenFontSizeKey(LPHKEY lphkFontSize);
BOOL WINAPI Display_SetFontSize(LPCSTR lpszFontSize);

#endif // NODEVICEINSTALL



/***************************************************************************/
//
// setup reg DB calls, use just like those in kernel
//
/***************************************************************************/

DWORD WINAPI SURegOpenKey(HKEY hKey, LPSTR lpszSubKey, HKEY FAR *lphkResult);
DWORD WINAPI SURegCloseKey(HKEY hKey);
DWORD WINAPI SURegCreateKey(HKEY hKey, LPSTR lpszSubKey, HKEY FAR *lphkResult);
DWORD WINAPI SURegDeleteKey(HKEY hKey, LPSTR lpszSubKey);
DWORD WINAPI SURegEnumKey(HKEY hKey, DWORD dwIdx, LPSTR lpszBuffer, DWORD dwBufSize);
DWORD WINAPI SURegQueryValue16(HKEY hKey, LPSTR lpszSubKey, LPSTR lpValueBuf, DWORD FAR *ldwBufSize);
DWORD WINAPI SURegSetValue16(HKEY hKey, LPSTR lpszSubKey, DWORD dwType, LPBYTE lpszValue, DWORD dwValSize);
DWORD WINAPI SURegDeleteValue(HKEY hKey,LPSTR lpszValue);
DWORD WINAPI SURegEnumValue(HKEY hKey,DWORD dwIdx, LPSTR lpszValue, DWORD FAR *lpcbValue, DWORD FAR *lpdwReserved, DWORD FAR *lpdwType, LPBYTE lpbData, DWORD FAR *lpcbData);
DWORD WINAPI SURegQueryValueEx(HKEY hKey,LPSTR lpszValueName, DWORD FAR *lpdwReserved,DWORD FAR *lpdwType,LPSTR lpValueBuf, DWORD FAR *ldwBufSize);
DWORD WINAPI SURegSetValueEx(HKEY hKey,LPSTR lpszValueName, DWORD dwReserved, DWORD dwType, LPBYTE lpszValue, DWORD dwValSize);

DWORD WINAPI SURegFlush(VOID);
DWORD WINAPI SURegInit(VOID);    // should be called before any other Reg APIs


/***************************************************************************/
// setup FormatMessage support
/***************************************************************************/

UINT FAR CDECL suFormatMessage(HINSTANCE hAppInst, LPCSTR lpcFormat, LPSTR szMessage, UINT uSize,
	...);
UINT WINAPI suvFormatMessage(HINSTANCE hAppInst, LPCSTR lpcFormat, LPSTR szMessage, UINT uSize,
	LPVOID FAR * lpArgs);
int WINCAPI _loadds suFormatMessageBox(HINSTANCE hAppInst, HWND hwndParent, LPCSTR lpcText, LPCSTR lpcTitle,
	UINT uStyle, ...);

WORD WINAPI suErrorToIds( WORD Value, WORD Class );

/***************************************************************************/
// setup Version Conflict support
/***************************************************************************/

LPVOID WINAPI suVerConflictInit(void);
void WINAPI suVerConflictTerm(LPVOID lpvData);
LRESULT WINAPI suVerConflict(HWND hwnd, LPVCPVERCONFLICT lpvc, LPVOID lpvData);

//***************************************************************************
// Misc SETUPX.DLL support functions.
//***************************************************************************
enum  SU_ACTIONS                        // Actions msgs for Setupx()    /* ;Internal */
{                                                                       /* ;Internal */
    SUX_REGINIT,                        // Intialize registry           /* ;Internal */
    SUX_DBGLEVEL,                       // Set debug level              /* ;Internal */
    SUX_SETUPFLG,                       // Set fIsSetup flag            /* ;INternal */
    SUX_FASTSETUP,				// Puts setupx into a checking less mode.
    SUX_FORCEREGFLUSH,                  // Call kRegFlush               /* ;INternal */
    SUX_DBGHFILE,			// File to write messages to
};                                                                      /* ;Internal */

RETERR WINAPI Setupx( UINT uMsg, WPARAM wParam, LPARAM lParam );        /* ;Internal */

RETERR WINAPI SUGetSetSetupFlags(LPDWORD lpdwFlags, BOOL bSet);

//  Flags returned by SUGetSetSetupFlags

#define SUF_FIRSTTIME		0x00000001L
#define SUF_EXPRESS		0x00000002L




RETERR WINAPI CfgSetupMerge( int uFlags );

// structure for the LPARAM argument to Setupx() for SUX_REGINIT action.	;Internal
typedef struct _REGINIT_S { /* setupx - reg_init */					    /* ;Internal */
    LPSTR       lpszSystemFile;         // reg's base SYSTEM filename   /* ;Internal */
    LOGDISKID   ldidSystemFile;         // ldid for SYSTEM filename     /* ;Internal */
    LPSTR       lpszUserFile;			// reg's base USER filename     /* ;Internal */
    LOGDISKID   ldidUserFile;           // ldid for USER filename       /* ;Internal */
} REGINIT_S, FAR *LPREGINIT;                                            /* ;Internal */

#ifndef LPLPSTR
    typedef LPSTR (FAR *LPLPSTR);
#endif


#define         CFG_PARSE_BUFLEN 512    // Buf sized passed line obj funcs 	    /* ;Internal */

LPLPSTR WINAPI  CfgParseLine( LPCSTR szLine, LPSTR Buf );                       /* ;Internal */
BOOL    WINAPI  CfgSetAutoProcess( int TrueFalse );                             /* ;Internal */
void    WINAPI  CfgObjToStr( LPLPSTR apszObj, LPSTR szLine );                   /* ;Internal */
LPLPSTR WINAPI  CfgLnToObj( HTP hSection, int Offset, int Origin, LPSTR Buf );  /* ;Internal */
LPLPSTR WINAPI  CfgObjFindKeyCmd( HTP hSec, LPCSTR szKey, LPCSTR szCmd,         /* ;Internal */
                                  int Offset, int Origin, LPSTR Buf );          /* ;Internal */


//***************************************************************************
//
// ENUMS for accessing config.sys/autoexec.bat line objects using the
// array returned by ParseConfigLine()..
//
//***************************************************************************

enum    CFGLINE_STRINGS                     // Config.sys/autoexec.bat objects
{
    CFG_KEYLEAD,                            // Keyword leading whitespaces
    CFG_KEYWORD,                            // Keyword
    CFG_KEYTRAIL,                           // Keyword trailing delimiters
    CFG_UMBINFO,                            // Load high info
    CFG_DRVLETTER,                          // Drive letter for cmd path
    CFG_PATH,                               // Command path
    CFG_COMMAND,                            // Command base name
    CFG_EXT,                                // Command extension including '.'
    CFG_ARGS,                               // Command arguments
    CFG_FREE,                               // Free area at end of buffer
    CFG_END
};


//***************************************************************************

#endif      // SETUPX_INC
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\hnw\shared\util.cpp ===
//
// Util.cpp
//

#include "stdafx.h"
#include "Util.h"
#include "theapp.h"
#include <stdarg.h>
#include <shlobj.h>


LPTSTR lstrchr(LPCTSTR pszString, TCHAR ch)
{
	while (*pszString != _T('\0'))
	{
		if (*pszString == ch)
			return (LPTSTR)pszString;
		pszString = CharNext(pszString);
	}
	return NULL;
}

LPTSTR lstrdup(LPCTSTR psz)
{
	LPTSTR pszResult = (LPTSTR)malloc((lstrlen(psz)+1) * sizeof(TCHAR));
	if (pszResult != NULL)
		lstrcpy(pszResult, psz);
	return pszResult;
}

void ReplaceString(LPTSTR& pszTarget, LPCTSTR pszSource)
{
	free(pszTarget);
	pszTarget = lstrdup(pszSource);
}

BOOL MyIsDigit(TCHAR ch)
{
	return ((UINT)ch - (UINT)_T('0')) <= 9;
}

// A version of atoi that doesn't use the CRT
int MyAtoi(LPCTSTR psz)
{
	int result = 0;
	UINT digit;

	TCHAR chSign = *psz;
	if (*psz == _T('-') || *psz == _T('+'))
		psz += 1;

	while ((digit = (UINT)((int)*psz - (int)_T('0'))) <= 9)
	{
		result = (result * 10) + (int)digit;
		psz += 1;
	}

	if (chSign == _T('-'))
		result = -result;

	return result;
}

// CountChars
//
//		Returns the number of times the given character appears in the
//		string.
//
//		 2/03/1999  KenSh    Created
//
int CountChars(LPCTSTR psz, TCHAR ch)
{
	int count = 0;

	while (*psz != _T('\0'))
	{
		if (*psz == ch)
			count++;
		psz = CharNext(psz);
	}

	return count;
}


// GetFirstToken
//
//		Copies the characters up to but not including the separator char, and
//		advances the source pointer to the character after the separator char.
//		Returns TRUE if a token was found, FALSE if not.
//
BOOL GetFirstToken(LPCTSTR& pszList, TCHAR chSeparator, LPTSTR pszBuf, int cchBuf)
{
	if (pszList == NULL || *pszList == '\0')
	{
		*pszBuf = '\0';
		return FALSE;
	}

	LPTSTR pchComma = lstrchr(pszList, chSeparator);
	int cchCopy;
	int cchSkip;
	if (pchComma == NULL)
	{
		cchCopy = lstrlen(pszList);
		cchSkip = cchCopy;
	}
	else
	{
		cchCopy = (int)(pchComma - pszList);
		cchSkip = cchCopy + 1;
	}

	cchCopy += 1;
	if (cchCopy > cchBuf)
		cchCopy = cchBuf;
	lstrcpyn(pszBuf, pszList, cchCopy);

	pszList += cchSkip;
	return TRUE;
}


// Use this function for initializing multiple DLL procs
// pszFunction names is a series of null-separated proc names, followed by an extra null
BOOL LoadDllFunctions(LPCTSTR pszDll, LPCSTR pszFunctionNames, FARPROC* prgFunctions)
{
	UINT uPrevMode = SetErrorMode(SEM_NOOPENFILEERRORBOX | SEM_FAILCRITICALERRORS);
	HINSTANCE hInst = LoadLibrary(pszDll);
	SetErrorMode(uPrevMode);

	if (hInst == NULL)
	{
		ASSERT(FALSE);
		return FALSE;
	}

	while (*pszFunctionNames != '\0')
	{
		*prgFunctions = GetProcAddress(hInst, pszFunctionNames);
		if (*prgFunctions == NULL)
		{
			ASSERT(FALSE);
			return FALSE;
		}

		pszFunctionNames += (lstrlenA(pszFunctionNames) + 1);
		prgFunctions += 1;
	}

	return TRUE;
}

int MakePath(LPTSTR pszBuf, LPCTSTR pszFolder, LPCTSTR pszFileTitle)
{
	lstrcpy(pszBuf, pszFolder);
	int cch = lstrlen(pszBuf);
	if (pszBuf[cch-1] != _T('\\'))
		pszBuf[cch++] = _T('\\');
	lstrcpy(pszBuf + cch, pszFileTitle);
	return lstrlen(pszBuf);
}

// pszLinkTarget - where the link will point
// pszDescription - link's description
// pszFolderPath - path to folder to create file in or fully qualified file path to create
// pszFileName - name of file to create in pszFolderPath or NULL to indicate pszFolderPath is already a file path
//

#ifndef NO_MAKELNKFILE

HRESULT MakeLnkFile(CLSID clsid, LPCTSTR pszLinkTarget, LPCTSTR pszDescription, LPCTSTR pszFolderPath, LPCTSTR pszFileName)
{
    HRESULT hresCoInit = CoInitialize(NULL);            // we will create a COM object

    IUnknown *punk;
    HRESULT hr = CoCreateInstance(clsid, NULL, CLSCTX_INPROC_SERVER, IID_PPV_ARG(IUnknown, &punk));
    if (SUCCEEDED(hr))
    {
        IShellLinkW * pslW;
        hr = punk->QueryInterface(IID_PPV_ARG(IShellLinkW, &pslW));
        if (SUCCEEDED(hr))
        {
            //WCHAR szBuffer[MAX_PATH];
            //SHTCharToUnicode(pszLinkTarget, szBuffer, ARRAYSIZE(szBuffer));
            pslW->SetPath(pszLinkTarget);
            if (pszDescription)
            {
                //SHTCharToUnicode(pszDescription, szBuffer, ARRAYSIZE(szBuffer));
                pslW->SetDescription(pszDescription);
            }
            pslW->Release();
        }
        else
        {
            IShellLinkA * pslA;
            hr = punk->QueryInterface(IID_PPV_ARG(IShellLinkA, &pslA));
            if (SUCCEEDED(hr))
            {
                char szBuffer[MAX_PATH];
                SHTCharToAnsi(pszLinkTarget, szBuffer, ARRAYSIZE(szBuffer));
                pslA->SetPath(szBuffer);

                if (pszDescription)
                {
                    SHTCharToAnsi(pszDescription, szBuffer, ARRAYSIZE(szBuffer));
                    pslA->SetDescription(szBuffer);
                }

                pslA->Release();
            }
        }

        if (SUCCEEDED(hr))
        {
            IPersistFile *ppf;
            hr = punk->QueryInterface(IID_PPV_ARG(IPersistFile, &ppf));
            if (SUCCEEDED(hr))
            {
                TCHAR szPath[MAX_PATH];

                if (!pszFileName)
                {
                    MakePath(szPath, pszFolderPath, pszFileName);
                    pszFolderPath = szPath;
                }

                //WCHAR szFolderPath[MAX_PATH];
                //SHTCharToUnicode(pszFolderPath, szFolderPath, ARRAYSIZE(szFolderPath));
                hr = ppf->Save(pszFolderPath, TRUE);
                ppf->Release();
            }
        }

        punk->Release();
    }

    if (SUCCEEDED(hresCoInit))
        CoUninitialize();

    return hr;
}

#endif

// FindPartialPath
//
//		Returns a pointer to the file title preceded by nDepth levels of
//		directory names (zero == file title only).  If the path has less than
//		nDepth levels, a pointer to the beginning of the string is returned.
//		NULL is never returned.
//
//		10/18/1996  KenSh    Created
//
LPTSTR FindPartialPath(LPCTSTR pszFullPath, int nDepth)
{
	#define MAX_SLASHES (MAX_PATH / 2)	// No more slashes than this in the path

	LPTSTR pch;
	LPTSTR rgpchSlashes[MAX_SLASHES];
	int cSlashes = 0;

	for (pch = (LPTSTR)pszFullPath; *pch; pch = CharNext(pch))
	{
		if (*pch == _T('\\') || *pch == _T('/'))
		{
			rgpchSlashes[cSlashes++] = pch;
		}
	}

	if (cSlashes > nDepth)
	{
		return rgpchSlashes[cSlashes-nDepth-1] + 1;
	}
	else
	{
		// Not enough slashes - return the full path
		return (LPTSTR)pszFullPath;
	}
}

// FindFileTitle
//
//		Given a full pathname or URL, returns a pointer to the file title.  If 
//		the given does not contain path information, a pointer to the beginning
//		of the string is returned.  NULL is never returned.
//
//		 4/19/1996  KenSh    Created
//
LPTSTR FindFileTitle(LPCTSTR pszFullPath)
{
	LPTSTR pch;
	LPTSTR pchSlash = NULL;

	for (pch = (LPTSTR)pszFullPath; *pch; pch = CharNext(pch))
	{
		if (*pch == _T('\\') || *pch == _T('/'))
			pchSlash = pch;
	}

	if (pchSlash)
		return pchSlash+1;
	else
		return (LPTSTR)pszFullPath;
}

// FindExtension
//
//		Given a path, returns a pointer to its file extension (the character
//		following the ".").  If there is no extension, the return value is
//		a pointer to the end of the string ('\0' character).
//
//		 3/04/1996  KenSh    Created
//		11/17/1997  KenSh    Fixed case where path has "." but the filename doesn't
//
LPTSTR FindExtension(LPCTSTR pszFileName)
{
	// Start with the file title
	LPTSTR pch = FindFileTitle(pszFileName);
	LPTSTR pchDot = NULL;

	// Find the last "." in the filename
	while (*pch)
	{
		if (*pch == _T('.'))
			pchDot = pch;
		pch = CharNext(pch);
	}

	if (pchDot)
		return pchDot+1;
	else
		return pch;		// empty string
}


// IsFullPath
//
//		Returns nonzero if the given path is a fully qualified path starting
//		with "X:\" or "\\"
//
//		 5/19/1999  KenSh     Created
//
BOOL IsFullPath(LPCTSTR pszPath)
{
	if ((*pszPath == '\\' && *(pszPath+1) == '\\') ||
		(*pszPath != '\0' && *(pszPath+1) == ':' && *(pszPath+2) == '\\'))
	{
		return TRUE;
	}
	else
	{
		return FALSE;
	}
}


void ShowDlgItem(HWND hwndDlg, int nCtrlID, int nCmdShow)
{
	ShowWindow(GetDlgItem(hwndDlg, nCtrlID), nCmdShow);
}


// GetDlgItemRect
//
//		Retrieves the bounding rect of the dialog item relative to the top left
//		corner of the dialog's client area.
//
//		10/13/1997  KenSh    Created
//
HWND GetDlgItemRect(HWND hwndDlg, int nCtrlID, RECT* pRect)
{
	ASSERT(IsWindow(hwndDlg));
	ASSERT(pRect);

	HWND hwndCtrl = GetDlgItem(hwndDlg, nCtrlID);
	if (hwndCtrl != NULL)
	{
		POINT ptTopLeft;
		ptTopLeft.x = ptTopLeft.y = 0;
		ClientToScreen(hwndDlg, &ptTopLeft);
		GetWindowRect(hwndCtrl, pRect);
		OffsetRect(pRect, -ptTopLeft.x, -ptTopLeft.y);
	}
	return hwndCtrl;
}


// GetRelativeRect
//
//		Retrieves the bounding rect of the window relative to the top left
//		corner of its parent client area.
//
//		 1/04/2000  KenSh    Created
//
void GetRelativeRect(HWND hwndCtrl, RECT* pRect)
{
	ASSERT(IsWindow(hwndCtrl));
	ASSERT(pRect != NULL);

	HWND hwndParent = GetParent(hwndCtrl);
	POINT ptTopLeft = { 0, 0 };
	ClientToScreen(hwndParent, &ptTopLeft);
	GetWindowRect(hwndCtrl, pRect);
	OffsetRect(pRect, -ptTopLeft.x, -ptTopLeft.y);
}


// SetDlgItemRect
//
//		Updates the position and size of a dialog item to the given rectangle,
//		in coordinates relative to the top left corner of the dialog's client area.
//
//		 3/17/1999  KenSh    Created
//
void SetDlgItemRect(HWND hwndDlg, int nCtrlID, CONST RECT* pRect)
{
	ASSERT(IsWindow(hwndDlg));
	ASSERT(GetDlgItem(hwndDlg, nCtrlID));
	ASSERT(pRect);

	SetWindowPos(GetDlgItem(hwndDlg, nCtrlID), NULL, pRect->left, pRect->top, 
				 pRect->right - pRect->left, pRect->bottom - pRect->top,
				 SWP_NOZORDER | SWP_NOACTIVATE);
}


// FormatDlgItemText
//
//		Works like wsprintf to change the text of an existing dialog control.
//		If pszFormat is non-NULL, it contains the formatting string.
//		If pszFormat is NULL, then the existing control text is used as the
//		format string.
//
//		 9/22/1999  KenSh    Created
//
BOOL __cdecl FormatDlgItemText(HWND hwnd, int nCtrlID, LPCTSTR pszFormat, ...)
{
	HWND hwndCtrl = GetDlgItem(hwnd, nCtrlID);
	if (NULL == hwndCtrl)
		return FALSE;

	va_list argList;
	va_start(argList, pszFormat);

	FormatWindowTextV(hwndCtrl, pszFormat, argList);
	return TRUE;
}

// FormatWindowTextV
//
//		Combines the functionality of wvsprintf with SetWindowText, automatically
//		allocating a buffer large enough to hold the expanded string, and freeing
//		the buffer after setting the window text.
//
//		 9/22/1999  KenSh    Created
//
void FormatWindowTextV(HWND hwnd, LPCTSTR pszFormat, va_list argList)
{
    LPTSTR pszWindowText = NULL;

    if (pszFormat == NULL)
    {
        int cchWindowText = GetWindowTextLength(hwnd) + 1;
        pszWindowText = (LPTSTR)malloc(cchWindowText * sizeof(TCHAR));
        if (pszWindowText)
        {
            GetWindowText(hwnd, pszWindowText, cchWindowText);
            pszFormat = pszWindowText;
        }
    }

    if (pszFormat)
    {
        int cchNeeded = EstimateFormatLength(pszFormat, argList);
        LPTSTR pszBuf = (LPTSTR)malloc(cchNeeded * sizeof(TCHAR));
        if (pszBuf)
        {
#ifdef UNICODE
            wvnsprintf(pszBuf, cchNeeded, pszFormat, argList);
#else
            wvsprintf(pszBuf, pszFormat, argList);
#endif
            SetWindowText(hwnd, pszBuf);
            free(pszBuf);
        }
    }

    if (pszWindowText != NULL)
    {
        free(pszWindowText);
    }
}

LPTSTR __cdecl LoadStringFormat(HINSTANCE hInstance, UINT nStringID, ...)
{
    LPTSTR pszBuf = NULL;
    LPTSTR pszFormat = LoadStringAlloc(hInstance, nStringID);
    if (pszFormat)
    {
        va_list argList;
        va_start(argList, nStringID);

        int cchNeeded = EstimateFormatLength(pszFormat, argList);
        LPTSTR pszBuf = (LPTSTR)malloc(cchNeeded * sizeof(TCHAR));
        if (pszBuf)
        {
#ifdef UNICODE
            wvnsprintf(pszBuf, cchNeeded, pszFormat, argList);
#else
            wvsprintf(pszBuf, pszFormat, argList);
#endif
        }

        free(pszFormat);
    }
    return pszBuf;
}

// EstimateFormatLength
//
//		Estimates the number of characters needed to format the string,
//		including the terminating NULL.
//
//		 9/22/1999  KenSh    Created
//
int EstimateFormatLength(LPCTSTR pszFormat, va_list argList)
{
	ASSERT(pszFormat != NULL);

	int cch = lstrlen(pszFormat) + 1;
	for (LPCTSTR pch = pszFormat; *pch; pch = CharNext(pch))
	{
		if (*pch == _T('%'))
		{
			pch++;
			if (*pch == _T('-')) // we don't care about left vs. right justification
				pch++;

			if (*pch == _T('#')) // prefix hex numbers with 0x
			{
				pch++;
				cch += 2;
			}

			if (*pch == _T('0')) // pads with zeroes instead of spaces
				pch++;

			if (MyIsDigit(*pch))
			{
				cch += MyAtoi(pch); // this overshoots but that's ok
				do
				{
					pch++;
				} while (MyIsDigit(*pch));
			}

			switch (*pch)
			{
			case _T('s'):
				cch += lstrlen(va_arg(argList, LPCTSTR)) - 2;
				break;

			case _T('c'):
			case _T('C'):
				va_arg(argList, TCHAR);
				cch -= 1;
				break;

			case _T('d'):
				va_arg(argList, int);
				cch += INT_CCH_MAX - 2;
				break;

			case _T('h'):
				pch++;
				ASSERT(*pch == _T('d') || *pch == _T('u')); // other forms of 'h' not implemented!
				cch += SHORT_CCH_MAX - 2;
				break;

			case _T('l'):
				pch++;
				if (*pch == _T('d') || *pch == _T('i'))
					cch += LONG_CCH_MAX - 2;
				else if (*pch == _T('x') || *pch == _T('X'))
					cch += LONGX_CCH_MAX - 2;
				else
					ASSERT(FALSE); // other forms of 'l' not implemented!
				break;

			default:
				ASSERT(FALSE); // other 
				break;
			}
		}
	}

	return cch;
}

// CenterWindow
//
//		Centers the given window relative to its parent window.  If the parent
//		is NULL, the window is centered over the desktop excluding the taskbar.
//
//		 9/24/1999  KenSh    Created
//
void CenterWindow(HWND hwnd)
{
	RECT rcWindow;
	RECT rcDesktop;
	GetWindowRect(hwnd, &rcWindow);

	HWND hwndParent = GetParent(hwnd);
	if (hwndParent == NULL)
	{
		SystemParametersInfo(SPI_GETWORKAREA, sizeof(RECT), &rcDesktop, FALSE);
	}
	else
	{
		GetWindowRect(hwndParent, &rcDesktop);
	}

	int cxWindow = rcWindow.right - rcWindow.left;
	int cyWindow = rcWindow.bottom - rcWindow.top;
	int x = (rcDesktop.left + rcDesktop.right - cxWindow) / 2;
	int y = (rcDesktop.top + rcDesktop.bottom - cyWindow) / 2;
	SetWindowPos(hwnd, NULL, x, y, 0, 0, SWP_NOSIZE | SWP_NOZORDER | SWP_NOACTIVATE);
}


// FindResourceString
//
//		Returns a pointer to the given string resource in memory, or NULL
//		if the string does not exist.  Note that the string is in Unicode,
//		and is not NULL-terminated.
//
//		 3/17/1999  KenSh     Created
//
LPCWSTR FindResourceString(HINSTANCE hInstance, UINT nStringID, int* pcchString, WORD wLangID)
{
	ASSERT(pcchString != NULL);
	*pcchString = 0;

	HRSRC hRsrc = FindResourceEx(hInstance, RT_STRING, MAKEINTRESOURCE((nStringID/16)+1), wLangID);
	if (hRsrc == NULL)
		return NULL;

	DWORD cbStringTable = SizeofResource(hInstance, hRsrc);
	HGLOBAL hGlb = LoadResource(hInstance, hRsrc);
	LPBYTE pbData = (LPBYTE)LockResource(hGlb);
	LPBYTE pbEnd = pbData + cbStringTable;

	// Skip strings preceding desired one
	int iString = (int)nStringID % 16;
	for (int i = 0; i < iString; i++)
	{
		int cch = (int)*((LPWORD)pbData);
		pbData += sizeof(WORD) + (sizeof(WCHAR) * cch);
		if (pbData >= pbEnd)
			return NULL;
	}

	if (pbData + sizeof(WORD) >= pbEnd)
		return NULL;

	*pcchString = (int)*((LPWORD)pbData);
	pbData += sizeof(WORD);

	return (LPCWSTR)pbData;
}


// GetResourceStringLength
//
//		Finds the given string in the string table, and returns its length
//		in characters, not including room for the terminating NULL.
//
// History:
//
//		 3/17/1999  KenSh     Created
//
int GetResourceStringLength(HINSTANCE hInstance, UINT nStringID, WORD wLangID)
{
	int cch;
	FindResourceString(hInstance, nStringID, &cch, wLangID);
	return cch;
}


// LoadStringHelper
//
//      Helper function for LoadStringAllocEx.
//
//       2/23/1998  KenSh    Created
//       9/27/1999  KenSh    changed alloc method from new[] to malloc
//      12/21/1999  KenSh    fixed unicode and DBCS bugs
//
int LoadStringHelper(HINSTANCE hInstance, UINT nID, LPTSTR* ppszBuf, int cchBuf, WORD wLangID)
{
    int cch, cchCopy;
    LPCWSTR pwszString = FindResourceString(hInstance, nID, &cch, wLangID);
    if (pwszString == NULL)
        return 0;

    if (!(*ppszBuf))
    {
#ifdef UNICODE
        cchBuf = 1 + cch;
#else
        cchBuf = 1 + WideCharToMultiByte(CP_ACP, 0, pwszString, cch, NULL, 0, NULL, NULL);
#endif

        *ppszBuf = (LPTSTR)malloc(cchBuf * sizeof(TCHAR));
        cchCopy = cch;
    }
    else
    {
        cchCopy = min(cchBuf-1, cch);
    }

    if (*ppszBuf)
    {
#ifdef UNICODE
        CopyMemory(*ppszBuf, pwszString, cchCopy * sizeof(WCHAR));
        (*ppszBuf)[cchCopy] = _T('\0');
#else
        cchCopy = WideCharToMultiByte(CP_ACP, 0, pwszString, cchCopy, *ppszBuf, cchBuf, NULL, NULL);
        (*ppszBuf)[cchCopy] = _T('\0');
#endif

        return cchCopy;
    }

    return 0;
}

// LoadStringAllocEx
//
//		Finds the string resource with the given ID and language, allocates a
//		buffer using malloc, and copies the string to the buffer.  If the
//		string is not found, NULL is returned.
//
//		 2/24/1998  KenSh    Created
//
LPTSTR LoadStringAllocEx(HINSTANCE hInstance, UINT nID, WORD wLangID)
{
	LPTSTR psz = NULL;
	LoadStringHelper(hInstance, nID, &psz, 0, wLangID);
	return psz;
}

void TrimLeft(LPTSTR pszText)
{
	LPTSTR pch2 = pszText; // will point to first non-space
	while (*pch2 == _T(' '))
		pch2++;

	// If there's leading space, slide the string down
	if (pch2 != pszText)
	{
		// Note: it's safe to skip CharNext here, since '\0' is immune to DBCS
		while (_T('\0') != (*pszText++ = *pch2++))
			NULL;
	}
}

void TrimRight(LPTSTR pszText)
{
	LPTSTR pch2 = NULL; // will point to beginning of trailing space
	while (*pszText != _T('\0'))
	{
		if (*pszText == _T(' '))
		{
			if (pch2 == NULL)
				pch2 = pszText;
		}
		else
		{
			// found more non-space, reset the trailing-space pointer
			pch2 = NULL;
		}
		pszText = CharNext(pszText);
	}

	// Truncate the trailing spaces, if any
	if (pch2 != NULL)
		*pch2 = _T('\0');
}

// RegDeleteKeyAndSubKeys
//
//		Does what RegDeleteKey should do.  (Actually a single call to RegDeleteKey
//		will do this in Win95, but not in NT, according to the docs.  Should see
//		if this gets fixed in NT5.)
//
//		 2/24/1998  KenSh    Created
//
DWORD RegDeleteKeyAndSubKeys(HKEY hkey, LPCTSTR pszSubKey)
{
#if 0 // This might be faster in Win95 than doing it manually, but bigger.
	OSVERSIONINFO osvi;
	osvi.dwOSVersionInfoSize = sizeof(osvi);
	GetVersionEx(&osvi);
	if (osvi.dwPlatformId == VER_PLATFORM_WIN32_NT)
#endif
	{
		HKEY hSubKey;
		LONG err = RegOpenKeyEx(hkey, pszSubKey, 0, KEY_ALL_ACCESS, &hSubKey);
		if (ERROR_SUCCESS == err)
		{
			DWORD dwNumSubKeys;
			RegQueryInfoKey(hSubKey, NULL, NULL, NULL, &dwNumSubKeys, NULL, NULL, NULL, NULL, NULL, NULL, NULL);
			for (DWORD iSubKey = dwNumSubKeys; iSubKey > 0; iSubKey--)
			{
				TCHAR szSubKey[260];
				DWORD cchSubKey = _countof(szSubKey);
				if (ERROR_SUCCESS == RegEnumKeyEx(hSubKey, iSubKey-1, szSubKey, &cchSubKey, NULL, NULL, NULL, NULL))
				{
					RegDeleteKeyAndSubKeys(hSubKey, szSubKey);
				}
			}
			RegCloseKey(hSubKey);
		}
	}

	return RegDeleteKey(hkey, pszSubKey);
}

// LoadFile
//
//		Loads the file and null-terminates the copy in memory.  The memory 
//		is allocated via malloc().
//
//		 4/05/1996  KenSh     Created
//		 8/27/1996  KenSh     Improved error checking
//		 4/21/1997  KenSh     Tightened up a bit
//		 2/01/1998  KenSh     Append a null-terminating byte
//		 9/29/1999  KenSh     use malloc instead of new []
//
LPBYTE LoadFile(LPCTSTR pszFileName, DWORD* pdwFileSize /*=NULL*/)
{
	HANDLE hFile;
	LPBYTE pData = NULL;
	DWORD dwFileSize = 0;

	hFile = CreateFile( pszFileName, GENERIC_READ, FILE_SHARE_READ, NULL,
						OPEN_EXISTING, FILE_FLAG_SEQUENTIAL_SCAN, NULL );
	if (hFile == INVALID_HANDLE_VALUE)
		goto done;

	dwFileSize = GetFileSize(hFile, NULL);
	ASSERT(dwFileSize != 0xFFFFFFFF);	// this shouldn't ever happen for valid hFile

	pData = (LPBYTE)malloc(dwFileSize + 1);
	if (!pData)
		goto done;

	DWORD cbRead;
	if (!ReadFile(hFile, pData, dwFileSize, &cbRead, NULL))
	{
		free(pData);
		pData = NULL;
		goto done;
	}

	pData[dwFileSize] = 0;

done:
	if (pdwFileSize)
		*pdwFileSize = dwFileSize;

	if (hFile != INVALID_HANDLE_VALUE)
		CloseHandle(hFile);

	return pData;
}

// DrawHollowRect
//
//		Draws a hollow rectangle in the current background color.
//
//		 2/06/1998  KenSh    Created
//
void DrawHollowRect(HDC hdc, const RECT* pRect, int cxLeft, int cyTop, int cxRight, int cyBottom)
{
	RECT rcCopy;
	RECT rcNewCoords;
	int i;

	CopyRect(&rcCopy, pRect);
	SetRect(&rcNewCoords,
			pRect->right - cxRight, 
			pRect->bottom - cyBottom, 
			pRect->left + cxLeft,
			pRect->top + cyTop);

	// Do each side in turn : right, bottom, left, top
	for (i = 0; i < 4; i++)
	{
		LONG coordSave = ((LONG*)&rcCopy)[i];
		((LONG*)&rcCopy)[i] = ((LONG*)&rcNewCoords)[i];
		DrawFastRect(hdc, &rcCopy);
		((LONG*)&rcCopy)[i] = coordSave;
	}
}

void DrawFastRect(HDC hdc, const RECT* pRect)
{
	COLORREF crTextSave = SetTextColor(hdc, GetBkColor(hdc));
	ExtTextOut(hdc, 0, 0, ETO_OPAQUE | ETO_CLIPPED, pRect, TEXT(" "), 1, NULL);
	SetTextColor(hdc, crTextSave);
}

int GetFontHeight(HFONT hFont)
{
	HDC hdcT = GetDC(NULL);
	HFONT hFontSave = (HFONT)SelectObject(hdcT, hFont);
	TEXTMETRIC tm;
	GetTextMetrics(hdcT, &tm);
	SelectObject(hdcT, hFontSave);
	ReleaseDC(NULL, hdcT);
	return tm.tmHeight;
}

HRESULT MyGetSpecialFolderPath(int nFolder, LPTSTR pszPath)
{
	LPITEMIDLIST pidl;
	HRESULT hr;
	if (SUCCEEDED(hr = SHGetSpecialFolderLocation(NULL, nFolder, &pidl)))
	{
        hr = SHGetPathFromIDList(pidl, pszPath) ? S_OK : E_FAIL;

		LPMALLOC pMalloc;
		if (SUCCEEDED(SHGetMalloc(&pMalloc)))
		{
			pMalloc->Free(pidl);
			pMalloc->Release();
		}
	}

	return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\hnw\win95\setupx2.h ===
//**********************************************************************
//
// SETUPX.H
//
//  Copyright (c) 1993 - Microsoft Corp.
//  All rights reserved.
//  Microsoft Confidential
//
// Public include file for Chicago Setup services.
//
// 12/1/93      DONALDM     Added LPCLASS_INFO, and function protos for
//                          exports in SETUP4.DLL
// 12/4/943     DONALDM     Moved SHELL.H include and Chicago specific
//                          helper functions to SETUP4.H
// 1/11/94      DONALDM     Added members to DEVICE_INFO to better handle
//                          ClassInstaller load/unload.
// 1/11/94      DONALDM     Added some new DIF_ messages for Net guys.
// 2/25/94      DONALDM     Fixed a bug with the DIREG_ flags
//**********************************************************************

#ifndef SETUPX_INC
#define SETUPX_INC   1                   // SETUPX.H signature

typedef UINT RETERR;             // Return Error code type.

#define OK 0                     // success error code

#define IP_ERROR       (100)    // Inf parsing
#define TP_ERROR       (200)    // Text processing module
#define VCP_ERROR      (300)    // Virtual copy module
#define GEN_ERROR      (400)    // Generic Installer
#define DI_ERROR       (500)    // Device Installer

// err2ids mappings
enum ERR_MAPPINGS {
    E2I_VCPM,           // Maps VCPM to strings
    E2I_SETUPX,         // Maps setupx returns to strings
    E2I_SETUPX_MODULE,  // Maps setupx returns to appropriate module
    E2I_DOS_SOLUTION,   // Maps DOS Extended errors to solutions
    E2I_DOS_REASON,     // Maps DOS extended errors to strings.
    E2I_DOS_MEDIA,      // Maps DOS extended errors to media icon.
};

#ifndef NOVCP

/***************************************************************************/
//
// Logical Disk ID definitions
//
/***************************************************************************/

// DECLARE_HANDLE(VHSTR);           /* VHSTR = VirtCopy Handle to STRing */
typedef UINT VHSTR;         /* VirtCopy Handle to String */

VHSTR   WINAPI vsmStringAdd(LPCSTR lpszName);
int WINAPI vsmStringDelete(VHSTR vhstr);
VHSTR   WINAPI vsmStringFind(LPCSTR lpszName);
int WINAPI vsmGetStringName(VHSTR vhstr, LPSTR lpszBuffer, int cbBuffer);
int WINAPI vsmStringCompare(VHSTR vhstrA, VHSTR vhstrB);
LPCSTR  WINAPI vsmGetStringRawName(VHSTR vhstr);
void    WINAPI vsmStringCompact(void);

typedef UINT LOGDISKID;          /* ldid */

// Logical Disk Descriptor: Structure which describes the physical attributes
// of a logical disk. Every logical disk is assigned a logical disk
// identifier (LDID), and is described by a logical disk descriptor (LDD).
//
// The cbSize structure member must always be set to sizeof(LOGDISKDESC_S),
// but all other unused structure members should be NULL or 0. No validation
// is performed on the size of string arrays; all string pointers, if
// non-NULL and they are to receive a string, must point at string arrays
// whose sizes are as follows:
//      sizeof( szPath )    = MAX_PATH_LEN
//      sizeof( szVolLabel) = MAX_FILENAME_LEN
//      sizeof( szName )    = MAX_STRING_LEN
#define MAX_PATH_LEN        260     // Max. path length.
#define MAX_FILENAME_LEN    20      // Max. filename length. ( > sizeof( "x:\\12345678.123" )


typedef struct _LOGDISKDESC_S { /* ldd */
    WORD        cbSize;                 // Size of this structure (bytes)
    LOGDISKID   ldid;                   // Logical Disk ID.
    LPSTR       pszPath;                // Ptr. to associated Path string.
    LPSTR       pszVolLabel;            // Ptr. to Volume Label string.
    LPSTR       pszDiskName;            // Ptr. to Disk Name string.
    WORD        wVolTime;               // Volume label modification time.
    WORD        wVolDate;               // Volume label modification date.
    DWORD       dwSerNum;               // Disk serial number.
    WORD        wFlags;                 // Flags.
} LOGDISKDESC_S, FAR *LPLOGDISKDESC;


// Range for pre-defined LDIDs.
#define LDID_PREDEF_START   0x0001  // Start of range
#define LDID_PREDEF_END     0x7FFF  // End of range

// Range for dynamically assigned LDIDs.
#define LDID_ASSIGN_START   0x8000  // Start of range
#define LDID_ASSIGN_END     0xBFFF  // End of range

// Pre-defined Logical Disk Identifiers (LDID).
//
#define LDID_NULL       0               // Null (undefined) LDID.
#define LDID_ABSOLUTE   ((UINT)-1)      // Absolute path

// source path of windows install, this is typically A:\ or a net drive
#define LDID_SRCPATH    1   // source of instilation
// temporary setup directory used by setup, this is only valid durring
// regular install
#define LDID_SETUPTEMP  2   // temporary setup dir for install
// path to uninstall location, this is where we backup files that will
// be overwritten
#define LDID_UNINSTALL  3   // uninstall (backup) dir.
// backup path for the copy engine, this should not be used
#define LDID_BACKUP     4   // ISSUE-2002/01/16-roelfc: backup dir for the copy engine, not used

// windows directory, this is the destinatio of the insallation
#define LDID_WIN        10  // destination Windows dir (just user files).
#define LDID_SYS        11  // destination Windows System dir.
#define LDID_IOS        12  // destination Windows Iosubsys dir.
#define LDID_CMD        13  // destination Windows Command (DOS) dir.
#define LDID_CPL        14  // destination Windows Control Panel dir.
#define LDID_PRINT      15  // destination Windows Printer dir.
#define LDID_MAIL       16  // destination Mail dir.
#define LDID_INF        17  // destination Windows *.INF dir.
#define LDID_HELP       18  // destination Windows Help dir.
#define LDID_WINADMIN   19  // admin stuff.

// Shared dirs for net install.
#define LDID_SHARED     25  // Bulk of windows files.
#define LDID_WINBOOT    26  // guarenteed boot device for windows.
#define LDID_MACHINE    27  // machine specific files.

// boot and old win and dos dirs.
#define LDID_BOOT       30  // Root dir of boot drive
#define LDID_BOOT_HOST  31  // Root dir of boot drive host
#define LDID_DOSBOOT    32  // Subdir off of Root (optional)
#define LDID_OLD_WIN    33  // old windows directory (if it exists)
#define LDID_OLD_DOS    34  // old dos directory (if it exists)

// Convert Ascii drive letter to Integer drive number ('A'=1, 'B'=2, ...).
#define DriveAtoI( chDrv )      ((int)(chDrv & 31))

// Convert Integer drive number to Ascii drive letter (1='A', 2='B', ...).
#define DriveItoA( iDrv )       ((char) (iDrv - 1 + 'A'))


// ISSUE-2002/01/16-roelfc: change the names of these

RETERR WINAPI CtlSetLdd     ( LPLOGDISKDESC );
RETERR WINAPI CtlGetLdd     ( LPLOGDISKDESC );
RETERR WINAPI CtlFindLdd    ( LPLOGDISKDESC );
RETERR WINAPI CtlAddLdd     ( LPLOGDISKDESC );
RETERR WINAPI CtlDelLdd     ( LOGDISKID  );
RETERR WINAPI CtlGetLddPath ( LOGDISKID, LPSTR );


/***************************************************************************/
//
// Virtual File Copy definitions
//
/***************************************************************************/


typedef DWORD LPEXPANDVTBL;         /* ISSUE-2002/01/16-roelfc -- clean this up */

enum _ERR_VCP
{
    ERR_VCP_IOFAIL = (VCP_ERROR + 1),       // File I/O failure
    ERR_VCP_STRINGTOOLONG,                  // String length limit exceeded
    ERR_VCP_NOMEM,                          // Insufficient memory to comply
    ERR_VCP_NOVHSTR,                        // No string handles available
    ERR_VCP_OVERFLOW,                       // Reference count would overflow
    ERR_VCP_BADARG,                         // Invalid argument to function
    ERR_VCP_UNINIT,                         // String library not initialized
    ERR_VCP_NOTFOUND ,                      // String not found in string table
    ERR_VCP_BUSY,                           // Can't do that now
    ERR_VCP_INTERRUPTED,                    // User interrupted operation
    ERR_VCP_BADDEST,                        // Invalid destination directory
    ERR_VCP_SKIPPED,                        // User skipped operation
    ERR_VCP_IO,                             // Hardware error encountered
    ERR_VCP_LOCKED,                         // List is locked
    ERR_VCP_WRONGDISK,                      // The wrong disk is in the drive
    ERR_VCP_CHANGEMODE,                     //
    ERR_VCP_LDDINVALID,                // Logical Disk ID Invalid.
    ERR_VCP_LDDFIND,                   // Logical Disk ID not found.
    ERR_VCP_LDDUNINIT,                 // Logical Disk Descriptor Uninitialized.
    ERR_VCP_LDDPATH_INVALID,
    ERR_VCP_NOEXPANSION,                // Failed to load expansion dll
    ERR_VCP_NOTOPEN,                    // Copy session not open
};


/*****************************************************************************
 *              Structures
 *****************************************************************************/

/*---------------------------------------------------------------------------*
 *                  VCPPROGRESS
 *---------------------------------------------------------------------------*/

typedef struct tagVCPPROGRESS { /* prg */
    DWORD   dwSoFar;            /* Number of units copied so far */
    DWORD   dwTotal;            /* Number of units to copy */
} VCPPROGRESS, FAR *LPVCPPROGRESS;

/*---------------------------------------------------------------------------*
 *                  VCPDISKINFO
 *---------------------------------------------------------------------------*/

/*  ISSUE-2002/01/16-roelfc:                                       ;Internal
 *  I currently don't use wVolumeTime, wVolumeDate or              ;Internal
 *  dwSerialNumber.  We may not want to use dwSerialNumber because ;Internal
 *  it means that any disk other than the factory originals will be;Internal
 *  suspected of being tampered with, since the serial number      ;Internal
 *  won't match.  Similar with the time/date stamp on the          ;Internal
 *  volume label.  Or maybe that's what we want to do.             ;Internal
 */                                                             /* ;Internal */
                                                                /* ;Internal */

typedef struct tagVCPDISKINFO {
    WORD        cbSize;         /* Size of this structure in bytes */
    LOGDISKID   ldid;           /* Logical disk ID */
    VHSTR       vhstrRoot;      /* Location of root directory */
    VHSTR       vhstrVolumeLabel;/* Volume label */
    VHSTR       vhstrDiskName;  // Printed name on the disk.
    WORD        wVolumeTime;    /* Volume label modification time */
    WORD        wVolumeDate;    /* Volume label modification date */
    DWORD       dwSerialNumber; /* Disk serial number */
    WORD        fl;             /* Flags */
    LPARAM      lparamRef;      /* Reference data for client */

    VCPPROGRESS prgFileRead;    /* Progress info */
    VCPPROGRESS prgByteRead;

    VCPPROGRESS prgFileWrite;
    VCPPROGRESS prgByteWrite;

} VCPDISKINFO, FAR *LPVCPDISKINFO;

#define VDIFL_VALID     0x0001  /* Fields are valid from a prev. call */
#define VDIFL_EXISTS    0x0002  /* Disk exists; do not format */

RETERR WINAPI DiskInfoFromLdid(LOGDISKID ldid, LPVCPDISKINFO lpdi);


/*---------------------------------------------------------------------------*
 *                  VCPFILESPEC
 *---------------------------------------------------------------------------*/

typedef struct tagVCPFILESPEC { /* vfs */
    LOGDISKID   ldid;           /* Logical disk */
    VHSTR       vhstrDir;       /* Directory withing logical disk */
    VHSTR       vhstrFileName;  /* Filename within directory */
} VCPFILESPEC, FAR *LPVCPFILESPEC;

/*---------------------------------------------------------------------------*
 *              VCPFATTR
 *---------------------------------------------------------------------------*/

/*
 * ISSUE-2002/01/16-roelfc -- explain diffce between llenIn and llenOut wrt compression.
 */
typedef struct tagVCPFATTR {
    UINT    uiMDate;            /* Modification date */
    UINT    uiMTime;            /* Modification time */
    UINT    uiADate;            /* Access date */
    UINT    uiATime;            /* Access time */
    UINT    uiAttr;             /* File attribute bits */
    DWORD   llenIn;             /* Original file length */
    DWORD   llenOut;            /* Final file length */
                                /* (after decompression) */
} VCPFATTR, FAR *LPVCPFATTR;

/*---------------------------------------------------------------------------*
 *                  VIRTNODEEX
 *---------------------------------------------------------------------------*/
typedef struct tagVIRTNODEEX
{    /* vnex */
    HFILE           hFileSrc;
    HFILE           hFileDst;
    VCPFATTR        fAttr;
    WORD            dosError;   // The first/last error encountered
    VHSTR           vhstrFileName;  // The original destination name.
    WPARAM          vcpm;   // The message that was being processed.
} VIRTNODEEX, FAR *LPCVIRTNODEEX, FAR *LPVIRTNODEEX ;


/*---------------------------------------------------------------------------*
 *                  VIRTNODE
 *---------------------------------------------------------------------------*/

/* WARNING!                                                        ;Internal
 *  All fields through but not including                           ;Internal
 *  fl are memcmp'd to determine if we have a duplicate copy       ;Internal
 *  request.                                                       ;Internal
 *                                                                 ;Internal
 *  Do not insert fields before fl unless you want them to be      ;Internal
 *  compared; conversely, if you add a new field that needs to     ;Internal
 *  be compared, make sure it goes before fl.                      ;Internal
 *                                                                 ;Internal
 *  And don't change any of the fields once Windows 4.0 ships.     ;Internal
 */                                                             /* ;Internal */
                                                                /* ;Internal */
typedef struct tagVIRTNODE {    /* vn */
    WORD            cbSize;
    VCPFILESPEC     vfsSrc;
    VCPFILESPEC     vfsDst;
    WORD            fl;
    LPARAM          lParam;
    LPEXPANDVTBL    lpExpandVtbl;
    LPVIRTNODEEX    lpvnex;
} VIRTNODE, FAR *LPCVIRTNODE, FAR *LPVIRTNODE ;


/*---------------------------------------------------------------------------*
 *              VCPDESTINFO
 *---------------------------------------------------------------------------*/

typedef struct tagVCPDESTINFO { /* destinfo */
    WORD    flDevAttr;          /* Device attributes */
    LONG    cbCapacity;         /* Disk capacity */
    WORD    cbCluster;          /* Bytes per cluster */
    WORD    cRootDir;           /* Size of root directory */
} VCPDESTINFO, FAR *LPVCPDESTINFO;

#define DIFL_FIXED      0x0001  /* Nonremoveable media */
#define DIFL_CHANGELINE 0x0002  /* Change line support */

// Now also used by the virtnode as we dont have copy nodes any more.
// #define CNFL_BACKUP             0x0001  /* This is a backup node */
#define CNFL_DELETEONFAILURE    0x0002  /* Dest should be deleted on failure */
#define CNFL_RENAMEONSUCCESS    0x0004  /* Dest needs to be renamed */
#define CNFL_CONTINUATION       0x0008  /* Dest is continued onto difft disk */
#define CNFL_SKIPPED            0x0010  /* User asked to skip file */
#define CNFL_IGNOREERRORS       0x0020  // An error has occured on this file already
#define CNFL_RETRYFILE          0x0040  // Retry the file (error ocurred)
#define CNFL_COPIED				0x0080  // Node has already been copied.

// ISSUE-2002/01/16-roelfc: verify the use and usefullness of these flags
// #define VNFL_UNIQUE         0x0000  /* Default */
#define VNFL_MULTIPLEOK     0x0100  /* Do not search PATH for duplicates */
#define VNFL_DESTROYOLD     0x0200  /* Do not back up files */
// #define VNFL_NOW            0x0400  /* Use by vcp Flush */
// To deternime what kind of node it is.
#define VNFL_COPY			0x0000  // A simple copy node.
#define VNFL_DELETE         0x0800  // A delete node
#define VNFL_RENAME         0x1000  // A rename node
#define VNFL_NODE_TYPE		( VNFL_RENAME|VNFL_DELETE|VNFL_COPY )
    /* Read-only flag bits */
#define VNFL_CREATED        0x2000  /* VCPM_NODECREATE has been sent */
#define VNFL_REJECTED       0x4000  /* Node has been rejected */
#define VNFL_VALIDVQCFLAGS  0xff00  /* ;Internal */

/*---------------------------------------------------------------------------*
 *                  VCPSTATUS
 *---------------------------------------------------------------------------*/

typedef struct tagVCPSTATUS {   /* vstat */
    WORD    cbSize;             /* Size of this structure */

    VCPPROGRESS prgDiskRead;
    VCPPROGRESS prgFileRead;
    VCPPROGRESS prgByteRead;

    VCPPROGRESS prgDiskWrite;
    VCPPROGRESS prgFileWrite;
    VCPPROGRESS prgByteWrite;

    LPVCPDISKINFO lpvdiIn;      /* Current input disk */
    LPVCPDISKINFO lpvdiOut;     /* Current output disk */
    LPVIRTNODE    lpvn;            /* Current file */

} VCPSTATUS, FAR *LPVCPSTATUS;

/*---------------------------------------------------------------------------*
 *                  VCPVERCONFLICT
 *---------------------------------------------------------------------------*/

typedef struct tagVCPVERCONFLICT {

    LPCSTR  lpszOldFileName;
    LPCSTR  lpszNewFileName;
    DWORD   dwConflictType;     /* Same values as VerInstallFiles */
    LPVOID  lpvinfoOld;         /* Version information resources */
    LPVOID  lpvinfoNew;
    WORD    wAttribOld;         /* File attributes for original */
    LPARAM  lparamRef;          /* Reference data for callback */

} VCPVERCONFLICT, FAR *LPVCPVERCONFLICT;

/*****************************************************************************
 *              Callback functions
 *****************************************************************************/

typedef LRESULT (CALLBACK *VIFPROC)(LPVOID lpvObj, UINT uMsg, WPARAM wParam, LPARAM lParam, LPARAM lparamRef);

LRESULT CALLBACK vcpDefCallbackProc(LPVOID lpvObj, UINT uMsg, WPARAM wParam, LPARAM lParam, LPARAM lparamRef);

// callback for default UI.
// lparamRef --> a VCPUIINFO structure
LRESULT CALLBACK vcpUICallbackProc(LPVOID lpvObj, UINT uMsg, WPARAM wParam, LPARAM lParam, LPARAM lparamRef);

/*---------------------------------------------------------------------------*
 *                  VCPUIINFO
 *
 * This structure is passed in as the lparamRef of vcpUICallbackProc.
 *
 * on using vcpUICallbackProc:
 * - to use, have vcpUICallbackProc as the callback for vcpOpen with
 *   an appropriately filled in VCPUIINFO structure as the lparamRef.
 *
 * - based on flags, hwndProgress is created and maintained
 * - lpfnStatCallback is called with only status messages
 *     returning VCPM_ABORT indicates that the copy should be aborted
 * - if hwndProgress is non-NULL, the control with idProgress will
 *     receive progress gauge messages as appropriate
 *
 *---------------------------------------------------------------------------*/
#define VCPUI_CREATEPROGRESS 0x0001 // callback should create and manage progress gauge dialog
#define VCPUI_NOBROWSE       0x0002 // no browse button in InsertDisk
#define VCPUI_RENAMEREQUIRED 0x0004 // as a result of a file being in use at copy, reboot required

typedef struct {
    UINT flags;
    HWND hwndParent;            // window of parent
    HWND hwndProgress;          // window to get progress updates (nonzero ids)
    UINT idPGauge;              // id for progress gauge
    VIFPROC lpfnStatCallback;   // callback for status info (or NULL)
    LPARAM lUserData;           // caller definable data
    LOGDISKID ldidCurrent;      // reserved.  do not touch.
} VCPUIINFO, FAR *LPVCPUIINFO;

/******************************************************************************
 *          Callback notification codes
 *****************************************************************************/

/* ISSUE-2002/01/16-roelfc -- VCPN_ABORT should match VCPERROR_INTERRUPTED */

#define VCPN_OK         0       /* All is hunky-dory */
#define VCPN_PROCEED        0   /* The same as VCPN_OK */

#define VCPN_ABORT      (-1)    /* Cancel current operation */
#define VCPN_RETRY      (-2)    /* Retry current operation */
#define VCPN_IGNORE     (-3)    /* Ignore error and continue */
#define VCPN_SKIP       (-4)    /* Skip this file and continue */
#define VCPN_FORCE      (-5)    /* Force an action */
#define VCPN_DEFER      (-6)    /* Save the action for later */
#define VCPN_FAIL       (-7)    /* Return failure back to caller */
#define VCPN_RETRYFILE  (-8)    // An error ocurred during file copy, do it again.

/*****************************************************************************
 *          Callback message numbers
 *****************************************************************************/

#define VCPM_CLASSOF(uMsg)  HIBYTE(uMsg)
#define VCPM_TYPEOF(uMsg)   (0x00FF & (uMsg))   // LOBYTE(uMsg)

/*---------------------------------------------------------------------------*
 *          ERRORs
 *---------------------------------------------------------------------------*/

#define VCPM_ERRORCLASSDELTA    0x80
#define VCPM_ERRORDELTA         0x8000      /* Where the errors go */

/*---------------------------------------------------------------------------*
 *          Disk information callbacks
 *---------------------------------------------------------------------------*/

#define VCPM_DISKCLASS      0x01
#define VCPM_DISKFIRST      0x0100
#define VCPM_DISKLAST       0x01FF

enum tagVCPM_DISK {

    VCPM_DISKCREATEINFO = VCPM_DISKFIRST,
    VCPM_DISKGETINFO,
    VCPM_DISKDESTROYINFO,
    VCPM_DISKPREPINFO,

    VCPM_DISKENSURE,
    VCPM_DISKPROMPT,

    VCPM_DISKFORMATBEGIN,
    VCPM_DISKFORMATTING,
    VCPM_DISKFORMATEND,

    /* Remaining messages reserved for future use */
};

/*---------------------------------------------------------------------------*
 *          File copy callbacks
 *---------------------------------------------------------------------------*/

// ISSUE-2002/01/16-roelfc: this needs to be merged back with other internal errors
#define VCPERROR_IO         (VCP_ERROR - ERR_VCP_IO)            /* Hardware error encountered */

#define VCPM_FILEINCLASS    0x02
#define VCPM_FILEOUTCLASS   0x03
#define VCPM_FILEFIRSTIN    0x0200
#define VCPM_FILEFIRSTOUT   0x0300
#define VCPM_FILELAST       0x03FF

enum tagVCPM_FILE {
    VCPM_FILEOPENIN = VCPM_FILEFIRSTIN,
    VCPM_FILEGETFATTR,
    VCPM_FILECLOSEIN,
    VCPM_FILECOPY,
    VCPM_FILENEEDED,

    VCPM_FILEOPENOUT = VCPM_FILEFIRSTOUT,
    VCPM_FILESETFATTR,
    VCPM_FILECLOSEOUT,
    VCPM_FILEFINALIZE,
    VCPM_FILEDELETE,
    VCPM_FILERENAME,
    /* Remaining messages reserved for future use */
};

/*---------------------------------------------------------------------------*
 *          VIRTNODE callbacks
 *---------------------------------------------------------------------------*/

#define VCPM_NODECLASS  0x04
#define VCPM_NODEFIRST  0x0400
#define VCPM_NODELAST   0x04FF

enum tagVCPM_NODE {
    VCPM_NODECREATE = VCPM_NODEFIRST,
    VCPM_NODEACCEPT,
    VCPM_NODEREJECT,
    VCPM_NODEDESTROY,
    VCPM_NODECHANGEDESTDIR,
    VCPM_NODECOMPARE,
    /* Remaining messages reserved for future use */
};

/*---------------------------------------------------------------------------*
 *          TALLY callbacks
 *---------------------------------------------------------------------------*/

#define VCPM_TALLYCLASS     0x05
#define VCPM_TALLYFIRST     0x0500
#define VCPM_TALLYLAST      0x05FF

enum tagVCPM_TALLY {
    VCPM_TALLYSTART = VCPM_TALLYFIRST,
    VCPM_TALLYEND,
    VCPM_TALLYFILE,
    VCPM_TALLYDISK,
    /* Remaining messages reserved for future use */
};

/*---------------------------------------------------------------------------*
 *          VER callbacks
 *---------------------------------------------------------------------------*/

#define VCPM_VERCLASS       0x06
#define VCPM_VERFIRST       0x0600
#define VCPM_VERLAST        0x06FF

enum tagVCPM_VER {
    VCPM_VERCHECK = VCPM_VERFIRST,
    VCPM_VERCHECKDONE,
    VCPM_VERRESOLVECONFLICT,
    /* Remaining messages reserved for future use */
};

/*---------------------------------------------------------------------------*
 *          VSTAT callbacks
 *---------------------------------------------------------------------------*/

#define VCPM_VSTATCLASS     0x07
#define VCPM_VSTATFIRST     0x0700
#define VCPM_VSTATLAST      0x07FF

enum tagVCPM_VSTAT {
    VCPM_VSTATSTART = VCPM_VSTATFIRST,
    VCPM_VSTATEND,
    VCPM_VSTATREAD,
    VCPM_VSTATWRITE,
    VCPM_VSTATNEWDISK,

    VCPM_VSTATCLOSESTART,       // Start of VCP close
    VCPM_VSTATCLOSEEND,         // upon leaving VCP close
    VCPM_VSTATBACKUPSTART,      // Backup is beginning
    VCPM_VSTATBACKUPEND,        // Backup is finished
    VCPM_VSTATRENAMESTART,      // Rename phase start/end
    VCPM_VSTATRENAMEEND,
    VCPM_VSTATCOPYSTART,        // Acutal copy phase
    VCPM_VSTATCOPYEND,
    VCPM_VSTATDELETESTART,      // Delete phase
    VCPM_VSTATDELETEEND,
    VCPM_VSTATPATHCHECKSTART,   // Check for valid paths
    VCPM_VSTATPATHCHECKEND,
    VCPM_VSTATUSERABORT,        // User wants to quit.
    /* Remaining messages reserved for future use */
};

/*---------------------------------------------------------------------------*
 *          Destination info callbacks
 *---------------------------------------------------------------------------*/

/* ISSUE-2002/01/16-roelfc -- find a reasonable message range for this */
#define VCPM_PATHCLASS      0x08
#define VCPM_PATHFIRST      0x0800
#define VCPM_PATHLAST       0x08FF

enum tagVCPM_PATH{
    VCPM_BUILDPATH = VCPM_PATHFIRST,
    VCPM_UNIQUEPATH,
    VCPM_CHECKPATH,
};

// #define VCPM_BUILDPATH      0x83


/*****************************************************************************/
void WINAPI VcpAddMRUPath( LPCSTR lpszPath );
#define SZ_INSTALL_LOCATIONS "InstallLocationsMRU"


RETERR WINAPI VcpOpen(VIFPROC vifproc, LPARAM lparamMsgRef);

RETERR WINAPI VcpClose(WORD fl, LPCSTR lpszBackupDest);

RETERR WINAPI VcpFlush(WORD fl, LPCSTR lpszBackupDest);

#define VCPFL_ABANDON           0x0000  /* Abandon all pending file copies */
#define VCPFL_BACKUP            0x0001  /* Perform backup */
#define VCPFL_COPY              0x0002  /* Copy files */
#define VCPFL_BACKUPANDCOPY     (VCPFL_BACKUP | VCPFL_COPY)
#define VCPFL_INSPECIFIEDORDER  0x0004  /* Do not sort before copying */
#define VCPFL_DELETE            0x0008
#define VCPFL_RENAME            0x0010
#define VCPFL_DIAMOND           0x0020

typedef int (CALLBACK *VCPENUMPROC)(LPVIRTNODE lpvn, LPARAM lparamRef);

int WINAPI vcpEnumFiles(VCPENUMPROC vep, LPARAM lparamRef);

/* Flag bits that can be set via VcpQueueCopy */


// Various Lparams for files
#define VNLP_SYSCRITICAL    0x0001  // This file should not be skipped
#define VNLP_SETUPCRITICAL  0x0002  // This file cannot be skipped

// VcpEnumFiles Flags.

#define VEN_OP      0x00ff      /* Operation field */

#define VEN_NOP     0x0000      /* Do nothing */
#define VEN_DELETE  0x0001      /* Delete current item */
#define VEN_SET     0x0002      /* Change value of current item */
#define VEN_ADVANCE 0x0003      /* Move to head of list */      /* ;Internal */

#define VEN_FL      0xff00      /* Flags field */

#define VEN_STOP    0x0100      /* Stop enumeration after this item */
#define VEN_ERROR   0x8000      /* Stop enumeration after this item
                                 * and ignore the OP field */



// ISSUE-2002/01/16-roelfc: add the other VCP stuff necessary to use this

// ISSUE-2002/01/16-roelfc: remove the lpsz*Dir fields, make overload the LDID with them

RETERR WINAPI VcpQueueCopy(LPCSTR lpszSrcFileName, LPCSTR lpszDstFileName,
                LPCSTR lpszSrcDir, LPCSTR lpszDstDir,
                LOGDISKID ldidSrc, LOGDISKID ldidDst,
                LPEXPANDVTBL lpExpandVtbl, WORD fl,
                LPARAM lParam);

RETERR WINAPI VcpQueueDelete( LPCSTR lpszDstFileName,
                              LPCSTR lpszDstDir,
                              LOGDISKID ldidDst,
                              LPARAM lParamRef );

RETERR WINAPI VcpQueueRename( LPCSTR      lpszSrcFileName,
                            LPCSTR      lpszDstFileName,
                            LPCSTR      lpszSrcDir,
                            LPCSTR      lpszDstDir,
                            LOGDISKID   ldidSrc,
                            LOGDISKID   ldidDst,
                            LPARAM      lParam );

#endif // NOVCP



#ifndef NOINF
/***************************************************************************/
//
// Inf Parser API declaration and definitions
//
/***************************************************************************/

enum _ERR_IP
{
    ERR_IP_INVALID_FILENAME = (IP_ERROR + 1),
    ERR_IP_ALLOC_ERR,
    ERR_IP_INVALID_SECT_NAME,
    ERR_IP_OUT_OF_HANDLES,
    ERR_IP_INF_NOT_FOUND,
    ERR_IP_INVALID_INFFILE,
    ERR_IP_INVALID_HINF,
    ERR_IP_INVALID_FIELD,
    ERR_IP_SECT_NOT_FOUND,
    ERR_IP_END_OF_SECTION,
    ERR_IP_PROFILE_NOT_FOUND,
    ERR_IP_LINE_NOT_FOUND,
    ERR_IP_FILEREAD,
    ERR_IP_TOOMANYINFFILES,
    ERR_IP_INVALID_SAVERESTORE,
    ERR_IP_INVALID_INFTYPE
};

#define INFTYPE_TEXT                0
#define INFTYPE_EXECUTABLE          1

#define MAX_SECT_NAME_LEN    32

typedef struct _INF NEAR * HINF;
typedef struct _INFLINE FAR * HINFLINE;            // tolken to inf line

RETERR  WINAPI IpOpen(LPCSTR pszFileSpec, HINF FAR * lphInf);
RETERR  WINAPI IpOpenEx(LPCSTR pszFileSpec, HINF FAR * lphInf, UINT InfType);
RETERR  WINAPI IpOpenAppend(LPCSTR pszFileSpec, HINF hInf);
RETERR  WINAPI IpOpenAppendEx(LPCSTR pszFileSpec, HINF hInf, UINT InfType);
RETERR  WINAPI IpSaveRestorePosition(HINF hInf, BOOL bSave);
RETERR  WINAPI IpClose(HINF hInf);
RETERR  WINAPI IpGetLineCount(HINF hInf, LPCSTR lpszSection, int FAR * lpCount);
RETERR  WINAPI IpFindFirstLine(HINF hInf, LPCSTR lpszSect, LPCSTR lpszKey, HINFLINE FAR * lphRet);
RETERR  WINAPI IpFindNextLine(HINF hInf, HINFLINE FAR * lphRet);
RETERR  WINAPI IpFindNextMatchLine(HINF hInf, LPCSTR lpszKey, HINFLINE FAR * lphRet);
RETERR  WINAPI IpGetProfileString(HINF hInf, LPCSTR lpszSec, LPCSTR lpszKey, LPSTR lpszBuf, int iBufSize);
RETERR  WINAPI IpGetFieldCount(HINF hInf, HINFLINE hInfLine, int FAR * lpCount);
RETERR  WINAPI IpGetFileName(HINF hInf, LPSTR lpszBuf, int iBufSize);
RETERR  WINAPI IpGetIntField(HINF hInf, HINFLINE hInfLine, int iField, int FAR * lpVal);
RETERR  WINAPI IpGetLongField(HINF hInf, HINFLINE hInfLine, int iField, long FAR * lpVal);
RETERR  WINAPI IpGetStringField(HINF hInf, HINFLINE hInfLine, int iField, LPSTR lpBuf, int iBufSize, int FAR * lpuCount);
RETERR  WINAPI IpGetClass(LPSTR lpszInfFile, LPSTR lpszBuf, int cbBuf, LPSTR lpszDefaultClassName);

#endif // NOINF



#ifndef NOTEXTPROC
/***************************************************************************/
//
// Text processing API declaration and definitions
//
/***************************************************************************/

/* Relative/absolute positioning */
#define SEC_SET 1       // Absolute positioning (relative to the start)
#define SEC_END 2       // Realtive to the end
#define SEC_CUR 3       // Relative to the current line.

#define SEC_OPENALWAYS          1   // Always open a section, no error if it does not exist
#define SEC_OPENEXISTING        2   // Open an existing section, an error given if it does not exist.
#define SEC_OPENNEWALWAYS       3   // Open a section (present or not) and discard its contents.
#define SEC_OPENNEWEXISTING     4   // Open an existing section (discarding its contents). Error if not existing

// Flags for TP_OpenFile().
//
  // Use autoexec/config.sys key delimiters
  //
#define TP_WS_KEEP      1

  // If TP code running under SETUP, the foll. flag specifies whether
  // to cache this file or not! Use this, if you want to read a whole
  // file in when doing the TpOpenSection()!
  //
#define TP_WS_DONTCACHE 2

// The following are simple errors
enum {
    ERR_TP_NOT_FOUND = (TP_ERROR + 1),  // line, section, file etc.
                    // not necessarily terminal
    ERR_TP_NO_MEM,      // couldn't perform request - generally terminal
    ERR_TP_READ,        // could not read the disc - terminal
    ERR_TP_WRITE,       // could not write the data - terminal.
    ERR_TP_INVALID_REQUEST, // Multitude of sins - not necessarily terminal.
    ERR_TP_INVALID_LINE         // Invalid line from DELETE_LINE etc.
};

/* Data handles */
DECLARE_HANDLE(HTP);
typedef HTP FAR * LPHTP;

/* File handles */
DECLARE_HANDLE(HFN);
typedef HFN FAR * LPHFN;

typedef UINT TFLAG;
typedef UINT LINENUM, FAR * LPLINENUM;

#define MAX_REGPATH     256     // Max Registry Path Length
#define LINE_LEN        256     // ISSUE-2002/01/16-roelfc: max line length?
#define SECTION_LEN     32      // ISSUE-2002/01/16-roelfc: max length of a section name?
#define MAX_STRING_LEN  512     // ISSUE-2002/01/16-roelfc: review this

/* Function prototypes */
RETERR  WINAPI TpOpenFile(LPCSTR Filename, LPHFN phFile, TFLAG Flag);
RETERR  WINAPI TpCloseFile(HFN hFile);
RETERR  WINAPI TpOpenSection(HFN hfile, LPHTP phSection, LPCSTR Section, TFLAG flag);
RETERR  WINAPI TpCloseSection(HTP Section);
RETERR  WINAPI TpCommitSection(HFN hFile, HTP hSection, LPCSTR Section, TFLAG flag);
LINENUM WINAPI TpGetLine(HTP hSection, LPCSTR key, LPCSTR value, int rel, int orig, LPLINENUM lpLineNum );
LINENUM WINAPI TpGetNextLine(HTP hSection, LPCSTR key, LPCSTR value, LPLINENUM lpLineNum );
RETERR  WINAPI TpInsertLine(HTP hSection, LPCSTR key, LPCSTR value, int rel, int orig, TFLAG flag);
RETERR  WINAPI TpReplaceLine(HTP hSection, LPCSTR key, LPCSTR value, int rel, int orig, TFLAG flag);
RETERR  WINAPI TpDeleteLine(HTP hSection, int rel, int orig,TFLAG flag);
RETERR  WINAPI TpMoveLine(HTP hSection, int src_rel, int src_orig, int dest_rel, int dest_orig, TFLAG flag);
RETERR  WINAPI TpGetLineContents(HTP hSection, LPSTR buffer, UINT bufsize, UINT FAR * lpActualSize,int rel, int orig, TFLAG flag);

// UINT    WINAPI TpGetWindowsDirectory(LPSTR lpDest, UINT size);
// UINT    WINAPI TpGetSystemDirectory(LPSTR lpDest, UINT size);

int  WINAPI TpGetPrivateProfileString(LPCSTR lpszSect, LPCSTR lpszKey, LPCSTR lpszDefault, LPSTR lpszReturn, int nSize, LPCSTR lpszFile);
int  WINAPI TpWritePrivateProfileString(LPCSTR lpszSect, LPCSTR lpszKey, LPCSTR lpszString, LPCSTR lpszFile);
int  WINAPI TpGetProfileString(LPCSTR lpszSect, LPCSTR lpszKey, LPCSTR lpszDefault, LPSTR lpszReturn, int nSize);
BOOL WINAPI TpWriteProfileString(LPCSTR lpszSect , LPCSTR lpszKey , LPCSTR lpszString);

#endif // NOTEXTPROC



#ifndef NOGENINSTALL
/***************************************************************************/
//
// Generic Installer prototypes and definitions
//
/***************************************************************************/

enum _ERR_GENERIC
{
    ERR_GEN_LOW_MEM = GEN_ERROR+1,  // Insufficient memory.
    ERR_GEN_INVALID_FILE,           // Invalid INF file.
    ERR_GEN_LOGCONFIG,              // Can't process LogConfig=.
    ERR_GEN_CFGAUTO,                // Can't process CONFIG.SYS/AUTOEXEC.BAT
    ERR_GEN_UPDINI,                 // Can't process UpdateInis=.
    ERR_GEN_UPDINIFIELDS,           // Can't process UpdateIniFields=.
    ERR_GEN_ADDREG,                 // Can't process AddReg=.
    ERR_GEN_DELREG,                 // Can't process DelReg=.
    ERR_GEN_INI2REG,                // Can't process Ini2Reg=.
    ERR_GEN_FILE_COPY,              // Can't process CopyFiles=.
    ERR_GEN_FILE_DEL,               // Can't process DelFiles=.
    ERR_GEN_FILE_REN,               // Can't process RenFiles=.
    ERR_GEN_REG_API,                // Error returned by Reg API.
    ERR_GEN_DO_FILES,               // can't do Copy, Del or RenFiles.
};

// The cbSize field will always be set to sizeof(GENCALLBACKINFO_S).
// All unused fields (for the operation) will be not be initialized.
// For example, when the operation is GENO_DELFILE, the Src fields will
// not have any sensible values (Dst fields will be set correctly) as
// VcpQueueDelete only accepts Dst parameters.
//
/***************************************************************************
 * GenCallbackINFO structure passed to GenInstall CallBack functions.
 ***************************************************************************/
typedef struct _GENCALLBACKINFO_S { /* gen-callback struc */
    WORD         cbSize;                 // Size of this structure (bytes).
    WORD         wOperation;             // Operation being performed.
    LOGDISKID    ldidSrc;                // Logical Disk ID for Source.
    LPCSTR       pszSrcSubDir;           // Source sub-dir off of the LDID.
    LPCSTR       pszSrcFileName;         // Source file name (base name).
    LOGDISKID    ldidDst;                // Logical Disk ID for Dest.
    LPCSTR       pszDstSubDir;           // Dest. sub-dir off of the LDID.
    LPCSTR       pszDstFileName;         // Dest. file name (base name).
    LPEXPANDVTBL lpExpandVtbl;           // ISSUE-2002/01/16-roelfc: Needed? NULL right now!
    WORD         wflags;                 // flags for VcpQueueCopy.
    LPARAM       lParam;                 // LPARAM to the Vcp API.
} GENCALLBACKINFO_S, FAR *LPGENCALLBACKINFO;

/***************************************************************************
 * GenCallback notification codes -- callback proc returns 1 of foll. values.
 ***************************************************************************/
#define GENN_OK         0       /* All is hunky-dory. Do the VCP operation */
#define GENN_PROCEED    0       /* The same as GENN_OK */

#define GENN_ABORT      (-1)    /* Cancel current GenInstall altogether */
#define GENN_SKIP       (-2)    /* Skip this file and continue */

/***************************************************************************
 * VCP Operation being performed by GenInstall() -- wOperation values in
 * GENCALLBACKINFO structure above.
 ***************************************************************************/
#define GENO_COPYFILE   1       /* VCP copyfile being done */
#define GENO_DELFILE    2       /* VCP delfile being done */
#define GENO_RENFILE    3       /* VCP renfile being done */


typedef LRESULT (CALLBACK *GENCALLBACKPROC)(LPGENCALLBACKINFO lpGenInfo,
                                                            LPARAM lparamRef);

RETERR WINAPI GenInstall( HINF hinfFile, LPCSTR szInstallSection, WORD wFlags );
RETERR WINAPI GenInstallEx( HINF hInf, LPCSTR szInstallSection, WORD wFlags,
                                HKEY hRegKey, GENCALLBACKPROC CallbackProc,
                                LPARAM lparam);
RETERR WINAPI GenWinInitRename(LPCSTR szNew, LPSTR szOld, LOGDISKID ldid);
RETERR WINAPI GenCopyLogConfig2Reg(HINF hInf, HKEY hRegKey,
                                                LPCSTR szLogConfigSection);
void   WINAPI GenFormStrWithoutPlaceHolders( LPSTR szDst, LPCSTR szSrc,
                                                                HINF hInf ) ;

// A devnode is just a DWORD and this is easier than
// having to include configmg.h for everybody
RETERR WINAPI GenInfLCToDevNode(ATOM atInfFileName, LPSTR lpszSectionName,
                                BOOL bInstallSec, UINT InfType, 
                                DWORD dnDevNode);

// Bit fields for GenInstall() (for wFlags parameter) -- these can be OR-ed!
#define GENINSTALL_DO_FILES     1
#define GENINSTALL_DO_INI       2
#define GENINSTALL_DO_REG       4
#define GENINSTALL_DO_INI2REG   8
#define GENINSTALL_DO_CFGAUTO   16
#define GENINSTALL_DO_LOGCONFIG 32
#define GENINSTALL_DO_INIREG    (GENINSTALL_DO_INI | \
                                 GENINSTALL_DO_REG | \
                                 GENINSTALL_DO_INI2REG)
#define GENINSTALL_DO_ALL       (GENINSTALL_DO_FILES | \
                                    GENINSTALL_DO_INIREG | \
                                    GENINSTALL_DO_CFGAUTO | \
                                    GENINSTALL_DO_LOGCONFIG)

#endif // NOGENINSTALL



#ifndef NODEVICENSTALL
/***************************************************************************/
//
// Device Installer prototypes and definitions
//
/***************************************************************************/

enum _ERR_DEVICE_INSTALL
{
    ERR_DI_INVALID_DEVICE_ID = DI_ERROR,    // Incorrectly formed device IDF
    ERR_DI_INVALID_COMPATIBLE_DEVICE_LIST,  // Invalid compatible device list
    ERR_DI_REG_API,                         // Error returned by Reg API.
    ERR_DI_LOW_MEM,             // Insufficient memory to complete
    ERR_DI_BAD_DEV_INFO,            // Device Info struct invalid
    ERR_DI_INVALID_CLASS_INSTALLER,     // Registry entry / DLL invalid
    ERR_DI_DO_DEFAULT,              // Take default action
    ERR_DI_USER_CANCEL,             // the user cancelled the operation
    ERR_DI_NOFILECOPY,              // No need to copy files (in install)
    ERR_DI_BAD_CLASS_INFO,          // Class Info Struct invalid
    ERR_DI_BAD_INF,                 //  Bad INF file encountered
    ERR_DI_BAD_MOVEDEV_PARAMS,	    // Bad Move Device Params struct
    ERR_DI_NO_INF,		    // No INF found on OEM disk
};



typedef struct _DRIVER_NODE {
    struct _DRIVER_NODE FAR* lpNextDN;
    UINT    Rank;
    UINT    InfType;
    unsigned    InfDate;
    LPSTR   lpszDescription;
    LPSTR   lpszSectionName;
    ATOM    atInfFileName;
    ATOM    atMfgName;
    ATOM    atProviderName;
    DWORD   Flags;
    DWORD   dwPrivateData;
}   DRIVER_NODE, NEAR* PDRIVER_NODE, FAR* LPDRIVER_NODE, FAR* FAR* LPLPDRIVER_NODE;

#define DNF_DUPDESC    0x00000001   // Multiple providers have same desc
#define DNF_OLDDRIVER  0x00000002   // Driver node specifies old/current driver

// possible types of "INF" files
#define INFTYPE_WIN4        1
#define INFTYPE_WIN3        2
#define INFTYPE_COMBIDRV    3
#define INFTYPE_PPD         4
#define INFTYPE_WPD     5
#define INFTYPE_CLASS_SPEC1 6
#define INFTYPE_CLASS_SPEC2 7
#define INFTYPE_CLASS_SPEC3 8
#define INFTYPE_CLASS_SPEC4 9


#define MAX_CLASS_NAME_LEN   32
#define MAX_DRIVER_INST_LEN  10


typedef struct _DEVICE_INFO
{
    UINT        cbSize;
    struct _DEVICE_INFO FAR* lpNextDi;
    char                szDescription[LINE_LEN];
    DWORD       dnDevnode;
    HKEY        hRegKey;
    char        szRegSubkey[100]; //~~~~
    char        szClassName[MAX_CLASS_NAME_LEN];
    DWORD       Flags;
    HWND        hwndParent;
    LPDRIVER_NODE   lpCompatDrvList;
    LPDRIVER_NODE   lpClassDrvList;
    LPDRIVER_NODE   lpSelectedDriver;
    ATOM    atDriverPath;
    ATOM    atTempInfFile;
    HINSTANCE   hinstClassInstaller;            // The Class Installer module
    HINSTANCE   hinstClassPropProvidor;         // The Class Property Providor
    HINSTANCE   hinstDevicePropProvidor;        // The Device Property Providor
    HINSTANCE   hinstBasicPropProvidor;         // The Basic Property Providor hinst
    FARPROC     fpClassInstaller;               // ClassInstall entry point
    FARPROC     fpClassEnumPropPages;           // Class EnumPropPages entry point
    FARPROC     fpDeviceEnumPropPages;          // Device EnumPropPages entry point
    FARPROC     fpEnumBasicProperties;          // Basic Property Page enum entry
    DWORD       dwSetupReserved;                // Reserved for SETUP's use
    DWORD       dwClassInstallReserved;         // Reserved for Class Installer use
    GENCALLBACKPROC gicpGenInstallCallBack;     // Set by Caller of DiInstallDevice if 
                                                // they want GenInstall callbacks
    LPARAM          gicplParam;                 // lParam for GenInstall Callback                                                
    UINT            InfType;                    // The type of INF file it ENUMSINGLEINF is
                                                // specified
    HINSTANCE   hinstPrivateProblemHandler;     // The Private Problem DLL for a Specific Device
    FARPROC     fpPrivateProblemHandler;        // The Private Problem Handler entry point
    LPARAM      lpClassInstallParams;           // Class Install functions specific Parameters
} DEVICE_INFO, FAR * LPDEVICE_INFO, FAR * FAR * LPLPDEVICE_INFO;

#define ASSERT_DI_STRUC(lpdi) if (lpdi->cbSize != sizeof(DEVICE_INFO)) return (ERR_DI_BAD_DEV_INFO)

typedef struct _CLASS_INFO
{
    UINT        cbSize;
    struct _CLASS_INFO FAR* lpNextCi;
    LPDEVICE_INFO   lpdi;
    char                szDescription[LINE_LEN];
    char        szClassName[MAX_CLASS_NAME_LEN];
} CLASS_INFO, FAR * LPCLASS_INFO, FAR * FAR * LPLPCLASS_INFO;
#define ASSERT_CI_STRUC(lpci) if (lpci->cbSize != sizeof(CLASS_INFO)) return (ERR_DI_BAD_CLASS_INFO)


// flags for device choosing (InFlags)
#define DI_SHOWOEM  0x00000001L     // support Other... button
#define DI_SHOWCOMPAT   0x00000002L     // show compatibility list
#define DI_SHOWCLASS    0x00000004L     // show class list
#define DI_SHOWALL  0x00000007L
#define DI_NOVCP    0x00000008L     // Don't do vcpOpen/vcpClose.
#define DI_DIDCOMPAT    0x00000010L     // Searched for compatible devices
#define DI_DIDCLASS 0x00000020L     // Searched for class devices
#define DI_AUTOASSIGNRES 0x00000040L    // No UI for resources if possible

// flags returned by DiInstallDevice to indicate need to reboot/restart
#define DI_NEEDRESTART  0x00000080L     // Restart required to take effect
#define DI_NEEDREBOOT   0x00000100L     // Reboot required to take effect

// flags for device installation
#define DI_NOBROWSE 0x00000200L     // no Browse... in InsertDisk

// Flags set by DiBuildClassDrvList
#define DI_MULTMFGS 0x00000400L     // Set if multiple manufacturers in
                    // class driver list
// Flag indicates that device is disabled
#define DI_DISABLED 0x00000800L     // Set if device disabled

// Flags for Device/Class Properties
#define DI_GENERALPAGE_ADDED    0x00001000L
#define DI_RESOURCEPAGE_ADDED   0x00002000L

// Flag to indicate the setting properties for this Device (or class) caused a change
// so the Dev Mgr UI probably needs to be updatd.
#define DI_PROPERTIES_CHANGE    0x00004000L

// Flag to indicate that the sorting from the INF file should be used.
#define DI_INF_IS_SORTED        0x00008000L

#define DI_ENUMSINGLEINF        0x00010000L

// The following flags can be used to install a device disabled
// and to prevent CONFIGMG being called when a device is installed
#define DI_DONOTCALLCONFIGMG    0x00020000L
#define DI_INSTALLDISABLED      0x00040000L

// This flag is set of this LPDI is really just an LPCI, ie
// it only contains class info, NO DRIVER/DEVICE INFO
#define DI_CLASSONLY            0x00080000L

// This flag is set if the Class Install params are valid
#define DI_CLASSINSTALLPARAMS   0x00100000L

// This flag is set if the caller of DiCallClassInstaller does NOT
// want the internal default action performed if the Class installer
// return ERR_DI_DO_DEFAULT
#define DI_NODI_DEFAULTACTION   0x00200000L

// ISSUE-2002/01/16-roelfc. This is a hack for M6 Net setup.  Net Setup does not work correctly
// if we process devnode syncronously.  This WILL be removed for M7 when
// Net setup is fixed to work with DiInstallDevice
#define DI_NOSYNCPROCESSING     0x00400000L

// flags for device installation
#define DI_QUIETINSTALL 	0x00800000L	// don't confuse the user with
						// questions or excess info
// Defines for class installer functions
#define DIF_SELECTDEVICE        0x0001
#define DIF_INSTALLDEVICE       0x0002
#define DIF_ASSIGNRESOURCES     0x0003
#define DIF_PROPERTIES          0x0004
#define DIF_REMOVE          0x0005
#define DIF_FIRSTTIMESETUP      0x0006
#define DIF_FOUNDDEVICE         0x0007
#define DIF_SELECTCLASSDRIVERS      0x0008
#define DIF_VALIDATECLASSDRIVERS    0x0009
#define DIF_INSTALLCLASSDRIVERS     0x000A
#define DIF_CALCDISKSPACE           0x000B
#define DIF_DESTROYPRIVATEDATA      0x000C
#define DIF_VALIDATEDRIVER          0x000D
#define DIF_MOVEDEVICE              0x000E

typedef UINT        DI_FUNCTION;    // Function type for device installer

// DIF_MOVEDEVICE parameter struct.
typedef struct _MOVEDEV_PARAMS
{
    UINT            cbSize;
    LPDEVICE_INFO   lpdiOldDev;     // References the Device Begin Moved
} MOVEDEV_PARAMS, FAR * LPMOVEDEV_PARAMS;
#define ASSERT_MOVEDEVPARAMS_STRUC(lpmdp) if (lpmdp->cbSize != sizeof(MOVEDEV_PARAMS)) return (ERR_DI_BAD_MOVEDEV_PARAMS)

RETERR WINAPI DiCreateDeviceInfo(
    LPLPDEVICE_INFO lplpdi,     // Ptr to ptr to dev info
    LPCSTR      lpszDescription,    // If non-null then description string
    DWORD       hDevnode,       // ISSUE-2002/01/16-roelfc -- MAKE A DEVNODE
    HKEY        hkey,       // Registry hkey for dev info
    LPCSTR      lpszRegsubkey,  // If non-null then reg subkey string
    LPCSTR      lpszClassName,  // If non-null then class name string
    HWND        hwndParent);    // If non-null then hwnd of parent

RETERR WINAPI DiGetClassDevs(
    LPLPDEVICE_INFO lplpdi,     // Ptr to ptr to dev info
    LPCSTR      lpszClassName,  // Must be name of class
    HWND        hwndParent,     // If non-null then hwnd of parent
    int         iFlags);        // Options

#define DIGCF_DEFAULT           0x0001  // NOT IMPLEMENTED!
#define DIGCF_PRESENT           0x0002
#define DIGCF_ALLCLASSES        0x0004
#define DIGCF_PROFILE           0x0008

// API to return the Class name of an INF File
RETERR WINAPI DiGetINFClass(LPSTR lpszMWDPath, UINT InfType, LPSTR lpszClassName, DWORD dwcbClassName);

RETERR WINAPI PASCAL DiCreateDevRegKey(
    LPDEVICE_INFO   lpdi,
    LPHKEY      lphk,
    HINF        hinf,
    LPCSTR      lpszInfSection,
    int         iFlags);
    
RETERR WINAPI PASCAL DiDeleteDevRegKey(LPDEVICE_INFO lpdi, int  iFlags);


RETERR WINAPI PASCAL DiOpenDevRegKey(
    LPDEVICE_INFO   lpdi,
    LPHKEY      lphk,
    int         iFlags);

#define DIREG_DEV	0x0001		// Open/Create/Delete device key
#define DIREG_DRV	0x0002		// Open/Create/Delete driver key
#define DIREG_BOTH	0x0004		// Delete both driver and Device key

RETERR WINAPI DiReadRegLogConf
(
    LPDEVICE_INFO       lpdi,
    LPSTR               lpszConfigName,
    LPBYTE FAR          *lplpbLogConf,
    LPDWORD             lpdwSize
);

RETERR WINAPI DiReadRegConf
(
    LPDEVICE_INFO       lpdi,
    LPBYTE FAR          *lplpbLogConf,
    LPDWORD             lpdwSize,
    DWORD               dwFlags
);

#define DIREGLC_FORCEDCONFIG        0x00000001
#define DIREGLC_BOOTCONFIG          0x00000002

RETERR WINAPI DiDestroyClassInfoList(LPCLASS_INFO lpci);
RETERR WINAPI DiBuildClassInfoList(LPLPCLASS_INFO lplpci);
RETERR WINAPI DiGetDeviceClassInfo(LPLPCLASS_INFO lplpci, LPDEVICE_INFO lpdi);

RETERR WINAPI DiDestroyDeviceInfoList(LPDEVICE_INFO lpdi);
RETERR WINAPI DiSelectDevice( LPDEVICE_INFO lpdi );
RETERR WINAPI DiSelectOEMDrv(HWND hDlg, LPDEVICE_INFO lpdi);
RETERR WINAPI DiInstallDevice( LPDEVICE_INFO lpdi );
RETERR WINAPI DiRemoveDevice( LPDEVICE_INFO lpdi );
RETERR WINAPI DiAssignResources( LPDEVICE_INFO lpdi );
RETERR WINAPI DiAskForOEMDisk(LPDEVICE_INFO lpdi);

RETERR WINAPI DiCallClassInstaller(DI_FUNCTION diFctn, LPDEVICE_INFO lpdi);

RETERR WINAPI DiBuildCompatDrvList(LPDEVICE_INFO lpdi);
RETERR WINAPI DiBuildClassDrvList(LPDEVICE_INFO lpdi);

typedef RETERR (CALLBACK *OLDINFPROC)(HINF hinf, LPCSTR lpszNewInf, LPARAM lParam);
RETERR WINAPI DiBuildClassDrvListFromOldInf(LPDEVICE_INFO lpdi, LPCSTR lpszSection, OLDINFPROC lpfnOldInfProc, LPARAM lParam);

RETERR WINAPI DiDestroyDriverNodeList(LPDRIVER_NODE lpdn);

// The following export will load a dll and find the specified proc name
typedef RETERR (FAR PASCAL *DIINSTALLERPROPERTIES)(LPDEVICE_INFO);

RETERR WINAPI GetFctn(HKEY hk, LPSTR lpszRegVal, LPSTR lpszDefProcName,
                      HINSTANCE FAR * lphinst, FARPROC FAR *lplpfn);
                        
RETERR
WINAPI
DiCreateDriverNode(
    LPLPDRIVER_NODE lplpdn,
    UINT    Rank,
    UINT    InfType,
    unsigned    InfDate,
    LPCSTR  lpszDescription,
    LPCSTR  lpszProviderName,
    LPCSTR  lpszMfgName,
    LPCSTR  lpszInfFileName,
    LPCSTR  lpszSectionName,
    DWORD   dwPrivateData);


RETERR WINAPI DiLoadClassIcon(
    LPCSTR  szClassName,
    HICON FAR *lphiLargeIcon,
    int FAR *lpiMiniIconIndex);


RETERR WINAPI DiInstallDrvSection(
    LPCSTR  lpszInfFileName,
    LPCSTR  lpszSection,
    LPCSTR  lpszClassName,
    LPCSTR  lpszDescription,
    DWORD   dwFlags);


RETERR WINAPI DiChangeState(LPDEVICE_INFO lpdi, DWORD dwStateChange, DWORD dwFlags, LPARAM lParam);

#define DICS_ENABLE                 0x00000001
#define DICS_DISABLE                0x00000002
#define DICS_PROPCHANGE             0x00000003

#define DICS_FLAG_GLOBAL            0x00000001
#define DICS_FLAG_CONFIGSPECIFIC    0x00000002

RETERR WINAPI DiInstallClass(LPCSTR lpszInfFileName, DWORD dwFlags);

RETERR WINAPI DiOpenClassRegKey(LPHKEY lphk, LPCSTR lpszClassName);

// support routine for dealing with class mini icons
int WINAPI PASCAL DiDrawMiniIcon(HDC hdc, RECT rcLine, int iMiniIcon, UINT flags);
BOOL WINAPI DiGetClassBitmapIndex(LPCSTR lpszClass, int FAR *lpiMiniIconIndex);

// internal calls for display class
#define DISPLAY_SETMODE_SUCCESS     0x0001
#define DISPLAY_SETMODE_DRVCHANGE   0x0002
#define DISPLAY_SETMODE_FONTCHANGE  0x0004

UINT WINAPI Display_SetMode(LPDEVICE_INFO lpdi, UINT uColorRes, int iXRes, int iYRes);
RETERR WINAPI Display_ClassInstaller(DI_FUNCTION diFctn, LPDEVICE_INFO lpdi);
RETERR WINAPI Display_OpenFontSizeKey(LPHKEY lphkFontSize);
BOOL WINAPI Display_SetFontSize(LPCSTR lpszFontSize);

RETERR WINAPI DiIsThereNeedToCopy(HWND hwnd, DWORD dwFlags);

#define DINTC_NOCOPYDEFAULT	    0x00000001

// API for the mouse class installer
RETERR WINAPI Mouse_ClassInstaller(DI_FUNCTION diFctn, LPDEVICE_INFO lpdi);
#endif // NODEVICEINSTALL



/***************************************************************************/
//
// setup reg DB calls, use just like those in kernel
//
/***************************************************************************/

DWORD WINAPI SURegOpenKey(HKEY hKey, LPSTR lpszSubKey, HKEY FAR *lphkResult);
DWORD WINAPI SURegCloseKey(HKEY hKey);
DWORD WINAPI SURegCreateKey(HKEY hKey, LPSTR lpszSubKey, HKEY FAR *lphkResult);
DWORD WINAPI SURegDeleteKey(HKEY hKey, LPSTR lpszSubKey);
DWORD WINAPI SURegEnumKey(HKEY hKey, DWORD dwIdx, LPSTR lpszBuffer, DWORD dwBufSize);
DWORD WINAPI SURegQueryValue16(HKEY hKey, LPSTR lpszSubKey, LPSTR lpValueBuf, DWORD FAR *ldwBufSize);
DWORD WINAPI SURegSetValue16(HKEY hKey, LPSTR lpszSubKey, DWORD dwType, LPBYTE lpszValue, DWORD dwValSize);
DWORD WINAPI SURegDeleteValue(HKEY hKey,LPSTR lpszValue);
DWORD WINAPI SURegEnumValue(HKEY hKey,DWORD dwIdx, LPSTR lpszValue, DWORD FAR *lpcbValue, DWORD FAR *lpdwReserved, DWORD FAR *lpdwType, LPBYTE lpbData, DWORD FAR *lpcbData);
DWORD WINAPI SURegQueryValueEx(HKEY hKey,LPSTR lpszValueName, DWORD FAR *lpdwReserved,DWORD FAR *lpdwType,LPSTR lpValueBuf, DWORD FAR *ldwBufSize);
DWORD WINAPI SURegSetValueEx(HKEY hKey,LPSTR lpszValueName, DWORD dwReserved, DWORD dwType, LPBYTE lpszValue, DWORD dwValSize);

DWORD WINAPI SURegFlush(VOID);
DWORD WINAPI SURegInit(VOID);    // should be called before any other Reg APIs


/***************************************************************************/
// setup PropertySheet support
/***************************************************************************/
#ifndef NOPRSHT
#include <prsht.h>
HPROPSHEETPAGE  WINAPI SUCreatePropertySheetPage(LPCPROPSHEETPAGE lppsp);
BOOL            WINAPI SUDestroyPropertySheetPage(HPROPSHEETPAGE hPage);
int             WINAPI SUPropertySheet(LPCPROPSHEETHEADER lppsh);
#endif // NOPRSHT


/***************************************************************************/
// setup FormatMessage support
/***************************************************************************/
#define MB_LOG  (UINT)-1

UINT FAR CDECL suFormatMessage(HINSTANCE hAppInst, LPCSTR lpcFormat, LPSTR szMessage, UINT uSize,
    ...);
UINT WINAPI suvFormatMessage(HINSTANCE hAppInst, LPCSTR lpcFormat, LPSTR szMessage, UINT uSize,
    LPVOID FAR * lpArgs);
int WINCAPI _loadds suFormatMessageBox(HINSTANCE hAppInst, HWND hwndParent, LPCSTR lpcText, LPCSTR lpcTitle,
    UINT uStyle, ...);

WORD WINAPI suErrorToIds( WORD Value, WORD Class );

/***************************************************************************/
// setup Version Conflict support
/***************************************************************************/

LPVOID WINAPI suVerConflictInit(BOOL fYesToLangMismatch);
void WINAPI suVerConflictTerm(LPVOID lpvData);
LRESULT WINAPI suVerConflict(HWND hwnd, LPVCPVERCONFLICT lpvc, LPVOID lpvData);


/***************************************************************************/
// setup Help support
/***************************************************************************/

BOOL WINAPI suHelp( HWND hwndApp, HWND hwndDlg );


//***************************************************************************
// Misc SETUPX.DLL support functions.
//***************************************************************************
enum  SU_ACTIONS                        // Actions msgs for Setupx()    /* ;Internal */
{                                                                       /* ;Internal */
    SUX_REGINIT,                        // Intialize registry           /* ;Internal */
    SUX_DBGLEVEL,                       // Set debug level              /* ;Internal */
    SUX_SETUPFLG,                       // Set fIsSetup flag            /* ;Internal */
    SUX_FASTSETUP,						// Setupx => checking less mode /* ;Internal */
    SUX_FORCEREGFLUSH,                  // Call kRegFlush               /* ;Internal */
    SUX_TPSFLUSH,                  	    // Call TPS_Flush() fns.        /* ;Internal */
    SUX_DBGHFILE,			            // File to write messages to    /* ;Internal */
    SUX_LOADSTORELDIDS,			        // Load/store setup's LDID's    /* ;Internal */
    SUX_ENABLEREGFLUSH,			        // Enable/Disable SURegFlush() if fIsSetup  /* ;Internal */
    SUX_SETUNCPATHFUNC,			        // Set UNC Path Convert Func    /* ;Internal */
};                                                                      /* ;Internal */

RETERR WINAPI Setupx( UINT uMsg, WPARAM wParam, LPARAM lParam );        /* ;Internal */

RETERR WINAPI SUGetSetSetupFlags(LPDWORD lpdwFlags, BOOL bSet);

RETERR WINAPI CfgSetupMerge( int uFlags );

// structure for the LPARAM argument to Setupx() for SUX_REGINIT action.    ;Internal
typedef struct _REGINIT_S { /* setupx - reg_init */                     /* ;Internal */
    LPSTR       lpszSystemFile;         // reg's base SYSTEM filename   /* ;Internal */
    LOGDISKID   ldidSystemFile;         // ldid for SYSTEM filename     /* ;Internal */
    LPSTR       lpszUserFile;           // reg's base USER filename     /* ;Internal */
    LOGDISKID   ldidUserFile;           // ldid for USER filename       /* ;Internal */
} REGINIT_S, FAR *LPREGINIT;                                            /* ;Internal */

#ifndef LPLPSTR
    typedef LPSTR (FAR *LPLPSTR);
#endif


#define         CFG_PARSE_BUFLEN 512    // Buf sized passed line obj funcs      /* ;Internal */

LPLPSTR WINAPI  CfgParseLine( LPCSTR szLine, LPSTR Buf );                       /* ;Internal */
BOOL    WINAPI  CfgSetAutoProcess( int TrueFalse );                             /* ;Internal */
void    WINAPI  CfgObjToStr( LPLPSTR apszObj, LPSTR szLine );                   /* ;Internal */
LPLPSTR WINAPI  CfgLnToObj( HTP hSection, int Offset, int Origin, LPSTR Buf );  /* ;Internal */
LPLPSTR WINAPI  CfgObjFindKeyCmd( HTP hSec, LPCSTR szKey, LPCSTR szCmd,         /* ;Internal */
                                  int Offset, int Origin, LPSTR Buf );          /* ;Internal */


//***************************************************************************
//
// ENUMS for accessing config.sys/autoexec.bat line objects using the
// array returned by ParseConfigLine()..
//
//***************************************************************************

enum    CFGLINE_STRINGS                     // Config.sys/autoexec.bat objects
{
    CFG_KEYLEAD,                            // Keyword leading whitespaces
    CFG_KEYWORD,                            // Keyword
    CFG_KEYTRAIL,                           // Keyword trailing delimiters
    CFG_UMBINFO,                            // Load high info
    CFG_DRVLETTER,                          // Drive letter for cmd path
    CFG_PATH,                               // Command path
    CFG_COMMAND,                            // Command base name
    CFG_EXT,                                // Command extension including '.'
    CFG_ARGS,                               // Command arguments
    CFG_FREE,                               // Free area at end of buffer
    CFG_END
};

// DJM  This will be included soon
/*---------------------------------------------------------------------------*
 *                  SUB String Data 
 *---------------------------------------------------------------------------*/

typedef struct _SUBSTR_DATA {
    LPSTR lpFirstSubstr;
    LPSTR lpCurSubstr;
    LPSTR lpLastSubstr;
}   SUBSTR_DATA;


typedef SUBSTR_DATA*		PSUBSTR_DATA;
typedef SUBSTR_DATA NEAR*	NPSUBSTR_DATA;
typedef SUBSTR_DATA FAR*	LPSUBSTR_DATA;

BOOL WINAPI InitSubstrData(LPSUBSTR_DATA lpSubstrData, LPSTR lpStr);
BOOL WINAPI GetFirstSubstr(LPSUBSTR_DATA lpSubstrData);
BOOL WINAPI GetNextSubstr(LPSUBSTR_DATA lpSubStrData);

/*---------------------------------------------------------------------------*
 *                  Misc. Di functions
 *---------------------------------------------------------------------------*/
BOOL WINAPI DiBuildPotentialDuplicatesList
(
    LPDEVICE_INFO   lpdi, 
    LPSTR           lpDuplicateList, 
    DWORD           cbSize,
    LPDWORD         lpcbData,
    LPSTR           lpstrDupType
);

//***************************************************************************
#endif      // SETUPX_INC
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\hnw\win95\setupx4.h ===
//**********************************************************************
//
// SETUPX.H                         
//
//  Copyright (c) 1993 - Microsoft Corp.
//  All rights reserved.
//  Microsoft Confidential
//
// Public include file for Chicago Setup services.
//
// 12/1/93      DONALDM     Added LPCLASS_INFO, and function protos for         ;Internal
//                          exports in SETUP4.DLL                               ;Internal
// 12/4/943     DONALDM     Moved SHELL.H include and Chicago specific          ;Internal
//                          helper functions to SETUP4.H                        ;Internal
// 1/11/94      DONALDM     Added members to DEVICE_INFO to better handle       ;Internal
//                          ClassInstaller load/unload.                         ;Internal
// 1/11/94      DONALDM     Added some new DIF_ messages for Net guys.          ;Internal
// 2/25/94      DONALDM     Fixed a bug with the DIREG_ flags                   ;Internal
//**********************************************************************

#ifndef SETUPX_INC
#define SETUPX_INC   1                   // SETUPX.H signature

/***************************************************************************/
// setup PropertySheet support
// NOTE:  Always include PRST.H because it is needed later for Class Installer
// stuff, and optionally define the SU prop sheet stuff.
/***************************************************************************/
#include <prsht.h>
#ifndef NOPRSHT
HPROPSHEETPAGE  WINAPI SUCreatePropertySheetPage(LPCPROPSHEETPAGE lppsp);
BOOL            WINAPI SUDestroyPropertySheetPage(HPROPSHEETPAGE hPage);
int             WINAPI SUPropertySheet(LPCPROPSHEETHEADER lppsh);
#endif // NOPRSHT

typedef UINT RETERR;             // Return Error code type.

#define OK 0                     // success error code

#define IP_ERROR       (100)    // Inf parsing
#define TP_ERROR       (200)    // Text processing module
#define VCP_ERROR      (300)    // Virtual copy module
#define GEN_ERROR      (400)    // Generic Installer
#define DI_ERROR       (500)    // Device Installer

// err2ids mappings
enum ERR_MAPPINGS {
    E2I_VCPM,           // Maps VCPM to strings
    E2I_SETUPX,         // Maps setupx returns to strings
    E2I_SETUPX_MODULE,  // Maps setupx returns to appropriate module
    E2I_DOS_SOLUTION,   // Maps DOS Extended errors to solutions
    E2I_DOS_REASON,     // Maps DOS extended errors to strings.
    E2I_DOS_MEDIA,      // Maps DOS extended errors to media icon.
};

#ifndef NOVCP

/***************************************************************************/
//
// Logical Disk ID definitions
//
/***************************************************************************/

// DECLARE_HANDLE(VHSTR);           /* VHSTR = VirtCopy Handle to STRing */
typedef UINT VHSTR;         /* VirtCopy Handle to String */

VHSTR   WINAPI vsmStringAdd(LPCSTR lpszName);
int WINAPI vsmStringDelete(VHSTR vhstr);
VHSTR   WINAPI vsmStringFind(LPCSTR lpszName);
int WINAPI vsmGetStringName(VHSTR vhstr, LPSTR lpszBuffer, int cbBuffer);
int WINAPI vsmStringCompare(VHSTR vhstrA, VHSTR vhstrB);
LPCSTR  WINAPI vsmGetStringRawName(VHSTR vhstr);
void    WINAPI vsmStringCompact(void);

typedef UINT LOGDISKID;          /* ldid */

// Logical Disk Descriptor: Structure which describes the physical attributes
// of a logical disk. Every logical disk is assigned a logical disk
// identifier (LDID), and is described by a logical disk descriptor (LDD).
//
// The cbSize structure member must always be set to sizeof(LOGDISKDESC_S),
// but all other unused structure members should be NULL or 0. No validation
// is performed on the size of string arrays; all string pointers, if
// non-NULL and they are to receive a string, must point at string arrays
// whose sizes are as follows:
//      sizeof( szPath )    = MAX_PATH_LEN
//      sizeof( szVolLabel) = MAX_FILENAME_LEN
//      sizeof( szName )    = MAX_STRING_LEN
#define MAX_PATH_LEN        260     // Max. path length.
#define MAX_FILENAME_LEN    20      // Max. filename length. ( > sizeof( "x:\\12345678.123" )


typedef struct _LOGDISKDESC_S { /* ldd */
    WORD        cbSize;                 // Size of this structure (bytes)
    LOGDISKID   ldid;                   // Logical Disk ID.
    LPSTR       pszPath;                // Ptr. to associated Path string.
    LPSTR       pszVolLabel;            // Ptr. to Volume Label string.
    LPSTR       pszDiskName;            // Ptr. to Disk Name string.
    WORD        wVolTime;               // Volume label modification time.
    WORD        wVolDate;               // Volume label modification date.
    DWORD       dwSerNum;               // Disk serial number.
    WORD        wFlags;                 // Flags.
} LOGDISKDESC_S, FAR *LPLOGDISKDESC;



// Range for pre-defined LDIDs.
#define LDID_PREDEF_START   0x0001  // Start of range
#define LDID_PREDEF_END     0x7FFF  // End of range

// Range for dynamically assigned LDIDs.
#define LDID_ASSIGN_START   0x8000  // Start of range
#define LDID_ASSIGN_END     0xBFFF  // End of range

// Pre-defined Logical Disk Identifiers (LDID).
//
#define LDID_NULL       0               // Null (undefined) LDID.
#define LDID_ABSOLUTE   ((UINT)-1)      // Absolute path

// source path of windows install, this is typically A:\ or a net drive
#define LDID_SRCPATH    1   // source of instilation
// temporary setup directory used by setup, this is only valid durring
// regular install and contains the INF and other binary files.  May be
// read-only location.
#define LDID_SETUPTEMP  2   // temporary setup dir for install
// path to uninstall location, this is where we backup files that will
// be overwritten
#define LDID_UNINSTALL  3   // uninstall (backup) dir.
// backup path for the copy engine, this should not be used
#define LDID_BACKUP     4   // ISSUE-2002/01/16-roelfc: backup dir for the copy engine, not used
// temporary setup directory used by setup, this is only valid durring
// regular install and is guarenteed to be a read/write location for 
// scratch space.
#define LDID_SETUPSCRATCH  5   // temporary setup dir for scratch space.

// windows directory, this is the destinatio of the insallation
#define LDID_WIN        10  // destination Windows dir (just user files).
#define LDID_SYS        11  // destination Windows System dir.
#define LDID_IOS        12  // destination Windows Iosubsys dir.
#define LDID_CMD        13  // destination Windows Command (DOS) dir.
#define LDID_CPL        14  // destination Windows Control Panel dir.
#define LDID_PRINT      15  // destination Windows Printer dir.
#define LDID_MAIL       16  // destination Mail dir.
#define LDID_INF        17  // destination Windows *.INF dir.
#define LDID_HELP       18  // destination Windows Help dir.
#define LDID_WINADMIN   19  // admin stuff.

#define LDID_FONTS      20  // destination Windows Font dir.
#define LDID_VIEWERS    21  // destination Windows Viewers dir.
#define LDID_VMM32      22  // destination Windows VMM32 dir.
#define LDID_COLOR      23  // destination Windows Color dir.

#define LDID_APPS       24  // Applications folder location.

// Shared dirs for net install.
#define LDID_SHARED     25  // Bulk of windows files.
#define LDID_WINBOOT    26  // guarenteed boot device for windows.
#define LDID_MACHINE    27  // machine specific files.
#define LDID_HOST_WINBOOT   28

// boot and old win and dos dirs.
#define LDID_BOOT       30  // Root dir of boot drive
#define LDID_BOOT_HOST  31  // Root dir of boot drive host
#define LDID_OLD_WINBOOT    32  // Subdir off of Root (optional)
#define LDID_OLD_WIN    33  // old windows directory (if it exists)
#define LDID_OLD_DOS    34  // old dos directory (if it exists)

#define LDID_OLD_NET    35  // old network root directory, only valid during
                            // network GenUpgrade

#define LDID_MOUSE      36  // path to MOUSE env. variable if set or same as LDID_WIN
                            // only valid after mouse class installer.

// Convert Ascii drive letter to Integer drive number ('A'=1, 'B'=2, ...).
#define DriveAtoI( chDrv )      ((int)(chDrv & 31))

// Convert Integer drive number to Ascii drive letter (1='A', 2='B', ...).
#define DriveItoA( iDrv )       ((char) (iDrv - 1 + 'A'))


// ISSUE-2002/01/16-roelfc: change the names of these

RETERR WINAPI CtlSetLdd     ( LPLOGDISKDESC );
RETERR WINAPI CtlGetLdd     ( LPLOGDISKDESC );
RETERR WINAPI CtlFindLdd    ( LPLOGDISKDESC );
RETERR WINAPI CtlAddLdd     ( LPLOGDISKDESC );
RETERR WINAPI CtlDelLdd     ( LOGDISKID  );
RETERR WINAPI CtlGetLddPath ( LOGDISKID, LPSTR );
RETERR WINAPI CtlSetLddPath ( LOGDISKID, LPSTR );


/***************************************************************************/
//
// Virtual File Copy definitions
//
/***************************************************************************/


typedef DWORD LPEXPANDVTBL;         /* ISSUE-2002/01/16-roelfc -- clean this up */

enum _ERR_VCP
{
    ERR_VCP_IOFAIL = (VCP_ERROR + 1),       // File I/O failure
    ERR_VCP_STRINGTOOLONG,                  // String length limit exceeded
    ERR_VCP_NOMEM,                          // Insufficient memory to comply
    ERR_VCP_NOVHSTR,                        // No string handles available
    ERR_VCP_OVERFLOW,                       // Reference count would overflow
    ERR_VCP_BADARG,                         // Invalid argument to function
    ERR_VCP_UNINIT,                         // String library not initialized
    ERR_VCP_NOTFOUND ,                      // String not found in string table
    ERR_VCP_BUSY,                           // Can't do that now
    ERR_VCP_INTERRUPTED,                    // User interrupted operation
    ERR_VCP_BADDEST,                        // Invalid destination directory
    ERR_VCP_SKIPPED,                        // User skipped operation
    ERR_VCP_IO,                             // Hardware error encountered
    ERR_VCP_LOCKED,                         // List is locked
    ERR_VCP_WRONGDISK,                      // The wrong disk is in the drive
    ERR_VCP_CHANGEMODE,                     //
    ERR_VCP_LDDINVALID,                // Logical Disk ID Invalid.
    ERR_VCP_LDDFIND,                   // Logical Disk ID not found.
    ERR_VCP_LDDUNINIT,                 // Logical Disk Descriptor Uninitialized.
    ERR_VCP_LDDPATH_INVALID,
    ERR_VCP_NOEXPANSION,                // Failed to load expansion dll
    ERR_VCP_NOTOPEN,                    // Copy session not open
};


/*****************************************************************************
 *              Structures
 *****************************************************************************/

/*---------------------------------------------------------------------------*
 *                  VCPPROGRESS
 *---------------------------------------------------------------------------*/

typedef struct tagVCPPROGRESS { /* prg */
    DWORD   dwSoFar;            /* Number of units copied so far */
    DWORD   dwTotal;            /* Number of units to copy */
} VCPPROGRESS, FAR *LPVCPPROGRESS;

/*---------------------------------------------------------------------------*
 *                  VCPDISKINFO
 *---------------------------------------------------------------------------*/

/*  ISSUE-2002/01/16-roelfc:                                       ;Internal
 *  I currently don't use wVolumeTime, wVolumeDate or              ;Internal
 *  dwSerialNumber.  We may not want to use dwSerialNumber because ;Internal
 *  it means that any disk other than the factory originals will be;Internal
 *  suspected of being tampered with, since the serial number      ;Internal
 *  won't match.  Similar with the time/date stamp on the          ;Internal
 *  volume label.  Or maybe that's what we want to do.             ;Internal
 */                                                             /* ;Internal */
                                                                /* ;Internal */

typedef struct tagVCPDISKINFO {
    WORD        cbSize;         /* Size of this structure in bytes */
    LOGDISKID   ldid;           /* Logical disk ID */
    VHSTR       vhstrRoot;      /* Location of root directory */
    VHSTR       vhstrVolumeLabel;/* Volume label */
    VHSTR       vhstrDiskName;  // Printed name on the disk.
    WORD        wVolumeTime;    /* Volume label modification time */
    WORD        wVolumeDate;    /* Volume label modification date */
    DWORD       dwSerialNumber; /* Disk serial number */
    WORD        fl;             /* Flags */
    LPARAM      lparamRef;      /* Reference data for client */

    VCPPROGRESS prgFileRead;    /* Progress info */
    VCPPROGRESS prgByteRead;

    VCPPROGRESS prgFileWrite;
    VCPPROGRESS prgByteWrite;

} VCPDISKINFO, FAR *LPVCPDISKINFO;

#define VDIFL_VALID     0x0001  /* Fields are valid from a prev. call */
#define VDIFL_EXISTS    0x0002  /* Disk exists; do not format */

RETERR WINAPI DiskInfoFromLdid(LOGDISKID ldid, LPVCPDISKINFO lpdi);


/*---------------------------------------------------------------------------*
 *                  VCPFILESPEC
 *---------------------------------------------------------------------------*/

typedef struct tagVCPFILESPEC { /* vfs */
    LOGDISKID   ldid;           /* Logical disk */
    VHSTR       vhstrDir;       /* Directory withing logical disk */
    VHSTR       vhstrFileName;  /* Filename within directory */
} VCPFILESPEC, FAR *LPVCPFILESPEC;

/*---------------------------------------------------------------------------*
 *              VCPFATTR
 *---------------------------------------------------------------------------*/

/*
 * ISSUE-2002/01/16-roelfc -- explain diffce between llenIn and llenOut wrt compression.
 */
typedef struct tagVCPFATTR {
    UINT    uiMDate;            /* Modification date */
    UINT    uiMTime;            /* Modification time */
    UINT    uiADate;            /* Access date */
    UINT    uiATime;            /* Access time */
    UINT    uiAttr;             /* File attribute bits */
    DWORD   llenIn;             /* Original file length */
    DWORD   llenOut;            /* Final file length */
                                /* (after decompression) */
} VCPFATTR, FAR *LPVCPFATTR;

/*---------------------------------------------------------------------------*
 *                  VIRTNODEEX
 *---------------------------------------------------------------------------*/
typedef struct tagVIRTNODEEX
{    /* vnex */
    HFILE           hFileSrc;
    HFILE           hFileDst;
    VCPFATTR        fAttr;
    WORD            dosError;   // The first/last error encountered
    VHSTR           vhstrFileName;  // The original destination name.
    WPARAM          vcpm;   // The message that was being processed.
} VIRTNODEEX, FAR *LPCVIRTNODEEX, FAR *LPVIRTNODEEX ;


/*---------------------------------------------------------------------------*
 *                  VIRTNODE
 *---------------------------------------------------------------------------*/

/* WARNING!                                                        ;Internal
 *  All fields through but not including                           ;Internal
 *  fl are memcmp'd to determine if we have a duplicate copy       ;Internal
 *  request.                                                       ;Internal
 *                                                                 ;Internal
 *  Do not insert fields before fl unless you want them to be      ;Internal
 *  compared; conversely, if you add a new field that needs to     ;Internal
 *  be compared, make sure it goes before fl.                      ;Internal
 *                                                                 ;Internal
 *  And don't change any of the fields once Windows 4.0 ships.     ;Internal
 */                                                             /* ;Internal */
                                                                /* ;Internal */
typedef struct tagVIRTNODE {    /* vn */
    WORD            cbSize;
    VCPFILESPEC     vfsSrc;
    VCPFILESPEC     vfsDst;
    WORD            fl;
    LPARAM          lParam;
    LPEXPANDVTBL    lpExpandVtbl;
    LPVIRTNODEEX    lpvnex;
} VIRTNODE, FAR *LPCVIRTNODE, FAR *LPVIRTNODE ;


/*---------------------------------------------------------------------------*
 *              VCPDESTINFO
 *---------------------------------------------------------------------------*/

typedef struct tagVCPDESTINFO { /* destinfo */
    WORD    flDevAttr;          /* Device attributes */
    LONG    cbCapacity;         /* Disk capacity */
    WORD    cbCluster;          /* Bytes per cluster */
    WORD    cRootDir;           /* Size of root directory */
} VCPDESTINFO, FAR *LPVCPDESTINFO;

#define DIFL_FIXED      0x0001  /* Nonremoveable media */
#define DIFL_CHANGELINE 0x0002  /* Change line support */

// Now also used by the virtnode as we dont have copy nodes any more.
// #define CNFL_BACKUP             0x0001  /* This is a backup node */
#define CNFL_DELETEONFAILURE    0x0002  /* Dest should be deleted on failure */
#define CNFL_RENAMEONSUCCESS    0x0004  /* Dest needs to be renamed */
#define CNFL_CONTINUATION       0x0008  /* Dest is continued onto difft disk */
#define CNFL_SKIPPED            0x0010  /* User asked to skip file */
#define CNFL_IGNOREERRORS       0x0020  // An error has occured on this file already
#define CNFL_RETRYFILE          0x0040  // Retry the file (error ocurred)
#define CNFL_COPIED				0x0080  // Node has already been copied.

// ISSUE-2002/01/16-roelfc: verify the use and usefullness of these flags
// #define VNFL_UNIQUE          0x0000  /* Default */
#define VNFL_MULTIPLEOK         0x0100  /* Do not search PATH for duplicates */
#define VNFL_DESTROYOLD         0x0200  /* Do not back up files */
// #define VNFL_NOW             0x0400  /* Use by vcp Flush */
// To deternime what kind of node it is.
#define VNFL_COPY			    0x0000  // A simple copy node.
#define VNFL_DELETE             0x0800  // A delete node
#define VNFL_RENAME             0x1000  // A rename node
#define VNFL_NODE_TYPE		    ( VNFL_RENAME|VNFL_DELETE|VNFL_COPY )
    /* Read-only flag bits */
#define VNFL_CREATED            0x2000  /* VCPM_NODECREATE has been sent */
#define VNFL_REJECTED           0x4000  /* Node has been rejected */

#define VNFL_DEVICEINSTALLER    0x8000     /* Node was added by the Device Installer */

#define VNFL_VALIDVQCFLAGS      0xff00  /* ;Internal */

/*---------------------------------------------------------------------------*
 *                  VCPSTATUS
 *---------------------------------------------------------------------------*/

typedef struct tagVCPSTATUS {   /* vstat */
    WORD    cbSize;             /* Size of this structure */

    VCPPROGRESS prgDiskRead;
    VCPPROGRESS prgFileRead;
    VCPPROGRESS prgByteRead;

    VCPPROGRESS prgDiskWrite;
    VCPPROGRESS prgFileWrite;
    VCPPROGRESS prgByteWrite;

    LPVCPDISKINFO lpvdiIn;      /* Current input disk */
    LPVCPDISKINFO lpvdiOut;     /* Current output disk */
    LPVIRTNODE    lpvn;            /* Current file */

} VCPSTATUS, FAR *LPVCPSTATUS;

/*---------------------------------------------------------------------------*
 *                  VCPVERCONFLICT
 *---------------------------------------------------------------------------*/

typedef struct tagVCPVERCONFLICT {

    LPCSTR  lpszOldFileName;
    LPCSTR  lpszNewFileName;
    DWORD   dwConflictType;     /* Same values as VerInstallFiles */
    LPVOID  lpvinfoOld;         /* Version information resources */
    LPVOID  lpvinfoNew;
    WORD    wAttribOld;         /* File attributes for original */
    LPARAM  lparamRef;          /* Reference data for callback */

} VCPVERCONFLICT, FAR *LPVCPVERCONFLICT;

/*****************************************************************************
 *              Callback functions
 *****************************************************************************/

typedef LRESULT (CALLBACK *VIFPROC)(LPVOID lpvObj, UINT uMsg, WPARAM wParam, LPARAM lParam, LPARAM lparamRef);

LRESULT CALLBACK vcpDefCallbackProc(LPVOID lpvObj, UINT uMsg, WPARAM wParam, LPARAM lParam, LPARAM lparamRef);

// callback for default UI.
// lparamRef --> a VCPUIINFO structure
LRESULT CALLBACK vcpUICallbackProc(LPVOID lpvObj, UINT uMsg, WPARAM wParam, LPARAM lParam, LPARAM lparamRef);


/*---------------------------------------------------------------------------*
 *                  VCPUIINFO
 *
 * This structure is passed in as the lparamRef of vcpUICallbackProc.
 *
 * on using vcpUICallbackProc:
 * - to use, have vcpUICallbackProc as the callback for vcpOpen with
 *   an appropriately filled in VCPUIINFO structure as the lparamRef.
 *
 * - based on flags, hwndProgress is created and maintained
 * - lpfnStatCallback is called with only status messages
 *     returning VCPM_ABORT indicates that the copy should be aborted
 * - if hwndProgress is non-NULL, the control with idProgress will
 *     receive progress gauge messages as appropriate
 *
 *---------------------------------------------------------------------------*/
#define VCPUI_CREATEPROGRESS 0x0001 // callback should create and manage progress gauge dialog
#define VCPUI_NOBROWSE       0x0002 // no browse button in InsertDisk
#define VCPUI_RENAMEREQUIRED 0x0004 // as a result of a file being in use at copy, reboot required

typedef struct {
    UINT flags;
    HWND hwndParent;            // window of parent
    HWND hwndProgress;          // window to get progress updates (nonzero ids)
    UINT idPGauge;              // id for progress gauge
    VIFPROC lpfnStatCallback;   // callback for status info (or NULL)
    LPARAM lUserData;           // caller definable data
    LOGDISKID ldidCurrent;      // reserved.  do not touch.
} VCPUIINFO, FAR *LPVCPUIINFO;

/******************************************************************************
 *          Callback notification codes
 *****************************************************************************/

/* ISSUE-2002/01/16-roelfc -- VCPN_ABORT should match VCPERROR_INTERRUPTED */

#define VCPN_OK         0       /* All is hunky-dory */
#define VCPN_PROCEED        0   /* The same as VCPN_OK */

#define VCPN_ABORT      (-1)    /* Cancel current operation */
#define VCPN_RETRY      (-2)    /* Retry current operation */
#define VCPN_IGNORE     (-3)    /* Ignore error and continue */
#define VCPN_SKIP       (-4)    /* Skip this file and continue */
#define VCPN_FORCE      (-5)    /* Force an action */
#define VCPN_DEFER      (-6)    /* Save the action for later */
#define VCPN_FAIL       (-7)    /* Return failure back to caller */
#define VCPN_RETRYFILE  (-8)    // An error ocurred during file copy, do it again.

/*****************************************************************************
 *          Callback message numbers
 *****************************************************************************/

#define VCPM_CLASSOF(uMsg)  HIBYTE(uMsg)
#define VCPM_TYPEOF(uMsg)   (0x00FF & (uMsg))   // LOBYTE(uMsg)

/*---------------------------------------------------------------------------*
 *          ERRORs
 *---------------------------------------------------------------------------*/

#define VCPM_ERRORCLASSDELTA    0x80
#define VCPM_ERRORDELTA         0x8000      /* Where the errors go */

/*---------------------------------------------------------------------------*
 *          Disk information callbacks
 *---------------------------------------------------------------------------*/

#define VCPM_DISKCLASS      0x01
#define VCPM_DISKFIRST      0x0100
#define VCPM_DISKLAST       0x01FF

enum tagVCPM_DISK {

    VCPM_DISKCREATEINFO = VCPM_DISKFIRST,
    VCPM_DISKGETINFO,
    VCPM_DISKDESTROYINFO,
    VCPM_DISKPREPINFO,

    VCPM_DISKENSURE,
    VCPM_DISKPROMPT,

    VCPM_DISKFORMATBEGIN,
    VCPM_DISKFORMATTING,
    VCPM_DISKFORMATEND,

    /* Remaining messages reserved for future use */
};

/*---------------------------------------------------------------------------*
 *          File copy callbacks
 *---------------------------------------------------------------------------*/

// ISSUE-2002/01/16-roelfc: this needs to be merged back with other internal errors
#define VCPERROR_IO         (VCP_ERROR - ERR_VCP_IO)            /* Hardware error encountered */

#define VCPM_FILEINCLASS    0x02
#define VCPM_FILEOUTCLASS   0x03
#define VCPM_FILEFIRSTIN    0x0200
#define VCPM_FILEFIRSTOUT   0x0300
#define VCPM_FILELAST       0x03FF

enum tagVCPM_FILE {
    VCPM_FILEOPENIN = VCPM_FILEFIRSTIN,
    VCPM_FILEGETFATTR,
    VCPM_FILECLOSEIN,
    VCPM_FILECOPY,
    VCPM_FILENEEDED,

    VCPM_FILEOPENOUT = VCPM_FILEFIRSTOUT,
    VCPM_FILESETFATTR,
    VCPM_FILECLOSEOUT,
    VCPM_FILEFINALIZE,
    VCPM_FILEDELETE,
    VCPM_FILERENAME,
    /* Remaining messages reserved for future use */
};

/*---------------------------------------------------------------------------*
 *          VIRTNODE callbacks
 *---------------------------------------------------------------------------*/

#define VCPM_NODECLASS  0x04
#define VCPM_NODEFIRST  0x0400
#define VCPM_NODELAST   0x04FF

enum tagVCPM_NODE {
    VCPM_NODECREATE = VCPM_NODEFIRST,
    VCPM_NODEACCEPT,
    VCPM_NODEREJECT,
    VCPM_NODEDESTROY,
    VCPM_NODECHANGEDESTDIR,
    VCPM_NODECOMPARE,
    /* Remaining messages reserved for future use */
};

/*---------------------------------------------------------------------------*
 *          TALLY callbacks
 *---------------------------------------------------------------------------*/

#define VCPM_TALLYCLASS     0x05
#define VCPM_TALLYFIRST     0x0500
#define VCPM_TALLYLAST      0x05FF

enum tagVCPM_TALLY {
    VCPM_TALLYSTART = VCPM_TALLYFIRST,
    VCPM_TALLYEND,
    VCPM_TALLYFILE,
    VCPM_TALLYDISK,
    /* Remaining messages reserved for future use */
};

/*---------------------------------------------------------------------------*
 *          VER callbacks
 *---------------------------------------------------------------------------*/

#define VCPM_VERCLASS       0x06
#define VCPM_VERFIRST       0x0600
#define VCPM_VERLAST        0x06FF

enum tagVCPM_VER {
    VCPM_VERCHECK = VCPM_VERFIRST,
    VCPM_VERCHECKDONE,
    VCPM_VERRESOLVECONFLICT,
    /* Remaining messages reserved for future use */
};

/*---------------------------------------------------------------------------*
 *          VSTAT callbacks
 *---------------------------------------------------------------------------*/

#define VCPM_VSTATCLASS     0x07
#define VCPM_VSTATFIRST     0x0700
#define VCPM_VSTATLAST      0x07FF

enum tagVCPM_VSTAT {
    VCPM_VSTATSTART = VCPM_VSTATFIRST,
    VCPM_VSTATEND,
    VCPM_VSTATREAD,
    VCPM_VSTATWRITE,
    VCPM_VSTATNEWDISK,

    VCPM_VSTATCLOSESTART,       // Start of VCP close
    VCPM_VSTATCLOSEEND,         // upon leaving VCP close
    VCPM_VSTATBACKUPSTART,      // Backup is beginning
    VCPM_VSTATBACKUPEND,        // Backup is finished
    VCPM_VSTATRENAMESTART,      // Rename phase start/end
    VCPM_VSTATRENAMEEND,
    VCPM_VSTATCOPYSTART,        // Acutal copy phase
    VCPM_VSTATCOPYEND,
    VCPM_VSTATDELETESTART,      // Delete phase
    VCPM_VSTATDELETEEND,
    VCPM_VSTATPATHCHECKSTART,   // Check for valid paths
    VCPM_VSTATPATHCHECKEND,
    VCPM_VSTATUSERABORT,        // User wants to quit.
    VCPM_VSTATYIELD,            // Do a yield.
    /* Remaining messages reserved for future use */
};

/*---------------------------------------------------------------------------*
 *          Destination info callbacks
 *---------------------------------------------------------------------------*/

/* ISSUE-2002/01/16-roelfc -- find a reasonable message range for this */
#define VCPM_PATHCLASS      0x08
#define VCPM_PATHFIRST      0x0800
#define VCPM_PATHLAST       0x08FF

enum tagVCPM_PATH{
    VCPM_BUILDPATH = VCPM_PATHFIRST,
    VCPM_UNIQUEPATH,
    VCPM_CHECKPATH,
};

// #define VCPM_BUILDPATH      0x83

/*****************************************************************************/
void WINAPI VcpAddMRUPath( LPCSTR lpszPath );
#define SZ_INSTALL_LOCATIONS "InstallLocationsMRU"


RETERR WINAPI VcpOpen(VIFPROC vifproc, LPARAM lparamMsgRef);

RETERR WINAPI VcpClose(WORD fl, LPCSTR lpszBackupDest);

RETERR WINAPI VcpFlush(WORD fl, LPCSTR lpszBackupDest);

#define VCPFL_ABANDON           0x0000  /* Abandon all pending file copies */
#define VCPFL_BACKUP            0x0001  /* Perform backup */
#define VCPFL_COPY              0x0002  /* Copy files */
#define VCPFL_BACKUPANDCOPY     (VCPFL_BACKUP | VCPFL_COPY)
#define VCPFL_INSPECIFIEDORDER  0x0004  /* Do not sort before copying */
#define VCPFL_DELETE            0x0008
#define VCPFL_RENAME            0x0010
#define VCPFL_ALL	        (VCPFL_COPY | VCPFL_DELETE | VCPFL_RENAME)

typedef int (CALLBACK *VCPENUMPROC)(LPVIRTNODE lpvn, LPARAM lparamRef);

int WINAPI vcpEnumFiles(VCPENUMPROC vep, LPARAM lparamRef);

enum tag_VCPM_EXPLAIN{
    VCPEX_SRC_DISK,
    VCPEX_SRC_CABINET,
    VCPEX_SRC_LOCN,
    VCPEX_DST_LOCN,
    VCPEX_SRC_FILE,
    VCPEX_DST_FILE,
    VCPEX_DOS_ERROR,
    VCPEX_MESSAGE,
    VCPEX_DOS_SOLUTION,
    VCPEX_SRC_FULL,
    VCPEX_DST_FULL,
};

LPCSTR WINAPI VcpExplain( LPVIRTNODE lpVn, DWORD dwWhat );

/* Flag bits that can be set via VcpQueueCopy */


// Various Lparams for files
#define VNLP_SYSCRITICAL    0x0001  // This file should not be skipped
#define VNLP_SETUPCRITICAL  0x0002  // This file cannot be skipped
#define VNLP_NOVERCHECK     0x0004  // This file must not be VerResolved.
#define VNLP_FORCETEMP      0x0008  // This file must left as a temp name
#define VNLP_IFEXISTS       0x0010  // File skipped if already on machine
#define VNLP_KEEPNEWER      0x0020  // If the dest file is newer - keep it (frosting)

// VcpEnumFiles Flags.

#define VEN_OP      0x00ff      /* Operation field */

#define VEN_NOP     0x0000      /* Do nothing */
#define VEN_DELETE  0x0001      /* Delete current item */
#define VEN_SET     0x0002      /* Change value of current item */
#define VEN_ADVANCE 0x0003      /* Move to head of list */      /* ;Internal */

#define VEN_FL      0xff00      /* Flags field */

#define VEN_STOP    0x0100      /* Stop enumeration after this item */
#define VEN_ERROR   0x8000      /* Stop enumeration after this item
                                 * and ignore the OP field */



// ISSUE-2002/01/16-roelfc: add the other VCP stuff necessary to use this

// ISSUE-2002/01/16-roelfc: remove the lpsz*Dir fields, make overload the LDID with them

RETERR WINAPI VcpQueueCopy(LPCSTR lpszSrcFileName, LPCSTR lpszDstFileName,
                LPCSTR lpszSrcDir, LPCSTR lpszDstDir,
                LOGDISKID ldidSrc, LOGDISKID ldidDst,
                LPEXPANDVTBL lpExpandVtbl, WORD fl,
                LPARAM lParam);

RETERR WINAPI VcpQueueDelete( LPCSTR lpszDstFileName,
                              LPCSTR lpszDstDir,
                              LOGDISKID ldidDst,
                              LPARAM lParamRef );

RETERR WINAPI VcpQueueRename( LPCSTR      lpszSrcFileName,
                            LPCSTR      lpszDstFileName,
                            LPCSTR      lpszSrcDir,
                            LPCSTR      lpszDstDir,
                            LOGDISKID   ldidSrc,
                            LOGDISKID   ldidDst,
                            LPARAM      lParam );

#endif // NOVCP



#ifndef NOINF
/***************************************************************************/
//
// Inf Parser API declaration and definitions
//
/***************************************************************************/

enum _ERR_IP
{
    ERR_IP_INVALID_FILENAME = (IP_ERROR + 1),
    ERR_IP_ALLOC_ERR,
    ERR_IP_INVALID_SECT_NAME,
    ERR_IP_OUT_OF_HANDLES,
    ERR_IP_INF_NOT_FOUND,
    ERR_IP_INVALID_INFFILE,
    ERR_IP_INVALID_HINF,
    ERR_IP_INVALID_FIELD,
    ERR_IP_SECT_NOT_FOUND,
    ERR_IP_END_OF_SECTION,
    ERR_IP_PROFILE_NOT_FOUND,
    ERR_IP_LINE_NOT_FOUND,
    ERR_IP_FILEREAD,
    ERR_IP_TOOMANYINFFILES,
    ERR_IP_INVALID_SAVERESTORE,
    ERR_IP_INVALID_INFTYPE
};

#define INFTYPE_TEXT                0
#define INFTYPE_EXECUTABLE          1

#define MAX_SECT_NAME_LEN    32

typedef struct _INF NEAR * HINF;
typedef struct _INFLINE FAR * HINFLINE;            // tolken to inf line

RETERR  WINAPI IpOpen(LPCSTR pszFileSpec, HINF FAR * lphInf);
RETERR  WINAPI IpOpenEx(LPCSTR pszFileSpec, HINF FAR * lphInf, UINT InfType);
RETERR  WINAPI IpOpenAppend(LPCSTR pszFileSpec, HINF hInf);
RETERR  WINAPI IpOpenAppendEx(LPCSTR pszFileSpec, HINF hInf, UINT InfType);
RETERR  WINAPI IpSaveRestorePosition(HINF hInf, BOOL bSave);
RETERR  WINAPI IpClose(HINF hInf);
RETERR  WINAPI IpGetLineCount(HINF hInf, LPCSTR lpszSection, int FAR * lpCount);
RETERR  WINAPI IpFindFirstLine(HINF hInf, LPCSTR lpszSect, LPCSTR lpszKey, HINFLINE FAR * lphRet);
RETERR  WINAPI IpFindNextLine(HINF hInf, HINFLINE FAR * lphRet);
RETERR  WINAPI IpFindNextMatchLine(HINF hInf, LPCSTR lpszKey, HINFLINE FAR * lphRet);
RETERR  WINAPI IpGetProfileString(HINF hInf, LPCSTR lpszSec, LPCSTR lpszKey, LPSTR lpszBuf, int iBufSize);
RETERR  WINAPI IpGetFieldCount(HINF hInf, HINFLINE hInfLine, int FAR * lpCount);
RETERR  WINAPI IpGetFileName(HINF hInf, LPSTR lpszBuf, int iBufSize);
RETERR  WINAPI IpGetIntField(HINF hInf, HINFLINE hInfLine, int iField, int FAR * lpVal);
RETERR  WINAPI IpGetLongField(HINF hInf, HINFLINE hInfLine, int iField, long FAR * lpVal);
RETERR  WINAPI IpGetStringField(HINF hInf, HINFLINE hInfLine, int iField, LPSTR lpBuf, int iBufSize, int FAR * lpuCount);
RETERR  WINAPI IpGetVersionString(LPSTR lpszInfFile, LPSTR lpszValue, LPSTR lpszBuf, int cbBuf, LPSTR lpszDefaultValue);

#endif // NOINF



#ifndef NOTEXTPROC
/***************************************************************************/
//
// Text processing API declaration and definitions
//
/***************************************************************************/

/* Relative/absolute positioning */
#define SEC_SET 1       // Absolute positioning (relative to the start)
#define SEC_END 2       // Realtive to the end
#define SEC_CUR 3       // Relative to the current line.

#define SEC_OPENALWAYS          1   // Always open a section, no error if it does not exist
#define SEC_OPENEXISTING        2   // Open an existing section, an error given if it does not exist.
#define SEC_OPENNEWALWAYS       3   // Open a section (present or not) and discard its contents.
#define SEC_OPENNEWEXISTING     4   // Open an existing section (discarding its contents). Error if not existing

// Flags for TP_OpenFile().
//
  // Use autoexec/config.sys key delimiters
  //
#define TP_WS_KEEP      1

  // If TP code running under SETUP, the foll. flag specifies whether
  // to cache this file or not! Use this, if you want to read a whole
  // file in when doing the TpOpenSection()!
  //
#define TP_WS_DONTCACHE 2

// The following are simple errors
enum {
    ERR_TP_NOT_FOUND = (TP_ERROR + 1),  // line, section, file etc.
                    // not necessarily terminal
    ERR_TP_NO_MEM,      // couldn't perform request - generally terminal
    ERR_TP_READ,        // could not read the disc - terminal
    ERR_TP_WRITE,       // could not write the data - terminal.
    ERR_TP_INVALID_REQUEST, // Multitude of sins - not necessarily terminal.
    ERR_TP_INVALID_LINE         // Invalid line from DELETE_LINE etc.
};

/* Data handles */
DECLARE_HANDLE(HTP);
typedef HTP FAR * LPHTP;

/* File handles */
DECLARE_HANDLE(HFN);
typedef HFN FAR * LPHFN;

typedef UINT TFLAG;
typedef UINT LINENUM, FAR * LPLINENUM;

#define MAX_REGPATH     256     // Max Registry Path Length
#define LINE_LEN        256     // ISSUE-2002/01/16-roelfc: max line length?
#define SECTION_LEN     32      // ISSUE-2002/01/16-roelfc: max length of a section name?
#define MAX_STRING_LEN  512     // ISSUE-2002/01/16-roelfc: review this

/* Function prototypes */
RETERR  WINAPI TpOpenFile(LPCSTR Filename, LPHFN phFile, TFLAG Flag);
RETERR  WINAPI TpCloseFile(HFN hFile);
RETERR  WINAPI TpOpenSection(HFN hfile, LPHTP phSection, LPCSTR Section, TFLAG flag);
RETERR  WINAPI TpCloseSection(HTP Section);
RETERR  WINAPI TpCommitSection(HFN hFile, HTP hSection, LPCSTR Section, TFLAG flag);
LINENUM WINAPI TpGetLine(HTP hSection, LPCSTR key, LPCSTR value, int rel, int orig, LPLINENUM lpLineNum );
LINENUM WINAPI TpGetNextLine(HTP hSection, LPCSTR key, LPCSTR value, LPLINENUM lpLineNum );
RETERR  WINAPI TpInsertLine(HTP hSection, LPCSTR key, LPCSTR value, int rel, int orig, TFLAG flag);
RETERR  WINAPI TpReplaceLine(HTP hSection, LPCSTR key, LPCSTR value, int rel, int orig, TFLAG flag);
RETERR  WINAPI TpDeleteLine(HTP hSection, int rel, int orig,TFLAG flag);
RETERR  WINAPI TpMoveLine(HTP hSection, int src_rel, int src_orig, int dest_rel, int dest_orig, TFLAG flag);
RETERR  WINAPI TpGetLineContents(HTP hSection, LPSTR buffer, UINT bufsize, UINT FAR * lpActualSize,int rel, int orig, TFLAG flag);

// UINT    WINAPI TpGetWindowsDirectory(LPSTR lpDest, UINT size);
// UINT    WINAPI TpGetSystemDirectory(LPSTR lpDest, UINT size);

int  WINAPI TpGetPrivateProfileString(LPCSTR lpszSect, LPCSTR lpszKey, LPCSTR lpszDefault, LPSTR lpszReturn, int nSize, LPCSTR lpszFile);
int  WINAPI TpWritePrivateProfileString(LPCSTR lpszSect, LPCSTR lpszKey, LPCSTR lpszString, LPCSTR lpszFile);
int  WINAPI TpGetProfileString(LPCSTR lpszSect, LPCSTR lpszKey, LPCSTR lpszDefault, LPSTR lpszReturn, int nSize);
BOOL WINAPI TpWriteProfileString(LPCSTR lpszSect , LPCSTR lpszKey , LPCSTR lpszString);

#endif // NOTEXTPROC



#ifndef NOGENINSTALL
/***************************************************************************/
//
// Generic Installer prototypes and definitions
//
/***************************************************************************/

enum _ERR_GENERIC
{
    ERR_GEN_LOW_MEM = GEN_ERROR+1,  // Insufficient memory.
    ERR_GEN_INVALID_FILE,           // Invalid INF file.
    ERR_GEN_LOGCONFIG,              // Can't process LogConfig=.
    ERR_GEN_CFGAUTO,                // Can't process CONFIG.SYS/AUTOEXEC.BAT
    ERR_GEN_UPDINI,                 // Can't process UpdateInis=.
    ERR_GEN_UPDINIFIELDS,           // Can't process UpdateIniFields=.
    ERR_GEN_ADDREG,                 // Can't process AddReg=.
    ERR_GEN_DELREG,                 // Can't process DelReg=.
    ERR_GEN_INI2REG,                // Can't process Ini2Reg=.
    ERR_GEN_FILE_COPY,              // Can't process CopyFiles=.
    ERR_GEN_FILE_DEL,               // Can't process DelFiles=.
    ERR_GEN_FILE_REN,               // Can't process RenFiles=.
    ERR_GEN_REG_API,                // Error returned by Reg API.
    ERR_GEN_DO_FILES,               // can't do Copy, Del or RenFiles.
};

// The cbSize field will always be set to sizeof(GENCALLBACKINFO_S).
// All unused fields (for the operation) will be not be initialized.
// For example, when the operation is GENO_DELFILE, the Src fields will
// not have any sensible values (Dst fields will be set correctly) as
// VcpQueueDelete only accepts Dst parameters.
//
/***************************************************************************
 * GenCallbackINFO structure passed to GenInstall CallBack functions.
 ***************************************************************************/
typedef struct _GENCALLBACKINFO_S { /* gen-callback struc */
    WORD         cbSize;                 // Size of this structure (bytes).
    WORD         wOperation;             // Operation being performed.
    LOGDISKID    ldidSrc;                // Logical Disk ID for Source.
    LPCSTR       pszSrcSubDir;           // Source sub-dir off of the LDID.
    LPCSTR       pszSrcFileName;         // Source file name (base name).
    LOGDISKID    ldidDst;                // Logical Disk ID for Dest.
    LPCSTR       pszDstSubDir;           // Dest. sub-dir off of the LDID.
    LPCSTR       pszDstFileName;         // Dest. file name (base name).
    LPEXPANDVTBL lpExpandVtbl;           // ISSUE-2002/01/16-roelfc: Needed? NULL right now!
    WORD         wflags;                 // flags for VcpQueueCopy.
    LPARAM       lParam;                 // LPARAM to the Vcp API.
} GENCALLBACKINFO_S, FAR *LPGENCALLBACKINFO;

/***************************************************************************
 * GenCallback notification codes -- callback proc returns 1 of foll. values.
 ***************************************************************************/
#define GENN_OK         0       /* All is hunky-dory. Do the VCP operation */
#define GENN_PROCEED    0       /* The same as GENN_OK */

#define GENN_ABORT      (-1)    /* Cancel current GenInstall altogether */
#define GENN_SKIP       (-2)    /* Skip this file and continue */

/***************************************************************************
 * VCP Operation being performed by GenInstall() -- wOperation values in
 * GENCALLBACKINFO structure above.
 ***************************************************************************/
#define GENO_COPYFILE   1       /* VCP copyfile being done */
#define GENO_DELFILE    2       /* VCP delfile being done */
#define GENO_RENFILE    3       /* VCP renfile being done */


typedef LRESULT (CALLBACK *GENCALLBACKPROC)(LPGENCALLBACKINFO lpGenInfo,
                                                            LPARAM lparamRef);

RETERR WINAPI GenInstall( HINF hinfFile, LPCSTR szInstallSection, WORD wFlags );
RETERR WINAPI GenInstallEx( HINF hInf, LPCSTR szInstallSection, WORD wFlags,
                                HKEY hRegKey, GENCALLBACKPROC CallbackProc,
                                LPARAM lparam);
RETERR WINAPI GenWinInitRename(LPCSTR szNew, LPSTR szOld, LOGDISKID ldid);
RETERR WINAPI GenCopyLogConfig2Reg(HINF hInf, HKEY hRegKey,
                                                LPCSTR szLogConfigSection);
void   WINAPI GenFormStrWithoutPlaceHolders( LPSTR szDst, LPCSTR szSrc,
                                                                HINF hInf ) ;
// Flags for GenAddReg() from INf /GenSURegSetValueEx()
//
#define FLG_ADDREG_BINVALUETYPE  1
#define FLG_ADDREG_NOCLOBBER     2
#define FLG_ADDREG_DELVAL        4

RETERR WINAPI GenSURegSetValueEx(HKEY hkeyRoot, LPCSTR szSubKey,
                         LPCSTR lpszValueName, DWORD dwValType,
                         LPBYTE lpszValue, DWORD dwValSize, UINT uFlags );

// A devnode is just a DWORD and this is easier than
// having to include configmg.h for everybody
RETERR WINAPI GenInfLCToDevNode(ATOM atInfFileName, LPSTR lpszSectionName,
                                BOOL bInstallSec, UINT InfType, 
                                DWORD dnDevNode);

// Bit fields for GenInstall() (for wFlags parameter) -- these can be OR-ed!
#define GENINSTALL_DO_FILES     1
#define GENINSTALL_DO_INI       2
#define GENINSTALL_DO_REG       4
#define GENINSTALL_DO_INI2REG   8
#define GENINSTALL_DO_CFGAUTO   16
#define GENINSTALL_DO_LOGCONFIG 32
#define GENINSTALL_DO_INIREG    (GENINSTALL_DO_INI | \
                                 GENINSTALL_DO_REG | \
                                 GENINSTALL_DO_INI2REG)
#define GENINSTALL_DO_ALL       (GENINSTALL_DO_FILES | \
                                    GENINSTALL_DO_INIREG | \
                                    GENINSTALL_DO_CFGAUTO | \
                                    GENINSTALL_DO_LOGCONFIG)

#endif // NOGENINSTALL



#ifndef NODEVICENSTALL
/***************************************************************************/
//
// Device Installer prototypes and definitions
//
/***************************************************************************/

/*******************************************************************************
*   AUTODOC
*   @doc    EXTERNAL SETUPX DEVICE_INSTALLER
*
*   @typee    _ERR_DEVICE_INSTALL | Error return codes for Device Installation
*   APIs.
*
*   @emem ERR_DI_INVALID_DEVICE_ID | Incorrectly formed device ID.
*
*   @emem ERR_DI_INVALID_COMPATIBLE_DEVICE_LIST | Invalid compatible device list.
*
*   @emem ERR_DI_REG_API | Error returned by one of the registry API.
*
*   @emem ERR_DI_LOW_MEM | Insufficient memory to complete.
*
*   @emem ERR_DI_BAD_DEV_INFO | A passed in DEVICE_INFO struct is invalid.
*
*   @emem ERR_DI_INVALID_CLASS_INSTALLER | The class installer is listed incorrecrly
*   in the registry, or points to an invalid class installer.
*
*   @emem ERR_DI_DO_DEFAULT | Do the default action for the requested operation.
*
*   @emem ERR_DI_USER_CANCEL | The user cancelled the operation.
*
*   @emem ERR_DI_NOFILECOPY | No need to copy files (in install).
*
*   @emem ERR_DI_BAD_CLASS_INFO | A passed in CLASS_INFO struct is invalid.
*
*   @emem ERR_DI_BAD_INF | An invalid INF file was encountered.
*
*   @emem ERR_DI_BAD_MOVEDEV_PARAMS | A passed in MOVEDEVICE_PARAMS struct was
*   invalid.
*
*   @emem ERR_DI_NO_INF | No INF found on supplied OEM path.
*
*   @emem ERR_DI_BAD_PROPCHANGE_PARAMS | A passed in PROPCHANGE_PARMS struct was
*   invalid.
*
*   @emem ERR_DI_BAD_SELECTDEVICE_PARAMS | A passed in SELECTEDEVICE_PARAMS struct
*   was invalid.
*
*   @emem ERR_DI_BAD_REMOVEDEVICE_PARAMS | A passed in REMOVEDEVICE_PARAMS struct
*   was invalid.
*
*   @emem ERR_DI_BAD_ENABLECLASS_PARAMS | A passed in ENABLECLASS_PARAMS struct
*   was invalid.
*
*   @emem ERR_DI_FAIL_QUERY | The queried action should not take place.
*
*   @emem ERR_DI_API_ERROR | One of the Device installation APIs was called
*   incorrectly or with invalid parameters.
*
*   @emem ERR_DI_BAD_PATH | An OEM path was specified incorrectly.
*
*******************************************************************************/
enum _ERR_DEVICE_INSTALL
{
    ERR_DI_INVALID_DEVICE_ID = DI_ERROR,    // Incorrectly formed device IDF
    ERR_DI_INVALID_COMPATIBLE_DEVICE_LIST,  // Invalid compatible device list
    ERR_DI_REG_API,                         // Error returned by Reg API.
    ERR_DI_LOW_MEM,                         // Insufficient memory to complete
    ERR_DI_BAD_DEV_INFO,                    // Device Info struct invalid
    ERR_DI_INVALID_CLASS_INSTALLER,         // Registry entry / DLL invalid
    ERR_DI_DO_DEFAULT,                      // Take default action
    ERR_DI_USER_CANCEL,                     // the user cancelled the operation
    ERR_DI_NOFILECOPY,                      // No need to copy files (in install)
    ERR_DI_BAD_CLASS_INFO,                  // Class Info Struct invalid
    ERR_DI_BAD_INF,                         // Bad INF file encountered
    ERR_DI_BAD_MOVEDEV_PARAMS,	            // Bad Move Device Params struct
    ERR_DI_NO_INF,                          // No INF found on OEM disk
    ERR_DI_BAD_PROPCHANGE_PARAMS,           // Bad property change param struct
    ERR_DI_BAD_SELECTDEVICE_PARAMS,         // Bad Select Device Parameters
    ERR_DI_BAD_REMOVEDEVICE_PARAMS,         // Bad Remove Device Parameters
    ERR_DI_BAD_ENABLECLASS_PARAMS,          // Bad Enable Class Parameters
    ERR_DI_FAIL_QUERY,                      // Fail the Enable Class query
    ERR_DI_API_ERROR,                       // DI API called incorrectly
    ERR_DI_BAD_PATH,                        // An OEM path was specified incorrectly
};

/*******************************************************************************
*   AUTODOC
*   @doc    EXTERNAL SETUPX DEVICE_INSTALLER
*
*   @types    DRIVER_INFO | This structure contains the information necessary
*   to present the user with a select device dialog.
*
*   @field WORD | cbSize | Size of this structure in bytes.
*
*   @field struct _DRIVER_INFO FAR | *lpNextInfo | Pointer to the next DRIVER_INFO
*   struct in a linked list.
*                 
*   @field LPSTR | lpszDescription | Pointer to the description of the device being
*   supported by this driver.
*
*   @field LPSTR | lpszMfgName | Pointer to the name of the manufacture of this
*   driver.
*
*   @field LPSTR | lpszProviderName | Pointer to provider of this driver if the
*   lpdi->Flags has the DI_MULTMFGS flag set.
*
*   @field WORD | Rank | The Rank match of this driver.  Ranks go from 0 to n, where 0 
*   is the most compatible.
*
*   @field DWORD | dwFlags | Flags that control the use of this driver node.  These
*   are the same as the flags defined for a DRIVER_NODE.
*       @flag DNF_DUPDESC           | This driver has the same device description 
*       from by more than one provider.
*       @flag DNF_OLDDRIVER         | Driver node specifies old/current driver
*       @flag DNF_EXCLUDEFROMLIST   | If set, this driver node will not be displayed
*       in any driver select dialogs.
*       @flag DNF_NODRIVER          | Set if we want to install no driver e.g no mouse drv
*
*   @field LPARAM | lpReserved | Reserved for use by the Device Installer.
*
*   @field DWORD | dwPrivateData | Reserved for use by the Device Installer.
*
*******************************************************************************/
typedef struct _DRIVER_INFO
{
    WORD                        cbSize;                     // Size of this structure in bytes
    struct _DRIVER_INFO FAR*    lpNextInfo;
    LPSTR                       lpszDescription;
    LPSTR                       lpszMfgName;
    LPSTR                       lpszProviderName;           // ONLY valid if DI_MULTMFGS is set in the LPDI
    WORD                        Rank;
    DWORD                       dwFlags;          
    LPARAM                      lpReserved;
    DWORD                       dwPrivateData;
} DRIVER_INFO, *PDRIVER_INFO, FAR *LPDRIVER_INFO;

/*******************************************************************************
*   AUTODOC
*   @doc    EXTERNAL SETUPX DEVICE_INSTALLER
*
*   @types    DRIVER_NODE | This strucure represents a driver which can be 
*   installed for a specific device.
*
*   @field struct _DRIVER_NODE FAR* | lpNextDN | Pointer to the next driver node
*   in a list.
*
*   @field UINT | Rank | The Rank match of this driver.  Ranks go from 0 to n, where 0 
*   is the most compatible.
*
*   @field UINT | InfType | Type of INF this driver cam from.  This will
*   be either INFTYPE_TEXT or INFTYPE_EXECUTABLE
*
*   @field unsigned | InfDate | DOS date stamp of the INF file.
*
*   @field LPSTR | lpszDescription | Pointer to a the descriptrion of the device being
*   supported by this driver.
*
*   @field LPSTR | lpszSectionName | Pointer to the name of INF install section for
*   this driver.
*
*   @field ATOM  | atInfFileName | Global ATOM containing the name of the INF file.
*
*   @field ATOM  | atMfgName | Global ATOM containing the name of this driver's 
*   manufacture.
*
*   @field ATOM  | atProviderName | Global ATOM containing the name of this driver's
*   provider.
*
*   @field DWORD | Flags | Flags that control functions using this DRIVER_NODE
*       @flag DNF_DUPDESC           | This driver has the same device description 
*       from by more than one provider.
*       @flag DNF_OLDDRIVER         | Driver node specifies old/current driver
*       @flag DNF_EXCLUDEFROMLIST   | If set, this driver node will not be displayed
*       in any driver select dialogs.
*       @flag DNF_NODRIVER          | Set if we want to install no driver e.g no mouse drv
*       @flag DNF_CONVERTEDLPINFO   | Set if this Driver Node was converted from an Info Node.
*       Setting this flag will cause the cleanup functions to explicitly delete it.
*
*   @field DWORD | dwPrivateData | Reserved
*
*   @field LPSTR | lpszDrvDescription | Pointer to a driver description.
*
*   @field LPSTR | lpszHardwareID | Pointer to a list of Plug-and-Play hardware IDs for 
*   this driver.
*   
*   @field LPSTR | lpszCompatIDs | Pointer to a list of Plug-and-Play compatible IDs for
*   this driver.
*
*******************************************************************************/
typedef struct _DRIVER_NODE {
    struct _DRIVER_NODE FAR* lpNextDN;
    UINT    Rank;
    UINT    InfType;
    unsigned    InfDate;
    LPSTR   lpszDescription;        // Compatibility: Contains the Device Desc.
    LPSTR   lpszSectionName;
    ATOM    atInfFileName;
    ATOM    atMfgName;
    ATOM    atProviderName;
    DWORD   Flags;
    DWORD   dwPrivateData;
    LPSTR   lpszDrvDescription;     // New contains an driver description
    LPSTR   lpszHardwareID;
    LPSTR   lpszCompatIDs;
}   DRIVER_NODE, NEAR* PDRIVER_NODE, FAR* LPDRIVER_NODE, FAR* FAR* LPLPDRIVER_NODE;

#define DNF_DUPDESC         0x00000001   // Multiple providers have same desc
#define DNF_OLDDRIVER       0x00000002   // Driver node specifies old/current driver
#define DNF_EXCLUDEFROMLIST 0x00000004  
#define DNF_NODRIVER	    0x00000008	 // if we want to install no driver e.g no mouse drv

#define DNF_CONVERTEDLPINFO 0x00000010  // Set if the Driver Node is a Converted Info Node

// possible types of "INF" files
#define INFTYPE_WIN4        1
#define INFTYPE_WIN3        2
#define INFTYPE_COMBIDRV    3
#define INFTYPE_PPD         4
#define INFTYPE_WPD     5
#define INFTYPE_CLASS_SPEC1 6
#define INFTYPE_CLASS_SPEC2 7
#define INFTYPE_CLASS_SPEC3 8
#define INFTYPE_CLASS_SPEC4 9


#define MAX_CLASS_NAME_LEN   32
#define MAX_DRIVER_INST_LEN  10

// NOTE:  Keep this in sync with confimg.h in \DDK\INC
#define MAX_DEVNODE_ID_LEN  256

/*******************************************************************************
*   AUTODOC
*   @doc    EXTERNAL SETUPX DEVICE_INSTALLER
*
*   @types    DEVICE_INFO | This is the basic data structure for most Device
*   installation APIs.  A DEVICE_INFO represents a device that is being installed
*   on the system, or an installed device that is being modified in some way.
*
*   @field UINT | cbSize | Size of the DEVICE_INFO struct.
*
*   @field struct _DEVICE_INFO FAR | *lpNextDi | Pointer to the next DEVICE_INFO struct
*   in a linked list.
*
*   @field char | szDescription[LINE_LEN] | Buffer containing the description of the 
*   device.
*
*   @field DWORD | dnDevnode | If set, this contains the address of the DevNode associated
*   with the device.
*
*   @field HKEY | hRegKey | An opened registry key that contains the device's registry
*   subkey.  This is usually HKEY_LOCAL_MACHINE.
*
*   @field char | szRegSubkey[MAX_DEVNODE_ID_LEN] | Buffer containing the device's 
*   hardware registry subkey.  This is key is rooted in hRegKey, and is ususally some 
*   place in the \\ENUM branch.
*
*   @field char | szClassName[MAX_CLASS_NAME_LEN] | Buffer containing the device's
*   class name.
*
*   @field DWORD | Flags | Flags for controlling installation and U/I functions. Some
*   flags can be set prior to calling device installer APIs, and other are set
*   automatically during the processing of some APIs.
*       @flag DI_SHOWOEM                  | Set if OEM disk support should be allowed
*       @flag DI_SHOWCOMPAT               | Will be set if only a compatible driver list
*       is being displayed by DiSelectDevice.
*       @flag DI_SHOWCLASS                | Will be set if only a Class driver list is
*       is being displayed by DiSelectDevice.
*       @flag DI_SHOWALL                  | Will be set if both a compatible driver list
*       and a class driver list are being shown by DiSelectDevice.
*       @flag DI_NOVCP                    | Set if no VCP (Virtual Copy Procedure) is 
*       desired during DiInstallDevice.
*       @flag DI_DIDCOMPAT                | Will be set if DiBuildCompatDrvList has been
*       done, and lpCompatDrvList points to this device's compatible driver list.
*       @flag DI_DIDCLASS                 | Will be set if DiBuildClassDrvList has been
*       done, and lpClassDrvList points to this device's class driver list.
*       @flag DI_AUTOASSIGNRES            | Unused.
*       @flag DI_NEEDRESTART              | Will be set if the device requires a restart
*       of Windows after installation or a state change.
*       @flag DI_NEEDREBOOT               | Will be set if the device requires a reboot
*       of the machine after installation or a state change.
*       @flag DI_NOBROWSE                 | Set to diable browsing when selecting an OEM
*       disk path.
*       @flag DI_MULTMFGS                 | Will be set if a class driver list, or class
*       info list contains multiple manufactures.
*       @flag DI_DISABLED                 | Unused.
*       @flag DI_GENERALPAGE_ADDED        | Set by a property page provider if a general
*       properties page has been added to the device's property sheet.
*       @flag DI_RESOURCEPAGE_ADDED       | Set by a property page provider if a resource
*       properties page has been added to the device's property sheet.
*       @flag DI_PROPERTIES_CHANGE        | Set if a device's properties have been changed
*       and require an update of the Device Manager's U/I.
*       @flag DI_INF_IS_SORTED            | Set if the INF containing drivers for this 
*       device is in sorted order.
*       @flag DI_ENUMSINGLEINF            | Set if DiBuildCompatDrvList and 
*       DiBuildlassDrvList should only search the INF file specificed by atDriverPath.
*       @flag DI_DONOTCALLCONFIGMG        | Set if the configuration manager should not
*       be called during DiInstallDevice.
*       @flag DI_INSTALLDISABLED          | Set if the device should be installed in a 
*       disabled state by default.
*       @flag DI_CLASSONLY                | Set if this DEVICE_INFO struct contains only
*       a class name.
*       @flag DI_CLASSINSTALLPARAMS       | Set if the lpClassIntallParams field points to
*       a class install parameter block.
*       @flag DI_NODI_DEFAULTACTION       | Set if DiCallClassInstaller should not 
*       perform any default action if the class installer return ERR_DI_DO_DEFAULT, or
*       there is not class installer.
*       @flag DI_QUIETINSTALL             | Set if device install API should be as 
*       silent as possible using default choices whereever possible.
*       @flag DI_NOFILECOPY               | Set if DiInstallDevice should skip file
*       copying.
*       @flag DI_FORCECOPY                | Set if DiInstallDevice should always
*       copy file, even if they are present on the system.
*       @flag DI_DRIVERPAGE_ADDED         | Set by a property page provider if a driver
*       properties page has been added to the device's property sheet.
*       @flag DI_USECI_SELECTSTRINGS      | Set if class installer provided strings 
*       should be used during DiSelectDevice.
*       @flag DI_OVERRIDE_INFFLAGS        | Unused.
*       @flag DI_PROPS_NOCHANGEUSAGE      | Set if there should be no Enable/Disable 
*       capability on the device's general property page.
*       @flag DI_NOSELECTICONS            | Set if no small icons should be used during
*       DiSelectDevice.
*       @flag DI_NOWRITE_IDS              | Set if DiInstallDevice should not write
*       the device's hardware and compatible IDs to the registry.
*   
*   @field HWND | hwndParent | Window handle that will own U/I dialogs related to this
*   device.
*
*   @field LPDRIVER_NODE | lpCompatDrvList | Pointer to a linked list of DRIVER_NODES 
*   representing the compatible drivers for this device.
*
*   @field LPDRIVER_NODE | lpClassDrvList | Pointer to a linked list of DRIVER_NODES
*   representing all drivers of this device's class.
*
*   @field LPDRIVER_NODE | lpSelectedDriver | Pointer to a single DRIVER_NODE that
*   has been selected as the driver for this device.
*
*   @field ATOM | atDriverPath | Global ATOM containing the path to this device's INF
*   file.  This is set only of the driver came from an OEM INF file.  This will be
*   0 if the INF is a standard Windows INF file.
*
*   @field ATOM | atTempInfFile | Global ATOM containing the name of a temporary INF
*   file for this device's drivers.  This is set if the drivers came from an old style
*   INF file and have been converted.
*
*   @field HINSTANCE | hinstClassInstaller | Class installer module instance.
*
*   @field HINSTANCE | hinstClassPropProvidor | Class Property Providor module instance.
*
*   @field HINSTANCE | hinstDevicePropProvidor | Device Property Providor module instance.
*
*   @field HINSTANCE | hinstBasicPropProvidor | Basic Property Providor module instance.
*
*   @field FARPROC | fpClassInstaller | Procedure address of class install function.
*
*   @field FARPROC | fpClassEnumPropPages | Procedure address of the Class property 
*   provider page enumeration function.
*
*   @field FARPROC | fpDeviceEnumPropPages | Procedure address of the Device property
*   provider page enumeration function.
*
*   @field FARPROC | fpEnumBasicProperties | Procedure address of the Basic device
*   property provider page enumeration function.
*
*   @field DWORD | dwSetupReserved | Reserved for use by Setup.
*
*   @field DWORD | dwClassInstallReserved | Reserved for use by Class Installers.
*
*   @field GENCALLBACKPROC | gicpGenInstallCallBack | Procedure address of a GenInstall
*   call back function.  This would be set if the class installer wanted to handle
*   GenInstall callbacks during DiInstallDevice.
*
*   @field LPARAM | gicplParam | lParam for the GenInstall Callback.                                                
*
*   @field UINT | InfType | The type of INF file being used.  This will be INFTYPE_TEXT
*   or INFTYPE_EXECUTABLE.
*
*   @field HINSTANCE | hinstPrivateProblemHandler | Module handle for the device's 
*   private problem procedure.
*
*   @field FARPROC | fpPrivateProblemHandler | Procedure address of the device's
*   private problem handler.
*
*   @field LPARAM | lpClassInstallParams | Pointer to a class install parameter block.
*   Class installer parameters are specific to the class install functions.
*
*   @field struct _DEVICE_INFO FAR | *lpdiChildList | Pointer to a linked list of
*   DRIVER_INFO structs representing children of this device.
*
*   @field DWORD | dwFlagsEx | Additional control flags.
*       @flag DI_FLAGSEX_USEOLDINFSEARCH  | Set if INF Search functions should not use 
*       indexed searching.
*       @flag DI_FLAGSEX_AUTOSELECTRANK0  | Set if DiSelectDevice should automatically
*       select rank 0 match drivers.
*       @flag DI_FLAGSEX_CI_FAILED        | Will be set internally if there was a 
*       failure to load or call a class installer.
*       @flag DI_FLAGSEX_DIDINFOLIST      | Will be set if DiBuildCompatDrvInfoList has
*       been called, and this device's compatible driver Info list has been built.
*       @flag DI_FLAGSEX_DIDCOMPATINFO    | Will be set if DiBuildClassDrvInfoList has
*       been called, and this device's class driver Info list has been built.
*       @flag DI_FLAGSEX_FILTERCLASSES    | If set, DiBuildClassDrvList, and 
*       DiBuildClassDrvInfoList will check for Class inclusion filters.  This means
*       devices will not be included in the list, if their class is marked as a
*       NoInstallClass class.
*       @flag DI_FLAGSEX_SETFAILEDINSTALL | If set, then if DiInstallDevice installs
*       a NULL driver, it will also set the FAILEDINSTALL config flag
*       @flag DI_FLAGSEX_DEVICECHANGE | If set, the device manager will rebuild it
*       tree of devices after the device property sheet is closed.
*       @flag DI_FLAGSEX_ALWAYSWRITEIDS | If set, and the flag, DI_NOWRITE_ID is clear
*       (ie that flag takes higher precedance) then always write Hardare and Compat
*       ids, even if they allready exist
*       @flag DI_FLAGSEX_ALLOWEXCLUDEDDRVS | If set, DiSelectDevice will display drivers
*       that have the Exlude From Select state
*   @field LPDRIVER_INFO | lpCompatDrvInfoList | Pointer to a linked list of
*   DRIVER_INFO structs that are compatible with this device.
*
*   @field LPDRIVER_INFO | lpClassDrvInfoList | Pointer to a linked list of 
*   DRIVER_INFO structs representing all drivers for this device's class.
*
*******************************************************************************/
typedef struct _DEVICE_INFO
{
    UINT                        cbSize;
    struct _DEVICE_INFO FAR     *lpNextDi;
    char                        szDescription[LINE_LEN];
    DWORD                       dnDevnode;
    HKEY                        hRegKey;
    char                        szRegSubkey[MAX_DEVNODE_ID_LEN]; 
    char                        szClassName[MAX_CLASS_NAME_LEN];
    DWORD                       Flags;
    HWND                        hwndParent;
    LPDRIVER_NODE               lpCompatDrvList;
    LPDRIVER_NODE               lpClassDrvList;
    LPDRIVER_NODE               lpSelectedDriver;
    ATOM                        atDriverPath;
    ATOM                        atTempInfFile;
    HINSTANCE                   hinstClassInstaller;            
    HINSTANCE                   hinstClassPropProvidor;         
    HINSTANCE                   hinstDevicePropProvidor;        
    HINSTANCE                   hinstBasicPropProvidor;         
    FARPROC                     fpClassInstaller;               
    FARPROC                     fpClassEnumPropPages;           
    FARPROC                     fpDeviceEnumPropPages;          
    FARPROC                     fpEnumBasicProperties;          
    DWORD                       dwSetupReserved;                
    DWORD                       dwClassInstallReserved;         
    GENCALLBACKPROC             gicpGenInstallCallBack;     
                                                
    LPARAM                      gicplParam;     
    UINT                        InfType;        
                                                
    HINSTANCE                   hinstPrivateProblemHandler;
    FARPROC                     fpPrivateProblemHandler;   
    LPARAM                      lpClassInstallParams;      
    struct _DEVICE_INFO FAR     *lpdiChildList;     
    DWORD                       dwFlagsEx;          
    LPDRIVER_INFO               lpCompatDrvInfoList;
    LPDRIVER_INFO               lpClassDrvInfoList;
} DEVICE_INFO, FAR * LPDEVICE_INFO, FAR * FAR * LPLPDEVICE_INFO;

#define ASSERT_DI_STRUC(lpdi) if (lpdi->cbSize != sizeof(DEVICE_INFO)) return (ERR_DI_BAD_DEV_INFO)

typedef struct _CLASS_INFO
{
    UINT        cbSize;
    struct _CLASS_INFO FAR* lpNextCi;
    LPDEVICE_INFO   lpdi;
    char                szDescription[LINE_LEN];
    char        szClassName[MAX_CLASS_NAME_LEN];
} CLASS_INFO, FAR * LPCLASS_INFO, FAR * FAR * LPLPCLASS_INFO;
#define ASSERT_CI_STRUC(lpci) if (lpci->cbSize != sizeof(CLASS_INFO)) return (ERR_DI_BAD_CLASS_INFO)


// flags for device choosing (InFlags)
#define DI_SHOWOEM                  0x00000001L     // support Other... button
#define DI_SHOWCOMPAT               0x00000002L     // show compatibility list
#define DI_SHOWCLASS                0x00000004L     // show class list
#define DI_SHOWALL                  0x00000007L
#define DI_NOVCP                    0x00000008L     // Don't do vcpOpen/vcpClose.
#define DI_DIDCOMPAT                0x00000010L     // Searched for compatible devices
#define DI_DIDCLASS                 0x00000020L     // Searched for class devices
#define DI_AUTOASSIGNRES            0x00000040L    // No UI for resources if possible

// flags returned by DiInstallDevice to indicate need to reboot/restart
#define DI_NEEDRESTART              0x00000080L     // Restart required to take effect
#define DI_NEEDREBOOT               0x00000100L     // Reboot required to take effect

// flags for device installation
#define DI_NOBROWSE                 0x00000200L     // no Browse... in InsertDisk

// Flags set by DiBuildClassDrvList
#define DI_MULTMFGS                 0x00000400L     // Set if multiple manufacturers in
                                                    // class driver list
// Flag indicates that device is disabled
#define DI_DISABLED                 0x00000800L     // Set if device disabled

// Flags for Device/Class Properties
#define DI_GENERALPAGE_ADDED        0x00001000L
#define DI_RESOURCEPAGE_ADDED       0x00002000L

// Flag to indicate the setting properties for this Device (or class) caused a change
// so the Dev Mgr UI probably needs to be updatd.
#define DI_PROPERTIES_CHANGE        0x00004000L

// Flag to indicate that the sorting from the INF file should be used.
#define DI_INF_IS_SORTED            0x00008000L

#define DI_ENUMSINGLEINF            0x00010000L

// The following flags can be used to install a device disabled
// and to prevent CONFIGMG being called when a device is installed
#define DI_DONOTCALLCONFIGMG        0x00020000L
#define DI_INSTALLDISABLED          0x00040000L

// This flag is set of this LPDI is really just an LPCI, ie
// it only contains class info, NO DRIVER/DEVICE INFO
#define DI_CLASSONLY                0x00080000L

// This flag is set if the Class Install params are valid
#define DI_CLASSINSTALLPARAMS       0x00100000L

// This flag is set if the caller of DiCallClassInstaller does NOT
// want the internal default action performed if the Class installer
// return ERR_DI_DO_DEFAULT
#define DI_NODI_DEFAULTACTION       0x00200000L

// ISSUE-2002/01/16-roelfc. This is a hack for M6 Net setup.  Net Setup does not work correctly
// if we process devnode syncronously.  This WILL be removed for M7 when
// Net setup is fixed to work with DiInstallDevice
#define DI_NOSYNCPROCESSING         0x00400000L

// flags for device installation
#define DI_QUIETINSTALL             0x00800000L     // don't confuse the user with
                                                    // questions or excess info
#define DI_NOFILECOPY               0x01000000L     // No file Copy necessary
#define DI_FORCECOPY                0x02000000L     // Force files to be copied from install path
#define DI_DRIVERPAGE_ADDED         0x04000000L     // Prop providor added Driver page.
#define DI_USECI_SELECTSTRINGS      0x08000000L     // Use Class Installer Provided strings in the Select Device Dlg
#define DI_OVERRIDE_INFFLAGS        0x10000000L     // Override INF flags
#define DI_PROPS_NOCHANGEUSAGE      0x20000000L     // No Enable/Disable in General Props

#define DI_NOSELECTICONS	    0x40000000L     // No small icons in select device dialogs

#define DI_NOWRITE_IDS		    0x80000000L     // Don't write HW & Compat IDs on install

#define DI_FLAGSEX_USEOLDINFSEARCH  0x00000001L  // Inf Search functions should not use Index Search
#define DI_FLAGSEX_AUTOSELECTRANK0  0x00000002L  // DiSelectDevice doesn't propmt user if rank 0 match
#define DI_FLAGSEX_CI_FAILED        0x00000004L  // Failed to Load/Call class installer

#define DI_FLAGSEX_DIDINFOLIST      0x00000010L  // Did the Class Info List
#define DI_FLAGSEX_DIDCOMPATINFO    0x00000020L  // Did the Compat Info List

#define DI_FLAGSEX_FILTERCLASSES        0x00000040L
#define DI_FLAGSEX_SETFAILEDINSTALL     0x00000080L
#define DI_FLAGSEX_DEVICECHANGE         0x00000100L
#define DI_FLAGSEX_ALWAYSWRITEIDS       0x00000200L
#define DI_FLAGSEX_ALLOWEXCLUDEDDRVS    0x00000800L

// Defines for class installer functions
#define DIF_SELECTDEVICE            0x0001
#define DIF_INSTALLDEVICE           0x0002
#define DIF_ASSIGNRESOURCES         0x0003
#define DIF_PROPERTIES              0x0004
#define DIF_REMOVE                  0x0005
#define DIF_FIRSTTIMESETUP          0x0006
#define DIF_FOUNDDEVICE             0x0007
#define DIF_SELECTCLASSDRIVERS      0x0008
#define DIF_VALIDATECLASSDRIVERS    0x0009
#define DIF_INSTALLCLASSDRIVERS     0x000A
#define DIF_CALCDISKSPACE           0x000B
#define DIF_DESTROYPRIVATEDATA      0x000C
#define DIF_VALIDATEDRIVER          0x000D
#define DIF_MOVEDEVICE              0x000E
#define DIF_DETECT                  0x000F
#define DIF_INSTALLWIZARD           0x0010
#define DIF_DESTROYWIZARDDATA       0x0011
#define DIF_PROPERTYCHANGE          0x0012
#define DIF_ENABLECLASS             0x0013
#define DIF_DETECTVERIFY            0x0014
#define DIF_INSTALLDEVICEFILES      0x0015

typedef UINT        DI_FUNCTION;    // Function type for device installer

/*******************************************************************************
*   AUTODOC
*   @doc    EXTERNAL SETUPX DEVICE_INSTALLER
*
*   @types    ENABLECLASS_PARAMS | DIF_ENABLECLASS class install parameters
*
*   @field UINT | cbSize | Size of the ENABLECLASS_PARAMS struct.
*
*   @field LPSTR | szClass | The class that is being enabled.
*
*   @field WORD | wEnableMsg | Specifies the stage of enabling.
*   Can be one of:
*
*   @const ENABLECLASS_QUERY | The class is about to be enabled.  Return
*   ERR_DI_DO_DEFAULT to allow the class to be enabled, or ERR_DI_FAIL_QUERY
*   to prevent the class from being enabled.
*
*   @const ENABLECLASS_SUCCESS | The enabling of the class has succeeded,
*   return ERR_DI_DO_DEFAULT.
*
*   @const ENABLECLASS_FAILURE | The enabling of the class has failed,
*   return ERR_DI_DO_DEFAULT.
*
*******************************************************************************/
// DIF_ENABLECLASS parameter struct.
typedef struct _ENABLECLASS_PARAMS
{
    UINT            cbSize;
    LPSTR           szClass;
    WORD            wEnableMsg;
} ENABLECLASS_PARAMS, FAR * LPENABLECLASS_PARAMS;
#define ASSERT_ENABLECLASSPARAMS_STRUC(lpecp) if (lpecp->cbSize != sizeof(ENABLECLASS_PARAMS)) return (ERR_DI_BAD_ENABLECLASS_PARAMS)

#define ENABLECLASS_QUERY   0
#define ENABLECLASS_SUCCESS 1
#define ENABLECLASS_FAILURE 2

/*******************************************************************************
*   AUTODOC
*   @doc    EXTERNAL SETUPX DEVICE_INSTALLER
*
*   @types    MOVEDEV_PARAMS | DIF_MOVEDEVICE class install parameters
*
*   @field UINT | cbSize | Size of the MOVDEV_PARAMS struct.
*
*   @field LPDEVICE_INFO | lpdiOldDev  | Pointer to the device that is being 
*   moved.
*
*******************************************************************************/
typedef struct _MOVEDEV_PARAMS
{
    UINT            cbSize;
    LPDEVICE_INFO   lpdiOldDev;     // References the Device Begin Moved
} MOVEDEV_PARAMS, FAR * LPMOVEDEV_PARAMS;
#define ASSERT_MOVEDEVPARAMS_STRUC(lpmdp) if (lpmdp->cbSize != sizeof(MOVEDEV_PARAMS)) return (ERR_DI_BAD_MOVEDEV_PARAMS)

/*******************************************************************************
*   AUTODOC
*   @doc    EXTERNAL SETUPX DEVICE_INSTALLER
*
*   @types    PROPCHANGE_PARAMS | DIF_PROPCHANGE class install parameters
*
*   @field UINT | cbSize | Size of the PROPCHANGE_PARAMS struct.
*
*   @field DWORD | dwStateChange | State change action. See DiChangeState for details.
*
*   @field DWORD | dwFlags | Flags specific to the type of state change.
*
*   @field DWORD | dwConfigID | Configuration ID for config specific changes.
*
*   @xref DiChangeState.
*
*******************************************************************************/
typedef struct _PROPCHANGE_PARAMS
{
    UINT            cbSize;
    DWORD           dwStateChange;
    DWORD           dwFlags;
    DWORD           dwConfigID;
} PROPCHANGE_PARAMS, FAR * LPPROPCHANGE_PARAMS;
#define ASSERT_PROPCHANGEPARAMS_STRUC(lpmdp) if (lpmdp->cbSize != sizeof(PROPCHANGE_PARAMS)) return (ERR_DI_BAD_PROPCHANGE_PARAMS)

#define MAX_TITLE_LEN           60
#define MAX_INSTRUCTION_LEN     256
#define MAX_LABEL_LEN           30
/*******************************************************************************
*   AUTODOC
*   @doc    EXTERNAL SETUPX DEVICE_INSTALLER
*
*   @types    SELECTDEVICE_PARAMS | DIF_SELECTDEVICE class install parameters
*
*   @field UINT | cbSize | Size of the SELECTDEVICE_PARAMS struct.
*
*   @field char | szTitle[MAX_TITLE_LEN] | Buffer containing a class installer
*   provided title for the Select Device dialogs.
*
*   @field char | szInstructions[MAX_INSTRUCTION_LEN] |  Buffer containing 
*   class installer provided Select Device instructions.
*
*   @field char | szListLabel[MAX_LABEL_LEN] | Buffer containing a lable
*   of the Select Device list of drivers.
*
*******************************************************************************/
typedef struct _SELECTDEVICE_PARAMS
{
    UINT            cbSize;
    char            szTitle[MAX_TITLE_LEN];
    char            szInstructions[MAX_INSTRUCTION_LEN];
    char            szListLabel[MAX_LABEL_LEN];
} SELECTDEVICE_PARAMS, FAR * LPSELECTDEVICE_PARAMS;
#define ASSERT_SELECTDEVICEPARAMS_STRUC(p) if (p->cbSize != sizeof(SELECTDEVICE_PARAMS)) return (ERR_DI_BAD_SELECTDEVICE_PARAMS)

#define DI_REMOVEDEVICE_GLOBAL                  0x00000001
#define DI_REMOVEDEVICE_CONFIGSPECIFIC          0x00000002
/*******************************************************************************
*   AUTODOC
*   @doc    EXTERNAL SETUPX DEVICE_INSTALLER
*
*   @types    REMOVEDEVICE_PARAMS | DIF_REMOVE class install parameters
*
*   @field UINT | cbSize | Size of the REMOVEDEVICE_PARAMS struct.
*
*   @field DWORD | dwFlags | Flags indicating the type of removal to perform.
*       @flag DI_REMOVEDEVICE_GLOBAL         | The device will be removed globally.
*       @flag DI_REMOVEDEVICE_CONFIGSPECIFIC | The device will be removed from only
*       the specified configuration.
*
*   @field DWORD | dwConfigID |  If DI_REMOVEDEVICE_CONFIGSPECIFIC is set, then
*   this is the configuration the device will be removed from. 0 means the current
*   config.
*
*******************************************************************************/
typedef struct _REMOVEDEVICE_PARAMS
{
    UINT            cbSize;
    DWORD           dwFlags;
    DWORD           dwConfigID;
} REMOVEDEVICE_PARAMS, FAR * LPREMOVEDEVICE_PARAMS;
#define ASSERT_REMOVEDPARAMS_STRUC(p) if (p->cbSize != sizeof(REMOVEDEVICE_PARAMS)) return (ERR_DI_BAD_REMOVEDEVICE_PARAMS)

/*******************************************************************************
*   AUTODOC
*   @doc    EXTERNAL SETUPX DEVICE_INSTALLER
*
*   @type NONE | Dynamic Hardware Install Wizard Constants | Constants that are
*   used when adding custom pages to the hardware install wizard.
*
*   @const MAX_INSTALLWIZARD_DYNAPAGES | The maximum number of dynamic hardware 
*   installation wizard pages that can be added by a class installer.
*
*   @const IDD_DYNAWIZ_FIRSTPAGE | Resource ID for the first page that the install 
*   wizard will go to after adding the class installer pages.
*
*   @const IDD_DYNAWIZ_SELECT_PREVPAGE | Resource ID for the page that the Select 
*   Device page will go back to.
*
*   @const IDD_DYNAWIZ_SELECT_NEXTPAGE | Resource ID for the page that the Select 
*   Device page will go forward to.
*
*   @const IDD_DYNAWIZ_ANALYZE_PREVPAGE | Resource ID for the page that the Analyze 
*   page will go back to. This will only be used in the event that there is a 
*   problem (i.e a conflict), and the user selects Back from the analyze page.
*
*   @const IDD_DYNAWIZ_ANALYZE_NEXTPAGE | Resource ID for the page that the Analyze 
*   page will go to if it continues forward.  The wAnalyzeResult in the 
*   INSTALLWIZARDDATA struct will contain the anaysis results.
*
*   @const IDD_DYNAWIZ_INSTALLDETECTED_PREVPAGE | Resource ID for that page that the
*   Install detected devices page will go back to.
*
*   @const IDD_DYNAWIZ_INSTALLDETECTED_NEXTPAGE | Resource ID for the page that the
*   Install detected devices page will go forward to.
*
*   @const IDD_DYNAWIZ_INSTALLDETECTED_NODEVS | Resource ID for the page that the
*   Install detected devices page will go to in the event that no devices are 
*   detected.
*
*   @const IDD_DYNAWIZ_SELECTDEV_PAGE | Resource ID of the hardware install wizard's
*   select device page.  This ID can be used to go directly to the hardware install
*   wizard's select device page.
*
*   @const IDD_DYNAWIZ_ANALYZEDEV_PAGE | Resource ID of the hardware install wizard's
*   device analysis page.  This ID can be use to go directly to the hardware install
*   wizard's analysis page.
*
*   @const IDD_DYNAWIZ_INSTALLDETECTEDDEVS_PAGE | Resource ID of the hardware install
*   wizard's install detected devices page.  This ID can be use to go directly to
*   the hardware install wizard's install detected devices page.
*
*   @const IDD_DYNAWIZ_SELECTCLASS_PAGE | Resource ID of the hardware install wizard's
*   select class page.  This ID can be use to go directly to the hardware install 
*   wizard's select class page.
*
*******************************************************************************/
// DIF_INSTALLWIZARD  Wizard Data
#define MAX_INSTALLWIZARD_DYNAPAGES             20

// Use this ID for the first page that the install wizard should dynamically jump to.
#define IDD_DYNAWIZ_FIRSTPAGE                   10000

// Use this ID for the page that the Select Device dialog should go back to
#define IDD_DYNAWIZ_SELECT_PREVPAGE             10001

// Use this ID for the page that the Select Device dialog should go to next
#define IDD_DYNAWIZ_SELECT_NEXTPAGE             10002
               
// Use this ID for the page that the Analyze dialog should go back to
// This will only be used in the event that there is a problem, and the user
// selects Back from the analyze proc.
#define IDD_DYNAWIZ_ANALYZE_PREVPAGE            10003

// Use this ID for the page that the Analyze dialog should go to if it continue from
// the analyze proc.  the wAnalyzeResult in the INSTALLDATA struct will
// contain the anaysis results.
#define IDD_DYNAWIZ_ANALYZE_NEXTPAGE            10004

// This dialog will be selected if the user chooses back from the
// Install Detected Devices dialog.
#define IDD_DYNAWIZ_INSTALLDETECTED_PREVPAGE    10006

// This dialog will be selected if the user chooses Next from the
// Install Detected Devices dialog.
#define IDD_DYNAWIZ_INSTALLDETECTED_NEXTPAGE    10007

// This is the ID of the dialog to select if detection does not
// find any new devices
#define IDD_DYNAWIZ_INSTALLDETECTED_NODEVS      10008
   
// This is the ID of the Select Device Wizard page.
#define IDD_DYNAWIZ_SELECTDEV_PAGE              10009

// This is the ID of the Analyze Device Wizard page.
#define IDD_DYNAWIZ_ANALYZEDEV_PAGE             10010

// This is the ID of the Install Detected Devs Wizard page.
#define IDD_DYNAWIZ_INSTALLDETECTEDDEVS_PAGE    10011

// This is the ID of the Select Class Wizard page.
#define IDD_DYNAWIZ_SELECTCLASS_PAGE            10012

// This flag is set if a Class installer has added pages to the
// install wizard.
#define DYNAWIZ_FLAG_PAGESADDED             0x00000001

// The following flags will control the button states when displaying
// the InstallDetectedDevs dialog.  
#define DYNAWIZ_FLAG_INSTALLDET_NEXT        0x00000002
#define DYNAWIZ_FLAG_INSTALLDET_PREV        0x00000004

// Set this flag if you jump to the analyze page, and want it to
// handle conflicts for you.  NOTE.  You will not get control back 
// in the event of a conflict if you set this flag.
#define DYNAWIZ_FLAG_ANALYZE_HANDLECONFLICT 0x00000008

#define ANALYZE_FACTDEF_OK      1
#define ANALYZE_STDCFG_OK       2
#define ANALYZE_CONFLICT        3
#define ANALYZE_NORESOURCES     4
#define ANALYZE_ERROR           5
#define ANALYZE_PNP_DEV         6
#define ANALYZE_PCMCIA_DEV      7

/*******************************************************************************
*   AUTODOC
*   @doc    EXTERNAL SETUPX DEVICE_INSTALLER
*
*   @types    INSTALLWIZARDDATA | DIF_INSTALLWIZARD class install parameters. This
*   struct is used by class installers to extend the operation of the hardware
*   installation wizard by adding custom pages.
*
*   @field UINT | cbSize | Size of the INSTALLWIZARDDATA struct.
*
*   @field LPDEVICE_INFO | lpdiOriginal | Pointer to the Original DEVICE_INFO
*   struct at the start of the manual installation.
*
*   @field LPDEVICE_INFO | lpdiSelected | Pointer to the current DEVICE_INFO struct
*   that is being manually selected.
*
*   @field DWORD | dwFlags | Flags that control the operation of the hardware
*   installation wizard.  There are currently none defined.
*
*   @field LPVOID | lpConfigData | Pointer to configuration data for analysis to
*   determine if the selected device can be installed with no conflicts.
*
*   @field WORD | wAnalyzeResult | Results of analysis to determine if the device
*   can be installed with no problems.  The following values are defined:
*       @flag ANALYZE_FACTDEF_OK    | The device can be installed using its factory
*       default settings.
*       @flag ANALYZE_STDCFG_OK     | The device can be installed using a configuration
*       specified in one if its basic logical configurations.  The user will probably
*       have to set jumpers or switches on the hardware to match the settings determined
*       by the install wizard.
*       @flag ANALYZE_CONFLICT      | The device cannot be installed without causing a
*       conflict with another device.
*       @flag ANALYZE_NORESOURCES   | The device does not require any resources, so it
*       can be installed witth no conflicts.
*       @flag ANALYZE_ERROR         | There was an error during analysis.
*       @flag ANALYZE_PNP_DEV       | The device has a least one softsettable logical
*       configurations, allowing it to be automatically configured.  Additionally the
*       device will be enumerated by one of the standard bus enumerators, so it does
*       not require manual installation, except to pre-copy driver files.
*
*   @field HPROPSHEETPAGE | hpsDynamicPages[MAX_INSTALLWIZARD_DYNAPAGES] | An
*   array of property sheet page handles.  The class installer would use this array
*   to create custom wizard pages, and insert their handles into this array.
*
*   @field WORD | wNumDynaPages | The number of pages inserted into the hpsDynamicPages
*   array.
*
*   @field DWORD | dwDynaWizFlags | Flags that control the behavior of the
*   installation wizard whtn dynamic pages have been added.
*       @flag DYNAWIZ_FLAG_PAGESADDED | Will be set by the install wizard if the
*       class installer adds custom pages.
*       @flag DYNAWIZ_FLAG_INSTALLDET_NEXT | If set, the install wizard will allow
*       going forward from the detected devices page, otherwise finish will
*       be the default option for the detected devices page.
*       @flag DYNAWIZ_FLAG_INSTALLDET_PREV | If set, the install wizard will allow
*       going back from the detected devices page.
*       @flag DYNAWIZ_FLAG_ANALYZE_HANDLECONFLICT | If set, the class installer will 
*       handle the case where the selected device cannot be installed because of
*       a conflict.
*
*   @field DWORD | dwPrivateFlags | Flags that may be defined and used by the class
*   installer.
*
*   @field LPARAM | lpPrivateData | Pointer to private reference data defined and
*   set by the class installer.
*
*   @field LPSTR | lpExtraRunDllParams | Pointer to a string containing extra 
*   parameters passed to the hardware install rundll function.
*
*   @field HWND | hwndWizardDlg | Window handle of the install wizard top level 
*   window.
*
*******************************************************************************/
typedef struct InstallWizardData_tag        
{
    UINT                    cbSize;
    
    LPDEVICE_INFO           lpdiOriginal;
    LPDEVICE_INFO           lpdiSelected;
    DWORD                   dwFlags;
    LPVOID                  lpConfigData;
    WORD                    wAnalyzeResult;
        
    // The following fields are used when a Class Installer Extends the Install Wizard
    HPROPSHEETPAGE          hpsDynamicPages[MAX_INSTALLWIZARD_DYNAPAGES];
    WORD                    wNumDynaPages;
    DWORD                   dwDynaWizFlags;
    DWORD                   dwPrivateFlags;
    LPARAM                  lpPrivateData;
    LPSTR                   lpExtraRunDllParams;    
    HWND                    hwndWizardDlg;
} INSTALLWIZDATA, * PINSTALLWIZDATA , FAR *LPINSTALLWIZDATA;

RETERR WINAPI DiCreateDeviceInfo(
    LPLPDEVICE_INFO lplpdi,     // Ptr to ptr to dev info
    LPCSTR      lpszDescription,    // If non-null then description string
    DWORD       hDevnode,       // ISSUE-2002/01/16-roelfc -- MAKE A DEVNODE
    HKEY        hkey,       // Registry hkey for dev info
    LPCSTR      lpszRegsubkey,  // If non-null then reg subkey string
    LPCSTR      lpszClassName,  // If non-null then class name string
    HWND        hwndParent);    // If non-null then hwnd of parent

RETERR WINAPI DiGetClassDevs(
    LPLPDEVICE_INFO lplpdi,     // Ptr to ptr to dev info
    LPCSTR      lpszClassName,  // Must be name of class
    HWND        hwndParent,     // If non-null then hwnd of parent
    int         iFlags);        // Options

RETERR WINAPI DiGetClassDevsEx(
    LPLPDEVICE_INFO lplpdi,     // Ptr to ptr to dev info
    LPCSTR      lpszClassName,  // Must be name of class
    LPCSTR      lpszEnumerator, // Must be name of enumerator, or NULL
    HWND        hwndParent,     // If non-null then hwnd of parent
    int         iFlags);        // Options
    
#define DIGCF_DEFAULT           0x0001  // NOT IMPLEMENTED!
#define DIGCF_PRESENT           0x0002
#define DIGCF_ALLCLASSES        0x0004
#define DIGCF_PROFILE           0x0008

// API to return the Class name of an INF File
RETERR WINAPI DiGetINFClass(LPSTR lpszMWDPath, UINT InfType, LPSTR lpszClassName, DWORD dwcbClassName);

RETERR WINAPI PASCAL DiCreateDevRegKey(
    LPDEVICE_INFO   lpdi,
    LPHKEY      lphk,
    HINF        hinf,
    LPCSTR      lpszInfSection,
    int         iFlags);
    
RETERR WINAPI PASCAL DiDeleteDevRegKey(LPDEVICE_INFO lpdi, int  iFlags);


RETERR WINAPI PASCAL DiOpenDevRegKey(
    LPDEVICE_INFO   lpdi,
    LPHKEY      lphk,
    int         iFlags);

#define DIREG_DEV	0x0001		// Open/Create/Delete device key
#define DIREG_DRV	0x0002		// Open/Create/Delete driver key
#define DIREG_BOTH	0x0004		// Delete both driver and Device key

RETERR WINAPI DiReadRegLogConf
(
    LPDEVICE_INFO       lpdi,
    LPSTR               lpszConfigName,
    LPBYTE FAR          *lplpbLogConf,
    LPDWORD             lpdwSize
);

RETERR WINAPI DiReadRegConf
(
    LPDEVICE_INFO       lpdi,
    LPBYTE FAR          *lplpbLogConf,
    LPDWORD             lpdwSize,
    DWORD               dwFlags
);

#define DIREGLC_FORCEDCONFIG        0x00000001
#define DIREGLC_BOOTCONFIG          0x00000002

RETERR WINAPI DiCopyRegSubKeyValue
(
    HKEY    hkKey,
    LPSTR   lpszFromSubKey,
    LPSTR   lpszToSubKey,
    LPSTR   lpszValueToCopy
);

RETERR WINAPI DiDestroyClassInfoList(LPCLASS_INFO lpci);
RETERR WINAPI DiBuildClassInfoList(LPLPCLASS_INFO lplpci);

#define DIBCI_NOINSTALLCLASS        0x000000001
#define DIBCI_NODISPLAYCLASS        0x000000002

RETERR WINAPI DiBuildClassInfoListEx(LPLPCLASS_INFO lplpci, DWORD dwFlags);
RETERR WINAPI DiGetDeviceClassInfo(LPLPCLASS_INFO lplpci, LPDEVICE_INFO lpdi);

RETERR WINAPI DiDestroyDeviceInfoList(LPDEVICE_INFO lpdi);
RETERR WINAPI DiSelectDevice( LPDEVICE_INFO lpdi );
RETERR WINAPI DiSelectOEMDrv(HWND hDlg, LPDEVICE_INFO lpdi);

// Callback for diInstallDevice vcpOpen.  Basically calls vcpUICallback for everthing
// except when DI_FORCECOPY is active, in which case copies get defaulted to
// VCPN_FORCE
LRESULT CALLBACK diInstallDeviceUICallbackProc(LPVOID lpvObj, UINT uMsg, WPARAM wParam, LPARAM lParam, LPARAM lparamRef);
RETERR WINAPI DiInstallDevice( LPDEVICE_INFO lpdi );
RETERR WINAPI DiInstallDriverFiles(LPDEVICE_INFO lpdi);

RETERR WINAPI DiRemoveDevice( LPDEVICE_INFO lpdi );
RETERR WINAPI DiAskForOEMDisk(LPDEVICE_INFO lpdi);

RETERR WINAPI DiCallClassInstaller(DI_FUNCTION diFctn, LPDEVICE_INFO lpdi);

BOOL WINAPI DiBuildDriverIndex(BOOL bUI);
BOOL WINAPI DiAddSingleInfToDrvIdx(LPSTR lpszInfName, WORD InfType, BOOL bCreate);

RETERR WINAPI DiBuildCompatDrvList(LPDEVICE_INFO lpdi);
RETERR WINAPI DiBuildClassDrvList(LPDEVICE_INFO lpdi);
RETERR WINAPI DiBuildCompatDrvInfoList(LPDEVICE_INFO lpdi);
RETERR WINAPI DiBuildClassDrvInfoList(LPDEVICE_INFO lpdi);
RETERR WINAPI DiDestroyDrvInfoList(LPDRIVER_INFO lpInfo);
LPDRIVER_NODE WINAPI DiConvertDriverInfoToDriverNode(LPDEVICE_INFO lpdi, LPDRIVER_INFO lpInfo);    

typedef RETERR (CALLBACK *OLDINFPROC)(HINF hinf, LPCSTR lpszNewInf, LPARAM lParam);
RETERR WINAPI DiBuildClassDrvListFromOldInf(LPDEVICE_INFO lpdi, LPCSTR lpszSection, OLDINFPROC lpfnOldInfProc, LPARAM lParam);

RETERR WINAPI DiDestroyDriverNodeList(LPDRIVER_NODE lpdn);

RETERR  WINAPI  DiMoveDuplicateDevNode(LPDEVICE_INFO lpdiNewDev);

// The following export will load a dll and find the specified proc name
typedef RETERR (FAR PASCAL *DIINSTALLERPROPERTIES)(LPDEVICE_INFO);

RETERR WINAPI GetFctn(HKEY hk, LPSTR lpszRegVal, LPSTR lpszDefProcName,
                      HINSTANCE FAR * lphinst, FARPROC FAR *lplpfn);
                        
RETERR
WINAPI
DiCreateDriverNode(
    LPLPDRIVER_NODE lplpdn,
    UINT    Rank,
    UINT    InfType,
    unsigned    InfDate,
    LPCSTR  lpszDevDescription,
    LPCSTR  lpszDrvDescription,
    LPCSTR  lpszProviderName,
    LPCSTR  lpszMfgName,
    LPCSTR  lpszInfFileName,
    LPCSTR  lpszSectionName,
    DWORD   dwPrivateData);

RETERR WINAPI DiLoadClassIcon(
    LPCSTR  szClassName,
    HICON FAR *lphiLargeIcon,
    int FAR *lpiMiniIconIndex);


RETERR WINAPI DiInstallDrvSection(
    LPCSTR  lpszInfFileName,
    LPCSTR  lpszSection,
    LPCSTR  lpszClassName,
    LPCSTR  lpszDescription,
    DWORD   dwFlags);


RETERR WINAPI DiChangeState(LPDEVICE_INFO lpdi, DWORD dwStateChange, DWORD dwFlags, LPARAM lParam);

#define DICS_ENABLE                 0x00000001
#define DICS_DISABLE                0x00000002
#define DICS_PROPCHANGE 	    0x00000003
#define DICS_START		    0x00000004
#define DICS_STOP		    0x00000005

#define DICS_FLAG_GLOBAL            0x00000001
#define DICS_FLAG_CONFIGSPECIFIC    0x00000002
#define DICS_FLAG_CONFIGGENERAL     0x00000004

RETERR WINAPI DiInstallClass(LPCSTR lpszInfFileName, DWORD dwFlags);

RETERR WINAPI DiOpenClassRegKey(LPHKEY lphk, LPCSTR lpszClassName);

// support routine for dealing with class mini icons
#define DMI_MASK            0x0001
#define DMI_BKCOLOR         0x0002
#define DMI_USERECT         0x0004
int WINAPI PASCAL DiDrawMiniIcon(HDC hdc, RECT rcLine, int iMiniIcon, DWORD flags);
BOOL WINAPI DiGetClassBitmapIndex(LPCSTR lpszClass, int FAR *lpiMiniIconIndex);

// internal calls for display class
#define DISPLAY_SETMODE_SUCCESS     0x0001
#define DISPLAY_SETMODE_DRVCHANGE   0x0002
#define DISPLAY_SETMODE_FONTCHANGE  0x0004

UINT WINAPI Display_SetMode(LPDEVICE_INFO lpdi, UINT uColorRes, int iXRes, int iYRes);
RETERR WINAPI Display_ClassInstaller(DI_FUNCTION diFctn, LPDEVICE_INFO lpdi);
RETERR WINAPI Display_OpenFontSizeKey(LPHKEY lphkFontSize);
BOOL WINAPI Display_SetFontSize(LPCSTR lpszFontSize);

RETERR WINAPI DiIsThereNeedToCopy(HWND hwnd, DWORD dwFlags);

#define DINTC_NOCOPYDEFAULT	    0x00000001

// API for the mouse class installer
RETERR WINAPI Mouse_ClassInstaller(DI_FUNCTION diFctn, LPDEVICE_INFO lpdi);
#endif // NODEVICEINSTALL

// API for determining if a Driver file is currently part of VMM32.VxD
BOOL WINAPI bIsFileInVMM32
(
    LPSTR   lpszFileName
);


#ifndef NOUSERINTERFACE
/***************************************************************************/
//
// User Interface prototypes and definitions
//
/***************************************************************************/

BOOL WINAPI UiMakeDlgNonBold(HWND hDlg);
VOID WINAPI UiDeleteNonBoldFont(HWND hDlg);

#endif

/***************************************************************************/
//
// setup reg DB calls, use just like those in kernel
//
/***************************************************************************/

DWORD WINAPI SURegOpenKey(HKEY hKey, LPCSTR lpszSubKey, HKEY FAR *lphkResult);
DWORD WINAPI SURegCloseKey(HKEY hKey);
DWORD WINAPI SURegCreateKey(HKEY hKey, LPCSTR lpszSubKey, HKEY FAR *lphkResult);
DWORD WINAPI SURegDeleteKey(HKEY hKey, LPCSTR lpszSubKey);
DWORD WINAPI SURegEnumKey(HKEY hKey, DWORD dwIdx, LPSTR lpszBuffer, DWORD dwBufSize);
DWORD WINAPI SURegQueryValue16(HKEY hKey, LPCSTR lpszSubKey, LPSTR lpValueBuf, DWORD FAR *ldwBufSize);
DWORD WINAPI SURegSetValue16(HKEY hKey, LPCSTR lpszSubKey, DWORD dwType, LPCBYTE lpszValue, DWORD dwValSize);
DWORD WINAPI SURegDeleteValue(HKEY hKey,LPCSTR lpszValue);
DWORD WINAPI SURegEnumValue(HKEY hKey,DWORD dwIdx, LPCSTR lpszValue, DWORD FAR *lpcbValue, DWORD FAR *lpdwReserved, DWORD FAR *lpdwType, LPBYTE lpbData, DWORD FAR *lpcbData);
DWORD WINAPI SURegQueryValueEx(HKEY hKey,LPCSTR lpszValueName, DWORD FAR *lpdwReserved,DWORD FAR *lpdwType,LPSTR lpValueBuf, DWORD FAR *ldwBufSize);
DWORD WINAPI SURegSetValueEx(HKEY hKey,LPCSTR lpszValueName, DWORD dwReserved, DWORD dwType, LPBYTE lpszValue, DWORD dwValSize);
DWORD WINAPI SURegSaveKey(HKEY hKey, LPCSTR lpszFileName, LPVOID lpsa);
DWORD WINAPI SURegLoadKey(HKEY hKey, LPCSTR lpszSubKey, LPCSTR lpszFileName);
DWORD WINAPI SURegUnLoadKey(HKEY hKey, LPCSTR lpszSubKey);

DWORD WINAPI SURegFlush(VOID);
DWORD WINAPI SURegInit(VOID);    // should be called before any other Reg APIs

/***************************************************************************/
// setup FormatMessage support
/***************************************************************************/
#define MB_LOG  (UINT)-1
#define MB_DBG  (UINT)-2

UINT FAR CDECL suFormatMessage(HINSTANCE hAppInst, LPCSTR lpcFormat, LPSTR szMessage, UINT uSize,
    ...);
UINT WINAPI suvFormatMessage(HINSTANCE hAppInst, LPCSTR lpcFormat, LPSTR szMessage, UINT uSize,
    LPVOID FAR * lpArgs);
int WINCAPI _loadds suFormatMessageBox(HINSTANCE hAppInst, HWND hwndParent, LPCSTR lpcText, LPCSTR lpcTitle,
    UINT uStyle, ...);

WORD WINAPI suErrorToIds( WORD Value, WORD Class );

/***************************************************************************/
// setup Version Conflict support
/***************************************************************************/

LPVOID WINAPI suVerConflictInit(BOOL fYesToLangMismatch);
void WINAPI suVerConflictTerm(LPVOID lpvData);
LRESULT WINAPI suVerConflict(HWND hwnd, LPVCPVERCONFLICT lpvc, LPVOID lpvData);


/***************************************************************************/
// setup Help support
/***************************************************************************/

BOOL WINAPI suHelp( HWND hwndApp, HWND hwndDlg );

//***************************************************************************/
// setup Emergency Boot Disk (EBD) creation fn.
//***************************************************************************/

RETERR WINAPI suCreateEBD( HWND hWnd, VIFPROC CopyCallbackProc, LPARAM lpuii );

//***************************************************************************
// Misc SETUPX.DLL support functions.
//***************************************************************************
enum  SU_ACTIONS                        // Actions msgs for Setupx()    /* ;Internal */
{                                                                       /* ;Internal */
    SUX_REGINIT,                        // Intialize registry           /* ;Internal */
    SUX_DBGLEVEL,                       // Set debug level              /* ;Internal */
    SUX_SETUPFLG,                       // Set fIsSetup flag            /* ;Internal */
    SUX_FASTSETUP,						// Setupx => checking less mode /* ;Internal */
    SUX_FORCEREGFLUSH,                  // Call kRegFlush               /* ;Internal */
    SUX_TPSFLUSH,                  	    // Call TPS_Flush() fns.        /* ;Internal */
    SUX_DBGHFILE,			            // File to write messages to    /* ;Internal */
    SUX_LOADSTORELDIDS,			        // Load/store setup's LDID's    /* ;Internal */
    SUX_ENABLEREGFLUSH,			        // Enable/Disable SURegFlush() if fIsSetup  /* ;Internal */
    SUX_SETUNCPATHFUNC,			        // NOW UNUSED!!                   /* ;Internal */
    SUX_SETTRUEDISKFREEFUNC,            // Set TRUE disk free func      /* ;Internal */
    SUX_ISFLOPPYBOOT,                   // Set TRUE if floppy boot disk /* ;Internal */
    SUX_BISVER4,                        // returns bIsVer4(CHICAGO) flag/* ;Internal */
    SUX_SETCTLCALLBACKFUNC,             // Set ctlCopyCallBackProc Func /* ;Internal */
    SUX_GETCTLCALLBACKFUNC,             // Get ctlCopyCallBackProc Func /* ;Internal */
    SUX_BISMULTICFG,                    // returns SETUPX's gfMultiCfg  /* ;Internal */
    SUX_DUMPDSINFO,                    // Dumps diskspace info          /* ;Internal */
    SUX_INFCACHEOFF,                   // Turns INF file caching on/off /* ;Internal */
    SUX_SETFCDROMDRIVEEXISTS,          // Set CDRomDriveExists func     /* ;Internal */
#ifdef  NEC_98                         // for support AT Boot
    SUX_ATDRIVEMODE,                   // Set AT Boot mode func         /* ;Internal */
#endif  //NEC_98
};                                                                      /* ;Internal */

RETERR WINAPI Setupx( UINT uMsg, WPARAM wParam, LPARAM lParam );        /* ;Internal */

RETERR WINAPI SUStoreLdidPath( LOGDISKID ldid, LPSTR lpszPath );        /* ;Internal */

BOOL WINAPI sxIsSBSServerFile( LPVIRTNODE lpVn );                       /* ;Internal */

BOOL WINAPI sxMakeUNCPath( LPSTR lpszPath );                            /* ;Internal */

RETERR WINAPI SUGetSetSetupFlags(LPDWORD lpdwFlags, BOOL bSet);

RETERR WINAPI CfgSetupMerge( int uFlags );

// structure for the LPARAM argument to Setupx() for SUX_REGINIT action.    ;Internal
typedef struct _REGINIT_S { /* setupx - reg_init */                     /* ;Internal */
    LPSTR       lpszSystemFile;         // reg's base SYSTEM filename   /* ;Internal */
    LOGDISKID   ldidSystemFile;         // ldid for SYSTEM filename     /* ;Internal */
    LPSTR       lpszUserFile;           // reg's base USER filename     /* ;Internal */
    LOGDISKID   ldidUserFile;           // ldid for USER filename       /* ;Internal */
} REGINIT_S, FAR *LPREGINIT;                                            /* ;Internal */

#ifndef LPLPSTR
    typedef LPSTR (FAR *LPLPSTR);
#endif


#define         CFG_PARSE_BUFLEN 1024    // Buf sized passed line obj funcs      /* ;Internal */

LPLPSTR WINAPI  CfgParseLine( LPCSTR szLine, LPSTR Buf );                       /* ;Internal */
BOOL    WINAPI  CfgSetAutoProcess( int TrueFalse );                             /* ;Internal */
void    WINAPI  CfgObjToStr( LPLPSTR apszObj, LPSTR szLine );                   /* ;Internal */
LPLPSTR WINAPI  CfgLnToObj( HTP hSection, int Offset, int Origin, LPSTR Buf );  /* ;Internal */
LPLPSTR WINAPI  CfgObjFindKeyCmd( HTP hSec, LPCSTR szKey, LPCSTR szCmd,         /* ;Internal */
                                  int Offset, int Origin, LPSTR Buf );          /* ;Internal */
LPCSTR WINAPI   WildCardStrCmpi( LPCSTR szKey, LPCSTR szLine, LPCSTR szDelims ); /* ;Internal */
RETERR WINAPI   GenMapRootRegStr2Key( LPCSTR szRegRoot, HKEY hRegRelKey,        /* ;Internal */
														HKEY FAR *lphkeyRoot ); /* ;Internal */


//***************************************************************************
//
// ENUMS for accessing config.sys/autoexec.bat line objects using the
// array returned by ParseConfigLine()..
//
//***************************************************************************

enum    CFGLINE_STRINGS                     // Config.sys/autoexec.bat objects
{
    CFG_KEYLEAD,                            // Keyword leading whitespaces
    CFG_KEYWORD,                            // Keyword
    CFG_KEYTRAIL,                           // Keyword trailing delimiters
    CFG_UMBINFO,                            // Load high info
    CFG_DRVLETTER,                          // Drive letter for cmd path
    CFG_PATH,                               // Command path
    CFG_COMMAND,                            // Command base name
    CFG_EXT,                                // Command extension including '.'
    CFG_ARGS,                               // Command arguments
    CFG_FREE,                               // Free area at end of buffer
    CFG_END
};

/*---------------------------------------------------------------------------*
 *                  SUB String Data 
 *---------------------------------------------------------------------------*/

/*******************************************************************************
*   AUTODOC
*   @doc    EXTERNAL SETUPX DEVICE_INSTALLER
*
*   @types    SUBSTR_DATA | Data structure used to manage substrings.
*   struct is used by class installers to extend the operation of the hardware
*   installation wizard by adding custom pages.
*
*   @field LPSTR | lpFirstSubstr | Pointer to the first substring in the list.
*
*   @field LPSTR | lpCurSubstr | Pointer to the current substring in the list.
*
*   @field LPSTR | lpLastSubstr | Pointer to the last substring in the list.
*
*   @xref InitSubstrData
*   @xref GetFirstSubstr
*   @xref GetNextSubstr
*
*******************************************************************************/
typedef struct _SUBSTR_DATA {
    LPSTR lpFirstSubstr;
    LPSTR lpCurSubstr;
    LPSTR lpLastSubstr;
}   SUBSTR_DATA;


typedef SUBSTR_DATA*		PSUBSTR_DATA;
typedef SUBSTR_DATA NEAR*	NPSUBSTR_DATA;
typedef SUBSTR_DATA FAR*	LPSUBSTR_DATA;

BOOL WINAPI InitSubstrData(LPSUBSTR_DATA lpSubstrData, LPSTR lpStr);
BOOL WINAPI GetFirstSubstr(LPSUBSTR_DATA lpSubstrData);
BOOL WINAPI GetNextSubstr(LPSUBSTR_DATA lpSubStrData);

BOOL FAR PASCAL InitSubstrDataEx(LPSUBSTR_DATA lpssd, LPSTR lpString, char chDelim);  /* ;Internal */

BOOL WINAPI FirstBootMoveToDOSSTART(LPSTR lpszCmd, BOOL fRemark);
BOOL WINAPI DOSOptEnableCurCfg(LPCSTR lpszOptKey);

/*---------------------------------------------------------------------------*
 *                  Misc. Di functions
 *---------------------------------------------------------------------------*/
BOOL WINAPI DiBuildPotentialDuplicatesList
(
    LPDEVICE_INFO   lpdi, 
    LPSTR           lpDuplicateList, 
    DWORD           cbSize,
    LPDWORD         lpcbData,
    LPSTR           lpstrDupType
);

//***************************************************************************
#endif      // SETUPX_INC

=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\hnw\win95\setupx3.h ===
//**********************************************************************
//
// SETUPX.H                         
//
//  Copyright (c) 1993 - Microsoft Corp.
//  All rights reserved.
//  Microsoft Confidential
//
// Public include file for Chicago Setup services.
//
//**********************************************************************

#ifndef SETUPX_INC
#define SETUPX_INC   1                   // SETUPX.H signature

/***************************************************************************/
// setup PropertySheet support
// NOTE:  Always include PRST.H because it is needed later for Class Installer
// stuff, and optionally define the SU prop sheet stuff.
/***************************************************************************/
#include <prsht.h>
#ifndef NOPRSHT
HPROPSHEETPAGE  WINAPI SUCreatePropertySheetPage(LPCPROPSHEETPAGE lppsp);
BOOL            WINAPI SUDestroyPropertySheetPage(HPROPSHEETPAGE hPage);
int             WINAPI SUPropertySheet(LPCPROPSHEETHEADER lppsh);
#endif // NOPRSHT

typedef UINT RETERR;             // Return Error code type.

#define OK 0                     // success error code

#define IP_ERROR       (100)    // Inf parsing
#define TP_ERROR       (200)    // Text processing module
#define VCP_ERROR      (300)    // Virtual copy module
#define GEN_ERROR      (400)    // Generic Installer
#define DI_ERROR       (500)    // Device Installer

// err2ids mappings
enum ERR_MAPPINGS {
    E2I_VCPM,           // Maps VCPM to strings
    E2I_SETUPX,         // Maps setupx returns to strings
    E2I_SETUPX_MODULE,  // Maps setupx returns to appropriate module
    E2I_DOS_SOLUTION,   // Maps DOS Extended errors to solutions
    E2I_DOS_REASON,     // Maps DOS extended errors to strings.
    E2I_DOS_MEDIA,      // Maps DOS extended errors to media icon.
};

#ifndef NOVCP

/***************************************************************************/
//
// Logical Disk ID definitions
//
/***************************************************************************/

// DECLARE_HANDLE(VHSTR);           /* VHSTR = VirtCopy Handle to STRing */
typedef UINT VHSTR;         /* VirtCopy Handle to String */

VHSTR   WINAPI vsmStringAdd(LPCSTR lpszName);
int WINAPI vsmStringDelete(VHSTR vhstr);
VHSTR   WINAPI vsmStringFind(LPCSTR lpszName);
int WINAPI vsmGetStringName(VHSTR vhstr, LPSTR lpszBuffer, int cbBuffer);
int WINAPI vsmStringCompare(VHSTR vhstrA, VHSTR vhstrB);
LPCSTR  WINAPI vsmGetStringRawName(VHSTR vhstr);
void    WINAPI vsmStringCompact(void);

typedef UINT LOGDISKID;          /* ldid */

// Logical Disk Descriptor: Structure which describes the physical attributes
// of a logical disk. Every logical disk is assigned a logical disk
// identifier (LDID), and is described by a logical disk descriptor (LDD).
//
// The cbSize structure member must always be set to sizeof(LOGDISKDESC_S),
// but all other unused structure members should be NULL or 0. No validation
// is performed on the size of string arrays; all string pointers, if
// non-NULL and they are to receive a string, must point at string arrays
// whose sizes are as follows:
//      sizeof( szPath )    = MAX_PATH_LEN
//      sizeof( szVolLabel) = MAX_FILENAME_LEN
//      sizeof( szName )    = MAX_STRING_LEN
#define MAX_PATH_LEN        260     // Max. path length.
#define MAX_FILENAME_LEN    20      // Max. filename length. ( > sizeof( "x:\\12345678.123" )

typedef struct _LOGDISKDESC_S { /* ldd */
    WORD        cbSize;                 // Size of this structure (bytes)
    LOGDISKID   ldid;                   // Logical Disk ID.
    LPSTR       pszPath;                // Ptr. to associated Path string.
    LPSTR       pszVolLabel;            // Ptr. to Volume Label string.
    LPSTR       pszDiskName;            // Ptr. to Disk Name string.
    WORD        wVolTime;               // Volume label modification time.
    WORD        wVolDate;               // Volume label modification date.
    DWORD       dwSerNum;               // Disk serial number.
    WORD        wFlags;                 // Flags.
} LOGDISKDESC_S, FAR *LPLOGDISKDESC;

// Range for pre-defined LDIDs.
#define LDID_PREDEF_START   0x0001  // Start of range
#define LDID_PREDEF_END     0x7FFF  // End of range

// Range for dynamically assigned LDIDs.
#define LDID_ASSIGN_START   0x8000  // Start of range
#define LDID_ASSIGN_END     0xBFFF  // End of range

// Pre-defined Logical Disk Identifiers (LDID).
//
#define LDID_NULL       0               // Null (undefined) LDID.
#define LDID_ABSOLUTE   ((UINT)-1)      // Absolute path

// source path of windows install, this is typically A:\ or a net drive
#define LDID_SRCPATH    1   // source of instilation
// temporary setup directory used by setup, this is only valid durring
// regular install and contains the INF and other binary files.  May be
// read-only location.
#define LDID_SETUPTEMP  2   // temporary setup dir for install
// path to uninstall location, this is where we backup files that will
// be overwritten
#define LDID_UNINSTALL  3   // uninstall (backup) dir.
// backup path for the copy engine, this should not be used
#define LDID_BACKUP     4   // ISSUE-2002/01/16-roelfc: backup dir for the copy engine, not used
// temporary setup directory used by setup, this is only valid durring
// regular install and is guarenteed to be a read/write location for 
// scratch space.
#define LDID_SETUPSCRATCH  5   // temporary setup dir for scratch space.

// windows directory, this is the destinatio of the insallation
#define LDID_WIN        10  // destination Windows dir (just user files).
#define LDID_SYS        11  // destination Windows System dir.
#define LDID_IOS        12  // destination Windows Iosubsys dir.
#define LDID_CMD        13  // destination Windows Command (DOS) dir.
#define LDID_CPL        14  // destination Windows Control Panel dir.
#define LDID_PRINT      15  // destination Windows Printer dir.
#define LDID_MAIL       16  // destination Mail dir.
#define LDID_INF        17  // destination Windows *.INF dir.
#define LDID_HELP       18  // destination Windows Help dir.
#define LDID_WINADMIN   19  // admin stuff.

#define LDID_FONTS      20  // destination Windows Font dir.
#define LDID_VIEWERS    21  // destination Windows Viewers dir.
#define LDID_VMM32      22  // destination Windows VMM32 dir.
#define LDID_COLOR      23  // destination Windows Color dir.

#define LDID_APPS       24  // Applications folder location.

// Shared dirs for net install.
#define LDID_SHARED     25  // Bulk of windows files.
#define LDID_WINBOOT    26  // guarenteed boot device for windows.
#define LDID_MACHINE    27  // machine specific files.
#define LDID_HOST_WINBOOT   28

// boot and old win and dos dirs.
#define LDID_BOOT       30  // Root dir of boot drive
#define LDID_BOOT_HOST  31  // Root dir of boot drive host
#define LDID_OLD_WINBOOT    32  // Subdir off of Root (optional)
#define LDID_OLD_WIN    33  // old windows directory (if it exists)
#define LDID_OLD_DOS    34  // old dos directory (if it exists)

#define LDID_OLD_NET    35  // old network root directory, only valid during
                            // network GenUpgrade

#define LDID_MOUSE      36  // path to MOUSE env. variable if set or same as LDID_WIN
                            // only valid after mouse class installer.

// Convert Ascii drive letter to Integer drive number ('A'=1, 'B'=2, ...).
#define DriveAtoI( chDrv )      ((int)(chDrv & 31))

// Convert Integer drive number to Ascii drive letter (1='A', 2='B', ...).
#define DriveItoA( iDrv )       ((char) (iDrv - 1 + 'A'))

// ISSUE-2002/01/16-roelfc: change the names of these

RETERR WINAPI CtlSetLdd     ( LPLOGDISKDESC );
RETERR WINAPI CtlGetLdd     ( LPLOGDISKDESC );
RETERR WINAPI CtlFindLdd    ( LPLOGDISKDESC );
RETERR WINAPI CtlAddLdd     ( LPLOGDISKDESC );
RETERR WINAPI CtlDelLdd     ( LOGDISKID  );
RETERR WINAPI CtlGetLddPath ( LOGDISKID, LPSTR );
RETERR WINAPI CtlSetLddPath ( LOGDISKID, LPSTR );

/***************************************************************************/
//
// Virtual File Copy definitions
//
/***************************************************************************/

typedef DWORD LPEXPANDVTBL;         /* ISSUE-2002/01/16-roelfc -- clean this up */

enum _ERR_VCP
{
    ERR_VCP_IOFAIL = (VCP_ERROR + 1),       // File I/O failure
    ERR_VCP_STRINGTOOLONG,                  // String length limit exceeded
    ERR_VCP_NOMEM,                          // Insufficient memory to comply
    ERR_VCP_NOVHSTR,                        // No string handles available
    ERR_VCP_OVERFLOW,                       // Reference count would overflow
    ERR_VCP_BADARG,                         // Invalid argument to function
    ERR_VCP_UNINIT,                         // String library not initialized
    ERR_VCP_NOTFOUND ,                      // String not found in string table
    ERR_VCP_BUSY,                           // Can't do that now
    ERR_VCP_INTERRUPTED,                    // User interrupted operation
    ERR_VCP_BADDEST,                        // Invalid destination directory
    ERR_VCP_SKIPPED,                        // User skipped operation
    ERR_VCP_IO,                             // Hardware error encountered
    ERR_VCP_LOCKED,                         // List is locked
    ERR_VCP_WRONGDISK,                      // The wrong disk is in the drive
    ERR_VCP_CHANGEMODE,                     //
    ERR_VCP_LDDINVALID,                // Logical Disk ID Invalid.
    ERR_VCP_LDDFIND,                   // Logical Disk ID not found.
    ERR_VCP_LDDUNINIT,                 // Logical Disk Descriptor Uninitialized.
    ERR_VCP_LDDPATH_INVALID,
    ERR_VCP_NOEXPANSION,                // Failed to load expansion dll
    ERR_VCP_NOTOPEN,                    // Copy session not open
};

/*****************************************************************************
 *              Structures
 *****************************************************************************/

/*---------------------------------------------------------------------------*
 *                  VCPPROGRESS
 *---------------------------------------------------------------------------*/

typedef struct tagVCPPROGRESS { /* prg */
    DWORD   dwSoFar;            /* Number of units copied so far */
    DWORD   dwTotal;            /* Number of units to copy */
} VCPPROGRESS, FAR *LPVCPPROGRESS;

/*---------------------------------------------------------------------------*
 *                  VCPDISKINFO
 *---------------------------------------------------------------------------*/

typedef struct tagVCPDISKINFO {
    WORD        cbSize;         /* Size of this structure in bytes */
    LOGDISKID   ldid;           /* Logical disk ID */
    VHSTR       vhstrRoot;      /* Location of root directory */
    VHSTR       vhstrVolumeLabel;/* Volume label */
    VHSTR       vhstrDiskName;  // Printed name on the disk.
    WORD        wVolumeTime;    /* Volume label modification time */
    WORD        wVolumeDate;    /* Volume label modification date */
    DWORD       dwSerialNumber; /* Disk serial number */
    WORD        fl;             /* Flags */
    LPARAM      lparamRef;      /* Reference data for client */

    VCPPROGRESS prgFileRead;    /* Progress info */
    VCPPROGRESS prgByteRead;

    VCPPROGRESS prgFileWrite;
    VCPPROGRESS prgByteWrite;

} VCPDISKINFO, FAR *LPVCPDISKINFO;

#define VDIFL_VALID     0x0001  /* Fields are valid from a prev. call */
#define VDIFL_EXISTS    0x0002  /* Disk exists; do not format */

RETERR WINAPI DiskInfoFromLdid(LOGDISKID ldid, LPVCPDISKINFO lpdi);

/*---------------------------------------------------------------------------*
 *                  VCPFILESPEC
 *---------------------------------------------------------------------------*/

typedef struct tagVCPFILESPEC { /* vfs */
    LOGDISKID   ldid;           /* Logical disk */
    VHSTR       vhstrDir;       /* Directory withing logical disk */
    VHSTR       vhstrFileName;  /* Filename within directory */
} VCPFILESPEC, FAR *LPVCPFILESPEC;

/*---------------------------------------------------------------------------*
 *              VCPFATTR
 *---------------------------------------------------------------------------*/

/*
 * ISSUE-2002/01/16-roelfc -- explain diffce between llenIn and llenOut wrt compression.
 */
typedef struct tagVCPFATTR {
    UINT    uiMDate;            /* Modification date */
    UINT    uiMTime;            /* Modification time */
    UINT    uiADate;            /* Access date */
    UINT    uiATime;            /* Access time */
    UINT    uiAttr;             /* File attribute bits */
    DWORD   llenIn;             /* Original file length */
    DWORD   llenOut;            /* Final file length */
                                /* (after decompression) */
} VCPFATTR, FAR *LPVCPFATTR;

/*---------------------------------------------------------------------------*
 *                  VIRTNODEEX
 *---------------------------------------------------------------------------*/
typedef struct tagVIRTNODEEX
{    /* vnex */
    HFILE           hFileSrc;
    HFILE           hFileDst;
    VCPFATTR        fAttr;
    WORD            dosError;   // The first/last error encountered
    VHSTR           vhstrFileName;  // The original destination name.
    WPARAM          vcpm;   // The message that was being processed.
} VIRTNODEEX, FAR *LPCVIRTNODEEX, FAR *LPVIRTNODEEX ;

/*---------------------------------------------------------------------------*
 *                  VIRTNODE
 *---------------------------------------------------------------------------*/

typedef struct tagVIRTNODE {    /* vn */
    WORD            cbSize;
    VCPFILESPEC     vfsSrc;
    VCPFILESPEC     vfsDst;
    WORD            fl;
    LPARAM          lParam;
    LPEXPANDVTBL    lpExpandVtbl;
    LPVIRTNODEEX    lpvnex;
} VIRTNODE, FAR *LPCVIRTNODE, FAR *LPVIRTNODE ;

/*---------------------------------------------------------------------------*
 *              VCPDESTINFO
 *---------------------------------------------------------------------------*/

typedef struct tagVCPDESTINFO { /* destinfo */
    WORD    flDevAttr;          /* Device attributes */
    LONG    cbCapacity;         /* Disk capacity */
    WORD    cbCluster;          /* Bytes per cluster */
    WORD    cRootDir;           /* Size of root directory */
} VCPDESTINFO, FAR *LPVCPDESTINFO;

#define DIFL_FIXED      0x0001  /* Nonremoveable media */
#define DIFL_CHANGELINE 0x0002  /* Change line support */

// Now also used by the virtnode as we dont have copy nodes any more.
// #define CNFL_BACKUP             0x0001  /* This is a backup node */
#define CNFL_DELETEONFAILURE    0x0002  /* Dest should be deleted on failure */
#define CNFL_RENAMEONSUCCESS    0x0004  /* Dest needs to be renamed */
#define CNFL_CONTINUATION       0x0008  /* Dest is continued onto difft disk */
#define CNFL_SKIPPED            0x0010  /* User asked to skip file */
#define CNFL_IGNOREERRORS       0x0020  // An error has occured on this file already
#define CNFL_RETRYFILE          0x0040  // Retry the file (error ocurred)
#define CNFL_COPIED				0x0080  // Node has already been copied.

// ISSUE-2002/01/16-roelfc: verify the use and usefullness of these flags
// #define VNFL_UNIQUE          0x0000  /* Default */
#define VNFL_MULTIPLEOK         0x0100  /* Do not search PATH for duplicates */
#define VNFL_DESTROYOLD         0x0200  /* Do not back up files */
// #define VNFL_NOW             0x0400  /* Use by vcp Flush */
// To deternime what kind of node it is.
#define VNFL_COPY			    0x0000  // A simple copy node.
#define VNFL_DELETE             0x0800  // A delete node
#define VNFL_RENAME             0x1000  // A rename node
#define VNFL_NODE_TYPE		    ( VNFL_RENAME|VNFL_DELETE|VNFL_COPY )
    /* Read-only flag bits */
#define VNFL_CREATED            0x2000  /* VCPM_NODECREATE has been sent */
#define VNFL_REJECTED           0x4000  /* Node has been rejected */

#define VNFL_DEVICEINSTALLER    0x8000     /* Node was added by the Device Installer */

/*---------------------------------------------------------------------------*
 *                  VCPSTATUS
 *---------------------------------------------------------------------------*/

typedef struct tagVCPSTATUS {   /* vstat */
    WORD    cbSize;             /* Size of this structure */

    VCPPROGRESS prgDiskRead;
    VCPPROGRESS prgFileRead;
    VCPPROGRESS prgByteRead;

    VCPPROGRESS prgDiskWrite;
    VCPPROGRESS prgFileWrite;
    VCPPROGRESS prgByteWrite;

    LPVCPDISKINFO lpvdiIn;      /* Current input disk */
    LPVCPDISKINFO lpvdiOut;     /* Current output disk */
    LPVIRTNODE    lpvn;            /* Current file */

} VCPSTATUS, FAR *LPVCPSTATUS;

/*---------------------------------------------------------------------------*
 *                  VCPVERCONFLICT
 *---------------------------------------------------------------------------*/

typedef struct tagVCPVERCONFLICT {

    LPCSTR  lpszOldFileName;
    LPCSTR  lpszNewFileName;
    DWORD   dwConflictType;     /* Same values as VerInstallFiles */
    LPVOID  lpvinfoOld;         /* Version information resources */
    LPVOID  lpvinfoNew;
    WORD    wAttribOld;         /* File attributes for original */
    LPARAM  lparamRef;          /* Reference data for callback */

} VCPVERCONFLICT, FAR *LPVCPVERCONFLICT;

/*****************************************************************************
 *              Callback functions
 *****************************************************************************/

typedef LRESULT (CALLBACK *VIFPROC)(LPVOID lpvObj, UINT uMsg, WPARAM wParam, LPARAM lParam, LPARAM lparamRef);

LRESULT CALLBACK vcpDefCallbackProc(LPVOID lpvObj, UINT uMsg, WPARAM wParam, LPARAM lParam, LPARAM lparamRef);

// callback for default UI.
// lparamRef --> a VCPUIINFO structure
LRESULT CALLBACK vcpUICallbackProc(LPVOID lpvObj, UINT uMsg, WPARAM wParam, LPARAM lParam, LPARAM lparamRef);

/*---------------------------------------------------------------------------*
 *                  VCPUIINFO
 *
 * This structure is passed in as the lparamRef of vcpUICallbackProc.
 *
 * on using vcpUICallbackProc:
 * - to use, have vcpUICallbackProc as the callback for vcpOpen with
 *   an appropriately filled in VCPUIINFO structure as the lparamRef.
 *
 * - based on flags, hwndProgress is created and maintained
 * - lpfnStatCallback is called with only status messages
 *     returning VCPM_ABORT indicates that the copy should be aborted
 * - if hwndProgress is non-NULL, the control with idProgress will
 *     receive progress gauge messages as appropriate
 *
 *---------------------------------------------------------------------------*/
#define VCPUI_CREATEPROGRESS 0x0001 // callback should create and manage progress gauge dialog
#define VCPUI_NOBROWSE       0x0002 // no browse button in InsertDisk
#define VCPUI_RENAMEREQUIRED 0x0004 // as a result of a file being in use at copy, reboot required

typedef struct {
    UINT flags;
    HWND hwndParent;            // window of parent
    HWND hwndProgress;          // window to get progress updates (nonzero ids)
    UINT idPGauge;              // id for progress gauge
    VIFPROC lpfnStatCallback;   // callback for status info (or NULL)
    LPARAM lUserData;           // caller definable data
    LOGDISKID ldidCurrent;      // reserved.  do not touch.
} VCPUIINFO, FAR *LPVCPUIINFO;

/******************************************************************************
 *          Callback notification codes
 *****************************************************************************/

/* ISSUE-2002/01/16-roelfc -- VCPN_ABORT should match VCPERROR_INTERRUPTED */

#define VCPN_OK         0       /* All is hunky-dory */
#define VCPN_PROCEED        0   /* The same as VCPN_OK */

#define VCPN_ABORT      (-1)    /* Cancel current operation */
#define VCPN_RETRY      (-2)    /* Retry current operation */
#define VCPN_IGNORE     (-3)    /* Ignore error and continue */
#define VCPN_SKIP       (-4)    /* Skip this file and continue */
#define VCPN_FORCE      (-5)    /* Force an action */
#define VCPN_DEFER      (-6)    /* Save the action for later */
#define VCPN_FAIL       (-7)    /* Return failure back to caller */
#define VCPN_RETRYFILE  (-8)    // An error ocurred during file copy, do it again.

/*****************************************************************************
 *          Callback message numbers
 *****************************************************************************/

#define VCPM_CLASSOF(uMsg)  HIBYTE(uMsg)
#define VCPM_TYPEOF(uMsg)   (0x00FF & (uMsg))   // LOBYTE(uMsg)

/*---------------------------------------------------------------------------*
 *          ERRORs
 *---------------------------------------------------------------------------*/

#define VCPM_ERRORCLASSDELTA    0x80
#define VCPM_ERRORDELTA         0x8000      /* Where the errors go */

/*---------------------------------------------------------------------------*
 *          Disk information callbacks
 *---------------------------------------------------------------------------*/

#define VCPM_DISKCLASS      0x01
#define VCPM_DISKFIRST      0x0100
#define VCPM_DISKLAST       0x01FF

enum tagVCPM_DISK {

    VCPM_DISKCREATEINFO = VCPM_DISKFIRST,
    VCPM_DISKGETINFO,
    VCPM_DISKDESTROYINFO,
    VCPM_DISKPREPINFO,

    VCPM_DISKENSURE,
    VCPM_DISKPROMPT,

    VCPM_DISKFORMATBEGIN,
    VCPM_DISKFORMATTING,
    VCPM_DISKFORMATEND,

    /* Remaining messages reserved for future use */
};

/*---------------------------------------------------------------------------*
 *          File copy callbacks
 *---------------------------------------------------------------------------*/

// ISSUE-2002/01/16-roelfc: this needs to be merged back with other internal errors
#define VCPERROR_IO         (VCP_ERROR - ERR_VCP_IO)            /* Hardware error encountered */

#define VCPM_FILEINCLASS    0x02
#define VCPM_FILEOUTCLASS   0x03
#define VCPM_FILEFIRSTIN    0x0200
#define VCPM_FILEFIRSTOUT   0x0300
#define VCPM_FILELAST       0x03FF

enum tagVCPM_FILE {
    VCPM_FILEOPENIN = VCPM_FILEFIRSTIN,
    VCPM_FILEGETFATTR,
    VCPM_FILECLOSEIN,
    VCPM_FILECOPY,
    VCPM_FILENEEDED,

    VCPM_FILEOPENOUT = VCPM_FILEFIRSTOUT,
    VCPM_FILESETFATTR,
    VCPM_FILECLOSEOUT,
    VCPM_FILEFINALIZE,
    VCPM_FILEDELETE,
    VCPM_FILERENAME,
    /* Remaining messages reserved for future use */
};

/*---------------------------------------------------------------------------*
 *          VIRTNODE callbacks
 *---------------------------------------------------------------------------*/

#define VCPM_NODECLASS  0x04
#define VCPM_NODEFIRST  0x0400
#define VCPM_NODELAST   0x04FF

enum tagVCPM_NODE {
    VCPM_NODECREATE = VCPM_NODEFIRST,
    VCPM_NODEACCEPT,
    VCPM_NODEREJECT,
    VCPM_NODEDESTROY,
    VCPM_NODECHANGEDESTDIR,
    VCPM_NODECOMPARE,
    /* Remaining messages reserved for future use */
};

/*---------------------------------------------------------------------------*
 *          TALLY callbacks
 *---------------------------------------------------------------------------*/

#define VCPM_TALLYCLASS     0x05
#define VCPM_TALLYFIRST     0x0500
#define VCPM_TALLYLAST      0x05FF

enum tagVCPM_TALLY {
    VCPM_TALLYSTART = VCPM_TALLYFIRST,
    VCPM_TALLYEND,
    VCPM_TALLYFILE,
    VCPM_TALLYDISK,
    /* Remaining messages reserved for future use */
};

/*---------------------------------------------------------------------------*
 *          VER callbacks
 *---------------------------------------------------------------------------*/

#define VCPM_VERCLASS       0x06
#define VCPM_VERFIRST       0x0600
#define VCPM_VERLAST        0x06FF

enum tagVCPM_VER {
    VCPM_VERCHECK = VCPM_VERFIRST,
    VCPM_VERCHECKDONE,
    VCPM_VERRESOLVECONFLICT,
    /* Remaining messages reserved for future use */
};

/*---------------------------------------------------------------------------*
 *          VSTAT callbacks
 *---------------------------------------------------------------------------*/

#define VCPM_VSTATCLASS     0x07
#define VCPM_VSTATFIRST     0x0700
#define VCPM_VSTATLAST      0x07FF

enum tagVCPM_VSTAT {
    VCPM_VSTATSTART = VCPM_VSTATFIRST,
    VCPM_VSTATEND,
    VCPM_VSTATREAD,
    VCPM_VSTATWRITE,
    VCPM_VSTATNEWDISK,

    VCPM_VSTATCLOSESTART,       // Start of VCP close
    VCPM_VSTATCLOSEEND,         // upon leaving VCP close
    VCPM_VSTATBACKUPSTART,      // Backup is beginning
    VCPM_VSTATBACKUPEND,        // Backup is finished
    VCPM_VSTATRENAMESTART,      // Rename phase start/end
    VCPM_VSTATRENAMEEND,
    VCPM_VSTATCOPYSTART,        // Acutal copy phase
    VCPM_VSTATCOPYEND,
    VCPM_VSTATDELETESTART,      // Delete phase
    VCPM_VSTATDELETEEND,
    VCPM_VSTATPATHCHECKSTART,   // Check for valid paths
    VCPM_VSTATPATHCHECKEND,
    VCPM_VSTATUSERABORT,        // User wants to quit.
    VCPM_VSTATYIELD,            // Do a yield.
    /* Remaining messages reserved for future use */
};

/*---------------------------------------------------------------------------*
 *          Destination info callbacks
 *---------------------------------------------------------------------------*/

/* ISSUE-2002/01/16-roelfc -- find a reasonable message range for this */
#define VCPM_PATHCLASS      0x08
#define VCPM_PATHFIRST      0x0800
#define VCPM_PATHLAST       0x08FF

enum tagVCPM_PATH{
    VCPM_BUILDPATH = VCPM_PATHFIRST,
    VCPM_UNIQUEPATH,
    VCPM_CHECKPATH,
};

// #define VCPM_BUILDPATH      0x83

/*****************************************************************************/
void WINAPI VcpAddMRUPath( LPCSTR lpszPath );
#define SZ_INSTALL_LOCATIONS "InstallLocationsMRU"

RETERR WINAPI VcpOpen(VIFPROC vifproc, LPARAM lparamMsgRef);

RETERR WINAPI VcpClose(WORD fl, LPCSTR lpszBackupDest);

RETERR WINAPI VcpFlush(WORD fl, LPCSTR lpszBackupDest);

#define VCPFL_ABANDON           0x0000  /* Abandon all pending file copies */
#define VCPFL_BACKUP            0x0001  /* Perform backup */
#define VCPFL_COPY              0x0002  /* Copy files */
#define VCPFL_BACKUPANDCOPY     (VCPFL_BACKUP | VCPFL_COPY)
#define VCPFL_INSPECIFIEDORDER  0x0004  /* Do not sort before copying */
#define VCPFL_DELETE            0x0008
#define VCPFL_RENAME            0x0010
#define VCPFL_ALL	        (VCPFL_COPY | VCPFL_DELETE | VCPFL_RENAME)

typedef int (CALLBACK *VCPENUMPROC)(LPVIRTNODE lpvn, LPARAM lparamRef);

int WINAPI vcpEnumFiles(VCPENUMPROC vep, LPARAM lparamRef);

enum tag_VCPM_EXPLAIN{
    VCPEX_SRC_DISK,
    VCPEX_SRC_CABINET,
    VCPEX_SRC_LOCN,
    VCPEX_DST_LOCN,
    VCPEX_SRC_FILE,
    VCPEX_DST_FILE,
    VCPEX_DOS_ERROR,
    VCPEX_MESSAGE,
    VCPEX_DOS_SOLUTION,
    VCPEX_SRC_FULL,
    VCPEX_DST_FULL,
};

LPCSTR WINAPI VcpExplain( LPVIRTNODE lpVn, DWORD dwWhat );

/* Flag bits that can be set via VcpQueueCopy */

// Various Lparams for files
#define VNLP_SYSCRITICAL    0x0001  // This file should not be skipped
#define VNLP_SETUPCRITICAL  0x0002  // This file cannot be skipped
#define VNLP_NOVERCHECK     0x0004  // This file must not be VerResolved.
#define VNLP_FORCETEMP      0x0008  // This file must left as a temp name
#define VNLP_IFEXISTS       0x0010  // File skipped if already on machine
#define VNLP_KEEPNEWER      0x0020  // If the dest file is newer - keep it (frosting)

// VcpEnumFiles Flags.

#define VEN_OP      0x00ff      /* Operation field */

#define VEN_NOP     0x0000      /* Do nothing */
#define VEN_DELETE  0x0001      /* Delete current item */
#define VEN_SET     0x0002      /* Change value of current item */

#define VEN_FL      0xff00      /* Flags field */

#define VEN_STOP    0x0100      /* Stop enumeration after this item */
#define VEN_ERROR   0x8000      /* Stop enumeration after this item
                                 * and ignore the OP field */

// ISSUE-2002/01/16-roelfc: add the other VCP stuff necessary to use this

// ISSUE-2002/01/16-roelfc: remove the lpsz*Dir fields, make overload the LDID with them

RETERR WINAPI VcpQueueCopy(LPCSTR lpszSrcFileName, LPCSTR lpszDstFileName,
                LPCSTR lpszSrcDir, LPCSTR lpszDstDir,
                LOGDISKID ldidSrc, LOGDISKID ldidDst,
                LPEXPANDVTBL lpExpandVtbl, WORD fl,
                LPARAM lParam);

RETERR WINAPI VcpQueueDelete( LPCSTR lpszDstFileName,
                              LPCSTR lpszDstDir,
                              LOGDISKID ldidDst,
                              LPARAM lParamRef );

RETERR WINAPI VcpQueueRename( LPCSTR      lpszSrcFileName,
                            LPCSTR      lpszDstFileName,
                            LPCSTR      lpszSrcDir,
                            LPCSTR      lpszDstDir,
                            LOGDISKID   ldidSrc,
                            LOGDISKID   ldidDst,
                            LPARAM      lParam );

#endif // NOVCP

#ifndef NOINF
/***************************************************************************/
//
// Inf Parser API declaration and definitions
//
/***************************************************************************/

enum _ERR_IP
{
    ERR_IP_INVALID_FILENAME = (IP_ERROR + 1),
    ERR_IP_ALLOC_ERR,
    ERR_IP_INVALID_SECT_NAME,
    ERR_IP_OUT_OF_HANDLES,
    ERR_IP_INF_NOT_FOUND,
    ERR_IP_INVALID_INFFILE,
    ERR_IP_INVALID_HINF,
    ERR_IP_INVALID_FIELD,
    ERR_IP_SECT_NOT_FOUND,
    ERR_IP_END_OF_SECTION,
    ERR_IP_PROFILE_NOT_FOUND,
    ERR_IP_LINE_NOT_FOUND,
    ERR_IP_FILEREAD,
    ERR_IP_TOOMANYINFFILES,
    ERR_IP_INVALID_SAVERESTORE,
    ERR_IP_INVALID_INFTYPE
};

#define INFTYPE_TEXT                0
#define INFTYPE_EXECUTABLE          1

#define MAX_SECT_NAME_LEN    32

typedef struct _INF NEAR * HINF;
typedef struct _INFLINE FAR * HINFLINE;            // tolken to inf line

RETERR  WINAPI IpOpen(LPCSTR pszFileSpec, HINF FAR * lphInf);
RETERR  WINAPI IpOpenEx(LPCSTR pszFileSpec, HINF FAR * lphInf, UINT InfType);
RETERR  WINAPI IpOpenAppend(LPCSTR pszFileSpec, HINF hInf);
RETERR  WINAPI IpOpenAppendEx(LPCSTR pszFileSpec, HINF hInf, UINT InfType);
RETERR  WINAPI IpSaveRestorePosition(HINF hInf, BOOL bSave);
RETERR  WINAPI IpClose(HINF hInf);
RETERR  WINAPI IpGetLineCount(HINF hInf, LPCSTR lpszSection, int FAR * lpCount);
RETERR  WINAPI IpFindFirstLine(HINF hInf, LPCSTR lpszSect, LPCSTR lpszKey, HINFLINE FAR * lphRet);
RETERR  WINAPI IpFindNextLine(HINF hInf, HINFLINE FAR * lphRet);
RETERR  WINAPI IpFindNextMatchLine(HINF hInf, LPCSTR lpszKey, HINFLINE FAR * lphRet);
RETERR  WINAPI IpGetProfileString(HINF hInf, LPCSTR lpszSec, LPCSTR lpszKey, LPSTR lpszBuf, int iBufSize);
RETERR  WINAPI IpGetFieldCount(HINF hInf, HINFLINE hInfLine, int FAR * lpCount);
RETERR  WINAPI IpGetFileName(HINF hInf, LPSTR lpszBuf, int iBufSize);
RETERR  WINAPI IpGetIntField(HINF hInf, HINFLINE hInfLine, int iField, int FAR * lpVal);
RETERR  WINAPI IpGetLongField(HINF hInf, HINFLINE hInfLine, int iField, long FAR * lpVal);
RETERR  WINAPI IpGetStringField(HINF hInf, HINFLINE hInfLine, int iField, LPSTR lpBuf, int iBufSize, int FAR * lpuCount);
RETERR  WINAPI IpGetVersionString(LPSTR lpszInfFile, LPSTR lpszValue, LPSTR lpszBuf, int cbBuf, LPSTR lpszDefaultValue);

#endif // NOINF

#ifndef NOTEXTPROC
/***************************************************************************/
//
// Text processing API declaration and definitions
//
/***************************************************************************/

/* Relative/absolute positioning */
#define SEC_SET 1       // Absolute positioning (relative to the start)
#define SEC_END 2       // Realtive to the end
#define SEC_CUR 3       // Relative to the current line.

#define SEC_OPENALWAYS          1   // Always open a section, no error if it does not exist
#define SEC_OPENEXISTING        2   // Open an existing section, an error given if it does not exist.
#define SEC_OPENNEWALWAYS       3   // Open a section (present or not) and discard its contents.
#define SEC_OPENNEWEXISTING     4   // Open an existing section (discarding its contents). Error if not existing

// Flags for TP_OpenFile().
//
  // Use autoexec/config.sys key delimiters
  //
#define TP_WS_KEEP      1

  // If TP code running under SETUP, the foll. flag specifies whether
  // to cache this file or not! Use this, if you want to read a whole
  // file in when doing the TpOpenSection()!
  //
#define TP_WS_DONTCACHE 2

// The following are simple errors
enum {
    ERR_TP_NOT_FOUND = (TP_ERROR + 1),  // line, section, file etc.
                    // not necessarily terminal
    ERR_TP_NO_MEM,      // couldn't perform request - generally terminal
    ERR_TP_READ,        // could not read the disc - terminal
    ERR_TP_WRITE,       // could not write the data - terminal.
    ERR_TP_INVALID_REQUEST, // Multitude of sins - not necessarily terminal.
    ERR_TP_INVALID_LINE         // Invalid line from DELETE_LINE etc.
};

/* Data handles */
DECLARE_HANDLE(HTP);
typedef HTP FAR * LPHTP;

/* File handles */
DECLARE_HANDLE(HFN);
typedef HFN FAR * LPHFN;

typedef UINT TFLAG;
typedef UINT LINENUM, FAR * LPLINENUM;

#define MAX_REGPATH     256     // Max Registry Path Length
#define LINE_LEN        256     // ISSUE-2002/01/16-roelfc: max line length?
#define SECTION_LEN     32      // ISSUE-2002/01/16-roelfc: max length of a section name?
#define MAX_STRING_LEN  512     // ISSUE-2002/01/16-roelfc: review this

/* Function prototypes */
RETERR  WINAPI TpOpenFile(LPCSTR Filename, LPHFN phFile, TFLAG Flag);
RETERR  WINAPI TpCloseFile(HFN hFile);
RETERR  WINAPI TpOpenSection(HFN hfile, LPHTP phSection, LPCSTR Section, TFLAG flag);
RETERR  WINAPI TpCloseSection(HTP Section);
RETERR  WINAPI TpCommitSection(HFN hFile, HTP hSection, LPCSTR Section, TFLAG flag);
LINENUM WINAPI TpGetLine(HTP hSection, LPCSTR key, LPCSTR value, int rel, int orig, LPLINENUM lpLineNum );
LINENUM WINAPI TpGetNextLine(HTP hSection, LPCSTR key, LPCSTR value, LPLINENUM lpLineNum );
RETERR  WINAPI TpInsertLine(HTP hSection, LPCSTR key, LPCSTR value, int rel, int orig, TFLAG flag);
RETERR  WINAPI TpReplaceLine(HTP hSection, LPCSTR key, LPCSTR value, int rel, int orig, TFLAG flag);
RETERR  WINAPI TpDeleteLine(HTP hSection, int rel, int orig,TFLAG flag);
RETERR  WINAPI TpMoveLine(HTP hSection, int src_rel, int src_orig, int dest_rel, int dest_orig, TFLAG flag);
RETERR  WINAPI TpGetLineContents(HTP hSection, LPSTR buffer, UINT bufsize, UINT FAR * lpActualSize,int rel, int orig, TFLAG flag);

// UINT    WINAPI TpGetWindowsDirectory(LPSTR lpDest, UINT size);
// UINT    WINAPI TpGetSystemDirectory(LPSTR lpDest, UINT size);

int  WINAPI TpGetPrivateProfileString(LPCSTR lpszSect, LPCSTR lpszKey, LPCSTR lpszDefault, LPSTR lpszReturn, int nSize, LPCSTR lpszFile);
int  WINAPI TpWritePrivateProfileString(LPCSTR lpszSect, LPCSTR lpszKey, LPCSTR lpszString, LPCSTR lpszFile);
int  WINAPI TpGetProfileString(LPCSTR lpszSect, LPCSTR lpszKey, LPCSTR lpszDefault, LPSTR lpszReturn, int nSize);
BOOL WINAPI TpWriteProfileString(LPCSTR lpszSect , LPCSTR lpszKey , LPCSTR lpszString);

#endif // NOTEXTPROC

#ifndef NOGENINSTALL
/***************************************************************************/
//
// Generic Installer prototypes and definitions
//
/***************************************************************************/

enum _ERR_GENERIC
{
    ERR_GEN_LOW_MEM = GEN_ERROR+1,  // Insufficient memory.
    ERR_GEN_INVALID_FILE,           // Invalid INF file.
    ERR_GEN_LOGCONFIG,              // Can't process LogConfig=.
    ERR_GEN_CFGAUTO,                // Can't process CONFIG.SYS/AUTOEXEC.BAT
    ERR_GEN_UPDINI,                 // Can't process UpdateInis=.
    ERR_GEN_UPDINIFIELDS,           // Can't process UpdateIniFields=.
    ERR_GEN_ADDREG,                 // Can't process AddReg=.
    ERR_GEN_DELREG,                 // Can't process DelReg=.
    ERR_GEN_INI2REG,                // Can't process Ini2Reg=.
    ERR_GEN_FILE_COPY,              // Can't process CopyFiles=.
    ERR_GEN_FILE_DEL,               // Can't process DelFiles=.
    ERR_GEN_FILE_REN,               // Can't process RenFiles=.
    ERR_GEN_REG_API,                // Error returned by Reg API.
    ERR_GEN_DO_FILES,               // can't do Copy, Del or RenFiles.
};

// The cbSize field will always be set to sizeof(GENCALLBACKINFO_S).
// All unused fields (for the operation) will be not be initialized.
// For example, when the operation is GENO_DELFILE, the Src fields will
// not have any sensible values (Dst fields will be set correctly) as
// VcpQueueDelete only accepts Dst parameters.
//
/***************************************************************************
 * GenCallbackINFO structure passed to GenInstall CallBack functions.
 ***************************************************************************/
typedef struct _GENCALLBACKINFO_S { /* gen-callback struc */
    WORD         cbSize;                 // Size of this structure (bytes).
    WORD         wOperation;             // Operation being performed.
    LOGDISKID    ldidSrc;                // Logical Disk ID for Source.
    LPCSTR       pszSrcSubDir;           // Source sub-dir off of the LDID.
    LPCSTR       pszSrcFileName;         // Source file name (base name).
    LOGDISKID    ldidDst;                // Logical Disk ID for Dest.
    LPCSTR       pszDstSubDir;           // Dest. sub-dir off of the LDID.
    LPCSTR       pszDstFileName;         // Dest. file name (base name).
    LPEXPANDVTBL lpExpandVtbl;           // ISSUE-2002/01/16-roelfc: Needed? NULL right now!
    WORD         wflags;                 // flags for VcpQueueCopy.
    LPARAM       lParam;                 // LPARAM to the Vcp API.
} GENCALLBACKINFO_S, FAR *LPGENCALLBACKINFO;

/***************************************************************************
 * GenCallback notification codes -- callback proc returns 1 of foll. values.
 ***************************************************************************/
#define GENN_OK         0       /* All is hunky-dory. Do the VCP operation */
#define GENN_PROCEED    0       /* The same as GENN_OK */

#define GENN_ABORT      (-1)    /* Cancel current GenInstall altogether */
#define GENN_SKIP       (-2)    /* Skip this file and continue */

/***************************************************************************
 * VCP Operation being performed by GenInstall() -- wOperation values in
 * GENCALLBACKINFO structure above.
 ***************************************************************************/
#define GENO_COPYFILE   1       /* VCP copyfile being done */
#define GENO_DELFILE    2       /* VCP delfile being done */
#define GENO_RENFILE    3       /* VCP renfile being done */
#define GENO_WININITRENAME 4    /* VCP wininit rename being added */

typedef LRESULT (CALLBACK *GENCALLBACKPROC)(LPGENCALLBACKINFO lpGenInfo,
                                                            LPARAM lparamRef);

RETERR WINAPI GenInstall( HINF hinfFile, LPCSTR szInstallSection, WORD wFlags );
RETERR WINAPI GenInstallEx( HINF hInf, LPCSTR szInstallSection, WORD wFlags,
                                HKEY hRegKey, GENCALLBACKPROC CallbackProc,
                                LPARAM lparam);
RETERR WINAPI GenWinInitRename(LPCSTR szNew, LPSTR szOld, LOGDISKID ldid);
RETERR WINAPI GenCopyLogConfig2Reg(HINF hInf, HKEY hRegKey,
                                                LPCSTR szLogConfigSection);
void   WINAPI GenFormStrWithoutPlaceHolders( LPSTR szDst, LPCSTR szSrc,
                                                                HINF hInf ) ;
// Flags for GenAddReg() from INf /GenSURegSetValueEx()
//
#define FLG_ADDREG_BINVALUETYPE  1
#define FLG_ADDREG_NOCLOBBER     2
#define FLG_ADDREG_DELVAL        4

RETERR WINAPI GenSURegSetValueEx(HKEY hkeyRoot, LPCSTR szSubKey,
                         LPCSTR lpszValueName, DWORD dwValType,
                         LPBYTE lpszValue, DWORD dwValSize, UINT uFlags );

// A devnode is just a DWORD and this is easier than
// having to include configmg.h for everybody
RETERR WINAPI GenInfLCToDevNode(ATOM atInfFileName, LPSTR lpszSectionName,
                                BOOL bInstallSec, UINT InfType, 
                                DWORD dnDevNode);

// Bit fields for GenInstall() (for wFlags parameter) -- these can be OR-ed!
#define GENINSTALL_DO_FILES     1
#define GENINSTALL_DO_INI       2
#define GENINSTALL_DO_REG       4
#define GENINSTALL_DO_INI2REG   8
#define GENINSTALL_DO_CFGAUTO   16
#define GENINSTALL_DO_LOGCONFIG 32
#define GENINSTALL_DO_INIREG    (GENINSTALL_DO_INI | \
                                 GENINSTALL_DO_REG | \
                                 GENINSTALL_DO_INI2REG)
#define GENINSTALL_DO_ALL       (GENINSTALL_DO_FILES | \
                                    GENINSTALL_DO_INIREG | \
                                    GENINSTALL_DO_CFGAUTO | \
                                    GENINSTALL_DO_LOGCONFIG)

#endif // NOGENINSTALL

#ifndef NODEVICENSTALL
/***************************************************************************/
//
// Device Installer prototypes and definitions
//
/***************************************************************************/

/*******************************************************************************
*   AUTODOC
*   @doc    EXTERNAL SETUPX DEVICE_INSTALLER
*
*   @typee    _ERR_DEVICE_INSTALL | Error return codes for Device Installation
*   APIs.
*
*   @emem ERR_DI_INVALID_DEVICE_ID | Incorrectly formed device ID.
*
*   @emem ERR_DI_INVALID_COMPATIBLE_DEVICE_LIST | Invalid compatible device list.
*
*   @emem ERR_DI_REG_API | Error returned by one of the registry API.
*
*   @emem ERR_DI_LOW_MEM | Insufficient memory to complete.
*
*   @emem ERR_DI_BAD_DEV_INFO | A passed in DEVICE_INFO struct is invalid.
*
*   @emem ERR_DI_INVALID_CLASS_INSTALLER | The class installer is listed incorrecrly
*   in the registry, or points to an invalid class installer.
*
*   @emem ERR_DI_DO_DEFAULT | Do the default action for the requested operation.
*
*   @emem ERR_DI_USER_CANCEL | The user cancelled the operation.
*
*   @emem ERR_DI_NOFILECOPY | No need to copy files (in install).
*
*   @emem ERR_DI_BAD_CLASS_INFO | A passed in CLASS_INFO struct is invalid.
*
*   @emem ERR_DI_BAD_INF | An invalid INF file was encountered.
*
*   @emem ERR_DI_BAD_MOVEDEV_PARAMS | A passed in MOVEDEVICE_PARAMS struct was
*   invalid.
*
*   @emem ERR_DI_NO_INF | No INF found on supplied OEM path.
*
*   @emem ERR_DI_BAD_PROPCHANGE_PARAMS | A passed in PROPCHANGE_PARMS struct was
*   invalid.
*
*   @emem ERR_DI_BAD_SELECTDEVICE_PARAMS | A passed in SELECTEDEVICE_PARAMS struct
*   was invalid.
*
*   @emem ERR_DI_BAD_REMOVEDEVICE_PARAMS | A passed in REMOVEDEVICE_PARAMS struct
*   was invalid.
*
*   @emem ERR_DI_BAD_ENABLECLASS_PARAMS | A passed in ENABLECLASS_PARAMS struct
*   was invalid.
*
*   @emem ERR_DI_FAIL_QUERY | The queried action should not take place.
*
*   @emem ERR_DI_API_ERROR | One of the Device installation APIs was called
*   incorrectly or with invalid parameters.
*
*   @emem ERR_DI_BAD_PATH | An OEM path was specified incorrectly.
*
*******************************************************************************/
enum _ERR_DEVICE_INSTALL
{
    ERR_DI_INVALID_DEVICE_ID = DI_ERROR,    // Incorrectly formed device IDF
    ERR_DI_INVALID_COMPATIBLE_DEVICE_LIST,  // Invalid compatible device list
    ERR_DI_REG_API,                         // Error returned by Reg API.
    ERR_DI_LOW_MEM,                         // Insufficient memory to complete
    ERR_DI_BAD_DEV_INFO,                    // Device Info struct invalid
    ERR_DI_INVALID_CLASS_INSTALLER,         // Registry entry / DLL invalid
    ERR_DI_DO_DEFAULT,                      // Take default action
    ERR_DI_USER_CANCEL,                     // the user cancelled the operation
    ERR_DI_NOFILECOPY,                      // No need to copy files (in install)
    ERR_DI_BAD_CLASS_INFO,                  // Class Info Struct invalid
    ERR_DI_BAD_INF,                         // Bad INF file encountered
    ERR_DI_BAD_MOVEDEV_PARAMS,	            // Bad Move Device Params struct
    ERR_DI_NO_INF,                          // No INF found on OEM disk
    ERR_DI_BAD_PROPCHANGE_PARAMS,           // Bad property change param struct
    ERR_DI_BAD_SELECTDEVICE_PARAMS,         // Bad Select Device Parameters
    ERR_DI_BAD_REMOVEDEVICE_PARAMS,         // Bad Remove Device Parameters
    ERR_DI_BAD_ENABLECLASS_PARAMS,          // Bad Enable Class Parameters
    ERR_DI_FAIL_QUERY,                      // Fail the Enable Class query
    ERR_DI_API_ERROR,                       // DI API called incorrectly
    ERR_DI_BAD_PATH,                        // An OEM path was specified incorrectly
};

/*******************************************************************************
*   AUTODOC
*   @doc    EXTERNAL SETUPX DEVICE_INSTALLER
*
*   @types    DRIVER_INFO | This structure contains the information necessary
*   to present the user with a select device dialog.
*
*   @field WORD | cbSize | Size of this structure in bytes.
*
*   @field struct _DRIVER_INFO FAR | *lpNextInfo | Pointer to the next DRIVER_INFO
*   struct in a linked list.
*                 
*   @field LPSTR | lpszDescription | Pointer to the description of the device being
*   supported by this driver.
*
*   @field LPSTR | lpszMfgName | Pointer to the name of the manufacture of this
*   driver.
*
*   @field LPSTR | lpszProviderName | Pointer to provider of this driver if the
*   lpdi->Flags has the DI_MULTMFGS flag set.
*
*   @field WORD | Rank | The Rank match of this driver.  Ranks go from 0 to n, where 0 
*   is the most compatible.
*
*   @field DWORD | dwFlags | Flags that control the use of this driver node.  These
*   are the same as the flags defined for a DRIVER_NODE.
*       @flag DNF_DUPDESC           | This driver has the same device description 
*       from by more than one provider.
*       @flag DNF_OLDDRIVER         | Driver node specifies old/current driver
*       @flag DNF_EXCLUDEFROMLIST   | If set, this driver node will not be displayed
*       in any driver select dialogs.
*       @flag DNF_NODRIVER          | Set if we want to install no driver e.g no mouse drv
*
*   @field LPARAM | lpReserved | Reserved for use by the Device Installer.
*
*   @field DWORD | dwPrivateData | Reserved for use by the Device Installer.
*
*******************************************************************************/
typedef struct _DRIVER_INFO
{
    WORD                        cbSize;                     // Size of this structure in bytes
    struct _DRIVER_INFO FAR*    lpNextInfo;
    LPSTR                       lpszDescription;
    LPSTR                       lpszMfgName;
    LPSTR                       lpszProviderName;           // ONLY valid if DI_MULTMFGS is set in the LPDI
    WORD                        Rank;
    DWORD                       dwFlags;          
    LPARAM                      lpReserved;
    DWORD                       dwPrivateData;
} DRIVER_INFO, *PDRIVER_INFO, FAR *LPDRIVER_INFO;

/*******************************************************************************
*   AUTODOC
*   @doc    EXTERNAL SETUPX DEVICE_INSTALLER
*
*   @types    DRIVER_NODE | This strucure represents a driver which can be 
*   installed for a specific device.
*
*   @field struct _DRIVER_NODE FAR* | lpNextDN | Pointer to the next driver node
*   in a list.
*
*   @field UINT | Rank | The Rank match of this driver.  Ranks go from 0 to n, where 0 
*   is the most compatible.
*
*   @field UINT | InfType | Type of INF this driver cam from.  This will
*   be either INFTYPE_TEXT or INFTYPE_EXECUTABLE
*
*   @field unsigned | InfDate | DOS date stamp of the INF file.
*
*   @field LPSTR | lpszDescription | Pointer to a the descriptrion of the device being
*   supported by this driver.
*
*   @field LPSTR | lpszSectionName | Pointer to the name of INF install section for
*   this driver.
*
*   @field ATOM  | atInfFileName | Global ATOM containing the name of the INF file.
*
*   @field ATOM  | atMfgName | Global ATOM containing the name of this driver's 
*   manufacture.
*
*   @field ATOM  | atProviderName | Global ATOM containing the name of this driver's
*   provider.
*
*   @field DWORD | Flags | Flags that control functions using this DRIVER_NODE
*       @flag DNF_DUPDESC           | This driver has the same device description 
*       from by more than one provider.
*       @flag DNF_OLDDRIVER         | Driver node specifies old/current driver
*       @flag DNF_EXCLUDEFROMLIST   | If set, this driver node will not be displayed
*       in any driver select dialogs.
*       @flag DNF_NODRIVER          | Set if we want to install no driver e.g no mouse drv
*       @flag DNF_CONVERTEDLPINFO   | Set if this Driver Node was converted from an Info Node.
*       Setting this flag will cause the cleanup functions to explicitly delete it.
*
*   @field DWORD | dwPrivateData | Reserved
*
*   @field LPSTR | lpszDrvDescription | Pointer to a driver description.
*
*   @field LPSTR | lpszHardwareID | Pointer to a list of Plug-and-Play hardware IDs for 
*   this driver.
*   
*   @field LPSTR | lpszCompatIDs | Pointer to a list of Plug-and-Play compatible IDs for
*   this driver.
*
*******************************************************************************/
typedef struct _DRIVER_NODE {
    struct _DRIVER_NODE FAR* lpNextDN;
    UINT    Rank;
    UINT    InfType;
    unsigned    InfDate;
    LPSTR   lpszDescription;        // Compatibility: Contains the Device Desc.
    LPSTR   lpszSectionName;
    ATOM    atInfFileName;
    ATOM    atMfgName;
    ATOM    atProviderName;
    DWORD   Flags;
    DWORD   dwPrivateData;
    LPSTR   lpszDrvDescription;     // New contains an driver description
    LPSTR   lpszHardwareID;
    LPSTR   lpszCompatIDs;
}   DRIVER_NODE, NEAR* PDRIVER_NODE, FAR* LPDRIVER_NODE, FAR* FAR* LPLPDRIVER_NODE;

#define DNF_DUPDESC         0x00000001   // Multiple providers have same desc
#define DNF_OLDDRIVER       0x00000002   // Driver node specifies old/current driver
#define DNF_EXCLUDEFROMLIST 0x00000004  
#define DNF_NODRIVER	    0x00000008	 // if we want to install no driver e.g no mouse drv

#define DNF_CONVERTEDLPINFO 0x00000010  // Set if the Driver Node is a Converted Info Node

// possible types of "INF" files
#define INFTYPE_WIN4        1
#define INFTYPE_WIN3        2
#define INFTYPE_COMBIDRV    3
#define INFTYPE_PPD         4
#define INFTYPE_WPD     5
#define INFTYPE_CLASS_SPEC1 6
#define INFTYPE_CLASS_SPEC2 7
#define INFTYPE_CLASS_SPEC3 8
#define INFTYPE_CLASS_SPEC4 9

#define MAX_CLASS_NAME_LEN   32
#define MAX_DRIVER_INST_LEN  10

// NOTE:  Keep this in sync with confimg.h in \DDK\INC
#define MAX_DEVNODE_ID_LEN  256

/*******************************************************************************
*   AUTODOC
*   @doc    EXTERNAL SETUPX DEVICE_INSTALLER
*
*   @types    DEVICE_INFO | This is the basic data structure for most Device
*   installation APIs.  A DEVICE_INFO represents a device that is being installed
*   on the system, or an installed device that is being modified in some way.
*
*   @field UINT | cbSize | Size of the DEVICE_INFO struct.
*
*   @field struct _DEVICE_INFO FAR | *lpNextDi | Pointer to the next DEVICE_INFO struct
*   in a linked list.
*
*   @field char | szDescription[LINE_LEN] | Buffer containing the description of the 
*   device.
*
*   @field DWORD | dnDevnode | If set, this contains the address of the DevNode associated
*   with the device.
*
*   @field HKEY | hRegKey | An opened registry key that contains the device's registry
*   subkey.  This is usually HKEY_LOCAL_MACHINE.
*
*   @field char | szRegSubkey[MAX_DEVNODE_ID_LEN] | Buffer containing the device's 
*   hardware registry subkey.  This is key is rooted in hRegKey, and is ususally some 
*   place in the \\ENUM branch.
*
*   @field char | szClassName[MAX_CLASS_NAME_LEN] | Buffer containing the device's
*   class name.
*
*   @field DWORD | Flags | Flags for controlling installation and U/I functions. Some
*   flags can be set prior to calling device installer APIs, and other are set
*   automatically during the processing of some APIs.
*       @flag DI_SHOWOEM                  | Set if OEM disk support should be allowed
*       @flag DI_SHOWCOMPAT               | Will be set if only a compatible driver list
*       is being displayed by DiSelectDevice.
*       @flag DI_SHOWCLASS                | Will be set if only a Class driver list is
*       is being displayed by DiSelectDevice.
*       @flag DI_SHOWALL                  | Will be set if both a compatible driver list
*       and a class driver list are being shown by DiSelectDevice.
*       @flag DI_NOVCP                    | Set if no VCP (Virtual Copy Procedure) is 
*       desired during DiInstallDevice.
*       @flag DI_DIDCOMPAT                | Will be set if DiBuildCompatDrvList has been
*       done, and lpCompatDrvList points to this device's compatible driver list.
*       @flag DI_DIDCLASS                 | Will be set if DiBuildClassDrvList has been
*       done, and lpClassDrvList points to this device's class driver list.
*       @flag DI_AUTOASSIGNRES            | Unused.
*       @flag DI_NEEDRESTART              | Will be set if the device requires a restart
*       of Windows after installation or a state change.
*       @flag DI_NEEDREBOOT               | Will be set if the device requires a reboot
*       of the machine after installation or a state change.
*       @flag DI_NOBROWSE                 | Set to diable browsing when selecting an OEM
*       disk path.
*       @flag DI_MULTMFGS                 | Will be set if a class driver list, or class
*       info list contains multiple manufactures.
*       @flag DI_DISABLED                 | Unused.
*       @flag DI_GENERALPAGE_ADDED        | Set by a property page provider if a general
*       properties page has been added to the device's property sheet.
*       @flag DI_RESOURCEPAGE_ADDED       | Set by a property page provider if a resource
*       properties page has been added to the device's property sheet.
*       @flag DI_PROPERTIES_CHANGE        | Set if a device's properties have been changed
*       and require an update of the Device Manager's U/I.
*       @flag DI_INF_IS_SORTED            | Set if the INF containing drivers for this 
*       device is in sorted order.
*       @flag DI_ENUMSINGLEINF            | Set if DiBuildCompatDrvList and 
*       DiBuildlassDrvList should only search the INF file specificed by atDriverPath.
*       @flag DI_DONOTCALLCONFIGMG        | Set if the configuration manager should not
*       be called during DiInstallDevice.
*       @flag DI_INSTALLDISABLED          | Set if the device should be installed in a 
*       disabled state by default.
*       @flag DI_CLASSONLY                | Set if this DEVICE_INFO struct contains only
*       a class name.
*       @flag DI_CLASSINSTALLPARAMS       | Set if the lpClassIntallParams field points to
*       a class install parameter block.
*       @flag DI_NODI_DEFAULTACTION       | Set if DiCallClassInstaller should not 
*       perform any default action if the class installer return ERR_DI_DO_DEFAULT, or
*       there is not class installer.
*       @flag DI_QUIETINSTALL             | Set if device install API should be as 
*       silent as possible using default choices whereever possible.
*       @flag DI_NOFILECOPY               | Set if DiInstallDevice should skip file
*       copying.
*       @flag DI_FORCECOPY                | Set if DiInstallDevice should always
*       copy file, even if they are present on the system.
*       @flag DI_DRIVERPAGE_ADDED         | Set by a property page provider if a driver
*       properties page has been added to the device's property sheet.
*       @flag DI_USECI_SELECTSTRINGS      | Set if class installer provided strings 
*       should be used during DiSelectDevice.
*       @flag DI_OVERRIDE_INFFLAGS        | Unused.
*       @flag DI_PROPS_NOCHANGEUSAGE      | Set if there should be no Enable/Disable 
*       capability on the device's general property page.
*       @flag DI_NOSELECTICONS            | Set if no small icons should be used during
*       DiSelectDevice.
*       @flag DI_NOWRITE_IDS              | Set if DiInstallDevice should not write
*       the device's hardware and compatible IDs to the registry.
*   
*   @field HWND | hwndParent | Window handle that will own U/I dialogs related to this
*   device.
*
*   @field LPDRIVER_NODE | lpCompatDrvList | Pointer to a linked list of DRIVER_NODES 
*   representing the compatible drivers for this device.
*
*   @field LPDRIVER_NODE | lpClassDrvList | Pointer to a linked list of DRIVER_NODES
*   representing all drivers of this device's class.
*
*   @field LPDRIVER_NODE | lpSelectedDriver | Pointer to a single DRIVER_NODE that
*   has been selected as the driver for this device.
*
*   @field ATOM | atDriverPath | Global ATOM containing the path to this device's INF
*   file.  This is set only of the driver came from an OEM INF file.  This will be
*   0 if the INF is a standard Windows INF file.
*
*   @field ATOM | atTempInfFile | Global ATOM containing the name of a temporary INF
*   file for this device's drivers.  This is set if the drivers came from an old style
*   INF file and have been converted.
*
*   @field HINSTANCE | hinstClassInstaller | Class installer module instance.
*
*   @field HINSTANCE | hinstClassPropProvidor | Class Property Providor module instance.
*
*   @field HINSTANCE | hinstDevicePropProvidor | Device Property Providor module instance.
*
*   @field HINSTANCE | hinstBasicPropProvidor | Basic Property Providor module instance.
*
*   @field FARPROC | fpClassInstaller | Procedure address of class install function.
*
*   @field FARPROC | fpClassEnumPropPages | Procedure address of the Class property 
*   provider page enumeration function.
*
*   @field FARPROC | fpDeviceEnumPropPages | Procedure address of the Device property
*   provider page enumeration function.
*
*   @field FARPROC | fpEnumBasicProperties | Procedure address of the Basic device
*   property provider page enumeration function.
*
*   @field DWORD | dwSetupReserved | Reserved for use by Setup.
*
*   @field DWORD | dwClassInstallReserved | Reserved for use by Class Installers.
*
*   @field GENCALLBACKPROC | gicpGenInstallCallBack | Procedure address of a GenInstall
*   call back function.  This would be set if the class installer wanted to handle
*   GenInstall callbacks during DiInstallDevice.
*
*   @field LPARAM | gicplParam | lParam for the GenInstall Callback.                                                
*
*   @field UINT | InfType | The type of INF file being used.  This will be INFTYPE_TEXT
*   or INFTYPE_EXECUTABLE.
*
*   @field HINSTANCE | hinstPrivateProblemHandler | Module handle for the device's 
*   private problem procedure.
*
*   @field FARPROC | fpPrivateProblemHandler | Procedure address of the device's
*   private problem handler.
*
*   @field LPARAM | lpClassInstallParams | Pointer to a class install parameter block.
*   Class installer parameters are specific to the class install functions.
*
*   @field struct _DEVICE_INFO FAR | *lpdiChildList | Pointer to a linked list of
*   DRIVER_INFO structs representing children of this device.
*
*   @field DWORD | dwFlagsEx | Additional control flags.
*       @flag DI_FLAGSEX_USEOLDINFSEARCH  | Set if INF Search functions should not use 
*       indexed searching.
*       @flag DI_FLAGSEX_AUTOSELECTRANK0  | Set if DiSelectDevice should automatically
*       select rank 0 match drivers.
*       @flag DI_FLAGSEX_CI_FAILED        | Will be set internally if there was a 
*       failure to load or call a class installer.
*       @flag DI_FLAGSEX_DIDINFOLIST      | Will be set if DiBuildCompatDrvInfoList has
*       been called, and this device's compatible driver Info list has been built.
*       @flag DI_FLAGSEX_DIDCOMPATINFO    | Will be set if DiBuildClassDrvInfoList has
*       been called, and this device's class driver Info list has been built.
*       @flag DI_FLAGSEX_FILTERCLASSES    | If set, DiBuildClassDrvList, and 
*       DiBuildClassDrvInfoList will check for Class inclusion filters.  This means
*       devices will not be included in the list, if their class is marked as a
*       NoInstallClass class.
*       @flag DI_FLAGSEX_SETFAILEDINSTALL | If set, then if DiInstallDevice installs
*       a NULL driver, it will also set the FAILEDINSTALL config flag
*       @flag DI_FLAGSEX_DEVICECHANGE | If set, the device manager will rebuild it
*       tree of devices after the device property sheet is closed.
*       @flag DI_FLAGSEX_ALWAYSWRITEIDS | If set, and the flag, DI_NOWRITE_ID is clear
*       (ie that flag takes higher precedance) then always write Hardare and Compat
*       ids, even if they allready exist
*       @flag DI_FLAGSEX_ALLOWEXCLUDEDDRVS | If set, DiSelectDevice will display drivers
*       that have the Exlude From Select state
*       @flag DI_FLAGSEX_NOUIONQUERYREMOVE | If setup, DiInstallDevice will prevent 
*       U/I warnings during a query removal.  Any U/I wanings that would have been
*       displayed will be silently failed.
*   @field LPDRIVER_INFO | lpCompatDrvInfoList | Pointer to a linked list of
*   DRIVER_INFO structs that are compatible with this device.
*
*   @field LPDRIVER_INFO | lpClassDrvInfoList | Pointer to a linked list of 
*   DRIVER_INFO structs representing all drivers for this device's class.
*
*******************************************************************************/
typedef struct _DEVICE_INFO
{
    UINT                        cbSize;
    struct _DEVICE_INFO FAR     *lpNextDi;
    char                        szDescription[LINE_LEN];
    DWORD                       dnDevnode;
    HKEY                        hRegKey;
    char                        szRegSubkey[MAX_DEVNODE_ID_LEN]; 
    char                        szClassName[MAX_CLASS_NAME_LEN];
    DWORD                       Flags;
    HWND                        hwndParent;
    LPDRIVER_NODE               lpCompatDrvList;
    LPDRIVER_NODE               lpClassDrvList;
    LPDRIVER_NODE               lpSelectedDriver;
    ATOM                        atDriverPath;
    ATOM                        atTempInfFile;
    HINSTANCE                   hinstClassInstaller;            
    HINSTANCE                   hinstClassPropProvidor;         
    HINSTANCE                   hinstDevicePropProvidor;        
    HINSTANCE                   hinstBasicPropProvidor;         
    FARPROC                     fpClassInstaller;               
    FARPROC                     fpClassEnumPropPages;           
    FARPROC                     fpDeviceEnumPropPages;          
    FARPROC                     fpEnumBasicProperties;          
    DWORD                       dwSetupReserved;                
    DWORD                       dwClassInstallReserved;         
    GENCALLBACKPROC             gicpGenInstallCallBack;     
                                                
    LPARAM                      gicplParam;     
    UINT                        InfType;        
                                                
    HINSTANCE                   hinstPrivateProblemHandler;
    FARPROC                     fpPrivateProblemHandler;   
    LPARAM                      lpClassInstallParams;      
    struct _DEVICE_INFO FAR     *lpdiChildList;     
    DWORD                       dwFlagsEx;          
    LPDRIVER_INFO               lpCompatDrvInfoList;
    LPDRIVER_INFO               lpClassDrvInfoList;
} DEVICE_INFO, FAR * LPDEVICE_INFO, FAR * FAR * LPLPDEVICE_INFO;

#define ASSERT_DI_STRUC(lpdi) if (lpdi->cbSize != sizeof(DEVICE_INFO)) return (ERR_DI_BAD_DEV_INFO)

typedef struct _CLASS_INFO
{
    UINT        cbSize;
    struct _CLASS_INFO FAR* lpNextCi;
    LPDEVICE_INFO   lpdi;
    char                szDescription[LINE_LEN];
    char        szClassName[MAX_CLASS_NAME_LEN];
} CLASS_INFO, FAR * LPCLASS_INFO, FAR * FAR * LPLPCLASS_INFO;
#define ASSERT_CI_STRUC(lpci) if (lpci->cbSize != sizeof(CLASS_INFO)) return (ERR_DI_BAD_CLASS_INFO)

// flags for device choosing (InFlags)
#define DI_SHOWOEM                  0x00000001L     // support Other... button
#define DI_SHOWCOMPAT               0x00000002L     // show compatibility list
#define DI_SHOWCLASS                0x00000004L     // show class list
#define DI_SHOWALL                  0x00000007L
#define DI_NOVCP                    0x00000008L     // Don't do vcpOpen/vcpClose.
#define DI_DIDCOMPAT                0x00000010L     // Searched for compatible devices
#define DI_DIDCLASS                 0x00000020L     // Searched for class devices
#define DI_AUTOASSIGNRES            0x00000040L    // No UI for resources if possible

// flags returned by DiInstallDevice to indicate need to reboot/restart
#define DI_NEEDRESTART              0x00000080L     // Restart required to take effect
#define DI_NEEDREBOOT               0x00000100L     // Reboot required to take effect

// flags for device installation
#define DI_NOBROWSE                 0x00000200L     // no Browse... in InsertDisk

// Flags set by DiBuildClassDrvList
#define DI_MULTMFGS                 0x00000400L     // Set if multiple manufacturers in
                                                    // class driver list
// Flag indicates that device is disabled
#define DI_DISABLED                 0x00000800L     // Set if device disabled

// Flags for Device/Class Properties
#define DI_GENERALPAGE_ADDED        0x00001000L
#define DI_RESOURCEPAGE_ADDED       0x00002000L

// Flag to indicate the setting properties for this Device (or class) caused a change
// so the Dev Mgr UI probably needs to be updatd.
#define DI_PROPERTIES_CHANGE        0x00004000L

// Flag to indicate that the sorting from the INF file should be used.
#define DI_INF_IS_SORTED            0x00008000L

#define DI_ENUMSINGLEINF            0x00010000L

// The following flags can be used to install a device disabled
// and to prevent CONFIGMG being called when a device is installed
#define DI_DONOTCALLCONFIGMG        0x00020000L
#define DI_INSTALLDISABLED          0x00040000L

// This flag is set of this LPDI is really just an LPCI, ie
// it only contains class info, NO DRIVER/DEVICE INFO
#define DI_CLASSONLY                0x00080000L

// This flag is set if the Class Install params are valid
#define DI_CLASSINSTALLPARAMS       0x00100000L

// This flag is set if the caller of DiCallClassInstaller does NOT
// want the internal default action performed if the Class installer
// return ERR_DI_DO_DEFAULT
#define DI_NODI_DEFAULTACTION       0x00200000L

// ISSUE-2002/01/16-roelfc. This is a hack for M6 Net setup.  Net Setup does not work correctly
// if we process devnode syncronously.  This WILL be removed for M7 when
// Net setup is fixed to work with DiInstallDevice
#define DI_NOSYNCPROCESSING         0x00400000L

// flags for device installation
#define DI_QUIETINSTALL             0x00800000L     // don't confuse the user with
                                                    // questions or excess info
#define DI_NOFILECOPY               0x01000000L     // No file Copy necessary
#define DI_FORCECOPY                0x02000000L     // Force files to be copied from install path
#define DI_DRIVERPAGE_ADDED         0x04000000L     // Prop providor added Driver page.
#define DI_USECI_SELECTSTRINGS      0x08000000L     // Use Class Installer Provided strings in the Select Device Dlg
#define DI_OVERRIDE_INFFLAGS        0x10000000L     // Override INF flags
#define DI_PROPS_NOCHANGEUSAGE      0x20000000L     // No Enable/Disable in General Props

#define DI_NOSELECTICONS	    0x40000000L     // No small icons in select device dialogs

#define DI_NOWRITE_IDS		    0x80000000L     // Don't write HW & Compat IDs on install

#define DI_FLAGSEX_USEOLDINFSEARCH  0x00000001L  // Inf Search functions should not use Index Search
#define DI_FLAGSEX_AUTOSELECTRANK0  0x00000002L  // DiSelectDevice doesn't propmt user if rank 0 match
#define DI_FLAGSEX_CI_FAILED        0x00000004L  // Failed to Load/Call class installer

#define DI_FLAGSEX_DIDINFOLIST      0x00000010L  // Did the Class Info List
#define DI_FLAGSEX_DIDCOMPATINFO    0x00000020L  // Did the Compat Info List

#define DI_FLAGSEX_FILTERCLASSES        0x00000040L
#define DI_FLAGSEX_SETFAILEDINSTALL     0x00000080L
#define DI_FLAGSEX_DEVICECHANGE         0x00000100L
#define DI_FLAGSEX_ALWAYSWRITEIDS       0x00000200L
#define DI_FLAGSEX_ALLOWEXCLUDEDDRVS    0x00000800L
#define DI_FLAGSEX_NOUIONQUERYREMOVE    0x00001000L

// Defines for class installer functions
#define DIF_SELECTDEVICE            0x0001
#define DIF_INSTALLDEVICE           0x0002
#define DIF_ASSIGNRESOURCES         0x0003
#define DIF_PROPERTIES              0x0004
#define DIF_REMOVE                  0x0005
#define DIF_FIRSTTIMESETUP          0x0006
#define DIF_FOUNDDEVICE             0x0007
#define DIF_SELECTCLASSDRIVERS      0x0008
#define DIF_VALIDATECLASSDRIVERS    0x0009
#define DIF_INSTALLCLASSDRIVERS     0x000A
#define DIF_CALCDISKSPACE           0x000B
#define DIF_DESTROYPRIVATEDATA      0x000C
#define DIF_VALIDATEDRIVER          0x000D
#define DIF_MOVEDEVICE              0x000E
#define DIF_DETECT                  0x000F
#define DIF_INSTALLWIZARD           0x0010
#define DIF_DESTROYWIZARDDATA       0x0011
#define DIF_PROPERTYCHANGE          0x0012
#define DIF_ENABLECLASS             0x0013
#define DIF_DETECTVERIFY            0x0014
#define DIF_INSTALLDEVICEFILES      0x0015

typedef UINT        DI_FUNCTION;    // Function type for device installer

/*******************************************************************************
*   AUTODOC
*   @doc    EXTERNAL SETUPX DEVICE_INSTALLER
*
*   @types    ENABLECLASS_PARAMS | DIF_ENABLECLASS class install parameters
*
*   @field UINT | cbSize | Size of the ENABLECLASS_PARAMS struct.
*
*   @field LPSTR | szClass | The class that is being enabled.
*
*   @field WORD | wEnableMsg | Specifies the stage of enabling.
*   Can be one of:
*
*   @const ENABLECLASS_QUERY | The class is about to be enabled.  Return
*   ERR_DI_DO_DEFAULT to allow the class to be enabled, or ERR_DI_FAIL_QUERY
*   to prevent the class from being enabled.
*
*   @const ENABLECLASS_SUCCESS | The enabling of the class has succeeded,
*   return ERR_DI_DO_DEFAULT.
*
*   @const ENABLECLASS_FAILURE | The enabling of the class has failed,
*   return ERR_DI_DO_DEFAULT.
*
*******************************************************************************/
// DIF_ENABLECLASS parameter struct.
typedef struct _ENABLECLASS_PARAMS
{
    UINT            cbSize;
    LPSTR           szClass;
    WORD            wEnableMsg;
} ENABLECLASS_PARAMS, FAR * LPENABLECLASS_PARAMS;
#define ASSERT_ENABLECLASSPARAMS_STRUC(lpecp) if (lpecp->cbSize != sizeof(ENABLECLASS_PARAMS)) return (ERR_DI_BAD_ENABLECLASS_PARAMS)

#define ENABLECLASS_QUERY   0
#define ENABLECLASS_SUCCESS 1
#define ENABLECLASS_FAILURE 2

/*******************************************************************************
*   AUTODOC
*   @doc    EXTERNAL SETUPX DEVICE_INSTALLER
*
*   @types    MOVEDEV_PARAMS | DIF_MOVEDEVICE class install parameters
*
*   @field UINT | cbSize | Size of the MOVDEV_PARAMS struct.
*
*   @field LPDEVICE_INFO | lpdiOldDev  | Pointer to the device that is being 
*   moved.
*
*******************************************************************************/
typedef struct _MOVEDEV_PARAMS
{
    UINT            cbSize;
    LPDEVICE_INFO   lpdiOldDev;     // References the Device Begin Moved
} MOVEDEV_PARAMS, FAR * LPMOVEDEV_PARAMS;
#define ASSERT_MOVEDEVPARAMS_STRUC(lpmdp) if (lpmdp->cbSize != sizeof(MOVEDEV_PARAMS)) return (ERR_DI_BAD_MOVEDEV_PARAMS)

/*******************************************************************************
*   AUTODOC
*   @doc    EXTERNAL SETUPX DEVICE_INSTALLER
*
*   @types    PROPCHANGE_PARAMS | DIF_PROPCHANGE class install parameters
*
*   @field UINT | cbSize | Size of the PROPCHANGE_PARAMS struct.
*
*   @field DWORD | dwStateChange | State change action. See DiChangeState for details.
*
*   @field DWORD | dwFlags | Flags specific to the type of state change.
*
*   @field DWORD | dwConfigID | Configuration ID for config specific changes.
*
*   @xref DiChangeState.
*
*******************************************************************************/
typedef struct _PROPCHANGE_PARAMS
{
    UINT            cbSize;
    DWORD           dwStateChange;
    DWORD           dwFlags;
    DWORD           dwConfigID;
} PROPCHANGE_PARAMS, FAR * LPPROPCHANGE_PARAMS;
#define ASSERT_PROPCHANGEPARAMS_STRUC(lpmdp) if (lpmdp->cbSize != sizeof(PROPCHANGE_PARAMS)) return (ERR_DI_BAD_PROPCHANGE_PARAMS)

#define MAX_TITLE_LEN           60
#define MAX_INSTRUCTION_LEN     256
#define MAX_LABEL_LEN           30
/*******************************************************************************
*   AUTODOC
*   @doc    EXTERNAL SETUPX DEVICE_INSTALLER
*
*   @types    SELECTDEVICE_PARAMS | DIF_SELECTDEVICE class install parameters
*
*   @field UINT | cbSize | Size of the SELECTDEVICE_PARAMS struct.
*
*   @field char | szTitle[MAX_TITLE_LEN] | Buffer containing a class installer
*   provided title for the Select Device dialogs.
*
*   @field char | szInstructions[MAX_INSTRUCTION_LEN] |  Buffer containing 
*   class installer provided Select Device instructions.
*
*   @field char | szListLabel[MAX_LABEL_LEN] | Buffer containing a lable
*   of the Select Device list of drivers.
*
*******************************************************************************/
typedef struct _SELECTDEVICE_PARAMS
{
    UINT            cbSize;
    char            szTitle[MAX_TITLE_LEN];
    char            szInstructions[MAX_INSTRUCTION_LEN];
    char            szListLabel[MAX_LABEL_LEN];
} SELECTDEVICE_PARAMS, FAR * LPSELECTDEVICE_PARAMS;
#define ASSERT_SELECTDEVICEPARAMS_STRUC(p) if (p->cbSize != sizeof(SELECTDEVICE_PARAMS)) return (ERR_DI_BAD_SELECTDEVICE_PARAMS)

#define DI_REMOVEDEVICE_GLOBAL                  0x00000001
#define DI_REMOVEDEVICE_CONFIGSPECIFIC          0x00000002
/*******************************************************************************
*   AUTODOC
*   @doc    EXTERNAL SETUPX DEVICE_INSTALLER
*
*   @types    REMOVEDEVICE_PARAMS | DIF_REMOVE class install parameters
*
*   @field UINT | cbSize | Size of the REMOVEDEVICE_PARAMS struct.
*
*   @field DWORD | dwFlags | Flags indicating the type of removal to perform.
*       @flag DI_REMOVEDEVICE_GLOBAL         | The device will be removed globally.
*       @flag DI_REMOVEDEVICE_CONFIGSPECIFIC | The device will be removed from only
*       the specified configuration.
*
*   @field DWORD | dwConfigID |  If DI_REMOVEDEVICE_CONFIGSPECIFIC is set, then
*   this is the configuration the device will be removed from. 0 means the current
*   config.
*
*******************************************************************************/
typedef struct _REMOVEDEVICE_PARAMS
{
    UINT            cbSize;
    DWORD           dwFlags;
    DWORD           dwConfigID;
} REMOVEDEVICE_PARAMS, FAR * LPREMOVEDEVICE_PARAMS;
#define ASSERT_REMOVEDPARAMS_STRUC(p) if (p->cbSize != sizeof(REMOVEDEVICE_PARAMS)) return (ERR_DI_BAD_REMOVEDEVICE_PARAMS)

/*******************************************************************************
*   AUTODOC
*   @doc    EXTERNAL SETUPX DEVICE_INSTALLER
*
*   @type NONE | Dynamic Hardware Install Wizard Constants | Constants that are
*   used when adding custom pages to the hardware install wizard.
*
*   @const MAX_INSTALLWIZARD_DYNAPAGES | The maximum number of dynamic hardware 
*   installation wizard pages that can be added by a class installer.
*
*   @const IDD_DYNAWIZ_FIRSTPAGE | Resource ID for the first page that the install 
*   wizard will go to after adding the class installer pages.
*
*   @const IDD_DYNAWIZ_SELECT_PREVPAGE | Resource ID for the page that the Select 
*   Device page will go back to.
*
*   @const IDD_DYNAWIZ_SELECT_NEXTPAGE | Resource ID for the page that the Select 
*   Device page will go forward to.
*
*   @const IDD_DYNAWIZ_ANALYZE_PREVPAGE | Resource ID for the page that the Analyze 
*   page will go back to. This will only be used in the event that there is a 
*   problem (i.e a conflict), and the user selects Back from the analyze page.
*
*   @const IDD_DYNAWIZ_ANALYZE_NEXTPAGE | Resource ID for the page that the Analyze 
*   page will go to if it continues forward.  The wAnalyzeResult in the 
*   INSTALLWIZARDDATA struct will contain the anaysis results.
*
*   @const IDD_DYNAWIZ_INSTALLDETECTED_PREVPAGE | Resource ID for that page that the
*   Install detected devices page will go back to.
*
*   @const IDD_DYNAWIZ_INSTALLDETECTED_NEXTPAGE | Resource ID for the page that the
*   Install detected devices page will go forward to.
*
*   @const IDD_DYNAWIZ_INSTALLDETECTED_NODEVS | Resource ID for the page that the
*   Install detected devices page will go to in the event that no devices are 
*   detected.
*
*   @const IDD_DYNAWIZ_SELECTDEV_PAGE | Resource ID of the hardware install wizard's
*   select device page.  This ID can be used to go directly to the hardware install
*   wizard's select device page.
*
*   @const IDD_DYNAWIZ_ANALYZEDEV_PAGE | Resource ID of the hardware install wizard's
*   device analysis page.  This ID can be use to go directly to the hardware install
*   wizard's analysis page.
*
*   @const IDD_DYNAWIZ_INSTALLDETECTEDDEVS_PAGE | Resource ID of the hardware install
*   wizard's install detected devices page.  This ID can be use to go directly to
*   the hardware install wizard's install detected devices page.
*
*   @const IDD_DYNAWIZ_SELECTCLASS_PAGE | Resource ID of the hardware install wizard's
*   select class page.  This ID can be use to go directly to the hardware install 
*   wizard's select class page.
*
*******************************************************************************/
// DIF_INSTALLWIZARD  Wizard Data
#define MAX_INSTALLWIZARD_DYNAPAGES             20

// Use this ID for the first page that the install wizard should dynamically jump to.
#define IDD_DYNAWIZ_FIRSTPAGE                   10000

// Use this ID for the page that the Select Device dialog should go back to
#define IDD_DYNAWIZ_SELECT_PREVPAGE             10001

// Use this ID for the page that the Select Device dialog should go to next
#define IDD_DYNAWIZ_SELECT_NEXTPAGE             10002
               
// Use this ID for the page that the Analyze dialog should go back to
// This will only be used in the event that there is a problem, and the user
// selects Back from the analyze proc.
#define IDD_DYNAWIZ_ANALYZE_PREVPAGE            10003

// Use this ID for the page that the Analyze dialog should go to if it continue from
// the analyze proc.  the wAnalyzeResult in the INSTALLDATA struct will
// contain the anaysis results.
#define IDD_DYNAWIZ_ANALYZE_NEXTPAGE            10004

// This dialog will be selected if the user chooses back from the
// Install Detected Devices dialog.
#define IDD_DYNAWIZ_INSTALLDETECTED_PREVPAGE    10006

// This dialog will be selected if the user chooses Next from the
// Install Detected Devices dialog.
#define IDD_DYNAWIZ_INSTALLDETECTED_NEXTPAGE    10007

// This is the ID of the dialog to select if detection does not
// find any new devices
#define IDD_DYNAWIZ_INSTALLDETECTED_NODEVS      10008
   
// This is the ID of the Select Device Wizard page.
#define IDD_DYNAWIZ_SELECTDEV_PAGE              10009

// This is the ID of the Analyze Device Wizard page.
#define IDD_DYNAWIZ_ANALYZEDEV_PAGE             10010

// This is the ID of the Install Detected Devs Wizard page.
#define IDD_DYNAWIZ_INSTALLDETECTEDDEVS_PAGE    10011

// This is the ID of the Select Class Wizard page.
#define IDD_DYNAWIZ_SELECTCLASS_PAGE            10012

// This flag is set if a Class installer has added pages to the
// install wizard.
#define DYNAWIZ_FLAG_PAGESADDED             0x00000001

// The following flags will control the button states when displaying
// the InstallDetectedDevs dialog.  
#define DYNAWIZ_FLAG_INSTALLDET_NEXT        0x00000002
#define DYNAWIZ_FLAG_INSTALLDET_PREV        0x00000004

// Set this flag if you jump to the analyze page, and want it to
// handle conflicts for you.  NOTE.  You will not get control back 
// in the event of a conflict if you set this flag.
#define DYNAWIZ_FLAG_ANALYZE_HANDLECONFLICT 0x00000008

#define ANALYZE_FACTDEF_OK      1
#define ANALYZE_STDCFG_OK       2
#define ANALYZE_CONFLICT        3
#define ANALYZE_NORESOURCES     4
#define ANALYZE_ERROR           5
#define ANALYZE_PNP_DEV         6
#define ANALYZE_PCMCIA_DEV      7

/*******************************************************************************
*   AUTODOC
*   @doc    EXTERNAL SETUPX DEVICE_INSTALLER
*
*   @types    INSTALLWIZARDDATA | DIF_INSTALLWIZARD class install parameters. This
*   struct is used by class installers to extend the operation of the hardware
*   installation wizard by adding custom pages.
*
*   @field UINT | cbSize | Size of the INSTALLWIZARDDATA struct.
*
*   @field LPDEVICE_INFO | lpdiOriginal | Pointer to the Original DEVICE_INFO
*   struct at the start of the manual installation.
*
*   @field LPDEVICE_INFO | lpdiSelected | Pointer to the current DEVICE_INFO struct
*   that is being manually selected.
*
*   @field DWORD | dwFlags | Flags that control the operation of the hardware
*   installation wizard.  There are currently none defined.
*
*   @field LPVOID | lpConfigData | Pointer to configuration data for analysis to
*   determine if the selected device can be installed with no conflicts.
*
*   @field WORD | wAnalyzeResult | Results of analysis to determine if the device
*   can be installed with no problems.  The following values are defined:
*       @flag ANALYZE_FACTDEF_OK    | The device can be installed using its factory
*       default settings.
*       @flag ANALYZE_STDCFG_OK     | The device can be installed using a configuration
*       specified in one if its basic logical configurations.  The user will probably
*       have to set jumpers or switches on the hardware to match the settings determined
*       by the install wizard.
*       @flag ANALYZE_CONFLICT      | The device cannot be installed without causing a
*       conflict with another device.
*       @flag ANALYZE_NORESOURCES   | The device does not require any resources, so it
*       can be installed witth no conflicts.
*       @flag ANALYZE_ERROR         | There was an error during analysis.
*       @flag ANALYZE_PNP_DEV       | The device has a least one softsettable logical
*       configurations, allowing it to be automatically configured.  Additionally the
*       device will be enumerated by one of the standard bus enumerators, so it does
*       not require manual installation, except to pre-copy driver files.
*
*   @field HPROPSHEETPAGE | hpsDynamicPages[MAX_INSTALLWIZARD_DYNAPAGES] | An
*   array of property sheet page handles.  The class installer would use this array
*   to create custom wizard pages, and insert their handles into this array.
*
*   @field WORD | wNumDynaPages | The number of pages inserted into the hpsDynamicPages
*   array.
*
*   @field DWORD | dwDynaWizFlags | Flags that control the behavior of the
*   installation wizard whtn dynamic pages have been added.
*       @flag DYNAWIZ_FLAG_PAGESADDED | Will be set by the install wizard if the
*       class installer adds custom pages.
*       @flag DYNAWIZ_FLAG_INSTALLDET_NEXT | If set, the install wizard will allow
*       going forward from the detected devices page, otherwise finish will
*       be the default option for the detected devices page.
*       @flag DYNAWIZ_FLAG_INSTALLDET_PREV | If set, the install wizard will allow
*       going back from the detected devices page.
*       @flag DYNAWIZ_FLAG_ANALYZE_HANDLECONFLICT | If set, the class installer will 
*       handle the case where the selected device cannot be installed because of
*       a conflict.
*
*   @field DWORD | dwPrivateFlags | Flags that may be defined and used by the class
*   installer.
*
*   @field LPARAM | lpPrivateData | Pointer to private reference data defined and
*   set by the class installer.
*
*   @field LPSTR | lpExtraRunDllParams | Pointer to a string containing extra 
*   parameters passed to the hardware install rundll function.
*
*   @field HWND | hwndWizardDlg | Window handle of the install wizard top level 
*   window.
*
*******************************************************************************/
typedef struct InstallWizardData_tag        
{
    UINT                    cbSize;
    
    LPDEVICE_INFO           lpdiOriginal;
    LPDEVICE_INFO           lpdiSelected;
    DWORD                   dwFlags;
    LPVOID                  lpConfigData;
    WORD                    wAnalyzeResult;
        
    // The following fields are used when a Class Installer Extends the Install Wizard
    HPROPSHEETPAGE          hpsDynamicPages[MAX_INSTALLWIZARD_DYNAPAGES];
    WORD                    wNumDynaPages;
    DWORD                   dwDynaWizFlags;
    DWORD                   dwPrivateFlags;
    LPARAM                  lpPrivateData;
    LPSTR                   lpExtraRunDllParams;    
    HWND                    hwndWizardDlg;
} INSTALLWIZDATA, * PINSTALLWIZDATA , FAR *LPINSTALLWIZDATA;

RETERR WINAPI DiCreateDeviceInfo(
    LPLPDEVICE_INFO lplpdi,     // Ptr to ptr to dev info
    LPCSTR      lpszDescription,    // If non-null then description string
    DWORD       hDevnode,       // ISSUE-2002/01/16-roelfc -- MAKE A DEVNODE
    HKEY        hkey,       // Registry hkey for dev info
    LPCSTR      lpszRegsubkey,  // If non-null then reg subkey string
    LPCSTR      lpszClassName,  // If non-null then class name string
    HWND        hwndParent);    // If non-null then hwnd of parent

RETERR WINAPI DiGetClassDevs(
    LPLPDEVICE_INFO lplpdi,     // Ptr to ptr to dev info
    LPCSTR      lpszClassName,  // Must be name of class
    HWND        hwndParent,     // If non-null then hwnd of parent
    int         iFlags);        // Options

RETERR WINAPI DiGetClassDevsEx(
    LPLPDEVICE_INFO lplpdi,     // Ptr to ptr to dev info
    LPCSTR      lpszClassName,  // Must be name of class
    LPCSTR      lpszEnumerator, // Must be name of enumerator, or NULL
    HWND        hwndParent,     // If non-null then hwnd of parent
    int         iFlags);        // Options
    
#define DIGCF_DEFAULT           0x0001  // NOT IMPLEMENTED!
#define DIGCF_PRESENT           0x0002
#define DIGCF_ALLCLASSES        0x0004
#define DIGCF_PROFILE           0x0008

// API to return the Class name of an INF File
RETERR WINAPI DiGetINFClass(LPSTR lpszMWDPath, UINT InfType, LPSTR lpszClassName, DWORD dwcbClassName);

RETERR WINAPI PASCAL DiCreateDevRegKey(
    LPDEVICE_INFO   lpdi,
    LPHKEY      lphk,
    HINF        hinf,
    LPCSTR      lpszInfSection,
    int         iFlags);
    
RETERR WINAPI PASCAL DiDeleteDevRegKey(LPDEVICE_INFO lpdi, int  iFlags);

RETERR WINAPI PASCAL DiOpenDevRegKey(
    LPDEVICE_INFO   lpdi,
    LPHKEY      lphk,
    int         iFlags);

#define DIREG_DEV	0x0001		// Open/Create/Delete device key
#define DIREG_DRV	0x0002		// Open/Create/Delete driver key
#define DIREG_BOTH	0x0004		// Delete both driver and Device key

RETERR WINAPI DiReadRegLogConf
(
    LPDEVICE_INFO       lpdi,
    LPSTR               lpszConfigName,
    LPBYTE FAR          *lplpbLogConf,
    LPDWORD             lpdwSize
);

RETERR WINAPI DiReadRegConf
(
    LPDEVICE_INFO       lpdi,
    LPBYTE FAR          *lplpbLogConf,
    LPDWORD             lpdwSize,
    DWORD               dwFlags
);

#define DIREGLC_FORCEDCONFIG        0x00000001
#define DIREGLC_BOOTCONFIG          0x00000002

RETERR WINAPI DiCopyRegSubKeyValue
(
    HKEY    hkKey,
    LPSTR   lpszFromSubKey,
    LPSTR   lpszToSubKey,
    LPSTR   lpszValueToCopy
);

RETERR WINAPI DiDestroyClassInfoList(LPCLASS_INFO lpci);
RETERR WINAPI DiBuildClassInfoList(LPLPCLASS_INFO lplpci);

#define DIBCI_NOINSTALLCLASS        0x000000001
#define DIBCI_NODISPLAYCLASS        0x000000002

RETERR WINAPI DiBuildClassInfoListEx(LPLPCLASS_INFO lplpci, DWORD dwFlags);
RETERR WINAPI DiGetDeviceClassInfo(LPLPCLASS_INFO lplpci, LPDEVICE_INFO lpdi);

RETERR WINAPI DiDestroyDeviceInfoList(LPDEVICE_INFO lpdi);
RETERR WINAPI DiSelectDevice( LPDEVICE_INFO lpdi );
RETERR WINAPI DiSelectOEMDrv(HWND hDlg, LPDEVICE_INFO lpdi);

// Callback for diInstallDevice vcpOpen.  Basically calls vcpUICallback for everthing
// except when DI_FORCECOPY is active, in which case copies get defaulted to
// VCPN_FORCE
LRESULT CALLBACK diInstallDeviceUICallbackProc(LPVOID lpvObj, UINT uMsg, WPARAM wParam, LPARAM lParam, LPARAM lparamRef);
RETERR WINAPI DiInstallDevice( LPDEVICE_INFO lpdi );
RETERR WINAPI DiInstallDriverFiles(LPDEVICE_INFO lpdi);

RETERR WINAPI DiRemoveDevice( LPDEVICE_INFO lpdi );
RETERR WINAPI DiAskForOEMDisk(LPDEVICE_INFO lpdi);

RETERR WINAPI DiCallClassInstaller(DI_FUNCTION diFctn, LPDEVICE_INFO lpdi);

BOOL WINAPI DiBuildDriverIndex(BOOL bUI);
BOOL WINAPI DiAddSingleInfToDrvIdx(LPSTR lpszInfName, WORD InfType, BOOL bCreate);

RETERR WINAPI DiBuildCompatDrvList(LPDEVICE_INFO lpdi);
RETERR WINAPI DiBuildClassDrvList(LPDEVICE_INFO lpdi);
RETERR WINAPI DiBuildCompatDrvInfoList(LPDEVICE_INFO lpdi);
RETERR WINAPI DiBuildClassDrvInfoList(LPDEVICE_INFO lpdi);
RETERR WINAPI DiDestroyDrvInfoList(LPDRIVER_INFO lpInfo);
LPDRIVER_NODE WINAPI DiConvertDriverInfoToDriverNode(LPDEVICE_INFO lpdi, LPDRIVER_INFO lpInfo);    

typedef RETERR (CALLBACK *OLDINFPROC)(HINF hinf, LPCSTR lpszNewInf, LPARAM lParam);
RETERR WINAPI DiBuildClassDrvListFromOldInf(LPDEVICE_INFO lpdi, LPCSTR lpszSection, OLDINFPROC lpfnOldInfProc, LPARAM lParam);

RETERR WINAPI DiDestroyDriverNodeList(LPDRIVER_NODE lpdn);

RETERR  WINAPI  DiMoveDuplicateDevNode(LPDEVICE_INFO lpdiNewDev);

// The following export will load a dll and find the specified proc name
typedef RETERR (FAR PASCAL *DIINSTALLERPROPERTIES)(LPDEVICE_INFO);

RETERR WINAPI GetFctn(HKEY hk, LPSTR lpszRegVal, LPSTR lpszDefProcName,
                      HINSTANCE FAR * lphinst, FARPROC FAR *lplpfn);
                        
RETERR
WINAPI
DiCreateDriverNode(
    LPLPDRIVER_NODE lplpdn,
    UINT    Rank,
    UINT    InfType,
    unsigned    InfDate,
    LPCSTR  lpszDevDescription,
    LPCSTR  lpszDrvDescription,
    LPCSTR  lpszProviderName,
    LPCSTR  lpszMfgName,
    LPCSTR  lpszInfFileName,
    LPCSTR  lpszSectionName,
    DWORD   dwPrivateData);

RETERR WINAPI DiLoadClassIcon(
    LPCSTR  szClassName,
    HICON FAR *lphiLargeIcon,
    int FAR *lpiMiniIconIndex);

RETERR WINAPI DiInstallDrvSection(
    LPCSTR  lpszInfFileName,
    LPCSTR  lpszSection,
    LPCSTR  lpszClassName,
    LPCSTR  lpszDescription,
    DWORD   dwFlags);

RETERR WINAPI DiChangeState(LPDEVICE_INFO lpdi, DWORD dwStateChange, DWORD dwFlags, LPARAM lParam);

#define DICS_ENABLE                 0x00000001
#define DICS_DISABLE                0x00000002
#define DICS_PROPCHANGE 	    0x00000003
#define DICS_START		    0x00000004
#define DICS_STOP		    0x00000005

#define DICS_FLAG_GLOBAL            0x00000001
#define DICS_FLAG_CONFIGSPECIFIC    0x00000002
#define DICS_FLAG_CONFIGGENERAL     0x00000004

RETERR WINAPI DiInstallClass(LPCSTR lpszInfFileName, DWORD dwFlags);

RETERR WINAPI DiOpenClassRegKey(LPHKEY lphk, LPCSTR lpszClassName);

// support routine for dealing with class mini icons
#define DMI_MASK            0x0001
#define DMI_BKCOLOR         0x0002
#define DMI_USERECT         0x0004
int WINAPI PASCAL DiDrawMiniIcon(HDC hdc, RECT rcLine, int iMiniIcon, DWORD flags);
BOOL WINAPI DiGetClassBitmapIndex(LPCSTR lpszClass, int FAR *lpiMiniIconIndex);

// internal calls for display class
#define DISPLAY_SETMODE_SUCCESS     0x0001
#define DISPLAY_SETMODE_DRVCHANGE   0x0002
#define DISPLAY_SETMODE_FONTCHANGE  0x0004

UINT WINAPI Display_SetMode(LPDEVICE_INFO lpdi, UINT uColorRes, int iXRes, int iYRes);
RETERR WINAPI Display_ClassInstaller(DI_FUNCTION diFctn, LPDEVICE_INFO lpdi);
RETERR WINAPI Display_OpenFontSizeKey(LPHKEY lphkFontSize);
BOOL WINAPI Display_SetFontSize(LPCSTR lpszFontSize);

RETERR WINAPI DiIsThereNeedToCopy(HWND hwnd, DWORD dwFlags);

#define DINTC_NOCOPYDEFAULT	    0x00000001

// API for the mouse class installer
RETERR WINAPI Mouse_ClassInstaller(DI_FUNCTION diFctn, LPDEVICE_INFO lpdi);
#endif // NODEVICEINSTALL

// API for determining if a Driver file is currently part of VMM32.VxD
BOOL WINAPI bIsFileInVMM32
(
    LPSTR   lpszFileName
);

#ifndef NOUSERINTERFACE
/***************************************************************************/
//
// User Interface prototypes and definitions
//
/***************************************************************************/

BOOL WINAPI UiMakeDlgNonBold(HWND hDlg);
VOID WINAPI UiDeleteNonBoldFont(HWND hDlg);

#endif

/***************************************************************************/
//
// setup reg DB calls, use just like those in kernel
//
/***************************************************************************/

DWORD WINAPI SURegOpenKey(HKEY hKey, LPCSTR lpszSubKey, HKEY FAR *lphkResult);
DWORD WINAPI SURegCloseKey(HKEY hKey);
DWORD WINAPI SURegCreateKey(HKEY hKey, LPCSTR lpszSubKey, HKEY FAR *lphkResult);
DWORD WINAPI SURegDeleteKey(HKEY hKey, LPCSTR lpszSubKey);
DWORD WINAPI SURegEnumKey(HKEY hKey, DWORD dwIdx, LPSTR lpszBuffer, DWORD dwBufSize);
DWORD WINAPI SURegQueryValue16(HKEY hKey, LPCSTR lpszSubKey, LPSTR lpValueBuf, DWORD FAR *ldwBufSize);
DWORD WINAPI SURegSetValue16(HKEY hKey, LPCSTR lpszSubKey, DWORD dwType, LPCBYTE lpszValue, DWORD dwValSize);
DWORD WINAPI SURegDeleteValue(HKEY hKey,LPCSTR lpszValue);
DWORD WINAPI SURegEnumValue(HKEY hKey,DWORD dwIdx, LPCSTR lpszValue, DWORD FAR *lpcbValue, DWORD FAR *lpdwReserved, DWORD FAR *lpdwType, LPBYTE lpbData, DWORD FAR *lpcbData);
DWORD WINAPI SURegQueryValueEx(HKEY hKey,LPCSTR lpszValueName, DWORD FAR *lpdwReserved,DWORD FAR *lpdwType,LPSTR lpValueBuf, DWORD FAR *ldwBufSize);
DWORD WINAPI SURegSetValueEx(HKEY hKey,LPCSTR lpszValueName, DWORD dwReserved, DWORD dwType, LPBYTE lpszValue, DWORD dwValSize);
DWORD WINAPI SURegSaveKey(HKEY hKey, LPCSTR lpszFileName, LPVOID lpsa);
DWORD WINAPI SURegLoadKey(HKEY hKey, LPCSTR lpszSubKey, LPCSTR lpszFileName);
DWORD WINAPI SURegUnLoadKey(HKEY hKey, LPCSTR lpszSubKey);

DWORD WINAPI SURegFlush(VOID);
DWORD WINAPI SURegInit(VOID);    // should be called before any other Reg APIs

/***************************************************************************/
// setup FormatMessage support
/***************************************************************************/
#define MB_LOG  (UINT)-1
#define MB_DBG  (UINT)-2

UINT FAR CDECL suFormatMessage(HINSTANCE hAppInst, LPCSTR lpcFormat, LPSTR szMessage, UINT uSize,
    ...);
UINT WINAPI suvFormatMessage(HINSTANCE hAppInst, LPCSTR lpcFormat, LPSTR szMessage, UINT uSize,
    LPVOID FAR * lpArgs);
int WINCAPI _loadds suFormatMessageBox(HINSTANCE hAppInst, HWND hwndParent, LPCSTR lpcText, LPCSTR lpcTitle,
    UINT uStyle, ...);

WORD WINAPI suErrorToIds( WORD Value, WORD Class );

/***************************************************************************/
// setup Version Conflict support
/***************************************************************************/

LPVOID WINAPI suVerConflictInit(BOOL fYesToLangMismatch);
void WINAPI suVerConflictTerm(LPVOID lpvData);
LRESULT WINAPI suVerConflict(HWND hwnd, LPVCPVERCONFLICT lpvc, LPVOID lpvData);
int WINAPI sxCompareDosAppVer( LPCSTR lpszOldFileSpec, LPCSTR lpszNewFileSpec);

/***************************************************************************/
// setup Help support
/***************************************************************************/

BOOL WINAPI suHelp( HWND hwndApp, HWND hwndDlg );

//***************************************************************************/
// setup Emergency Boot Disk (EBD) creation fn.
//***************************************************************************/

RETERR WINAPI suCreateEBD( HWND hWnd, VIFPROC CopyCallbackProc, LPARAM lpuii );

//***************************************************************************
// Misc SETUPX.DLL support functions.
//***************************************************************************
#ifdef  NEC_98                         // for support AT Boot
#endif  //NEC_98

RETERR WINAPI SUGetSetSetupFlags(LPDWORD lpdwFlags, BOOL bSet);

RETERR WINAPI CfgSetupMerge( int uFlags );
BOOL WINAPI sxIsMSDOS7Running();

#ifndef LPLPSTR
    typedef LPSTR (FAR *LPLPSTR);
#endif

//***************************************************************************
//
// ENUMS for accessing config.sys/autoexec.bat line objects using the
// array returned by ParseConfigLine()..
//
//***************************************************************************

enum    CFGLINE_STRINGS                     // Config.sys/autoexec.bat objects
{
    CFG_KEYLEAD,                            // Keyword leading whitespaces
    CFG_KEYWORD,                            // Keyword
    CFG_KEYTRAIL,                           // Keyword trailing delimiters
    CFG_UMBINFO,                            // Load high info
    CFG_DRVLETTER,                          // Drive letter for cmd path
    CFG_PATH,                               // Command path
    CFG_COMMAND,                            // Command base name
    CFG_EXT,                                // Command extension including '.'
    CFG_ARGS,                               // Command arguments
    CFG_FREE,                               // Free area at end of buffer
    CFG_END
};

/*---------------------------------------------------------------------------*
 *                  SUB String Data 
 *---------------------------------------------------------------------------*/

/*******************************************************************************
*   AUTODOC
*   @doc    EXTERNAL SETUPX DEVICE_INSTALLER
*
*   @types    SUBSTR_DATA | Data structure used to manage substrings.
*   struct is used by class installers to extend the operation of the hardware
*   installation wizard by adding custom pages.
*
*   @field LPSTR | lpFirstSubstr | Pointer to the first substring in the list.
*
*   @field LPSTR | lpCurSubstr | Pointer to the current substring in the list.
*
*   @field LPSTR | lpLastSubstr | Pointer to the last substring in the list.
*
*   @xref InitSubstrData
*   @xref GetFirstSubstr
*   @xref GetNextSubstr
*
*******************************************************************************/
typedef struct _SUBSTR_DATA {
    LPSTR lpFirstSubstr;
    LPSTR lpCurSubstr;
    LPSTR lpLastSubstr;
}   SUBSTR_DATA;

typedef SUBSTR_DATA*		PSUBSTR_DATA;
typedef SUBSTR_DATA NEAR*	NPSUBSTR_DATA;
typedef SUBSTR_DATA FAR*	LPSUBSTR_DATA;

BOOL WINAPI InitSubstrData(LPSUBSTR_DATA lpSubstrData, LPSTR lpStr);
BOOL WINAPI GetFirstSubstr(LPSUBSTR_DATA lpSubstrData);
BOOL WINAPI GetNextSubstr(LPSUBSTR_DATA lpSubStrData);

BOOL WINAPI FirstBootMoveToDOSSTART(LPSTR lpszCmd, BOOL fRemark);
BOOL WINAPI DOSOptEnableCurCfg(LPCSTR lpszOptKey);

/*---------------------------------------------------------------------------*
 *                  Misc. Di functions
 *---------------------------------------------------------------------------*/
BOOL WINAPI DiBuildPotentialDuplicatesList
(
    LPDEVICE_INFO   lpdi, 
    LPSTR           lpDuplicateList, 
    DWORD           cbSize,
    LPDWORD         lpcbData,
    LPSTR           lpstrDupType
);

// PID
BOOL _loadds WINAPI PidConstruct( LPSTR lpszProductType, LPSTR lpszPID, LPSTR lpszUPI, int iAction);
BOOL _loadds WINAPI PidValidate( LPSTR lpszProductType, LPSTR lpszPID);
int _loadds WINAPI WriteDMFBootData(int iDrive, LPSTR pData, int cb);

//***************************************************************************
#endif      // SETUPX_INC
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\hnw\win95\svrapi.h ===
/********************************************************************/
/**                     Microsoft Windows                          **/
/**               Copyright(c) Microsoft Corp., 1994               **/
/********************************************************************/

/********************************************************************
 *                                                                  *
 *  About this file ...  SVRAPI.H                                   *
 *                                                                  *
 *  This file contains information about the NetAccess,             *
 *  NetConnection, NetFile, NetServer, NetSession and NetShare APIs.*
 *  There is a section for each set of APIs.                        *
 *  Each section contains:                                          *
 *                                                                  *
 *      Function prototypes.                                        *
 *                                                                  *
 *      Data structure templates.                                   *
 *                                                                  *
 *      Definition of special values.                               *
 *                                                                  *
 ********************************************************************/

/*
 *      NOTE:  Lengths of ASCIIZ strings are given as the maximum
 *      strlen() value.  This does not include space for the
 *      terminating 0-byte.  When allocating space for such an item,
 *      use the form:
 *
 *              char username[LM20_UNLEN+1];
 *
 *      An exception to this is the PATHLEN manifest, which does
 *      include space for the terminating 0-byte.
 */

/*NOINC*/
#ifndef SVRAPI_INCLUDED
#define SVRAPI_INCLUDED

#include <lmcons.h>
#include <lmerr.h>

#ifndef RC_INVOKED
#pragma pack(1)         /* Assume byte packing throughout */
#endif

#ifdef __cplusplus
extern "C" {            /* Assume C declarations for C++ */
#endif	/* __cplusplus */

#if !defined(_SVRAPI_)
#define API_FUNCTION DECLSPEC_IMPORT API_RET_TYPE APIENTRY
#else
#define API_FUNCTION API_RET_TYPE APIENTRY
#endif

/*INC*/


/****************************************************************
 *                                                              *
 *                 Access Class                                 *
 *                                                              *
 ****************************************************************/


/****************************************************************
 *                                                              *
 *                  Function prototypes - ACCESS                *
 *                                                              *
 ****************************************************************/

extern API_FUNCTION
  NetAccessAdd ( const char FAR * pszServer,
                 short            sLevel,
                 char FAR *       pbBuffer,
                 unsigned short   cbBuffer );

extern API_FUNCTION
  NetAccessCheck ( char FAR *           pszReserved,
                   char FAR *           pszUserName,
                   char FAR *           pszResource,
                   unsigned short       usOperation,
                   unsigned short FAR * pusResult );

extern API_FUNCTION
  NetAccessDel ( const char FAR * pszServer,
                 char FAR *       pszResource );

extern API_FUNCTION
  NetAccessEnum ( const char FAR *     pszServer,
                  char FAR *           pszBasePath,
                  short                fsRecursive,
                  short                sLevel,
                  char FAR *           pbBuffer,
                  unsigned short       cbBuffer,
                  unsigned short FAR * pcEntriesRead,
                  unsigned short FAR * pcTotalAvail );

extern API_FUNCTION
  NetAccessGetInfo ( const char FAR *     pszServer,
                     char FAR *           pszResource,
                     short                sLevel,
                     char FAR *           pbBuffer,
                     unsigned short       cbBuffer,
                     unsigned short FAR * pcbTotalAvail );

extern API_FUNCTION
  NetAccessSetInfo ( const char FAR * pszServer,
                     char FAR *       pszResource,
                     short            sLevel,
                     char FAR *       pbBuffer,
                     unsigned short   cbBuffer,
                     short            sParmNum );

extern API_FUNCTION
  NetAccessGetUserPerms ( char FAR *           pszServer,
                          char FAR *           pszUgName,
                          char FAR *           pszResource,
                          unsigned short FAR * pusPerms );


/****************************************************************
 *                                                              *
 *              Data structure templates - ACCESS               *
 *                                                              *
 ****************************************************************/

struct access_list {
        char            acl_ugname[LM20_UNLEN+1];
        char            acl_ugname_pad_1;
        short           acl_access;
};      /* access_list */

struct access_list_2
{
        char FAR *      acl2_ugname;
        unsigned short  acl2_access;
};      /* access_list_2 */
             
struct access_list_12
{
        char FAR *      acl12_ugname;
        unsigned short  acl12_access;
};      /* access_list_12 */
             
struct access_info_0 {
        char FAR *      acc0_resource_name;
};      /* access_info_0 */

struct access_info_1 {
        char  FAR *     acc1_resource_name;
        short           acc1_attr;                      /* See values below */
        short           acc1_count;
};      /* access_info_1 */

struct access_info_2 
{
        char  FAR *     acc2_resource_name;
        short           acc2_attr;
        short           acc2_count;
};      /* access_info_2 */

struct access_info_10 {
        char FAR *      acc10_resource_name;
};      /* access_info_10 */

struct access_info_12 
{
        char  FAR *     acc12_resource_name;
        short           acc12_attr;
        short           acc12_count;
};      /* access_info_12 */


/****************************************************************
 *                                                              *
 *              Special values and constants - ACCESS           *
 *                                                              *
 ****************************************************************/

/*
 *      Maximum number of permission entries for each resource.
 */

#define MAXPERMENTRIES  64


/*
 *      Bit values for the access permissions.  ACCESS_ALL is a handy
 *      way to specify maximum permissions.  These are used in
 *      acl_access field of access_list structures.
 */
/*NOINC*/
#define         ACCESS_NONE     0
/*INC*/
#define         ACCESS_DELETE   0x10
#define         ACCESS_ATRIB    0x20
#define         ACCESS_PERM     0x40
#define         ACCESS_FINDFIRST 0x80

#define         ACCESS_GROUP    0x8000

/*
 *      Bit values for the acc1_attr field of the access_info_1 structure.
 *      Only one bit is currently defined.
 */

#define         ACCESS_AUDIT            0x1

/*
 *      Parmnum value for NetAccessSetInfo.
 */

#define         ACCESS_ATTR_PARMNUM     2


/*
 *      ACCESS_LETTERS defines a letter for each bit position in
 *      the acl_access field of struct access_list.  Note that some
 *      bits have a corresponding letter of ' ' (space).
 */

#define         ACCESS_LETTERS          "RWCXDAP         "



/****************************************************************
 *								*
 *	  	Share Class			                *
 *								*
 ****************************************************************/

/****************************************************************
 *                                                              *
 *              Function prototypes - SHARE                     *
 *                                                              *
 ****************************************************************/

extern API_FUNCTION
  NetShareAdd ( const char FAR * pszServer,
                short            sLevel,
                const char FAR * pbBuffer,
                unsigned short   cbBuffer );

extern API_FUNCTION
  NetShareDel ( const char FAR * pszServer,
                const char FAR * pszNetName,
                unsigned short   usReserved );

extern API_FUNCTION
  NetShareEnum ( const char FAR *     pszServer,
                 short                sLevel,
                 char FAR *           pbBuffer,
                 unsigned short       cbBuffer,
                 unsigned short FAR * pcEntriesRead,
                 unsigned short FAR * pcTotalAvail );

extern API_FUNCTION
  NetShareGetInfo ( const char FAR *     pszServer,
                    const char FAR *     pszNetName,
                    short                sLevel,
                    char FAR *           pbBuffer,
                    unsigned short       cbBuffer,
                    unsigned short FAR * pcbTotalAvail );

extern API_FUNCTION
  NetShareSetInfo ( const char FAR * pszServer,
                    const char FAR * pszNetName,
                    short            sLevel,
                    const char FAR * pbBuffer,
                    unsigned short   cbBuffer,
                    short            sParmNum );


/****************************************************************
 *								*
 *	  	Data structure templates - SHARE		*
 *								*
 ****************************************************************/

struct share_info_0 {
    char		shi0_netname[LM20_NNLEN+1];
};  /* share_info_0 */

struct share_info_1 {
    char		shi1_netname[LM20_NNLEN+1];
    char		shi1_pad1;
    unsigned short	shi1_type;
    char FAR *		shi1_remark;
};  /* share_info_1 */

struct share_info_2 {
    char		shi2_netname[LM20_NNLEN+1];
    char		shi2_pad1;
    unsigned short	shi2_type;
    char FAR *		shi2_remark;
    unsigned short	shi2_permissions;
    unsigned short	shi2_max_uses;
    unsigned short	shi2_current_uses;
    char FAR *		shi2_path;
    char 		shi2_passwd[SHPWLEN+1];
    char		shi2_pad2;
};  /* share_info_2 */

struct share_info_50 {
	char		shi50_netname[LM20_NNLEN+1];
	unsigned char 	shi50_type;
    unsigned short	shi50_flags;
	char FAR *	shi50_remark;
	char FAR *	shi50_path;
	char		shi50_rw_password[SHPWLEN+1];
	char		shi50_ro_password[SHPWLEN+1];
};	/* share_info_50 */


/****************************************************************
 *								*
 *	  	Special values and constants - SHARE		*
 *								*
 ****************************************************************/

/* Field values for shi50_flags; */

#define	SHI50F_RDONLY		0x0001
#define	SHI50F_FULL			0x0002
#define	SHI50F_DEPENDSON	(SHI50F_RDONLY|SHI50F_FULL)
#define	SHI50F_ACCESSMASK	(SHI50F_RDONLY|SHI50F_FULL)

#define	SHI50F_PERSIST		0x0100
#define SHI50F_SYSTEM		0x0200


/*
 *	Values for parmnum parameter to NetShareSetInfo.
 */

#define	SHI_REMARK_PARMNUM		4
#define	SHI_PERMISSIONS_PARMNUM		5
#define	SHI_MAX_USES_PARMNUM		6
#define	SHI_PASSWD_PARMNUM		9

#define	SHI1_NUM_ELEMENTS		4
#define	SHI2_NUM_ELEMENTS		10


/*
 *	Share types (shi1_type and shi2_type fields).
 */

#define STYPE_DISKTREE 			0
#define STYPE_PRINTQ   			1
#define STYPE_DEVICE   			2
#define STYPE_IPC      			3

#define SHI_USES_UNLIMITED		-1



/****************************************************************
 *								*
 *	  	Session Class			                *
 *								*
 ****************************************************************/

/****************************************************************
 *                                                              *
 *              Function prototypes - SESSION                   *
 *                                                              *
 ****************************************************************/

extern API_FUNCTION
  NetSessionDel ( const char FAR * pszServer,
                  const char FAR * pszClientName,
                  short            sReserved );

extern API_FUNCTION
  NetSessionEnum ( const char FAR *     pszServer,
                   short                sLevel,
                   char FAR *           pbBuffer,
                   unsigned short       cbBuffer,
                   unsigned short FAR * pcEntriesRead,
                   unsigned short FAR * pcTotalAvail );

extern API_FUNCTION
  NetSessionGetInfo ( const char FAR *     pszServer,
                      const char FAR *     pszClientName,
                      short                sLevel,
                      char FAR *           pbBuffer,
                      unsigned short       cbBuffer,
                      unsigned short FAR * pcbTotalAvail );


/****************************************************************
 *								*
 *		Data structure templates - SESSION		*
 *								*
 ****************************************************************/


struct session_info_0 {
    char FAR *		sesi0_cname;
};  /* session_info_0 */

struct session_info_1 {
    char FAR *		sesi1_cname;
    char FAR *		sesi1_username;
    unsigned short	sesi1_num_conns;
    unsigned short	sesi1_num_opens;
    unsigned short	sesi1_num_users;
    unsigned long	sesi1_time;
    unsigned long	sesi1_idle_time;
    unsigned long	sesi1_user_flags;
};  /* session_info_1 */

struct session_info_2 {
    char FAR *		 sesi2_cname;
    char FAR *		 sesi2_username;
    unsigned short	 sesi2_num_conns;
    unsigned short	 sesi2_num_opens;
    unsigned short	 sesi2_num_users;
    unsigned long	 sesi2_time;
    unsigned long	 sesi2_idle_time;
    unsigned long	 sesi2_user_flags;
    char FAR *		 sesi2_cltype_name;
};  /* session_info_2 */

struct session_info_10 {
        char FAR *     sesi10_cname;
        char FAR *     sesi10_username;
        unsigned long  sesi10_time;
        unsigned long  sesi10_idle_time;
};  /* session_info_10 */


struct session_info_50 {
	char FAR * sesi50_cname;
	char FAR * sesi50_username;
	unsigned long sesi50_key;
	unsigned short sesi50_num_conns;
	unsigned short sesi50_num_opens;
	unsigned long sesi50_time;
	unsigned long sesi50_idle_time;
	unsigned char sesi50_protocol; 
	unsigned char pad1;
};	/* session_info_50 */


/****************************************************************
 *								*
 *	  	Special values and constants - SESSION		*
 *								*
 ****************************************************************/

/*
 *	Bits defined in sesi1_user_flags.
 */

#define SESS_GUEST		1	/* session is logged on as a guest */
#define SESS_NOENCRYPTION	2	/* session is not using encryption */


#define SESI1_NUM_ELEMENTS	8
#define SESI2_NUM_ELEMENTS	9



/****************************************************************
 *								*
 *	  	Connection Class			        *
 *								*
 ****************************************************************/

/****************************************************************
 *                                                              *
 *              Function prototypes - CONNECTION                *
 *                                                              *
 ****************************************************************/

extern API_FUNCTION
  NetConnectionEnum ( const char FAR *     pszServer,
                      const char FAR *     pszQualifier,
                      short                sLevel,
                      char FAR *           pbBuffer,
                      unsigned short       cbBuffer,
                      unsigned short FAR * pcEntriesRead,
                      unsigned short FAR * pcTotalAvail );


/****************************************************************
 *								*
 *	  	Data structure templates - CONNECTION		*
 *								*
 ****************************************************************/

struct connection_info_0 {
    unsigned short	coni0_id;
};  /* connection_info_0 */

struct connection_info_1 {
    unsigned short	coni1_id;
    unsigned short	coni1_type;
    unsigned short	coni1_num_opens;
    unsigned short	coni1_num_users;
    unsigned long	coni1_time;
    char FAR *		coni1_username;
    char FAR *		coni1_netname;
};  /* connection_info_1 */

struct connection_info_50 {
	unsigned short coni50_type;
	unsigned short coni50_num_opens;
	unsigned long coni50_time;
	char FAR * coni50_netname;
	char FAR * coni50_username;
}; /* connection_info_50 */


/****************************************************************
 *								*
 *	  	File Class			                *
 *								*
 ****************************************************************/


/****************************************************************
 *                                                              *
 *              Function prototypes - FILE                      *
 *                                                              *
 ****************************************************************/

extern API_FUNCTION
  NetFileClose2 ( const char FAR * pszServer,
                  unsigned long    ulFileId );

extern API_FUNCTION
  NetFileEnum ( const char FAR *     pszServer,
                const char FAR *     pszBasePath,
                short                sLevel,
                char FAR *           pbBuffer,
                unsigned short       cbBuffer,
                unsigned short FAR * pcEntriesRead,
                unsigned short FAR * pcTotalAvail );


/****************************************************************
 *								*
 *	  	Data structure templates - FILE			*
 *								*
 ****************************************************************/

struct file_info_0 {
    unsigned short	fi0_id;
};  /* file_info_0 */

struct file_info_1 {
    unsigned short	fi1_id;
    unsigned short	fi1_permissions;
    unsigned short	fi1_num_locks;
    char FAR *		fi1_pathname;
    char FAR *		fi1_username;
};  /* file_info_1 */

struct file_info_2 {
    unsigned long	fi2_id;
};  /* file_info_2 */

struct file_info_3 {
    unsigned long	fi3_id;
    unsigned short	fi3_permissions;
    unsigned short	fi3_num_locks;
    char FAR *		fi3_pathname;
    char FAR *		fi3_username;
};  /* file_info_3 */

struct file_info_50 {
	unsigned long fi50_id;
	unsigned short fi50_permissions;
	unsigned short fi50_num_locks;
	char FAR * fi50_pathname;
	char FAR * fi50_username;
	char FAR * fi50_sharename;
}; /* file_info_50 */

struct res_file_enum_2 {
    unsigned short	res_pad;	 /* not used now */
    unsigned short      res_fs;          /* server type */
    unsigned long	res_pro;	  /* progressive */
};  /* res_file_enum_2 */

/****************************************************************
 *								*
 *		Special values and constants - FILE		*
 *								*
 ****************************************************************/

					/* bit values for permissions */
#define	PERM_FILE_READ		0x1	/* user has read access */
#define	PERM_FILE_WRITE		0x2	/* user has write access */
#define	PERM_FILE_CREATE	0x4	/* user has create access */


typedef struct res_file_enum_2 FRK;

/*NOINC*/
#define FRK_INIT( f )	\
	{		\
		(f).res_pad = 0L;	\
		(f).res_fs = 0;	\
		(f).res_pro = 0;	\
	}

/*INC*/


/****************************************************************
 *								*
 *	  	Server Class			                *
 *								*
 ****************************************************************/


/****************************************************************
 *                                                              *
 *              Function prototypes - SERVER                    *
 *                                                              *
 ****************************************************************/

extern API_FUNCTION
  NetServerGetInfo ( const char FAR *     pszServer,
                     short                sLevel,
                     char FAR *           pbBuffer,
                     unsigned short       cbBuffer,
                     unsigned short FAR * pcbTotalAvail );

extern API_FUNCTION
  NetServerSetInfo ( const char FAR * pszServer,
                     short            sLevel,
                     const char FAR * pbBuffer,
                     unsigned short   cbBuffer,
                     short            sParmNum );


/****************************************************************
 *								*
 *	  	Data structure templates - SERVER		*
 *								*
 ****************************************************************/

struct server_info_0 {
    char	    sv0_name[CNLEN + 1]; 	/* Server name		    */
};	 /* server_info_0 */


struct server_info_1 {
    char	    sv1_name[CNLEN + 1];
    unsigned char   sv1_version_major;		/* Major version # of net   */
    unsigned char   sv1_version_minor;		/* Minor version # of net   */
    unsigned long   sv1_type;	     		/* Server type 		    */
    char FAR *	    sv1_comment; 		/* Exported server comment  */
};	 /* server_info_1 */


/* NOTE struct prefix must equal server_info_1 like below! */

struct server_info_50 {
    char	    sv50_name[CNLEN + 1];
    unsigned char   sv50_version_major;		/* Major version # of net   */
    unsigned char   sv50_version_minor;		/* Minor version # of net   */
    unsigned long   sv50_type;	     		/* Server type 		    */
    char FAR *	    sv50_comment; 		/* Exported server comment  */
    unsigned short  sv50_security;    		/* SV_SECURITY_* (see below) */
    unsigned short  sv50_auditing;    /* 0 = no auditing; nonzero = auditing */
    char FAR *      sv50_container;		/* Security server/domain    */
    char FAR *	    sv50_ab_server;		/* Address book server       */
    char FAR *	    sv50_ab_dll;		/* Address book provider DLL */
};	/* server_info_50 */


struct server_info_2 {
    char            sv2_name[CNLEN + 1];
    unsigned char   sv2_version_major;
    unsigned char   sv2_version_minor;
    unsigned long   sv2_type;	
    char FAR *	    sv2_comment;		
    unsigned long   sv2_ulist_mtime; /* User list, last modification time    */
    unsigned long   sv2_glist_mtime; /* Group list, last modification time   */
    unsigned long   sv2_alist_mtime; /* Access list, last modification time  */
    unsigned short  sv2_users;       /* max number of users allowed          */
    unsigned short  sv2_disc;	    /* auto-disconnect timeout(in minutes)  */
    char FAR *	    sv2_alerts;	    /* alert names (semicolon separated)    */
    unsigned short  sv2_security;    /* SV_USERSECURITY or SV_SHARESECURITY  */
    unsigned short  sv2_auditing;    /* 0 = no auditing; nonzero = auditing  */

    unsigned short  sv2_numadmin;    /* max number of administrators allowed */
    unsigned short  sv2_lanmask;     /* bit mask representing the srv'd nets */
    unsigned short  sv2_hidden;      /* 0 = visible; nonzero = hidden        */
    unsigned short  sv2_announce;    /* visible server announce rate (sec)   */
    unsigned short  sv2_anndelta;    /* announce randomize interval (sec)    */
                                    /* name of guest account                */
    char            sv2_guestacct[LM20_UNLEN + 1];
    unsigned char   sv2_pad1;	    /* Word alignment pad byte		    */
    char FAR *      sv2_userpath;    /* ASCIIZ path to user directories      */
    unsigned short  sv2_chdevs;      /* max # shared character devices       */
    unsigned short  sv2_chdevq;      /* max # character device queues        */
    unsigned short  sv2_chdevjobs;   /* max # character device jobs          */
    unsigned short  sv2_connections; /* max # of connections		    */
    unsigned short  sv2_shares;	    /* max # of shares			    */
    unsigned short  sv2_openfiles;   /* max # of open files		    */
    unsigned short  sv2_sessopens;   /* max # of open files per session	    */
    unsigned short  sv2_sessvcs;     /* max # of virtual circuits per client */
    unsigned short  sv2_sessreqs;    /* max # of simul. reqs. from a client  */
    unsigned short  sv2_opensearch;  /* max # of open searches		    */
    unsigned short  sv2_activelocks; /* max # of active file locks           */
    unsigned short  sv2_numreqbuf;   /* number of server (standard) buffers  */
    unsigned short  sv2_sizreqbuf;   /* size of svr (standard) bufs (bytes)  */
    unsigned short  sv2_numbigbuf;   /* number of big (64K) buffers          */
    unsigned short  sv2_numfiletasks;/* number of file worker processes      */
    unsigned short  sv2_alertsched;  /* alert counting interval (minutes)    */
    unsigned short  sv2_erroralert;  /* error log alerting threshold         */
    unsigned short  sv2_logonalert;  /* logon violation alerting threshold   */
    unsigned short  sv2_accessalert; /* access violation alerting threshold  */
    unsigned short  sv2_diskalert;   /* low disk space alert threshold (KB)  */
    unsigned short  sv2_netioalert;  /* net I/O error ratio alert threshold  */
                                    /*  (tenths of a percent)               */
    unsigned short  sv2_maxauditsz;  /* Maximum audit file size (KB)        */
    char FAR *	    sv2_srvheuristics; /* performance related server switches*/
};	/* server_info_2 */


struct server_info_3 {
    char	    sv3_name[CNLEN + 1];
    unsigned char   sv3_version_major;
    unsigned char   sv3_version_minor;
    unsigned long   sv3_type;
    char FAR *	    sv3_comment;
    unsigned long   sv3_ulist_mtime; /* User list, last modification time    */
    unsigned long   sv3_glist_mtime; /* Group list, last modification time   */
    unsigned long   sv3_alist_mtime; /* Access list, last modification time  */
    unsigned short  sv3_users;	     /* max number of users allowed	     */
    unsigned short  sv3_disc;	    /* auto-disconnect timeout(in minutes)  */
    char FAR *	    sv3_alerts;     /* alert names (semicolon separated)    */
    unsigned short  sv3_security;    /* SV_USERSECURITY or SV_SHARESECURITY  */
    unsigned short  sv3_auditing;    /* 0 = no auditing; nonzero = auditing  */

    unsigned short  sv3_numadmin;    /* max number of administrators allowed */
    unsigned short  sv3_lanmask;     /* bit mask representing the srv'd nets */
    unsigned short  sv3_hidden;      /* 0 = visible; nonzero = hidden	     */
    unsigned short  sv3_announce;    /* visible server announce rate (sec)   */
    unsigned short  sv3_anndelta;    /* announce randomize interval (sec)    */
				    /* name of guest account		    */
    char	    sv3_guestacct[LM20_UNLEN + 1];
    unsigned char   sv3_pad1;	    /* Word alignment pad byte		    */
    char FAR *	    sv3_userpath;    /* ASCIIZ path to user directories	     */
    unsigned short  sv3_chdevs;      /* max # shared character devices	     */
    unsigned short  sv3_chdevq;      /* max # character device queues	     */
    unsigned short  sv3_chdevjobs;   /* max # character device jobs	     */
    unsigned short  sv3_connections; /* max # of connections		    */
    unsigned short  sv3_shares;     /* max # of shares			    */
    unsigned short  sv3_openfiles;   /* max # of open files		    */
    unsigned short  sv3_sessopens;   /* max # of open files per session     */
    unsigned short  sv3_sessvcs;     /* max # of virtual circuits per client */
    unsigned short  sv3_sessreqs;    /* max # of simul. reqs. from a client  */
    unsigned short  sv3_opensearch;  /* max # of open searches		    */
    unsigned short  sv3_activelocks; /* max # of active file locks	     */
    unsigned short  sv3_numreqbuf;   /* number of server (standard) buffers  */
    unsigned short  sv3_sizreqbuf;   /* size of svr (standard) bufs (bytes)  */
    unsigned short  sv3_numbigbuf;   /* number of big (64K) buffers	     */
    unsigned short  sv3_numfiletasks;/* number of file worker processes      */
    unsigned short  sv3_alertsched;  /* alert counting interval (minutes)    */
    unsigned short  sv3_erroralert;  /* error log alerting threshold	     */
    unsigned short  sv3_logonalert;  /* logon violation alerting threshold   */
    unsigned short  sv3_accessalert; /* access violation alerting threshold  */
    unsigned short  sv3_diskalert;   /* low disk space alert threshold (KB)  */
    unsigned short  sv3_netioalert;  /* net I/O error ratio alert threshold  */
                                    /*  (tenths of a percent)               */
    unsigned short  sv3_maxauditsz;  /* Maximum audit file size (KB)	     */
    char FAR *	    sv3_srvheuristics; /* performance related server switches*/
    unsigned long   sv3_auditedevents; /* Audit event control mask	     */
    unsigned short  sv3_autoprofile; /* (0,1,2,3) = (NONE,LOAD,SAVE,or BOTH) */
    char FAR *	    sv3_autopath;    /* file pathname (where to load & save) */
};	/* server_info_3 */



/****************************************************************
 *								*
 *	  	Special values and constants - SERVER		*
 *								*
 ****************************************************************/

/*
 *	Mask to be applied to svX_version_major in order to obtain
 *	the major version number.
 */

#define MAJOR_VERSION_MASK	0x0F

/*
 *	Bit-mapped values for svX_type fields. X = 1, 2 or 3.
 */

#define SV_TYPE_WORKSTATION	0x00000001
#define SV_TYPE_SERVER		0x00000002
#define SV_TYPE_SQLSERVER	0x00000004
#define SV_TYPE_DOMAIN_CTRL	0x00000008
#define SV_TYPE_DOMAIN_BAKCTRL	0x00000010
#define SV_TYPE_TIME_SOURCE	0x00000020
#define SV_TYPE_AFP		0x00000040
#define SV_TYPE_NOVELL		0x00000080
#define SV_TYPE_DOMAIN_MEMBER	0x00000100
#define SV_TYPE_PRINTQ_SERVER	0x00000200
#define SV_TYPE_DIALIN_SERVER	0x00000400
#define SV_TYPE_ALL		0xFFFFFFFF   /* handy for NetServerEnum2 */

/*
 *	Values of svX_security field. X = 2 or 3.
 */

#define SV_USERSECURITY		1
#define SV_SHARESECURITY	0

/*
 *	Values of svX_security field. X = 50.
 */

#define SV_SECURITY_SHARE	0	/* Share-level */
#define SV_SECURITY_WINNT	1	/* User-level - Windows NT workst'n */
#define SV_SECURITY_WINNTAS	2	/* User-level - Windows NT domain */
#define SV_SECURITY_NETWARE	3	/* User-level - NetWare 3.x bindery */

/*
 *	Values of svX_hidden field. X = 2 or 3.
 */

#define SV_HIDDEN		1
#define SV_VISIBLE		0

/*
 *	Values for parmnum parameter to NetServerSetInfo.
 */

#define SV_COMMENT_PARMNUM	5
#define SV_DISC_PARMNUM 	10
#define SV_ALERTS_PARMNUM	11
#define SV_HIDDEN_PARMNUM	16
#define SV_ANNOUNCE_PARMNUM	17
#define SV_ANNDELTA_PARMNUM	18
#define SV_ALERTSCHED_PARMNUM	37
#define SV_ERRORALERT_PARMNUM	38
#define SV_LOGONALERT_PARMNUM	39
#define SV_ACCESSALERT_PARMNUM	40
#define SV_DISKALERT_PARMNUM	41
#define SV_NETIOALERT_PARMNUM	42
#define SV_MAXAUDITSZ_PARMNUM	43

#define SVI1_NUM_ELEMENTS	5


/*
 *      Masks describing AUTOPROFILE parameters
 */

#define SW_AUTOPROF_LOAD_MASK	0x1
#define SW_AUTOPROF_SAVE_MASK	0x2



/****************************************************************
 *                                                              *
 *                 Security Class                               *
 *                                                              *
 ****************************************************************/


/****************************************************************
 *                                                              *
 *                  Function prototypes - SECURITY              *
 *                                                              *
 ****************************************************************/

extern API_FUNCTION
  NetSecurityGetInfo ( const char FAR *     pszServer,
                       short                sLevel,
                       char FAR *           pbBuffer,
                       unsigned short       cbBuffer,
                       unsigned short FAR * pcbTotalAvail );


/****************************************************************
 *								*
 *	  	Data structure templates - SECURITY		*
 *								*
 ****************************************************************/

struct security_info_1 {
    unsigned long   sec1_security;    	/* SEC_SECURITY_* (see below) */
    char FAR *      sec1_container;	/* Security server/domain     */
    char FAR *	    sec1_ab_server;	/* Address book server        */
    char FAR *	    sec1_ab_dll;	/* Address book provider DLL  */
};	/* security_info_1 */


/****************************************************************
 *								*
 *	  	Special values and constants - SECURITY		*
 *								*
 ****************************************************************/

/*
/*
 *	Values of secX_security field. X = 1.
 */

#define SEC_SECURITY_SHARE	SV_SECURITY_SHARE
#define SEC_SECURITY_WINNT	SV_SECURITY_WINNT
#define SEC_SECURITY_WINNTAS	SV_SECURITY_WINNTAS
#define SEC_SECURITY_NETWARE	SV_SECURITY_NETWARE



/*NOINC*/
#ifdef __cplusplus
}
#endif	/* __cplusplus */

#ifndef RC_INVOKED
#pragma pack()          /* Revert to default packing */
#endif

#endif /* SVRAPI_INCLUDED */
/*INC*/
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\hnw\win95\svrapi1.h ===
/********************************************************************/
/**                     Microsoft Windows                          **/
/**               Copyright(c) Microsoft Corp., 1994               **/
/********************************************************************/

/********************************************************************
 *                                                                  *
 *  About this file ...  SVRAPI.H                                   *
 *                                                                  *
 *  This file contains information about the NetAccess,             *
 *  NetConnection, NetFile, NetServer, NetSession and NetShare APIs.*
 *  There is a section for each set of APIs.                        *
 *  Each section contains:                                          *
 *                                                                  *
 *      Function prototypes.                                        *
 *                                                                  *
 *      Data structure templates.                                   *
 *                                                                  *
 *      Definition of special values.                               *
 *                                                                  *
 ********************************************************************/

/*
 *      NOTE:  Lengths of ASCIIZ strings are given as the maximum
 *      strlen() value.  This does not include space for the
 *      terminating 0-byte.  When allocating space for such an item,
 *      use the form:
 *
 *              char username[LM20_UNLEN+1];
 *
 *      An exception to this is the PATHLEN manifest, which does
 *      include space for the terminating 0-byte.
 */

/*NOINC*/
#ifndef SVRAPI_INCLUDED
#define SVRAPI_INCLUDED

#include <lmcons.h>
#include <lmerr.h>

#ifndef RC_INVOKED
#pragma pack(1)         /* Assume byte packing throughout */
#endif

#ifdef __cplusplus
extern "C" {            /* Assume C declarations for C++ */
#endif	/* __cplusplus */

#if !defined(_SVRAPI_)
#define API_FUNCTION DECLSPEC_IMPORT API_RET_TYPE APIENTRY
#else
#define API_FUNCTION API_RET_TYPE APIENTRY
#endif

/*INC*/


/****************************************************************
 *                                                              *
 *                 Access Class                                 *
 *                                                              *
 ****************************************************************/


/****************************************************************
 *                                                              *
 *                  Function prototypes - ACCESS                *
 *                                                              *
 ****************************************************************/

extern API_FUNCTION
  NetAccessAdd ( const char FAR * pszServer,
                 short            sLevel,
                 char FAR *       pbBuffer,
                 unsigned short   cbBuffer );

extern API_FUNCTION
  NetAccessCheck ( char FAR *           pszReserved,
                   char FAR *           pszUserName,
                   char FAR *           pszResource,
                   unsigned short       usOperation,
                   unsigned short FAR * pusResult );

extern API_FUNCTION
  NetAccessDel ( const char FAR * pszServer,
                 char FAR *       pszResource );

extern API_FUNCTION
  NetAccessEnum ( const char FAR *     pszServer,
                  char FAR *           pszBasePath,
                  short                fsRecursive,
                  short                sLevel,
                  char FAR *           pbBuffer,
                  unsigned short       cbBuffer,
                  unsigned short FAR * pcEntriesRead,
                  unsigned short FAR * pcTotalAvail );

extern API_FUNCTION
  NetAccessGetInfo ( const char FAR *     pszServer,
                     char FAR *           pszResource,
                     short                sLevel,
                     char FAR *           pbBuffer,
                     unsigned short       cbBuffer,
                     unsigned short FAR * pcbTotalAvail );

extern API_FUNCTION
  NetAccessSetInfo ( const char FAR * pszServer,
                     char FAR *       pszResource,
                     short            sLevel,
                     char FAR *       pbBuffer,
                     unsigned short   cbBuffer,
                     short            sParmNum );

extern API_FUNCTION
  NetAccessGetUserPerms ( char FAR *           pszServer,
                          char FAR *           pszUgName,
                          char FAR *           pszResource,
                          unsigned short FAR * pusPerms );


/****************************************************************
 *                                                              *
 *              Data structure templates - ACCESS               *
 *                                                              *
 ****************************************************************/

struct access_list {
        char            acl_ugname[LM20_UNLEN+1];
        char            acl_ugname_pad_1;
        short           acl_access;
};      /* access_list */

struct access_list_2
{
        char FAR *      acl2_ugname;
        unsigned short  acl2_access;
};      /* access_list_2 */
             
struct access_list_12
{
        char FAR *      acl12_ugname;
        unsigned short  acl12_access;
};      /* access_list_12 */
             
struct access_info_0 {
        char FAR *      acc0_resource_name;
};      /* access_info_0 */

struct access_info_1 {
        char  FAR *     acc1_resource_name;
        short           acc1_attr;                      /* See values below */
        short           acc1_count;
};      /* access_info_1 */

struct access_info_2 
{
        char  FAR *     acc2_resource_name;
        short           acc2_attr;
        short           acc2_count;
};      /* access_info_2 */

struct access_info_10 {
        char FAR *      acc10_resource_name;
};      /* access_info_10 */

struct access_info_12 
{
        char  FAR *     acc12_resource_name;
        short           acc12_attr;
        short           acc12_count;
};      /* access_info_12 */


/****************************************************************
 *                                                              *
 *              Special values and constants - ACCESS           *
 *                                                              *
 ****************************************************************/

/*
 *      Maximum number of permission entries for each resource.
 */

#define MAXPERMENTRIES  64


/*
 *      Bit values for the access permissions.  ACCESS_ALL is a handy
 *      way to specify maximum permissions.  These are used in
 *      acl_access field of access_list structures.
 */
/*NOINC*/
#define         ACCESS_NONE     0
#define         ACCESS_ALL     (ACCESS_READ|ACCESS_WRITE|ACCESS_CREATE|ACCESS_EXEC|ACCESS_DELETE|ACCESS_ATRIB|ACCESS_PERM|ACCESS_FINDFIRST)
/*INC*/
#define         ACCESS_READ     0x1
#define         ACCESS_WRITE    0x2
#define         ACCESS_CREATE   0x4
#define         ACCESS_EXEC     0x8
#define         ACCESS_DELETE   0x10
#define         ACCESS_ATRIB    0x20
#define         ACCESS_PERM     0x40
#define         ACCESS_FINDFIRST 0x80

#define         ACCESS_GROUP    0x8000

/*
 *      Bit values for the acc1_attr field of the access_info_1 structure.
 *      Only one bit is currently defined.
 */

#define         ACCESS_AUDIT            0x1

/*
 *      Parmnum value for NetAccessSetInfo.
 */

#define         ACCESS_ATTR_PARMNUM     2


/*
 *      ACCESS_LETTERS defines a letter for each bit position in
 *      the acl_access field of struct access_list.  Note that some
 *      bits have a corresponding letter of ' ' (space).
 */

#define         ACCESS_LETTERS          "RWCXDAP         "



/****************************************************************
 *								*
 *	  	Share Class			                *
 *								*
 ****************************************************************/

/****************************************************************
 *                                                              *
 *              Function prototypes - SHARE                     *
 *                                                              *
 ****************************************************************/

extern API_FUNCTION
  NetShareAdd ( const char FAR * pszServer,
                short            sLevel,
                const char FAR * pbBuffer,
                unsigned short   cbBuffer );

extern API_FUNCTION
  NetShareDel ( const char FAR * pszServer,
                const char FAR * pszNetName,
                unsigned short   usReserved );

extern API_FUNCTION
  NetShareEnum ( const char FAR *     pszServer,
                 short                sLevel,
                 char FAR *           pbBuffer,
                 unsigned short       cbBuffer,
                 unsigned short FAR * pcEntriesRead,
                 unsigned short FAR * pcTotalAvail );

extern API_FUNCTION
  NetShareGetInfo ( const char FAR *     pszServer,
                    const char FAR *     pszNetName,
                    short                sLevel,
                    char FAR *           pbBuffer,
                    unsigned short       cbBuffer,
                    unsigned short FAR * pcbTotalAvail );

extern API_FUNCTION
  NetShareSetInfo ( const char FAR * pszServer,
                    const char FAR * pszNetName,
                    short            sLevel,
                    const char FAR * pbBuffer,
                    unsigned short   cbBuffer,
                    short            sParmNum );


/****************************************************************
 *								*
 *	  	Data structure templates - SHARE		*
 *								*
 ****************************************************************/

struct share_info_0 {
    char		shi0_netname[LM20_NNLEN+1];
};  /* share_info_0 */

struct share_info_1 {
    char		shi1_netname[LM20_NNLEN+1];
    char		shi1_pad1;
    unsigned short	shi1_type;
    char FAR *		shi1_remark;
};  /* share_info_1 */

struct share_info_2 {
    char		shi2_netname[LM20_NNLEN+1];
    char		shi2_pad1;
    unsigned short	shi2_type;
    char FAR *		shi2_remark;
    unsigned short	shi2_permissions;
    unsigned short	shi2_max_uses;
    unsigned short	shi2_current_uses;
    char FAR *		shi2_path;
    char 		shi2_passwd[SHPWLEN+1];
    char		shi2_pad2;
};  /* share_info_2 */

struct share_info_50 {
	char		shi50_netname[LM20_NNLEN+1];
	unsigned char 	shi50_type;
    unsigned short	shi50_flags;
	char FAR *	shi50_remark;
	char FAR *	shi50_path;
	char		shi50_rw_password[SHPWLEN+1];
	char		shi50_ro_password[SHPWLEN+1];
};	/* share_info_50 */


/****************************************************************
 *								*
 *	  	Special values and constants - SHARE		*
 *								*
 ****************************************************************/

/* Field values for shi50_flags; */

#define	SHI50F_RDONLY		0x0001
#define	SHI50F_FULL			0x0002
#define	SHI50F_DEPENDSON	(SHI50F_RDONLY|SHI50F_FULL)
#define	SHI50F_ACCESSMASK	(SHI50F_RDONLY|SHI50F_FULL)

#define	SHI50F_PERSIST		0x0100
#define SHI50F_SYSTEM		0x0200


/*
 *	Values for parmnum parameter to NetShareSetInfo.
 */

#define	SHI_REMARK_PARMNUM		4
#define	SHI_PERMISSIONS_PARMNUM		5
#define	SHI_MAX_USES_PARMNUM		6
#define	SHI_PASSWD_PARMNUM		9

#define	SHI1_NUM_ELEMENTS		4
#define	SHI2_NUM_ELEMENTS		10


/*
 *	Share types (shi1_type and shi2_type fields).
 */

#define STYPE_DISKTREE 			0
#define STYPE_PRINTQ   			1
#define STYPE_DEVICE   			2
#define STYPE_IPC      			3

#define SHI_USES_UNLIMITED		-1



/****************************************************************
 *								*
 *	  	Session Class			                *
 *								*
 ****************************************************************/

/****************************************************************
 *                                                              *
 *              Function prototypes - SESSION                   *
 *                                                              *
 ****************************************************************/

extern API_FUNCTION
  NetSessionDel ( const char FAR * pszServer,
                  const char FAR * pszClientName,
                  short            sReserved );

extern API_FUNCTION
  NetSessionEnum ( const char FAR *     pszServer,
                   short                sLevel,
                   char FAR *           pbBuffer,
                   unsigned short       cbBuffer,
                   unsigned short FAR * pcEntriesRead,
                   unsigned short FAR * pcTotalAvail );

extern API_FUNCTION
  NetSessionGetInfo ( const char FAR *     pszServer,
                      const char FAR *     pszClientName,
                      short                sLevel,
                      char FAR *           pbBuffer,
                      unsigned short       cbBuffer,
                      unsigned short FAR * pcbTotalAvail );


/****************************************************************
 *								*
 *		Data structure templates - SESSION		*
 *								*
 ****************************************************************/


struct session_info_0 {
    char FAR *		sesi0_cname;
};  /* session_info_0 */

struct session_info_1 {
    char FAR *		sesi1_cname;
    char FAR *		sesi1_username;
    unsigned short	sesi1_num_conns;
    unsigned short	sesi1_num_opens;
    unsigned short	sesi1_num_users;
    unsigned long	sesi1_time;
    unsigned long	sesi1_idle_time;
    unsigned long	sesi1_user_flags;
};  /* session_info_1 */

struct session_info_2 {
    char FAR *		 sesi2_cname;
    char FAR *		 sesi2_username;
    unsigned short	 sesi2_num_conns;
    unsigned short	 sesi2_num_opens;
    unsigned short	 sesi2_num_users;
    unsigned long	 sesi2_time;
    unsigned long	 sesi2_idle_time;
    unsigned long	 sesi2_user_flags;
    char FAR *		 sesi2_cltype_name;
};  /* session_info_2 */

struct session_info_10 {
        char FAR *     sesi10_cname;
        char FAR *     sesi10_username;
        unsigned long  sesi10_time;
        unsigned long  sesi10_idle_time;
};  /* session_info_10 */


struct session_info_50 {
	char FAR * sesi50_cname;
	char FAR * sesi50_username;
	unsigned long sesi50_key;
	unsigned short sesi50_num_conns;
	unsigned short sesi50_num_opens;
	unsigned long sesi50_time;
	unsigned long sesi50_idle_time;
	unsigned char sesi50_protocol; 
	unsigned char pad1;
};	/* session_info_50 */


/****************************************************************
 *								*
 *	  	Special values and constants - SESSION		*
 *								*
 ****************************************************************/

/*
 *	Bits defined in sesi1_user_flags.
 */

#define SESS_GUEST		1	/* session is logged on as a guest */
#define SESS_NOENCRYPTION	2	/* session is not using encryption */


#define SESI1_NUM_ELEMENTS	8
#define SESI2_NUM_ELEMENTS	9



/****************************************************************
 *								*
 *	  	Connection Class			        *
 *								*
 ****************************************************************/

/****************************************************************
 *                                                              *
 *              Function prototypes - CONNECTION                *
 *                                                              *
 ****************************************************************/

extern API_FUNCTION
  NetConnectionEnum ( const char FAR *     pszServer,
                      const char FAR *     pszQualifier,
                      short                sLevel,
                      char FAR *           pbBuffer,
                      unsigned short       cbBuffer,
                      unsigned short FAR * pcEntriesRead,
                      unsigned short FAR * pcTotalAvail );


/****************************************************************
 *								*
 *	  	Data structure templates - CONNECTION		*
 *								*
 ****************************************************************/

struct connection_info_0 {
    unsigned short	coni0_id;
};  /* connection_info_0 */

struct connection_info_1 {
    unsigned short	coni1_id;
    unsigned short	coni1_type;
    unsigned short	coni1_num_opens;
    unsigned short	coni1_num_users;
    unsigned long	coni1_time;
    char FAR *		coni1_username;
    char FAR *		coni1_netname;
};  /* connection_info_1 */

struct connection_info_50 {
	unsigned short coni50_type;
	unsigned short coni50_num_opens;
	unsigned long coni50_time;
	char FAR * coni50_netname;
	char FAR * coni50_username;
}; /* connection_info_50 */


/****************************************************************
 *								*
 *	  	File Class			                *
 *								*
 ****************************************************************/


/****************************************************************
 *                                                              *
 *              Function prototypes - FILE                      *
 *                                                              *
 ****************************************************************/

extern API_FUNCTION
  NetFileClose2 ( const char FAR * pszServer,
                  unsigned long    ulFileId );

extern API_FUNCTION
  NetFileEnum ( const char FAR *     pszServer,
                const char FAR *     pszBasePath,
                short                sLevel,
                char FAR *           pbBuffer,
                unsigned short       cbBuffer,
                unsigned short FAR * pcEntriesRead,
                unsigned short FAR * pcTotalAvail );


/****************************************************************
 *								*
 *	  	Data structure templates - FILE			*
 *								*
 ****************************************************************/

struct file_info_0 {
    unsigned short	fi0_id;
};  /* file_info_0 */

struct file_info_1 {
    unsigned short	fi1_id;
    unsigned short	fi1_permissions;
    unsigned short	fi1_num_locks;
    char FAR *		fi1_pathname;
    char FAR *		fi1_username;
};  /* file_info_1 */

struct file_info_2 {
    unsigned long	fi2_id;
};  /* file_info_2 */

struct file_info_3 {
    unsigned long	fi3_id;
    unsigned short	fi3_permissions;
    unsigned short	fi3_num_locks;
    char FAR *		fi3_pathname;
    char FAR *		fi3_username;
};  /* file_info_3 */

struct file_info_50 {
	unsigned long fi50_id;
	unsigned short fi50_permissions;
	unsigned short fi50_num_locks;
	char FAR * fi50_pathname;
	char FAR * fi50_username;
	char FAR * fi50_sharename;
}; /* file_info_50 */

struct res_file_enum_2 {
    unsigned short	res_pad;	 /* not used now */
    unsigned short      res_fs;          /* server type */
    unsigned long	res_pro;	  /* progressive */
};  /* res_file_enum_2 */

/****************************************************************
 *								*
 *		Special values and constants - FILE		*
 *								*
 ****************************************************************/

					/* bit values for permissions */
#define	PERM_FILE_READ		0x1	/* user has read access */
#define	PERM_FILE_WRITE		0x2	/* user has write access */
#define	PERM_FILE_CREATE	0x4	/* user has create access */


typedef struct res_file_enum_2 FRK;

/*NOINC*/
#define FRK_INIT( f )	\
	{		\
		(f).res_pad = 0L;	\
		(f).res_fs = 0;	\
		(f).res_pro = 0;	\
	}

/*INC*/


/****************************************************************
 *								*
 *	  	Server Class			                *
 *								*
 ****************************************************************/


/****************************************************************
 *                                                              *
 *              Function prototypes - SERVER                    *
 *                                                              *
 ****************************************************************/

extern API_FUNCTION
  NetServerGetInfo ( const char FAR *     pszServer,
                     short                sLevel,
                     char FAR *           pbBuffer,
                     unsigned short       cbBuffer,
                     unsigned short FAR * pcbTotalAvail );

extern API_FUNCTION
  NetServerSetInfo ( const char FAR * pszServer,
                     short            sLevel,
                     const char FAR * pbBuffer,
                     unsigned short   cbBuffer,
                     short            sParmNum );


/****************************************************************
 *								*
 *	  	Data structure templates - SERVER		*
 *								*
 ****************************************************************/

struct server_info_0 {
    char	    sv0_name[CNLEN + 1]; 	/* Server name		    */
};	 /* server_info_0 */


struct server_info_1 {
    char	    sv1_name[CNLEN + 1];
    unsigned char   sv1_version_major;		/* Major version # of net   */
    unsigned char   sv1_version_minor;		/* Minor version # of net   */
    unsigned long   sv1_type;	     		/* Server type 		    */
    char FAR *	    sv1_comment; 		/* Exported server comment  */
};	 /* server_info_1 */


/* NOTE struct prefix must equal server_info_1 like below! */

struct server_info_50 {
    char	    sv50_name[CNLEN + 1];
    unsigned char   sv50_version_major;		/* Major version # of net   */
    unsigned char   sv50_version_minor;		/* Minor version # of net   */
    unsigned long   sv50_type;	     		/* Server type 		    */
    char FAR *	    sv50_comment; 		/* Exported server comment  */
    unsigned short  sv50_security;    		/* SV_SECURITY_* (see below) */
    unsigned short  sv50_auditing;    /* 0 = no auditing; nonzero = auditing */
    char FAR *      sv50_container;		/* Security server/domain    */
    char FAR *	    sv50_ab_server;		/* Address book server       */
    char FAR *	    sv50_ab_dll;		/* Address book provider DLL */
};	/* server_info_50 */


struct server_info_2 {
    char            sv2_name[CNLEN + 1];
    unsigned char   sv2_version_major;
    unsigned char   sv2_version_minor;
    unsigned long   sv2_type;	
    char FAR *	    sv2_comment;		
    unsigned long   sv2_ulist_mtime; /* User list, last modification time    */
    unsigned long   sv2_glist_mtime; /* Group list, last modification time   */
    unsigned long   sv2_alist_mtime; /* Access list, last modification time  */
    unsigned short  sv2_users;       /* max number of users allowed          */
    unsigned short  sv2_disc;	    /* auto-disconnect timeout(in minutes)  */
    char FAR *	    sv2_alerts;	    /* alert names (semicolon separated)    */
    unsigned short  sv2_security;    /* SV_USERSECURITY or SV_SHARESECURITY  */
    unsigned short  sv2_auditing;    /* 0 = no auditing; nonzero = auditing  */

    unsigned short  sv2_numadmin;    /* max number of administrators allowed */
    unsigned short  sv2_lanmask;     /* bit mask representing the srv'd nets */
    unsigned short  sv2_hidden;      /* 0 = visible; nonzero = hidden        */
    unsigned short  sv2_announce;    /* visible server announce rate (sec)   */
    unsigned short  sv2_anndelta;    /* announce randomize interval (sec)    */
                                    /* name of guest account                */
    char            sv2_guestacct[LM20_UNLEN + 1];
    unsigned char   sv2_pad1;	    /* Word alignment pad byte		    */
    char FAR *      sv2_userpath;    /* ASCIIZ path to user directories      */
    unsigned short  sv2_chdevs;      /* max # shared character devices       */
    unsigned short  sv2_chdevq;      /* max # character device queues        */
    unsigned short  sv2_chdevjobs;   /* max # character device jobs          */
    unsigned short  sv2_connections; /* max # of connections		    */
    unsigned short  sv2_shares;	    /* max # of shares			    */
    unsigned short  sv2_openfiles;   /* max # of open files		    */
    unsigned short  sv2_sessopens;   /* max # of open files per session	    */
    unsigned short  sv2_sessvcs;     /* max # of virtual circuits per client */
    unsigned short  sv2_sessreqs;    /* max # of simul. reqs. from a client  */
    unsigned short  sv2_opensearch;  /* max # of open searches		    */
    unsigned short  sv2_activelocks; /* max # of active file locks           */
    unsigned short  sv2_numreqbuf;   /* number of server (standard) buffers  */
    unsigned short  sv2_sizreqbuf;   /* size of svr (standard) bufs (bytes)  */
    unsigned short  sv2_numbigbuf;   /* number of big (64K) buffers          */
    unsigned short  sv2_numfiletasks;/* number of file worker processes      */
    unsigned short  sv2_alertsched;  /* alert counting interval (minutes)    */
    unsigned short  sv2_erroralert;  /* error log alerting threshold         */
    unsigned short  sv2_logonalert;  /* logon violation alerting threshold   */
    unsigned short  sv2_accessalert; /* access violation alerting threshold  */
    unsigned short  sv2_diskalert;   /* low disk space alert threshold (KB)  */
    unsigned short  sv2_netioalert;  /* net I/O error ratio alert threshold  */
                                    /*  (tenths of a percent)               */
    unsigned short  sv2_maxauditsz;  /* Maximum audit file size (KB)        */
    char FAR *	    sv2_srvheuristics; /* performance related server switches*/
};	/* server_info_2 */


struct server_info_3 {
    char	    sv3_name[CNLEN + 1];
    unsigned char   sv3_version_major;
    unsigned char   sv3_version_minor;
    unsigned long   sv3_type;
    char FAR *	    sv3_comment;
    unsigned long   sv3_ulist_mtime; /* User list, last modification time    */
    unsigned long   sv3_glist_mtime; /* Group list, last modification time   */
    unsigned long   sv3_alist_mtime; /* Access list, last modification time  */
    unsigned short  sv3_users;	     /* max number of users allowed	     */
    unsigned short  sv3_disc;	    /* auto-disconnect timeout(in minutes)  */
    char FAR *	    sv3_alerts;     /* alert names (semicolon separated)    */
    unsigned short  sv3_security;    /* SV_USERSECURITY or SV_SHARESECURITY  */
    unsigned short  sv3_auditing;    /* 0 = no auditing; nonzero = auditing  */

    unsigned short  sv3_numadmin;    /* max number of administrators allowed */
    unsigned short  sv3_lanmask;     /* bit mask representing the srv'd nets */
    unsigned short  sv3_hidden;      /* 0 = visible; nonzero = hidden	     */
    unsigned short  sv3_announce;    /* visible server announce rate (sec)   */
    unsigned short  sv3_anndelta;    /* announce randomize interval (sec)    */
				    /* name of guest account		    */
    char	    sv3_guestacct[LM20_UNLEN + 1];
    unsigned char   sv3_pad1;	    /* Word alignment pad byte		    */
    char FAR *	    sv3_userpath;    /* ASCIIZ path to user directories	     */
    unsigned short  sv3_chdevs;      /* max # shared character devices	     */
    unsigned short  sv3_chdevq;      /* max # character device queues	     */
    unsigned short  sv3_chdevjobs;   /* max # character device jobs	     */
    unsigned short  sv3_connections; /* max # of connections		    */
    unsigned short  sv3_shares;     /* max # of shares			    */
    unsigned short  sv3_openfiles;   /* max # of open files		    */
    unsigned short  sv3_sessopens;   /* max # of open files per session     */
    unsigned short  sv3_sessvcs;     /* max # of virtual circuits per client */
    unsigned short  sv3_sessreqs;    /* max # of simul. reqs. from a client  */
    unsigned short  sv3_opensearch;  /* max # of open searches		    */
    unsigned short  sv3_activelocks; /* max # of active file locks	     */
    unsigned short  sv3_numreqbuf;   /* number of server (standard) buffers  */
    unsigned short  sv3_sizreqbuf;   /* size of svr (standard) bufs (bytes)  */
    unsigned short  sv3_numbigbuf;   /* number of big (64K) buffers	     */
    unsigned short  sv3_numfiletasks;/* number of file worker processes      */
    unsigned short  sv3_alertsched;  /* alert counting interval (minutes)    */
    unsigned short  sv3_erroralert;  /* error log alerting threshold	     */
    unsigned short  sv3_logonalert;  /* logon violation alerting threshold   */
    unsigned short  sv3_accessalert; /* access violation alerting threshold  */
    unsigned short  sv3_diskalert;   /* low disk space alert threshold (KB)  */
    unsigned short  sv3_netioalert;  /* net I/O error ratio alert threshold  */
                                    /*  (tenths of a percent)               */
    unsigned short  sv3_maxauditsz;  /* Maximum audit file size (KB)	     */
    char FAR *	    sv3_srvheuristics; /* performance related server switches*/
    unsigned long   sv3_auditedevents; /* Audit event control mask	     */
    unsigned short  sv3_autoprofile; /* (0,1,2,3) = (NONE,LOAD,SAVE,or BOTH) */
    char FAR *	    sv3_autopath;    /* file pathname (where to load & save) */
};	/* server_info_3 */



/****************************************************************
 *								*
 *	  	Special values and constants - SERVER		*
 *								*
 ****************************************************************/

/*
 *	Mask to be applied to svX_version_major in order to obtain
 *	the major version number.
 */

#define MAJOR_VERSION_MASK	0x0F

/*
 *	Bit-mapped values for svX_type fields. X = 1, 2 or 3.
 */

#define SV_TYPE_WORKSTATION	0x00000001
#define SV_TYPE_SERVER		0x00000002
#define SV_TYPE_SQLSERVER	0x00000004
#define SV_TYPE_DOMAIN_CTRL	0x00000008
#define SV_TYPE_DOMAIN_BAKCTRL	0x00000010
#define SV_TYPE_TIME_SOURCE	0x00000020
#define SV_TYPE_AFP		0x00000040
#define SV_TYPE_NOVELL		0x00000080
#define SV_TYPE_DOMAIN_MEMBER	0x00000100
#define SV_TYPE_PRINTQ_SERVER	0x00000200
#define SV_TYPE_DIALIN_SERVER	0x00000400
#define SV_TYPE_ALL		0xFFFFFFFF   /* handy for NetServerEnum2 */

/*
 *	Special value for svX_disc that specifies infinite disconnect
 *	time. X = 2 or 3.
 */

#define SV_NODISC		0xFFFF	/* No autodisconnect timeout enforced */

/*
 *	Values of svX_security field. X = 2 or 3.
 */

#define SV_USERSECURITY		1
#define SV_SHARESECURITY	0

/*
 *	Values of svX_security field. X = 50.
 */

#define SV_SECURITY_SHARE	0	/* Share-level */
#define SV_SECURITY_WINNT	1	/* User-level - Windows NT workst'n */
#define SV_SECURITY_WINNTAS	2	/* User-level - Windows NT domain */
#define SV_SECURITY_NETWARE	3	/* User-level - NetWare 3.x bindery */

/*
 *	Values of svX_hidden field. X = 2 or 3.
 */

#define SV_HIDDEN		1
#define SV_VISIBLE		0

/*
 *	Values for parmnum parameter to NetServerSetInfo.
 */

#define SV_COMMENT_PARMNUM	5
#define SV_DISC_PARMNUM 	10
#define SV_ALERTS_PARMNUM	11
#define SV_HIDDEN_PARMNUM	16
#define SV_ANNOUNCE_PARMNUM	17
#define SV_ANNDELTA_PARMNUM	18
#define SV_ALERTSCHED_PARMNUM	37
#define SV_ERRORALERT_PARMNUM	38
#define SV_LOGONALERT_PARMNUM	39
#define SV_ACCESSALERT_PARMNUM	40
#define SV_DISKALERT_PARMNUM	41
#define SV_NETIOALERT_PARMNUM	42
#define SV_MAXAUDITSZ_PARMNUM	43

#define SVI1_NUM_ELEMENTS	5
#define SVI2_NUM_ELEMENTS	44
#define SVI3_NUM_ELEMENTS	45


/*
 *      Masks describing AUTOPROFILE parameters
 */

#define SW_AUTOPROF_LOAD_MASK	0x1
#define SW_AUTOPROF_SAVE_MASK	0x2



/****************************************************************
 *                                                              *
 *                 Security Class                               *
 *                                                              *
 ****************************************************************/


/****************************************************************
 *                                                              *
 *                  Function prototypes - SECURITY              *
 *                                                              *
 ****************************************************************/

extern API_FUNCTION
  NetSecurityGetInfo ( const char FAR *     pszServer,
                       short                sLevel,
                       char FAR *           pbBuffer,
                       unsigned short       cbBuffer,
                       unsigned short FAR * pcbTotalAvail );


/****************************************************************
 *								*
 *	  	Data structure templates - SECURITY		*
 *								*
 ****************************************************************/

struct security_info_1 {
    unsigned long   sec1_security;    	/* SEC_SECURITY_* (see below) */
    char FAR *      sec1_container;	/* Security server/domain     */
    char FAR *	    sec1_ab_server;	/* Address book server        */
    char FAR *	    sec1_ab_dll;	/* Address book provider DLL  */
};	/* security_info_1 */


/****************************************************************
 *								*
 *	  	Special values and constants - SECURITY		*
 *								*
 ****************************************************************/

/*
/*
 *	Values of secX_security field. X = 1.
 */

#define SEC_SECURITY_SHARE	SV_SECURITY_SHARE
#define SEC_SECURITY_WINNT	SV_SECURITY_WINNT
#define SEC_SECURITY_WINNTAS	SV_SECURITY_WINNTAS
#define SEC_SECURITY_NETWARE	SV_SECURITY_NETWARE



/*NOINC*/
#ifdef __cplusplus
}
#endif	/* __cplusplus */

#ifndef RC_INVOKED
#pragma pack()          /* Revert to default packing */
#endif

#endif /* SVRAPI_INCLUDED */
/*INC*/
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\hnw\win95\svrapi2.h ===
/********************************************************************/
/**                     Microsoft Windows                          **/
/**               Copyright(c) Microsoft Corp., 1995-1996          **/
/********************************************************************/

/********************************************************************
 *                                                                  *
 *  About this file ...  SVRAPI.H                                   *
 *                                                                  *
 *  This file contains information about the NetAccess,             *
 *  NetConnection, NetFile, NetServer, NetSession, NetShare and     *
 *  NetSecurity APIs.                                               *
 *  There is a section for each set of APIs.                        *
 *  Each section contains:                                          *
 *                                                                  *
 *      Function prototypes.                                        *
 *                                                                  *
 *      Data structure templates.                                   *
 *                                                                  *
 *      Definition of special values.                               *
 *                                                                  *
 *      Description of level of Win95 peer server support           *
 *
 *  For background information refer to the Lan Manager Programmer's
 *  Reference.
 *
 *  WARNING:
 *      The APIs documented herein are not guaranteed to be supported
 * in future versions of Windows. Their primary purpose is to       *
 * administer Win95 peer servers.                                   *
 *                                                                  *
 ********************************************************************/

/*
 *      NOTE:  Lengths of ASCIIZ strings are given as the maximum
 *      strlen() value.  This does not include space for the
 *      terminating 0-byte.  When allocating space for such an item,
 *      use the form:
 *
 *              char username[LM20_UNLEN+1];
 *
 *      An exception to this is the PATHLEN manifest, which does
 *      include space for the terminating 0-byte.
 *
 *      User names, computer names and share names should be
 *      upper-cased by the caller and drawn from the ANSI 
 *      character set.
 * 
 */

/*NOINC*/
#ifndef SVRAPI_INCLUDED
#define SVRAPI_INCLUDED

#include <lmcons.h>
#include <lmerr.h>

#ifndef RC_INVOKED
#pragma pack(1)         /* Assume byte packing throughout */
#endif

#ifdef __cplusplus
extern "C" {            /* Assume C declarations for C++ */
#endif	/* __cplusplus */

#if !defined(_SVRAPI_)
#define API_FUNCTION DECLSPEC_IMPORT API_RET_TYPE APIENTRY
#else
#define API_FUNCTION API_RET_TYPE APIENTRY
#endif

/*INC*/


/****************************************************************
 *                                                              *
 *                 Access Class                                 *
 *                                                              *
 ****************************************************************/


/****************************************************************
 *                                                              *
 *                  Function prototypes - ACCESS                *
 *
 * 	Requires User level security to be enabled
 *                                                              *
 *	Peer Server Support:
 *      Remote support of these APIs on NWSERVER is limited as
 *      described below:
 *
 *		NetAccessAdd -
 *				local and remote VSERVER - level 2
 *              remote NWSERVER -          level 2
 *	    NetAccessCheck - local only
 *      NetAccessDel - 
 *              local, remote NWSERVER and remote VSERVER
 *      NetAccessEnum -
 *              sLevel 0 on remote NWSERVER (fRecursive = 1),
 *              slevel 0, 1, 2 on local and remote VSERVER
 *		NetAccessGetInfo -
 *               all sLevels on local and remote VSERVER,
 *      		 sLevel 0, 12 on remote NWSERVER
 *      NetAccessSetInfo - 
 *              sLevel 1, 12 on local and remote VSERVER,
 *              sLevel 12 on remote NWSERVER
 *              parmnum = PARMNUM_ALL only
 *      NetAccessGetUserPerms - local and remote VSERVER only
 ****************************************************************/

extern API_FUNCTION
  NetAccessAdd ( const char FAR * pszServer,
                 short            sLevel,
                 char FAR *       pbBuffer,
                 unsigned short   cbBuffer );

extern API_FUNCTION
  NetAccessCheck ( char FAR *           pszReserved,
                   char FAR *           pszUserName,
                   char FAR *           pszResource,
                   unsigned short       usOperation,
                   unsigned short FAR * pusResult );

extern API_FUNCTION
  NetAccessDel ( const char FAR * pszServer,
                 char FAR *       pszResource );

extern API_FUNCTION
  NetAccessEnum ( const char FAR *     pszServer,
                  char FAR *           pszBasePath,
                  short                fsRecursive,
                  short                sLevel,
                  char FAR *           pbBuffer,
                  unsigned short       cbBuffer,
                  unsigned short FAR * pcEntriesRead,
                  unsigned short FAR * pcTotalAvail );

extern API_FUNCTION
  NetAccessGetInfo ( const char FAR *     pszServer,
                     char FAR *           pszResource,
                     short                sLevel,
                     char FAR *           pbBuffer,
                     unsigned short       cbBuffer,
                     unsigned short FAR * pcbTotalAvail );

extern API_FUNCTION
  NetAccessSetInfo ( const char FAR * pszServer,
                     char FAR *       pszResource,
                     short            sLevel,
                     char FAR *       pbBuffer,
                     unsigned short   cbBuffer,
                     short            sParmNum );

extern API_FUNCTION
  NetAccessGetUserPerms ( char FAR *           pszServer,
                          char FAR *           pszUgName,
                          char FAR *           pszResource,
                          unsigned short FAR * pusPerms );


/****************************************************************
 *                                                              *
 *              Data structure templates - ACCESS               *
 *                                                              *
 ****************************************************************/

struct access_list {
        char            acl_ugname[LM20_UNLEN+1];
        char            acl_ugname_pad_1;
        short           acl_access;
};      /* access_list */

struct access_list_2
{
        char FAR *      acl2_ugname;
        unsigned short  acl2_access;
};      /* access_list_2 */
             
struct access_list_12
{
        char FAR *      acl12_ugname;
        unsigned short  acl12_access;
};      /* access_list_12 */
             
struct access_info_0 {
        char FAR *      acc0_resource_name;
};      /* access_info_0 */

struct access_info_1 {
        char  FAR *     acc1_resource_name;
        short           acc1_attr;                      /* See values below */
        short           acc1_count;
};      /* access_info_1 */

struct access_info_2 
{
        char  FAR *     acc2_resource_name;
        short           acc2_attr;
        short           acc2_count;
};      /* access_info_2 */

struct access_info_10 {
        char FAR *      acc10_resource_name;
};      /* access_info_10 */

struct access_info_12 
{
        char  FAR *     acc12_resource_name;
        short           acc12_attr;
        short           acc12_count;
};      /* access_info_12 */


/****************************************************************
 *                                                              *
 *              Special values and constants - ACCESS           *
 *                                                              *
 ****************************************************************/

/*
 *      Maximum number of permission entries for each resource.
 */

#define MAXPERMENTRIES  64


/*
 *      Bit values for the access permissions.  ACCESS_ALL is a handy
 *      way to specify maximum permissions.  These are used in
 *      acl_access field of access_list structures.
 */
/*NOINC*/
#define         ACCESS_NONE     0
#define         ACCESS_ALL     (ACCESS_READ|ACCESS_WRITE|ACCESS_CREATE|ACCESS_EXEC|ACCESS_DELETE|ACCESS_ATRIB|ACCESS_PERM|ACCESS_FINDFIRST)
/*INC*/
#define         ACCESS_READ     0x1
#define         ACCESS_WRITE    0x2
#define         ACCESS_CREATE   0x4
#define         ACCESS_EXEC     0x8
#define         ACCESS_DELETE   0x10
#define         ACCESS_ATRIB    0x20
#define         ACCESS_PERM     0x40
#define         ACCESS_FINDFIRST 0x80

#define         ACCESS_GROUP    0x8000

/*
 *      Bit values for the acc1_attr field of the access_info_1 structure.
 *      Only one bit is currently defined.
 */

#define         ACCESS_AUDIT            0x1

/*
 *      Parmnum value for NetAccessSetInfo.
 */

#define         ACCESS_ATTR_PARMNUM     2


/*
 *      ACCESS_LETTERS defines a letter for each bit position in
 *      the acl_access field of struct access_list.  Note that some
 *      bits have a corresponding letter of ' ' (space).
 */

#define         ACCESS_LETTERS          "RWCXDAP         "



/****************************************************************
 *								*
 *	  	Share Class			                *
 *								*
 ****************************************************************/

/****************************************************************
 *                                                              *
 *              Function prototypes - SHARE                     *
 *                                                              *
 *	Peer Server Support
 * 		NetShareAdd() - sLevel 50 on VSERVER and NWSERVER
 * 		NetShareDel() - VSERVER and NWSERVER
 *		NetShareEnum() - sLevel 1,50 on VSERVER; 50 on NWSERVER
 *      NetShareGetInfo() - sLevel 50 on VSERVER, NWSERVER
 * 		NetShareSetInfo() - sLevel 50, sParmNum PARMNUM_ALL
 *						 on VSERVER, NWSERVER
 ****************************************************************/

/***	NetShareAdd - add a new share to the server tables
 *
 *	NetShareAdd( servername, level, buf, buflen )
 *
 *	ENTRY:	servername - asciz string containing name of server
 *                       or NULL if local
 *		level- Must be 50 for Win95 peer servers.
 *		buf - far ptr to struct share_info
 *		buflen - unsigned int length of buffer
 *
 *	EXIT:	0 = success
 *		ERROR_INVALID_LEVEL
 *      ERROR_BAD_NETPATH
 *		ERROR_INVALID_PARAMETER
 *		NERR_UnknownDevDir
 *		NERR_ShareExists
 *		NERR_UnknownServer
 *		NERR_ServerNotStarted
 *		NERR_RedirectedPath
 *		NERR_DuplicateShare
 *		NERR_BufTooSmall
 *		ERROR_NOT_ENOUGH_MEMORY
 *
 */
extern API_FUNCTION
  NetShareAdd ( const char FAR * pszServer,
                short            sLevel,
                const char FAR * pbBuffer,
                unsigned short   cbBuffer );

/***	NetShareDel (Admin only)
 *
 *	API_FUNCTION NetShareDel( servername, netname, reserved )
 *
 *	ENTRY
 *
 *	char FAR *  servername;     asciz remote srv name, NULL if local
 *	char FAR *  netname;        asciz network name of share being deleted
 *	unsigned short reserved;    MBZ
 *
 *	EXIT
 *
 *	0 = success
 *	NERR_NetNotStarted
 *  ERROR_BAD_NETPATH
 *	NERR_ServerNotStarted
 *	NERR_NetNameNotFound
 *	ERROR_INVALID_PARAMETER
 *
 *
 *	Note:  Deleting a share will also delete any existing connections
 *		to the shared resource, and close open files within the
 *		connections.
 */
extern API_FUNCTION
  NetShareDel ( const char FAR * pszServer,
                const char FAR * pszNetName,
                unsigned short   usReserved );

/* 2.1  NetShareEnum
 *
 * API_FUNCTION
 * NetShareEnum( servername, level, buf, buflen, entriesread, totalentries )
 * char FAR *          servername;     asciz remote server name or NULL if local
 * short               sLevel;         level of detail requested; 1 or 50
 * char FAR *          pbBuffer;       buffer to return entries in
 * unsigned short      cbBuffer;       size of buffer on call
 * unsigned short FAR *pcEntriesRead;  # of entries supplied on return
 * unsigned short FAR *pcTotalAvail ;  total # of entries available
 *
 * Supply information about existing shares at specified level.
 *
 * Buffer contents on response (format for a single entry):
 *     Level 1 contains a "struct share_info_1".
 *     Level 50 contains a "struct share_info_50".
 *
 * Returns 0 if successful.  Possible error returns:
 *  ERROR_INVALID_LEVEL
 *  ERROR_BAD_NETPATH
 *  NERR_NetNotStarted
 *  NERR_ServerNotStarted
 *  ERROR_MORE_DATA
 */
extern API_FUNCTION
  NetShareEnum ( const char FAR *     pszServer,
                 short                sLevel,
                 char FAR *           pbBuffer,
                 unsigned short       cbBuffer,
                 unsigned short FAR * pcEntriesRead,
                 unsigned short FAR * pcTotalAvail );

/* 2.2  NetShareGetInfo
 *
 * Purpose: Read complete information about a single outstanding share.
 *
 * API_FUNCTION
 * NetShareGetInfo( servername, netname, level, buf, buflen, totalavail )
 * char FAR *          servername;     asciz remote server name or NULL if local
 * char FAR *          netname;        asciz network name of share being queried
 * short               level;          level of info requested (50 for Win95 peer servers)
 * char FAR *          buf;            for returned entry
 * unsigned short      buflen;         size of buffer
 * unsigned short FAR *totalavail;     total size needed for buffer
 *
 * Buffer contents on response:
 *     Level 50 contains a "struct share_info_50".
 *
 * Returns 0 if successful.  Possible error returns:
 *  ERROR_INVALID_LEVEL
 *  ERROR_INVALID_PARAMETER
 *  ERROR_BAD_NETPATH
 *  NERR_NetNotStarted
 *  NERR_ServerNotStarted
 *  NERR_NetNameNotFound
 *  NERR_MoreData
 *  NERR_BufTooSmall
 */
extern API_FUNCTION
  NetShareGetInfo ( const char FAR *     pszServer,
                    const char FAR *     pszNetName,
                    short                sLevel,
                    char FAR *           pbBuffer,
                    unsigned short       cbBuffer,
                    unsigned short FAR * pcbTotalAvail );

/***	NetShareSetInfo (Admin only)
 *
 *	API_FUNCTION NetShareSetInfo( servername,
 *					netname,
 *					level,
 *					buf,
 *					buflen,
 *					parmnum )
 *					
 *	ENTRY
 *
 *	servername;     asciz remote srv name, NULL if local
 *	netname;        asciz network name of share being set
 *	level;		level of info provided (50 for Win95 peer servers)
 *	buf;            contents described below
 *	buflen;         size of buffer
 *	parmnum;        must be PARMNUM_ALL for Win95 peer servers
 *
 *	Buffer contents on call if parmnum is zero:
 *   	    Level 50 contains a "struct share_info_50".
 *
 *	Settable fields are:
 *          shi_remark
 *          shi_passwd
 *
 *	EXIT
 *
 *	0 = success
 *	NERR_NetNotStarted
 *	NERR_ServerNotStarted
 *	NERR_NetNameNotFound
 *	ERROR_INVALID_LEVEL
 * 	NERR_BufTooSmall
 *	NERR_RemoteErr
 *	ERROR_MORE_DATA
 *	ERROR_INVALID_PARAMETER
 ***/
extern API_FUNCTION
  NetShareSetInfo ( const char FAR * pszServer,
                    const char FAR * pszNetName,
                    short            sLevel,
                    const char FAR * pbBuffer,
                    unsigned short   cbBuffer,
                    short            sParmNum );


/****************************************************************
 *								*
 *	  	Data structure templates - SHARE		*
 *
 ****************************************************************/

struct share_info_0 {
    char		shi0_netname[LM20_NNLEN+1];
};  /* share_info_0 */

struct share_info_1 {
    char		shi1_netname[LM20_NNLEN+1];
    char		shi1_pad1;
    unsigned short	shi1_type;
    char FAR *		shi1_remark;
};  /* share_info_1 */

struct share_info_2 {
    char		shi2_netname[LM20_NNLEN+1];
    char		shi2_pad1;
    unsigned short	shi2_type;
    char FAR *		shi2_remark;
    unsigned short	shi2_permissions;
    unsigned short	shi2_max_uses;
    unsigned short	shi2_current_uses;
    char FAR *		shi2_path;
    char 		shi2_passwd[SHPWLEN+1];
    char		shi2_pad2;
};  /* share_info_2 */

struct share_info_50 {
	char		shi50_netname[LM20_NNLEN+1];    /* share name */
	unsigned char 	shi50_type;                 /* see below */
    unsigned short	shi50_flags;                /* see below */
	char FAR *	shi50_remark;                   /* ANSI comment string */
	char FAR *	shi50_path;                     /* shared resource */
	char		shi50_rw_password[SHPWLEN+1];   /* read-write password (share-level security) */
	char		shi50_ro_password[SHPWLEN+1];   /* read-only password (share-level security) */
};	/* share_info_50 */


/****************************************************************
 *								*
 *	  	Special values and constants - SHARE		*
 *								*
 ****************************************************************/

/* Field values for shi50_flags; */

/* These flags are relevant for share-level security on VSERVER
 * When operating with user-level security, use SHI50F_FULL - the actual
 * access rights are determined by the NetAccess APIs.
 */
#define	SHI50F_RDONLY		0x0001
#define	SHI50F_FULL			0x0002
#define	SHI50F_DEPENDSON	(SHI50F_RDONLY|SHI50F_FULL)
#define	SHI50F_ACCESSMASK	(SHI50F_RDONLY|SHI50F_FULL)

/* The share is restored on system startup */
#define	SHI50F_PERSIST		0x0100
/* The share is not normally visible  */
#define SHI50F_SYSTEM		0x0200


/*
 *	Values for parmnum parameter to NetShareSetInfo.
 */

#ifndef PARMNUM_ALL
#define PARMNUM_ALL				0
#endif

#define	SHI_REMARK_PARMNUM		4
#define	SHI_PERMISSIONS_PARMNUM		5
#define	SHI_MAX_USES_PARMNUM		6
#define	SHI_PASSWD_PARMNUM		9

#define	SHI1_NUM_ELEMENTS		4
#define	SHI2_NUM_ELEMENTS		10


/*
 *	Share types .
 *  
 *  STYPE_DISKTREE and STYPE_PRINTQ are recognized on peer servers
 */

#define STYPE_DISKTREE 			0       /* disk share */
#define STYPE_PRINTQ   			1       /* printer share */
#define STYPE_DEVICE   			2
#define STYPE_IPC      			3

#define SHI_USES_UNLIMITED		-1



/****************************************************************
 *								*
 *	  	Session Class			                *
 *								*
 ****************************************************************/

/****************************************************************
 *                                                              *
 *              Function prototypes - SESSION                   *
 *
 *	Peer Server Support                                         *
 *  	NetSessionDel() - NWSERVER and VSERVER 					*
 *	    NetSessionEnum() - sLevel 50 on NWSERVER and VSERVER    *
 *		NetSessionGetInfo() - not supported on peer servers     *
 ****************************************************************/

/***	NetSessionDel (Admin only)
 *
 *
 *	API_FUNCTION NetSessionDel( servername, clientname, reserved )
 *
 *	ENTRY
 *
 * 	servername;     asciz remote srv name, NULL if local
 *	clientname;     asciz remote computer name (returned by NetSessionEnum)
 *                               	of session being deleted
 *                  In the case of a Win95 NWSERVER, the clientname should be the
 *                  ascii connection number
 *	reserved;       session key returned by NetSessionEnum
 *
 * 	EXIT
 *
 *	0 = success
 *	NERR_NetNotStarted
 *  ERROR_BAD_NETPATH
 *	NERR_ServerNotStarted
 *	ERROR_INVALID_LEVEL
 *	NERR_RemoteErr
 *	NERR_RemoteOnly
 * 	ERROR_ACCESS_DENIED
 *	NERR_BufTooSmall
 *	NERR_ClientNameNotFound
 *
 ***/
extern API_FUNCTION
  NetSessionDel ( const char FAR * pszServer,
                  const char FAR * pszClientName,
                  short            sReserved );

/***	NetSessionEnum
 *
 *	API_FUNCTION NetSessionEnum( servername,
 *				       level,
 *				       buf,
 *				       buflen,
 *				       entriesread,
 *				       totalentries )
 *	ENTRY
 *				
 *	servername;     asciz remote srv name, NULL if local
 * 	level;          level of detail requested; (50 for Win95 peer servers)
 *	buf;            for returned entries
 *	buflen;         size of buffer on call;
 *	entriesread;    # of entries supplied on return
 *	totalentries;   total # of entries available
 *
 * 	EXIT
 *
 *	0 = success
 *	NERR_NetNotStarted
 *	NERR_ServerNotStarted
 *  ERROR_BAD_NETPATH
 *	ERROR_INVALID_LEVEL
 *	NERR_RemoteErr
 *	ERROR_MORE_DATA
 * 	ERROR_ACCESS_DENIED
 *
 *	Buffer contains an array of session_info structures.
 *
 ***/
extern API_FUNCTION
  NetSessionEnum ( const char FAR *     pszServer,
                   short                sLevel,
                   char FAR *           pbBuffer,
                   unsigned short       cbBuffer,
                   unsigned short FAR * pcEntriesRead,
                   unsigned short FAR * pcTotalAvail );


extern API_FUNCTION
  NetSessionGetInfo ( const char FAR *     pszServer,
                      const char FAR *     pszClientName,
                      short                sLevel,
                      char FAR *           pbBuffer,
                      unsigned short       cbBuffer,
                      unsigned short FAR * pcbTotalAvail );


/****************************************************************
 *								*
 *		Data structure templates - SESSION		*
 *								*
 ****************************************************************/


struct session_info_0 {
    char FAR *		sesi0_cname;
};  /* session_info_0 */

struct session_info_1 {
    char FAR *		sesi1_cname;
    char FAR *		sesi1_username;
    unsigned short	sesi1_num_conns;
    unsigned short	sesi1_num_opens;
    unsigned short	sesi1_num_users;
    unsigned long	sesi1_time;
    unsigned long	sesi1_idle_time;
    unsigned long	sesi1_user_flags;
};  /* session_info_1 */

struct session_info_2 {
    char FAR *		 sesi2_cname;
    char FAR *		 sesi2_username;
    unsigned short	 sesi2_num_conns;
    unsigned short	 sesi2_num_opens;
    unsigned short	 sesi2_num_users;
    unsigned long	 sesi2_time;
    unsigned long	 sesi2_idle_time;
    unsigned long	 sesi2_user_flags;
    char FAR *		 sesi2_cltype_name;
};  /* session_info_2 */

struct session_info_10 {
        char FAR *     sesi10_cname;
        char FAR *     sesi10_username;
        unsigned long  sesi10_time;
        unsigned long  sesi10_idle_time;
};  /* session_info_10 */


struct session_info_50 {
	char FAR * sesi50_cname;            //remote computer name (connection id in Netware)
	char FAR * sesi50_username;
	unsigned long sesi50_key;           // used to delete session (not used in Netware)
	unsigned short sesi50_num_conns;
	unsigned short sesi50_num_opens;    //not available in Netware
	unsigned long sesi50_time;
	unsigned long sesi50_idle_time;		//not available in Netware
	unsigned char sesi50_protocol;
	unsigned char pad1;
};	/* session_info_50 */


/****************************************************************
 *								*
 *	  	Special values and constants - SESSION		*
 *								*
 ****************************************************************/

/*
 *	Bits defined in sesi1_user_flags.
 */

#define SESS_GUEST		1	/* session is logged on as a guest */
#define SESS_NOENCRYPTION	2	/* session is not using encryption */


#define SESI1_NUM_ELEMENTS	8
#define SESI2_NUM_ELEMENTS	9



/****************************************************************
 *								*
 *	  	Connection Class			        *
 *								*
 ****************************************************************/

/****************************************************************
 *                                                              *
 *              Function prototypes - CONNECTION                *
 *                                                              *
 *  Peer Server Support
 * 		NetConnectionEnum -
 *               sLevel 50 on VSERVER and NWSERVER              *
 *               On NWSERVER, this API doesnt provide more      *
 *               information than NetSessionEnum
 ****************************************************************/

/***	NetConnectionEnum (Admin only)
 *
 *	API_FUNCTION NetConnectionEnum( servername, 
 *					  qualifier, 
 *					  level, 
 *					  buf, 
 *					  buflen, 
 *					  totalavail )
 *
 *	ENTRY
 *
 *	servername;     asciz remote srv name, NULL if local
 *	qualifier;      netname or client computer name.
 *                  computer name should be prefaced by '\\'.
 *	level;	    	level of info requested
 *	buf;            for returned entry
 *	buflen;         size of buffer 
 *	totalavail;     total size needed for buffer
 *
 *	EXIT
 *
 *	0 = success
 *	NERR_NetNotStarted
 *	NERR_ServerNotStarted
 *	ERROR_INVALID_LEVEL
 *	NERR_RemoteErr
 *	NERR_RemoteOnly		(DOS)
 *	ERROR_MORE_DATA
 * 	ERROR_ACCESS_DENIED
 *	NERR_ClientNameNotFound
 *	NERR_NetNameNotFound
 *
 *	Buffer contents on response (format for a single entry):
 *   	    Level 50 contains a "struct connection_info_50".
 ***/
extern API_FUNCTION
  NetConnectionEnum ( const char FAR *     pszServer,
                      const char FAR *     pszQualifier,   /* upper case */
                      short                sLevel,
                      char FAR *           pbBuffer,
                      unsigned short       cbBuffer,
                      unsigned short FAR * pcEntriesRead,
                      unsigned short FAR * pcTotalAvail );


/****************************************************************
 *								*
 *	  	Data structure templates - CONNECTION		*
 *								*
 ****************************************************************/

struct connection_info_0 {
    unsigned short	coni0_id;
};  /* connection_info_0 */

struct connection_info_1 {
    unsigned short	coni1_id;
    unsigned short	coni1_type;
    unsigned short	coni1_num_opens;
    unsigned short	coni1_num_users;
    unsigned long	coni1_time;
    char FAR *		coni1_username;
    char FAR *		coni1_netname;
};  /* connection_info_1 */

struct connection_info_50 {
	unsigned short coni50_type;         // share type
	unsigned short coni50_num_opens;	//not used in Netware
	unsigned long coni50_time;
	char FAR * coni50_netname;          // share name          
	char FAR * coni50_username;         // user connected to share
}; /* connection_info_50 */


/****************************************************************
 *								*
 *	  	File Class			                *
 *								*
 ****************************************************************/


/****************************************************************
 *                                                              *
 *              Function prototypes - FILE                      *
 *                                                              *
 *  Peer Server Support
 * 		NetFileEnum - sLevel 50 on VSERVER and NWSERVER        *
 *      NetFileClose2 - VSERVER only
 ****************************************************************/

/***	NetFileClose2
 *
 *	int FAR PASCAL	NetFileClose2( servername, fileid )
 *
 *	ENTRY
 *
 *	servername;     asciz remote srv name, NULL if local
 *	fileid;     	file id supplied by NetFileEnum
 *
 *	EXIT
 *
 *	0 = success
 *	NERR_NetNotStarted
 *	NERR_ServerNotStarted
 *	NERR_RemoteErr
 * 	ERROR_ACCESS_DENIED
 *	NERR_FileIdNotFound
 *
 ***/
extern API_FUNCTION
  NetFileClose2 ( const char FAR * pszServer,
                  unsigned long    ulFileId );

/***	NetFileEnum (Admin Only)
 *
 *	int FAR PASCAL NetFileEnum( servername,
 *				    level, 
 *				    buf, 
 *				    buflen, 
 *				    entriesread, 
 *				    totalentries )
 *
 *	ENTRY
 *
 *	servername;     asciz remote srv name, NULL if local
 *	basepath;	path qualifier for file matching
 *              (not used for Win95 NWSERVER)
 *	level;          level of detail requested; (50 for Win95 peer servers)
 *	buf;            for returned entries
 *	buflen;         size of buffer on call; 
 *	entriesread;    # of entries supplied on return
 *	totalentries;   total # of entries available
 *
 * 	EXIT
 *
 *	0 = success
 *	NERR_RemoteOnly
 *	NERR_NetNotStarted
 *	NERR_ServerNotStarted
 *	ERROR_INVALID_LEVEL
 *	NERR_RemoteErr
 *	ERROR_MORE_DATA
 * 	ERROR_ACCESS_DENIED
 *
 *	
 *	Buffer contents on response (format for a single entry):
 *   	    Level 0 contains a "struct file_info_0".
 *   	    Level 50 contains a "struct file_info_50".
 *
 ***/

extern API_FUNCTION
  NetFileEnum ( const char FAR *     pszServer,
                const char FAR *     pszBasePath,
                short                sLevel,
                char FAR *           pbBuffer,
                unsigned short       cbBuffer,
                unsigned short FAR * pcEntriesRead,
                unsigned short FAR * pcTotalAvail );


/****************************************************************
 *								*
 *	  	Data structure templates - FILE			*
 *								*
 ****************************************************************/

struct file_info_0 {
    unsigned short	fi0_id;
};  /* file_info_0 */

struct file_info_1 {
    unsigned short	fi1_id;
    unsigned short	fi1_permissions;
    unsigned short	fi1_num_locks;
    char FAR *		fi1_pathname;
    char FAR *		fi1_username;
};  /* file_info_1 */

struct file_info_2 {
    unsigned long	fi2_id;
};  /* file_info_2 */

struct file_info_3 {
    unsigned long	fi3_id;
    unsigned short	fi3_permissions;
    unsigned short	fi3_num_locks;
    char FAR *		fi3_pathname;
    char FAR *		fi3_username;
};  /* file_info_3 */

struct file_info_50 {
	unsigned long fi50_id;              // not used on NWSERVER
	unsigned short fi50_permissions;    // not available on NWSERVER
	unsigned short fi50_num_locks;      // not available on NWSERVER
	char FAR * fi50_pathname;
	char FAR * fi50_username;
	char FAR * fi50_sharename;
}; /* file_info_50 */

struct res_file_enum_2 {
    unsigned short	res_pad;	 /* not used now */
    unsigned short      res_fs;          /* server type */
    unsigned long	res_pro;	  /* progressive */
};  /* res_file_enum_2 */

/****************************************************************
 *								*
 *		Special values and constants - FILE		*
 *								*
 ****************************************************************/

					/* bit values for permissions */
#define	PERM_FILE_READ		0x1	/* user has read access */
#define	PERM_FILE_WRITE		0x2	/* user has write access */
#define	PERM_FILE_CREATE	0x4	/* user has create access */


typedef struct res_file_enum_2 FRK;

/*NOINC*/
#define FRK_INIT( f )	\
	{		\
		(f).res_pad = 0L;	\
		(f).res_fs = 0;	\
		(f).res_pro = 0;	\
	}

/*INC*/


/****************************************************************
 *								*
 *	  	Server Class			                *
 *								*
 ****************************************************************/


/****************************************************************
 *                                                              *
 *              Function prototypes - SERVER                    *
 *                                                              *
 * Peer Server Support
 * 	NetServerGetInfo - sLevel 1,50 on NWSERVER, VSERVER
 ****************************************************************/

/* 6.2  NetServerGetInfo 
 *
 * Purpose: Read the current configuration parameters of the server.
 *
 * int FAR PASCAL
 * NetServerGetInfo( servername, level, buf, buflen, totalavail )
 * char FAR *          servername;   asciz remote server name or NULL if local
 * short               level;          level of information to be returned
 * char FAR *          buf;            for returned data
 * unsigned short      buflen;         size of buffer
 * unsigned short FAR *totalavail;     total size needed for buffer
 *
 * Buffer contents on response (format for a single entry):
 *     Level 1 contains a "struct server_info_1".
 *     Level 50 contains a "struct server_info_50".
 *
 * If the buflen is not large enough for all of the information, the call
 * will return as much as will fit in the buffer.
 *
 * Returns 0 if successful. Error return information:
 *
 *     - ERROR_INVALID_LEVEL       - Level parameter specified is invalid
 *     - ERROR_INVALID_PARAMETER   - An invalid input parameter was detected.
 *     - NERR_NetNotStarted        - Network not installed on local machine
 *     - NERR_ServerNotStarted     - Server is not started
 *     - NERR_BufTooSmall          - The buffer supplied was to small to
 *                                   return the fixed length structure
 *				     requested.
 *     - NERR_MoreData             - The buffer supplied was too small to
 *				     return all the information available
 *				     for this server.
 *
 */


extern API_FUNCTION
  NetServerGetInfo ( const char FAR *     pszServer,
                     short                sLevel,
                     char FAR *           pbBuffer,
                     unsigned short       cbBuffer,
                     unsigned short FAR * pcbTotalAvail );


/****************************************************************
 *								*
 *	  	Data structure templates - SERVER		*
 *								*
 ****************************************************************/

struct server_info_0 {
    char	    sv0_name[CNLEN + 1]; 	/* Server name		    */
};	 /* server_info_0 */


struct server_info_1 {
    char	    sv1_name[CNLEN + 1];
    unsigned char   sv1_version_major;		/* Major version # of net   */
    unsigned char   sv1_version_minor;		/* Minor version # of net   */
    unsigned long   sv1_type;	     		/* Server type 		    */
    char FAR *	    sv1_comment; 		/* Exported server comment  */
};	 /* server_info_1 */


/* NOTE struct prefix must equal server_info_1 like below! */

struct server_info_50 {
    char	    sv50_name[CNLEN + 1];
    unsigned char   sv50_version_major;		/* Major version # of net   */
    unsigned char   sv50_version_minor;		/* Minor version # of net   */
    unsigned long   sv50_type;	     		/* Server type 		    */
    char FAR *	    sv50_comment; 		/* Exported server comment  */
    unsigned short  sv50_security;    		/* SV_SECURITY_* (see below) */
    unsigned short  sv50_auditing;    /* 0 = no auditing; nonzero = auditing */
    char FAR *      sv50_container;		/* Security server/domain    */
    char FAR *	    sv50_ab_server;		/* Address book server       */
    char FAR *	    sv50_ab_dll;		/* Address book provider DLL */
};	/* server_info_50 */


struct server_info_2 {
    char            sv2_name[CNLEN + 1];
    unsigned char   sv2_version_major;
    unsigned char   sv2_version_minor;
    unsigned long   sv2_type;	
    char FAR *	    sv2_comment;		
    unsigned long   sv2_ulist_mtime; /* User list, last modification time    */
    unsigned long   sv2_glist_mtime; /* Group list, last modification time   */
    unsigned long   sv2_alist_mtime; /* Access list, last modification time  */
    unsigned short  sv2_users;       /* max number of users allowed          */
    unsigned short  sv2_disc;	    /* auto-disconnect timeout(in minutes)  */
    char FAR *	    sv2_alerts;	    /* alert names (semicolon separated)    */
    unsigned short  sv2_security;    /* SV_USERSECURITY or SV_SHARESECURITY  */
    unsigned short  sv2_auditing;    /* 0 = no auditing; nonzero = auditing  */

    unsigned short  sv2_numadmin;    /* max number of administrators allowed */
    unsigned short  sv2_lanmask;     /* bit mask representing the srv'd nets */
    unsigned short  sv2_hidden;      /* 0 = visible; nonzero = hidden        */
    unsigned short  sv2_announce;    /* visible server announce rate (sec)   */
    unsigned short  sv2_anndelta;    /* announce randomize interval (sec)    */
                                    /* name of guest account                */
    char            sv2_guestacct[LM20_UNLEN + 1];
    unsigned char   sv2_pad1;	    /* Word alignment pad byte		    */
    char FAR *      sv2_userpath;    /* ASCIIZ path to user directories      */
    unsigned short  sv2_chdevs;      /* max # shared character devices       */
    unsigned short  sv2_chdevq;      /* max # character device queues        */
    unsigned short  sv2_chdevjobs;   /* max # character device jobs          */
    unsigned short  sv2_connections; /* max # of connections		    */
    unsigned short  sv2_shares;	    /* max # of shares			    */
    unsigned short  sv2_openfiles;   /* max # of open files		    */
    unsigned short  sv2_sessopens;   /* max # of open files per session	    */
    unsigned short  sv2_sessvcs;     /* max # of virtual circuits per client */
    unsigned short  sv2_sessreqs;    /* max # of simul. reqs. from a client  */
    unsigned short  sv2_opensearch;  /* max # of open searches		    */
    unsigned short  sv2_activelocks; /* max # of active file locks           */
    unsigned short  sv2_numreqbuf;   /* number of server (standard) buffers  */
    unsigned short  sv2_sizreqbuf;   /* size of svr (standard) bufs (bytes)  */
    unsigned short  sv2_numbigbuf;   /* number of big (64K) buffers          */
    unsigned short  sv2_numfiletasks;/* number of file worker processes      */
    unsigned short  sv2_alertsched;  /* alert counting interval (minutes)    */
    unsigned short  sv2_erroralert;  /* error log alerting threshold         */
    unsigned short  sv2_logonalert;  /* logon violation alerting threshold   */
    unsigned short  sv2_accessalert; /* access violation alerting threshold  */
    unsigned short  sv2_diskalert;   /* low disk space alert threshold (KB)  */
    unsigned short  sv2_netioalert;  /* net I/O error ratio alert threshold  */
                                    /*  (tenths of a percent)               */
    unsigned short  sv2_maxauditsz;  /* Maximum audit file size (KB)        */
    char FAR *	    sv2_srvheuristics; /* performance related server switches*/
};	/* server_info_2 */


struct server_info_3 {
    char	    sv3_name[CNLEN + 1];
    unsigned char   sv3_version_major;
    unsigned char   sv3_version_minor;
    unsigned long   sv3_type;
    char FAR *	    sv3_comment;
    unsigned long   sv3_ulist_mtime; /* User list, last modification time    */
    unsigned long   sv3_glist_mtime; /* Group list, last modification time   */
    unsigned long   sv3_alist_mtime; /* Access list, last modification time  */
    unsigned short  sv3_users;	     /* max number of users allowed	     */
    unsigned short  sv3_disc;	    /* auto-disconnect timeout(in minutes)  */
    char FAR *	    sv3_alerts;     /* alert names (semicolon separated)    */
    unsigned short  sv3_security;    /* SV_USERSECURITY or SV_SHARESECURITY  */
    unsigned short  sv3_auditing;    /* 0 = no auditing; nonzero = auditing  */

    unsigned short  sv3_numadmin;    /* max number of administrators allowed */
    unsigned short  sv3_lanmask;     /* bit mask representing the srv'd nets */
    unsigned short  sv3_hidden;      /* 0 = visible; nonzero = hidden	     */
    unsigned short  sv3_announce;    /* visible server announce rate (sec)   */
    unsigned short  sv3_anndelta;    /* announce randomize interval (sec)    */
				    /* name of guest account		    */
    char	    sv3_guestacct[LM20_UNLEN + 1];
    unsigned char   sv3_pad1;	    /* Word alignment pad byte		    */
    char FAR *	    sv3_userpath;    /* ASCIIZ path to user directories	     */
    unsigned short  sv3_chdevs;      /* max # shared character devices	     */
    unsigned short  sv3_chdevq;      /* max # character device queues	     */
    unsigned short  sv3_chdevjobs;   /* max # character device jobs	     */
    unsigned short  sv3_connections; /* max # of connections		    */
    unsigned short  sv3_shares;     /* max # of shares			    */
    unsigned short  sv3_openfiles;   /* max # of open files		    */
    unsigned short  sv3_sessopens;   /* max # of open files per session     */
    unsigned short  sv3_sessvcs;     /* max # of virtual circuits per client */
    unsigned short  sv3_sessreqs;    /* max # of simul. reqs. from a client  */
    unsigned short  sv3_opensearch;  /* max # of open searches		    */
    unsigned short  sv3_activelocks; /* max # of active file locks	     */
    unsigned short  sv3_numreqbuf;   /* number of server (standard) buffers  */
    unsigned short  sv3_sizreqbuf;   /* size of svr (standard) bufs (bytes)  */
    unsigned short  sv3_numbigbuf;   /* number of big (64K) buffers	     */
    unsigned short  sv3_numfiletasks;/* number of file worker processes      */
    unsigned short  sv3_alertsched;  /* alert counting interval (minutes)    */
    unsigned short  sv3_erroralert;  /* error log alerting threshold	     */
    unsigned short  sv3_logonalert;  /* logon violation alerting threshold   */
    unsigned short  sv3_accessalert; /* access violation alerting threshold  */
    unsigned short  sv3_diskalert;   /* low disk space alert threshold (KB)  */
    unsigned short  sv3_netioalert;  /* net I/O error ratio alert threshold  */
                                    /*  (tenths of a percent)               */
    unsigned short  sv3_maxauditsz;  /* Maximum audit file size (KB)	     */
    char FAR *	    sv3_srvheuristics; /* performance related server switches*/
    unsigned long   sv3_auditedevents; /* Audit event control mask	     */
    unsigned short  sv3_autoprofile; /* (0,1,2,3) = (NONE,LOAD,SAVE,or BOTH) */
    char FAR *	    sv3_autopath;    /* file pathname (where to load & save) */
};	/* server_info_3 */



/****************************************************************
 *								*
 *	  	Special values and constants - SERVER		*
 *								*
 ****************************************************************/

/*
 *	Mask to be applied to svX_version_major in order to obtain
 *	the major version number.
 */

#define MAJOR_VERSION_MASK	0x0F

/*
 *	Bit-mapped values for svX_type fields. X = 1, 2 or 3.
 */

#define SV_TYPE_WORKSTATION	0x00000001
#define SV_TYPE_SERVER		0x00000002
#define SV_TYPE_SQLSERVER	0x00000004
#define SV_TYPE_DOMAIN_CTRL	0x00000008
#define SV_TYPE_DOMAIN_BAKCTRL	0x00000010
#define SV_TYPE_TIME_SOURCE	0x00000020
#define SV_TYPE_AFP		0x00000040
#define SV_TYPE_NOVELL		0x00000080      /* This flag is also set by Win95 NWSERVER */
#define SV_TYPE_DOMAIN_MEMBER	0x00000100
#define SV_TYPE_PRINTQ_SERVER	0x00000200
#define SV_TYPE_DIALIN_SERVER	0x00000400
#define SV_TYPE_ALL		0xFFFFFFFF   /* handy for NetServerEnum2 */

/*
 *	Special value for svX_disc that specifies infinite disconnect
 *	time. X = 2 or 3.
 */

#define SV_NODISC		0xFFFF	/* No autodisconnect timeout enforced */

/*
 *	Values of svX_security field. X = 2 or 3.
 */

#define SV_USERSECURITY		1
#define SV_SHARESECURITY	0

/*
 *	Values of svX_security field. X = 50.
 *  For Win95 NWSERVER, the only possible returned value is SV_SECURITY_NETWARE.
 */

#define SV_SECURITY_SHARE	0	/* Share-level */
#define SV_SECURITY_WINNT	1	/* User-level - Windows NT workst'n */
#define SV_SECURITY_WINNTAS	2	/* User-level - Windows NT domain */
#define SV_SECURITY_NETWARE	3	/* User-level - NetWare 3.x bindery */

/*
 *	Values of svX_hidden field. X = 2 or 3.
 */

#define SV_HIDDEN		1
#define SV_VISIBLE		0

#define SVI1_NUM_ELEMENTS	5
#define SVI2_NUM_ELEMENTS	44
#define SVI3_NUM_ELEMENTS	45


/*
 *      Masks describing AUTOPROFILE parameters
 */

#define SW_AUTOPROF_LOAD_MASK	0x1
#define SW_AUTOPROF_SAVE_MASK	0x2



/****************************************************************
 *                                                              *
 *                 Security Class                               *
 *                                                              *
 ****************************************************************/


/****************************************************************
 *                                                              *
 *                  Function prototypes - SECURITY              *
 *                                                              *
 ****************************************************************/

extern API_FUNCTION
  NetSecurityGetInfo ( const char FAR *     pszServer,
                       short                sLevel,
                       char FAR *           pbBuffer,
                       unsigned short       cbBuffer,
                       unsigned short FAR * pcbTotalAvail );


/****************************************************************
 *								*
 *	  	Data structure templates - SECURITY		*
 *								*
 ****************************************************************/

struct security_info_1 {
    unsigned long   sec1_security;    	/* SEC_SECURITY_* (see below) */
    char FAR *      sec1_container;	/* Security server/domain     */
    char FAR *	    sec1_ab_server;	/* Address book server        */
    char FAR *	    sec1_ab_dll;	/* Address book provider DLL  */
};	/* security_info_1 */


/****************************************************************
 *								*
 *	  	Special values and constants - SECURITY		*
 *								*
 ****************************************************************/

/*
/*
 *	Values of secX_security field. X = 1.
 */

#define SEC_SECURITY_SHARE	SV_SECURITY_SHARE
#define SEC_SECURITY_WINNT	SV_SECURITY_WINNT
#define SEC_SECURITY_WINNTAS	SV_SECURITY_WINNTAS
#define SEC_SECURITY_NETWARE	SV_SECURITY_NETWARE



/*NOINC*/
#ifdef __cplusplus
}
#endif	/* __cplusplus */

#ifndef RC_INVOKED
#pragma pack()          /* Revert to default packing */
#endif

#endif /* SVRAPI_INCLUDED */
/*INC*/
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\hnw\win95\svrapi3.h ===
/********************************************************************/
/**                     Microsoft Windows                          **/
/**               Copyright 1995 - 1998 Microsoft Corporation               **/
/********************************************************************/

/********************************************************************
 *                                                                  *
 *  About this file ...  SVRAPI.H                                   *
 *                                                                  *
 *  This file contains information about the NetAccess,             *
 *  NetConnection, NetFile, NetServer, NetSession, NetShare and     *
 *  NetSecurity APIs.                                               *
 *  There is a section for each set of APIs.                        *
 *  Each section contains:                                          *
 *                                                                  *
 *      Function prototypes.                                        *
 *                                                                  *
 *      Data structure templates.                                   *
 *                                                                  *
 *      Definition of special values.                               *
 *                                                                  *
 *      Description of level of Win95 peer server support           *
 *
 *  For background information refer to the Lan Manager Programmer's
 *  Reference.
 *
 *  WARNING:
 *      The APIs documented herein are not guaranteed to be supported
 * in future versions of Windows. Their primary purpose is to       *
 * administer Win95 peer servers.                                   *
 *                                                                  *
 ********************************************************************/

/*
 *      NOTE:  Lengths of ASCIIZ strings are given as the maximum
 *      strlen() value.  This does not include space for the
 *      terminating 0-byte.  When allocating space for such an item,
 *      use the form:
 *
 *              char username[LM20_UNLEN+1];
 *
 *      An exception to this is the PATHLEN manifest, which does
 *      include space for the terminating 0-byte.
 *
 *      User names, computer names and share names should be
 *      upper-cased by the caller and drawn from the ANSI 
 *      character set.
 * 
 */

/*NOINC*/
#ifndef SVRAPI_INCLUDED
#define SVRAPI_INCLUDED

#include <lmcons.h>
#include <lmerr.h>

#ifndef RC_INVOKED
#pragma pack(1)         /* Assume byte packing throughout */
#endif

#ifdef __cplusplus
extern "C" {            /* Assume C declarations for C++ */
#endif	/* __cplusplus */

#if !defined(_SVRAPI_)
#define API_FUNCTION DECLSPEC_IMPORT API_RET_TYPE APIENTRY
#else
#define API_FUNCTION API_RET_TYPE APIENTRY
#endif

/*INC*/


/****************************************************************
 *                                                              *
 *                 Access Class                                 *
 *                                                              *
 ****************************************************************/


/****************************************************************
 *                                                              *
 *                  Function prototypes - ACCESS                *
 *
 * 	Requires User level security to be enabled
 *                                                              *
 *	Peer Server Support:
 *      Remote support of these APIs on NWSERVER is limited as
 *      described below:
 *
 *		NetAccessAdd -
 *				local and remote VSERVER - level 2
 *              remote NWSERVER -          level 2
 *	    NetAccessCheck - local only
 *      NetAccessDel - 
 *              local, remote NWSERVER and remote VSERVER
 *      NetAccessEnum -
 *              sLevel 0 on remote NWSERVER (fRecursive = 1),
 *              slevel 0, 1, 2 on local and remote VSERVER
 *		NetAccessGetInfo -
 *               all sLevels on local and remote VSERVER,
 *      		 sLevel 0, 12 on remote NWSERVER
 *      NetAccessSetInfo - 
 *              sLevel 1, 12 on local and remote VSERVER,
 *              sLevel 12 on remote NWSERVER
 *              parmnum = PARMNUM_ALL only
 *      NetAccessGetUserPerms - local and remote VSERVER only
 ****************************************************************/

extern API_FUNCTION
  NetAccessAdd ( const char FAR * pszServer,
                 short            sLevel,
                 char FAR *       pbBuffer,
                 unsigned short   cbBuffer );

extern API_FUNCTION
  NetAccessCheck ( char FAR *           pszReserved,
                   char FAR *           pszUserName,
                   char FAR *           pszResource,
                   unsigned short       usOperation,
                   unsigned short FAR * pusResult );

extern API_FUNCTION
  NetAccessDel ( const char FAR * pszServer,
                 char FAR *       pszResource );

extern API_FUNCTION
  NetAccessEnum ( const char FAR *     pszServer,
                  char FAR *           pszBasePath,
                  short                fsRecursive,
                  short                sLevel,
                  char FAR *           pbBuffer,
                  unsigned short       cbBuffer,
                  unsigned short FAR * pcEntriesRead,
                  unsigned short FAR * pcTotalAvail );

extern API_FUNCTION
  NetAccessGetInfo ( const char FAR *     pszServer,
                     char FAR *           pszResource,
                     short                sLevel,
                     char FAR *           pbBuffer,
                     unsigned short       cbBuffer,
                     unsigned short FAR * pcbTotalAvail );

extern API_FUNCTION
  NetAccessSetInfo ( const char FAR * pszServer,
                     char FAR *       pszResource,
                     short            sLevel,
                     char FAR *       pbBuffer,
                     unsigned short   cbBuffer,
                     short            sParmNum );

extern API_FUNCTION
  NetAccessGetUserPerms ( char FAR *           pszServer,
                          char FAR *           pszUgName,
                          char FAR *           pszResource,
                          unsigned short FAR * pusPerms );


/****************************************************************
 *                                                              *
 *              Data structure templates - ACCESS               *
 *                                                              *
 ****************************************************************/

struct access_list {
        char            acl_ugname[LM20_UNLEN+1];
        char            acl_ugname_pad_1;
        short           acl_access;
};      /* access_list */

struct access_list_2
{
        char FAR *      acl2_ugname;
        unsigned short  acl2_access;
};      /* access_list_2 */
             
struct access_list_12
{
        char FAR *      acl12_ugname;
        unsigned short  acl12_access;
};      /* access_list_12 */
             
struct access_info_0 {
        char FAR *      acc0_resource_name;
};      /* access_info_0 */

struct access_info_1 {
        char  FAR *     acc1_resource_name;
        short           acc1_attr;                      /* See values below */
        short           acc1_count;
};      /* access_info_1 */

struct access_info_2 
{
        char  FAR *     acc2_resource_name;
        short           acc2_attr;
        short           acc2_count;
};      /* access_info_2 */

struct access_info_10 {
        char FAR *      acc10_resource_name;
};      /* access_info_10 */

struct access_info_12 
{
        char  FAR *     acc12_resource_name;
        short           acc12_attr;
        short           acc12_count;
};      /* access_info_12 */


/****************************************************************
 *                                                              *
 *              Special values and constants - ACCESS           *
 *                                                              *
 ****************************************************************/

/*
 *      Maximum number of permission entries for each resource.
 */

#define MAXPERMENTRIES  64


/*
 *      Bit values for the access permissions.  ACCESS_ALL is a handy
 *      way to specify maximum permissions.  These are used in
 *      acl_access field of access_list structures.
 */
/*NOINC*/
#define         ACCESS_NONE     0
#define         ACCESS_ALL     (ACCESS_READ|ACCESS_WRITE|ACCESS_CREATE|ACCESS_EXEC|ACCESS_DELETE|ACCESS_ATRIB|ACCESS_PERM|ACCESS_FINDFIRST)
/*INC*/
#define         ACCESS_READ     0x1
#define         ACCESS_WRITE    0x2
#define         ACCESS_CREATE   0x4
#define         ACCESS_EXEC     0x8
#define         ACCESS_DELETE   0x10
#define         ACCESS_ATRIB    0x20
#define         ACCESS_PERM     0x40
#define         ACCESS_FINDFIRST 0x80

#define         ACCESS_GROUP    0x8000

/*
 *      Bit values for the acc1_attr field of the access_info_1 structure.
 *      Only one bit is currently defined.
 */

#define         ACCESS_AUDIT            0x1

/*
 *      Parmnum value for NetAccessSetInfo.
 */

#define         ACCESS_ATTR_PARMNUM     2


/*
 *      ACCESS_LETTERS defines a letter for each bit position in
 *      the acl_access field of struct access_list.  Note that some
 *      bits have a corresponding letter of ' ' (space).
 */

#define         ACCESS_LETTERS          "RWCXDAP         "



/****************************************************************
 *								*
 *	  	Share Class			                *
 *								*
 ****************************************************************/

/****************************************************************
 *                                                              *
 *              Function prototypes - SHARE                     *
 *                                                              *
 *	Peer Server Support
 * 		NetShareAdd() - sLevel 50 on VSERVER and NWSERVER
 * 		NetShareDel() - VSERVER and NWSERVER
 *		NetShareEnum() - sLevel 1,50 on VSERVER; 50 on NWSERVER
 *      NetShareGetInfo() - sLevel 50 on VSERVER, NWSERVER
 * 		NetShareSetInfo() - sLevel 50, sParmNum PARMNUM_ALL
 *						 on VSERVER, NWSERVER
 ****************************************************************/

/***	NetShareAdd - add a new share to the server tables
 *
 *	NetShareAdd( servername, level, buf, buflen )
 *
 *	ENTRY:	servername - asciz string containing name of server
 *                       or NULL if local
 *		level- Must be 50 for Win95 peer servers.
 *		buf - far ptr to struct share_info
 *		buflen - unsigned int length of buffer
 *
 *	EXIT:	0 = success
 *		ERROR_INVALID_LEVEL
 *      ERROR_BAD_NETPATH
 *		ERROR_INVALID_PARAMETER
 *		NERR_UnknownDevDir
 *		NERR_ShareExists
 *		NERR_UnknownServer
 *		NERR_ServerNotStarted
 *		NERR_RedirectedPath
 *		NERR_DuplicateShare
 *		NERR_BufTooSmall
 *		ERROR_NOT_ENOUGH_MEMORY
 *
 */
extern API_FUNCTION
  NetShareAdd ( const char FAR * pszServer,
                short            sLevel,
                const char FAR * pbBuffer,
                unsigned short   cbBuffer );

/***	NetShareDel (Admin only)
 *
 *	API_FUNCTION NetShareDel( servername, netname, reserved )
 *
 *	ENTRY
 *
 *	char FAR *  servername;     asciz remote srv name, NULL if local
 *	char FAR *  netname;        asciz network name of share being deleted
 *	unsigned short reserved;    MBZ
 *
 *	EXIT
 *
 *	0 = success
 *	NERR_NetNotStarted
 *  ERROR_BAD_NETPATH
 *	NERR_ServerNotStarted
 *	NERR_NetNameNotFound
 *	ERROR_INVALID_PARAMETER
 *
 *
 *	Note:  Deleting a share will also delete any existing connections
 *		to the shared resource, and close open files within the
 *		connections.
 */
extern API_FUNCTION
  NetShareDel ( const char FAR * pszServer,
                const char FAR * pszNetName,
                unsigned short   usReserved );

/* 2.1  NetShareEnum
 *
 * API_FUNCTION
 * NetShareEnum( servername, level, buf, buflen, entriesread, totalentries )
 * char FAR *          servername;     asciz remote server name or NULL if local
 * short               sLevel;         level of detail requested; 1 or 50
 * char FAR *          pbBuffer;       buffer to return entries in
 * unsigned short      cbBuffer;       size of buffer on call
 * unsigned short FAR *pcEntriesRead;  # of entries supplied on return
 * unsigned short FAR *pcTotalAvail ;  total # of entries available
 *
 * Supply information about existing shares at specified level.
 *
 * Buffer contents on response (format for a single entry):
 *     Level 1 contains a "struct share_info_1".
 *     Level 50 contains a "struct share_info_50".
 *
 * Returns 0 if successful.  Possible error returns:
 *  ERROR_INVALID_LEVEL
 *  ERROR_BAD_NETPATH
 *  NERR_NetNotStarted
 *  NERR_ServerNotStarted
 *  ERROR_MORE_DATA
 */
extern API_FUNCTION
  NetShareEnum ( const char FAR *     pszServer,
                 short                sLevel,
                 char FAR *           pbBuffer,
                 unsigned short       cbBuffer,
                 unsigned short FAR * pcEntriesRead,
                 unsigned short FAR * pcTotalAvail );

/* 2.2  NetShareGetInfo
 *
 * Purpose: Read complete information about a single outstanding share.
 *
 * API_FUNCTION
 * NetShareGetInfo( servername, netname, level, buf, buflen, totalavail )
 * char FAR *          servername;     asciz remote server name or NULL if local
 * char FAR *          netname;        asciz network name of share being queried
 * short               level;          level of info requested (50 for Win95 peer servers)
 * char FAR *          buf;            for returned entry
 * unsigned short      buflen;         size of buffer
 * unsigned short FAR *totalavail;     total size needed for buffer
 *
 * Buffer contents on response:
 *     Level 50 contains a "struct share_info_50".
 *
 * Returns 0 if successful.  Possible error returns:
 *  ERROR_INVALID_LEVEL
 *  ERROR_INVALID_PARAMETER
 *  ERROR_BAD_NETPATH
 *  NERR_NetNotStarted
 *  NERR_ServerNotStarted
 *  NERR_NetNameNotFound
 *  NERR_MoreData
 *  NERR_BufTooSmall
 */
extern API_FUNCTION
  NetShareGetInfo ( const char FAR *     pszServer,
                    const char FAR *     pszNetName,
                    short                sLevel,
                    char FAR *           pbBuffer,
                    unsigned short       cbBuffer,
                    unsigned short FAR * pcbTotalAvail );

/***	NetShareSetInfo (Admin only)
 *
 *	API_FUNCTION NetShareSetInfo( servername,
 *					netname,
 *					level,
 *					buf,
 *					buflen,
 *					parmnum )
 *					
 *	ENTRY
 *
 *	servername;     asciz remote srv name, NULL if local
 *	netname;        asciz network name of share being set
 *	level;		level of info provided (50 for Win95 peer servers)
 *	buf;            contents described below
 *	buflen;         size of buffer
 *	parmnum;        must be PARMNUM_ALL for Win95 peer servers
 *
 *	Buffer contents on call if parmnum is zero:
 *   	    Level 50 contains a "struct share_info_50".
 *
 *	Settable fields are:
 *          shi_remark
 *          shi_passwd
 *
 *	EXIT
 *
 *	0 = success
 *	NERR_NetNotStarted
 *	NERR_ServerNotStarted
 *	NERR_NetNameNotFound
 *	ERROR_INVALID_LEVEL
 * 	NERR_BufTooSmall
 *	NERR_RemoteErr
 *	ERROR_MORE_DATA
 *	ERROR_INVALID_PARAMETER
 ***/
extern API_FUNCTION
  NetShareSetInfo ( const char FAR * pszServer,
                    const char FAR * pszNetName,
                    short            sLevel,
                    const char FAR * pbBuffer,
                    unsigned short   cbBuffer,
                    short            sParmNum );


/****************************************************************
 *								*
 *	  	Data structure templates - SHARE		*
 *
 ****************************************************************/

struct share_info_0 {
    char		shi0_netname[LM20_NNLEN+1];
};  /* share_info_0 */

struct share_info_1 {
    char		shi1_netname[LM20_NNLEN+1];
    char		shi1_pad1;
    unsigned short	shi1_type;
    char FAR *		shi1_remark;
};  /* share_info_1 */

struct share_info_2 {
    char		shi2_netname[LM20_NNLEN+1];
    char		shi2_pad1;
    unsigned short	shi2_type;
    char FAR *		shi2_remark;
    unsigned short	shi2_permissions;
    unsigned short	shi2_max_uses;
    unsigned short	shi2_current_uses;
    char FAR *		shi2_path;
    char 		shi2_passwd[SHPWLEN+1];
    char		shi2_pad2;
};  /* share_info_2 */

struct share_info_50 {
	char		shi50_netname[LM20_NNLEN+1];    /* share name */
	unsigned char 	shi50_type;                 /* see below */
    unsigned short	shi50_flags;                /* see below */
	char FAR *	shi50_remark;                   /* ANSI comment string */
	char FAR *	shi50_path;                     /* shared resource */
	char		shi50_rw_password[SHPWLEN+1];   /* read-write password (share-level security) */
	char		shi50_ro_password[SHPWLEN+1];   /* read-only password (share-level security) */
};	/* share_info_50 */


/****************************************************************
 *								*
 *	  	Special values and constants - SHARE		*
 *								*
 ****************************************************************/

/* Field values for shi50_flags; */

/* These flags are relevant for share-level security on VSERVER
 * When operating with user-level security, use SHI50F_FULL - the actual
 * access rights are determined by the NetAccess APIs.
 */
#define	SHI50F_RDONLY		0x0001
#define	SHI50F_FULL			0x0002
#define	SHI50F_DEPENDSON	(SHI50F_RDONLY|SHI50F_FULL)
#define	SHI50F_ACCESSMASK	(SHI50F_RDONLY|SHI50F_FULL)

/* The share is restored on system startup */
#define	SHI50F_PERSIST		0x0100
/* The share is not normally visible  */
#define SHI50F_SYSTEM		0x0200


/*
 *	Values for parmnum parameter to NetShareSetInfo.
 */

#ifndef PARMNUM_ALL
#define PARMNUM_ALL				0
#endif

#define	SHI_REMARK_PARMNUM		4
#define	SHI_PERMISSIONS_PARMNUM		5
#define	SHI_MAX_USES_PARMNUM		6
#define	SHI_PASSWD_PARMNUM		9

#define	SHI1_NUM_ELEMENTS		4
#define	SHI2_NUM_ELEMENTS		10


/*
 *	Share types .
 *  
 *  STYPE_DISKTREE and STYPE_PRINTQ are recognized on peer servers
 */

#define STYPE_DISKTREE 			0       /* disk share */
#define STYPE_PRINTQ   			1       /* printer share */
#define STYPE_DEVICE   			2
#define STYPE_IPC      			3

#define SHI_USES_UNLIMITED		-1



/****************************************************************
 *								*
 *	  	Session Class			                *
 *								*
 ****************************************************************/

/****************************************************************
 *                                                              *
 *              Function prototypes - SESSION                   *
 *
 *	Peer Server Support                                         *
 *  	NetSessionDel() - NWSERVER and VSERVER 					*
 *	    NetSessionEnum() - sLevel 50 on NWSERVER and VSERVER    *
 *		NetSessionGetInfo() - not supported on peer servers     *
 ****************************************************************/

/***	NetSessionDel (Admin only)
 *
 *
 *	API_FUNCTION NetSessionDel( servername, clientname, reserved )
 *
 *	ENTRY
 *
 * 	servername;     asciz remote srv name, NULL if local
 *	clientname;     asciz remote computer name (returned by NetSessionEnum)
 *                               	of session being deleted
 *                  In the case of a Win95 NWSERVER, the clientname should be the
 *                  ascii connection number
 *	reserved;       session key returned by NetSessionEnum
 *
 * 	EXIT
 *
 *	0 = success
 *	NERR_NetNotStarted
 *  ERROR_BAD_NETPATH
 *	NERR_ServerNotStarted
 *	ERROR_INVALID_LEVEL
 *	NERR_RemoteErr
 *	NERR_RemoteOnly
 * 	ERROR_ACCESS_DENIED
 *	NERR_BufTooSmall
 *	NERR_ClientNameNotFound
 *
 ***/
extern API_FUNCTION
  NetSessionDel ( const char FAR * pszServer,
                  const char FAR * pszClientName,
                  short            sReserved );

/***	NetSessionEnum
 *
 *	API_FUNCTION NetSessionEnum( servername,
 *				       level,
 *				       buf,
 *				       buflen,
 *				       entriesread,
 *				       totalentries )
 *	ENTRY
 *				
 *	servername;     asciz remote srv name, NULL if local
 * 	level;          level of detail requested; (50 for Win95 peer servers)
 *	buf;            for returned entries
 *	buflen;         size of buffer on call;
 *	entriesread;    # of entries supplied on return
 *	totalentries;   total # of entries available
 *
 * 	EXIT
 *
 *	0 = success
 *	NERR_NetNotStarted
 *	NERR_ServerNotStarted
 *  ERROR_BAD_NETPATH
 *	ERROR_INVALID_LEVEL
 *	NERR_RemoteErr
 *	ERROR_MORE_DATA
 * 	ERROR_ACCESS_DENIED
 *
 *	Buffer contains an array of session_info structures.
 *
 ***/
extern API_FUNCTION
  NetSessionEnum ( const char FAR *     pszServer,
                   short                sLevel,
                   char FAR *           pbBuffer,
                   unsigned short       cbBuffer,
                   unsigned short FAR * pcEntriesRead,
                   unsigned short FAR * pcTotalAvail );


extern API_FUNCTION
  NetSessionGetInfo ( const char FAR *     pszServer,
                      const char FAR *     pszClientName,
                      short                sLevel,
                      char FAR *           pbBuffer,
                      unsigned short       cbBuffer,
                      unsigned short FAR * pcbTotalAvail );


/****************************************************************
 *								*
 *		Data structure templates - SESSION		*
 *								*
 ****************************************************************/


struct session_info_0 {
    char FAR *		sesi0_cname;
};  /* session_info_0 */

struct session_info_1 {
    char FAR *		sesi1_cname;
    char FAR *		sesi1_username;
    unsigned short	sesi1_num_conns;
    unsigned short	sesi1_num_opens;
    unsigned short	sesi1_num_users;
    unsigned long	sesi1_time;
    unsigned long	sesi1_idle_time;
    unsigned long	sesi1_user_flags;
};  /* session_info_1 */

struct session_info_2 {
    char FAR *		 sesi2_cname;
    char FAR *		 sesi2_username;
    unsigned short	 sesi2_num_conns;
    unsigned short	 sesi2_num_opens;
    unsigned short	 sesi2_num_users;
    unsigned long	 sesi2_time;
    unsigned long	 sesi2_idle_time;
    unsigned long	 sesi2_user_flags;
    char FAR *		 sesi2_cltype_name;
};  /* session_info_2 */

struct session_info_10 {
        char FAR *     sesi10_cname;
        char FAR *     sesi10_username;
        unsigned long  sesi10_time;
        unsigned long  sesi10_idle_time;
};  /* session_info_10 */


struct session_info_50 {
	char FAR * sesi50_cname;            //remote computer name (connection id in Netware)
	char FAR * sesi50_username;
	unsigned long sesi50_key;           // used to delete session (not used in Netware)
	unsigned short sesi50_num_conns;
	unsigned short sesi50_num_opens;    //not available in Netware
	unsigned long sesi50_time;
	unsigned long sesi50_idle_time;		//not available in Netware
	unsigned char sesi50_protocol;
	unsigned char pad1;
};	/* session_info_50 */


/****************************************************************
 *								*
 *	  	Special values and constants - SESSION		*
 *								*
 ****************************************************************/

/*
 *	Bits defined in sesi1_user_flags.
 */

#define SESS_GUEST		1	/* session is logged on as a guest */
#define SESS_NOENCRYPTION	2	/* session is not using encryption */


#define SESI1_NUM_ELEMENTS	8
#define SESI2_NUM_ELEMENTS	9



/****************************************************************
 *								*
 *	  	Connection Class			        *
 *								*
 ****************************************************************/

/****************************************************************
 *                                                              *
 *              Function prototypes - CONNECTION                *
 *                                                              *
 *  Peer Server Support
 * 		NetConnectionEnum -
 *               sLevel 50 on VSERVER and NWSERVER              *
 *               On NWSERVER, this API doesnt provide more      *
 *               information than NetSessionEnum
 ****************************************************************/

/***	NetConnectionEnum (Admin only)
 *
 *	API_FUNCTION NetConnectionEnum( servername, 
 *					  qualifier, 
 *					  level, 
 *					  buf, 
 *					  buflen, 
 *					  totalavail )
 *
 *	ENTRY
 *
 *	servername;     asciz remote srv name, NULL if local
 *	qualifier;      netname or client computer name.
 *                  computer name should be prefaced by '\\'.
 *	level;	    	level of info requested
 *	buf;            for returned entry
 *	buflen;         size of buffer 
 *	totalavail;     total size needed for buffer
 *
 *	EXIT
 *
 *	0 = success
 *	NERR_NetNotStarted
 *	NERR_ServerNotStarted
 *	ERROR_INVALID_LEVEL
 *	NERR_RemoteErr
 *	NERR_RemoteOnly		(DOS)
 *	ERROR_MORE_DATA
 * 	ERROR_ACCESS_DENIED
 *	NERR_ClientNameNotFound
 *	NERR_NetNameNotFound
 *
 *	Buffer contents on response (format for a single entry):
 *   	    Level 50 contains a "struct connection_info_50".
 ***/
extern API_FUNCTION
  NetConnectionEnum ( const char FAR *     pszServer,
                      const char FAR *     pszQualifier,   /* upper case */
                      short                sLevel,
                      char FAR *           pbBuffer,
                      unsigned short       cbBuffer,
                      unsigned short FAR * pcEntriesRead,
                      unsigned short FAR * pcTotalAvail );


/****************************************************************
 *								*
 *	  	Data structure templates - CONNECTION		*
 *								*
 ****************************************************************/

struct connection_info_0 {
    unsigned short	coni0_id;
};  /* connection_info_0 */

struct connection_info_1 {
    unsigned short	coni1_id;
    unsigned short	coni1_type;
    unsigned short	coni1_num_opens;
    unsigned short	coni1_num_users;
    unsigned long	coni1_time;
    char FAR *		coni1_username;
    char FAR *		coni1_netname;
};  /* connection_info_1 */

struct connection_info_50 {
	unsigned short coni50_type;         // share type
	unsigned short coni50_num_opens;	//not used in Netware
	unsigned long coni50_time;
	char FAR * coni50_netname;          // share name          
	char FAR * coni50_username;         // user connected to share
}; /* connection_info_50 */


/****************************************************************
 *								*
 *	  	File Class			                *
 *								*
 ****************************************************************/


/****************************************************************
 *                                                              *
 *              Function prototypes - FILE                      *
 *                                                              *
 *  Peer Server Support
 * 		NetFileEnum - sLevel 50 on VSERVER and NWSERVER        *
 *      NetFileClose2 - VSERVER only
 ****************************************************************/

/***	NetFileClose2
 *
 *	int FAR PASCAL	NetFileClose2( servername, fileid )
 *
 *	ENTRY
 *
 *	servername;     asciz remote srv name, NULL if local
 *	fileid;     	file id supplied by NetFileEnum
 *
 *	EXIT
 *
 *	0 = success
 *	NERR_NetNotStarted
 *	NERR_ServerNotStarted
 *	NERR_RemoteErr
 * 	ERROR_ACCESS_DENIED
 *	NERR_FileIdNotFound
 *
 ***/
extern API_FUNCTION
  NetFileClose2 ( const char FAR * pszServer,
                  unsigned long    ulFileId );

/***	NetFileEnum (Admin Only)
 *
 *	int FAR PASCAL NetFileEnum( servername,
 *				    level, 
 *				    buf, 
 *				    buflen, 
 *				    entriesread, 
 *				    totalentries )
 *
 *	ENTRY
 *
 *	servername;     asciz remote srv name, NULL if local
 *	basepath;	path qualifier for file matching
 *              (not used for Win95 NWSERVER)
 *	level;          level of detail requested; (50 for Win95 peer servers)
 *	buf;            for returned entries
 *	buflen;         size of buffer on call; 
 *	entriesread;    # of entries supplied on return
 *	totalentries;   total # of entries available
 *
 * 	EXIT
 *
 *	0 = success
 *	NERR_RemoteOnly
 *	NERR_NetNotStarted
 *	NERR_ServerNotStarted
 *	ERROR_INVALID_LEVEL
 *	NERR_RemoteErr
 *	ERROR_MORE_DATA
 * 	ERROR_ACCESS_DENIED
 *
 *	
 *	Buffer contents on response (format for a single entry):
 *   	    Level 0 contains a "struct file_info_0".
 *   	    Level 50 contains a "struct file_info_50".
 *
 ***/

extern API_FUNCTION
  NetFileEnum ( const char FAR *     pszServer,
                const char FAR *     pszBasePath,
                short                sLevel,
                char FAR *           pbBuffer,
                unsigned short       cbBuffer,
                unsigned short FAR * pcEntriesRead,
                unsigned short FAR * pcTotalAvail );


/****************************************************************
 *								*
 *	  	Data structure templates - FILE			*
 *								*
 ****************************************************************/

struct file_info_0 {
    unsigned short	fi0_id;
};  /* file_info_0 */

struct file_info_1 {
    unsigned short	fi1_id;
    unsigned short	fi1_permissions;
    unsigned short	fi1_num_locks;
    char FAR *		fi1_pathname;
    char FAR *		fi1_username;
};  /* file_info_1 */

struct file_info_2 {
    unsigned long	fi2_id;
};  /* file_info_2 */

struct file_info_3 {
    unsigned long	fi3_id;
    unsigned short	fi3_permissions;
    unsigned short	fi3_num_locks;
    char FAR *		fi3_pathname;
    char FAR *		fi3_username;
};  /* file_info_3 */

struct file_info_50 {
	unsigned long fi50_id;              // not used on NWSERVER
	unsigned short fi50_permissions;    // not available on NWSERVER
	unsigned short fi50_num_locks;      // not available on NWSERVER
	char FAR * fi50_pathname;
	char FAR * fi50_username;
	char FAR * fi50_sharename;
}; /* file_info_50 */

struct res_file_enum_2 {
    unsigned short	res_pad;	 /* not used now */
    unsigned short      res_fs;          /* server type */
    unsigned long	res_pro;	  /* progressive */
};  /* res_file_enum_2 */

/****************************************************************
 *								*
 *		Special values and constants - FILE		*
 *								*
 ****************************************************************/

					/* bit values for permissions */
#define	PERM_FILE_READ		0x1	/* user has read access */
#define	PERM_FILE_WRITE		0x2	/* user has write access */
#define	PERM_FILE_CREATE	0x4	/* user has create access */


typedef struct res_file_enum_2 FRK;

/*NOINC*/
#define FRK_INIT( f )	\
	{		\
		(f).res_pad = 0L;	\
		(f).res_fs = 0;	\
		(f).res_pro = 0;	\
	}

/*INC*/


/****************************************************************
 *								*
 *	  	Server Class			                *
 *								*
 ****************************************************************/


/****************************************************************
 *                                                              *
 *              Function prototypes - SERVER                    *
 *                                                              *
 * Peer Server Support
 * 	NetServerGetInfo - sLevel 1,50 on NWSERVER, VSERVER
 ****************************************************************/

/* 6.2  NetServerGetInfo 
 *
 * Purpose: Read the current configuration parameters of the server.
 *
 * int FAR PASCAL
 * NetServerGetInfo( servername, level, buf, buflen, totalavail )
 * char FAR *          servername;   asciz remote server name or NULL if local
 * short               level;          level of information to be returned
 * char FAR *          buf;            for returned data
 * unsigned short      buflen;         size of buffer
 * unsigned short FAR *totalavail;     total size needed for buffer
 *
 * Buffer contents on response (format for a single entry):
 *     Level 1 contains a "struct server_info_1".
 *     Level 50 contains a "struct server_info_50".
 *
 * If the buflen is not large enough for all of the information, the call
 * will return as much as will fit in the buffer.
 *
 * Returns 0 if successful. Error return information:
 *
 *     - ERROR_INVALID_LEVEL       - Level parameter specified is invalid
 *     - ERROR_INVALID_PARAMETER   - An invalid input parameter was detected.
 *     - NERR_NetNotStarted        - Network not installed on local machine
 *     - NERR_ServerNotStarted     - Server is not started
 *     - NERR_BufTooSmall          - The buffer supplied was to small to
 *                                   return the fixed length structure
 *				     requested.
 *     - NERR_MoreData             - The buffer supplied was too small to
 *				     return all the information available
 *				     for this server.
 *
 */


extern API_FUNCTION
  NetServerGetInfo ( const char FAR *     pszServer,
                     short                sLevel,
                     char FAR *           pbBuffer,
                     unsigned short       cbBuffer,
                     unsigned short FAR * pcbTotalAvail );


/****************************************************************
 *								*
 *	  	Data structure templates - SERVER		*
 *								*
 ****************************************************************/

struct server_info_0 {
    char	    sv0_name[CNLEN + 1]; 	/* Server name		    */
};	 /* server_info_0 */


struct server_info_1 {
    char	    sv1_name[CNLEN + 1];
    unsigned char   sv1_version_major;		/* Major version # of net   */
    unsigned char   sv1_version_minor;		/* Minor version # of net   */
    unsigned long   sv1_type;	     		/* Server type 		    */
    char FAR *	    sv1_comment; 		/* Exported server comment  */
};	 /* server_info_1 */


/* NOTE struct prefix must equal server_info_1 like below! */

struct server_info_50 {
    char	    sv50_name[CNLEN + 1];
    unsigned char   sv50_version_major;		/* Major version # of net   */
    unsigned char   sv50_version_minor;		/* Minor version # of net   */
    unsigned long   sv50_type;	     		/* Server type 		    */
    char FAR *	    sv50_comment; 		/* Exported server comment  */
    unsigned short  sv50_security;    		/* SV_SECURITY_* (see below) */
    unsigned short  sv50_auditing;    /* 0 = no auditing; nonzero = auditing */
    char FAR *      sv50_container;		/* Security server/domain    */
    char FAR *	    sv50_ab_server;		/* Address book server       */
    char FAR *	    sv50_ab_dll;		/* Address book provider DLL */
};	/* server_info_50 */


struct server_info_2 {
    char            sv2_name[CNLEN + 1];
    unsigned char   sv2_version_major;
    unsigned char   sv2_version_minor;
    unsigned long   sv2_type;	
    char FAR *	    sv2_comment;		
    unsigned long   sv2_ulist_mtime; /* User list, last modification time    */
    unsigned long   sv2_glist_mtime; /* Group list, last modification time   */
    unsigned long   sv2_alist_mtime; /* Access list, last modification time  */
    unsigned short  sv2_users;       /* max number of users allowed          */
    unsigned short  sv2_disc;	    /* auto-disconnect timeout(in minutes)  */
    char FAR *	    sv2_alerts;	    /* alert names (semicolon separated)    */
    unsigned short  sv2_security;    /* SV_USERSECURITY or SV_SHARESECURITY  */
    unsigned short  sv2_auditing;    /* 0 = no auditing; nonzero = auditing  */

    unsigned short  sv2_numadmin;    /* max number of administrators allowed */
    unsigned short  sv2_lanmask;     /* bit mask representing the srv'd nets */
    unsigned short  sv2_hidden;      /* 0 = visible; nonzero = hidden        */
    unsigned short  sv2_announce;    /* visible server announce rate (sec)   */
    unsigned short  sv2_anndelta;    /* announce randomize interval (sec)    */
                                    /* name of guest account                */
    char            sv2_guestacct[LM20_UNLEN + 1];
    unsigned char   sv2_pad1;	    /* Word alignment pad byte		    */
    char FAR *      sv2_userpath;    /* ASCIIZ path to user directories      */
    unsigned short  sv2_chdevs;      /* max # shared character devices       */
    unsigned short  sv2_chdevq;      /* max # character device queues        */
    unsigned short  sv2_chdevjobs;   /* max # character device jobs          */
    unsigned short  sv2_connections; /* max # of connections		    */
    unsigned short  sv2_shares;	    /* max # of shares			    */
    unsigned short  sv2_openfiles;   /* max # of open files		    */
    unsigned short  sv2_sessopens;   /* max # of open files per session	    */
    unsigned short  sv2_sessvcs;     /* max # of virtual circuits per client */
    unsigned short  sv2_sessreqs;    /* max # of simul. reqs. from a client  */
    unsigned short  sv2_opensearch;  /* max # of open searches		    */
    unsigned short  sv2_activelocks; /* max # of active file locks           */
    unsigned short  sv2_numreqbuf;   /* number of server (standard) buffers  */
    unsigned short  sv2_sizreqbuf;   /* size of svr (standard) bufs (bytes)  */
    unsigned short  sv2_numbigbuf;   /* number of big (64K) buffers          */
    unsigned short  sv2_numfiletasks;/* number of file worker processes      */
    unsigned short  sv2_alertsched;  /* alert counting interval (minutes)    */
    unsigned short  sv2_erroralert;  /* error log alerting threshold         */
    unsigned short  sv2_logonalert;  /* logon violation alerting threshold   */
    unsigned short  sv2_accessalert; /* access violation alerting threshold  */
    unsigned short  sv2_diskalert;   /* low disk space alert threshold (KB)  */
    unsigned short  sv2_netioalert;  /* net I/O error ratio alert threshold  */
                                    /*  (tenths of a percent)               */
    unsigned short  sv2_maxauditsz;  /* Maximum audit file size (KB)        */
    char FAR *	    sv2_srvheuristics; /* performance related server switches*/
};	/* server_info_2 */


struct server_info_3 {
    char	    sv3_name[CNLEN + 1];
    unsigned char   sv3_version_major;
    unsigned char   sv3_version_minor;
    unsigned long   sv3_type;
    char FAR *	    sv3_comment;
    unsigned long   sv3_ulist_mtime; /* User list, last modification time    */
    unsigned long   sv3_glist_mtime; /* Group list, last modification time   */
    unsigned long   sv3_alist_mtime; /* Access list, last modification time  */
    unsigned short  sv3_users;	     /* max number of users allowed	     */
    unsigned short  sv3_disc;	    /* auto-disconnect timeout(in minutes)  */
    char FAR *	    sv3_alerts;     /* alert names (semicolon separated)    */
    unsigned short  sv3_security;    /* SV_USERSECURITY or SV_SHARESECURITY  */
    unsigned short  sv3_auditing;    /* 0 = no auditing; nonzero = auditing  */

    unsigned short  sv3_numadmin;    /* max number of administrators allowed */
    unsigned short  sv3_lanmask;     /* bit mask representing the srv'd nets */
    unsigned short  sv3_hidden;      /* 0 = visible; nonzero = hidden	     */
    unsigned short  sv3_announce;    /* visible server announce rate (sec)   */
    unsigned short  sv3_anndelta;    /* announce randomize interval (sec)    */
				    /* name of guest account		    */
    char	    sv3_guestacct[LM20_UNLEN + 1];
    unsigned char   sv3_pad1;	    /* Word alignment pad byte		    */
    char FAR *	    sv3_userpath;    /* ASCIIZ path to user directories	     */
    unsigned short  sv3_chdevs;      /* max # shared character devices	     */
    unsigned short  sv3_chdevq;      /* max # character device queues	     */
    unsigned short  sv3_chdevjobs;   /* max # character device jobs	     */
    unsigned short  sv3_connections; /* max # of connections		    */
    unsigned short  sv3_shares;     /* max # of shares			    */
    unsigned short  sv3_openfiles;   /* max # of open files		    */
    unsigned short  sv3_sessopens;   /* max # of open files per session     */
    unsigned short  sv3_sessvcs;     /* max # of virtual circuits per client */
    unsigned short  sv3_sessreqs;    /* max # of simul. reqs. from a client  */
    unsigned short  sv3_opensearch;  /* max # of open searches		    */
    unsigned short  sv3_activelocks; /* max # of active file locks	     */
    unsigned short  sv3_numreqbuf;   /* number of server (standard) buffers  */
    unsigned short  sv3_sizreqbuf;   /* size of svr (standard) bufs (bytes)  */
    unsigned short  sv3_numbigbuf;   /* number of big (64K) buffers	     */
    unsigned short  sv3_numfiletasks;/* number of file worker processes      */
    unsigned short  sv3_alertsched;  /* alert counting interval (minutes)    */
    unsigned short  sv3_erroralert;  /* error log alerting threshold	     */
    unsigned short  sv3_logonalert;  /* logon violation alerting threshold   */
    unsigned short  sv3_accessalert; /* access violation alerting threshold  */
    unsigned short  sv3_diskalert;   /* low disk space alert threshold (KB)  */
    unsigned short  sv3_netioalert;  /* net I/O error ratio alert threshold  */
                                    /*  (tenths of a percent)               */
    unsigned short  sv3_maxauditsz;  /* Maximum audit file size (KB)	     */
    char FAR *	    sv3_srvheuristics; /* performance related server switches*/
    unsigned long   sv3_auditedevents; /* Audit event control mask	     */
    unsigned short  sv3_autoprofile; /* (0,1,2,3) = (NONE,LOAD,SAVE,or BOTH) */
    char FAR *	    sv3_autopath;    /* file pathname (where to load & save) */
};	/* server_info_3 */



/****************************************************************
 *								*
 *	  	Special values and constants - SERVER		*
 *								*
 ****************************************************************/

/*
 *	Mask to be applied to svX_version_major in order to obtain
 *	the major version number.
 */

#define MAJOR_VERSION_MASK	0x0F

/*
 *	Bit-mapped values for svX_type fields. X = 1, 2 or 3.
 */

#define SV_TYPE_WORKSTATION	0x00000001
#define SV_TYPE_SERVER		0x00000002
#define SV_TYPE_SQLSERVER	0x00000004
#define SV_TYPE_DOMAIN_CTRL	0x00000008
#define SV_TYPE_DOMAIN_BAKCTRL	0x00000010
#define SV_TYPE_TIME_SOURCE	0x00000020
#define SV_TYPE_AFP		0x00000040
#define SV_TYPE_NOVELL		0x00000080      /* This flag is also set by Win95 NWSERVER */
#define SV_TYPE_DOMAIN_MEMBER	0x00000100
#define SV_TYPE_PRINTQ_SERVER	0x00000200
#define SV_TYPE_DIALIN_SERVER	0x00000400
#define SV_TYPE_ALL		0xFFFFFFFF   /* handy for NetServerEnum2 */

/*
 *	Special value for svX_disc that specifies infinite disconnect
 *	time. X = 2 or 3.
 */

#define SV_NODISC		0xFFFF	/* No autodisconnect timeout enforced */

/*
 *	Values of svX_security field. X = 2 or 3.
 */

#define SV_USERSECURITY		1
#define SV_SHARESECURITY	0

/*
 *	Values of svX_security field. X = 50.
 *  For Win95 NWSERVER, the only possible returned value is SV_SECURITY_NETWARE.
 */

#define SV_SECURITY_SHARE	0	/* Share-level */
#define SV_SECURITY_WINNT	1	/* User-level - Windows NT workst'n */
#define SV_SECURITY_WINNTAS	2	/* User-level - Windows NT domain */
#define SV_SECURITY_NETWARE	3	/* User-level - NetWare 3.x bindery */

/*
 *	Values of svX_hidden field. X = 2 or 3.
 */

#define SV_HIDDEN		1
#define SV_VISIBLE		0

#define SVI1_NUM_ELEMENTS	5
#define SVI2_NUM_ELEMENTS	44
#define SVI3_NUM_ELEMENTS	45


/*
 *      Masks describing AUTOPROFILE parameters
 */

#define SW_AUTOPROF_LOAD_MASK	0x1
#define SW_AUTOPROF_SAVE_MASK	0x2



/****************************************************************
 *                                                              *
 *                 Security Class                               *
 *                                                              *
 ****************************************************************/


/****************************************************************
 *                                                              *
 *                  Function prototypes - SECURITY              *
 *                                                              *
 ****************************************************************/

extern API_FUNCTION
  NetSecurityGetInfo ( const char FAR *     pszServer,
                       short                sLevel,
                       char FAR *           pbBuffer,
                       unsigned short       cbBuffer,
                       unsigned short FAR * pcbTotalAvail );


/****************************************************************
 *								*
 *	  	Data structure templates - SECURITY		*
 *								*
 ****************************************************************/

struct security_info_1 {
    unsigned long   sec1_security;    	/* SEC_SECURITY_* (see below) */
    char FAR *      sec1_container;	/* Security server/domain     */
    char FAR *	    sec1_ab_server;	/* Address book server        */
    char FAR *	    sec1_ab_dll;	/* Address book provider DLL  */
};	/* security_info_1 */


/****************************************************************
 *								*
 *	  	Special values and constants - SECURITY		*
 *								*
 ****************************************************************/

/*
/*
 *	Values of secX_security field. X = 1.
 */

#define SEC_SECURITY_SHARE	SV_SECURITY_SHARE
#define SEC_SECURITY_WINNT	SV_SECURITY_WINNT
#define SEC_SECURITY_WINNTAS	SV_SECURITY_WINNTAS
#define SEC_SECURITY_NETWARE	SV_SECURITY_NETWARE



/*NOINC*/
#ifdef __cplusplus
}
#endif	/* __cplusplus */

#ifndef RC_INVOKED
#pragma pack()          /* Revert to default packing */
#endif

#endif /* SVRAPI_INCLUDED */
/*INC*/
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\hnw\wizard\comctlwrap.cpp ===
#include "stdafx.h"
#include <cstrinout.h>



//
// Globals
//

DWORD g_dwComCtlIEVersion;

//
// 
//

DWORD GetComCtlIEVersion()
{
    DWORD dwVersion = 0;

    HMODULE hComCtl = LoadLibrary(L"comctl32.dll");

    if (hComCtl)
    {
        HRESULT (*DllGetVersion)(DLLVERSIONINFO* pdvi) = (HRESULT (*)(DLLVERSIONINFO*))GetProcAddress(hComCtl, "DllGetVersion");

        if (DllGetVersion)
        {
            DLLVERSIONINFO dvi;

            dvi.cbSize = sizeof(dvi);
            DllGetVersion(&dvi);

            dwVersion = dvi.dwMajorVersion;
        }
        else
        {
            BOOL (*InitCommonControlsEx)(LPINITCOMMONCONTROLSEX) = (BOOL (*)(LPINITCOMMONCONTROLSEX))GetProcAddress(hComCtl, "InitCommonControlsEx");

            dwVersion = InitCommonControlsEx ? 3 : 2;
        }

        FreeLibrary(hComCtl);
    }

    return dwVersion;
}

LRESULT ListView_InsertColumnWrap(HWND hwnd, int nCol, LVCOLUMN* pCol)
{
    LRESULT lRet;

    if (g_dwComCtlIEVersion >= 3)
    {
        lRet = ListView_InsertColumn(hwnd, nCol, pCol);
    }
    else
    {
        ASSERT(!(pCol->mask & (LVCF_IMAGE | LVCF_ORDER | LVCF_TEXT)));

        lRet = SendMessage(hwnd, LVM_INSERTCOLUMNA, nCol, (LPARAM)pCol);
    }

    return lRet;
}

void ListView_SetExtendedListViewStyleExWrap(HWND hwnd, DWORD dwMask, DWORD dwStyle)
{
    if (g_dwComCtlIEVersion >= 3)
    {
        ListView_SetExtendedListViewStyleEx(hwnd, dwMask, dwStyle);
    }
    else
    {

    }
}

int ListView_InsertItemWrap(HWND hwnd, const LVITEM* pItem)
{
    int iRet;

    if (g_dwComCtlIEVersion >= 3)
    {
         iRet = ListView_InsertItem(hwnd, pItem);
    }
    else
    {
        if (pItem->mask & LVIF_TEXT)
        {
            LVITEMA ItemA = *(LVITEMA*)pItem;
            
            CStrIn strText(pItem->pszText);
            ItemA.pszText = strText;

            iRet = SendMessage(hwnd, LVM_INSERTITEMA, 0, (LPARAM)&ItemA);
        }
        else
        {
            iRet = SendMessage(hwnd, LVM_INSERTITEMA, 0, (LPARAM)pItem);
        }
    }

    return iRet;
}

void ListView_SetItemTextWrap(HWND hwnd, int iItem, int iSubItem, LPWSTR pszText)
{
    if (g_dwComCtlIEVersion >= 3)
    {
        ListView_SetItemText(hwnd, iItem, iSubItem, pszText);
    }
    else
    {
        CStrIn strText(pszText);

        LV_ITEMA ItemA;
        ItemA.iSubItem = iSubItem;
        ItemA.pszText  = strText;

        SendMessage(hwnd, LVM_SETITEMTEXTA, iItem, (LPARAM)&ItemA);
    }
}

BOOL ListView_SetColumnWidthWrap(HWND hwnd, int iCol, int cx)
{
    BOOL fRet;

    if (g_dwComCtlIEVersion >= 2) 
    {
        fRet = ListView_SetColumnWidth(hwnd, iCol, cx);
    }
    else
    {
        if (LVSCW_AUTOSIZE == cx || LVSCW_AUTOSIZE_USEHEADER == cx)
        {
            // HACK set to 150 for now.
            fRet = ListView_SetColumnWidth(hwnd, iCol, 150);
        }
        else
        {
            fRet = ListView_SetColumnWidth(hwnd, iCol, cx);
        }
    }

    return fRet;
}

BOOL ListView_GetItemWrap(HWND hwnd, LVITEM* pItem)
{
    BOOL fRet;

    if (g_dwComCtlIEVersion >= 3)
    {
        fRet = ListView_GetItem(hwnd, pItem);
    }
    else
    {
        ASSERT (!(pItem->mask & LVIF_TEXT));

        fRet = SendMessage(hwnd, LVM_GETITEMA, 0, (LPARAM)pItem);
    }

    return fRet;
}

BOOL ListView_GetCheckStateWrap(HWND hwnd, UINT iItem)
{
    BOOL fRet;

    if (g_dwComCtlIEVersion >= 3)
    {
        fRet = ListView_GetCheckState(hwnd, iItem);
    }
    else
    {
        fRet = FALSE;
    }

    return fRet;
}

void ListView_SetCheckStateWrap(HWND hwnd, UINT iItem, BOOL fCheck)
{
    if (g_dwComCtlIEVersion >= 3)
    {
        ListView_SetCheckState(hwnd, iItem, fCheck);
    }
    else
    {
    }
}

void ListView_GetItemTextWrap(HWND hwnd, int iItem, int iSubItem, WCHAR* pszText, int cchText)
{
    if (g_dwComCtlIEVersion >= 3)
    {
        ListView_GetItemText(hwnd, iItem, iSubItem, pszText, cchText)
    }
    else
    {
        CStrOut strText(pszText, cchText);

        LVITEMA ItemA;
        ItemA.iSubItem   = iSubItem;
        ItemA.pszText    = strText;
        ItemA.cchTextMax = strText.BufSize();

        SendMessage(hwnd, LVM_GETITEMTEXTA, iItem, (LPARAM)&ItemA);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\hnw\wizard\comctlwrap.h ===
#pragma once

extern DWORD g_dwComCtlIEVersion;

DWORD GetComCtlIEVersion(void);


//
// Wrapped comctrl functions.
//

#undef  ListView_InsertColumn
#define ListView_InsertColumn ListView_InsertColumnWrap

LRESULT ListView_InsertColumnWrap(HWND hwnd, int nCol, LVCOLUMN* pCol);


#undef  ListView_SetExtendedListViewStyleEx
#define ListView_SetExtendedListViewStyleEx ListView_SetExtendedListViewStyleExWrap

void ListView_SetExtendedListViewStyleExWrap(HWND hwnd, DWORD dwMask, DWORD dwStyle);


#undef  ListView_InsertItem
#define ListView_InsertItem ListView_InsertItemWrap

int ListView_InsertItemWrap(HWND hwnd, const LVITEM* pItem);


#undef  ListView_SetItemText
#define ListView_SetItemText ListView_SetItemTextWrap

void ListView_SetItemTextWrap(HWND hwnd, int iItem, int iSubItem, LPWSTR pszText);


#undef  ListView_SetColumnWidth
#define ListView_SetColumnWidth ListView_SetColumnWidthWrap

BOOL ListView_SetColumnWidthWrap(HWND hwnd, int iCol, int cx);


#undef  ListView_GetItem
#define ListView_GetItem ListView_GetItemWrap

BOOL ListView_GetItemWrap(HWND hwnd, LVITEM* pItem);


#undef  ListView_GetCheckState
#define ListView_GetCheckState ListView_GetCheckStateWrap

BOOL ListView_GetCheckStateWrap(HWND hwnd, UINT iItem);


#undef  ListView_SetCheckState
#define ListView_SetCheckState ListView_SetCheckStateWrap

void ListView_SetCheckStateWrap(HWND hwnd, UINT iItem, BOOL fCheck);


#undef  ListView_GetItemText
#define ListView_GetItemText ListView_GetItemTextWrap

void ListView_GetItemTextWrap(HWND hwnd, int iItem, int iSubItem, WCHAR* pszText, int cchText);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\hnw\wizard\crawler.h ===
#ifndef _CRAWLER_H_
#define _CRAWLER_H_

#define CB_WNET_BUFFER 8*1024

typedef enum tagCrawlerFlags
{
	NC_FINISHED         = 0x0001,
    NC_INIT_WORKGROUPS  = 0x0002,
} NCFLAGS;

class CNetCrawler
{
public:
    CNetCrawler(void) : _dwStatus(0), _hdpaWorkGroups(NULL), _cRef(1), _cItems(0) {}
	~CNetCrawler(void);
	void Init(DWORD dwFlags, int nItems);
    HRESULT GetWorkGroupName(LPTSTR pszWorkGroupName, int cb, BOOL fBlocking);
    inline void AddRef(void)
    {
        InterlockedIncrement(&_cRef);
    }
    inline void Release(void)
    {
        ASSERT( 0 != _cRef );
        if ( 0 == InterlockedDecrement(&_cRef) )
        {
            delete this;
        }
    }

private:
    BOOL _dwStatus;
    HDPA _hdpaWorkGroups;
    int _iMaxItems;
    int _cItems;
    LONG _cRef;

	void _EnumNetResources(LPNETRESOURCE pnr);
 	static DWORD WINAPI _EnumWorkGroups(LPVOID pv);
};

#endif  // _CRAWLER_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\hnw\wizard\cwnd.h ===
//
// CWnd.h
//

#pragma once

class CWnd
{
public:
    CWnd();

    void Release();
    BOOL Attach(HWND hwnd);

    static CWnd* FromHandle(HWND hwnd);

public:
    HWND    m_hWnd;

protected:
    // This is what subclasses implement
    virtual LRESULT WindowProc(UINT message, WPARAM wParam, LPARAM lParam) PURE;

    // Subclasses call CWnd::Default to forward the message to the original wndproc
    LRESULT Default(UINT message, WPARAM wParam, LPARAM lParam);

    virtual ~CWnd();

private:
    static LRESULT CALLBACK StaticWindowProc(HWND hwnd, UINT message, WPARAM wParam, LPARAM lParam);
    void OnNCDESTROY();

private:
    WNDPROC m_pfnPrevWindowProc;
    UINT    m_cRef;
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\hnw\wizard\cwnd.cpp ===
//
// CWnd.cpp
//
//        A super-simple window wrapper implementation.
//
// History:
//
//        10/07/1999  KenSh     Created
//

#include "stdafx.h"
#include "CWnd.h"


CWnd::CWnd()
{
    m_hWnd = NULL;
    m_pfnPrevWindowProc = NULL;
    m_cRef = 1;
}

CWnd::~CWnd()
{
}

BOOL CWnd::Attach(HWND hwnd)
{
    m_hWnd = hwnd;

    SetPropA(hwnd, "CWnd*", (HANDLE)this);

    m_pfnPrevWindowProc = SubclassWindow(hwnd, StaticWindowProc);

    m_cRef++;

    return TRUE;
}

void CWnd::Release()
{
    m_cRef--;

    if (0==m_cRef)
        delete this;
}

// Can NOT cache the return value from this function
CWnd* CWnd::FromHandle(HWND hwnd)
{
    return (CWnd*)GetPropA(hwnd, "CWnd*");
}

LRESULT CWnd::Default(UINT message, WPARAM wParam, LPARAM lParam)
{
    return CallWindowProc(m_pfnPrevWindowProc, m_hWnd, message, wParam, lParam );
}

LRESULT CALLBACK CWnd::StaticWindowProc(HWND hwnd, UINT message, WPARAM wParam, LPARAM lParam)
{
    LRESULT lResult;

    CWnd* pWnd = FromHandle(hwnd);
    if (pWnd)
    {
        lResult = pWnd->WindowProc(message, wParam, lParam);

        if (message == WM_NCDESTROY)
        {
            RemovePropA(hwnd, "CWnd*");
            pWnd->OnNCDESTROY();
        }
    }
    else
    {
        lResult = DefWindowProc(hwnd, message, wParam, lParam);
    }

    return lResult;
}

void CWnd::OnNCDESTROY()
{
    SubclassWindow(m_hWnd, m_pfnPrevWindowProc);

    m_hWnd = NULL;
    m_pfnPrevWindowProc = NULL;
    Release();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\hnw\wizard\config.h ===
#ifndef __CONFIG_H__
#define __CONFIG_H__

#include "tchar.h"
#include "stdio.h"

#define        MAX_KEYSIZE        1024

#define        MAX_GENERAL        (128)
#define        MAX_PARAMS        (128)
#define        MAX_BLOCKOUT    (128)
#define        MAX_DHCP        (128)
#define        MAX_SERVERS        (1024)

#define        MAX_IPADDRESS    32
#define        MAX_STRLEN        256


// return flags from SaveConfig
#define SAVE_SUCCEDED        0x00
#define    BINDINGS_NEEDED        0x01
#define ICSENABLETOGGLED    0x02

/////////////////////////////////////////////////////////////////////////////
// CConfig window

class CConfig 
{
// Construction
public:
    CConfig();

// Attributes
public:

// Operations
public:
    

// Implementation
public:

    TCHAR m_ExternalAdapterDesc[MAX_STRLEN];
    TCHAR m_InternalAdapterDesc[MAX_STRLEN];
    TCHAR m_ExternalAdapterReg[MAX_STRLEN];
    TCHAR m_InternalAdapterReg[MAX_STRLEN];
    TCHAR m_DialupEntry[MAX_STRLEN];
    TCHAR m_HangupTimer[MAX_STRLEN];

    BOOL m_bWizardRun;        // TRUE if Wizard changed settings, FALSE if config UI did

    BOOL m_EnableICS;
    BOOL m_EnableDialOnDemand;
    BOOL m_EnableDHCP;
    BOOL m_ShowTrayIcon;

    // returns BINDINGS_NEEDED if rebindings are needed, otherwise SAVE_SUCCEDED.
    int SaveConfig();

    // writes the run code to the registry.  bWizardRun should be TRUE if the wizard was run, or FALSE if the config
    // dlg was run
    void WriteWizardCode(BOOL bWizardRun);

    void InitWizardResult();
    void WizardCancelled();
    void WizardFailed();


    void LoadConfig();

    // old values to determing if rebind is needed at save
    TCHAR m_OldExternalAdapterReg[MAX_STRLEN];
    TCHAR m_OldInternalAdapterReg[MAX_STRLEN];
    TCHAR m_OldDialupEntry[MAX_STRLEN];

    BOOL m_bOldEnableICS;
    
    int m_nGeneral;
    TCHAR* m_General[MAX_GENERAL];

    int m_nParams;
    TCHAR* m_Params[MAX_PARAMS];

    int m_nBlockOut;
    TCHAR* m_BlockOut[MAX_BLOCKOUT];

    int m_nDhcp;
    TCHAR* m_Dhcp[MAX_DHCP];

    int m_nServers;
    TCHAR* m_Servers[MAX_SERVERS];

    virtual ~CConfig();

    // Generated message map functions
protected:
};

/////////////////////////////////////////////////////////////////////////////


#endif    // __CONFIG_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\hnw\wizard\debug.c ===
#include "stdafx.h"

#define SZ_DEBUGINI         "hnetwiz.ini"
#define SZ_DEBUGSECTION     "HNETWIZ"
#define SZ_MODULE           "HNETWIZ"
#define DECLARE_DEBUG
#include <debug.h>
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\hnw\wizard\config.cpp ===
// Config.cpp : implementation file
//

#include "stdafx.h"
#include "Config.h"
//#include "lstentry.h"
#include "Registry.h"

//
// Settings for autodial
//
#define RAS_AUTODIAL_OPT_NONE           0x00000000  // No options
#define RAS_AUTODIAL_OPT_NEVER          0x00000001  // Never Autodial
#define RAS_AUTODIAL_OPT_ALWAYS         0x00000002  // Autodial regardless
#define RAS_AUTODIAL_OPT_DEMAND         0x00000004  // Autodial on demand
#define RAS_AUTODIAL_OPT_NOPROMPT       0x00000010  // Dial without prompting


DWORD gWizardSuccess = 0x00000000;
DWORD gWizardFailure = 0x00000001;
DWORD gWizardCancelled = 0x00000002;
DWORD gNewInstall = 0x00000001;
DWORD gUpdateSettings = 0x00000002;

DWORD gWizardResult;    // will be set to gWizardSuccess, gWizardFailure, or gWizardCancelled

const TCHAR c_szICSGeneral[] = _T("System\\CurrentControlSet\\Services\\ICSharing\\Settings\\General");

/* RMR TODO: reenable
void WriteDefaultConnectoidRegString ( LPTSTR lpszValue )
{
  DWORD dwAutodialOpt;

  //
  // Default to dial on demand, no prompting
  //
  dwAutodialOpt = (RAS_AUTODIAL_OPT_DEMAND | RAS_AUTODIAL_OPT_NOPROMPT);

  RnaSetDefaultAutodialConnection(lpszValue, dwAutodialOpt);
}

void ReadDefaultConnectoidString ( LPTSTR lpszValue, DWORD dwSize )
{
  DWORD dwAutodialOpt;

  //
  // Read the default autodial setting 
  //

 RnaGetDefaultAutodialConnection((PUCHAR) lpszValue, dwSize, &dwAutodialOpt);
}
*/


/////////////////////////////////////////////////////////////////////////////
// CConfig

CConfig::CConfig()
{
    m_EnableICS = TRUE;
    m_ShowTrayIcon = TRUE;
    m_nServers = 0;
    m_nDhcp = 0;
    m_nBlockOut = 0;
    m_nParams = 0;
    m_nGeneral = 0;

    m_OldExternalAdapterReg[0] = '\0';
    m_OldInternalAdapterReg[0] = '\0';
    m_OldDialupEntry[0] = '\0';

    m_bOldEnableICS = FALSE;

}

CConfig::~CConfig()
{
}



/////////////////////////////////////////////////////////////////////////////
// CConfig message handlers


int CConfig::SaveConfig()
{
    BOOL bBindingsNeeded = FALSE;
    BOOL bICSEnableToggled = FALSE;

    // check to see if a rebind is necessary
    if ( StrCmp ( m_OldExternalAdapterReg, m_ExternalAdapterReg ) != 0 )
        bBindingsNeeded = TRUE;
    if ( StrCmp( m_OldInternalAdapterReg, m_InternalAdapterReg ) != 0 )
        bBindingsNeeded = TRUE;

    // Save parameters in the [General] Section
    //

    CRegistry reg;
    reg.OpenKey(HKEY_LOCAL_MACHINE, c_szICSGeneral);

//  RMR TODO: REENABLE!!!
//    if ( _tcslen ( m_DialupEntry ) > 0 )
//        WriteDefaultConnectoidRegString ( m_DialupEntry );
    reg.SetStringValue(_T("HangupTimer"), m_HangupTimer);
    if (m_EnableDialOnDemand) 
        reg.SetStringValue(_T("DialOnDemand"), _T("1"));
    else 
        reg.SetStringValue(_T("DialOnDemand"), _T("0"));

    if (m_EnableDHCP) 
    {
        reg.SetStringValue(_T("EnableDHCP"), _T("1"));
    }
    else 
    {
        reg.SetStringValue(_T("EnableDHCP"), _T("0"));
    }

    if (m_ShowTrayIcon) 
        reg.SetStringValue(_T("ShowTrayIcon"), _T("1"));
    else 
        reg.SetStringValue(_T("ShowTrayIcon"), _T("0"));

    if (m_EnableICS) 
    {
        if ( !m_bOldEnableICS )
            bICSEnableToggled = TRUE;

        reg.SetStringValue(_T("Enabled"), _T("1"));
    }
    else 
    {
        if ( m_bOldEnableICS )
            bICSEnableToggled = TRUE;

        reg.SetStringValue(_T("Enabled"), _T("0"));
    }

    // Added for compatibility with Win98SE/legacy setup for now
    reg.SetStringValue(_T("RunWizard"), _T("0"));

    if ( bBindingsNeeded )
        return BINDINGS_NEEDED;
    else if ( bICSEnableToggled )
        return ICSENABLETOGGLED;
    else
        return SAVE_SUCCEDED;
    

}

void CConfig::WriteWizardCode( BOOL bWizardRun )
{
    CRegistry reg;
    reg.OpenKey(HKEY_LOCAL_MACHINE, c_szICSGeneral);
    reg.SetBinaryValue(_T("WizardStatus"), &gWizardResult, sizeof(gWizardResult) );
    if ( bWizardRun )
        reg.SetBinaryValue(_T("WizardOptions"), &gNewInstall, sizeof(gNewInstall) );
    else
        reg.SetBinaryValue(_T("WizardOptions"), &gUpdateSettings, sizeof(gUpdateSettings) );

}
/*
RMR TODO: REENABLE
void CConfig::LoadConfig()
{
    // Save parameters in the [General] Section
    //
     
    ReadGeneralRegString(_T("InternalAdapterReg"), m_InternalAdapterReg, MAX_STRLEN);
    ReadGeneralRegString(_T("ExternalAdapterReg"), m_ExternalAdapterReg, MAX_STRLEN);
//    ReadGeneralRegString(_T("DialupEntry"), m_DialupEntry, MAX_STRLEN);
    ReadDefaultConnectoidString ( m_DialupEntry, MAX_STRLEN );
    ReadGeneralRegString(_T("HangupTimer"), m_HangupTimer, MAX_STRLEN);

    TCHAR szBOOL[MAX_STRLEN];
    ReadGeneralRegString(_T("DialOnDemand"), szBOOL, MAX_STRLEN);
    if ( _tcscmp ( szBOOL, _T("1")) == 0 )
        m_EnableDialOnDemand = TRUE;
    else
        m_EnableDialOnDemand = FALSE;
    
    ReadGeneralRegString(_T("EnableDHCP"),szBOOL, MAX_STRLEN);
    if ( _tcscmp ( szBOOL, _T("1")) == 0 )
        m_EnableDHCP = TRUE;
    else
        m_EnableDHCP = FALSE;

    ReadGeneralRegString(_T("ShowTrayIcon"), szBOOL, MAX_STRLEN);
    if ( _tcscmp ( szBOOL, _T("1")) == 0 )
        m_ShowTrayIcon = TRUE;
    else
        m_ShowTrayIcon = FALSE;

    ReadGeneralRegString(_T("Enabled"), szBOOL, MAX_STRLEN);
    if ( _tcscmp ( szBOOL, _T("1")) == 0 )
        m_EnableICS = TRUE;
    else
        m_EnableICS = FALSE;


    // save these off to check against on a save
    _tcsncpy ( m_OldExternalAdapterReg, m_ExternalAdapterReg, MAX_STRLEN);
    _tcsncpy ( m_OldInternalAdapterReg, m_InternalAdapterReg, MAX_STRLEN);
    _tcsncpy ( m_OldDialupEntry, m_DialupEntry, MAX_STRLEN);

    m_bOldEnableICS = m_EnableICS;

}
*/
void CConfig::InitWizardResult() 
{ 
    gWizardResult = gWizardSuccess; 
}

void CConfig::WizardCancelled() 
{
    gWizardResult = gWizardCancelled;
}
void CConfig::WizardFailed() 
{
    gWizardResult = gWizardFailure;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\hnw\wizard\crawler.cpp ===
//#include <winnetwk.h>
#include "stdafx.h"
#include "crawler.h"
#include "theapp.h"

void CNetCrawler::_EnumNetResources(LPNETRESOURCE pnr)
{
    HANDLE hEnum = NULL;
    INT cPrinters = 0;
    INT cShares = 0;
    DWORD dwScope = RESOURCE_GLOBALNET;
    
    // If no net resource structure passed then lets enumerate the workgroup
    NETRESOURCE nr = { 0 };

    if (!pnr)
    {
        pnr = &nr;
        dwScope = RESOURCE_CONTEXT;
        nr.dwType = RESOURCETYPE_ANY;
        nr.dwUsage = RESOURCEUSAGE_CONTAINER;
    }

    DWORD dwres = WNetOpenEnum(dwScope, RESOURCETYPE_ANY, 0, pnr, &hEnum);

    if (NO_ERROR == dwres)
    {
        // Avoid putting the buffer on the stack
        NETRESOURCE *pnrBuffer = (NETRESOURCE*)LocalAlloc(LPTR, CB_WNET_BUFFER);        

        if (pnrBuffer)
        {
			// WNetEnumResource() needs us to continue the enumeration
            do
            {
                DWORD cbEnumBuffer= CB_WNET_BUFFER;
                DWORD dwCount = -1;

                // Enumerate the resources for this enum context and then lets
                // Determine the objects which we should see.

            
                dwres = WNetEnumResource(hEnum, &dwCount, pnrBuffer, &cbEnumBuffer);

                if (NO_ERROR == dwres || (dwres == ERROR_MORE_DATA))
                {
                    DWORD index;
                    for (index = 0 ; index != dwCount; index++)
                    {    
                        LPNETRESOURCE pnr = &pnrBuffer[index];
                        LPTSTR pszRemoteName = pnr->lpRemoteName;

                        switch (pnr->dwDisplayType)
                        {
                            case RESOURCEDISPLAYTYPE_NETWORK:
							    _EnumNetResources(pnr);
								break;

                            case RESOURCEDISPLAYTYPE_DOMAIN:
                                if (_cItems < _iMaxItems || -1 == _iMaxItems)
                                {                                    
                                    LPTSTR pszName = (LPTSTR) LocalAlloc(LPTR, (lstrlen(pnr->lpRemoteName)+1)*sizeof(WCHAR));
                                    if (pszName)
                                    {
                                        lstrcpy(pszName, pnr->lpRemoteName);
                                        _cItems++;

                                        if (-1 == DPA_AppendPtr(_hdpaWorkGroups, pszName))
                                            LocalFree(pszName);
                                    }
                                }
                                else
                                {
                                    goto ENUMERATION_DONE;
                                }
                                break;
                        
                            // Add code here if we want to enumerate more network resources
                            case RESOURCEDISPLAYTYPE_SERVER:                            
                            case RESOURCEDISPLAYTYPE_SHARE:
                            default:
                                break;

                        }
                    } 
                } 
            } while ((NO_ERROR == dwres || dwres == ERROR_MORE_DATA) && (_cItems < _iMaxItems));

ENUMERATION_DONE:            
            LocalFree(pnrBuffer);
        }    

        WNetCloseEnum(hEnum);        
    }
}

DWORD WINAPI CNetCrawler::_EnumWorkGroups(LPVOID pv)
{
    CNetCrawler * pNC = (CNetCrawler *) pv;
	INT nMachines = 10;	

    NETRESOURCE nr = { 0 };

    nr.dwScope = RESOURCE_GLOBALNET;
    nr.dwType = RESOURCETYPE_ANY;
    nr.dwUsage = RESOURCEUSAGE_CONTAINER;

    pNC->_hdpaWorkGroups = DPA_Create(pNC->_iMaxItems);

    if (pNC->_hdpaWorkGroups) 
	    pNC->_EnumNetResources(&nr);

	pNC->_dwStatus = NC_FINISHED;

    pNC->Release();

	return 0;
}

CNetCrawler::~CNetCrawler(void)
{
    ASSERT (!_cRef);

    if (_hdpaWorkGroups)
    {
        int n = DPA_GetPtrCount(_hdpaWorkGroups);
        LPTSTR pszName;

        for (int i = 0; i < n; i++)
        {
            pszName = (LPTSTR) DPA_GetPtr(_hdpaWorkGroups, i);
            if (pszName)
            {
                LocalFree(pszName);
            }
        }        

        DPA_Destroy(_hdpaWorkGroups);
    }
}

void CNetCrawler::Init(DWORD dwFlags, int nItems)
{
	DWORD idThread;
    HANDLE hThread;

    _iMaxItems = nItems;

    AddRef();

    if (dwFlags | NC_INIT_WORKGROUPS)
	    hThread = CreateThread(NULL, 0, _EnumWorkGroups, (void *) this, 0, &idThread);

    if (hThread)
    {
        // Thread handle is no use, close it right a way
        _dwStatus = 0;
        CloseHandle(hThread);
    }
    else
        Release();


}


HRESULT CNetCrawler::GetWorkGroupName(LPTSTR pszWorkGroupName, int cb, BOOL fBlocking)
{
    ASSERT(pszWorkGroupName);

    LPTSTR psz;
    BOOL hr = S_OK;

    TCHAR szMSHOME[MAX_COMPUTERNAME_LENGTH+1];
    TCHAR szWORKGROUP[MAX_COMPUTERNAME_LENGTH+1];

    LoadString(g_hinst, IDS_DEFAULT_WORKGROUP1, szMSHOME, _countof(szMSHOME));
    LoadString(g_hinst, IDS_DEFAULT_WORKGROUP2, szWORKGROUP, _countof(szWORKGROUP));

    if (fBlocking && _hdpaWorkGroups && !(_dwStatus & NC_FINISHED))
    {
        // Blocking call - wait for thread to finish
        while (!(_dwStatus & NC_FINISHED))
        {}
    }

    if (_hdpaWorkGroups && _dwStatus & NC_FINISHED)
    {    
        int n = DPA_GetPtrCount(_hdpaWorkGroups);

        BOOL fHaveWorkgroup = FALSE;
        LPTSTR pszUserDefined = NULL;

        for (int i = 0; i < n; i++)
        {
            LPTSTR pszWG = (LPTSTR)DPA_GetPtr(_hdpaWorkGroups, i);
            if (0 == StrCmpI(pszWG, szWORKGROUP))
            {
                fHaveWorkgroup = TRUE;
            }
            else if (0 != StrCmpI(pszWG, szMSHOME))
            {
                if (!pszUserDefined)
                {
                    pszUserDefined = pszWG;
                }
                else
                {
                    // Choose the "lesser" of the two user defined workgroups
                    if (StrCmpI(pszUserDefined, pszWG) > 0)
                    {
                        pszUserDefined = pszWG;
                    }
                }
            }
        }

        if (pszUserDefined)
        {
            // We have a user-defined workgroup
            psz = pszUserDefined;
        }
        else if (fHaveWorkgroup)
        {
            // We have a "WORKGROUP" workgroup
            psz = szWORKGROUP;
        }
        else
        {
            // Use "MSHOME"
            psz = szMSHOME;
        }
    }
    // Enumeration not done, use the MSHOME with E_PENDING return
    else
    {
        hr = E_PENDING;
        psz = szMSHOME;
    }

    if (psz)
        lstrcpyn(pszWorkGroupName, psz, cb);
    
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\hnw\wizard\dll.cpp ===
#include "stdafx.h"
#include "theapp.h"
#include "comctlwrap.h"

HINSTANCE   g_hinst;
EXTERN_C BOOL g_fRunningOnNT;
UINT        g_uWindowsBuild;

// Local functions
//
void InitVersionInfo()
{
    OSVERSIONINFOA osvi;
    osvi.dwOSVersionInfoSize = sizeof(osvi);
    GetVersionExA(&osvi);
    g_uWindowsBuild = LOWORD(osvi.dwBuildNumber);
    g_fRunningOnNT = (osvi.dwPlatformId == VER_PLATFORM_WIN32_NT);

    g_dwComCtlIEVersion = GetComCtlIEVersion();
    g_dwShlwapiVersion  = GetShlwapiVersion();

#ifdef _DEBUG
    // Debug code for simulating different OSes.
    CRegistry regDebug;
    if (regDebug.OpenKey(HKEY_LOCAL_MACHINE, c_szAppRegKey, KEY_READ))
    {
        DWORD dwSimulateWinBuild = g_uWindowsBuild;
        if (!regDebug.QueryDwordValue(c_szRegVal_WindowsBuild, &dwSimulateWinBuild))
        {
            TCHAR szBuildNum[10];
            if (regDebug.QueryStringValue(c_szRegVal_WindowsBuild, szBuildNum, _countof(szBuildNum)))
                dwSimulateWinBuild = MyAtoi(szBuildNum);
        }
        g_uWindowsBuild = (UINT)dwSimulateWinBuild;
    }
#endif
}

BOOL WINAPI DllMain(
  HINSTANCE hinstDLL,  // handle to the DLL module
  DWORD fdwReason,     // reason for calling function
  LPVOID lpvReserved   // reserved
)
{
    switch (fdwReason)
    {
    case DLL_PROCESS_ATTACH:
        DisableThreadLibraryCalls(hinstDLL);
        g_hinst = hinstDLL;
        InitVersionInfo();
        SHFusionInitializeFromModule(hinstDLL);
        break;
    case DLL_PROCESS_DETACH:
        SHFusionUninitialize();
        break;
    }

    return TRUE;
}

void APIENTRY HomeNetWizardRunDll(HWND hwndStub, HINSTANCE hAppInstance, LPSTR pszCmdLine, int nCmdShow)
{
    if (S_OK == CoInitialize(NULL))
    {
        BOOL fReboot = FALSE;
        HomeNetworkWizard_ShowWizard(NULL, &fReboot);

        if (fReboot)
        {
            RestartDialog(NULL, NULL, EWX_REBOOT);                
        }

        CoUninitialize();
    }

    return;
}


// Classfactory implementation

LONG g_cRefThisDll = 0;          // DLL global reference count

STDAPI_(void) DllAddRef(void)
{
    InterlockedIncrement(&g_cRefThisDll);
}

STDAPI_(void) DllRelease(void)
{
    ASSERT( 0 != g_cRefThisDll );
    InterlockedDecrement(&g_cRefThisDll);
}

STDAPI DllCanUnloadNow(void)
{
    return g_cRefThisDll ? S_FALSE : S_OK;
}

HRESULT CHomeNetworkWizard_CreateInstance(IUnknown *punkOuter, IUnknown **ppunk, LPCOBJECTINFO poi);

CF_TABLE_BEGIN( g_ObjectInfo )
    CF_TABLE_ENTRY( &CLSID_HomeNetworkWizard,   CHomeNetworkWizard_CreateInstance,      COCREATEONLY),
CF_TABLE_END( g_ObjectInfo )


STDMETHODIMP CClassFactory::QueryInterface(REFIID riid, void **ppvObj)
{
    if (IsEqualIID(riid, IID_IClassFactory) || IsEqualIID(riid, IID_IUnknown))
    {
        *ppvObj = (void *)GET_ICLASSFACTORY(this);
        DllAddRef();
        return NOERROR;
    }

    *ppvObj = NULL;
    return E_NOINTERFACE;
}

STDMETHODIMP_(ULONG) CClassFactory::AddRef()
{
    DllAddRef();
    return 2;
}

STDMETHODIMP_(ULONG) CClassFactory::Release()
{
    DllRelease();
    return 1;
}

STDMETHODIMP CClassFactory::CreateInstance(IUnknown *punkOuter, REFIID riid, void **ppv)
{
    *ppv = NULL;

    if (punkOuter && !IsEqualIID(riid, IID_IUnknown))
    {
        return CLASS_E_NOAGGREGATION;
    }
    else
    {
        LPOBJECTINFO pthisobj = (LPOBJECTINFO)this;
       
        if (punkOuter) // && !(pthisobj->dwClassFactFlags & OIF_ALLOWAGGREGATION))
            return CLASS_E_NOAGGREGATION;

        IUnknown *punk;
        HRESULT hr = pthisobj->pfnCreateInstance(punkOuter, &punk, pthisobj);
        if (SUCCEEDED(hr))
        {
            hr = punk->QueryInterface(riid, ppv);
            punk->Release();
        }
    
        return hr;
    }
}

STDMETHODIMP CClassFactory::LockServer(BOOL fLock)
{
    if (fLock)
        DllAddRef();
    else
        DllRelease();
    return S_OK;
}

STDAPI DllGetClassObject(REFCLSID rclsid, REFIID riid, void **ppv)
{
    if (IsEqualIID(riid, IID_IClassFactory) || IsEqualIID(riid, IID_IUnknown))
    {
        for (LPCOBJECTINFO pcls = g_ObjectInfo; pcls->pclsid; pcls++)
        {
            if (IsEqualGUID(rclsid, *(pcls->pclsid)))
            {
                *ppv = (void*)pcls; 
                DllAddRef();        // class factory holds DLL ref count
                return NOERROR;
            }
        }
    }
    *ppv = NULL;
    return CLASS_E_CLASSNOTAVAILABLE;
}


// Call ADVPACK for the given section of our resource based INF>
//   hInstance = resource instance to get REGINST section from
//   szSection = section name to invoke
HRESULT CallRegInstall(HINSTANCE hInstance, LPCSTR szSection)
{
    HRESULT hr = E_FAIL;
    HINSTANCE hinstAdvPack = LoadLibrary(TEXT("ADVPACK.DLL"));
    if (hinstAdvPack)
    {
        REGINSTALL pfnri = (REGINSTALL)GetProcAddress(hinstAdvPack, "RegInstall");
        if ( pfnri )
        {
#ifdef WINNT
            STRENTRY seReg[] =
            {
                // These two NT-specific entries must be at the end
                { "25", "%SystemRoot%" },
                { "11", "%SystemRoot%\\system32" },
            };
            STRTABLE stReg = { ARRAYSIZE(seReg), seReg };
            hr = pfnri(hInstance, szSection, &stReg);
#else
            hr = pfnri(hInstance, szSection, NULL);
#endif
        }
        FreeLibrary(hinstAdvPack);
    }
    return hr;
}

STDAPI DllRegisterServer(void)
{
    CallRegInstall(g_hinst, "RegDll");
    return S_OK;
}

STDAPI DllUnregisterServer(void)
{
    CallRegInstall(g_hinst, "UnregDll");
    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\hnw\wizard\msprintx.h ===
//////////////////////////////////////////////////////////////////////////
//
// This is the public header file for apps that call MSPRINT.DLL
//
//////////////////////////////////////////////////////////////////////////

#ifdef _WIN32

// Typedef for the following function:
//
// BOOL WINAPI PrinterSetup32(HWND hWnd,WORD wAction,WORD wBufSize,
//                            LPBYTE lpBuffer,LPWORD lpwRequired);

typedef BOOL (WINAPI* PRINTERSETUPPROC32)(HWND,WORD,WORD,LPBYTE,LPWORD);

#define MSPRINT2_PRINTERSETUP32  ("PrinterSetup32")

#endif

#define MSP_NEWPRINTER             1
#define MSP_NETPRINTER             2
#define MSP_NEWDRIVER              3
#define MSP_NETADMIN               4
#define MSP_TESTPAGEFULLPROMPT     5
#define MSP_TESTPAGEPARTIALPROMPT  6
#define MSP_TESTPAGENOPROMPT       7
#define MSP_REMOVEPRINTER          8
#define MSP_SPOOLERFOUNDPRINTER    9
#define MSP_REMOVENETPRINTER       10
#define MSP_NEWPRINTER_MODELESS    11
#define MSP_FINDPRINTER            12

#if 0

#define MSPRINT_TESTONLY

#define MSP_BATCHPRINTERS        100

#define PBD_INSTALLED             1L

typedef struct tagONEPRINTERBATCHDATA
{
    char  szFriendlyName[32];
    char  szModelName[32];
    char  szPort[60];
    DWORD dwFlags;
} ONEPRINTERBATCHDATA, FAR * LPONEPRINTERBATCHDATA;

typedef struct tagPRINTERBATCHDATA
{
    char                szFileSource[60];
    DWORD               dwCount;
    ONEPRINTERBATCHDATA Printers[1];
} PRINTERBATCHDATA, FAR * LPPRINTERBATCHDATA;

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\hnw\wizard\dllload.c ===
#include "stdafx.h"
#include <msprintx.h>
#include "shlwapi.h"
#define _NO_NETSHARE_WRAPPERS_
#include "mysvrapi.h"
#define _NO_UNICWRAP_WRAPPERS_
#include "unicwrap.h"
#include "newapi.h"
#include <netcon.h>
#include <rasdlg.h>
#include <tapi.h>

#define NO_LOADING_OF_SHDOCVW_ONLY_FOR_WHICHPLATFORM
#include "..\..\..\inc\dllload.c"

#include <port32.h>  // for BOOLFROMPTR used in DELAY_LOAD_NAME_VOID

typedef enum  _NETSETUP_NAME_TYPE {

    NetSetupUnknown = 0,
    NetSetupMachine,
    NetSetupWorkgroup,
    NetSetupDomain,
    NetSetupNonExistentDomain,
#if(_WIN32_WINNT >= 0x0500)
    NetSetupDnsMachine
#endif

} NETSETUP_NAME_TYPE, *PNETSETUP_NAME_TYPE;

// -----------shlwapi.dll---------------
HMODULE g_hmodSHLWAPI = NULL;

#undef wvnsprintfW
DELAY_LOAD_NAME(g_hmodSHLWAPI, SHLWAPI, int, _wvnsprintfW, wvnsprintfW,
                 (LPWSTR lpOut, int cchLimitIn, LPCWSTR lpFmt, va_list arglist),
                 (lpOut, cchLimitIn, lpFmt, arglist));

DELAY_LOAD_NAME_HRESULT(g_hmodSHLWAPI, SHLWAPI, _StrRetToBufW, StrRetToBufW,
                        (STRRET* psr, LPCITEMIDLIST pidl, LPWSTR pszBuf, UINT cchBuf),
                        (psr, pidl, pszBuf, cchBuf));

DELAY_LOAD_ORD_ERR(g_hmodSHLWAPI, SHLWAPI, DWORD, _FormatMessageWrapW, 68,
                   (DWORD dwFlags, LPCVOID lpSource, DWORD dwMessageId, DWORD dwLanguageId, LPWSTR lpBuffer, DWORD nSize, va_list* Arguments),
                   (dwFlags, lpSource, dwMessageId, dwLanguageId, lpBuffer, nSize, Arguments), 0);

DELAY_LOAD_ORD_VOID(g_hmodSHLWAPI, SHLWAPI, _SHSetWindowBits, 165,
                    (HWND hWnd, int iWhich, DWORD dwBits, DWORD dwValue),
                    (hWnd, iWhich, dwBits, dwValue));

DELAY_LOAD_ORD_ERR(g_hmodSHLWAPI, SHLWAPI, int, _SHAnsiToUnicode, 215,
                   (LPCSTR pszSrc, LPWSTR pwszDst, int cwchBuf),
                   (pszSrc, pwszDst, cwchBuf), 0);

DELAY_LOAD_ORD_ERR(g_hmodSHLWAPI, SHLWAPI, int, _SHAnsiToUnicodeCP, 216,
                   (UINT uiCP, LPCSTR pszSrc, LPWSTR pwszDst, int cwchBuf),
                   (uiCP, pszSrc, pwszDst, cwchBuf), 0);

DELAY_LOAD_ORD_ERR(g_hmodSHLWAPI, SHLWAPI, int, _SHUnicodeToAnsi, 217,
                   (LPCWSTR pwszSrc, LPSTR pszDst, int cchBuf),
                   (pwszSrc, pszDst, cchBuf), 0);

DELAY_LOAD_ORD_ERR(g_hmodSHLWAPI, SHLWAPI, BOOL, _GUIDFromStringA, 269,
                   (LPCSTR psz, GUID *pguid),
                   (psz, pguid), FALSE);

DELAY_LOAD_ORD_ERR(g_hmodSHLWAPI, SHLWAPI, UINT, _WhichPlatform, 276,
                   (void),
                   (), PLATFORM_UNKNOWN);


DELAY_LOAD_ORD_ERR(g_hmodSHLWAPI, SHLWAPI, BOOL, _WritePrivateProfileStringWrapW, 298,
                   (LPCWSTR pwzAppName, LPCWSTR pwzKeyName, LPCWSTR pwzString, LPCWSTR pwzFileName),
                   (pwzAppName, pwzKeyName, pwzString, pwzFileName), FALSE);

DELAY_LOAD_ORD_ERR(g_hmodSHLWAPI, SHLWAPI, BOOL, _ExtTextOutWrapW, 299,
                   (HDC hdc, int x, int y, UINT fuOptions, CONST RECT *lprc, LPCWSTR lpStr, UINT cch, CONST INT *lpDx),
                   (hdc, x, y, fuOptions, lprc, lpStr, cch, lpDx), FALSE);

DELAY_LOAD_ORD_ERR(g_hmodSHLWAPI, SHLWAPI, HINSTANCE, _LoadLibraryWrapW, 309,
                   (LPCWSTR pwzLibFileName),
                   (pwzLibFileName), NULL);

DELAY_LOAD_ORD_ERR(g_hmodSHLWAPI, SHLWAPI, BOOL, _SHGetPathFromIDListWrapW, 334,
                   (LPCITEMIDLIST pidl, LPWSTR pwzPath),
                   (pidl, pwzPath), FALSE);

DELAY_LOAD_ORD_ERR(g_hmodSHLWAPI, SHLWAPI, BOOL, _SetFileAttributesWrapW, 338,
                   (LPCWSTR pwzFile, DWORD dwFileAttributes),
                   (pwzFile, dwFileAttributes), FALSE);

DELAY_LOAD_ORD_ERR(g_hmodSHLWAPI, SHLWAPI, int, _MessageBoxWrapW, 340,
                   (HWND hwnd, LPCWSTR pwzText, LPCWSTR pwzCaption, UINT uType),
                   (hwnd, pwzText, pwzCaption, uType), 0);

DELAY_LOAD_ORD_ERR(g_hmodSHLWAPI, SHLWAPI, BOOL, _CreateProcessWrapW, 369,
                   (LPCWSTR lpApplicationName, LPWSTR lpCommandLine, LPSECURITY_ATTRIBUTES lpProcessAttributes, LPSECURITY_ATTRIBUTES lpThreadAttributes, BOOL bInheritHandles, DWORD dwCreationFlags, LPVOID lpEnvironment, LPCWSTR lpCurrentDirectory, LPSTARTUPINFOW lpStartupInfo, LPPROCESS_INFORMATION lpProcessInformation),
                   (lpApplicationName, lpCommandLine, lpProcessAttributes, lpThreadAttributes, bInheritHandles, dwCreationFlags, lpEnvironment, lpCurrentDirectory, lpStartupInfo, lpProcessInformation), FALSE);

DELAY_LOAD_ORD_VOID(g_hmodSHLWAPI, SHLWAPI, _SHChangeNotify, 394,
                    (LONG wEventId, UINT uFlags, LPCVOID dwItem1, LPCVOID dwItem2),
                    (wEventId, uFlags, dwItem1, dwItem2));



// -----------hhctrl.ocx--------------- 
HMODULE g_hmodHHCtrl = NULL;

DELAY_LOAD_EXT(g_hmodHHCtrl, hhctrl, OCX, HWND, HtmlHelpA,
                (HWND hwndCaller, LPCSTR pszFile, UINT uCommand, DWORD dwData), 
                (hwndCaller, pszFile, uCommand, dwData))

// --------- Shell32.dll (NT) -----------
HINSTANCE g_hinstSHELL32 = NULL;

DELAY_LOAD_NAME(g_hinstSHELL32, SHELL32, BOOL, LinkWindow_RegisterClass_NT, LinkWindow_RegisterClass, (), ());
DELAY_LOAD_NAME(g_hinstSHELL32, SHELL32, LPITEMIDLIST, ILCreateFromPathW_NT, ILCreateFromPathW, (LPCWSTR pszPath), (pszPath));

#undef SHGetFileInfoW
DELAY_LOAD_NAME(g_hinstSHELL32, SHELL32, DWORD_PTR, SHGetFileInfoW_NT, SHGetFileInfoW,
                (LPCWSTR pszPath, DWORD dwFileAttributes, SHFILEINFOW *psfi, UINT cbFileInfo, UINT uFlags), 
                (pszPath, dwFileAttributes, psfi, cbFileInfo, uFlags));

// --------- KERNEL32.DLL (NT) ----------
HINSTANCE g_hinstKERNEL32 = NULL;

DELAY_LOAD_NAME(g_hinstKERNEL32, KERNEL32, BOOL, SetComputerNameExW_NT, SetComputerNameExW,
                 (COMPUTER_NAME_FORMAT NameType, LPCWSTR lpBuffer),
                 (NameType, lpBuffer));

DELAY_LOAD_NAME(g_hinstKERNEL32, KERNEL32, BOOL, GetComputerNameExW_NT, GetComputerNameExW,
                 (COMPUTER_NAME_FORMAT NameType, LPWSTR lpBuffer, LPDWORD lpnSize),
                 (NameType, lpBuffer, lpnSize));


// --------- NETSHELL.DLL (NT) ----------
HINSTANCE g_hinstNETSHELL = NULL;

DELAY_LOAD_VOID(g_hinstNETSHELL, NETSHELL, NcFreeNetconProperties,
    (NETCON_PROPERTIES* pprops),
    (pprops));

// --------- ADVAPI32.DLL (NT) ----------
HINSTANCE g_hinstADVAPI = NULL;

DELAY_LOAD_NAME(g_hinstADVAPI, ADVAPI32, BOOL, AllocateAndInitializeSid_NT, AllocateAndInitializeSid,
                        (PSID_IDENTIFIER_AUTHORITY pIdentifierAuthority, BYTE nSubAuthorityCount, DWORD dwSubAuthority0, DWORD dwSubAuthority1, DWORD dwSubAuthority2, DWORD dwSubAuthority3, DWORD dwSubAuthority4, DWORD dwSubAuthority5, DWORD dwSubAuthority6, DWORD dwSubAuthority7, PSID *pSid),
                        (pIdentifierAuthority, nSubAuthorityCount, dwSubAuthority0, dwSubAuthority1, dwSubAuthority2, dwSubAuthority3, dwSubAuthority4, dwSubAuthority5, dwSubAuthority6, dwSubAuthority7, pSid));

DELAY_LOAD_NAME(g_hinstADVAPI, ADVAPI32, BOOL, CheckTokenMembership_NT, CheckTokenMembership,
                        (HANDLE TokenHandle, PSID SidToCheck, PBOOL IsMember),
                        (TokenHandle, SidToCheck, IsMember));

DELAY_LOAD_NAME(g_hinstADVAPI, ADVAPI32, PVOID, FreeSid_NT, FreeSid,
                        (PSID SidToFree),
                        (SidToFree));


// --------- TAPI32.DLL ---------------
/*
HINSTANCE g_hinstTAPI32 = NULL;

DELAY_LOAD(g_hinstTAPI32, TAPI32, LONG, lineInitializeExW,
	(LPHLINEAPP lphLineApp, HINSTANCE hInstance, LINECALLBACK lpfnCallback, LPCWSTR lpszFriendlyAppName, LPDWORD lpdwNumDevs, LPDWORD lpdwAPIVersion, LPLINEINITIALIZEEXPARAMS lpLineInitializeExParams),
	(lphLineApp, hInstance, lpfnCallback, lpszFriendlyAppName, lpdwNumDevs, lpdwAPIVersion, lpLineInitializeExParams));
DELAY_LOAD(g_hinstTAPI32, TAPI32, LONG, lineInitializeExA,
	(LPHLINEAPP lphLineApp, HINSTANCE hInstance, LINECALLBACK lpfnCallback, LPCSTR lpszFriendlyAppName, LPDWORD lpdwNumDevs, LPDWORD lpdwAPIVersion, LPLINEINITIALIZEEXPARAMS lpLineInitializeExParams),
	(lphLineApp, hInstance, lpfnCallback, lpszFriendlyAppName, lpdwNumDevs, lpdwAPIVersion, lpLineInitializeExParams));
*/
// --------- RASDLG.DLL ---------------

HINSTANCE g_hinstRASDLG = NULL;

DELAY_LOAD_BOOL(g_hinstRASDLG, RASDLG, RasDialDlgW,
    (LPWSTR lpszPhoneBook, LPWSTR lpszEntry, LPWSTR lpszPhoneNumber, LPRASDIALDLG lpInfo),
    (lpszPhoneBook, lpszEntry, lpszPhoneNumber, lpInfo));
DELAY_LOAD_BOOL(g_hinstRASDLG, RASDLG, RasDialDlgA,
    (LPSTR lpszPhoneBook, LPSTR lpszEntry, LPSTR lpszPhoneNumber, LPRASDIALDLG lpInfo),
    (lpszPhoneBook, lpszEntry, lpszPhoneNumber, lpInfo));

// --------- RASAPI32.DLL ---------------

HINSTANCE g_hinstRASAPI32 = NULL;

DELAY_LOAD_DWORD(g_hinstRASAPI32, RASAPI32, RasGetEntryPropertiesW,
    (LPCWSTR lpszPhoneBook, LPCWSTR lpszEntry, LPRASENTRYW lpRasEntryW, LPDWORD lpdwEntryInfoSize, LPBYTE lpbDeviceInfo, LPDWORD lpdwDeviceInfoSize),
    (lpszPhoneBook, lpszEntry, lpRasEntryW, lpdwEntryInfoSize, lpbDeviceInfo, lpdwDeviceInfoSize));
DELAY_LOAD_DWORD(g_hinstRASAPI32, RASAPI32, RasGetEntryPropertiesA,
    (LPCSTR lpszPhoneBook, LPCSTR lpszEntry, LPRASENTRYA lpRasEntryA, LPDWORD lpdwEntryInfoSize, LPBYTE lpbDeviceInfo, LPDWORD lpdwDeviceInfoSize),
    (lpszPhoneBook, lpszEntry, lpRasEntryA, lpdwEntryInfoSize, lpbDeviceInfo, lpdwDeviceInfoSize));

DELAY_LOAD_DWORD(g_hinstRASAPI32, RASAPI32, RasEnumEntriesW,
    (LPCWSTR reserved, LPCWSTR pszPhoneBookPath, LPRASENTRYNAMEW pRasEntryNameW, LPDWORD pcb, LPDWORD pcEntries),
    (reserved, pszPhoneBookPath, pRasEntryNameW, pcb, pcEntries));
DELAY_LOAD_DWORD(g_hinstRASAPI32, RASAPI32, RasEnumEntriesA,
    (LPCSTR reserved, LPCSTR pszPhoneBookPath, LPRASENTRYNAMEA pRasEntryNameA, LPDWORD pcb, LPDWORD pcEntries),
    (reserved, pszPhoneBookPath, pRasEntryNameA, pcb, pcEntries));

DELAY_LOAD_DWORD(g_hinstRASAPI32, RASAPI32, RasSetEntryDialParamsW,
    (LPCWSTR pszPhonebook, LPRASDIALPARAMSW lpRasDialParamsW, BOOL fRemovePassword),
    (pszPhonebook, lpRasDialParamsW, fRemovePassword));
DELAY_LOAD_DWORD(g_hinstRASAPI32, RASAPI32, RasSetEntryDialParamsA,
    (LPCSTR pszPhonebook, LPRASDIALPARAMSA lpRasDialParamsA, BOOL fRemovePassword),
    (pszPhonebook, lpRasDialParamsA, fRemovePassword));

DELAY_LOAD_DWORD(g_hinstRASAPI32, RASAPI32, RasGetEntryDialParamsW,
    (LPCWSTR pszPhonebook, LPRASDIALPARAMSW lpRasDialParamsW, LPBOOL pfRemovePassword),
    (pszPhonebook, lpRasDialParamsW, pfRemovePassword));
DELAY_LOAD_DWORD(g_hinstRASAPI32, RASAPI32, RasGetEntryDialParamsA,
    (LPCSTR pszPhonebook, LPRASDIALPARAMSA lpRasDialParamsA, LPBOOL pfRemovePassword),
    (pszPhonebook, lpRasDialParamsA, pfRemovePassword));

DELAY_LOAD_DWORD(g_hinstRASAPI32, RASAPI32, RasSetEntryPropertiesW,
    (LPCWSTR pszPhonebook, LPCWSTR pszEntry, LPRASENTRYW pRasEntryW, DWORD cbRasEntry, LPBYTE pbDeviceConfig, DWORD cbDeviceConfig),
    (pszPhonebook, pszEntry, pRasEntryW, cbRasEntry, pbDeviceConfig, cbDeviceConfig));
DELAY_LOAD_DWORD(g_hinstRASAPI32, RASAPI32, RasSetEntryPropertiesA,
    (LPCSTR pszPhonebook, LPCSTR pszEntry, LPRASENTRYA pRasEntryA, DWORD cbRasEntry, LPBYTE pbDeviceConfig, DWORD cbDeviceConfig),
    (pszPhonebook, pszEntry, pRasEntryA, cbRasEntry, pbDeviceConfig, cbDeviceConfig));

DELAY_LOAD_DWORD(g_hinstRASAPI32, RASAPI32, RnaGetDefaultAutodialConnection,
    (LPSTR szBuffer, DWORD cchBuffer, LPDWORD lpdwOptions),
    (szBuffer, cchBuffer, lpdwOptions));

DELAY_LOAD_DWORD(g_hinstRASAPI32, RASAPI32, RnaSetDefaultAutodialConnection,
    (LPSTR szEntry, DWORD dwOptions),
    (szEntry, dwOptions));

// Only on NT (rasapi32.dll)
//DELAY_LOAD_DWORD(g_hinstRASAPI32, RASAPI32, RasShareConnection,
//    (LPRASSHARECONN pConn, GUID* pPrivateLanGuid),
//    (pConn, pPrivateLanGuid));

//DELAY_LOAD_DWORD(g_hinstRASAPI32, RASAPI32, RasUnshareConnection,
//    (PBOOL pfWasShared),
//    (pfWasShared));

// --------- OLE32.DLL ----------------

HINSTANCE g_hmodOLE32 = NULL;

// CoSetProxyBlanket not available on W95 Gold ole32.dll

DELAY_LOAD_NAME_HRESULT(g_hmodOLE32, OLE32, CoSetProxyBlanket_NT, CoSetProxyBlanket,
                        (IUnknown* pProxy, DWORD dwAuthnSvc, DWORD dwAuthzSvc, OLECHAR* pServerPrincName, DWORD dwAuthnLevel, DWORD dwImpLevel, RPC_AUTH_IDENTITY_HANDLE pAuthInfo, DWORD dwCapabilities),
                        (pProxy, dwAuthnSvc, dwAuthzSvc, pServerPrincName, dwAuthnLevel, dwImpLevel, pAuthInfo, dwCapabilities));

// --------- MPR.DLL ----------------

HINSTANCE g_hmodMPR = NULL;

DELAY_LOAD_WNET(g_hmodMPR, MPR, WNetOpenEnumW,
       (DWORD dwScope, DWORD dwType, DWORD dwUsage, LPNETRESOURCEW lpNetResource, LPHANDLE lphEnum),
       (dwScope, dwType, dwUsage, lpNetResource, lphEnum));
DELAY_LOAD_WNET(g_hmodMPR, MPR, WNetOpenEnumA,
       (DWORD dwScope, DWORD dwType, DWORD dwUsage, LPNETRESOURCEA lpNetResource, LPHANDLE lphEnum),
       (dwScope, dwType, dwUsage, lpNetResource, lphEnum));

DELAY_LOAD_WNET(g_hmodMPR, MPR, WNetEnumResourceW,
       (HANDLE  hEnum, LPDWORD lpcCount, LPVOID  lpBuffer, LPDWORD lpBufferSize),
       (hEnum, lpcCount, lpBuffer, lpBufferSize));
DELAY_LOAD_WNET(g_hmodMPR, MPR, WNetEnumResourceA,
       (HANDLE  hEnum, LPDWORD lpcCount, LPVOID  lpBuffer, LPDWORD lpBufferSize),
       (hEnum, lpcCount, lpBuffer, lpBufferSize));

DELAY_LOAD_WNET(g_hmodMPR, MPR, WNetCloseEnum, (HANDLE hEnum), (hEnum));

DELAY_LOAD_WNET(g_hmodMPR, MPR, WNetGetUserW,
       (LPCWSTR lpName, LPWSTR lpUserName, LPDWORD lpnLength),
       (lpName, lpUserName, lpnLength));
DELAY_LOAD_WNET(g_hmodMPR, MPR, WNetGetUserA,
       (LPCSTR lpName, LPSTR lpUserName, LPDWORD lpnLength),
       (lpName, lpUserName, lpnLength));



// --------- WINSPOOL.DRV ----------------

HINSTANCE g_hinstWINSPOOL_DRV = NULL;

DELAY_LOAD_EXT(g_hinstWINSPOOL_DRV, WINSPOOL, DRV, BOOL, EnumPrintersW,
                (DWORD dwFlags, LPWSTR psz1, DWORD dw1, LPBYTE pb1, DWORD dw2, LPDWORD pdw2, LPDWORD pdw3),
                (dwFlags, psz1, dw1, pb1, dw2, pdw2, pdw3));

DELAY_LOAD_EXT(g_hinstWINSPOOL_DRV, WINSPOOL, DRV, BOOL, EnumPrintersA,
                (DWORD dwFlags, LPSTR psz1, DWORD dw1, LPBYTE pb1, DWORD dw2, LPDWORD pdw2, LPDWORD pdw3),
                (dwFlags, psz1, dw1, pb1, dw2, pdw2, pdw3));

DELAY_LOAD_EXT(g_hinstWINSPOOL_DRV, WINSPOOL, DRV, BOOL, GetDefaultPrinter, // NT only
                (LPTSTR szDefaultPrinter, LPDWORD pcch),
                (szDefaultPrinter, pcch));

DELAY_LOAD_NAME_EXT_ERR(g_hinstWINSPOOL_DRV, Win32Spl, DRV, BOOL, OpenPrinter_NT, OpenPrinterW,
    (LPWSTR pPrinterName, LPHANDLE phPrinter, LPPRINTER_DEFAULTSW pDefault),
    (pPrinterName, phPrinter, pDefault), 0);

DELAY_LOAD_NAME_EXT_ERR(g_hinstWINSPOOL_DRV, Win32Spl, DRV, BOOL, ClosePrinter_NT, ClosePrinter,
    (HANDLE hPrinter),
    (hPrinter), 0);

DELAY_LOAD_NAME_EXT_ERR(g_hinstWINSPOOL_DRV, Win32Spl, DRV, BOOL, GetPrinter_NT, GetPrinterW,
    (HANDLE hPrinter, DWORD Level, LPBYTE pPrinter, DWORD cbBuf, LPDWORD pcbNeeded),
    (hPrinter, Level, pPrinter, cbBuf, pcbNeeded), 0);

DELAY_LOAD_NAME_EXT_ERR(g_hinstWINSPOOL_DRV, Win32Spl, DRV, BOOL, SetPrinter_NT, SetPrinterW,
    (HANDLE  hPrinter, DWORD Level, LPBYTE pPrinter, DWORD Command),
    (hPrinter, Level, pPrinter, Command), 0);


// --------- SVRAPI.DLL (w9x) ----------------

HINSTANCE g_hinstSVRAPI = NULL;

DELAY_LOAD_NAME_ERR(g_hinstSVRAPI, SVRAPI, DWORD, NetShareEnum_W95, NetShareEnum,
                        (const char FAR * pszServer, short sLevel, char FAR * pbBuffer, unsigned short cbBuffer, unsigned short FAR * pcEntriesRead, unsigned short FAR * pcTotalAvail),
                        (pszServer, sLevel, pbBuffer, cbBuffer, pcEntriesRead, pcTotalAvail), ~NERR_Success);

DELAY_LOAD_NAME_ERR(g_hinstSVRAPI, SVRAPI, DWORD, NetShareAdd_W95, NetShareAdd,
                        (const char FAR * pszServer, short sLevel, const char FAR * pbBuffer, unsigned short cbBuffer),
                        (pszServer, sLevel,  pbBuffer, cbBuffer), ~NERR_Success);

DELAY_LOAD_NAME_ERR(g_hinstSVRAPI, SVRAPI, DWORD, NetShareDel_W95, NetShareDel,
                        (const char FAR * pszServer, const char FAR * pszNetName, unsigned short usReserved),
                        (pszServer, pszNetName, usReserved), ~NERR_Success);

DELAY_LOAD_NAME_ERR(g_hinstSVRAPI, SVRAPI, DWORD, NetShareGetInfo_W95, NetShareGetInfo,
                        (const char FAR * pszServer, const char FAR * pszNetName, short sLevel, char FAR * pbBuffer, unsigned short cbBuffer, unsigned short FAR * pcbTotalAvail),
                        (pszServer, pszNetName, sLevel, pbBuffer, cbBuffer, pcbTotalAvail), ~NERR_Success);
                        
DELAY_LOAD_NAME_ERR(g_hinstSVRAPI, SVRAPI, DWORD, NetShareSetInfo_W95, NetShareSetInfo,
                        (const char FAR * pszServer, const char FAR * pszNetName, short sLevel, const char FAR * pbBuffer, unsigned short cbBuffer, short sParmNum),
                        (pszServer, pszNetName, sLevel, pbBuffer, cbBuffer, sParmNum), ~NERR_Success);


// --------- NETAPI32.DLL (NT) ----------------

HINSTANCE g_hinstNETAPI32 = NULL;

DELAY_LOAD_NAME_DWORD(g_hinstNETAPI32, NETAPI32, NetShareEnum_NT, NetShareEnum,
                        (LPWSTR pszServer, DWORD level, LPBYTE * ppbuffer, DWORD cbbuffer, LPDWORD pcEntriesRead, LPDWORD pcTotalEntries, LPDWORD dsResumeHandle),
                        (pszServer, level, ppbuffer, cbbuffer, pcEntriesRead, pcTotalEntries, dsResumeHandle));

DELAY_LOAD_NAME_DWORD(g_hinstNETAPI32, NETAPI32, NetShareAdd_NT, NetShareAdd,
                        (LPWSTR servername, DWORD level, LPBYTE buf, LPDWORD parm_err),
                        (servername, level, buf, parm_err));

DELAY_LOAD_NAME_DWORD(g_hinstNETAPI32, NETAPI32, NetShareDel_NT, NetShareDel,
                        (LPWSTR servername, LPWSTR netname, DWORD reserved),
                        (servername, netname, reserved));

DELAY_LOAD_NAME_DWORD(g_hinstNETAPI32, NETAPI32, NetShareGetInfo_NT, NetShareGetInfo,
                        (LPWSTR servername, LPWSTR netname, DWORD level, LPBYTE *bufptr),
                        (servername, netname, level, bufptr));

DELAY_LOAD_NAME_DWORD(g_hinstNETAPI32, NETAPI32, NetShareSetInfo_NT, NetShareSetInfo,
                        (LPWSTR servername, LPWSTR netname, DWORD level, LPBYTE buf, LPDWORD parm_err),
                        (servername, netname, level, buf, parm_err));

DELAY_LOAD_NAME_DWORD(g_hinstNETAPI32, NETAPI32, NetServerGetInfo_NT, NetServerGetInfo,
                        (LPWSTR servername, DWORD level, LPBYTE* pbuf),
                        (servername, level, pbuf));

DELAY_LOAD_NAME_DWORD(g_hinstNETAPI32, NETAPI32, NetServerSetInfo_NT, NetServerSetInfo,
                        (LPWSTR servername, DWORD level, LPBYTE buf, LPDWORD parm_err),
                        (servername, level, buf, parm_err));

DELAY_LOAD_NAME_DWORD(g_hinstNETAPI32, NETAPI32, NetApiBufferFree_NT, NetApiBufferFree,
                        (LPVOID Buffer), (Buffer));


DELAY_LOAD_DWORD(g_hinstNETAPI32, NETAPI32, NetValidateName,
                        (LPCWSTR pszServer, LPCWSTR pszName, LPCWSTR pszAccount, LPCWSTR pszPassword, NETSETUP_NAME_TYPE NameType), 
                        (pszServer, pszName, pszAccount, pszPassword, NameType));

// We only use NetGetJoinInformation on NT anyway
DELAY_LOAD_DWORD(g_hinstNETAPI32, NETAPI32, NetGetJoinInformation,
                        (LPWSTR servername, LPWSTR* pbuffer, LPDWORD type),
                        (servername, pbuffer, type));

DELAY_LOAD_DWORD(g_hinstNETAPI32, NETAPI32, NetJoinDomain,
                        (LPCWSTR lpServer, LPCWSTR lpDomain, LPCWSTR lpAccountOU, LPCWSTR lpAccount, LPCWSTR lpPassword, DWORD fJoinOptions),
                        (lpServer, lpDomain, lpAccountOU, lpAccount, lpPassword, fJoinOptions));

DELAY_LOAD_DWORD(g_hinstNETAPI32, NETAPI32, NetUnjoinDomain,
                        (LPCWSTR lpServer, LPCWSTR lpAccount, LPCWSTR lpPassword, DWORD fUnjoinOptions),
                        (lpServer, lpAccount, lpPassword, fUnjoinOptions));

// ws2_32 for Network Location Awareness (NT)
HINSTANCE g_hinstWS2_32 = NULL;

DELAY_LOAD_NAME(g_hinstWS2_32, ws2_32, int, WSAStartup_NT, WSAStartup,
                (WORD wVersionRequested, LPWSADATA lpWSAData),
                (wVersionRequested, lpWSAData));

DELAY_LOAD_NAME(g_hinstWS2_32, ws2_32, int, WSAGetLastError_NT, WSAGetLastError,
                (),
                ());

DELAY_LOAD_NAME(g_hinstWS2_32, ws2_32, int, WSACleanup_NT, WSACleanup,
                (),
                ());

DELAY_LOAD_NAME(g_hinstWS2_32, ws2_32, int, WSALookupServiceEnd_NT, WSALookupServiceEnd,
                (HANDLE hLookup),
                (hLookup));

DELAY_LOAD_NAME(g_hinstWS2_32, ws2_32, int, WSALookupServiceBegin_NT, WSALookupServiceBegin,
                (LPWSAQUERYSET lpqsRestrictions, DWORD dwControlFlags, LPHANDLE lphLookup),
                (lpqsRestrictions, dwControlFlags, lphLookup));

DELAY_LOAD_NAME(g_hinstWS2_32, ws2_32, int, WSALookupServiceNext_NT, WSALookupServiceNext,
                (HANDLE hLookup, DWORD dwControlFlags, LPDWORD lpdwBufferLength, LPWSAQUERYSET lpqsResults),
                (hLookup, dwControlFlags, lpdwBufferLength, lpqsResults));


// --------- NCONN Thunks ----------------

#include "netconn.h"

BOOL      g_fRunningOnNT;


//
// The thunk macros do the following:
//
//     1. Create a delay load W9x function for the given API using the delay
//        load map macros with Ncxp32.dll and a W9x_ prefix for the
//        function name.
//
//     2. Create a delay load NT function for the given API using the delay
//        load map macros with NCxpNT.dll and a NT_ prefix for the function
//        name.
//
//     3. Create the exported API of the given name that checks what platform
//        we're currently running on and calls the W9x or NT delay loaded
//        version of the API.
//

#define W9x_NT_THUNK(_W9xhinst, _W9xdll, _NThinst, _NTdll, _ret, _fn, _args, _nargs, _err) \
    \
    DELAY_LOAD_NAME_ERR(_NThinst,   _NTdll, _ret,  NT_##_fn, _fn, _args, _nargs, _err);\
    \
    DELAY_LOAD_NAME_ERR(_W9xhinst, _W9xdll, _ret, W9x_##_fn, _fn, _args, _nargs, _err);\
    \
    _ret _stdcall _fn _args \
    { \
        _ret ret; \
    \
        if (g_fRunningOnNT) \
        { \
            ret = NT_##_fn _nargs; \
        } \
        else \
        { \
            ret = W9x_##_fn _nargs; \
        } \
    \
        return ret; \
    }

#define W9x_NT_THUNK_VOID(_W9xhinst, _W9xdll, _NThinst, _NTdll, _fn, _args, _nargs) \
    \
    DELAY_LOAD_NAME_VOID(_NThinst,   _NTdll,  NT_##_fn, _fn, _args, _nargs);\
    \
    DELAY_LOAD_NAME_VOID(_W9xhinst, _W9xdll, W9x_##_fn, _fn, _args, _nargs);\
    \
    void _stdcall _fn _args \
    { \
        if (g_fRunningOnNT) \
        { \
            NT_##_fn _nargs; \
        } \
        else \
        { \
            W9x_##_fn _nargs; \
        } \
    }


//
// Delay load thunk declarations for ncxpnt.dll and ncxp32.dll.
//

HINSTANCE g_hNcxp32 = NULL;
HINSTANCE g_hNcxpNT = NULL;


#define W9x_NT_NCONN_THUNK(_ret, _fn, _args, _nargs, _err) \
    W9x_NT_THUNK(g_hNcxp32, ncxp32, g_hNcxpNT, ncxpnt, _ret, _fn, _args, _nargs, _err)

#define W9x_NT_NCONN_THUNK_VOID(_fn, _args, _nargs) \
    W9x_NT_THUNK_VOID(g_hNcxp32, ncxp32, g_hNcxpNT, ncxpnt, _fn, _args, _nargs)


W9x_NT_NCONN_THUNK (LPVOID,
                    NetConnAlloc,
                    (DWORD cbAlloc),
                    (cbAlloc),
                    NULL);

W9x_NT_NCONN_THUNK_VOID (NetConnFree,
                         (LPVOID pMem),
                         (pMem));

W9x_NT_NCONN_THUNK (BOOL,
                    IsProtocolInstalled,
                    (LPCWSTR pszProtocolDeviceID, BOOL bExhaustive),
                    (pszProtocolDeviceID, bExhaustive),
                    FALSE);

W9x_NT_NCONN_THUNK (HRESULT,
                    InstallProtocol,
                    (LPCWSTR pszProtocol, HWND hwndParent, PROGRESS_CALLBACK pfnCallback, LPVOID pvCallbackParam),
                    (pszProtocol, hwndParent, pfnCallback, pvCallbackParam),
                    E_FAIL);

W9x_NT_NCONN_THUNK (HRESULT,
                    InstallTCPIP,
                    (HWND hwndParent, PROGRESS_CALLBACK pfnProgress, LPVOID pvProgressParam),
                    (hwndParent, pfnProgress, pvProgressParam),
                    E_FAIL);

W9x_NT_NCONN_THUNK (HRESULT,
                    RemoveProtocol,
                    (LPCWSTR pszProtocol),
                    (pszProtocol),
                    E_FAIL);

W9x_NT_NCONN_THUNK (BOOL,
                    IsMSClientInstalled,
                    (BOOL bExhaustive),
                    (bExhaustive),
                    FALSE);

W9x_NT_NCONN_THUNK (HRESULT,
                    InstallMSClient,
                    (HWND hwndParent, PROGRESS_CALLBACK pfnProgress, LPVOID pvProgressParam),
                    (hwndParent, pfnProgress, pvProgressParam),
                    E_FAIL);

W9x_NT_NCONN_THUNK (HRESULT,
                    EnableBrowseMaster,
                    (),
                    (),
                    E_FAIL);

W9x_NT_NCONN_THUNK (BOOL,
                    IsSharingInstalled,
                    (BOOL bExhaustive),
                    (bExhaustive),
                    FALSE);

W9x_NT_NCONN_THUNK (BOOL,
                    IsFileSharingEnabled,
                    (),
                    (),
                    FALSE);

W9x_NT_NCONN_THUNK (BOOL,
                    IsPrinterSharingEnabled,
                    (),
                    (),
                    FALSE);

W9x_NT_NCONN_THUNK (HRESULT,
                    InstallSharing,
                    (HWND hwndParent, PROGRESS_CALLBACK pfnProgress, LPVOID pvProgressParam),
                    (hwndParent, pfnProgress, pvProgressParam),
                    E_FAIL);

W9x_NT_NCONN_THUNK (BOOL,
                    FindConflictingService,
                    (LPCWSTR pszWantService, NETSERVICE* pConflict),
                    (pszWantService, pConflict),
                    FALSE);

W9x_NT_NCONN_THUNK (int,
                    EnumNetAdapters,
                    (NETADAPTER FAR** pprgNetAdapters),
                    (pprgNetAdapters),
                    0);

W9x_NT_NCONN_THUNK (HRESULT,
                    InstallNetAdapter,
                    (LPCWSTR pszDeviceID, LPCWSTR pszInfPath, HWND hwndParent, PROGRESS_CALLBACK pfnProgress, LPVOID pvCallbackParam),
                    (pszDeviceID, pszInfPath, hwndParent, pfnProgress, pvCallbackParam),
                    E_FAIL);

W9x_NT_NCONN_THUNK (BOOL,
                    IsAccessControlUserLevel,
                    (),
                    (),
                    FALSE);

W9x_NT_NCONN_THUNK (HRESULT,
                    DisableUserLevelAccessControl,
                    (),
                    (),
                    E_FAIL);

W9x_NT_NCONN_THUNK (HRESULT,
                    EnableQuickLogon,
                    (),
                    (),
                    E_FAIL);

W9x_NT_NCONN_THUNK (HRESULT,
                    DetectHardware,
                    (LPCWSTR pszDeviceID),
                    (pszDeviceID),
                    E_FAIL);

W9x_NT_NCONN_THUNK (BOOL,
                    IsProtocolBoundToAdapter,
                    (LPCWSTR pszProtocolID, const NETADAPTER* pAdapter),
                    (pszProtocolID, pAdapter),
                    FALSE);

W9x_NT_NCONN_THUNK (HRESULT,
                    EnableNetAdapter,
                    (const NETADAPTER* pAdapter),
                    (pAdapter),
                    E_FAIL);

W9x_NT_NCONN_THUNK (BOOL,
                    IsClientInstalled,
                    (LPCWSTR pszClient, BOOL bExhaustive),
                    (pszClient, bExhaustive),
                    FALSE);

W9x_NT_NCONN_THUNK (HRESULT,
                    RemoveClient,
                    (LPCWSTR pszClient),
                    (pszClient),
                    E_FAIL);

W9x_NT_NCONN_THUNK (HRESULT,
                    RemoveGhostedAdapters,
                    (LPCWSTR pszDeviceID),
                    (pszDeviceID),
                    E_FAIL);

W9x_NT_NCONN_THUNK (HRESULT,
                    RemoveUnknownAdapters,
                    (LPCWSTR pszDeviceID),
                    (pszDeviceID),
                    E_FAIL);

W9x_NT_NCONN_THUNK (BOOL,
                    DoesAdapterMatchDeviceID,
                    (const NETADAPTER* pAdapter, LPCWSTR pszDeviceID),
                    (pAdapter, pszDeviceID),
                    FALSE);

W9x_NT_NCONN_THUNK (BOOL,
                    IsAdapterBroadband,
                    (const NETADAPTER* pAdapter),
                    (pAdapter),
                    FALSE);

W9x_NT_NCONN_THUNK_VOID (SaveBroadbandSettings,
                         (LPCWSTR pszBroadbandAdapterNumber),
                         (pszBroadbandAdapterNumber));

W9x_NT_NCONN_THUNK (BOOL,
                    UpdateBroadbandSettings,
                    (LPWSTR pszEnumKeyBuf, int cchEnumKeyBuf),
                    (pszEnumKeyBuf, cchEnumKeyBuf),
                    FALSE);

W9x_NT_NCONN_THUNK_VOID (EnableAutodial,
                         (BOOL bAutodial, LPCWSTR pszConnection),
                         (bAutodial, pszConnection));

W9x_NT_NCONN_THUNK (BOOL,
                    IsAutodialEnabled,
                    (void),
                    (),
                    FALSE);

W9x_NT_NCONN_THUNK_VOID (SetDefaultDialupConnection,
                         (LPCWSTR pszConnectionName),
                         (pszConnectionName));

W9x_NT_NCONN_THUNK_VOID (GetDefaultDialupConnection,
                         (LPWSTR pszConnectionName, int cchMax),
                         (pszConnectionName, cchMax));
                                       
W9x_NT_NCONN_THUNK (int,
                    EnumMatchingNetBindings,
                    (LPCWSTR pszParentBinding, LPCWSTR pszDeviceID, LPWSTR** pprgBindings),
                    (pszParentBinding, pszDeviceID, pprgBindings),
                    0);
                                       
W9x_NT_NCONN_THUNK (HRESULT,
                    RestartNetAdapter,
                    (DWORD devnode),
                    (devnode),
                    E_FAIL);

W9x_NT_NCONN_THUNK (HRESULT,
                    HrFromLastWin32Error,
                    (void),
                    (),
                    E_FAIL);

W9x_NT_NCONN_THUNK (HRESULT,
                    HrWideCharToMultiByte,
                    (const WCHAR* szwString, char** ppszString),
                    (szwString, ppszString),
                    E_FAIL);

W9x_NT_NCONN_THUNK (HRESULT,
                    HrEnableDhcp,
                    (VOID* pContext, DWORD dwFlags),
                    (pContext, dwFlags),
                    E_FAIL);

W9x_NT_NCONN_THUNK (BOOLEAN,
                    IsAdapterDisconnected,
                    (VOID* pContext),
                    (pContext),
                    FALSE);

W9x_NT_NCONN_THUNK (HRESULT,
                    IcsUninstall,
                    (void),
                    (),
                    E_FAIL);

//
// Delay load thunk declarations for internet connection sharing.
//

HINSTANCE g_hicsapi32 = NULL;
HINSTANCE g_hicsapint = NULL;


#define W9x_NT_ICS_THUNK(_ret, _fn, _args, _nargs, _err) \
    W9x_NT_THUNK(g_hicsapi32, icsapi32, g_hicsapint, dontknow, _ret, _fn, _args, _nargs, _err)

W9x_NT_ICS_THUNK(DWORD, IcsEnable, (DWORD dwOptions), (dwOptions), 0);

W9x_NT_ICS_THUNK(DWORD, IcsDisable, (DWORD dwOptions), (dwOptions), 0);

W9x_NT_ICS_THUNK(BOOLEAN, IsIcsEnabled, (), (), FALSE);

W9x_NT_ICS_THUNK(BOOLEAN, IsIcsAvailable, (), (), FALSE);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\hnw\wizard\icsapi.h ===
/******************************************************************************
 **
 **  Copyright (c) 1998-1999  Microsoft Corporation
 **
 **  Module Name:
 **
 **      icsapi.h
 **
 **  Abstract:
 **
 **      External header for Internet Connection Sharing API module
 **
 **  Author:
 **
 **      Bruce Johnson (bjohnson)
 **
 **
 **  Environment:
 **
 **      Win32.
 **
 **  Revision History:
 **
 **  Date     Author     Comments    
 **  -------- ---------- ----------------------------------------------------
 **  03/08/99 bjohnson   Created
 **
 ****************************************************************************/

//****************************************************************************
// Defines
//****************************************************************************

//
// ICSAPI32 parameters 
//


//****************************************************************************
// ICS Return Codes
//****************************************************************************

#define ICS_ERROR_SUCCESS               0x00000000
#define ICS_ERROR_FAILURE               0x80000001
#define ICS_ERROR_NOT_IMPLEMENTED       0x80000002
#define ICS_ERROR_NO_MEMORY             0x80000003
#define ICS_ERROR_INVALID_OPTION        0x80000004
#define ICS_ERROR_INVALID_PARAMETER     0x80000005

//****************************************************************************
// Options for IcsSetMapping
//****************************************************************************
#define ICS_PORTMAP_ENABLE                  1
#define ICS_PORTMAP_DISABLE                 2
#define ICS_PORTMAP_DISABLE_ALL             3
#define ICS_PORTMAP_ENABLE_NON_PERSISTENT   4

//****************************************************************************
// Options for IcsDisconnect
//****************************************************************************
#define ICS_DISCONNECT_IMMEDIATELY          0
#define ICS_DISCONNECT_IF_IDLE              1

//****************************************************************************
// Connect status
//****************************************************************************
#define ICS_CONN_STATUS_DISCONNECTED        0
#define ICS_CONN_STATUS_DIALING             1
#define ICS_CONN_STATUS_AUTHENTICATING      2
#define ICS_CONN_STATUS_CONNECTED           3
#define ICS_CONN_STATUS_LINE_IDLE           4

//****************************************************************************
// Autodial configuration
//****************************************************************************
#define ICS_AUTODIAL_OPT_NONE           0x00000000  // No options
#define ICS_AUTODIAL_OPT_NEVER          0x00000001  // Never Autodial
#define ICS_AUTODIAL_OPT_ALWAYS         0x00000002  // Autodial regardless
#define ICS_AUTODIAL_OPT_DEMAND         0x00000004  // Autodial on demand

//****************************************************************************
// Ip Information options
//****************************************************************************
#define ICS_IP_OPT_NONE                 0x00000000  // No options
#define ICS_IP_OPT_ENABLE_DHCP          0x00000001  // Enable DHCP

//****************************************************************************
// Miscellaneous
//****************************************************************************
#define ICS_MAX_NAME          255
#define ICS_MAX_PORTKEY       255
#define ICS_MAX_INDEX         255
#define ICS_MAX_STRING        1024
#define ICS_DISABLED          0
#define ICS_ENABLED           1

//****************************************************************************
// Typedefs
//****************************************************************************

//
// ICS Machine Information
//

typedef struct  _ICS_MACHINE_INFO {
    char   szName[ICS_MAX_NAME+1];
    BYTE   bMacAddress[6];
    DWORD  IpAddress;
    DWORD  dwLeaseTime;
    DWORD  dwOptions;
  
} ICS_MACHINE_INFO, *PICS_MACHINE_INFO, *LPICS_MACHINE_INFO;

//
// ICS Client Options
//

typedef struct  _ICS_CLIENT_OPTIONS {
     char   szName[ICS_MAX_NAME+1];
     DWORD  dwOptions;

} ICS_CLIENT_OPTIONS, *PICS_CLIENT_OPTIONS, *LPICS_CLIENT_OPTIONS;

//
// ICS Port Mapping
//

typedef struct  _ICS_PORT_MAPPING {
     char   szName[ICS_MAX_NAME+1];
     char   szPortMapping[ICS_MAX_PORTKEY+1];
     DWORD  dwOptions;

} ICS_PORT_MAPPING, *PICS_PORT_MAPPING, *LPICS_PORT_MAPPING;


//
// ICS Active Port Mapping
//

typedef struct _ICS_ACTIVE_PORT_MAPPING {
    ICS_PORT_MAPPING PortMap;
    ICS_MACHINE_INFO Client;

} ICS_ACTIVE_PORT_MAPPING, *PICS_ACTIVE_PORT_MAPPING, *LPICS_ACTIVE_PORT_MAPPING;


//
// ICS Adapter Information
//

typedef struct  _ICS_ADAPTER {
    char   szAdapterName[ICS_MAX_NAME+1];
    char   szAdapterIndex[ICS_MAX_INDEX+1];

} ICS_ADAPTER, *PICS_ADAPTER, *LPICS_ADAPTER;


//
// ICS IP Information
//

typedef struct _ICS_IP_INFORMATION {
    DWORD   dwOptions;
    char    szIPAddress[ICS_MAX_STRING];
    char    szIPMask[ICS_MAX_STRING];
    char    szDefaultGateway[ICS_MAX_STRING];
    char    szDNSServerPrimary[ICS_MAX_STRING];
    char    szDNSServerSecondary[ICS_MAX_STRING];
    char    szHostName[ICS_MAX_STRING];
    char    szDomainName[ICS_MAX_STRING];
    char    szDomainSuffixSearchList[ICS_MAX_STRING];
} ICS_IP_INFORMATION, *PICS_IP_INFORMATION, *LPICS_IP_INFORMATION;



//
// ICS General Statistics
//

typedef struct  _ICS_GENERAL_STATISTICS {
    DWORD   dwBytesSent;
    DWORD   dwBytesReceived;
    DWORD   dwActiveClients;
    DWORD   dwActivePortMappings;
    DWORD   dwUpTime;
    DWORD   dwStatusFlags;
    char    szAutodialMachine [ICS_MAX_NAME+1];

} ICS_GENERAL_STATISTICS, *PICS_GENERAL_STATISTICS, *LPICS_GENERAL_STATISTICS;

//
// ICS General Configuration
//

typedef struct  _ICS_GENERAL_CONFIGURATION {
    DWORD  dwEnabled;
    DWORD  dwShowTrayIcon;
    DWORD  dwDHCPEnabled;
    DWORD  dwDNSEnabled;
    DWORD  dwLoggingEnabled;
    DWORD  dwDHCPSubnet;
    DWORD  dwDHCPServerAddress;
    DWORD  dwOptions;
    DWORD  dwAutodialEnabled;
    DWORD  dwAutodialTimeout;
    char   szAutodialConnection [ICS_MAX_NAME+1];
    char   szInternetAdapter [ICS_MAX_INDEX+1];
    char   szHomeNetworkAdapter [ICS_MAX_INDEX+1];

} ICS_GENERAL_CONFIGURATION, *PICS_GENERAL_CONFIGURATION, *LPICS_GENERAL_CONFIGURATION;

typedef struct _ICS_GENERAL_CONFIGURATION ICS_CONFIG, *PICS_CONFIG, *LPICS_CONFIG;


typedef enum {
    ICS_MSG_CONNECT_STATUS_CHANGE,
    ICS_MSG_ICS_STATUS_CHANGE,
} ICS_MESSAGE_TYPE;

typedef struct 
{
    DWORD       dwConnectStatus;
    DWORD       dwLastError;
} ICS_MSG_CONNECT_STATUS_CHANGE_INFO;

typedef struct
{
    DWORD       dwIcsStatus;
} ICS_MSG_ICS_STATUS_CHANGE_INFO;

typedef struct _ICS_MESSAGE {
    ICS_MESSAGE_TYPE    Type;
    union
    {
        ICS_MSG_CONNECT_STATUS_CHANGE_INFO  IcsConnectStatusChangeInfo;
        ICS_MSG_ICS_STATUS_CHANGE_INFO      IcsStatusChangeInfo;
    } MsgSpecific;
} ICS_MESSAGE, *LPICS_MESSAGE;

#define IM_dwConnectStatus  MsgSpecific.IcsConnectStatusChangeInfo.dwConnectStatus
#define IM_dwLastError      MsgSpecific.IcsConnectStatusChangeInfo.dwLastError
#define IM_dwIcsStatus      MsgSpecific.IcsStatusChangeInfo.dwIcsStatus

typedef VOID (WINAPI *ICS_MSG_NOTIFIER_FN)(LPICS_MESSAGE pIcsMsg);

//****************************************************************************
//
// Prototypes
//
//****************************************************************************


//****************************************************************************
// Configuration API's
//****************************************************************************


DWORD APIENTRY 
IcsGetConfiguration(
    LPICS_CONFIG lpIcsConfig
    );


DWORD APIENTRY 
IcsSetConfiguration(
    LPICS_CONFIG lpIcsConfig
    );


DWORD APIENTRY 
IcsGetAdapterList(
    LPICS_ADAPTER lpIcsAdapterList, 
    LPDWORD lpdwBufferSize
    );


DWORD APIENTRY 
IcsGetIpInformation(
    LPICS_ADAPTER lpIcsAdapter, 
    LPICS_IP_INFORMATION lpIcsIpInformation 
    );

DWORD APIENTRY 
IcsSetIpInformation(
    LPICS_ADAPTER lpIcsAdapter, 
    LPICS_IP_INFORMATION lpIcsIpInformation 
    );

DWORD APIENTRY 
IcsSetInternetConnection(
    LPICS_ADAPTER lpIcsAdapter
    );


DWORD APIENTRY 
IcsSetHomenetConnection(
    LPICS_ADAPTER lpIcsAdapter
    );


DWORD APIENTRY 
IcsEnumerateInstalledMappings(
    LPICS_PORT_MAPPING lpIcsPortMappings,
    LPDWORD lpdwBufferSize
    );

DWORD APIENTRY 
IcsGetAutodialEnable(
    LPDWORD lpdwOpt
    );

//****************************************************************************
// Management API's
//****************************************************************************

BOOLEAN APIENTRY 
IsIcsInstalled(
    VOID         
    );


BOOLEAN APIENTRY 
IsIcsAvailable(
    VOID         
    );


BOOLEAN APIENTRY 
IsIcsEnabled(
    VOID         
    );


DWORD APIENTRY 
IcsConnect(
    LPSTR                 lpszPhonebook,
    BOOL                  Synchronous
    );


DWORD APIENTRY
IcsDisconnect(
    DWORD                 dwOptions
    );


DWORD APIENTRY 
IcsEnable(
    DWORD                 dwOptions
    );


DWORD APIENTRY 
IcsDisable(
    DWORD                 dwOptions
    );


DWORD APIENTRY 
IcsGetStatistics(
    LPICS_GENERAL_STATISTICS  lpIcsGeneralStats
    );

DWORD APIENTRY 
Remote_IcsGetStatistics(
    LPICS_GENERAL_STATISTICS  lpIcsGeneralStats
    );


DWORD APIENTRY 
IcsEnumerateClients(
    LPICS_MACHINE_INFO    lpIcsClients, 
    LPDWORD               lpdwBufferSize
    );


DWORD APIENTRY 
IcsEnumerateActiveMappings(
    LPICS_ACTIVE_PORT_MAPPING   lpIcsActiveMappings, 
    LPDWORD                     lpdwBufferSize
    );


DWORD APIENTRY 
IcsSetMapping(
    LPICS_MACHINE_INFO    lpIcsClient,  
    LPICS_PORT_MAPPING    lpIcsPortMap, 
    DWORD                 dwOptions
    );


DWORD APIENTRY 
IcsGetClientOptions(
    LPICS_MACHINE_INFO    lpIcsClient,
    LPICS_CLIENT_OPTIONS  lpIcsClientOptions
    );


DWORD APIENTRY 
IcsSetClientOptions(
    LPICS_MACHINE_INFO    lpIcsClient,
    LPICS_CLIENT_OPTIONS  lpIcsClientOptions
    );

DWORD APIENTRY 
IcsGetConnectStatus(
    LPDWORD                 lpdwConnectStatus,
    LPDWORD                 lpdwLastError
    );


DWORD APIENTRY    
IcsRegisterNotifierCallback(
    LPVOID  fnNotifier,
    DWORD   Options
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\hnw\wizard\icsinst.h ===
//
// ICSInst.h
//

#include <netcon.h>

#pragma once


// Public functions
//
BOOL IsOtherNATAlreadyInstalled(LPTSTR pszOtherNatDescription, int cchOtherNatDescription);


typedef enum
{
    ICS_NOACTION = 0,
    ICS_INSTALL,
    ICS_UNINSTALL,
    ICS_ENABLE,
    ICS_DISABLE,
    ICS_UPDATEBINDINGS,
    ICS_CLIENTSETUP
} ICSOPTION;

class CICSInst
{
public:
    CICSInst();
    ~CICSInst();
    BOOL InitICSAPI();

    ICSOPTION       m_option;
    LPTSTR          m_pszHostName;
    BOOL            m_bInstalledElsewhere;
    BOOL            m_bShowTrayIcon;

    void DoInstallOption(BOOL* pfRebootRequired, UINT ipaInternal);
    void Install(BOOL* pfRebootRequired, UINT ipaInternal);
    void UpdateBindings(BOOL* pfRebootRequired, UINT ipaInternal);
    void Uninstall(BOOL* pfRebootRequired);
    BOOL IsInstalled();
    BOOL IsEnabled();
    BOOL IsInstalledElsewhere();
    void SetInternetConnection();
    BOOL GetICSConnections(LPTSTR szExternalConnection, LPTSTR szInternalConnection);
    void SetHomeConnection(UINT ipaInternal);
    BOOL IsHomeConnectionValid();
    BOOL Enable();
    BOOL Disable();
    void SetupClient();

private:
    void UpdateIcsTrayIcon();

};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\hnw\wizard\icsinst.cpp ===
//
// ICSInst.cpp
//
//        ICS (Internet Connection Sharing) installation functions and thunk
//        layer.
//
// History:
//
//         9/27/1999  RayRicha  Created
//        11/01/1999  KenSh     Store function ptrs in array rather than globals
//        12/09/1999  KenSh     Check for 3rd party NATs
//

#include "stdafx.h"
#include "ICSInst.h"
#include "TheApp.h"
#include "Config.h"
#include "DefConn.h"
#include "NetConn.h"
#include "Util.h"
#include "netapi.h"
extern "C" {
#include "icsapi.h"
}

// these are the Command Line parameters to CreateProcess for running a first time install and a reconfig
static const TCHAR c_szUpdateDriverBindings[] = _T("rundll.exe ISSETUP.DLL,UpdateDriverBindings");
static const TCHAR c_szInstallICS[] = _T("rundll.exe ISSETUP.DLL,InstallOptionalComponent ICS");
static const TCHAR c_szUninstall[] = _T("rundll.exe ISSETUP.DLL,ExtUninstall");
static const TCHAR c_szICSSettingsKey[] = _T("System\\CurrentControlSet\\Services\\ICSharing\\Settings\\General");
static const TCHAR c_szICSInt[] = _T("System\\CurrentControlSet\\Services\\ICSharing\\Settings\\General\\InternalAdapters");
static const TCHAR c_szInternalAdapters[] = _T("InternalAdapters");
static const TCHAR c_szRunServices[] = _T("Software\\Microsoft\\Windows\\CurrentVersion\\RunServices");
#define c_szIcsRegVal_ShowTrayIcon        _T("ShowTrayIcon")

#define SZ_UNINSTALL_KEY  _T("Software\\Microsoft\\Windows\\CurrentVersion\\Uninstall")


static void (PASCAL FAR * g_pfInstallOptionalComponent)(HWND, HINSTANCE, LPSTR, int);       
HHOOK g_hSupressRebootHook = NULL;

//////////////////////////////////////////////////////////////////////////////
// Helper functions

BOOL RunNetworkInstall(BOOL* pfRebootRequired)
{
    PROCESS_INFORMATION ProcessInfo;
    STARTUPINFO         si;
    DWORD               dwExitCode = 0xffffffffL;
    BOOL                fSuccess;

    memset((char *)&si, 0, sizeof(si));
    si.cb = sizeof(si);
    si.wShowWindow = SW_SHOW;

    fSuccess = CreateProcess(NULL, (LPTSTR)c_szUpdateDriverBindings, NULL, NULL, FALSE, 
                             0, NULL, NULL, &si, &ProcessInfo);

    if (fSuccess) 
    {
        HANDLE hProcess = ProcessInfo.hProcess;

        CloseHandle(ProcessInfo.hThread);

        //
        // wait for update driver bindings to complete
        //

        WaitForSingleObject(hProcess, INFINITE);

        GetExitCodeProcess(hProcess, &dwExitCode);
        CloseHandle(hProcess);

        *pfRebootRequired = TRUE;
        return TRUE;
    }
    return FALSE;
}

// check for 3rd party NATs - returns TRUE if any are installed
BOOL IsOtherNATAlreadyInstalled(LPTSTR pszOtherNatDescription, int cchOtherNatDescription)
{
    BOOL bRet = FALSE;

    CRegistry reg;
    LPCTSTR pszUninstallKey = NULL;

    if (reg.OpenKey(HKEY_LOCAL_MACHINE, c_szRunServices, KEY_READ))
    {
        if (0 != reg.GetValueSize(_T("SyGateService")))
        {
            bRet = TRUE;
            pszUninstallKey = _T("SyGate");
        }
        else if (0 != reg.GetValueSize(_T("WinGate Service")))
        {
            bRet = TRUE;
            pszUninstallKey = _T("WinGate");
        }
        else if (0 != reg.GetValueSize(_T("ENSApServer"))) // Intel AnyPoint
        {
            bRet = TRUE;
            pszUninstallKey = _T("Intel AnyPoint Network Software");
        }
        else if (0 != reg.GetValueSize(_T("WinNATService"))) // Diamond HomeFree
        {
            bRet = TRUE;
            pszUninstallKey = _T("WinNAT");
        }
    }

    // WinProxy has to be launched manually, and requires a static IP.  Just check
    // to see if it's installed - the user might not even be running it.
    //
    if (reg.OpenKey(HKEY_LOCAL_MACHINE, SZ_UNINSTALL_KEY _T("\\WinProxy"), KEY_READ))
    {
        bRet = TRUE;
        pszUninstallKey = _T("WinProxy");
    }

    if (pszOtherNatDescription != NULL)
    {
        *pszOtherNatDescription = _T('\0');

        if (bRet) // Get the friendly name of the conflicting service from uninstall key
        {
            if (reg.OpenKey(HKEY_LOCAL_MACHINE, SZ_UNINSTALL_KEY, KEY_READ))
            {
                if (reg.OpenSubKey(pszUninstallKey, KEY_READ))
                {
                    reg.QueryStringValue(_T("DisplayName"), pszOtherNatDescription, cchOtherNatDescription);
                }
            }
        }
    }

    return bRet;
}


//////////////////////////////////////////////////////////////////////////////
// CICSInst

CICSInst::CICSInst()
{
    m_option = ICS_NOACTION;
    m_pszHostName = theApp.LoadStringAlloc(IDS_ICS_HOST);
    m_bInstalledElsewhere = FALSE;

    m_bShowTrayIcon = TRUE;
    CRegistry reg;
    if (reg.OpenKey(HKEY_LOCAL_MACHINE, c_szICSSettingsKey, KEY_READ))
    {
        TCHAR szTrayIcon[10];
        if (reg.QueryStringValue(c_szIcsRegVal_ShowTrayIcon, szTrayIcon, _countof(szTrayIcon)))
        {
            if (!StrCmp(szTrayIcon, _T("0")))
            {
                m_bShowTrayIcon = FALSE;
            }
        }
    }
}

CICSInst::~CICSInst()
{
    free(m_pszHostName);
}

BOOL
CICSInst::InitICSAPI()
{
    return TRUE;
}

// UpdateIcsTrayIcon
//
//        Updates the registry values that affect the ICS tray icon, and
//        immediately updates the icon to reflect the new values.
//
//         2/04/2000  KenSh     Created
//
void CICSInst::UpdateIcsTrayIcon()
{
    CRegistry reg;
    if (reg.CreateKey(HKEY_LOCAL_MACHINE, c_szICSSettingsKey))
    {
        // Update the tray icon setting in the registry
        TCHAR szVal[2];
        szVal[0] = m_bShowTrayIcon ? _T('1') : _T('0');
        szVal[1] = _T('\0');
        reg.SetStringValue(c_szIcsRegVal_ShowTrayIcon, szVal);
    }

    // Show or hide the icon immediately 
    HWND hwndTray = ::FindWindow(_T("ICSTrayWnd"), NULL);
    if (hwndTray != NULL)
    {
        // Post a custom message to the ICS manager window (icshare\util\icsmgr\trayicon.c)
        //
        // This message shows or hides the tray icon according to the value in
        // the registry.
        //
        // wParam: enable/disable accordint to value in registry
        // lParam: unused
        //
        UINT uUpdateMsg = RegisterWindowMessage(_T("ICSTaskbarUpdate"));
        PostMessage(hwndTray, uUpdateMsg, FALSE, 0L);
    }
}

void CICSInst::DoInstallOption(BOOL* pfRebootRequired, UINT ipaInternal)
{
    BOOL bIcsInstalled = ::IsIcsInstalled();

    // Force uninstall if internal or external NIC is not valid
    if ((m_option == ICS_UNINSTALL && TRUE == bIcsInstalled)|| 
        (bIcsInstalled && m_option == ICS_NOACTION && !this->IsInstalled()))
    {
        Uninstall(pfRebootRequired);
        bIcsInstalled = FALSE;
    }

    // Force tray icon to show up, if ICS is currently installed
    m_bShowTrayIcon = TRUE;
    UpdateIcsTrayIcon();

    switch (m_option)
    {
    case ICS_INSTALL:
        if(FALSE == IsInstalled())
        {
            Install(pfRebootRequired, ipaInternal);
        }
        break;

    case ICS_UPDATEBINDINGS:
        UpdateBindings(pfRebootRequired, ipaInternal);
        break;

    case ICS_UNINSTALL:
        // Already handled above
        break;

    case ICS_ENABLE:
        Enable();
        break;

    case ICS_DISABLE:
        Disable();
        break;

    case ICS_CLIENTSETUP:
        SetupClient();
        break;

    case ICS_NOACTION:
        break;

    }
}

// Similar steps from here as Win98SE ConfigureICS (without UI)
void CICSInst::UpdateBindings(BOOL* pfRebootRequired, UINT ipaInternal)
{
    CConfig rghConfig;

    // TODO: remove hardcoded values!
    StrCpy(rghConfig.m_HangupTimer, _T("300"));

    SetInternetConnection();
    SetHomeConnection(ipaInternal);

    // REVIEW: is there a case where these values should be set differently?
    rghConfig.m_EnableICS = TRUE;
    rghConfig.m_EnableDialOnDemand = TRUE;
    rghConfig.m_EnableDHCP = TRUE;
    rghConfig.m_ShowTrayIcon = m_bShowTrayIcon;

    rghConfig.InitWizardResult();
    // Set to TRUE until we see a need to differentiate between new install and update
    rghConfig.WriteWizardCode(TRUE);

    int iSaveStatus = rghConfig.SaveConfig();

    // TODO: determine if we need to check for binding changes
    //if ( iSaveStatus == BINDINGS_NEEDED )
    //{
    RunNetworkInstall(pfRebootRequired);
    //}
}

void CICSInst::Install(BOOL* pfRebootRequired, UINT ipaInternal)
{
    PROCESS_INFORMATION ProcessInfo;
    STARTUPINFO         si;
    BOOL                fSuccess;

    // Check for conflicting 3rd party NAT
    {
        TCHAR szConflictingNAT[260];
        if (IsOtherNATAlreadyInstalled(szConflictingNAT, _countof(szConflictingNAT)))
        {
            if (szConflictingNAT[0] == _T('\0'))
            {
                LPTSTR pszDefault1 = theApp.LoadStringAlloc(IDS_OTHERNAT_GENERIC);
                LPTSTR pszDefault2 = theApp.LoadStringAlloc(IDS_OTHERNAT_GENERIC_THE);
                if (pszDefault1 && pszDefault2)
                    theApp.MessageBoxFormat(MB_ICONEXCLAMATION | MB_OK, IDS_ERR_OTHERNAT, pszDefault1, pszDefault2);
                free(pszDefault2);
                free(pszDefault1);
            }
            else
            {
                theApp.MessageBoxFormat(MB_ICONEXCLAMATION | MB_OK, IDS_ERR_OTHERNAT, szConflictingNAT, szConflictingNAT);
            }

            return; // block ICS installation
        }
    }

    ZeroMemory(&si, sizeof(si));
    si.cb = sizeof(si);
    si.wShowWindow = SW_SHOW;

    fSuccess = CreateProcess(NULL, (LPTSTR)c_szInstallICS, NULL, NULL, FALSE,
                    0, NULL, NULL, &si, &ProcessInfo);
    if (fSuccess) 
    {
        HANDLE hProcess = ProcessInfo.hProcess;
        CloseHandle(ProcessInfo.hThread);

        //
        // wait for update driver bindings to complete
        //

        WaitForSingleObject(hProcess, INFINITE);

        CloseHandle(hProcess);
        UpdateBindings(pfRebootRequired, ipaInternal);

        // Need to reboot
        *pfRebootRequired = TRUE;
    }
}

LRESULT CALLBACK SupressRebootDialog(int nCode, WPARAM wParam, LPARAM lParam)
{
    LRESULT lResult = 0;
    if (nCode == HCBT_CREATEWND)
    {
        HWND hwnd = (HWND)wParam;
        CBT_CREATEWND* pCW = (CBT_CREATEWND*)lParam;

        LPCREATESTRUCT pCreateStruct = pCW->lpcs;
        
        
        lResult = 1; // prevent window creation   
    }
    else
    {
        lResult = CallNextHookEx(g_hSupressRebootHook, nCode, wParam, lParam);
    }

    return lResult;
    
}

void CICSInst::Uninstall(BOOL* pfRebootRequired)
{
    g_hSupressRebootHook = SetWindowsHookEx(WH_CBT, SupressRebootDialog, NULL, GetCurrentThreadId()); // not thread safe, should be OK
    
    IcsUninstall();
    
    if(NULL != g_hSupressRebootHook)
    {
        UnhookWindowsHookEx(g_hSupressRebootHook );
    }

    *pfRebootRequired = TRUE;

    return;
}

BOOL CICSInst::IsInstalled()
{
    // Make sure ICS is installed correctly by checking Internet and Home connection.
    return (IsIcsInstalled() && GetICSConnections(NULL, NULL) && IsHomeConnectionValid());
}

BOOL CICSInst::IsEnabled()
{
    return IsIcsEnabled();
}

BOOL CICSInst::IsInstalledElsewhere()
{
    if (m_bInstalledElsewhere || IsIcsAvailable())
    {
        //MessageBox(theApp.m_hWndMain, "IsIcsAvailable returned TRUE", "Test", MB_OK);

        // Note: if we knew the name of the ICS host, here's where we'd set m_pszHostName.

        return TRUE;
    }
    else
    {
        //MessageBox(theApp.m_hWndMain, "IsIcsAvailable returned FALSE", "Test", MB_OK);
        return FALSE;
    }
} 

void CICSInst::SetInternetConnection()
{
    /*
    if (-1 != theApp.m_uExternalAdapter)
    {
        TCHAR szClassKey[MAX_KEY_SIZE];
        StrCpy(szClassKey, FindFileTitle(theApp.m_pCachedNetAdapters[theApp.m_uExternalAdapter].szClassKey));

        CRegistry reg;
        reg.OpenKey(HKEY_LOCAL_MACHINE, c_szICSSettingsKey);
        reg.SetStringValue(_T("ExternalAdapter"), szClassKey);
        reg.SetStringValue(_T("ExternalAdapterReg"), szClassKey);
    }
    */
}

BOOL CICSInst::GetICSConnections(LPTSTR szExternalConnection, LPTSTR szInternalConnection)
{
    CRegistry reg;
    TCHAR szEntry[10];
    if (reg.OpenKey(HKEY_LOCAL_MACHINE, c_szICSSettingsKey, KEY_READ))
    {
        if (reg.QueryStringValue(_T("ExternalAdapterReg"), szEntry, _countof(szEntry)) &&
            lstrlen(szEntry))
        {
            if (szExternalConnection)
            {
                StrCpy(szExternalConnection, szEntry);
            }

            if (reg.QueryStringValue(_T("InternalAdapterReg"), szEntry, _countof(szEntry)) &&
                lstrlen(szEntry))
            {
                if (szInternalConnection)
                {
                    StrCpy(szInternalConnection, szEntry);
                }
                return TRUE;
            }
        }

    }
    return FALSE;
}

void CICSInst::SetHomeConnection(UINT ipaInternal)
{
    int cInternalAdapter = 0; // hack for one adapter
    TCHAR szNumber[5];
    wnsprintf(szNumber, ARRAYSIZE(szNumber), TEXT("%04d"), cInternalAdapter); 
    
    const NETADAPTER* pAdapterArray;
    EnumCachedNetAdapters(&pAdapterArray);
    const NETADAPTER* pAdapter = &pAdapterArray[ipaInternal];
    
    TCHAR szClassKey[MAX_KEY_SIZE];
    StrCpy(szClassKey, FindFileTitle((LPCTSTR)pAdapter->szClassKey));

    LPTSTR* prgBindings;
    int cBindings = EnumMatchingNetBindings(pAdapter->szEnumKey, SZ_PROTOCOL_TCPIP, (LPWSTR**)&prgBindings);
    
    CRegistry reg2(HKEY_LOCAL_MACHINE, c_szICSInt);
    reg2.CreateSubKey(szNumber);
    reg2.SetStringValue(_T("InternalAdapterReg"), szClassKey);
    reg2.SetStringValue(_T("InternalAdapter"), szClassKey);
    
    // Assume that adapter is only bound to one TCP/IP instance
    reg2.SetStringValue(_T("InternalBinding"), prgBindings[0]);

    TCHAR szIPAddress[30];
    wnsprintf(szIPAddress, ARRAYSIZE(szIPAddress), TEXT("192.168.%d.1,255.255.255.0"), cInternalAdapter);
    reg2.SetStringValue(_T("IntranetInfo"), szIPAddress);
    
    // TODO: remove
    // Put the first adapter in the "old location" to support legacy config
    CRegistry reg;
    reg.OpenKey(HKEY_LOCAL_MACHINE, c_szICSSettingsKey);
    reg.DeleteSubKey(c_szInternalAdapters);
    reg.CreateSubKey(c_szInternalAdapters);

    reg.OpenKey(HKEY_LOCAL_MACHINE, c_szICSSettingsKey);
    reg.SetStringValue(_T("InternalAdapterReg"), szClassKey);
    reg.SetStringValue(_T("InternalAdapter"), szClassKey);
    
    // Assume that adapter is only bound to one TCP/IP instance
    reg.SetStringValue(_T("InternalBinding"), prgBindings[0]);
    reg.SetStringValue(_T("IntranetInfo"), szIPAddress);
}

// TODO: expand with support for multiple adapters
BOOL CICSInst::IsHomeConnectionValid()
{
    CRegistry reg;
    TCHAR szEntry[10];
    if (reg.OpenKey(HKEY_LOCAL_MACHINE, c_szICSSettingsKey, KEY_READ))
    {
        if (reg.QueryStringValue(_T("InternalAdapterReg"), szEntry, _countof(szEntry)) &&
            lstrlen(szEntry))
        {
            return TRUE;
        }
        else
        {
            // Check for valid multiple-adapter scenario
            if (reg.OpenKey(HKEY_LOCAL_MACHINE, c_szICSInt) &&
                reg.OpenSubKey(_T("0000")) &&
                reg.QueryStringValue(_T("InternalAdapterReg"), szEntry, _countof(szEntry)) &&
                lstrlen(szEntry))
            {
                return TRUE;
            }
        }
    }
    return FALSE;
}

BOOL CICSInst::Enable()
{
    if (InitICSAPI())
    {
        IcsEnable(0);
        return TRUE;
    }
    else
    {
        return FALSE;
    }
//    return (!IcsEnable(0));
}

BOOL CICSInst::Disable()
{
    if (InitICSAPI())
    {
        IcsDisable(0);
        return TRUE;
    }
    else
    {
        return FALSE;
    }
//    return (!IcsDisable(0));
}

void CICSInst::SetupClient()
{
    // Move this functionality to WizPages.cpp and Install.cpp for now
    //::SetDefaultDialupConnection(NULL);
}

BOOLEAN APIENTRY IsIcsInstalled(VOID) // API not available on Win98 so implement it here
{
    BOOLEAN fIcsInstalled = FALSE;
    
    HKEY hKey;
    DWORD dwRet = RegOpenKeyEx (HKEY_LOCAL_MACHINE, REGSTR_PATH_RUN, (DWORD)0, KEY_READ, &hKey);
    if (ERROR_SUCCESS == dwRet) 
    {
        
        DWORD dwType;
        char szValue[128];
        DWORD dwSize = sizeof(szValue) / sizeof(char);
        
        dwRet = RegQueryValueExA(hKey, "ICSMGR", NULL, &dwType, reinterpret_cast<LPBYTE>(szValue), &dwSize);
        if ((ERROR_SUCCESS == dwRet) && (dwType == REG_SZ)) 
        {
            fIcsInstalled =  0 == lstrcmpA(szValue, "ICSMGR.EXE"); 
        }
        
        RegCloseKey ( hKey );
    }
    
    return (fIcsInstalled);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\hnw\wizard\install.cpp ===
//
// Install.cpp
//
//        Performs the actual installation work for the Home Networking Wizard.
//

#include "stdafx.h"
#include "Install.h"
#include "NetUtil.h"

CLogFile g_logFile;

void Install_SetWorkgroupName(LPCTSTR pszWorkgroup, BOOL* pfRebootRequired)
{
    g_logFile.Write("Attempting to set workgroup name\r\n");
    TCHAR szOldWorkgroup[LM20_DNLEN + 1];
    GetWorkgroupName(szOldWorkgroup, _countof(szOldWorkgroup));

    if (0 != StrCmpI(szOldWorkgroup, pszWorkgroup))
    {
        if (SetWorkgroupName(pszWorkgroup))
        {
            g_logFile.Write("Workgroup name set: ");
            g_logFile.Write(pszWorkgroup);
            g_logFile.Write("\r\n");
        }
        else
        {
            g_logFile.Write("Set workgroup name failed.\r\n");
        }

        *pfRebootRequired = TRUE;
    }
    else
    {
        g_logFile.Write("Workgroup name is the same as the old one - not setting.\r\n");
    }
}

HRESULT CLogFile::Initialize(LPCSTR pszPath)
{
    HRESULT hr = E_FAIL;
    CHAR szPathExpand[MAX_PATH];

    if (ExpandEnvironmentStringsA(pszPath, szPathExpand, ARRAYSIZE(szPathExpand)))
    {
        _hLogFile = CreateFileA(szPathExpand, GENERIC_WRITE, 0, NULL, CREATE_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL);
        if (INVALID_HANDLE_VALUE != _hLogFile)
        {
            hr = S_OK;
            
            Write(LOGNAMESTRA);
        }
    }

    return hr;
}

HRESULT CLogFile::Write(LPCSTR psz)
{
    HRESULT hr = E_FAIL;

    if (_hLogFile)
    {
        DWORD cbWritten;
        BOOL fSuccess = WriteFile(_hLogFile, psz, lstrlenA(psz), &cbWritten, NULL);
        if (fSuccess)
        {
            hr = S_OK;
        }
    }

    return hr;
}

HRESULT CLogFile::Write(LPCWSTR psz)
{
    CHAR szAnsi[512]; // Assume 512 is enough...
    if (SHUnicodeToAnsi(psz, szAnsi, ARRAYSIZE(szAnsi)))
    {
        return Write(szAnsi);
    }
    
    return E_FAIL;
}

HRESULT CLogFile::Uninitialize()
{
    if (_hLogFile)
    {
        CloseHandle(_hLogFile);
        _hLogFile = NULL;
    }

    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\hnw\wizard\install.h ===
//
// Install.h
//

#pragma once

void Install_SetWorkgroupName(LPCTSTR pszWorkgroup, BOOL* pfRebootRequired);

class CLogFile
{
public:
    HRESULT Initialize(LPCSTR pszPath);
    HRESULT Write(LPCSTR psz);
    HRESULT Write(LPCWSTR psz);
    HRESULT Uninitialize();

protected:
    HANDLE _hLogFile;

};


extern CLogFile g_logFile;
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\hnw\wizard\mydocs.h ===
//
// MyDocs.h
//

#pragma once


extern "C" BOOL APIENTRY NetConn_IsSharedDocumentsShared();
extern "C" void APIENTRY NetConn_CreateSharedDocuments(HWND hwndStub, HINSTANCE hAppInstance, LPSTR pszCmdLine, int nCmdShow);
int GetSharedDocsDirectory(LPTSTR pszPath, BOOL bCreate = FALSE);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\hnw\wizard\mydocs.cpp ===
//
// MyDocs.cpp
//
//        Code to call or simulate CreateSharedDocuments in mydocs.dll
//

#include "stdafx.h"
#include "TheApp.h"
#include "MyDocs.h"
#include "Util.h"
#include "NetUtil.h"
#include "Sharing.h"
#include "unicwrap.h"



extern "C" void APIENTRY CreateSharedDocuments(HWND hwndStub, HINSTANCE hAppInstance, LPSTR pszCmdLine, int nCmdShow);
typedef void (APIENTRY* CREATESHAREDDOCS_PROC)(HWND, HINSTANCE, LPSTR, int);

// Local functions
//
HRESULT MySHGetFolderPath(HWND hwndOwner, int nFolder, HANDLE hToken, DWORD dwFlags, LPTSTR pszPath);


#ifndef CSIDL_COMMON_DOCUMENTS
#define CSIDL_COMMON_DOCUMENTS    0x002e
#endif

#ifndef SHGFP_TYPE_CURRENT
#define SHGFP_TYPE_CURRENT 0
#endif

#define CSIDL_FLAG_CREATE               0x8000        // combine with CSIDL_ value to force create on SHGetSpecialFolderLocation()

#ifndef IID_PPV_ARG
#define IID_PPV_ARG(IType, ppType) IID_##IType, reinterpret_cast<void**>(static_cast<IType**>(ppType))
#define IID_X_PPV_ARG(IType, X, ppType) IID_##IType, X, reinterpret_cast<void**>(static_cast<IType**>(ppType))
#endif


#define DEFINE_GUID_EMBEDDED(name, l, w1, w2, b1, b2, b3, b4, b5, b6, b7, b8) \
        EXTERN_C const GUID name \
                = { l, w1, w2, { b1, b2,  b3,  b4,  b5,  b6,  b7,  b8 } }
DEFINE_GUID_EMBEDDED(CLSID_FolderShortcut_private, 0x0AFACED1,0xE828,0x11D1,0x91,0x87,0xB5,0x32,0xF1,0xE9,0x57,0x5D);


int GetSharedDocsDirectory(LPTSTR pszPath, BOOL bCreate)
{
    *pszPath = TEXT('\0');

    // Try to find the Shared Documents folder the official way...
    HRESULT hr = MyGetSpecialFolderPath(CSIDL_COMMON_DOCUMENTS, pszPath);

    // This version of the OS doesn't know about Common Documents
    if (FAILED(hr))
    {
        // Check for "Common Documents" registry entry
        CRegistry reg;
        if (reg.OpenKey(HKEY_LOCAL_MACHINE, TEXT("Software\\Microsoft\\Windows\\CurrentVersion\\Explorer\\Shell Folders"), KEY_READ))
        {
            if (reg.QueryStringValue(TEXT("Common Documents"), pszPath, MAX_PATH))
            {
                DWORD dwAttrib = GetFileAttributes(pszPath);
                if (dwAttrib != 0xFFFFFFFF && 0 != (dwAttrib & FILE_ATTRIBUTE_DIRECTORY))
                {
                    goto done;
                }
            }
        }

        int nFolder = bCreate ? CSIDL_PERSONAL | CSIDL_FLAG_CREATE : CSIDL_PERSONAL;
        MySHGetFolderPath(NULL, nFolder, NULL, 0, pszPath);

        int cch = lstrlen(pszPath);
        if (cch == 0 || pszPath[cch-1] != '\\')
            pszPath[cch++] = '\\';
        theApp.LoadString(IDS_SHAREDDOCS, pszPath + cch, MAX_PATH - cch);

        if (bCreate)
            CreateDirectory(pszPath, NULL);
    }

done:
    return lstrlen(pszPath);
}

BOOL APIENTRY NetConn_IsSharedDocumentsShared()
{
    BOOL bResult = FALSE;

    TCHAR szSharedDocs[MAX_PATH];
    if (GetSharedDocsDirectory(szSharedDocs))
    {
        DWORD dwAttrib = GetFileAttributes(szSharedDocs);
        if (dwAttrib != 0xFFFFFFFF && (dwAttrib & FILE_ATTRIBUTE_DIRECTORY))
        {
            if (IsFolderShared(szSharedDocs, TRUE))
            {
                bResult = TRUE;
            }
        }
    }

    return bResult;
}

BOOL MyPathRenameExtension(LPTSTR pszPath, LPCTSTR pszExt)
{
    ASSERT(pszExt != NULL && *pszExt == _T('.'));

    LPTSTR pszOldExt = FindExtension(pszPath);
    if (*pszOldExt != _T('\0') || *(pszOldExt-1) == _T('.'))
    {
        pszOldExt--;
    }

    // Check that the new path won't exceed MAX_PATH, including trailing '\0'
    int cch = (int)(pszOldExt - pszPath) + lstrlen(pszExt);
    if (cch >= MAX_PATH - 1)
        return FALSE; // path too long!

    StrCpy(pszOldExt, pszExt);
    return TRUE;
}

HRESULT MySHGetFolderPath(HWND hwndOwner, int nFolder, HANDLE hToken, DWORD dwFlags, LPTSTR pszPath)
{
    ASSERT(hToken == NULL); // not supported
    ASSERT(dwFlags == SHGFP_TYPE_CURRENT); // other flags not supported

    LPITEMIDLIST pidl;
    HRESULT hr;
    int nNakedFolder = (nFolder & ~CSIDL_FLAG_CREATE);

    // Get the full path of the directory in question
    //
    if (nNakedFolder == CSIDL_COMMON_DOCUMENTS) // special-case shared docs
    {
        GetSharedDocsDirectory(pszPath, nFolder & CSIDL_FLAG_CREATE);
        hr = S_OK;
    }
    else if (SUCCEEDED(hr = SHGetSpecialFolderLocation(NULL, nNakedFolder, &pidl)))
    {
        hr = SHGetPathFromIDList(pidl, pszPath) ? S_OK : E_FAIL;
        ILFree(pidl);
    }
    else // folder doesn't exist, handle some special cases
    {
        if (nNakedFolder == CSIDL_PERSONAL)
        {
            GetWindowsDirectory(pszPath, MAX_PATH);
            theApp.LoadString(IDS_MYDOCS, pszPath + 3, MAX_PATH - 3);
            hr = S_OK;
        }
    }

    // Create the directory if needed
    //
    if (SUCCEEDED(hr))
    {
        if (nFolder & CSIDL_FLAG_CREATE)
        {
            if (!DoesFileExist(pszPath))
            {
                if (!CreateDirectory(pszPath, NULL))
                {
                    // Unknown error (could be lots of things, all unlikely)
                    hr = E_FAIL;
                }
            }
        }
    }

    return hr;
}

HRESULT _MakeSharedDocsLink(CLSID clsid, LPCTSTR pszLinkFolder, LPCTSTR pszSharedDocsPath, LPTSTR pszExtension)
{
    TCHAR wszComment[MAX_PATH];
    TCHAR wszName[MAX_PATH];

    theApp.LoadString(IDS_SHAREDDOCSCOMMENT, wszComment, ARRAYSIZE(wszComment));
    theApp.LoadString(IDS_SHAREDDOCS, wszName, ARRAYSIZE(wszName));
    if (pszExtension)
        MyPathRenameExtension(wszName, pszExtension);

    return MakeLnkFile(clsid, pszSharedDocsPath, wszComment, pszLinkFolder, wszName);
}

HRESULT _MakeSharedDocsLink(CLSID clsid, UINT csidl, LPCTSTR pszSharedDocsPath, LPTSTR pszExtension)
{
    TCHAR szPath[MAX_PATH];
    HRESULT hr = MySHGetFolderPath(NULL, csidl | CSIDL_FLAG_CREATE, NULL, 0, szPath);
    if (SUCCEEDED(hr))
    {
        hr = _MakeSharedDocsLink(clsid, szPath, pszSharedDocsPath, pszExtension);
    }
    return hr;
}

#define NET_INFO TEXT("System\\CurrentControlSet\\Services\\VxD\\VNETSUP")

void _GetMachineComment(LPTSTR pszBuffer, int cchBuffer)
{
    pszBuffer[0] = TEXT('\0');            // null the buffer

    // attempt to read the comment for the machine from the registry

    HKEY hk;
    if (ERROR_SUCCESS == RegOpenKey(HKEY_LOCAL_MACHINE, NET_INFO, &hk))
    {
        DWORD dwSize = cchBuffer*sizeof(TCHAR);
        RegQueryValueEx(hk, TEXT("Comment"), NULL, NULL, (BYTE *)pszBuffer, &dwSize);
        RegCloseKey(hk);
    }

    // either that failed, or the user set the comment to NULL, therefore we
    // just read the computer name.

    if ( !pszBuffer[0] )
    {
        DWORD dwSize = cchBuffer;
        GetComputerName(pszBuffer, &dwSize);
    }
}

BOOL MySHSetIniString(LPCTSTR pszSection, LPCTSTR pszEntry, LPCTSTR pszValue, LPCTSTR pszIniFile)
{
    return WritePrivateProfileString(pszSection, pszEntry, pszValue, pszIniFile);
}

BOOL GetShareName(LPTSTR pszName, UINT cchName)
{
    TCHAR szBase[SHARE_NAME_LENGTH+1];
    int cchBase = theApp.LoadString(IDS_SHAREDDOCS_SHARENAME, szBase, _countof(szBase));

    if (cchBase != 0)
    {
        if (!g_fRunningOnNT)
        {
            CharUpper(szBase);
        }
        // Ensure that the share name is unique
        StrCpyN(pszName, szBase, cchName);
        for (int i = 2; IsShareNameInUse(pszName); i++)
        {
        loop_begin:
            // Format name like "Documents2"
            wnsprintf(pszName, cchName, TEXT("%s%d"), szBase, i);

            // Ensure the new name isn't too long (rare rare rare rare!)
            if (lstrlen(pszName) > SHARE_NAME_LENGTH)
            {
                ASSERT(cchBase > 0); // must be true, or string wouldn't be too long

                // REVIEW: this isn't DBCS compliant, but it's such a rare
                // case that I don't really care.
                szBase[--cchBase] = _T('\0');
                goto loop_begin;
            }
        }
    }

    return cchBase != 0;
}

BOOL ShareHelper(LPCTSTR pszPath, LPCTSTR pszShareName, DWORD dwAccess, BYTE bShareType, LPCTSTR pszReadOnlyPassword, LPCTSTR pszFullAccessPassword);

void RenameShare(LPTSTR pszOldName, LPTSTR pszNewName)
{
    SHARE_INFO_502* pShare2;
    if (GetShareInfo502(pszOldName, &pShare2))
    {
        pShare2->shi502_netname = pszNewName;
        SetShareInfo502(pszOldName, pShare2);
        NetApiBufferFree(pShare2);
    }
}

void APIENTRY NetConn_CreateSharedDocuments(HWND hwndStub, HINSTANCE hAppInstance, LPSTR pszCmdLine, int nCmdShow)
{
    // Try to load the real version of this function
    HINSTANCE hInstMyDocs = LoadLibrary(TEXT("mydocs.dll"));
    if (hInstMyDocs != NULL)
    {
        CREATESHAREDDOCS_PROC pfn = (CREATESHAREDDOCS_PROC)GetProcAddress(hInstMyDocs, "CreateSharedDocuments");
        if (pfn != NULL)
        {
            (*pfn)(hwndStub, hAppInstance, pszCmdLine, nCmdShow);
        }

        FreeLibrary(hInstMyDocs);

        if (pfn != NULL)
        {
            if (!g_fRunningOnNT)
            {
                // rename share
                TCHAR szSharedDocs[MAX_PATH];
                GetSharedDocsDirectory(szSharedDocs, TRUE);
                TCHAR szShareName[SHARE_NAME_LENGTH+5];
                if (ShareNameFromPath(szSharedDocs, szShareName, ARRAYSIZE(szShareName)))
                {
                    TCHAR szNewShareName[SHARE_NAME_LENGTH+5];    
                    if (GetShareName(szNewShareName, ARRAYSIZE(szNewShareName)))
                    {
                        RenameShare(szShareName, szNewShareName);
                    }
                }
            }

            return;
        }
    }


    TCHAR szSharedDocs[MAX_PATH];
    GetSharedDocsDirectory(szSharedDocs, TRUE);

    // Save the folder path in the registry
    //
    CRegistry regFolders;
    if (regFolders.CreateKey(HKEY_LOCAL_MACHINE, TEXT("Software\\Microsoft\\Windows\\CurrentVersion\\Explorer\\Shell Folders")))
    {
        regFolders.SetStringValue(TEXT("Common Documents"), szSharedDocs);
        regFolders.CloseKey();
    }


    // stash a desktop.ini in the folder, then when the netcrawler finds this object it will
    // attempt to create the shortcut using this name
    //
    TCHAR szComment[64], szFormat[64], szDesktopIni[MAX_PATH];
    MakePath(szDesktopIni, szSharedDocs, TEXT("desktop.ini"));

    _GetMachineComment(szComment, _countof(szComment));
    theApp.LoadString(IDS_SHARECOMMENT, szFormat, _countof(szFormat));
    LPTSTR pszTemp = theApp.FormatStringAlloc(szFormat, szComment);
    MySHSetIniString(TEXT("FileSharingInformation"), TEXT("ShortcutName"), pszTemp, szDesktopIni);
    free(pszTemp);

    SetFileAttributes(szDesktopIni, FILE_ATTRIBUTE_HIDDEN | FILE_ATTRIBUTE_SYSTEM);     // ensure it's hidden

    // Share the folder
    //
    if (!IsFolderShared(szSharedDocs, TRUE))
    {
        TCHAR szShareName[SHARE_NAME_LENGTH+5];

        if (GetShareName(szShareName, ARRAYSIZE(szShareName)))
        {
            ShareFolder(szSharedDocs, szShareName, NETACCESS_FULL, NULL, NULL);
        }
    }


    // Create shortcut to Shared Docs if it's in another user's MyDocs folder
    //
    TCHAR szMyDocs[MAX_PATH];
    if (SUCCEEDED(MySHGetFolderPath(NULL, CSIDL_PERSONAL | CSIDL_FLAG_CREATE, NULL, 0, szMyDocs)))
    {
        LPTSTR pchTemp = FindFileTitle(szSharedDocs) - 1;
        *pchTemp = TEXT('\0');
        BOOL bMatch = !StrCmpI(szMyDocs, szSharedDocs);
        *pchTemp = TEXT('\\');

        if (!bMatch) // don't create link right next to the folder itself
        {
            _MakeSharedDocsLink(CLSID_ShellLink, szMyDocs, szSharedDocs, TEXT(".lnk"));
        }
    }


    // Create shortcut in SendTo folder
    //
    _MakeSharedDocsLink(CLSID_ShellLink, CSIDL_SENDTO, szSharedDocs, TEXT(".lnk"));
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\hnw\wizard\myprsht.h ===
//
// MyPrSht.h
//

#pragma once
#include "CWnd.h"


// Public functions
//
INT_PTR MyPropertySheet(LPCPROPSHEETHEADER pHeader);
HPROPSHEETPAGE MyCreatePropertySheetPage(LPPROPSHEETPAGE psp);


// CMyPropSheet -- used internally by MyPrSht.cpp
//
class CMyPropSheet : public CWnd
{
public:
    CMyPropSheet();

    void Release() { CWnd::Release(); };
    BOOL Attach(HWND hwnd) {return CWnd::Attach(hwnd); };

    INT_PTR DoPropSheet(LPCPROPSHEETHEADER pHeader);
    LPPROPSHEETPAGE GetCurrentPropSheetPage();

    // Message handler for WM_CTLCOLOR* messages - public so prop pages
    // can call it directly.
    HBRUSH OnCtlColor(UINT message, HDC hdc, HWND hwndControl);

    inline void OnSetActivePage(HWND hwnd)
        { m_hwndActive = hwnd; }
    inline HWND GetActivePage()
        { return m_hwndActive; }

protected:
    ~CMyPropSheet();

    // Virtual function overrides
    LRESULT WindowProc(UINT message, WPARAM wParam, LPARAM lParam);

    // Implementation
    static LRESULT CALLBACK HookProc(int nCode, WPARAM wParam, LPARAM lParam);
    void PaintHeader(HDC hdc, LPPROPSHEETPAGE ppsp);
    void PaintWatermark(HDC hdc, LPPROPSHEETPAGE ppsp);
    void InitColorSettings();
    void LoadBitmaps();

public:
    void SetHeaderFonts();
    int ComputeHeaderHeight(int dxMax);
    int WriteHeaderTitle(HDC hdc, LPRECT prc, LPCTSTR pszTitle, BOOL bTitle, DWORD dwDrawFlags);

protected:
    LPPROPSHEETHEADER   m_pRealHeader;
    HHOOK               m_hHook;
    HBRUSH              m_hbrWindow;
    HBRUSH              m_hbrDialog;
    HWND                m_hwndActive;
    HBITMAP             m_hbmWatermark;
    HBITMAP             m_hbmHeader;
    HPALETTE            m_hpalWatermark;
    HFONT               m_hFontBold;
    int                 m_ySubTitle;
};


// Note: we can't subclass from CWnd because the wizard property pages
// are already CWnd's, and we can't have 2 CWnd's for a single HWND.
class CMyPropPage : public CWnd
{
public:
    void Release() { CWnd::Release(); };
    BOOL Attach(HWND hwnd) {return CWnd::Attach(hwnd); };

    static CMyPropPage* FromHandle(HWND hwnd);

    LPPROPSHEETPAGE GetPropSheetPage();

protected:
    LRESULT WindowProc(UINT message, WPARAM wParam, LPARAM lParam);

    LPPROPSHEETPAGE m_ppspOriginal;
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\hnw\wizard\netapi.cpp ===
//
// NetApi.cpp
//
//        Wrapper / helper functions that interface between real net APIs and
//        the Home Networking Wizard.
//
// Revision History:
//
//         9/27/1999  KenSh     Created
//

#include "stdafx.h"
#include "NetConn.h"
#include "NetApi.h"
#include "theapp.h"


NETADAPTER* g_prgCachedAdapters;
int g_cCachedAdapters;


void FlushNetAdapterCache()
{
    NetConnFree(g_prgCachedAdapters);
    g_prgCachedAdapters = NULL;
    g_cCachedAdapters = 0;
}

// Note: do NOT free the array that is returned!
int EnumCachedNetAdapters(const NETADAPTER** pprgAdapters)
{
    if (!theApp.IsWindows9x())
    {
        // Shouldn't be called on NT
        return 0;
    }

    if (g_prgCachedAdapters == NULL)
    {
        // Note: this will be leaked if FlushNetAdapterCache() is not called
        g_cCachedAdapters = EnumNetAdapters(&g_prgCachedAdapters);
    }

    *pprgAdapters = g_prgCachedAdapters;
    return g_cCachedAdapters;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\hnw\wizard\mysvrapi.cpp ===
//
// MySvrApi.cpp
//
//        Thunk layer for SVRAPI.DLL (Win9x and NT)
//
//

#include "stdafx.h"
#include "mysvrapi.h"
#include "TheApp.h"
#include "cstrinout.h"
#include <lm.h>

//
// Conversion classes.
//

class CShareInfo50to502
{
public:
    CShareInfo50to502(LPBYTE* ppBuff) {_ppBuffOut = ppBuff;}
    operator char*()     {return _aBuffIn;}
    USHORT SizeOfBuffer()       {return sizeof(_aBuffIn);}
    BOOL Convert();

protected:
    CShareInfo50to502() {};
    ULONG SizeRequired(const share_info_50* psi50);
    void  CopyData(const share_info_50* psi50, SHARE_INFO_502* psi502, WCHAR** ppsz, ULONG* pcch);

private:
    void  CopyStringAndAdvancePointer(LPCSTR pszSrc, LPWSTR* ppszDst, ULONG* pcch);
    DWORD ConvertPermissions(USHORT shi50_flags);

private:
    BYTE**  _ppBuffOut;
    char    _aBuffIn[sizeof(share_info_50) + 2*MAX_PATH];
};

ULONG CShareInfo50to502::SizeRequired(const share_info_50* psi50)
{
    ULONG cb = sizeof(SHARE_INFO_502);

    cb += sizeof(WCHAR) * MultiByteToWideChar(CP_ACP, 0, psi50->shi50_netname, -1, NULL, 0);
    cb += sizeof(WCHAR) * MultiByteToWideChar(CP_ACP, 0, (psi50->shi50_remark ? psi50->shi50_remark : ""), -1, NULL, 0);
    cb += sizeof(WCHAR) * MultiByteToWideChar(CP_ACP, 0, (psi50->shi50_path ? psi50->shi50_path : ""), -1, NULL, 0);
    cb += sizeof(WCHAR) * MultiByteToWideChar(CP_ACP, 0, psi50->shi50_rw_password, -1, NULL, 0);

    return cb;
}

void CShareInfo50to502::CopyStringAndAdvancePointer(LPCSTR pszSrc, LPWSTR* ppszDst, ULONG* pcch)
{
    int cch = SHAnsiToUnicode(pszSrc, *ppszDst, *pcch);

    *ppszDst += cch;
    *pcch    -= cch;
}

DWORD CShareInfo50to502::ConvertPermissions(USHORT shi50_flags)
{
    DWORD dwRet;

    if (shi50_flags & SHI50F_FULL)
    {
        dwRet = ACCESS_ALL;
    }
    else if (shi50_flags & SHI50F_RDONLY)
    {
        dwRet = ACCESS_READ;
    }
    else
    {
        dwRet = 0;
    }

    return dwRet | SHI50F_PERSIST;
}

void CShareInfo50to502::CopyData(const share_info_50* psi50, SHARE_INFO_502* psi502, WCHAR** ppsz, ULONG* pcch)
{
    psi502->shi502_type = psi50->shi50_type;
    psi502->shi502_permissions = ConvertPermissions(psi50->shi50_flags);
    psi502->shi502_max_uses = 0;
    psi502->shi502_current_uses = 0;
    psi502->shi502_reserved = 0;
    psi502->shi502_security_descriptor = NULL;

    psi502->shi502_netname = *ppsz;
    CopyStringAndAdvancePointer(psi50->shi50_netname, ppsz, pcch);

    psi502->shi502_remark = *ppsz;
    CopyStringAndAdvancePointer(psi50->shi50_remark, ppsz, pcch);

    psi502->shi502_path = *ppsz;
    CopyStringAndAdvancePointer(psi50->shi50_path, ppsz, pcch);

    psi502->shi502_passwd = *ppsz;
    CopyStringAndAdvancePointer(psi50->shi50_rw_password, ppsz, pcch);
}

BOOL CShareInfo50to502::Convert()
{
    ULONG cb = SizeRequired((share_info_50*)_aBuffIn);

    *_ppBuffOut = (BYTE*)LocalAlloc(LPTR, cb);

    if (*_ppBuffOut)
    {
        WCHAR* psz = (WCHAR*)((BYTE*)*_ppBuffOut + sizeof(SHARE_INFO_502));
        ULONG cch  = (cb - sizeof(SHARE_INFO_502)) / sizeof(WCHAR);
        
        CopyData((share_info_50*)_aBuffIn, (SHARE_INFO_502*)*_ppBuffOut, &psz, &cch);
    }

    return (*_ppBuffOut != NULL);
}

//
//
//

class CMultiShareInfo50to502 : public CShareInfo50to502
{
public:
    CMultiShareInfo50to502(BYTE** ppBuff, const char* pData, ULONG nItems);
    BOOL Convert();

private:
    ULONG MultiSizeRequired();
    void MultiCopyData(ULONG cb);

private:
    SHARE_INFO_502**     _ppBuffOut;
    const share_info_50* _pDataIn;
    ULONG  _nItems;
};

CMultiShareInfo50to502::CMultiShareInfo50to502(BYTE** ppBuff, const char* pData, ULONG nItems)
{
    _ppBuffOut = (SHARE_INFO_502**)ppBuff;
    _pDataIn = (share_info_50*)pData;
    _nItems = nItems;
}

ULONG CMultiShareInfo50to502::MultiSizeRequired()
{
    ULONG cbRet = 0;

    for (ULONG i = 0; i < _nItems; i++)
        cbRet += SizeRequired(&_pDataIn[i]);

    return cbRet;
}

void CMultiShareInfo50to502::MultiCopyData(ULONG cb)
{
    WCHAR* psz = (WCHAR*)((BYTE*)*_ppBuffOut + (sizeof(SHARE_INFO_502) * _nItems));
    ULONG cch  = (cb - (sizeof(SHARE_INFO_502) * _nItems)) / sizeof(WCHAR);

    for (ULONG i = 0; i < _nItems; i++)
        CopyData(&_pDataIn[i], &(*_ppBuffOut)[i], &psz, &cch);
}

BOOL CMultiShareInfo50to502::Convert()
{
    ULONG cb = MultiSizeRequired();

    *_ppBuffOut = (SHARE_INFO_502*)LocalAlloc(LPTR, cb);

    if (*_ppBuffOut)
    {
        MultiCopyData(cb);
    }

    return *_ppBuffOut != NULL;
}

//
//
//

class CShareInfo502to50
{
public:
    CShareInfo502to50(BYTE* pBuff) {_pBuffIn = pBuff;}
    operator char*();
    WORD SizeOfBuffer() {return sizeof(_aBuff);}

private:
    void CopyData();
    void CopyStringAndAdvancePointer(LPCWSTR pszSrc, LPSTR* ppszDst, ULONG* pcch);
    WORD ConvertPermissions(DWORD shi502_permissions);

private:
    BYTE* _pBuffIn;
    BYTE  _aBuff[sizeof(share_info_50) + 256];
};

WORD CShareInfo502to50::ConvertPermissions(DWORD shi502_permissions)
{
    WORD wRet;

    if (shi502_permissions & (ACCESS_ALL ^ ACCESS_READ))
    {
        wRet = SHI50F_FULL;
    }
    else if (shi502_permissions & ACCESS_READ)
    {
        wRet = SHI50F_RDONLY;
    }
    else
    {
        wRet = 0;
    }

    return wRet  | SHI50F_PERSIST;  // Always persist share info.
}

void CShareInfo502to50::CopyStringAndAdvancePointer(LPCWSTR pszSrc, LPSTR* ppszDst, ULONG* pcch)
{
    int cch = SHUnicodeToAnsi(pszSrc, *ppszDst, *pcch);

    *ppszDst += cch;
    *pcch    -= cch;
}

void CShareInfo502to50::CopyData()
{
    share_info_50*  psi50  = (share_info_50*)_aBuff;
    SHARE_INFO_502* psi502 = (SHARE_INFO_502*)_pBuffIn;
    char* psz              = (char*)(_aBuff + sizeof(share_info_50));
    ULONG cch              = ARRAYSIZE(_aBuff) - sizeof(share_info_50);

    psi50->shi50_type = (BYTE)psi502->shi502_type;
    psi50->shi50_flags = ConvertPermissions(psi502->shi502_permissions);
    psi50->shi50_ro_password[0] = '\0';


    WideCharToMultiByte(CP_ACP, 0, psi502->shi502_netname, -1, psi50->shi50_netname,
                        ARRAYSIZE(psi50->shi50_netname), NULL, NULL);

    WideCharToMultiByte(CP_ACP, 0, psi502->shi502_passwd, -1, psi50->shi50_rw_password,
                        ARRAYSIZE(psi50->shi50_rw_password), NULL, NULL);

    if (psi502->shi502_remark)
    {
        psi50->shi50_remark = psz;
        CopyStringAndAdvancePointer(psi502->shi502_remark, &psz, &cch);
    }
    else
    {
        psi50->shi50_remark = NULL;
    }

    if (psi502->shi502_path)
    {
        psi50->shi50_path = psz;
        CopyStringAndAdvancePointer(psi502->shi502_path, &psz, &cch);
    }
    else
    {
        psi502->shi502_path = NULL;
    }
}

CShareInfo502to50::operator char*()
{
    char* pRet;

    if (_pBuffIn)
    {
        CopyData();
        pRet = (char*)_aBuff;
    }
    else
    {
        pRet = NULL;
    }

    return pRet;
}

//
//
//
NET_API_STATUS NetShareEnumWrap(LPCTSTR pszServer, DWORD level, LPBYTE * ppBuffer, DWORD dwPrefMaxLen, LPDWORD pdwEntriesRead, LPDWORD pdwTotalEntries, LPDWORD dsResumeHandle)
{
    ASSERTMSG(502==level, "NetShareEnumWrap doesn't thunk the requestesd buffer level");

    NET_API_STATUS nasRet;

    if (!theApp.IsWindows9x())
    {
        nasRet = NetShareEnum_NT((LPWSTR)pszServer, level, ppBuffer, dwPrefMaxLen, pdwEntriesRead, pdwTotalEntries, dsResumeHandle);
    }
    else
    {
        CStrIn cstrServer(pszServer);

        USHORT cb = sizeof(share_info_50) + (2 * MAX_PATH);

        char* pData = (char*)LocalAlloc(LPTR, cb);

        if (pData)
        {
            *pdwEntriesRead = *pdwTotalEntries = 0;

            nasRet = NetShareEnum_W95(cstrServer, 50, pData, cb, (USHORT*)pdwEntriesRead, (USHORT*)pdwTotalEntries);

            if (*pdwEntriesRead < *pdwTotalEntries)
            {
                LocalFree(pData);
                cb = (USHORT)((sizeof(share_info_50) + (2 * MAX_PATH)) * (*pdwTotalEntries));
                pData = (char*)LocalAlloc(LPTR, cb);

                if (pData)
                {
                    nasRet = NetShareEnum_W95(cstrServer, 50, pData, cb, (USHORT*)pdwEntriesRead, (USHORT*)pdwTotalEntries);
                }

            }

            if (NERR_Success == nasRet)
            {
                CMultiShareInfo50to502 cmnsio(ppBuffer, pData, *pdwEntriesRead);

                if (!cmnsio.Convert())
                    nasRet = ERROR_NOT_ENOUGH_MEMORY;
            }

            LocalFree(pData);
        }
        else
        {
            nasRet = ERROR_NOT_ENOUGH_MEMORY;
        }
    }

    return nasRet;
}


NET_API_STATUS NetShareAddWrap(LPCTSTR pszServer, DWORD level, LPBYTE buffer)
{
    ASSERTMSG(502==level, "NetShareAddWrap doesn't thunk the requested buffer level");

    NET_API_STATUS nasRet;

    if (!theApp.IsWindows9x())
    {
        nasRet = NetShareAdd_NT((LPTSTR)pszServer, level, buffer, NULL);
    }
    else
    {
        if (502 == level)
        {
            CStrIn cstrServer(pszServer);
            CShareInfo502to50 CSI(buffer);

            nasRet = NetShareAdd_W95(cstrServer, 50, CSI, sizeof(share_info_50));
        }
        else
        {
            nasRet = ERROR_INVALID_LEVEL;
        }
    }

    return nasRet;
}


NET_API_STATUS NetShareDelWrap(LPCTSTR pszServer, LPCTSTR pszNetName, DWORD reserved)
{
    ASSERTMSG(0==reserved, "NetShareDelWrap called with non-zero reserved parameter");

    NET_API_STATUS nasRet;

    if (!theApp.IsWindows9x())
    {
        nasRet = NetShareDel_NT((LPTSTR)pszServer, (LPTSTR)pszNetName, 0);
    }
    else
    {
        CStrIn cstrServer(pszServer);
        CStrIn cstrNetName(pszNetName);

        nasRet = NetShareDel_W95(cstrServer, cstrNetName, 0);
    }

    return nasRet;
}

NET_API_STATUS NetShareGetInfoWrap(LPCTSTR pszServer, LPCTSTR pszNetName, DWORD level, LPBYTE * ppbuffer)
{
    NET_API_STATUS nasRet;

    if (!theApp.IsWindows9x())
    {
        nasRet = NetShareGetInfo_NT((LPTSTR)pszServer, (LPTSTR)pszNetName, level, ppbuffer);
    }
    else
    {
        if (502==level)
        {
            CShareInfo50to502 CNSIOut(ppbuffer);
            CStrIn cstrServer(pszServer);
            CStrIn cstrNetName(pszNetName);
            USHORT n;

            nasRet = NetShareGetInfo_W95(cstrServer, cstrNetName, 50, CNSIOut, CNSIOut.SizeOfBuffer(), &n);
    
            if (NERR_Success == nasRet)
            {
                if (!CNSIOut.Convert())
                    nasRet = ERROR_NOT_ENOUGH_MEMORY;
            }
        }
        else
        {
            *ppbuffer = NULL;
            nasRet = ERROR_INVALID_LEVEL;
        }
    }

    return nasRet;
}

NET_API_STATUS NetShareSetInfoWrap(LPCTSTR pszServer, LPCTSTR pszNetName, DWORD level, LPBYTE buffer)
{
    NET_API_STATUS nasRet;

    if (!theApp.IsWindows9x())
    {
        nasRet = NetShareSetInfo_NT((LPTSTR)pszServer, (LPTSTR)pszNetName, level, buffer, NULL);
    }
    else
    {
        if (502==level)
        {
            CStrIn cstrServer(pszServer);
            CStrIn cstrNetName(pszNetName);
            CShareInfo502to50 CNSI(buffer);

            nasRet = NetShareSetInfo_W95(cstrServer, cstrNetName, 50, CNSI, sizeof(share_info_50), NULL);
        }
        else
        {
            nasRet = ERROR_INVALID_LEVEL;
        }
    }

    return nasRet;
}

NET_API_STATUS NetApiBufferFreeWrap(LPVOID p)
{
    NET_API_STATUS nasRet;

    if (p)
    {
        if (!theApp.IsWindows9x())
        {
            nasRet = NetApiBufferFree_NT(p);
        }
        else
        {
            LocalFree(p);
            nasRet = NERR_Success;
        }
    }
    else
    {
        nasRet = NERR_Success;
    }

    return nasRet;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\hnw\wizard\mysvrapi.h ===
//
// SvrApi.h
//

#pragma once

// svrapi.h and lmshare.h have some of the same defines,
// so turn off the compile warning for them...
#pragma warning(disable:4005)


EXTERN_C BOOL  AllocateAndInitializeSid_NT(PSID_IDENTIFIER_AUTHORITY pIdentifierAuthority, BYTE nSubAuthorityCount, DWORD dwSubAuthority0, DWORD dwSubAuthority1, DWORD dwSubAuthority2, DWORD dwSubAuthority3, DWORD dwSubAuthority4, DWORD dwSubAuthority5, DWORD dwSubAuthority6, DWORD dwSubAuthority7, PSID *pSid);
EXTERN_C BOOL  CheckTokenMembership_NT(HANDLE TokenHandle, PSID SidToCheck, PBOOL IsMember);
EXTERN_C PVOID FreeSid_NT(PSID SidToFree);

//
// Get the Win9X versions of these apis
//

#define NetAccessAdd            NetAccessAdd_W95
#define NetAccessCheck          NetAccessCheck_W95
#define NetAccessDel            NetAccessDel_W95
#define NetAccessEnum           NetAccessEnum_W95
#define NetAccessGetInfo        NetAccessGetInfo_W95
#define NetAccessSetInfo        NetAccessSetInfo_W95
#define NetAccessGetUserPerms   NetAccessGetUserPerms_W95
#define NetShareAdd             NetShareAdd_W95
#define NetShareDel             NetShareDel_W95
#define NetShareEnum            NetShareEnum_W95
#define NetShareGetInfo         NetShareGetInfo_W95
#define NetShareSetInfo         NetShareSetInfo_W95
#define NetSessionDel           NetSessionDel_W95
#define NetSessionEnum          NetSessionEnum_W95
#define NetSessionGetInfo       NetSessionGetInfo_W95
#define NetConnectionEnum       NetConnectionEnum_W95
#define NetFileClose2           NetFileClose2_W95
#define NetFileEnum             NetFileEnum_W95
#define NetServerGetInfo        NetServerGetInfo_W95
#define NetServerSetInfo        NetServerSetInfo_W95
#define NetSecurityGetInfo      NetSecurityGetInfo_W95

#define _SVRAPI_ // turn off dllimport define
#include <svrapi.h>

#undef NetAccessAdd
#undef NetAccessCheck
#undef NetAccessDel
#undef NetAccessEnum
#undef NetAccessGetInfo
#undef NetAccessSetInfo
#undef NetAccessGetUserPerms
#undef NetShareAdd
#undef NetShareDel
#undef NetShareEnum
#undef NetShareGetInfo
#undef NetShareSetInfo
#undef NetSessionDel
#undef NetSessionEnum
#undef NetSessionGetInfo
#undef NetConnectionEnum
#undef NetFileClose2
#undef NetFileEnum
#undef NetServerGetInfo
#undef NetServerSetInfo
#undef NetSecurityGetInfo

//
// get the NT versions of these apis
//

#define NetShareAdd           NetShareAdd_NT
#define NetShareEnum          NetShareEnum_NT
#define NetShareEnumSticky    NetShareEnumSticky_NT
#define NetShareGetInfo       NetShareGetInfo_NT
#define NetShareSetInfo       NetShareSetInfo_NT
#define NetShareDel           NetShareDel_NT
#define NetShareDelSticky     NetShareDelSticky_NT
#define NetShareCheck         NetShareCheck_NT
#define NetSessionEnum        NetSessionEnum_NT
#define NetSessionDel         NetSessionDel_NT
#define NetSessionGetInfo     NetSessionGetInfo_NT
#define NetConnectionEnum     NetConnectionEnum_NT
#define NetFileClose          NetFileClose_NT
#define NetFileEnum           NetFileEnum_NT
#define NetFileGetInfo        NetFileGetInfo_NT

#include <lmshare.h>

#undef NetShareAdd
#undef NetShareEnum
#undef NetShareEnumSticky
#undef NetShareGetInfo
#undef NetShareSetInfo
#undef NetShareDel    
#undef NetShareDelSticky
#undef NetShareCheck  
#undef NetSessionEnum
#undef NetSessionDel
#undef NetSessionGetInfo
#undef NetConnectionEnum
#undef NetFileClose
#undef NetFileEnum
#undef NetFileGetInfo

#pragma warning(default:4005)

#define NetApiBufferAllocate    NetApiBufferAllocate_NT
#define NetApiBufferFree        NetApiBufferFree_NT
#define NetApiBufferReallocate  NetApiBufferReallocate_NT
#define NetApiBufferSize        NetApiBufferSize_NT

#include <lmapibuf.h>

#undef NetApiBufferAllocate
#undef NetApiBufferFree 
#undef NetApiBufferReallocate
#undef NetApiBufferSize

//
// Now define our wrapper versions of these functions
//
#ifndef _NO_NETSHARE_WRAPPERS_

NET_API_STATUS NetShareEnumWrap(LPCTSTR pszServer, DWORD level, LPBYTE * ppbuffer, DWORD PrefMaxLen, LPDWORD pcEntriesRead, LPDWORD pcTotalEntries, LPDWORD phResumeHandle);

NET_API_STATUS NetShareAddWrap(LPCTSTR pszServer, DWORD level, LPBYTE buffer);

NET_API_STATUS NetShareDelWrap(LPCTSTR pszServer, LPCTSTR pszNetName, DWORD reserved);

NET_API_STATUS NetShareGetInfoWrap(LPCTSTR pszServer, LPCTSTR pszNetName, DWORD level, LPBYTE * ppbuffer);

NET_API_STATUS NetShareSetInfoWrap(LPCTSTR pszServer, LPCTSTR pszNetName, DWORD level, LPBYTE buffer);

NET_API_STATUS NetApiBufferFreeWrap(LPVOID p);

#define NetShareEnum NetShareEnumWrap
#define NetShareAdd NetShareAddWrap
#define NetShareDel NetShareDelWrap
#define NetShareGetInfo NetShareGetInfoWrap
#define NetShareSetInfo NetShareSetInfoWrap
#define NetApiBufferFree NetApiBufferFreeWrap

#endif // _NO_NETSHARE_WRAPPERS_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\hnw\wizard\netapi.h ===
//
// NetApi.h
//

#pragma once


// Forward declarations
typedef struct tagNETADAPTER NETADAPTER;


// Constants for CountValidNics()
#define COUNT_NICS_WORKING    0x00000001
#define COUNT_NICS_BROKEN    0x00000002
#define COUNT_NICS_DISABLED    0x00000004

// Cached NIC enumeration to avoid querying the registry a billion times
int EnumCachedNetAdapters(const NETADAPTER** pprgAdapters);
void FlushNetAdapterCache();
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\hnw\wizard\myprsht.cpp ===
//
// MyPrSht.cpp
//
//        Implementation of the extensions made to the PropertySheet API
//        in IE5, but which we need on all platforms.
//
// History:
//
//        10/11/1999  KenSh     Created
//

#include "stdafx.h"
#include "TheApp.h"
#include "MyPrSht.h"
#include "CWnd.h"
#include "unicwrap.h"

// Thunk up to propsheetpage v6 for XP
typedef struct _PROPSHEETPAGEV6W 
{
        DWORD           dwSize;
        DWORD           dwFlags;
        HINSTANCE       hInstance;
        union 
        {
            LPCWSTR     pszTemplate;
#ifdef _WIN32
            LPCDLGTEMPLATE  pResource;
#else
            const VOID *pResource;
#endif
        } DUMMYUNIONNAME;
        union 
        {
            HICON        hIcon;
            LPCWSTR      pszIcon;
        } DUMMYUNIONNAME2;
        LPCWSTR          pszTitle;
        DLGPROC          pfnDlgProc;
        LPARAM           lParam;
        LPFNPSPCALLBACKW pfnCallback;
        UINT             *pcRefParent;

#if (_WIN32_IE >= 0x0400)
        LPCWSTR          pszHeaderTitle;    // this is displayed in the header
        LPCWSTR          pszHeaderSubTitle; ///
#endif
        HANDLE           hActCtx;
} PROPSHEETPAGEV6W, *LPPROPSHEETPAGEV6W;




// Local data
//
static CMyPropSheet* g_pMyPropSheet;

static const TCHAR c_szProp_ClassPointer[] = _T("CP");


#define DEFAULTHEADERHEIGHT    58   // in pixels
#define DEFAULTTEXTDIVIDERGAP  5
#define DEFAULTCTRLWIDTH       501   // page list window in new wizard style
#define DEFAULTCTRLHEIGHT      253   // page list window in new wizard style
#define TITLEX                 22
#define TITLEY                 10
#define SUBTITLEX              44
#define SUBTITLEY              25

// fixed sizes for the bitmap painted in the header section
#define HEADERBITMAP_Y            5
#define HEADERBITMAP_WIDTH        49
#define HEADERBITMAP_CXBACK       (5 + HEADERBITMAP_WIDTH)
#define HEADERBITMAP_HEIGHT       49                
#define HEADERSUBTITLE_WRAPOFFSET 10

// Fixed sizes for the watermark bitmap (Wizard97IE5 style)
#define BITMAP_WIDTH  164
#define BITMAP_HEIGHT 312

#define DRAWTEXT_WIZARD97FLAGS (DT_LEFT | DT_WORDBREAK | DT_NOPREFIX | DT_EDITCONTROL)

#define IDD_PAGELIST        0x3020
#define IDD_DIVIDER            0x3026
#define IDD_TOPDIVIDER        0x3027

#ifndef IS_INTRESOURCE
#define IS_INTRESOURCE(psz) (HIWORD((DWORD_PTR)(psz)) == 0)
#endif



/////////////////////////////////////////////////////////////////////////////
// MyPropertySheet

INT_PTR MyPropertySheet(LPCPROPSHEETHEADER pHeader)
{
    // If IE5 is present, use the built-in property sheet code
    // REVIEW: should we bother checking for IE5 on older OS's?
    
    if (theApp.IsWin98SEOrLater() && (! theApp.IsBiDiLocalized()) )
    {
        // ISSUE-2002/01/16-roelfc: THUNK THIS (but which way???)
        return PropertySheet(pHeader);
    }

    // ISSUE-2002/01/16-roelfc: nobody destroys g_pMyPropSheet, nobody does g_pMyPropSheet->Release()
    ASSERT(g_pMyPropSheet == NULL);
    g_pMyPropSheet = new CMyPropSheet();
    if (g_pMyPropSheet)
        return g_pMyPropSheet->DoPropSheet(pHeader);
    else
        return NULL;
}

/////////////////////////////////////////////////////////////////////////////
// MyCreatePropertySheetPage

HPROPSHEETPAGE MyCreatePropertySheetPage(LPPROPSHEETPAGE ppsp)
{
    // If IE5 is present, use the built-in property sheet code
    // REVIEW: should we bother checking for IE5 on older OS's?

    if (theApp.IsWin98SEOrLater() && (! theApp.IsBiDiLocalized()) )
    {
        if (g_fRunningOnNT)
        {
            PROPSHEETPAGEV6W spv6;

            ASSERT(sizeof (spv6) >= sizeof (PROPSHEETPAGE));
            memcpy(&spv6, ppsp, sizeof (PROPSHEETPAGE));
            
            spv6.dwSize = sizeof (spv6);
            spv6.hActCtx = NULL;

            return CreatePropertySheetPage((PROPSHEETPAGE*) &spv6);
        }
        else
        {
            return CreatePropertySheetPage(ppsp);
        }
    }

    PROPSHEETPAGE psp;
    CopyMemory(&psp, ppsp, ppsp->dwSize);

    // REVIEW: this memory is never freed
    LPPROPSHEETPAGE ppspOriginal = (LPPROPSHEETPAGE)malloc(sizeof(PROPSHEETPAGE));
    if (ppspOriginal)
    {
        CopyMemory(ppspOriginal, ppsp, ppsp->dwSize);

        psp.dwSize = PROPSHEETPAGE_V1_SIZE;
        psp.dwFlags &= ~(PSP_USEHEADERTITLE | PSP_USEHEADERSUBTITLE | PSP_HIDEHEADER);
        psp.lParam = (LPARAM)ppspOriginal;

        return ::CreatePropertySheetPage(&psp);
    }

    return NULL;
}

/////////////////////////////////////////////////////////////////////////////
// IsIMEWindow

BOOL IsIMEWindow(HWND hwnd, LPCREATESTRUCT lpcs)
{
    // check for cheap CS_IME style first...
    if (GetClassLong(hwnd, GCL_STYLE) & CS_IME)
        return TRUE;

    // get class name of the window that is being created
    LPCTSTR pszClassName;
    TCHAR szClassName[_countof("ime")+1];
    if (HIWORD(lpcs->lpszClass))
    {
        pszClassName = lpcs->lpszClass;
    }
    else
    {
        szClassName[0] = _T('\0');
        GlobalGetAtomName((ATOM)lpcs->lpszClass, szClassName, _countof(szClassName));
        pszClassName = szClassName;
    }

    // a little more expensive to test this way, but necessary...
    if (StrCmpI(pszClassName, _T("ime")) == 0)
        return TRUE;

    return FALSE; // not an IME window
}

void CMyPropSheet::SetHeaderFonts()
{
    if (m_hFontBold == NULL)
    {
        LOGFONT LogFont;
        GetObject(GetWindowFont(m_hWnd), sizeof(LogFont), &LogFont);

        LogFont.lfWeight = FW_BOLD;
        m_hFontBold = CreateFontIndirect(&LogFont);
    }
}

// Kensh: Copied and modified from _ComputeHeaderHeight in prsht.c (comctl32.dll)
//
// In Wizard97 only:
// The subtitles user passed in could be larger than the two line spaces we give
// them, especially in localization cases. So here we go through all subtitles and
// compute the max space they need and set the header height so that no text is clipped
int CMyPropSheet::ComputeHeaderHeight(int dxMax)
{
    SetHeaderFonts();

    int dyHeaderHeight;
    int dyTextDividerGap;
    HDC hdc;
    dyHeaderHeight = DEFAULTHEADERHEIGHT;
    hdc = ::GetDC(m_hWnd);

    // First, let's get the correct text height and spacing, this can be used
    // as the title height and the between-lastline-and-divider spacing.
    {
        HFONT hFont, hFontOld;
        TEXTMETRIC tm;
        if (m_hFontBold)
            hFont = m_hFontBold;
        else
            hFont = GetWindowFont(m_hWnd);

        hFontOld = (HFONT)SelectObject(hdc, hFont);
        if (GetTextMetrics(hdc, &tm))
        {
            dyTextDividerGap = tm.tmExternalLeading;
            m_ySubTitle = max ((tm.tmHeight + tm.tmExternalLeading + TITLEY), SUBTITLEY);
        }
        else
        {
            dyTextDividerGap = DEFAULTTEXTDIVIDERGAP;
            m_ySubTitle = SUBTITLEY;
        }

        if (hFontOld)
            SelectObject(hdc, hFontOld);
    }

    // Second, get the subtitle text block height
    // should make into a function if shared
    {
        RECT rcWrap;
//        UINT uPages;

        //
        //  WIZARD97IE5 subtracts out the space used by the header bitmap.
        //  WIZARD97IE4 uses the full width since the header bitmap
        //  in IE4 is a watermark and occupies no space.
        //
//        if (ppd->psh.dwFlags & PSH_WIZARD97IE4)
//            rcWrap.right = dxMax;
//        else
            rcWrap.right = dxMax - HEADERBITMAP_CXBACK - HEADERSUBTITLE_WRAPOFFSET;

        // Note (kensh): the "real" wizard code computes the max height across
        // all pages. Our cheap version only computes the current page's height
        LPPROPSHEETPAGE ppsp = GetCurrentPropSheetPage();
        if (ppsp != NULL)
        {
            if (!(ppsp->dwFlags & PSP_HIDEHEADER) &&
                 (ppsp->dwFlags & PSP_USEHEADERSUBTITLE))
            {
                int iSubHeaderHeight = WriteHeaderTitle(hdc, &rcWrap, ppsp->pszHeaderSubTitle,
                    FALSE, DT_CALCRECT | DRAWTEXT_WIZARD97FLAGS);
                if ((iSubHeaderHeight + m_ySubTitle) > dyHeaderHeight)
                    dyHeaderHeight = iSubHeaderHeight + m_ySubTitle;
            }
        }
    }

    // If the header height has been recomputed, set the correct gap between
    // the text and the divider.
    if (dyHeaderHeight != DEFAULTHEADERHEIGHT)
    {
        ASSERT(dyHeaderHeight > DEFAULTHEADERHEIGHT);
        dyHeaderHeight += dyTextDividerGap;
    }

    ::ReleaseDC(m_hWnd, hdc);
    return dyHeaderHeight;
}

// Kensh: Copied and modified from _WriteHeaderTitle in prsht.c (comctl32.dll)
//
int CMyPropSheet::WriteHeaderTitle(HDC hdc, LPRECT prc, LPCTSTR pszTitle, BOOL bTitle, DWORD dwDrawFlags)
{
    SetHeaderFonts();

    LPCTSTR pszOut;
    int cch;
    int cx, cy;
    UINT ETO_Flags=0; 
    SIZE Size;
    TCHAR szTitle[MAX_PATH*4];
    HFONT hFontOld = NULL;
    HFONT hFont;
    int yDrawHeight = 0;

    if (IS_INTRESOURCE(pszTitle))
    {
        LPPROPSHEETPAGE ppsp = GetCurrentPropSheetPage();
        if (NULL != ppsp)
        {
            LoadString(ppsp->hInstance, (UINT)LOWORD(pszTitle), szTitle, _countof(szTitle));
        }
        else
        {
            *szTitle = 0;
        }

        pszOut = szTitle;
    }
    else
        pszOut = pszTitle;

    cch = lstrlen(pszOut);

    if (bTitle && m_hFontBold)
        hFont = m_hFontBold;
    else
        hFont = GetWindowFont(m_hWnd);

    hFontOld = (HFONT)SelectObject(hdc, hFont);

    if (bTitle)
    {
          cx = TITLEX;
          cy = TITLEY;

        if (theApp.IsBiDiLocalized())
        {
        ETO_Flags |= ETO_RTLREADING;
        if (GetTextExtentPoint32(hdc, pszOut, lstrlen (pszOut), &Size))
            cx = prc->right - Size.cx;
        }          
        ExtTextOut(hdc, cx, cy, ETO_Flags, prc, pszOut, cch, NULL);
    }
    else
    {
        RECT rcWrap;
        CopyRect(&rcWrap, prc);

        rcWrap.left = SUBTITLEX;
        rcWrap.top = m_ySubTitle;
        if (theApp.IsBiDiLocalized())
        {
          dwDrawFlags |= DT_RTLREADING | DT_RIGHT;
          }
        yDrawHeight = DrawText(hdc, pszOut, cch, &rcWrap, dwDrawFlags);
    }

    if (hFontOld)
        SelectObject(hdc, hFontOld);

    return yDrawHeight;
}

/////////////////////////////////////////////////////////////////////////////
// CMyPropSheet

CMyPropSheet::CMyPropSheet()
{
    m_pRealHeader = NULL;
    m_hHook = NULL;
    m_hbrWindow = NULL;
    m_hbrDialog = NULL;
    m_hwndActive = NULL;
    m_hbmWatermark = NULL;
    m_hbmHeader = NULL;
    m_hpalWatermark = NULL;
    m_hFontBold = NULL;
}

CMyPropSheet::~CMyPropSheet()
{
    free(m_pRealHeader);
    ASSERT(m_hHook == NULL);

    if (m_hbrWindow != NULL)
        DeleteObject(m_hbrWindow);
    if (m_hbrDialog != NULL)
        DeleteObject(m_hbrDialog);
}

void CMyPropSheet::InitColorSettings()
{
    if (m_hbrWindow != NULL)
        DeleteObject(m_hbrWindow);
    m_hbrWindow = CreateSolidBrush(GetSysColor(COLOR_WINDOW));

    if (m_hbrDialog != NULL)
        DeleteObject(m_hbrDialog);
    m_hbrDialog = CreateSolidBrush(GetSysColor(COLOR_3DFACE));
}

void CMyPropSheet::LoadBitmaps()
{
    LPPROPSHEETHEADER ppsh = m_pRealHeader;
    if (ppsh)
    {
        if (ppsh->dwFlags & PSH_USEHBMHEADER)
            m_hbmHeader = ppsh->hbmHeader;
        else
            m_hbmHeader = LoadBitmap(ppsh->hInstance, ppsh->pszbmHeader);

        if (ppsh->dwFlags & PSH_USEHBMWATERMARK)
            m_hbmWatermark = ppsh->hbmWatermark;
        else
            m_hbmWatermark = LoadBitmap(ppsh->hInstance, ppsh->pszbmWatermark);

        // Note: might need a palette later, but so far it hasn't been necessary
    }
}

INT_PTR CMyPropSheet::DoPropSheet(LPCPROPSHEETHEADER ppsh)
{
    INT_PTR nResult = 0;

    ASSERT(m_pRealHeader == NULL);
    m_pRealHeader = (LPPROPSHEETHEADER)malloc(ppsh->dwSize);
    if (m_pRealHeader)
    {
        CopyMemory(m_pRealHeader, ppsh, ppsh->dwSize);

        InitColorSettings();

        // Create header and watermark bitmaps
        LoadBitmaps();

        PROPSHEETHEADER psh;
        ASSERT(sizeof(psh) >= ppsh->dwSize);
        CopyMemory(&psh, ppsh, ppsh->dwSize);

        psh.dwSize = PROPSHEETHEADER_V1_SIZE;
        psh.dwFlags &= 0x00000fff; // W95 gold comctl32 prop sheet mask.
        psh.dwFlags |= PSH_WIZARD;

        ASSERT(m_hHook == NULL);
        m_hHook = SetWindowsHookEx(WH_CBT, HookProc, NULL, GetCurrentThreadId());

        nResult = ::PropertySheet(&psh);

        if (m_hHook != NULL)
        {
            UnhookWindowsHookEx(m_hHook);
            m_hHook = NULL;
        }
    }

    return nResult;
}

LRESULT CALLBACK CMyPropSheet::HookProc(int nCode, WPARAM wParam, LPARAM lParam)
{
    ASSERT(g_pMyPropSheet != NULL);

    LRESULT lResult = CallNextHookEx(g_pMyPropSheet->m_hHook, nCode, wParam, lParam);

    if (nCode == HCBT_CREATEWND)
    {
        HWND hwnd = (HWND)wParam;
        LPCBT_CREATEWND pCbt = (LPCBT_CREATEWND)lParam;

        // Make sure this isn't an IME window
        if (IsIMEWindow(hwnd, pCbt->lpcs))
            goto done;

        if (g_pMyPropSheet->m_hWnd == NULL) // The main wizard window
        {
            // Add the WS_EX_DLGMODALFRAME extended style to the window
            // Remove WS_EX_CONTEXTHELP extended style from the window
            SHSetWindowBits(hwnd, GWL_EXSTYLE, WS_EX_DLGMODALFRAME|WS_EX_CONTEXTHELP, WS_EX_DLGMODALFRAME);

            // Add the WS_SYSMENU style to the window
            SHSetWindowBits(hwnd, GWL_STYLE, WS_SYSMENU, WS_SYSMENU);

            // Subclass the window
            g_pMyPropSheet->Attach(hwnd);
        }
        else if (pCbt->lpcs->hwndParent == g_pMyPropSheet->m_hWnd && 
                 pCbt->lpcs->hMenu == NULL &&
                 (pCbt->lpcs->style & WS_CHILD) == WS_CHILD)
        {
            // It's a wizard page sub-dialog -- subclass it so we can 
            // draw its background
            CMyPropPage* pPropPage = new CMyPropPage;
            if (pPropPage)
            {
                pPropPage->Attach(hwnd);
                pPropPage->Release();
            }
        }
    }
    else if (nCode == HCBT_DESTROYWND)
    {
        HWND hwnd = (HWND)wParam;
        if (hwnd == g_pMyPropSheet->m_hWnd)
        {
            // Main window being destroyed -- stop hooking window creation
            UnhookWindowsHookEx(g_pMyPropSheet->m_hHook);
            g_pMyPropSheet->m_hHook = NULL;
        }
    }

done:
    return lResult;
}

LPPROPSHEETPAGE CMyPropSheet::GetCurrentPropSheetPage()
{
    CMyPropPage* pPage = CMyPropPage::FromHandle(GetActivePage());
    if (pPage)
    {
        return pPage->GetPropSheetPage();
    }
    return NULL;
}

LRESULT CMyPropSheet::WindowProc(UINT message, WPARAM wParam, LPARAM lParam)
{
    switch (message)
    {
    case WM_SETTINGCHANGE:
        {
            InitColorSettings();
            return Default(message, wParam, lParam);
        }

    case PSM_SETCURSEL:
        {
            InvalidateRect(m_hWnd, NULL, TRUE);
            return Default(message, wParam, lParam);
        }
        break;

        /*
    case WM_ERASEBKGND:
        {
            TRACE("Main window - WM_ERASEBKGND - active page = %X\r\n", GetActivePage());
            LPPROPSHEETPAGE ppsp = GetCurrentPropSheetPage();

            HDC hdc = (HDC)wParam;
            RECT rcClient;
            GetClientRect(&rcClient);

            if (ppsp->dwFlags & PSP_HIDEHEADER)
            {
                RECT rcDivider;
                GetDlgItemRect(hwnd, IDD_DIVIDER, &rcDivider);
                rcClient.top = rcDivider.bottom;
                FillRect(hdc, &rcClient, m_hbrDialog);
                rcClient.bottom = rcClient.top;
                rcClient.top = 0;
                FillRect(hdc, &rcClient, m_hbrWindow);
                return TRUE;
            }
            else
            {
                RECT rcHeader;
                CopyRect(&rcHeader, &rcClient);
                rcHeader.bottom = DEFAULTHEADERHEIGHT;
                FillRect(hdc, &rcHeader, m_hbrWindow);
                rcClient.top = rcHeader.bottom;
                FillRect(hdc, &rcClient, m_hbrDialog);
            }
        }
        return FALSE;
        */

    case WM_PAINT:
        {
            PAINTSTRUCT ps;
            LPPROPSHEETPAGE ppsp = GetCurrentPropSheetPage();

            HDC hdc = ::BeginPaint(m_hWnd, &ps);

            if (ppsp != NULL)
            {
                if (ppsp->dwFlags & PSP_HIDEHEADER)
                {
                    // Draw the watermark
                    PaintWatermark(hdc, ppsp);
                }
                else
                {
                    // Draw the header
                    PaintHeader(hdc, ppsp);
                }
            }

            ::EndPaint(m_hWnd, &ps);
        }
        break;

    case WM_CTLCOLOREDIT:
    case WM_CTLCOLORDLG:
    case WM_CTLCOLOR:
    case WM_CTLCOLORMSGBOX:
    case WM_CTLCOLORLISTBOX:
    case WM_CTLCOLORBTN:
    case WM_CTLCOLORSCROLLBAR:
    case WM_CTLCOLORSTATIC:
        {
            return (LRESULT)OnCtlColor(message, (HDC)wParam, (HWND)lParam);
        }

    default:
        {
            return Default(message, wParam, lParam);
        }
    }

    return 0;
}

HBRUSH CMyPropSheet::OnCtlColor(UINT message, HDC hdc, HWND hwndControl)
{
    HBRUSH hbr = (HBRUSH)Default(message, (WPARAM)hdc, (LPARAM)hwndControl);

    if (message == WM_CTLCOLOREDIT || message == WM_CTLCOLORDLG)
        return hbr;

    SetTextColor(hdc, GetSysColor(COLOR_WINDOWTEXT));
    SetBkColor(hdc, GetSysColor(COLOR_WINDOW));
    return m_hbrWindow;
}

//
//  lprc is the target rectangle.
//  Use as much of the bitmap as will fit into the target rectangle.
//  If the bitmap is smaller than the target rectangle, then fill the rest with
//  the pixel in the upper left corner of the hbmpPaint.
//
void PaintWithPaletteBitmap(HDC hdc, LPRECT lprc, HPALETTE hplPaint, HBITMAP hbmpPaint)
{
    HDC hdcBmp = CreateCompatibleDC(hdc);
    if (hdcBmp)
    {
        BITMAP bm;
        int cxRect, cyRect, cxBmp, cyBmp;

        GetObject(hbmpPaint, sizeof(BITMAP), &bm);
        SelectObject(hdcBmp, hbmpPaint);

        if (hplPaint)
        {
            SelectPalette(hdc, hplPaint, FALSE);
            RealizePalette(hdc);
        }

        cxRect = RECTWIDTH(*lprc);
        cyRect = RECTHEIGHT(*lprc);

        //  Never use more pixels from the bmp as we have room in the rect.
        cxBmp = min(bm.bmWidth, cxRect);
        cyBmp = min(bm.bmHeight, cyRect);

        BitBlt(hdc, lprc->left, lprc->top, cxBmp, cyBmp, hdcBmp, 0, 0, SRCCOPY);

        // If bitmap is too narrow, then StretchBlt to fill the width.
        if (cxBmp < cxRect)
            StretchBlt(hdc, lprc->left + cxBmp, lprc->top,
                       cxRect - cxBmp, cyBmp,
                       hdcBmp, 0, 0, 1, 1, SRCCOPY);

        // If bitmap is to short, then StretchBlt to fill the height.
        if (cyBmp < cyRect)
            StretchBlt(hdc, lprc->left, cyBmp,
                       cxRect, cyRect - cyBmp,
                       hdcBmp, 0, 0, 1, 1, SRCCOPY);

        DeleteDC(hdcBmp);
    }
}

void CMyPropSheet::PaintWatermark(HDC hdc, LPPROPSHEETPAGE ppsp)
{
    RECT rcClient;
    RECT rcClient_Dlg;

    GetClientRect(m_hWnd, &rcClient);
    GetClientRect(m_hWnd, &rcClient_Dlg);

    RECT rcDivider;
    GetDlgItemRect(m_hWnd, IDD_DIVIDER, &rcDivider);

    if (m_hbmWatermark)
    {
        // Bottom gets gray
        rcClient.top = rcDivider.bottom;
        FillRect(hdc, &rcClient, m_hbrDialog);
        rcClient.bottom = rcClient.top;
        rcClient.top = 0;
        // Right-hand side gets m_hbrWindow.
        
        if (theApp.IsBiDiLocalized())
          rcClient.right = rcClient_Dlg.right - BITMAP_WIDTH;
        else
          rcClient.left = BITMAP_WIDTH;
        FillRect(hdc, &rcClient, m_hbrWindow);
        // Left-hand side gets watermark in top portion with autofill...
        if (theApp.IsBiDiLocalized())
            {
            rcClient.right = rcClient_Dlg.right;
            rcClient.left = rcClient_Dlg.right - BITMAP_WIDTH;
            }
        else    
            {
            rcClient.right = rcClient.left;
            rcClient.left = 0;
            }

        PaintWithPaletteBitmap(hdc, &rcClient, m_hpalWatermark, m_hbmWatermark);
    }
}

void CMyPropSheet::PaintHeader(HDC hdc, LPPROPSHEETPAGE ppsp)
{
    RECT rcClient, rcHeaderBitmap;
    GetClientRect(m_hWnd, &rcClient);
    int cyHeader = ComputeHeaderHeight(rcClient.right);

    // Bottom gets gray
    rcClient.top = cyHeader;
    FillRect(hdc, &rcClient, m_hbrDialog);

    // Top gets white
    rcClient.bottom = rcClient.top;
    rcClient.top = 0;
    FillRect(hdc, &rcClient, m_hbrWindow);

    // Draw the fixed-size header bitmap
    int bx= RECTWIDTH(rcClient) - HEADERBITMAP_CXBACK;
    ASSERT(bx > 0);
    SetRect(&rcHeaderBitmap, bx, HEADERBITMAP_Y, bx + HEADERBITMAP_WIDTH, HEADERBITMAP_Y + HEADERBITMAP_HEIGHT);
    PaintWithPaletteBitmap(hdc, &rcHeaderBitmap, m_hpalWatermark, m_hbmHeader);

    // Draw header title & subtitle
    rcClient.right = bx - HEADERSUBTITLE_WRAPOFFSET;
    WriteHeaderTitle(hdc, &rcClient, ppsp->pszHeaderTitle, TRUE, DRAWTEXT_WIZARD97FLAGS);
    WriteHeaderTitle(hdc, &rcClient, ppsp->pszHeaderSubTitle, FALSE, DRAWTEXT_WIZARD97FLAGS);
}


/////////////////////////////////////////////////////////////////////////////
// CMyPropPage

CMyPropPage* CMyPropPage::FromHandle(HWND hwnd)
{
    return (CMyPropPage*)(CWnd::FromHandle(hwnd));
}

LPPROPSHEETPAGE CMyPropPage::GetPropSheetPage()
{
    return m_ppspOriginal;
}

LRESULT CMyPropPage::WindowProc(UINT message, WPARAM wParam, LPARAM lParam)
{
    switch (message)
    {
    case WM_INITDIALOG:
        {
            LPPROPSHEETPAGE ppspBogus = (LPPROPSHEETPAGE)lParam;
            LPPROPSHEETPAGE ppspOriginal = (LPPROPSHEETPAGE) ppspBogus->lParam;
            m_ppspOriginal = ppspOriginal;
            lParam = (LPARAM)ppspOriginal;
        }
        break;

    case WM_ERASEBKGND:
        {
            if ((m_ppspOriginal->dwFlags & PSP_HIDEHEADER) != 0)
            {
                // Let the parent window bleed through
                return FALSE;
            }
        }
        break;

    case WM_CTLCOLORSTATIC:
        {
            if ((m_ppspOriginal->dwFlags & PSP_HIDEHEADER) != 0)
            {
                return (LRESULT)g_pMyPropSheet->OnCtlColor(message, (HDC)wParam, (HWND)lParam);
            }
        }
        break;

    case WM_NOTIFY:
        {
            NMHDR* pHdr = (NMHDR*)lParam;
            switch (pHdr->code)
            {
            case PSN_KILLACTIVE:
                {
//                    TRACE("PSN_KILLACTIVE - hwnd = %X\r\n", hwnd);
                }
                break;

            case PSN_SETACTIVE:
                {
//                    TRACE("PSN_SETACTIVE - hwnd = %X\r\n", hwnd);

                    HWND hwndParent = GetParent(m_hWnd);

                    RECT rcParent;
                    ::GetClientRect(hwndParent, &rcParent);

                    RECT rcTopDivider;
                    HWND hwndTopDivider = GetDlgItemRect(hwndParent, IDD_TOPDIVIDER, &rcTopDivider);


                    // Hide the tab control (not sure why it's showing up, but it shouldn't)
                    ShowWindow(::GetDlgItem(hwndParent, IDD_PAGELIST), SW_HIDE);

                    RECT rcDivider;
                    HWND hwndDivider = GetDlgItemRect(hwndParent, IDD_DIVIDER, &rcDivider);
                    
                    // Set the proper size and position for the dialog
                    if ((m_ppspOriginal->dwFlags & PSP_HIDEHEADER) != 0)
                    {
                        // Reposition the divider
                        SetWindowPos(hwndDivider, NULL, 0, rcDivider.top, rcParent.right, RECTHEIGHT(rcDivider),
                                     SWP_NOZORDER | SWP_NOACTIVATE);

                        // Hide the top divider
                        if (hwndTopDivider != NULL)
                            ShowWindow(hwndTopDivider, SW_HIDE);

                        // Reposition the dialog

                        SetWindowPos(m_hWnd, NULL, rcParent.left, rcParent.top, RECTWIDTH(rcParent), rcDivider.top - rcParent.top,
                                     SWP_NOZORDER | SWP_NOACTIVATE);
                        

                    }
                    else
                    {
                        int cyHeader = g_pMyPropSheet->ComputeHeaderHeight(rcParent.right);


                        // Reposition and show the top divider
                        if (hwndTopDivider != NULL)
                        {
                            SetWindowPos(hwndTopDivider, NULL, 0, cyHeader, rcParent.right, RECTHEIGHT(rcTopDivider),
                                         SWP_NOZORDER | SWP_NOACTIVATE);
                            ShowWindow(hwndTopDivider, SW_SHOW);
                        }

                        // Reposition the dialog
                        SetWindowPos(m_hWnd, NULL, rcParent.left + 7, cyHeader + 7, RECTWIDTH(rcParent) - 14, rcDivider.top - cyHeader - 14,
                                     SWP_NOZORDER | SWP_NOACTIVATE);
                    }
                    g_pMyPropSheet->OnSetActivePage(m_hWnd);
                }
                break;
            }
        }
        break;

    default:
        break;
    }

    return CWnd::Default(message, wParam, lParam);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\hnw\wizard\netenum.h ===
//
// NetEnum.h
//

#pragma once


// Callback is called with a NULL pNetResource to indicate no more items to enumerate
typedef BOOL (CALLBACK * NETENUMCALLBACK)(LPVOID pvCallbackParam, LPCTSTR pszComputerName, LPCTSTR pszShareName);

// One global iteration can be happening at a time. If you need
// more than one, instantiate CNetEnum yourself.
void InitNetEnum();
void TermNetEnum();
void EnumComputers(NETENUMCALLBACK pfnCallback, LPVOID pvCallbackParam);


class CNetEnum
{
public:
    CNetEnum();
    ~CNetEnum();

    void EnumComputers(NETENUMCALLBACK pfnCallback, LPVOID pvCallbackParam);
    void EnumNetPrinters(NETENUMCALLBACK pfnCallback, LPVOID pvCallbackParam);
    void Abort();

protected:
    enum JOBTYPE { jtEnumComputers, jtEnumPrinters };

    void EnumHelper(JOBTYPE eJobType, NETENUMCALLBACK pfnCallback, LPVOID pvCallbackParam);
    static DWORD WINAPI EnumThreadProc(LPVOID pvParam);
    void EnumThreadProc();

protected:
    CRITICAL_SECTION m_cs;

    HANDLE m_hThread;
    BOOL m_bAbort;
    BOOL m_bNewJob;

    JOBTYPE m_eJobType;
    NETENUMCALLBACK m_pfnCallback;
    LPVOID m_pvCallbackParam;
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\hnw\wizard\netinet.cpp ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997 - 2000
//
//  File:       N E T I N E T . C P P
//
//  Contents:   Routines supporting RAS interoperability
//
//  Notes:
//
//  Author:     billi   07 03 2001
//
//  History:    
//
//----------------------------------------------------------------------------


#include "stdafx.h"
#include "Util.h"
#include "TheApp.h"

#include <lmjoin.h>
#include <devguid.h>

#include "NetUtil.h"				 
#include "NetInet.h"                  


#define c_szIConnDwnAgent  WIZARDNAME    // agent for InternetOpen()



HRESULT GetInternetAutodialMode( DWORD *pdwMode )
//+---------------------------------------------------------------------------
//
//  Function:   GetInternetAutodialMode
//
//  Purpose:    Gets the Autodial mode setting in the IE5+ dialer
//
//  Arguments:  pdwMode  AUTODIAL_MODE_NEVER
//                       AUTODIAL_MODE_ALWAYS
//                       AUTODIAL_MODE_NO_NETWORK_PRESENT
//
//  Returns:    HRESULT
//
//  Author:     billi  22/01/01
//
//  Notes:      
//
{
	HRESULT hr;

	ASSERT(NULL != pdwMode);
    
    if ( NULL != pdwMode )
    {
		HINTERNET hInternet;
        
        hr        = S_OK;
        *pdwMode  = 0;
		hInternet = InternetOpen( c_szIConnDwnAgent, INTERNET_OPEN_TYPE_PRECONFIG, NULL, NULL, 0 );

		if ( NULL == hInternet )
		{
			hr = HrFromLastWin32Error();
	    }
	    else
		{
	    	DWORD dwLength = sizeof(*pdwMode);
	    
			// The flag only exists for IE5, this call 
			// will have no effect if IE5 is not present.

			BOOL bOk = InternetQueryOption( hInternet, 
	               						    INTERNET_OPTION_AUTODIAL_MODE, 
	                                        pdwMode, 
	                                        &dwLength );
	                                      
	        if ( !bOk )
	        {
	        	hr = HrFromLastWin32Error();
			}
	        
	        InternetCloseHandle( hInternet );
		}
    }
    else
    {
    	hr = E_POINTER;
    }

	return hr;
}



HRESULT HrSetInternetAutodialMode( DWORD dwMode )
//+---------------------------------------------------------------------------
//
//  Function:   HrSetInternetAutodialMode
//
//  Purpose:    Sets the Autodial mode setting in the IE5+ dialer
//
//  Arguments:  dwMode   AUTODIAL_MODE_NEVER
//                       AUTODIAL_MODE_ALWAYS
//                       AUTODIAL_MODE_NO_NETWORK_PRESENT
//
//  Returns:    HRESULT
//
//  Author:     billi  22/01/01
//
//  Notes:      
//
{
	HRESULT   hr = S_OK;
	HINTERNET hInternet;

	hInternet = InternetOpen( c_szIConnDwnAgent, INTERNET_OPEN_TYPE_PRECONFIG, NULL, NULL, 0 );

	if ( NULL != hInternet )
	{
		// The flag only exists for IE5, this call 
		// will have no effect if IE5 is not present.

		BOOL bOk = InternetSetOption( hInternet, 
               						  INTERNET_OPTION_AUTODIAL_MODE, 
                                      &dwMode, 
                                      sizeof(dwMode) );
                                      
        if ( !bOk )
        {
        	hr = HrFromLastWin32Error();
		}
        
        InternetCloseHandle( hInternet );
	}
    else
	{
		hr = HrFromLastWin32Error();
    }

	return hr;
}



HRESULT HrSetAutodial( DWORD dwMode )
//+---------------------------------------------------------------------------
//
//  Function:   HrSetAutodial
//
//  Purpose:    Sets the specified network connection to the specified mode.
//
//  Arguments:  dwMode   AUTODIAL_MODE_NEVER
//                       AUTODIAL_MODE_ALWAYS
//                       AUTODIAL_MODE_NO_NETWORK_PRESENT
//
//  Returns:    HRESULT
//
//  Author:     billi  22/01/01
//
//  Notes:      
//
{
#ifdef SETAUTODIALMODEDOWNONLY

	DWORD   dwCurrentMode;
    HRESULT	hr;
    
    // If we are trying to set the autodial mode to an extreme then
    // we go ahead and set it.

	if ( AUTODIAL_MODE_NO_NETWORK_PRESENT != dwMode )
    {
    	hr = HrSetInternetAutodialMode( dwMode );
    }
    else
    {
    	// If we are trying to set autodial mode to AUTODIAL_MODE_NO_NETWORK_PRESENT
        // then we only need to set if the current state is AUTODIAL_MODE_ALWAYS.
    
	    hr = GetInternetAutodialMode( &dwCurrentMode );
	    
	    if ( SUCCEEDED(hr) && ( AUTODIAL_MODE_ALWAYS == dwCurrentMode ) )
	    {
	    	hr = HrSetInternetAutodialMode( dwMode );
	    }
    }

   	return hr;

#else

	return HrSetInternetAutodialMode( dwMode );

#endif    
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\hnw\wizard\netinet.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997 - 2000
//
//  File:       N E T R A S . H
//
//  Contents:   Routines supporting RAS interoperability
//
//  Notes:
//
//  Author:     billi   07 03 2001
//
//  History:    
//
//----------------------------------------------------------------------------


#pragma once


#include <wininet.h>


#define HNW_ED_NONE			0x0
#define HNW_ED_RELEASE		0x1
#define HNW_ED_RENEW		0x2


HRESULT HrSetInternetAutodialMode( DWORD dwMode );
HRESULT HrSetAutodial( DWORD dwMode );
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\hnw\wizard\netip.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997 - 2000
//
//  File:       N E T R I P . H
//
//  Contents:   Routines supporting RAS interoperability
//
//  Notes:
//
//  Author:     billi   07 03 2001
//
//  History:    
//
//----------------------------------------------------------------------------


#pragma once


#include <..\shared\netip.h>


HRESULT HrCheckListForMatch( INetConnection* pConnection, IPAddr IpAddress, LPHOSTENT pHostEnt, BOOL* pfAssociated );
HRESULT HrGetAdapterInfo( INetConnection* pConnection, PIP_ADAPTER_INFO* ppAdapter );
HRESULT HrGetHostIpList( char* pszHost, IPAddr* pIpAddress, LPHOSTENT* ppHostEnt );
HRESULT HrLookupForIpAddress( INetConnection* pConnection, IPAddr IpAddress, BOOL* pfExists, WCHAR** ppszHost, PDWORD pdwSize );
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\hnw\wizard\netras.cpp ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997 - 2000
//
//  File:       N E T R A S . C P P
//
//  Contents:   Routines supporting RAS interoperability
//
//  Notes:
//
//  Author:     billi   07 03 2001
//
//  History:    
//
//----------------------------------------------------------------------------


#include "stdafx.h"
#include "Util.h"
#include "TheApp.h"

#include <lmjoin.h>
#include <devguid.h>
#include <tapi.h>
#include <rasdlg.h>
				  
#include "NetUtil.h"                  
#include "NetRas.h"
#include "NetIp.h"


// PPPoE driver returns the MAC addresses appended to call info from lineGetCallInfo
// for caller and called station id's
// we set their size as 6 ( a MAC address occupies 6 bytes )

#define TAPI_STATION_ID_SIZE            ( 6 * sizeof( CHAR ) )

// PPPoE driver returns address string appended to address caps from lineGetAddressCaps

#define PPPOE_LINE_ADDR_STRING      L"PPPoE VPN"
#define PPTP_LINE_ADDR_STRING       L"PPTP VPN"



HRESULT HrRasGetEntryProperties( 
	INetRasConnection* pRas,
    LPRASENTRY*        lplpRasEntry, 
	LPDWORD            lpdwEntryInfoSize )
//+---------------------------------------------------------------------------
//
//  Function:   HrRasGetEntryProperties
//
//  Purpose:    
//
//  Arguments:  INetConnection* pRas
//			    LPRASENTRY      lpRasEntry, 
//				LPDWORD         lpdwEntryInfoSize
//
//  Returns:    HRESULT
//
//  Author:     billi  07/02/01
//
//  Notes:      
//
{
	ASSERT( pRas );
    ASSERT( lplpRasEntry );
    ASSERT( lpdwEntryInfoSize );
    
    HRESULT      hr;
	RASCON_INFO  rcInfo;
    
    *lplpRasEntry      = NULL;
    *lpdwEntryInfoSize = 0L;
    
	hr = pRas->GetRasConnectionInfo( &rcInfo );
    
    if ( SUCCEEDED(hr) )
    {
		DWORD      dwSize = sizeof(RASENTRY);
        
    	hr = E_FAIL;

        for ( DWORD i=0; i<2; i++ )
        {
		    LPRASENTRY lpEntry = (LPRASENTRY) new BYTE[ dwSize ];

	        if ( NULL != lpEntry )
	        {
	        	lpEntry->dwSize = dwSize;
	        
	        	DWORD dwErr = RasGetEntryProperties( rcInfo.pszwPbkFile,
			        								 rcInfo.pszwEntryName,
			                                         lpEntry,
			                                         &dwSize,
			                                         NULL,
			                                         0 );

	            if ( ERROR_SUCCESS == dwErr )
	            {
	#if (WINVER >= 0x500)
	                ASSERT( RASET_Vpn == (*lplpRasEntry)->dwType );
	            	ASSERT( rcInfo.guidId == (*lplpRasEntry)->guidId );
	#endif
    				
	            
				    *lplpRasEntry      = lpEntry;
				    *lpdwEntryInfoSize = dwSize;
	            	hr                 = S_OK;
                    break;
	            }
	            else
	            {
			    	TraceMsg(TF_ERROR, "\tRasGetEntryProperties Failed = %lx Size = %ul", dwErr, *lpdwEntryInfoSize );
                    
	            	delete [] (PBYTE)(lpEntry);
	            }
        	}
            else
            {
            	hr = E_OUTOFMEMORY;
		    	TraceMsg(TF_ERROR, "\tnew Failed!" );
                break;
            }
        }

     	CoTaskMemFree( rcInfo.pszwPbkFile );
     	CoTaskMemFree( rcInfo.pszwEntryName );
	}
    else
    {
    	TraceMsg(TF_ERROR, "\tGetRasConnectionInfo Failed!" );
    }
    
	TraceMsg(TF_ALWAYS, "HrRasGetEntryProperties = %lx", hr);
    return hr;
}



HRESULT HrCheckVPNForRoute(
	INetConnection*    pPrivate, 
    INetRasConnection* pShared,
	NETCON_PROPERTIES* pProps,
    BOOL*              pfAssociated )
//+---------------------------------------------------------------------------
//
//  Function:   HrCheckVPNForRoute
//
//  Purpose:    
//
//  Arguments:  INetConnection*    pPrivate
//              INetConnection*    pShared
//           	NETCON_PROPERTIES* pProps
//              BOOL*              pfAssociated 
//
//  Returns:    HRESULT
//
//  Author:     billi  26/01/01
//
//  Notes:      
//
{
    HRESULT     hr;
    LPRASENTRY  lpRasEntry      = NULL;
    DWORD       dwEntryInfoSize = 0;
    
    ASSERT( pPrivate );
    ASSERT( pShared );
    ASSERT( pProps );
    ASSERT( pfAssociated );

    *pfAssociated = FALSE;
    
    hr = HrRasGetEntryProperties( pShared, &lpRasEntry, &dwEntryInfoSize );
    
    if ( SUCCEEDED(hr) )
    {
	    int      WsaErr = ERROR_SUCCESS;
	    WSADATA  WsaData;

	    WsaErr = WSAStartup( MAKEWORD(2, 0), &WsaData );
        
        if ( ERROR_SUCCESS == WsaErr )
        {
	    	PHOSTENT  pHostEnt  = NULL;
	        IPAddr    IpAddress = INADDR_NONE;
            
#ifdef DBG   // checked build
            if ( NCS_DISCONNECTED == pProps->Status )
            {
				TraceMsg(TF_ALWAYS, "VPN = DISCONNECTED");
            }
            else if ( NCS_CONNECTED == pProps->Status )
            {
				TraceMsg(TF_ALWAYS, "VPN = CONNECTED");
            }
#endif
            
			hr = HrGetHostIpList( (char*)lpRasEntry->szLocalPhoneNumber, &IpAddress, &pHostEnt );
            
            if ( SUCCEEDED(hr) )
            {
            	hr = HrCheckListForMatch( pPrivate, IpAddress, pHostEnt, pfAssociated );
            }
        
	        WSACleanup();
        }
        else
        {
	    	TraceMsg(TF_ERROR, "WSAStartup Failed = %lu", WsaErr );
        	hr = E_FAIL;
        }
        
    	delete lpRasEntry;
    }
    
	TraceMsg(TF_ALWAYS, "HrCheckVPNForRoute = %lx", hr);
    return hr;
}



HRESULT HrRasDialDlg( INetRasConnection* pRas )
//+---------------------------------------------------------------------------
//
//  Function:   HrRasDialDlg
//
//  Purpose:    
//
//  Arguments:  INetConnection* pRas
//
//  Returns:    HRESULT
//
//  Author:     billi  26/01/01
//
//  Notes:      
//
{
	ASSERT( pRas );
    
    HRESULT      hr;
	RASCON_INFO  rcInfo;
    
	hr = pRas->GetRasConnectionInfo( &rcInfo );
    
    if ( SUCCEEDED(hr) )
    {
    	RASDIALDLG Info;
        
        ZeroMemory( &Info, sizeof(Info) );
        Info.dwSize   = sizeof (RASDIALDLG);
//billi 3/19/01 we don't set this flag as per #342832 by SethH        
//		Info.dwFlags |= RASDDFLAG_LinkFailure;	// "reconnect pending" countdown
        
        TraceMsg(TF_ALWAYS, "Pbk  : %s", rcInfo.pszwPbkFile);
        TraceMsg(TF_ALWAYS, "Entry: %s", rcInfo.pszwEntryName);
        
        SetLastError( ERROR_SUCCESS );
    
    	if ( RasDialDlg( rcInfo.pszwPbkFile,
        				 rcInfo.pszwEntryName,
                         NULL,
                         &Info ) )
        {
        	hr = S_OK;
        }
        else
        {
			hr = HrFromLastWin32Error();

        	if ( ERROR_SUCCESS == Info.dwError )
            {
            	TraceMsg(TF_ALWAYS, "RasDialDlg Cancelled by User!");
	        	hr = E_FAIL;
            }
            else
           	{
	        	TraceMsg(TF_ERROR, "RasDialDlg Failed! = %lx", Info.dwError );
            }
        }
    
     	CoTaskMemFree( rcInfo.pszwPbkFile );
     	CoTaskMemFree( rcInfo.pszwEntryName );
     }
    
	TraceMsg(TF_ALWAYS, "HrRasDialDlg = %lx", hr);
    return hr;
}



VOID CALLBACK
RasTapiCallback( 
    DWORD               hDevice,
    DWORD               dwMessage,
    DWORD_PTR           dwInstance,
    DWORD_PTR           dwParam1,
    DWORD_PTR           dwParam2,
    DWORD_PTR           dwParam3 )
//+---------------------------------------------------------------------------
//
//  Function:   RasTapiCallback
//
//  Purpose:    a callback function that is invoked to determine status and events on 
//				the line device, addresses, or calls, when the application is using 
//				the "hidden window" method of event notification 
//
//  Arguments:	hDevice 			A handle to either a line device or a call associated 
//									with the callback. The nature of this handle (line 
//									handle or call handle) can be determined by the context 
//									provided by dwMsg. Applications must use the DWORD type 
//									for this parameter because using the HANDLE type may 
//									generate an error. 
//				dwMessage			A line or call device message. 
//				dwCallbackInstance  Callback instance data passed back to the application 
//									in the callback. This DWORD is not interpreted by TAPI. 
//				dwParam1 			A parameter for the message. 
//				dwParam2 			A parameter for the message. 
//				dwParam3 			A parameter for the message. 
//
//  Returns:    VOID
//
//  Author:     billi  15/02/01
//
//  Notes:      
//
{
	TraceMsg(TF_ALWAYS, "RasTapiCallback");
	TraceMsg(TF_ALWAYS, "\t%lx, %lx, %lx, %lx, %lx, %lx", hDevice, dwMessage, dwInstance, dwParam1, dwParam2, dwParam3);
	return;
}



//+---------------------------------------------------------------------------
//
//  Function:   HrLineInitialize
//
//  Purpose:    
//
//  Arguments:  HLINEAPP* phRasLine
//              DWORD*    pdwLines
//
//  Returns:    HRESULT
//
//  Author:     billi  22/02/01
//
//  Notes:      
//
HRESULT HrLineInitialize( 
	HLINEAPP* phRasLine,
    DWORD*    pdwLines
    )
{
	HRESULT                 hr        = E_FAIL;
	DWORD                   dwVersion = HIGH_VERSION;
	LONG                    lError;
	LINEINITIALIZEEXPARAMS  param;
    
    ASSERT( phRasLine );
    ASSERT( pdwLines );
    
    *phRasLine = 0;
    *pdwLines  = 0;

	memset( &param, 0, sizeof (LINEINITIALIZEEXPARAMS) ) ;

	param.dwOptions   = LINEINITIALIZEEXOPTION_USEHIDDENWINDOW ;
	param.dwTotalSize = sizeof(param) ;

	// lineInitialize
    
    //TODO: Place application name in resource (for localization ) and make
    //      sure application name string is used throughout!

	lError = lineInitializeEx( phRasLine,
	                           g_hinst,
	                           (LINECALLBACK) RasTapiCallback,
	                           WIZARDNAME,
	                           pdwLines,
	                           &dwVersion,
	                           &param );

	TraceMsg(TF_GENERAL, "lineInitializeEx( %lx,", phRasLine );
	TraceMsg(TF_GENERAL, "                  %lx,", g_hinst );
	TraceMsg(TF_GENERAL, "                  %lx,", RasTapiCallback );
	TraceMsg(TF_GENERAL, "                  %s,", WIZARDNAME );
	TraceMsg(TF_GENERAL, "                  %lx = %lx,", pdwLines, *pdwLines );
	TraceMsg(TF_GENERAL, "                  %lx = %lx,", &dwVersion, dwVersion );
	TraceMsg(TF_GENERAL, "                  %lx", &param );
	TraceMsg(TF_GENERAL, "                  ) = %lx", lError );
        
    if ( ERROR_SUCCESS == lError )
    {
        hr = S_OK;
	}

	TraceMsg(TF_ALWAYS, "HrLineInitialize = %lx", hr);
    return hr;
}


HRESULT HrLineOpen( 
	HLINEAPP hRasLine, 
    DWORD    dwLine, 
    HLINE*   phLine, 
    DWORD*   pdwApiVersion, 
    DWORD*   pdwExtVersion,
    LPWSTR*  ppszwLineAddress
    )
//+---------------------------------------------------------------------------
//
//  Function:   HrLineOpen
//
//  Purpose:    
//
//  Arguments:  HLINEAPP hRasLine
//              DWORD    dwLine
//              HLINE*   phLine
//              DWORD*   pdwApiVersion
//              DWORD*   pdwExtVersion
//              LPWSTR*  ppszwLineAddress
//
//  Returns:    HRESULT
//
//  Author:     billi  22/02/01
//
//  Notes:      
//
{
	HRESULT          hr;
	LONG             lError;
	LINEEXTENSIONID  extensionid;
    
    ASSERT(phLine);
    ASSERT(pdwApiVersion);
    ASSERT(pdwExtVersion);
    ASSERT(ppszwLineAddress);

    hr                = E_FAIL;
    *phLine           = 0;
    *pdwApiVersion    = 0;
    *pdwExtVersion    = 0;
    *ppszwLineAddress = NULL;

    lError = lineNegotiateAPIVersion( hRasLine,
	                                  dwLine,
	                                  LOW_VERSION,
	                                  HIGH_VERSION,
	                                  pdwApiVersion,
	                                  &extensionid );

    TraceMsg(TF_GENERAL, "lineNegotiateAPIVersion( %lx,", hRasLine);
    TraceMsg(TF_GENERAL, "                         %lx,", dwLine);
    TraceMsg(TF_GENERAL, "                         %lx,", LOW_VERSION);
    TraceMsg(TF_GENERAL, "                         %lx,", HIGH_VERSION);
    TraceMsg(TF_GENERAL, "                         %lx = %lx,", pdwApiVersion, *pdwApiVersion);
    TraceMsg(TF_GENERAL, "                         %lx = %lx", &extensionid, extensionid);
    TraceMsg(TF_GENERAL, "                         ) = %lx", lError);

	if ( ERROR_SUCCESS == lError )
    {                                      
	    LINECALLPARAMS  lineparams;
        
    	lError = lineOpen( hRasLine, dwLine, phLine,
        				   *pdwApiVersion,
                           *pdwExtVersion, 0,
                           LINECALLPRIVILEGE_NONE,
                           LINEMEDIAMODE_DIGITALDATA,
                           &lineparams );

        TraceMsg(TF_GENERAL, "lineOpen( %lx,", hRasLine);
        TraceMsg(TF_GENERAL, "          %lx,", dwLine);
        TraceMsg(TF_GENERAL, "          %lx = %lx,", phLine, *phLine);
        TraceMsg(TF_GENERAL, "          %lx,", *pdwApiVersion);
        TraceMsg(TF_GENERAL, "          %lx,", *pdwExtVersion);
        TraceMsg(TF_GENERAL, "          %lx,", 0);
        TraceMsg(TF_GENERAL, "          %lx,", LINECALLPRIVILEGE_NONE);
        TraceMsg(TF_GENERAL, "          %lx,", LINEMEDIAMODE_DIGITALDATA);
        TraceMsg(TF_GENERAL, "          %lx", &lineparams);
        TraceMsg(TF_GENERAL, "          ) = %lx", lError);
        
        if ( ERROR_SUCCESS == lError )
        {
        	DWORD dwSize = 1024;
        
        	for ( int i=0; (i<2)&&(E_FAIL==hr); i++ )
            {
            	BYTE* Buffer = new BYTE[ dwSize ];
                
                if ( NULL != Buffer )
                {
                	LPLINEADDRESSCAPS lpCaps = (LPLINEADDRESSCAPS)Buffer;
                    
                    lpCaps->dwTotalSize = dwSize * sizeof(BYTE);
                    
		        	lError = lineGetAddressCaps( hRasLine, dwLine, 0,
			  		         				     *pdwApiVersion,
			  		                             *pdwExtVersion,
	                                             lpCaps );
                                         
					if ( ERROR_SUCCESS == lError )
                    {
				        TraceMsg(TF_GENERAL, "\tdwTotalSize     = %lx", lpCaps->dwTotalSize);
				        TraceMsg(TF_GENERAL, "\tdwNeededSize    = %lx", lpCaps->dwNeededSize);
				        TraceMsg(TF_GENERAL, "\tdwUsedSize      = %lx", lpCaps->dwUsedSize);
				        TraceMsg(TF_GENERAL, "\tdwAddressSize   = %lx", lpCaps->dwAddressSize);
				        TraceMsg(TF_GENERAL, "\tdwAddressOffset = %lx", lpCaps->dwAddressOffset);
                        
                        if ( ( 0 < lpCaps->dwAddressOffset ) &&
                             ( 0 < lpCaps->dwAddressSize ) )
                        {
                        	LPWSTR lpsz = (LPWSTR)((CHAR*)lpCaps + lpCaps->dwAddressOffset);
                            
                            if ( lpsz )
                            {
                            	LPWSTR lpBuf = new WCHAR[ lpCaps->dwAddressSize / sizeof(WCHAR) + 1 ];
                                
                                if ( NULL != lpBuf )
                                {
                                	memcpy( lpBuf, lpsz, lpCaps->dwAddressSize );
                                    lpBuf[ lpCaps->dwAddressSize / sizeof(WCHAR) ] = 0;
                                    
		                        	*ppszwLineAddress = lpBuf;
							        TraceMsg(TF_ALWAYS, "\tdwAddress       = %s", lpBuf);
                                }
							}
                        }
        
			        	hr = S_OK;
					}
		            else if ( LINEERR_STRUCTURETOOSMALL == lError )
		            {
		            	dwSize = lpCaps->dwNeededSize;
		            }
                    else
                    {
                    	i = 2;	// drop out of for loop
                    }
                    
                    delete [] Buffer;
                }
                else
                {
                	hr = E_OUTOFMEMORY;
                }
                
			}	//	for ( int i=0; i<2; i++ )
            
            if ( FAILED(hr) )
            {
            	lineClose( *phLine );
                *phLine = 0;
            }
            
        }	//	if ( ERROR_SUCCESS == lError )
        
    }	//	if ( ERROR_SUCCESS == lError )

	TraceMsg(TF_ALWAYS, "HrLineOpen = %lx", hr);
    return hr;
}



HRESULT HrGetCallList( 
	HLINE   hLine, 
    DWORD*  pdwNumber,
    HCALL** ppList
    )
//+---------------------------------------------------------------------------
//
//  Function:   HrGetCallList
//
//  Purpose:    
//
//  Arguments:  HLINE   hLine
//              DWORD*  pdwNumber
//              HCALL** ppList
//
//  Returns:    HRESULT
//
//  Author:     billi  22/02/01
//
//  Notes:      
//
{
	HRESULT        hr     = E_FAIL;
    DWORD          dwSize = 1024;
    
    ASSERT( ppList );
    ASSERT( pdwNumber );
    
    *ppList    = NULL;
    *pdwNumber = 0;
    
    for ( int i=0; (i<2)&&(E_FAIL==hr); i++ )
    {
	    BYTE* Buffer = new BYTE[ dwSize ];
        
        if ( NULL != Buffer )
        {
			LONG           lError;
		    LPLINECALLLIST lpList = (LPLINECALLLIST)Buffer;

            ZeroMemory( lpList, dwSize*sizeof(BYTE) );
		    lpList->dwTotalSize = dwSize * sizeof(BYTE);
		    
		    lError = lineGetNewCalls( hLine, 0, LINECALLSELECT_LINE, lpList );
		                              
		    TraceMsg(TF_GENERAL, "lineGetNewCalls( %lx,", hLine);
			TraceMsg(TF_GENERAL, "                 %lx,", 0);
			TraceMsg(TF_GENERAL, "                 %lx,", LINECALLSELECT_LINE);
			TraceMsg(TF_GENERAL, "                 %lx,", lpList);
		    TraceMsg(TF_GENERAL, "                 ) = %lx", lError);

		    if ( ERROR_SUCCESS == lError )
		    {
		        DWORD  dwNumber;
		    
		        TraceMsg(TF_GENERAL, "\tdwTotalSize       = %lx", lpList->dwTotalSize);
		        TraceMsg(TF_GENERAL, "\tdwNeededSize      = %lx", lpList->dwNeededSize);
		        TraceMsg(TF_GENERAL, "\tdwUsedSize        = %lx", lpList->dwUsedSize);
		        TraceMsg(TF_GENERAL, "\tdwCallsNumEntries = %lx", lpList->dwCallsNumEntries);
		        TraceMsg(TF_GENERAL, "\tdwCallsSize       = %lx", lpList->dwCallsSize);
		        TraceMsg(TF_GENERAL, "\tdwCallsOffset     = %lx", lpList->dwCallsOffset);

		        dwNumber = lpList->dwCallsNumEntries;
                ASSERT(dwNumber);
                
                if ( 0 < dwNumber )
                {
			    	HCALL *pCalls = new HCALL[ dwNumber ];
			        
			        if ( NULL != pCalls )
			        {
			        	memcpy( pCalls, (Buffer + lpList->dwCallsOffset), dwNumber*sizeof(HCALL) );
			            
			            *pdwNumber = dwNumber;
			        	*ppList    = pCalls;
			    	    hr         = S_OK;
			        }
			        else
			        {
			        	hr = E_OUTOFMEMORY;
			        }
                }
                else
                {
                	hr = E_UNEXPECTED;
                }
                
		    }
            else if ( LINEERR_STRUCTURETOOSMALL == lError )
            {
            	dwSize = lpList->dwNeededSize;
            }
            else
            {
            	i = 2;	// break out of for loop
            }
            
            delete [] Buffer;
		
        }	//	if ( NULL != Buffer )
        else
        {
        	hr = E_OUTOFMEMORY;
            break;
        }
        
	}	//	for ( int i=0; i<2; i++ )

	TraceMsg(TF_ALWAYS, "HrGetCallList = %lx", hr);
    return hr;
}



HRESULT HrGetSourceMacAddr( HCALL hCall, BYTE** ppMacAddress )
//+---------------------------------------------------------------------------
//
//  Function:   HrGetSourceMacAddr
//
//  Purpose:    
//
//  Arguments:  HCALL  hCall
//
//  Returns:    HRESULT
//
//  Author:     billi  22/02/01
//
//  Notes:      
//
{
	HRESULT hr     = E_FAIL;
    DWORD   dwSize = sizeof(LINECALLINFO) + 3*TAPI_STATION_ID_SIZE;
    
    ASSERT( ppMacAddress );
    
    *ppMacAddress = NULL;
    
    for ( int i=0; (i<2)&&(E_FAIL==hr); i++ )
    {
        BYTE* Buffer = new BYTE[ dwSize ];
        
        if ( NULL != Buffer )
        {
            LONG           lError;
            LPLINECALLINFO lpInfo = (LPLINECALLINFO)Buffer;
             
            ZeroMemory( lpInfo, dwSize*sizeof(BYTE) );
            lpInfo->dwTotalSize = dwSize * sizeof(BYTE);

            lError = lineGetCallInfo( hCall, lpInfo );

            TraceMsg(TF_ALWAYS, "lineGetCallInfo( %lx, %lx ) = %lx", hCall, lpInfo, lError);
                
            if ( ERROR_SUCCESS == lError )
            {
                TraceMsg(TF_ALWAYS, "\tdwTotalSize       = %lx", lpInfo->dwTotalSize);
                TraceMsg(TF_ALWAYS, "\tdwNeededSize      = %lx", lpInfo->dwNeededSize);
                TraceMsg(TF_ALWAYS, "\tdwUsedSize        = %lx", lpInfo->dwUsedSize);
                TraceMsg(TF_ALWAYS, "\tdwCallerIDFlags   = %lx", lpInfo->dwCallerIDFlags);
                TraceMsg(TF_ALWAYS, "\tdwCallerIDSize    = %lx", lpInfo->dwCallerIDSize);
                TraceMsg(TF_ALWAYS, "\tdwCallerIDOffset  = %lx", lpInfo->dwCallerIDOffset);
                TraceMsg(TF_ALWAYS, "\tdwCalledIDFlags   = %lx", lpInfo->dwCalledIDFlags);
                TraceMsg(TF_ALWAYS, "\tdwCalledIDSize    = %lx", lpInfo->dwCalledIDSize);
                TraceMsg(TF_ALWAYS, "\tdwCalledIDOffset  = %lx", lpInfo->dwCalledIDOffset);
            
                if ( ( 0 < lpInfo->dwCalledIDOffset ) && 
                     ( 0 < lpInfo->dwCalledIDSize ) )
                {
                    PBYTE lpAddr;

                    lpAddr = ( (PBYTE) lpInfo ) + lpInfo->dwCallerIDOffset;
                    
                    if ( lpAddr )
                    {
                        TraceMsg(TF_ALWAYS, "\t%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x", 
                        lpAddr[0], lpAddr[1], lpAddr[2], lpAddr[3], lpAddr[4], lpAddr[5],
                        lpAddr[6], lpAddr[7], lpAddr[8], lpAddr[9], lpAddr[10], lpAddr[11] );
                    }
                    
                    // The local address from the ndis binding is in dwCalledIDOffset
                    // The server address is in dwCallerIDOffset
                    
                    lpAddr = ( (PBYTE) lpInfo ) + lpInfo->dwCalledIDOffset;
                    
                    if ( lpAddr )
                    {
                        DWORD dwSize = lpInfo->dwCalledIDSize;
                        PBYTE lpBuf  = new BYTE[ dwSize ];
                        
                        TraceMsg(TF_ALWAYS, "\t%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x", 
                        lpAddr[0], lpAddr[1], lpAddr[2], lpAddr[3], lpAddr[4], lpAddr[5],
                        lpAddr[6], lpAddr[7], lpAddr[8], lpAddr[9], lpAddr[10], lpAddr[11] );
                        
                        if ( NULL != lpBuf )
                        {
                            memset( lpBuf, NULL, sizeof(lpBuf) );
                        
                            for ( DWORD j=0; j<dwSize/2; j++ )
                            {
                                lpBuf[j] = lpAddr[2*j];
                            }
                        
                            *ppMacAddress = lpBuf;
                            hr = S_OK;
                        }
                    }
                }
                else if ( lpInfo->dwNeededSize > lpInfo->dwTotalSize )
                {
                    dwSize = lpInfo->dwNeededSize + 1;
                }
            }
            else if ( LINEERR_STRUCTURETOOSMALL == lError )
            {
                dwSize = lpInfo->dwNeededSize + 1;
            }
            else
            {
                i = 2;    // break out of for loop
            }
            
            delete [] Buffer;

        }    //    if ( NULL != Buffer )
        else
        {
            hr = E_OUTOFMEMORY;
            break;
        }
        
    }    //    for ( int i=0; i<2; i++ )

    TraceMsg(TF_ALWAYS, "HrGetSourceMacAddr = %lx", hr);
    return hr;
}



HRESULT HrCompareMacAddresses( 
    INetConnection*  pConnection,
    HLINE            hLine,
    BOOL*            pfAssociated 
    )
//+---------------------------------------------------------------------------
//
//  Function:   HrCompareMacAddresses
//
//  Purpose:    
//
//  Arguments:  INetConnection*  pConnection
//              HLINE            hLine
//              BOOL*            pfAssociated 
//
//  Returns:    HRESULT
//
//  Author:     billi  22/02/01
//
//  Notes:      
//
{
    HRESULT hr;
    HCALL*  pList    = NULL;
    DWORD   dwNumber = 0;
    
    ASSERT( pConnection );
    ASSERT( pfAssociated );
    
    *pfAssociated = FALSE;
                
    hr = HrGetCallList( hLine, &dwNumber, &pList );
    
    if ( SUCCEEDED(hr) )
    {
        PIP_ADAPTER_INFO  pInfo;

        hr = HrGetAdapterInfo( pConnection, &pInfo );
        
        if ( SUCCEEDED(hr) )
        {
            for ( DWORD i=0; i<dwNumber; i++ )
            {
                PBYTE pMacAddress;
            
                hr = HrGetSourceMacAddr( pList[i], &pMacAddress );
                
                if ( SUCCEEDED(hr) )
                {
                    TraceMsg(TF_ALWAYS, 
                             "memcmp( %lx, %lx, %lx, %lx )", 
                             pMacAddress, pInfo->Address, pInfo->AddressLength, TAPI_STATION_ID_SIZE);
                             
                    TraceMsg(TF_ALWAYS, "\t%02x %02x %02x %02x %02x %02x", 
                    pMacAddress[0], pMacAddress[1], pMacAddress[2], 
                    pMacAddress[3], pMacAddress[4], pMacAddress[5] );
                    
                    TraceMsg(TF_ALWAYS, "\t%02x %02x %02x %02x %02x %02x", 
                    pInfo->Address[0], pInfo->Address[1], pInfo->Address[2], 
                    pInfo->Address[3], pInfo->Address[4], pInfo->Address[5] );
                    
                    if ( !memcmp( pMacAddress, pInfo->Address, TAPI_STATION_ID_SIZE ) )
                    {
                        TraceMsg(TF_ALWAYS, "\tFound It!");
                        *pfAssociated = TRUE;
                        i             = dwNumber;    // break out of for loop
                    }
                
                    delete pMacAddress;
                }
                
            }    //    for ( DWORD i=0; i<dwNumber; i++ )
            
            delete pInfo;
        }
    
        delete pList;
    }
                    
    TraceMsg(TF_ALWAYS, "HrCompareMacAddresses = %lx", hr);
    return hr;
}



HRESULT HrCheckMacAddress( 
    INetConnection*  pConnection,
    NETCON_MEDIATYPE MediaType,
    BOOL*            pfAssociated 
    )
//+---------------------------------------------------------------------------
//
//  Function:   HrCheckMacAddress
//
//  Purpose:    
//
//  Arguments:  INetConnection*  pConnection
//              NETCON_MEDIATYPE MediaType 
//              BOOL*            pfAssociated 
//
//  Returns:    HRESULT
//
//  Author:     billi  22/02/01
//
//  Notes:      
//
{
    HRESULT  hr;
    HLINEAPP hRasLine = 0;
    DWORD    dwLines  = 0;
    
    ASSERT( pConnection );
    ASSERT( pfAssociated );
    
    *pfAssociated = FALSE;

    hr = HrLineInitialize( &hRasLine, &dwLines );
    
    if ( SUCCEEDED(hr) )
    {
        for ( DWORD i=0; i<dwLines; i++ )
        {                         
            DWORD  dwApiVersion   = 0;
            DWORD  dwExtVersion   = 0;
            HLINE  hLine          = 0;
            LPWSTR pszwLineAddress = NULL;
            
            hr = HrLineOpen( hRasLine, i, &hLine, &dwApiVersion, &dwExtVersion, &pszwLineAddress );
            
            if ( SUCCEEDED(hr) && pszwLineAddress )
            {
                if ( (NCM_TUNNEL == MediaType) && 
                     !wcscmp(pszwLineAddress, PPTP_LINE_ADDR_STRING) )
                {
                    TraceMsg(TF_ALWAYS, "MediaType match %s!", PPTP_LINE_ADDR_STRING);
                    hr = S_OK;
                }
                else if ( (NCM_PPPOE == MediaType) &&
                     !wcscmp(pszwLineAddress, PPPOE_LINE_ADDR_STRING) )
                {
                    TraceMsg(TF_ALWAYS, "MediaType match %s!", PPPOE_LINE_ADDR_STRING);
                    hr = S_OK;
                }
/*                
                else if ( (NCM_PHONE == MediaType) &&
                     !wcscmp(pszwLineAddress, PPPOE_LINE_ADDR_STRING) )
                {
                    TraceMsg(TF_ALWAYS, "MediaType match %s!", PPPOE_LINE_ADDR_STRING);
                    hr = S_OK;
                }
*/
                else
                {
                    TraceMsg(TF_ALWAYS, "MediaType mismatch");
                    hr = E_FAIL;
                }
                
                if ( SUCCEEDED(hr) )
                {
                    hr = HrCompareMacAddresses( pConnection, hLine, pfAssociated );
                    
                    if ( SUCCEEDED(hr) && *pfAssociated )
                    {
                        i = dwLines;    // break out of for loop
                    }
                }
                
                if ( NULL != pszwLineAddress )
                {
                    delete [] pszwLineAddress;
                }
                
                lineClose( hLine );
            }
            
        }    //    for ( DWORD i=0; i<dwLines; i++ )
    
        lineShutdown( hRasLine ) ;
    }

    TraceMsg(TF_ALWAYS, "HrCheckMacAddress = %lx", hr);
    return hr;
}



HRESULT HrConnectionAssociatedWithSharedConnection( 
    INetConnection* pPrivate, 
    INetConnection* pShared, 
    BOOL*           pfAssociated 
    )
//+---------------------------------------------------------------------------
//
//  Function:   HrConnectionAssociatedWithSharedConnection
//
//  Purpose:    
//
//  Arguments:  INetConnection* pPrivate
//              INetConnection* pShared
//
//  Returns:    HRESULT
//
//  Author:     billi  26/01/01
//
//  Notes:      
//
{
    HRESULT hr = S_OK;
    
    ASSERT( pPrivate );
    ASSERT( pfAssociated );
    
    // False by default
    *pfAssociated = FALSE;
    
    if ( NULL != pShared )
    {
        NETCON_PROPERTIES* pProps = NULL;

        hr = pShared->GetProperties( &pProps );
    
        if ( SUCCEEDED(hr) )
        {
            INetRasConnection* pRasShared = NULL;
            
            TraceMsg(TF_ALWAYS, "MediaType = %lx", pProps->MediaType);

            switch ( pProps->MediaType )
            {
            case NCM_TUNNEL:
                hr = pShared->QueryInterface( IID_PPV_ARG(INetRasConnection, &pRasShared) );
            
                if ( SUCCEEDED(hr) )
                {
                    hr = HrCheckVPNForRoute( pPrivate, pRasShared, pProps, pfAssociated );
                    
                    pRasShared->Release();
                }
                break;

            case NCM_PPPOE:
                if ( pProps->Status == NCS_DISCONNECTED )
                {
                    hr = pShared->QueryInterface( IID_PPV_ARG(INetRasConnection, &pRasShared) );
                
                    if ( SUCCEEDED(hr) )
                    {
                        // We are in a bad fix if the connection is in an
                        // intermediate state or a failure state
                     
                        hr = HrRasDialDlg( pRasShared );
                        
                        pRasShared->Release();
                    }
                }
                
                if ( SUCCEEDED(hr) )
                {
                    hr = HrCheckMacAddress( pPrivate, pProps->MediaType, pfAssociated );
                }
                break;

            default:
                // leave hr as succeeded
                // leave pfAssociated = FALSE
                break;
            }
        
            NcFreeNetconProperties( pProps );
            
            if ( FAILED(hr) )
            {
                // We want this call to succeed.  If there were problems then 
                // we simply report that the connections weren't associated
                *pfAssociated = FALSE;

                // Whether it succeeds or not we need to return S_OK
                // The wizard should not fail because we can't determine the
                // correct adapter.
                hr = S_OK;
            }
        }    
    }
    
    TraceMsg(TF_ALWAYS, "HrConnectionAssociatedWithSharedConnection = %lx  fAssociated = %lx", hr, *pfAssociated );
    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\hnw\wizard\netenum.cpp ===
//
// NetEnum.cpp
//
//        Functions to enumerate computers and/or shares on the network
//

#include "stdafx.h"
#include "NetEnum.h"
#include "NetUtil.h"
#include "Util.h"

static CNetEnum* g_pNetEnum = NULL;


//////////////////////////////////////////////////////////////////////////////

void InitNetEnum()
{
    ASSERT(g_pNetEnum == NULL);
    g_pNetEnum = new CNetEnum;
}

void TermNetEnum()
{
    delete g_pNetEnum;
}

void EnumComputers(NETENUMCALLBACK pfnCallback, LPVOID pvCallbackParam)
{
    if (g_pNetEnum)
        g_pNetEnum->EnumComputers(pfnCallback, pvCallbackParam);
}


//////////////////////////////////////////////////////////////////////////////

CNetEnum::CNetEnum()
{
    m_hThread = NULL;
    InitializeCriticalSection(&m_cs);
    m_bAbort = FALSE;
}

CNetEnum::~CNetEnum()
{
    m_bAbort = TRUE;

    // Wait for the thread to die
    EnterCriticalSection(&m_cs);
    HANDLE hThread = m_hThread;
    m_hThread = NULL;
    LeaveCriticalSection(&m_cs);
    if (hThread != NULL)
    {
        WaitForSingleObject(hThread, INFINITE);
        CloseHandle(hThread);
    }

    DeleteCriticalSection(&m_cs);
}

void CNetEnum::Abort()
{
    EnterCriticalSection(&m_cs);
    m_bAbort = TRUE;
    LeaveCriticalSection(&m_cs);
}

void CNetEnum::EnumComputers(NETENUMCALLBACK pfnCallback, LPVOID pvCallbackParam)
{
    EnumHelper(jtEnumComputers, pfnCallback, pvCallbackParam);
}

void CNetEnum::EnumNetPrinters(NETENUMCALLBACK pfnCallback, LPVOID pvCallbackParam)
{
    EnumHelper(jtEnumPrinters, pfnCallback, pvCallbackParam);
}

void CNetEnum::EnumHelper(JOBTYPE eJobType, NETENUMCALLBACK pfnCallback, LPVOID pvCallbackParam)
{
    EnterCriticalSection(&m_cs);
    HANDLE hThread = m_hThread;
    m_pfnCallback = pfnCallback;
    m_pvCallbackParam = pvCallbackParam;
    m_eJobType = eJobType;
    m_bAbort = FALSE;
    m_bNewJob = TRUE; // if thread in progress, tell it to start a new job
    LeaveCriticalSection(&m_cs);

    if (hThread == NULL)
    {
        DWORD dwThreadId;
        m_hThread = CreateThread(NULL, 0, EnumThreadProc, this, CREATE_SUSPENDED, &dwThreadId);
        if (m_hThread)
        {
            ResumeThread(m_hThread);
        }
    }
}

DWORD WINAPI CNetEnum::EnumThreadProc(LPVOID pvParam)
{
    ((CNetEnum*)pvParam)->EnumThreadProc();
    return 0;
}

#ifdef _DEBUG
void TraceNetResource(const NETRESOURCE* pNetRes)
{
    DWORD dwScope = pNetRes->dwScope;
    DWORD dwType = pNetRes->dwType;
    DWORD dwDisplayType = pNetRes->dwDisplayType;
    DWORD dwUsage = pNetRes->dwUsage;
    TRACE("NETRESOURCE (0x%08X):\n\tdwScope = %s\n\tdwType = %s\n\tdwDisplayType = %s\n\tdwUsage = %s\n\tlpLocalName = %s\n\tlpRemoteName = %s\n\tlpComment = %s\n\tlpProvider = %s\n",
        (DWORD_PTR)pNetRes,
        (dwScope == RESOURCE_CONNECTED) ? "RESOURCE_CONNECTED" : (dwScope == RESOURCE_GLOBALNET) ? "RESOURCE_GLOBALNET" : (dwScope == RESOURCE_REMEMBERED) ? "RESOURCE_REMEMBERED" : "(unknown)",
        (dwType == RESOURCETYPE_ANY) ? "RESOURCETYPE_ANY" : (dwType == RESOURCETYPE_DISK) ? "RESOURCETYPE_DISK" : (dwType == RESOURCETYPE_PRINT) ? "RESOURCETYPE_PRINT" : "(unknown)",
        (dwDisplayType == RESOURCEDISPLAYTYPE_DOMAIN) ? "RESOURCEDISPLAYTYPE_DOMAIN" : (dwDisplayType == RESOURCEDISPLAYTYPE_GENERIC) ? "RESOURCEDISPLAYTYPE_GENERIC" : (dwDisplayType == RESOURCEDISPLAYTYPE_SERVER) ? "RESOURCEDISPLAYTYPE_SERVER" : (dwDisplayType == RESOURCEDISPLAYTYPE_SHARE) ? "RESOURCEDISPLAYTYPE_SHARE" : "(unknown)",
        (dwUsage == RESOURCEUSAGE_CONNECTABLE) ? "RESOURCEUSAGE_CONNECTABLE" : (dwUsage == RESOURCEUSAGE_CONTAINER) ? "RESOURCEUSAGE_CONTAINER" : "(unknown)",
        pNetRes->lpLocalName == NULL ? L"(null)" : pNetRes->lpLocalName,
        pNetRes->lpRemoteName == NULL ? L"(null)" : pNetRes->lpRemoteName,
        pNetRes->lpComment == NULL ? L"(null)" : pNetRes->lpComment,
        pNetRes->lpProvider == NULL ? L"(null)" : pNetRes->lpProvider);
}
#endif

void CNetEnum::EnumThreadProc()
{
    // Init stuff we don't want to do more than once
    NETRESOURCE* prgNetResOuter = (NETRESOURCE*)malloc(1024);
    NETRESOURCE* prgNetResInnerT = (NETRESOURCE*)malloc(1024);
    TCHAR szComputerName[MAX_COMPUTERNAME_LENGTH+1];
    DWORD cch = _countof(szComputerName);
    GetComputerName(szComputerName, &cch);

    HANDLE hEnumOuter = NULL;

begin:
    // If the job ID changes out from under us, that means we need to stop
    // the current task and jump back to the beginning.
    EnterCriticalSection(&m_cs);
    JOBTYPE eJobType = m_eJobType;
    m_bNewJob = FALSE;
    LeaveCriticalSection(&m_cs);

    // Close enumeration left open by a previous job
    if (hEnumOuter != NULL)
    {
        WNetCloseEnum(hEnumOuter);
        hEnumOuter = NULL;
    }

#ifdef _DEBUG
//    Sleep(eJobType == jtEnumComputers ? 6000 : 12000); // simulate WNetOpenEnum taking a long time
#endif

    // REVIEW: should we look for computers outside the current workgroup?
    DWORD dwResult;
    if (eJobType == jtEnumComputers)
    {
        dwResult = WNetOpenEnum(RESOURCE_CONTEXT, RESOURCETYPE_ANY, RESOURCEUSAGE_CONTAINER,
                            NULL, &hEnumOuter);
    }
    else
    {
        ASSERT(eJobType == jtEnumPrinters);
        dwResult = WNetOpenEnum(RESOURCE_CONTEXT, RESOURCETYPE_PRINT, RESOURCEUSAGE_CONNECTABLE,
                            NULL, &hEnumOuter);
    }

    if (dwResult == NO_ERROR)
    {
        if (m_bAbort) goto cleanup;
        if (m_bNewJob) goto begin;

        BOOL bCallbackResult = TRUE;

        // Keep looping until no more items
        for (;;)
        {
            DWORD cOuterEntries = 20;
            DWORD cbBuffer = 1024;
            dwResult = WNetEnumResource(hEnumOuter, &cOuterEntries, prgNetResOuter, &cbBuffer);

            if (dwResult == ERROR_NO_MORE_ITEMS)
                break;

            for (DWORD iOuter = 0; iOuter < cOuterEntries; iOuter++)
            {
                NETRESOURCE* pNetResOuter = &prgNetResOuter[iOuter];
                BOOL bDoCallback = FALSE;

                #ifdef _DEBUG
                    if (eJobType == jtEnumPrinters)
                        TraceNetResource(pNetResOuter);
                #endif

                if (pNetResOuter->dwDisplayType != RESOURCEDISPLAYTYPE_SERVER)
                    continue;

                if (DoComputerNamesMatch(pNetResOuter->lpRemoteName, szComputerName))
                    continue;

                HANDLE hEnumInner = NULL;

                if (eJobType == jtEnumPrinters)
                {
                    #ifdef _DEBUG
                        DWORD dwTicksBefore = GetTickCount();
                    #endif

                    dwResult = WNetOpenEnum(RESOURCE_GLOBALNET, RESOURCETYPE_PRINT, RESOURCEUSAGE_CONNECTABLE,
                                    pNetResOuter, &hEnumInner);

                    #ifdef _DEBUG
                        DWORD dwTicks = GetTickCount() - dwTicksBefore;
                        if (dwTicks > 100)
                        {
                            TRACE("PERFORMANCE NOTE - took %d.%d sec to look for printers on %s\r\n", dwTicks / 1000, (dwTicks % 1000) - (dwTicks % 100), pNetResOuter->lpRemoteName);
                        }
                    #endif

                    if (dwResult != NO_ERROR)
                        continue;
                }

                for (;;)
                {
                    DWORD cInnerEntries;
                    const NETRESOURCE* prgNetResInner = NULL;

                    if (eJobType == jtEnumPrinters)
                    {
                        cInnerEntries = 20;
                        cbBuffer = 1024;
                        dwResult = WNetEnumResource(hEnumInner, &cInnerEntries, prgNetResInnerT, &cbBuffer);
                        if (dwResult == ERROR_NO_MORE_ITEMS)
                            break;
                        prgNetResInner = prgNetResInnerT;
                    }
                    else
                    {
                        cInnerEntries = 1;
                        prgNetResInner = prgNetResOuter + iOuter;
                    }

                    for (DWORD iInner = 0; iInner < cInnerEntries; iInner++)
                    {
                        const NETRESOURCE* pNetResInner = &prgNetResInner[iInner];
                        LPCTSTR pszShareName;

                        #ifdef _DEBUG
                            if (eJobType == jtEnumPrinters)
                                TraceNetResource(pNetResInner);
                        #endif

                        if (eJobType == jtEnumComputers)
                        {
                            if (pNetResInner->dwDisplayType == RESOURCEDISPLAYTYPE_SERVER)
                            {
                                bDoCallback = TRUE;
                                pszShareName = NULL;
                            }
                        }
                        else // eJobType == jtEnumPrinters
                        {
                            bDoCallback = TRUE;
                            pszShareName = FindFileTitle(pNetResInner->lpRemoteName);
                        }

                        // We must call the callback inside the same critical section where
                        // we check if we should stop or restart, otherwise we might call
                        // the wrong callback!
                        // TODO: Get the real printer share name!!
                        EnterCriticalSection(&m_cs);
                        if (m_bAbort || m_bNewJob)
                            bCallbackResult = FALSE;
                        else if (bDoCallback)
                            bCallbackResult = (*m_pfnCallback)(m_pvCallbackParam, pNetResOuter->lpRemoteName, pszShareName);
                        LeaveCriticalSection(&m_cs);

                        if (!bCallbackResult)
                            break;
                    }

                    if (eJobType == jtEnumComputers)
                        break;
                }

                if (eJobType == jtEnumPrinters)
                {
                    WNetCloseEnum(hEnumInner);
                }
            }

            if (m_bAbort) goto cleanup;
            if (m_bNewJob) goto begin;

            if (!bCallbackResult)
                break;
        }
    }

cleanup:
    if (hEnumOuter != NULL)
    {
        WNetCloseEnum(hEnumOuter);
        hEnumOuter = NULL;
    }

    // Be careful to close m_hThread only if we don't need to start another job
    {
        EnterCriticalSection(&m_cs);

        BOOL bThreadDone = (m_bAbort || !m_bNewJob);
        if (bThreadDone)
        {
            // Call callback function one more time
            if (!m_bAbort)
            {
                (*m_pfnCallback)(m_pvCallbackParam, NULL, NULL);
            }

            CloseHandle(m_hThread);
            m_hThread = NULL;
        }
        LeaveCriticalSection(&m_cs);

        // Check if another job has been requested
        if (!bThreadDone)
            goto begin;
    }

    free(prgNetResInnerT);
    free(prgNetResOuter);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\hnw\wizard\netutil.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997 - 2000
//
//  File:       N E T U T I L . H
//
//  Contents:   
//
//  Notes:
//
//  Author:     
//
//  History:    billi   07 03 2001     Added HrFromWin32Error and HrFromLastWin32Error
//
//----------------------------------------------------------------------------


#pragma once


BOOL    IsComputerNameValid(LPCTSTR pszName);
BOOL    GetWorkgroupName(LPTSTR pszBuffer, int cchBuffer);
BOOL    SetWorkgroupName(LPCTSTR pszWorkgroup);
BOOL    DoComputerNamesMatch(LPCTSTR pszName1, LPCTSTR pszName2);
void    MakeComputerNamePretty(LPCTSTR pszUgly, LPTSTR pszPretty, int cchPretty);
LPTSTR  FormatShareNameAlloc(LPCTSTR pszComputerName, LPCTSTR pszShareName);
LPTSTR  FormatShareNameAlloc(LPCTSTR pszComputerAndShare);


#define MAX_WORKGROUPNAME_LENGTH MAX_COMPUTERNAME_LENGTH
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\hnw\wizard\netip.cpp ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997 - 2000
//
//  File:       N E T I P. C P P
//
//  Contents:   Routines supporting RAS interoperability
//
//  Notes:
//
//  Author:     billi   07 03 2001
//
//  History:    
//
//----------------------------------------------------------------------------


#include "stdafx.h"
#include "Util.h"				  
#include "TheApp.h"

#include <lmjoin.h>
#include <devguid.h>
          
#include "NetIp.h"
#include "netutil.h"



HRESULT HrGetHostIpList( char* pszHost, IPAddr* pIpAddress, LPHOSTENT* ppHostEnt )
//+---------------------------------------------------------------------------
//
// Function:  HrGetHostIpList
//
// Purpose:   
//
// Arguments: 
//
// Returns:   S_OK on success, otherwise an error code
//
// Notes: 
//
{
    ASSERT( pszHost );
    ASSERT( pIpAddress );
    ASSERT( ppHostEnt );
    
    HRESULT hr = E_INVALIDARG;
    
    if ( pIpAddress )
        *pIpAddress = INADDR_NONE;

    if ( ppHostEnt )
        *ppHostEnt  = NULL;
    
    if ( pszHost && ( pIpAddress || ppHostEnt ) )
    {
        hr = E_FAIL;
    
        *pIpAddress = inet_addr( pszHost );
        
        if ( INADDR_NONE == *pIpAddress )
        {
            LPHOSTENT pHost;
        
            pHost = gethostbyname( pszHost );
            
            if ( pHost && pHost->h_addr_list )
            {
#ifdef DBG   // checked build
                for ( DWORD i=0; pHost->h_addr_list[i]; i++ )
                {
                    char*  pszName = (char *)(pHost->h_addr_list[i]) + sizeof(DWORD);
                    DWORD* pdwAddr = (DWORD *)(pHost->h_addr_list[i]);
                    struct in_addr in;
                    
                    in.S_un.S_addr = *pdwAddr;
                    char*  pszAddr = inet_ntoa( in );
                
                    TraceMsg(TF_ALWAYS, "    Addr[%d] = %S     %p     %S", i, pszName, pdwAddr, pszAddr );
                }
#endif // DBG 

                if ( pIpAddress )
                    *pIpAddress  = *(IPAddr*)(pHost->h_addr);

                if ( ppHostEnt )
                    *ppHostEnt   = pHost;
            }
        }

        if ( INADDR_NONE != *pIpAddress )
        {
            hr = S_OK;
        }
    }

    TraceMsg(TF_ALWAYS, "HrGetHostIpList = %lx  pHostEnt = %lx  IpAddress = %lx", hr, *ppHostEnt, *pIpAddress );
    return hr;
}



HRESULT HrGetHostIpList( WCHAR* pszwHost, IPAddr* pIpAddress, LPHOSTENT* ppHostEnt )
//+---------------------------------------------------------------------------
//
// Function:  HrGetHostIpList
//
// Purpose:   
//
// Arguments: 
//
// Returns:   S_OK on success, otherwise an error code
//
// Notes: 
//
{
    HRESULT hr;
    char*   pszHost = NULL;

    hr = HrWideCharToMultiByte( pszwHost, &pszHost );
    
    if ( SUCCEEDED(hr) )
    {
        hr = HrGetHostIpList( pszHost, pIpAddress, ppHostEnt );
        
        delete [] pszHost;
    }
    
    return hr;
}



HRESULT HrGetBestAdapter( IPAddr IpAddress, PIP_ADAPTER_INDEX_MAP pAdapter )
//+---------------------------------------------------------------------------
//
// Function:  HrGetBestAdapter
//
// Purpose:   
//
// Arguments: 
//
// Returns:   S_OK on success, otherwise an error code
//
// Notes: 
//
{
    ASSERT( pAdapter );
    
    HRESULT hr = E_FAIL;

    TraceMsg(TF_ALWAYS, "    %lu:", IpAddress);

    DWORD dwBestIfIndex = 0;
    DWORD dwErr         = GetBestInterface( IpAddress, &dwBestIfIndex );
    
    if ( ERROR_SUCCESS == dwErr )
    {
           ULONG ulLen = 1024;

        for ( int i=0; i<2; i++ )
        {
            PIP_INTERFACE_INFO pIfTable = (PIP_INTERFACE_INFO)new BYTE[ ulLen ];
            
            if ( NULL != pIfTable )
            {
                ZeroMemory( pIfTable, ulLen*sizeof(BYTE) );
                dwErr = GetInterfaceInfo( pIfTable, &ulLen );
                
                if ( ERROR_SUCCESS == dwErr )
                {
                    for ( LONG j=0L; j<pIfTable->NumAdapters; j++ )
                    {
                        TraceMsg(TF_ALWAYS, "    %lu %s", pIfTable->Adapter[j].Index, pIfTable->Adapter[j].Name);
                        
                        if ( pIfTable->Adapter[j].Index == dwBestIfIndex )
                        {
                            memcpy( pAdapter, pIfTable->Adapter, sizeof(IP_ADAPTER_INDEX_MAP) );
                            hr = S_OK;
                            break;
                        }
                    }
                }

                delete [] (BYTE *)pIfTable;
            }
            else
            {
                TraceMsg(TF_ERROR, "new Failed!" );
                break;
            }
            
            if ( ERROR_INSUFFICIENT_BUFFER != dwErr )
                break;
        }
    }
    else
    {
        TraceMsg(TF_ERROR, "GetBestInterface Failed = %lx", dwErr);
    }
    
    TraceMsg(TF_ALWAYS, "HrGetBestAdapter = %lx", hr);
    return hr;
}



HRESULT HrCheckForAdapterMatch(
    INetConnection*       pConnection,
    PIP_ADAPTER_INDEX_MAP pAdapter,
    BOOL*                 pfAssociated )
//+---------------------------------------------------------------------------
//
// Function:  HrCheckForAdapterMatch
//
// Purpose:   
//
// Arguments: 
//
// Returns:   S_OK on success, otherwise an error code
//
// Notes: 
//
{
    HRESULT            hr;
    NETCON_PROPERTIES* pProps;

    ASSERT( pConnection );
    ASSERT( pAdapter );
    ASSERT( pfAssociated );
    
    *pfAssociated = FALSE;

    hr = pConnection->GetProperties( &pProps );

    if ( SUCCEEDED(hr) )
    {
        OLECHAR szwGuid[ GUID_LENGTH + 1 ];
        
        if ( StringFromGUID2( pProps->guidId, szwGuid, GUID_LENGTH+1 ) )
        {
            long index = wcslen( pAdapter->Name ) - wcslen( szwGuid );
            
            ASSERT( 0 <= index );
            
            WCHAR* pszwGuidName = &(pAdapter->Name[index]);
        
            TraceMsg(TF_ALWAYS, "    - %s", szwGuid );
            TraceMsg(TF_ALWAYS, "    - %s", pszwGuidName );
        
            if ( ( wcscmp( szwGuid, pszwGuidName ) == 0 ) )
            {
                TraceMsg(TF_ALWAYS, "    FOUNT IT! %s", pProps->pszwName );
                *pfAssociated = TRUE;
            }
        }
        
        NcFreeNetconProperties( pProps );
    }
    
    TraceMsg(TF_ALWAYS, "HrCheckForAdapterMatch = %lx", hr);
    return hr;
}



HRESULT HrCheckListForMatch(
    INetConnection*  pConnection,
    IPAddr           IpAddress,
    LPHOSTENT        pHostEnt,
    BOOL*            pfAssociated )
//+---------------------------------------------------------------------------
//
// Function:  HrCheckListForMatch
//
// Purpose:   
//
// Arguments: 
//
// Returns:   S_OK on success, otherwise an error code
//
// Notes: 
//
{
    // If IpAdress or pHostEnt->h_addr INADDR_NONE then the HRESULT is still successful
    HRESULT hr = S_OK;
    
    ASSERT( pConnection );
    ASSERT( pfAssociated );

    IP_ADAPTER_INDEX_MAP Adapter;
    
    *pfAssociated = FALSE;
    
    if ( NULL != pHostEnt )
    {
        int i;
    
        for ( i=0; pHostEnt->h_addr_list[i]; i++ )
           {
            IpAddress = *(IPAddr *)(pHostEnt->h_addr_list[i]);
            
            if ( INADDR_NONE != IpAddress )
            {
                hr = HrGetBestAdapter( IpAddress, &Adapter );

                if ( SUCCEEDED(hr) )
                {
                    hr =  HrCheckForAdapterMatch( pConnection, &Adapter, pfAssociated );
                    
                    if ( *pfAssociated )
                        break;
                }
            }
        }
    }
    else
    {
        if ( INADDR_NONE != IpAddress )
        {
            // The name was an ip address
        
            hr = HrGetBestAdapter( IpAddress, &Adapter );
            
            if ( SUCCEEDED(hr) )
            {
                hr = HrCheckForAdapterMatch( pConnection, &Adapter, pfAssociated );
            }
        }
    }
    
    TraceMsg(TF_ALWAYS, "HrCheckListForMatch = %lx", hr);
    return hr;
}



HRESULT HrInternalGetAdapterInfo(
    PIP_ADAPTER_INFO*  ppAdapter
    )
//+---------------------------------------------------------------------------
//
//  Function:   HrInternalGetAdapterInfo
//
//  Purpose:    
//
//  Arguments:  PIP_ADAPTER_INFO*  ppAdapter
//
//  Returns:    HRESULT
//
//  Author:     billi  12/02/01
//
//  Notes:      
//
{
    HRESULT          hr;
    PIP_ADAPTER_INFO paAdapterInfo = NULL;
    
    ASSERT( ppAdapter );
    
    if ( NULL == ppAdapter )
    {
        ppAdapter = &paAdapterInfo;
        hr        = E_POINTER;
    }
    else
    {
        ULONG uLen = 1024;
    
        *ppAdapter = NULL;
        hr         = E_FAIL;

        for ( int i=0; i<2; i++ )
        {
            PIP_ADAPTER_INFO pInfo = (PIP_ADAPTER_INFO)new BYTE[ uLen ];
            
            ZeroMemory( pInfo, uLen );
            
            if ( NULL != pInfo )
            {
                DWORD dwErr = GetAdaptersInfo( pInfo, &uLen );
                
                if ( ERROR_SUCCESS == dwErr )
                {
                    hr         = S_OK;
                    *ppAdapter = pInfo;
                    break;
                }

                delete [] (BYTE *)pInfo;
            }
            else
            {
                hr = E_OUTOFMEMORY;
                break;
            }
        }
    }
    
    TraceMsg(TF_ALWAYS, "HrInternalGetAdapterInfo = %lx  Info = %lx", hr, *ppAdapter);
    return hr;
}



HRESULT HrGetAdapterInfo(
    INetConnection*    pConnection,
    PIP_ADAPTER_INFO*  ppAdapter
    )
//+---------------------------------------------------------------------------
//
//  Function:   HrGetAdapterInfo
//
//  Purpose:    
//
//  Arguments:  INetConnection*    pConnection
//               PIP_ADAPTER_INFO*  ppAdapter
//
//  Returns:    HRESULT
//
//  Author:     billi  12/02/01
//
//  Notes:      
//
{
    HRESULT            hr;
    NETCON_PROPERTIES* pProps;

    ASSERT( pConnection );
    ASSERT( ppAdapter );
    
    *ppAdapter = NULL;
    
    hr = pConnection->GetProperties( &pProps );

    if ( SUCCEEDED(hr) )
    {
        OLECHAR szwGuid[ GUID_LENGTH + 1 ];
        
        hr = E_FAIL;            // assume failure
        
        if ( StringFromGUID2( pProps->guidId, szwGuid, GUID_LENGTH+1 ) )
        {
            char* szGuid = NULL;

            hr = HrWideCharToMultiByte( szwGuid, &szGuid );
            
            if ( SUCCEEDED(hr) )
            {
                PIP_ADAPTER_INFO pInfo;
            
                TraceMsg(TF_ALWAYS, "%S:", szGuid);

                hr = HrInternalGetAdapterInfo( &pInfo );
                
                if ( SUCCEEDED(hr) )
                {
                    PIP_ADAPTER_INFO pAdapter = pInfo;
                    
                    hr = E_FAIL;			// Assume the loop fails...
                    
                    while ( pAdapter )
                    {
                        TraceMsg(TF_ALWAYS, "    %S", pAdapter->AdapterName);
         
                        if ( ( strcmp( szGuid, pAdapter->AdapterName ) == 0 ) )
                        {
                            TraceMsg(TF_ALWAYS, "    Found It!");
                            
                            PIP_ADAPTER_INFO pBuf = new IP_ADAPTER_INFO;
                            
                            if ( NULL != pBuf )
                            {
                                memcpy( pBuf, pAdapter, sizeof(IP_ADAPTER_INFO) );
                                *ppAdapter = pBuf;
                                hr         = S_OK;
                                break;
                            }
                            
                        }    //    if ( ( strcmp( szGuid, pAdapter->AdapterName ) == 0 ) )
             
                        pAdapter = pAdapter->Next;
                        
                    }    //    while ( pAdapter )
                    
                    if ( NULL == *ppAdapter )
                    {
                    	hr = HrFromWin32Error( ERROR_FILE_NOT_FOUND );
                    }
                    
                    delete pInfo;
                    
                }    //    if ( SUCCEEDED(hr) )
                
                delete [] szGuid;
                
            }    //    if ( SUCCEEDED(hr) )
            
        }    //    if ( StringFromGUID2( pProps->guidId, szwGuid, GUID_LENGTH+1 ) )
        
        NcFreeNetconProperties( pProps );
        
    }    //    if ( SUCCEEDED(hr) )
    
    TraceMsg(TF_ALWAYS, "HrGetAdapterInfo = %lx  Info = %lx", hr, *ppAdapter);
    return hr;
}



HRESULT HrGetHostByAddr(
    IPAddr  IpAddress,
    WCHAR** ppszHost,
    PDWORD  pdwSize
    )
//+---------------------------------------------------------------------------
//
//  Function:   HrGetHostByAddr
//
//  Purpose:    
//
//  Arguments:  
//
//  Returns:    HRESULT
//
//  Author:     billi  05/08/01
//
//  Notes:      
//
{
    HRESULT hr = E_INVALIDARG;
    
    if ( ppszHost )
        *ppszHost = 0;
        
    if ( pdwSize )
        *pdwSize = 0;
      
    if ( INADDR_NONE != IpAddress )
    {
        LPHOSTENT pHostEnt = gethostbyaddr( (char*)&IpAddress, sizeof(IPAddr), AF_INET );
        int       iErr     = WSAGetLastError();
        
        switch ( iErr )
        {
        case WSANOTINITIALISED:
        case WSAENETDOWN:
        case WSANO_RECOVERY:
        case WSAEFAULT:
            hr = E_FAIL;
            break;

        case NO_ERROR:
            hr = S_OK;
            ASSERT( pHostEnt );
            break;
        
        case WSAHOST_NOT_FOUND:
        default:                
            hr = S_FALSE;
            break;
        }                
            
        if ( SUCCEEDED(hr) && pHostEnt && pHostEnt->h_name && ppszHost && pdwSize )
        {
            char* pName  = pHostEnt->h_name;
            int   iLen   = strlen( pName ) + 1;
            DWORD dwSize = 0;
            
            dwSize = MultiByteToWideChar( CP_ACP, 0, pName, iLen, NULL, 0 );
            if ( dwSize > 0 )
            {
                WCHAR* pszName = new WCHAR[ ++dwSize ];
                
                if ( pszName )
                {
                    if ( MultiByteToWideChar( CP_ACP, 0, pName, iLen, pszName, dwSize ) == 0 )
                    {
                        hr        = HrFromLastWin32Error();
                        *ppszHost = 0;
                        
                        delete [] pszName;
                    }
                    else
                    {
                        *pdwSize  = dwSize;
                        *ppszHost = pszName;
                    }
                }
                else
                {
                    hr = E_OUTOFMEMORY;
                }
                
            }   //  if ( dwSize > 0 )
            else
            {
                   TraceMsg(TF_ERROR, "    MultiByteToWideChar returned %lx wchars", dwSize );
            }

            TraceMsg(TF_ALWAYS, "    %lx: %S", IpAddress, pHostEnt->h_name, pHostEnt->h_name );
            
        }   //  if ( SUCCEEDED(hr) && ...
        
    }   //  if ( INADDR_NONE != IpAddress )
    
    TraceMsg(TF_ALWAYS, "HrGetHostByAddr = %lx", hr);
    return hr;
}



HRESULT HrSendArp(
    INetConnection*  pConnection,
    IPAddr           DestIp,
    PULONG           pMacAddr,
    PULONG           pAddrLen
    )
//+---------------------------------------------------------------------------
//
//  Function:   HrSendArp
//
//  Purpose:    
//
//  Arguments:  
//
//  Returns:    HRESULT
//
//  Author:     billi  05/08/01
//
//  Notes:      
//
{
    HRESULT hr = E_POINTER;
    
    ASSERT( pMacAddr );
    ASSERT( pAddrLen );
    
    if ( pMacAddr ) *pMacAddr = 0L;
    
    if ( pMacAddr && pAddrLen )
    {
        hr = E_INVALIDARG;

        if ( pConnection && ( INADDR_NONE != DestIp ) )
        {
            PIP_ADAPTER_INFO  pAdapter;

            hr = HrGetAdapterInfo( pConnection, &pAdapter );
            
            if ( NULL == pAdapter )
            {
                hr = E_FAIL;
            }
        
            if ( SUCCEEDED(hr) )
            {
                hr = E_FAIL;
                
                // Make sure the target IP address isn't already cached,
                // by removing it from the ARP cache if present using the interface index
                // determined above.
                
                MIB_IPNETROW IpNetRow;
                CHAR         HardwareAddress[MAXLEN_PHYSADDR];
                ULONG        HardwareAddressLength;
                ULONG        SrcIp;
                DWORD        dwRet;

                SrcIp = inet_addr( pAdapter->IpAddressList.IpAddress.String );
                
                ZeroMemory( &IpNetRow, sizeof(IpNetRow) );
                IpNetRow.dwIndex       = pAdapter->Index;
                IpNetRow.dwPhysAddrLen = MAXLEN_PHYSADDR;
                IpNetRow.dwAddr        = DestIp;
                IpNetRow.dwType        = MIB_IPNET_TYPE_INVALID;

                dwRet = DeleteIpNetEntry( &IpNetRow );

                TraceMsg( TF_ALWAYS, "SendArp: DestIp = %lu  SrcIp = %lu Ret = %lx", DestIp, SrcIp, dwRet );
                
                if ( ( INADDR_NONE != SrcIp ) && ( NO_ERROR == dwRet ) )
                {
                    HardwareAddressLength = MAXLEN_PHYSADDR;
                
                    if ( SendARP( DestIp, SrcIp, (PULONG)HardwareAddress, &HardwareAddressLength ) == NO_ERROR )
                    {
                        hr = S_OK;
                        
                        if ( HardwareAddressLength < *pAddrLen )
                        {
                            *pAddrLen = HardwareAddressLength;
                        }
                        
                        memcpy( pMacAddr, HardwareAddress, *pAddrLen );
                    }

                    TraceMsg(TF_ALWAYS, "\t%02x %02x %02x %02x %02x %02x  Len=%lu", 
                                        HardwareAddress[0] & 0x0ff,
                                        HardwareAddress[1] & 0x0ff,
                                        HardwareAddress[2] & 0x0ff,
                                        HardwareAddress[3] & 0x0ff,
                                        HardwareAddress[4] & 0x0ff,
                                        HardwareAddress[5] & 0x0ff,
                                        *pAddrLen);
                }
                
                delete pAdapter;
                
            }   //  if ( SUCCEEDED(hr) )
            
        }   //  if ( pConnection && ( INADDR_NONE != DestIp ) )
        
    }   //  if ( pMacAddr && pAddrLen )
        
    TraceMsg( TF_ALWAYS, "HrSendArp = %lx", hr );
    return hr;
}



HRESULT HrLookupForIpAddress(
    INetConnection*  pConnection,
    IPAddr           IpAddress,
    BOOL*            pfExists,
    WCHAR**          ppszHost,
    PDWORD           pdwSize
    )
//+---------------------------------------------------------------------------
//
//  Function:   HrLookupForIpAddress
//
//  Purpose:    
//
//  Arguments:  
//
//  Returns:    HRESULT
//
//  Author:     billi  12/02/01
//
//  Notes:      
//
{
    HRESULT hr = E_POINTER;

    ASSERT( pfExists );
    ASSERT( pConnection );
    ASSERT( INADDR_NONE != IpAddress );
    
    if ( ppszHost && *ppszHost ) *ppszHost = NULL;
    if ( pdwSize ) *pdwSize = NULL;

    if ( pfExists ) 
    {
        hr        = E_INVALIDARG;
        *pfExists = FALSE;

        if ( pConnection && ( INADDR_NONE != IpAddress ) )
        {
            WSADATA  WsaData;
            int      iErr;
        
            iErr = WSAStartup( MAKEWORD(2, 0), &WsaData );
            
            if ( ERROR_SUCCESS == iErr )
            {
// This is taking to long and No One is using the host name in the wizard.            
//                hr = HrGetHostByAddr( IpAddress, ppszHost, pdwSize );
                hr = S_OK;
                
                if ( S_OK == hr )
                {
                    CHAR  MacAddr[6];
                    ULONG ulAddrLen = 6L;
                
                    hr = HrSendArp( pConnection, IpAddress, (PULONG)MacAddr, &ulAddrLen );
                    
                    if ( SUCCEEDED(hr) && ulAddrLen )
                    {
                        *pfExists = TRUE;
                    }
                }
                else if ( S_FALSE == hr )
                {
                    hr        = S_OK;
                    *pfExists = FALSE;
                }
                
                WSACleanup();
                
            }   //  if ( ERROR_SUCCESS == iErr )
            else
            {
                TraceMsg(TF_ERROR, "WSAStartup Failed = %lu", iErr );
                hr = E_FAIL;
            }
            
        }   //  if ( pConnection && ( INADDR_NONE != IpAddress ) )

    }   //  if ( pfExists ) 
    
    TraceMsg(TF_ALWAYS, "HrLookupForIpAddress = %lx, Exists = %lx", hr, *pfExists);
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\hnw\wizard\netras.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997 - 2000
//
//  File:       N E T R A S . H
//
//  Contents:   Routines supporting RAS interoperability
//
//  Notes:
//
//  Author:     billi   07 03 2001
//
//  History:    
//
//----------------------------------------------------------------------------


#pragma once


#define LOW_MAJOR_VERSION                   0x0001
#define LOW_MINOR_VERSION                   0x0003
#define HIGH_MAJOR_VERSION                  0x0002
#define HIGH_MINOR_VERSION                  0x0000

#define LOW_VERSION                         ((LOW_MAJOR_VERSION  << 16) | LOW_MINOR_VERSION)
#define HIGH_VERSION                        ((HIGH_MAJOR_VERSION << 16) | HIGH_MINOR_VERSION)

#define LOW_EXT_MAJOR_VERSION               0x0000
#define LOW_EXT_MINOR_VERSION               0x0000
#define HIGH_EXT_MAJOR_VERSION              0x0001
#define HIGH_EXT_MINOR_VERSION              0x0000

#define LOW_EXT_VERSION                     ((LOW_EXT_MAJOR_VERSION  << 16) | LOW_EXT_MINOR_VERSION)
#define HIGH_EXT_VERSION                    ((HIGH_EXT_MAJOR_VERSION << 16) | HIGH_EXT_MINOR_VERSION)


HRESULT HrConnectionAssociatedWithSharedConnection( INetConnection* pPrivate, INetConnection* pShared, BOOL* pfAssociated );
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\hnw\wizard\netutil.cpp ===
//
// NetUtil.cpp
//

#include "stdafx.h"
#include "Util.h"
#include "TheApp.h"

#include <lmjoin.h>
#include <devguid.h>
				  
#include "NetUtil.h"


// Network registry entries
#define c_szNetConfig                _T("System\\CurrentControlSet\\Services\\VxD\\VNETSUP")
#define c_szNetConfig_ComputerName    _T("ComputerName")
#define c_szNetConfig_Description    _T("Comment")
#define c_szNetConfig_Workgroup        _T("Workgroup")


// A valid computer name is a max of MAX_COMPUTERNAME_LENGTH (15) chars,
// and contains only the following characters:
//        A-Z   a-z   0-9   `!#$@%&'()-.^_{}~
// It also may not consist of all periods.
//
// REVIEW: Is this accurate even on Japanese and other international Windows?
//

static const BYTE c_rgValidChars[] = {
    1,                        // 32        (space)
    1,                        // 33       !
    0,                        // 34       "
    1,1,1,1,1,1,1,            // 35-41    #$%&'()
    0,0,0,                    // 42-44    *+,
    1,1,                    // 45-46    -.
    0,                        // 47       /
    1,1,1,1,1,1,1,1,1,1,    // 48-57    0123456789
    0,0,0,0,0,0,            // 58-63    :;<=>?
    1,1,1,1,1,1,1,1,1,1,    // 64-73    @ABCDEFGHI
    1,1,1,1,1,1,1,1,1,1,    // 74-83    JKLMNOPQRS
    1,1,1,1,1,1,1,            // 84-90    TUVWXYZ
    0,0,0,                    // 91-93    [\]
    1,1,1,                    // 94-96    ^_`
    1,1,1,1,1,1,1,1,1,1,    // 97-106   abcdefghij
    1,1,1,1,1,1,1,1,1,1,    // 107-116  klmnopqrst
    1,1,1,1,1,1,1,            // 117-123  uvwxyz{
    0,                        // 124      |
    1,1,                    // 125-126  }~
};

#define CH_FIRST_VALID  32
#define CH_LAST_VALID    (_countof(c_rgValidChars) + CH_FIRST_VALID - 1)


BOOL IsComputerNameValid(LPCTSTR pszName)
{
    if (lstrlen(pszName) > MAX_COMPUTERNAME_LENGTH)
        return FALSE;

    UCHAR ch;
    BOOL bAllPeriods = TRUE; // can't be all periods and/or whitespace

    while ((ch = (UCHAR)*pszName) != _T('\0'))
    {
        if (ch < CH_FIRST_VALID || ch > CH_LAST_VALID)
        {
            if (ch < 128) // Bug 116203 - allow extended chars for international
                return FALSE;
        }
        else if (c_rgValidChars[ch - CH_FIRST_VALID] == 0)
        {
            return FALSE;
        }

        if (ch != _T('.') && ch != _T(' '))
            bAllPeriods = FALSE;

        pszName = CharNext(pszName);
    }

    if (bAllPeriods)
        return FALSE;

    return TRUE;
}

BOOL GetWorkgroupName(LPTSTR pszBuffer, int cchBuffer)
{
    ASSERT(pszBuffer != NULL);
    *pszBuffer = _T('\0');
    BOOL bResult = FALSE;

    if (IsWindows9x())
    {
        CRegistry reg;
        if (reg.OpenKey(HKEY_LOCAL_MACHINE, c_szNetConfig, KEY_QUERY_VALUE))
        {
            reg.QueryStringValue(c_szNetConfig_Workgroup, pszBuffer, cchBuffer);
            bResult = TRUE;
        }
    }
    else // NT 
    {
        LPWSTR pszWorkgroup;
        NETSETUP_JOIN_STATUS njs;
						 
        if (NERR_Success == NetGetJoinInformation(NULL, &pszWorkgroup, &njs))
        {
            if (NetSetupWorkgroupName == njs)
            {
                StrCpyNW(pszBuffer, pszWorkgroup, cchBuffer);

                bResult = TRUE;
            }

            NetApiBufferFree(pszWorkgroup);
        }
    }

    return bResult;
}


BOOL SetWorkgroupName(LPCTSTR pszWorkgroup)
{
    ASSERT(pszWorkgroup != NULL);
    ASSERT(IsComputerNameValid(pszWorkgroup));

    BOOL bResult = FALSE;

    if (g_fRunningOnNT)
    {
        NET_API_STATUS nas = NetUnjoinDomain(NULL, NULL, NULL, NETSETUP_ACCT_DELETE);
        if ( (nas != NERR_Success) && (nas != NERR_SetupNotJoined) )
        {
            NetUnjoinDomain(NULL, NULL, NULL, 0x0);
        }
        
        nas = NetJoinDomain(NULL, pszWorkgroup, NULL, NULL, NULL, 0);

        bResult = (nas == NERR_Success);
    }
    else
    {
        CRegistry reg;
        if (reg.OpenKey(HKEY_LOCAL_MACHINE, c_szNetConfig, KEY_SET_VALUE))
        {
            reg.SetStringValue(c_szNetConfig_Workgroup, pszWorkgroup);
            bResult = TRUE;
        }
    }

    return bResult;
}

BOOL DoComputerNamesMatch(LPCTSTR pszName1, LPCTSTR pszName2)
{
    if (pszName1[0] == _T('\\') && pszName1[1] == _T('\\'))
        pszName1 += 2;
    if (pszName2[0] == _T('\\') && pszName2[1] == _T('\\'))
        pszName2 += 2;

    return !StrCmpI(pszName1, pszName2);
}

void MakeComputerNamePretty(LPCTSTR pszUgly, LPTSTR pszPretty, int cchPretty)
{
    if (pszUgly[0] == _T('\\') && pszUgly[1] == _T('\\'))
        pszUgly += 2;
    StrCpyN(pszPretty, pszUgly, cchPretty);

#ifdef SIMPLE_PRETTY_NAMES
    CharLower(CharNext(pszPretty));
#else
    static const LPCTSTR c_rgUpperNames[] = { _T("PC"), _T("HP"), _T("IBM"), _T("AT&T"), _T("NEC") };

    LPTSTR pch = pszPretty;
    BOOL bStartWord = TRUE;
    TCHAR szTemp[MAX_PATH];
    while (*pch)
    {
        if (*pch == _T(' ') || *pch == _T('_'))
        {
            pch++;
        }
        else
        {
            LPTSTR pchNextSpace = StrChr(pch, _T(' '));
            LPTSTR pchNextUnderscore = StrChr(pch, _T('_'));
            LPTSTR pchNext = pchNextSpace;
            if (pchNext == NULL || (pchNextUnderscore != NULL && pchNextUnderscore < pchNext))
                pchNext = pchNextUnderscore;
            LPTSTR pchEnd = pchNext;
            if (pchNext == NULL)
                pchNext = pch + lstrlen(pch);
            int cchWord = (int)(pchNext - pch);
            StrCpyN(szTemp, pch, cchWord + 1);
            CharUpper(szTemp);

            for (int iUpper = _countof(c_rgUpperNames)-1; iUpper >= 0; iUpper--)
            {
                if (!StrCmpI(szTemp, c_rgUpperNames[iUpper]))
                    break;
            }

            if (iUpper < 0)
                CharLower(CharNext(szTemp));

            CopyMemory(pch, szTemp, cchWord * sizeof(TCHAR));
            pch = pchNext;
        }
    }
#endif
}

LPTSTR FormatShareNameAlloc(LPCTSTR pszComputerName, LPCTSTR pszShareName)
{
    ASSERT(pszComputerName != NULL);
    ASSERT(pszShareName != NULL);

    TCHAR szPrettyComputer[MAX_COMPUTERNAME_LENGTH+1];
    MakeComputerNamePretty(pszComputerName, szPrettyComputer, _countof(szPrettyComputer));

    TCHAR szPrettyShare[100];
    MakeComputerNamePretty(pszShareName, szPrettyShare, _countof(szPrettyShare));

    LPTSTR pszResult = theApp.FormatStringAlloc(IDS_SHARENAME, szPrettyShare, szPrettyComputer);
    return pszResult;
}

// pszComputerAndShare is of the form \\kensh\printer
LPTSTR FormatShareNameAlloc(LPCTSTR pszComputerAndShare)
{
    ASSERT(pszComputerAndShare[0] == _T('\\') && pszComputerAndShare[1] == _T('\\'));
    ASSERT(CountChars(pszComputerAndShare, _T('\\')) == 3);

    TCHAR szComputerName[MAX_COMPUTERNAME_LENGTH+1];
    StrCpyN(szComputerName, pszComputerAndShare+2, _countof(szComputerName));
    LPTSTR pchSlash = StrChr(szComputerName, _T('\\'));
    if (pchSlash != NULL)
        *pchSlash = _T('\0');

    return FormatShareNameAlloc(szComputerName, FindFileTitle(pszComputerAndShare));
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\hnw\wizard\newapi.h ===
// Contains APIs for Whistler/NT whose normal header files we can't load for whatever reason.
// In some cases, this is because we already #define stuff for win9x that conflicts with the real header.
// In other cases, XXXComputerNameExW for example, its because we have _WIN32_WINNT < 0x0500.

#ifdef __cplusplus
extern "C" {
#endif

    typedef enum _COMPUTER_NAME_FORMAT {
    ComputerNameNetBIOS,
    ComputerNameDnsHostname,
    ComputerNameDnsDomain,
    ComputerNameDnsFullyQualified,
    ComputerNamePhysicalNetBIOS,
    ComputerNamePhysicalDnsHostname,
    ComputerNamePhysicalDnsDomain,
    ComputerNamePhysicalDnsFullyQualified,
    ComputerNameMax
} COMPUTER_NAME_FORMAT ;


typedef struct _SERVER_INFO_1005_NT {
    LMSTR           sv1005_comment;
} SERVER_INFO_1005_NT, *PSERVER_INFO_1005_NT, *LPSERVER_INFO_1005_NT;

typedef struct _SERVER_INFO_101_NT {
    DWORD           sv101_platform_id;
    LMSTR           sv101_name;
    DWORD           sv101_version_major;
    DWORD           sv101_version_minor;
    DWORD           sv101_type;
    LMSTR           sv101_comment;
} SERVER_INFO_101_NT, *PSERVER_INFO_101_NT, *LPSERVER_INFO_101_NT;

BOOL
WINAPI
GetComputerNameExW_NT (
    IN COMPUTER_NAME_FORMAT NameType,
    OUT LPWSTR lpBuffer,
    IN OUT LPDWORD nSize
    );

BOOL
WINAPI
SetComputerNameExW_NT (
    IN COMPUTER_NAME_FORMAT NameType,
    IN LPCWSTR lpBuffer
    );

NET_API_STATUS NET_API_FUNCTION
NetServerSetInfo_NT (
    IN  LMSTR   servername OPTIONAL,
    IN  DWORD   level,
    IN  LPBYTE  buf,
    OUT LPDWORD ParmError OPTIONAL
    );

NET_API_STATUS NET_API_FUNCTION 
NetServerGetInfo_NT (
  LPWSTR servername,  
  DWORD level,        
  LPBYTE *bufptr   
);

BOOL WINAPI LinkWindow_RegisterClass_NT();

// Printer functions (winspl32.dll)
BOOL
WINAPI
OpenPrinter_NT(
   IN LPWSTR    pPrinterName,
   OUT LPHANDLE phPrinter,
   IN LPPRINTER_DEFAULTSW pDefault
);

BOOL
WINAPI
ClosePrinter_NT(
    IN HANDLE hPrinter
);

BOOL
WINAPI
SetPrinter_NT(
    IN HANDLE  hPrinter,
    IN DWORD   Level,
    IN LPBYTE  pPrinter,
    IN DWORD   Command
);

BOOL
WINAPI
GetPrinter_NT(
    IN HANDLE  hPrinter,
    IN DWORD   Level,
    OUT LPBYTE  pPrinter,
    IN DWORD   cbBuf,
    OUT LPDWORD pcbNeeded
);

// Winsock
int WSAStartup_NT(
  WORD wVersionRequested,  
  LPWSADATA lpWSAData  
);

int WSACleanup_NT (void);

INT WSALookupServiceBegin_NT(
  LPWSAQUERYSET lpqsRestrictions,  
  DWORD dwControlFlags,            
  LPHANDLE lphLookup               
);

INT WSALookupServiceNext_NT(
  HANDLE hLookup,        
  DWORD dwControlFlags,  
  LPDWORD lpdwBufferLength,  
  LPWSAQUERYSET lpqsResults  
);

INT WSALookupServiceEnd_NT(
  HANDLE hLookup  
);

int WSAGetLastError_NT (void);

LPITEMIDLIST ILCreateFromPathW_NT(LPCWSTR pszPath);

DWORD_PTR SHGetFileInfoW_NT(
    LPCWSTR pszPath,
    DWORD dwFileAttributes,
    SHFILEINFOW *psfi,
    UINT cbFileInfo,
    UINT uFlags
);



#ifdef __cplusplus
} // extern "C"
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\hnw\wizard\nla.h ===
// NLA.h

NLA_INTERNET GetConnectionInternetType(GUID* pConnectionGuid);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\hnw\wizard\nla.cpp ===
// NLA.cpp
#include "stdafx.h"
#include "newapi.h"
#include "nla.h"

GUID g_guidNLAServiceClass = NLA_SERVICE_CLASS_GUID;

BOOL _IsSameAdapter(GUID* pGuid, const char* pszAdapter)
{
    BOOL fSame = FALSE;
    GUID guidAdapter;
    if (GUIDFromStringA(pszAdapter, &guidAdapter))
    {
        fSame = (guidAdapter == *pGuid);
    }

    return fSame;
}

NLA_BLOB* _NLABlobNext(NLA_BLOB* pnlaBlob)
{
    NLA_BLOB* pNext = NULL;

    if (pnlaBlob->header.nextOffset)
    {
        pNext = (NLA_BLOB*) (((BYTE*) pnlaBlob) + pnlaBlob->header.nextOffset);
    }
    
    return pNext;
}

int _AllocWSALookupServiceNext(HANDLE hQuery, DWORD dwControlFlags, LPWSAQUERYSET* ppResults)
{
    *ppResults = NULL;

    DWORD cb = 0;
    int error = 0;
    if (SOCKET_ERROR == WSALookupServiceNext_NT(hQuery, dwControlFlags, &cb, NULL))
    {
        error = WSAGetLastError_NT();
        if (WSAEFAULT == error)
        {
            ASSERT(cb);
            *ppResults = (LPWSAQUERYSET) LocalAlloc(LPTR, cb);

            if (NULL != *ppResults)
            {
                error = 0;
                if (SOCKET_ERROR == WSALookupServiceNext_NT(hQuery, dwControlFlags, &cb, *ppResults))
                {
                    error = WSAGetLastError_NT();
                }
            }
            else
            {
                error = WSA_NOT_ENOUGH_MEMORY;
            }
        }
    }

    // May as well map outdated error code while we're here.
    if (WSAENOMORE == error)
    {
        error = WSA_E_NO_MORE;
    }

    if (error && (*ppResults))
    {
        LocalFree(*ppResults);
        *ppResults = NULL;
    }

    return error;
}

NLA_INTERNET GetConnectionInternetType(GUID* pConnectionGuid)
{
    NLA_INTERNET ni = NLA_INTERNET_UNKNOWN;

	// Init Winsock
    WSADATA wsaData;
    if (0 == WSAStartup_NT(MAKEWORD(2, 2), &wsaData)) 
    {
	    // Init query for network names
        WSAQUERYSET restrictions = {0};
        restrictions.dwSize = sizeof(restrictions);
        restrictions.lpServiceClassId = &g_guidNLAServiceClass;
        restrictions.dwNameSpace = NS_NLA;

        HANDLE hQuery;
	    // Make sure we do not ask for the (chicken) blobs that take a long time to get
        if (0 == WSALookupServiceBegin_NT(&restrictions, LUP_NOCONTAINERS | LUP_DEEP, &hQuery))
        {
            PWSAQUERYSET pqsResults = NULL;
            BOOL fAdapterFound = FALSE;
            
            // Start loop of getting network names
            while (!fAdapterFound && (0 == _AllocWSALookupServiceNext(hQuery, 0, &pqsResults))) 
            {
                if (NULL != pqsResults->lpBlob)
                {
                    NLA_BLOB* pnlaBlob = (NLA_BLOB*) pqsResults->lpBlob->pBlobData;
                    NLA_INTERNET ni2 = NLA_INTERNET_UNKNOWN;
                    
                    while (NULL != pnlaBlob)
                    {
                        switch (pnlaBlob->header.type)
                        {
                        case NLA_INTERFACE:
                            if (_IsSameAdapter(pConnectionGuid, pnlaBlob->data.interfaceData.adapterName))
                            {
                                fAdapterFound = TRUE;
                            }
                            break;
                        case NLA_CONNECTIVITY:
                            ni2 = pnlaBlob->data.connectivity.internet;
                            break;
                        default:
                            break;
                        }
                        
                        pnlaBlob = _NLABlobNext(pnlaBlob);
                    }
                    
                    if (fAdapterFound)
                    {
                        ni = ni2;
                    }
                }
                
                LocalFree(pqsResults);
            }
	        // tidy up and return the result
            WSALookupServiceEnd_NT(hQuery);
        }
        WSACleanup_NT();
    }

    return ni;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\hnw\wizard\prnutil.h ===
//
// PrnUtil.h
//

#pragma once

typedef struct tagPRINTER_ENUM
{
    LPTSTR pszPrinterName;
    LPTSTR pszPortName;
    DWORD dwFlags;
} PRINTER_ENUM;

#define PRF_LOCAL        0x00000001
#define PRF_REMOTE        0x00000002
#define PRF_VIRTUAL        0x00000004
#define PRF_DEFAULT        0x00000008
#define PRF_SHARED        0x00000010



int MyEnumPrinters(PRINTER_ENUM** pprgPrinters, DWORD dwEnumFlags);

#define MY_PRINTER_ENUM_LOCAL    0x00000001
#define MY_PRINTER_ENUM_REMOTE    0x00000002
#define MY_PRINTER_ENUM_VIRTUAL    0x00000004 // virtual printers on FILE: port

int MyEnumLocalPrinters(PRINTER_ENUM** prgPrinters);
int MyEnumRemotePrinters(PRINTER_ENUM** prgPrinters);

BOOL ConnectToNetworkPrinter(HWND hWndOwner, LPCTSTR pszPrinterShare);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\hnw\wizard\registry.cpp ===
#include "stdafx.h"

#include "..\shared\registry.cpp"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\hnw\wizard\ntwiz.cpp ===
#include "stdafx.h"
#include "theapp.h"
#include "netconn.h"
#include "netapi.h"
#include "prnutil.h"
#include "install.h"
#include "mydocs.h"
#include "comctlwrap.h"
#include "icsinst.h"
#include "defconn.h"
#include "initguid.h"
DEFINE_GUID(CLSID_FolderItem, 0xfef10fa2, 0x355e, 0x4e06, 0x93, 0x81, 0x9b, 0x24, 0xd7, 0xf7, 0xcc, 0x88);
DEFINE_GUID(CLSID_SharedAccessConnectionManager,            0xBA126AE0,0x2166,0x11D1,0xB1,0xD0,0x00,0x80,0x5F,0xC1,0x27,0x0E); // this doesn't exist in the shell tree

#include "resource.h"
#include "newapi.h"
#include "shgina.h"

#include "hnetcfg.h"
#include "netconp.h"
#include "hnetbcon.h" // ICSLapCtl.h
#include "Lm.h"
#include "htmlhelp.h"

#include "nla.h"
#include "netinet.h"
#include "netip.h"
#include "netras.h"
#include "netutil.h"

// include files necessary for showing diagrams using ShowHTMLDialog. TinQian
#include <urlmon.h>
#include <mshtmhst.h>
#include <mshtml.h>
#include <atlbase.h>

// Debugging #defines:

// Uncomment NO_CHECK_DOMAIN when you want to test the wizard on a domain machine - just don't apply changes ;)
// #define NO_CHECK_DOMAIN

// Uncomment NO_CONFIG to neuter the wizard for UI-only testing
// #define NO_CONFIG

// Uncomment FAKE_ICS to simulate the "ICS machine" state
// #define FAKE_ICS

// Uncomment FAKE_UNPLUGGED to simulate unplugged connections
// #define FAKE_UNPLUGGED

// Uncomment FAKE_REBOOTREQUIRED to simulate reboot required
// #define FAKE_REBOOTREQUIRED

// Delay Load ole32.dll function CoSetProxyBlanket since it isn't on W95 Gold
// and it's only used by the wizard on NT

#define CoSetProxyBlanket CoSetProxyBlanket_NT

EXTERN_C STDAPI CoSetProxyBlanket_NT(IUnknown* pProxy, DWORD dwAuthnSvc, DWORD dwAuthzSvc, OLECHAR* pServerPrincName, DWORD dwAuthnLevel, DWORD dwImpLevel, RPC_AUTH_IDENTITY_HANDLE pAuthInfo, DWORD dwCapabilities);

// Functions not in any include file yet
extern int AdapterIndexFromClass(LPTSTR szClass, BOOL bSkipClass);

#define LWS_IGNORERETURN 0x0002

#define MAX_HNW_PAGES 30

#define MAX_WORKGROUPS  20

#define CONN_EXTERNAL     0x00000001
#define CONN_INTERNAL     0x00000002
#define CONN_UNPLUGGED    0x00000004

// Return value to use for sharing configuration conflict

#define HNETERRORSTART          0x200
#define E_ANOTHERADAPTERSHARED  MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, HNETERRORSTART+1)
#define E_ICSADDRESSCONFLICT    MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, HNETERRORSTART+2)

class CEnsureSingleInstance
{
public:
    CEnsureSingleInstance(LPCTSTR szCaption);
    ~CEnsureSingleInstance();

    BOOL ShouldExit() { return m_fShouldExit;}

private:
    BOOL m_fShouldExit;
    HANDLE m_hEvent;
};

CEnsureSingleInstance::CEnsureSingleInstance(LPCTSTR szCaption)
{
    // Create an event
    m_hEvent = CreateEvent(NULL, TRUE, FALSE, szCaption);

    // If any weird errors occur, default to running the instance
    m_fShouldExit = FALSE;

    if (NULL != m_hEvent)
    {
        // If our event isn't signaled, we're the first instance
        m_fShouldExit = (WAIT_OBJECT_0 == WaitForSingleObject(m_hEvent, 0));

        if (m_fShouldExit)
        {
            // app should exit after calling ShouldExit()

            // Find and show the caption'd window
            HWND hwndActivate = FindWindow(NULL, szCaption);
            if (IsWindow(hwndActivate))
            {
                SetForegroundWindow(hwndActivate);
            }
        }
        else
        {
            // Signal that event
            SetEvent(m_hEvent);
        }
    }
}

CEnsureSingleInstance::~CEnsureSingleInstance()
{
    if (NULL != m_hEvent)
    {
        CloseHandle(m_hEvent);
    }
}

typedef struct _tagHOMENETSETUPINFO
{
    HWND hwnd;

    DWORD cbSize;
    DWORD dwFlags;

    // Data for NT - NetConnections are temporarily represented by their corresponding GUIDs to cross the
    // thread boundary for asynchronous configuration.
    BOOL  fAsync;
    GUID  guidExternal;
    GUID* prgguidInternal;
    DWORD cguidInternal;
    UINT  umsgAsyncNotify;

    INetConnection* pncExternal;
    INetConnection** prgncInternal;
    DWORD cncInternal;

    // Data for Win9x
    const NETADAPTER*   pNA;    // list of adapters.
    UINT                cNA;    // count of entries in pNA.
    RASENTRYNAME*       pRas;   // list of RAS connectoids.
    UINT                cRas;   // count of RAS connectoids.
    UINT                ipaExternal;
    UINT                ipaInternal;

    // Data for both NT and Win9x
    TCHAR szComputer[CNLEN + 1];
    TCHAR szComputerDescription[256];
    TCHAR szWorkgroup[LM20_DNLEN + 1];

    // Out-data
    BOOL        fRebootRequired;
} HOMENETSETUPINFO, *PHOMENETSETUPINFO;

// Function prototypes
void HelpCenter(HWND hwnd, LPCWSTR pszTopic);
void BoldControl(HWND hwnd, int id);
void ShowControls(HWND hwndParent, const int *prgControlIDs, DWORD nControls, int nCmdShow);
HRESULT ConfigureHomeNetwork(PHOMENETSETUPINFO pInfo);
DWORD WINAPI ConfigureHomeNetworkThread(void* pData);
HRESULT ConfigureHomeNetworkSynchronous(PHOMENETSETUPINFO pInfo);
HRESULT ConfigureICSBridgeFirewall(PHOMENETSETUPINFO pInfo);
HRESULT EnableSimpleSharing();
HRESULT GetConnections(HDPA* phdpa);
int FreeConnectionDPACallback(LPVOID pFreeMe, LPVOID pData);
HRESULT GetConnectionsFolder(IShellFolder** ppsfConnections);
//HRESULT GetConnectionIconIndex(GUID& guidConnection, IShellFolder* psfConnections, int* pIndex, HIMAGELIST imgList);
HRESULT GetDriveNameAndIconIndex(LPWSTR pszDrive, LPWSTR pszDisplayName, DWORD cchDisplayName, int* pIndex);
void    W9xGetNetTypeName(BYTE bNicType, WCHAR* pszBuff, UINT cchBuff);
BOOL    W9xIsValidAdapter(const NETADAPTER* pNA, DWORD dwFlags);
BOOL    W9xIsAdapterDialUp(const NETADAPTER* pAdapter);
BOOL    IsEqualConnection(INetConnection* pnc1, INetConnection* pnc2);
void GetTitleFont(LPTSTR pszFaceName, DWORD cch);
LONG GetTitlePointSize(void);
BOOL FormatMessageString(UINT idTemplate, LPTSTR pszStrOut, DWORD cchSize, ...);
int DisplayFormatMessage(HWND hwnd, UINT idCaption, UINT idFormatString, UINT uType, ...);
HRESULT SetProxyBlanket(IUnknown * pUnk);
HRESULT MakeUniqueShareName(LPCTSTR pszBaseName, LPTSTR pszUniqueName, DWORD cchName);
HRESULT WriteSetupInfoToRegistry(PHOMENETSETUPINFO pInfo);
HRESULT ReadSetupInfoFromRegistry(PHOMENETSETUPINFO pInfo);
HRESULT ShareWellKnownFolders(PHOMENETSETUPINFO pInfo);
HRESULT ShareAllPrinters();
HRESULT DeleteSetupInfoFromRegistry();
HRESULT IsUserLocalAdmin(HANDLE TokenHandle, BOOL* pfIsAdmin);
BOOL AllPlatformGetComputerName(LPWSTR pszName, DWORD cchName);
BOOL AllPlatformSetComputerName(LPCWSTR pszName);
void FreeInternalConnections(PHOMENETSETUPINFO pInfo);
void FreeInternalGUIDs(PHOMENETSETUPINFO pInfo);
void FreeExternalConnection(PHOMENETSETUPINFO pInfo);
HRESULT GetConnectionByGUID(HDPA hdpaConnections, const GUID* pguid, INetConnection** ppnc);
HRESULT GUIDsToConnections(PHOMENETSETUPINFO pInfo);
HRESULT GetConnectionGUID(INetConnection* pnc, GUID* pguid);
HRESULT ConnectionsToGUIDs(PHOMENETSETUPINFO pInfo);
BOOL  IsValidNameSyntax(LPCWSTR pszName, NETSETUP_NAME_TYPE type);
void  STDMETHODCALLTYPE ConfigurationLogCallback(LPCWSTR pszLogEntry, LPARAM lParam);

// Home network wizard class
class CHomeNetworkWizard : public IHomeNetworkWizard
{
    friend HRESULT CHomeNetworkWizard_CreateInstance(IUnknown *punkOuter, IUnknown **ppunk, LPCOBJECTINFO poi);

public:
    // IUnknown
    STDMETHOD(QueryInterface)(REFIID riid, LPVOID* ppvObj);
    STDMETHOD_(ULONG, AddRef) ();
    STDMETHOD_(ULONG, Release) ();

    // IHomeNetworkWizard
    STDMETHOD(ConfigureSilently)(LPCWSTR pszPublicConnection, DWORD hnetFlags, BOOL* pfRebootRequired);
    STDMETHOD(ShowWizard)(HWND hwnd, BOOL* pfRebootRequired);

protected:
    CHomeNetworkWizard();
    HRESULT Initialize();
    HRESULT Uninitialize();

private:
    // Shared functions
    void DestroyConnectionList(HWND hwndList);
    void InitializeConnectionList(HWND hwndList, DWORD dwFlags);
    void FillConnectionList(HWND hwndList, INetConnection* pncExcludeFromList, DWORD dwFlags);
    BOOL ShouldShowConnection(INetConnection* pnc, INetConnection* pncExcludeFromList, DWORD dwFlags);
    BOOL IsConnectionICSPublic(INetConnection* pnc);
    BOOL IsConnectionUnplugged(INetConnection* pnc);
    BOOL W9xAddAdapterToList(const NETADAPTER* pNA, const WCHAR* pszDesc, UINT uiAdapterIndex, UINT uiDialupIndex, HWND hwndList, DWORD dwFlags);
    UINT W9xEnumRasEntries(void);
    HRESULT GetConnectionByName(LPCWSTR pszName, INetConnection** ppncOut);
    HRESULT GetInternalConnectionArray(INetConnection* pncExclude, INetConnection*** pprgncArray, DWORD* pcncArray);
    DWORD GetConnectionCount(INetConnection* pncExclude, DWORD dwFlags);
    void ReplaceStaticWithLink(HWND hwndStatic, UINT idcLinkControl, UINT idsLinkText);
    BOOL IsMachineOnDomain();
    BOOL IsMachineWrongOS();
    BOOL IsICSIPInUse( WCHAR** ppszHost, PDWORD pdwSize );

    // Per-Page functions
    // Welcome
    static INT_PTR CALLBACK WelcomePageProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam);
    void WelcomeSetTitleFont(HWND hwnd);

    // No home network hardware
    static INT_PTR CALLBACK NoHardwareWelcomePageProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam);

    // Page with instructions for manual configuration of the network
    void ManualRefreshConnectionList();
    static INT_PTR CALLBACK ManualConfigPageProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam);

    // User has some network hardware unplugged
    BOOL UnpluggedFillList(HWND hwnd);
    static INT_PTR CALLBACK UnpluggedPageProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam);

    // Found ICS (Internet connection sharing)
    static INT_PTR CALLBACK FoundIcsPageProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam);
    void FoundIcsSetText(HWND hwnd);
    BOOL GetICSMachine(LPTSTR pszICSMachineName, DWORD cch);

    // Connect
    static INT_PTR CALLBACK ConnectPageProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam);
    void ConnectSetDefault(HWND hwnd);
    void ConnectNextPage(HWND hwnd);

    // Show Me Links
    void ShowMeLink(HWND hwnd, LPCWSTR pszTopic);

    // Connect other (alternative methods for connection)
    static INT_PTR CALLBACK ConnectOtherPageProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam);

    // Public
    static INT_PTR CALLBACK PublicPageProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam);
    void PublicSetActive(HWND hwnd);
    void PublicSetControlState(HWND hwnd);
    void PublicNextPage(HWND hwnd);
    void PublicGetControlPositions(HWND hwnd);
    void PublicResetControlPositions(HWND hwnd);
    void PublicMoveControls(HWND hwnd, BOOL fItemPreselected);

    // File sharing
    static INT_PTR CALLBACK EdgelessPageProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam);
    void EdgelessSetActive(HWND hwnd);

    // ICS conflict
    void ICSConflictSetActive(HWND hwnd);
    static INT_PTR CALLBACK ICSConflictPageProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam);

    // BridgeWarning (do you want to manually configure the bridge? Are you crazy !?)
    static INT_PTR CALLBACK BridgeWarningPageProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam);

    // Private
    static INT_PTR CALLBACK PrivatePageProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam);
    void PrivateNextPage(HWND hwnd);
    void PrivateSetControlState(HWND hwnd);

    // Name (computer and workgroup)
    static INT_PTR CALLBACK NamePageProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam);
    void NameInitDialog(HWND hwnd);
    void NameSetControlState(HWND hwnd);
    HRESULT NameNextPage(HWND hwnd);

    // Workgroup name
    void WorkgroupSetControlState(HWND hwnd);
    HRESULT WorkgroupNextPage(HWND hwnd);
    static INT_PTR CALLBACK WorkgroupPageProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam);

    // Summary
    static INT_PTR CALLBACK SummaryPageProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam);
    void SummarySetActive(HWND hwnd);

    // Progress (while the configuration is taking place)
    static INT_PTR CALLBACK ProgressPageProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam);

    // Almost done (after configuration but before the "completed" page)
    static INT_PTR CALLBACK AlmostDonePageProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam);

    // Choose disk drive
    void FillDriveList(HWND hwndList);
    void ChooseDiskSetControlState(HWND hwnd);
    static INT_PTR CALLBACK ChooseDiskPageProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam);

    // Insert disk
    static HRESULT GetSourceFilePath(LPSTR pszSource, DWORD cch);
    static INT_PTR CALLBACK InsertDiskPageProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam);

    // Floppy and XP CD "run the wizard" instructions
    static INT_PTR CALLBACK InstructionsPageProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam);

    // Finish
    static INT_PTR CALLBACK FinishPageProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam);

    // Error finish
    static INT_PTR CALLBACK ErrorFinishPageProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam);

    // No Hardware Finish
    // An alternate finish if they have a LAN card ONLY, and its used for an INet connection,
    // so therefore they have no LAN cards connecting to other computers...
    static INT_PTR CALLBACK NoHardwareFinishPageProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam);

    // Can't Run Wizard Pages
    // An alternate welcome page when the user isn't an adminm or doesn't have permissions,
    static INT_PTR CALLBACK CantRunWizardPageProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam);

    static CHomeNetworkWizard* GetThis(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam);

    // Get Icon Index for network connections based on GUIDs
    HRESULT GetConnectionIconIndex(GUID& guidConnection, IShellFolder* psfConnections, int* pIndex);

    // Helpers
    UINT PopPage()
    {
        ASSERT(_iPageStackTop);
        return _rguiPageStack[--_iPageStackTop];
    }

    void PushPage(UINT uiPageId)
    {
        ASSERT(_iPageStackTop < MAX_HNW_PAGES);
        _rguiPageStack[_iPageStackTop++] = uiPageId;
    }

    // Data
    HDPA                _hdpaConnections;
    HOMENETSETUPINFO    _hnetInfo;

    // even though CNLEN+1 is the limit of a name buffer, friendly names can be longer
    TCHAR               _szICSMachineName[MAX_PATH];   // Machine on the network doing ICS, if applicable

    UINT                _rguiPageStack[MAX_HNW_PAGES];  // Stackopages
    int                 _iPageStackTop;                 // Current top of the stack

    BOOL                _fManualBridgeConfig;           // The user wants to manuall configure the bridge
    BOOL                _fICSClient;// This computer will connect through an ICS machine or another sharing device

    // Shell image lists - never free these
    HIMAGELIST          _himlSmall;
    HIMAGELIST          _himlLarge;

    LONG                _cRef;

    BOOL                _fShowPublicPage;
    BOOL                _fShowSharingPage;
    BOOL                _fNoICSQuestion;
    BOOL                _fNoHomeNetwork;
    BOOL                _fExternalOnly;

    UINT                _iDrive;        // Ordinal of removable drive for floppy creation
    WCHAR               _szDrive[256];  // Name of removable drive
    BOOL                _fCancelCopy;
    BOOL                _fFloppyInstructions; // Show the floppy, as opposed to CD, instructions

    // data structure used by show me links
    HINSTANCE hinstMSHTML;
    SHOWHTMLDIALOGEXFN * pfnShowHTMLDialog;
    IHTMLWindow2 * showMeDlgWnd, * pFrameWindow;

    // Network Connection folder and folder view call back.  Used by Connection List Views.
    IShellFolder *_psfConnections;
    IShellFolderViewCB *_pConnViewCB;

    struct PUBLICCONTROLPOSITIONS
    {
        RECT _rcSelectMessage;
        RECT _rcListLabel;
        RECT _rcList;
        RECT _rcHelpIcon;
        RECT _rcHelpText;
    } PublicControlPositions;
};

int FreeConnectionDPACallback(LPVOID pFreeMe, LPVOID pData)
{
    ((INetConnection*) pFreeMe)->Release();
    return 1;
}

void InitHnetInfo(HOMENETSETUPINFO* pInfo)
{
    ZeroMemory(pInfo, sizeof (HOMENETSETUPINFO));
    pInfo->cbSize = sizeof (HOMENETSETUPINFO);
    pInfo->ipaExternal = -1;
    pInfo->ipaInternal = -1;
}


// Creation function
HRESULT HomeNetworkWizard_RunFromRegistry(HWND hwnd, BOOL* pfRebootRequired)
{
    HOMENETSETUPINFO setupInfo;

    InitHnetInfo(&setupInfo);

    HRESULT hr = ReadSetupInfoFromRegistry(&setupInfo);

    if (S_OK == hr)
    {
        setupInfo.dwFlags = HNET_SHAREPRINTERS | HNET_SHAREFOLDERS;
        setupInfo.hwnd = hwnd;
        hr = ConfigureHomeNetwork(&setupInfo);
        *pfRebootRequired = setupInfo.fRebootRequired;
    }

    DeleteSetupInfoFromRegistry();

    return hr;
}

HRESULT HomeNetworkWizard_ShowWizard(HWND hwnd, BOOL* pfRebootRequired)
{
    if (*pfRebootRequired)
        *pfRebootRequired = FALSE;

    HRESULT hr = HomeNetworkWizard_RunFromRegistry(hwnd, pfRebootRequired);

    if (S_FALSE == hr)
    {
        IUnknown* punk;
        hr = CHomeNetworkWizard_CreateInstance(NULL, &punk, NULL);

        if (SUCCEEDED(hr))
        {
            IHomeNetworkWizard* pwizard;
            hr = punk->QueryInterface(IID_PPV_ARG(IHomeNetworkWizard, &pwizard));

            if (SUCCEEDED(hr))
            {
                hr = pwizard->ShowWizard(hwnd, pfRebootRequired);
                pwizard->Release();
            }

            punk->Release();
        }
    }

    return hr;
}

HRESULT CHomeNetworkWizard_CreateInstance(IUnknown *punkOuter, IUnknown **ppunk, LPCOBJECTINFO poi)
{
    *ppunk = NULL;

    if (punkOuter)
        return CLASS_E_NOAGGREGATION;

    CHomeNetworkWizard* pwiz = new CHomeNetworkWizard();
    if (!pwiz)
        return E_OUTOFMEMORY;

    HRESULT hr = pwiz->QueryInterface(IID_PPV_ARG(IUnknown, ppunk));
    pwiz->Release();
    return hr;
}

// IUnknown
HRESULT CHomeNetworkWizard::QueryInterface(REFIID riid, LPVOID* ppvObj)
{
    if (IsEqualIID(riid, IID_IUnknown) || IsEqualIID(riid, IID_IHomeNetworkWizard))
    {
        AddRef();
        *ppvObj = static_cast<IHomeNetworkWizard *>(this);
    }
    else
    {
        *ppvObj = NULL;
    }

    return *ppvObj ? S_OK : E_NOINTERFACE;
}

ULONG CHomeNetworkWizard::AddRef()
{
    return (ULONG) InterlockedIncrement(&_cRef);
}

ULONG CHomeNetworkWizard::Release()
{
    ASSERT( 0 != _cRef );
    ULONG cRef = InterlockedDecrement(&_cRef);
    if ( 0 == cRef )
    {
        delete this;
    }
    return cRef;
}


HRESULT CHomeNetworkWizard::GetConnectionByName(LPCWSTR pszName, INetConnection** ppncOut)
{
    *ppncOut = NULL;
    DWORD cItems = DPA_GetPtrCount(_hdpaConnections);
    DWORD iItem = 0;
    while ((iItem < cItems) && (NULL == *ppncOut))
    {
        INetConnection* pnc = (INetConnection*) DPA_GetPtr(_hdpaConnections, iItem);

        NETCON_PROPERTIES* pncprops;
        HRESULT hr = pnc->GetProperties(&pncprops);
        if (SUCCEEDED(hr))
        {
            if (0 == StrCmpIW(pszName, pncprops->pszwName))
            {
                *ppncOut = pnc;
                (*ppncOut)->AddRef();
            }

            NcFreeNetconProperties(pncprops);
        }

        iItem ++;
    }

    return (*ppncOut) ? S_OK : E_FAIL;
}

HRESULT CHomeNetworkWizard::GetInternalConnectionArray(INetConnection* pncExclude, INetConnection*** pprgncArray, DWORD* pcncArray)
{
    HRESULT hr = S_OK;
    *pprgncArray = NULL;

    DWORD cTotalConnections = DPA_GetPtrCount(_hdpaConnections);
    DWORD cInternalConnections = GetConnectionCount(pncExclude, CONN_INTERNAL);

    if (cInternalConnections)
    {
        (*pprgncArray) = (INetConnection**) LocalAlloc(LPTR, (cInternalConnections + 1) * sizeof (INetConnection*));
        // Note that we allocated an extra entry since this is a null-terminated array
        if (*pprgncArray)
        {
            DWORD nInternalConnection = 0;
            for (DWORD n = 0; n < cTotalConnections; n++)
            {
                INetConnection* pnc = (INetConnection*) DPA_GetPtr(_hdpaConnections, n);
                if (ShouldShowConnection(pnc, pncExclude, CONN_INTERNAL))
                {
                    pnc->AddRef();
                    (*pprgncArray)[nInternalConnection++] = pnc;
                }
            }

            ASSERT(nInternalConnection == cInternalConnections);
        }
        else
        {
            hr = E_OUTOFMEMORY;
        }
    }

    if (SUCCEEDED(hr))
    {
        *pcncArray = cInternalConnections;
    }

    return hr;
}

HRESULT CHomeNetworkWizard::ConfigureSilently(LPCWSTR pszPublicConnection, DWORD hnetFlags, BOOL* pfRebootRequired)
{
    // Never set workgroup name
    hnetFlags &= (~HNET_SETWORKGROUPNAME);
    
    if (!g_fRunningOnNT)
        return E_NOTIMPL;

    HRESULT hr = Initialize();

    if (SUCCEEDED(hr))
    {
        _hnetInfo.dwFlags = hnetFlags;
        // Calculate what the external and internal adapters will be...
        if (pszPublicConnection)
        {
            hr = GetConnectionByName(pszPublicConnection, &_hnetInfo.pncExternal);
        }
        else
        {
            _hnetInfo.pncExternal = NULL;
        }

        if (SUCCEEDED(hr))
        {
            // Get all LAN connections except the public connection
            if (_hnetInfo.dwFlags & HNET_BRIDGEPRIVATE)
            {
                hr = GetInternalConnectionArray(_hnetInfo.pncExternal, &(_hnetInfo.prgncInternal), &_hnetInfo.cncInternal);
            }

            if (SUCCEEDED(hr))
            {
                hr = ConfigureHomeNetwork(&_hnetInfo);
                *pfRebootRequired = _hnetInfo.fRebootRequired;
            }
        }

        Uninitialize();
    }

    return hr;
}


CHomeNetworkWizard::CHomeNetworkWizard() :
    _cRef(1)
{}

HRESULT CHomeNetworkWizard::Initialize()
{
    _fExternalOnly       = FALSE;
    _fNoICSQuestion      = FALSE;
    _hdpaConnections     = NULL;
    _iPageStackTop       = 0;
    _fManualBridgeConfig = FALSE;
    _fICSClient          = FALSE;
    _psfConnections      = NULL;
    _pConnViewCB         = NULL;

    InitHnetInfo(&_hnetInfo);
    *_szICSMachineName   = 0;

    HRESULT hr;
    
    if (g_fRunningOnNT)
    {
        hr = GetConnections(&_hdpaConnections);
    }
    else
    {
        _hnetInfo.cNA = EnumCachedNetAdapters(&_hnetInfo.pNA);
        hr            = S_OK;
        
        if ( _hnetInfo.cNA > 0 )
        {
            _hnetInfo.ipaInternal = 0;
        }
    }

    // Get the shell image lists - never free these
    if (!Shell_GetImageLists(&_himlLarge, &_himlSmall))
    {
        hr = E_FAIL;
    }

    // variables used by displaying show me links
    hinstMSHTML = NULL;
    pfnShowHTMLDialog = NULL;
    showMeDlgWnd = NULL; 
    pFrameWindow = NULL;

    return hr;
}

HRESULT CHomeNetworkWizard::Uninitialize()
{
    if (g_fRunningOnNT)
    {
        if (_hdpaConnections)
        {
            DPA_DestroyCallback(_hdpaConnections, FreeConnectionDPACallback, NULL);
            _hdpaConnections = NULL;
        }

        // Free public lan information
        FreeExternalConnection(&_hnetInfo);

        // Free private lan information
        FreeInternalConnections(&_hnetInfo);
    
        if (_psfConnections != NULL)
            _psfConnections->Release();

        if (_pConnViewCB != NULL)
            _pConnViewCB->Release();
    }
    else
    {
        if (_hnetInfo.pNA)
        {
            FlushNetAdapterCache();
            _hnetInfo.pNA = NULL;
        }

        if (_hnetInfo.pRas)
        {
            LocalFree(_hnetInfo.pRas);
            _hnetInfo.pRas = NULL;
        }
    }

    // release resources used by show me links
    if (hinstMSHTML)
        FreeLibrary(hinstMSHTML);

    if (showMeDlgWnd != NULL)
        showMeDlgWnd->Release();
    
    if (pFrameWindow != NULL)
        pFrameWindow->Release();

    return S_OK;
}

// TODO: Move the formatting functions here to a util file or something...

BOOL FormatMessageString(UINT idTemplate, LPTSTR pszStrOut, DWORD cchSize, ...)
{
    BOOL fResult = FALSE;

    va_list vaParamList;

    TCHAR szFormat[1024];
    if (LoadString(g_hinst, idTemplate, szFormat, ARRAYSIZE(szFormat)))
    {
        va_start(vaParamList, cchSize);

        fResult = FormatMessage(FORMAT_MESSAGE_FROM_STRING, szFormat, 0, 0, pszStrOut, cchSize, &vaParamList);

        va_end(vaParamList);
    }

    return fResult;
}

int DisplayFormatMessage(HWND hwnd, UINT idCaption, UINT idFormatString, UINT uType, ...)
{
    int iResult = IDCANCEL;
    TCHAR szError[512]; *szError = 0;
    TCHAR szCaption[256];
    TCHAR szFormat[512]; *szFormat = 0;

    // Load and format the error body
    if (LoadString(g_hinst, idFormatString, szFormat, ARRAYSIZE(szFormat)))
    {
        va_list arguments;
        va_start(arguments, uType);

        if (FormatMessage(FORMAT_MESSAGE_FROM_STRING, szFormat, 0, 0, szError, ARRAYSIZE(szError), &arguments))
        {
            // Load the caption
            if (LoadString(g_hinst, idCaption, szCaption, ARRAYSIZE(szCaption)))
            {
                iResult = MessageBox(hwnd, szError, szCaption, uType);
            }
        }

        va_end(arguments);
    }
    return iResult;
}

BOOL CHomeNetworkWizard::GetICSMachine(LPTSTR pszICSMachineName, DWORD cch)
{
#ifdef FAKE_ICS
    lstrcpyn(pszICSMachineName, L"COMPNAME", cch);
    return TRUE;
#endif

    SetCursor(LoadCursor(NULL, IDC_WAIT));

    BOOL fICSInstalled = FALSE;

    HRESULT hr = S_OK;

    INetConnectionManager* pSharedAccessConnectionManager; 
    hr = CoCreateInstance(CLSID_SharedAccessConnectionManager, NULL, CLSCTX_LOCAL_SERVER, IID_INetConnectionManager, reinterpret_cast<void**>(&pSharedAccessConnectionManager));
    if(SUCCEEDED(hr))
    {
        IEnumNetConnection* pEnumerator;
        hr = pSharedAccessConnectionManager->EnumConnections(NCME_DEFAULT, &pEnumerator);
        if(SUCCEEDED(hr))
        {
            INetConnection* pNetConnection;
            ULONG ulFetched;
            hr = pEnumerator->Next(1, &pNetConnection, &ulFetched); // HNW only cares about >= 1 beacon
            if(SUCCEEDED(hr) && 1 == ulFetched)
            {
                fICSInstalled = TRUE; 

                // found the beacon, now recover the machine name if supported
                
                INetSharedAccessConnection* pNetSharedAccessConnection;
                hr = pNetConnection->QueryInterface(IID_INetSharedAccessConnection, reinterpret_cast<void**>(&pNetSharedAccessConnection));
                if(SUCCEEDED(hr))
                {
                    IUPnPService* pOSInfoService;
                    hr = pNetSharedAccessConnection->GetService(SAHOST_SERVICE_OSINFO, &pOSInfoService);
                    if(SUCCEEDED(hr))
                    {
                        
                        VARIANT Variant;
                        VariantInit(&Variant);
                        BSTR VariableName;
                        VariableName = SysAllocString(L"OSMachineName");
                        if(NULL != VariableName)
                        {
                            hr = pOSInfoService->QueryStateVariable(VariableName, &Variant);
                            if(SUCCEEDED(hr))
                            {
                                if(V_VT(&Variant) == VT_BSTR)
                                {
                                    lstrcpyn(pszICSMachineName, V_BSTR(&Variant), cch);
                                }
                                else
                                {
                                    hr = E_UNEXPECTED;
                                }
                                VariantClear(&Variant);
                            }
                            SysFreeString(VariableName);
                        }
                        else
                        {
                            hr = E_OUTOFMEMORY;
                        }
                        pOSInfoService->Release();
                    }
                    pNetSharedAccessConnection->Release();
                }

                if(FAILED(hr))
                {
                    if (!LoadString(g_hinst, IDS_UNIDENTIFIED_ICS_DEVICE, pszICSMachineName, cch))
                        *pszICSMachineName = TEXT('\0');
                }
                pNetConnection->Release();
            }
            pEnumerator->Release();
        }
        pSharedAccessConnectionManager->Release();
    }
    return fICSInstalled;
}

void CHomeNetworkWizard::InitializeConnectionList(HWND hwndList, DWORD dwFlags)
{
    // Set up the columns of the list
    LVCOLUMN lvc;
    lvc.mask = LVCF_SUBITEM | LVCF_WIDTH;

    lvc.iSubItem = 0;
    lvc.cx = 10;
    ListView_InsertColumn(hwndList, 0, &lvc);

    lvc.iSubItem = 1;
    lvc.cx = 10;
    ListView_InsertColumn(hwndList, 1, &lvc);

    DWORD dwStyles = LVS_EX_FULLROWSELECT;
    if (dwFlags & CONN_INTERNAL)
        dwStyles |= LVS_EX_CHECKBOXES;

    // Consider disabling the list or something for CONN_UNPLUGGED

    ListView_SetExtendedListViewStyleEx(hwndList, dwStyles, dwStyles);

    ListView_SetImageList(hwndList, _himlSmall, LVSIL_SMALL);
       
    _psfConnections = NULL;
    _pConnViewCB = NULL;

    if (g_fRunningOnNT)
    {
        HRESULT hr = GetConnectionsFolder(&_psfConnections);
    
        if (SUCCEEDED(hr))
        {
            IShellView *pConnView = NULL;
        
            hr = _psfConnections->CreateViewObject(hwndList, IID_IShellView, reinterpret_cast<LPVOID *>(&pConnView));
            if (SUCCEEDED(hr))
            {
    
                hr = _psfConnections->QueryInterface(IID_IShellFolderViewCB, reinterpret_cast<LPVOID *>(&_pConnViewCB));
                if (SUCCEEDED(hr))
                {
                    HWND hWndParent = GetParent(hwndList);
                    hr = _pConnViewCB->MessageSFVCB(SFVM_HWNDMAIN, NULL, reinterpret_cast<LPARAM>(hWndParent));
                }                
            }

            if (pConnView != NULL)
                pConnView->Release();
        }
    }
}

BOOL CHomeNetworkWizard::IsConnectionUnplugged(INetConnection* pnc)
{
    BOOL fUnplugged = FALSE;
    
    if ( g_fRunningOnNT )
    {
        HRESULT            hr;
        NETCON_PROPERTIES* pncprops;
        
        hr = pnc->GetProperties(&pncprops);
     
        if (SUCCEEDED(hr))
        {
            ASSERT(pncprops);
        
            fUnplugged = (NCS_MEDIA_DISCONNECTED == pncprops->Status);

            NcFreeNetconProperties(pncprops);
        }
    }

    return fUnplugged;
}

BOOL CHomeNetworkWizard::ShouldShowConnection(INetConnection* pnc, INetConnection* pncExcludeFromList, DWORD dwFlags)
{
    BOOL fShow = FALSE;

    if (!IsEqualConnection(pnc, pncExcludeFromList))
    {
        NETCON_PROPERTIES* pprops;
        HRESULT hr = pnc->GetProperties(&pprops);

        // Is this the kind of connection we want to show based on whether its external or internal list?
        if (SUCCEEDED(hr))
        {
            // Note: The bridge is a virtual and not a real connection. If it exists, it will have
            // NCM_BRIDGE, and so it won't get shown here, which is correct.
            if (dwFlags & CONN_EXTERNAL)
            {
                if ((pprops->MediaType == NCM_LAN) ||
                    (pprops->MediaType == NCM_PHONE) ||
                    (pprops->MediaType == NCM_TUNNEL) ||
                    (pprops->MediaType == NCM_ISDN) ||
                    (pprops->MediaType == NCM_PPPOE))
                {
                    fShow = TRUE;
                }
            }

            if (dwFlags & CONN_INTERNAL)
            {
                if (pprops->MediaType == NCM_LAN)
                {
                    // Note: In this case pncExcludeFromList is the shared adapter.  
                    // If this is a VPN(NCM_TUNNEL) connection then we want to make 
                    // sure its pszPrerequisiteEntry is connected.
                    
                    BOOL    fAssociated;
                    HRESULT hr;
                    
                    hr = HrConnectionAssociatedWithSharedConnection( pnc, pncExcludeFromList, &fAssociated );
                
                    if ( SUCCEEDED(hr) )
                    {
                        fShow = !fAssociated;
                    }
                    else
                    {
                        fShow = TRUE;
                    }
                }
            }

            if (dwFlags & CONN_UNPLUGGED)
            {
                if (IsConnectionUnplugged(pnc))
                {
                    fShow = TRUE;
                }
            }

            NcFreeNetconProperties(pprops);
        }
    }

    return fShow;
}

BOOL CHomeNetworkWizard::IsConnectionICSPublic(INetConnection* pnc)
{
    BOOL fShared = FALSE;

    NETCON_PROPERTIES* pprops;
    HRESULT hr = pnc->GetProperties(&pprops);

    // Is this the kind of connection we want to show based on whether its external or internal list?
    if (SUCCEEDED(hr))
    {
        // Note: Don't check pprops->MediaType == NCM_SHAREDACCESSHOST. SHAREDACCESSHOST is the connectoid
        // representing a host's shared connection from the point of view of an ICS client, and not what we're
        // interested in.
        if (pprops->dwCharacter & NCCF_SHARED)
        {
            fShared = TRUE;
        }

        NcFreeNetconProperties(pprops);
    }

    return fShared;
}

void CHomeNetworkWizard::FillConnectionList(HWND hwndList, INetConnection* pncExcludeFromList, DWORD dwFlags)
{
    DestroyConnectionList(hwndList);

    BOOL fSelected = FALSE; // Has an entry in the list been selected

    if (g_fRunningOnNT)
    {
        HRESULT hr = 0;

        if (_pConnViewCB != NULL)
            _pConnViewCB->MessageSFVCB(DVM_REFRESH, TRUE, TRUE);
    
        if (SUCCEEDED(hr))
        {
            // Enumerate each net connection
            DWORD cItems = DPA_GetPtrCount(_hdpaConnections);

            for (DWORD iItem = 0; iItem < cItems; iItem ++)
            {                        
                
                INetConnection* pnc = (INetConnection*) DPA_GetPtr(_hdpaConnections, iItem);

                ASSERT(pnc);

                // Is this the kind of connection we want to show?
                if (ShouldShowConnection(pnc, pncExcludeFromList, dwFlags))
                {
                    NETCON_PROPERTIES* pncprops;

                    hr = pnc->GetProperties(&pncprops);

                    if (SUCCEEDED(hr))
                    {
                        LVITEM lvi = {0};
                        
                        if ((dwFlags & CONN_EXTERNAL) && fSelected)
                        {
                            // If we have a default public adapter, insert other adapters
                            // after it so the default appears at the top of the list.
                            lvi.iItem = 1;
                        }
                        
                        lvi.mask = LVIF_PARAM | LVIF_TEXT;
                        lvi.pszText = pncprops->pszwName;
                        lvi.lParam = (LPARAM) pnc; // We addref this guy when/if we actually add this item

                        // Get the icon index for this connection
                        int iIndex;        

                        hr = GetConnectionIconIndex(pncprops->guidId, _psfConnections, &iIndex);
                        
                        if (SUCCEEDED(hr))
                        {
                            lvi.iImage = iIndex;
                            if (-1 != lvi.iImage)
                               lvi.mask |= LVIF_IMAGE;
                        }

                        // Its ok if the icon stuff failed for now
                        hr = S_OK;

                        int iItem = ListView_InsertItem(hwndList, &lvi);

                        if (-1 != iItem)
                        {
                            pnc->AddRef();

                            ListView_SetItemText(hwndList, iItem, 1, pncprops->pszwDeviceName);

                            if (dwFlags & CONN_EXTERNAL)
                            {
                                // Select the connection that is already ICS public, if applicable, or
                                // Use network location awareness to guess at a connection type - TODO
                                if (pncprops->dwCharacter & NCCF_SHARED || NLA_INTERNET_YES == GetConnectionInternetType(&pncprops->guidId))
                                {
                                    ListView_SetItemState(hwndList, iItem, LVIS_SELECTED, LVIS_SELECTED);
                                    fSelected = TRUE;
                                }
                            }

                            if (dwFlags & CONN_INTERNAL)
                            {
                                ListView_SetItemState(hwndList, iItem, INDEXTOSTATEIMAGEMASK(2), LVIS_STATEIMAGEMASK);
                                fSelected = TRUE;
                            }
                        }

                        NcFreeNetconProperties(pncprops);
                    }
                }
            }
        }

    }
    else
    {
        if (_hnetInfo.cNA && _hnetInfo.pNA)
        {
            const NETADAPTER* pNA = _hnetInfo.pNA;

            for (UINT i = 0; i < _hnetInfo.cNA; i++, pNA++)
            {
                // Check if the NIC is working.

                if (W9xIsValidAdapter(pNA, dwFlags))
                {
                    fSelected = W9xAddAdapterToList(pNA, pNA->szDisplayName, i, 0, hwndList, dwFlags);
                }
                else if (W9xIsAdapterDialUp(pNA))
                {
                    _hnetInfo.cRas = W9xEnumRasEntries();

                    for (UINT j = 0; j < _hnetInfo.cRas; j++)
                    {
                        // W9xAddAdapterToList ALWAYS adds the adapter regardless of the
                        // state of the connection.  So we do not have the equivalent of
                        // the Whistler "ShouldShowConnection".  Here we need to check
                        // the flags to exclude listing inappropriate adapters.
                    
                        if ( ~CONN_UNPLUGGED & dwFlags )    // Never show RAS Entry's as Unplugged
                        {
                            fSelected = W9xAddAdapterToList( pNA, 
                                                             _hnetInfo.pRas[j].szEntryName, 
                                                             i, j, 
                                                             hwndList, 
                                                             dwFlags );
                        }
                    }
                }
            }
        }
    }

    ListView_SetColumnWidth(hwndList, 0, LVSCW_AUTOSIZE);
    ListView_SetColumnWidth(hwndList, 1, LVSCW_AUTOSIZE);
}

BOOL  CHomeNetworkWizard::W9xAddAdapterToList(const NETADAPTER* pNA, const WCHAR* pszDesc, UINT uiAdapterIndex, UINT uiDialupIndex, HWND hwndList, DWORD dwFlags)
{
    BOOL fSelected = FALSE;

    LVITEM lvi = {0};
    lvi.mask = LVIF_PARAM | LVIF_TEXT;

    WCHAR szNicType[MAX_PATH];
    W9xGetNetTypeName(pNA->bNetType, szNicType, ARRAYSIZE(szNicType));
    lvi.pszText = szNicType;

    lvi.lParam = MAKELONG(LOWORD(uiAdapterIndex), LOWORD(uiDialupIndex));

    int iItem = ListView_InsertItem(hwndList, &lvi);

    if (-1 != iItem)
    {
        ListView_SetItemText(hwndList, iItem, 1, (LPWSTR)pszDesc);

        if (dwFlags & CONN_EXTERNAL)
        {
            if (NETTYPE_DIALUP == pNA->bNetType ||
                NETTYPE_PPTP   == pNA->bNetType ||
                NETTYPE_ISDN   == pNA->bNetType    )
            {
                ListView_SetItemState(hwndList, iItem, LVIS_SELECTED, LVIS_SELECTED);
                fSelected = TRUE;
            }

        }

        if (dwFlags & CONN_INTERNAL)
        {
            if (NETTYPE_LAN  == pNA->bNetType ||
                NETTYPE_IRDA == pNA->bNetType ||    // ISSUE-2000/05/31-edwardp: Internal?
                NETTYPE_TV   == pNA->bNetType    )  // ISSUE-2000/05/31-edwardp: Internal?
            {
                ListView_SetItemState(hwndList, iItem, INDEXTOSTATEIMAGEMASK(2), LVIS_STATEIMAGEMASK);
                fSelected = TRUE;
            }
        }
    }

    return fSelected;
}

UINT CHomeNetworkWizard::W9xEnumRasEntries()
{
    UINT uiRet = 0;

    if (!_hnetInfo.pRas)
    {
        DWORD cDUNs = 0;
        DWORD cb    = 0;

        RasEnumEntries(NULL, NULL, NULL, &cb, &cDUNs);

        if (cb > 0)
        {
            _hnetInfo.pRas = (RASENTRYNAME*)LocalAlloc(LPTR, cb);

            if (_hnetInfo.pRas)
            {
                _hnetInfo.pRas->dwSize = sizeof(RASENTRYNAME);

                if (RasEnumEntries(NULL, NULL, _hnetInfo.pRas, &cb, &cDUNs) == 0)
                {
                    uiRet = cDUNs;
                }
            }
        }
    }

    return uiRet;
}

typedef struct
{
    LPCWSTR idPage;
    DLGPROC pDlgProc;
    LPCWSTR pHeading;
    LPCWSTR pSubHeading;
    DWORD dwFlags;
} WIZPAGE;

#define MAKEWIZPAGE(name, dlgproc, dwFlags)   \
    { MAKEINTRESOURCE(IDD_WIZ_##name##), dlgproc, MAKEINTRESOURCE(IDS_HEADER_##name##), MAKEINTRESOURCE(IDS_SUBHEADER_##name##), dwFlags }

INT_PTR MyPropertySheet(LPCPROPSHEETHEADER pHeader);
HPROPSHEETPAGE MyCreatePropertySheetPage(LPPROPSHEETPAGE psp);


HRESULT DoesUserHaveHNetPermissions(BOOL* pfHasPermission)
{
    HRESULT hr;

    if (g_fRunningOnNT)
    {
        // TODO: We need to check this stuff in once the net team RI's
        INetConnectionUiUtilities* pNetConnUiUtil;
        *pfHasPermission = FALSE;

        hr = CoCreateInstance(CLSID_NetConnectionUiUtilities, NULL, CLSCTX_INPROC, IID_PPV_ARG(INetConnectionUiUtilities, &pNetConnUiUtil));

        if (SUCCEEDED(hr))
        {
            if (pNetConnUiUtil->UserHasPermission(NCPERM_ShowSharedAccessUi) &&
#if 0 // NYI
                pNetConnUiUtil->UserHasPermission(NCPERM_AllowNetBridge_NLA) &&
#endif
                pNetConnUiUtil->UserHasPermission(NCPERM_ICSClientApp) &&
                pNetConnUiUtil->UserHasPermission(NCPERM_PersonalFirewallConfig))
            {
                *pfHasPermission = TRUE;
            }

            pNetConnUiUtil->Release();
        }
        else
        {
            TraceMsg(TF_WARNING, "Could not cocreate CLSID_NetConnectionUIUtilities");
        }
    }
    else
    {
        // Windows 9x
        *pfHasPermission = TRUE;
        hr = S_OK;
    }

    return hr;
}

BOOL CHomeNetworkWizard::IsMachineOnDomain()
{
    BOOL fDomain = FALSE;

#ifdef NO_CHECK_DOMAIN
    return fDomain;
#endif

    NETSETUP_JOIN_STATUS njs;

    //
    // Make sure to initialize pszName to NULL.  On W9x NetJoinInformation returns NERR_Success
    // but doesn't allocate pszName.  On retail builds the stack garbage in pszName happened to
    // be the this pointer for CHomeNetworkWizard and NetApiBufferFreeWrap called LocalFree
    // on it.
    //
    LPWSTR pszName = NULL;  // init to NULL! See comment above.
    if (NERR_Success == NetGetJoinInformation(NULL, &pszName, &njs))
    {
        fDomain = (NetSetupDomainName == njs);
        NetApiBufferFree(pszName);
    }

    return fDomain;
}

BOOL CHomeNetworkWizard::IsMachineWrongOS()
{
    BOOL fWrongOS = TRUE;

    if (IsOS(OS_WINDOWS))
    {
        if (IsOS(OS_WIN98ORGREATER))
        {
            fWrongOS = FALSE;
        }
    }
    else
    {
        if (IsOS(OS_WHISTLERORGREATER))
        {
            fWrongOS = FALSE;
        }
    }

    return fWrongOS;
}

// The page indices for the possible start pages (three error and one real start page)
#define PAGE_NOTADMIN      0
#define PAGE_NOPERMISSIONS 1
#define PAGE_NOHARDWARE    2
#define PAGE_WRONGOS       3
#define PAGE_DOMAIN        4
#define PAGE_WELCOME       5
#define PAGE_CONNECT       9
#define PAGE_FINISH        25

HRESULT CHomeNetworkWizard::ShowWizard(HWND hwnd, BOOL* pfRebootRequired)
{
    HRESULT hr = S_OK;
    TCHAR szCaption[256];
    LoadString(g_hinst, IDS_WIZ_CAPTION, szCaption, ARRAYSIZE(szCaption));
    CEnsureSingleInstance ESI(szCaption);

    if (!ESI.ShouldExit())
    {
        if (g_fRunningOnNT)
        {
            LinkWindow_RegisterClass_NT();
        }

        *pfRebootRequired = FALSE;
        hr = Initialize();
        if (SUCCEEDED(hr))
        {
            WIZPAGE c_wpPages[] =
            {
                // Error start pages
                MAKEWIZPAGE(NOTADMIN,          CantRunWizardPageProc,     PSP_HIDEHEADER),
                MAKEWIZPAGE(NOPERMISSIONS,     CantRunWizardPageProc,     PSP_HIDEHEADER),
                MAKEWIZPAGE(NOHARDWARE,        NoHardwareWelcomePageProc, PSP_HIDEHEADER),
                MAKEWIZPAGE(WRONGOS,           CantRunWizardPageProc,     PSP_HIDEHEADER),
                MAKEWIZPAGE(DOMAINWELCOME,     CantRunWizardPageProc,     PSP_HIDEHEADER),
                // Real start page
                MAKEWIZPAGE(WELCOME,           WelcomePageProc,           PSP_HIDEHEADER),
                MAKEWIZPAGE(MANUALCONFIG,      ManualConfigPageProc,      0),
                MAKEWIZPAGE(UNPLUGGED,         UnpluggedPageProc,         0),
                MAKEWIZPAGE(FOUNDICS,          FoundIcsPageProc,          0),
                MAKEWIZPAGE(CONNECT,           ConnectPageProc,           0),
                MAKEWIZPAGE(CONNECTOTHER,      ConnectOtherPageProc,      0),
                MAKEWIZPAGE(PUBLIC,            PublicPageProc,            0),
                MAKEWIZPAGE(EDGELESS,          EdgelessPageProc,           0),
                MAKEWIZPAGE(ICSCONFLICT,       ICSConflictPageProc,       0),
                MAKEWIZPAGE(BRIDGEWARNING,     BridgeWarningPageProc,     0),
                MAKEWIZPAGE(PRIVATE,           PrivatePageProc,           0),
                MAKEWIZPAGE(NAME,              NamePageProc,              0),
                MAKEWIZPAGE(WORKGROUP,         WorkgroupPageProc,         0),
                MAKEWIZPAGE(SUMMARY,           SummaryPageProc,           0),
                MAKEWIZPAGE(PROGRESS,          ProgressPageProc,          0),
                MAKEWIZPAGE(ALMOSTDONE,        AlmostDonePageProc,        0),
                MAKEWIZPAGE(CHOOSEDISK,        ChooseDiskPageProc,        0),
                MAKEWIZPAGE(INSERTDISK,        InsertDiskPageProc,        0),
                MAKEWIZPAGE(FLOPPYINST,        InstructionsPageProc,      0),
                MAKEWIZPAGE(CDINST,            InstructionsPageProc,      0),
                MAKEWIZPAGE(FINISH,            FinishPageProc,            PSP_HIDEHEADER),
                MAKEWIZPAGE(CONFIGERROR,       ErrorFinishPageProc,       PSP_HIDEHEADER),
                MAKEWIZPAGE(NOHARDWAREFINISH,  NoHardwareFinishPageProc,  PSP_HIDEHEADER),
            };

            // Sanity check to make sure we haven't added new error pages without updating the
            // welcome page number
            ASSERT(c_wpPages[PAGE_WELCOME].idPage == MAKEINTRESOURCE(IDD_WIZ_WELCOME));
            ASSERT(c_wpPages[PAGE_CONNECT].idPage == MAKEINTRESOURCE(IDD_WIZ_CONNECT));
            ASSERT(c_wpPages[PAGE_FINISH].idPage  == MAKEINTRESOURCE(IDD_WIZ_FINISH));

            if (!g_fRunningOnNT)
            {
                c_wpPages[PAGE_WELCOME].idPage = MAKEINTRESOURCE(IDD_WIZ_WIN9X_WELCOME);
                c_wpPages[PAGE_FINISH].idPage  = MAKEINTRESOURCE(IDD_WIZ_WIN9X_FINISH);

                CICSInst* pICS = new CICSInst;
                if (pICS)
                {
                    if (!pICS->IsInstalled())
                    {
                        c_wpPages[PAGE_CONNECT].idPage = MAKEINTRESOURCE(IDD_WIZ_WIN9X_CONNECT);
                        _fNoICSQuestion = TRUE;
                    }

                    delete pICS;
                }
            }

            HPROPSHEETPAGE rghpage[MAX_HNW_PAGES];
            int cPages;

            for (cPages = 0; cPages < ARRAYSIZE(c_wpPages); cPages ++)
            {
                PROPSHEETPAGE psp = { 0 };

                psp.dwSize = SIZEOF(PROPSHEETPAGE);
                psp.hInstance = g_hinst;
                psp.lParam = (LPARAM)this;
                psp.dwFlags = PSP_USETITLE | PSP_DEFAULT | PSP_USEHEADERTITLE |
                                            PSP_USEHEADERSUBTITLE | c_wpPages[cPages].dwFlags;
                psp.pszTemplate = c_wpPages[cPages].idPage;
                psp.pfnDlgProc = c_wpPages[cPages].pDlgProc;
                psp.pszTitle = MAKEINTRESOURCE(IDS_WIZ_CAPTION);
                psp.pszHeaderTitle = c_wpPages[cPages].pHeading;
                psp.pszHeaderSubTitle = c_wpPages[cPages].pSubHeading;

                rghpage[cPages] = MyCreatePropertySheetPage(&psp);
            }

            ASSERT(cPages < MAX_HNW_PAGES);

            PROPSHEETHEADER psh = { 0 };
            psh.dwSize = SIZEOF(PROPSHEETHEADER);
            psh.hwndParent = hwnd;
            psh.hInstance = g_hinst;
            psh.dwFlags = PSH_USEICONID | PSH_WIZARD | PSH_WIZARD97 | PSH_WATERMARK | PSH_STRETCHWATERMARK | PSH_HEADER;
            psh.pszbmHeader = MAKEINTRESOURCE(IDB_HEADER);
            psh.pszbmWatermark = MAKEINTRESOURCE(IDB_WATERMARK);
            psh.nPages = cPages;
            psh.phpage = rghpage;
            psh.pszIcon = MAKEINTRESOURCE(IDI_APPICON);

            // Check for administrator and policy (permissions)
            BOOL fUserIsAdmin = FALSE;
            BOOL fUserHasPermissions = FALSE;

            IsUserLocalAdmin(NULL, &fUserIsAdmin);
            DoesUserHaveHNetPermissions(&fUserHasPermissions);

            if (!fUserIsAdmin)
            {
                // Not admin error page
                psh.nStartPage = PAGE_NOTADMIN;
            }
            else if (!fUserHasPermissions)
            {
                // No permissions error page
                psh.nStartPage = PAGE_NOPERMISSIONS;
            }
            else if (GetConnectionCount(NULL, CONN_INTERNAL) < 1)
            {
                if ( g_fRunningOnNT && ( GetConnectionCount(NULL, CONN_EXTERNAL) > 0 ) )
                {
                    TraceMsg(TF_WARNING, "External Adapters Only");

                    psh.nStartPage = PAGE_WELCOME;
                    _fExternalOnly  = TRUE;
                }
                else
                {
                    // No hardware error page
                    psh.nStartPage = PAGE_NOHARDWARE;
                }
            }
            else if (IsMachineWrongOS())
            {
                psh.nStartPage = PAGE_WRONGOS;
            }
            else if (IsMachineOnDomain())
            {
                psh.nStartPage = PAGE_DOMAIN;
            }
            else
            {
                // Run the real wizard
                psh.nStartPage = PAGE_WELCOME;
            }

            INT_PTR iReturn = MyPropertySheet(&psh);
            *pfRebootRequired = ((iReturn == ID_PSRESTARTWINDOWS) || (iReturn == ID_PSREBOOTSYSTEM));

            Uninitialize();
        }
    }

    return hr;
}

void GetTitleFont(LPTSTR pszFaceName, DWORD cch)
{
    if (!LoadString(g_hinst, IDS_TITLE_FONT, pszFaceName, cch))
    {
        lstrcpyn(pszFaceName, TEXT("Verdana"), cch);
    }
}

LONG GetTitlePointSize()
{
    LONG lPointSize = 0;
    TCHAR szPointSize[20];

    if (LoadString(g_hinst, IDS_TITLE_POINTSIZE, szPointSize, ARRAYSIZE(szPointSize)))
    {
        lPointSize = StrToInt(szPointSize);
    }

    if (!lPointSize)
    {
        lPointSize = 12;
    }

    return lPointSize;
}

void CHomeNetworkWizard::WelcomeSetTitleFont(HWND hwnd)
{
    HWND hwndTitle = GetDlgItem(hwnd, IDC_TITLE);

    // Get the existing font
    HFONT hfontOld = (HFONT) SendMessage(hwndTitle, WM_GETFONT, 0, 0);

    LOGFONT lf = {0};
    if (GetObject(hfontOld, sizeof(lf), &lf))
    {
        GetTitleFont(lf.lfFaceName, ARRAYSIZE(lf.lfFaceName));

        HDC hDC = GetDC(hwndTitle);
        if (hDC)
        {
            lf.lfHeight = -MulDiv(GetTitlePointSize(), GetDeviceCaps(hDC, LOGPIXELSY), 72);
            lf.lfWeight = FW_BOLD;

            HFONT hfontNew = CreateFontIndirect(&lf);
            if (hfontNew)
            {
                SendMessage(hwndTitle, WM_SETFONT, (WPARAM) hfontNew, FALSE);

                // Don't do this, its shared.
                // DeleteObject(hfontOld);
            }

            ReleaseDC(hwndTitle, hDC);
        }
    }

    LONG lStyle = GetWindowLong(GetParent(hwnd), GWL_STYLE);
    SetWindowLong(GetParent(hwnd), GWL_STYLE, lStyle & ~WS_SYSMENU);
}

INT_PTR CHomeNetworkWizard::WelcomePageProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    CHomeNetworkWizard* pthis = GetThis(hwnd, uMsg, wParam, lParam);

    switch (uMsg)
    {
    case WM_INITDIALOG:
        pthis->WelcomeSetTitleFont(hwnd);
        return TRUE;
    case WM_NOTIFY:
        {
            LPNMHDR pnmh = (LPNMHDR) lParam;

            switch (pnmh->code)
            {
            case PSN_SETACTIVE:
                PropSheet_SetWizButtons(pnmh->hwndFrom, PSWIZB_NEXT);
                return TRUE;
            case PSN_WIZNEXT:
                SetWindowLongPtr(hwnd, DWLP_MSGRESULT, IDD_WIZ_MANUALCONFIG);
                if (!g_fRunningOnNT)
                    pthis->PushPage(IDD_WIZ_WIN9X_WELCOME);
                else
                    pthis->PushPage(IDD_WIZ_WELCOME);
                return TRUE;
            }
        }
        return FALSE;
    }

    return FALSE;
}

INT_PTR CHomeNetworkWizard::NoHardwareWelcomePageProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    CHomeNetworkWizard* pthis = GetThis(hwnd, uMsg, wParam, lParam);

    switch (uMsg)
    {
    case WM_INITDIALOG:
        pthis->WelcomeSetTitleFont(hwnd);
        pthis->ReplaceStaticWithLink(GetDlgItem(hwnd, IDC_HELPSTATIC), IDC_HELPLINK, IDS_HELP_HARDWAREREQ);
        return TRUE;
    case WM_NOTIFY:
        {
            LPNMHDR pnmh = (LPNMHDR) lParam;

            switch (pnmh->code)
            {
            case PSN_SETACTIVE:
                PropSheet_SetWizButtons(pnmh->hwndFrom, 0);
                return TRUE;
            case NM_CLICK:
            case NM_RETURN:
                switch ((int) wParam)
                {
                    case IDC_HELPLINK:
                        {
                            HelpCenter(hwnd, L"network.chm%3A%3A/hnw_requirements.htm");
                        }
                        return TRUE;
                }
            }
        }
        return FALSE;
    }

    return FALSE;
}

void CHomeNetworkWizard::ReplaceStaticWithLink(HWND hwndStatic, UINT idcLinkControl, UINT idsLinkText)
{
    if (g_fRunningOnNT)
    {
        RECT rcStatic;
        HWND hwndParent = GetParent(hwndStatic);
        if (GetWindowRect(hwndStatic, &rcStatic) &&
            MapWindowPoints(NULL, hwndParent, (LPPOINT) &rcStatic, 2))
        {
            WCHAR szLinkText[256];
            if (LoadString(g_hinst, idsLinkText, szLinkText, ARRAYSIZE(szLinkText)))
            {
                HWND hwndLink = CreateWindowEx(0, TEXT("SysLink"), szLinkText, WS_CHILD | WS_TABSTOP | LWS_IGNORERETURN,
                    rcStatic.left, rcStatic.top, (rcStatic.right - rcStatic.left), (rcStatic.bottom - rcStatic.top),
                    hwndParent, NULL, g_hinst, NULL);

                if (hwndLink)
                {
                    SetWindowLongPtr(hwndLink, GWLP_ID, (LONG_PTR) idcLinkControl);
                    ShowWindow(hwndLink, SW_SHOW);
                    ShowWindow(hwndStatic, SW_HIDE);
                }
            }
        }
    }
}

void CHomeNetworkWizard::ManualRefreshConnectionList()
{
    if (g_fRunningOnNT)
    {
        // Refresh connection DPA in case the user plugged in more connections
        HDPA hdpaConnections2;
        if (SUCCEEDED(GetConnections(&hdpaConnections2)))
        {
            // Replace the real list with our new one
            DPA_DestroyCallback(_hdpaConnections, FreeConnectionDPACallback, NULL);
            _hdpaConnections = hdpaConnections2;

            // Ensure we remove our other holds to the INetConnections
            // Free public lan information
            FreeExternalConnection(&_hnetInfo);

            // Free private lan information
            FreeInternalConnections(&_hnetInfo);
        }
    }
}

INT_PTR CHomeNetworkWizard::ManualConfigPageProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    CHomeNetworkWizard* pthis = GetThis(hwnd, uMsg, wParam, lParam);

    switch (uMsg)
    {
    case WM_INITDIALOG:
        pthis->ReplaceStaticWithLink(GetDlgItem(hwnd, IDC_HELPSTATIC), IDC_HELPLINK, IDS_HELP_INSTALLATION);
        return TRUE;
    case WM_NOTIFY:
        {
            LPNMHDR pnmh = (LPNMHDR) lParam;

            switch (pnmh->code)
            {
            case PSN_SETACTIVE:
                PropSheet_SetWizButtons(pnmh->hwndFrom, PSWIZB_BACK | PSWIZB_NEXT);
                return TRUE;
            case PSN_WIZNEXT:
                // pthis->ManualRefreshConnectionList();
                SetWindowLongPtr(hwnd, DWLP_MSGRESULT, IDD_WIZ_UNPLUGGED);
                pthis->PushPage(IDD_WIZ_MANUALCONFIG);
                return TRUE;
            case PSN_WIZBACK:
                SetWindowLongPtr(hwnd, DWLP_MSGRESULT, pthis->PopPage());
                return TRUE;
            case NM_CLICK:
            case NM_RETURN:
                switch ((int) wParam)
                {
                    case IDC_HELPLINK:
                        {
                            if (IsOS(OS_PERSONAL))
                            {
                                HelpCenter(hwnd, L"network.chm%3A%3A/hnw_checklistP.htm");
                            }
                            else
                            {
                                HelpCenter(hwnd, L"network.chm%3A%3A/hnw_checklistW.htm");
                            }
                        }
                        return TRUE;
                }
            }
        }
        return FALSE;
    }

    return FALSE;
}

// Returns TRUE if there are some unplugged connections, FALSE o/w
BOOL CHomeNetworkWizard::UnpluggedFillList(HWND hwnd)
{
    BOOL fSomeUnpluggedConnections = FALSE;

    HWND hwndList = GetDlgItem(hwnd, IDC_CONNLIST);
    FillConnectionList(hwndList, NULL, CONN_UNPLUGGED);

    // and if there actually are unplugged connections...
    if (0 != ListView_GetItemCount(hwndList))
    {
        // Show this page
        fSomeUnpluggedConnections = TRUE;
    }

    return fSomeUnpluggedConnections;
}

INT_PTR CHomeNetworkWizard::UnpluggedPageProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    CHomeNetworkWizard* pthis = GetThis(hwnd, uMsg, wParam, lParam);

    switch (uMsg)
    {
    case WM_INITDIALOG:
        pthis->InitializeConnectionList(GetDlgItem(hwnd, IDC_CONNLIST), CONN_UNPLUGGED);
        SendDlgItemMessage(hwnd, IDC_IGNORE, BM_SETCHECK, BST_UNCHECKED, 0);
        return TRUE;
    case WM_NOTIFY:
        {
            LPNMHDR pnmh = (LPNMHDR) lParam;

            switch (pnmh->code)
            {
            case PSN_SETACTIVE:
                {
                    // If we don't need to show this page
                    if (!pthis->UnpluggedFillList(hwnd))
                    {
                        // Don't push ourselves on the stack
                        // But navigate to the next page...
                        SetWindowLongPtr( hwnd, DWLP_MSGRESULT, 
                                          (pthis->_fExternalOnly) ? IDD_WIZ_CONNECTOTHER : IDD_WIZ_FOUNDICS );
                    }
                }
                return TRUE;
            case PSN_WIZNEXT:
                {
                    BOOL fStillUnplugged = pthis->UnpluggedFillList(hwnd);
                    int idNext;
                    if (!fStillUnplugged)
                    {
                        // User fixed the problem. Go forward and don't store this
                        // error page on the pagestack
                        
                        idNext = (pthis->_fExternalOnly) ? IDD_WIZ_CONNECTOTHER : IDD_WIZ_FOUNDICS;
                    }
                    else if (BST_CHECKED == SendDlgItemMessage(hwnd, IDC_IGNORE, BM_GETCHECK, 0, 0))
                    {
                        // User wants to go on, but store this page on the pagestack
                        // so they can "back" up to it.
                        pthis->PushPage(IDD_WIZ_UNPLUGGED);
                        idNext = (pthis->_fExternalOnly) ? IDD_WIZ_CONNECTOTHER : IDD_WIZ_FOUNDICS;
                    }
                    else
                    {
                        // User still has disconnected net hardware they don't want to ignore. Tell them and keep them on this page.
                        DisplayFormatMessage(hwnd, IDS_WIZ_CAPTION, IDS_STILLUNPLUGGED, MB_ICONERROR | MB_OK);
                        idNext = -1;
                    }

                    SetWindowLongPtr(hwnd, DWLP_MSGRESULT, idNext);
                }
                return TRUE;
            case PSN_WIZBACK:
                SetWindowLongPtr(hwnd, DWLP_MSGRESULT, pthis->PopPage());
                return TRUE;
            }
        }
        return FALSE;
    case WM_DESTROY:
        pthis->DestroyConnectionList(GetDlgItem(hwnd, IDC_CONNLIST));
        return TRUE;
    }

    return FALSE;
}



void CHomeNetworkWizard::PublicSetControlState(HWND hwnd)
{
    BOOL fSelection = ListView_GetSelectedCount(GetDlgItem(hwnd, IDC_CONNLIST));
    PropSheet_SetWizButtons(GetParent(hwnd), fSelection ? PSWIZB_BACK | PSWIZB_NEXT : PSWIZB_BACK);
}

void FreeExternalConnection(PHOMENETSETUPINFO pInfo)
{
    if (pInfo->pncExternal)
    {
        pInfo->pncExternal->Release();
        pInfo->pncExternal = NULL;
    }
}

void CHomeNetworkWizard::PublicNextPage(HWND hwnd)
{
    FreeExternalConnection(&_hnetInfo);

    // Get the selected external adapter
    HWND hwndList = GetDlgItem(hwnd, IDC_CONNLIST);

    int iItem = ListView_GetNextItem(hwndList, -1, LVNI_SELECTED);

    // We can assert here since Next should be disabled if there is no selection!
    ASSERT(-1 != iItem);

    LVITEM lvi = {0};
    lvi.iItem = iItem;
    lvi.mask = LVIF_PARAM;

    if (ListView_GetItem(hwndList, &lvi))
    {
        if (g_fRunningOnNT)
        {
            _hnetInfo.pncExternal = (INetConnection*) (lvi.lParam);
            _hnetInfo.pncExternal->AddRef();
        }
        else
        {
            _hnetInfo.ipaExternal = lvi.lParam;
        }
    }

    // Do the real wizard navigation

    UINT idPage = IDD_WIZ_NAME;

    if (g_fRunningOnNT)
    {
        idPage = _fShowSharingPage ? IDD_WIZ_EDGELESS : IDD_WIZ_ICSCONFLICT;
    }

    SetWindowLongPtr(hwnd, DWLP_MSGRESULT, idPage);
}

void CHomeNetworkWizard::FoundIcsSetText(HWND hwnd)
{
    if (GetICSMachine(_szICSMachineName, ARRAYSIZE(_szICSMachineName)))
    {
        TCHAR szMsg[256];
        if (FormatMessageString(IDS_ICSMSG, szMsg, ARRAYSIZE(szMsg), _szICSMachineName))
        {
            SetWindowText(GetDlgItem(hwnd, IDC_ICSMSG), szMsg);
        }
    }
    else
    {
        // No ICS beacon - ask the user how they connect
        SetWindowLongPtr(hwnd, DWLP_MSGRESULT, (LONG_PTR) _fNoICSQuestion ? IDD_WIZ_WIN9X_CONNECT : IDD_WIZ_CONNECT);
    }
}

INT_PTR CHomeNetworkWizard::FoundIcsPageProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    CHomeNetworkWizard* pthis = GetThis(hwnd, uMsg, wParam, lParam);

    switch (uMsg)
    {
    case WM_INITDIALOG:
        SendMessage(GetDlgItem(hwnd, IDC_SHARECONNECT), BM_SETCHECK, BST_CHECKED, 0);
        return TRUE;
    case WM_NOTIFY:
        {
            LPNMHDR pnmh = (LPNMHDR) lParam;

            switch (pnmh->code)
            {
            case PSN_SETACTIVE:
                PropSheet_SetWizButtons(pnmh->hwndFrom, PSWIZB_BACK | PSWIZB_NEXT);
                pthis->FoundIcsSetText(hwnd);
                return TRUE;
            case PSN_WIZNEXT:
                {
                    UINT idNext;
                    if (BST_CHECKED == SendMessage(GetDlgItem(hwnd, IDC_SHARECONNECT), BM_GETCHECK, 0, 0))
                    {
                        // This machine should be an ICS Client and won't have a public connection
                        pthis->_hnetInfo.dwFlags = HNET_SHAREPRINTERS |
                                                   HNET_SHAREFOLDERS |
                                                   HNET_ICSCLIENT;

                        pthis->_fShowPublicPage = FALSE;
                        pthis->_fShowSharingPage = FALSE;
                        pthis->_fICSClient = TRUE;

                        idNext = g_fRunningOnNT ? IDD_WIZ_ICSCONFLICT : IDD_WIZ_NAME;
                    }
                    else
                    {
                        idNext = pthis->_fNoICSQuestion ? IDD_WIZ_WIN9X_CONNECT : IDD_WIZ_CONNECT;
                    }

                    pthis->PushPage(IDD_WIZ_FOUNDICS);
                    SetWindowLongPtr(hwnd, DWLP_MSGRESULT, idNext);
                }
                return TRUE;
            case PSN_WIZBACK:
                SetWindowLongPtr(hwnd, DWLP_MSGRESULT, pthis->PopPage());
                return TRUE;
            }
        }
        return FALSE;
    }

    return FALSE;
}

void CHomeNetworkWizard::ConnectSetDefault(HWND hwnd)
{
    UINT idSelect = IDC_ICSHOST;

    if ((!g_fRunningOnNT) || (GetConnectionCount(NULL, CONN_INTERNAL | CONN_EXTERNAL) == 1))
    {
        idSelect = IDC_ICSCLIENT;
    }

    SendDlgItemMessage(hwnd, idSelect, BM_SETCHECK, BST_CHECKED, 0);
}

void CHomeNetworkWizard::ConnectNextPage(HWND hwnd)
{
    _fICSClient = FALSE;
    _fNoHomeNetwork = FALSE;

    if (BST_CHECKED == SendMessage(GetDlgItem(hwnd, IDC_ICSHOST), BM_GETCHECK, 0, 0))
    {
        // This machine will need a firewalled, public connection, and should be ICS Host.
        _hnetInfo.dwFlags = HNET_SHARECONNECTION |
                            HNET_FIREWALLCONNECTION |
                            HNET_SHAREPRINTERS |
                            HNET_SHAREFOLDERS;

        _fShowPublicPage = TRUE;
        _fShowSharingPage = FALSE;
    }
    else if (BST_CHECKED == SendMessage(GetDlgItem(hwnd, IDC_ICSCLIENT), BM_GETCHECK, 0, 0))
    {
        // This machine should be an ICS Client and won't have a public connection
        _hnetInfo.dwFlags = HNET_SHAREPRINTERS |
                            HNET_SHAREFOLDERS |
                            HNET_ICSCLIENT;

        _fShowPublicPage = FALSE;
        _fShowSharingPage = FALSE;
        _fICSClient = TRUE;
    }
    else if (BST_CHECKED == SendMessage(GetDlgItem(hwnd, IDC_ALLCOMPUTERSDIRECT), BM_GETCHECK, 0, 0))
    {
        // This machine will need a public connection, and we should ask before sharing files
        _hnetInfo.dwFlags = HNET_FIREWALLCONNECTION |
                            HNET_SHAREPRINTERS |
                            HNET_SHAREFOLDERS;

        _fShowPublicPage = TRUE;
        _fShowSharingPage = TRUE;
    }
    else if (BST_CHECKED == SendMessage(GetDlgItem(hwnd, IDC_NOHOMENETWORK), BM_GETCHECK, 0, 0))
    {
        // This machine needs a firewalled, public connection and not much else
        _hnetInfo.dwFlags = HNET_FIREWALLCONNECTION |
                            HNET_SHAREPRINTERS |
                            HNET_SHAREFOLDERS;

        _fShowPublicPage = TRUE;
        _fShowSharingPage = FALSE;
        _fNoHomeNetwork = TRUE;
    }
    else if (BST_CHECKED == SendMessage(GetDlgItem(hwnd, IDC_NOINTERNET), BM_GETCHECK, 0, 0))
    {
        // No internet box
        _hnetInfo.dwFlags = HNET_SHAREPRINTERS |
                            HNET_SHAREFOLDERS;
                         
        _fShowPublicPage = FALSE;
        _fShowSharingPage = FALSE;
    }

    UINT idNext;
    if (g_fRunningOnNT)
    {
        if (BST_CHECKED == SendMessage(GetDlgItem(hwnd, IDC_OTHER), BM_GETCHECK, 0, 0))
        {
            idNext = IDD_WIZ_CONNECTOTHER;        
        }
        else
        {
            idNext = _fShowPublicPage ? IDD_WIZ_PUBLIC : IDD_WIZ_ICSCONFLICT;
        }
    }
    else
    {
        // For now - TODO: Ed and I need to figure out what we need to do downlevel (9x + 2k)
        idNext = IDD_WIZ_NAME;
    }

    SetWindowLongPtr(hwnd, DWLP_MSGRESULT, idNext);
}

INT_PTR CHomeNetworkWizard::ConnectPageProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    CHomeNetworkWizard* pthis = GetThis(hwnd, uMsg, wParam, lParam);

    switch (uMsg)
    {
    case WM_INITDIALOG:
        pthis->ReplaceStaticWithLink(GetDlgItem(hwnd, IDC_HELPSTATIC), IDC_HELPLINK, IDS_HELP_HNCONFIG);
        pthis->ReplaceStaticWithLink(GetDlgItem(hwnd, IDC_SHOWMESTATIC1), IDC_SHOWMELINK1, IDS_SHOWME);
        pthis->ReplaceStaticWithLink(GetDlgItem(hwnd, IDC_SHOWMESTATIC2), IDC_SHOWMELINK2, IDS_SHOWME);
        pthis->ConnectSetDefault(hwnd);
        return TRUE;
    case WM_NOTIFY:
        {
            LPNMHDR pnmh = (LPNMHDR) lParam;

            switch (pnmh->code)
            {
            case PSN_SETACTIVE:
                PropSheet_SetWizButtons(pnmh->hwndFrom, PSWIZB_BACK | PSWIZB_NEXT);
                return TRUE;
            case PSN_WIZNEXT:
                {
                    pthis->PushPage(pthis->_fNoICSQuestion ? IDD_WIZ_WIN9X_CONNECT : IDD_WIZ_CONNECT);
                    pthis->ConnectNextPage(hwnd);
                }
                return TRUE;
            case PSN_WIZBACK:
                SetWindowLongPtr(hwnd, DWLP_MSGRESULT, pthis->PopPage());
                return TRUE;
            case NM_CLICK:
            case NM_RETURN:
                switch ((int) wParam)
                {
                    case IDC_HELPLINK:
                        {
                            if (IsOS(OS_PERSONAL))
                            {
                                HelpCenter(hwnd, L"network.chm%3A%3A/hnw_howto_connectP.htm");
                            }
                            else
                            {
                                HelpCenter(hwnd, L"network.chm%3A%3A/hnw_howto_connectW.htm");
                            }

                        }
                        return TRUE;
                     case IDC_SHOWMELINK1:
                        {
                            pthis->ShowMeLink(hwnd, L"ntart.chm::/hn_showme1.htm");
                        }
                        return TRUE;
                     case IDC_SHOWMELINK2:
                        {
                            pthis->ShowMeLink(hwnd, L"ntart.chm::/hn_showme2.htm");
                        }
                        return TRUE;
                }
            }
        }
        return FALSE;
    }

    return FALSE;
}

INT_PTR CHomeNetworkWizard::ConnectOtherPageProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    CHomeNetworkWizard* pthis = GetThis(hwnd, uMsg, wParam, lParam);

    switch (uMsg)
    {
    case WM_INITDIALOG:
        if ( pthis->_fExternalOnly )
        {
            TraceMsg(TF_WARNING, "External Adapters Only");
        }

        SendDlgItemMessage(hwnd, IDC_ALLCOMPUTERSDIRECT, BM_SETCHECK, (WPARAM) BST_CHECKED, 0);
        pthis->ReplaceStaticWithLink(GetDlgItem(hwnd, IDC_HELPSTATIC), IDC_HELPLINK, IDS_HELP_HNCONFIG);
        pthis->ReplaceStaticWithLink(GetDlgItem(hwnd, IDC_SHOWMESTATIC3), IDC_SHOWMELINK3, IDS_SHOWME);
        pthis->ReplaceStaticWithLink(GetDlgItem(hwnd, IDC_SHOWMESTATIC4), IDC_SHOWMELINK4, IDS_SHOWME);
        pthis->ReplaceStaticWithLink(GetDlgItem(hwnd, IDC_SHOWMESTATIC5), IDC_SHOWMELINK5, IDS_SHOWME);
        return TRUE;
    case WM_NOTIFY:
        {
            LPNMHDR pnmh = (LPNMHDR) lParam;

            switch (pnmh->code)
            {
            case PSN_SETACTIVE:
                PropSheet_SetWizButtons(pnmh->hwndFrom, PSWIZB_BACK | PSWIZB_NEXT);
                return TRUE;
            case PSN_WIZNEXT:
                {
                    pthis->PushPage(IDD_WIZ_CONNECTOTHER);
                    pthis->ConnectNextPage(hwnd);
                }
                return TRUE;
            case PSN_WIZBACK:
                SetWindowLongPtr(hwnd, DWLP_MSGRESULT, pthis->PopPage());
                return TRUE;
            case NM_CLICK:
            case NM_RETURN:
                switch ((int) wParam)
                {
                    case IDC_HELPLINK:
                        {
                            HelpCenter(hwnd, L"netcfg.chm%3A%3A/share_conn_overvw.htm");
                        }
                        return TRUE;
                    case IDC_SHOWMELINK3:
                        {
 
                            pthis->ShowMeLink(hwnd, L"ntart.chm::/hn_showme3.htm");
                        }
                        return TRUE;
                    case IDC_SHOWMELINK4:
                        {
 
                            pthis->ShowMeLink(hwnd, L"ntart.chm::/hn_showme4.htm");
                        }
                        return TRUE;
                    case IDC_SHOWMELINK5:
                        {
 
                            pthis->ShowMeLink(hwnd, L"ntart.chm::/hn_showme5.htm");
                        }
                        return TRUE;
                }
            }
        }
        return FALSE;
    }

    return FALSE;
}


void CHomeNetworkWizard::DestroyConnectionList(HWND hwndList)
{
    if (g_fRunningOnNT)
    {
        int nItems = ListView_GetItemCount(hwndList);

        for (int iItem = 0; iItem < nItems; iItem ++)
        {
            // Get our stashed INetConnection for each item in the list and free it
            LVITEM lvi = {0};
            lvi.mask = LVIF_PARAM;
            lvi.iItem = iItem;

            if (ListView_GetItem(hwndList, &lvi))
            {
                ((INetConnection*) lvi.lParam)->Release();
            }
        }
    }

    ListView_DeleteAllItems(hwndList);
}

inline void _SetDlgItemRect(HWND hwnd, UINT id, RECT* pRect)
{
    SetWindowPos(GetDlgItem(hwnd, id), NULL, pRect->left, pRect->top, pRect->right - pRect->left, pRect->bottom - pRect->top, SWP_NOZORDER | SWP_SHOWWINDOW);
}

void _OffsetDlgItem(HWND hwnd, UINT id, int xOffset, int yOffset, BOOL fAdjustWidth, BOOL fAdjustHeight)
{
    RECT rc;
    HWND hwndControl = GetDlgItem(hwnd, id);
    GetWindowRect(hwndControl, &rc);
    MapWindowPoints(NULL, hwnd, (LPPOINT) &rc, 2);
    OffsetRect(&rc, xOffset, yOffset);

    if (fAdjustWidth)
    {
        rc.right -= xOffset;
    }

    if (fAdjustHeight)
    {
        rc.bottom -= yOffset;
    }

    _SetDlgItemRect(hwnd, id, &rc);
}

void CHomeNetworkWizard::PublicMoveControls(HWND hwnd, BOOL fItemPreselected)
{
    // We need to move controls around on this page depending on whether or not an item is preselected or not
    // Reset the dialog so that all controls are in their default positions
    PublicResetControlPositions(hwnd);

    if (fItemPreselected)
    {
        // We are transitioning from the "default" position to one where an item is preselected.
        // The only work we do here is to hide the help icon and move over the help text a bit to the left

        int xOffset = (PublicControlPositions._rcHelpIcon.left) - (PublicControlPositions._rcHelpText.left);
        UINT idHelp = IsWindowVisible(GetDlgItem(hwnd, IDC_HELPSTATIC)) ? IDC_HELPSTATIC : IDC_HELPLINK;
        _OffsetDlgItem(hwnd, idHelp, xOffset, 0, TRUE, FALSE);
        ShowWindow(GetDlgItem(hwnd, IDC_HELPICON), SW_HIDE);
    }
    else
    {
        // We are transitioning from the "default" position to the one where we don't have a preselection
        // We need to hide the "we've automatically selected..." message and move up the list label,
        // and expand the connection list.

        int yOffset = (PublicControlPositions._rcSelectMessage.top) - (PublicControlPositions._rcListLabel.top);
        _OffsetDlgItem(hwnd, IDC_LISTLABEL, 0, yOffset, FALSE, FALSE);
        _OffsetDlgItem(hwnd, IDC_CONNLIST, 0, yOffset, FALSE, TRUE);
        ShowWindow(GetDlgItem(hwnd, IDC_SELECTMSG), SW_HIDE);
    }
}

void CHomeNetworkWizard::PublicSetActive(HWND hwnd)
{
    
    HCURSOR hOldCursor = SetCursor(LoadCursor(NULL, IDC_WAIT));
    
    FreeExternalConnection(&_hnetInfo);

    HWND hwndList = GetDlgItem(hwnd, IDC_CONNLIST);
    FillConnectionList(hwndList, NULL, CONN_EXTERNAL);

    // Auto-select if there is only one connection listed
    if (ListView_GetItemCount(hwndList) == 1
    #ifdef DEBUG
        && !(GetKeyState(VK_CONTROL) < 0) // don't do this if CTRL is down for debugging
    #endif
       )
    {
        ListView_SetItemState(hwndList, 0, LVIS_SELECTED, LVIS_SELECTED);

        // PublicNextPage will set DWLP_MSGRESULT and tell the wizard to skip this page
        // and go on to the next.
        PublicNextPage(hwnd);
    }
    else
    {
        // If there is a selected item
        int iSelectedItem = ListView_GetNextItem(hwndList, -1, LVNI_SELECTED);
        if (-1 != iSelectedItem)
        {
            // Read the item name and set the alternate "Windows recommends this connection." text
            WCHAR szItem[256], szMsg[256];
            ListView_GetItemText(hwndList, iSelectedItem, 0, szItem, ARRAYSIZE(szItem));
            FormatMessageString(IDS_RECOMMENDEDCONN, szMsg, ARRAYSIZE(szMsg), szItem);
            SetDlgItemText(hwnd, IDC_SELECTMSG, szMsg);

            BoldControl(hwnd, IDC_SELECTMSG);
        }

        PublicMoveControls(hwnd, (-1 != iSelectedItem));
        PublicSetControlState(hwnd);
    }

    if(NULL != hOldCursor)
    {
        SetCursor(hOldCursor);
    }
}

void CHomeNetworkWizard::PublicGetControlPositions(HWND hwnd)
{
    // Remember the default positions of the controls that will move as we reorganize this dialog
    GetWindowRect(GetDlgItem(hwnd, IDC_SELECTMSG), &PublicControlPositions._rcSelectMessage);
    GetWindowRect(GetDlgItem(hwnd, IDC_LISTLABEL), &PublicControlPositions._rcListLabel);
    GetWindowRect(GetDlgItem(hwnd, IDC_CONNLIST), &PublicControlPositions._rcList);
    GetWindowRect(GetDlgItem(hwnd, IDC_HELPICON), &PublicControlPositions._rcHelpIcon);
    GetWindowRect(GetDlgItem(hwnd, IDC_HELPSTATIC), &PublicControlPositions._rcHelpText);

    // We actually need them in client coords
    // Map 2 points (1 rect) at a time since Mirrored points get screwed up with more
    MapWindowPoints(NULL, hwnd, (LPPOINT) &PublicControlPositions._rcSelectMessage, 2);
    MapWindowPoints(NULL, hwnd, (LPPOINT) &PublicControlPositions._rcListLabel, 2);
    MapWindowPoints(NULL, hwnd, (LPPOINT) &PublicControlPositions._rcList, 2);
    MapWindowPoints(NULL, hwnd, (LPPOINT) &PublicControlPositions._rcHelpIcon, 2);
    MapWindowPoints(NULL, hwnd, (LPPOINT) &PublicControlPositions._rcHelpText, 2);
}

void CHomeNetworkWizard::PublicResetControlPositions(HWND hwnd)
{
    // Set the controls back to their default positions
    _SetDlgItemRect(hwnd, IDC_SELECTMSG, &PublicControlPositions._rcSelectMessage);
    _SetDlgItemRect(hwnd, IDC_LISTLABEL, &PublicControlPositions._rcListLabel);
    _SetDlgItemRect(hwnd, IDC_CONNLIST, &PublicControlPositions._rcList);
    _SetDlgItemRect(hwnd, IDC_HELPICON, &PublicControlPositions._rcHelpIcon);

    UINT idHelp = IsWindowVisible(GetDlgItem(hwnd, IDC_HELPSTATIC)) ? IDC_HELPSTATIC : IDC_HELPLINK;
    _SetDlgItemRect(hwnd, idHelp, &PublicControlPositions._rcHelpText);
}


INT_PTR CHomeNetworkWizard::PublicPageProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    CHomeNetworkWizard* pthis = GetThis(hwnd, uMsg, wParam, lParam);

    switch (uMsg)
    {
    case WM_INITDIALOG:
        pthis->InitializeConnectionList(GetDlgItem(hwnd, IDC_CONNLIST), CONN_EXTERNAL);
        pthis->ReplaceStaticWithLink(GetDlgItem(hwnd, IDC_HELPSTATIC), IDC_HELPLINK, IDS_HELP_SELECTPUBLIC);
        pthis->PublicGetControlPositions(hwnd);
        return TRUE;
    case WM_NOTIFY:
        {
            LPNMHDR pnmh = (LPNMHDR) lParam;

            switch (pnmh->code)
            {
            case PSN_SETACTIVE:
                {
                    pthis->PublicSetActive(hwnd);
                    return TRUE;
                }
            case PSN_WIZNEXT:
                pthis->PushPage(IDD_WIZ_PUBLIC);
                pthis->PublicNextPage(hwnd);
                return TRUE;
            case PSN_WIZBACK:
                SetWindowLongPtr(hwnd, DWLP_MSGRESULT, pthis->PopPage());
                return TRUE;
            case LVN_ITEMCHANGED:
                pthis->PublicSetControlState(hwnd);
                return TRUE;
            case NM_CLICK:
            case NM_RETURN:
                switch ((int) wParam)
                {
                    case IDC_HELPLINK:
                        {
                            HelpCenter(hwnd, L"network.chm%3A%3A/hnw_determine_internet_connection.htm");
                        }
                        return TRUE;
                }
            }
        }
        return FALSE;
    case WM_DESTROY:
        pthis->DestroyConnectionList(GetDlgItem(hwnd, IDC_CONNLIST));
        return TRUE;
    }

    return FALSE;
}

void CHomeNetworkWizard::EdgelessSetActive(HWND hwnd)
{
    PropSheet_SetWizButtons(GetParent(hwnd), PSWIZB_BACK | PSWIZB_NEXT);
//    _hnetInfo.dwFlags &= (~(HNET_SHAREFOLDERS | HNET_SHAREPRINTERS));

    if (!ShouldShowConnection(_hnetInfo.pncExternal, NULL, CONN_INTERNAL))
    {
        // External connection is a modem or such - no file sharing necessary (user already said they didn't have a home network)
        SetWindowLongPtr(hwnd, DWLP_MSGRESULT, IDD_WIZ_ICSCONFLICT);
    }
}

INT_PTR CHomeNetworkWizard::EdgelessPageProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    CHomeNetworkWizard* pthis = GetThis(hwnd, uMsg, wParam, lParam);

    switch (uMsg)
    {
    case WM_INITDIALOG:
        pthis->ReplaceStaticWithLink(GetDlgItem(hwnd, IDC_HELPSTATIC), IDC_HELPLINK, IDS_HELP_RECOMMENDED);
        return TRUE;
    case WM_NOTIFY:
        {
            LPNMHDR pnmh = (LPNMHDR) lParam;

            switch (pnmh->code)
            {
            case PSN_SETACTIVE:
                pthis->EdgelessSetActive(hwnd);
                return TRUE;
            case PSN_WIZNEXT:
                pthis->_hnetInfo.dwFlags |= (HNET_SHAREFOLDERS | HNET_SHAREPRINTERS);
                pthis->PushPage(IDD_WIZ_EDGELESS);
                SetWindowLongPtr(hwnd, DWLP_MSGRESULT, (LONG_PTR) IDD_WIZ_BRIDGEWARNING);
                return TRUE;
            case PSN_WIZBACK:
                SetWindowLongPtr(hwnd, DWLP_MSGRESULT, pthis->PopPage());
                return TRUE;
            case NM_CLICK:
            case NM_RETURN:
                switch ((int) wParam)
                {
                    case IDC_HELPLINK:
                        {
                            if (IsOS(OS_PERSONAL))
                            {
                                HelpCenter(hwnd, L"network.chm%3A%3A/hnw_nohost_computerP.htm");
                            }
                            else
                            {
                                HelpCenter(hwnd, L"network.chm%3A%3A/hnw_nohost_computerW.htm");
                            }
                        }
                        return TRUE;
                }
            }
        }
        return FALSE;
    }
    return FALSE;
}

BOOL CHomeNetworkWizard::IsICSIPInUse( WCHAR** ppszHost, PDWORD pdwSize )
{
    HRESULT          hr;
    INetConnection** ppArray = NULL;
    DWORD            dwItems = 0;
    BOOL             bExists = FALSE;

    if ( ppszHost )
        *ppszHost = NULL;

    if ( pdwSize )
        *pdwSize = 0;

    hr = GetInternalConnectionArray( _hnetInfo.pncExternal, &ppArray, &dwItems );
    
    if ( SUCCEEDED(hr) )
    {
        hr = E_FAIL;
    
        for( DWORD i=0; i<dwItems; i++ )
        {
            if ( S_OK != hr )
            {
                hr = HrLookupForIpAddress( ppArray[i], 
                                           DEFAULT_SCOPE_ADDRESS, 
                                           &bExists, 
                                           ppszHost, 
                                           pdwSize );
            }
                                       
            ppArray[i]->Release();
            
        }   //  for( DWORD i=0; i<dwItems; i++ )
        
        LocalFree( ppArray );

    }   //  if ( SUCCEEDED(hr) )
        
    return bExists;
}

void CHomeNetworkWizard::ICSConflictSetActive(HWND hwnd)
{
    WCHAR* pszConflictingHost = NULL;
    DWORD  dwSize = 0;

    PropSheet_SetWizButtons(GetParent(hwnd), PSWIZB_BACK | PSWIZB_NEXT);

    static const int _KnownControls[] = 
    {
        IDC_KNOWNCONFLICT1,
        IDC_KNOWNCONFLICT2,
        IDC_KNOWNCONFLICT3,
        IDC_KNOWNCONFLICT4,
        IDC_KNOWNCONFLICT5,
        IDC_KNOWNCONFLICT6,
        IDC_KNOWNCONFLICT7,
        IDC_KNOWNCONFLICT8,
        IDC_COMPUTERNAME
    };

    static const int _UnknownControls[] = 
    {
        IDC_UNKNOWNCONFLICT1,
        IDC_UNKNOWNCONFLICT2
    };
    
    if ((_hnetInfo.dwFlags & HNET_SHARECONNECTION) && IsICSIPInUse(&pszConflictingHost, &dwSize))
    {
        // We show and hide controls depending on if we already know about an ICS machine name
        WCHAR szICSHost[MAX_PATH];
        if (GetICSMachine(szICSHost, ARRAYSIZE(szICSHost)))
        {
            // We know this is a UPnP ICS host - show the "known conflict" set of controls
            ShowControls(hwnd, _KnownControls, ARRAYSIZE(_KnownControls), SW_SHOWNORMAL);
            ShowControls(hwnd, _UnknownControls, ARRAYSIZE(_UnknownControls), SW_HIDE);
            SetDlgItemText(hwnd, IDC_COMPUTERNAME, szICSHost);
        }
        else
        {
            // We have no idea what's hogging our IP - show a very generic set of controls
            ShowControls(hwnd, _UnknownControls, ARRAYSIZE(_UnknownControls), SW_SHOWNORMAL);
            ShowControls(hwnd, _KnownControls, ARRAYSIZE(_KnownControls), SW_HIDE);
        }
    }
    else
    {
        // Go on to the next screen
        SetWindowLongPtr(hwnd, DWLP_MSGRESULT, IDD_WIZ_BRIDGEWARNING);
    }

        
    if ( pszConflictingHost )
        delete [] pszConflictingHost;
}

INT_PTR CHomeNetworkWizard::ICSConflictPageProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    CHomeNetworkWizard* pthis = GetThis(hwnd, uMsg, wParam, lParam);

    switch (uMsg)
    {
    case WM_INITDIALOG:
        pthis->ReplaceStaticWithLink(GetDlgItem(hwnd, IDC_HELPSTATIC), IDC_HELPLINK, IDS_HELP_ICSCONFLICT);
        return TRUE;
    case WM_NOTIFY:
        {
            LPNMHDR pnmh = (LPNMHDR) lParam;
            WCHAR*  pszConflictingHost = NULL;
            DWORD   dwSize = 0;

            switch (pnmh->code)
            {
            case PSN_SETACTIVE:
                pthis->ICSConflictSetActive(hwnd);
                return TRUE;
            case PSN_WIZNEXT:
                if (pthis->IsICSIPInUse(&pszConflictingHost, &dwSize))
                {
                    DisplayFormatMessage(hwnd, IDS_WIZ_CAPTION, IDS_STILLICSCONFLICT, MB_ICONERROR | MB_OK);
                    SetWindowLongPtr(hwnd, DWLP_MSGRESULT, -1);
                }
                else
                {
                    SetWindowLongPtr(hwnd, DWLP_MSGRESULT, (LONG_PTR) IDD_WIZ_BRIDGEWARNING);
                }
                if ( pszConflictingHost )
                    delete [] pszConflictingHost;
                return TRUE;
            case PSN_WIZBACK:
                SetWindowLongPtr(hwnd, DWLP_MSGRESULT, pthis->PopPage());
                return TRUE;
            case NM_CLICK:
            case NM_RETURN:
                switch ((int) wParam)
                {
                    case IDC_HELPLINK:
                        {
                            HelpCenter(hwnd, L"network.chm%3A%3A/hnw_change_ics_host.htm");
                        }
                        return TRUE;
                }
            }
        }
        return FALSE;
    }
    return FALSE;
}

DWORD CHomeNetworkWizard::GetConnectionCount(INetConnection* pncExclude, DWORD dwFlags)
{
    DWORD dwCount = 0;

    if (g_fRunningOnNT)
    {
        DWORD cItems = DPA_GetPtrCount(_hdpaConnections);
        for (DWORD iItem = 0; iItem < cItems; iItem ++)
        {
            INetConnection* pnc = (INetConnection*) DPA_GetPtr(_hdpaConnections, iItem);
            if (ShouldShowConnection(pnc, pncExclude, dwFlags))
            {
                dwCount++;
            }
        }
    }
    else
    {
        const NETADAPTER* pNA = _hnetInfo.pNA;

        for (UINT i = 0; i < _hnetInfo.cNA; i++, pNA++)
        {
            // Check if the NIC is working.

            if (W9xIsValidAdapter(pNA, dwFlags))
            {
                dwCount++;
            }
        }
    }

    return dwCount;
}

INT_PTR CHomeNetworkWizard::BridgeWarningPageProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    CHomeNetworkWizard* pthis = GetThis(hwnd, uMsg, wParam, lParam);

    switch (uMsg)
    {
    case WM_INITDIALOG:
        SendDlgItemMessage(hwnd, IDC_AUTOBRIDGE, BM_SETCHECK, (WPARAM) BST_CHECKED, 0);
        pthis->ReplaceStaticWithLink(GetDlgItem(hwnd, IDC_HELPSTATIC), IDC_HELPLINK, IDS_HELP_BRIDGE);
        return TRUE;
    case WM_NOTIFY:
        {
            LPNMHDR pnmh = (LPNMHDR) lParam;

            switch (pnmh->code)
            {
            case PSN_SETACTIVE:
                {
                    if (pthis->_fNoHomeNetwork)
                    {
                        FreeInternalConnections(&pthis->_hnetInfo);
                        SetWindowLongPtr(hwnd, DWLP_MSGRESULT, IDD_WIZ_NAME);
                    }
                    else
                    {
                        DWORD nInternal = pthis->GetConnectionCount(pthis->_hnetInfo.pncExternal, CONN_INTERNAL);
                        if (1 < nInternal)
                        {
                            // We show this page if there are two or more internal connections (which is this case)
                            PropSheet_SetWizButtons(pnmh->hwndFrom, PSWIZB_BACK | PSWIZB_NEXT);
                        }
                        else if ((pthis->_hnetInfo.dwFlags & HNET_SHARECONNECTION) && (0 == nInternal))
                        {
                            // We are sharing the public connection, and there are no other connections left
                            // over for home networking. Show error page
                            pthis->_fManualBridgeConfig = FALSE;
                            SetWindowLongPtr(hwnd, DWLP_MSGRESULT, IDD_WIZ_NOHARDWAREFINISH);
                        }
                        else
                        {
                            // There are either zero or one internal connections. If zero, then we aren't sharing the connection
                            // Skip the bridge warning page and go to the private page
                            pthis->_fManualBridgeConfig = FALSE;
                            SetWindowLongPtr(hwnd, DWLP_MSGRESULT, IDD_WIZ_PRIVATE);
                        }
                    }

                    return TRUE;
                }
            case PSN_WIZNEXT:
                {
                    pthis->_fManualBridgeConfig = (BST_CHECKED == SendDlgItemMessage(hwnd, IDC_MANUALBRIDGE, BM_GETCHECK, 0, 0));
                    pthis->PushPage(IDD_WIZ_BRIDGEWARNING);
                    SetWindowLongPtr(hwnd, DWLP_MSGRESULT, IDD_WIZ_PRIVATE);
                }
                return TRUE;
            case PSN_WIZBACK:
                SetWindowLongPtr(hwnd, DWLP_MSGRESULT, pthis->PopPage());
                return TRUE;
            case NM_CLICK:
            case NM_RETURN:
                switch ((int) wParam)
                {
                    case IDC_HELPLINK:
                        {
                            HelpCenter(hwnd, L"netcfg.chm%3A%3A/hnw_understanding_bridge.htm");
                        }
                        return TRUE;
                }
            }
        }
        return FALSE;
    }

    return FALSE;
}

void FreeInternalConnections(PHOMENETSETUPINFO pInfo)
{
    // Delete any existing private connection information

    if (pInfo->prgncInternal)
    {
        for (DWORD i = 0; i < pInfo->cncInternal; i++)
        {
            INetConnection* pnc = pInfo->prgncInternal[i];
            pnc->Release();
        }

        LocalFree(pInfo->prgncInternal);
        pInfo->prgncInternal = NULL;
    }

    pInfo->cncInternal = 0;
}

void FreeInternalGUIDs(PHOMENETSETUPINFO pInfo)
{
    if (pInfo->prgguidInternal)
    {
        LocalFree(pInfo->prgguidInternal);
        pInfo->prgguidInternal = NULL;
    }

    pInfo->cguidInternal = 0;
}

DWORD _ListView_GetCheckedCount(HWND hwndList)
{
    int nItems = ListView_GetItemCount(hwndList);
    DWORD nCheckedItems = 0;
    if (-1 != nItems)
    {
        for(int iItem = 0; iItem < nItems; iItem ++)
        {
            if (ListView_GetCheckState(hwndList, iItem))
            {
                nCheckedItems ++;
            }
        }
    }

    return nCheckedItems;
}

void CHomeNetworkWizard::PrivateSetControlState(HWND hwnd)
{
    BOOL fEnableNext = TRUE;

    // If the user is sharing a connection, they must specify at least one private connection
    if (_hnetInfo.dwFlags & HNET_SHARECONNECTION)
    {
        fEnableNext = (0 != _ListView_GetCheckedCount(GetDlgItem(hwnd, IDC_CONNLIST)));
    }

    PropSheet_SetWizButtons(GetParent(hwnd), fEnableNext ? PSWIZB_BACK | PSWIZB_NEXT : PSWIZB_BACK);
}


void CHomeNetworkWizard::PrivateNextPage(HWND hwnd)
{
    FreeInternalConnections(&_hnetInfo);

    // Figure out the number of connections we'll need
    HWND hwndList = GetDlgItem(hwnd, IDC_CONNLIST);
    int nItems = ListView_GetItemCount(hwndList);
    DWORD nCheckedItems = _ListView_GetCheckedCount(hwndList);

    if (nCheckedItems)
    {
        _hnetInfo.prgncInternal = (INetConnection**) LocalAlloc(LPTR, (nCheckedItems + 1) * sizeof (INetConnection*));
        // Alloc one extra INetConnection* and Null-terminate this array so we can pass it to HNet config api

        if (_hnetInfo.prgncInternal)
        {
            _hnetInfo.cncInternal = 0;
            // Get the INetConnection for each checked item
            for (int iItem = 0; iItem < nItems; iItem ++)
            {
                if (ListView_GetCheckState(hwndList, iItem))
                {
                    LVITEM lvi = {0};
                    lvi.iItem = iItem;
                    lvi.mask = LVIF_PARAM;
                    ListView_GetItem(hwndList, &lvi);

                    if (g_fRunningOnNT)
                    {
                        _hnetInfo.prgncInternal[_hnetInfo.cncInternal] = (INetConnection*) lvi.lParam;
                        _hnetInfo.prgncInternal[_hnetInfo.cncInternal]->AddRef();
                    }
                    else
                    {
                        // TODO W9x
                    }
                    _hnetInfo.cncInternal ++;
                }
            }

            // Assert since if we messed something up there might not be enough space allocated in the buffer!
            ASSERT(nCheckedItems == _hnetInfo.cncInternal);
        }
    }

    SetWindowLongPtr(hwnd, DWLP_MSGRESULT, IDD_WIZ_NAME);
}

INT_PTR CHomeNetworkWizard::PrivatePageProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    CHomeNetworkWizard* pthis = GetThis(hwnd, uMsg, wParam, lParam);

    switch (uMsg)
    {
    case WM_INITDIALOG:
        pthis->InitializeConnectionList(GetDlgItem(hwnd, IDC_CONNLIST), CONN_INTERNAL);
        pthis->ReplaceStaticWithLink(GetDlgItem(hwnd, IDC_HELPSTATIC), IDC_HELPLINK, IDS_HELP_BRIDGE);
        return TRUE;
    case WM_NOTIFY:
        {
            LPNMHDR pnmh = (LPNMHDR) lParam;

            switch (pnmh->code)
            {
            case PSN_SETACTIVE:
                {
                    FreeInternalConnections(&(pthis->_hnetInfo));

                    HWND hwndList = GetDlgItem(hwnd, IDC_CONNLIST);
                    pthis->FillConnectionList(hwndList, pthis->_hnetInfo.pncExternal, CONN_INTERNAL);

                    // If the user hasn't select manual bridge and/or there is less than 2 items,
                    // then _fManualBridgeConfig will be FALSE and we'll autobridge
                    if (!pthis->_fManualBridgeConfig)
                    {
                        // PrivateNextPage will set DWLP_MSGRESULT and tell the wizard to skip this page
                        // and go on to the next.
                        pthis->PrivateNextPage(hwnd);
                    }

                    pthis->PrivateSetControlState(hwnd);
                    return TRUE;
                }
            case PSN_WIZNEXT:
                pthis->PrivateNextPage(hwnd);
                pthis->PushPage(IDD_WIZ_PRIVATE);
                return TRUE;
            case PSN_WIZBACK:
                SetWindowLongPtr(hwnd, DWLP_MSGRESULT, pthis->PopPage());
                return TRUE;
            case NM_CLICK:
            case NM_RETURN:
                switch ((int) wParam)
                {
                    case IDC_HELPLINK:
                        {
                            HelpCenter(hwnd, L"netcfg.chm%3A%3A/hnw_understanding_bridge.htm");
                        }
                        return TRUE;
                }
            case LVN_ITEMCHANGED:
                pthis->PrivateSetControlState(hwnd);
                return TRUE;
            }
        }
        return FALSE;
    case WM_DESTROY:
        pthis->DestroyConnectionList(GetDlgItem(hwnd, IDC_CONNLIST));
        return FALSE;
    }

    return FALSE;
}

void CHomeNetworkWizard::NameSetControlState(HWND hwnd)
{
    BOOL fEnableNext = (0 != GetWindowTextLength(GetDlgItem(hwnd, IDC_COMPUTERNAME)));
    PropSheet_SetWizButtons(GetParent(hwnd), fEnableNext ? PSWIZB_BACK | PSWIZB_NEXT : PSWIZB_BACK);
}

HRESULT CHomeNetworkWizard::NameNextPage(HWND hwnd)
{
    HRESULT hr = E_FAIL;
    GetDlgItemText(hwnd, IDC_COMPUTERDESC, _hnetInfo.szComputerDescription, ARRAYSIZE(_hnetInfo.szComputerDescription));
    GetDlgItemText(hwnd, IDC_COMPUTERNAME, _hnetInfo.szComputer, ARRAYSIZE(_hnetInfo.szComputer));
    
    // There are two errors that we show for computer name: INVALID and DUPLICATE
    // TODO: We only detect duplicate for NT so far!!!
    UINT idError = IDS_COMPNAME_INVALID;

    // Test to see if the name is more than 15 OEM bytes
    int iBytes = WideCharToMultiByte(CP_OEMCP, 0, _hnetInfo.szComputer, -1, NULL, 0, NULL, NULL) - 1;
        
    if (iBytes <= LM20_DNLEN)
    {
        if (IsValidNameSyntax(_hnetInfo.szComputer, NetSetupMachine))
        {
            if (g_fRunningOnNT)
            {
                SetCursor(LoadCursor(NULL, IDC_WAIT));
                NET_API_STATUS nas = NetValidateName(NULL, _hnetInfo.szComputer, NULL, NULL, NetSetupMachine);
                if (ERROR_DUP_NAME == nas)
                {
                    ASSERT(E_FAIL == hr);
                    idError = IDS_COMPNAME_DUPLICATE;
                }
                else if (NERR_InvalidComputer == nas)
                {
                    ASSERT(E_FAIL == hr);
                    idError = IDS_COMPNAME_INVALID;
                }
                else
                {
                    // if there is any other failure we just go ahead.  If the Client For MS Networks is not installed we 
                    // can't validate the name, but it should be fine to use what we have
                
                    hr = S_OK;
                    _hnetInfo.dwFlags |= HNET_SETCOMPUTERNAME;
                }
            }
            else
            {
                // TODO: Win9x!!!
                hr = S_OK;
                _hnetInfo.dwFlags |= HNET_SETCOMPUTERNAME;
            }
        }
    }
    else
    {
        ASSERT(E_FAIL == hr);
        idError = IDS_COMPNAME_TOOMANYBYTES;
    }

    // If the computer name didn't validate, don't change pages and show an error.
    if(FAILED(hr))
    {
        SetFocus(GetDlgItem(hwnd, IDC_COMPUTERNAME));
        PropSheet_SetWizButtons(GetParent(hwnd), PSWIZB_BACK);
        DisplayFormatMessage(hwnd, IDS_WIZ_CAPTION, idError, MB_ICONERROR | MB_OK, _hnetInfo.szComputer);
    }

    return hr;
}

void CHomeNetworkWizard::NameInitDialog(HWND hwnd)
{
    // Limit the edit fields
    SendDlgItemMessage(hwnd, IDC_COMPUTERDESC, EM_SETLIMITTEXT, ARRAYSIZE(_hnetInfo.szComputerDescription) - 1, NULL);
    SendDlgItemMessage(hwnd, IDC_COMPUTERNAME, EM_SETLIMITTEXT, ARRAYSIZE(_hnetInfo.szComputer) - 1, NULL);

    // Set the current name as the default

    WCHAR szComputerName[ARRAYSIZE(_hnetInfo.szComputer)];
    *szComputerName = 0;

    WCHAR szDescription[ARRAYSIZE(_hnetInfo.szComputerDescription)];
    *szDescription = 0;

    if (g_fRunningOnNT)
    {
        SERVER_INFO_101_NT* psv101 = NULL;
        if (NERR_Success == NetServerGetInfo_NT(NULL, 101, (LPBYTE*) &psv101))
        {
            if (psv101->sv101_comment && psv101->sv101_comment[0])
            {
                StrCpyN(szDescription, psv101->sv101_comment, ARRAYSIZE(szDescription));
            }

            ASSERT(psv101->sv101_name);
            StrCpyN(szComputerName, psv101->sv101_name, ARRAYSIZE(szComputerName));
            NetApiBufferFree(psv101);
        }
    }
    else
    {
        AllPlatformGetComputerName(szComputerName, ARRAYSIZE(szComputerName));

        CRegistry reg;
        if (reg.OpenKey(HKEY_LOCAL_MACHINE, L"System\\CurrentControlSet\\Services\\VxD\\VNETSUP", KEY_READ))
        {
            reg.QueryStringValue(L"Comment", szDescription, ARRAYSIZE(szDescription));
        }
    }

    SetDlgItemText(hwnd, IDC_COMPUTERNAME, szComputerName);
    SetDlgItemText(hwnd, IDC_COMPUTERDESC, szDescription);

    WCHAR szNameMessage[256];
    if (FormatMessageString(IDS_CURRENTNAME, szNameMessage, ARRAYSIZE(szNameMessage), szComputerName))
    {
        SetDlgItemText(hwnd, IDC_CURRENTNAME, szNameMessage);
    }
}

INT_PTR CHomeNetworkWizard::NamePageProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    CHomeNetworkWizard* pthis = GetThis(hwnd, uMsg, wParam, lParam);

    switch (uMsg)
    {
    case WM_INITDIALOG:
        pthis->NameInitDialog(hwnd);
        pthis->ReplaceStaticWithLink(GetDlgItem(hwnd, IDC_HELPSTATIC), IDC_HELPLINK, IDS_HELP_COMPNAME);
        return TRUE;
    case WM_NOTIFY:
        {
            LPNMHDR pnmh = (LPNMHDR) lParam;

            switch (pnmh->code)
            {
            case PSN_SETACTIVE:
                {
                    // Show the ISP Warning if this computer connects directly to the Internet
                    int nShowISPWarning = (NULL != pthis->_hnetInfo.pncExternal) ? SW_SHOW : SW_HIDE;
                    ShowWindow(GetDlgItem(hwnd, IDC_ISPWARN1), nShowISPWarning);
                    ShowWindow(GetDlgItem(hwnd, IDC_ISPWARN2), nShowISPWarning);

                    pthis->NameSetControlState(hwnd);
                }
                return TRUE;
            case PSN_WIZNEXT:
                if (SUCCEEDED(pthis->NameNextPage(hwnd)))
                {
                    SetWindowLongPtr(hwnd, DWLP_MSGRESULT, (LONG_PTR) IDD_WIZ_WORKGROUP);
                    pthis->PushPage(IDD_WIZ_NAME);
                }
                else
                {
                    // else not changing pages; don't push
                    SetWindowLongPtr(hwnd, DWLP_MSGRESULT, (LONG_PTR) -1);
                }
                return TRUE;
            case PSN_WIZBACK:
                SetWindowLongPtr(hwnd, DWLP_MSGRESULT, pthis->PopPage());
                return TRUE;
            case NM_CLICK:
            case NM_RETURN:
                switch ((int) wParam)
                {
                    case IDC_HELPLINK:
                        {
                            HelpCenter(hwnd, L"network.chm%3A%3A/hnw_comp_name_description.htm");
                        }
                        return TRUE;
                }
            }
        }
        return FALSE;
    case WM_COMMAND:
        {
            switch (HIWORD(wParam))
            {
            case EN_CHANGE:
                if (LOWORD(wParam) == IDC_COMPUTERNAME)
                {
                    pthis->NameSetControlState(hwnd);
                }
                return FALSE;
            }
        }
        return FALSE;
    }

    return FALSE;
}

void CHomeNetworkWizard::WorkgroupSetControlState(HWND hwnd)
{
    BOOL fNext = (0 != SendDlgItemMessage(hwnd, IDC_WORKGROUP, WM_GETTEXTLENGTH, 0, 0));
    PropSheet_SetWizButtons(GetParent(hwnd), PSWIZB_BACK | (fNext ? PSWIZB_NEXT : 0));
}

HRESULT CHomeNetworkWizard::WorkgroupNextPage(HWND hwnd)
{
    HRESULT hr = E_FAIL;

    UINT idError = IDS_WORKGROUP_INVALID;
    
    if (GetDlgItemText(hwnd, IDC_WORKGROUP, _hnetInfo.szWorkgroup, ARRAYSIZE(_hnetInfo.szWorkgroup)))
    {
        // Test to see if the name is more than 15 OEM bytes
        int iBytes = WideCharToMultiByte(CP_OEMCP, 0, _hnetInfo.szWorkgroup, -1, NULL, 0, NULL, NULL) - 1;
        
        if (iBytes <= LM20_DNLEN)
        {
            // Remove any preceding blanks
            size_t szLen  = wcslen( _hnetInfo.szWorkgroup ) + 1;
            LPWSTR szTemp = new WCHAR[ szLen ];
            
            if ( szTemp )
            {
                WCHAR* pch;
                
                for ( pch = _hnetInfo.szWorkgroup; *pch && (L' ' == *pch); )
                    pch++;
                    
                wcsncpy( szTemp, pch, szLen );
                wcsncpy( _hnetInfo.szWorkgroup, szTemp, szLen );
            
                delete [] szTemp;
            }
        
            // Use the computer name check for workgroups too
            if (IsValidNameSyntax(_hnetInfo.szWorkgroup, NetSetupWorkgroup))
            {
                if (g_fRunningOnNT)
                {
                    SetCursor(LoadCursor(NULL, IDC_WAIT));
                    NET_API_STATUS nas = NetValidateName(NULL, _hnetInfo.szWorkgroup, NULL, NULL, NetSetupWorkgroup);
                    if (NERR_InvalidWorkgroupName != nas) // we only put up a invalid name dialog if the name was invalid.  
                    {
                        hr = S_OK;
                        _hnetInfo.dwFlags |= HNET_SETWORKGROUPNAME;
                    }
                }
                else
                {
                    // TODO: Win9x!!!
                    hr = S_OK;
                    _hnetInfo.dwFlags |= HNET_SETWORKGROUPNAME;
                }
            }
        }
        else
        {
            ASSERT(E_FAIL == hr);
            idError = IDS_WORKGROUP_TOOMANYBYTES;
        }

        // If the computer name didn't validate, don't change pages and show an error.
        if(FAILED(hr))
        {
            SetFocus(GetDlgItem(hwnd, IDC_WORKGROUP));
            PropSheet_SetWizButtons(GetParent(hwnd), PSWIZB_BACK);
            DisplayFormatMessage(hwnd, IDS_WIZ_CAPTION, idError, MB_ICONERROR | MB_OK, _hnetInfo.szWorkgroup);
        }
    }

    return hr;
}

INT_PTR CHomeNetworkWizard::WorkgroupPageProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    CHomeNetworkWizard* pthis = GetThis(hwnd, uMsg, wParam, lParam);

    switch (uMsg)
    {
    case WM_INITDIALOG:
        {
            WCHAR szWorkgroup[LM20_DNLEN + 1]; *szWorkgroup = 0;
            LoadString(g_hinst, IDS_DEFAULT_WORKGROUP1, szWorkgroup, ARRAYSIZE(szWorkgroup));
            SetDlgItemText(hwnd, IDC_WORKGROUP, szWorkgroup);
            SendDlgItemMessage(hwnd, IDC_WORKGROUP, EM_LIMITTEXT, ARRAYSIZE(pthis->_hnetInfo.szWorkgroup) - 1, 0);
        }
        return TRUE;
    case WM_NOTIFY:
        {
            LPNMHDR pnmh = (LPNMHDR) lParam;

            switch (pnmh->code)
            {
            case PSN_SETACTIVE:
                {
                    pthis->WorkgroupSetControlState(hwnd);
                    pthis->_hnetInfo.dwFlags &= (~HNET_SETWORKGROUPNAME);
                }
                return TRUE;
            case PSN_WIZNEXT:
                {
                    if (SUCCEEDED(pthis->WorkgroupNextPage(hwnd)))
                    {
                        SetWindowLongPtr(hwnd, DWLP_MSGRESULT, (LONG_PTR) IDD_WIZ_SUMMARY);
                        pthis->PushPage(IDD_WIZ_WORKGROUP);
                    }
                    else
                    {
                        // else not changing pages; don't push
                        SetWindowLongPtr(hwnd, DWLP_MSGRESULT, (LONG_PTR) -1);
                    }
                }
                return TRUE;
            case PSN_WIZBACK:
                SetWindowLongPtr(hwnd, DWLP_MSGRESULT, pthis->PopPage());
                return TRUE;
            }
        }
        return FALSE;
    case WM_COMMAND:
        {
            switch (HIWORD(wParam))
            {
            case EN_CHANGE:
                if (LOWORD(wParam) == IDC_WORKGROUP)
                {
                    pthis->WorkgroupSetControlState(hwnd);
                }
                return FALSE;
            }
        }
        return FALSE;
    }

    return FALSE;
}

INT_PTR CHomeNetworkWizard::SummaryPageProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    CHomeNetworkWizard* pthis = GetThis(hwnd, uMsg, wParam, lParam);

    switch (uMsg)
    {
    case WM_INITDIALOG:
        {
            return TRUE;
        }
    case WM_NOTIFY:
        {
            LPNMHDR pnmh = (LPNMHDR) lParam;

            switch (pnmh->code)
            {
            case PSN_QUERYINITIALFOCUS:
                SetWindowLongPtr(hwnd, DWLP_MSGRESULT, (LONG_PTR) GetDlgItem(hwnd, IDC_TITLE));
                return TRUE;
            case PSN_SETACTIVE:
                pthis->SummarySetActive(hwnd);
                PropSheet_SetWizButtons(pnmh->hwndFrom, PSWIZB_BACK | PSWIZB_NEXT);
                return TRUE;
            case PSN_WIZBACK:
                SetWindowLongPtr(hwnd, DWLP_MSGRESULT, pthis->PopPage());
                return TRUE;
            case PSN_WIZNEXT:
                pthis->PushPage(IDD_WIZ_SUMMARY);
                SetWindowLongPtr(hwnd, DWLP_MSGRESULT, IDD_WIZ_PROGRESS);
                return TRUE;
            }
        }
        return FALSE;
    }

    return FALSE;
}

#define WM_CONFIGDONE   (WM_USER + 0x100)

INT_PTR CHomeNetworkWizard::ProgressPageProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    CHomeNetworkWizard* pthis = GetThis(hwnd, uMsg, wParam, lParam);

    switch (uMsg)
    {
    case WM_INITDIALOG:
        {
            return TRUE;
        }
    case WM_NOTIFY:
        {
            LPNMHDR pnmh = (LPNMHDR) lParam;

            switch (pnmh->code)
            {
            case PSN_SETACTIVE:
                {
                    PropSheet_CancelToClose(GetParent(hwnd));
                    PropSheet_SetWizButtons(pnmh->hwndFrom, 0);

                    pthis->_hnetInfo.fAsync = TRUE;
                    pthis->_hnetInfo.hwnd = hwnd;
                    pthis->_hnetInfo.umsgAsyncNotify = WM_CONFIGDONE;

                    ConfigureHomeNetwork(&(pthis->_hnetInfo));

                    HWND hwndAnimate = GetDlgItem(hwnd, IDC_PROGRESS);
                    Animate_Open(hwndAnimate, g_fRunningOnNT ? IDA_CONFIG : IDA_LOWCOLORCONFIG);
                    Animate_Play(hwndAnimate, 0, -1, -1);
                }

                return TRUE;
            }
        }
        return FALSE;
    case WM_CONFIGDONE:
        {
            Animate_Stop(GetDlgItem(hwnd, IDC_PROGRESS));

            // The config thread has finished. We assert that the thread has freed/nulled out
            // all of his INetConnection*'s since otherwise the UI thread will try to use/free them!
            ASSERT(NULL == pthis->_hnetInfo.pncExternal);
            ASSERT(NULL == pthis->_hnetInfo.prgncInternal);

            if (pthis->_hnetInfo.fRebootRequired)
            {
                PropSheet_RebootSystem(GetParent(hwnd));
            }

            // The HRESULT from the configuration is stored in wParam
            HRESULT hr = (HRESULT) wParam;
            UINT idFinishPage;

            if (SUCCEEDED(hr))
            {
                idFinishPage = IDD_WIZ_ALMOSTDONE;
            }
            else
            {
                idFinishPage = IDD_WIZ_CONFIGERROR;
            }

            PropSheet_SetCurSelByID(GetParent(hwnd), idFinishPage);
        }
        return TRUE;
    }

    return FALSE;
}

INT_PTR CHomeNetworkWizard::AlmostDonePageProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    CHomeNetworkWizard* pthis = GetThis(hwnd, uMsg, wParam, lParam);

    switch (uMsg)
    {
    case WM_INITDIALOG:
        {
            SendDlgItemMessage(hwnd, IDC_CREATEDISK, BM_SETCHECK, BST_CHECKED, 0);
            return TRUE;
        }
    case WM_NOTIFY:
        {
            LPNMHDR pnmh = (LPNMHDR) lParam;

            switch (pnmh->code)
            {
            case PSN_SETACTIVE:
                {
                    if (g_fRunningOnNT)
                    {
                        PropSheet_SetWizButtons(pnmh->hwndFrom, PSWIZB_NEXT);
                    }
                    else
                    {
                        // Skip this page on 9x
                        SetWindowLongPtr(hwnd, DWLP_MSGRESULT, IDD_WIZ_WIN9X_FINISH);
                    }
                }
                return TRUE;
            case PSN_WIZNEXT:
                {
                    // This page only shows on NT
                    ASSERT(g_fRunningOnNT);
                    pthis->_fFloppyInstructions = TRUE;
                    pthis->PushPage(IDD_WIZ_ALMOSTDONE);

                    UINT idNext = IDD_WIZ_FINISH;
                    if (BST_CHECKED == SendDlgItemMessage(hwnd, IDC_CREATEDISK, BM_GETCHECK, 0, 0))
                    {
                        idNext = IDD_WIZ_CHOOSEDISK;
                    }
                    else if (BST_CHECKED == SendDlgItemMessage(hwnd, IDC_HAVEDISK, BM_GETCHECK, 0, 0))
                    {
                        idNext = IDD_WIZ_FLOPPYINST;
                    }
                    else if (BST_CHECKED == SendDlgItemMessage(hwnd, IDC_HAVECD, BM_GETCHECK, 0, 0))
                    {
                        idNext = IDD_WIZ_CDINST;
                        pthis->_fFloppyInstructions = FALSE;
                    }

                    SetWindowLongPtr(hwnd, DWLP_MSGRESULT, (LONG_PTR) idNext);
                }
                return TRUE;
            }
        }
        return FALSE;
    }

    return FALSE;
}

void CHomeNetworkWizard::FillDriveList(HWND hwndList)
{
    ListView_SetImageList(hwndList, _himlLarge, LVSIL_NORMAL);

    ListView_DeleteAllItems(hwndList);

    WCHAR szDrive[] = L"A:\\";
    for (UINT i = 0; i < 26; i++)
    {
        szDrive[0] = L'A' + i;

        if (DRIVE_REMOVABLE == GetDriveType(szDrive))
        {
            LVITEM lvi = {0};
            lvi.mask = LVIF_PARAM | LVIF_TEXT;
            lvi.lParam = i;

            int iIndex;
            WCHAR szDriveDisplay[256];
            HRESULT hr = GetDriveNameAndIconIndex(szDrive, szDriveDisplay, ARRAYSIZE(szDriveDisplay), &iIndex);
            if (SUCCEEDED(hr))
            {
                lvi.iImage = iIndex;
                if (-1 != lvi.iImage)
                   lvi.mask |= LVIF_IMAGE;

                lvi.pszText = szDriveDisplay;

                int iItem = ListView_InsertItem(hwndList, &lvi);
            }
        }
    }

    ListView_SetColumnWidth(hwndList, 0, LVSCW_AUTOSIZE);
    ListView_SetColumnWidth(hwndList, 1, LVSCW_AUTOSIZE);
}

void CHomeNetworkWizard::ChooseDiskSetControlState(HWND hwnd)
{
    BOOL fSelection = ListView_GetSelectedCount(GetDlgItem(hwnd, IDC_DEVICELIST));
    PropSheet_SetWizButtons(GetParent(hwnd), fSelection ? PSWIZB_BACK | PSWIZB_NEXT : PSWIZB_BACK);
}

INT_PTR CHomeNetworkWizard::ChooseDiskPageProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    CHomeNetworkWizard* pthis = GetThis(hwnd, uMsg, wParam, lParam);

    switch (uMsg)
    {
    case WM_INITDIALOG:
        ASSERT(g_fRunningOnNT);
        return TRUE;
    case WM_NOTIFY:
        {
            LPNMHDR pnmh = (LPNMHDR) lParam;

            switch (pnmh->code)
            {
            case PSN_QUERYINITIALFOCUS:
                SetFocus(GetDlgItem(hwnd, IDC_DEVICELIST));
                return TRUE;
            case PSN_SETACTIVE:
                {
                    HWND hwndList = GetDlgItem(hwnd, IDC_DEVICELIST);
                    pthis->FillDriveList(hwndList);
                    pthis->ChooseDiskSetControlState(hwnd);

                    int cDrives = ListView_GetItemCount(hwndList);

                    if (0 >= cDrives)
                    {
                        // There are no removable drives or an error occurred
                        DisplayFormatMessage(hwnd, IDS_WIZ_CAPTION, IDS_NOREMOVABLEDRIVES, MB_ICONINFORMATION | MB_OK);
                        SetWindowLongPtr(hwnd, DWLP_MSGRESULT, pthis->PopPage());
                    }
                    else if (1 == cDrives)
                    {
                        // One drive - autoselect it and go to the next page
                        LVITEM lvi = {0};
                        lvi.mask = LVIF_PARAM;
                        ListView_GetItem(hwndList, &lvi);
                        pthis->_iDrive = lvi.lParam;
                        ListView_GetItemText(hwndList, lvi.iItem, 0, pthis->_szDrive, ARRAYSIZE(pthis->_szDrive));
                        SetWindowLongPtr(hwnd, DWLP_MSGRESULT, IDD_WIZ_INSERTDISK);
                    }
                }
                return TRUE;
            case PSN_WIZNEXT:
                {
                    HWND hwndList = GetDlgItem(hwnd, IDC_DEVICELIST);
                    pthis->_iDrive = 0;
                    LVITEM lvi = {0};
                    lvi.mask = LVIF_PARAM;
                    lvi.iItem = ListView_GetNextItem(hwndList, -1, LVNI_SELECTED);
                    if (-1 != lvi.iItem && ListView_GetItem(hwndList, &lvi))
                    {
                        pthis->_iDrive = lvi.lParam;
                        ListView_GetItemText(hwndList, lvi.iItem, 0, pthis->_szDrive, ARRAYSIZE(pthis->_szDrive));
                        pthis->PushPage(IDD_WIZ_CHOOSEDISK);
                        SetWindowLongPtr(hwnd, DWLP_MSGRESULT, IDD_WIZ_INSERTDISK);
                    }
                }
                return TRUE;
            case PSN_WIZBACK:
                SetWindowLongPtr(hwnd, DWLP_MSGRESULT, pthis->PopPage());
                return TRUE;
            case LVN_ITEMCHANGED:
                pthis->ChooseDiskSetControlState(hwnd);
                return TRUE;
            }
        }
        return FALSE;
    }

    return FALSE;
}

#define SOURCE_FILE "%windir%\\system32\\netsetup.exe"
HRESULT CHomeNetworkWizard::GetSourceFilePath(LPSTR pszSource, DWORD cch)
{
    HRESULT hr = E_FAIL;

    if (ExpandEnvironmentStringsA(SOURCE_FILE, pszSource, cch))
    {
        DWORD c = lstrlenA(pszSource);
        if (c + 2 <= cch)
        {
            // Add double NULL since we'll be passing this to SHFileOperation
            pszSource[c + 1] = '\0';
            hr = S_OK;
        }
    }

    return hr;
}

INT_PTR CHomeNetworkWizard::InsertDiskPageProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    CHomeNetworkWizard* pthis = GetThis(hwnd, uMsg, wParam, lParam);

    switch (uMsg)
    {
    case WM_INITDIALOG:
        ASSERT(g_fRunningOnNT);
        return TRUE;
    case WM_COMMAND:
        if (IDC_FORMAT == LOWORD(wParam))
        {
            SHFormatDrive(hwnd, pthis->_iDrive, 0, 0);
            return TRUE;
        }
        return FALSE;
    case WM_NOTIFY:
        {
            LPNMHDR pnmh = (LPNMHDR) lParam;

            switch (pnmh->code)
            {
            case PSN_SETACTIVE:
                {
                    SetDlgItemText(hwnd, IDC_DISK, pthis->_szDrive);
                    PropSheet_SetWizButtons(pnmh->hwndFrom, PSWIZB_BACK | PSWIZB_NEXT);
                }
                return TRUE;
            case PSN_WIZBACK:
                SetWindowLongPtr(hwnd, DWLP_MSGRESULT, pthis->PopPage());
                return TRUE;
            case PSN_WIZNEXT:
                {
                    CHAR szSource[MAX_PATH];
                    if (SUCCEEDED(GetSourceFilePath(szSource, ARRAYSIZE(szSource))))
                    {
                        // Double-null since we'll be passing this to SHFileOperation
                        CHAR szDest[] = "a:\\netsetup.exe\0";
                        szDest[0] = 'A' + pthis->_iDrive;

                        SHFILEOPSTRUCTA shfo = {0};
                        shfo.wFunc = FO_COPY;
                        shfo.pFrom = szSource;
                        shfo.pTo = szDest;
                        shfo.fFlags = FOF_SIMPLEPROGRESS | FOF_NOCONFIRMATION;
                        CHAR szTitle[256];
                        LoadStringA(g_hinst, IDS_COPYING, szTitle, ARRAYSIZE(szTitle));
                        shfo.lpszProgressTitle = szTitle;

                        int i = SHFileOperationA(&shfo);
                        if (i || shfo.fAnyOperationsAborted)
                        {
                            SetWindowLongPtr(hwnd, DWLP_MSGRESULT, -1);
                        }
                        else
                        {
                            SetWindowLongPtr(hwnd, DWLP_MSGRESULT, IDD_WIZ_FLOPPYINST);
                        }
                    }
                }
                return TRUE;
            }
        }
        return FALSE;
    }

    return FALSE;
}

INT_PTR CHomeNetworkWizard::InstructionsPageProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    CHomeNetworkWizard* pthis = GetThis(hwnd, uMsg, wParam, lParam);

    switch (uMsg)
    {
    case WM_INITDIALOG:
        ASSERT(g_fRunningOnNT);
        return TRUE;
    case WM_NOTIFY:
        {
            LPNMHDR pnmh = (LPNMHDR) lParam;

            switch (pnmh->code)
            {
            case PSN_SETACTIVE:
                {
                    PropSheet_SetWizButtons(pnmh->hwndFrom, PSWIZB_BACK | PSWIZB_NEXT);

                    // If we aren't going to need to reboot
                    if (!pthis->_hnetInfo.fRebootRequired)
                    {
                        // Then we don't want to tell the user to reboot in the text
                        UINT idNoReboot = IDS_CD_NOREBOOT;

                        if (pthis->_fFloppyInstructions)
                        {
                            // We're on the floppy instructions page
                            idNoReboot = IDS_FLOPPY_NOREBOOT;
                        }

                        WCHAR szLine[256];
                        LoadString(g_hinst, idNoReboot, szLine, ARRAYSIZE(szLine));
                        SetDlgItemText(hwnd, IDC_INSTRUCTIONS, szLine);
                    }
                }
                return TRUE;
            case PSN_WIZBACK:
                SetWindowLongPtr(hwnd, DWLP_MSGRESULT, pthis->PopPage());
                return TRUE;
            case PSN_WIZNEXT:
                pthis->PushPage(pthis->_fFloppyInstructions ? IDD_WIZ_FLOPPYINST : IDD_WIZ_CDINST);
                SetWindowLongPtr(hwnd, DWLP_MSGRESULT, IDD_WIZ_FINISH);
                return TRUE;
            }
        }
        return FALSE;
    }

    return FALSE;
}



void _AddLineToBuffer(LPCWSTR pszLine, LPWSTR pszBuffer, DWORD cchBuffer, DWORD* piChar)
{
    lstrcpyn(pszBuffer + (*piChar), pszLine, cchBuffer - (*piChar));
    *piChar += lstrlen(pszLine);
    lstrcpyn(pszBuffer + (*piChar), L"\r\n", cchBuffer - (*piChar));
    *piChar += 2;
}

void CHomeNetworkWizard::SummarySetActive(HWND hwnd)
{
    WCHAR szText[2048];
    WCHAR szLine[256];
    DWORD iChar = 0;

    // Fill the list with some information based on what things we're going to do to
    // configure their home network.

    if (_hnetInfo.pncExternal)
    {
        // "Internet connection settings:"
        LoadString(g_hinst, IDS_SUMMARY_INETSETTINGS, szLine, ARRAYSIZE(szLine));
        _AddLineToBuffer(szLine, szText, ARRAYSIZE(szText), &iChar);

        NETCON_PROPERTIES* pncprops;
        HRESULT hr = _hnetInfo.pncExternal->GetProperties(&pncprops);
        if (SUCCEEDED(hr))
        {
            // Internet connection:\t%1
            if (FormatMessageString(IDS_SUMMARY_INETCON, szLine, ARRAYSIZE(szLine), pncprops->pszwName))
            {
                _AddLineToBuffer(szLine, szText, ARRAYSIZE(szText), &iChar);
            }

            // Internet connection sharing:\tenabled
            if (_hnetInfo.dwFlags & HNET_SHARECONNECTION)
            {
                LoadString(g_hinst, IDS_SUMMARY_ICSENABLED, szLine, ARRAYSIZE(szLine));
                _AddLineToBuffer(szLine, szText, ARRAYSIZE(szText), &iChar);
            }

            // Personal firewall:\tenabled
            if (_hnetInfo.dwFlags & HNET_FIREWALLCONNECTION)
            {
                LoadString(g_hinst, IDS_SUMMARY_FIREWALLENABLED, szLine, ARRAYSIZE(szLine));
                _AddLineToBuffer(szLine, szText, ARRAYSIZE(szText), &iChar);
            }

            NcFreeNetconProperties(pncprops);
        }

        LoadString(g_hinst, IDS_SUMMARY_UNDERLINE, szLine, ARRAYSIZE(szLine));
        _AddLineToBuffer(szLine, szText, ARRAYSIZE(szText), &iChar);
    }
    else
    {
        if (_fICSClient)
        {
            // "Internet connection settings:"
            LoadString(g_hinst, IDS_SUMMARY_INETSETTINGS, szLine, ARRAYSIZE(szLine));
            _AddLineToBuffer(szLine, szText, ARRAYSIZE(szText), &iChar);

            if (*_szICSMachineName)
            {
                // Connecting via ICS through:\t%1
                if (FormatMessageString(IDS_sUMMARY_CONNECTTHROUGH, szLine, ARRAYSIZE(szLine), _szICSMachineName))
                {
                    _AddLineToBuffer(szLine, szText, ARRAYSIZE(szText), &iChar);
                }
            }
            else
            {
                // Connecting through another device or computer.
                LoadString(g_hinst, IDS_SUMMARY_CONNECTTHROUGH2, szLine, ARRAYSIZE(szLine));
                _AddLineToBuffer(szLine, szText, ARRAYSIZE(szText), &iChar);
            }

            LoadString(g_hinst, IDS_SUMMARY_UNDERLINE, szLine, ARRAYSIZE(szLine));
            _AddLineToBuffer(szLine, szText, ARRAYSIZE(szText), &iChar);
        }
        else
        {
            // Not connecting to the Internet - display nothing
        }
    }

    // Home network settings:
    LoadString(g_hinst, IDS_SUMMARY_HNETSETTINGS, szLine, ARRAYSIZE(szLine));
    _AddLineToBuffer(szLine, szText, ARRAYSIZE(szText), &iChar);

    if (_hnetInfo.dwFlags & HNET_SETCOMPUTERNAME)
    {
        // Computer description:\t%1
        if (FormatMessageString(IDS_SUMMARY_COMPDESC, szLine, ARRAYSIZE(szLine), _hnetInfo.szComputerDescription))
        {
            _AddLineToBuffer(szLine, szText, ARRAYSIZE(szText), &iChar);
        }

        // Computer name:\t%1
        if (FormatMessageString(IDS_SUMMARY_COMPNAME, szLine, ARRAYSIZE(szLine), _hnetInfo.szComputer))
        {
            _AddLineToBuffer(szLine, szText, ARRAYSIZE(szText), &iChar);
        }
    }

    if (_hnetInfo.dwFlags & HNET_SETWORKGROUPNAME)
    {
        // Workgroup name:\t%1
        if (FormatMessageString(IDS_SUMMARY_WORKGROUP, szLine, ARRAYSIZE(szLine), _hnetInfo.szWorkgroup))
        {
            _AddLineToBuffer(szLine, szText, ARRAYSIZE(szText), &iChar);
        }
    }

    // The Shared Documents folder and any printers connected to this computer have been shared.
    _AddLineToBuffer(L"", szText, ARRAYSIZE(szText), &iChar);
    LoadString(g_hinst, IDS_SUMMARY_SHARING, szLine, ARRAYSIZE(szLine));
    _AddLineToBuffer(szLine, szText, ARRAYSIZE(szText), &iChar);
    LoadString(g_hinst, IDS_SUMMARY_UNDERLINE, szLine, ARRAYSIZE(szLine));
    _AddLineToBuffer(szLine, szText, ARRAYSIZE(szText), &iChar);

    if ((_hnetInfo.prgncInternal) && (_hnetInfo.cncInternal))
    {
        if (_hnetInfo.cncInternal > 1)
        {
            // Bridged connections:\r\n
            LoadString(g_hinst, IDS_SUMMARY_BRIDGESETTINGS, szLine, ARRAYSIZE(szLine));
            _AddLineToBuffer(szLine, szText, ARRAYSIZE(szText), &iChar);

            // Now list the connections...
            for (DWORD i = 0; i < _hnetInfo.cncInternal; i++)
            {
                NETCON_PROPERTIES* pncprops;
                HRESULT hr = _hnetInfo.prgncInternal[i]->GetProperties(&pncprops);
                if (SUCCEEDED(hr))
                {
                    _AddLineToBuffer(pncprops->pszwName, szText, ARRAYSIZE(szText), &iChar);
                    NcFreeNetconProperties(pncprops);
                }
            }
        }
        else // Single internal connection case
        {
            // Home network connection:\t%1
            NETCON_PROPERTIES* pncprops;
            HRESULT hr = _hnetInfo.prgncInternal[0]->GetProperties(&pncprops);
            if (SUCCEEDED(hr))
            {
                if (FormatMessageString(IDS_SUMMARY_HOMENETCON, szLine, ARRAYSIZE(szLine), pncprops->pszwName))
                {
                    _AddLineToBuffer(szLine, szText, ARRAYSIZE(szText), &iChar);
                }

                NcFreeNetconProperties(pncprops);
            }
        }
    }

    ASSERT(iChar < ARRAYSIZE(szText));

    UINT iTabDistance = 150;
    SendDlgItemMessage(hwnd, IDC_CHANGELIST, EM_SETTABSTOPS, (WPARAM) 1, (LPARAM) &iTabDistance);
    SetDlgItemText(hwnd, IDC_CHANGELIST, szText);
}

INT_PTR CHomeNetworkWizard::FinishPageProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    CHomeNetworkWizard* pthis = GetThis(hwnd, uMsg, wParam, lParam);

    switch (uMsg)
    {
    case WM_INITDIALOG:
        {
            pthis->WelcomeSetTitleFont(hwnd);
            pthis->ReplaceStaticWithLink(GetDlgItem(hwnd, IDC_HELPSTATIC), IDC_HELPLINK, IDS_HELP_SHARING);
            pthis->ReplaceStaticWithLink(GetDlgItem(hwnd, IDC_HELPSTATIC2), IDC_HELPLINK2, IDS_HELP_SHAREDDOCS);
            return TRUE;
        }

    case WM_NOTIFY:
        {
            LPNMHDR pnmh = (LPNMHDR) lParam;

            switch (pnmh->code)
            {
            case PSN_SETACTIVE:
                PropSheet_CancelToClose(GetParent(hwnd));
                PropSheet_SetWizButtons(pnmh->hwndFrom, PSWIZB_BACK | PSWIZB_FINISH);
                return TRUE;
            case PSN_WIZBACK:
                SetWindowLongPtr(hwnd, DWLP_MSGRESULT, pthis->PopPage());
                return TRUE;
            case PSN_WIZFINISH:
                return TRUE;
            case NM_CLICK:
            case NM_RETURN:
                switch ((int) wParam)
                {
                    case IDC_HELPLINK:
                        // help on sharing
                        {
                            if (IsOS(OS_PERSONAL))
                            {
                                HelpCenter(hwnd, L"filefold.chm%3A%3A/sharing_files_overviewP.htm");
                            }
                            else
                            {
                                HelpCenter(hwnd, L"filefold.chm%3A%3A/sharing_files_overviewW.htm");
                            }
                        }
                        return TRUE;
                    case IDC_HELPLINK2:
                        // help on Shared Documents
                        {
                            HelpCenter(hwnd, L"filefold.chm%3A%3A/windows_shared_documents.htm");
                        }
                        return TRUE;
                }
            }
        }
        return FALSE;
    }

    return FALSE;
}

INT_PTR CHomeNetworkWizard::ErrorFinishPageProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    CHomeNetworkWizard* pthis = GetThis(hwnd, uMsg, wParam, lParam);

    switch (uMsg)
    {
    case WM_INITDIALOG:
        pthis->WelcomeSetTitleFont(hwnd);
        return TRUE;
    case WM_NOTIFY:
        {
            LPNMHDR pnmh = (LPNMHDR) lParam;

            switch (pnmh->code)
            {
            case PSN_SETACTIVE:
                PropSheet_SetWizButtons(pnmh->hwndFrom, PSWIZB_FINISH);
                return TRUE;
            case PSN_WIZBACK:
                SetWindowLongPtr(hwnd, DWLP_MSGRESULT, pthis->PopPage());
                return TRUE;
            case PSN_WIZFINISH:
                return TRUE;
            }
        }
        return FALSE;
    }

    return FALSE;
}


INT_PTR CHomeNetworkWizard::NoHardwareFinishPageProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    CHomeNetworkWizard* pthis = GetThis(hwnd, uMsg, wParam, lParam);

    switch (uMsg)
    {
    case WM_INITDIALOG:
        {
            pthis->WelcomeSetTitleFont(hwnd);
            return TRUE;
        }
    case WM_NOTIFY:
        {
            LPNMHDR pnmh = (LPNMHDR) lParam;

            switch (pnmh->code)
            {
            case PSN_SETACTIVE:
                PropSheet_SetWizButtons(pnmh->hwndFrom, PSWIZB_BACK);
                return TRUE;
            case PSN_WIZBACK:
                SetWindowLongPtr(hwnd, DWLP_MSGRESULT, pthis->PopPage());
                return TRUE;
            case PSN_WIZFINISH:
                return TRUE;
            }
        }
        return FALSE;
    }

    return FALSE;
}

INT_PTR CHomeNetworkWizard::CantRunWizardPageProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    CHomeNetworkWizard* pthis = GetThis(hwnd, uMsg, wParam, lParam);

    switch (uMsg)
    {
    case WM_INITDIALOG:
        pthis->WelcomeSetTitleFont(hwnd);
        return TRUE;
    case WM_NOTIFY:
        {
            LPNMHDR pnmh = (LPNMHDR) lParam;

            switch (pnmh->code)
            {
            case PSN_SETACTIVE:
                PropSheet_SetWizButtons(pnmh->hwndFrom, 0);
                return TRUE;
            }
        }
        return FALSE;
    }

    return FALSE;
}

HRESULT GetConnections(HDPA* phdpa)
{
    HRESULT hr = S_OK;
    *phdpa = DPA_Create(5);
    if (*phdpa)
    {
        // Initialize the net connection enumeration
        INetConnectionManager* pmgr;

        hr = CoCreateInstance(CLSID_ConnectionManager, NULL, CLSCTX_SERVER | CLSCTX_NO_CODE_DOWNLOAD,
            IID_PPV_ARG(INetConnectionManager, &pmgr));

        if (SUCCEEDED(hr))
        {
            hr = SetProxyBlanket(pmgr);

            if (SUCCEEDED(hr))
            {
                IEnumNetConnection* penum;
                hr = pmgr->EnumConnections(NCME_DEFAULT, &penum);

                if (SUCCEEDED(hr))
                {
                    hr = SetProxyBlanket(penum);

                    if (SUCCEEDED(hr))
                    {
                        // Fill in our DPA will the connections
                        hr = penum->Reset();
                        while (S_OK == hr)
                        {
                            INetConnection* pnc;
                            ULONG ulISuck;
                            hr = penum->Next(1, &pnc, &ulISuck);

                            if (S_OK == hr)
                            {
                                hr = SetProxyBlanket(pnc);

                                if (SUCCEEDED(hr))
                                {
                                    if (-1 != DPA_AppendPtr(*phdpa, pnc))
                                    {
                                        pnc->AddRef();
                                    }
                                    else
                                    {
                                        hr = E_OUTOFMEMORY;
                                    }
                                }

                                pnc->Release();
                            }
                        }
                    }

                    penum->Release();
                }
            }
            pmgr->Release();
        }

        if (FAILED(hr))
        {
            DPA_DestroyCallback(*phdpa, FreeConnectionDPACallback, NULL);
            *phdpa = NULL;
        }
    }
    else
    {
        hr = E_OUTOFMEMORY;
    }

    return hr;
}

CHomeNetworkWizard* CHomeNetworkWizard::GetThis(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    CHomeNetworkWizard* pthis = NULL;

    if (uMsg == WM_INITDIALOG)
    {
        PROPSHEETPAGE* psp = (PROPSHEETPAGE*) lParam;
        pthis = (CHomeNetworkWizard*) psp->lParam;
        SetWindowLongPtr(hwnd, GWLP_USERDATA, (LONG_PTR) pthis);
    }
    else
    {
        pthis = (CHomeNetworkWizard*) GetWindowLongPtr(hwnd, GWLP_USERDATA);
    }

    return pthis;
}


// Utility functions
HRESULT GetConnectionsFolder(IShellFolder** ppsfConnections)
{
    LPITEMIDLIST pidlFolder;
    HRESULT hr = SHGetSpecialFolderLocation(NULL, CSIDL_CONNECTIONS, &pidlFolder);

    if (SUCCEEDED(hr))
    {
        IShellFolder* pshDesktop;
        hr = SHGetDesktopFolder(&pshDesktop);

        if (SUCCEEDED(hr))
        {
            hr = pshDesktop->BindToObject(pidlFolder, NULL, IID_PPV_ARG(IShellFolder, ppsfConnections));

    

#if 0
            /*
            We need to do an IEnumIDList::Reset to set up internal data structures so that ::ParseDisplayName
            works later. Remove this once DaveA's stuff gets in the desktop build. TODO
            */
            if (SUCCEEDED(hr))
            {
                IEnumIDList* penum;
                hr = (*ppsfConnections)->EnumObjects(NULL, SHCONTF_NONFOLDERS | SHCONTF_FOLDERS, &penum);

                if (SUCCEEDED(hr))
                {
                    penum->Reset();
                    penum->Release();
                }
            }
#endif

            pshDesktop->Release();
        }

        ILFree(pidlFolder);
    }

    return hr;
}

void W9xGetNetTypeName(BYTE bNicType, WCHAR* pszBuff, UINT cchBuff)
{
    COMPILETIME_ASSERT(IDS_NETTYPE_START == IDS_NETTYPE_LAN);
    COMPILETIME_ASSERT(IDS_NETTYPE_LAN    - IDS_NETTYPE_START == NETTYPE_LAN);
    COMPILETIME_ASSERT(IDS_NETTYPE_DIALUP - IDS_NETTYPE_START == NETTYPE_DIALUP);
    COMPILETIME_ASSERT(IDS_NETTYPE_IRDA   - IDS_NETTYPE_START == NETTYPE_IRDA);
    COMPILETIME_ASSERT(IDS_NETTYPE_PPTP   - IDS_NETTYPE_START == NETTYPE_PPTP);
    COMPILETIME_ASSERT(IDS_NETTYPE_TV     - IDS_NETTYPE_START == NETTYPE_TV);
    COMPILETIME_ASSERT(IDS_NETTYPE_ISDN   - IDS_NETTYPE_START == NETTYPE_ISDN);
    COMPILETIME_ASSERT(IDS_NETTYPE_LAN    - IDS_NETTYPE_START == NETTYPE_LAN);

    if (bNicType >= NETTYPE_LAN && bNicType <= NETTYPE_ISDN)
    {
        LoadString(g_hinst, IDS_NETTYPE_START + bNicType, pszBuff, cchBuff);
    }
    else
    {
        LoadString(g_hinst, IDS_NETTYPE_UNKNOWN, pszBuff, cchBuff);
    }

    return;
}

BOOL W9xIsValidAdapter(const NETADAPTER* pNA, DWORD dwFlags)
{
    BOOL fRet = FALSE;

    if (dwFlags & CONN_EXTERNAL)
    {
        fRet = (pNA->bError      == NICERR_NONE &&
                pNA->bNetType    == NETTYPE_LAN &&
                pNA->bNetSubType != SUBTYPE_ICS &&
                pNA->bNetSubType != SUBTYPE_AOL &&
                pNA->bNicType    != NIC_1394       );
    }
    else if (dwFlags & CONN_INTERNAL)
    {
        fRet = (pNA->bError      == NICERR_NONE &&
                pNA->bNetType    == NETTYPE_LAN &&
                pNA->bNetSubType != SUBTYPE_ICS &&
                pNA->bNetSubType != SUBTYPE_AOL    );
    }
/*    else if ( dwFlags & CONN_UNPLUGGED )
    {
        if ( IsOS(OS_MILLENNIUM) )
        {
            fRet = IsAdapterDisconnected( (void*)pNA );
        }
    }
*/

    return fRet;
}

BOOL W9xIsAdapterDialUp(const NETADAPTER* pAdapter)
{
    return (pAdapter->bNetType == NETTYPE_DIALUP && pAdapter->bNetSubType == SUBTYPE_NONE);
}



HRESULT CHomeNetworkWizard::GetConnectionIconIndex(GUID& guidConnection, IShellFolder* psfConnections, int* pIndex)
{
    *pIndex = -1;
    OLECHAR szGUID[40];
    HRESULT hr = E_FAIL;
    if (StringFromGUID2(guidConnection, szGUID, ARRAYSIZE(szGUID)))
    {
        LPITEMIDLIST pidlConn = NULL;
        ULONG cchEaten = 0;
        hr = psfConnections->ParseDisplayName(NULL, NULL, szGUID, &cchEaten, &pidlConn, NULL);
        
        if (SUCCEEDED(hr))
        {
            IExtractIconW *pExtractIconW;
            LPCITEMIDLIST pcidl = pidlConn;

            hr = psfConnections->GetUIObjectOf(NULL, 1, &pcidl, IID_IExtractIconW, 0, (LPVOID *)(&pExtractIconW));
            if (SUCCEEDED(hr))
            {
                WCHAR szIconLocation[MAX_PATH];
                INT iIndex;
                UINT wFlags;

                hr = pExtractIconW->GetIconLocation(GIL_FORSHELL, szIconLocation, MAX_PATH, &iIndex, &wFlags);

                if (SUCCEEDED(hr))
                {
                    HICON hIconLarge;
                    HICON hIconSmall;

                    hr = pExtractIconW->Extract(szIconLocation, iIndex, &hIconLarge, &hIconSmall, 0x00100010);
                    if (SUCCEEDED(hr))
                    {
                        *pIndex = ImageList_AddIcon(_himlSmall, hIconSmall);
                    }
                    DestroyIcon(hIconLarge);
                    DestroyIcon(hIconSmall);
                }
            }

            if(pExtractIconW != NULL)
                pExtractIconW->Release();

            ILFree(pidlConn);
        }
    }

    return hr;
}

HRESULT GetDriveNameAndIconIndex(LPWSTR pszDrive, LPWSTR pszDisplayName, DWORD cchDisplayName, int* pIndex)
{
    SHFILEINFO fi = {0};
    
    if (SHGetFileInfoW_NT(pszDrive, 0, &fi, sizeof (fi), SHGFI_DISPLAYNAME | SHGFI_SYSICONINDEX))
    {
        *pIndex = fi.iIcon;
        lstrcpyn(pszDisplayName, fi.szDisplayName, cchDisplayName);
        return S_OK;
    }

    return E_FAIL;
}

BOOL IsEqualConnection(INetConnection* pnc1, INetConnection* pnc2)
{
    BOOL fEqual = FALSE;

    if ((pnc1) && (pnc2))
    {
        NETCON_PROPERTIES *pprops1, *pprops2;

        if (SUCCEEDED(pnc1->GetProperties(&pprops1)))
        {
            if (SUCCEEDED(pnc2->GetProperties(&pprops2)))
            {
                fEqual = (pprops1->guidId == pprops2->guidId);

                NcFreeNetconProperties(pprops2);
            }

            NcFreeNetconProperties(pprops1);
        }
    }

    return fEqual;
}

HRESULT ShareAllPrinters()
{
    PRINTER_ENUM* pPrinters;
    int nPrinters = MyEnumLocalPrinters(&pPrinters);

    if (nPrinters)
    {
        int iPrinterNumber = 1;
        for (int iPrinter = 0; iPrinter < nPrinters; iPrinter ++)
        {
            TCHAR szShare[NNLEN + 1];

            do
            {
                FormatMessageString(IDS_PRINTER, szShare, ARRAYSIZE(szShare), iPrinterNumber);
                if (1 == iPrinterNumber)
                {
                    szShare[lstrlen(szShare) - 1] = 0;
                    // Remove the "1" from the end since this is the first printer
                    // ie: "Printer1" --> "Printer"
                }

                if (!g_fRunningOnNT)
                {
                    CharUpper(szShare);
                }

                iPrinterNumber ++;
            } while (IsShareNameInUse(szShare));

            if (SharePrinter(pPrinters[iPrinter].pszPrinterName, szShare, NULL))
            {
                g_logFile.Write("Shared Printer: ");
            }
            else
            {
                g_logFile.Write("Failed to share Printer: ");
            }

            g_logFile.Write(pPrinters[iPrinter].pszPrinterName);
            g_logFile.Write("\r\n");
        }

        free(pPrinters);
    }

    return S_OK;
}

BOOL AllPlatformGetComputerName(LPWSTR pszName, DWORD cchName)
{
    if (g_fRunningOnNT)
    {
        return GetComputerNameExW_NT(ComputerNamePhysicalNetBIOS, pszName, &cchName);
    }
    else
    {
        return GetComputerName(pszName, &cchName);
    }
}

BOOL _IsTCPIPAvailable(void)
{
    BOOL fTCPIPAvailable = FALSE;
    HKEY hk;
    DWORD dwSize;

    // we check to see if the TCP/IP stack is installed and which object it is
    // bound to, this is a string, we don't check the value only that the
    // length is non-zero.

    if ( ERROR_SUCCESS == RegOpenKeyEx(HKEY_LOCAL_MACHINE,
                                       TEXT("System\\CurrentControlSet\\Services\\Tcpip\\Linkage"),
                                       0x0,
                                       KEY_QUERY_VALUE, &hk) )
    {
        if ( ERROR_SUCCESS == RegQueryValueEx(hk, TEXT("Export"), 0x0, NULL, NULL, &dwSize) )
        {
            if ( dwSize > 2 )
            {
                fTCPIPAvailable = TRUE;
            }
        }
        RegCloseKey(hk);
    }

    return (fTCPIPAvailable);
}

BOOL AllPlatformSetComputerName(LPCWSTR pszComputerName)
{
    // NetBIOS computer name is set even on NT for completeness
    BOOL fSuccess;

    if (g_fRunningOnNT)
    {
        if (_IsTCPIPAvailable())
        {
            fSuccess = SetComputerNameExW_NT(ComputerNamePhysicalDnsHostname, pszComputerName);
        }
        else
        {
            fSuccess = SetComputerNameExW_NT(ComputerNamePhysicalNetBIOS, pszComputerName);
        }
    }
    else
    {
        // Windows 9x
        fSuccess = SetComputerName(pszComputerName);
    }

    return fSuccess;
}

BOOL SetComputerNameIfNecessary(LPCWSTR pszComputerName, BOOL* pfRebootRequired)
{
    g_logFile.Write("Attempting to set computer name\r\n");

    WCHAR szOldComputerName[LM20_CNLEN + 1];
    AllPlatformGetComputerName(szOldComputerName, ARRAYSIZE(szOldComputerName));

    if (0 != StrCmpIW(szOldComputerName, pszComputerName))
    {
        if (AllPlatformSetComputerName(pszComputerName))
        {
            g_logFile.Write("Computer name set successfully: ");
            g_logFile.Write(pszComputerName);
            g_logFile.Write("\r\n");
            *pfRebootRequired = TRUE;
        }
        else
        {
            g_logFile.Write("Computer name set failed.\r\n");
            return FALSE;
        }
    }
    else
    {
        g_logFile.Write("Old computer name is the same as new computer name - not setting.\r\n");
    }

    return TRUE;
}

BOOL SetComputerDescription(LPCWSTR pszComputerDescription)
{
    BOOL fRet;

    if (g_fRunningOnNT)
    {
        g_logFile.Write("Setting server description (comment): ");
        g_logFile.Write(pszComputerDescription);
        g_logFile.Write("\r\n");

        // Set comment (for now, NT only) win9x - TODO
        SERVER_INFO_1005_NT sv1005;
        sv1005.sv1005_comment = const_cast<LPWSTR>(pszComputerDescription);
        fRet = (NERR_Success == NetServerSetInfo_NT(NULL, 1005, (LPBYTE) &sv1005, NULL));
    }
    else
    {
        CRegistry reg;
        fRet = reg.OpenKey(HKEY_LOCAL_MACHINE, L"System\\CurrentControlSet\\Services\\VxD\\VNETSUP");
        if (fRet)
        {
            fRet = reg.SetStringValue(L"Comment", pszComputerDescription);
        }
    }

    return fRet;
}

HRESULT ShareWellKnownFolders(PHOMENETSETUPINFO pInfo)
{
    if (!NetConn_IsSharedDocumentsShared())
    {
        NetConn_CreateSharedDocuments(NULL, g_hinst, NULL, 0);

        if (NetConn_IsSharedDocumentsShared())
        {
            g_logFile.Write("'Shared Documents' shared.\r\n");
        }
        else
        {
            g_logFile.Write("Failed to share 'Shared Documents'\r\n");
            return E_FAIL;
        }
    }

    return S_OK;
}

HRESULT SetProxyBlanket(IUnknown * pUnk)
{
    HRESULT hr;
    hr = CoSetProxyBlanket (
            pUnk,
            RPC_C_AUTHN_WINNT,      // use NT default security
            RPC_C_AUTHZ_NONE,       // use NT default authentication
            NULL,                   // must be null if default
            RPC_C_AUTHN_LEVEL_CALL, // call
            RPC_C_IMP_LEVEL_IMPERSONATE,
            NULL,                   // use process token
            EOAC_NONE);

    if(SUCCEEDED(hr))
    {
        IUnknown * pUnkSet = NULL;
        hr = pUnk->QueryInterface(IID_PPV_ARG(IUnknown, &pUnkSet));
        if(SUCCEEDED(hr))
        {
            hr = CoSetProxyBlanket (
                    pUnkSet,
                    RPC_C_AUTHN_WINNT,      // use NT default security
                    RPC_C_AUTHZ_NONE,       // use NT default authentication
                    NULL,                   // must be null if default
                    RPC_C_AUTHN_LEVEL_CALL, // call
                    RPC_C_IMP_LEVEL_IMPERSONATE,
                    NULL,                   // use process token
                    EOAC_NONE);
            pUnkSet->Release();
        }
    }
    return hr;
}

HRESULT WriteSetupInfoToRegistry(PHOMENETSETUPINFO pInfo)
{
    HKEY hkey;
    if (ERROR_SUCCESS == RegCreateKeyEx(HKEY_LOCAL_MACHINE, c_szAppRegKey, 0, NULL, 0, KEY_WRITE, NULL, &hkey, NULL))
    {
       // Write information telling the home network wizard to run silently on next boot, and what to share
       DWORD dwRun = 1;
       RegSetValueEx(hkey, TEXT("RunWizardFromRegistry"), NULL, REG_DWORD, (CONST BYTE*) &dwRun, sizeof (dwRun));
       RegCloseKey(hkey);
    }

    // Add a runonce entry for this wizard
    TCHAR szProcess[MAX_PATH];
    if (0 != GetModuleFileName(NULL, szProcess, ARRAYSIZE(szProcess)))
    {
        TCHAR szModule[MAX_PATH];
        if (0 != GetModuleFileName(g_hinst, szModule, ARRAYSIZE(szModule)))
        {
            const TCHAR szRunDllFormat[] = TEXT("%s %s,HomeNetWizardRunDll");
            TCHAR szRunDllLine[MAX_PATH];
            if (0 < wnsprintf(szRunDllLine, ARRAYSIZE(szRunDllLine), szRunDllFormat, szProcess, szModule))
            {
                if (ERROR_SUCCESS == RegCreateKeyEx(HKEY_LOCAL_MACHINE, REGSTR_PATH_RUNONCE, 0, NULL, 0, KEY_WRITE, NULL, &hkey, NULL))
                {
                    RegSetValueEx(hkey, TEXT("Network Setup Wizard"), 0, REG_SZ, (LPBYTE) szRunDllLine, ARRAYSIZE(szRunDllLine));
                    RegCloseKey(hkey);
                }
            }
        }
    }

   return S_OK;
}

HRESULT DeleteSetupInfoFromRegistry()
{
    RegDeleteKeyAndSubKeys(HKEY_LOCAL_MACHINE, c_szAppRegKey);
    return S_OK;
}

HRESULT ReadSetupInfoFromRegistry(PHOMENETSETUPINFO pInfo)
{
    BOOL fRunFromRegistry = FALSE;

    HKEY hkey;
    if (ERROR_SUCCESS == RegOpenKeyEx(HKEY_LOCAL_MACHINE, c_szAppRegKey, 0, KEY_READ, &hkey))
    {
        DWORD dwType;
        DWORD cbData = sizeof (fRunFromRegistry);
        if (ERROR_SUCCESS != RegQueryValueEx(hkey, TEXT("RunWizardFromRegistry"), NULL, &dwType, (LPBYTE) &fRunFromRegistry, &cbData))
        {
            fRunFromRegistry = FALSE;
        }

        RegCloseKey(hkey);
    }

    // S_FALSE indicates we're not running silently from infromation in the registry.
    return fRunFromRegistry ? S_OK : S_FALSE;
}

HRESULT MakeUniqueShareName(LPCTSTR pszBaseName, LPTSTR pszUniqueName, DWORD cchName)
{
    if (!IsShareNameInUse(pszBaseName))
    {
        lstrcpyn(pszUniqueName, pszBaseName, cchName);
        return S_OK;
    }
    else
    {
        int i = 2;
        while (TRUE)
        {
            if (0 > wnsprintf(pszUniqueName, cchName, TEXT("%s%d"), pszBaseName, i))
            {
                return E_FAIL;
            }

            if (!IsShareNameInUse(pszUniqueName))
            {
                return S_OK;
            }
        }
    }
}

// Pass NULL as TokenHandle to see if thread token is admin
HRESULT IsUserLocalAdmin(HANDLE TokenHandle, BOOL* pfIsAdmin)
{
    if (g_fRunningOnNT)
    {
        // First we must check if the current user is a local administrator; if this is
        // the case, our dialog doesn't even display

        PSID psidAdminGroup = NULL;
        SID_IDENTIFIER_AUTHORITY security_nt_authority = SECURITY_NT_AUTHORITY;

        BOOL fSuccess = ::AllocateAndInitializeSid_NT(&security_nt_authority, 2,
                                                   SECURITY_BUILTIN_DOMAIN_RID,
                                                   DOMAIN_ALIAS_RID_ADMINS,
                                                   0, 0, 0, 0, 0, 0,
                                                   &psidAdminGroup);
        if (fSuccess)
        {
            // See if the user for this process is a local admin
            fSuccess = CheckTokenMembership_NT(TokenHandle, psidAdminGroup, pfIsAdmin);
            FreeSid_NT(psidAdminGroup);
        }

        return fSuccess ? S_OK:E_FAIL;
    }
    else
    {
        // Win9x - every user is an admin
        *pfIsAdmin = TRUE;
        return S_OK;
    }
}

HRESULT GetConnectionByGUID(HDPA hdpaConnections, const GUID* pguid, INetConnection** ppnc)
{
    *ppnc = NULL;
    DWORD nItems = DPA_GetPtrCount(hdpaConnections);
    HRESULT hr = E_FAIL;

    if (nItems)
    {
        DWORD iItem = 0;
        while (iItem < nItems)
        {
            INetConnection* pnc = (INetConnection*) DPA_GetPtr(hdpaConnections, iItem);
            if (pnc)
            {
                GUID guidMatch;
                hr = GetConnectionGUID(pnc, &guidMatch);
                if (SUCCEEDED(hr))
                {
                    if (*pguid == guidMatch)
                    {
                        *ppnc = pnc;
                        (*ppnc)->AddRef();
                        break;
                    }
                }
                // Don't pnc->Release() - its coming from the DPA
            }

            iItem ++;
        }

        if (iItem == nItems)
        {
            // We searched and didn't find
            hr = E_FAIL;
        }
    }

    return hr;
}

HRESULT GUIDsToConnections(PHOMENETSETUPINFO pInfo)
{
    ASSERT(NULL == pInfo->prgncInternal);
    ASSERT(NULL == pInfo->pncExternal);

    HDPA hdpaConnections;
    HRESULT hr = GetConnections(&hdpaConnections);
    if (SUCCEEDED(hr))
    {
        // Get internal connections by GUID (allocate an extra one for null-terminated array, as elsewhere)
        pInfo->prgncInternal = (INetConnection**) LocalAlloc(LPTR, (pInfo->cguidInternal + 1) * sizeof (INetConnection*));

        if (pInfo->prgncInternal)
        {
            DWORD iConnection = 0;
            while ((iConnection < pInfo->cguidInternal) && SUCCEEDED(hr))
            {
                hr = GetConnectionByGUID(hdpaConnections, pInfo->prgguidInternal + iConnection, pInfo->prgncInternal + iConnection);
                iConnection++;
            }

            pInfo->cncInternal = iConnection;
        }
        else
        {
            hr = E_OUTOFMEMORY;
        }

        if (SUCCEEDED(hr) && (GUID_NULL != pInfo->guidExternal))
        {
            // Get external connection
            hr = GetConnectionByGUID(hdpaConnections, &(pInfo->guidExternal), &(pInfo->pncExternal));
        }

        DPA_DestroyCallback(hdpaConnections, FreeConnectionDPACallback, NULL);
        hdpaConnections = NULL;
    }

    if (FAILED(hr))
    {
        FreeExternalConnection(pInfo);
        FreeInternalConnections(pInfo);
    }

    pInfo->guidExternal = GUID_NULL;
    FreeInternalGUIDs(pInfo);

    return hr;
}

HRESULT GetConnectionGUID(INetConnection* pnc, GUID* pguid)
{
    NETCON_PROPERTIES* pncprops;
    HRESULT hr = pnc->GetProperties(&pncprops);
    if (SUCCEEDED(hr))
    {
        *pguid = pncprops->guidId;
        NcFreeNetconProperties(pncprops);
    }

    return hr;
}

HRESULT ConnectionsToGUIDs(PHOMENETSETUPINFO pInfo)
{
    HRESULT hr = S_OK;
    ASSERT(NULL == pInfo->prgguidInternal);
    ASSERT(GUID_NULL == pInfo->guidExternal);

    // Allocate the private connection guid array
    if (pInfo->cncInternal)
    {
        pInfo->prgguidInternal = (GUID*) LocalAlloc(LPTR, pInfo->cncInternal * sizeof (GUID));
        if (pInfo->prgguidInternal)
        {
            // Get each connection's GUID and fill in the array
            DWORD i = 0;
            while ((i < pInfo->cncInternal) && (SUCCEEDED(hr)))
            {
                hr = GetConnectionGUID(pInfo->prgncInternal[i], &(pInfo->prgguidInternal[i]));

                i++;
            }

            pInfo->cguidInternal = i;
        }
        else
        {
            hr = E_OUTOFMEMORY;
        }
    }

    if (SUCCEEDED(hr))
    {
        if (pInfo->pncExternal)
        {
            hr = GetConnectionGUID(pInfo->pncExternal, &(pInfo->guidExternal));
        }
    }

    if (FAILED(hr) && pInfo->prgguidInternal)
    {
        FreeInternalGUIDs(pInfo);
        pInfo->guidExternal = GUID_NULL;
    }

    FreeExternalConnection(pInfo);
    FreeInternalConnections(pInfo);

    return hr;
}


HRESULT ConfigureHomeNetwork(PHOMENETSETUPINFO pInfo)
{
    HRESULT hr = E_FAIL;

    if (pInfo->fAsync)
    {
        if (g_fRunningOnNT)
        {
            // Bundle up NT specific data for cross-thread
            hr = ConnectionsToGUIDs(pInfo);
        }
        else
        {
            // TODO: Anything necessary on win9x
            hr = S_OK;
        }

        if (SUCCEEDED(hr))
        {
            if (SHCreateThread(ConfigureHomeNetworkThread, pInfo, CTF_COINIT, NULL))
            {
                hr = S_FALSE;
            }
            else
            {
                hr = E_FAIL;
            }
        }
    }
    else
    {
        hr = ConfigureHomeNetworkSynchronous(pInfo);
    }

    return hr;
}

DWORD WINAPI ConfigureHomeNetworkThread(void* pvData)
{
    PHOMENETSETUPINFO pInfo = (PHOMENETSETUPINFO) pvData;

    // Before creating this thread, the caller MUST have freed his INetConnection*'s or
    // else the thread might touch/free them, which it must not do. Assert this.
    ASSERT(NULL == pInfo->pncExternal);
    ASSERT(NULL == pInfo->prgncInternal);

    HRESULT hr;

    if (g_fRunningOnNT)
    {
        // Unbundle data after crossing the thread boundary
        hr = GUIDsToConnections(pInfo);
    }
    else
    {
        // TODO: Anything necessary for Win9x
        hr = S_OK;
    }

    if (SUCCEEDED(hr))
    {
        hr = ConfigureHomeNetworkSynchronous(pInfo);

        FreeExternalConnection(pInfo);
        FreeInternalConnections(pInfo);

        if ((pInfo->hwnd) && (pInfo->umsgAsyncNotify))
        {
            // The HRESULT from the configuration is passed in WPARAM
            PostMessage(pInfo->hwnd, pInfo->umsgAsyncNotify, (WPARAM) hr, 0);
        }
    }

    return 0;
}

HRESULT ConfigureHomeNetworkSynchronous(PHOMENETSETUPINFO pInfo)
{
    g_logFile.Initialize("%systemroot%\\nsw.log");

    HRESULT hr = S_OK;

#ifdef NO_CONFIG
    g_logFile.Write("UI Test only - no configuration\r\n");
    g_logFile.Uninitialize();
    Sleep(2000);

#ifdef FAKE_REBOOTREQUIRED
    pInfo->fRebootRequired = TRUE;
#endif

    return S_OK;
#endif

    BOOL fInstallSharing = TRUE;
    BOOL fSharingAlreadyInstalled = IsSharingInstalled(TRUE);
    BOOL fInstalledWorkgroup = FALSE;

    // We don't need to install sharing unless we're sharing something
    if (!(pInfo->dwFlags & (HNET_SHAREFOLDERS | HNET_SHAREPRINTERS)))
    {
        g_logFile.Write("No file or printer sharing requested\r\n");
        fInstallSharing = FALSE;
    }

    // Worker function for the whole wizard

    // Computer name
    if ((pInfo->dwFlags & HNET_SETCOMPUTERNAME) && (*(pInfo->szComputer)))
    {
        SetComputerNameIfNecessary(pInfo->szComputer, &(pInfo->fRebootRequired));
        SetComputerDescription(pInfo->szComputerDescription);
    }

    // Workgroup name
    if ((pInfo->dwFlags & HNET_SETWORKGROUPNAME) && (*(pInfo->szWorkgroup)))
    {
        Install_SetWorkgroupName(pInfo->szWorkgroup, &(pInfo->fRebootRequired));

        fInstalledWorkgroup = TRUE;
    }

    // Install TCP/IP
    hr = InstallTCPIP(pInfo->hwnd, NULL, NULL);
    if (NETCONN_NEED_RESTART == hr)
    {
        pInfo->fRebootRequired = TRUE;
        hr = S_OK;
    }

    if (FAILED(hr))
    {
        g_logFile.Write("Failed to install TCP/IP\r\n");
    }

    // Install Client for Microsoft Networks
    // TODO: figure out what to do if NetWare client is installed!?!?
    hr = InstallMSClient(pInfo->hwnd, NULL, NULL);
    if (NETCONN_NEED_RESTART == hr)
    {
        pInfo->fRebootRequired = TRUE;
        hr = S_OK;
    }

    if (FAILED(hr))
    {
        g_logFile.Write("Failed to install Client for Microsoft Networks.\r\n");
    }

    // Install sharing
    if (fInstallSharing)
    {
        hr = InstallSharing(pInfo->hwnd, NULL, NULL);
        if (NETCONN_NEED_RESTART == hr)
        {
            pInfo->fRebootRequired = TRUE;
            hr = S_OK;
        }

        if (FAILED(hr))
        {
            g_logFile.Write("Failed to install File and Printer Sharing.\r\n");
        }
    }

    // TODO: What to do about share level vs. user level access control on windows 9x???

    // TODO: What to do about autodialing? Are we assuming this will already be done for us? 9x and NT? I think so!
    if ( g_fRunningOnNT )
    {
        // We only set autodial here if we are configuring an ICS Client
        // In the case that we explicitly set a public adapter then ConfigureICSBridgeFirewall
        // will set autodial if required.
        if ( pInfo->dwFlags & HNET_ICSCLIENT )
        {
            hr = HrSetAutodial( AUTODIAL_MODE_NO_NETWORK_PRESENT );
        }
    }
    else
    {
        if ( pInfo->ipaExternal != -1 )
        {
            if (W9xIsAdapterDialUp(&pInfo->pNA[LOWORD(pInfo->ipaExternal)]))  // Dialup adapter for connecting to internet
            {
                g_logFile.Write("Setting default dial-up connection to autodial.\r\n");
                SetDefaultDialupConnection((pInfo->pRas[HIWORD(pInfo->ipaExternal)]).szEntryName);
                EnableAutodial(TRUE);
            }
            else
            {
                g_logFile.Write("Disabling autodial since default connection isn't dial-up.\r\n");
                SetDefaultDialupConnection(NULL);
                EnableAutodial(FALSE);
            }
        }
    }

    // Configure ICS, the Bridge and the personal firewall
    if (g_fRunningOnNT)
    {
        hr = ConfigureICSBridgeFirewall(pInfo);
    }
    else
    {
        // ICS client or no internet connection.
        if ((pInfo->dwFlags & HNET_ICSCLIENT) || (pInfo->pNA && pInfo->ipaExternal == -1))
        {
            CICSInst* pICS = new CICSInst;
            if (pICS)
            {                    
                if (pICS->IsInstalled())
                {
                    pICS->m_option = ICS_UNINSTALL;

                    g_logFile.Write("Uninstalling ICS Client.\r\n");

                    pICS->DoInstallOption(&(pInfo->fRebootRequired), pInfo->ipaInternal);
                }

                delete pICS;
            }
            
            if ( (pInfo->dwFlags & HNET_ICSCLIENT) && (pInfo->pNA && pInfo->ipaInternal != -1))
            {
                UINT ipa;
                
                for ( ipa=0; ipa<pInfo->cNA; ipa++ )
                {
                    const NETADAPTER* pNA = &pInfo->pNA[ ipa ];
            
                    if ( W9xIsValidAdapter( pNA, CONN_INTERNAL ) && 
                        !W9xIsValidAdapter( pNA, CONN_UNPLUGGED ) )
                    {
                        HrEnableDhcp( (void*)pNA, HNW_ED_RELEASE|HNW_ED_RENEW );
                    }
                }
            }

            g_logFile.Write("Disabling autodial.\r\n");
            SetDefaultDialupConnection(NULL);
            EnableAutodial(FALSE);
        }
    }

    // NOTE: we might want to split HNET_SHAREFOLDERS out into two
    // bits: HNET_CREATESHAREDFOLDERS and HNET_SHARESHAREDFOLDERS
    //
    if (pInfo->dwFlags & (HNET_SHAREPRINTERS | HNET_SHAREFOLDERS))
    {
        // Due to domain/corporate security concerns, share things
        // iff we're setting up a workgroup, or we're already on one
        //
        BOOL fOnWorkgroup = fInstalledWorkgroup;
        if (!fOnWorkgroup)
        {
            if (g_fRunningOnNT)
            {
                LPTSTR pszDomain;
                NETSETUP_JOIN_STATUS njs;
                if (NERR_Success == NetGetJoinInformation(NULL, &pszDomain, &njs))
                {
                    NetApiBufferFree(pszDomain);

                    fOnWorkgroup = (NetSetupWorkgroupName == njs);
                }
            }
            else
            {
                fOnWorkgroup = TRUE;  // there may be some registry key we can check for this
            }
        }

        if (fOnWorkgroup)
        {
            EnableSimpleSharing();

            if (fSharingAlreadyInstalled)
            {
                if (pInfo->dwFlags & HNET_SHAREPRINTERS)
                {
                    ShareAllPrinters();
                }

                if (pInfo->dwFlags & HNET_SHAREFOLDERS)
                {
                    ShareWellKnownFolders(pInfo);
                }
            }
            else
            {
                // Write the sharing info to the registry - do required work on reboot
                g_logFile.Write("Sharing isn't installed. Will share folders and printers on reboot.\r\n");
                pInfo->fRebootRequired = TRUE;
                WriteSetupInfoToRegistry(pInfo);
            }
        }
    }

    if (pInfo->fRebootRequired)
    {
        g_logFile.Write("Reboot is required for changes to take effect.\r\n");
    }

    g_logFile.Uninitialize();

    // Kick off the netcrawler
    INetCrawler *pnc;
    if (SUCCEEDED(CoCreateInstance(CLSID_NetCrawler, NULL, CLSCTX_LOCAL_SERVER, IID_PPV_ARG(INetCrawler, &pnc))))
    {
        pnc->Update(0x0);
        pnc->Release();
    }

#ifdef FAKE_REBOOTREQUIRED
    pInfo->fRebootRequired = TRUE;
#endif

    return hr;
}

void STDMETHODCALLTYPE ConfigurationLogCallback(LPCWSTR pszLogEntry, LPARAM lParam)
{
    g_logFile.Write(pszLogEntry);
}

typedef BOOL (APIENTRY* PFNNETSETUPICSUPGRADE)(BOOL);
HRESULT ConfigureICSBridgeFirewall(PHOMENETSETUPINFO pInfo)
{
    HRESULT hr = E_FAIL;

    // Call HNetSetShareAndBridgeSettings directly
    BOOLEAN fSharePublicConnection = (pInfo->pncExternal && (pInfo->dwFlags & HNET_SHARECONNECTION)) ? TRUE : FALSE;
    BOOLEAN fFirewallPublicConnection = (pInfo->pncExternal && (pInfo->dwFlags & HNET_FIREWALLCONNECTION)) ? TRUE : FALSE;

    if (fSharePublicConnection)
    {
        g_logFile.Write("Will attempt to share public connection.\r\n");
    }

    if (fFirewallPublicConnection)
    {
        g_logFile.Write("Will attempt to firewall public connection.\r\n");
    }

    HMODULE hHNetCfg = LoadLibrary(L"hnetcfg.dll");
    if (hHNetCfg)
    {
        INetConnection* pncPrivate = NULL;

        LPFNHNETSETSHAREANDBRIDGESETTINGS pfnHNetSetShareAndBridgeSettings

        = reinterpret_cast<LPFNHNETSETSHAREANDBRIDGESETTINGS>

            (GetProcAddress(hHNetCfg, "HNetSetShareAndBridgeSettings"));

        if (pfnHNetSetShareAndBridgeSettings)
        {
            hr = (*pfnHNetSetShareAndBridgeSettings)( pInfo->pncExternal,
                                                      pInfo->prgncInternal,
                                                      fSharePublicConnection,
                                                      fFirewallPublicConnection,
                                                      ConfigurationLogCallback,
                                                      0,
                                                      &pncPrivate );
            if (SUCCEEDED(hr))
            {
                if ( ( HNET_ICSCLIENT & pInfo->dwFlags ) &&
                    ( NULL == pInfo->prgncInternal[1] ) )
                {
                    HrEnableDhcp( pInfo->prgncInternal[0], HNW_ED_RELEASE|HNW_ED_RENEW );
                }
                
                // If we are sharing an external adapter then set WinInet settings to allow
                // for an existing connection created from ICS client traffic.
                
                if ( pInfo->pncExternal )
                {
                    hr = HrSetAutodial( AUTODIAL_MODE_NO_NETWORK_PRESENT );
                }
                
                if ( pncPrivate )
                {
                    pncPrivate->Release();
                }
            }
            else
            {
                g_logFile.Write("Adapter Configuration for Home Networking failed.\r\n");
            }
        }
        else
        {
            TraceMsg(TF_WARNING, "HNetCfg.DLL could not find HNetSetShareAndBridgeSettings");
        }

        FreeLibrary(hHNetCfg);
    }
    else
    {
        TraceMsg(TF_WARNING, "HNetCfg.DLL could not be loaded");
    }

    return hr;
}

BOOL MachineHasNetShares()
{
    SHARE_INFO* prgShares;
    int cShares = EnumLocalShares(&prgShares);
    
    // See if there are any file or print shares, which are the ones we care about
    BOOL fHasShares = FALSE;
    for (int i = 0; i < cShares; i++)
    {
        if ((STYPE_DISKTREE == prgShares[i].bShareType) ||
            (STYPE_PRINTQ   == prgShares[i].bShareType))
        {
            fHasShares = TRUE;
            break;
        }
    }
    NetApiBufferFree(prgShares);
    return fHasShares;
}


// Checks if guest access mode is enabled. If guest access mode is OFF but
// in the indeterminate state (ForceGuest is not set), and the m/c has no net shares,
// then we set ForceGuest to 1 and return TRUE.
//
// This indeterminate state occurs only on win2k->XP upgrade.

BOOL
EnsureGuestAccessMode(
    VOID
    )
{
    BOOL fIsGuestAccessMode = FALSE;

    if (IsOS(OS_PERSONAL))
    {
        // Guest mode is always on for Personal
        fIsGuestAccessMode = TRUE;
    }
    else if (IsOS(OS_PROFESSIONAL) && !IsOS(OS_DOMAINMEMBER))
    {
        LONG    ec;
        HKEY    hkey;

        // Professional, not in a domain. Check the ForceGuest value.

        ec = RegOpenKeyEx(
                    HKEY_LOCAL_MACHINE,
                    TEXT("SYSTEM\\CurrentControlSet\\Control\\LSA"),
                    0,
                    KEY_QUERY_VALUE | KEY_SET_VALUE,
                    &hkey
                    );

        if (ec == NO_ERROR)
        {
            DWORD dwValue;
            DWORD dwValueSize = sizeof(dwValue);

            ec = RegQueryValueEx(hkey,
                                 TEXT("ForceGuest"),
                                 NULL,
                                 NULL,
                                 (LPBYTE)&dwValue,
                                 &dwValueSize);

            if (ec == NO_ERROR)
            {
                if (1 == dwValue)
                {
                    // ForceGuest is already on
                    fIsGuestAccessMode = TRUE;
                }
            }
            else
            {
                // Value doesn't exist
                if (!MachineHasNetShares())
                {
                    // Machine has no shares
                    dwValue = 1;
                    ec = RegSetValueEx(hkey,
                                       TEXT("ForceGuest"),
                                       0,
                                       REG_DWORD,
                                       (BYTE*) &dwValue,
                                       sizeof (dwValue));

                    if (ec == NO_ERROR)
                    {
                        // Write succeeded - guest access mode is enabled
                        fIsGuestAccessMode = TRUE;
                    }
                }
            }

            RegCloseKey(hkey);
        }
    }

    return fIsGuestAccessMode;
}


// It is assumed the machine is not joined to a domain when this is called!
HRESULT EnableSimpleSharing()
{
    HRESULT hr = S_FALSE;

    if (EnsureGuestAccessMode())
    {
        ILocalMachine *pLM;
        hr = CoCreateInstance(CLSID_ShellLocalMachine, NULL, CLSCTX_INPROC_SERVER, IID_PPV_ARG(ILocalMachine, &pLM));

        if (SUCCEEDED(hr))
        {
            TraceMsg(TF_ALWAYS, "Enabling Guest Account");

            hr = pLM->EnableGuest(ILM_GUEST_NETWORK_LOGON);
            pLM->Release();

            SendNotifyMessage(HWND_BROADCAST, WM_SETTINGCHANGE, 0, 0);
        }
    }

    return hr;    
}

#define INVALID_COMPUTERNAME_CHARS L" {|}~[\\]^':;<=>?@!\"#$%^`()+/*&"
#define INVALID_WORKGROUP_CHARS    L"{|}~[\\]^':;<=>?!\"#$%^`()+/*&"
#define INVALID_TRAILING_CHAR      L' '

BOOL IsValidNameSyntax(LPCWSTR pszName, NETSETUP_NAME_TYPE type)
{
    // Only support workgroup and machine - need to add new charsets if
    // required
    ASSERT(type == NetSetupWorkgroup || type == NetSetupMachine);

    LPCWSTR pszInvalid = (type == NetSetupWorkgroup) ? INVALID_WORKGROUP_CHARS : INVALID_COMPUTERNAME_CHARS;
    BOOL    fValid     = TRUE;
    WCHAR*  pch        = (LPWSTR) pszName;
    
    if ( *pch && ( NetSetupWorkgroup == type ) )
    {
        // remove trailing blanks

        WCHAR* pchLast = pch + wcslen(pch) - 1;
        
        while ( (INVALID_TRAILING_CHAR == *pchLast) && (pchLast >= pch) )
        {
            *pchLast = NULL;
            pchLast--;
        }
    }
    
    fValid = ( *pch ) ? TRUE : FALSE;

    while (*pch && fValid)
    {
        fValid = (NULL == StrChrW(pszInvalid, *pch));
        pch ++;
    }
    
    return fValid;
}

void BoldControl(HWND hwnd, int id)
{
    HWND hwndTitle = GetDlgItem(hwnd, id);

    // Get the existing font
    HFONT hfontOld = (HFONT) SendMessage(hwndTitle, WM_GETFONT, 0, 0);

    LOGFONT lf = {0};
    if (GetObject(hfontOld, sizeof(lf), &lf))
    {
        lf.lfWeight = FW_BOLD;

        HFONT hfontNew = CreateFontIndirect(&lf);
        if (hfontNew)
        {
            SendMessage(hwndTitle, WM_SETFONT, (WPARAM) hfontNew, FALSE);

            // Don't do this, its shared.
            // DeleteObject(hfontOld);
        }
    }
}

void ShowControls(HWND hwndParent, const int *prgControlIDs, DWORD nControls, int nCmdShow)
{
    for (DWORD i = 0; i < nControls; i++)
        ShowWindow(GetDlgItem(hwndParent, prgControlIDs[i]), nCmdShow);
}

void HelpCenter(HWND hwnd, LPCWSTR pszTopic)
{
    // use ShellExecuteExA for w98 compat.

    CHAR szURL[1024];
    wsprintfA(szURL, "hcp://services/layout/contentonly?topic=ms-its%%3A%%25help_location%%25\\%S", pszTopic);

    SHELLEXECUTEINFOA shexinfo = {0};
    shexinfo.cbSize = sizeof (shexinfo);
    shexinfo.fMask = SEE_MASK_FLAG_NO_UI;
    shexinfo.nShow = SW_SHOWNORMAL;
    shexinfo.lpFile = szURL;
    shexinfo.lpVerb = "open";

    // since help center doesn't properly call AllowSetForegroundWindow when it defers to an existing process we just give it to the next taker.
    
    HMODULE hUser32 = GetModuleHandleA("user32.dll");
    if(NULL != hUser32)
    {
        BOOL (WINAPI *pAllowSetForegroundWindow)(DWORD);
        
        pAllowSetForegroundWindow = reinterpret_cast<BOOL (WINAPI*)(DWORD)>(GetProcAddress(hUser32, "AllowSetForegroundWindow"));
        if(NULL != pAllowSetForegroundWindow)
        {
            pAllowSetForegroundWindow(-1);
        }
    }

    ShellExecuteExA(&shexinfo);
}

void CHomeNetworkWizard::ShowMeLink(HWND hwnd, LPCWSTR pszTopic)
{

    if (pfnShowHTMLDialog == NULL)
    {
        hinstMSHTML = LoadLibrary(TEXT("MSHTML.DLL"));

        if (hinstMSHTML)
        {
            pfnShowHTMLDialog = (SHOWHTMLDIALOGEXFN*)GetProcAddress(hinstMSHTML, "ShowHTMLDialogEx");
        }

        // can not find ShowHTMLDialog API.  Do nothing.
        if (pfnShowHTMLDialog == NULL)
            return;
    }

    WCHAR szURL[1024];
    HRESULT hr;
    VARIANT_BOOL isClosed = VARIANT_FALSE;

    // check to see if the dialog window is closed.  If so, release it so that a new one
    // will be created.
    if (showMeDlgWnd != NULL)
    {
        if (SUCCEEDED(showMeDlgWnd->get_closed(&isClosed)))
        { 
            if (isClosed == VARIANT_TRUE)
            {
                showMeDlgWnd->Release();
                showMeDlgWnd = NULL;

                if (pFrameWindow != NULL)
                {
                    pFrameWindow->Release();
                    pFrameWindow = NULL;
                }
            }
        }
        else
        {
            return;
        }
    }

    const char *helpLoc = getenv("help_location");
    
    LPWSTR lpszWinDir;     // pointer to system information string 
    WCHAR tchBuffer[MAX_PATH];  // buffer for concatenated string 

    // if unset use the default location.
    lpszWinDir = tchBuffer;
    GetWindowsDirectory(lpszWinDir, MAX_PATH);
    
    if (showMeDlgWnd == NULL)
    {    
        BSTR bstrFrameURL;        
        // need to create a new dialog window. 
        if (helpLoc != NULL)
            wnsprintfW(szURL, 1024, L"ms-its:%S\\ntart.chm::/hn_ShowMeFrame.htm", helpLoc);
        else
            wnsprintfW(szURL, 1024, L"ms-its:%s\\help\\ntart.chm::/hn_ShowMeFrame.htm", lpszWinDir);

        bstrFrameURL = SysAllocString((const LPCWSTR)szURL);

        if (bstrFrameURL == NULL)
            return;

        IMoniker * pURLMoniker = NULL;

        CreateURLMoniker(NULL, bstrFrameURL, &pURLMoniker);

        if (pURLMoniker != NULL)
        {
            VARIANT  varReturn;
            
            VariantInit(&varReturn);
            
            DWORD dwFlags = HTMLDLG_MODELESS | HTMLDLG_VERIFY;

            hr = (*pfnShowHTMLDialog)(
                    NULL, 
                    pURLMoniker,
                    dwFlags,
                    NULL, 
                    L"scroll:no;help:no;status:no;dialogHeight:394px;dialogWidth:591px;", 
                    &varReturn);

            if (SUCCEEDED(hr))
            {
                hr = V_UNKNOWN(&varReturn)->QueryInterface(__uuidof(IHTMLWindow2), (void**)&showMeDlgWnd);

            }    
            
            pURLMoniker->Release();
            VariantClear(&varReturn);
        }

        SysFreeString(bstrFrameURL);
    }

    // we don't have a dialog window to work with so quit silently.
    if (showMeDlgWnd == NULL)
    {
        return;
    }

    // we need get the frame window where the actual html page will be displayed.
    if (pFrameWindow == NULL)
    {
        VARIANT index;
        VARIANT frameOut;
        long frameLen = 0;

        VariantInit(&index);
        VariantInit(&frameOut);

        IHTMLFramesCollection2* pFramesCol = NULL;
        // we may not be able to get the frames the first time around.  So try some more.
        int i = 5;
        while (i-- > 0)
        {

            if(!SUCCEEDED(showMeDlgWnd->get_frames(&pFramesCol)))
            {
                // can not get frames. so quit.
                break;
            }
            else
                if (!SUCCEEDED(pFramesCol->get_length(&frameLen)))
                {
                    // can not determine how many frames it has.  so quit.
                    break;
                }
                else
                {
                    if (frameLen > 0)
                    {
                        V_VT(&index) = VT_I4;
                        V_I4(&index) = 0;
    
                        if (SUCCEEDED(pFramesCol->item(&index, &frameOut)))
                        {
                            if (V_VT(&frameOut) == VT_DISPATCH && V_DISPATCH(&frameOut) != NULL)
                            {
                                hr = V_DISPATCH(&frameOut)->QueryInterface(__uuidof(IHTMLWindow2), (void**)&pFrameWindow);

                            }    
                        }
                        // found at least one frame.  jump out of the loop.
                        break;
                    }
                }

            if (pFramesCol != NULL)
                pFramesCol->Release();

            Sleep(1000);
        }

        if (pFramesCol != NULL)
            pFramesCol->Release();

        VariantClear(&index);
        VariantClear(&frameOut);
    }
    
    if (pFrameWindow == NULL)
        return;

    // now to load in the actual html page    
    BSTR bstrURL;
    if (helpLoc != NULL)
        wnsprintf(szURL, 1024, L"ms-its:%S\\%s", helpLoc, pszTopic);
    else
        wnsprintf(szURL, 1024, L"ms-its:%s\\help\\%s", lpszWinDir, pszTopic);

    bstrURL = SysAllocString((const LPCWSTR)szURL);
    if (bstrURL == NULL)
        return;
    
    hr = pFrameWindow->navigate(bstrURL);
    hr = showMeDlgWnd->focus();
    
    SysFreeString(bstrURL);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\hnw\wizard\shell.cpp ===
// we can link to these directly instead of implementing them ourselves...
//

void ILFree(LPITEMIDLIST pidl)
{
    LPMALLOC pMalloc;
    if (SUCCEEDED(SHGetMalloc(&pMalloc)))
    {
        pMalloc->Free(pidl);
        pMalloc->Release();
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\hnw\wizard\resource.h ===
// Random stuff 1-99
#define IDB_WATERMARK                   1
#define IDB_HEADER                      2
#define IDA_CONFIG                      3
#define IDA_LOWCOLORCONFIG              4

// Misc Strings 100 - 999
#define IDS_APPTITLE                    100
#define IDS_SHAREDDOCS                  101
#define IDS_SHAREDDOCSCOMMENT           102
#define IDS_SHAREDDOCS_SHARENAME        103
#define IDS_SHARENAME                   104
#define IDS_ADDPRINTER_APPEND           105
#define IDS_SHARECOMMENT                106
#define IDS_MYDOCS                      107
#define IDS_MYDOCS_SHARENAME            108
#define IDS_DEFAULT_WORKGROUP1          109
#define IDS_DEFAULT_WORKGROUP2          110
#define IDS_ICS_HOST                    111
#define IDS_OTHERNAT_GENERIC            112
#define IDS_OTHERNAT_GENERIC_THE        113
#define IDS_ERR_OTHERNAT                114
#define IDS_ICSMSG                      115
#define IDS_NETTYPE_START               116
#define IDS_NETTYPE_LAN                 116
#define IDS_NETTYPE_DIALUP              117
#define IDS_NETTYPE_IRDA                118
#define IDS_NETTYPE_PPTP                119
#define IDS_NETTYPE_TV                  120
#define IDS_NETTYPE_ISDN                121
#define IDS_NETTYPE_UNKNOWN             122
// Leave 123-129 for future nettypes
#define IDS_PRINTER                     130
#define IDS_UNIDENTIFIED_ICS_DEVICE     131
#define IDS_SUMMARY_INETSETTINGS        132
#define IDS_SUMMARY_INETCON             133
#define IDS_SUMMARY_ICSENABLED          134
#define IDS_SUMMARY_FIREWALLENABLED     135
#define IDS_SUMMARY_UNDERLINE           136
#define IDS_SUMMARY_HNETSETTINGS        137
#define IDS_SUMMARY_COMPDESC            138
#define IDS_SUMMARY_COMPNAME            139
#define IDS_SUMMARY_WORKGROUP           140
#define IDS_SUMMARY_SHARING             141
#define IDS_SUMMARY_BRIDGESETTINGS      142
#define IDS_sUMMARY_CONNECTTHROUGH      143
#define IDS_SUMMARY_CONNECTTHROUGH2     144
#define IDS_SUMMARY_HOMENETCON          145
#define IDS_SHARE_TEXT                  146
#define IDS_INETSELECTMSG               147
#define IDS_HELP_INSTALLATION           148
#define IDS_HELP_HARDWAREREQ            149
#define IDS_HELP_SELECTPUBLIC           150
#define IDS_HELP_BRIDGE                 151
#define IDS_HELP_SHARING                152
#define IDS_HELP_SHAREDDOCS             153
#define IDS_HELP_FIREWALL               154
#define IDS_COMPNAME_INVALID            155
#define IDS_COMPNAME_DUPLICATE          156
#define IDS_HELP_COMPNAME               157
#define IDS_HELP_HNCONFIG               158
#define IDS_HELP_ICSCONFLICT            159
#define IDS_COMPNAME_TOOMANYBYTES       160
#define IDS_WORKGROUP_TOOMANYBYTES      161

// Wizard page header/subheader strings 1000-1999
#define IDS_HEADER_WELCOME              1000
#define IDS_SUBHEADER_WELCOME           1001
#define IDS_HEADER_CONNECT              1002
#define IDS_SUBHEADER_CONNECT           1003
#define IDS_HEADER_PUBLIC               1004
#define IDS_SUBHEADER_PUBLIC            1005
#define IDS_HEADER_FINISH               1006
#define IDS_SUBHEADER_FINISH            1007
#define IDS_WIZ_CAPTION                 1008
#define IDS_HEADER_PRIVATE              1009
#define IDS_SUBHEADER_PRIVATE           1010
#define IDS_HEADER_FOUNDICS             1011
#define IDS_SUBHEADER_FOUNDICS          1012
#define IDS_HEADER_NAME                 1013
#define IDS_SUBHEADER_NAME              1014
#define IDS_TITLE_FONT                  1015
#define IDS_TITLE_POINTSIZE             1016
#define IDS_HEADER_DOMAINWELCOME        1017
#define IDS_SUBHEADER_DOMAINWELCOME     1018
#define IDS_MYSHAREDDOCUMENTS           1020
#define IDS_HEADER_EDGELESS             1021
#define IDS_SUBHEADER_EDGELESS          1022
#define IDS_HEADER_NOTADMIN             1023
#define IDS_SUBHEADER_NOTADMIN          1024
#define IDS_HEADER_NOPERMISSIONS        1025
#define IDS_SUBHEADER_NOPERMISSIONS     1026
#define IDS_HEADER_SUMMARY              1027
#define IDS_SUBHEADER_SUMMARY           1028
#define IDS_HEADER_BRIDGEWARNING        1029
#define IDS_SUBHEADER_BRIDGEWARNING     1030
#define IDS_HEADER_NOHARDWARE           1031
#define IDS_SUBHEADER_NOHARDWARE        1032
#define IDS_HEADER_NOHWFINISH           1033
#define IDS_SUBHEADER_NOHWFINISH        1034
#define IDS_HEADER_PROGRESS             1035
#define IDS_SUBHEADER_PROGRESS          1036
#define IDS_HEADER_CONFIGERROR          1037
#define IDS_SUBHEADER_CONFIGERROR       1038
#define IDS_ERR_NAMEINUSE               1039
#define IDS_HEADER_MANUALCONFIG         1040
#define IDS_SUBHEADER_MANUALCONFIG      1041
#define IDS_RECOMMENDEDCONN             1042
#define IDS_HEADER_NOHARDWAREFINISH     1043
#define IDS_SUBHEADER_NOHARDWAREFINISH  1044
#define IDS_HEADER_ALMOSTDONE           1045
#define IDS_SUBHEADER_ALMOSTDONE        1046
#define IDS_HEADER_CONNECTOTHER         1047
#define IDS_SUBHEADER_CONNECTOTHER      1048
#define IDS_CURRENTNAME                 1049
#define IDS_HELP_RECOMMENDED            1050
#define IDS_HELP_CONFIGERROR            1051
#define IDS_HEADER_ICSCONFLICT          1052
#define IDS_SUBHEADER_ICSCONFLICT       1053
#define IDS_STILLICSCONFLICT            1054
#define IDS_HEADER_UNPLUGGED            1055
#define IDS_SUBHEADER_UNPLUGGED         1056
#define IDS_STILLUNPLUGGED              1057
#define IDS_HEADER_WRONGOS              1058
#define IDS_SUBHEADER_WRONGOS           1059
#define IDS_HEADER_CHOOSEDISK           1062
#define IDS_SUBHEADER_CHOOSEDISK        1063
#define IDS_HEADER_INSERTDISK           1064
#define IDS_SUBHEADER_INSERTDISK        1065
#define IDS_NOREMOVABLEDRIVES           1066
#define IDS_HEADER_FLOPPYINST           1068
#define IDS_SUBHEADER_FLOPPYINST        1069
#define IDS_COPYING                     1070
#define IDS_HEADER_CDINST               1071
#define IDS_SUBHEADER_CDINST            1072
#define IDS_CD_NOREBOOT                 1073
#define IDS_FLOPPY_NOREBOOT             1074
#define IDS_HEADER_WORKGROUP            1075
#define IDS_SUBHEADER_WORKGROUP         1076
#define IDS_WORKGROUP_INVALID           1077
#define IDS_SHOWME                      1078

// Dialogs 2000-2999
#define IDD_WIZ_WELCOME                 2000
#define IDD_WIZ_CONNECT                 2001
#define IDD_WIZ_PUBLIC                  2002
#define IDD_WIZ_FINISH                  2003
#define IDD_WIZ_PRIVATE                 2004
#define IDD_WIZ_FOUNDICS                2005
#define IDD_WIZ_NAME                    2006
#define IDD_WIZ_EDGELESS                2007
#define IDD_WIZ_DOMAINWELCOME           2008
#define IDD_WIZ_NOTADMIN                2009
#define IDD_WIZ_NOPERMISSIONS           2010
#define IDD_WIZ_WIN9X_WELCOME           2011
#define IDD_WIZ_SUMMARY                 2012
#define IDD_WIZ_BRIDGEWARNING           2013
#define IDD_WIZ_NOHARDWARE              2014
#define IDD_WIZ_NOHWFINISH              2015
#define IDD_WIZ_PROGRESS                2016
#define IDD_WIZ_CONFIGERROR             2017
#define IDD_WIZ_MANUALCONFIG            2018
#define IDD_WIZ_WIN9X_FINISH            2019
#define IDD_WIZ_NOHARDWAREFINISH        2020
#define IDD_WIZ_ALMOSTDONE              2021
#define IDD_WIZ_WIN9X_CONNECT           2022
#define IDD_WIZ_CONNECTOTHER            2023
#define IDD_WIZ_ICSCONFLICT             2024
#define IDD_WIZ_UNPLUGGED               2025
#define IDD_WIZ_WRONGOS                 2026
#define IDD_WIZ_CHOOSEDISK              2027
#define IDD_WIZ_INSERTDISK              2028
#define IDD_WIZ_FLOPPYINST              2029
#define IDD_WIZ_CDINST                  2030
#define IDD_WIZ_WORKGROUP               2031

// Controls 4000-4999
#define IDC_COMPUTERDESC                4000
#define IDC_TITLE                       4001
#define IDC_PROGRESS                    4002
#define IDC_MANUALBRIDGE                4003
#define IDC_CONNLIST                    4007
#define IDC_SHARECONNECT                4008
#define IDC_ICSMSG                      4009
#define IDC_CHANGELIST                  4011
#define IDC_WORKGROUPDEFAULT            4012
#define IDC_WORKGROUPSPECIFY            4013
#define IDC_WORKGROUPSTATIC             4014
#define IDC_COMPUTERNAME                4015
#define IDC_SELECTMSG                   4018
#define IDC_AUTOBRIDGE                  4019
#define IDC_ISPWARN1                    4021
#define IDC_ISPWARN2                    4022
#define IDC_HELPSTATIC                  4023
#define IDC_HELPLINK                    4024
#define IDC_HELPSTATIC2                 4025
#define IDC_HELPLINK2                   4026
#define IDC_ICSHOST                     4027
#define IDC_ICSCLIENT                   4028
#define IDC_ALLCOMPUTERSDIRECT          4029
#define IDC_NOHOMENETWORK               4030
#define IDC_NOINTERNET                  4031
#define IDC_SHARE                       4032
#define IDC_DONTSHARE                   4033
#define IDC_HELPICON                    4034
#define IDC_LISTLABEL                   4035
#define IDC_OTHER                       4036
#define IDC_CURRENTNAME                 4037
#define IDC_KNOWNCONFLICT1              4039
#define IDC_KNOWNCONFLICT2              4040
#define IDC_KNOWNCONFLICT3              4041
#define IDC_KNOWNCONFLICT4              4042
#define IDC_KNOWNCONFLICT5              4043
#define IDC_KNOWNCONFLICT6              4044
#define IDC_KNOWNCONFLICT7              4045
#define IDC_KNOWNCONFLICT8              4046
#define IDC_UNKNOWNCONFLICT1            4047
#define IDC_UNKNOWNCONFLICT2            4048
#define IDC_IGNORE                      4049
#define IDC_HAVECD                      4050
#define IDC_DONTHAVECD                  4051
#define IDC_CREATEDISK                  4052
#define IDC_DEVICELIST                  4053
#define IDC_DISK                        4054
#define IDC_FORMAT                      4055
#define IDC_HAVEDISK                    4056
#define IDC_FINISHNOW                   4057
#define IDC_INSTRUCTIONS                4058
#define IDC_WORKGROUP                   4059
#define IDC_SHOWMESTATIC1               4060
#define IDC_SHOWMESTATIC2               4061
#define IDC_SHOWMESTATIC3               4062
#define IDC_SHOWMESTATIC4               4063
#define IDC_SHOWMESTATIC5               4064
#define IDC_SHOWMELINK1                 4065
#define IDC_SHOWMELINK2                 4066
#define IDC_SHOWMELINK3                 4067
#define IDC_SHOWMELINK4                 4068
#define IDC_SHOWMELINK5                 4069

// ** Resources whose IDs must not change **
// Localized resources for shortcuts
// Don't move or change 3085 or 3086 - they're referenced from outside the .dll (MUI support for homenetwiz shortcut)
#define IDS_SHORTCUT_DISPLAYNAME        3085
#define IDS_SHORTCUT_INFOTIP            3086

// Icons 10000-11000
//
// Note:
//  Low numbers are bad for icons, because when we pop them into selfreg.inx
//  and reference them by "binary,-id" the shell code gets all confused.  It
//  is currently using small negative numbers (such as -1, -2) for its own
//  nefarious plans, so when we pass in something like "binary,-1" we don't
//  get back whatever we mapped #define IDI_ICON 1 to, as we would expect.
//
#define IDI_APPICON                     10000
#define IDI_HELP                        10001
#define IDI_INFO                        10002
#define IDI_WARN                        10003
#define IDI_HNW                         10004
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\hnw\wizard\prnutil.cpp ===
//
// PrnUtil.cpp
//

#include "stdafx.h"
#include "PrnUtil.h"
#include "Sharing.h"
#include "msprintx.h"
#include "NetUtil.h"
#include "TheApp.h"
#include "cwnd.h"


/////////////////////////////////////////////////////////////////////////////
// static data

static BOOL _bInit = FALSE;
static HMODULE _hShell32 = NULL;
static HMODULE _hMSPrint2 = NULL;
static BOOL (STDAPICALLTYPE *_pfnSHInvokePrinterCommand)(HWND, UINT, LPCTSTR, LPCTSTR, BOOL) = NULL;
static BOOL (STDAPICALLTYPE *_pfnSHHelpShortcuts)(HWND, HINSTANCE, LPSTR, int) = NULL;
static BOOL (STDAPICALLTYPE *_pfnPrinterSetup32)(HWND, WORD, WORD, LPBYTE, LPWORD) = NULL;



/////////////////////////////////////////////////////////////////////////////
// Initialization of function thunks

void InitPrinterFunctions()
{
    if (!_bInit)
    {
        _bInit = TRUE;

        _hShell32 = LoadLibrary(TEXT("shell32.dll"));
        if (_hShell32 != NULL)
        {
            *(FARPROC*)&_pfnSHInvokePrinterCommand = GetProcAddress(_hShell32, "SHInvokePrinterCommandA");
            *(FARPROC*)&_pfnSHHelpShortcuts = GetProcAddress(_hShell32, "SHHelpShortcuts_RunDLL");
        }

        if (theApp.IsWindows9x())
        {
            _hMSPrint2 = LoadLibrary(TEXT("msprint2.dll"));
            if (_hMSPrint2 != NULL)
            {
                *(FARPROC*)&_pfnPrinterSetup32 = GetProcAddress(_hMSPrint2, MSPRINT2_PRINTERSETUP32);
            }
        }
        else
        {
            // NTs version of this function moved to a new dll and a different name
            _hMSPrint2 = LoadLibrary(TEXT("printui.dll"));
            if (_hMSPrint2 != NULL)
            {
                *(FARPROC*)&_pfnPrinterSetup32 = GetProcAddress(_hMSPrint2, "bPrinterSetup");
            }
        }
    }
}


/////////////////////////////////////////////////////////////////////////////
// MyEnumPrinters
//
//      Enumerates local or remote connected printers, allocates an array
//      of PRINTER_ENUM structs for the result, and returns the number of
//      printers found.
//
//      pprgPrinters - gets filled with an array of PRINTER_ENUM structs
//                     allocated via malloc().
//
//      dwEnumFlags  - one or more of:
//                          MY_PRINTER_ENUM_REMOTE
//                          MY_PRINTER_ENUM_LOCAL
//                          MY_PRINTER_ENUM_LOCAL
//
int MyEnumPrinters(PRINTER_ENUM** pprgPrinters, DWORD dwEnumFlags)
{
    PRINTER_ENUM* prgPrinters = NULL;
    int cMatchingPrinters = 0;

    ASSERT(sizeof(PRINTER_INFO_5A) == sizeof(PRINTER_INFO_5W)); // to handle thunking

    DWORD cb = 0;
    DWORD cAllPrinters = 0;
    EnumPrinters(PRINTER_ENUM_LOCAL, NULL, 5, NULL, 0, &cb, &cAllPrinters);
    if (cb > 0)
    {
        PRINTER_INFO_5* prgPrinterInfo5 = (PRINTER_INFO_5*)malloc(cb);
        if (prgPrinterInfo5)
        {
            if (EnumPrinters(PRINTER_ENUM_LOCAL, NULL, 5, (LPBYTE)prgPrinterInfo5, cb, &cb, &cAllPrinters))
            {
                ASSERT(cAllPrinters > 0);

                // How much space will the strings take?
                DWORD cbArray = cAllPrinters * sizeof(PRINTER_INFO_5);
                DWORD cbStrings = cb - cbArray;

                // Allocate out [OUT] buffer
                prgPrinters = (PRINTER_ENUM*)malloc(cAllPrinters*sizeof(PRINTER_ENUM) + cbStrings);
                if (prgPrinters)
                {
                    // set up text portion of output buffer and thunking/copying function
                    //
                    LPTSTR pszPrinterText = (LPTSTR)(prgPrinters + cAllPrinters);
                    UINT cchStrings = cbStrings/sizeof(WCHAR);

                    // NT and 9X do defaultness differently...
                    TCHAR szDefaultPrinter[MAX_PATH];
                    szDefaultPrinter[0]=TEXT('\0');
                    if (!theApp.IsWindows9x())
                    {
                        DWORD cch = ARRAYSIZE(szDefaultPrinter);
                        GetDefaultPrinter(szDefaultPrinter, &cch);
                    }

                    // Fill in the output buffer
                    for (DWORD i = 0; i < cAllPrinters; i++)
                    {
                        BOOL bKeepThisPrinter = FALSE;
                        DWORD dwFlags = 0;

                        if (theApp.IsWindows9x())
                        {
                            PRINTER_INFO_5* pPrinterInfo5 = (PRINTER_INFO_5*)&prgPrinterInfo5[i];
                            if (pPrinterInfo5->pPortName[0] == L'\\' && pPrinterInfo5->pPortName[1] == L'\\')
                            {
                                // Found a remote, connected printer
                                if (dwEnumFlags & MY_PRINTER_ENUM_REMOTE)
                                {
                                    bKeepThisPrinter = TRUE;
                                    dwFlags |= PRF_REMOTE;
                                }
                            }
                            else if (0 == StrCmpI(pPrinterInfo5->pPortName, L"FILE:"))
                            {
                                // Found a pseudo printer
                                if (dwEnumFlags & MY_PRINTER_ENUM_VIRTUAL)
                                {
                                    bKeepThisPrinter = TRUE;
                                    dwFlags |= PRF_VIRTUAL;
                                }
                            }
                            else if (StrStr(pPrinterInfo5->pPortName, L"FAX"))
                            {
                                // Found a pseudo printer
                                if (dwEnumFlags & MY_PRINTER_ENUM_VIRTUAL)
                                {
                                    bKeepThisPrinter = TRUE;
                                    dwFlags |= PRF_VIRTUAL;
                                }
                            }
                            else
                            {
                                // Found a local printer
                                if (dwEnumFlags & MY_PRINTER_ENUM_LOCAL)
                                {
                                    bKeepThisPrinter = TRUE;
                                    dwFlags |= PRF_LOCAL;
                                }
                            }
                        }
                        else // handle NT
                        {
                            PRINTER_INFO_5* pPrinterInfo5 = (PRINTER_INFO_5*)&prgPrinterInfo5[i];
                            if (pPrinterInfo5->pPortName[0] == _T('\\') && pPrinterInfo5->pPortName[1] == _T('\\'))
                            {
                                // Found a remote, connected printer
                                if (dwEnumFlags & MY_PRINTER_ENUM_REMOTE)
                                {
                                    bKeepThisPrinter = TRUE;
                                    dwFlags |= PRF_REMOTE;
                                }
                            }
                            else if (0 == StrCmpI(pPrinterInfo5->pPortName, _T("FILE:")))
                            {
                                // Found a pseudo printer
                                if (dwEnumFlags & MY_PRINTER_ENUM_VIRTUAL)
                                {
                                    bKeepThisPrinter = TRUE;
                                    dwFlags |= PRF_VIRTUAL;
                                }
                            }
                            else if (StrStr(pPrinterInfo5->pPortName, _T("FAX")))
                            {
                                // Found a pseudo printer
                                if (dwEnumFlags & MY_PRINTER_ENUM_VIRTUAL)
                                {
                                    bKeepThisPrinter = TRUE;
                                    dwFlags |= PRF_VIRTUAL;
                                }
                            }
                            else
                            {
                                // Found a local printer
                                if (dwEnumFlags & MY_PRINTER_ENUM_LOCAL)
                                {
                                    bKeepThisPrinter = TRUE;
                                    dwFlags |= PRF_LOCAL;
                                }
                            }
                        }

                        if (bKeepThisPrinter)
                        {
                            PRINTER_INFO_5* pPrinterInfo5 = (PRINTER_INFO_5*)&prgPrinterInfo5[i];
                            PRINTER_ENUM* pPrinter = &prgPrinters[cMatchingPrinters++];
                            int cch;

                            StrCpyNW(pszPrinterText, pPrinterInfo5->pPrinterName, cchStrings);
                            cch = lstrlenW(pszPrinterText) + 1;
                            pPrinter->pszPrinterName = pszPrinterText;
                            pszPrinterText += cch;
                            cchStrings -= cch;

                            StrCpyNW(pszPrinterText, pPrinterInfo5->pPortName, cchStrings);
                            cch = lstrlenW(pszPrinterText) + 1;
                            pPrinter->pszPortName = pszPrinterText;
                            pszPrinterText += cch;
                            cchStrings -= cch;

                            // update some flags before we cache them away
                            //
                            if (!(dwFlags&PRF_REMOTE) && IsPrinterShared(pPrinter->pszPrinterName))
                            {
                                dwFlags |= PRF_SHARED;
                            }

                            if ((pPrinterInfo5->Attributes & PRINTER_ATTRIBUTE_DEFAULT)
                                || (0 == StrCmpI(szDefaultPrinter, pPrinterInfo5->pPrinterName)))
                            {
                                dwFlags |= PRF_DEFAULT;
                            }

                            pPrinter->dwFlags = dwFlags;
                        }
                    }

                    // didn't find anything, throw away our output buffer
                    if (cMatchingPrinters == 0 && prgPrinters != NULL)
                    {
                        free(prgPrinters);
                        prgPrinters = NULL;
                    }
                }
            }

            free(prgPrinterInfo5);
        }
    }

    *pprgPrinters = prgPrinters;

    return cMatchingPrinters;
}

int MyEnumLocalPrinters(PRINTER_ENUM** prgPrinters)
{
    return MyEnumPrinters(prgPrinters, MY_PRINTER_ENUM_LOCAL);
}

int MyEnumRemotePrinters(PRINTER_ENUM** prgPrinters)
{
    return MyEnumPrinters(prgPrinters, MY_PRINTER_ENUM_REMOTE);
}


/////////////////////////////////////////////////////////////////////////////
// AddPrinterHookProc

class CAddPrinterHook : public CWnd
{
public:
    CAddPrinterHook(LPCTSTR pszAppendWindowTitle, HWND hwndOwner);

    void Release() { CWnd::Release(); };

    void Done(BOOL bResult);

protected:
    static LRESULT CALLBACK AddPrinterHookProcStatic(int nCode, WPARAM wParam, LPARAM lParam);
    ~CAddPrinterHook();

    LRESULT WindowProc(UINT message, WPARAM wParam, LPARAM lParam);
    LRESULT AddPrinterHookProc(int nCode, WPARAM wParam, LPARAM lParam);

    HHOOK m_hAddPrinterHook;
    HWND  m_hWndAddPrinterParent;
    LPTSTR m_pszAppendWindowTitle;
};

// global hooks have no state, must use global to get back to our data
static CAddPrinterHook * g_pCAddPrinterHook = NULL;

CAddPrinterHook::CAddPrinterHook(LPCTSTR pszAppendWindowTitle, HWND hwndOwner)
{
    ASSERT(NULL == g_pCAddPrinterHook);
    g_pCAddPrinterHook = this;

    m_pszAppendWindowTitle = lstrdup(pszAppendWindowTitle);
    m_hWndAddPrinterParent = hwndOwner;

    // Set a hook so we can modify the title of the add printer wizard when it pops up
    m_hAddPrinterHook = SetWindowsHookEx(WH_CBT, AddPrinterHookProcStatic, NULL, GetCurrentThreadId());
}

CAddPrinterHook::~CAddPrinterHook()
{
    ASSERT(this == g_pCAddPrinterHook);
    g_pCAddPrinterHook = NULL;

    if (m_pszAppendWindowTitle)
        free(m_pszAppendWindowTitle);

    CWnd::~CWnd();
}

void CAddPrinterHook::Done(BOOL bResult)
{
    // TRUE==bResult if the window was launched.
    //
    // FALSE => no window to watch, so remove our hook as it'll never come up
    // TRUE  => if the window is on the same thread, we've already seen it and unhooked
    //          but if the window is on another thread, it may not come up it so don't unhook.
    //          EXCEPT, we may never see it.  So be safe and always unhook...
    //
    if (m_hAddPrinterHook != NULL)
    {
        if (bResult)
        {
            TraceMsg(TF_WARNING, "CAddPrinterHook::Done(TRUE) called but m_hAddPrinterHook still exists...");
        }
        UnhookWindowsHookEx(m_hAddPrinterHook);
        m_hAddPrinterHook = NULL;
    }
}

LRESULT CAddPrinterHook::WindowProc(UINT message, WPARAM wParam, LPARAM lParam)
{
    LPTSTR pszTempText = NULL;

    switch (message)
    {
    case WM_SETTEXT:
        if (m_pszAppendWindowTitle)
        {
            pszTempText = new TCHAR [lstrlen(m_pszAppendWindowTitle) + lstrlen((LPCTSTR)lParam) + 1];
            if (pszTempText)
            {
                StrCpy(pszTempText, (LPCTSTR)lParam);
                StrCat(pszTempText, m_pszAppendWindowTitle);
                lParam = (LPARAM)pszTempText;
            }
        }
        break;
    }

    LRESULT lResult = Default(message, wParam, lParam);

    delete [] pszTempText;
    return lResult;
}


LRESULT CALLBACK CAddPrinterHook::AddPrinterHookProcStatic(int nCode, WPARAM wParam, LPARAM lParam)
{
    CAddPrinterHook* pThis = g_pCAddPrinterHook; // global hook -- we have no associated state!
    if (pThis)
        return pThis->AddPrinterHookProc(nCode, wParam, lParam);
    else
        return 0;
}

LRESULT CAddPrinterHook::AddPrinterHookProc(int nCode, WPARAM wParam, LPARAM lParam)
{
    LRESULT lResult = CallNextHookEx(m_hAddPrinterHook, nCode, wParam, lParam);

    if (nCode == HCBT_CREATEWND)
    {
        HWND hwndNew = (HWND)wParam;
        CBT_CREATEWND* pCreateWnd = (CBT_CREATEWND*)lParam;
        if (pCreateWnd->lpcs->hwndParent == m_hWndAddPrinterParent &&
            (pCreateWnd->lpcs->style & WS_POPUP) != 0)
        {
            UnhookWindowsHookEx(m_hAddPrinterHook);
            m_hAddPrinterHook = NULL;

            Attach(hwndNew);
        }
    }

    return lResult;
}


/////////////////////////////////////////////////////////////////////////////
// ConnectToNetworkPrinter

BOOL ConnectToNetworkPrinter(HWND hWndOwner, LPCTSTR pszPrinterShare)
{
    InitPrinterFunctions();

    BOOL bResult;
    LPTSTR pszAppendWindowTitle = NULL;

    LPTSTR pszPrettyName = FormatShareNameAlloc(pszPrinterShare);
    if (pszPrettyName)
    {
        pszAppendWindowTitle = theApp.FormatStringAlloc(IDS_ADDPRINTER_APPEND, pszPrettyName);
        free(pszPrettyName);
    }
    CAddPrinterHook * paph = new CAddPrinterHook(pszAppendWindowTitle, hWndOwner);
    if (pszAppendWindowTitle)
        free(pszAppendWindowTitle);
 
    if (_pfnSHInvokePrinterCommand != NULL)
    {
        // First: Try to call SHInvokePrinterCommand, if available.
        // This only works on systems with the IE4 desktop enhancements installed.

        bResult = (*_pfnSHInvokePrinterCommand)(hWndOwner, PRINTACTION_NETINSTALL, pszPrinterShare, NULL, TRUE);
    }
    else if (_pfnPrinterSetup32 != NULL)
    {
        // Next: Try to call PrinterSetup32, if available.

        WORD cch = lstrlen(pszPrinterShare) + 1;
        BYTE* pPrinterShare = (BYTE*)malloc(cch);
        StrCpy((LPTSTR)pPrinterShare, pszPrinterShare);
        bResult = (*_pfnPrinterSetup32)(hWndOwner, MSP_NETPRINTER, cch, pPrinterShare, &cch);
        free(pPrinterShare);
    }
    else if (_pfnSHHelpShortcuts != NULL)
    {
        // Neither of the above APIs was available.
        // Instead, just launch the Add Printer Wizard.

        bResult = (*_pfnSHHelpShortcuts)(hWndOwner, _hShell32, "AddPrinter", SW_SHOW);
    }
    else
    {
        // Yikes, we can't even launch the Add Printer Wizard!
        bResult = FALSE;
    }

    if (paph)
    {
        paph->Done(bResult);
        paph->Release();
    }

    return bResult;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\hnw\wizard\sharing.h ===
//
// Sharing.h
//
//        Utility functions to help with file and printer sharing.
//

#pragma once

#include "mysvrapi.h"

// Flags defining access to shared resources
#define NETACCESS_NONE            0
#define NETACCESS_READONLY        1
#define NETACCESS_FULL            2
#define NETACCESS_DEPENDSON       (NETACCESS_READONLY | NETACCESS_FULL)
#define NETACCESS_MASK            (NETACCESS_READONLY | NETACCESS_FULL)

#define NETFLAGS_PERSIST          0x0100 // share lasts past a reboot
#define NETFLAGS_SYSTEM           0x0200 // share is not visible to users


#define DRIVESHARE_SOME           1
#define DRIVESHARE_ALL            2


#define SHARE_NAME_LENGTH         12 // same as LM20_NNLEN from lmcons.h
#define SHARE_PASSWORD_LENGTH     8  // same as SHPWLEN from svrapi.h

#include <pshpack1.h>

// Note: this struct is identical to SHARE_INFO_502
typedef struct _SHARE_INFO
{
    LPWSTR    szShareName;  //shi502_netname;
    DWORD     bShareType;   //shi502_type;
    LPWSTR    shi502_remark;
    DWORD     uFlags;       //shi502_permissions;
    DWORD     shi502_max_uses;
    DWORD     shi502_current_uses;
    LPWSTR    pszPath;      //shi502_path;
    LPWSTR    shi502_passwd;
    DWORD     shi502_reserved;
    PSECURITY_DESCRIPTOR  shi502_security_descriptor;
} SHARE_INFO;

#include <poppack.h>


int EnumLocalShares(SHARE_INFO** pprgShares);
int EnumSharedDrives(LPBYTE pbDriveArray, int cShares, const SHARE_INFO* prgShares);
int EnumSharedDrives(LPBYTE pbDriveArray);
BOOL ShareFolder(LPCTSTR pszPath, LPCTSTR pszShareName, DWORD dwAccess, LPCTSTR pszReadOnlyPassword = NULL, LPCTSTR pszFullAccessPassword = NULL);
BOOL UnshareFolder(LPCTSTR pszPath);
BOOL IsFolderSharedEx(LPCTSTR pszPath, BOOL bDetectHidden, BOOL bPrinter, int cShares, const SHARE_INFO* prgShares);
BOOL IsFolderShared(LPCTSTR pszPath, BOOL bDetectHidden = FALSE);
BOOL ShareNameFromPath(LPCTSTR pszPath, LPTSTR pszShareName, UINT cchShareName);
BOOL IsVisibleFolderShare(const SHARE_INFO* pShare);
BOOL IsShareNameInUse(LPCTSTR pszShareName);
void MakeSharePersistent(LPCTSTR pszShareName);
BOOL SetShareInfo502(LPCTSTR pszShareName, SHARE_INFO_502* pShare);
BOOL GetShareInfo502(LPCTSTR pszShareName, SHARE_INFO_502** ppShare);
BOOL SharePrinter(LPCTSTR pszPrinterName, LPCTSTR pszShareName, LPCTSTR pszPassword = NULL);
BOOL IsPrinterShared(LPCTSTR pszPrinterName);
BOOL SetSharePassword(LPCTSTR pszShareName, LPCTSTR pszReadOnlyPassword, LPCTSTR pszFullAccessPassword);
BOOL GetSharePassword(LPCTSTR pszShareName, LPTSTR pszReadOnlyPassword, DWORD cchRO, LPTSTR pszFullAccessPassword, DWORD cchFA);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\hnw\wizard\sharing.cpp ===
//
// Sharing.cpp
//
//        Utility functions to help with file and printer sharing.
//
//        To use these functions, you need to add SvrApi.cpp to your project,
//        and call its InitSvrApiThunk() function at startup.
//
// History:
//
//         5/17/1999  KenSh     Created for JetNet
//        10/05/1999  KenSh     Adapted for Home Networking Wizard
//        10/19/1999  KenSh     Added AreAdvancedFoldersShared
//

#include "stdafx.h"
#include "Sharing.h"
#include "MySvrApi.h"
#include "MyDocs.h"
#include "Util.h"
#include <regstr.h>
#include <lm.h>
#include "theapp.h"
#include "newapi.h"

#include <msshrui.h>    // SetFolderPermissionsForSharing

#define NET_API_STATUS    DWORD
#define API_RET_TYPE    NET_API_STATUS



// Allocates array of shares using malloc(), returns number of shares
int EnumLocalShares(SHARE_INFO** pprgShares)
{
    SHARE_INFO_502* prgShares = NULL;
    DWORD dwShares;
    DWORD dwTotalShares;

    if (NERR_Success == NetShareEnum(NULL, 502, (LPBYTE*)&prgShares, MAX_PREFERRED_LENGTH, &dwShares, &dwTotalShares, NULL))
    {
        // We defined SHARE_INFO to mimic SHARE_INFO_502, even though we ignore
        // all but four fields of it.
        *pprgShares = (SHARE_INFO*)prgShares;
        return (int)dwShares;
    }
    else
    {
        *pprgShares = NULL;
        return 0;
    }
}


// EnumSharedDrives
//
//        Use this version if you've already enumerated shares via EnumLocalShares().
//
//        pbDriveArray is an array of 26 bytes, one for each possible shared drive.
//        Each entry is filled with a NETACCESS flag (defined in Sharing.h): 0 if not 
//        shared, 1 if read-only, 2 if read-write, 3 if depends-on-password.
//
//        Return value is number of drives shared.
//
int EnumSharedDrives(LPBYTE pbDriveArray, int cShares, const SHARE_INFO* prgShares)
{
    ZeroMemory(pbDriveArray, 26);
    int cDrives = 0;

    for (int i = 0; i < cShares; i++)
    {
        LPCTSTR pszPath = prgShares[i].pszPath;

        if (pszPath[1] == _T(':') && pszPath[2] == _T('\\')) // is it a folder
        {
            if (pszPath[3] == _T('\0')) // is it a whole drive
            {
                TCHAR ch = (TCHAR)CharUpper((LPTSTR)(prgShares[i].pszPath[0]));
                ASSERT (ch >= _T('A') && ch <= _T('Z'));

                pbDriveArray[ch - _T('A')] = (BYTE)(prgShares[i].uFlags & NETACCESS_MASK);
                cDrives += 1;
            }
        }
    }

    return cDrives;
}

// Use this version of EnumSharedDrives if you haven't called EnumLocalShares()
int EnumSharedDrives(LPBYTE pbDriveArray)
{
    SHARE_INFO* prgShares;
    int cShares = EnumLocalShares(&prgShares);
    int cDrives = EnumSharedDrives(pbDriveArray, cShares, prgShares);
    NetApiBufferFree(prgShares);
    return cDrives;
}

// Helper function for ShareFolder() (and SharePrinter on 9x)
BOOL ShareHelper(LPCTSTR pszPath, LPCTSTR pszShareName, DWORD dwAccess, BYTE bShareType, LPCTSTR pszReadOnlyPassword, LPCTSTR pszFullAccessPassword)
{
    ASSERTMSG(pszReadOnlyPassword==NULL, "ShareHelper doesn't support roPassword");

    SHARE_INFO_502 si;

    si.shi502_netname = (LPTSTR)pszShareName;
    //CharUpperA(si.shi50_netname);

    si.shi502_type = bShareType;
    si.shi502_remark = NULL;
    si.shi502_permissions = ACCESS_ALL;
    si.shi502_max_uses = -1;
    si.shi502_current_uses = -1;

    TCHAR szPath[MAX_PATH];
    if (bShareType == STYPE_DISKTREE)
    {
        StrCpyN(szPath, pszPath, ARRAYSIZE(szPath));
        CharUpper(szPath);
        si.shi502_path = szPath;
    }
    else
    {
        si.shi502_path = (LPWSTR)pszPath;
    }

    si.shi502_passwd = (pszFullAccessPassword) ? (LPTSTR)pszFullAccessPassword : L"";
    si.shi502_reserved = NULL;
    si.shi502_security_descriptor = NULL;

    if (NO_ERROR != NetShareAdd(NULL, 502, (LPBYTE)&si))
    {
        return FALSE;
    }

    MakeSharePersistent(pszShareName);

    return TRUE;
}

// dwAccess is NETACCESS_READONLY, NETACCESS_FULL, or NETACCESS_DEPENDSON
// Either or both passwords may be NULL.  For simplicity, you can pass the 
// same password for both, even if you're only sharing read-only or full-access.
BOOL ShareFolder(LPCTSTR pszPath, LPCTSTR pszShareName, DWORD dwAccess, LPCTSTR pszReadOnlyPassword, LPCTSTR pszFullAccessPassword)
{
    ASSERT(pszPath != NULL);
    ASSERT(pszShareName != NULL);
    ASSERT(dwAccess == NETACCESS_READONLY || dwAccess == NETACCESS_FULL || dwAccess == NETACCESS_DEPENDSON);

    BOOL bResult = ShareHelper(pszPath, pszShareName, dwAccess, STYPE_DISKTREE, pszReadOnlyPassword, pszFullAccessPassword);
    if (bResult)
    {
        SHChangeNotify(SHCNE_NETSHARE, SHCNF_PATH, pszPath, NULL);

        // On NT, make sure the folder permissions are set correctly
        HINSTANCE hInstNtShrUI = LoadLibrary(TEXT("ntshrui.dll"));
        if (hInstNtShrUI != NULL)
        {
            PFNSETFOLDERPERMISSIONSFORSHARING pfn = (PFNSETFOLDERPERMISSIONSFORSHARING)GetProcAddress(hInstNtShrUI, "SetFolderPermissionsForSharing");
            if (pfn != NULL)
            {
                // level 3 means "shared read/write"
                // level 2 means "shared read-only"
                (*pfn)(pszPath, NULL, dwAccess == NETACCESS_FULL ? 3 : 2, NULL);
            }
            FreeLibrary(hInstNtShrUI);
        }
    }

    return bResult;
}

BOOL UnshareFolder(LPCTSTR pszPath)
{
    TCHAR szShareName[SHARE_NAME_LENGTH+1];
    BOOL bResult = FALSE;

    if (ShareNameFromPath(pszPath, szShareName, ARRAYSIZE(szShareName)))
    {
        if (NO_ERROR == NetShareDel(NULL, szShareName, 0))
        {
            SHChangeNotify(SHCNE_NETUNSHARE, SHCNF_PATH, pszPath, NULL);
            bResult = TRUE;

            // On NT, make sure the folder permissions are set correctly
            HINSTANCE hInstNtShrUI = LoadLibrary(TEXT("ntshrui.dll"));
            if (hInstNtShrUI != NULL)
            {
                PFNSETFOLDERPERMISSIONSFORSHARING pfn = (PFNSETFOLDERPERMISSIONSFORSHARING)GetProcAddress(hInstNtShrUI, "SetFolderPermissionsForSharing");
                if (pfn != NULL)
                {
                    // level 1 means "not shared"
                    (*pfn)(pszPath, NULL, 1, NULL);
                }
                FreeLibrary(hInstNtShrUI);
            }
        }
    }

    return bResult;
}

BOOL ShareNameFromPath(LPCTSTR pszPath, LPTSTR pszShareName, UINT cchShareName)
{
    BOOL bResult = FALSE;
    *pszShareName = _T('\0');

    SHARE_INFO* prgShares;
    int cShares = EnumLocalShares(&prgShares);

    for (int i = 0; i < cShares; i++)
    {
        if (0 == StrCmpI(prgShares[i].pszPath, pszPath))
        {
            StrCpyN(pszShareName, prgShares[i].szShareName, cchShareName);
            bResult = TRUE;
            break;
        }
    }

    NetApiBufferFree(prgShares);
    return bResult;
}

BOOL IsVisibleFolderShare(const SHARE_INFO* pShare)
{
    return (pShare->bShareType == STYPE_DISKTREE &&
            pShare->szShareName[lstrlen(pShare->szShareName) - 1] != _T('$'));
}

BOOL IsShareNameInUse(LPCTSTR pszShareName)
{
    LPBYTE pbuf;
    BOOL bResult = (NERR_Success == NetShareGetInfo(NULL, pszShareName, 502, &pbuf));
    if (bResult)
        NetApiBufferFree(pbuf);

    return bResult;
}

// Note: this function works for printers too
BOOL IsFolderSharedEx(LPCTSTR pszPath, BOOL bDetectHidden, BOOL bPrinter, int cShares, const SHARE_INFO* prgShares)
{
    BYTE bShareType = (bPrinter ? STYPE_PRINTQ : STYPE_DISKTREE);

    for (int i = 0; i < cShares; i++)
    {
        const SHARE_INFO* pShare = &prgShares[i];

        if (pShare->bShareType == bShareType &&
            (bDetectHidden || IsVisibleFolderShare(pShare)) &&
            0 == StrCmpI(pShare->pszPath, pszPath))
        {
            return TRUE;
        }
    }

    return FALSE;
}

BOOL IsFolderShared(LPCTSTR pszPath, BOOL bDetectHidden)
{
    SHARE_INFO* prgShares;
    int cShares = EnumLocalShares(&prgShares);
    BOOL bShared = IsFolderSharedEx(pszPath, bDetectHidden, FALSE, cShares, prgShares);
    NetApiBufferFree(prgShares);
    return bShared;
}

void MakeSharePersistent(LPCTSTR pszShareName)
{
    SHARE_INFO_502* pShare2;
    if (GetShareInfo502(pszShareName, &pShare2))
    {
        SetShareInfo502(pShare2->shi502_netname, pShare2);

        // Need to manually add the Path to the registry
        CRegistry reg;
        if (reg.OpenKey(HKEY_LOCAL_MACHINE, REGSTR_KEY_SHARES))
        {
            if (reg.OpenSubKey(pShare2->shi502_netname))
            {
                reg.SetStringValue(REGSTR_VAL_SHARES_PATH, pShare2->shi502_path);
            }
            else if (reg.OpenKey(HKEY_LOCAL_MACHINE, REGSTR_KEY_SHARES) && reg.CreateSubKey(pShare2->shi502_netname))
            {
                // On older downlevel platforms we need to persist this manually.

                DWORD dwFlags = (pShare2->shi502_permissions & (ACCESS_ALL ^ ACCESS_READ)) ? SHI50F_FULL : SHI50F_RDONLY;
                dwFlags |= SHI50F_PERSIST;
                if (pShare2->shi502_type == STYPE_PRINTQ)
                    dwFlags |= 0x0090; // REVIEW: what does this number mean?
                else
                    dwFlags |= 0x0080; // REVIEW: what does this number mean?

                reg.SetDwordValue(REGSTR_VAL_SHARES_FLAGS, dwFlags);
                reg.SetDwordValue(REGSTR_VAL_SHARES_TYPE, (DWORD)pShare2->shi502_type);
                reg.SetStringValue(REGSTR_VAL_SHARES_PATH, pShare2->shi502_path);
                reg.SetStringValue(REGSTR_VAL_SHARES_REMARK, pShare2->shi502_remark);
            }
        }

        NetApiBufferFree(pShare2);
    }

#ifdef OLD_WAY
    // Hack: add the new share to the registry, or else it won't be persisted!
    // REVIEW: surely there must be an API that does this??
    CRegistry reg;
    if (reg.OpenKey(HKEY_LOCAL_MACHINE, REGSTR_KEY_SHARES))
    {
        if (reg.CreateSubKey(pShare->szShareName) ||
            reg.OpenSubKey(pShare->szShareName))
        {
            DWORD dwFlags = pShare->uFlags | SHI50F_PERSIST;
            if (pShare->bShareType == STYPE_PRINTQ)
                dwFlags |= 0x0090; // REVIEW: what does this number mean?
            else
                dwFlags |= 0x0080; // REVIEW: what does this number mean?

            reg.SetDwordValue(REGSTR_VAL_SHARES_FLAGS, dwFlags);
            reg.SetDwordValue(REGSTR_VAL_SHARES_TYPE, (DWORD)pShare->bShareType);
            reg.SetStringValue(REGSTR_VAL_SHARES_PATH, pShare->pszPath);
            reg.SetStringValue(REGSTR_VAL_SHARES_REMARK, pShare->pszComment);
            reg.SetStringValue(REGSTR_VAL_SHARES_RW_PASS, pShare->szPassword_rw);
            reg.SetStringValue(REGSTR_VAL_SHARES_RO_PASS, pShare->szPassword_ro);
//            reg.SetBinaryValue("Parm1enc", "", 0);
//            reg.SetBinaryValue("Parm2enc", "", 0);

            // Note: passwords are encrypted next time the user reboots.
        }
    }
#endif // OLD_WAY
}

BOOL SetShareInfo502(LPCTSTR pszShareName, SHARE_INFO_502* pShare)
{
    BOOL bResult;

    if (StrCmpI(pszShareName, pShare->shi502_netname) != 0)
    {
        // Can't rename an existing share. Unshare and re-share instead.
        bResult = (NO_ERROR == NetShareDel(NULL, pszShareName, 0) &&
                   NO_ERROR == NetShareAdd(NULL, 502, (LPBYTE)pShare));

        if (bResult)
        {
            MakeSharePersistent(pShare->shi502_netname);
        }
    }
    else
    {
        // Change parameters of existing share.
        bResult = (NO_ERROR == NetShareSetInfo(NULL, pszShareName, 502, (LPBYTE)pShare));
    }

    return bResult;
}

BOOL GetShareInfo502(LPCTSTR pszShareName, SHARE_INFO_502** ppShare)
{
    NET_API_STATUS ret = NetShareGetInfo(NULL, pszShareName, 502, (LPBYTE*)ppShare);

    return (NERR_Success == ret);
}

BOOL SharePrinter(LPCTSTR pszPrinterName, LPCTSTR pszShareName, LPCTSTR pszPassword)
{
    ASSERT(pszPrinterName != NULL);
    ASSERT(pszShareName != NULL);

    BOOL fResult = FALSE;
    
    if (g_fRunningOnNT)
    {
        HANDLE hPrinter;
        PRINTER_DEFAULTS pd = {0};
        pd.DesiredAccess = PRINTER_ALL_ACCESS;

        if (OpenPrinter_NT((LPWSTR) pszPrinterName, &hPrinter, &pd))
        {
            DWORD cbBuffer = 0;
            // Get buffer size
            if (!GetPrinter_NT(hPrinter, 2, NULL, 0, &cbBuffer) && cbBuffer)
            {
                PRINTER_INFO_2* pInfo2 = (PRINTER_INFO_2*) LocalAlloc(LPTR, cbBuffer);
                if (pInfo2)
                {
                    if (GetPrinter_NT(hPrinter, 2, (LPBYTE) pInfo2, cbBuffer, &cbBuffer))
                    {
                        if (pInfo2->Attributes & PRINTER_ATTRIBUTE_SHARED)
                        {
                            // Printer is already shared - we're good to go
                            fResult = TRUE;
                        }
                        else
                        {
                            // Share printer
                            pInfo2->Attributes |= PRINTER_ATTRIBUTE_SHARED;
                            if((!pInfo2->pShareName) || (!pInfo2->pShareName[0]))
                            {
                                pInfo2->pShareName = (LPWSTR) pszShareName;
                            }

                            fResult = SetPrinter_NT(hPrinter, 2, (LPBYTE) pInfo2, 0);
                        }
                    }

                    LocalFree(pInfo2);
                }
            }

            ClosePrinter_NT(hPrinter);
        }
    }
    else
    {
        fResult = ShareHelper(pszPrinterName, pszShareName, NETACCESS_FULL, STYPE_PRINTQ, NULL, pszPassword);
        if (fResult)
        {
            Sleep(500); // need to wait for VSERVER to register the changes, same as msprint2
            SHChangeNotify(SHCNE_NETSHARE, SHCNF_PRINTER, pszPrinterName, NULL);
        }
    }

    return fResult;
}

BOOL IsPrinterShared(LPCTSTR pszPrinterName)
{
    SHARE_INFO* prgShares;
    int cShares = EnumLocalShares(&prgShares);
    BOOL bShared = IsFolderSharedEx(pszPrinterName, TRUE, TRUE, cShares, prgShares);
    NetApiBufferFree(prgShares);
    return bShared;
}

BOOL SetSharePassword(LPCTSTR pszShareName, LPCTSTR pszReadOnlyPassword, LPCTSTR pszFullAccessPassword)
{
    SHARE_INFO_502* pShare;
    BOOL bResult = FALSE;

    if (GetShareInfo502(pszShareName, &pShare))
    {
        ASSERTMSG(NULL == pszReadOnlyPassword, "SetSharePassword can't store roPassword");

        if (pszFullAccessPassword == NULL)
            pszFullAccessPassword = TEXT("");
        pShare->shi502_passwd = (LPTSTR)pszFullAccessPassword;

        bResult = SetShareInfo502(pszShareName, pShare);
        NetApiBufferFree(pShare);
    }

    return bResult;
}

BOOL GetSharePassword(LPCTSTR pszShareName, LPTSTR pszReadOnlyPassword, DWORD cchRO, LPTSTR pszFullAccessPassword, DWORD cchFA)
{
    SHARE_INFO_502* pShare;
    BOOL bResult = GetShareInfo502(pszShareName, &pShare);

    if (bResult)
    {
        ASSERTMSG(NULL==pszReadOnlyPassword, "GetSharePassword can't support roPassword");

        if (pszFullAccessPassword != NULL)
            StrCpyN(pszFullAccessPassword, pShare->shi502_passwd, cchFA);

        NetApiBufferFree(pShare);
    }

    return bResult;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\hnw\wizard\shlwapiunwrap.h ===
//
// IE4 shlwapi (which we need to link to) exported its unicode wrappers with their original names (i.e.
// SendMessageW was exported as SendMessageW and the component had to link to shlwapi.lib before user32.lib).
// In order for us to link to the IE4 shlwapi functions the IE5 WrapW names must be undef'ed.
//


#undef SendMessageW
#undef GetDlgItemTextW
#undef LoadStringW
#undef SetWindowLongW
#undef DefWindowProcW
#undef PostMessageW
#undef RegisterWindowMessageW
#undef FindWindowW
#undef CreateDirectoryW
#undef GetFileAttributesW
#undef GetWindowsDirectoryW
#undef RegQueryValueExW
#undef RegOpenKeyW
#undef CharUpperW
#undef GetClassLongW
#undef CreateFontIndirectW
#undef GetObjectW
#undef GetTextMetricsW
#undef DrawTextW
#undef GetTextExtentPoint32W
#undef LoadBitmapW
#undef SetWindowsHookExW
#undef CharNextW
#undef CharLowerW
#undef CreateEventW
#undef LoadCursorW
#undef GetWindowLongW
#undef SendDlgItemMessageW
#undef SetWindowTextW
#undef SetDlgItemTextW
#undef GetWindowTextLengthW
#undef RegOpenKeyExW
#undef GetModuleFileNameW
#undef RegSetValueExW
#undef RegCreateKeyExW
#undef RegDeleteKeyW
#undef RegEnumKeyExW
#undef RegQueryInfoKeyW
#undef RegEnumValueW
#undef RegDeleteValueW
#undef CallWindowProcW
#undef GetWindowTextW
#undef SystemParametersInfoW
#undef CreateFileW


//
// Some static library functions link to shlwapi WrapW functions and the WrapW functions
// aren't defined in IE4 shlwapi.  Create WrapW exports that forward to the correct IE4 shlwapi
// export or HNW wrapper function and have the static libs link to these.
//

#undef GetModuleHandleW
#define GetModuleHandleWrapW GetModuleHandleWrapW_Unwrap

#undef GetWindowsDirectoryW
#define GetWindowsDirectoryWrapW GetWindowsDirectoryWrapW_Unwrap

#undef GetModuleFileNameW
#define GetModuleFileNameWrapW GetModuleFileNameWrapW_Unwrap

#undef CreateWindowExW
#define CreateWindowExWrapW CreateWindowExWrapW_Unwrap

#undef CreateDialogIndirectParamW
#define CreateDialogIndirectParamWrapW CreateDialogIndirectParamWrapW_Unwrap

#undef CreateDialogParamW
#define CreateDialogParamWrapW CreateDialogParamWrapW_Unwrap

#undef DialogBoxIndirectParamW
#define DialogBoxIndirectParamWrapW DialogBoxIndirectParamW_Unwrap

#undef DialogBoxParamW
#define DialogBoxParamWrapW DialogBoxParamWrapW_Unwrap 

#undef RegisterClassW
#define RegisterClassWrapW RegisterClassWrapW_Unwrap

#undef RegisterClassExW
#define RegisterClassExWrapW RegisterClassExWrapW_Unwrap

#undef GetClassInfoW
#define GetClassInfoWrapW GetClassInfoWrapW_Unwrap

#undef GetClassInfoExW
#define GetClassInfoExWrapW GetClassInfoExWrapW_Unwrap

#undef CreateFileW
#define CreateFileWrapW CreateFileWrapW_Unwrap

#undef SetFileAttributesW
#define SetFileAttributesWrapW SetFileAttributesWrapW_Unwrap


#define LoadLibraryWrapW LoadLibraryWrapW_Unwrap
#define SHAnsiToUnicodeCP SHAnsiToUnicodeCP_Unwrap
#define SHUnicodeToAnsi SHUnicodeToAnsi_Unwrap
#define WhichPlatform WhichPlatform_Unwrap
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\hnw\wizard\shlwapiwrap.cpp ===
// shlwapi wrappers
//
// Since the HNW needs to run on win98 and W98 shipped with IE4 shlwapi.dll we need to created wrappers
// for the IE5 shlwapi functions that aren't implemented in IE4 shlwapi.
//

#include "stdafx.h"
#include "cstrinout.h"


//
// Globals
//

DWORD g_dwShlwapiVersion = 0;

//
//  Version helper function.
//

DWORD GetShlwapiVersion()
{
    DWORD dwVersion = 0;

    HMODULE hShlwapi = LoadLibrary(L"shlwapi.dll");

    if (hShlwapi)
    {
        HRESULT (*DllGetVersion)(DLLVERSIONINFO* pdvi) = (HRESULT (*)(DLLVERSIONINFO*))GetProcAddress(hShlwapi, "DllGetVersion");

        if (DllGetVersion)
        {
            DLLVERSIONINFO dvi;

            dvi.cbSize = sizeof(dvi);
            DllGetVersion(&dvi);

            dwVersion = dvi.dwMajorVersion;
        }
        else
        {
            dwVersion = 3;
        }

        FreeLibrary(hShlwapi);
    }

    return dwVersion;
}

//
// wrappers
//

// SHChangeNotify

#undef SHChangeNotify

SHSTDAPI_(void) SHChangeNotify(LONG wEventId, UINT uFlags, LPCVOID dwItem1, LPCVOID dwItem2);

#define SHCNF_HAS_WSTR_PARAMS(f)   ((f & SHCNF_TYPE) == SHCNF_PATHW     ||    \
                                    (f & SHCNF_TYPE) == SHCNF_PRINTERW  ||    \
                                    (f & SHCNF_TYPE) == SHCNF_PRINTJOBW    )

void SHChangeNotify_HNWWrap(LONG wEventId, UINT uFlags, LPCVOID dwItem1, LPCVOID dwItem2)
{
    if (g_dwShlwapiVersion >= 5)
    {
        _SHChangeNotify(wEventId, uFlags, dwItem1, dwItem2);  // delayloaded shlwapi version.
    }
    else
    {
        if (SHCNF_HAS_WSTR_PARAMS(uFlags))
        {
            CStrIn striItem1((LPWSTR)dwItem1);
            CStrIn striItem2((LPWSTR)dwItem2);
        
            if ((uFlags & SHCNF_TYPE) == SHCNF_PATHW)
            {
                uFlags = (uFlags & ~SHCNF_TYPE) | SHCNF_PATHA;
            }
            else if ((uFlags & SHCNF_TYPE) == SHCNF_PRINTERW)
            {
                uFlags = (uFlags & ~SHCNF_TYPE) | SHCNF_PRINTERA;
            }
            else
            {
                uFlags = (uFlags & ~SHCNF_TYPE) | SHCNF_PRINTJOBA;
            }

            SHChangeNotify(wEventId, uFlags, (void*)(LPSTR)striItem1, (void*)(LPSTR)striItem2); // shell32 version.
        }
        else
        {
            SHChangeNotify(wEventId, uFlags, dwItem1, dwItem2);   // shell32 version.
        }
    }

    return;
}


// wsprintf functions.

#undef wvnsprintfW

int wvnsprintfW_HNWWrap(LPWSTR lpOut, int cchLimitIn, LPCWSTR lpFmt, va_list arglist)
{
    int iRet;

    if (g_dwShlwapiVersion >= 5)
    {
        iRet = _wvnsprintfW(lpOut, cchLimitIn, lpFmt, arglist); // shlwapi delayloaded version.
    }
    else
    {
        // Change all %s to %S in the format buffer.
        // Note: this doesn't take into account format modifiers like %-30s!
        char szFmtA[1024];
        SHUnicodeToAnsi_HNWWrap(lpFmt, szFmtA, ARRAYSIZE(szFmtA));

        for (char* psz = szFmtA; *psz != '\0'; psz++)
        {
            if ('%' == psz[0] && 's' == psz[1])
                psz[1] = 'S';
        }

        CStrOut strOut(lpOut, cchLimitIn);

        // use unbounded version.
        iRet = wvsprintfA(strOut, szFmtA, arglist); // user32 version.
    }

    return iRet;
}

int __cdecl wnsprintfW_HNWWrap(LPWSTR lpOut, int cchLimitIn, LPCWSTR lpFmt, ...)
{
    int iRet;

    va_list arglist;
    va_start(arglist, lpFmt);

    iRet = wvnsprintfW_HNWWrap(lpOut, cchLimitIn, lpFmt, arglist);

    va_end(arglist);

    return iRet;
}


// SHSetWindowBits.

void SHSetWindowBits_HNWWrap(HWND hWnd, int iWhich, DWORD dwBits, DWORD dwValue)
{
    if (g_dwShlwapiVersion >= 5)
    {
        _SHSetWindowBits(hWnd, iWhich, dwBits, dwValue);
    }
    else
    {
        DWORD dwStyle = GetWindowLong(hWnd, iWhich);
        DWORD dwNewStyle = (dwStyle & ~dwBits) | (dwValue & dwBits);
        if (dwStyle != dwNewStyle) 
        {
            SetWindowLong(hWnd, iWhich, dwNewStyle);
        }
    }

    return;
}


// SHAnsiToUnicode

int SHAnsiToUnicode_HNWWrap(LPCSTR pszSrc, LPWSTR pwszDst, int cwchBuf)
{
    int iRet;

    if (g_dwShlwapiVersion >= 5)
    {
        iRet = _SHAnsiToUnicode(pszSrc, pwszDst, cwchBuf);
    }
    else
    {
        iRet = MultiByteToWideChar(CP_ACP, 0, pszSrc, -1, pwszDst, cwchBuf);
    }

    return iRet;
}


// SHUnicodeToAnsi

int SHUnicodeToAnsi_HNWWrap(LPCWSTR pwszSrc, LPSTR pszDst, int cchBuf)
{
    int iRet;

    if (g_dwShlwapiVersion >= 5)
    {
        iRet = _SHUnicodeToAnsi(pwszSrc, pszDst, cchBuf);
    }
    else
    {
        iRet = WideCharToMultiByte(CP_ACP, 0, pwszSrc, -1, pszDst, cchBuf, NULL, NULL);
    }

    return iRet;
}


// GUIDFromStringA

#undef CLSIDFromString
WINOLEAPI CLSIDFromString(IN LPOLESTR lpsz, OUT LPCLSID pclsid);

BOOL GUIDFromStringA_HNWWrap(LPCSTR psz, GUID* pguid)
{
    BOOL fRet;

    if (g_dwShlwapiVersion >= 5)
    {
        fRet = _GUIDFromStringA(psz, pguid);
    }
    else
    {
        CStrInW str(psz);
        fRet = (S_OK == CLSIDFromString(str, pguid));
    }

    return fRet;
}


// WritePrivateProfileString

BOOL WINAPI WritePrivateProfileStringW_HNWWrap(LPCWSTR pwzAppName, LPCWSTR pwzKeyName, LPCWSTR pwzString, LPCWSTR pwzFileName)
{
    BOOL fRet;

    if (g_dwShlwapiVersion >= 5)
    {
        fRet = _WritePrivateProfileStringWrapW(pwzAppName, pwzKeyName, pwzString, pwzFileName);
    }
    else
    {
        CStrIn strTextAppName(pwzAppName);
        CStrIn strTextKeyName(pwzKeyName);
        CStrIn strTextString(pwzString);
        CStrIn strTextFileName(pwzFileName);

        fRet = WritePrivateProfileStringA(strTextAppName, strTextKeyName, strTextString, strTextFileName);
    }

    return fRet;
}


// ExtTextOutW

#undef ExtTextOutW
LWSTDAPI_(BOOL) ExtTextOutW(HDC hdc, int x, int y, UINT fuOptions, CONST RECT *lprc, LPCWSTR lpStr, UINT cch, CONST INT *lpDx);


BOOL ExtTextOutWrapW_HNWWrap(HDC hdc, int x, int y, UINT fuOptions, CONST RECT *lprc, LPCWSTR lpStr, UINT cch, CONST INT *lpDx)
{
    BOOL fRet;

    if (g_dwShlwapiVersion >= 5)
    {
        fRet = _ExtTextOutWrapW(hdc, x, y, fuOptions, lprc, lpStr, cch, lpDx);
    }
    else
    {
        fRet = ExtTextOutW(hdc, x, y, fuOptions, lprc, lpStr, cch, lpDx);
    }

    return fRet;
}


// LoadLibraryW

HINSTANCE LoadLibraryW_HNWWrap(LPCWSTR pwzLibFileName)
{
    HINSTANCE hinst;

    if (g_dwShlwapiVersion >= 5)
    {
        hinst = _LoadLibraryWrapW(pwzLibFileName);
    }
    else
    {
        CStrIn  strFileName(pwzLibFileName);
        hinst = LoadLibraryA(strFileName);
    }

    return hinst;
}


// SHGetPathFromIDListW

BOOL SHGetPathFromIDListW_HNWWrap(LPCITEMIDLIST pidl, LPWSTR pwzPath)
{
    BOOL fRet;

    if (g_dwShlwapiVersion >= 5)
    {
        fRet = _SHGetPathFromIDListWrapW(pidl, pwzPath);
    }
    else
    {
        CStrOut strPathOut(pwzPath, MAX_PATH);
        fRet = SHGetPathFromIDListA(pidl, strPathOut);
        if (fRet)
        {
            strPathOut.ConvertIncludingNul();
        }
    }

    return fRet;
}


// SetFileAttributesW

BOOL SetFileAttributesW_HNWWrap(LPCWSTR pwzFile, DWORD dwFileAttributes)
{
    BOOL fRet;

    if (g_dwShlwapiVersion >= 5)
    {
        fRet = _SetFileAttributesWrapW(pwzFile, dwFileAttributes);
    }
    else
    {
        CStrIn  str(pwzFile);
        fRet = SetFileAttributesA(str, dwFileAttributes);
    }

    return fRet;
}


// MessageBoxW

int MessageBoxW_HNWWrap(HWND hwnd, LPCWSTR pwzText, LPCWSTR pwzCaption, UINT uType)
{
    int iRet;

    if (g_dwShlwapiVersion >= 5)
    {
        iRet = _MessageBoxWrapW(hwnd, pwzText, pwzCaption, uType);
    }
    else
    {
        CStrIn  strCaption(pwzCaption);
        CStrIn  strText(pwzText);
        iRet = MessageBoxA(hwnd, strText, strCaption, uType);
    }

    return iRet;
}



// CreateProcessW

BOOL CreateProcessW_HNWWrap(LPCWSTR lpApplicationName, LPWSTR lpCommandLine, LPSECURITY_ATTRIBUTES lpProcessAttributes,
                            LPSECURITY_ATTRIBUTES lpThreadAttributes, BOOL bInheritHandles, DWORD dwCreationFlags,
                            LPVOID lpEnvironment, LPCWSTR lpCurrentDirectory, LPSTARTUPINFOW lpStartupInfo,
                            LPPROCESS_INFORMATION lpProcessInformation)
{
    BOOL fRet;

    if (g_dwShlwapiVersion >= 5)
    {
        fRet = _CreateProcessWrapW(lpApplicationName, lpCommandLine, lpProcessAttributes, lpThreadAttributes,
                                   bInheritHandles, dwCreationFlags, lpEnvironment, lpCurrentDirectory,
                                   lpStartupInfo, lpProcessInformation);
    }
    else
    {
        CStrIn striApplicationName(lpApplicationName);
        CStrIn striCommandLine(lpCommandLine);
        CStrIn striCurrentDirectory(lpCurrentDirectory);

        if (NULL == lpStartupInfo)
        {
            fRet = CreateProcessA(striApplicationName, striCommandLine,
                                  lpProcessAttributes, lpThreadAttributes,
                                  bInheritHandles, dwCreationFlags,
                                  lpEnvironment, striCurrentDirectory,
                                  NULL, lpProcessInformation);
        }
        else
        {
            STARTUPINFOA si = *(STARTUPINFOA*)lpStartupInfo;

            CStrIn striReserved(lpStartupInfo->lpReserved);
            CStrIn striDesktop(lpStartupInfo->lpDesktop);
            CStrIn striTitle(lpStartupInfo->lpTitle);

            si.lpReserved = striReserved;
            si.lpDesktop  = striDesktop;
            si.lpTitle   = striTitle;

            fRet = CreateProcessA(striApplicationName, striCommandLine,
                                  lpProcessAttributes, lpThreadAttributes,
                                  bInheritHandles, dwCreationFlags,
                                  lpEnvironment, striCurrentDirectory,
                                  &si, lpProcessInformation);
        }
    }

    return fRet;
}


// FormatMessageW

DWORD FormatMessageW_HNWWrap(DWORD dwFlags, LPCVOID lpSource, DWORD dwMessageId, DWORD dwLanguageId,
                             LPWSTR lpBuffer, DWORD nSize, va_list* Arguments)
{
    DWORD dwRet;

    if (g_dwShlwapiVersion >= 5)
    {
        dwRet = _FormatMessageWrapW(dwFlags, lpSource, dwMessageId, dwLanguageId, lpBuffer,
                                    nSize, Arguments);
    }
    else
    {
        if (FORMAT_MESSAGE_FROM_STRING == dwFlags)
        {
            CStrIn  strSource((LPWSTR)lpSource);
            CStrOut strBuffer(lpBuffer, nSize);

            dwRet = FormatMessageA(dwFlags, strSource, dwMessageId, dwLanguageId, strBuffer,
                                   strBuffer.BufSize(), Arguments);

            if (dwRet)
            {
                dwRet = strBuffer.ConvertExcludingNul();
            }
                           
        }
        else
        {
            ASSERT(0);
            dwRet = 0;
        }
    }

    return dwRet;
}


// SHAnsiToUnicodeCP

int SHAnsiToUnicodeCP_HNWWrap(UINT uiCP, LPCSTR pszSrc, LPWSTR pwszDst, int cwchBuf)
{
    int iRet;

    if (g_dwShlwapiVersion >= 5)
    {
        iRet = _SHAnsiToUnicodeCP(uiCP, pszSrc, pwszDst, cwchBuf);
    }
    else
    {
        iRet = 0;             /* Assume failure */
        int cchSrc = lstrlenA(pszSrc) + 1;

        iRet = MultiByteToWideChar(uiCP, 0, pszSrc, cchSrc, pwszDst, cwchBuf);
        if (iRet) {
            /*
             *  The output buffer was big enough; no double-buffering
             *  needed.
             */
        } else if (GetLastError() == ERROR_INSUFFICIENT_BUFFER) {
            /*
             *  The output buffer wasn't big enough.  Need to double-buffer.
             */

            int cwchNeeded = MultiByteToWideChar(uiCP, 0, pszSrc, cchSrc,
                                                 NULL, 0);

            ASSERT(iRet == 0);        /* In case we fail later */
            if (cwchNeeded) {
                LPWSTR pwsz = (LPWSTR)LocalAlloc(LMEM_FIXED,
                                                 cwchNeeded * SIZEOF(WCHAR));
                if (pwsz) {
                    iRet = MultiByteToWideChar(uiCP, 0, pszSrc, cchSrc,
                                                 pwsz, cwchNeeded);
                    if (iRet) {
                        StrCpyNW(pwszDst, pwsz, cwchBuf);
                        iRet = cwchBuf;
                    }
                    LocalFree(pwsz);
                }
            }
        } else {
            /* Possibly unsupported code page */
            ASSERT(!"Unexpected error in MultiByteToWideChar");
        }
    }

    return iRet;
}


// StrRetToBufW

HRESULT StrRetToBufW_HNWWrap(STRRET* psr, LPCITEMIDLIST pidl, LPWSTR pszBuf, UINT cchBuf)
{
    HRESULT hr = E_FAIL;

    switch (psr->uType)
    {
    case STRRET_WSTR:
        {
            LPWSTR pwszTmp = psr->pOleStr;
            if (pwszTmp)
            {
                StrCpyNW(pszBuf, pwszTmp, cchBuf);
                CoTaskMemFree(pwszTmp);

                // Make sure no one thinks things are allocated still
                psr->uType = STRRET_CSTR;   
                psr->cStr[0] = 0;
            
                hr = S_OK;
            }
        }
        break;

    case STRRET_CSTR:
        SHAnsiToUnicode_HNWWrap(psr->cStr, pszBuf, cchBuf);
        hr = S_OK;
        break;

    case STRRET_OFFSET:
        if (pidl)
        {
            SHAnsiToUnicode_HNWWrap(STRRET_OFFPTR(pidl, psr), pszBuf, cchBuf);
            hr = S_OK;
        }
        break;
    }

    if (FAILED(hr) && cchBuf)
        *pszBuf = 0;

    return hr;
}


// WhichPlatform

UINT WhichPlatform_HNWWrap(void)
{
    UINT uiRet;

    if (g_dwShlwapiVersion >= 5)
    {
        uiRet = _WhichPlatform();
    }
    else
    {
        uiRet = PLATFORM_UNKNOWN;

        if (uiRet != PLATFORM_UNKNOWN)
            return uiRet;

        // Not all callers are linked to SHELL32.DLL, so we must use LoadLibrary.
        HINSTANCE hinst = LoadLibraryA("SHELL32.DLL");
        if (hinst)
        {
            DWORD fValue;
            DWORD cbSize = sizeof(fValue);
            HKEY hKey;
            LONG lRes;

            // NOTE: GetProcAddress always takes ANSI strings!
            DLLGETVERSIONPROC pfnGetVersion =
                (DLLGETVERSIONPROC)GetProcAddress(hinst, "DllGetVersion");

            uiRet = (NULL != pfnGetVersion) ? PLATFORM_INTEGRATED : PLATFORM_BROWSERONLY;

            // check that the registry reflects the right value... (this is so iexplore can check efficiently)
            lRes = RegOpenKeyEx(HKEY_LOCAL_MACHINE, TEXT("Software\\Microsoft\\Internet Explorer"),
                                0, KEY_READ | KEY_WRITE, &hKey);
            if (lRes == ERROR_SUCCESS)
            {
                lRes = RegQueryValueEx(hKey, L"IntegratedBrowser",
                                        NULL, NULL,
                                        (LPBYTE) &fValue, &cbSize);

                if (lRes == ERROR_SUCCESS && uiRet == PLATFORM_BROWSERONLY)
                {
                    // remove the value, we are now Browser only release
                    RegDeleteValue(hKey, L"IntegratedBrowser");
                }
                else if (lRes != ERROR_SUCCESS && uiRet == PLATFORM_INTEGRATED)
                {
                    // install the RegValue, we are integrated browser mode...
                    fValue = TRUE;
                    cbSize = sizeof(fValue);
                    RegSetValueEx(hKey, L"IntegratedBrowser",
                                   (DWORD) NULL, REG_DWORD,
                                   (LPBYTE) &fValue, cbSize);
                    // ignore the failure, if the key is not present, shdocvw will be loaded and this
                    // function called anyway....
                }
                RegCloseKey(hKey);
            }

            FreeLibrary(hinst);
        }
    }

    return uiRet;
}


//
// Static libs are linked to various shlwapi exports.  Some of the exports aren't implemented in
// IE4 shlwapi.  Define the exports here so that that linker fixes up the static lib imports
// to these functions.
//

#undef LoadLibraryWrapW

STDAPI_(HINSTANCE) LoadLibraryWrapW(LPCWSTR pwzLibFileName)
{
    return LoadLibraryW_HNWWrap(pwzLibFileName);
}

#undef SHAnsiToUnicodeCP

STDAPI_(int) SHAnsiToUnicodeCP(UINT uiCP, LPCSTR pszSrc, LPWSTR pwszDst, int cwchBuf)
{
    return SHAnsiToUnicodeCP_HNWWrap(uiCP, pszSrc, pwszDst, cwchBuf);
}

#undef SHUnicodeToAnsi

STDAPI_(int) SHUnicodeToAnsi(LPCWSTR pwszSrc, LPSTR pszDst, int cchBuf)
{
    return SHUnicodeToAnsi_HNWWrap(pwszSrc, pszDst, cchBuf);
}

#undef GetModuleHandleWrapW

STDAPI_(HMODULE) GetModuleHandleWrapW(LPCWSTR lpModuleName)
{
    return GetModuleHandleW(lpModuleName);
}

#undef GetWindowsDirectoryWrapW

STDAPI_(UINT) GetWindowsDirectoryWrapW(LPWSTR lpWinPath, UINT cch)
{
    return GetWindowsDirectoryW(lpWinPath, cch);
}

#undef GetModuleFileNameWrapW

STDAPI_(DWORD) GetModuleFileNameWrapW(HINSTANCE hModule, LPWSTR pwszFilename, DWORD nSize)
{
    return GetModuleFileNameW(hModule, pwszFilename, nSize);
}

#undef CreateWindowExWrapW

STDAPI_(HWND) CreateWindowExWrapW(DWORD dwExStyle, LPCWSTR lpClassName, LPCWSTR lpWindowName, DWORD dwStyle, int X,
                                  int Y, int nWidth, int nHeight, HWND hWndParent, HMENU hMenu, HINSTANCE hInstance,
                                  LPVOID lpParam)
{
    return CreateWindowExW(dwExStyle, lpClassName, lpWindowName, dwStyle, X, Y, nWidth, nHeight, hWndParent, hMenu,
                           hInstance, lpParam);
}

#undef CreateDialogIndirectParamWrapW

STDAPI_(HWND) CreateDialogIndirectParamWrapW(HINSTANCE hInstance, LPCDLGTEMPLATEW hDialogTemplate, HWND hWndParent,
                                             DLGPROC lpDialogFunc, LPARAM dwInitParam)
{
    return CreateDialogIndirectParamW(hInstance, hDialogTemplate, hWndParent, lpDialogFunc, dwInitParam);
}

#undef CreateDialogParamWrapW

STDAPI_(HWND) CreateDialogParamWrapW(HINSTANCE hInstance, LPCWSTR lpTemplateName, HWND hWndParent, DLGPROC lpDialogFunc,
                                     LPARAM dwInitParam)
{
    return CreateDialogParamW(hInstance, lpTemplateName, hWndParent, lpDialogFunc, dwInitParam);
}

#undef DialogBoxIndirectParamWrapW

STDAPI_(INT_PTR) DialogBoxIndirectParamWrapW(HINSTANCE hInstance, LPCDLGTEMPLATEW hDialogTemplate, HWND hWndParent,
                                             DLGPROC lpDialogFunc, LPARAM dwInitParam)
{
    return DialogBoxIndirectParamW(hInstance, hDialogTemplate, hWndParent, lpDialogFunc, dwInitParam);
}

#undef DialogBoxParamWrapW

STDAPI_(INT_PTR) DialogBoxParamWrapW(HINSTANCE hInstance, LPCWSTR lpszTemplate, HWND hWndParent, DLGPROC lpDialogFunc,
                                     LPARAM dwInitParam)
{
    return DialogBoxParamW(hInstance, lpszTemplate, hWndParent, lpDialogFunc, dwInitParam);
}

#undef RegisterClassWrapW

STDAPI_(ATOM) RegisterClassWrapW(CONST WNDCLASSW* lpWndClass)
{
    return RegisterClassW(lpWndClass);
}

#undef RegisterClassExWrapW

STDAPI_(ATOM) RegisterClassExWrapW(CONST WNDCLASSEXW* pwcx)
{
    return RegisterClassExW(pwcx);
}

#undef GetClassInfoWrapW

STDAPI_(BOOL) GetClassInfoWrapW(HINSTANCE hModule, LPCWSTR lpClassName, LPWNDCLASSW lpWndClassW)
{
    return GetClassInfoW(hModule, lpClassName, lpWndClassW);
}

#undef GetClassInfoExWrapW

STDAPI_(BOOL) GetClassInfoExWrapW(HINSTANCE hinst, LPCWSTR pwzClass, LPWNDCLASSEXW lpwcx)
{
    return GetClassInfoExW(hinst, pwzClass, lpwcx);
}

#undef CreateFileWrapW

STDAPI_(HANDLE) CreateFileWrapW(LPCWSTR lpFileName, DWORD dwDesiredAccess, DWORD dwShareMode, LPSECURITY_ATTRIBUTES lpSecurityAttributes,
                                DWORD dwCreationDisposition, DWORD dwFlagsAndAttributes, HANDLE hTemplateFile)
{
    return CreateFileW(lpFileName, dwDesiredAccess, dwShareMode, lpSecurityAttributes, dwCreationDisposition, dwFlagsAndAttributes, hTemplateFile);
}


#undef SetFileAttributesWrapW

STDAPI_(BOOL) SetFileAttributesWrapW(LPCWSTR pwzFile, DWORD dwFileAttributes)
{
    return SetFileAttributesW(pwzFile, dwFileAttributes);
}

#undef WhichPlatform

STDAPI_(UINT) WhichPlatform(void)
{
    return WhichPlatform_HNWWrap();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\hnw\wizard\stdafx.h ===
//
// stdafx.h
//

#ifndef __stdafx_h__
#define __stdafx_h__

#define STRICT

#ifdef DEBUG

#define _DEBUG

// ISSUE-2000/04/11-edwardp: Enable debug trace.
#define TRACE

#endif  // DEBUG
#include <basetsd.h>
#include "w95wraps.h"
#include "shlwapiunwrap.h"

#include <winsock2.h>
#include <mswsock.h>
#include <windows.h>
#include <windowsx.h>
#include <tchar.h>
#include <commctrl.h>
#include <comctrlp.h>
#include <prsht.h>
#include <shlobj.h>
#include <shlwapi.h>
#include <regstr.h>
#include <cfdefs.h>
#include <advpub.h>     // RegInstall stuff
#include <shpriv.h>
#include <netcon.h>

#include <shlwapiwrap.h>

// Review this! We need #defines in ras.h that depend on this high winver.
#undef WINVER
#define WINVER 0x501
#include <ras.h>
//#include <rasuip.h>
#undef WINVER
#define WINVER 0x400

#include "ccstock.h"
#include "debug.h"

#define _REG_ALLOCMEM 0
#include "Registry.h"

#ifndef _countof
#define _countof(ar) (sizeof(ar) / sizeof((ar)[0]))
#endif
#ifndef ARRAYSIZE
#define ARRAYSIZE(ar) (sizeof(ar) / sizeof((ar)[0]))
#endif

#ifndef IDC_HAND // not defined by default in VC6 headers
#define IDC_HAND            MAKEINTRESOURCE(32649)
#endif

#ifndef UNICODE_STRING
#define UNICODE_STRING  HNW_UNICODE_STRING
#define PUNICODE_STRING PHNW_UNICODE_STRING

typedef struct _HNW_UNICODE_STRING
{
    USHORT Length;
    USHORT MaximumLength;
    PWSTR  Buffer;
} 
HNW_UNICODE_STRING, *PHNW_UNICODE_STRING;
#endif


#include <shfusion.h>
#include "localstr.h"

#endif // __stdafx_h__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\hnw\wizard\strarray.cpp ===
#include "stdafx.h"

#include "..\shared\strarray.cpp"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\hnw\wizard\stdafx2.cpp ===
#include "stdafx.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\hnw\wizard\shlwapiwrap.h ===
// shlwapi wrappers

extern DWORD g_dwShlwapiVersion;

DWORD GetShlwapiVersion(void);


//
//  Static shlwapi functions.
//

// IsOS isn't implemented in W98 shlwapi, so use the static version instead.
#define IsOS staticIsOS



//////////////////////
#ifdef SHChangeNotify
#undef SHChangeNotify
#endif

#define SHChangeNotify  SHChangeNotify_HNWWrap

void SHChangeNotify_HNWWrap(LONG wEventId, UINT uFlags, LPCVOID dwItem1, LPCVOID dwItem2);
EXTERN_C void _SHChangeNotify(LONG wEventId, UINT uFlags, LPCVOID dwItem1, LPCVOID dwItem2);


//////////////////
#ifdef wnsprintfW
#undef wnsprintfW
#endif

#define wnsprintfW wnsprintfW_HNWWrap

int wnsprintfW_HNWWrap(LPWSTR lpOut, int cchLimitIn, LPCWSTR lpFmt, ...);


///////////////////
#ifdef wvnsprintfW
#undef wvnsprintfW
#endif

#define wvnsprintfW wvnsprintfW_HNWWrap

int wvnsprintfW_HNWWrap(LPWSTR lpOut, int cchLimitIn, LPCWSTR lpFmt, va_list va_args);
EXTERN_C int _wvnsprintfW(LPWSTR lpOut, int cchLimitIn, LPCWSTR lpFmt, va_list arglist);


///////////////////////
#ifdef SHSetWindowBits
#undef SHSetWindowBits
#endif

#define SHSetWindowBits SHSetWindowBits_HNWWrap

void SHSetWindowBits_HNWWrap(HWND hWnd, int iWhich, DWORD dwBits, DWORD dwValue);
EXTERN_C void _SHSetWindowBits(HWND hWnd, int iWhich, DWORD dwBits, DWORD dwValue);


///////////////////////
#ifdef SHAnsiToUnicode
#undef SHAnsiToUnicode
#endif

#define SHAnsiToUnicode SHAnsiToUnicode_HNWWrap

int SHAnsiToUnicode_HNWWrap(LPCSTR pszSrc, LPWSTR pwszDst, int cwchBuf);
EXTERN_C int _SHAnsiToUnicode(LPCSTR pszSrc, LPWSTR pwszDst, int cwchBuf);




///////////////////////
#ifdef SHUnicodeToAnsi
#undef SHUnicodeToAnsi
#endif

#define SHUnicodeToAnsi SHUnicodeToAnsi_HNWWrap

int SHUnicodeToAnsi_HNWWrap(LPCWSTR pwszSrc, LPSTR pszDst, int cchBuf);
EXTERN_C int _SHUnicodeToAnsi(LPCWSTR pwszSrc, LPSTR pszDst, int cchBuf);


///////////////////////
#ifdef GUIDFromStringA
#undef GUIDFromStringA
#endif

#define GUIDFromStringA GUIDFromStringA_HNWWrap

BOOL GUIDFromStringA_HNWWrap(LPCSTR psz, GUID* pguid);
EXTERN_C BOOL _GUIDFromStringA(LPCSTR psz, GUID* pguid);



//////////////////////////////////
#ifdef WritePrivateProfileStringW
#undef WritePrivateProfileStringW
#endif

#define WritePrivateProfileStringW WritePrivateProfileStringW_HNWWrap

BOOL WINAPI WritePrivateProfileStringW_HNWWrap(LPCWSTR pwzAppName, LPCWSTR pwzKeyName, LPCWSTR pwzString, LPCWSTR pwzFileName);
EXTERN_C BOOL WINAPI _WritePrivateProfileStringWrapW(LPCWSTR pwzAppName, LPCWSTR pwzKeyName, LPCWSTR pwzString, LPCWSTR pwzFileName);


///////////////////////
#ifdef ExtTextOutWrapW
#undef ExtTextOutWrapW
#endif

#define ExtTextOutWrapW ExtTextOutWrapW_HNWWrap

BOOL ExtTextOutWrapW_HNWWrap(HDC hdc, int x, int y, UINT fuOptions, CONST RECT *lprc, LPCWSTR lpStr, UINT cch, CONST INT *lpDx);
EXTERN_C BOOL _ExtTextOutWrapW(HDC hdc, int x, int y, UINT fuOptions, CONST RECT *lprc, LPCWSTR lpStr, UINT cch, CONST INT *lpDx);


////////////////////
#ifdef LoadLibraryW
#undef LoadLibraryW
#endif

#define LoadLibraryW LoadLibraryW_HNWWrap

HINSTANCE LoadLibraryW_HNWWrap(LPCWSTR pwzLibFileName);
EXTERN_C HINSTANCE _LoadLibraryWrapW(LPCWSTR pwzLibFileName);



////////////////////////////
#ifdef SHGetPathFromIDListW
#undef SHGetPathFromIDListW
#endif

#define SHGetPathFromIDListW SHGetPathFromIDListW_HNWWrap

BOOL SHGetPathFromIDListW_HNWWrap(LPCITEMIDLIST pidl, LPWSTR pwzPath);
EXTERN_C BOOL _SHGetPathFromIDListWrapW(LPCITEMIDLIST pidl, LPWSTR pwzPath);



//////////////////////////
#ifdef SetFileAttributesW
#undef SetFileAttributesW
#endif

#define SetFileAttributesW SetFileAttributesW_HNWWrap

BOOL SetFileAttributesW_HNWWrap(LPCWSTR pwzFile, DWORD dwFileAttributes);
EXTERN_C BOOL _SetFileAttributesWrapW(LPCWSTR pwzFile, DWORD dwFileAttributes);



///////////////////
#ifdef MessageBoxW
#undef MessageBoxW
#endif

#define MessageBoxW MessageBoxW_HNWWrap

int MessageBoxW_HNWWrap(HWND hwnd, LPCWSTR pwzText, LPCWSTR pwzCaption, UINT uType);
EXTERN_C int _MessageBoxWrapW(HWND hwnd, LPCWSTR pwzText, LPCWSTR pwzCaption, UINT uType);



//////////////////////////
#ifdef CreateProcessW
#undef CreateProcessW
#endif

#define CreateProcessW CreateProcessW_HNWWrap

BOOL CreateProcessW_HNWWrap(LPCWSTR lpApplicationName, LPWSTR lpCommandLine, LPSECURITY_ATTRIBUTES lpProcessAttributes,
                            LPSECURITY_ATTRIBUTES lpThreadAttributes, BOOL bInheritHandles, DWORD dwCreationFlags,
                            LPVOID lpEnvironment, LPCWSTR lpCurrentDirectory, LPSTARTUPINFOW lpStartupInfo,
                            LPPROCESS_INFORMATION lpProcessInformation);
EXTERN_C BOOL _CreateProcessWrapW(LPCWSTR lpApplicationName, LPWSTR lpCommandLine, LPSECURITY_ATTRIBUTES lpProcessAttributes,
                                  LPSECURITY_ATTRIBUTES lpThreadAttributes, BOOL bInheritHandles, DWORD dwCreationFlags,
                                  LPVOID lpEnvironment, LPCWSTR lpCurrentDirectory, LPSTARTUPINFOW lpStartupInfo,
                                  LPPROCESS_INFORMATION lpProcessInformation);



//////////////////////
#ifdef FormatMessageW
#undef FormatMessageW
#endif

#define FormatMessageW FormatMessageW_HNWWrap

DWORD FormatMessageW_HNWWrap(DWORD dwFlags, LPCVOID lpSource, DWORD dwMessageId, DWORD dwLanguageId,
                             LPWSTR lpBuffer, DWORD nSize, va_list* Arguments);
EXTERN_C DWORD _FormatMessageWrapW(DWORD dwFlags, LPCVOID lpSource, DWORD dwMessageId, DWORD dwLanguageId,
                                   LPWSTR lpBuffer, DWORD nSize, va_list* Arguments);


/////////////////////////
#ifdef SHAnsiToUnicodeCP
#undef SHAnsiToUnicodeCP
#endif

#define SHAnsiToUnicodeCP SHAnsiToUnicodeCP_HNWWrap

int SHAnsiToUnicodeCP_HNWWrap(UINT uiCP, LPCSTR pszSrc, LPWSTR pwszDst, int cwchBuf);
EXTERN_C int _SHAnsiToUnicodeCP(UINT uiCP, LPCSTR pszSrc, LPWSTR pwszDst, int cwchBuf);



////////////////////
#ifdef StrRetToBufW
#undef StrRetToBufW
#endif

#define StrRetToBufW StrRetToBufW_HNWWrap

HRESULT StrRetToBufW_HNWWrap(STRRET* psr, LPCITEMIDLIST pidl, LPWSTR pszBuf, UINT cchBuf);
EXTERN_C HRESULT _StrRetToBufW(STRRET* psr, LPCITEMIDLIST pidl, LPWSTR pszBuf, UINT cchBuf);


//////////////////
#ifdef WhichPlatform
#undef WhichPlatform
#endif

#define WhichPlatform WhichPlatform_HNWWrap

UINT WhichPlatform_HNWWrap(void);
EXTERN_C UINT _WhichPlatform(void);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\hnw\wizard\theapp.cpp ===
//
// TheApp.cpp
//

#include "stdafx.h"
#include <stdarg.h>
#include "TheApp.h"
#include "Util.h"
#include "NetConn.h"
//#include "MySvrApi.h"
#include "MyPrSht.h"
#include "Sharing.h"
#include "NetEnum.h"
#include "netconn.h"
#include "netapi.h"
#include "comctlwrap.h"

#include <shellapi.h>  // SHellExecute

//
// Get rid of msvcrt dependency since msvcrt didn't ship on all downlevel platforms
//
extern "C" int __cdecl _purecall(void) 
{
    return 0;
}

extern "C" int __cdecl _except_handler3(void) 
{
    return 0;
}



// String data
//

// Global variables
//
CHomeNetWizardApp theApp;

BOOL CHomeNetWizardApp::IsBiDiLocalized()
{
    return m_bBiDiLocalizedApp; 
}

int CHomeNetWizardApp::MessageBox(UINT nStringID, UINT uType)
{
    TCHAR szMsg[1024];
    TCHAR szTitle[256];
    LoadString(nStringID, szMsg, _countof(szMsg));
    LoadString(IDS_APPTITLE, szTitle, _countof(szTitle));
    return ::MessageBox(NULL, szMsg, szTitle, uType);
}

LPTSTR __cdecl CHomeNetWizardApp::FormatStringAlloc(UINT nStringID, ...)
{
    va_list argList;
    va_start(argList, nStringID);

    LPTSTR pszMsg = NULL;
    
    LPTSTR pszFormat = LoadStringAlloc(nStringID);
    if (pszFormat)
    {
        int cchNeeded = EstimateFormatLength(pszFormat, argList);
        pszMsg = (LPTSTR)malloc(cchNeeded * sizeof(TCHAR));
        if (pszMsg)
        {
            wvnsprintf(pszMsg, cchNeeded, pszFormat, argList);
        }

        free(pszFormat);
    }

    return pszMsg;
}

LPTSTR __cdecl CHomeNetWizardApp::FormatStringAlloc(LPCTSTR pszFormat, ...)
{
    va_list argList;
    va_start(argList, pszFormat);

    int cchNeeded = EstimateFormatLength(pszFormat, argList);
    LPTSTR pszMsg = (LPTSTR)malloc(cchNeeded * sizeof(TCHAR));
    if (pszMsg)
    {
        wvnsprintf(pszMsg, cchNeeded, pszFormat, argList);
    }

    return pszMsg;
}

int __cdecl CHomeNetWizardApp::MessageBoxFormat(UINT uType, UINT nStringID, ...)
{
    TCHAR szTitle[256];
    LoadString(IDS_APPTITLE, szTitle, _countof(szTitle));

    int nResult = 0;
    
    LPTSTR pszFormat = LoadStringAlloc(nStringID);
    if (pszFormat)
    {
        va_list argList;
        va_start(argList, nStringID);

        int cchNeeded = EstimateFormatLength(pszFormat, argList);
        LPTSTR pszMsg = (LPTSTR)malloc(cchNeeded * sizeof(TCHAR));
        if (pszMsg)
        {
            wvnsprintf(pszMsg, cchNeeded, pszFormat, argList);
            nResult = ::MessageBox(NULL, pszMsg, szTitle, uType);

            free(pszMsg);
        }

        free(pszFormat);
    }
    return nResult;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\hnw\wizard\theapp.h ===
//
// TheApp.h
//

#ifndef __HOMENETWIZAPP_H__
#define __HOMENETWIZAPP_H__

#include "resource.h"
#include "ICSInst.h"
#include "StrArray.h"
#include "Util.h"
#include "unicwrap.h"
#include "Sharing.h"
#include "netconn.h"

#include <netconp.h>

extern HINSTANCE g_hinst;
EXTERN_C BOOL    g_fRunningOnNT;
extern UINT      g_uWindowsBuild;

// Registry keys
//
#define c_szAppRegKey               _T("Software\\Microsoft\\Windows\\CurrentVersion\\HomeNetWizard")

// Debug-only values
#define c_szRegVal_WindowsBuild     _T("WindowsBuild")
#define c_szRegVal_NoInstall        _T("NoInstall")

// Windows build numbers
//
#define W9X_BUILD_WIN95         950
#define W9X_BUILD_WIN95_OSR2    1111
#define W9X_BUILD_WIN98         1998
#define W9X_BUILD_WIN98_SE      2222

#define MAX_KEY_SIZE            35

// Forward declarations
//
class CWizPageDlg;

// Public functions
//

// Shortcuts the user can take through the wizard (theApp.m_iShortcut)
#define SHORTCUT_NONE           0
#define SHORTCUT_COMPUTERNAME   1
#define SHORTCUT_SHARING        2
#define SHORTCUT_ICS            3 // note: m_bIcsOnly is a superset of this
#define SHORTCUT_FLOPPY         4

// Possible values for theApp.m_iNoIcsSetting
#define NOICS_WANT              0
#define NOICS_DONTWANT          1
#define NOICS_MISSING           2


/////////////////////////////////////////////////////////////////////////////
// CHomeNetWizardApp

class CHomeNetWizardApp
{
public:
    // OS Version info helpers
    inline UINT GetWin9xBuild()
        { return g_uWindowsBuild; }
    inline BOOL IsMillenniumOrLater()
        { return (GetWin9xBuild() > W9X_BUILD_WIN98_SE); }
    inline BOOL IsPreWin98SE()
        { return (GetWin9xBuild() < W9X_BUILD_WIN98_SE); }
    inline BOOL IsWin98SEOrLater()
        { return (GetWin9xBuild() >= W9X_BUILD_WIN98_SE); }
    inline BOOL IsWin95()
        { return (GetWin9xBuild() < W9X_BUILD_WIN98); }
    inline BOOL IsPreOSR2()
        { return (GetWin9xBuild() < W9X_BUILD_WIN95_OSR2); }
    inline BOOL IsWin98SE()
        { return (GetWin9xBuild() == W9X_BUILD_WIN98_SE); }
    inline BOOL IsWindows9x()
        { return !g_fRunningOnNT; }

    BOOL IsBiDiLocalized(void); // BiDi Localization support
    
    int MessageBox(UINT nStringID, UINT uType = MB_OK | MB_ICONEXCLAMATION);
    LPTSTR __cdecl FormatStringAlloc(UINT nStringID, ...);
    static LPTSTR __cdecl FormatStringAlloc(LPCTSTR pszFormat, ...);
    int __cdecl MessageBoxFormat(UINT uType, UINT nStringID, ...);
    void AllocInternalAdapters(UINT cAdapters);
    void FreeInternalAdapters();

    inline int LoadString(UINT uID, LPTSTR pszBuffer, int cchBuffer)
        { return ::LoadString(g_hinst, uID, pszBuffer, cchBuffer); }
    inline LPTSTR LoadStringAlloc(UINT uID)
        { return ::LoadStringAlloc(g_hinst, uID); }

public:
    BOOL m_bBiDiLocalizedApp;
};  

extern CHomeNetWizardApp theApp;

HRESULT HomeNetworkWizard_ShowWizard(HWND hwnd, BOOL* pfRebootRequired);

#endif // !__HOMENETWIZAPP_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\hnw\wizard\unicwrap.h ===
#ifndef _UNICWRAP_H_
#define _UNICWRAP_H_

///////////////////////////////////////////////////////////////////////////
//
// WNET
//
DWORD WNetOpenEnumWrapW(DWORD dwScope, DWORD dwType, DWORD dwUsage, LPNETRESOURCEW lpNetResource, LPHANDLE lphEnum);
DWORD WNetEnumResourceWrapW(HANDLE  hEnum, LPDWORD lpcCount, LPVOID lpBuffer, LPDWORD lpBufferSize);
DWORD WNetGetUserWrapW(LPCWSTR lpName, LPWSTR lpUserName, LPDWORD lpnLength);

#ifndef _NO_UNICWRAP_WRAPPERS_
#define WNetOpenEnumW WNetOpenEnumWrapW // WNetOpenEnum
#define WNetEnumResourceW WNetEnumResourceWrapW // WNetEnumResource
#define WNetGetUserW WNetGetUserWrapW // WNetGetUser
#endif // _NO_UNICWRAP_WRAPPERS_

///////////////////////////////////////////////////////////////////////////
//
// RAS
//
#include <ras.h>
// ras.h doesn't define these, but they are exported on Millennium platform!!!
EXTERN_C DWORD RnaGetDefaultAutodialConnection(LPSTR szBuffer, DWORD cchBuffer, LPDWORD lpdwOptions);
EXTERN_C DWORD RnaSetDefaultAutodialConnection(LPSTR szEntry, DWORD dwOptions);

DWORD RasEnumEntriesWrapW(LPCWSTR reserved, LPCWSTR pszPhoneBookPath, LPRASENTRYNAMEW pRasEntryNameW, LPDWORD pcb, LPDWORD pcEntries);
DWORD RasSetEntryDialParamsWrapW(LPCWSTR pszPhonebook, LPRASDIALPARAMSW lpRasDialParamsW, BOOL fRemovePassword);
DWORD RasGetEntryDialParamsWrapW(LPCWSTR pszPhonebook, LPRASDIALPARAMSW lpRasDialParamsW, LPBOOL pfRemovePassword);
DWORD RnaGetDefaultAutodialConnectionWrap(LPWSTR szBuffer, DWORD cchBuffer, LPDWORD lpdwOptions);
DWORD RnaSetDefaultAutodialConnectionWrap(LPWSTR szEntry, DWORD dwOptions);

#ifndef _NO_UNICWRAP_WRAPPERS_
#define RasEnumEntriesW RasEnumEntriesWrapW // RasEnumEntries
#define RasSetEntryDialParamsW RasSetEntryDialParamsWrapW // RasSetEntryDialParams
#define RasGetEntryDialParamsW RasGetEntryDialParamsWrapW // RasGetEntryDialParams
#define RnaGetDefaultAutodialConnection RnaGetDefaultAutodialConnectionWrap
#define RnaSetDefaultAutodialConnection RnaSetDefaultAutodialConnectionWrap
#endif // _NO_UNICWRAP_WRAPPERS_

///////////////////////////////////////////////////////////////////////////
//
// Property Sheets
//
INT_PTR WINAPI PropertySheetWrapW(LPCPROPSHEETHEADERW ppshW);
HPROPSHEETPAGE WINAPI CreatePropertySheetPageWrapW(LPCPROPSHEETPAGEW ppspW);

#ifndef _NO_UNICWRAP_WRAPPERS_
#define PropertySheetW PropertySheetWrapW
#define CreatePropertySheetPageW CreatePropertySheetPageWrapW
#endif // _NO_UNICWRAP_WRAPPERS_


///////////////////////////////////////////////////////////////////////////
//
// Printer APIs
//

BOOL EnumPrintersWrapW(DWORD dwFlags, LPWSTR pszName, DWORD dwLevel, BYTE* pPrinterEnum, DWORD cbPrinterEnum, DWORD* pcbNeeded, DWORD* pcPrinters);


#ifndef _NO_UNICWRAP_WRAPPERS_
#define EnumPrintersW EnumPrintersWrapW
#endif // _NO_UNICWRAP_WRAPPERS_


///////////////////////////////////////////////////////////////////////////
//
// Miscelaneous wrappers
//

UINT WINAPI GlobalGetAtomNameWrapW(ATOM nAtom, LPWSTR lpBuffer, int nSize);
BOOL WINAPI GetComputerNameWrapW(LPWSTR lpBuffer, LPDWORD pnSize);
BOOL WINAPI SetComputerNameWrapW (LPCWSTR lpComputerName);
UINT WINAPI GetDriveTypeWrapW(LPCWSTR lpRootPathName);

#ifndef _NO_UNICWRAP_WRAPPERS_
#define GlobalGetAtomNameW GlobalGetAtomNameWrapW
#define GetComputerNameW GetComputerNameWrapW
#define SetComputerNameW SetComputerNameWrapW
#define GetDriveTypeW GetDriveTypeWrapW
#endif // _NO_UNICWRAP_WRAPPERS_

#endif _UNICWRAP_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\hnw\wizard\util.cpp ===
#include "stdafx.h"

#include "..\shared\util.cpp"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\hnw\wizard\dll\makefile.inc ===
..\resource.rc : $(SELFREGNAME)

!include $(CCSHELL_DIR)\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\hnw\wizard\unicwrap.cpp ===
//
// Unicwrap.cpp
//
//      Simple thunking layer for NT/9X.
// 
//

#include "stdafx.h"
#define _NO_UNICWRAP_WRAPPERS_
#include "theapp.h"
#include "cstrinout.h"


///////////////////////////////////////////////////////////////////////////
//
// WNET
//

DWORD WNetOpenEnumWrapW(DWORD dwScope, DWORD dwType, DWORD dwUsage, LPNETRESOURCEW lpNetResource, LPHANDLE lphEnum)
{
    ASSERT(sizeof(NETRESOURCEA)==sizeof(NETRESOURCEW));

    if (g_fRunningOnNT)
    {
        return WNetOpenEnumW(dwScope, dwType, dwUsage, lpNetResource, lphEnum);
    }
    else
    {
        if (!lpNetResource)
        {
            return WNetOpenEnumA(dwScope, dwType, dwUsage, NULL, lphEnum);
        }
        else
        {
            CStrIn cstrLocalName(lpNetResource->lpLocalName);
            CStrIn cstrRemoteName(lpNetResource->lpRemoteName);
            CStrIn cstrComment(lpNetResource->lpComment);
            CStrIn cstrProvider(lpNetResource->lpProvider);
            
            NETRESOURCEA nrA;
            CopyMemory(&nrA, lpNetResource, sizeof(nrA));

            nrA.lpLocalName = cstrLocalName;
            nrA.lpRemoteName = cstrRemoteName;
            nrA.lpComment = cstrComment;
            nrA.lpProvider = cstrProvider;

            return WNetOpenEnumA(dwScope, dwType, dwUsage, &nrA, lphEnum);
        }
    }
}


DWORD WNetEnumResourceWrapW(HANDLE hEnum, LPDWORD lpcCount, LPVOID lpBuffer, LPDWORD lpBufferSize)
{
    ASSERT((!*lpBufferSize && !lpBuffer) || (*lpBufferSize && lpBuffer));

    if (g_fRunningOnNT)
    {
        return WNetEnumResourceW(hEnum, lpcCount, lpBuffer, lpBufferSize);
    }
    else
    {
        DWORD dwRet;
        LPVOID lpBufferA = NULL;
        DWORD dwBufferSizeA = (*lpBufferSize) / 2;

        if (dwBufferSizeA)
        {
            lpBufferA = malloc(dwBufferSizeA);
            if (!lpBufferA)
                return ERROR_OUTOFMEMORY;
        }

        dwRet = WNetEnumResourceA(hEnum, lpcCount, lpBufferA, &dwBufferSizeA);

        if ((0 == dwRet) || (ERROR_MORE_DATA == dwRet))
        {
            if (lpBufferA)
            {
                LPNETRESOURCEW pnrW = (LPNETRESOURCEW)lpBuffer;
                LPNETRESOURCEA pnrA = (LPNETRESOURCEA)lpBufferA;
                LPWSTR pwszStrings = (LPWSTR)&pnrW[*lpcCount];
                DWORD cchStrings = (*lpBufferSize - (DWORD)((LPBYTE)pwszStrings - (LPBYTE)pnrW)) / sizeof(WCHAR);
                DWORD i;

                // if cchStrings goes to 0 before all strings are copied, pwszStrings points
                // one past the buffer length. this case shouldn't happen, but if it does
                // we don't want to fault - reduce cchStrings by one so we point to valid memory.
                //
                cchStrings --;
                for (i=0 ; i<*lpcCount ; i++)
                {
                    ASSERT(sizeof(NETRESOURCEW) == sizeof(NETRESOURCEA));
                    CopyMemory(pnrW, pnrA, sizeof(NETRESOURCEA));

                    if (pnrA->lpLocalName)
                    {
                        DWORD cch = SHAnsiToUnicode(pnrA->lpLocalName, pwszStrings, cchStrings);
                        pnrW->lpLocalName = pwszStrings;
                        pwszStrings += cch;
                        cchStrings -= cch;
                    }
                    if (pnrA->lpRemoteName)
                    {                         
                        DWORD cch = SHAnsiToUnicode(pnrA->lpRemoteName, pwszStrings, cchStrings);
                        pnrW->lpRemoteName = pwszStrings;
                        pwszStrings += cch;
                        cchStrings -= cch;
                    }
                    if (pnrA->lpComment)
                    {
                        DWORD cch = SHAnsiToUnicode(pnrA->lpComment, pwszStrings, cchStrings);
                        pnrW->lpComment = pwszStrings;
                        pwszStrings += cch;
                        cchStrings -= cch;
                    }
                    if (pnrA->lpProvider)
                    {
                        DWORD cch = SHAnsiToUnicode(pnrA->lpProvider, pwszStrings, cchStrings);
                        pnrW->lpProvider = pwszStrings;
                        pwszStrings += cch;
                        cchStrings -= cch;
                    }

                    pnrW++;
                    pnrA++;
                }
                // (and null out that memory for the overflow case)
                *pwszStrings = TEXTW('\0');
            }

            *lpBufferSize = dwBufferSizeA * 2 + 1;
        }

        if (lpBufferA)
        {
            free(lpBufferA);
        }

        return dwRet;
    }

    return WN_NOT_SUPPORTED;
}

DWORD WNetGetUserWrapW(LPCWSTR lpName, LPWSTR lpUserName, LPDWORD lpnLength)
{
    if (g_fRunningOnNT)
    {
        return WNetGetUserW(lpName, lpUserName, lpnLength);
    }
    else
    {
        CStrIn cstrName(lpName);
        CStrOut cstrUserName(lpUserName, *lpnLength);

        // *lpnLength is character count, so no adjustment needed on ERROR_MORE_DATA
        return WNetGetUserA(cstrName, cstrUserName, lpnLength);
    }
}




///////////////////////////////////////////////////////////////////////////
//
// RAS
//

// ras structure thunkers

class CRasDialParamsIn
{
public:
    CRasDialParamsIn(LPRASDIALPARAMSW pRDP);

    void Convert();

    operator LPRASDIALPARAMSA() { return _pRDPW ? &_rdp : NULL; };

private:

    RASDIALPARAMSA _rdp;
    LPRASDIALPARAMSW _pRDPW;
};

CRasDialParamsIn::CRasDialParamsIn(LPRASDIALPARAMSW pRDP)
{
	_pRDPW = pRDP;
	_rdp.dwSize = sizeof(_rdp);
}

void CRasDialParamsIn::Convert()
{
    if (_pRDPW)
    {
        _rdp.dwSize = sizeof(_rdp);
        SHUnicodeToAnsi(_pRDPW->szEntryName, _rdp.szEntryName, ARRAYSIZE(_rdp.szEntryName));
        SHUnicodeToAnsi(_pRDPW->szPhoneNumber, _rdp.szPhoneNumber, ARRAYSIZE(_rdp.szPhoneNumber));
        SHUnicodeToAnsi(_pRDPW->szCallbackNumber, _rdp.szCallbackNumber, ARRAYSIZE(_rdp.szCallbackNumber));
        SHUnicodeToAnsi(_pRDPW->szUserName, _rdp.szUserName, ARRAYSIZE(_rdp.szUserName));
        SHUnicodeToAnsi(_pRDPW->szPassword, _rdp.szPassword, ARRAYSIZE(_rdp.szPassword));
        SHUnicodeToAnsi(_pRDPW->szDomain, _rdp.szDomain, ARRAYSIZE(_rdp.szDomain));
    }
}

class CRasDialParamsOut
{
public:
    CRasDialParamsOut(LPRASDIALPARAMSW pRDP) { _pRDPW = pRDP; _rdp.dwSize = sizeof(_rdp); };

    void Convert();
    void NullOutBuffer();

    operator LPRASDIALPARAMSA() { return _pRDPW ? &_rdp : NULL; };

private:

    RASDIALPARAMSA _rdp;
    LPRASDIALPARAMSW _pRDPW;
};

void CRasDialParamsOut::Convert()
{
    if (_pRDPW)
    {
        ASSERT(_pRDPW->dwSize == sizeof(*_pRDPW));
        SHAnsiToUnicode(_rdp.szEntryName, _pRDPW->szEntryName, ARRAYSIZE(_pRDPW->szEntryName));
        SHAnsiToUnicode(_rdp.szPhoneNumber, _pRDPW->szPhoneNumber, ARRAYSIZE(_pRDPW->szPhoneNumber));
        SHAnsiToUnicode(_rdp.szCallbackNumber, _pRDPW->szCallbackNumber, ARRAYSIZE(_pRDPW->szCallbackNumber));
        SHAnsiToUnicode(_rdp.szUserName, _pRDPW->szUserName, ARRAYSIZE(_pRDPW->szUserName));
        SHAnsiToUnicode(_rdp.szPassword, _pRDPW->szPassword, ARRAYSIZE(_pRDPW->szPassword));
        SHAnsiToUnicode(_rdp.szDomain, _pRDPW->szDomain, ARRAYSIZE(_pRDPW->szDomain));
    }
}

void CRasDialParamsOut::NullOutBuffer()
{
    if (_pRDPW)
    {
        _pRDPW->szEntryName[0]      = '\0';
        _pRDPW->szPhoneNumber[0]    = '\0';
        _pRDPW->szCallbackNumber[0] = '\0';
        _pRDPW->szUserName[0]       = '\0';
        _pRDPW->szPassword[0]       = '\0';
        _pRDPW->szDomain[0]         = '\0';
    }
}


//
// ras function wrappers
//

// Use old size so we work downlevel
#define OLD_RASENTRYNAMEA_SIZE  ((DWORD)(&((RASENTRYNAMEA*)NULL)->dwFlags))

DWORD RasEnumEntriesWrapW(LPCWSTR reserved, LPCWSTR pszPhoneBookPath, LPRASENTRYNAMEW pRasEntryNameW, LPDWORD pcb, LPDWORD pcEntries)
{
    ASSERT(NULL==reserved && NULL==pszPhoneBookPath); // we don't thunk these, so make sure we don't call with them
    ASSERT(!pRasEntryNameW || *pcb>0); // we're either requesting the size or we have a buffer

    if (g_fRunningOnNT)
    {
        return RasEnumEntriesW(reserved, pszPhoneBookPath, pRasEntryNameW, pcb, pcEntries);
    }
    else
    {
        DWORD dwRet = 0; // assume success
        DWORD cbA = *pcb / 2; // inverse of below
        LPRASENTRYNAMEA pRasEntryNameA = NULL;

        // if we're requesting info, allocate an ansi buffer
        if (pRasEntryNameW)
        {
            pRasEntryNameA = (LPRASENTRYNAMEA)malloc(cbA);

            if (pRasEntryNameA)
            {
                pRasEntryNameA->dwSize = OLD_RASENTRYNAMEA_SIZE;
            }
            else
            {
                dwRet = ERROR_NOT_ENOUGH_MEMORY;
            }
        }
        
        if (0==dwRet)
        {
            dwRet = RasEnumEntriesA(NULL, NULL, pRasEntryNameA, &cbA, pcEntries);

            // we successfully got info, thunk it back
            if (0 == dwRet && pRasEntryNameA)
            {
                UINT i;

                RASENTRYNAMEA* pRasEntryNameA2 = pRasEntryNameA;

                for (i=0 ; i<*pcEntries ; i++)
                {
                    pRasEntryNameW[i].dwSize = sizeof(pRasEntryNameW[i]);
                    SHAnsiToUnicode(pRasEntryNameA2->szEntryName, pRasEntryNameW[i].szEntryName, ARRAYSIZE(pRasEntryNameW[i].szEntryName));
                    pRasEntryNameA2 = (RASENTRYNAMEA*)((BYTE*)pRasEntryNameA2 + OLD_RASENTRYNAMEA_SIZE);
                }
            }

            // allow room for thunking
            *pcb = *pcEntries * sizeof(RASENTRYNAMEW);
        }

        if (pRasEntryNameA)
            free(pRasEntryNameA);

        return dwRet;
    }
}



DWORD RasSetEntryDialParamsWrapW(LPCWSTR pszPhonebook, LPRASDIALPARAMSW lpRasDialParamsW, BOOL fRemovePassword)
{
    ASSERT(NULL==pszPhonebook); // we don't thunk this

    if (g_fRunningOnNT)
    {
        return RasSetEntryDialParamsW(pszPhonebook, lpRasDialParamsW, fRemovePassword);
    }
    else
    {
        CRasDialParamsIn rdp(lpRasDialParamsW);

        rdp.Convert();

        return RasSetEntryDialParamsA(NULL, rdp, fRemovePassword);
    }
}

DWORD RasGetEntryDialParamsWrapW(LPCWSTR pszPhonebook, LPRASDIALPARAMSW lpRasDialParamsW, LPBOOL pfRemovePassword)
{
    ASSERT(NULL==pszPhonebook); // we don't thunk this

    if (g_fRunningOnNT)
    {
        return RasGetEntryDialParamsW(pszPhonebook, lpRasDialParamsW, pfRemovePassword);
    }
    else
    {
        DWORD dwRet;
        CRasDialParamsOut rdp(lpRasDialParamsW);

        dwRet = RasGetEntryDialParamsA(NULL, rdp, pfRemovePassword);

        if (ERROR_SUCCESS == dwRet)
        {
            rdp.Convert();
        }
        else
        {
            rdp.NullOutBuffer();
        }

        return dwRet;
    }
}

DWORD RnaGetDefaultAutodialConnectionWrap(LPWSTR szBuffer, DWORD cchBuffer, LPDWORD lpdwOptions)
{
    ASSERT(0 < cchBuffer);
    ASSERT(cchBuffer <= MAX_PATH); // largest string we thunk

    if (!g_fRunningOnNT)
    {
        DWORD dwRet;

        CStrOut cstroutBuffer(szBuffer, cchBuffer);

        dwRet = RnaGetDefaultAutodialConnection(cstroutBuffer, cstroutBuffer.BufSize(), lpdwOptions);

        cstroutBuffer.ConvertIncludingNul();

        return(dwRet);
    }

    // NT doesn't have an implementation of this function
    *lpdwOptions = 0;
    szBuffer[0] = TEXT('\0');

    return 0;
}

DWORD RnaSetDefaultAutodialConnectionWrap(LPWSTR szEntry, DWORD dwOptions)
{
    ASSERT(lstrlen(szEntry) < MAX_PATH); // should be valid since we assert this on the Get...

    if (!g_fRunningOnNT)
    {
        CStrIn cstrinEntry(szEntry);
        return RnaSetDefaultAutodialConnection(cstrinEntry, dwOptions);
    }

    // NT doesn't have an implementation of this function
    return 0;
}


//
// PropertySheet wrappers.
// 


INT_PTR WINAPI PropertySheetWrapW(LPCPROPSHEETHEADERW ppshW)
{
    INT_PTR iRet;

    if (g_fRunningOnNT)
    {
        iRet = PropertySheetW(ppshW);
    }
    else
    {
        //
        // Warning! Warning! Warning!
        //
        // This code assumes that none of the strings in this struct are being
        // used.  If a string gets used then the structure will have to be
        // converted.  It also assumes that PROPSHEETHEADERW and
        // PROPSHEETHEADERA are the same except for string types.
        //

        COMPILETIME_ASSERT(sizeof(PROPSHEETHEADERW) == sizeof(PROPSHEETHEADERA));

        ASSERT(NULL == ppshW->pszIcon        || !(ppshW->dwFlags & PSH_USEICONID)       || IS_INTRESOURCE(ppshW->pszIcon));
        ASSERT(NULL == ppshW->pszCaption     || IS_INTRESOURCE(ppshW->pszCaption));
        ASSERT(NULL == ppshW->pStartPage     || !(ppshW->dwFlags & PSH_USEPSTARTPAGE)   || IS_INTRESOURCE(ppshW->pStartPage));
        ASSERT(NULL == ppshW->pszIcon        || !(ppshW->dwFlags & PSH_USEICONID)       || IS_INTRESOURCE(ppshW->pszIcon));
        ASSERT(NULL == ppshW->pszbmWatermark || !(ppshW->dwFlags & PSH_USEHBMWATERMARK) || IS_INTRESOURCE(ppshW->pszbmWatermark));
        ASSERT(NULL == ppshW->pszbmHeader    || !(ppshW->dwFlags & PSH_USEHBMHEADER)    || IS_INTRESOURCE(ppshW->pszbmHeader));

        iRet = PropertySheetA((LPCPROPSHEETHEADERA)ppshW);
    }

    return iRet;
}

HPROPSHEETPAGE WINAPI CreatePropertySheetPageWrapW(LPCPROPSHEETPAGEW ppspW)
{
    HPROPSHEETPAGE hpspRet;

    if (g_fRunningOnNT)
    {
        hpspRet = CreatePropertySheetPageW(ppspW);
    }
    else
    {
        //
        // Warning! Warning! Warning!
        //
        // This code assumes that none of the strings in this struct are being
        // used.  If a string gets used then the structure will have to be
        // converted.  It also assumes that PROPSHEETPAGEW and
        // PROPSHEETPAGEA are the same except for string types.
        //
    
        COMPILETIME_ASSERT(sizeof(PROPSHEETPAGEW) == sizeof(PROPSHEETPAGEA));

        ASSERT(NULL == ppspW->pszTemplate       || (ppspW->dwFlags & PSP_DLGINDIRECT)        || IS_INTRESOURCE(ppspW->pszTemplate));
        ASSERT(NULL == ppspW->pszIcon           || !(ppspW->dwFlags & PSP_USEICONID)         || IS_INTRESOURCE(ppspW->pszIcon));
        ASSERT(NULL == ppspW->pszTitle          || !(ppspW->dwFlags & PSP_USETITLE)          || IS_INTRESOURCE(ppspW->pszTitle));
        ASSERT(NULL == ppspW->pszHeaderTitle    || !(ppspW->dwFlags & PSP_USEHEADERTITLE)    || IS_INTRESOURCE(ppspW->pszHeaderTitle));
        ASSERT(NULL == ppspW->pszHeaderSubTitle || !(ppspW->dwFlags & PSP_USEHEADERSUBTITLE) || IS_INTRESOURCE(ppspW->pszHeaderSubTitle));

        hpspRet = CreatePropertySheetPageA((LPCPROPSHEETPAGEA)ppspW);
    }

    return hpspRet;
}

//
// Miscelaneous APIs that aren't wrapped in shlwapi.  Move to shlwapi?
//

UINT WINAPI GlobalGetAtomNameWrapW(ATOM nAtom, LPWSTR lpBuffer, int nSize)
{
    UINT uRet;

    if (g_fRunningOnNT)
    {
        uRet = GlobalGetAtomNameW(nAtom, lpBuffer, nSize);
    }
    else
    {
        CStrOut csoBuffer(lpBuffer, nSize);

        uRet = GlobalGetAtomNameA(nAtom, csoBuffer, csoBuffer.BufSize());
    }

    return uRet;
}

BOOL WINAPI GetComputerNameWrapW(LPWSTR lpBuffer, LPDWORD pnSize)
{
    BOOL fRet;

    if (g_fRunningOnNT)
    {
        fRet = GetComputerNameW(lpBuffer, pnSize);
    }
    else
    {
        CStrOut csoBuffer(lpBuffer, *pnSize);
        DWORD cch = csoBuffer.BufSize();

        fRet = GetComputerNameA(csoBuffer, &cch);

        if (fRet && pnSize)
        {
            *pnSize = csoBuffer.ConvertExcludingNul();
        }
    }

    return fRet;
}

BOOL WINAPI SetComputerNameWrapW(LPCWSTR lpComputerName)
{
    BOOL fRet;

    if (g_fRunningOnNT)
    {
        fRet = SetComputerNameW(lpComputerName);
    }
    else
    {
        CStrIn csiComputerName(lpComputerName);

        fRet = SetComputerNameA(csiComputerName);
    }

    return fRet;
}

UINT WINAPI GetDriveTypeWrapW(LPCWSTR lpRootPathName)
{
    UINT uRet;

    if (g_fRunningOnNT)
    {
        uRet = GetDriveTypeW(lpRootPathName);
    }
    else
    {
        CStrIn csiRootPathName(lpRootPathName);

        uRet = GetDriveTypeA(csiRootPathName);
    }

    return uRet;
}


//
// Printer wrappers.
//

class CPrinterEnumIn
{
public:
    CPrinterEnumIn(DWORD dwLevel, BYTE* pPrinterEnum, DWORD cbPrinterEnum, DWORD* ppsbNeeded, DWORD* pcPrinters);
    ~CPrinterEnumIn();

    operator BYTE*() {return _pPrinterEnumA;}
    operator DWORD() {return _cbPrinterEnumA;}

private:
    void Convert(void);
    void ConvertStruct(const PRINTER_INFO_5A* ppi5A, PRINTER_INFO_5W* ppi5W, LPWSTR* ppszCurrent, UINT* pcchCurrent);
    void ConvertStructString(LPCSTR pszA, LPWSTR* ppszDst, LPWSTR* ppszW, UINT* pcchW);

private:
    BYTE*  _pPrinterEnum;
    DWORD  _cbPrinterEnum;
    DWORD* _pcbNeeded;
    DWORD* _pcPrinters;

    BYTE* _pPrinterEnumA;
    DWORD _cbPrinterEnumA;
};

CPrinterEnumIn::CPrinterEnumIn(DWORD dwLevel, BYTE* pPrinterEnum, DWORD cbPrinterEnum, DWORD* pcbNeeded, DWORD* pcPrinters)
{
    ASSERT(5 == dwLevel);  // only level supported.

    _pPrinterEnum  = pPrinterEnum;
    _cbPrinterEnum = cbPrinterEnum;
    _pcbNeeded     = pcbNeeded;
    _pcPrinters    = pcPrinters;

    if (_cbPrinterEnum)
    {
        _pPrinterEnumA = (BYTE*)LocalAlloc(LPTR, _cbPrinterEnum);

        _cbPrinterEnumA = _pPrinterEnumA ? _cbPrinterEnum : 0;
    }
    else
    {
        _pPrinterEnumA  = NULL;
        _cbPrinterEnumA = 0;
    }
}

CPrinterEnumIn::~CPrinterEnumIn()
{
    Convert();

    if (_pPrinterEnumA)
        LocalFree(_pPrinterEnumA);
}

void CPrinterEnumIn::Convert()
{
    if (!_pPrinterEnumA)
    {
        *_pcbNeeded *= 2;
    }
    else
    {
        UINT cchCurrent   = _cbPrinterEnum > (sizeof(PRINTER_INFO_5) * *_pcPrinters) ?
                               (_cbPrinterEnum - (sizeof(PRINTER_INFO_5) * *_pcPrinters)) / sizeof(WCHAR) :
                               0;

        LPWSTR pszCurrent = cchCurrent ? (LPWSTR)&(((PRINTER_INFO_5*)_pPrinterEnum)[*_pcPrinters]) : NULL;

        for (UINT i = 0; i < *_pcPrinters; i++)
        {
            ConvertStruct(&((const PRINTER_INFO_5A*)_pPrinterEnumA)[i], &((PRINTER_INFO_5W*)_pPrinterEnum)[i], &pszCurrent, &cchCurrent);
        }
    }

    return;
}

void CPrinterEnumIn::ConvertStruct(const PRINTER_INFO_5A* ppi5A, PRINTER_INFO_5W* ppi5W, LPWSTR* ppszCurrent, UINT* pcchCurrent)
{
    if (ppi5A->pPrinterName && *pcchCurrent)
    {
        ConvertStructString(ppi5A->pPrinterName, &ppi5W->pPrinterName, ppszCurrent, pcchCurrent);            
    }

    if (ppi5A->pPortName && *pcchCurrent)
    {
        ConvertStructString(ppi5A->pPortName, &ppi5W->pPortName, ppszCurrent, pcchCurrent);
    }

    ppi5W->Attributes               = ppi5A->Attributes;
    ppi5W->DeviceNotSelectedTimeout = ppi5A->DeviceNotSelectedTimeout;
    ppi5W->TransmissionRetryTimeout = ppi5A->TransmissionRetryTimeout;

    return;
}

void CPrinterEnumIn::ConvertStructString(LPCSTR pszA, LPWSTR* ppszDst, LPWSTR* ppszW, UINT* pcchW)
{
    UINT cch = MultiByteToWideChar(CP_ACP, 0, pszA, -1, *ppszW, *pcchW);

    if (cch)
    {
        *ppszDst = *ppszW;
        *pcchW  -= cch;
        *ppszW  += cch;
    }
    else
    {
        *ppszDst = NULL;
        *pcchW   = 0;
        *ppszW   = NULL;
    }

    return;
}

BOOL EnumPrintersWrapW(DWORD dwFlags, LPWSTR pszName, DWORD dwLevel, BYTE* pPrinterEnum, DWORD cbPrinterEnum, DWORD* pcbNeeded, DWORD* pcPrinters)
{
    BOOL fRet;

    if (g_fRunningOnNT)
    {
        fRet = EnumPrintersW(dwFlags, pszName, dwLevel, pPrinterEnum, cbPrinterEnum, pcbNeeded, pcPrinters);
    }
    else
    {
        CStrIn strName(pszName);
        CPrinterEnumIn cpeiPrinterEnum(dwLevel, pPrinterEnum, cbPrinterEnum, pcbNeeded, pcPrinters);

        fRet = EnumPrintersA(dwFlags, strName, dwLevel, cpeiPrinterEnum, cpeiPrinterEnum, pcbNeeded, pcPrinters);
    }

    return fRet;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\keyremap\map.c ===
/*****************************************************************************
 *
 *	map.c - Key Remap
 *
 *****************************************************************************/

#include "map.h"

/*****************************************************************************
 *
 *	The sqiffle for this file.
 *
 *****************************************************************************/

#define sqfl sqflDll

/*****************************************************************************
 *
 *	DllGetClassObject
 *
 *	OLE entry point.  Produces an IClassFactory for the indicated GUID.
 *
 *****************************************************************************/

STDAPI
DllGetClassObject(REFCLSID rclsid, RIID riid, PPV ppvObj)
{
    HRESULT hres;
    EnterProc(DllGetClassObject, (_ "G", rclsid));
    if (IsEqualIID(rclsid, &CLSID_KeyRemap)) {
	hres = CMapFactory_New(riid, ppvObj);
    } else {
	*ppvObj = 0;
	hres = CLASS_E_CLASSNOTAVAILABLE;
    }
    ExitOleProcPpv(ppvObj);
    return hres;
}

/*****************************************************************************
 *
 *	DllCanUnloadNow
 *
 *	OLE entry point.  Fail iff there are outstanding refs.
 *
 *	There is an unavoidable race condition between DllCanUnloadNow
 *	and the creation of a new reference:  Between the time we
 *	return from DllCanUnloadNow() and the caller inspects the value,
 *	another thread in the same process may decide to call
 *	DllGetClassObject, thus suddenly creating an object in this DLL
 *	when there previously was none.
 *
 *	It is the caller's responsibility to prepare for this possibility;
 *	there is nothing we can do about it.
 *
 *****************************************************************************/

STDAPI
DllCanUnloadNow(void)
{
    SquirtSqflPtszV(sqfl, TEXT("DllCanUnloadNow() - g_cRef = %d"), g_cRef);
    return g_cRef ? S_FALSE : S_OK;
}

/*****************************************************************************
 *
 *	Entry32
 *
 *	DLL entry point.
 *
 *****************************************************************************/

STDAPI_(BOOL)
Entry32(HINSTANCE hinst, DWORD dwReason, LPVOID lpReserved)
{
    switch (dwReason) {
    case DLL_PROCESS_ATTACH:
	g_hinst = hinst;
#ifdef	DEBUG
	sqflCur = GetProfileInt(TEXT("DEBUG"), TEXT("KeyRemap"), 0);
	SquirtSqflPtszV(sqfl, TEXT("LoadDll - KeyRemap"));
#endif
    }
    return 1;
}

/*****************************************************************************
 *
 *	The long-awaited CLSID
 *
 *****************************************************************************/

#include <initguid.h>

DEFINE_GUID(CLSID_KeyRemap, 0x176AA2C0, 0x9E15, 0x11cf,
		            0xbf,0xc7,0x44,0x45,0x53,0x54,0,0);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\keyremap\assert.c ===
/*****************************************************************************
 *
 *	assert.c - Assertion stuff
 *
 *****************************************************************************/

#include "map.h"

#ifdef DEBUG

#include <stdarg.h>
#include <shlwapi.h>

#ifndef ARRAYSIZE
#define ARRAYSIZE(a)    (sizeof(a)/sizeof((a)[0]))
#endif

/*****************************************************************************
 *
 *	SquirtSqflPtszV
 *
 *	Squirt a message with a trailing crlf.
 *
 *****************************************************************************/

void EXTERNAL
SquirtSqflPtszV(SQFL sqfl, LPCTSTR ptsz, ...)
{
    if (sqfl == 0 || (sqfl & sqflCur)) {
	va_list ap;
	TCHAR tsz[1024];
	va_start(ap, ptsz);
	wvnsprintf(tsz, ARRAYSIZE(tsz), ptsz, ap);
	va_end(ap);
	OutputDebugString(tsz);
	OutputDebugString(TEXT("\r\n"));
    }
}

/*****************************************************************************
 *
 *	AssertPtszPtszLn
 *
 *	Something bad happened.
 *
 *****************************************************************************/

int EXTERNAL
AssertPtszPtszLn(LPCTSTR ptszExpr, LPCTSTR ptszFile, int iLine)
{
    SquirtSqflPtszV(sqflAlways, TEXT("Assertion failed: `%s' at %s(%d)"),
		    ptszExpr, ptszFile, iLine);
    DebugBreak();
    return 0;
}

/*****************************************************************************
 *
 *	Procedure call tracing is gross because the C preprocessor is lame.
 *
 *	Oh, if only we had support for m4...
 *
 *****************************************************************************/

/*****************************************************************************
 *
 *	ArgsPszV
 *
 *	Collect arguments to a procedure.
 *
 *	psz -> ASCIIZ format string
 *	... = argument list
 *
 *	The characters in the format string are listed in EmitPal.
 *
 *****************************************************************************/

void EXTERNAL
ArgsPalPszV(PARGLIST pal, LPCSTR psz, ...)
{
    va_list ap;
    va_start(ap, psz);
    if (psz) {
	PPV ppv;
	pal->pszFormat = psz;
	for (ppv = pal->rgpv; *psz; psz++) {
	    *ppv++ = va_arg(ap, PV);
	}
    } else {
	pal->pszFormat = "";
    }
}

/*****************************************************************************
 *
 *	EmitPal
 *
 *	OutputDebugString the information, given a pal.  No trailing
 *	carriage return is emitted.
 *
 *	pal	 -> place where info was saved
 *
 *	Format characters:
 *
 *	p   - 32-bit flat pointer
 *	x   - 32-bit hex integer
 *	s   - TCHAR string
 *	A   - ANSI string
 *	W   - UNICODE string
 *	G   - GUID
 *	u   - unsigned integer
 *	C   - clipboard format
 *
 *****************************************************************************/

void INTERNAL
EmitPal(PARGLIST pal)
{
    char sz[MAX_PATH];
    int i;
    OutputDebugStringA(pal->pszProc);
    OutputDebugString(TEXT("("));
    for (i = 0; pal->pszFormat[i]; i++) {
	if (i) {
	    OutputDebugString(TEXT(", "));
	}
	switch (pal->pszFormat[i]) {

	case 'p':				/* 32-bit flat pointer */
	case 'x':				/* 32-bit hex */
	    wnsprintfA(sz, ARRAYSIZE(sz), "%08x", pal->rgpv[i]);
	    OutputDebugStringA(sz);
	    break;

	case 's':				/* TCHAR string */
	    if (pal->rgpv[i]) {
		OutputDebugString(pal->rgpv[i]);
	    }
	    break;

	case 'A':				/* ANSI string */
	    if (pal->rgpv[i]) {
		OutputDebugStringA(pal->rgpv[i]);
	    }
	    break;

#if 0
	case 'W':				/* UNICODE string */
#ifdef	UNICODE
	    OutputDebugStringW(pal->rgpv[i]);
#else
	    OleStrToStrN(sz, cA(sz), pal->rgpv[i], -1);
	    OutputDebugStringA(sz);
#endif
	    break;
#endif

	case 'G':				/* GUID */
	    wnsprintfA(sz, ARRAYSIZE(sz), "%08x", *(LPDWORD)pal->rgpv[i]);
	    OutputDebugStringA(sz);
	    break;

	case 'u':				/* 32-bit unsigned decimal */
	    wnsprintfA(sz, ARRAYSIZE(sz), "%u", pal->rgpv[i]);
	    OutputDebugStringA(sz);
	    break;

	case 'C':
	    if (GetClipboardFormatNameA(PtrToInt(pal->rgpv[i]), sz, cA(sz))) {
	    } else {
		wnsprintfA(sz, ARRAYSIZE(sz), "[%04x]", pal->rgpv[i]);
	    }
	    OutputDebugStringA(sz);
	    break;

	default: AssertF(0);			/* Invalid */
	}
    }
    OutputDebugString(TEXT(")"));
}

/*****************************************************************************
 *
 *	EnterSqflPtsz
 *
 *	Mark entry to a procedure.  Arguments were already collected by
 *	ArgsPszV.
 *
 *	sqfl	 -> squirty flags
 *	pszProc  -> procedure name
 *	pal	 -> place to save the name and get the format/args
 *
 *****************************************************************************/

void EXTERNAL
EnterSqflPszPal(SQFL sqfl, LPCSTR pszProc, PARGLIST pal)
{
    pal->pszProc = pszProc;
    if (sqfl == 0 || (sqfl & sqflCur)) {
	EmitPal(pal);
	OutputDebugString(TEXT("\r\n"));
    }
}

/*****************************************************************************
 *
 *	ExitSqflPalHresPpv
 *
 *	Mark exit from a procedure.
 *
 *	pal	 -> argument list
 *	hres	 -> exit result
 *	ppv	 -> optional OUT pointer;
 *		    1 means that hres is a boolean
 *		    2 means that hres is nothing at all
 *
 *****************************************************************************/

void EXTERNAL
ExitSqflPalHresPpv(SQFL sqfl, PARGLIST pal, HRESULT hres, PPV ppvObj)
{
    DWORD le = GetLastError();
    if (ppvObj == ppvVoid) {
    } else if (ppvObj == ppvBool) {
	if (hres == 0) {
	    sqfl |= sqflError;
	}
    } else {
	if (FAILED(hres)) {
	    AssertF(fLimpFF(ppvObj, *ppvObj == 0));
	    sqfl |= sqflError;
	}
    }

    if (sqfl == 0 || (sqfl & sqflCur)) {
	EmitPal(pal);
	OutputDebugString(TEXT(" -> "));
	if (ppvObj != ppvVoid) {
	    TCHAR tszBuf[32];
	    wnsprintf(tszBuf, ARRAYSIZE(tszBuf), TEXT("%08x"), hres);
	    OutputDebugString(tszBuf);
	    if (ppvObj != ppvBool) {
		if (ppvObj) {
		    wnsprintf(tszBuf, ARRAYSIZE(tszBuf), TEXT(" [%08x]"), *ppvObj);
		    OutputDebugString(tszBuf);
		}
	    } else if (hres == 0) {
		wnsprintf(tszBuf, ARRAYSIZE(tszBuf), TEXT(" [%d]"), le);
		OutputDebugString(tszBuf);
	    }
	}
	OutputDebugString(TEXT("\r\n"));
    }

    /*
     *	This redundant test prevents a breakpoint on SetLastError()
     *	from being hit constantly.
     */
    if (le != GetLastError()) {
	SetLastError(le);
    }
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\keyremap\common.c ===
/*****************************************************************************
 *
 *	common.c - Shared stuff that operates on all classes
 *
 *	WARNING!  The Common services work only if you pass in the
 *	"primary object".  This is vacuous if you don't use multiple
 *	inheritance, since there's only one object in the first place.
 *
 *	If you use multiple inheritance, make sure you pass the pointer
 *	to the object that you use as IUnknown.
 *
 *	The exceptions are the Forward_* functions, which work on
 *	pointers to non-primary interfaces.  They forward the call to the
 *	primary interface.
 *
 *****************************************************************************/

#include "map.h"

/*****************************************************************************
 *
 *	The sqiffle for this file.
 *
 *****************************************************************************/

#define sqfl sqflCommon

/*****************************************************************************
 *
 *  USAGE FOR OLE OBJECTS
 *
 *	Suppose you want to implement an object called CObj that supports
 *	the interfaces Foo, Bar, and Baz.  Suppose that you opt for
 *	Foo as the primary interface.
 *
 *	>> NAMING CONVENTION <<
 *
 *	    COM objects begin with the letter "C".
 *
 *	(1) Declare the primary and secondary vtbls.
 *
 *		Primary_Interface(CObj, IFoo);
 *		Secondary_Interface(CObj, IBar);
 *		Secondary_Interface(CObj, IBaz);
 *
 *	(3) Declare the object itself.
 *
 *		typedef struct CObj {
 *		    IFoo 	foo;	    // Primary must come first
 *		    IBar	bar;
 *		    IBaz	baz;
 *		    ... other fields ...
 *		} CObj;
 *
 *	(4) Implement the methods.
 *
 *	    You may *not* reimplement the AddRef and Release methods!
 *	    although you can subclass them.
 *
 *	(5) To allocate an object of the appropriate type, write
 *
 *		hres = Common_New(CObj, ppvOut);
 *
 *	    or, if the object is variable-sized,
 *
 *		hres = Common_NewCb(cb, CObj, ppvOut);
 *
 *	    If the object supports multiple interfaces, you also need to
 *	    initialize all the secondary interfaces.
 *
 *		CObj *pco = *ppvOut;
 *		pco->bar = Secondary_Vtbl(CObj, IBar);
 *		pco->baz = Secondary_Vtbl(CObj, IBaz);
 *
 *	(6) Define the vtbls.
 *
 *		#pragma BEGIN_CONST_DATA
 *
 *		// The macros will declare QueryInterface, AddRef and Release
 *		// so don't list them again
 *
 *		Primary_Interface_Begin(CObj, IFoo)
 *		    CObj_FooMethod1,
 *		    CObj_FooMethod2,
 *		    CObj_FooMethod3,
 *		    CObj_FooMethod4,
 *		Primary_Interface_End(Obj, IFoo)
 *
 *		Secondary_Interface_Begin(CObj, IBar, bar)
 *		    CObj_Bar_BarMethod1,
 *		    CObj_Bar_BarMethod2,
 *		Secondary_Interface_Begin(CObj, IBar, bar)
 *
 *		Secondary_Interface_Begin(CObj, IBaz, baz)
 *		    CObj_Baz_BazMethod1,
 *		    CObj_Baz_BazMethod2,
 *		    CObj_Baz_BazMethod3,
 *		Secondary_Interface_Begin(CObj, IBaz, baz)
 *
 *****************************************************************************/

/*****************************************************************************
 *
 *  USAGE FOR NON-OLE OBJECTS
 *
 *	All objects are COM objects, even if they are never given out.
 *	In the simplest case, it just derives from IUnknown.
 *
 *	Suppose you want to implement an object called Obj which is
 *	used only internally.
 *
 *	(1) Declare the vtbl.
 *
 *		Simple_Interface(Obj);
 *
 *	(3) Declare the object itself.
 *
 *		typedef struct Obj {
 *		    IUnknown unk;
 *		    ... other fields ...
 *		} Obj;
 *
 *	(4) Implement the methods.
 *
 *	    You may *not* override the QueryInterface, AddRef or
 *	    Release methods!
 *
 *	(5) Allocating an object of the appropriate type is the same
 *	    as with OLE objects.
 *
 *	(6) Define the "vtbl".
 *
 *		#pragma BEGIN_CONST_DATA
 *
 *		Simple_Interface_Begin(Obj)
 *		Simple_Interface_End(Obj)
 *
 *	    That's right, nothing goes between the Begin and the End.
 *
 *****************************************************************************/

/*****************************************************************************
 *
 *	CommonInfo
 *
 *	Information tracked for all common objects.
 *
 *	A common object looks like this:
 *
 *			  riid
 *              cRef	  FinalizeProc
 *	pFoo -> lpVtbl -> QueryInterface
 *		data	  Common_AddRef
 *		data	  Common_Release
 *		...	  ...
 *
 *	Essentially, we use the otherwise-unused space above the
 *	pointers to record our bookkeeping information.
 *
 *	cRef	     = object reference count
 *	riid	     = object iid
 *	FinalizeProc = Finalization procedure
 *
 *	For secondary interfaces, it looks like this:
 *
 *              	  offset to primary interface
 *	pFoo -> lpVtbl -> Forward_QueryInterface
 *			  Forward_AddRef
 *			  Forward_Release
 *			  ...
 *
 *****************************************************************************/

typedef struct CommonInfoN {
  D(ULONG cin_dwSig;)
    ULONG cin_cRef;
} CommonInfoN, CIN, *PCIN;

typedef struct CommonInfoP {
    PREVTBL *cip_prevtbl;
} CommonInfoP, CIP, *PCIP;

typedef struct CommonInfoP2 {
    PREVTBL2 *cip2_prevtbl2;
} CommonInfoP2, CIP2, *PCIP2;

typedef union CommonInfo {
    CIN cin[1];
    CIP cip[1];
    CIP2 cip2[1];
} CommonInfo, CI, *PCI;

#define ci_dwSig	cin[-1].cin_dwSig
#define ci_cRef		cin[-1].cin_cRef
#define ci_rgfp		cip[0].cip_prevtbl
#define ci_riid		cip[0].cip_prevtbl[-1].riid
#define ci_Finalize	cip[0].cip_prevtbl[-1].FinalizeProc
#define ci_lib		cip2[0].cip2_prevtbl2[-1].lib

#ifdef DEBUG
#define ci_Start	ci_dwSig
#else
#define ci_Start	ci_cRef
#endif

#define ci_dwSignature	0x38162378		/* typed by my cat */

/*****************************************************************************
 *
 *	Common_QueryInterface (from IUnknown)
 *
 *	Use this for objects that support only one interface.
 *
 *****************************************************************************/

STDMETHODIMP
Common_QueryInterface(PV pv, REFIID riid, PPV ppvObj)
{
    PCI pci = pv;
    HRESULT hres;
    EnterProc(Common_QueryInterface, (_ "pG", pv, riid));
    AssertF(pci->ci_dwSig == ci_dwSignature);
    if (IsEqualIID(riid, &IID_IUnknown) || IsEqualIID(riid, pci->ci_riid)) {
	*ppvObj = pv;
	Common_AddRef(pv);
	hres = S_OK;
    } else {
	*ppvObj = NULL;
	hres = E_NOINTERFACE;
    }
    ExitOleProcPpv(ppvObj);
    return hres;
}

/*****************************************************************************
 *
 *	Common_AddRef (from IUnknown)
 *
 *	Increment the object refcount and the dll refcount.
 *
 *****************************************************************************/

STDMETHODIMP_(ULONG)
_Common_AddRef(PV pv)
{
    PCI pci = pv;
    AssertF(pci->ci_dwSig == ci_dwSignature);
    InterlockedIncrement((LPLONG)&g_cRef);
    return ++pci->ci_cRef;
}

/*****************************************************************************
 *
 *	Common_Finalize (from Common_Release)
 *
 *	By default, no finalization is necessary.
 *
 *****************************************************************************/

void EXTERNAL
Common_Finalize(PV pv)
{
    SquirtSqflPtszV(sqfl, TEXT("Common_Finalize(%08x)"), pv);
}

/*****************************************************************************
 *
 *	Common_Release (from IUnknown)
 *
 *	Decrement the object refcount and the dll refcount.
 *
 *	If the object refcount drops to zero, finalize the object
 *	and free it.
 *
 *	The finalization handler lives ahead of the object vtbl.
 *
 *****************************************************************************/

STDMETHODIMP_(ULONG)
_Common_Release(PV pv)
{
    PCI pci = pv;
    ULONG ulRc;
    AssertF(pci->ci_dwSig == ci_dwSignature);
    AssertF(0 != g_cRef);
    InterlockedDecrement((LPLONG)&g_cRef);
    ulRc = --pci->ci_cRef;
    if (ulRc == 0) {
        pci->ci_Finalize(pv);
        FreePv(&pci->ci_Start);
    }
    return ulRc;
}

/*****************************************************************************
 *
 *	Forward_QueryInterface (from IUnknown)
 *
 *	Move to the main object and try again.
 *
 *****************************************************************************/

STDMETHODIMP
Forward_QueryInterface(PV pv, REFIID riid, PPV ppvObj)
{
    PCI pci = pv;
    LPUNKNOWN punk = pvAddPvCb(pv, 0 - pci->ci_lib);
    return Common_QueryInterface(punk, riid, ppvObj);
}

/*****************************************************************************
 *
 *	Forward_AddRef (from IUnknown)
 *
 *	Move to the main object and try again.
 *
 *****************************************************************************/

STDMETHODIMP_(ULONG)
Forward_AddRef(PV pv)
{
    PCI pci = pv;
    LPUNKNOWN punk = pvAddPvCb(pv, 0 - pci->ci_lib);
    return Common_AddRef(punk);
}

/*****************************************************************************
 *
 *	Forward_Release (from IUnknown)
 *
 *	Move to the main object and try again.
 *
 *****************************************************************************/

STDMETHODIMP_(ULONG)
Forward_Release(PV pv)
{
    PCI pci = pv;
    LPUNKNOWN punk = pvAddPvCb(pv, 0 - pci->ci_lib);
    return Common_Release(punk);
}

/*****************************************************************************
 *
 *	_Common_New
 *
 *	Create a new object with refcount 1 and the specific vtbl.
 *	All other fields are zero-initialized.
 *
 *****************************************************************************/

STDMETHODIMP
_Common_New(ULONG cb, PV vtbl, PPV ppvObj)
{
    HRESULT hres;
    EnterProc(Common_New, (_ "u", cb));
    SquirtSqflPtszV(sqfl, TEXT("Common_New()"));
    hres = AllocCbPpv(cb + sizeof(CIN), ppvObj);
    if (SUCCEEDED(hres)) {
	PCI pci = pvAddPvCb(*ppvObj, sizeof(CIN));
      D(pci->ci_dwSig = ci_dwSignature);
	pci->ci_rgfp = (PV)vtbl;
	*ppvObj = pci;
	Common_AddRef(pci);
	hres = S_OK;
    }
    ExitOleProcPpv(ppvObj);
    return hres;
}

/*****************************************************************************
 *
 *	Invoke_Release
 *
 *	Release the object (if there is one) and wipe out the back-pointer.
 *	Note that we wipe out the value before calling the release, in order
 *	to ameliorate various weird callback conditions.
 *
 *****************************************************************************/

void EXTERNAL
Invoke_Release(PV pv)
{
    LPUNKNOWN punk = pvExchangePpvPv(pv, 0);
    if (punk) {
	punk->lpVtbl->Release(punk);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\keyremap\map.h ===
/*****************************************************************************
 *
 *	map.h - Main private header file
 *
 *****************************************************************************/

/*****************************************************************************
 *
 *	Coding conventions:
 *
 *	+ Follow standard shell coding conventions.
 *
 *	+ Standard K&R brace placement and indentation style.
 *
 *	+ Indent by 4 spaces.
 *
 *	+ Fully-brace all dependent clauses.  Never write "if (c) foo();"
 *
 *	+ Do not return in the middle of a function.  If forced,
 *	  use a "goto exit".  This way, you can stick entry/exit stuff
 *	  later without getting caught out.  (I learned this rule the
 *	  hard way.)
 *
 *	+ Declare variables with narrowest possible scope.
 *
 *	+ Always test for success, not failure!  The compiler will
 *	  thank you.
 *
 *****************************************************************************/

/*****************************************************************************
 *
 *	NOTE!  This code was written for readability, not efficiency.
 *
 *	I'm trusting the compiler to do optimizations like these:
 *
 *	"Parameter alias":
 *
 *	    Function(LPFOO pfoo)
 *	    {
 *		LPBAR pbar = (LPBAR)pfoo;
 *		... use pbar and never mention pfoo again ...
 *	    }
 *
 *	    --> becomes
 *
 *	    Function(LPFOO pfoo)
 *	    {
 *		#define pbar ((LPBAR)pfoo)
 *		... use pbar and never mention pfoo again ...
 *		#undef pbar
 *	    }
 *
 *	"Speculative Execution":
 *
 *	    Function(PFOO pfoo)
 *	    {
 *		BOOL fRc;
 *		if (... condition 1 ...) {
 *		    ... complicated stuff ...
 *		    *pfoo = result;
 *		    fRc = 1;
 *		} else {		// condition 1 failed
 *		    *pfoo = 0;
 *		    fRc = 0;
 *		}
 *		return fRc;
 *	    }
 *
 *	    --> becomes
 *
 *	    Function(PFOO pfoo)
 *	    {
 *		BOOL fRc = 0;
 *		*pfoo = 0;
 *		if (... condition 1 ...) {
 *		    ... complicated stuff ...
 *		    *pfoo = result;
 *		    fRc = 1;
 *		}
 *		return fRc;
 *	    }
 *
 *	"Single Exit":
 *
 *	    Function(...)
 *	    {
 *		BOOL fRc;
 *		if (... condition 1 ...) {
 *		    ...
 *		    if (... condition 2 ...) {
 *			...
 *			fRc = 1;
 *		    } else {		// condition 2 failed
 *			... clean up ...
 *			fRc = 0;
 *		    }
 *		} else {		// condition 1 failed
 *		    ... clean up ...
 *		    fRc = 0;
 *		}
 *		return fRc;
 *	    }
 *
 *	    --> becomes
 *
 *	    Function(...)
 *	    {
 *		if (... condition 1 ...) {
 *		    ...
 *		    if (... condition 2 ...) {
 *			...
 *			return 1;
 *		    } else {		// condition 2 failed
 *			... clean up ...
 *			return 0;
 *		    }
 *		} else {		// condition 1 failed
 *		    ... clean up ...
 *		    return 0;
 *		}
 *		NOTREACHED;
 *	    }
 *
 *
 *
 *****************************************************************************/

#define STRICT
#undef  WIN32_LEAN_AND_MEAN
#define WIN32_LEAN_AND_MEAN
#define NOIME
#define NOSERVICE
#undef WINVER
#undef _WIN32_WINDOWS
#define WINVER 0x0400           /* Windows 4.0 compatible */
#define _WIN32_WINDOWS 0x0400   /* Windows 4.0 compatible */
#include <windows.h>

#ifdef	RC_INVOKED		/* Define some tags to speed up rc.exe */
#define __RPCNDR_H__		/* Don't need RPC network data representation */
#define __RPC_H__		/* Don't need RPC */
#include <oleidl.h>		/* Get the DROPEFFECT stuff */
#define _OLE2_H_		/* But none of the rest */
#define _WINDEF_
#define _WINBASE_
#define _WINGDI_
#define NONLS
#define _WINCON_
#define _WINREG_
#define _WINNETWK_
#define _INC_COMMCTRL
#define _INC_SHELLAPI
#else
#include <windowsx.h>
#include <regstr.h>
#endif

#include <shlobj.h>
#include <shellapi.h>

#ifdef DBG                          /* NT build process uses DBG */
#define DEBUG
#endif

/*****************************************************************************
 *
 *      Int64 goo.
 *
 *****************************************************************************/

#define SetWindowPointer(hwnd, i, p) SetWindowLongPtr(hwnd, i, (LRESULT)(p))
#define GetWindowPointer(hwnd, i)    (void *)GetWindowLongPtr(hwnd, i)

/*****************************************************************************
 *
 *	Stuff
 *
 *****************************************************************************/

#define IToClass(T, f, p)   CONTAINING_RECORD(p, T, f)
#define _IOffset(T, f)      FIELD_OFFSET(T, f)

/*****************************************************************************
 *
 *	Resource identifiers
 *
 *****************************************************************************/

/*****************************************************************************
 *
 *	Dialogs
 *
 *****************************************************************************/

#define IDC_STATIC		-1

#define IDD_MAIN		1

#define IDC_FROM                16
#define IDC_TO                  17

/*****************************************************************************
 *
 *	Strings
 *
 *****************************************************************************/

#define IDS_KEYFIRST            32
#define IDS_CAPSLOCK            32
#define IDS_LCTRL               33
#define IDS_RCTRL               34
#define IDS_LALT                35
#define IDS_RALT                36
#define IDS_LSHIFT              37
#define IDS_RSHIFT              38
#define IDS_LWIN                39
#define IDS_RWIN                40
#define IDS_APPS                41
#define IDS_KEYLAST             41
#define IDS_NUMKEYS             (IDS_KEYLAST - IDS_KEYFIRST + 1)

#ifndef	RC_INVOKED

/*****************************************************************************
 *
 *	Stuff I'm tired of typing over and over.
 *
 *****************************************************************************/

typedef LPITEMIDLIST PIDL, *PPIDL;
typedef LPCITEMIDLIST PCIDL;
typedef LPSHELLFOLDER PSF;
typedef LPVOID PV;
typedef LPVOID *PPV;
typedef LPCVOID PCV;
typedef REFIID RIID;
typedef LPUNKNOWN PUNK;

/*****************************************************************************
 *
 *	Baggage - Stuff I carry everywhere
 *
 *****************************************************************************/

#define INTERNAL NTAPI	/* Called only within a translation unit */
#define EXTERNAL NTAPI	/* Called from other translation units */
#define INLINE static __inline

#define BEGIN_CONST_DATA data_seg(".text", "CODE")
#define END_CONST_DATA data_seg(".data", "DATA")

#define OBJAT(T, v) (*(T *)(v))		/* Pointer punning */
#define PUN(T, v) OBJAT(T, &(v))	/* General-purpose type-punning */

/*
 * Convert a count of TCHAR's to a count of bytes.
 */
#define cbCtch(ctch) ((ctch) * sizeof(TCHAR))

/*
 * Convert an object (X) to a count of bytes (cb).
 */
#define cbX(X) sizeof(X)

/*
 * Convert an array name (A) to a generic count (c).
 */
#define cA(a) (cbX(a)/cbX(a[0]))

/*
 * Convert an array name (A) to a pointer to its Max.
 * (I.e., one past the last element.)
 */
#define pvMaxA(a) (&a[cA(a)])

#define pvSubPvCb(pv, cb) ((PV)((PBYTE)pv - (cb)))
#define pvAddPvCb(pv, cb) ((PV)((PBYTE)pv + (cb)))
#define cbSubPvPv(p1, p2) ((PBYTE)(p1) - (PBYTE)(p2))

/*
 * Round cb up to the nearest multiple of cbAlign.  cbAlign must be
 * a power of 2 whose evaluation entails no side-effects.
 */
#define ROUNDUP(cb, cbAlign) ((((cb) + (cbAlign) - 1) / (cbAlign)) * (cbAlign))

/*
 * lfNeVV
 *
 * Given two values, return zero if they are equal and nonzero if they
 * are different.  This is the same as (v1) != (v2), except that the
 * return value on unequal is a random nonzero value instead of 1.
 * (lf = logical flag)
 *
 * lfNePvPv
 *
 * The same as lfNeVV, but for pointers.
 *
 * lfPv
 *
 * Nonzero if pv is not null.
 *
 */
#define lfNeVV(v1, v2) ((v1) - (v2))
#define lfNePvPv(v1, v2) lfNeVV((DWORD)(PV)(v1), (DWORD)(PV)(v2))
#define lfPv(pv) ((BOOL)(PV)(pv))

/*
 * land -- Logical and.  Evaluate the first.  If the first is zero,
 * then return zero.  Otherwise, return the second.
 */

#define fLandFF(f1, f2) ((f1) ? (f2) : 0)

/*
 * lor -- Logical or.  Evaluate the first.  If the first is nonzero,
 * return it.  Otherwise, return the second.
 *
 * Unfortunately, due to the stupidity of the C language, this can
 * be implemented only with a GNU extension.  In the non-GNU case,
 * we return 1 if the first is nonzero.
 */

#if defined(__GNUC__)
#define fLorFF(f1, f2) ({ typeof (f1) _f = f1; if (!_f) _f = f2; _f; })
#else
#define fLorFF(f1, f2) ((f1) ? 1 : (f2))
#endif

/*
 * limp - logical implication.  True unless the first is nonzero and
 * the second is zero.
 */
#define fLimpFF(f1, f2) (!(f1) || (f2))

/*
 * leqv - logical equivalence.  True if both are zero or both are nonzero.
 */
#define fLeqvFF(f1, f2) (!(f1) == !(f2))

/*
 * InOrder - checks that i1 <= i2 < i3.
 */
#define fInOrder(i1, i2, i3) ((unsigned)((i2)-(i1)) < (unsigned)((i3)-(i1)))


/*****************************************************************************
 *
 *	Wrappers and other quickies
 *
 *****************************************************************************/

#define pvExchangePpvPv(ppv, pv) \
	InterlockedExchangePointer(ppv, pv)

/*****************************************************************************
 *
 *	Static globals:  Initialized at PROCESS_ATTACH and never modified.
 *
 *****************************************************************************/

HINSTANCE g_hinst;		/* My instance handle */
DEFINE_GUID(CLSID_KeyRemap, 0x176AA2C0, 0x9E15, 0x11cf,
		            0xbf,0xc7,0x44,0x45,0x53,0x54,0,0);

/*****************************************************************************
 *
 *	Dynamic Globals.  There should be as few of these as possible.
 *
 *	All access to dynamic globals must be thread-safe.
 *
 *****************************************************************************/

ULONG g_cRef;			/* Global reference count */

/*****************************************************************************
 *
 *	mapcf.c - Class Factory
 *
 *****************************************************************************/

STDMETHODIMP CMapFactory_New(RIID riid, PPV ppvObj);

/*****************************************************************************
 *
 *	mappsx.c - IPropSheetExt, IShellExtInit
 *
 *****************************************************************************/

STDMETHODIMP CMapPsx_New(RIID riid, PPV ppvObj);

/*****************************************************************************
 *
 *	mapps.c - Property sheet
 *
 *****************************************************************************/

INT_PTR CALLBACK MapPs_DlgProc(HWND hdlg, UINT wm, WPARAM wParam, LPARAM lParam);

/*****************************************************************************
 *
 *	Common object managers.
 *
 *****************************************************************************/

typedef struct PREVTBL0 {		/* Simple (non-OLE) object */
    void (NTAPI *FinalizeProc)(PV pv);	/* Finalization procedure */
} PREVTBL0, *PPREVTBL0;

typedef struct PREVTBL {		/* Primary interface */
    REFIID riid;			/* Type of this object */
    void (NTAPI *FinalizeProc)(PV pv);	/* Finalization procedure */
} PREVTBL, *PPREVTBL;

typedef struct PREVTBL2 {		/* Secondary interface */
    ULONG lib;				/* offset from start of object */
} PREVTBL2, *PPREVTBL2;

#ifdef	DEBUG

#define Simple_Interface(C) 		Primary_Interface(C, IUnknown); \
					Default_QueryInterface(C) \
					Default_AddRef(C) \
					Default_Release(C)
#define Simple_Vtbl(C)	    		Primary_Vtbl(C)
#define Simple_Interface_Begin(C)	Primary_Interface_Begin(C, IUnknown)
#define Simple_Interface_End(C)	    	Primary_Interface_End(C, IUnknown)

#else

#define Simple_Interface(C) 		Primary_Interface(C, IUnknown)
#define Simple_Vtbl(C)	    		Primary_Vtbl(C)
#define Simple_Interface_Begin(C)	\
	struct S_##C##Vtbl c_####C##VI = { {		\
	    &IID_##IUnknown,				\
	    C##_Finalize,				\
	}, {						\
	    Common##_QueryInterface,			\
	    Common##_AddRef,				\
	    Common##_Release,				\

#define Simple_Interface_End(C)	    	Primary_Interface_End(C, IUnknown)

#endif

#define Primary_Interface(C, I)				\
	extern struct S_##C##Vtbl {			\
	    PREVTBL prevtbl;				\
	    I##Vtbl vtbl;				\
	} c_##C##VI					\

#define Primary_Vtbl(C) &c_##C##VI.vtbl

#define Primary_Interface_Begin(C, I)			\
	struct S_##C##Vtbl c_####C##VI = { {		\
	    &IID_##I,					\
	    C##_Finalize,				\
	}, {						\
	    C##_QueryInterface,				\
	    C##_AddRef,					\
	    C##_Release,				\

#define Primary_Interface_End(C, I)			\
	} };						\

#define Secondary_Interface(C, I)			\
	extern struct S_##I##_##C##Vtbl {		\
	    PREVTBL2 prevtbl;	 			\
	    I##Vtbl vtbl;	 			\
	} c_##I##_##C##VI				\

#define Secondary_Vtbl(C, I) &c_##I##_##C##VI.vtbl

#define Secondary_Interface_Begin(C, I, nm)		\
	struct S_##I##_##C##Vtbl c_##I##_##C##VI = { {	\
	    _IOffset(C, nm),				\
	}, {						\
	    Forward_QueryInterface,			\
	    Forward_AddRef,				\
	    Forward_Release,				\

#define Secondary_Interface_End(C, I, nm)		\
	} };						\

STDMETHODIMP Common_QueryInterface(PV, REFIID, PPV);
STDMETHODIMP_(ULONG) _Common_AddRef(PV pv);
STDMETHODIMP_(ULONG) _Common_Release(PV pv);

/*
 * In DEBUG, go through the vtbl for additional squirties.
 */
#ifdef	DEBUG
#define Common_AddRef(punk) \
		((IUnknown *)(punk))->lpVtbl->AddRef((IUnknown *)(punk))
#define Common_Release(punk) \
		((IUnknown *)(punk))->lpVtbl->Release((IUnknown *)(punk))
#else
#define Common_AddRef _Common_AddRef
#define Common_Release _Common_Release
#endif

void EXTERNAL Common_Finalize(PV);

STDMETHODIMP _Common_New(ULONG cb, PV vtbl, PPV ppvObj);
#define Common_NewCb(cb, C, ppvObj) _Common_New(cb, Primary_Vtbl(C), ppvObj)
#define Common_New(C, ppvObj) Common_NewCb(cbX(C), C, ppvObj)

STDMETHODIMP Forward_QueryInterface(PV pv, REFIID riid, PPV ppvObj);
STDMETHODIMP_(ULONG) Forward_AddRef(PV pv);
STDMETHODIMP_(ULONG) Forward_Release(PV pv);

/*****************************************************************************
 *
 *	Common_CopyAddRef
 *
 *	Copy a pointer and increment its reference count.
 *
 *	Cannot be a macro because Common_AddRef evaluates its argument
 *	twice.
 *
 *****************************************************************************/

INLINE void Common_CopyAddRef(PV pvDst, PV pvSrc)
{
    PPV ppvDst = pvDst;
    *ppvDst = pvSrc;
    Common_AddRef(pvSrc);
}

/*****************************************************************************
 *
 *	Invoking OLE methods.
 *
 *	Invoke_Release is called with a pointer to the object, not with
 *	the object itself.  It zeros out the variable on the release.
 *
 *****************************************************************************/

void EXTERNAL Invoke_AddRef(PV pv);
void EXTERNAL Invoke_Release(PV pv);

/*****************************************************************************
 *
 *	assert.c - Assertion stuff
 *
 *****************************************************************************/

#define AssertNow(c) switch(0) case 0: case c:
#define CAssertNowPP(c,l) INLINE void Assert##l(void) { AssertNow(c); }
#define CAssertNowP(c,l) CAssertNowPP(c,l)
#define CAssertNow(c) CAssertNowP(c,__LINE__)

typedef enum {
    sqflAlways		= 0x00000000,		/* Unconditional */
    sqflDll		= 0x00000001,		/* Dll bookkeeping */
    sqflFactory		= 0x00000002,		/* IClassFactory */
    sqflPsx		= 0x00000004,		/* IPropSheetExt */
    sqflPs		= 0x00000008,		/* Property sheet */
    sqflCommon		= 0x00000000,		/* common.c */
    sqflError		= 0x80000000,		/* Errors */
} SQFL;						/* squiffle */

void EXTERNAL SquirtSqflPtszV(SQFL sqfl, LPCTSTR ptsz, ...);
int EXTERNAL AssertPtszPtszLn(LPCTSTR ptszExpr, LPCTSTR ptszFile, int iLine);

#ifndef	DEBUG
#define SquirtSqflPtszV sizeof
#endif

/*****************************************************************************
 *
 *	Procedure enter/exit tracking.
 *
 *	Start a procedure with
 *
 *	EnterProc(ProcedureName, (_ "format", arg, arg, arg, ...));
 *
 *	The format string is documented in EmitPal.
 *
 *	End a procedure with one of the following:
 *
 *	    ExitProc();
 *
 *		Procedure returns no value.
 *
 *	    ExitProcX();
 *
 *		Procedure returns an arbitrary DWORD.
 *
 *	    ExitOleProc();
 *
 *		Procedure returns an HRESULT (named "hres").
 *
 *	    ExitOleProcPpv(ppvOut);
 *
 *		Procedure returns an HRESULT (named "hres") and, on success,
 *		puts a new object in ppvOut.
 *
 *****************************************************************************/

#define cpvArgMax	10	/* Max of 10 args per procedure */

typedef struct ARGLIST {
    LPCSTR pszProc;
    LPCSTR pszFormat;
    PV rgpv[cpvArgMax];
} ARGLIST, *PARGLIST;

void EXTERNAL ArgsPalPszV(PARGLIST pal, LPCSTR psz, ...);
void EXTERNAL EnterSqflPszPal(SQFL sqfl, LPCTSTR psz, PARGLIST pal);
void EXTERNAL ExitSqflPalHresPpv(SQFL, PARGLIST, HRESULT, PPV);

#ifdef	DEBUG

SQFL sqflCur;

#define AssertFPtsz(c, ptsz) \
	((c) ? 0 : AssertPtszPtszLn(ptsz, TEXT(__FILE__), __LINE__))
#define ValidateF(c) \
	((c) ? 0 : AssertPtszPtszLn(TEXT(#c), TEXT(__FILE__), __LINE__))
#define D(x)		x

#define SetupEnterProc(nm)				\
	static CHAR s_szProc[] = #nm;			\
	ARGLIST _al[1]					\

#define _ _al,

#define ppvBool	((PPV)1)
#define ppvVoid	((PPV)2)

#define DoEnterProc(v)					\
	ArgsPalPszV v;					\
	EnterSqflPszPal(sqfl, s_szProc, _al)		\

#define EnterProc(nm, v)				\
	SetupEnterProc(nm);				\
	DoEnterProc(v)					\

#define ExitOleProcPpv(ppv)				\
	ExitSqflPalHresPpv(sqfl, _al, hres, (PPV)(ppv))	\

#define ExitOleProc()					\
	ExitOleProcPpv(0)				\

#define ExitProc()					\
	ExitSqflPalHresPpv(sqfl, _al, 0, ppvVoid)	\

#define ExitProcX(x)					\
	ExitSqflPalHresPpv(sqfl, _al, (HRESULT)(x), ppvBool) \

#else

#define AssertFPtsz(c, ptsz)
#define ValidateF(c)	(c)
#define D(x)

#define SetupEnterProc(nm)
#define DoEnterProc(v)
#define EnterProc(nm, v)
#define ExitOleProcPpv(ppv)
#define ExitOleProc()
#define ExitProc()

#endif

#define AssertF(c)	AssertFPtsz(c, TEXT(#c))

/*****************************************************************************
 *
 *	Macros that forward to the common handlers after squirting.
 *	Use these only in DEBUG.
 *
 *	It is assumed that sqfl has been #define'd to the appropriate sqfl.
 *
 *****************************************************************************/

#ifdef  DEBUG

#define Default_QueryInterface(Class)				\
STDMETHODIMP							\
Class##_QueryInterface(PV pv, RIID riid, PPV ppvObj)		\
{								\
    SquirtSqflPtszV(sqfl, TEXT(#Class) TEXT("_QueryInterface()")); \
    return Common_QueryInterface(pv, riid, ppvObj);		\
}								\

#define Default_AddRef(Class)					\
STDMETHODIMP_(ULONG)						\
Class##_AddRef(PV pv)						\
{								\
    ULONG ulRc = _Common_AddRef(pv);				\
    SquirtSqflPtszV(sqfl, TEXT(#Class)				\
			TEXT("_AddRef(%08x) -> %d"), pv, ulRc); \
    return ulRc;						\
}								\

#define Default_Release(Class)					\
STDMETHODIMP_(ULONG)						\
Class##_Release(PV pv)						\
{								\
    ULONG ulRc = _Common_Release(pv);				\
    SquirtSqflPtszV(sqfl, TEXT(#Class)				\
		       TEXT("_Release(%08x) -> %d"), pv, ulRc); \
    return ulRc;						\
}								\

#endif

/*****************************************************************************
 *
 *	mem.c
 *
 *	Be extremely careful with FreePv, because it doesn't work if
 *	the pointer is null.
 *
 *****************************************************************************/

STDMETHODIMP EXTERNAL ReallocCbPpv(UINT cb, PV ppvObj);
STDMETHODIMP EXTERNAL AllocCbPpv(UINT cb, PV ppvObj);

#define FreePpv(ppv) ReallocCbPpv(0, ppv)
#define FreePv(pv) LocalFree((HLOCAL)(pv))

#endif /* !RC_INVOKED */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\keyremap\mapcf.c ===
/*****************************************************************************
 *
 * mapcf.c - IClassFactory interface
 *
 *****************************************************************************/

#include "map.h"

/*****************************************************************************
 *
 *	The sqiffle for this file.
 *
 *****************************************************************************/

#define sqfl sqflFactory

/*****************************************************************************
 *
 *	Declare the interfaces we will be providing.
 *
 *****************************************************************************/

Primary_Interface(CMapFactory, IClassFactory);

/*****************************************************************************
 *
 *	CMapFactory
 *
 *	Really nothing doing.
 *
 *****************************************************************************/

typedef struct CMapFactory {

    /* Supported interfaces */
    IClassFactory 	cf;

} CMapFactory, FCF, *PFCF;

typedef IClassFactory CF, *PCF;

/*****************************************************************************
 *
 *	CMapFactory_QueryInterface (from IUnknown)
 *	CMapFactory_AddRef (from IUnknown)
 *	CMapFactory_Finalize (from Common)
 *	CMapFactory_Release (from IUnknown)
 *
 *****************************************************************************/

#ifdef DEBUG

Default_QueryInterface(CMapFactory)
Default_AddRef(CMapFactory)
Default_Release(CMapFactory)

#else
#define CMapFactory_QueryInterface Common_QueryInterface
#define CMapFactory_AddRef	Common_AddRef
#define CMapFactory_Release	Common_Release
#endif
#define CMapFactory_Finalize	Common_Finalize

/*****************************************************************************
 *
 *	CMapFactory_CreateInstance (from IClassFactory)
 *
 *****************************************************************************/

STDMETHODIMP
CMapFactory_CreateInstance(PCF pcf, LPUNKNOWN punkOuter, RIID riid, PPV ppvObj)
{
    HRESULT hres;
    SquirtSqflPtszV(sqfl, TEXT("CMapFactory_CreateInstance()"));
    if (!punkOuter) {
	/* The only object we know how to create is a propsheet extension */
	hres = CMapPsx_New(riid, ppvObj);
    } else {		/* Does anybody support aggregation any more? */
	hres = CLASS_E_NOAGGREGATION;
    }
    SquirtSqflPtszV(sqfl, TEXT("CMapFactory_CreateInstance() -> %08x [%08x]"),
		    hres, *ppvObj);
    return hres;
}

/*****************************************************************************
 *
 *	CMapFactory_LockServer (from IClassFactory)
 *
 *	What a stupid function.  Locking the server is identical to
 *	creating an object and not releasing it until you want to unlock
 *	the server.
 *
 *****************************************************************************/

STDMETHODIMP
CMapFactory_LockServer(PCF pcf, BOOL fLock)
{
    PFCF this = IToClass(CMapFactory, cf, pcf);
    if (fLock) {
        InterlockedIncrement((LPLONG)&g_cRef);
    } else {
        AssertF(0 != g_cRef);
        InterlockedDecrement((LPLONG)&g_cRef);
    }
    return S_OK;
}

/*****************************************************************************
 *
 *	CMapFactory_New
 *
 *****************************************************************************/

STDMETHODIMP
CMapFactory_New(RIID riid, PPV ppvObj)
{
    HRESULT hres;
    if (IsEqualIID(riid, &IID_IClassFactory)) {
	hres = Common_New(CMapFactory, ppvObj);
    } else {
	hres = E_NOINTERFACE;
    }
    return hres;
}

/*****************************************************************************
 *
 *	The long-awaited vtbl
 *
 *****************************************************************************/

#pragma BEGIN_CONST_DATA

Primary_Interface_Begin(CMapFactory, IClassFactory)
	CMapFactory_CreateInstance,
	CMapFactory_LockServer,
Primary_Interface_End(CMapFactory, IClassFactory)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\keyremap\mapps.c ===
/*****************************************************************************
 *
 *	mapps.c - Property sheet handler
 *
 *****************************************************************************/

#include "map.h"

/*****************************************************************************
 *
 *	The sqiffle for this file.
 *
 *****************************************************************************/

#define sqfl sqflPs

/*****************************************************************************
 *
 *      Strings.
 *
 *      The Scancode map registry value looks like this:
 *
 *      DWORD dwVersion;        // Must be zero
 *      DWORD dwFlags;          // Must be zero
 *      DWORD dwNumRemaps;      // Number of remaps, including terminating 0
 *      REMAPENTRY rgRemap[...];   // dwNumRemaps remap entries
 *
 *      The last remap entry must be all-zero.
 *
 *
 *      Each remap entry looks like this:
 *
 *      WORD wTo;
 *      WORD wFrom;
 *
 *      where wFrom is the source scancode and wTo is the target scancode.
 *      If the key being remapped is an extended key, then the high word
 *      of the scancode is 0xE0.  Otherwise, the high word is zero.
 *
 *      NOTE!  When we load the scancode map into memory, we make
 *      dwNumRemaps *not* include the terminating zero.  When we write
 *      it out, we re-adjust it back.  This is to avoid off-by-one errors
 *      in the code.
 *
 *****************************************************************************/

typedef union REMAPENTRY {
    union {
        DWORD dw;               /* Accessed as a dword */
    };
    struct {
        WORD    wTo;            /* Accessed as two words */
        WORD    wFrom;
    };
} REMAPENTRY, *PREMAPENTRY;

#define MAX_REMAPENTRY  (IDS_NUMKEYS+1)

typedef struct SCANCODEMAP {
    DWORD   dwVersion;
    DWORD   dwFlags;
    DWORD   dwNumRemaps;
    REMAPENTRY rgRemap[MAX_REMAPENTRY];
} SCANCODEMAP, *PSCANCODEMAP;

#pragma BEGIN_CONST_DATA

TCHAR c_tszKeyboard[] = TEXT("SYSTEM\\CurrentControlSet\\Control\\")
                        TEXT("Keyboard Layout");

TCHAR c_tszMapping[]  = TEXT("Scancode Map");

#pragma END_CONST_DATA

/*****************************************************************************
 *
 *      rgwRemap
 *
 *      Maps each key to its scancode.  This must match the list of strings.
 *
 *****************************************************************************/

#pragma BEGIN_CONST_DATA

WORD rgwRemap[] = {
    0x003A,         // IDS_CAPSLOCK
    0x001D,         // IDS_LCTRL
    0xE01D,         // IDS_RCTRL
    0x0038,         // IDS_LALT
    0xE038,         // IDS_RALT
    0x002A,         // IDS_LSHIFT
    0x0036,         // IDS_RSHIFT
    0xE05B,         // IDS_LWIN
    0xE05C,         // IDS_RWIN
    0xE05D,         // IDS_APPS
};

#pragma END_CONST_DATA

/*****************************************************************************
 *
 *	KEYMAPDATA
 *
 *      Instance data for the property sheet.
 *
 *****************************************************************************/

typedef struct KEYMAPDATA {
    SCANCODEMAP map;                    /* The mapping to apply */
    int ilbFrom;                        /* What's in ID_FROM? */
    int ilbTo;                          /* What's in ID_TO? */
} KMD, *PKMD;

#define pkmdHdlg(hdlg)      (PKMD)GetWindowPointer(hdlg, DWLP_USER)

/*****************************************************************************
 *
 *  MapPs_GetLbCurSel
 *
 *	Get the current selection from a listbox.
 *
 *****************************************************************************/

int PASCAL
MapPs_GetLbCurSel(HWND hdlg, UINT idc)
{
    return (int)SendDlgItemMessage(hdlg, idc, LB_GETCURSEL, 0, 0);
}

/*****************************************************************************
 *
 *  MapPs_FindEntry
 *
 *      Locate a mapping table entry, or -1 if not found.
 *
 *****************************************************************************/

int PASCAL
MapPs_FindEntry(PKMD pkmd, WORD wFrom)
{
    DWORD iMap;

    for (iMap = 0; iMap < pkmd->map.dwNumRemaps; iMap++) {
        if (pkmd->map.rgRemap[iMap].wFrom == wFrom) {
            return (int)iMap;
        }
    }

    return -1;
}

/*****************************************************************************
 *
 *  MapPs_WordToIndex
 *
 *      Given a mapping in the form of a word (rgwRemap), convert it back
 *      to the index that it came from.  This is the reverse of the rgwRemap
 *      array.
 *
 *****************************************************************************/

int PASCAL
MapPs_WordToIndex(WORD w)
{
    int i;

    for (i = 0; i < IDS_NUMKEYS; i++) {
        if (rgwRemap[i] == w) {
            return i;
        }
    }
    return -1;
}

/*****************************************************************************
 *
 *  MapPs_SaveCurSel
 *
 *	Stash what's in the current selection.
 *
 *****************************************************************************/

void PASCAL
MapPs_SaveCurSel(HWND hdlg, PKMD pkmd)
{
    int iTo = MapPs_GetLbCurSel(hdlg, IDC_TO);
    int iMap;
    WORD wFrom = rgwRemap[pkmd->ilbFrom];
    WORD wTo = rgwRemap[iTo];

    iMap = MapPs_FindEntry(pkmd, wFrom);

    if (iMap < 0) {
        /*
         *  Not found; must allocate.  Note that we check against
         *  MAX_REMAPENTRY-1 because the trailing null eats one slot.
         */
        if (pkmd->map.dwNumRemaps < MAX_REMAPENTRY - 1) {
            iMap = (int)pkmd->map.dwNumRemaps++;
        } else {
            /*
             *  No room in the table.  Oh well.
             */
            return;
        }
    }

    /*
     *  If the item is mapping to itself, then delete it entirely.
     */
    if (wFrom == wTo) {

        pkmd->map.dwNumRemaps--;
        pkmd->map.rgRemap[iMap].dw =
                            pkmd->map.rgRemap[pkmd->map.dwNumRemaps].dw;
    } else {
        pkmd->map.rgRemap[iMap].wFrom = wFrom;
        pkmd->map.rgRemap[iMap].wTo = wTo;
    }
}

/*****************************************************************************
 *
 *  MapPs_TrackSel
 *
 *	Select the corresponding item in idcTo given what's in idcFrom.
 *
 *****************************************************************************/

void PASCAL
MapPs_TrackSel(HWND hdlg, PKMD pkmd)
{
    int iFrom = pkmd->ilbFrom;
    int iMap, iTo;

    iMap = MapPs_FindEntry(pkmd, rgwRemap[iFrom]);

    if (iMap >= 0) {
        iTo = MapPs_WordToIndex(pkmd->map.rgRemap[iMap].wTo);

        if (iTo < 0) {
            /*
             *  Target not recognized; just map it to itself.
             */
            iTo = iFrom;
        }
    } else {
        /*
         *  Key not mapped.  Therefore, it maps to itself.
         */
        iTo = iFrom;
    }

    pkmd->ilbTo = iTo;
    SendDlgItemMessage(hdlg, IDC_TO, LB_SETCURSEL, iTo, 0);
}

/*****************************************************************************
 *
 *  MapPs_OnInitDialog
 *
 *      Read the current scancode mapping and fill in the dialog box.
 *
 *****************************************************************************/

BOOL NEAR PASCAL
MapPs_OnInitDialog(HWND hdlg)
{
    PKMD pkmd = LocalAlloc(LPTR, cbX(KMD));
    HKEY hk;
    LONG lRc;
    DWORD dwDisp;

    SetWindowPointer(hdlg, DWLP_USER, pkmd);

    lRc = RegCreateKeyEx(HKEY_LOCAL_MACHINE, c_tszKeyboard, 0,
                         TEXT(""), REG_OPTION_NON_VOLATILE,
                         KEY_QUERY_VALUE | KEY_SET_VALUE,
                         NULL, &hk, &dwDisp);
    if (lRc == ERROR_SUCCESS) {
        DWORD dwType;
        DWORD cb;
        int dids;

        cb = sizeof(pkmd->map);
        lRc = RegQueryValueEx(hk, c_tszMapping, NULL, &dwType,
                              (LPBYTE)&pkmd->map, &cb);
        RegCloseKey(hk);

        /*
         *  Note that ERROR_MORE_DATA is an error here.
         *  But ERROR_FILE_NOT_FOUND is okay.
         */
        if (lRc == ERROR_SUCCESS) {
            /*
             *  Sanity-check all the data.
             */
            if (
                /* Must be binary data */
                dwType == REG_BINARY &&

                /* Version zero */
                pkmd->map.dwVersion == 0 &&

                /* No flags */
                pkmd->map.dwFlags == 0 &&

                /* Sane number of remaps */
                pkmd->map.dwNumRemaps > 0 &&
                pkmd->map.dwNumRemaps <= MAX_REMAPENTRY &&

                /* Structure is the correct size */
                cb == (DWORD)FIELD_OFFSET(SCANCODEMAP,
                                          rgRemap[pkmd->map.dwNumRemaps]) &&

                /* Last remap must be zero */
                pkmd->map.rgRemap[pkmd->map.dwNumRemaps - 1].dw == 0
            ) {
            } else {
                goto fail;
            }

            pkmd->map.dwNumRemaps--;    /* Don't count the trailing null */

        } else if (lRc == ERROR_FILE_NOT_FOUND) {
            /*
             *  Set it up for a null mapping.
             */
            ZeroMemory(&pkmd->map, sizeof(pkmd->map));
        } else {
            goto fail;
        }

        /*
         *  Now init the dialog items.
         */
        for (dids = 0; dids < IDS_NUMKEYS; dids++) {
        TCHAR tsz[256];
        LoadString(g_hinst, IDS_KEYFIRST + dids, tsz, cA(tsz));
        SendDlgItemMessage(hdlg, IDC_FROM,
                           LB_ADDSTRING, 0, (LPARAM)tsz);
        SendDlgItemMessage(hdlg, IDC_TO,
                           LB_ADDSTRING, 0, (LPARAM)tsz);
        }

    } else {
        fail:;
        /*
         *  User does not have permission to remap keys, or the key
         *  contents aren't something we like.  Gray the controls.
         */
        EnableWindow(GetDlgItem(hdlg, IDC_TO), FALSE);

    }

    SendDlgItemMessage(hdlg, IDC_FROM, LB_SETCURSEL, 0, 0);
    MapPs_TrackSel(hdlg, pkmd);

    return 1;
}

/*****************************************************************************
 *
 *  MapPs_OnSelChange
 *
 *	Somebody changed a selection.  Save the selection and set
 *	the new one.
 *
 *****************************************************************************/

void PASCAL
MapPs_OnSelChange(HWND hdlg, PKMD pkmd)
{
    MapPs_SaveCurSel(hdlg, pkmd);       /* Save it */
    pkmd->ilbFrom = MapPs_GetLbCurSel(hdlg, IDC_FROM);
    MapPs_TrackSel(hdlg, pkmd);         /* And update for the new one */
}

/*****************************************************************************
 *
 *  MapPs_OnCommand
 *
 *	Ooh, we got a command.
 *
 *****************************************************************************/

BOOL PASCAL
MapPs_OnCommand(HWND hdlg, int id, UINT codeNotify)
{
    PKMD pkmd = pkmdHdlg(hdlg);

    switch (id) {

    case IDC_FROM:
	switch (codeNotify) {
	case LBN_SELCHANGE:
            MapPs_OnSelChange(hdlg, pkmd);
	    break;
	}
	break;

    case IDC_TO:
	switch (codeNotify) {
	case LBN_SELCHANGE:
            if (MapPs_GetLbCurSel(hdlg, IDC_TO) != pkmd->ilbTo) {
                PropSheet_Changed(GetParent(hdlg), hdlg);
            }
	    break;
	}
	break;

    }
    return 0;
}

/*****************************************************************************
 *
 *  MapPs_Apply
 *
 *	Write the changes to the registry and nudge the VxD.  We might have
 *	to load the VxD if the user is playing with KeyRemap immediately
 *	after installing, without rebooting in the interim.
 *
 *****************************************************************************/

BOOL PASCAL
MapPs_Apply(HWND hdlg)
{
    PKMD pkmd = pkmdHdlg(hdlg);

    MapPs_SaveCurSel(hdlg, pkmd);

    if (IsWindowEnabled(GetDlgItem(hdlg, IDC_TO))) {
        LONG lRc;
        HKEY hk;

        lRc = RegOpenKeyEx(HKEY_LOCAL_MACHINE, c_tszKeyboard, 0,
                             KEY_SET_VALUE, &hk);
        if (lRc == ERROR_SUCCESS) {

            DWORD cb;

            /*
             *  Count the trailing null again.  And make sure
             *  it's a trailing null!
             */

            pkmd->map.rgRemap[pkmd->map.dwNumRemaps].dw = 0;
            pkmd->map.dwNumRemaps++;

            cb = (DWORD)FIELD_OFFSET(SCANCODEMAP,
                                     rgRemap[pkmd->map.dwNumRemaps]);


            lRc = RegSetValueEx(hk, c_tszMapping, 0, REG_BINARY,
                                  (LPBYTE)&pkmd->map, cb);

            pkmd->map.dwNumRemaps--;

            RegCloseKey(hk);
        }

        if (lRc == ERROR_SUCCESS) {
            PropSheet_RebootSystem(GetParent(hdlg));
        }
    }

    return 1;
}

/*****************************************************************************
 *
 *  MapPs_OnNotify
 *
 *	Ooh, we got a notification.
 *
 *****************************************************************************/

BOOL PASCAL
MapPs_OnNotify(HWND hdlg, NMHDR FAR *pnm)
{
    switch (pnm->code) {
    case PSN_APPLY:
	MapPs_Apply(hdlg);
	break;
    }
    return 0;
}

/*****************************************************************************
 *
 *  MapPs_OnDestroy
 *
 *	Clean up.
 *
 *****************************************************************************/

BOOL PASCAL
MapPs_OnDestroy(HWND hdlg)
{
    PKMD pkmd = pkmdHdlg(hdlg);
    FreePv(pkmd);
    return 1;
}


/*****************************************************************************
 *
 *	MapPs_DlgProc
 *
 *	Our property sheet dialog procedure.
 *
 *****************************************************************************/

INT_PTR CALLBACK
MapPs_DlgProc(HWND hdlg, UINT wm, WPARAM wParam, LPARAM lParam)
{
    switch (wm) {
    case WM_INITDIALOG:
	return MapPs_OnInitDialog(hdlg);

    case WM_COMMAND:
	return MapPs_OnCommand(hdlg,
			          (int)GET_WM_COMMAND_ID(wParam, lParam),
			          (UINT)GET_WM_COMMAND_CMD(wParam, lParam));
    case WM_NOTIFY:
	return MapPs_OnNotify(hdlg, (NMHDR FAR *)lParam);

    case WM_DESTROY:
	return MapPs_OnDestroy(hdlg);

    default: return 0;	/* Unhandled */
    }
    return 1;		/* Handled */
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\loadwc\debug.c ===
// We don't use the debugging macros ourselves, but we use
// RunInstallUninstallStubs2, which uses IsOS() in stocklib,
// and stocklib uses the debugging macros, so we have to do all this
// stuff to keep the linker happy.
//

// This file cannot be compiled as a C++ file, otherwise the linker
// will bail on unresolved externals (even with extern "C" wrapping 
// this).

#include <windows.h>
#include <ccstock.h>

// Define some things for debug.h
//
#define SZ_DEBUGINI     "shellext.ini"
#define SZ_DEBUGSECTION "loadwc"
#define SZ_MODULE       "LOADWC"
#define DECLARE_DEBUG
#include <debug.h>
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\keyremap\mappsx.c ===
/*****************************************************************************
 *
 *	mappsx.c - IShellPropSheetExt interface
 *
 *****************************************************************************/

#include "map.h"

/*****************************************************************************
 *
 *	The sqiffle for this file.
 *
 *****************************************************************************/

#define sqfl sqflPsx

/*****************************************************************************
 *
 *	Declare the interfaces we will be providing.
 *
 *	We must implement an IShellExtInit so the shell
 *	will know that we are ready for action.
 *
 *****************************************************************************/

  Primary_Interface(CMapPsx, IShellPropSheetExt);
Secondary_Interface(CMapPsx, IShellExtInit);

/*****************************************************************************
 *
 *	CMapPsx
 *
 *	The property sheet extension for the Map/Ctrl gizmo.
 *
 *****************************************************************************/

typedef struct CMapPsx {

    /* Supported interfaces */
    IShellPropSheetExt 	psx;
    IShellExtInit	sxi;

} CMapPsx, CMSX, *PCMSX;

typedef IShellPropSheetExt PSX, *PPSX;
typedef IShellExtInit SXI, *PSXI;
typedef IDataObject DTO, *PDTO;		/* Used by IShellExtInit */

/*****************************************************************************
 *
 *	CMapPsx_QueryInterface (from IUnknown)
 *
 *	We need to check for our additional interfaces before falling
 *	through to Common_QueryInterface.
 *
 *****************************************************************************/

STDMETHODIMP
CMapPsx_QueryInterface(PPSX ppsx, RIID riid, PPV ppvObj)
{
    PCMSX this = IToClass(CMapPsx, psx, ppsx);
    HRESULT hres;
    if (IsEqualIID(riid, &IID_IShellExtInit)) {
	*ppvObj = &this->sxi;
	Common_AddRef(this);
	hres = S_OK;
    } else {
	hres = Common_QueryInterface(this, riid, ppvObj);
    }
    AssertF(fLimpFF(FAILED(hres), *ppvObj == 0));
    return hres;
}

/*****************************************************************************
 *
 *	CMapPsx_AddRef (from IUnknown)
 *	CMapPsx_Release (from IUnknown)
 *
 *****************************************************************************/

#ifdef DEBUG
Default_AddRef(CMapPsx)
Default_Release(CMapPsx)
#else
#define CMapPsx_AddRef Common_AddRef
#define CMapPsx_Release Common_Release
#endif

/*****************************************************************************
 *
 *	CMapPsx_Finalize (from Common)
 *
 *	Release the resources of an CMapPsx.
 *
 *****************************************************************************/

void EXTERNAL
CMapPsx_Finalize(PV pv)
{
    PCMSX this = pv;

    EnterProc(CMapPsx_Finalize, (_ "p", pv));

    ExitProc();
}

/*****************************************************************************
 *
 *	CMapPsx_AddPages (From IShellPropSheetExt)
 *
 *	Add one or more pages to an existing property sheet.
 *
 *	lpfnAdd	  - callback function to add pages
 *	lp	  - refdata for lpfnAdd
 *
 *****************************************************************************/

STDMETHODIMP
CMapPsx_AddPages(PPSX ppsx, LPFNADDPROPSHEETPAGE lpfnAdd, LPARAM lp)
{
    PCMSX this = IToClass(CMapPsx, psx, ppsx);
    HRESULT hres;
    EnterProc(CMapPsx_AddPages, (_ "p", ppsx));

    /*
     *  Add the page only on Windows NT.
     */
    if ((int)GetVersion() >= 0 && lpfnAdd) {
	HPROPSHEETPAGE hpsp;
	PROPSHEETPAGE psp;
	psp.dwSize = sizeof(psp);
	psp.dwFlags = PSP_DEFAULT;
	psp.hInstance = g_hinst;
	psp.pszTemplate = MAKEINTRESOURCE(IDD_MAIN);
	psp.pfnDlgProc = MapPs_DlgProc;

	hpsp = CreatePropertySheetPage(&psp);
	if (hpsp) {
	    if (lpfnAdd(hpsp, lp)) {
		Common_AddRef(this);
		hres = S_OK;
	    } else {
		DestroyPropertySheetPage(hpsp);
		hres = E_FAIL;
	    }
	} else {
	    hres = E_FAIL;
	}
    } else {
	hres = E_INVALIDARG;
    }

    ExitOleProc();
    return hres;
}

/*****************************************************************************
 *
 *	CMapPsx_ReplacePages (From IShellPropSheetExt)
 *
 *	Replaces one or more pages in an existing property sheet.
 *
 *	id	  - page identifier
 *	lpfnReplace  - callback function to replace the page
 *	lp	  - refdata for lpfnReplace
 *
 *****************************************************************************/

STDMETHODIMP
CMapPsx_ReplacePages(PPSX ppsx, UINT id,
		      LPFNADDPROPSHEETPAGE lpfnAdd, LPARAM lp)
{
    PCMSX this = IToClass(CMapPsx, psx, ppsx);
    HRESULT hres;
    EnterProc(CMapPsx_ReplacePages, (_ "pu", ppsx, id));

    hres = S_OK;

    ExitOleProc();
    return hres;
}

/*****************************************************************************
 *
 *	CMapPsx_SXI_Initialize (from IShellExtension)
 *
 *****************************************************************************/

STDMETHODIMP
CMapPsx_SXI_Initialize(PSXI psxi, PCIDL pidlFolder, PDTO pdto, HKEY hk)
{
    PCMSX this = IToClass(CMapPsx, sxi, psxi);
    HRESULT hres;
    EnterProc(CMapPsx_SXI_Initialize, (_ ""));

    hres = S_OK;

    ExitOleProc();
    return hres;
}

/*****************************************************************************
 *
 *	CMapPsx_New (from IClassFactory)
 *
 *	Note that we release the pmpsx that Common_New created, because we
 *	are done with it.  The real refcount is handled by the
 *	CMapPsx_QueryInterface.
 *
 *****************************************************************************/

STDMETHODIMP
CMapPsx_New(RIID riid, PPV ppvObj)
{
    HRESULT hres;
    EnterProc(CMapPsx_New, (_ "G", riid));

    *ppvObj = 0;
    hres = Common_New(CMapPsx, ppvObj);
    if (SUCCEEDED(hres)) {
	PCMSX pmpsx = *ppvObj;
	pmpsx->sxi.lpVtbl = Secondary_Vtbl(CMapPsx, IShellExtInit);
	hres = CMapPsx_QueryInterface(&pmpsx->psx, riid, ppvObj);
	Common_Release(pmpsx);
    }

    ExitOleProcPpv(ppvObj);
    return hres;
}

/*****************************************************************************
 *
 *	The long-awaited vtbls
 *
 *****************************************************************************/

#pragma BEGIN_CONST_DATA

Primary_Interface_Begin(CMapPsx, IShellPropSheetExt)
	CMapPsx_AddPages,
	CMapPsx_ReplacePages,
Primary_Interface_End(CMapPsx, IIShellPropSheetExt)

Secondary_Interface_Begin(CMapPsx, IShellExtInit, sxi)
 	CMapPsx_SXI_Initialize,
Secondary_Interface_End(CMapPsx, IShellExtInit, sxi)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\keyremap\mem.c ===
/*****************************************************************************
 *
 *	mem.c - Memory management
 *
 *	WARNING!  These do not go through OLE allocation.  Use these
 *	only for private allocation.
 *
 *****************************************************************************/

#include "map.h"

#ifdef NEED_REALLOC

/*****************************************************************************
 *
 *	ReallocCbPpv
 *
 *	Change the size of some zero-initialized memory.
 *
 *	This is the single place where all memory is allocated, resized,
 *	and freed.
 *
 *	If you realloc from a null pointer, memory is allocated.
 *	If you realloc to zero-size, memory is freed.
 *
 *	These semantics avoid boundary cases.  For example, it is no
 *	longer a problem trying to realloc something down to zero.
 *	You don't have to worry about special-casing an alloc of 0 bytes.
 *
 *	If an error is returned, the original pointer is UNCHANGED.
 *	This saves you from having to the double-switch around a realloc.
 *
 *****************************************************************************/

STDMETHODIMP EXTERNAL
ReallocCbPpv(UINT cb, PV ppvArg)
{
    HRESULT hres;
    PPV ppv = ppvArg;
    HLOCAL hloc = *ppv;
    if (cb) {			    /* Alloc or realloc */
	if (hloc) {		    /* Realloc */
	    hloc = LocalReAlloc(hloc, cb,
				LMEM_MOVEABLE+LMEM_ZEROINIT);
	} else {		/* Alloc */
	    hloc = LocalAlloc(LPTR, cb);
	}
	hres = hloc ? S_OK : E_OUTOFMEMORY;
    } else {			/* Freeing */
	if (hloc) {
	    LocalFree(hloc);
	    hloc = 0;
	    hres = S_OK;	/* All gone */
	} else {
	    hres = S_OK;	/* Nothing to free */
	}
    }

    if (SUCCEEDED(hres)) {
	*ppv = hloc;
    }
    return hres;
}

/*****************************************************************************
 *
 *	AllocCbPpv
 *
 *	Simple wrapper that forces *ppvObj = 0 before calling Realloc.
 *
 *****************************************************************************/

STDMETHODIMP EXTERNAL
AllocCbPpv(UINT cb, PPV ppv)
{
    *ppv = 0;
    return ReallocCbPpv(cb, ppv);
}

#else

/*****************************************************************************
 *
 *	AllocCbPpv
 *
 *	Allocate memory into the ppv.
 *
 *****************************************************************************/

STDMETHODIMP EXTERNAL
AllocCbPpv(UINT cb, PPV ppv)
{
    HRESULT hres;
    *ppv = LocalAlloc(LPTR, cb);
    hres = *ppv ? S_OK : E_OUTOFMEMORY;
    return hres;
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\loadwc\resource.h ===
#define IDD_InstallStubProgress 10

#define IDS_UNINSTALL   100
#define IDS_DESKTOP     101

#define IDS_CSIDL_PERSONAL_L    102
#define IDS_CSIDL_FAVORITES_L   103
#define IDS_CSIDL_APPDATA_L     104
#define IDS_CSIDL_CACHE_L       105
#define IDS_CSIDL_COOKIES_L     106
#define IDS_CSIDL_HISTORY_L     107
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\loadwc\loadwc.inc ===
#
#  Common defines across subcomponents 

TARGET_BOTH     = 1

!include $(CCSHELL_DIR)\common.inc

SOURCES_USED    =  $(SOURCES_USED) $(CCSHELL_DIR)\common.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\loadwc\resdll\makefile.inc ===
!include $(CCSHELL_DIR)\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\loadwc\dll\makefile.inc ===
!include $(CCSHELL_DIR)\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\logondui\debug.cpp ===
#include "priv.h"

// Define some things for debug.h
//
#define SZ_DEBUGINI         "ccshell.ini"
#define SZ_DEBUGSECTION     "logonui"
#define SZ_MODULE           "LOGONUI"
#define DECLARE_DEBUG
#include <debug.h>
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\loadwc\loadwc.cpp ===
//----------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1996 - 1997.
//
//  File:       LoadWC.cpp
//
//  Contents:   exe to load webcheck
//
//  Classes:
//
//  Functions:
//
//  History:    12-12/96    rayen (Raymond Endres)  Created
//
//----------------------------------------------------------------------------

#define _SHELL32_
#include <windows.h>
#include <ccstock.h>
#include <debug.h>
#include <docobj.h>
#include <webcheck.h>
#include <shlguid.h>
#include <shlobj.h>
#include <shellp.h>

// need to do this so we can #include <runonce.c>
BOOL g_fCleanBoot = FALSE;
BOOL g_fEndSession = FALSE;

//
// Channels are enabled for the IE4 upgrades.
//
#define ENABLE_CHANNELS

#define MLUI_INIT
#include <mluisupp.h>

//
// NOTE: ActiveSetup relies on our window name and class name
// to shut us down properly in softboot.  Do not change it.
//
const TCHAR c_szClassName[] = TEXT("LoadWC");
const TCHAR c_szWebCheckWindow[] = TEXT("MS_WebcheckMonitor");
const TCHAR c_szWebcheckKey[] = TEXT("Software\\Microsoft\\Windows\\CurrentVersion\\Webcheck");

// message send to dynamically start sens/lce (must not conflict with dialmon)
#define WM_START_SENSLCE    (WM_USER+200)

// only used in debug code to grovel with shell service object
#ifdef DEBUG
const TCHAR c_szWebCheck[] = TEXT("WebCheck");
const TCHAR c_szShellReg[] = TEXT("SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\ShellServiceObjectDelayLoad");
#endif

typedef struct {
    HINSTANCE   hInstance;          // handle to current instance
    HWND        hwnd;               // main window handle
    int         nCmdShow;           // hidden or not?
    HINSTANCE   hWebcheck;          // handle to webcheck dll
    BOOL        fUninstallOnly;     // TRUE -> run uninstall stubs only, then quit
    BOOL        fIntShellMode;      // TRUE -> integrated shell mode, else browser-only
    BOOL        fStartSensLce;
} GLOBALS;

GLOBALS g;

// webcheck function we dynaload
typedef HRESULT (WINAPI *PFNSTART)(BOOL fForceExternals);
typedef HRESULT (WINAPI *PFNSTOP)(void);

// Code to run install/uninstall stubs, from shell\inc.

#define HINST_THISDLL   g.hInstance

#include "resource.h"
//#include <stubsup.h>
#include <inststub.h>

int WINAPI WinMainT(HINSTANCE, HINSTANCE, LPSTR, int);
LRESULT APIENTRY WndProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam);
void vLoadWebCheck(void);
void vUnloadWebCheck(void);
BOOL bParseCommandLine(LPSTR lpCmdLine, int nCmdShow);

//----------------------------------------------------------------------------
// ModuleEntry
//----------------------------------------------------------------------------
extern "C" int _stdcall ModuleEntry(void)
{
    int i;
    STARTUPINFOA si;
    LPTSTR pszCmdLine;

    pszCmdLine = GetCommandLine();

    // g_hProcessHeap = GetProcessHeap();

    //
    // We don't want the "No disk in drive X:" requesters, so we set
    // the critical error mask such that calls will just silently fail
    //
    SetErrorMode(SEM_FAILCRITICALERRORS);

    if ( *pszCmdLine == TEXT('\"') ) {
        /*
         * Scan, and skip over, subsequent characters until
         * another double-quote or a null is encountered.
         */
        while ( *++pszCmdLine && (*pszCmdLine
             != TEXT('\"')) );
        /*
         * If we stopped on a double-quote (usual case), skip
         * over it.
         */
        if ( *pszCmdLine == TEXT('\"') )
            pszCmdLine++;
    }
    else {
        while (*pszCmdLine > TEXT(' '))
            pszCmdLine++;
    }

    /*
     * Skip past any white space preceeding the second token.
     */
    while (*pszCmdLine && (*pszCmdLine <= TEXT(' '))) {
        pszCmdLine++;
    }

    si.dwFlags = 0;
    GetStartupInfoA(&si);

    i = WinMainT(GetModuleHandle(NULL), NULL, pszCmdLine,
                   si.dwFlags & STARTF_USESHOWWINDOW ? si.wShowWindow : SW_SHOWDEFAULT);

    // Since we now have a way for an extension to tell us when it is finished,
    // we will terminate all processes when the main thread goes away.

    ExitProcess(i);

    // DebugMsg(DM_TRACE, TEXT("c.me: Cabinet main thread exiting without ExitProcess."));
    return i;
}

//----------------------------------------------------------------------------
// Registry helper function
//----------------------------------------------------------------------------
BOOL ReadRegValue(HKEY hkeyRoot, const TCHAR *pszKey, const TCHAR *pszValue,
                   void *pData, DWORD dwBytes)
{
    return ERROR_SUCCESS == SHRegGetValue(hkeyRoot, pszKey, pszValue, SRRF_RT_ANY | SRRF_NOEXPAND, NULL, pData, &dwBytes);
}

BOOL WriteRegValue(HKEY hkeyRoot, const TCHAR *pszKey, const TCHAR *pszValue,
                   DWORD dwType, void *pData, DWORD dwBytes)
{
    HKEY hkey;

    long lResult = RegOpenKeyEx(hkeyRoot, pszKey, 0, KEY_WRITE, &hkey);

    if (ERROR_SUCCESS == lResult)
    {
        lResult = RegSetValueEx(hkey, pszValue, 0, dwType, (BYTE *)pData, dwBytes);
        RegCloseKey(hkey);
    }

    return ERROR_SUCCESS == lResult;
}


void MakeWindowsRootPath(LPSTR pszBuffer, UINT cchBuffer)
{
    LPSTR pszEnd = NULL;
    if (*pszBuffer == '\\' && *(pszBuffer+1) == '\\') {
        pszEnd = pszBuffer + 2;
        while (*pszEnd && (*pszEnd != '\\'))
            pszEnd++;
        if (*pszEnd) {
            pszEnd++;
            while (*pszEnd && (*pszEnd != '\\'))
                pszEnd++;
            if (*pszEnd)
                pszEnd++;
        }
    }
    else {
        LPSTR pszNext = CharNext(pszBuffer);
        if (*pszNext == ':' && *(pszNext+1) == '\\')
            pszEnd = pszNext + 2;
    }
    if (pszEnd != NULL)
        *pszEnd = '\0';
    else {
        /* ??? Windows dir is neither UNC nor a root path?
         * Just make sure it ends in a backslash.
         */
        LPSTR pszLast = pszBuffer;
        if (*pszBuffer) {
             pszLast = CharPrev(pszBuffer, pszBuffer + lstrlen(pszBuffer));
        }
        if (*pszLast != '\\')
            StrCatBuff(pszLast, "\\", cchBuffer);
    }
}

//----------------------------------------------------------------------------
// InitShellFolders
//
// More of making loadwc.exe a browser-only mode catch-all.  This code makes
// sure that the Shell Folders key in the per-user registry is fully populated
// with the absolute paths to all the special folders for IE, even if
// shell32.dll doesn't understand all of them.
//
// As the shell would do in SHGetSpecialFolderLocation, we check the
// User Shell Folders key for a path, and if that's present we copy it to the
// Shell Folders key, expanding %USERPROFILE% if necessary.  If the value is
// not present under User Shell Folders, we generate the default location
// (usually under the Windows directory) and store that location under
// Shell Folders.
//----------------------------------------------------------------------------
struct FolderDescriptor {
    UINT idsDirName;        /* Resource ID for directory name */
    LPCTSTR pszRegValue;    /* Name of reg value to set path in */
    BOOL fDefaultInRoot : 1;    /* TRUE if default location is root directory */
    BOOL fWriteToUSF : 1;       /* TRUE if we should write to User Shell Folders to work around Win95 bug */
} aFolders[] = {
    { IDS_CSIDL_PERSONAL_L, TEXT("Personal"), TRUE, TRUE } ,
    { IDS_CSIDL_FAVORITES_L, TEXT("Favorites"), FALSE, TRUE },
    { IDS_CSIDL_APPDATA_L, TEXT("AppData"), FALSE, FALSE },
    { IDS_CSIDL_CACHE_L, TEXT("Cache"), FALSE, FALSE },
    { IDS_CSIDL_COOKIES_L, TEXT("Cookies"), FALSE, FALSE },
    { IDS_CSIDL_HISTORY_L, TEXT("History"), FALSE, FALSE },
};

void InitShellFolders(void)
{
    LONG err;
    HKEY hkeySF = NULL;
    HKEY hkeyUSF = NULL;
    TCHAR szDefaultDir[MAX_PATH];
    TCHAR szRootDir[MAX_PATH+1]; // possible extra '\'
    LPSTR pszPathEnd;
    LPSTR pszRootEnd;

    /* Get the windows directory and simulate PathAddBackslash (which we
     * can't get out of shlwapi, because loadwc.exe also needs to be able
     * to load after IE has been uninstalled and shlwapi deleted).
     *
     * Also build the root directory of the drive that the Windows directory
     * is on, so we can put My Documents there if necessary.
     */
    *szDefaultDir = TEXT('\0');
    GetWindowsDirectory(szDefaultDir, ARRAYSIZE(szDefaultDir));
    StrCpyN(szRootDir, szDefaultDir, ARRAYSIZE(szRootDir));
    MakeWindowsRootPath(szRootDir, ARRAYSIZE(szRootDir));
    pszRootEnd = szRootDir + lstrlen(szRootDir);

    pszPathEnd = CharPrev(szDefaultDir, szDefaultDir + lstrlen(szDefaultDir));
    if (*pszPathEnd != '\\') {
        pszPathEnd = CharNext(pszPathEnd);
        *(pszPathEnd++) = '\\';
    }
    // pszPathEnd now points to where we can append the relative path
    UINT cchPathSpace = ARRAYSIZE(szDefaultDir) - (UINT)(pszPathEnd - szDefaultDir);
    UINT cchRootSpace = ARRAYSIZE(szRootDir) - (UINT)(pszRootEnd - szRootDir);

    err = RegOpenKeyEx(HKEY_CURRENT_USER, "Software\\Microsoft\\Windows\\CurrentVersion\\Explorer\\Shell Folders",
                       0, KEY_QUERY_VALUE | KEY_SET_VALUE, &hkeySF);
    if (err == ERROR_SUCCESS) {
        err = RegOpenKeyEx(HKEY_CURRENT_USER, "Software\\Microsoft\\Windows\\CurrentVersion\\Explorer\\User Shell Folders",
                           0, KEY_QUERY_VALUE, &hkeyUSF);
        if (err == ERROR_SUCCESS) {
            for (UINT i=0; i<ARRAYSIZE(aFolders); i++) {
                TCHAR szRawFolderName[MAX_PATH];
                TCHAR szExpandedFolderName[MAX_PATH];
                DWORD dwType;
                DWORD cbData = sizeof(szRawFolderName);
                LPSTR pszPath;

                err = SHRegGetValue(hkeyUSF, NULL, aFolders[i].pszRegValue, SRRF_RT_ANY | SRRF_NOEXPAND, &dwType, szRawFolderName, &cbData);

                if (err == ERROR_SUCCESS) {

                    switch (dwType)
                    {
                        case REG_SZ:
                            pszPath = szRawFolderName;
                            break;

                        case REG_EXPAND_SZ:
                        {
                            DWORD cchExpanded = ExpandEnvironmentStrings(szRawFolderName, szExpandedFolderName, ARRAYSIZE(szExpandedFolderName));
                            if (cchExpanded <= 0 || cchExpanded > ARRAYSIZE(szExpandedFolderName))
                            {
                                continue;
                            }
                            pszPath = szExpandedFolderName;
                            break;
                        }

                        default:
                            continue;
                    }
                }
                else {
                    if (!MLLoadString(aFolders[i].idsDirName,
                                      aFolders[i].fDefaultInRoot ? pszRootEnd : pszPathEnd,
                                      aFolders[i].fDefaultInRoot ? cchRootSpace : cchPathSpace)) {
                        continue;
                    }
                    if (aFolders[i].fDefaultInRoot)
                        pszPath = szRootDir;
                    else
                        pszPath = szDefaultDir;

                    if (GetFileAttributes(pszPath) == 0xffffffff)
                        CreateDirectory(pszPath, NULL);

                    /* The Win95 shell has a bug where for some shell folders,
                     * if there isn't a path recorded under User Shell Folders,
                     * the shell folder is assumed not to exist.  So, for those
                     * folders only, we also write the default path to USF.
                     * We do not do this generically because no value under
                     * USF is supposed to mean "use the one in the Windows
                     * directory", whereas an absolute path means "use that
                     * path";  if there's a path under USF, it will be used
                     * literally, which is a problem if the folder is set up
                     * to use the shared folder location but roams to a machine
                     * with Windows installed in a different directory.
                     */
                    if (aFolders[i].fWriteToUSF) {
                        RegSetValueEx(hkeyUSF, aFolders[i].pszRegValue, 0, REG_SZ,
                                      (LPBYTE)pszPath, lstrlen(pszPath)+1);
                    }
                }
                RegSetValueEx(hkeySF, aFolders[i].pszRegValue, 0, REG_SZ,
                              (LPBYTE)pszPath, lstrlen(pszPath)+1);
            }

            RegCloseKey(hkeyUSF);
        }
        RegCloseKey(hkeySF);
    }
}


/* Function to determine whether we're in integrated-shell mode or browser-only
 * mode.  The method for doing this (looking for DllGetVersion exported from
 * shell32.dll) is taken from shdocvw.  We don't actually call that entrypoint,
 * we just look for it.
 */
BOOL IsIntegratedShellMode()
{
    FARPROC pfnDllGetVersion = NULL;
    HMODULE hmodShell = LoadLibrary("shell32.dll");
    if (hmodShell != NULL) {
        pfnDllGetVersion = GetProcAddress(hmodShell, "DllGetVersion");
        FreeLibrary(hmodShell);
    }

    return (pfnDllGetVersion != NULL);
}

//
// Convert the string to a DWORD.
//
DWORD StringToDW(LPCTSTR psz)
{
    DWORD dwRet = 0;

    while (*psz >= TEXT('0') && *psz <= TEXT('9'))
    {
        dwRet = dwRet * 10 + *psz - TEXT('0');
        *psz++;
    }

    return dwRet;
}

//
// Is the version string from IE4
//

BOOL IsVersionIE4(LPCTSTR pszVersion)
{
    BOOL fRet = FALSE;

    //
    // IE3.0 is 4.70  and Ie4.0x is >= 4.71.1218.xxxx
    //

    if (pszVersion[0] == TEXT('4') && pszVersion[1] == TEXT('.'))
    {
        DWORD dw = StringToDW(pszVersion+2);

        if (dw > 71 || (dw == 71 && pszVersion[4] == TEXT('.') &&
                        StringToDW(pszVersion+5) >= 1218))
        {
            fRet = TRUE;
        }
    }

    return fRet;
}

//
// Determine if this is an IE4 upgrade.
//
BOOL IsIE4Upgrade()
{
    BOOL fRet = FALSE;

    TCHAR szVersion[MAX_PATH];

    if (ReadRegValue(HKEY_LOCAL_MACHINE,
                     TEXT("Software\\Microsoft\\IE Setup\\Setup"),
                     TEXT("PreviousIESysFile"), (void *)szVersion,
                     sizeof(szVersion)))
    {
        fRet = IsVersionIE4(szVersion);
    }

    return fRet;
}

//
// This is an IE5 or later function.  If the user's machine is running IE4 they
// have uninstalled back to IE4.
//
BOOL IsUninstallToIE4()
{
    BOOL fRet = FALSE;

    TCHAR szVersion[MAX_PATH];

    if (ReadRegValue(HKEY_LOCAL_MACHINE,
                     TEXT("Software\\Microsoft\\Internet Explorer"),
                     TEXT("Version"), (void *)szVersion,
                     sizeof(szVersion)))
    {
        fRet = IsVersionIE4(szVersion);
    }

    return fRet;
}

/* Function to launch miscellaneous applications for browser only mode.
 * We run IEXPLORE.EXE -channelband, looking in the registry for the path
 * to IEXPLORE, and WELCOME.EXE /f, located in the same directory.
 */

#ifdef ENABLE_CHANNELS
const TCHAR c_szChanBarRegPath[] = TEXT("Software\\Microsoft\\Internet Explorer\\Main");
const TCHAR c_szChanBarKey[] = TEXT("Show_ChannelBand");
#endif

void LaunchBrowserOnlyApps()
{
    TCHAR szPath[MAX_PATH];

    /* Don't launch any of these guys if this is a "redist mode" install,
     * i.e. if a game or something installed browser components silently
     * without the user really realizing it's there.
     */
    if (ReadRegValue(HKEY_LOCAL_MACHINE, "Software\\Microsoft\\IE Setup\\Setup",
                     "InstallMode", (void *)szPath, sizeof(szPath))
        && !lstrcmp(szPath, "R")) {
        return;
    }

    LPTSTR pszPathEnd;
    LONG cbPath = sizeof(szPath);

    /* Get the default value from the App Paths\IEXPLORE.EXE reg key, which
     * is the absolute path to the EXE.
     */
    if (RegQueryValue(HKEY_LOCAL_MACHINE, "Software\\Microsoft\\Windows\\CurrentVersion\\App Paths\\IEXPLORE.EXE",
                      szPath, &cbPath) != ERROR_SUCCESS) {
        pszPathEnd = szPath;
        StrCpyN(szPath, "IEXPLORE.EXE", ARRAYSIZE(szPath));    /* can't get from reg, hope it's on the path */
    }
    else {
        /* Find the last backslash in the path.  This is a manual
         * version of strrchr(szPath, '\\').
         */
        LPTSTR pszLastBackslash = NULL;
        for (pszPathEnd = szPath; *pszPathEnd; pszPathEnd = CharNext(pszPathEnd)) {
            if (*pszPathEnd == '\\')
                pszLastBackslash = pszPathEnd;
        }
        if (pszLastBackslash == NULL)
            pszPathEnd = szPath;
        else
            pszPathEnd = pszLastBackslash + 1;      /* point after last backslash */
    }

#ifdef ENABLE_CHANNELS

    /* Don't launch the channel band app if the user doesn't want it.
     * They want it if the reg value is missing, or if it's "yes".
     * On WinNT, we default to "no" for browser-only installs.
     */
    TCHAR szValue[20];
    BOOL  fShowChannelBand=FALSE;

    if (ReadRegValue(HKEY_CURRENT_USER, c_szChanBarRegPath,
                      c_szChanBarKey, (void *)szValue, sizeof(szValue)))
    {
        if (!lstrcmpi(szValue, "yes"))
        {
            fShowChannelBand=TRUE;
        }
    }
    //
    // In general, don't auto launch the channel bar post IE4.
    //
    // Exception:  Show the channelband if there is no Show_ChannelBand key and
    // the user upgraded over IE4 and this is W95 or W98.  This is required
    // because IE4 would launch a channel bar in this scenario w/o writting the
    // Show_ChannelBand key.  We don't want to turn of the channel bar for these
    // users.
    //
    // Another exception:  Loadwc doesn't get uninstalled when IE is
    // uninstalled.  If the user uninstalls IE5+ and goes back to IE4 we want
    // this version of loadwc to revert to IE4 loadwc behavior.
    //
    else
    {
        OSVERSIONINFO vi;
        vi.dwOSVersionInfoSize = sizeof(OSVERSIONINFO);
        GetVersionEx(&vi);

        if (vi.dwPlatformId != VER_PLATFORM_WIN32_NT &&
            (IsIE4Upgrade() || IsUninstallToIE4()))
        {
            fShowChannelBand=TRUE;

            //
            // Set the registry key so this code only runs once and upgrades to
            // IE5 don't have to worry about this scenario.
            //

            WriteRegValue(HKEY_CURRENT_USER, c_szChanBarRegPath, c_szChanBarKey,
                          REG_SZ, TEXT("yes"), sizeof(TEXT("yes")));
        }
        else
        {
            WriteRegValue(HKEY_CURRENT_USER, c_szChanBarRegPath, c_szChanBarKey,
                          REG_SZ, TEXT("no"), sizeof(TEXT("no")));
        }
    }

    if (fShowChannelBand)
    {
        int cLen = lstrlen(szPath);
        StrCpyN(szPath + cLen, " -channelband", ARRAYSIZE(szPath) - cLen);
        WinExec(szPath, SW_SHOWNORMAL);
    }
#endif

    /* Check the registry to see if the welcome app should be launched.  Again,
     * only launch if value is missing or positive (non-zero dword, this time).
     */
    DWORD dwShow = 0;
    if (!ReadRegValue(HKEY_CURRENT_USER, "Software\\Microsoft\\Windows\\CurrentVersion\\Explorer\\Tips",
                      "ShowIE4", (void *)&dwShow, sizeof(dwShow))
        || dwShow) {
        StrCpyN(pszPathEnd, "WELCOME.EXE /f", ARRAYSIZE(szPath) - (UINT)(pszPathEnd - szPath));
        WinExec(szPath, SW_SHOWNORMAL);
    }
}


//----------------------------------------------------------------------------
// WinMain
//----------------------------------------------------------------------------
int WINAPI WinMainT(
    HINSTANCE hInstance,            // handle to current instance
    HINSTANCE hPrevInstance,        // handle to previous instance
    LPSTR lpCmdLine,                // pointer to command line
    int nCmdShow                        // show state of window
   )
{
    HWND hwndOtherInstance;

    // Save the globals
    g.hInstance = hInstance;
    g.nCmdShow = SW_HIDE;
    g.fUninstallOnly = FALSE;
    g.fStartSensLce = FALSE;

    g.fIntShellMode = IsIntegratedShellMode();
    g.hWebcheck = NULL;

    MLLoadResources(g.hInstance, TEXT("loadwclc.dll"));

    // Parse the command line, for DEBUG options and for uninstall-only switch.
    // Now also sets fStartSensLce
    if (!bParseCommandLine(lpCmdLine, nCmdShow))
        return 0;

    // look for webcheck window.  This is ultimately the guy we need to
    // find to load sens/lce late in the game.
    hwndOtherInstance = FindWindow(c_szWebCheckWindow, c_szWebCheckWindow);

    if(NULL == hwndOtherInstance)
    {
        // can't find webcheck, look for loadwc.  If we find him but not
        // webcheck, we either don't have the MOP or we're still in the 15
        // second delay.  Send the messages to loadwc and he'll take care
        // of it.
        hwndOtherInstance = FindWindow(c_szClassName, c_szClassName);
    }

    if(hwndOtherInstance)
    {
        // an instance is already running.  Tell it about Sens/LCE loading
        // requirements and bail out
        if(g.fStartSensLce)
        {
            PostMessage(hwndOtherInstance, WM_START_SENSLCE, 0, 0);
        }
        return 0;
    }

    // Set up the absolute paths for all the shell folders we care about,
    // in case we're in browser-only mode and the shell doesn't support
    // the new ones.
    if (!g.fUninstallOnly)
        InitShellFolders();

    // Run all install/uninstall stubs for browser-only mode.
    // If IE4 has been uninstalled, we'll be run with the -u switch; this
    // means to run install/uninstall stubs only, no webcheck stuff.
    if (!g.fIntShellMode) {
        RunInstallUninstallStubs2(NULL);
    }

    if (g.fUninstallOnly)
        return 0;

    // Launch the channel bar and welcome apps in browser-only mode.
    if (!g.fIntShellMode) {
        LaunchBrowserOnlyApps();
    }

    // Register the window class for the main window.
    WNDCLASS wc;
    if (!hPrevInstance)
    {
        wc.style            = 0;
        wc.lpfnWndProc      = WndProc;
        wc.cbClsExtra       = 0;
        wc.cbWndExtra       = 0;
        wc.hInstance        = hInstance;
        wc.hIcon            = NULL;
        wc.hCursor          = NULL;
        wc.hbrBackground    = (HBRUSH) (COLOR_WINDOW + 1);
        wc.lpszMenuName     = NULL;
        wc.lpszClassName    = c_szClassName;

        if (!RegisterClass(&wc))
            return 0;
    }

    // Create the main window.
    g.hwnd = CreateWindow(c_szClassName,
                            c_szClassName,
                            WS_OVERLAPPEDWINDOW,
                            CW_USEDEFAULT,
                            CW_USEDEFAULT,
                            CW_USEDEFAULT,
                            CW_USEDEFAULT,
                            (HWND) NULL,
                            (HMENU) NULL,
                            hInstance,
                            (LPVOID) NULL);
    if (!g.hwnd)
        return 0;

    // Show the window and paint its contents.
    ShowWindow(g.hwnd, g.nCmdShow);

    // Start the message loop
    MSG msg;
    while (GetMessage(&msg, (HWND) NULL, 0, 0)) {
        TranslateMessage(&msg);
        DispatchMessage(&msg);
    }

    MLFreeResources(g.hInstance);

    // Return the exit code to Windows
    return (int)msg.wParam;
}

//----------------------------------------------------------------------------
// WndProc
//----------------------------------------------------------------------------
LRESULT APIENTRY WndProc(
    HWND hwnd,
    UINT uMsg,
    WPARAM wParam,
    LPARAM lParam
    )
{
    switch (uMsg) {
        case WM_CREATE:
            DWORD   dwTime;
            if(!ReadRegValue(HKEY_CURRENT_USER, c_szWebcheckKey, "DelayLoad", &dwTime, sizeof(dwTime)))
                dwTime = 15;
            SetTimer(hwnd, 1, 1000 * dwTime, NULL);
            break;

        case WM_START_SENSLCE:
            g.fStartSensLce = TRUE;
            break;

        case WM_TIMER:
            KillTimer(hwnd, 1);
            vLoadWebCheck();
            return 0;

        case WM_ENDSESSION:
            if (!wParam)    // if not fEndSession, bail
                break;
            // else fall through to WM_DESTROY

        case WM_DESTROY:
            vUnloadWebCheck();
            PostQuitMessage(0);
            return 0;

        default:
            break;
    }
    return DefWindowProc(hwnd, uMsg, wParam, lParam);
}

//----------------------------------------------------------------------------
// vLoadWebCheck
//----------------------------------------------------------------------------
void vLoadWebCheck(void)
{
    if(g.hWebcheck)
        return;

    g.hWebcheck = LoadLibrary(TEXT("webcheck.dll"));
    if(g.hWebcheck)
    {
        PFNSTART pfn = (PFNSTART)GetProcAddress(g.hWebcheck, (LPCSTR)7);
        if(pfn)
        {
            pfn(g.fStartSensLce);
        }
        else
        {
            // clean up dll
            FreeLibrary(g.hWebcheck);
            g.hWebcheck = NULL;
        }
    }
}

//----------------------------------------------------------------------------
// vUnloadWebCheck
//----------------------------------------------------------------------------
void vUnloadWebCheck(void)
{
    if (!g.hWebcheck)
        return;

    PFNSTOP pfn = (PFNSTOP)GetProcAddress(g.hWebcheck, (LPCSTR)8);
    if(pfn)
    {
        pfn();
    }

    // [darrenmi] don't bother unloading webcheck.  We only do this in
    // response to a shut down so it's not a big deal.  On NT screen saver
    // proxy has a thread that wakes up after the call to StopService - if
    // we've unloaded the dll before then, we're toast.

    // clean up dll
    //FreeLibrary(g.hWebcheck);
    //g.hWebcheck = NULL;
}

//----------------------------------------------------------------------------
// bParseCmdLine
//
// Parse the command line
//      -u  run install/uninstall stubs only, then quit
//  DEBUG options:
//      -v  visible window (easy to shutdown)
//      -a  add webcheck to shell service object
//      -r  remove webcheck from shell service object
//      -s  fix shell folders only
//      -?  these options
//----------------------------------------------------------------------------
BOOL bParseCommandLine(LPSTR lpCmdLine, int nCmdShow)
{
    if (!lpCmdLine)
        return TRUE;

    CharUpper(lpCmdLine);   /* easier to parse */
    while (*lpCmdLine) {
        if (*lpCmdLine != '-' && *lpCmdLine != '/')
            break;

        lpCmdLine++;

        switch (*(lpCmdLine++)) {
        case 'E':
            // ignore 'embedding' command line
            break;
        case 'L':
        case 'M':
            g.fStartSensLce = TRUE;
            break;
        case 'U':
            g.fUninstallOnly = TRUE;
            break;

        }

        while (*lpCmdLine == ' ' || *lpCmdLine == '\t') {
            lpCmdLine++;
        }
    }

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\logondui\backend.h ===
// backend.h
//
#include "logon.h"

//  --------------------------------------------------------------------------
//  CBackgroundWindow
//
//  Purpose:    Simple class to wrap a background window that does nothing
//              but paint black. Useful for hiding areas of the desktop.
//
//  History:    2001-03-27  vtan        created
//  --------------------------------------------------------------------------

class   CBackgroundWindow
{
    private:
                                        CBackgroundWindow (void);
    public:
                                        CBackgroundWindow (HINSTANCE hInstance);
                                        ~CBackgroundWindow (void);

                HWND                    Create (void);
    private:
        static  LRESULT     CALLBACK    WndProc (HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam);
    private:
                HINSTANCE               _hInstance;
                ATOM                    _atom;
                HWND                    _hwnd;

        static  const TCHAR             s_szWindowClassName[];
};

HRESULT TurnOffComputer();
HRESULT UndockComputer();
void KillFlagAnimation();
HRESULT GetLogonUserByLogonName(LPWSTR pszUsername, ILogonUser **ppobjUser);
void CalcBalloonTargetLocation(HWND hwndParent, Element *pe, POINT *ppt);
void ReleaseStatusHost();
void EndHostProcess(UINT uiExitCode);
int GetRegistryNumericValue(HKEY hKey, LPCTSTR pszValueName);
BOOL IsShutdownAllowed();
BOOL IsUndockAllowed();
HRESULT BuildUserListFromGina(LogonFrame* plf, OUT LogonAccount** ppAccount);
void SetErrorHandler (void);
LRESULT CALLBACK LogonWindowProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\logondui\backend.cpp ===
// backend.cpp : Windows Logon application
// 
// backend logic for communicating with SHGina and winlogon

#include "priv.h"

using namespace DirectUI;

#include "resource.h"
#include "backend.h"


#include "shgina.h"
#include "profileutil.h"

#include "uihostipc.h"

////////////////////////////////
#include "eballoon.h"

#define MAX_COMPUTERDESC_LENGTH 255

static WCHAR g_szGuestName[UNLEN + sizeof('\0')] = L"Guest";
#define TIMER_REFRESHTIPS 1014
#define TIMER_ANIMATEFLAG 1015
#define TOTAL_FLAG_FRAMES (FLAG_ANIMATION_COUNT * MAX_FLAG_FRAMES)

UINT_PTR g_puTimerId = 0;
UINT_PTR g_puFlagTimerId = 0;

DWORD sTimerCount = 0;


extern CErrorBalloon g_pErrorBalloon;
extern LogonFrame* g_plf; 
extern ILogonStatusHost *g_pILogonStatusHost;

const TCHAR     CBackgroundWindow::s_szWindowClassName[]    =   TEXT("LogonUIBackgroundWindowClass");

//  --------------------------------------------------------------------------
//  CBackgroundWindow::CBackgroundWindow
//
//  Arguments:  hInstance   =   HINSTANCE of the process.
//
//  Returns:    <none>
//
//  Purpose:    Constructor for CBackgroundWindow. This registers the window
//              class.
//
//  History:    2001-03-27  vtan        created
//  --------------------------------------------------------------------------

CBackgroundWindow::CBackgroundWindow (HINSTANCE hInstance) :
    _hInstance(hInstance),
    _hwnd(NULL)

{
    WNDCLASSEX  wndClassEx;

    ZeroMemory(&wndClassEx, sizeof(wndClassEx));
    wndClassEx.cbSize = sizeof(wndClassEx);
    wndClassEx.lpfnWndProc = WndProc;
    wndClassEx.hInstance = hInstance;
    wndClassEx.lpszClassName = s_szWindowClassName;
    wndClassEx.hCursor = LoadCursor(NULL, IDC_ARROW);
    _atom = RegisterClassEx(&wndClassEx);
}

//  --------------------------------------------------------------------------
//  CBackgroundWindow::~CBackgroundWindow
//
//  Arguments:  <none>
//
//  Returns:    <none>
//
//  Purpose:    Destructor for CBackgroundWindow. This destroys the window
//              and unregisters the window class.
//
//  History:    2001-03-27  vtan        created
//  --------------------------------------------------------------------------

CBackgroundWindow::~CBackgroundWindow (void)

{
    if (_hwnd != NULL)
    {
        (BOOL)DestroyWindow(_hwnd);
    }
    if (_atom != 0)
    {
        TBOOL(UnregisterClass(MAKEINTRESOURCE(_atom), _hInstance));
    }
}

//  --------------------------------------------------------------------------
//  CBackgroundWindow::Create
//
//  Arguments:  <none>
//
//  Returns:    HWND
//
//  Purpose:    Creates the window. It's created WS_EX_TOPMOST and covers the
//              entire screen. It's not created on CHK builds of logonui.exe
//
//  History:    2001-03-27  vtan        created
//  --------------------------------------------------------------------------

HWND    CBackgroundWindow::Create (void)

{
    HWND    hwnd;

#if     DEBUG

    hwnd = NULL;

#else

    hwnd = CreateWindowEx(0,
                          s_szWindowClassName,
                          NULL,
                          WS_POPUP,
                          GetSystemMetrics(SM_XVIRTUALSCREEN), GetSystemMetrics(SM_YVIRTUALSCREEN),
                          GetSystemMetrics(SM_CXVIRTUALSCREEN), GetSystemMetrics(SM_CYVIRTUALSCREEN),
                          NULL, NULL, _hInstance, this);
    if (hwnd != NULL)
    {
        (BOOL)ShowWindow(hwnd, SW_SHOW);
        TBOOL(SetForegroundWindow(hwnd));
        (BOOL)EnableWindow(hwnd, FALSE);
    }

#endif

    return(hwnd);
}

//  --------------------------------------------------------------------------
//  CBackgroundWindow::WndProc
//
//  Arguments:  See the platform SDK under WindowProc.
//
//  Returns:    See the platform SDK under WindowProc.
//
//  Purpose:    WindowProc for the background window. This just passes the
//              messages thru to DefWindowProc.
//
//  History:    2001-03-27  vtan        created
//  --------------------------------------------------------------------------

LRESULT     CALLBACK    CBackgroundWindow::WndProc (HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)

{
    LRESULT             lResult;
    CBackgroundWindow   *pThis;

    pThis = reinterpret_cast<CBackgroundWindow*>(GetWindowLongPtr(hwnd, GWLP_USERDATA));
    switch (uMsg)
    {
        case WM_CREATE:
        {
            CREATESTRUCT    *pCreateStruct;

            pCreateStruct = reinterpret_cast<CREATESTRUCT*>(lParam);
            pThis = reinterpret_cast<CBackgroundWindow*>(pCreateStruct->lpCreateParams);
            (LONG_PTR)SetWindowLongPtr(hwnd, GWLP_USERDATA, reinterpret_cast<LONG_PTR>(pThis));
            lResult = 0;
            break;
        }
        case WM_PAINT:
        {
            HDC             hdcPaint;
            PAINTSTRUCT     ps;

            hdcPaint = BeginPaint(hwnd, &ps);
            TBOOL(FillRect(ps.hdc, &ps.rcPaint, reinterpret_cast<HBRUSH>(GetStockObject(BLACK_BRUSH))));
            TBOOL(EndPaint(hwnd, &ps));
            lResult = 0;
            break;
        }
        default:
            lResult = DefWindowProc(hwnd, uMsg, wParam, lParam);
            break;
    }
    return(lResult);
}


////////////////////////////////////////////////////////
// Logon Utilities
////////////////////////////////////////////////////////

////////////////////////////////////////
//
//  TurnOffComputer
//
//  Call SHGina to bring up the "Turn Off Computer" dialog and handle the request.
//  In debug builds, holding down the shift key and clicking the turn off button
//  will exit logonui.
//
//  RETURNS
//  HRESULT indicating whether it worked or not.  
//
/////////////////////////////////////////
HRESULT TurnOffComputer()
{
    ILocalMachine *pobjLocalMachine;
    HRESULT hr = CoCreateInstance(CLSID_ShellLocalMachine, NULL, CLSCTX_INPROC_SERVER, IID_PPV_ARG(ILocalMachine, &pobjLocalMachine));
    if (SUCCEEDED(hr))
    {
        hr = pobjLocalMachine->TurnOffComputer();
        pobjLocalMachine->Release();
    }
    return hr;
}

////////////////////////////////////////
//
//  UndockComputer
//
//  Tell SHGina to undock the computer
//
//  RETURNS
//  HRESULT indicating whether it worked or not.  
//
/////////////////////////////////////////
HRESULT UndockComputer()
{
    ILocalMachine *pobjLocalMachine;
    HRESULT hr = CoCreateInstance(CLSID_ShellLocalMachine, NULL, CLSCTX_INPROC_SERVER, IID_PPV_ARG(ILocalMachine, &pobjLocalMachine));
    if (SUCCEEDED(hr))
    {
        hr = pobjLocalMachine->UndockComputer();
        pobjLocalMachine->Release();
    }
    return hr;
}

////////////////////////////////////////
//
//  CalcBalloonTargetLocation
//
//  Given a DirectUI element, figure out a good place to have a balloon tip pointed to
//  in parent window coordinates.
//
//  RETURNS
//  nothing  
//
/////////////////////////////////////////
void CalcBalloonTargetLocation(HWND hwndParent, Element *pe, POINT *ppt)
{
    Value* pv;
    BOOL fIsRTL = (GetWindowLong(hwndParent, GWL_EXSTYLE) & WS_EX_LAYOUTRTL) != 0;

    DUIAssertNoMsg(pe);
    DUIAssertNoMsg(ppt);

    // get the position of the link so we can target the balloon tip correctly
    POINT pt = {0,0};

    const SIZE *psize = pe->GetExtent(&pv);
    pt.y += psize->cy / 2;

    if (psize->cx < 100)    
    {
        pt.x += psize->cx / 2;
    }
    else
    {
        if (fIsRTL)
        {
            pt.x = (pt.x + psize->cx) - 50;
        }
        else
        {
            pt.x += 50;
        }
    }

    pv->Release();

    while (pe)
    {
        const POINT* ppt = pe->GetLocation(&pv);
        pt.x += ppt->x;

        pt.y += ppt->y;
        pv->Release();
        pe = pe->GetParent();
    }

    *ppt = pt;
}
////////////////////////////////////////
//
//  DetermineGuestAccountName
//
//
//  Get the localized guest account name by matching the
//  local list of user account SIDs for the guest RID.
//  This code is lifted directly from msgina\userlist.cpp
//  In the event of failure this is initialized to the english "Guest".
//
//
//  RETURNS
//  nothing.  
//
/////////////////////////////////////////
void DetermineGuestAccountName()
{
    NET_API_STATUS      nasCode;
    DWORD               dwPreferredSize, dwEntriesRead;
    NET_DISPLAY_USER    *pNDU;

    static  const int   iMaximumUserCount   =   100;

    dwPreferredSize = (sizeof(NET_DISPLAY_USER) + (3 * UNLEN) * iMaximumUserCount);
    pNDU = NULL;
    nasCode = NetQueryDisplayInformation(NULL,
                                         1,
                                         0,
                                         iMaximumUserCount,
                                         dwPreferredSize,
                                         &dwEntriesRead,
                                         reinterpret_cast<void**>(&pNDU));
    if ((ERROR_SUCCESS == nasCode) || (ERROR_MORE_DATA == nasCode))
    {
        int     iIndex;

        for (iIndex = static_cast<int>(dwEntriesRead - 1); iIndex >= 0; --iIndex)
        {
            BOOL            fResult;
            DWORD           dwSIDSize, dwDomainSize;
            SID_NAME_USE    eUse;
            PSID            pSID;
            WCHAR           wszDomain[DNLEN + sizeof('\0')];

            //  Iterate the user list and look up the SID for each user in the
            //  list regardless of whether they are disabled or not.

            dwSIDSize = dwDomainSize = 0;
            fResult = LookupAccountNameW(NULL,
                                         pNDU[iIndex].usri1_name,
                                         NULL,
                                         &dwSIDSize,
                                         NULL,
                                         &dwDomainSize,
                                         &eUse);
            pSID = static_cast<PSID>(LocalAlloc(LMEM_FIXED, dwSIDSize));
            if (pSID != NULL)
            {
                dwDomainSize = DUIARRAYSIZE(wszDomain);
                fResult = LookupAccountNameW(NULL,
                                             pNDU[iIndex].usri1_name,
                                             pSID,
                                             &dwSIDSize,
                                             wszDomain,
                                             &dwDomainSize,
                                             &eUse);

                //  Ensure that only user SIDs are checked.

                if ((fResult != FALSE) && (SidTypeUser == eUse))
                {
                    unsigned char   ucSubAuthorityCount;
                    int             iSubAuthorityIndex;

                    ucSubAuthorityCount = *GetSidSubAuthorityCount(pSID);
                    for (iSubAuthorityIndex = 0; iSubAuthorityIndex < ucSubAuthorityCount; ++iSubAuthorityIndex)
                    {
                        DWORD   dwSubAuthority;

                        dwSubAuthority = *GetSidSubAuthority(pSID, iSubAuthorityIndex);
                        if (DOMAIN_USER_RID_GUEST == dwSubAuthority)
                        {
                            lstrcpyW(g_szGuestName, pNDU[iIndex].usri1_name);
                        }
                    }
                }
                (HLOCAL)LocalFree(pSID);
            }
        }
    }
    (NET_API_STATUS)NetApiBufferFree(pNDU);
}



////////////////////////////////////////
//
//  GetLogonUserByLogonName
//
//  Given a username, CoCreate the ILogonUser for that name.
//
//  RETURNS
//  HRESULT -- failure if the user could not be created.
//
/////////////////////////////////////////
HRESULT GetLogonUserByLogonName(LPWSTR pszUsername, ILogonUser **ppobjUser)
{
    VARIANT var;
    ILogonEnumUsers *pobjEnum;

    if (ppobjUser)
    {
        *ppobjUser = NULL;
    }

    var.vt = VT_BSTR;
    var.bstrVal = pszUsername;
     
    HRESULT hr = CoCreateInstance(CLSID_ShellLogonEnumUsers, NULL, CLSCTX_INPROC_SERVER, IID_PPV_ARG(ILogonEnumUsers, &pobjEnum));
    if (SUCCEEDED(hr))
    {
        hr = pobjEnum->item(var, ppobjUser);
        pobjEnum->Release();
    }
    return hr;
}

////////////////////////////////////////
//
//  ReleaseStatusHost
//
//  Clean up the logon status host object.
//
//  RETURNS
//  nothing
//
/////////////////////////////////////////
void ReleaseStatusHost()
{
    if (g_pILogonStatusHost != NULL)
    {
        g_pILogonStatusHost->UnInitialize();
        g_pILogonStatusHost->Release();
        g_pILogonStatusHost = NULL;
    }
}

////////////////////////////////////////
//
//  EndHostProcess
//
//  Clean up the logon status host object and if uiExitCode is anything other than 0,
//  then terminate the process immediately.
//
//  RETURNS
//  nothing
//
/////////////////////////////////////////
void EndHostProcess(UINT uiExitCode)
{
    ReleaseStatusHost();
    if (uiExitCode != 0)
    {
        ExitProcess(uiExitCode);
    }
}

////////////////////////////////////////
//
//  GetRegistryNumericValue
//
//  Given a registry HKEY and a value return the numeric value
//
//  RETURNS
//  the numeric value from the registry
//
/////////////////////////////////////////
int GetRegistryNumericValue(HKEY hKey, LPCTSTR pszValueName)

{
    int     iResult;
    DWORD   dwType, dwDataSize;

    iResult = 0;
    if (ERROR_SUCCESS == RegQueryValueEx(hKey,
                                         pszValueName,
                                         NULL,
                                         &dwType,
                                         NULL,
                                         NULL))
    {
        if (REG_DWORD == dwType)
        {
            DWORD   dwData;

            dwDataSize = sizeof(dwData);
            if (ERROR_SUCCESS == RegQueryValueEx(hKey,
                                                 pszValueName,
                                                 NULL,
                                                 NULL,
                                                 reinterpret_cast<LPBYTE>(&dwData),
                                                 &dwDataSize))
            {
                iResult = static_cast<int>(dwData);
            }
        }
        else if (REG_SZ == dwType)
        {
            TCHAR   szData[1024];

            dwDataSize = sizeof(szData);
            if (ERROR_SUCCESS == RegQueryValueEx(hKey,
                                                 pszValueName,
                                                 NULL,
                                                 NULL,
                                                 reinterpret_cast<LPBYTE>(szData),
                                                 &dwDataSize))
            {
                char    szAnsiData[1024];

                (int)WideCharToMultiByte(CP_ACP,
                                         0,
                                         (LPCWSTR)szData,
                                         -1,
                                         szAnsiData,
                                         sizeof(szAnsiData),
                                         NULL,
                                         NULL);
                iResult = atoi(szAnsiData);
            }
        }
    }
    return(iResult);
}

////////////////////////////////////////
//
//  IsShutdownAllowed
//
//  Firstly (firstly??)... if the machine is remote then don't allow shut down.
//  Determine the local machine policy for shutdown from the logon screen.
//  This is stored in two places as two different types (REG_DWORD and REG_SZ).
//  Always check the policy location AFTER the normal location to ensure that
//  policy overrides normal settings.
//
//  RETURNS
//  TRUE if the machine is allowed to be shut down from logonui.  FALSE otherwise
//
/////////////////////////////////////////
BOOL IsShutdownAllowed()
{
    BOOL fResult = FALSE;

    ILocalMachine *pobjLocalMachine;
    HRESULT hr = CoCreateInstance(CLSID_ShellLocalMachine, NULL, CLSCTX_INPROC_SERVER, IID_PPV_ARG(ILocalMachine, &pobjLocalMachine));
    if (SUCCEEDED(hr))
    {
        VARIANT_BOOL vbCanShutdown = VARIANT_FALSE; 
        hr = pobjLocalMachine->get_isShutdownAllowed(&vbCanShutdown);
        
        if (SUCCEEDED(hr))
        {
            fResult = (vbCanShutdown == VARIANT_TRUE);
        }
        pobjLocalMachine->Release();
    }
    return fResult;
}

////////////////////////////////////////
//
//  IsUndockAllowed
//
//  Check with SHGina to see if we are allowed to undock the PC.
//
//  RETURNS
//  TRUE if the machine is allowed to be undocked from logonui.  FALSE otherwise
//
/////////////////////////////////////////
BOOL IsUndockAllowed()
{
    BOOL fResult = FALSE;
#if 0   
    ILocalMachine *pobjLocalMachine;
    HRESULT hr = CoCreateInstance(CLSID_ShellLocalMachine, NULL, CLSCTX_INPROC_SERVER, IID_PPV_ARG(ILocalMachine, &pobjLocalMachine));
    if (SUCCEEDED(hr))
    {
        VARIANT_BOOL vbCanUndock = VARIANT_FALSE; 
        hr = pobjLocalMachine->get_isUndockEnabled(&vbCanUndock);
        
        if (SUCCEEDED(hr))
        {
            fResult = (vbCanUndock == VARIANT_TRUE);
        }
        pobjLocalMachine->Release();
    }
#endif
    return fResult;
}

#ifndef TESTDATA
LONG    WINAPI  LogonUIUnhandledExceptionFilter (struct _EXCEPTION_POINTERS *ExceptionInfo)

{
    return(RtlUnhandledExceptionFilter(ExceptionInfo));
}
#endif // !TESTDATA


void SetErrorHandler (void)

{
#ifndef TESTDATA
    SYSTEM_KERNEL_DEBUGGER_INFORMATION  kdInfo;

    (NTSTATUS)NtQuerySystemInformation(SystemKernelDebuggerInformation,
                                       &kdInfo,
                                       sizeof(kdInfo),
                                       NULL);
    if (kdInfo.KernelDebuggerEnabled || NtCurrentPeb()->BeingDebugged)
    {
        (LPTOP_LEVEL_EXCEPTION_FILTER)SetUnhandledExceptionFilter(LogonUIUnhandledExceptionFilter);
    }
#endif // !TESTDATA
}

////////////////////////////////////////
//
//  RunningInWinlogon
//
//  Checks to see if logonui is running in the winlogon context.  There are some things
//  that don't work well when we are not in winlogon so this makes debugging easier.
//
//  RETURNS
//  TRUE if the running in winlogon (actually if it can find the GINA Logon window).  FALSE otherwise
//
/////////////////////////////////////////
BOOL RunningInWinlogon()
{
#if DEBUG           
    return (FindWindow(NULL, TEXT("GINA Logon")) != NULL);
#else
    return true;
#endif
}


////////////////////////////////////////
//
//  BuildUserListFromGina
//
//  Enumerate all of the users that SHGina tells us we care about and add them to the accounts list.
//  Find out of they require a password and their current state for notifications.
//
//  If there is only 1 user or if there are 2 users, but one of them is guest, then ppAccount will
//  contain a pointer to the only user on this machine.  The caller can then automatically select
//  that user to avoid them from having to click that user given that there is no one else to click.
//  
//
//  RETURNS
//  HRESULT -- if not a success code, we are hosed.
//
/////////////////////////////////////////
HRESULT BuildUserListFromGina(LogonFrame* plf, OUT LogonAccount** ppAccount)
{
    if (ppAccount)
    {
        *ppAccount = NULL;
    }

    DetermineGuestAccountName();

    int iGuestId = -1;
    WCHAR szPicturePath[MAX_PATH];
    ILogonEnumUsers *pobjEnum;
    LogonAccount* plaLastNormal = NULL;
    // load the ILogonEnumUsers object from SHGina.dll
    HRESULT hr = CoCreateInstance(CLSID_ShellLogonEnumUsers, NULL, CLSCTX_INPROC_SERVER, IID_PPV_ARG(ILogonEnumUsers, &pobjEnum));
    if (SUCCEEDED(hr))
    {
        int iUser,cUsers;
        UINT uiUsers;
        ILogonUser *pobjUser;

        // get the number of users
        hr = pobjEnum->get_length(&uiUsers);
        if (FAILED(hr))
            goto done;

        cUsers = (int)uiUsers;
        for (iUser = 0; iUser < cUsers; iUser++)
        {
            VARIANT var, varUnreadMail, varPicture = {0}, varUsername = {0}, varHint = {0};
            VARIANT_BOOL vbLoggedOn, vbInteractiveLogonAllowed;

            var.vt = VT_I4;
            var.lVal = iUser;
            hr = pobjEnum->item( var, &pobjUser);

            if (SUCCEEDED(hr) && pobjUser)
            {
                if (SUCCEEDED(pobjUser->get_interactiveLogonAllowed(&vbInteractiveLogonAllowed)) &&
                    (vbInteractiveLogonAllowed != VARIANT_FALSE))
                {
                    // get the display name for the user
                    pobjUser->get_setting(L"DisplayName" ,&var);
                    pobjUser->get_setting(L"LoginName", &varUsername);

                    // if the display name is blank, we will use the login name.  This is the case for Guest
                    if (var.bstrVal && lstrlenW(var.bstrVal) == 0)
                    {
                        VariantClear(&var);
                        pobjUser->get_setting(L"LoginName" ,&var);
                    }
                    
                    if (FAILED(pobjUser->get_isLoggedOn(&vbLoggedOn)))
                    {
                        vbLoggedOn = VARIANT_FALSE;
                    }
                    
                    if (FAILED(pobjUser->get_setting(L"UnreadMail", &varUnreadMail)))
                    {
                        varUnreadMail.uintVal = 0;
                    }

                    lstrcpyW(szPicturePath, L"");
                    // get the path to their picture
                    if (SUCCEEDED(pobjUser->get_setting(L"Picture" ,&varPicture)))
                    {
                        if (lstrlenW(varPicture.bstrVal) != 0) // in the case of defaultUser, lets just use the user icons we have.
                        {
                            lstrcpynW(szPicturePath, &(varPicture.bstrVal[7]), MAX_PATH);
                        }
                        VariantClear(&varPicture);
                    }

                    VariantClear(&varHint);
                    hr = pobjUser->get_setting(L"Hint", &varHint);
                    if (FAILED(hr) || varHint.vt != VT_BSTR)
                    {
                        VariantClear(&varHint);
                    }
                    if (lstrcmpi(g_szGuestName, var.bstrVal) == 0)
                    {
                        iGuestId = iUser;
                    }
                
                    LogonAccount* pla = NULL;
                    // If no picture is available, default to one
                    hr = plf->AddAccount(*szPicturePath ? szPicturePath : MAKEINTRESOURCEW(IDB_USER0),
                               *szPicturePath == NULL,
                               var.bstrVal,
                               varUsername.bstrVal,
                               varHint.bstrVal,
                               (vbLoggedOn == VARIANT_TRUE),
                               &pla);

//                    pla->UpdateNotifications(true);

                    if (SUCCEEDED(hr) && (iGuestId != iUser))
                    {
                        plaLastNormal = pla;
                    }

                    VariantClear(&var);
                    VariantClear(&varHint);
                    VariantClear(&varUsername);
                }
                pobjUser->Release();
            }

        }

        // if there is only one user, select them by default.  Ignore guest.
        if (ppAccount && plaLastNormal && (cUsers == 1 || 
            (cUsers == 2 && iGuestId != -1)))
        {
            *ppAccount = plaLastNormal;
        }

done:   
        pobjEnum->Release();
    }
    

    // User logon list is now available
    plf->SetUserListAvailable(true);

    //DUITrace("LOGONUI: UserList is now available\n");

    return hr;
}



////////////////////////////////////////
//
//  KillFlagAnimation
//
//  Stop the flag from animating immediately.  What it actually does is check to
//  see if we are still animating the flag and if we are, then set the frame
//  counter to the end and set the bitmap to the first frame in the animation.
//  The next time the timer fires, it will see that we are done and actually
//  kill the timer.
//  
/////////////////////////////////////////
void KillFlagAnimation()
{
#ifdef ANIMATE_FLAG
    if (sTimerCount > 0 && sTimerCount < TOTAL_FLAG_FRAMES)
    {
        sTimerCount = TOTAL_FLAG_FRAMES + 1;
        if (g_plf != NULL)
        {
            g_plf->NextFlagAnimate(0);
        }
    }
#endif
}


////////////////////////////////////////
//
//  LogonWindowProc
//
//  This is the notification window that SHGina uses to communicate with logonui.
//  Send all messages through the helper in logonstatushost and check for our
//  own messages on this window.  This is where all of the SHGina notifications come.
//
////////////////////////////////////////
LRESULT CALLBACK LogonWindowProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    static BOOL sResetTimer = false;

    LogonFrame  *pLogonFrame;

    pLogonFrame = g_plf;
    if (g_pILogonStatusHost != NULL)
    {
        VARIANT varWParam, varLParam;

        varWParam.uintVal = static_cast<UINT>(wParam);
        varLParam.lVal = static_cast<LONG>(lParam);
        if (SUCCEEDED(g_pILogonStatusHost->WindowProcedureHelper(hwnd, uMsg, varWParam, varLParam)))
        {
            return 0;
        }
    }
    switch (uMsg)
    {
        case WM_TIMER:
            if ((pLogonFrame != NULL) && (pLogonFrame->GetState() == LAS_Logon) && (wParam == TIMER_REFRESHTIPS))
            {
                BOOL fRefreshAll = false;

                if (!sResetTimer)
                {
                    fRefreshAll = true;
                    sResetTimer = true;
                    KillTimer(hwnd, g_puTimerId);
                    g_puTimerId = SetTimer(hwnd, TIMER_REFRESHTIPS, 15000, NULL);       // update the values 15 seconds
#ifdef ANIMATE_FLAG
                    g_puFlagTimerId = SetTimer(hwnd, TIMER_ANIMATEFLAG, 20, NULL);    // start the flag animation
#endif
                }

                pLogonFrame->UpdateUserStatus(fRefreshAll);
                return 0;
            }
#ifdef ANIMATE_FLAG
            if (wParam == TIMER_ANIMATEFLAG)
            {
                if (sTimerCount > TOTAL_FLAG_FRAMES)
                {
                    sTimerCount = 0;
                    KillTimer(hwnd, g_puFlagTimerId);
                    pLogonFrame->NextFlagAnimate(0);
                }
                else
                {
                    sTimerCount ++;
                    pLogonFrame->NextFlagAnimate(sTimerCount % MAX_FLAG_FRAMES);
                }
                return 0;
            }
#endif
            break;

        case WM_UIHOSTMESSAGE:
            switch (wParam)
            {
                case HM_SWITCHSTATE_STATUS:                 // LAS_PreStatus
                    if (pLogonFrame != NULL)
                    {
                        pLogonFrame->EnterPreStatusMode(lParam != 0);
                    }
                    break;

                case HM_SWITCHSTATE_LOGON:                  // LAS_Logon
                    if (pLogonFrame != NULL)
                    {
                        pLogonFrame->EnterLogonMode(lParam != 0);
                    }
                    if (g_puTimerId != 0)
                    {
                        sResetTimer = false;
                        KillTimer(hwnd, g_puTimerId);
                    }
                    g_puTimerId = SetTimer(hwnd, TIMER_REFRESHTIPS, 250, NULL);       // update the values in 1 second
                    break;

                case HM_SWITCHSTATE_LOGGEDON:               // LAS_PostStatus
                    if (pLogonFrame != NULL)
                    {
                        pLogonFrame->EnterPostStatusMode();
                    }
                    break;

                case HM_SWITCHSTATE_HIDE:                   // LAS_Hide
                    if (pLogonFrame != NULL)
                    {
                        if (LogonAccount::GetCandidate())
                        {
                            LogonAccount* pla = LogonAccount::GetCandidate();
                            pla->InsertStatus(0);
                            pla->SetStatus(0, L"");
                            pla->ShowStatus(0);
                        }
                        else
                        {
                            pLogonFrame->SetStatus(L"");
                        }
                        pLogonFrame->EnterHideMode();
                    }
                    goto killTimer;
                    break;

                case HM_SWITCHSTATE_DONE:                   // LAS_Done
                    if (pLogonFrame != NULL)
                    {
                        pLogonFrame->EnterDoneMode();
                    }
killTimer:
                    if (g_puTimerId != 0)
                    {
                        KillTimer(hwnd, g_puTimerId);
                        g_puTimerId = 0;
                    }
                    break;

                case HM_NOTIFY_WAIT:
                    if (pLogonFrame != NULL)
                    {
                        pLogonFrame->SetTitle(IDS_PLEASEWAIT);
                    }
                    break;

                case HM_SELECT_USER:
                    if (pLogonFrame != NULL)
                    {
                        pLogonFrame->SelectUser(reinterpret_cast<SELECT_USER*>(lParam)->szUsername);
                    }
                    break;

                case HM_SET_ANIMATIONS:
                    if (pLogonFrame != NULL)
                    {
                        pLogonFrame->SetAnimations(lParam != 0);
                    }
                    break;

                case HM_DISPLAYSTATUS:
                    if ((pLogonFrame != NULL) && (lParam != NULL))
                    {
                        if (pLogonFrame->GetState() == LAS_PostStatus)
                        {
                            if (LogonAccount::GetCandidate())
                            {
                                LogonAccount* pla = LogonAccount::GetCandidate();
                                pla->InsertStatus(0);
                                pla->SetStatus(0, (WCHAR*)lParam);
                                pla->ShowStatus(0);
                            }
                            else
                            {
                                pLogonFrame->SetStatus((WCHAR*)lParam);
                            }
                        }
                        else
                        {
                            pLogonFrame->SetStatus((WCHAR*)lParam);
                        }
                    }
                    break;

                case HM_DISPLAYREFRESH:
                    if (pLogonFrame != NULL)
                    {
                        pLogonFrame->UpdateUserStatus(true);
                    }
                    break;

                case HM_DISPLAYRESIZE:
                    if (pLogonFrame != NULL)
                    {
                        pLogonFrame->Resize();
                    }
                    break;

                case HM_INTERACTIVE_LOGON_REQUEST:
                    return((pLogonFrame != NULL) && pLogonFrame->InteractiveLogonRequest(reinterpret_cast<INTERACTIVE_LOGON_REQUEST*>(lParam)->szUsername, reinterpret_cast<INTERACTIVE_LOGON_REQUEST*>(lParam)->szPassword));
            }
            break;
    }
    return DefWindowProc(hwnd, uMsg,wParam, lParam);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\logondui\fx.h ===
#if !defined(LOGON__Fx_h__INCLUDED)
#define LOGON__Fx_h__INCLUDED
#pragma once

#ifdef GADGET_ENABLE_GDIPLUS

enum EFadeDirection
{
    fdIn,
    fdOut
};


void
FxSetAlpha(
    IN  Element * pe,
    IN  float flNewAlpha);

HRESULT
FxPlayLinearAlpha(
    IN  Element * pe,
    IN  float flOldAlpha,
    IN  float flNewAlpha,
    IN  float flDuration = 0.5f,
    IN  float flDelay = 0.0f);

HRESULT 
FxInitGuts();

#endif // GADGET_ENABLE_GDIPLUS

#endif // LOGON__Fx_h__INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\logondui\eballoon.cpp ===
#include "priv.h"

#include <commctrl.h>

#include "EBalloon.h"

#undef ASSERT
#define ASSERT(x)

BOOL g_bMirroredOS = false;

CErrorBalloon::CErrorBalloon()
{
    // our allocation function should have zeroed our memory.  Check to make sure:
    ASSERT(0==m_hwndToolTip);
    ASSERT(0==m_uTimerID);
    g_bMirroredOS = IS_MIRRORING_ENABLED();
}

CErrorBalloon::~CErrorBalloon()
{

}

LRESULT CALLBACK CErrorBalloon::SubclassProc( HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam, UINT_PTR uID, ULONG_PTR dwRefData)
{
    UNREFERENCED_PARAMETER(uID);
    CErrorBalloon * pthis = (CErrorBalloon*)dwRefData;

    switch (uMsg)
    {
        // Do not autodismiss until after markup has had a chance to
        // parse the WM_LBUTTONUP to see if it's a link click or not
        case WM_LBUTTONUP:
            DefSubclassProc(hwnd, uMsg, wParam, lParam);
            pthis->HideToolTip();
            return 0;

        case WM_TIMER:
            if (wParam == ERRORBALLOONTIMERID)
            {
                pthis->HideToolTip();
                return 0;
            }
            break;

        default:
            break;
    }

    return DefSubclassProc(hwnd, uMsg, wParam, lParam);
}

void CErrorBalloon::ShowToolTip(HINSTANCE hInstance, HWND hwndTarget, const POINT *ppt, LPTSTR pszMessage, LPTSTR pszTitle, DWORD dwIconIndex, DWORD dwFlags, int iTimeout)
{
    hinst = hInstance;
    
    if (m_hwndToolTip)
    {
        HideToolTip();
    }

    m_hwndTarget = hwndTarget;
    m_dwIconIndex = dwIconIndex;

    if ( !m_hwndToolTip )
    {
        CreateToolTipWindow();
    }

    int x, y;
    x = ppt->x;
    y = ppt->y;

    SendMessage(m_hwndToolTip, TTM_TRACKPOSITION, 0, MAKELONG(x,y));

    if (pszTitle)
    {
        SendMessage(m_hwndToolTip, TTM_SETTITLE, (WPARAM)dwIconIndex, (LPARAM)pszTitle);
    }

    TOOLINFO ti = {0};
    ti.cbSize = TTTOOLINFOW_V2_SIZE;
    ti.hwnd = m_hwndTarget;
    ti.uId = 1;

    SendMessage(m_hwndToolTip, TTM_GETTOOLINFO, 0, (LPARAM)&ti);

    ti.uFlags &= ~TTF_PARSELINKS;
    if (dwFlags & EB_MARKUP)
    {
        ti.uFlags |= TTF_PARSELINKS;
    }
    ti.lpszText = pszMessage;

    SendMessage(m_hwndToolTip, TTM_SETTOOLINFO, 0, (LPARAM)&ti);

    // Show the tooltip
    SendMessage(m_hwndToolTip, TTM_TRACKACTIVATE, TRUE, (LPARAM)&ti);

    // Set a timer to hide the tooltip
    if ( m_uTimerID )
    {
        KillTimer(NULL,ERRORBALLOONTIMERID);
    }
    m_uTimerID = SetTimer(m_hwndToolTip, ERRORBALLOONTIMERID, iTimeout, NULL);

    SetWindowSubclass(m_hwndToolTip, CErrorBalloon::SubclassProc, (UINT_PTR)this, (LONG_PTR)this);
}


void CErrorBalloon::ShowToolTip(HINSTANCE hInstance, HWND hwndTarget, LPTSTR pszMessage, LPTSTR pszTitle, DWORD dwIconIndex, DWORD dwFlags, int iTimeout)
{
    // Set the tooltip display point
    RECT rc;
    GetWindowRect(hwndTarget, &rc);
    POINT pt;
    pt.x = (rc.left+rc.right)/2;
    if ( EB_WARNINGABOVE & dwFlags )
    {
        pt.y = rc.top;
    }
    else if ( EB_WARNINGCENTERED & dwFlags )
    {
        pt.y = (rc.top+rc.bottom)/2;
    }
    else
    {
        pt.y = rc.bottom;
    }

    ShowToolTip(hInstance, hwndTarget, &pt, pszMessage, pszTitle, dwIconIndex, dwFlags, iTimeout);
}

// CreateToolTipWindow
//
// Creates our tooltip control.  We share this one tooltip control and use it for all invalid
// input messages.  The control is hiden when not in use and then shown when needed.
//
void CErrorBalloon::CreateToolTipWindow()
{
    DWORD dwExStyle = 0;
    if (IS_BIDI_LOCALIZED_SYSTEM())
        dwExStyle |= WS_EX_LAYOUTRTL;

    m_hwndToolTip = CreateWindowEx(
            dwExStyle,
            TOOLTIPS_CLASS,
            NULL,
            WS_POPUP | TTS_NOPREFIX | TTS_ALWAYSTIP | TTS_BALLOON,
            CW_USEDEFAULT,
            CW_USEDEFAULT,
            CW_USEDEFAULT,
            CW_USEDEFAULT,
            m_hwndTarget,
            NULL,
            GetModuleHandle(NULL),
            NULL);

    if (m_hwndToolTip)
    {
        TOOLINFO ti = {0};

        ti.cbSize = TTTOOLINFOW_V2_SIZE;
        ti.uFlags = TTF_TRACK;
        ti.hwnd = m_hwndTarget;
        ti.uId = 1;
        ti.hinst = hinst;
        ti.lpszText = NULL;

        // set the version so we can have non buggy mouse event forwarding
        SendMessage(m_hwndToolTip, CCM_SETVERSION, COMCTL32_VERSION, 0);
        SendMessage(m_hwndToolTip, TTM_ADDTOOL, 0, (LPARAM)&ti);
        SendMessage(m_hwndToolTip, TTM_SETMAXTIPWIDTH, 0, 300);
    }
    else
    {
        // failed to create tool tip window, now what should we do?  Unsubclass ourselves?
    }
}

void CErrorBalloon::HideToolTip()
{
    // When the timer fires we hide the tooltip window
    if ( m_uTimerID )
    {
        KillTimer(m_hwndTarget,ERRORBALLOONTIMERID);
        m_uTimerID = 0;
    }
    if ( m_hwndToolTip )
    {
        HWND hwndTip = m_hwndToolTip;
        m_hwndToolTip = NULL;
        SendMessage(hwndTip, TTM_TRACKACTIVATE, FALSE, 0);
        DestroyWindow(hwndTip);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\logondui\langicon.h ===
/****************************** Module Header ******************************\
* Module Name: langicon.h
*
* Copyright (c) 1998, Microsoft Corporation
*
* Define apis in langicon.cpp
*
\***************************************************************************/

//
// Prototypes
//

typedef enum _LAYOUT_USER {
    LAYOUT_DEF_USER,
    LAYOUT_CUR_USER
} LAYOUT_USER;

#define TIMER_MYLANGUAGECHECK     1

BOOL
DisplayLanguageIcon(
    LAYOUT_USER LayoutUser,
    HKL  hkl);

void
FreeLayoutInfo(
    LAYOUT_USER LayoutUser);

void
LayoutCheckHandler(
    LAYOUT_USER LayoutUser);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\logondui\eballoon.h ===
class CErrorBalloon
{
public:
    CErrorBalloon();
    ~CErrorBalloon();

    void ShowToolTip(HINSTANCE hInstance, HWND hwndTarget, LPTSTR pszMessage, LPTSTR pszTitle, DWORD dwIconIndex, DWORD dwFlags, int iTimeout);
    void ShowToolTip(HINSTANCE hInstance, HWND hwndTarget, const POINT *ppt, LPTSTR pszMessage, LPTSTR pszTitle, DWORD dwIconIndex, DWORD dwFlags, int iTimeout);
    void HideToolTip();
    void CreateToolTipWindow();
    static LRESULT CALLBACK SubclassProc( HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam, UINT_PTR uID, ULONG_PTR dwRefData);

protected:
	HINSTANCE	hinst;
    HICON       hIcon;          // handle to an icon, or I_ICONCALLBACK if the notify window should be asked to provide an icon.
    HWND        hwndNotify;     // handle to a window to process notify messages
    INT         cxTipWidth;     // max width of the tooltip in pixels.  Defaults to 500.
    HWND        m_hwndTarget;   // the targeted control hwnd
    HWND        m_hwndToolTip;  // the tooltip control
    UINT_PTR    m_uTimerID;     // the timer id
    DWORD       m_dwIconIndex;  // icon index for the balloon
};


#define ERRORBALLOONTIMERID 1000
#define EB_WARNINGBELOW    0x00000000      // default value.  Balloon tooltips will be shown below the window by default.
#define EB_WARNINGABOVE    0x00000004      // Ballon tooltips will be shown above the window by default.
#define EB_WARNINGCENTERED 0x00000008      // Ballon tooltips will be shown pointing to the center of the window.
#define EB_MARKUP          0x00000010      // Interpret <A> as markup
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\logondui\fx.cpp ===
#include "priv.h"

#ifdef GADGET_ENABLE_GDIPLUS

using namespace DirectUI;

#include "Logon.h"
#include "Fx.h"

#include "Stub.h"
#include "Super.h"

const float flIGNORE    = -10000.0f;
const float flFadeOut   = 0.50f;

#define ENABLE_USEVALUEFLOW         1

/***************************************************************************\
*
* F2T
*
* F2T() converts from frames to time, using a constant.  This allows easily
* conversion from frames in Flash or Director to time used by DirectUser.
*
\***************************************************************************/

inline float
F2T(
    IN  int cFrames)
{
    return cFrames / 30.0f;
}


inline BYTE
GetAlphaByte(float fl)
{
    if (fl <= 0.0f) {
        return 0;
    } else if (fl >= 1.0f) {
        return 255;
    } else {
        return (BYTE) (fl * 255.0f);
    }
}


inline float
GetAlphaFloat(BYTE b)
{
    return b * 255.0f;
}


/***************************************************************************\
*
* GetVPatternDelay
*
* GetVPatternDelay() computes the delay time for a standard "v-pattern" of
* items that start from the middle and work outward.
*
\***************************************************************************/

inline float
GetVPatternDelay(
    IN  float flTimeLevel,
    IN  EFadeDirection dir,
    IN  int idxCur,
    IN  int cItems)
{
    float flBase = flTimeLevel * (float) (abs(cItems / 2 - idxCur));

    switch (dir)
    {
    case fdIn:
        return flBase;
        
    case fdOut:
        return flTimeLevel * (abs(cItems / 2)) - flBase;

    default:
        DUIAssertForce("Unknown direction");
        return 0;
    }
}


//------------------------------------------------------------------------------
HRESULT
BuildLinearAlpha(
    OUT Sequence ** ppseq,
    OUT Interpolation ** ppip)
{
    HRESULT hr = E_FAIL;
    LinearInterpolation * pip = NULL;
#if ENABLE_USEVALUEFLOW
    ValueFlow * pflow = NULL;
#else
    AlphaFlow * pflow = NULL;
#endif
    Sequence * pseq = NULL;

    pip = LinearInterpolation::Build();
    if (pip == NULL) {
        hr = HRESULT_FROM_WIN32(GetLastError());
        goto ErrorExit;
    }
    
#if ENABLE_USEVALUEFLOW
    ValueFlow::ValueFlowCI fci;
    ZeroMemory(&fci, sizeof(fci));
    fci.cbSize      = sizeof(fci);

    pflow = ValueFlow::Build(&fci);
#else
    Flow::FlowCI fci;
    ZeroMemory(&fci, sizeof(fci));
    fci.cbSize      = sizeof(fci);

    pflow = AlphaFlow::Build(&fci);
#endif
    if (pflow == NULL) {
        hr = HRESULT_FROM_WIN32(GetLastError());
        goto ErrorExit;
    }
        
    pseq = Sequence::Build();
    if (pseq == NULL) {
        hr = HRESULT_FROM_WIN32(GetLastError());
        goto ErrorExit;
    }
    
    pseq->SetFlow(pflow);
    pflow->Release();

    *ppseq = pseq;
    *ppip = pip;
    return S_OK;

ErrorExit:
    if (pseq != NULL)
        pseq->Release();
    if (pflow != NULL) 
        pflow->Release();
    if (pip != NULL)
        pip->Release();

    *ppseq = NULL;
    *ppip = NULL;
    
    return hr;
}


/***************************************************************************\
*
* class SyncVisible
*
* SyncVisible provides a mechansim to synchronize state between DirectUI and
* DirectUser for the fading in / out effects.  This allows an Element to be
* marked as "visible" during the fade out and then become "not visible" when
* the fade is done.  
*
* This is important for several reasons, including not modifying the mouse
* cursor when an Element becomes invisible.
*
\***************************************************************************/

class SyncVisible
{
public:
    static void Wait(Element * pel, EventGadget * pgeOperation, UINT nMsg)
    {
        SyncVisible * psv = new SyncVisible;
        if (psv != NULL)
        {
            psv->_pel = pel;
            if (SUCCEEDED(pgeOperation->AddHandlerD(nMsg, EVENT_DELEGATE(psv, EventProc))))
            {
                // Successfully attached delegate
                return;
            }
            delete psv;
        }
        
        // Unable to create a delegate, so set now
        Sync(pel);
    }

    static void Wait(Element * pel, EventGadget * pgeOperation, const GUID * pguid)
    {
        MSGID nMsg;
        if (FindGadgetMessages(&pguid, &nMsg, 1)) 
        {
            SyncVisible * psv = new SyncVisible;
            if (psv != NULL)
            {
                psv->_nMsg = nMsg;
                psv->_pel = pel;
                psv->_pgeOperation = pgeOperation;
                if (SUCCEEDED(pgeOperation->AddHandlerD(nMsg, EVENT_DELEGATE(psv, EventProc))))
                {
                    // Successfully attached delegate
                    return;
                }
                delete psv;
            }
        }
        
        // Unable to create a delegate, so set now
        Sync(pel);
    }

    static void Sync(Element * pel)
    {
        HGADGET hgad = pel->GetDisplayNode();
        bool fVisible = true;
    
        if (GetGadgetStyle(hgad) & GS_BUFFERED)
        {
            BUFFER_INFO bi;
            bi.cbSize = sizeof(bi);
            bi.nMask = GBIM_ALPHA;
            GetGadgetBufferInfo(hgad, &bi);

            if (bi.bAlpha < 5)
                fVisible = false;
        }
        
        pel->SetVisible(fVisible);
    }
    
protected:
    UINT CALLBACK EventProc(GMSG_EVENT * pmsg)
    {
        DUIAssert(GET_EVENT_DEST(pmsg) == GMF_EVENT, "Must be an event handler");
        Animation::CompleteEvent * pmsgC = (Animation::CompleteEvent *) pmsg;
        
        if (pmsgC->fNormal) {
            Sync(_pel);
        }
        
        _pgeOperation->RemoveHandlerD(_nMsg, EVENT_DELEGATE(this, EventProc));

        delete this;
        return GPR_NOTHANDLED;
    }

    UINT            _nMsg;
    Element *       _pel;
    EventGadget *   _pgeOperation;
};


/***************************************************************************\
*
* FxSetAlpha
*
* FxSetAlpha() provides a convenient mechanism to directly set the DirectUser
* "alpha" state on a Visual Gadget without modifying the DirectUI "alpha"
* property.
*
* NOTE: Eventually, we want to synchronize these, but for now, the DirectUI
* "alpha" property doesn't work with DirectUser's new (improved!) Animations
* infrastructure.
*
\***************************************************************************/

void
FxSetAlpha(
    IN  Element * pe,
    IN  float flNewAlpha,
    IN  float fSync)
{
#if ENABLE_USEVALUEFLOW
    pe->SetAlpha(GetAlphaByte(flNewAlpha));
#else
    HGADGET hgad = pe->GetDisplayNode();
    
    if (flNewAlpha >= 0.97f) {
        // Turn off alpha
        SetGadgetStyle(hgad, 0, GS_BUFFERED);
    } else {
        SetGadgetStyle(hgad, GS_BUFFERED | GS_OPAQUE, GS_BUFFERED | GS_OPAQUE);
    
        BUFFER_INFO bi;
        ZeroMemory(&bi, sizeof(bi));
        bi.cbSize   = sizeof(bi);
        bi.nMask    = GBIM_ALPHA;
        bi.bAlpha   = (BYTE) (flNewAlpha * 255.0f);
        SetGadgetBufferInfo(hgad, &bi);
    }
#endif

    if (fSync) {
        SyncVisible::Sync(pe);
    }
}


/***************************************************************************\
*
* FxPlayLinearAlpha
*
* FxPlayLinearAlpha() "plays" a linear, "simple" alpha-animation on a given 
* Element.
*
\***************************************************************************/

HRESULT
FxPlayLinearAlpha(
    IN  Element * pe,
    IN  float flOldAlpha,
    IN  float flNewAlpha,
    IN  float flDuration,
    IN  float flDelay)
{
    HRESULT hr = E_FAIL;
    HGADGET hgad = pe->GetDisplayNode();
    DUIAssert(hgad != NULL, "Must have valid Gadget");
    Visual * pgvSubject = Visual::Cast(hgad);

    pgvSubject->SetStyle(GS_OPAQUE, GS_OPAQUE);


    //
    // If an old alpha is specified, have it take place immediately.  We can't
    // use the Animation to do this because it will wait the delay.
    //
    
    if (flOldAlpha >= 0.0f) {
        FxSetAlpha(pe, flOldAlpha, false);
    }


    LinearInterpolation * pip = NULL;
#if ENABLE_USEVALUEFLOW
    ValueFlow * pflow = NULL;
    ValueFlow::ValueKeyFrame kf;
#else
    AlphaFlow * pflow = NULL;
    AlphaFlow::AlphaKeyFrame kf;
#endif
    Animation * pani = NULL;

    pip = LinearInterpolation::Build();
    if (pip == NULL) {
        hr = HRESULT_FROM_WIN32(GetLastError());
        goto ErrorExit;
    }
    
#if ENABLE_USEVALUEFLOW
    ValueFlow::ValueFlowCI fci;
    ZeroMemory(&fci, sizeof(fci));
    fci.cbSize      = sizeof(fci);
    fci.pgvSubject  = pgvSubject;
    fci.ppi         = DirectUI::Element::AlphaProp;
    
    pflow = ValueFlow::Build(&fci);
#else
    Flow::FlowCI fci;
    ZeroMemory(&fci, sizeof(fci));
    fci.cbSize      = sizeof(fci);
    fci.pgvSubject  = pgvSubject;

    pflow = AlphaFlow::Build(&fci);
#endif
    if (pflow == NULL) {
        hr = HRESULT_FROM_WIN32(GetLastError());
        goto ErrorExit;
    }
        
#if ENABLE_USEVALUEFLOW
    kf.cbSize       = sizeof(kf);
    kf.ppi          = DirectUI::Element::AlphaProp;
    kf.rv.SetInt(GetAlphaByte(flNewAlpha));
#else
    kf.cbSize       = sizeof(kf);

    kf.flAlpha      = flNewAlpha;
#endif    
    pflow->SetKeyFrame(Flow::tEnd, &kf);

    Animation::AniCI aci;
    ZeroMemory(&aci, sizeof(aci));
    aci.cbSize          = sizeof(aci);
    aci.act.flDelay     = flDelay;
    aci.act.flDuration  = flDuration;
    aci.act.dwPause     = (DWORD) -1;
    aci.pgvSubject      = pgvSubject;
    aci.pipol           = pip;
    aci.pgflow          = pflow;

    pani = Animation::Build(&aci);
    if (pani == NULL) {
        hr = HRESULT_FROM_WIN32(GetLastError());
        goto ErrorExit;
    }

    SyncVisible::Wait(pe, pani, &__uuidof(Animation::evComplete));

    pani->Release();
    pflow->Release();
    pip->Release();
    return S_OK;

ErrorExit:
    if (pani != NULL)
        pani->Release();    
    if (pflow != NULL)
        pflow->Release();
    if (pip != NULL)
        pip->Release();

    return hr;
}


/***************************************************************************\
*
* LogonFrame::FxFadeInAccounts
*
* FxFadeInAccounts() performs the first stage of animation:
* - Fades in the user accounts
* - Fades in the "options" in the bottom panel
*
\***************************************************************************/

HRESULT
LogonFrame::FxStartup()
{
    HRESULT hr = E_FAIL, hrT;

    hrT = FxFadeAccounts(fdIn);
    if (FAILED(hrT))
        hr = hrT;

    //
    // Fade in the "bottom pane" info
    //

    hrT = FxPlayLinearAlpha(_peOptions, 0.0f, 1.0f, F2T(16), F2T(32));
    if (FAILED(hrT))
        hr = hrT;

    return hr;
}
    
    
/***************************************************************************\
*
* LogonFrame::FxFadeAccounts
*
* FxFadeAccounts() fades the user accounts using a "v-delay" pattern
*
\***************************************************************************/

HRESULT
LogonFrame::FxFadeAccounts(
    IN  EFadeDirection dir,
    IN  float flCommonDelay)
{
    HRESULT hr = E_FAIL;

    Element * peSelection = NULL;
    float flOldAlpha, flNewAlpha, flTimeLevel;
    switch (dir)
    {
    case fdIn:
        // Fading accounts in (startup)
        flOldAlpha = 0.0f;
        flNewAlpha = 1.0f;
        flTimeLevel = F2T(5);
        break;
        
    case fdOut:
        // Fading accounts out (login)
        flOldAlpha = flIGNORE;
        flNewAlpha = 0.0f;
        flTimeLevel = F2T(5);
        peSelection = _peAccountList->GetSelection();
        break;

    default:
        DUIAssertForce("Unknown direction");
        return E_FAIL;
    }

    Value* pvChildren;
    ElementList* peList = _peAccountList->GetChildren(&pvChildren);
    if (peList)
    {
        hr = S_OK;
        LogonAccount* peAccount;
        int cAccounts = peList->GetSize();
        for (int i = 0; i < cAccounts; i++)
        {
            peAccount = (LogonAccount*)peList->GetItem(i);

            //
            // When fading out, we don't want to fade the selected item
            //

            if ((dir == fdOut) && (peAccount == peSelection))
            {
                continue;
            }

            float flDuration = F2T(15);
            float flDelay = GetVPatternDelay(flTimeLevel, dir, i, cAccounts) + flCommonDelay;
            HRESULT hrT = FxPlayLinearAlpha(peAccount, flOldAlpha, flNewAlpha, flDuration, flDelay);
            if (FAILED(hrT)) {
                hr = hrT;
            }
        }
    }
    pvChildren->Release();
    
    return hr;
}


/***************************************************************************\
*
* LogonFrame::FxLogUserOn
*
* FxLogUserOn() performs the login stage of animation:
* - Fade out Password field, "Type your password", "go" & "help" button
* - WAIT
* - Fade out scroll-bar
* - WAIT
* - Fade out other accounts (outside to selection), fade out "Click on your user..."
* - WAIT
* - Fade out of selection bitmap
* - Scroll-up of Icon / Name
* - Fade in "Logging in to Microsoft Windows"
* - Fade out "Turn off..." and "To manage or change accounts..."
*
\***************************************************************************/

HRESULT
LogonFrame::FxLogUserOn(LogonAccount * pla)
{
    HRESULT hr = S_OK;

    pla->FxLogUserOn();
    FxFadeAccounts(fdOut);

    // Fade out the "bottom pane" info
    FxPlayLinearAlpha(_peOptions, flIGNORE, 0.0f, F2T(10), F2T(65));

    GMA_ACTION act;
    ZeroMemory(&act, sizeof(act));
    act.cbSize      = sizeof(act);
    act.flDelay     = F2T(50);
    act.pvData      = this;
    act.pfnProc     = OnLoginCenterStage;

    CreateAction(&act);

    return hr;
}


/***************************************************************************\
*
* LogonFrame::OnLoginCenterStage
*
* OnLoginCenterStage() is called after everything has faded away, and we 
* are in the final steps.
*
\***************************************************************************/

void CALLBACK 
LogonFrame::OnLoginCenterStage(GMA_ACTIONINFO * pmai)
{
    if (!pmai->fFinished) {
        return;
    }

    LogonFrame * plf = (LogonFrame *) pmai->pvData;

    // Set keyfocus back to frame so it isn't pushed anywhere when controls are removed.
    // This will also cause a remove of the password panel from the current account
    plf->SetKeyFocus();

    // Clear list of logon accounts except the one logging on
    Value* pvChildren;
    ElementList* peList = plf->_peAccountList->GetChildren(&pvChildren);
    if (peList)
    {
        LogonAccount* peAccount;
        for (UINT i = 0; i < peList->GetSize(); i++)
        {
            peAccount = (LogonAccount*)peList->GetItem(i);
            if (peAccount->GetLogonState() == LS_Denied)
            {
                peAccount->SetLayoutPos(LP_None);
            }
        }
    }
    pvChildren->Release();
}


/***************************************************************************\
*
* LogonAccount::FxLogUserOn
*
* FxLogUserOn() performs the login stage of animation for the selected
* account.
* - Fade out Password field, "Type your password", "go" & "help" button
*
\***************************************************************************/

HRESULT 
LogonAccount::FxLogUserOn()
{
    HRESULT hr = S_OK;
    
    // Need to manually hide the edit control
    HideEdit();

    // Fade out the password panel
    FxPlayLinearAlpha(_pePwdPanel, 1.0f, 0.0f, F2T(10));

    return hr;
}


/***************************************************************************\
*
* LogonAccountList::FxMouseWithin
*
* FxMouseWithin() performs animations when the mouse enters or leaves the 
* account list.
*
\***************************************************************************/

HRESULT
LogonAccountList::FxMouseWithin(
    IN  EFadeDirection dir)
{
    HRESULT hr = E_FAIL;

    float flOldAlpha, flNewAlpha, flDuration;
    switch (dir)
    {
    case fdIn:
        // Entering list, so fade non-mouse-within accounts out
        flOldAlpha = 1.00f;
        flNewAlpha = flFadeOut;
        flDuration = F2T(5);
        break;
        
    case fdOut:
        // Leaving list, so fade non-mouse-within accounts in
        flOldAlpha = flIGNORE;
        flNewAlpha = 1.00f;
        flDuration = F2T(5);
        break;

    default:
        DUIAssertForce("Unknown direction");
        return E_FAIL;
    }

    Value* pvChildren;
    ElementList* peList = GetChildren(&pvChildren);
    if (peList)
    {
        hr = S_OK;
        LogonAccount* peAccount;
        int cAccounts = peList->GetSize();
        for (int i = 0; i < cAccounts; i++)
        {
            peAccount = (LogonAccount*)peList->GetItem(i);
            if (peAccount->GetLogonState() == LS_Pending)
            {
                //
                // Animations to use before login
                //
            
                if (peAccount->GetMouseWithin())
                {
                    //
                    // Mouse is within this child.  We need to special case this 
                    // node since the list is notified of the MouseWithin property
                    // change AFTER the child itself is.  If we didn't special case 
                    // this, we would fade the MouseWithin child out with the rest
                    // of its siblings.
                    //

                    FxSetAlpha(peAccount, 1.0f, true);
                }
                else
                {
                    //
                    // Mouse was not within this child, so apply the defaults
                    //
                    
                    HRESULT hrT = FxPlayLinearAlpha(peAccount, flOldAlpha, flNewAlpha, flDuration);
                    if (FAILED(hrT)) {
                        hr = hrT;
                    }
                }
            }
        }
    }
    pvChildren->Release();

    return hr;
}


/***************************************************************************\
*
* LogonAccount::FxMouseWithin
*
* FxMouseWithin() performs animations when the mouse enters an individual
* account item.
*
\***************************************************************************/

HRESULT
LogonAccount::FxMouseWithin(
    IN  EFadeDirection dir)
{
    HRESULT hr = S_OK;

    //
    // Only apply fades when we are not actually logging in.  This is important
    // because we kick off an entire set of animations that could be overridden
    // if we don't respect this.  When we log in, we change each of the 
    // accounts from LS_Pending.
    //

    switch (dir)
    {
    case fdIn:
        // Entering account, so fade non-mouse-within accounts out
        if (_fHasPwdPanel)
            ShowEdit();

        if (GetLogonState() == LS_Pending) 
            hr = FxPlayLinearAlpha(this, flIGNORE, 1.0f, F2T(3));
        break;
        
    case fdOut:
        // Leaving account, so fade non-mouse-within accounts in
        if (_fHasPwdPanel)
            HideEdit();
        
        if (GetLogonState() == LS_Pending) 
            hr = FxPlayLinearAlpha(this, flIGNORE, flFadeOut, F2T(10));
        break;

    default:
        DUIAssertForce("Unknown direction");
        return E_FAIL;
    }

    return hr;
}


/***************************************************************************\
*****************************************************************************
*
* helper Compute() functions
*
*****************************************************************************
\***************************************************************************/

//------------------------------------------------------------------------------
inline int
Round(float f)
{
    return (int) (f + 0.5);
}


//------------------------------------------------------------------------------
inline int     
Compute(Interpolation * pipol, float flProgress, int nStart, int nEnd)
{
    return Round(pipol->Compute(flProgress, (float) nStart, (float) nEnd));
}


//------------------------------------------------------------------------------
inline bool
Compute(Interpolation * pipol, float flProgress, bool fStart, bool fEnd)
{
    return (pipol->Compute(flProgress, 0.0f, 1.0f) < 0.5f) ? fStart : fEnd;
}


//------------------------------------------------------------------------------
POINT
Compute(Interpolation * pipol, float flProgress, const POINT * pptStart, const POINT * pptEnd)
{
    POINT pt;
    pt.x = Compute(pipol, flProgress, pptStart->x, pptEnd->x);
    pt.y = Compute(pipol, flProgress, pptStart->y, pptEnd->y);
    return pt;
}


//------------------------------------------------------------------------------
SIZE
Compute(Interpolation * pipol, float flProgress, const SIZE * psizeStart, const SIZE * psizeEnd)
{
    SIZE size;
    size.cx = Compute(pipol, flProgress, psizeStart->cx, psizeEnd->cx);
    size.cy = Compute(pipol, flProgress, psizeStart->cy, psizeEnd->cy);
    return size;
}


//------------------------------------------------------------------------------
RECT
Compute(Interpolation * pipol, float flProgress, const RECT * prcStart, const RECT * prcEnd)
{
    RECT rc;
    rc.left     = Compute(pipol, flProgress, prcStart->left, prcEnd->left);
    rc.top      = Compute(pipol, flProgress, prcStart->top, prcEnd->top);
    rc.right    = Compute(pipol, flProgress, prcStart->right, prcEnd->right);
    rc.bottom   = Compute(pipol, flProgress, prcStart->bottom, prcEnd->bottom);
    return rc;
}


//------------------------------------------------------------------------------
COLORREF
Compute(Interpolation * pipol, float flProgress, COLORREF crStart, COLORREF crEnd)
{
    int nAlpha  = Compute(pipol, flProgress, GetAValue(crStart), GetAValue(crEnd));
    int nRed    = Compute(pipol, flProgress, GetRValue(crStart), GetRValue(crEnd));
    int nGreen  = Compute(pipol, flProgress, GetGValue(crStart), GetGValue(crEnd));
    int nBlue   = Compute(pipol, flProgress, GetBValue(crStart), GetBValue(crEnd));

    return ARGB(nAlpha, nRed, nGreen, nBlue);
}


//------------------------------------------------------------------------------
DirectUI::Color
Compute(Interpolation * pipol, float flProgress, const DirectUI::Color * pclrStart, const DirectUI::Color * pclrEnd)
{
    DirectUI::Color clr;
    clr.dType   = pclrStart->dType;
    clr.cr      = Compute(pipol, flProgress, pclrStart->cr, pclrEnd->cr);

    switch (clr.dType)
    {
    case COLORTYPE_TriHGradient:
    case COLORTYPE_TriVGradient:
        clr.cr3     = Compute(pipol, flProgress, pclrStart->cr, pclrEnd->cr);
        // Fall through
        
    case COLORTYPE_HGradient:
    case COLORTYPE_VGradient:
        clr.cr2     = Compute(pipol, flProgress, pclrStart->cr, pclrEnd->cr);
    }
    
    return clr;
}


//------------------------------------------------------------------------------
inline float
Compute(Interpolation * pipol, float flProgress, float flStart, float flEnd)
{
    return pipol->Compute(flProgress, flStart, flEnd);
}


/***************************************************************************\
*****************************************************************************
*
* class DuiValueFlow
*
*****************************************************************************
\***************************************************************************/

class DuiValueFlow : public ValueFlowImpl<DuiValueFlow, SFlow>
{
// Construction
public:
    static  HRESULT     InitClass();
            HRESULT     PostBuild(DUser::Gadget::ConstructInfo * pci);

// Operations
public:

// Public API:
public:
    dapi    PRID        ApiGetPRID() { return s_prid; }
    dapi    HRESULT     ApiGetKeyFrame(Flow::ETime time, DUser::KeyFrame * pkf);
    dapi    HRESULT     ApiSetKeyFrame(Flow::ETime time, const DUser::KeyFrame * pkf);

    dapi    void        ApiOnReset(Visual * pgvSubject);
    dapi    void        ApiOnAction(Visual * pgvSubject, Interpolation * pipol, float flProgress);

// Implementaton
protected:
            Element *   GetElement(Visual * pgvSubject);

// Data
public:
    static  PRID        s_prid;
protected:
            DirectUI::PropertyInfo* 
                        m_ppi;
            ValueFlow::RawValue
                        m_rvStart;
            ValueFlow::RawValue
                        m_rvEnd;
};


/***************************************************************************\
*****************************************************************************
*
* class DuiValueFlow
*
*****************************************************************************
\***************************************************************************/

PRID        DuiValueFlow::s_prid = 0;
const GUID guidValueFlow = { 0xad9f0bd4, 0x1610, 0x47f3, { 0xba, 0xc9, 0x2c, 0x82, 0xe, 0x35, 0x2, 0xdf } }; // {AD9F0BD4-1610-47f3-BAC9-2C820E3502DF}

IMPLEMENT_GUTS_ValueFlow(DuiValueFlow, SFlow);


//------------------------------------------------------------------------------
HRESULT
DuiValueFlow::InitClass()
{
    s_prid = RegisterGadgetProperty(&guidValueFlow);
    return s_prid != 0 ? S_OK : (HRESULT) GetLastError();
}


//------------------------------------------------------------------------------
HRESULT
DuiValueFlow::PostBuild(
    IN  DUser::Gadget::ConstructInfo * pci)
{
    //
    // Get the information from the Gadget / Element
    //

    ValueFlow::ValueFlowCI * pDesc = static_cast<ValueFlow::ValueFlowCI *>(pci);
    DirectUI::Element * pel = GetElement(pDesc->pgvSubject);

    if ((pDesc != NULL) && (pel != NULL)) {
        m_ppi = pDesc->ppi;

        if (m_ppi != NULL) {
            DirectUI::Value * pvSrc = pel->GetValue(m_ppi, PI_Specified);
            DUIAssert(pvSrc != Value::pvUnset, "Value must be defined");

            m_rvStart.SetValue(pvSrc);
            m_rvEnd = m_rvStart;

            pvSrc->Release();
        }
    }

#if DEBUG_TRACECREATION
    TRACE("DuiValueFlow 0x%p on 0x%p initialized\n", pgvSubject, this);
#endif // DEBUG_TRACECREATION

    return S_OK;
}


//------------------------------------------------------------------------------
HRESULT
DuiValueFlow::ApiGetKeyFrame(Flow::ETime time, DUser::KeyFrame * pkf)
{
    if (pkf->cbSize != sizeof(ValueFlow::ValueKeyFrame)) {
        return E_INVALIDARG;
    }
    ValueFlow::ValueKeyFrame * pkfV = static_cast<ValueFlow::ValueKeyFrame *>(pkf);

    switch (time)
    {
    case Flow::tBegin:
        pkfV->ppi = m_ppi;
        pkfV->rv = m_rvStart;
        return S_OK;

    case Flow::tEnd:
        pkfV->ppi = m_ppi;
        pkfV->rv = m_rvEnd;
        return S_OK;

    default:
        return E_INVALIDARG;
    }
}


//------------------------------------------------------------------------------
HRESULT
DuiValueFlow::ApiSetKeyFrame(Flow::ETime time, const DUser::KeyFrame * pkf)
{
    if (pkf->cbSize != sizeof(ValueFlow::ValueKeyFrame)) {
        return E_INVALIDARG;
    }
    const ValueFlow::ValueKeyFrame * pkfV = static_cast<const ValueFlow::ValueKeyFrame *>(pkf);

    switch (time)
    {
    case Flow::tBegin:
        m_ppi = pkfV->ppi;
        m_rvStart = pkfV->rv;
        return S_OK;

    case Flow::tEnd:
        m_ppi = pkfV->ppi;
        m_rvEnd = pkfV->rv;
        return S_OK;

    default:
        return E_INVALIDARG;
    }
}


//------------------------------------------------------------------------------
void
DuiValueFlow::ApiOnReset(Visual * pgvSubject)
{
    DirectUI::Element * pel;
    if ((m_ppi != NULL) && ((pel  = GetElement(pgvSubject)) != NULL)) {
        DirectUI::Value * pvNew = NULL;
        if (SUCCEEDED(m_rvStart.GetValue(&pvNew))) {
            DUIAssert(pvNew != NULL, "Must have valid value");
            pel->SetValue(m_ppi, PI_Local, pvNew);
            pvNew->Release();
        }
    }
}


//------------------------------------------------------------------------------
void        
DuiValueFlow::ApiOnAction(Visual * pgvSubject, Interpolation * pipol, float flProgress)
{
    DirectUI::Element * pel;
    if ((m_ppi != NULL) && ((pel  = GetElement(pgvSubject)) != NULL)) {
        if (m_rvStart.GetType() != m_rvEnd.GetType()) {
            DUITrace("DuiValueFlow: Start and end value types do not match\n");
        } else {
            ValueFlow::RawValue rvCompute;
            BOOL fValid = TRUE;
            
            switch (m_rvStart.GetType())
            {
            case DUIV_INT:
                rvCompute.SetInt(Compute(pipol, flProgress, m_rvStart.GetInt(), m_rvEnd.GetInt()));
                break;
                
            case DUIV_BOOL:
                rvCompute.SetBool(Compute(pipol, flProgress, m_rvStart.GetBool(), m_rvEnd.GetBool()));
                break;
                
            case DUIV_POINT:
                rvCompute.SetPoint(Compute(pipol, flProgress, m_rvStart.GetPoint(), m_rvEnd.GetPoint()));
                break;
                
            case DUIV_SIZE:
                rvCompute.SetSize(Compute(pipol, flProgress, m_rvStart.GetSize(), m_rvEnd.GetSize()));
                break;
                
            case DUIV_RECT:
                rvCompute.SetRect(Compute(pipol, flProgress, m_rvStart.GetRect(), m_rvEnd.GetRect()));
                break;
                
            case DUIV_COLOR:
                rvCompute.SetColor(Compute(pipol, flProgress, m_rvStart.GetColor(), m_rvEnd.GetColor()));
                break;
                
            default:
                ASSERT(0 && "Unknown value type");
                fValid = FALSE;
            }

            if (fValid) {
                DirectUI::Value * pvNew = NULL;
                if (SUCCEEDED(rvCompute.GetValue(&pvNew))) {
                    DUIAssert(pvNew != NULL, "Must have valid value");
                    pel->SetValue(m_ppi, PI_Local, pvNew);
                    pvNew->Release();
                }
            }
        }
    }
}


//------------------------------------------------------------------------------
Element *
DuiValueFlow::GetElement(Visual * pgvSubject)
{
    Element * pel = NULL;
    
    if (pgvSubject != NULL) {
        HGADGET hgadSubject = pgvSubject->GetHandle();
        DUIAssert(hgadSubject != NULL, "Must have valid handle");
        
        pel = DirectUI::ElementFromGadget(hgadSubject);
        DUIAssert(pel != NULL, "Must have a valid DirectUI Element");
    }

    return pel;
}


//------------------------------------------------------------------------------
HRESULT FxInitGuts()
{
    if (!DuiValueFlow::InitValueFlow()) {
        return E_OUTOFMEMORY;
    }

    return S_OK;
}

#endif // GADGET_ENABLE_GDIPLUS
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\logondui\langicon.cpp ===
#include "priv.h"
#include <shellapi.h>
#include "langicon.h"

using namespace DirectUI;
#include "logon.h"
extern LogonFrame* g_plf; 

typedef struct
{
    HKL dwHkl;
    HICON hIcon;

} LAYOUTINFO, *PLAYOUTINFO;

typedef struct
{
    HKL hklLast;
    UINT uLangs;
    PLAYOUTINFO pLayoutInfo;
} USERLAYOUTINFO, *PUSERLAYOUTINFO;

HICON
CreateLangIdIcon(
    WORD LangId);
int
CreateIconList(
    PLAYOUTINFO pLayoutInfo,
    HKL hkl,
    UINT uLangs); 

HICON
GetIconFromHkl(
    PLAYOUTINFO pLayoutInfo,
    HKL hkl,
    UINT uLangs); 


USERLAYOUTINFO UserLayoutInfo[2] = {0};

typedef BOOL  (WINAPI *LPFNIMMGETIMEFILENAME)(HKL, LPTSTR, UINT);
LPFNIMMGETIMEFILENAME pfnImmGetImeFileName = NULL;
TCHAR szImm32DLL[] = TEXT("imm32.dll");

typedef UINT (WINAPI *PFNEXTRACTICONEXW)(LPCWSTR lpszFile, int nIconIndex, HICON FAR *phiconLarge, HICON FAR *phiconSmall, UINT nIcons);
 



/***************************************************************************\
* FUNCTION: CreateLangIdIcon
*
* PURPOSE:  Create an icon that displays the first two letters of the 
*           supplied language ID.
*
* RETURNS:  Icon that shows displays Language ID.
*
* HISTORY:
*
*   04-17-98  ShanXu       Borrowed from internat.exe
*
\***************************************************************************/

HICON
CreateLangIdIcon(
    WORD langID
    )
{
    HBITMAP hbmColour = NULL;
    HBITMAP hbmMono;
    HBITMAP hbmOld;
    HICON hicon = NULL;
    ICONINFO ii;
    RECT rc;
    DWORD rgbText;
    DWORD rgbBk = 0;
    HDC hdc = NULL;
    HDC hdcScreen;
    LOGFONT lf;
    HFONT hfont;
    HFONT hfontOld;
    TCHAR szData[20];
    UINT cxSmIcon, cySmIcon;
    
    // due to the font we create, these should not be smaller than 16 x 16
    cxSmIcon =  GetSystemMetrics(SM_CXSMICON);
    if (cxSmIcon < 16)
    {
        cxSmIcon = 16;
    }

    cySmIcon =  GetSystemMetrics(SM_CYSMICON);
    if (cySmIcon < 16)
    {
        cySmIcon = 16;
    }
    //
    //  Get the indicator by using the first 2 characters of the
    //  abbreviated language name.
    //
    if (GetLocaleInfo( MAKELCID(langID, SORT_DEFAULT),
                       LOCALE_SABBREVLANGNAME | LOCALE_NOUSEROVERRIDE,
                       szData,
                       sizeof(szData) / sizeof(szData[0]) ))
    {
        //
        //  Only use the first two characters.
        //
        szData[2] = TEXT('\0');
    }
    else
    {
        //
        //  Id wasn't found.  Use question marks.
        //
        szData[0] = TEXT('?');
        szData[1] = TEXT('?');
        szData[2] = TEXT('\0');
    }

    if (SystemParametersInfo(SPI_GETICONTITLELOGFONT, sizeof(LOGFONT), &lf, 0))
    {
        if ((hfont = CreateFontIndirect(&lf)) != NULL)
        {
            hdcScreen = GetDC(NULL);
            if ( hdcScreen )
            {
                hdc = CreateCompatibleDC(hdcScreen);
                hbmColour = CreateCompatibleBitmap(hdcScreen, cxSmIcon, cySmIcon);
                ReleaseDC(NULL, hdcScreen);
            }

            if (hbmColour && hdc)
            {
                hbmMono = CreateBitmap(cxSmIcon, cySmIcon, 1, 1, NULL);
                if (hbmMono)
                {
                    hbmOld    = (HBITMAP)SelectObject(hdc, hbmColour);
                    rc.left   = 0;
                    rc.top    = 0;
                    rc.right  = cxSmIcon;
                    rc.bottom = cySmIcon;

                    rgbBk = SetBkColor(hdc, GetSysColor(COLOR_HIGHLIGHT));
                    rgbText = SetTextColor(hdc, GetSysColor(COLOR_HIGHLIGHTTEXT));

                    ExtTextOut( hdc,
                                rc.left,
                                rc.top,
                                ETO_OPAQUE,
                                &rc,
                                TEXT(""),
                                0,
                                NULL );
                    SelectObject(hdc, GetStockObject(DEFAULT_GUI_FONT));
                    hfontOld = (HFONT)SelectObject(hdc, hfont);
                    DrawText( hdc,
                              szData,
                              2,
                              &rc,
                              DT_CENTER | DT_VCENTER | DT_SINGLELINE );
#ifdef USE_MIRRORING
                    {
                        DWORD dwLayout;

                        GetProcessDefaultLayout(&dwLayout);
                        if (dwLayout & LAYOUT_RTL)
                        {
//                            MirrorBitmapInDC(hdc, hbmColour);
                        }
                    }
#endif
                    SelectObject(hdc, hbmMono);
                    PatBlt(hdc, 0, 0, cxSmIcon, cySmIcon, BLACKNESS);
                    SelectObject(hdc, hbmOld);

                    ii.fIcon    = TRUE;
                    ii.xHotspot = 0;
                    ii.yHotspot = 0;
                    ii.hbmColor = hbmColour;
                    ii.hbmMask  = hbmMono;
                    hicon       = CreateIconIndirect(&ii);

                    DeleteObject(hbmMono);
                    SelectObject(hdc, hfontOld);
                }
                DeleteObject(hbmColour);
                DeleteDC(hdc);
            }
            DeleteObject(hfont);
        }
    }

    return (hicon);
}

/***************************************************************************\
* FUNCTION: CreateIconList
*
* PURPOSE:  Create the table that contains the relationship between an hkl
*           and an icon.
*
* RETURNS:  Index of the current hkl in the table.
*
* HISTORY:
*
*   04-17-98  ShanXu      Created
*
\***************************************************************************/
int
CreateIconList(
    PLAYOUTINFO pLayoutInfo,
    HKL hklCur,
    UINT uLangs)
{
    HKL *pLanguages;
    UINT uCount;
    int nCurIndex = -1;

    pLanguages = (HKL *)LocalAlloc(LPTR, uLangs * sizeof(HKL));
    if (!pLanguages)
    {
        return -1;
    }
    GetKeyboardLayoutList(uLangs, (HKL *)pLanguages);


    for (uCount = 0; uCount < uLangs; uCount++)
    {
        pLayoutInfo[uCount].dwHkl = pLanguages[uCount];
        if (pLanguages[uCount] == hklCur)
        {
            nCurIndex = uCount;
        }
        if ((HIWORD(pLanguages[uCount]) & 0xf000) == 0xe000)
        {
            WCHAR szIMEFile[32];   // assume long filename up to 32 byte

            if (!pfnImmGetImeFileName)
            {
                HMODULE hMod;
                hMod = GetModuleHandle(szImm32DLL);
                if (hMod)
                {
                    pfnImmGetImeFileName = (LPFNIMMGETIMEFILENAME) 
                                            GetProcAddress(
                                                hMod, 
                                                "ImmGetIMEFileNameW");
                }
            }
            if (pfnImmGetImeFileName &&
                (*pfnImmGetImeFileName) (pLanguages[uCount],
                                         szIMEFile,
                                         sizeof(szIMEFile) ))
            {
                HINSTANCE hInstShell32;
                PFNEXTRACTICONEXW pfnExtractIconExW;

                hInstShell32 = LoadLibrary (TEXT("shell32.dll"));

                if (hInstShell32)
                {
                    pfnExtractIconExW = (PFNEXTRACTICONEXW) GetProcAddress (hInstShell32,
                                        "ExtractIconExW");

                    if (pfnExtractIconExW)
                    {

                        //
                        //  First one of the file.
                        //
                        pfnExtractIconExW(
                                szIMEFile,
                                0,
                                NULL,
                                &pLayoutInfo[uCount].hIcon,
                                1);
                    }

                    FreeLibrary (hInstShell32);
                }
                continue;
            }
        }

        //
        // for non-ime layout
        //
        pLayoutInfo[uCount].hIcon = CreateLangIdIcon(LOWORD(pLanguages[uCount]));
        
    }

    LocalFree(pLanguages);

    return nCurIndex;
}

/***************************************************************************\
* FUNCTION: GetIconFromHkl
*
* PURPOSE:  Find the icon in our table that has a matching hkl
*           with the supplied hkl. Create the table if it does not
*           exist.
*
* RETURNS:  Icon of the macthing hkl.
*
* HISTORY:
*
*   04-17-98  ShanXu      Created 
*
\***************************************************************************/
HICON
GetIconFromHkl(
    PLAYOUTINFO pLayoutInfo,
    HKL hkl,
    UINT uLangs)
{
    UINT uCount;
    int nIndex = -1;

    if (pLayoutInfo[0].dwHkl == 0)
    {
        //
        //  Icon/hkl list no exsists yet.  Create it.
        //
        nIndex = CreateIconList(pLayoutInfo, hkl, uLangs);
    }
    else
    {
        //  
        //  Find the icon with a matching hkl
        //
        for (uCount = 0; uCount < uLangs; uCount++)
        {
            if (pLayoutInfo[uCount].dwHkl == hkl)
            {
                nIndex = uCount;
                break;
            }
        }
    }

    if (nIndex == -1)
    {
        return NULL;
    }
    

    return ( pLayoutInfo[nIndex].hIcon);
}

/***************************************************************************\
* FUNCTION: DisplayLanguageIcon
*
* PURPOSE:  Displays the icon of the currently selected hkl in the window.
*
* RETURNS:  TRUE - The icon is displayed.
*           FALSE - No icon displayed.
*
* HISTORY:
*
*   04-17-98  ShanXu      Created
*
\***************************************************************************/
BOOL
DisplayLanguageIcon(
    LAYOUT_USER LayoutUser,
    HKL  hkl)

{
    HICON hIconLayout;
    UINT uLangs;
    PLAYOUTINFO pLayout;
    
    uLangs = GetKeyboardLayoutList(0, NULL);
    if (uLangs < 2)
    {
        return FALSE;
    }

    pLayout = UserLayoutInfo[LayoutUser].pLayoutInfo;

    if (!pLayout)
    {
        pLayout = (PLAYOUTINFO)LocalAlloc(LPTR, uLangs * sizeof(LAYOUTINFO));

        if (!pLayout)
        {
            return FALSE;
        }

        UserLayoutInfo[LayoutUser].uLangs = uLangs;
        UserLayoutInfo[LayoutUser].pLayoutInfo = pLayout;
    }
        

    hIconLayout = GetIconFromHkl(
                        pLayout, 
                        hkl,    
                        uLangs);

    if (!hIconLayout)
    {
        return FALSE;
    }

    LogonAccount::SetKeyboardIcon(hIconLayout);
    UserLayoutInfo[LayoutUser].hklLast = hkl;

    return TRUE;
    
}

/***************************************************************************\
* FUNCTION: FreeLayoutInfo
*
* PURPOSE:  Delete the icon/hkl table and destroy all icons.
*
* RETURNS:  -
*
* HISTORY:
*
*   04-17-98  ShanXu      Created
*
\***************************************************************************/
void
FreeLayoutInfo(
    LAYOUT_USER LayoutUser)
{
    UINT uLangs;
    UINT uCount;

    PLAYOUTINFO pLayoutInfo;

    pLayoutInfo = UserLayoutInfo[LayoutUser].pLayoutInfo;

    if (!pLayoutInfo)
    {
        return;
    }

    uLangs = UserLayoutInfo[LayoutUser].uLangs;
    for (uCount = 0; uCount < uLangs; uCount++)
    {
        DestroyIcon (pLayoutInfo[uCount].hIcon);
    }

    LocalFree(pLayoutInfo);
    UserLayoutInfo[LayoutUser].pLayoutInfo = NULL;
    UserLayoutInfo[LayoutUser].uLangs = 0;

    return;
}

/***************************************************************************\
* FUNCTION: LayoutCheckHandler
*
* PURPOSE:  Handle layout check.  Set appropriate icon if there is
*           a change in keyboard layout.
*
* RETURNS:  -
*
* HISTORY:
*
*   04-22-98  ShanXu      Created
*
\***************************************************************************/
void
LayoutCheckHandler(
    LAYOUT_USER LayoutUser)
{
    HKL hklCurrent;

    hklCurrent = GetKeyboardLayout(0);

    if (hklCurrent != UserLayoutInfo[LayoutUser].hklLast)
    {
        DisplayLanguageIcon(
            LayoutUser,
            hklCurrent);

    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\logondui\makefile.inc ===
#
# logon.ui preprocessing
#

#$(O)\logon.uipp: GpRes\logon.ui
#    cl /nologo /EP GpRes\logon.ui > $(O)\logon.uipp
$(O)\logon.uipp: logon.ui
    cl /nologo /EP /I$(WINDOWS_INC_PATH)\DUser logon.ui > $(O)\logon.uipp

#
# GIDL
#

$(O)\stub.cpp: $(DUSER_INC_PATH)\DUser.gidl $(DUSER_INC_PATH)\DUser.gh
    Gidl.exe -I$(DUSER_INC_PATH) DUser.gidl DUser.gh Logon.gidl Logon.gh -dtarget=$(_BUILDARCH) -dproject=Priv.h -o$(O) -t$(NTMAKEENV)\DirectMT.gml

$(O)\super.cpp: $(DUSER_INC_PATH)\DUser.gidl $(DUSER_INC_PATH)\DUser.gh
    Gidl.exe -I$(DUSER_INC_PATH) DUser.gidl DUser.gh Logon.gidl Logon.gh -dtarget=$(_BUILDARCH) -dproject=Priv.h -o$(O) -t$(NTMAKEENV)\DirectMT.gml
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\logondui\logon.cpp ===
// Logon.cpp : Windows Logon application
//

#include "priv.h"

using namespace DirectUI;
// Logon.cpp : Windows Logon application
//

#include "logon.h"
#include "Fx.h"
#include "backend.h"
#include "resource.h"
#include "eballoon.h"
#include "profileutil.h"
#include "langicon.h"
#include <passrec.h>

BOOL RunningInWinlogon();    // from backend.cpp

UsingDUIClass(Element);
UsingDUIClass(Button);
UsingDUIClass(ScrollBar);
UsingDUIClass(Selector);
UsingDUIClass(ScrollViewer);
UsingDUIClass(Edit);

// Globals

LogonFrame* g_plf = NULL;
ILogonStatusHost *g_pILogonStatusHost = NULL;
CErrorBalloon g_pErrorBalloon;
BOOL g_fNoAnimations = false;
WCHAR szLastSelectedName[UNLEN + sizeof('\0')] = { L'\0' };
HANDLE g_rgH[3] = {0};

#define MAX_COMPUTERDESC_LENGTH 255
#define RECTWIDTH(r)  (r.right - r.left)


// Resource string loading
LPCWSTR LoadResString(UINT nID)
{
    static WCHAR szRes[101];
    szRes[0] = NULL;
    LoadStringW(g_plf->GetHInstance(), nID, szRes, DUIARRAYSIZE(szRes) - 1);
    return szRes;
}

void SetButtonLabel(Button* pButton, LPCWSTR pszLabel)
{
    Element *pLabel= (Element*)pButton->FindDescendent(StrToID(L"label"));
    DUIAssert(pLabel, "Cannot find button label, check the UI file");
    if (pLabel != NULL)
    {
        pLabel->SetContentString(pszLabel);
    }
}


////////////////////////////////////////
//
//  SetElementAccessability
//
//  Set the accessibility information for an element.
//
/////////////////////////////////////////
void inline SetElementAccessability(Element* pe, bool bAccessible, int iRole, LPCWSTR pszAccName)
{
    if (pe) 
    {
        pe->SetAccessible(bAccessible);
        pe->SetAccRole(iRole);
        pe->SetAccName(pszAccName);
    }
}

////////////////////////////////////////
//
//  RunningUnderWinlogon
//
//  Check to see if the logon message window is available.
//
/////////////////////////////////////////
BOOL RunningUnderWinlogon()
{
    return (FindWindow(TEXT("Shell_TrayWnd"), NULL) == NULL);
}

// global storage of username associated with failed logon.  Used for 
//  restore wizard via ECSubClassProc
WCHAR g_szUsername[UNLEN];

////////////////////////////////////////
// 
//  Support code for balloon tip launch of the Password Reset Wizard
//
//  Code in support of subclassing the Password Panel edit control
//
//  The control is displayed by InsertPasswordPanel and undisplayed
//   by RemovePasswordPanel.  The control is subclassed when displayed
//   and unsubclassed when removed.
//
////////////////////////////////////////

// Entirely randomly selected magic number for the edit control subclass operation
#define ECMAGICNUM 3212

void ShowResetWizard(HWND hw)
{
    // Show password restore wizard
    HMODULE hDll = LoadLibrary(L"keymgr.dll");
    if (hDll) 
    {
        RUNDLLPROC PRShowRestoreWizard;
        PRShowRestoreWizard = (RUNDLLPROC) GetProcAddress(hDll,(LPCSTR)"PRShowRestoreWizardW");
        if (PRShowRestoreWizard) 
        {
            PRShowRestoreWizard(hw,NULL,g_szUsername,0);
        }
        FreeLibrary(hDll);
    }
    return;
}

LRESULT CALLBACK ECSubClassProc( HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam,UINT_PTR uID, ULONG_PTR dwRefData)
{
    UNREFERENCED_PARAMETER(uID);
    UNREFERENCED_PARAMETER(dwRefData);
    switch (uMsg)
    {
        case WM_NOTIFY:
        {
            LPNMHDR lph;
            lph = (LPNMHDR) lParam;
            if (TTN_LINKCLICK == lph->code) 
            {
                g_pErrorBalloon.HideToolTip();
                ShowResetWizard(hwnd);
                return 0;
            }
        }

    default:
        break;
    }
    return DefSubclassProc(hwnd, uMsg, wParam, lParam);
}

BOOL SubClassTheEditBox(HWND he) 
{
    if (he)
    {
        SetWindowSubclass(he,ECSubClassProc,ECMAGICNUM,NULL);
    }
    return (he != NULL);
}

void UnSubClassTheEditBox(HWND he) 
{
    if (he)
    {
        RemoveWindowSubclass(he,ECSubClassProc,ECMAGICNUM);
    }
}


////////////////////////////////////////
//
//  BuildAccountList
//
//  Add all user accounts. 
//
//  Out parameter ppla returns a user that should be selected automatically if there is one.  
//  the caller should select this user.  
//
//  RETURNS
//  S_OK if everything works out.  Failure HRESULT if not.  You are pretty much hosed if this fails
//
/////////////////////////////////////////
HRESULT BuildAccountList(LogonFrame* plf, OUT LogonAccount **ppla)
{
    HRESULT hr;

    if (ppla)
    {
        *ppla = NULL;
    }

    hr = BuildUserListFromGina(plf, ppla);
    if (SUCCEEDED(hr))
    {
        g_plf->SetUserListAvailable(TRUE);
    }
#ifdef GADGET_ENABLE_GDIPLUS
    plf->FxStartup();
#endif
    
    return hr;
}


////////////////////////////////////////
//
//  PokeComCtl32
//
//  Flush comctl32's notion of the atom table.  This is so balloon tips will work correctly
//  after a logoff.
//
/////////////////////////////////////////

void PokeComCtl32()
{
    INITCOMMONCONTROLSEX iccex = { sizeof(INITCOMMONCONTROLSEX), ICC_WINLOGON_REINIT | ICC_STANDARD_CLASSES | ICC_TREEVIEW_CLASSES};
    InitCommonControlsEx(&iccex);
}

////////////////////////////////////////////////////////
//
// LogonFrame
//
////////////////////////////////////////////////////////


int LogonFrame::_nDPI = 0;

HRESULT LogonFrame::Create(OUT Element** ppElement)
{
    UNREFERENCED_PARAMETER(ppElement);
    DUIAssertForce("Cannot instantiate an HWND host derived Element via parser. Must use substitution.");
    return E_NOTIMPL;
}

HRESULT LogonFrame::Create(HWND hParent, BOOL fDblBuffer, UINT nCreate, OUT Element** ppElement)
{
    *ppElement = NULL;

    LogonFrame* plf = HNew<LogonFrame>();
    if (!plf)
        return E_OUTOFMEMORY;

    HRESULT hr = plf->Initialize(hParent, fDblBuffer, nCreate);
    if (FAILED(hr))
    {
        plf->Destroy();
        return hr;
    }

    *ppElement = plf;

    return S_OK;
}

void LogonFrame::ResetTheme(void)
{
    Parser *pParser = NULL;
    Value  *pvScrollerSheet;
    Element *peListScroller = NULL;
    if (g_rgH[SCROLLBARHTHEME])
    {
        CloseThemeData(g_rgH[SCROLLBARHTHEME]);
        g_rgH[SCROLLBARHTHEME] = NULL;
    }

    g_rgH[SCROLLBARHTHEME] = OpenThemeData(_pnhh->GetHWND(), L"Scrollbar");

    Parser::Create(IDR_LOGONUI, g_rgH, LogonParseError, &pParser);
    if (pParser && !pParser->WasParseError())
    {
        pvScrollerSheet = pParser->GetSheet(L"scroller");

        if (pvScrollerSheet)
        {
            peListScroller = (Selector*)FindDescendent(StrToID(L"scroller"));

            peListScroller->SetValue(SheetProp, PI_Local, pvScrollerSheet);
        
            pvScrollerSheet->Release();
        }

        pParser->Destroy();
    }
}


void LogonFrame::NextFlagAnimate(DWORD dwFrame)
{

#ifndef ANIMATE_FLAG
    UNREFERENCED_PARAMETER(dwFrame);
#else
    Element* pe;

    if( dwFrame >= MAX_FLAG_FRAMES || g_fNoAnimations)
    {
        return;
    }

    pe = FindDescendent(StrToID(L"product"));
    DUIAssertNoMsg(pe);

    if (pe)
    {
        HBITMAP hbm = NULL;
        HDC hdc;        
        Value *pv = NULL;

        hdc = CreateCompatibleDC(_hdcAnimation);

        if (hdc)
        {
            pv = pe->GetValue(Element::ContentProp, PI_Local);
            if (pv)
            {
                hbm = (HBITMAP)pv->GetImage(false);
            }

            if (hbm)
            {
                _dwFlagFrame = dwFrame;
                if (_dwFlagFrame >= MAX_FLAG_FRAMES)
                {
                    _dwFlagFrame = 0;
                }


                HBITMAP hbmSave = (HBITMAP)SelectObject(hdc, hbm);
                BitBlt(hdc, 0, 0, 137, 86, _hdcAnimation, 0, 86 * _dwFlagFrame,SRCCOPY);
                SelectObject(hdc, hbmSave);
                
                HGADGET hGad = pe->GetDisplayNode();
                if (hGad)
                {
                    InvalidateGadget(hGad);
                }
            }

            if (pv)
            {   
                pv->Release();
            }
            DeleteDC(hdc);
        }
    }
#endif
}

////////////////////////////////////////
//
//  LogonFrame::Initialize
//
//  Initialize the LogonFrame, create the notification window that is used by SHGina for 
//  sending messages to logonui. Set initial state, etc.
//
//  RETURNS
//  S_OK if everything works out.  Failure HRESULT if not.  You are pretty much hosed if this fails
//
/////////////////////////////////////////
HRESULT LogonFrame::Initialize(HWND hParent, BOOL fDblBuffer, UINT nCreate)
{
    // Zero-init members
    _peAccountList = NULL;
    _peViewer = NULL;
    _peRightPanel = NULL;
    _peLeftPanel = NULL;
    _pbPower = NULL;
    _pbUndock = NULL;
    _peHelp = NULL;
    _peMsgArea = NULL;
    _peLogoArea = NULL;
    _pParser = NULL;
    _hwndNotification = NULL;
    _nStatusID = 0;
    _fPreStatusLock = FALSE;
    _nAppState = LAS_PreStatus;
    _pnhh = NULL;
    _fListAvailable = FALSE;
    _pvHotList = NULL;
    _pvList = NULL;
    _hdcAnimation = NULL;
    _dwFlagFrame = 0;
    _nColorDepth = 0;


     // Set up notification window
    _hwndNotification = CreateWindowEx(0,
            TEXT("LogonWnd"),
            TEXT("Logon"),
            WS_OVERLAPPED,
            0, 0,
            10,
            10,
            HWND_MESSAGE,
            NULL,
            GetModuleHandleW(NULL),
            NULL);

    if (SUCCEEDED(CoCreateInstance(CLSID_ShellLogonStatusHost, NULL, CLSCTX_INPROC_SERVER, IID_PPV_ARG(ILogonStatusHost, &g_pILogonStatusHost))))
    {
        g_pILogonStatusHost->Initialize(GetModuleHandleW(NULL), _hwndNotification);
    }

    // In status (pre) state
    SetState(LAS_PreStatus);

     // Do base class initialization
    HRESULT hr;
    HDC hDC = NULL;

    hr = HWNDElement::Initialize(hParent, fDblBuffer ? true : false, nCreate);
    if (FAILED(hr))
    {
        return hr;
        goto Failure;
    }

    if (!g_fNoAnimations)
    {
        // Initialize
        hDC = GetDC(NULL);
        _nDPI = GetDeviceCaps(hDC, LOGPIXELSY);
        _nColorDepth = GetDeviceCaps(hDC, BITSPIXEL);
        ReleaseDC(NULL, hDC);

#ifdef ANIMATE_FLAG
        hDC = GetDC(hParent);
        _hdcAnimation = CreateCompatibleDC(hDC);
        if (_hdcAnimation)
        {
            _hbmpFlags = (HBITMAP)LoadImage(GetModuleHandleW(NULL), MAKEINTRESOURCE(IDB_FLAGSTRIP), IMAGE_BITMAP, 0, 0, LR_DEFAULTCOLOR);
            if (_hbmpFlags)
            {
                HBITMAP hbmOld = (HBITMAP)SelectObject(_hdcAnimation, _hbmpFlags);
                DeleteObject(hbmOld);
            }
            else
            {
                DeleteDC(_hdcAnimation);
                _hdcAnimation = NULL;
            }
        }
        ReleaseDC(hParent, hDC);
#endif
    }

    hr = SetActive(AE_MouseAndKeyboard);
    if (FAILED(hr))
        goto Failure;
    
    return S_OK;


Failure:

    return hr;
}

LogonFrame::~LogonFrame()
{
    if (_pvHotList)
        _pvHotList->Release();
    if (_pvList)
        _pvList->Release();
    if (_hdcAnimation)
        DeleteDC(_hdcAnimation);
    g_plf = NULL;
}

// Tree is ready. Upon failure, exit which will casuse the app to shutdown
HRESULT LogonFrame::OnTreeReady(Parser* pParser)
{
    HRESULT hr;

    // Cache
    _pParser = pParser;

    // Cache important descendents
    _peAccountList = (Selector*)FindDescendent(StrToID(L"accountlist"));
    DUIAssert(_peAccountList, "Cannot find account list, check the UI file");
    if (_peAccountList == NULL)
    {
        hr = E_OUTOFMEMORY;
        goto Failure;
    }

    _peLeftPanel = (Element*)FindDescendent(StrToID(L"leftpanel"));
    DUIAssert(_peLeftPanel, "Cannot find left panel, check the UI file");
    if (_peLeftPanel == NULL)
    {
        hr = E_OUTOFMEMORY;
        goto Failure;
    }

    _peViewer = (ScrollViewer*)FindDescendent(StrToID(L"scroller"));
    DUIAssert(_peViewer, "Cannot find scroller list, check the UI file");
    if (_peViewer == NULL)
    {
        hr = E_OUTOFMEMORY;
        goto Failure;
    }

    _peRightPanel = (Selector*)FindDescendent(StrToID(L"rightpanel"));
    DUIAssert(_peRightPanel, "Cannot find account list, check the UI file");
    if (_peRightPanel == NULL)
    {
        hr = E_OUTOFMEMORY;
        goto Failure;
    }

    _peLogoArea = (Element*)FindDescendent(StrToID(L"logoarea"));
    DUIAssert(_peLogoArea, "Cannot find logo area, check the UI file");
    if (_peLogoArea == NULL)
    {
        hr = E_OUTOFMEMORY;
        goto Failure;
    }

    _peMsgArea = (Element*)FindDescendent(StrToID(L"msgarea"));
    DUIAssert(_peMsgArea, "Cannot find welcome area, check the UI file");
    if (_peMsgArea == NULL)
    {
        hr = E_OUTOFMEMORY;
        goto Failure;
    }

    _pbPower = (Button*)FindDescendent(StrToID(L"power"));
    DUIAssert(_pbPower, "Cannot find power button, check the UI file");
    if (_pbPower == NULL)
    {
        hr = E_OUTOFMEMORY;
        goto Failure;
    }

    _pbUndock = (Button*)FindDescendent(StrToID(L"undock"));
    DUIAssert(_pbUndock, "Cannot find undock button, check the UI file");
    if (_pbUndock == NULL)
    {
        hr = E_OUTOFMEMORY;
        goto Failure;
    }


    _peHelp = (Button*)FindDescendent(StrToID(L"help"));
    DUIAssert(_peHelp, "Cannot find help text, check the UI file");
    if (_peHelp == NULL)
    {
        hr = E_OUTOFMEMORY;
        goto Failure;
    }

    _peOptions = FindDescendent(StrToID(L"options"));
    DUIAssert(_peOptions, "Cannot find account list, check the UI file");
    if (_peOptions == NULL)
    {
        hr = E_OUTOFMEMORY;
        goto Failure;
    }

    // check for small window or low color cases and hide some elements that will look bad then.
    HWND hwnd = _pnhh->GetHWND();
    RECT rcClient;
    Element *pEle;
    HDC hDC = GetDC(hwnd);
    _nColorDepth = GetDeviceCaps(hDC, BITSPIXEL);
    _pvHotList = _pParser->GetSheet(L"hotaccountlistss");
    _pvList = _pParser->GetSheet(L"accountlistss");

    ReleaseDC(hwnd, hDC);

    GetClientRect(hwnd, &rcClient);
    if (RECTWIDTH(rcClient) < 780 || _nColorDepth <= 8)
    {
        //no animations
        g_fNoAnimations = true;

        // remove the clouds 
        pEle = FindDescendent(StrToID(L"contentcontainer"));
        if (pEle)
        {
            pEle->RemoveLocalValue(ContentProp);
            if (_nColorDepth <= 8)
            {
                pEle->SetBackgroundColor(ORGB (96,128,255));
            }
        }

        if (_nColorDepth <= 8)
        {
            pEle = FindDescendent(StrToID(L"product"));
            if (pEle)
            {
                pEle->SetBackgroundColor(ORGB (96,128,255));
            }
        }
    }

    _peViewer->AddListener(this);
    _peAccountList->AddListener(this);

    // Setup frame labels
    SetPowerButtonLabel(LoadResString(IDS_POWER));
    SetUndockButtonLabel(LoadResString(IDS_UNDOCK));

    ShowLogoArea();
    HideWelcomeArea();

    return S_OK;


Failure:

    return hr;
}

// Set the title element (welcome, please wait..) by string resource id
void LogonFrame::SetTitle(UINT uRCID)
{
    WCHAR sz[1024];
    ZeroMemory(&sz, sizeof(sz));

    if (_nStatusID != uRCID)
    {

#ifdef DBG
        int cRead = 0;
        cRead = LoadStringW(_pParser->GetHInstance(), uRCID, sz, DUIARRAYSIZE(sz));
        DUIAssert(cRead, "Could not locate string resource ID");
#else
        LoadStringW(_pParser->GetHInstance(), uRCID, sz, ARRAYSIZE(sz));
#endif

        SetTitle(sz);
        _nStatusID = uRCID;
    }
}

// Set the title element (welcome, please wait..)
// slightly more involved because there is the shadow element that 
// needs to be changed as well
void LogonFrame::SetTitle(LPCWSTR pszTitle)
{
    Element *peTitle = NULL, *peShadow = NULL;

    peTitle= (Button*)FindDescendent(StrToID(L"welcome"));
    DUIAssert(peTitle, "Cannot find title text, check the UI file");
    
    if (peTitle)
    {
        peShadow= (Button*)FindDescendent(StrToID(L"welcomeshadow"));
        DUIAssert(peShadow, "Cannot find title shadow text, check the UI file");
    }

    if (peTitle && peShadow)
    {
        peTitle->SetContentString(pszTitle);
        peShadow->SetContentString(pszTitle);
    }
}

// Generic events
void LogonFrame::OnEvent(Event* pEvent)
{
    if (pEvent->nStage == GMF_BUBBLED)  // Bubbled events
    {
        g_pErrorBalloon.HideToolTip();
        if (pEvent->uidType == Button::Click)
        {
            if (pEvent->peTarget == _pbPower)
            {
                // Power button pressed
                OnPower();

                pEvent->fHandled = true;
                return;
            }
            else if (pEvent->peTarget == _pbUndock)
            {
                // Undock button pressed
                OnUndock();

                pEvent->fHandled = true;
                return;
            }
        }
    }

    HWNDElement::OnEvent(pEvent);
}

// PropertyChanged listened events from various descendents
// Swap out property sheets for account list based on state of the list
void LogonFrame::OnListenedPropertyChanged(Element* peFrom, PropertyInfo* ppi, int iIndex, Value* pvOld, Value* pvNew)
{
    UNREFERENCED_PARAMETER(pvOld);
    UNREFERENCED_PARAMETER(pvNew);

    {
        if (((peFrom == _peAccountList) && IsProp(Selector::Selection)) ||
            ((peFrom == _peViewer) && (IsProp(MouseWithin) || IsProp(KeyWithin))))
        {

            bool bHot = false;
            // Move to "hot" account list sheet if mouse or key is within viewer or an item is selected
            if (GetState() == LAS_PreStatus || GetState() == LAS_Logon)
            {
                bHot = _peViewer->GetMouseWithin() || _peAccountList->GetSelection();
            }

            if (!g_fNoAnimations)
            {
                KillFlagAnimation();
                _peAccountList->SetValue(SheetProp, PI_Local, bHot ? _pvHotList : _pvList);
            }
        }
    }
}



// System events

// Watch for input events. If the frame receives them, unselect the list and set keyfocus to it
void LogonFrame::OnInput(InputEvent* pEvent)
{
    if (pEvent->nStage == GMF_DIRECT || pEvent->nStage == GMF_BUBBLED)
    {
        if (pEvent->nDevice == GINPUT_KEYBOARD)
        {
             KeyboardEvent* pke = (KeyboardEvent*)pEvent;
             if (pke->nCode == GKEY_DOWN)
             {                 
                switch (pke->ch)
                {
                case VK_ESCAPE:
                    g_pErrorBalloon.HideToolTip();
                    SetKeyFocus();
                    _peAccountList->SetSelection(NULL);
                    pEvent->fHandled = true;
                    return;

                case VK_UP:
                case VK_DOWN:
                    if (UserListAvailable())
                    {
                        if (_peAccountList->GetSelection() == NULL)
                        {
                            Value* pvChildren;
                            ElementList* peList = _peAccountList->GetChildren(&pvChildren);
                            if (peList)
                            {
                                LogonAccount* peAccount = (LogonAccount*)peList->GetItem(0);
                                if (peAccount)
                                {
                                    peAccount->SetKeyFocus();
                                    _peAccountList->SetSelection(peAccount);
                                }
                            }
                            pvChildren->Release();
                            pEvent->fHandled = true;
                            return;
                        }
                    }
                    break;
                }
             }
        }
    }

    HWNDElement::OnInput(pEvent);
}

void LogonFrame::OnPropertyChanged(PropertyInfo* ppi, int iIndex, Value* pvOld, Value* pvNew)
{
    if (IsProp(KeyFocused))
    {
        if (pvNew->GetBool())
        {
            // Unselect items from account list if pressed on background
            _peAccountList->SetSelection(NULL);
        }
    }

    HWNDElement::OnPropertyChanged(ppi, iIndex, pvOld, pvNew);
}

Element* LogonFrame::GetAdjacent(Element* peFrom, int iNavDir, NavReference const* pnr, bool bKeyable)
{
    Element* peFound = HWNDElement::GetAdjacent(peFrom, iNavDir, pnr, bKeyable);

    if ((peFound == this))
    {
        // Don't let the frame show up in the tab order. Just repeat the search when we encounter the frame
        return HWNDElement::GetAdjacent(this, iNavDir, pnr, bKeyable);
    }

    return peFound;
}

// Add an account to the frame list
HRESULT LogonFrame::AddAccount(LPCWSTR pszPicture, BOOL fPicRes, LPCWSTR pszName, LPCWSTR pszUsername, LPCWSTR pszHint, BOOL fLoggedOn, OUT LogonAccount **ppla)
{
    HRESULT hr;
    LogonAccount* pla = NULL;

    if (!_pParser)
    {
        hr = E_FAIL;
        goto Failure;
    } 

    // Build up an account and insert into selection list
    hr = _pParser->CreateElement(L"accountitem", NULL, (Element**)&pla);
    if (FAILED(hr))
        goto Failure;

    hr = pla->OnTreeReady(pszPicture, fPicRes, pszName, pszUsername, pszHint, fLoggedOn, GetHInstance());
    if (FAILED(hr))
        goto Failure;

    hr = _peAccountList->Add(pla);
    if (FAILED(hr)) 
        goto Failure;

    if (pla)
    {
        SetElementAccessability(pla, true, ROLE_SYSTEM_LISTITEM, pszUsername);
    }
    
    if (_nColorDepth <= 8)
    {
        pla->SetBackgroundColor(ORGB (96,128,255));

        Element *pEle;
        pEle = pla->FindDescendent(StrToID(L"userpane"));
        if (pEle)
        {
            pEle->SetBorderColor(ORGB (96,128,255));
        }
    }

    if (ppla)
        *ppla = pla;

    return S_OK;


Failure:

    return hr;
}

// Passed authentication, log user on
HRESULT LogonFrame::OnLogUserOn(LogonAccount* pla)
{
    StartDefer();

#ifdef GADGET_ENABLE_GDIPLUS

    // Disable status so that it can't be clicked on anymore
    pla->DisableStatus(0);
    pla->DisableStatus(1);

    // Clear list of logon accounts except the one logging on
    Value* pvChildren;
    ElementList* peList = _peAccountList->GetChildren(&pvChildren);
    if (peList)
    {
        LogonAccount* peAccount;
        for (UINT i = 0; i < peList->GetSize(); i++)
        {
            peAccount = (LogonAccount*)peList->GetItem(i);

            if (peAccount != pla)
            {
                peAccount->SetLogonState(LS_Denied);
            }
            else
            {
                peAccount->SetLogonState(LS_Granted);
                peAccount->InsertStatus(0);
                peAccount->RemoveStatus(1);
            }

            // Account account items are disabled
            peAccount->SetEnabled(false);
        }
    }
    pvChildren->Release();

    FxLogUserOn(pla);

    // Set frame status
    SetStatus(LoadResString(IDS_LOGGINGON));

#else

    // Set keyfocus back to frame so it isn't pushed anywhere when controls are removed.
    // This will also cause a remove of the password panel from the current account
    SetKeyFocus();

    // Disable status so that it can't be clicked on anymore
    pla->DisableStatus(0);
    pla->DisableStatus(1);

    // Clear list of logon accounts except the one logging on
    Value* pvChildren;
    ElementList* peList = _peAccountList->GetChildren(&pvChildren);
    if (peList)
    {
        LogonAccount* peAccount;
        for (UINT i = 0; i < peList->GetSize(); i++)
        {
            peAccount = (LogonAccount*)peList->GetItem(i);

            if (peAccount != pla)
            {
                peAccount->SetLayoutPos(LP_None);
                peAccount->SetLogonState(LS_Denied);
            }
            else
            {
                peAccount->SetLogonState(LS_Granted);
                peAccount->InsertStatus(0);
                peAccount->RemoveStatus(1);
            }

            // Account account items are disabled
            peAccount->SetEnabled(false);
        }
    }
    pvChildren->Release();

    // Hide option buttons
    HidePowerButton();
    HideUndockButton();

    // Set frame status
    SetStatus(LoadResString(IDS_LOGGINGON));
    
    _peViewer->RemoveListener(this);
    _peAccountList->RemoveListener(this);

#endif

    EndDefer();

    return S_OK;
}

HRESULT LogonFrame::OnPower()
{
    DUITrace("LogonUI: LogonFrame::OnPower()\n");
    
    TurnOffComputer();

    return S_OK;
}

HRESULT LogonFrame::OnUndock()
{
    DUITrace("LogonUI: LogonFrame::OnUndock()\n");

    UndockComputer();
    
    return S_OK;
}

////////////////////////////////////////
//
//  LogonFrame::SetButtonLabels
//
//  If there is a friendly name of the computer stored in the computer name description, 
//  grab it and change the "Turn off" and "Undock" options to include the compute rname
//
//  RETURNS
//  nothing
//
/////////////////////////////////////////
void LogonFrame::SetButtonLabels()
{
    WCHAR szComputerName[MAX_COMPUTERDESC_LENGTH + 1] = {0};
    DWORD cchComputerName = MAX_COMPUTERDESC_LENGTH + 1;

    if ( _pbPower && SUCCEEDED(SHGetComputerDisplayName(NULL, SGCDNF_DESCRIPTIONONLY, szComputerName, cchComputerName)))
    {
        WCHAR szCommand[MAX_COMPUTERDESC_LENGTH + 50], szRes[50];

        LoadStringW(g_plf->GetHInstance(), IDS_POWERNAME, szRes, DUIARRAYSIZE(szRes));
        wsprintf(szCommand, szRes, szComputerName);
        SetPowerButtonLabel(szCommand);

        LoadStringW(g_plf->GetHInstance(), IDS_UNDOCKNAME, szRes, DUIARRAYSIZE(szRes));
        wsprintf(szCommand, szRes, szComputerName);
        SetUndockButtonLabel(szCommand);
    }
}


////////////////////////////////////////////////////////
// Logon Application State Transitions

////////////////////////////////////////
//
//  LogonFrame::EnterPreStatusMode
//
//  SHGina has sent a message telling logonui to enter the pre-status 
//  mode or we are starting up in status mode.  Hide items that should
//  not be displayed when in this state (power off, account list, user 
//  instructions, etc).
//
//  RETURNS
//  nothing
//
/////////////////////////////////////////
void LogonFrame::EnterPreStatusMode(BOOL fLock)
{
    // If currently locked, ignore call
    if (IsPreStatusLock())
    {
        DUIAssert(!fLock, "Receiving a lock while already within pre-Status lock");
        return; 
    }

    if (fLock)
    {
        LogonAccount *pAccount;
        // Entering pre-Status mode with "lock", cannot exit to logon state without an unlock
        _fPreStatusLock = TRUE;
        pAccount = static_cast<LogonAccount*>(_peAccountList->GetSelection());
        if (pAccount != NULL)
        {
            lstrcpynW(szLastSelectedName, pAccount->GetUsername(), ARRAYSIZE(szLastSelectedName));
        }
    }

    if (GetState() == LAS_Hide)
    {
        _pnhh->ShowWindow();
        SetWindowPos(_pnhh->GetHWND(), NULL, 0, 0, GetSystemMetrics(SM_CXSCREEN), GetSystemMetrics(SM_CYSCREEN), SWP_NOMOVE | SWP_NOZORDER );

    }

    StartDefer();

    SetKeyFocus();  // Removes selection

    HidePowerButton();
    HideUndockButton();
    ShowLogoArea();
    HideWelcomeArea();
    HideAccountPanel();

    Element *pe;
    pe = FindDescendent(StrToID(L"instruct"));
    DUIAssertNoMsg(pe);
    pe->SetVisible(FALSE);

    SetStatus(LoadResString(IDS_WINDOWSNAME));

    EndDefer();

    // Set state
    SetState(LAS_PreStatus);
}

////////////////////////////////////////
//
//  LogonFrame::EnterLogonMode
//
//  SHGina has sent a message telling logonui to enter the logon mode. 
//  this means to build and display the user list.  If we are re-entering
//  logon mode from another mode, the user list will already exist and we
//  should just set everything back to the pending state.
//
//  EnterLogonMode also sets up the undock and power off buttons based on 
//  whether those options are allowed.
//  
//
//  RETURNS
//  nothing
//
/////////////////////////////////////////
void LogonFrame::EnterLogonMode(BOOL fUnLock)
{
    // If currently locked, ignore call if not to unlock
    if (IsPreStatusLock())
    {
        if (fUnLock)
        {
            // Exiting pre-Status mode lock
            _fPreStatusLock = FALSE;
        }
        else
            return;
    }
    else
    {
        DUIAssert(!fUnLock, "Receiving an unlock while not within pre-Status lock");
    }

    DUIAssert(GetState() != LAS_Hide, "Cannot enter logon state from hidden state");
    
    ResetTheme();

    Element* pe;
    LogonAccount* plaAutoSelect = NULL;

    StartDefer();

    PokeComCtl32();

    // Retrieve data from backend if not populated
    if (UserListAvailable())
    {
        ResetUserList();
    }
    else
    {
        // Cache password field atoms for quicker identification (static)
        LogonAccount::idPwdGo = AddAtomW(L"go");

        LogonAccount::idPwdInfo = AddAtomW(L"info");

        // Create password panel
        Element* pePwdPanel;
        _pParser->CreateElement(L"passwordpanel", NULL, &pePwdPanel);
        DUIAssert(pePwdPanel, "Can't create password panel");

        // Cache password panel edit control
        Edit* pePwdEdit = (Edit*)pePwdPanel->FindDescendent(StrToID(L"password"));
        DUIAssert(pePwdPanel, "Can't create password edit control");

        // Cache password panel info button
        Button* pbPwdInfo = (Button*)pePwdPanel->FindDescendent(StrToID(L"info"));
        DUIAssert(pePwdPanel, "Can't create password info button");

        // Cache password panel keyboard element
        Element* peKbdIcon = (Button*)pePwdPanel->FindDescendent(StrToID(L"keyboard"));
        DUIAssert(pePwdPanel, "Can't create password keyboard icon");

        LogonAccount::InitPasswordPanel(pePwdPanel, pePwdEdit, pbPwdInfo, peKbdIcon );
    }

    BuildAccountList(this, &plaAutoSelect);

    if (szLastSelectedName[0] != L'\0')
    {
        LogonAccount *pAccount;
        pAccount = InternalFindNamedUser(szLastSelectedName);
        if (pAccount != NULL)
        {
            plaAutoSelect = pAccount;
        }
        szLastSelectedName[0] = L'\0';
    }

    if (IsShutdownAllowed())
    {
        ShowPowerButton();
    }
    else
    {
        HidePowerButton();
    }

    if (IsUndockAllowed())
    {
        ShowUndockButton();
    }
    else
    {
        HideUndockButton();
    }

    pe = FindDescendent(StrToID(L"instruct"));
    DUIAssertNoMsg(pe);
    pe->SetVisible(TRUE);
    
    
    pe = FindDescendent(StrToID(L"product"));
    DUIAssertNoMsg(pe);
    pe->StopAnimation(ANI_AlphaType);
    pe->RemoveLocalValue(BackgroundProp);

    // Account list viewer

    ShowAccountPanel();

    SetTitle(IDS_WELCOME);
    SetStatus(LoadResString(IDS_BEGIN));

    if (!plaAutoSelect)
    {
        SetKeyFocus();
    }

    EndDefer();

    // Set state
    SetState(LAS_Logon);

    // Set auto-select item, if exists
    if (plaAutoSelect)
    {
        plaAutoSelect->SetKeyFocus();
        _peAccountList->SetSelection(plaAutoSelect);
    }

    SetButtonLabels();
    SetForegroundWindow(_pnhh->GetHWND());
}

////////////////////////////////////////
//
//  LogonFrame::EnterPostStatusMode
//
//  SHGina has sent a message telling logonui that the authentication has succeeded
//  and we should now go into the post status mode. LogonFrame::OnLogUserOn has already
//  started the animations for this.  
//
//  RETURNS
//  nothing
//
/////////////////////////////////////////
void LogonFrame::EnterPostStatusMode()
{
    // Set state
    SetState(LAS_PostStatus);
    
    Element *pe;
    pe = FindDescendent(StrToID(L"instruct"));
    DUIAssertNoMsg(pe);
    pe->SetVisible(FALSE);

    //animation was started in OnLogUserOn
    ShowWelcomeArea();
    HideLogoArea();
}


////////////////////////////////////////
//
//  LogonFrame::EnterHideMode
//
//  SHGina has sent a message telling logonui to hide.
//
//  RETURNS
//  nothing
//
/////////////////////////////////////////
void LogonFrame::EnterHideMode()
{
    // Set state
    SetState(LAS_Hide);
    
    if (_pnhh)
    {
        _pnhh->HideWindow();
    }
}



////////////////////////////////////////
//
//  LogonFrame::EnterDoneMode
//
//  SHGina has sent a message telling logonui to exit.
//
//  RETURNS
//  nothing
//
/////////////////////////////////////////
void LogonFrame::EnterDoneMode()
{
    // Set state
    SetState(LAS_Done);
    
    if (_pnhh)
    {
        _pnhh->DestroyWindow();
    }
}


////////////////////////////////////////
//
//  LogonFrame::ResetUserList
//
//  Delete all of the users in the user list so that it can be rebuilt
//
//  RETURNS
//  nothing
//
/////////////////////////////////////////
void LogonFrame::ResetUserList()
{
    if (UserListAvailable())
    {
        // reset the candidate to NULL
        LogonAccount::ClearCandidate();

        // remove of the password panel from the current account (if any)
        SetKeyFocus();

        //fix up the existing list to get us back into logon mode
        Value* pvChildren;
        ElementList* peList = _peAccountList->GetChildren(&pvChildren);
       
        if (peList)
        {
            LogonAccount* peAccount;
            for (int i = peList->GetSize() - 1; i >= 0; i--)
            {
                peAccount = (LogonAccount*)peList->GetItem(i);
                peAccount->Destroy();
            }
        }
        pvChildren->Release();
    }
}


////////////////////////////////////////
//
//  LogonFrame::InteractiveLogonRequest
//
//  SHGina has sent an InteractiveLogonRequest.  We should look for the user
//  that was passed in and if found, try to log them in.  
//
//  RETURNS
//  LRESULT indicating success or failure of finding htem and logging them in.
//
/////////////////////////////////////////
LRESULT LogonFrame::InteractiveLogonRequest(LPCWSTR pszUsername, LPCWSTR pszPassword)
{
    LRESULT lResult = 0;
    LogonAccount *pla;
    pla = FindNamedUser(pszUsername);

    if (pla)
    {
        if (pla->OnAuthenticateUser(pszPassword))
        {
            lResult = ERROR_SUCCESS;
        }
        else
        {
            lResult = ERROR_ACCESS_DENIED;
        }
    }
    return(lResult);
}

////////////////////////////////////////
//
//  LogonFrame::InternalFindNamedUser
//
//  Find a user in the LogonAccount list with the
//  provided username (logon name).  
//
//  RETURNS
//  The LogonAccount* for the indicated user or NULL if 
//  not found
//
/////////////////////////////////////////
LogonAccount* LogonFrame::InternalFindNamedUser(LPCWSTR pszUsername)

{
    LogonAccount *plaResult = NULL;
    Value* pvChildren;

    ElementList* peList = _peAccountList->GetChildren(&pvChildren);
    if (peList)
    {
        for (UINT i = 0; i < peList->GetSize(); i++)
        {
            DUIAssert(peList->GetItem(i)->GetClassInfo() == LogonAccount::Class, "Account list must contain LogonAccount objects");

            LogonAccount* pla = (LogonAccount*)peList->GetItem(i);

            if (pla)
            {
                if (lstrcmpi(pla->GetUsername(), pszUsername) == 0)
                {
                    plaResult = pla;
                    break;
                }
            }
        }
    }

    pvChildren->Release();
    return plaResult;
}

////////////////////////////////////////
//
//  LogonFrame::FindNamedUser
//
//  Find a user in the LogonAccount list with the
//  provided username (logon name).  
//
//  RETURNS
//  The LogonAccount* for the indicated user or NULL if 
//  not found
//
/////////////////////////////////////////
LogonAccount *LogonFrame::FindNamedUser(LPCWSTR pszUsername)
{
    
    // Early out if:    no user list available
    //                  not in logon mode (showing user list)

    if (!UserListAvailable() || (GetState() != LAS_Logon))
    {
        return NULL;
    }
    else
    {
        return(InternalFindNamedUser(pszUsername));
    }

}

////////////////////////////////////////
//
//  LogonFrame::UpdateUserStatus
//
//  Iterate the list of user accounts and call LogonAccount::UpdateNotifications
//  for each one.  This will result in them updating the unread mail count and
//  logon status for each of the logon accounts.
//  Pass fRefreshAll through to UpdateApplications
//
/////////////////////////////////////////

void LogonFrame::UpdateUserStatus(BOOL fRefreshAll)
{
    Value* pvChildren;
    static fUpdating = false;
    // Early out if:    no user list available
    //                  not in logon mode (showing user list)

    if (!UserListAvailable() || (GetState() != LAS_Logon) || fUpdating)
        return;

    fUpdating = true;
    StartDefer();
    
    ElementList* peList = _peAccountList->GetChildren(&pvChildren);
    if (peList)
    {
        for (UINT i = 0; i < peList->GetSize(); i++)
        {
            DUIAssert(peList->GetItem(i)->GetClassInfo() == LogonAccount::Class, "Account list must contain LogonAccount objects");

            LogonAccount* pla = (LogonAccount*)peList->GetItem(i);

            if (pla)
            {
                pla->UpdateNotifications(fRefreshAll);
            }
        }
    }

    if (IsUndockAllowed())
    {
        ShowUndockButton();
    }
    else
    {
        HideUndockButton();
    }

    pvChildren->Release();
    EndDefer();
    fUpdating = false;
}


////////////////////////////////////////
//
//  LogonFrame::SelectUser
//
//  
//
/////////////////////////////////////////

void LogonFrame::SelectUser(LPCWSTR pszUsername)
{
    LogonAccount *pla;

    pla = FindNamedUser(pszUsername);
    if (pla != NULL)
    {
        pla->OnAuthenticatedUser();
    }
    else
    {
        LogonAccount::ClearCandidate();
        EnterPostStatusMode();
        HidePowerButton();
        HideUndockButton();
        HideAccountPanel();
    }
}

////////////////////////////////////////
//
//  LogonFrame::Resize
//
//  
//
/////////////////////////////////////////

void LogonFrame::Resize()
{
    RECT rc;

    SystemParametersInfo(SPI_GETWORKAREA, 0, &rc, 0);
    SetWindowPos(_pnhh->GetHWND(),
                 NULL,
                 rc.left,
                 rc.top,
                 rc.right - rc.left,
                 rc.bottom - rc.top,
                 SWP_NOACTIVATE | SWP_NOZORDER);
}

////////////////////////////////////////
//
//  LogonFrame::SetAnimations
//
//  
//
/////////////////////////////////////////

void LogonFrame::SetAnimations(BOOL fAnimations)
{
    g_fNoAnimations = !fAnimations;
    if (fAnimations)
    {
        EnableAnimations();
    }
    else
    {
        DisableAnimations();
    }
}


////////////////////////////////////////////////////////
// Property definitions

////////////////////////////////////////////////////////
// ClassInfo (must appear after property definitions)

// Define class info with type and base type, set static class pointer
IClassInfo* LogonFrame::Class = NULL;
HRESULT LogonFrame::Register()
{
    return ClassInfo<LogonFrame,HWNDElement>::Register(L"LogonFrame", NULL, 0);
}

////////////////////////////////////////////////////////
//
HRESULT LogonAccountList::Create(OUT Element** ppElement)
{
    *ppElement = NULL;

    LogonAccountList* plal = HNew<LogonAccountList>();
    if (!plal)
        return E_OUTOFMEMORY;

    HRESULT hr = plal->Initialize();
    if (FAILED(hr))
    {
        plal->Destroy();
        return hr;
    }

    *ppElement = plal;

    return S_OK;
}

void LogonAccountList::OnPropertyChanged(PropertyInfo* ppi, int iIndex, Value* pvOld, Value* pvNew)
{
#ifdef GADGET_ENABLE_GDIPLUS
    if (IsProp(MouseWithin))
    {
        if (pvNew->GetBool())
            FxMouseWithin(fdIn);
        else
            FxMouseWithin(fdOut);
    }
#endif // GADGET_ENABLE_GDIPLUS

    Selector::OnPropertyChanged(ppi, iIndex, pvOld, pvNew);
}


////////////////////////////////////////////////////////
// Property definitions

////////////////////////////////////////////////////////
// ClassInfo (must appear after property definitions)

// Define class info with type and base type, set static class pointer
IClassInfo* LogonAccountList::Class = NULL;
HRESULT LogonAccountList::Register()
{
    return ClassInfo<LogonAccountList,Selector>::Register(L"LogonAccountList", NULL, 0);
}

////////////////////////////////////////////////////////
//
// LogonAccount
//
////////////////////////////////////////////////////////

ATOM LogonAccount::idPwdGo = NULL;
ATOM LogonAccount::idPwdInfo = NULL;
Element* LogonAccount::_pePwdPanel = NULL;
Edit* LogonAccount::_pePwdEdit = NULL;
Button* LogonAccount::_pbPwdInfo = NULL;
Element* LogonAccount::_peKbdIcon = NULL;
LogonAccount* LogonAccount::_peCandidate = NULL;

HRESULT LogonAccount::Create(OUT Element** ppElement)
{
    *ppElement = NULL;

    LogonAccount* pla = HNew<LogonAccount>();
    if (!pla)
        return E_OUTOFMEMORY;

    HRESULT hr = pla->Initialize();
    if (FAILED(hr))
    {
        pla->Destroy();
        return hr;
    }

    *ppElement = pla;

    return S_OK;
}

HRESULT LogonAccount::Initialize()
{
    // Zero-init members
    _pbStatus[0] = NULL;
    _pbStatus[1] = NULL;
    _pvUsername = NULL;
    _pvHint = NULL;
    _fPwdNeeded = (BOOL)-1; // uninitialized
    _fLoggedOn = FALSE;
    _fHasPwdPanel = FALSE;

    // Do base class initialization
    HRESULT hr = Button::Initialize(AE_MouseAndKeyboard);
    if (FAILED(hr))
        goto Failure;

    // Initialize

    // TODO: Additional LogonAccount initialization code here

    return S_OK;


Failure:

    return hr;
}

LogonAccount::~LogonAccount()
{
    // Free resources
    if (_pvUsername)
    {
        _pvUsername->Release();
        _pvUsername = NULL;
    }

    if (_pvHint)
    {
        _pvHint->Release();
        _pvHint = NULL;
    }

    // TODO: Account destruction cleanup
}

void LogonAccount::SetStatus(UINT nLine, LPCWSTR psz) 
{ 
    if (psz)
    {
        _pbStatus[nLine]->SetContentString(psz); 
        SetElementAccessability(_pbStatus[nLine], true, ROLE_SYSTEM_LINK, psz);
    }
}

// Tree is ready
HRESULT LogonAccount::OnTreeReady(LPCWSTR pszPicture, BOOL fPicRes, LPCWSTR pszName, LPCWSTR pszUsername, LPCWSTR pszHint, BOOL fLoggedOn, HINSTANCE hInst)
{
    HRESULT hr;
    Element* pePicture = NULL;
    Element* peName = NULL;
    Value* pv = NULL;

    StartDefer();

    // Cache important descendents
    _pbStatus[0] = (Button*)FindDescendent(StrToID(L"status0"));
    DUIAssert(_pbStatus[0], "Cannot find account list, check the UI file");
    if (_pbStatus[0] == NULL)
    {
        hr = E_OUTOFMEMORY;
        goto Failure;
    }

    _pbStatus[1] = (Button*)FindDescendent(StrToID(L"status1"));
    DUIAssert(_pbStatus[1], "Cannot find account list, check the UI file");
    if (_pbStatus[1] == NULL)
    {
        hr = E_OUTOFMEMORY;
        goto Failure;
    }

    // Locate descendents and populate
    pePicture = FindDescendent(StrToID(L"picture"));
    DUIAssert(pePicture, "Cannot find account list, check the UI file");
    if (pePicture == NULL)
    {
        hr = E_OUTOFMEMORY;
        goto Failure;
    }

    // CreateGraphic handles NULL bitmaps
    pv = Value::CreateGraphic(pszPicture, GRAPHIC_NoBlend, 0, 0, 0, (fPicRes) ? hInst : 0);
    if (pv)
    {
        // Our preferred size is 1/2 inch (36pt) square.
        USHORT cx = (USHORT)LogonFrame::PointToPixel(36);
        USHORT cy = cx;

        Graphic* pg = pv->GetGraphic();

        // If it's not square, scale the smaller dimension
        // to maintain the aspect ratio.
        if (pg->cx > pg->cy)
        {
            cy = (USHORT)MulDiv(cx, pg->cy, pg->cx);
        }
        else if (pg->cy > pg->cx)
        {
            cx = (USHORT)MulDiv(cy, pg->cx, pg->cy);
        }

        // Did anything change?
        if (cx != pg->cx || cy != pg->cy)
        {
            // Reload the graphic
            pv->Release();
            pv = Value::CreateGraphic(pszPicture, GRAPHIC_NoBlend, 0, cx, cy, (fPicRes) ? hInst : 0);
        }
    }
    if (!pv)
    {
        // if we can't get the picture, use a default one
        pv = Value::CreateGraphic(MAKEINTRESOURCEW(IDB_USER0), GRAPHIC_NoBlend, 0, (USHORT)LogonFrame::PointToPixel(36), (USHORT)LogonFrame::PointToPixel(36), hInst);
        if (!pv)
        {
            hr = E_OUTOFMEMORY;
            goto Failure;
        }
    }

    hr = pePicture->SetValue(Element::ContentProp, PI_Local, pv);
    if (FAILED(hr))
        goto Failure;

    pv->Release();
    pv = NULL;

    // Name
    peName = FindDescendent(StrToID(L"username"));
    DUIAssert(peName, "Cannot find account list, check the UI file");
    if (peName == NULL)
    {
        hr = E_OUTOFMEMORY;
        goto Failure;
    }

    hr = peName->SetContentString(pszName);
    if (FAILED(hr))
        goto Failure;

    // Store members, will be released in destructor
    if (pszUsername)
    {
        _pvUsername = Value::CreateString(pszUsername);
        if (!_pvUsername)
        {
            hr = E_OUTOFMEMORY;
            goto Failure;
        }
    }

    if (pszHint)
    {
        _pvHint = Value::CreateString(pszHint);
        if (!_pvHint)
        {
            hr = E_OUTOFMEMORY;
            goto Failure;
        }
    }

    _fLoggedOn = fLoggedOn;
    
    EndDefer();

    return S_OK;


Failure:

    EndDefer();

    if (pv)
        pv->Release();

    return hr;
}

// Generic events
void LogonAccount::OnEvent(Event* pEvent)
{
    if (pEvent->nStage == GMF_DIRECT)  // Direct events
    {
        // Watch for click events initiated by LogonAccounts only
        // if we are not logging someone on
        if (pEvent->uidType == Button::Click)
        {
            if (pEvent->peTarget == this)
            {
                if (IsPasswordBlank())
                {
                    // No password needed, attempt logon
                    OnAuthenticateUser();
                }

                pEvent->fHandled = true;
                return;
            }
        }
    }
    else if (pEvent->nStage == GMF_BUBBLED)  // Bubbled events
    {
        if (pEvent->uidType == Button::Click)
        {
            if (idPwdGo && (pEvent->peTarget->GetID() == idPwdGo))
            {
                // Attempt logon
                OnAuthenticateUser();
                pEvent->fHandled = true;
                return;
            }
            else if (idPwdInfo && (pEvent->peTarget->GetID() == idPwdInfo))
            {
                // Retrieve hint
                OnHintSelect();
                pEvent->fHandled = true;
                return;
            }
            else if (pEvent->peTarget == _pbStatus[0])
            {
                // Retrieve status info
                OnStatusSelect(0);
                pEvent->fHandled = true;
                return;
            }
            else if (pEvent->peTarget == _pbStatus[1])
            {
                // Retrieve status info
                OnStatusSelect(1);
                pEvent->fHandled = true;
                return;
            }
        }
        else if (pEvent->uidType == Edit::Enter)
        {
            if (_pePwdEdit && pEvent->peTarget == _pePwdEdit)
            {
                // Attempt logon
                OnAuthenticateUser();
                pEvent->fHandled = true;
                return;
            }
        }
    }

    Button::OnEvent(pEvent);
}

// System events
void LogonAccount::OnInput(InputEvent* pEvent)
{
    KeyboardEvent* pke = (KeyboardEvent*)pEvent;

    if (pke->nDevice == GINPUT_KEYBOARD && pke->nCode == GKEY_DOWN)
    {
        g_pErrorBalloon.HideToolTip();
    }
    LayoutCheckHandler(LAYOUT_DEF_USER);
    Button::OnInput(pEvent);
}

void LogonAccount::OnPropertyChanged(PropertyInfo* ppi, int iIndex, Value* pvOld, Value* pvNew)
{
#ifdef GADGET_ENABLE_GDIPLUS
    // MouseWithin must be before Selected
    if (IsProp(MouseWithin))
    {
        if (pvNew->GetBool())
            FxMouseWithin(fdIn);
        else
            FxMouseWithin(fdOut);
    }
#endif    

    if (IsProp(Selected))
    {
        if (pvNew->GetBool())
            InsertPasswordPanel();
        else
            RemovePasswordPanel();
    }

    Button::OnPropertyChanged(ppi, iIndex, pvOld, pvNew);
}

BOOL LogonAccount::IsPasswordBlank()
{
    if (_fPwdNeeded == (BOOL)-1)
    {
        // assume a password is needed
        _fPwdNeeded = TRUE;

        if (_pvUsername)
        {
            LPTSTR pszUsername;

            pszUsername = _pvUsername->GetString();
            if (pszUsername)
            {
                ILogonUser* pUser;

                if (SUCCEEDED(GetLogonUserByLogonName(pszUsername, &pUser)))
                {
                    VARIANT_BOOL vbPwdNeeded;

                    if (RunningInWinlogon()                                     &&
                        SUCCEEDED(pUser->get_passwordRequired(&vbPwdNeeded))    &&
                        (vbPwdNeeded == VARIANT_FALSE))
                    {
                        _fPwdNeeded = FALSE;
                    }

                    pUser->Release();
                }
            }
        }
    }

    return (_fPwdNeeded == FALSE);
}

HRESULT LogonAccount::InsertPasswordPanel()
{
    HRESULT hr;

    // If already have it, or no password is available, or logon state is not pending
    if (_fHasPwdPanel || IsPasswordBlank() || (GetLogonState() != LS_Pending))
        goto Done;

    StartDefer();

    // Add password panel
    hr = Add(_pePwdPanel);
    if (FAILED(hr))
    {
        EndDefer();
        goto Failure;
    }

    SetElementAccessability(_pePwdEdit, true,  ROLE_SYSTEM_STATICTEXT, _pvUsername->GetString());

    _fHasPwdPanel = TRUE;

#ifdef GADGET_ENABLE_GDIPLUS    
    // Ensure that the Edit control is visible
    ShowEdit();
#endif

    // Hide hint button if no hint provided
    if (_pvHint && *(_pvHint->GetString()) != NULL)
        _pbPwdInfo->SetVisible(true);
    else
        _pbPwdInfo->SetVisible(false);

    // Hide status text (do not remove or insert)
    HideStatus(0);
    HideStatus(1);

    LayoutCheckHandler(LAYOUT_DEF_USER);
    // Push focus to edit control
    _pePwdEdit->SetKeyFocus();

    EndDefer();

Done:

    return S_OK;

Failure:

    return hr;
}

HRESULT LogonAccount::RemovePasswordPanel()
{
    HRESULT hr;

    if (!_fHasPwdPanel)
        goto Done;

    StartDefer();

    // Remove password panel
    hr = Remove(_pePwdPanel);
    if (FAILED(hr))
    {
        EndDefer();
        goto Failure;
    }

    // Clear out edit control
    _pePwdEdit->SetContentString(L"");
    UnSubClassTheEditBox(_pePwdEdit->GetHWND());     // Provide for trap of the TTN_LINKCLICK event


    // Unhide status text
    ShowStatus(0);
    ShowStatus(1);

    _fHasPwdPanel = FALSE;

    EndDefer();

Done:

    return S_OK;

Failure:
    
    return hr;
}

// User has authenticated
void LogonAccount::OnAuthenticatedUser()
{
    // On success, log user on
    _peCandidate = this;
    g_plf->OnLogUserOn(this);
    g_plf->EnterPostStatusMode();
}

// User is attempting to log on
BOOL LogonAccount::OnAuthenticateUser(LPCWSTR pszInPassword)
{
    HRESULT hr;
    // Logon requested on this account
    LPCWSTR pszPassword = L"";
    Value* pv = NULL;

    ILogonUser *pobjUser;
    VARIANT_BOOL vbLogonSucceeded = VARIANT_FALSE;

    WCHAR *pszUsername = _pvUsername->GetString();

    if (pszUsername)
    {
        if (SUCCEEDED(hr = GetLogonUserByLogonName(pszUsername, &pobjUser)))
        {
            if (!IsPasswordBlank())
            {
                if (pszInPassword)
                {
                    pszPassword = pszInPassword;
                }
                else
                {
                    if (_pePwdEdit)
                    {
                        pszPassword = _pePwdEdit->GetContentString(&pv);
        
                        if (!pszPassword)
                            pszPassword = L"";
        
                        if (pv)
                        {
                            pv->Release();
                        }
                    }
                }

                BSTR bstr = SysAllocString(pszPassword);
                pobjUser->logon(bstr, &vbLogonSucceeded);
                SysFreeString(bstr);
            }
            else
            {
                pobjUser->logon(L"", &vbLogonSucceeded);
            }
            pobjUser->Release();
        }
    }

    if (vbLogonSucceeded == VARIANT_TRUE)
    {
        OnAuthenticatedUser();
    }
    else
    {
        if (pszInPassword == NULL)  
        {
            ShowPasswordIncorrectMessage();
        }
    }

    return (vbLogonSucceeded == VARIANT_TRUE);
}

////////////////////////////////////////
//
//  LogonAccount::ShowPasswordIncorrectMessage
//
//  Put up the balloon message that says that the password is incorrect.
//
/////////////////////////////////////////
void LogonAccount::ShowPasswordIncorrectMessage()
{
    TCHAR szError[512], szTitle[128], szAccessible[640];
    BOOL fBackupAvailable = false;
    BOOL fHint = false;
    DWORD dwResult;
    g_szUsername[0] = 0;
    SubClassTheEditBox(_pePwdEdit->GetHWND());   // Provide for trap of the TTN_LINKCLICK event
    if (0 < lstrlen(_pvUsername->GetString())) 
    {
        wcscpy(g_szUsername,_pvUsername->GetString());
        if (0 == PRQueryStatus(NULL,_pvUsername->GetString(),&dwResult))
        {
            if (0 == dwResult) 
            {
                fBackupAvailable = TRUE;
            }
        }
    }

    if (NULL != _pvHint && 0 < lstrlen(_pvHint->GetString()))
    {
        fHint = true;
    }

    LoadStringW(g_plf->GetHInstance(), IDS_BADPWDTITLE, szTitle, DUIARRAYSIZE(szTitle));

    if (!fBackupAvailable && fHint)
        LoadStringW(g_plf->GetHInstance(), IDS_BADPWDHINT,      szError, DUIARRAYSIZE(szError));
    else if (fBackupAvailable && !fHint)
        LoadStringW(g_plf->GetHInstance(), IDS_BADPWDREST,      szError, DUIARRAYSIZE(szError));
    else if (fBackupAvailable && fHint)
        LoadStringW(g_plf->GetHInstance(), IDS_BADPWDHINTREST,  szError, DUIARRAYSIZE(szError));
    else
        LoadStringW(g_plf->GetHInstance(), IDS_BADPWD,          szError, DUIARRAYSIZE(szError));
    g_pErrorBalloon.ShowToolTip(GetModuleHandleW(NULL), _pePwdEdit->GetHWND(), szError, szTitle, TTI_ERROR, EB_WARNINGCENTERED | EB_MARKUP, 10000);

    lstrcpy(szAccessible, szTitle);
    lstrcat(szAccessible, szError);
    SetElementAccessability(_pePwdEdit, true,  ROLE_SYSTEM_STATICTEXT, szAccessible);
    
    _pePwdEdit->RemoveLocalValue(ContentProp);
    _pePwdEdit->SetKeyFocus();
}

////////////////////////////////////////
//
//  LogonAccount::OnHintSelect
//
//  Put up the balloon message that contains the user's password hint.
//
/////////////////////////////////////////
void LogonAccount::OnHintSelect()
{
    TCHAR szTitle[128];

    DUIAssertNoMsg(_pbPwdInfo);

    // get the position of the link so we can target the balloon tip correctly
    POINT pt = {0,0};
    CalcBalloonTargetLocation(g_plf->GetNativeHost()->GetHWND(), _pbPwdInfo, &pt);

    LoadStringW(g_plf->GetHInstance(), IDS_PASSWORDHINTTITLE, szTitle, DUIARRAYSIZE(szTitle));
    g_pErrorBalloon.ShowToolTip(GetModuleHandleW(NULL), g_plf->GetHWND(), &pt, _pvHint->GetString(), szTitle, TTI_INFO, EB_WARNINGCENTERED, 10000);
    
    SetElementAccessability(_pePwdEdit, true,  ROLE_SYSTEM_STATICTEXT, _pvHint->GetString());

    _pePwdEdit->SetKeyFocus();
}

////////////////////////////////////////
//
//  LogonAccount::OnStatusSelect
//
//  The user clicked one of the notification links (unread mail, running programs, etc).
//  Dispatch that click to the right balloon tip display procs
//
/////////////////////////////////////////
void LogonAccount::OnStatusSelect(UINT nLine)
{
    if (nLine == LASS_Email)
    {
        UnreadMailTip();
    }
    else if (nLine == LASS_LoggedOn)
    {
        AppRunningTip();
    }

}

////////////////////////////////////////
//
//  LogonAccount::AppRunningTip
//
//  The user activated the link that shows how many programs are running.  Show the tip that
//  basically says that running lots of programs can show the machine down
//
/////////////////////////////////////////
void LogonAccount::AppRunningTip()
{
    TCHAR szTitle[256], szTemp[512];
    
    Element* pe = FindDescendent(StrToID(L"username"));
    DUIAssertNoMsg(pe);

    Value* pv;
    LPCWSTR pszDisplayName = pe->GetContentString(&pv);
    if (!pszDisplayName)
        pszDisplayName = L"";

    if (_dwRunningApps == 0)
    {
        LoadStringW(g_plf->GetHInstance(), IDS_USERISLOGGEDON, szTemp, DUIARRAYSIZE(szTemp));
        wsprintf(szTitle, szTemp, pszDisplayName, _dwRunningApps);
    }
    else
    {
        LoadStringW(g_plf->GetHInstance(), (_dwRunningApps == 1 ? IDS_USERRUNNINGPROGRAM : IDS_USERRUNNINGPROGRAMS), szTemp, DUIARRAYSIZE(szTemp));
        wsprintf(szTitle, szTemp, pszDisplayName, _dwRunningApps);
    }
    
    pv->Release();

    // get the position of the link so we can target the balloon tip correctly
    POINT pt = {0,0};
    CalcBalloonTargetLocation(g_plf->GetNativeHost()->GetHWND(), _pbStatus[LASS_LoggedOn], &pt);

    LoadStringW(g_plf->GetHInstance(), (_dwRunningApps > 0 ? IDS_TOOMANYPROGRAMS : IDS_TOOMANYUSERS), szTemp, DUIARRAYSIZE(szTemp));
    g_pErrorBalloon.ShowToolTip(GetModuleHandleW(NULL), g_plf->GetHWND(), &pt, szTemp, szTitle, TTI_INFO, EB_WARNINGCENTERED, 10000);
}

////////////////////////////////////////
//
//  LogonAccount::UnreadMailTip
//
//  The user activated the link that shows how many unread email messages they have.
//  Show the tip that says how many messages each of their email accounts has.
//
//  TODO -- speed this up.  its really slow now because each call to SHGina's 
//  ILogonUser::getMailAccountInfo load's the users' hive to get the next account from
//  the registry.
//
/////////////////////////////////////////
void LogonAccount::UnreadMailTip()
{
    TCHAR szTitle[128], szMsg[1024], szTemp[512], szRes[128];
    HRESULT hr = E_FAIL;
    ILogonUser *pobjUser = NULL;

    szMsg[0] = TEXT('\0');

    Element* pe = FindDescendent(StrToID(L"username"));
    DUIAssertNoMsg(pe);

    Value* pv;
    LPCWSTR pszDisplayName = pe->GetContentString(&pv);
    if (!pszDisplayName)
        pszDisplayName = L"";
    
    WCHAR *pszUsername = _pvUsername->GetString();
    DWORD dwAccountsAdded = 0;
    if (pszUsername)
    {
        if (SUCCEEDED(hr = GetLogonUserByLogonName(pszUsername, &pobjUser)) && pobjUser)
        {
            DWORD  i, cMailAccounts;
            
            cMailAccounts = 5;
            for (i = 0; i < cMailAccounts; i++)
            {
                UINT cUnread;
                VARIANT varAcctName = {0};

                hr = pobjUser->getMailAccountInfo(i, &varAcctName, &cUnread);

                if (FAILED(hr))
                {
                    break;
                }
                
                if (varAcctName.bstrVal && cUnread > 0)
                {
                    if (dwAccountsAdded > 0)
                    {
                        lstrcat(szMsg, TEXT("\r\n"));
                    }
                    dwAccountsAdded++;
                    LoadStringW(g_plf->GetHInstance(), IDS_UNREADMAILACCOUNT, szRes, DUIARRAYSIZE(szRes));
                    wsprintf(szTemp, szRes, varAcctName.bstrVal, cUnread);
                    lstrcat(szMsg, szTemp);
                }
                VariantClear(&varAcctName);
            }
            pobjUser->Release();
        }
    }
    LoadStringW(g_plf->GetHInstance(), (_dwUnreadMail == 1 ? IDS_USERUNREADEMAIL : IDS_USERUNREADEMAILS), szTemp, DUIARRAYSIZE(szTemp));
    wsprintf(szTitle, szTemp, pszDisplayName, _dwUnreadMail);
    pv->Release();

    // get the position of the link so we can target the balloon tip correctly
    POINT pt = {0,0};
    CalcBalloonTargetLocation(g_plf->GetNativeHost()->GetHWND(), _pbStatus[LASS_Email], &pt);
    
    if (szMsg[0] == 0)
    {
        LoadStringW(g_plf->GetHInstance(), IDS_UNREADMAILTEMP, szMsg, DUIARRAYSIZE(szMsg));
    }
    g_pErrorBalloon.ShowToolTip(GetModuleHandleW(NULL), g_plf->GetHWND(), &pt, szMsg, szTitle, TTI_INFO, EB_WARNINGCENTERED, 10000);
}


////////////////////////////////////////
//
//  LogonAccount::UpdateNotifications
//
//  Update the notification links for this user.  Check to see if they are logged on and 
//  if so, find out how many applications they had open when they last switched away.
//
//  Check the unread mail count for users who are logged on or for everyone if fCheckEverything is
//  true.  Checking unread mail counts is slow because it has to load the user's registry hive.
//  Since no applications will update this value when the user is not logged on, there is no 
//  need to check this when they are not logged on.  The exception to this is when we are first
//  building the list since we need to always load it then, hence the fCheckEverything flag.
//
/////////////////////////////////////////
void LogonAccount::UpdateNotifications(BOOL fCheckEverything)
{
    HRESULT hr = E_FAIL;
    ILogonUser *pobjUser = NULL;
    WCHAR szTemp[1024], sz[1024];

    if (_fHasPwdPanel)
        return;

    WCHAR *pszUsername = _pvUsername->GetString();

    if (pszUsername)
    {
        if (SUCCEEDED(hr = GetLogonUserByLogonName(pszUsername, &pobjUser)) && pobjUser)
        {
            VARIANT_BOOL vbLoggedOn;
            VARIANT varUnreadMail;
            BOOL fLoggedOn;
            int iUnreadMailCount = 0;
            DWORD dwProgramsRunning = 0;

            if (FAILED(pobjUser->get_isLoggedOn(&vbLoggedOn)))
            {
                vbLoggedOn = VARIANT_FALSE;
            }

            fLoggedOn = (vbLoggedOn == VARIANT_TRUE);
            
            if (fLoggedOn)
            {
                HKEY hKey;
                CUserProfile userProfile(pszUsername, NULL);

                if (ERROR_SUCCESS == RegOpenKeyEx(userProfile, TEXT("SessionInformation"), 0, KEY_QUERY_VALUE, &hKey))
                {
                    DWORD dwProgramsRunningSize = sizeof(dwProgramsRunning);
                    RegQueryValueEx(hKey, TEXT("ProgramCount"), NULL, NULL, reinterpret_cast<LPBYTE>(&dwProgramsRunning), &dwProgramsRunningSize);
                    RegCloseKey(hKey);
                }
            }
            SetRunningApps(dwProgramsRunning);
                
            if (fLoggedOn)
            {
                InsertStatus(LASS_LoggedOn);

                if (dwProgramsRunning != 0)
                {
                    LoadStringW(g_plf->GetHInstance(), (dwProgramsRunning == 1 ? IDS_RUNNINGPROGRAM : IDS_RUNNINGPROGRAMS), szTemp, ARRAYSIZE(szTemp));
                    wsprintf(sz, szTemp, dwProgramsRunning);
                    SetStatus(LASS_LoggedOn, sz);
                    ShowStatus(LASS_LoggedOn);
                }
                else
                {
                    LoadStringW(g_plf->GetHInstance(), IDS_USERLOGGEDON, szTemp, ARRAYSIZE(szTemp));
                    SetStatus(LASS_LoggedOn, szTemp);
                }
            }
            else
            {
                // if they are not logged on, clean up the logged on text and remove any padding
                RemoveStatus(LASS_LoggedOn);
            }

            if (fLoggedOn || fCheckEverything)
            {
                varUnreadMail.uintVal = 0;
                if (FAILED(pobjUser->get_setting(L"UnreadMail", &varUnreadMail)))
                {
                    varUnreadMail.uintVal = 0;
                }
                iUnreadMailCount = varUnreadMail.uintVal;

                SetUnreadMail((DWORD)iUnreadMailCount);
                if (iUnreadMailCount != 0)
                {
                    InsertStatus(LASS_Email);

                    LoadStringW(g_plf->GetHInstance(), (iUnreadMailCount == 1 ? IDS_UNREADMAIL : IDS_UNREADMAILS), szTemp, ARRAYSIZE(szTemp));
                    wsprintf(sz, szTemp, iUnreadMailCount);
                    SetStatus(LASS_Email, sz);
                    ShowStatus(LASS_Email);
                }
                else
                {
                    RemoveStatus(LASS_Email);
                }
            }

            pobjUser->Release();
        }
    }
}


#ifdef GADGET_ENABLE_GDIPLUS

void 
LogonAccount::ShowEdit()
{
    HWND hwndEdit = _pePwdEdit->GetHWND();
    HWND hwndHost = ::GetParent(hwndEdit);

    SetWindowPos(hwndHost, NULL, 0, 0, 0, 0, SWP_NOMOVE | SWP_NOSIZE | SWP_NOZORDER | SWP_SHOWWINDOW);
    EnableWindow(hwndEdit, TRUE);
    SetFocus(hwndEdit);
}


void 
LogonAccount::HideEdit()
{
    HWND hwndEdit = _pePwdEdit->GetHWND();
    HWND hwndHost = ::GetParent(hwndEdit);

    EnableWindow(hwndEdit, FALSE);
    SetWindowPos(hwndHost, NULL, 0, 0, 0, 0, SWP_NOMOVE | SWP_NOSIZE | SWP_NOZORDER | SWP_HIDEWINDOW);
}

#endif // GADGET_ENABLE_GDIPLUS


////////////////////////////////////////////////////////
// Property definitions

////////////////////////////////////////////////////////
// ClassInfo (must appear after property definitions)

// LogonState property
static int vvLogonState[] = { DUIV_INT, -1 };
static PropertyInfo impLogonStateProp = { L"LogonState", PF_Normal, 0, vvLogonState, NULL, Value::pvIntZero /*LS_Pending*/ };
PropertyInfo* LogonAccount::LogonStateProp = &impLogonStateProp;

////////////////////////////////////////////////////////
// ClassInfo (must appear after property definitions)

// Class properties
static PropertyInfo* _aPI[] = {
                                LogonAccount::LogonStateProp,
                              };

// Define class info with type and base type, set static class pointer
IClassInfo* LogonAccount::Class = NULL;
HRESULT LogonAccount::Register()
{
    return ClassInfo<LogonAccount,Button>::Register(L"LogonAccount", _aPI, DUIARRAYSIZE(_aPI));
}

////////////////////////////////////////////////////////
// Logon Parser

void CALLBACK LogonParseError(LPCWSTR pszError, LPCWSTR pszToken, int dLine)
{
    WCHAR buf[201];

    if (dLine != -1)
        swprintf(buf, L"%s '%s' at line %d", pszError, pszToken, dLine);
    else
        swprintf(buf, L"%s '%s'", pszError, pszToken);

    MessageBoxW(NULL, buf, L"Parser Message", MB_OK);
}


void DoFadeWindow(HWND hwnd)
{
    HDC hdc;
    int i;
    RECT rcFrame;
    COLORREF rgbFinal = RGB(90,126,220);

    hdc = GetDC(hwnd);
    GetClientRect(hwnd, &rcFrame);

    COLORREF crCurr;
    HBRUSH hbrFill;

    crCurr = RGB(0,0,0);
    // draw the left bar
    for (i = 0; i < 16; i++)
    {
        RECT rcCurrFrame;

        rcCurrFrame = rcFrame;

        crCurr = RGB((GetRValue(rgbFinal) / 16)*i,
                     (GetGValue(rgbFinal) / 16)*i,
                     (GetBValue(rgbFinal) / 16)*i);
        hbrFill = CreateSolidBrush(crCurr);
        if (hbrFill)
        {
            FillRect(hdc, &rcCurrFrame, hbrFill);
            DeleteObject(hbrFill);
        }
        GdiFlush();
    }
    ReleaseDC(hwnd, hdc);
}

////////////////////////////////////////////////////////
// Logon entry point

int WINAPI WinMain(HINSTANCE hInst, HINSTANCE hPrevInstance, LPSTR pCmdLine, int nCmdShow)
{
    UNREFERENCED_PARAMETER(hPrevInstance);
    UNREFERENCED_PARAMETER(pCmdLine);
    UNREFERENCED_PARAMETER(nCmdShow);

    WNDCLASSEX wcx = {0};
    BOOL fStatusLaunch = false;
    BOOL fShutdownLaunch = false;
    BOOL fWait = false;
    CBackgroundWindow   backgroundWindow(hInst);

    ZeroMemory(g_rgH, sizeof(g_rgH));


    SetErrorHandler();
    InitCommonControls();
    // Register logon notification window
    wcx.cbSize = sizeof(WNDCLASSEX);
    wcx.lpfnWndProc = LogonWindowProc;
    wcx.hInstance = GetModuleHandleW(NULL);
    wcx.hbrBackground = (HBRUSH)GetStockObject(WHITE_BRUSH);
    wcx.lpszClassName = TEXT("LogonWnd");
    wcx.hCursor = LoadCursor(NULL, IDC_ARROW);
    RegisterClassEx(&wcx);

    fStatusLaunch = (StrStrIA(pCmdLine, "/status") != NULL);
    fShutdownLaunch = (StrStrIA(pCmdLine, "/shutdown") != NULL);
    fWait = (StrStrIA(pCmdLine, "/wait") != NULL);
    g_fNoAnimations = (StrStrIA(pCmdLine, "/noanim") != NULL);

    // Create frame
    Parser* pParser = NULL;
    NativeHWNDHost* pnhh = NULL;

    // DirectUI init process
    if (FAILED(InitProcess()))
        goto Failure;

    // Register classes
    if (FAILED(LogonFrame::Register()))
        goto Failure;

    if (FAILED(LogonAccountList::Register()))
        goto Failure;

    if (FAILED(LogonAccount::Register()))
        goto Failure;

    // DirectUI init thread
    if (FAILED(InitThread()))
        goto Failure;

    if (FAILED(CoInitialize(NULL)))
        goto Failure;

#ifdef GADGET_ENABLE_GDIPLUS
    if (FAILED(FxInitGuts()))
        goto Failure;
#endif    

#ifndef DEBUG
    if (!RunningUnderWinlogon())
        goto Failure;
#endif

    DisableAnimations();

    // Create host
    HMONITOR hMonitor;
    POINT pt;
    MONITORINFO monitorInfo;

    // Determine initial size of the host. This is desired to be the entire
    // primary monitor resolution because the host always runs on the secure
    // desktop. If magnifier is brought up it will call SHAppBarMessage which
    // will change the work area and we will respond to it appropriately from
    // the listener in shgina that sends us HM_DISPLAYRESIZE messages.

    pt.x = pt.y = 0;
    hMonitor = MonitorFromPoint(pt, MONITOR_DEFAULTTOPRIMARY);
    DUIAssert(hMonitor != NULL, "NULL HMONITOR returned from MonitorFromPoint");
    monitorInfo.cbSize = sizeof(monitorInfo);
    if (GetMonitorInfo(hMonitor, &monitorInfo) == FALSE)
    {
        SystemParametersInfo(SPI_GETWORKAREA, 0, &monitorInfo.rcMonitor, 0);
    }
    NativeHWNDHost::Create(L"Windows Logon", backgroundWindow.Create(), NULL, monitorInfo.rcMonitor.left, monitorInfo.rcMonitor.top, 
        monitorInfo.rcMonitor.right - monitorInfo.rcMonitor.left, monitorInfo.rcMonitor.bottom - monitorInfo.rcMonitor.top, 0, WS_POPUP, NHHO_IgnoreClose, &pnhh);
//    NativeHWNDHost::Create(L"Windows Logon", NULL, NULL, monitorInfo.rcMonitor.left, monitorInfo.rcMonitor.top, 
//        800, 600, 0, WS_POPUP, NHHO_IgnoreClose, &pnhh);
    if (!pnhh)
        goto Failure;

    // Populate handle list for theme style parsing
    g_rgH[0] = hInst; // Default HINSTANCE
    g_rgH[SCROLLBARHTHEME] = OpenThemeData(pnhh->GetHWND(), L"Scrollbar");

    // Frame creation
    Parser::Create(IDR_LOGONUI, g_rgH, LogonParseError, &pParser);
    if (!pParser)
        goto Failure;

    if (!pParser->WasParseError())
    {
        Element::StartDefer();

        // Always double buffer
        LogonFrame::Create(pnhh->GetHWND(), true, 0, (Element**)&g_plf);
        if (!g_plf)
        {
            Element::EndDefer();
            goto Failure;
        }
        
        g_plf->SetNativeHost(pnhh);
        
        Element* pe;
        pParser->CreateElement(L"main", g_plf, &pe);

        if (pe) // Fill contents using substitution
        {
            // Frame tree is built
            if (FAILED(g_plf->OnTreeReady(pParser)))
            {
                Element::EndDefer();
                goto Failure;
            }
            
            if (fShutdownLaunch || fWait)
            {
                g_plf->SetTitle(IDS_PLEASEWAIT);
            }

            if (!fStatusLaunch)
            {
                // Build contents of account list
                g_plf->EnterLogonMode(false);
            }
            else
            {   
               g_plf->EnterPreStatusMode(false);
            }

            // Host
            pnhh->Host(g_plf);
            
            g_plf->SetButtonLabels();

            Element *peLogoArea = g_plf->FindDescendent(StrToID(L"product"));

            if (!g_fNoAnimations)
            {
                pnhh->ShowWindow();
                DoFadeWindow(pnhh->GetHWND());
                if (peLogoArea)
                {
                    peLogoArea->SetAlpha(0);  
                }
            }

            // Set visible and focus
            g_plf->SetVisible(true);
            g_plf->SetKeyFocus();
            
            
            Element::EndDefer();

            // Do initial show
            pnhh->ShowWindow();

            if (!g_fNoAnimations)
            {
                EnableAnimations();
            }

            if (peLogoArea)
            {
                peLogoArea->SetAlpha(255);  
            }

            StartMessagePump();

            // psf will be deleted by native HWND host when destroyed
        }
        else
            Element::EndDefer();
    }

Failure:

    if (pnhh)
        pnhh->Destroy();
    if (pParser)
        pParser->Destroy();

    ReleaseStatusHost();
    
    FreeLayoutInfo(LAYOUT_DEF_USER);

    if (g_rgH[SCROLLBARHTHEME])  // Scrollbar
    {
        CloseThemeData(g_rgH[SCROLLBARHTHEME]);
    }

    CoUninitialize();

    UnInitThread();

    UnInitProcess();

    // Free cached atom list
    if (LogonAccount::idPwdGo)
        DeleteAtom(LogonAccount::idPwdGo);

    if (LogonAccount::idPwdInfo)
        DeleteAtom(LogonAccount::idPwdInfo);


    EndHostProcess(0);

    return 0;
}


void LogonAccount::SetKeyboardIcon(HICON hIcon)
{
    HICON hIconCopy = NULL;
    
    if (hIcon)
    {
        hIconCopy = CopyIcon(hIcon);
    }
    
    if (_peKbdIcon && hIconCopy) 
    {
        Value* pvIcon = Value::CreateGraphic(hIconCopy);
        _peKbdIcon->SetValue(Element::ContentProp, PI_Local, pvIcon);  // Element takes owners
        _peKbdIcon->SetPadding(0, 5, 0, 7);
        pvIcon->Release();  
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\logondui\priv.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1993 - 1998.
//
//  File:       priv.h
//
//  Contents:   precompiled header for shgina.dll
//
//----------------------------------------------------------------------------
#ifndef _PRIV_H_
#define _PRIV_H_

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>

#include <windows.h>

#include <process.h>
#include <malloc.h>

#include <uxtheme.h>

// DirectUser and DirectUI
#include <wchar.h>

#ifdef GADGET_ENABLE_GDIPLUS
#include <objbase.h>            // CoCreateInstance, IUnknown
#pragma warning(push, 3)
#include <GdiPlus.h>            // GDI+
#pragma warning(pop)
#endif

#define GADGET_ENABLE_TRANSITIONS
#define GADGET_ENABLE_CONTROLS
#include <duser.h>
#include <directui.h>

#include <debug.h>

#include <ccstock.h>
#include <shlguid.h>
#include <shlobj.h>
#include <shlobjp.h>

#include <shlwapi.h>    // these are needed
#include <shlwapip.h>   // for QISearch

#include <shgina.h>     // our IDL generated header file

#include <lmcons.h>     // for NET_API_STATUS
#include <lmaccess.h>   // for DetermineGuestAccountName
#include <lmapibuf.h>   // for NetApiBufferFree

// Work-around to get GIDL compiling
#undef ASSERT
#define ASSERT(f)   ((void)0)

#endif // _PRIV_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\logondui\logon.h ===
// logon.h
//

#if !defined(LOGON__Logon_h__INCLUDED)
#define LOGON__Logon_h__INCLUDED
#pragma once

//#define ANIMATE_FLAG

// Forward declarations
class LogonAccount;
#ifdef GADGET_ENABLE_GDIPLUS
enum EFadeDirection;
#endif

#define MAX_FLAG_FRAMES 1
#define FLAG_ANIMATION_COUNT 1

class LogonFrame: public HWNDElement, public IElementListener
{
public:
    static HRESULT Create(OUT Element** ppElement);  // Required for ClassInfo (always fails)
    static HRESULT Create(HWND hParent, BOOL fDblBuffer, UINT nCreate, OUT Element** ppElement);

    // Generic events
    virtual void OnEvent(Event* pEvent);

    // System events
    virtual void OnInput(InputEvent* pEvent);
    virtual void OnPropertyChanged(PropertyInfo* ppi, int iIndex, Value* pvOld, Value* pvNew);

    virtual Element* GetAdjacent(Element* peFrom, int iNavDir, NavReference const* pnr, bool bKeyable);

    // Frame Callbacks
    HRESULT OnLogUserOn(LogonAccount* pla);
    HRESULT OnPower();
    HRESULT OnUndock();
    HRESULT OnTreeReady(Parser* pParser);

    // Listener impl
    virtual void OnListenerAttach(Element* peFrom) { peFrom; }
    virtual void OnListenerDetach(Element* peFrom) { peFrom; }
    virtual bool OnListenedPropertyChanging(Element* peFrom, PropertyInfo* ppi, int iIndex, Value* pvOld, Value* pvNew) { peFrom; ppi; iIndex; pvOld; pvNew; return true; }
    virtual void OnListenedPropertyChanged(Element* peFrom, PropertyInfo* ppi, int iIndex, Value* pvOld, Value* pvNew);
    virtual void OnListenedInput(Element* peFrom, InputEvent* pInput) { peFrom; pInput; }
    virtual void OnListenedEvent(Element* peFrom, Event* pEvent) { peFrom; pEvent; }

    // Operations
    static int PointToPixel(int nPoint) { return MulDiv(nPoint, _nDPI, 72); }
    HINSTANCE GetHInstance() { return _pParser->GetHInstance(); }
    void HideAccountPanel() { _peRightPanel->SetLayoutPos(LP_None); _peLeftPanel->RemoveLocalValue(WidthProp);}
    void ShowAccountPanel() { _peRightPanel->SetLayoutPos(BLP_Left); _peLeftPanel->SetWidth(380);}
    void HideLogoArea() { _peLogoArea->SetLayoutPos(LP_None); }
    void ShowLogoArea() { _peLogoArea->SetLayoutPos(BLP_Client); }
    void HideWelcomeArea() { _peMsgArea->SetLayoutPos(LP_None); }
    void ShowWelcomeArea() { _peMsgArea->SetLayoutPos(BLP_Client); }
    void HidePowerButton() { _pbPower->SetVisible(false); }
    void ShowPowerButton() { _pbPower->SetVisible(true); }
    void SetPowerButtonLabel(LPCWSTR psz) { Element* pe = _pbPower->FindDescendent(StrToID(L"label")); if (pe) pe->SetContentString(psz); }
    void InsertUndockButton() { _pbUndock->SetLayoutPos(BLP_Top); }
    void RemoveUndockButton() { _pbUndock->SetLayoutPos(LP_None); }
    void HideUndockButton() { _pbUndock->SetVisible(false); }
    void ShowUndockButton() { _pbUndock->SetVisible(true); }
    void SetUndockButtonLabel(LPCWSTR psz) { Element* pe = _pbUndock->FindDescendent(StrToID(L"label")); if (pe) pe->SetContentString(psz); }
    void SetStatus(LPCWSTR psz) { if (psz){ _peHelp->SetContentString(psz);}}
    void SetTitle(UINT uRCID);
    void SetTitle(LPCWSTR pszTitle);
    void SetButtonLabels();
    HRESULT AddAccount(LPCWSTR pszPicture, BOOL fPicRes, LPCWSTR pszName, LPCWSTR pszUsername, LPCWSTR pszHint, BOOL fLoggedOn, OUT LogonAccount **ppla);
    NativeHWNDHost* GetNativeHost() {return _pnhh;}
    void SetNativeHost(NativeHWNDHost *pnhh) {_pnhh = pnhh;}
    void UpdateUserStatus(BOOL fRefreshAll = false);
    LogonAccount* FindNamedUser(LPCWSTR pszUsername);
    void SelectUser(LPCWSTR pszUsername);
    void ResetUserList();
    void Resize();
    void SetAnimations(BOOL fAnimations);
    
    void ResetTheme();

    BOOL UserListAvailable() {return _fListAvailable;}
    void SetUserListAvailable(BOOL fListAvailable) {_fListAvailable = fListAvailable;}
    // ClassInfo accessors (static and virtual instance-based)
    static IClassInfo* Class;
    virtual IClassInfo* GetClassInfo() { return Class; }
    static HRESULT Register();

    // state management
    void SetState(UINT uNewState) {_nAppState = uNewState;}
    UINT GetState() {return _nAppState;}
    BOOL IsPreStatusLock() {return _fPreStatusLock;}
    
    void EnterPreStatusMode(BOOL fLock);
    void EnterLogonMode(BOOL fUnLock);    
    void EnterPostStatusMode();
    void EnterHideMode();
    void EnterDoneMode();
    LRESULT InteractiveLogonRequest(LPCWSTR pszUsername, LPCWSTR pszPassword);
    void NextFlagAnimate(DWORD dwFrame);

#ifdef GADGET_ENABLE_GDIPLUS
    // Animations / Effects
    HRESULT FxStartup();
#endif

    LogonFrame() { }
    virtual ~LogonFrame();
    HRESULT Initialize(HWND hParent, BOOL fDblBuffer, UINT nCreate);

#ifdef GADGET_ENABLE_GDIPLUS
    // Animations / Effects
    HRESULT FxFadeAccounts(EFadeDirection dir, float flCommonDelay = 0.0f);
    HRESULT FxLogUserOn(LogonAccount * pla);
    static void CALLBACK OnLoginCenterStage(GMA_ACTIONINFO * pmai);
#endif    
    
    // References to key descendents
    Selector* _peAccountList;
    ScrollViewer* _peViewer;
    Element* _peRightPanel;
    Element* _peLeftPanel;
    Button* _pbPower;
    Button* _pbUndock;
    Element* _peHelp;
    Element* _peOptions;
    Element* _peMsgArea;
    Element* _peLogoArea;
   
private:
    LogonAccount* InternalFindNamedUser(LPCWSTR pszUsername);

    static int _nDPI;
    Parser* _pParser;

    BOOL _fListAvailable;
    BOOL _fPreStatusLock;
    HWND _hwndNotification;
    UINT _nStatusID;
    UINT _nAppState;
    NativeHWNDHost *_pnhh;
    Value* _pvHotList;
    Value* _pvList;
    HDC _hdcAnimation;
    HBITMAP _hbmpFlags;
    DWORD _dwFlagFrame;
    UINT _nColorDepth;
};


class LogonAccountList: public Selector
{
public:
    static HRESULT Create(OUT Element** ppElement);  // Required for ClassInfo

    // System events
    virtual void OnPropertyChanged(PropertyInfo* ppi, int iIndex, Value* pvOld, Value* pvNew);

    // ClassInfo accessors (static and virtual instance-based)
    static IClassInfo* Class;
    virtual IClassInfo* GetClassInfo() { return Class; }
    static HRESULT Register();

    LogonAccountList() { }
    virtual ~LogonAccountList() { }
    HRESULT Initialize() { return Selector::Initialize(); }

#ifdef GADGET_ENABLE_GDIPLUS
    // Animations / Effects
    HRESULT FxMouseWithin(EFadeDirection dir);
#endif
};


// LogonState property enum
#define LS_Pending      0
#define LS_Granted      1
#define LS_Denied       2

#define LAS_Initialized 0
#define LAS_PreStatus   1
#define LAS_Logon       2
#define LAS_PostStatus  3
#define LAS_Hide        4
#define LAS_Done        5

#define LASS_Email    0
#define LASS_LoggedOn 1

class LogonAccount: public Button
{
public:
    static HRESULT Create(OUT Element** ppElement);  // Required for ClassInfo

    // Generic events
    virtual void OnEvent(Event* pEvent);

    // System events
    virtual void OnInput(InputEvent* pEvent);
    virtual void OnPropertyChanged(PropertyInfo* ppi, int iIndex, Value* pvOld, Value* pvNew);

    // Account Callbacks
    void OnAuthenticatedUser();
    BOOL OnAuthenticateUser(LPCWSTR pszInPassword = NULL);
    void OnHintSelect();
    void OnStatusSelect(UINT nLine);
    HRESULT OnTreeReady(LPCWSTR pszPicture, BOOL fPicRes, LPCWSTR pszName, LPCWSTR pszUsername, LPCWSTR pszHint, BOOL fLoggedOn, HINSTANCE hInst);

    // Operations
    static void InitPasswordPanel(Element* pePwdPanel, Edit* pePwdEdit, Button* pbPwdInfo, Element* peKbdIcon) { _pePwdPanel = pePwdPanel; _pePwdEdit = pePwdEdit; _pbPwdInfo = pbPwdInfo; _peKbdIcon = peKbdIcon;}
    HRESULT InsertPasswordPanel();
    HRESULT RemovePasswordPanel();
    void InsertStatus(UINT nLine) { _pbStatus[nLine]->SetLayoutPos(BLP_Top); }
    void RemoveStatus(UINT nLine) { _pbStatus[nLine]->SetLayoutPos(LP_None); }
    void HideStatus(UINT nLine) { _pbStatus[nLine]->SetVisible(false); }
    void ShowStatus(UINT nLine) { _pbStatus[nLine]->SetVisible(true); }
	void SetStatus(UINT nLine, LPCWSTR psz);
    void DisableStatus(UINT nLine) { _pbStatus[nLine]->SetEnabled(false); }
    void ShowPasswordIncorrectMessage();
    void UpdateNotifications(BOOL fUpdateEverything);
    void AppRunningTip();
    void UnreadMailTip();
    BOOL IsPasswordBlank();

#ifdef GADGET_ENABLE_GDIPLUS
    void ShowEdit();
    void HideEdit();
#endif    

    
    // Cached atoms for quicker identification
    static ATOM idPwdGo;
    static ATOM idPwdInfo;

    // Property definitions
    static PropertyInfo* LogonStateProp;

    // Quick property accessors
    int     GetLogonState()           DUIQuickGetter(int, GetInt(), LogonState, Specified)
    HRESULT SetLogonState(int v)  DUIQuickSetter(CreateInt(v), LogonState)
    void    SetRunningApps(DWORD dwRunningApps) {_dwRunningApps = dwRunningApps;}
    void    SetUnreadMail(DWORD dwUnreadMail) {_dwUnreadMail = dwUnreadMail;}
    LPCWSTR GetUsername() {return _pvUsername->GetString();}
    static  LogonAccount* GetCandidate() { return _peCandidate; }
    static  void ClearCandidate() { _peCandidate = NULL; }
    static  void SetKeyboardIcon(HICON hIcon);
    // ClassInfo accessors (static and virtual instance-based)
    static IClassInfo* Class;
    virtual IClassInfo* GetClassInfo() { return Class; }
    static HRESULT Register();

#ifdef GADGET_ENABLE_GDIPLUS
    // Animations / Effects
    HRESULT FxLogUserOn();
#endif

    LogonAccount() { }
    virtual ~LogonAccount();
    HRESULT Initialize();

#ifdef GADGET_ENABLE_GDIPLUS
    // Animations / Effects
    HRESULT FxMouseWithin(EFadeDirection dir);
#endif

    // References to key descendents
    Button* _pbStatus[2];

    static Element* _pePwdPanel;
    static Edit* _pePwdEdit;
    static Button* _pbPwdInfo;
    static Element* _peKbdIcon;
    static LogonAccount* _peCandidate;
    
    Value* _pvUsername;
    Value* _pvHint;
    BOOL _fPwdNeeded;
    BOOL _fLoggedOn;
    BOOL _fHasPwdPanel;
    DWORD _dwUnreadMail;
    DWORD _dwRunningApps;
    
};

void CALLBACK LogonParseError(LPCWSTR pszError, LPCWSTR pszToken, int dLine);

#endif // LOGON__Logon_h__INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\logondui\resource.h ===
//
// Used by logon.rc
//

#define IDS_WELCOMEFONT         1
#define IDS_OPTIONSFONT         2
#define IDS_ACCOUNTLISTFONT     3

#define IDS_TYPEPASSWORD        6
#define IDS_WELCOME             7
#define IDS_BADPWD               8
#define IDS_BADPWDHINT           9
#define IDS_BADPWDTITLE         10
#define IDS_POWER               11
#define IDS_POWERNAME           12
#define IDS_PASSWORDHINTTITLE   13
#define IDS_UNDOCK              14
#define IDS_USERLOGGEDON        15
#define IDS_LOGGEDON            16
#define IDS_UNDOCKNAME          17
#define IDS_BADPWDREST               18
#define IDS_BADPWDHINTREST           19

#define IDS_BEGIN               22
#define IDS_MANAGEACCOUNTS      25
#define IDS_LOGGINGON           26
#define IDS_UNREADMAIL          27
#define IDS_UNREADMAILS         28
#define IDS_RUNNINGPROGRAM      29
#define IDS_RUNNINGPROGRAMS     30
#define IDS_PLEASEWAIT          31
#define IDS_USERRUNNINGPROGRAM  32
#define IDS_USERRUNNINGPROGRAMS 33
#define IDS_TOOMANYPROGRAMS     34
#define IDS_USERUNREADEMAIL     35
#define IDS_USERUNREADEMAILS    36
#define IDS_UNREADMAILTEMP      37
#define IDS_USERISLOGGEDON      38
#define IDS_TOOMANYUSERS        39
#define IDS_UNREADMAILACCOUNT   40
#define IDS_WINDOWSNAME         41
#define IDS_TURNOFFFONTSIZE     42
#define IDS_INSTRUCTFONTSIZE    43
#define IDS_WELCOMEFONTSIZE     44
#define IDS_HELPFONTSIZE        45
#define IDS_STATUSFONTSIZE      46
#define IDS_PWINSTRUCTFONTSIZE  47
#define IDS_HELPFONT            48
#define IDS_ACDSC_PWD           100

#define IDB_BACKGROUND          100
#define IDB_EDITFRAME           102
#define IDB_GO                  103
#define IDB_GOKF                104
#define IDB_INFO                105
#define IDB_INFOKF              106
#define IDB_POWER               107
#define IDB_UNDOCK              108
#define IDB_SBLINEDOWNV         109
#define IDB_SBLINEUPV           110
#define IDB_SBTHUMBV            111
#define IDB_SELECTION           112
#define IDB_USERFRAME           113
#define IDB_USER0               114
#define IDB_USERFRAMESEL        119
#ifdef DEBUG
#define IDB_USER1               115
#define IDB_USER2               116
#define IDB_USER3               117
#define IDB_USER4               118
#endif
#define IDB_SPOTLIGHT           120
#define IDB_POWERKF             121
#define IDB_UNDOCKKF            122
#define IDB_PRODUCTNAME         123
#define IDB_VDIVIDER            124
#define IDB_HDIVIDERTOP         125
#define IDB_HDIVIDERBOT         126
#define IDB_FLAGSTRIP           127

#define IDR_LOGONUI            1000

// hTheme identification from within the resource
#define SCROLLBARHTHEME           1
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\media\basemediaps.cpp ===
#include "pch.h"
#include "thisdll.h"
#include "wmwrap.h"
#include "MediaProp.h"
#include "ids.h"

#include <streams.h>

#include <drmexternals.h>

#define IsEqualSCID(a, b)   (((a).pid == (b).pid) && IsEqualIID((a).fmtid, (b).fmtid) )




class CMediaPropStgEnum : public IEnumSTATPROPSTG
{
public:
    CMediaPropStgEnum(const COLMAP **pprops, ULONG cprop, ULONG pos);

    // IUnknown
    STDMETHODIMP QueryInterface(REFIID riid, void **ppv);
    STDMETHODIMP_(ULONG) AddRef();
    STDMETHODIMP_(ULONG) Release();

    // IEnumSTATPROPSTG
    STDMETHODIMP Next(ULONG celt, STATPROPSTG *rgelt, ULONG *pceltFetched);
    STDMETHODIMP Skip(ULONG celt);
    STDMETHODIMP Reset();
    STDMETHODIMP Clone(IEnumSTATPROPSTG **ppenum);

    STDMETHODIMP Init(BOOL *pbAvailable);

protected:
    ~CMediaPropStgEnum();

private:

    LONG _cRef;
    ULONG _pos, _size;
    const COLMAP **_pprops;
    BOOL *_pbAvailable;
};

/*
The way this works:

The PropSetStg has a fixed set of PropStorages. When it gets created, 
it makes an authoritative PropStg for each fmtid. Thereafter, it defers 
Open() requests to the appropriate PropStg.

This PropStg then marks itself opened and makes a copy of itself 
(marked NON_AUTH) which can be abused as the caller sees fit. 
The copy will call the original when it's time to commit and will also 
notify the original when it is closed.

The current implementation requires that STGM_SHARE_EXCLUSIVE be specified 
when opening a propstg.

If you plan on creating this class yourself (which you probably shouldn't),
you must also call Init() first and confirm that it succeeds.
*/




STDMETHODIMP_(ULONG) CMediaPropStgEnum::AddRef()
{
    return InterlockedIncrement(&_cRef);
}

STDMETHODIMP_(ULONG) CMediaPropStgEnum::Release()
{
    ASSERT( 0 != _cRef );
    ULONG cRef = InterlockedDecrement(&_cRef);
    if ( 0 == cRef )
    {
        delete this;
    }
    return cRef;
}

STDMETHODIMP CMediaPropStgEnum::QueryInterface(REFIID riid, void **ppv)
{
    static const QITAB qit[] = {
        QITABENT(CMediaPropStgEnum, IEnumSTATPROPSTG),
        { 0 },
    };
    return QISearch(this, qit, riid, ppv);
}

// IEnum
STDMETHODIMP CMediaPropStgEnum::Next(ULONG celt, STATPROPSTG *rgelt, ULONG *pceltFetched)
{
    ULONG cFetched = 0;

    // While there is still room for more in rgelt, and we haven't exhausted our supply...
    while ((cFetched < celt) && (_pos < _size))
    {
        // Don't enumerate VT_EMPTY values.
        // e.g. if track# doesn't exist for this storage, don't enum it. (_pbAvailable).
        // Also don't enumerate aliased properties (.bEnumerate)
        if (_pbAvailable[_pos]  &&  _pprops[_pos]->bEnumerate)
        {
            ZeroMemory(&rgelt[cFetched], sizeof(STATPROPSTG));
            rgelt[cFetched].lpwstrName = NULL;
            rgelt[cFetched].propid     = _pprops[_pos]->pscid->pid; 
            rgelt[cFetched].vt         = _pprops[_pos]->vt;
            cFetched++;
        }

        _pos++; // increment our position in our internal list of properties.
    }

    if (pceltFetched)
        *pceltFetched = cFetched;
    
    return cFetched == celt ? S_OK : S_FALSE;
}

STDMETHODIMP CMediaPropStgEnum::Skip(ULONG celt)
{
    HRESULT hr;
    
    if (_pos + celt > _size)
    {
        hr = S_FALSE;
        _pos = _size;
    }
    else
    {
        hr = S_OK;
        _pos += celt;
    }
    return hr;
}

STDMETHODIMP CMediaPropStgEnum::Reset()
{
    _pos = 0;
    return S_OK;
}

STDMETHODIMP CMediaPropStgEnum::Clone(IEnumSTATPROPSTG **ppenum)
{
    HRESULT hr = STG_E_INSUFFICIENTMEMORY;

    CMediaPropStgEnum *penum = new CMediaPropStgEnum(_pprops, _size, _pos);
    if (penum)
    {
        hr = penum->Init(_pbAvailable);
        if (SUCCEEDED(hr))
        {
            hr = penum->QueryInterface(IID_PPV_ARG(IEnumSTATPROPSTG, ppenum));
        }

        penum->Release();
    }

    return hr;
}

// pbAvailable array must be of size _size.
STDMETHODIMP CMediaPropStgEnum::Init(BOOL *pbAvailable)
{
    HRESULT hr = E_FAIL;
    if (pbAvailable)
    {
        _pbAvailable = (BOOL*)CoTaskMemAlloc(sizeof(BOOL) * _size);
        if (_pbAvailable)
        {
            // Copy the values.
            CopyMemory(_pbAvailable, pbAvailable, sizeof(BOOL) * _size);
            hr = S_OK;
        }
        else
        {
            hr = STG_E_INSUFFICIENTMEMORY;
        }
    }

    return hr;
}

CMediaPropStgEnum::CMediaPropStgEnum(const COLMAP **pprops, ULONG cprops, ULONG pos) :
    _cRef(1), _pprops(pprops), _size(cprops), _pos(pos)
{
    DllAddRef();
}

CMediaPropStgEnum::~CMediaPropStgEnum()
{
    if (_pbAvailable)
    {
        CoTaskMemFree(_pbAvailable);
    }

    DllRelease();
}

//
// CMediaPropStg methods
//

// IUnknown
STDMETHODIMP CMediaPropStorage::QueryInterface(REFIID riid, void **ppv)
{
    static const QITAB qit[] = {
        QITABENT(CMediaPropStorage, IPropertyStorage), 
        QITABENT(CMediaPropStorage, IQueryPropertyFlags), 
        { 0 },
    };
    return QISearch(this, qit, riid, ppv);
}

STDMETHODIMP_(ULONG) CMediaPropStorage::AddRef()
{
    return InterlockedIncrement(&_cRef);
}

STDMETHODIMP_(ULONG) CMediaPropStorage::Release()
{
    ASSERT( 0 != _cRef );
    ULONG cRef = InterlockedDecrement(&_cRef);
    if ( 0 == cRef )
    {
        delete this;
    }
    return cRef;
}



//IPropertyStorage
STDMETHODIMP CMediaPropStorage::ReadMultiple(ULONG cpspec, const PROPSPEC rgpspec[], PROPVARIANT rgvar[])
{
    EnterCriticalSection(_pcs);

    const COLMAP *pcmap;
    PROPVARIANT *pvar;
    LONG celt = 0;
    for (ULONG i = 0; i < cpspec; i++)
    {
        if (SUCCEEDED(LookupProp(&rgpspec[i], &pcmap, &pvar, NULL, NULL, FALSE)) && pvar->vt != VT_EMPTY)
        {
            celt++;

            // This copy can only fail for a bad type in pvar, but the results we get from LookupProp
            // should always be valid variants.
            PropVariantCopy(&rgvar[i], pvar);
        }
        else
        {
            PropVariantInit(&rgvar[i]);
        }
    }

    LeaveCriticalSection(_pcs);

    return celt ? S_OK : S_FALSE;
}

/**
 * Provide some more suitable errors, so docprop can tell the user what happened.
 */
HRESULT _WMToStgWriteErrorCode(HRESULT hrIn)
{
    HRESULT hr;

    switch (hrIn)
    {
    case NS_E_FILE_WRITE:
        // Probably because of a lock violation.
        // Ideally the WMSDK would pass back a more descriptive error.
        hr = STG_E_LOCKVIOLATION;
        break;

    default:
        hr = STG_E_WRITEFAULT;
    }

    return hr;
}

STDMETHODIMP CMediaPropStorage::WriteMultiple(ULONG cpspec, PROPSPEC const rgpspec[], const PROPVARIANT rgvar[], PROPID propidNameFirst)
{
    const COLMAP *pcmap;
    PROPVARIANT *pvar, *pvarWrite;
    BOOL *pbDirty;
    ULONG celt = 0;
    
    EnterCriticalSection(_pcs);

    // fail if we're readonly
    HRESULT hr = STG_E_ACCESSDENIED;
    if (_dwMode & (STGM_WRITE | STGM_READWRITE))
    {
        hr = S_OK;
    
        for (ULONG i = 0; i < cpspec; i++)
        {
            if (!IsSpecialProperty(&rgpspec[i]) && SUCCEEDED(LookupProp(&rgpspec[i], &pcmap, &pvar, &pvarWrite, &pbDirty, FALSE)))
            {
                if (SUCCEEDED(PropVariantCopy(pvarWrite, &rgvar[i]))) // Could fail if we're given bad propvariant
                {
                    celt++;
                    *pbDirty = TRUE;
                }
            }
        }

        if (IsDirectMode() && celt)
        {
            hr = DoCommit(STGC_OVERWRITE, &_ftLastCommit, _pvarProps, _pbDirtyFlags);
            if (FAILED(hr))
            {
                //
                _ppsAuthority->CopyPropStorageData(_pvarProps);
                for (ULONG i=0; i<_cNumProps; i++)
                {
                    _pbDirtyFlags[i]=FALSE;
                }
                hr = _WMToStgWriteErrorCode(hr);
            }
        }

        if (SUCCEEDED(hr))
        {
            hr = (celt == cpspec) ? S_OK : S_FALSE;
        }
    }

    LeaveCriticalSection(_pcs);

    return hr;
}

STDMETHODIMP CMediaPropStorage::DeleteMultiple(ULONG cpspec, PROPSPEC const rgpspec[])
{
    const COLMAP *pcmap;
    PROPVARIANT *pvar, *pvarWrite;
    BOOL *pbDirty;
    ULONG celt = 0;

    EnterCriticalSection(_pcs);

    for (ULONG i = 0; i < cpspec; i++)
    {
        if (!IsSpecialProperty(&rgpspec[i]) && SUCCEEDED(LookupProp(&rgpspec[i], &pcmap, &pvar, &pvarWrite, &pbDirty, FALSE)))
        {
            celt++;
            *pbDirty = TRUE;
            PropVariantInit(pvarWrite);
        }
    }
    if (IsDirectMode() && celt)
    {
        DoCommit(STGC_OVERWRITE, &_ftLastCommit, _pvarProps, _pbDirtyFlags);
    }

    LeaveCriticalSection(_pcs);

    return celt == cpspec? S_OK : S_FALSE;
}

STDMETHODIMP CMediaPropStorage::ReadPropertyNames(ULONG cpspec, PROPID const rgpropid[], LPWSTR rglpwstrName[])
{
    ULONG celt = 0;
    PROPSPEC spec;

    EnterCriticalSection(_pcs);

    spec.ulKind = PRSPEC_PROPID;
    for (ULONG i = 0; i < cpspec; i++)
    {
        rglpwstrName[i] = NULL;
        spec.propid = rgpropid[i];
        PROPVARIANT *pvar;
        const COLMAP *pcmap;
        if (SUCCEEDED(LookupProp(&spec, &pcmap, &pvar, NULL, NULL, FALSE)))
        {
            if (pcmap && SUCCEEDED(SHStrDup(pcmap->pszName, &rglpwstrName[i])))
            {
                celt++;
            }
        }
    }

    LeaveCriticalSection(_pcs);

    return celt ? S_OK : S_FALSE;
}

STDMETHODIMP CMediaPropStorage::WritePropertyNames(ULONG cpspec, PROPID const rgpropid[], LPWSTR const rglpwstrName[])
{
    return E_NOTIMPL;
}

STDMETHODIMP CMediaPropStorage::DeletePropertyNames(ULONG cpspec, PROPID const rgpropid[])
{
    return E_NOTIMPL;
}

STDMETHODIMP CMediaPropStorage::SetClass(REFCLSID clsid)
{
    return E_NOTIMPL;
}

STDMETHODIMP CMediaPropStorage::Commit(DWORD grfCommitFlags)
{
    HRESULT hr = S_OK;

    EnterCriticalSection(_pcs);

    if (!IsDirectMode())
    {
        
        hr = DoCommit(grfCommitFlags, &_ftLastCommit, _pvarChangedProps, _pbDirtyFlags);
        if (SUCCEEDED(hr))
        {
            for (ULONG i = 0;i < _cNumProps; i++)
            {
                if (_pbDirtyFlags[i])
                {
                    _pbDirtyFlags[i] = FALSE;
                    PropVariantCopy(&_pvarProps[i], &_pvarChangedProps[i]);
                }
            }
        }
    }

    LeaveCriticalSection(_pcs);

    return hr;
}

STDMETHODIMP CMediaPropStorage::Revert()
{
    EnterCriticalSection(_pcs);

    if (!IsDirectMode())
    {
        for (ULONG i = 0; i < _cNumProps; i++)
        {
            if (_pbDirtyFlags[i])
            {
                _pbDirtyFlags[i] = FALSE;

                // Should never fail, _pvarProps[i] always has valid type
                PropVariantCopy(&_pvarChangedProps[i], &_pvarProps[i]);
            }
        }
    }

    LeaveCriticalSection(_pcs);

    return S_OK;
}

STDMETHODIMP CMediaPropStorage::Enum(IEnumSTATPROPSTG **ppenum)
{
    EnterCriticalSection(_pcs);

    HRESULT hr = S_OK;
    if (_csEnumFlags & SHCOLSTATE_SLOW)
    {
        // Ensure slow properties have been extracted, since we won't know whether to enumerate
        // them if their values are still VT_EMPTY;
        hr = _EnsureSlowPropertiesLoaded();
    }

    if (SUCCEEDED(hr))
    {
        // Make the availability array - if a property value is set to VT_EMPTY, we
        // will not enumerate it.
        BOOL *pbAvailable = (BOOL*)CoTaskMemAlloc(sizeof(BOOL) * _cNumProps);
        if (pbAvailable)
        {
            for (UINT i = 0; i < _cNumProps; i++)
            {
                pbAvailable[i] = (_pvarProps[i].vt != VT_EMPTY);
            }

            CMediaPropStgEnum *penum = new CMediaPropStgEnum(_ppcmPropInfo, _cNumProps, 0);
            if (penum)
            {
                hr = penum->Init(pbAvailable);
                if (SUCCEEDED(hr))
                {
                    hr = penum->QueryInterface(IID_PPV_ARG(IEnumSTATPROPSTG, ppenum));
                }

                penum->Release();
            }

            CoTaskMemFree(pbAvailable);
        }
    }

    LeaveCriticalSection(_pcs);

    return hr;
}

STDMETHODIMP CMediaPropStorage::Stat(STATPROPSETSTG *pstatpropstg)
{
    ZeroMemory(pstatpropstg, sizeof(STATPROPSETSTG));
    pstatpropstg->fmtid = _fmtid;
    return S_OK;
}

STDMETHODIMP CMediaPropStorage::SetTimes(FILETIME const *pctime, FILETIME const *patime, FILETIME const *pmtime)
{
    return E_NOTIMPL;
}

// This only returns the SHCOLSTATE_SLOW flag currently.
STDMETHODIMP CMediaPropStorage::GetFlags(const PROPSPEC *pspec, SHCOLSTATEF *pcsFlags)
{
    const COLMAP *pPInfo;
    PROPVARIANT *pvar;
    *pcsFlags = 0;

    EnterCriticalSection(_pcs);

    HRESULT hr = LookupProp(pspec, &pPInfo, &pvar, NULL, NULL, TRUE); // TRUE -> so it doesn't populate slow props
    if (SUCCEEDED(hr) && _IsSlowProperty(pPInfo))
    {
        *pcsFlags |= SHCOLSTATE_SLOW;
    }

    LeaveCriticalSection(_pcs);

    return hr;
}

// Allows the caller to specify which properties get enumerated (e.g. slow ones, or not).
STDMETHODIMP CMediaPropStorage::SetEnumFlags(SHCOLSTATEF csFlags)
{
    _csEnumFlags = csFlags;
    return S_OK;
}

CMediaPropStorage::CMediaPropStorage(CMediaPropSetStg *ppssParent, CMediaPropStorage *ppsAuthority, REFFMTID fmtid, const COLMAP **ppcmPropInfo, DWORD cNumProps, DWORD dwMode, CRITICAL_SECTION *pcs) : 
    _cRef(1), _ppssParent(ppssParent), _ppsAuthority(ppsAuthority), _fmtid(fmtid), _ppcmPropInfo(ppcmPropInfo), _cNumProps(cNumProps), _dwMode(dwMode), _pcs(pcs), _bRetrievedSlowProperties(FALSE), _csEnumFlags(0)
{
    // init our Authority info and column metadata
    _authLevel = ppsAuthority ? NON_AUTH : AUTH;
    if (ppsAuthority)
        _ppsAuthority->AddRef();

    ASSERT ((_ppsAuthority && _authLevel== NON_AUTH) || (_ppsAuthority==NULL && _authLevel== AUTH));

    SYSTEMTIME stime;
    GetSystemTime(&stime);
    SystemTimeToFileTime(&stime, &_ftLastCommit);
    _state = CLOSED;

    PropVariantInit(&_varCodePage);
    _varCodePage.vt = VT_I2;
    _varCodePage.iVal = (SHORT)CP_WINUNICODE;

    // Allocate our Property arrays
    _pvarProps = (PROPVARIANT*)CoTaskMemAlloc(sizeof(*_pvarProps) * _cNumProps);
    if (_pvarProps)
    {
        for (ULONG i = 0; i < _cNumProps; i++)
        {
            PropVariantInit(&_pvarProps[i]);
        }
        if (_ppsAuthority)
            _ppsAuthority->CopyPropStorageData(_pvarProps);

        if (IsDirectMode())
        {
            _pvarChangedProps = NULL;
        }
        else
        {
            _pvarChangedProps = (PROPVARIANT*)CoTaskMemAlloc(sizeof(*_pvarChangedProps) * _cNumProps);
            if (_pvarChangedProps)
            {
                for (ULONG i = 0; i < _cNumProps; i++)
                {
                    PropVariantInit(&_pvarChangedProps[i]);
                }
            }
        }

        _pbDirtyFlags = (BOOL*)CoTaskMemAlloc(sizeof(*_pbDirtyFlags) * _cNumProps);
        if (_pbDirtyFlags)
            ZeroMemory(_pbDirtyFlags, sizeof(*_pbDirtyFlags) * _cNumProps);
    }
    DllAddRef();
}

CMediaPropStorage::~CMediaPropStorage()
{
    ASSERT(_state==CLOSED);
    if (_authLevel == NON_AUTH)
    {
        ASSERT(_ppsAuthority);
        _ppsAuthority->OnClose();
        _ppsAuthority->Release();
    }

    for (ULONG i = 0; i < _cNumProps; i++)
    {
        PropVariantClear(&_pvarProps[i]);
    }
        
    CoTaskMemFree(_pvarProps);
    if (_pvarChangedProps)
    {
        for (ULONG i = 0; i < _cNumProps; i++)
        {
            PropVariantClear(&_pvarChangedProps[i]);
        }
        CoTaskMemFree(_pvarChangedProps);
    }
    CoTaskMemFree(_pbDirtyFlags);
    PropVariantClear(&_varCodePage);
    DllRelease();
}

HRESULT CMediaPropStorage::Open(DWORD dwShareMode, DWORD dwOpenMode, IPropertyStorage **ppPropStg)
{
    // require STGM_SHARE_EXCLUSIVE
    if (!(dwShareMode & STGM_SHARE_EXCLUSIVE))
        return E_FAIL;
        
    HRESULT hr;
    CMediaPropStorage *pps = new CMediaPropStorage(NULL, this, _fmtid, _ppcmPropInfo, _cNumProps, dwOpenMode, _pcs);
    if (pps)
    {
        hr = pps->QueryInterface(IID_PPV_ARG(IPropertyStorage, ppPropStg));
        pps->Release();
        if (SUCCEEDED(hr))
            _state = OPENED_DENYALL;
    }
    else
        hr = STG_E_INSUFFICIENTMEMORY;
    return hr;
}


HRESULT CMediaPropStorage::_EnsureSlowPropertiesLoaded()
{
    if (!_bRetrievedSlowProperties)
    {
        HRESULT hr;

        _bRetrievedSlowProperties = TRUE;
        if (_authLevel == NON_AUTH)
        {
            ASSERT(_ppsAuthority);

            hr = _ppsAuthority->_EnsureSlowPropertiesLoaded();

            if (SUCCEEDED(hr))
            {
                // We have some new values... recopy them.
                hr = _ppsAuthority->CopyPropStorageData(_pvarProps);
            }
        }
        else
        {
            hr = _ppssParent->_PopulateSlowProperties();
        }

        _hrSlowProps = hr;
    }

    return _hrSlowProps;
}


BOOL CMediaPropStorage::_IsSlowProperty(const COLMAP *pPInfo)
{
    if (_authLevel == NON_AUTH)
    {
        ASSERT(_ppsAuthority);

        return (_ppsAuthority->_IsSlowProperty(pPInfo));
    }
    else
    {
        return (_ppssParent->_IsSlowProperty(pPInfo));
    }
}


HRESULT CMediaPropStorage::CopyPropStorageData(PROPVARIANT *pvarProps)
{
    ASSERT(_authLevel == AUTH);
    for (ULONG i = 0; i < _cNumProps; i++)
    {
        // Check for VT_EMPTY, because this may be the second time
        // we're copying properties (because of slow properties)
        if (pvarProps[i].vt == VT_EMPTY)
            PropVariantCopy(&pvarProps[i], &_pvarProps[i]);
    }
    return S_OK;
}

void CMediaPropStorage::OnClose()
{
    ASSERT(_authLevel == AUTH);
    _state = CLOSED;
}

void CMediaPropStorage::_ResetPropStorage()
{
    for (ULONG i = 0; i < _cNumProps; i++)
    {
        PropVariantClear(&_pvarProps[i]);
    }
}

HRESULT CMediaPropStorage::SetProperty(PROPSPEC *ppspec, PROPVARIANT *pvar)
{
    PROPVARIANT *pvarRead, *pvarWrite;
    const COLMAP *pcmap;
    
    if (SUCCEEDED(LookupProp(ppspec, &pcmap, &pvarRead, &pvarWrite, NULL, TRUE)) && pvarWrite)
    {
        return PropVariantCopy(pvarRead, pvar);//We can write to this pointer because we're populating the store with initial data
    }
    return E_FAIL;
}

/**
 * Provides a peek to the current value requested.  Does _not_ triggered a call to PopulateSlowProperties
 * if the property is slow and hasn't been populated.
 */
HRESULT CMediaPropStorage::QuickLookup(PROPSPEC *pspec, PROPVARIANT **ppvar)
{
    const COLMAP *pcmap;
    return LookupProp(pspec, &pcmap, ppvar, NULL, NULL, TRUE);
}

//
// On Success, returns a pointer to the COLMAP struct for this prop and a pointer to the propvariant
// holding the data.
//
// handles special proids and knows about STGM_DIRECT (if in direct mode readdata == writedata)
//
// ppvarWriteData and ppbDirty are optional and may be NULL
// If pspec refers to a special property, then pvarWriteData and ppbDirty are set to null (if they are supplied)
//
HRESULT CMediaPropStorage::LookupProp(const PROPSPEC *pspec, const COLMAP **ppcmName, PROPVARIANT **ppvarReadData, PROPVARIANT **ppvarWriteData, BOOL **ppbDirty, BOOL bPropertySet)
{
    if (IsSpecialProperty(pspec))
    {
        *ppvarReadData = NULL;
        switch (pspec->propid)
        {
        case 0:
            return E_FAIL;//we don't support a dictionary
        case 1:
            //return the codepage property
            *ppvarReadData = &_varCodePage;
            *ppcmName = NULL;
            if (ppvarWriteData)
                *ppvarWriteData = NULL;
            if (ppbDirty)
                *ppbDirty = NULL;
            return S_OK;
        default:
            return E_NOTIMPL;
        }
    }
    
    ULONG iPos = -1;
    switch (pspec->ulKind)
    {
    case PRSPEC_LPWSTR:
        for (ULONG i = 0; i < _cNumProps; i++)
        {
            if (StrCmpW(_ppcmPropInfo[i]->pszName, pspec->lpwstr) == 0)
            {
                iPos = i;
                break;
            }
        }
        break;
    case PRSPEC_PROPID:
        for (i = 0; i < _cNumProps; i++)
        {
            if (_ppcmPropInfo[i]->pscid->pid == pspec->propid)
            {
                iPos = i;
                break;
            }
        }
        break;
    default:
        return E_UNEXPECTED;
    }

    if (iPos == -1)
        return STG_E_INVALIDPARAMETER;// Not found

    *ppcmName = _ppcmPropInfo[iPos];

    HRESULT hr = S_OK;
    // We're checking several things here, before asking to load slow properties:
    // 1) We need to make sure we're not setting a value in our internal list of props - or else we could get in a loop
    // 2) We need to check that slow properties have not yet been retrieved
    // 3) We need to check that the property asked for is slow
    // 4) We need to check that its current value is VT_EMPTY, since it could have been populated with the fast properties
    if (!bPropertySet && !_bRetrievedSlowProperties && _IsSlowProperty(*ppcmName) && (_pvarProps[iPos].vt == VT_EMPTY) )
    {
        hr = _EnsureSlowPropertiesLoaded();
    }

    if (SUCCEEDED(hr))
    {
        if (IsDirectMode())
        {
            *ppvarReadData  = &_pvarProps[iPos];
            if (ppvarWriteData)
                *ppvarWriteData = *ppvarReadData;
        }
        else if (_pbDirtyFlags[iPos])
        {
            *ppvarReadData  = &_pvarChangedProps[iPos];
            if (ppvarWriteData)
                *ppvarWriteData = &_pvarChangedProps[iPos];
        }
        else
        {
            *ppvarReadData  = &_pvarProps[iPos];
            if (ppvarWriteData)
                *ppvarWriteData = &_pvarChangedProps[iPos];
        }

        if (ppbDirty)
        {
            *ppbDirty = &_pbDirtyFlags[iPos];
        }
    }

    return hr;
}

//flushes changes made to the actual Music file. Works in both transacted mode and direct mode
HRESULT CMediaPropStorage::DoCommit(DWORD grfCommitFlags, FILETIME *ftLastCommit, PROPVARIANT *pVarProps, BOOL *pbDirtyFlags)
{
    if (_authLevel == NON_AUTH)
        return _ppsAuthority->DoCommit(grfCommitFlags, ftLastCommit, pVarProps, pbDirtyFlags);

    //Flush out changes
    switch (grfCommitFlags)
    {
    case STGC_DEFAULT:
    case STGC_OVERWRITE:
        break;
        
    case STGC_ONLYIFCURRENT:
        if (CompareFileTime(&_ftLastCommit, ftLastCommit) ==1)
            return STG_E_NOTCURRENT;
        break;
    default:
        return STG_E_INVALIDPARAMETER;
    }
    
    HRESULT hr = _ppssParent->FlushChanges(_fmtid, _cNumProps, _ppcmPropInfo, pVarProps, pbDirtyFlags);
    if (SUCCEEDED(hr))
    {
        if (!IsDirectMode())
        {
            for (ULONG i = 0; i < _cNumProps; i++)
            {
                PropVariantCopy(&_pvarProps[i], &pVarProps[i]);
            }
        }
        _ftLastCommit = *ftLastCommit;
    }

    return hr;
}

BOOL CMediaPropStorage::IsDirectMode()
{
    // Backwards logic because STGM_DIRECT == 0x0
    return (STGM_TRANSACTED & _dwMode) ? FALSE : TRUE;
}

BOOL CMediaPropStorage::IsSpecialProperty(const PROPSPEC *pspec)
{
    return (pspec->propid < 2 || pspec->propid > 0x7fffffff) ? TRUE : FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\media\basemediapss.cpp ===
#include "pch.h"
#include "thisdll.h"
#include "wmwrap.h"
#include "MediaProp.h"
#include "ids.h"

// declr property set storage enum
class CMediaPropSetEnum : public IEnumSTATPROPSETSTG
{
public:
    CMediaPropSetEnum(const PROPSET_INFO *propsets, ULONG cpropset, ULONG pos);

    // IUnknown
    STDMETHODIMP QueryInterface(REFIID riid, void **ppv);
    STDMETHODIMP_(ULONG) AddRef();
    STDMETHODIMP_(ULONG) Release();

    // IEnumSTATPROPSETSTG
    STDMETHODIMP Next(ULONG celt, STATPROPSETSTG *rgelt, ULONG *pceltFetched);
    STDMETHODIMP Skip(ULONG celt);
    STDMETHODIMP Reset();
    STDMETHODIMP Clone(IEnumSTATPROPSETSTG **ppenum);

private:
    ~CMediaPropSetEnum();
    LONG _cRef;
    ULONG _pos, _size;
    const PROPSET_INFO *_propsets;
};

// property set storage enum 
STDMETHODIMP_(ULONG) CMediaPropSetEnum::AddRef()
{
    return InterlockedIncrement(&_cRef);
}

STDMETHODIMP_(ULONG) CMediaPropSetEnum::Release()
{
    ASSERT( 0 != _cRef );
    ULONG cRef = InterlockedDecrement(&_cRef);
    if ( 0 == cRef )
    {
        delete this;
    }
    return cRef;
}

STDMETHODIMP CMediaPropSetEnum::QueryInterface(REFIID riid, void **ppv)
{
    static const QITAB qit[] = {
        QITABENT(CMediaPropSetEnum, IEnumSTATPROPSETSTG), 
        { 0 },
    };
    return QISearch(this, qit, riid, ppv);
}

// IEnum
STDMETHODIMP CMediaPropSetEnum::Next(ULONG celt, STATPROPSETSTG *rgelt, ULONG *pceltFetched)
{
    ULONG cFetched = 0;
    for (ULONG i = 0; i < celt && _pos < _size; i++)
    {
        ZeroMemory(&rgelt[i], sizeof(STATPROPSETSTG));
        rgelt[i].fmtid = _propsets[_pos].fmtid;
        _pos++;
        cFetched++;
    }
    if (pceltFetched)
        *pceltFetched = cFetched;
    
    return cFetched == celt ? S_OK : S_FALSE;
}

STDMETHODIMP CMediaPropSetEnum::Skip(ULONG celt)
{
    HRESULT hr;
    
    if (_pos + celt > _size)
    {
        hr = S_FALSE;
        _pos = _size;
    }
    else
    {
        hr = S_OK;
        _pos += celt;
    }
    return hr;
}

STDMETHODIMP CMediaPropSetEnum::Reset()
{
    _pos = 0;
    return S_OK;
}

STDMETHODIMP CMediaPropSetEnum::Clone(IEnumSTATPROPSETSTG **ppenum)
{
    HRESULT hr;
    CMediaPropSetEnum *penum = new CMediaPropSetEnum(_propsets, _size, _pos);
    if (penum)
    {
        hr = penum->QueryInterface(IID_PPV_ARG(IEnumSTATPROPSETSTG, ppenum));
        penum->Release();
    }
    else
        hr = STG_E_INSUFFICIENTMEMORY;
    return hr;
}

CMediaPropSetEnum::CMediaPropSetEnum(const PROPSET_INFO *propsets, ULONG cpropsets, ULONG pos) : 
    _cRef(1), _propsets(propsets), _size(cpropsets), _pos(pos)
{
    DllAddRef();
}

CMediaPropSetEnum::~CMediaPropSetEnum()
{
    DllRelease();
}


HRESULT CMediaPropSetStg::_PopulateSlowProperties()
{
    return S_OK;
}

HRESULT CMediaPropSetStg::_PopulateProperty(const COLMAP *pPInfo, PROPVARIANT *pvar)
{
    CMediaPropStorage *pps;
    HRESULT hr = _ResolveFMTID(pPInfo->pscid->fmtid, &pps);
    if (SUCCEEDED(hr))
    {
        PROPSPEC spec;
        spec.ulKind = PRSPEC_PROPID;
        spec.propid = pPInfo->pscid->pid;
        hr = pps->SetProperty(&spec, pvar);
    }

    PropVariantClear(pvar);
    return hr;
}


// Internal enumeration class used when populating properties.
CEnumAllProps::CEnumAllProps(const PROPSET_INFO *pPropSets, UINT cPropSets) : _pPropSets(pPropSets), _cPropSets(cPropSets), _iPropSetPos(0), _iPropPos(0)
{
}

const COLMAP *CEnumAllProps::Next()
{
    const COLMAP *pcmReturn = NULL;
    while (_iPropSetPos < _cPropSets)
    {
        if (_iPropPos < _pPropSets[_iPropSetPos].cNumProps)
        {
            // Go to next property.
            pcmReturn = _pPropSets[_iPropSetPos].pcmProps[_iPropPos];
            _iPropPos++;
            break;
        }
        else
        {
            // Go to next property set.
            _iPropSetPos++;
            _iPropPos = 0;
        }
    }

    return pcmReturn;
}

// Base media property set storage

STDMETHODIMP_(ULONG) CMediaPropSetStg::AddRef()
{
    return InterlockedIncrement(&_cRef);
}

STDMETHODIMP_(ULONG) CMediaPropSetStg::Release()
{
    ASSERT( 0 != _cRef );
    ULONG cRef = InterlockedDecrement(&_cRef);
    if ( 0 == cRef )
    {
        delete this;
    }
    return cRef;
}

STDMETHODIMP CMediaPropSetStg::QueryInterface(REFIID riid, void **ppv)
{
    static const QITAB qit[] = {
        QITABENT(CMediaPropSetStg, IPropertySetStorage),
        QITABENT(CMediaPropSetStg, IPersistFile), 
        QITABENTMULTI(CMediaPropSetStg, IPersist, IPersistFile),
        QITABENT(CMediaPropSetStg, IWMReaderCallback),
        { 0 },
    };
    return QISearch(this, qit, riid, ppv);
}

// IPersist

STDMETHODIMP CMediaPropSetStg::GetClassID(CLSID *pClassID)
{
    return E_NOTIMPL;
}

// IPersistFile

STDMETHODIMP CMediaPropSetStg::IsDirty(void)
{
    return S_FALSE;// sniff for uncommitted changed?
}

#define STGM_OPENMODE (STGM_READ | STGM_WRITE | STGM_READWRITE)

// Any stuff we have to do at 'load time'
HRESULT CMediaPropSetStg::_PreCheck()
{
    return S_OK;
}

STDMETHODIMP CMediaPropSetStg::Load(LPCOLESTR pszFileName, DWORD dwMode)
{
    // Allow Load only on existing files.
    if (dwMode & (STGM_CREATE | STGM_CONVERT | STGM_FAILIFTHERE))
        return STG_E_INVALIDFLAG;

    EnterCriticalSection(&_cs);

    DWORD dwFlags = dwMode & STGM_OPENMODE;

    _dwMode = dwMode;
    HRESULT hr = StringCchCopy(_wszFile, ARRAYSIZE(_wszFile), pszFileName);
    if (SUCCEEDED(hr))
    {
        _bHasBeenPopulated = FALSE;
        _bSlowPropertiesExtracted = FALSE;
        _hrPopulated = S_OK;
        _bIsWritable = (dwFlags & (STGM_WRITE | STGM_READWRITE));
    
        _ResetPropertySet();

        hr = _PreCheck();
    }

    LeaveCriticalSection(&_cs);

    return hr;
}

STDMETHODIMP CMediaPropSetStg::Save(LPCOLESTR pszFileName, BOOL fRemember)
{
    return E_NOTIMPL;
}

STDMETHODIMP CMediaPropSetStg::SaveCompleted(LPCOLESTR pszFileName)
{
    return E_NOTIMPL;
}

STDMETHODIMP CMediaPropSetStg::GetCurFile(LPOLESTR *ppszFileName)
{
    EnterCriticalSection(&_cs);

    HRESULT hr = SHStrDupW(_wszFile, ppszFileName);

    LeaveCriticalSection(&_cs);

    return hr;
}

// IPropertySetStorage methods
STDMETHODIMP CMediaPropSetStg::Create(REFFMTID fmtid, const CLSID *pclsid, DWORD grfFlags, DWORD grfMode, IPropertyStorage** ppPropStg)
{
    return E_NOTIMPL;
}

STDMETHODIMP CMediaPropSetStg::Open(REFFMTID fmtid, DWORD grfMode, IPropertyStorage** ppPropStg)
{
    EnterCriticalSection(&_cs);

    HRESULT hr = _PopulatePropertySet();
    if (SUCCEEDED(hr))
    {
        DWORD dwPssMode = _dwMode & STGM_OPENMODE;

        switch (grfMode & STGM_OPENMODE)
        {
        case STGM_READ:
            break;
        
        case STGM_WRITE:
            if (!_bIsWritable || (dwPssMode == STGM_READ))
                hr = E_FAIL;
            break;
        
        case STGM_READWRITE:
            if (!_bIsWritable || (dwPssMode != STGM_READWRITE))
                hr = E_FAIL;
            break;

        default:
            hr = E_INVALIDARG;
        }

        if (SUCCEEDED(hr))
        {
            CMediaPropStorage *pps;
            hr = _ResolveFMTID(fmtid, &pps);
            if (SUCCEEDED(hr))
            {
                hr = pps->Open(STGM_SHARE_EXCLUSIVE, grfMode & STGM_OPENMODE, ppPropStg);
            }
        }
    }

    LeaveCriticalSection(&_cs);

    return hr;
}

STDMETHODIMP CMediaPropSetStg::Delete(REFFMTID fmtid)
{
    return E_NOTIMPL;
}

STDMETHODIMP CMediaPropSetStg::Enum(IEnumSTATPROPSETSTG** ppenum)
{
    HRESULT hr;
    CMediaPropSetEnum *psenum = new CMediaPropSetEnum(_pPropStgInfo, _cPropertyStorages, 0);
    if (psenum)
    {
        hr = psenum->QueryInterface(IID_PPV_ARG(IEnumSTATPROPSETSTG, ppenum));
        psenum->Release();
    }
    else
        hr = STG_E_INSUFFICIENTMEMORY;

    return hr;
}

CMediaPropSetStg::CMediaPropSetStg() : _cRef(1), _bHasBeenPopulated(FALSE), _dwMode(STGM_READ), _propStg(NULL)
{
    _wszFile[0] = 0;
    DllAddRef();
}

// The only place this is called is at creation time.
HRESULT CMediaPropSetStg::Init()
{
    HRESULT hr = E_FAIL;

    InitializeCriticalSection(&_cs);

    _hFileOpenEvent = CreateEvent(NULL, TRUE, FALSE, NULL);
    if (_hFileOpenEvent != NULL)
    {
        hr = _CreatePropertyStorages();
        if (SUCCEEDED(hr))
        {
            hr = _ResetPropertySet();
        }
    }

    return hr;
}

CMediaPropSetStg::~CMediaPropSetStg()
{
    if (_propStg)
    {
        for (ULONG i = 0; i < _cPropertyStorages; i++)
        {
            ATOMICRELEASE(_propStg[i]);
        }

        LocalFree(_propStg);
    }

    if (_hFileOpenEvent)
    {
        CloseHandle(_hFileOpenEvent);
    }

    DeleteCriticalSection(&_cs);

    DllRelease();
}

BOOL CMediaPropSetStg::_IsSlowProperty(const COLMAP *pPInfo)
{
    return FALSE;
}

HRESULT CMediaPropSetStg::FlushChanges(REFFMTID fmtid, LONG cNumProps, const COLMAP **pcmapInfo, PROPVARIANT *pVarProps, BOOL *pbDirtyFlags)
{
    return E_NOTIMPL;
}

//returns success if we support that FMTID
// ppps and ppcmPropInfo are optional
HRESULT CMediaPropSetStg::_ResolveFMTID(REFFMTID fmtid, CMediaPropStorage **ppps)
{
    for (ULONG i = 0; i < _cPropertyStorages; i++)
    {
        if (IsEqualGUID(_pPropStgInfo[i].fmtid, fmtid))
        {
            if (ppps)
                *ppps = _propStg[i];
            return S_OK;
        }
    }
    return E_FAIL;
}

HRESULT CMediaPropSetStg::_ResetPropertySet()
{
    for (ULONG i = 0; i < _cPropertyStorages; i++)
    {
        _propStg[i]->_ResetPropStorage();
    }
    return S_OK;
}

HRESULT CMediaPropSetStg::_CreatePropertyStorages()
{
    HRESULT hr = E_OUTOFMEMORY;

    ASSERT(NULL == _propStg);

    _propStg = (CMediaPropStorage**)LocalAlloc(LPTR, sizeof(CMediaPropStorage*) * _cPropertyStorages);
    if (_propStg)
    {
        for (ULONG i = 0; i < _cPropertyStorages; i++)
        {
            ASSERTMSG(_pPropStgInfo[i].pcmProps != NULL, "CMediaPropSetStg::_CreatePropertyStorages: my COLMAP structure is null");

            // We want to give each property storage a list of the COLMAPs that it supports.
            // This information is contained in _pPropStgInfo[i].ppids and cpids.

            // We'll make a new array of COLMAPS

            _propStg[i] = new CMediaPropStorage(this, NULL, _pPropStgInfo[i].fmtid, 
                _pPropStgInfo[i].pcmProps, _pPropStgInfo[i].cNumProps, _dwMode, &_cs);
            if (!_propStg[i])
                break;
        }

        hr = S_OK;
    }
    return hr;
}

HRESULT CMediaPropSetStg::_PopulatePropertySet()
{
    return E_NOTIMPL;
}

STDMETHODIMP CMediaPropSetStg::OnStatus(WMT_STATUS Status, HRESULT hr, WMT_ATTR_DATATYPE dwType, BYTE *pValue, void *pvContext)
{
    // This is callback from WMSDK while we're holding a critical section on the main thread,
    // waiting for this event to be set.
    switch(Status)
    {
    case WMT_OPENED:
        SetEvent(_hFileOpenEvent);
        break;
    }
    return S_OK;
}

STDMETHODIMP CMediaPropSetStg::OnSample(DWORD dwOutputNum, QWORD cnsSampleTime, QWORD cnsSampleDuration, DWORD dwFlags, INSSBuffer *pSample, void* pcontext)
{
    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\media\mediaprop.h ===
#ifndef __MEDIAPROP_H__
#define __MEDIAPROP_H__

// These should be moved into some central location
#define PIDISI_CX           0x00000003L  // VT_UI4
#define PIDISI_CY           0x00000004L  // VT_UI4
#define PIDISI_FRAME_COUNT  0x0000000CL  // VT_LPWSTR
#define PIDISI_DIMENSIONS   0x0000000DL  // VT_LPWSTR


#define IsEqualSCID(a, b)   (((a).pid == (b).pid) && IsEqualIID((a).fmtid, (b).fmtid) )

typedef struct 
{
    const SHCOLUMNID *pscid;
    LPCWSTR pszName;        // Propstg string name for this property.
    VARTYPE vt;             // Note that the type of a given FMTID/PID pair is a known, fixed value
    BOOL bEnumerate;        // We don't want to enumerate alias properties.
} COLMAP;


#define DEFINE_SCID(name, fmtid, pid) const SHCOLUMNID name = { fmtid, pid }

DEFINE_SCID(SCID_Author,                PSGUID_SUMMARYINFORMATION,          PIDSI_AUTHOR); 
DEFINE_SCID(SCID_Title,                 PSGUID_SUMMARYINFORMATION,          PIDSI_TITLE);
DEFINE_SCID(SCID_Comment,               PSGUID_SUMMARYINFORMATION,          PIDSI_COMMENTS);

DEFINE_SCID(SCID_Category,              PSGUID_DOCUMENTSUMMARYINFORMATION,  PIDDSI_CATEGORY);

DEFINE_SCID(SCID_MUSIC_Artist,          PSGUID_MUSIC,                       PIDSI_ARTIST);
DEFINE_SCID(SCID_MUSIC_Album,           PSGUID_MUSIC,                       PIDSI_ALBUM);
DEFINE_SCID(SCID_MUSIC_Year,            PSGUID_MUSIC,                       PIDSI_YEAR);
DEFINE_SCID(SCID_MUSIC_Track,           PSGUID_MUSIC,                       PIDSI_TRACK);
DEFINE_SCID(SCID_MUSIC_Genre,           PSGUID_MUSIC,                       PIDSI_GENRE);
DEFINE_SCID(SCID_MUSIC_Lyrics,          PSGUID_MUSIC,                       PIDSI_LYRICS);

DEFINE_SCID(SCID_DRM_Protected,         PSGUID_DRM,                         PIDDRSI_PROTECTED);
DEFINE_SCID(SCID_DRM_Description,       PSGUID_DRM,                         PIDDRSI_DESCRIPTION);
DEFINE_SCID(SCID_DRM_PlayCount,         PSGUID_DRM,                         PIDDRSI_PLAYCOUNT);
DEFINE_SCID(SCID_DRM_PlayStarts,        PSGUID_DRM,                         PIDDRSI_PLAYSTARTS);
DEFINE_SCID(SCID_DRM_PlayExpires,       PSGUID_DRM,                         PIDDRSI_PLAYEXPIRES);

DEFINE_SCID(SCID_VIDEO_StreamName,      PSGUID_VIDEO,                       PIDVSI_STREAM_NAME);
DEFINE_SCID(SCID_VIDEO_FrameRate,       PSGUID_VIDEO,                       PIDVSI_FRAME_RATE);
DEFINE_SCID(SCID_VIDEO_Bitrate,         PSGUID_VIDEO,                       PIDVSI_DATA_RATE);
DEFINE_SCID(SCID_VIDEO_SampleSize,      PSGUID_VIDEO,                       PIDVSI_SAMPLE_SIZE);
DEFINE_SCID(SCID_VIDEO_Compression,     PSGUID_VIDEO,                       PIDVSI_COMPRESSION);

DEFINE_SCID(SCID_AUDIO_Format,          PSGUID_AUDIO,                       PIDASI_FORMAT);
DEFINE_SCID(SCID_AUDIO_Duration,        PSGUID_AUDIO,                       PIDASI_TIMELENGTH);  //100ns units, not milliseconds. VT_UI8, not VT_UI4
DEFINE_SCID(SCID_AUDIO_Bitrate,         PSGUID_AUDIO,                       PIDASI_AVG_DATA_RATE);
DEFINE_SCID(SCID_AUDIO_SampleRate,      PSGUID_AUDIO,                       PIDASI_SAMPLE_RATE);
DEFINE_SCID(SCID_AUDIO_SampleSize,      PSGUID_AUDIO,                       PIDASI_SAMPLE_SIZE);
DEFINE_SCID(SCID_AUDIO_ChannelCount,    PSGUID_AUDIO,                       PIDASI_CHANNEL_COUNT);

DEFINE_SCID(SCID_IMAGE_Width,           PSGUID_IMAGESUMMARYINFORMATION,     PIDISI_CX);
DEFINE_SCID(SCID_IMAGE_Height,          PSGUID_IMAGESUMMARYINFORMATION,     PIDISI_CY);
DEFINE_SCID(SCID_IMAGE_Dimensions,      PSGUID_IMAGESUMMARYINFORMATION,     PIDISI_DIMENSIONS);
DEFINE_SCID(SCID_IMAGE_FrameCount,      PSGUID_IMAGESUMMARYINFORMATION,     PIDISI_FRAME_COUNT);


// Docsummary props
const COLMAP g_CM_Category =    { &SCID_Category,           L"Category",        VT_LPWSTR,  FALSE}; // Alias property of Genre

// SummaryProps
const COLMAP g_CM_Author =      { &SCID_Author,             L"Author",          VT_LPWSTR,  FALSE}; // Alias property of Artist
const COLMAP g_CM_Title =       { &SCID_Title,              L"Title",           VT_LPWSTR,  TRUE};
const COLMAP g_CM_Comment =     { &SCID_Comment,            L"Description",     VT_LPWSTR,  TRUE};

// Music props
const COLMAP g_CM_Artist =      { &SCID_MUSIC_Artist,       L"Author",          VT_LPWSTR,  TRUE};
const COLMAP g_CM_Album =       { &SCID_MUSIC_Album,        L"AlbumTitle",      VT_LPWSTR,  TRUE};
const COLMAP g_CM_Year =        { &SCID_MUSIC_Year,         L"Year",            VT_LPWSTR,  TRUE};
const COLMAP g_CM_Track =       { &SCID_MUSIC_Track,        L"Track",           VT_UI4,     TRUE};  // NB: This is exposed as a WMT_ATTRTYPE_STRING for mp3. We may need to change it.
const COLMAP g_CM_Genre =       { &SCID_MUSIC_Genre,        L"Genre",           VT_LPWSTR,  TRUE};
const COLMAP g_CM_Lyrics =      { &SCID_MUSIC_Lyrics,       L"Lyrics",          VT_LPWSTR,  TRUE};

// Audio props
const COLMAP g_CM_Format =      { &SCID_AUDIO_Format,       L"Format",          VT_LPWSTR,  TRUE};
const COLMAP g_CM_Duration =    { &SCID_AUDIO_Duration,     L"Duration",        VT_UI8,     TRUE};
const COLMAP g_CM_Bitrate =     { &SCID_AUDIO_Bitrate,      L"Bitrate",         VT_UI4,     TRUE};
const COLMAP g_CM_SampleRate =  { &SCID_AUDIO_SampleRate,   L"SampleRate",      VT_UI4,     TRUE};  // samples per sec
const COLMAP g_CM_SampleSize =  { &SCID_AUDIO_SampleSize,   L"SampleSize",      VT_UI4,     TRUE};
const COLMAP g_CM_ChannelCount ={ &SCID_AUDIO_ChannelCount, L"ChannelCount",    VT_UI4,     TRUE};

// Video props
const COLMAP g_CM_StreamName =  { &SCID_VIDEO_StreamName,   L"StreamName",      VT_LPWSTR,  TRUE};
const COLMAP g_CM_FrameRate =   { &SCID_VIDEO_FrameRate,    L"FrameRate",       VT_UI4,     TRUE};
const COLMAP g_CM_SampleSizeV = { &SCID_VIDEO_SampleSize,   L"SampleSize",      VT_UI4,     TRUE}; // different from audio sample simple
const COLMAP g_CM_BitrateV =    { &SCID_VIDEO_Bitrate,      L"Bitrate",         VT_UI4,     TRUE};    // different from audio bitrate
const COLMAP g_CM_Compression = { &SCID_VIDEO_Compression,  L"Compression",     VT_LPWSTR,  TRUE};

// Image props
const COLMAP g_CM_Width =       { &SCID_IMAGE_Width,        L"Width",           VT_UI4,     TRUE};
const COLMAP g_CM_Height =      { &SCID_IMAGE_Height,       L"Height",          VT_UI4,     TRUE};
const COLMAP g_CM_Dimensions =  { &SCID_IMAGE_Dimensions,   L"Dimensions",      VT_LPWSTR,  TRUE};
const COLMAP g_CM_FrameCount =  { &SCID_IMAGE_FrameCount,   L"FrameCount",      VT_UI4,     TRUE};

// DRM props
const COLMAP g_CM_Protected  =  { &SCID_DRM_Protected,      L"Protected",       VT_BOOL,    TRUE};
const COLMAP g_CM_DRMDescription={&SCID_DRM_Description,    L"DRMDescription",  VT_LPWSTR,  TRUE};
const COLMAP g_CM_PlayCount =   { &SCID_DRM_PlayCount,      L"PlayCount",       VT_UI4,     TRUE};
const COLMAP g_CM_PlayStarts =  { &SCID_DRM_PlayStarts,     L"PlayStarts",      VT_FILETIME,TRUE};
const COLMAP g_CM_PlayExpires = { &SCID_DRM_PlayExpires,    L"PlayExpires",     VT_FILETIME,TRUE};


// Describes each of the property sets an IPropertySetStorage uses.
typedef struct {
    GUID fmtid;                 // fmtid for this property set
    const COLMAP **pcmProps;    // List of all properties that exist in this set
    ULONG cNumProps;
} PROPSET_INFO;


enum MUSICPROPSTG_AUTHLEVEL 
{
    AUTH = 0, NON_AUTH
};

enum PROPSTG_STATE 
{
    CLOSED = 0,
    OPENED_SHARED,
    OPENED_DENYREAD,
    OPENED_DENYWRITE,
    OPENED_DENYALL
};

class CMediaPropSetStg;

// Base property storage implementation.
class CMediaPropStorage : public IPropertyStorage, IQueryPropertyFlags
{
public:
    // IUnknown
    STDMETHODIMP QueryInterface(REFIID riid, void **ppv);
    STDMETHODIMP_(ULONG) AddRef();
    STDMETHODIMP_(ULONG) Release();

    //IPropertyStorage
    STDMETHODIMP ReadMultiple  (ULONG cpspec, const PROPSPEC rgpspec[], PROPVARIANT rgvar[]);
    STDMETHODIMP WriteMultiple (ULONG cpspec, PROPSPEC const rgpspec[], const PROPVARIANT rgvar[], PROPID propidNameFirst);
    STDMETHODIMP DeleteMultiple(ULONG cpspec, PROPSPEC const rgpspec[]);
    
    STDMETHODIMP ReadPropertyNames  (ULONG cpspec, PROPID const rgpropid[], LPWSTR rglpwstrName[]);
    STDMETHODIMP WritePropertyNames (ULONG cpspec, PROPID const rgpropid[], LPWSTR const rglpwstrName[]);
    STDMETHODIMP DeletePropertyNames(ULONG cpspec, PROPID const rgpropid[]);
    
    STDMETHODIMP SetClass(REFCLSID clsid);
    STDMETHODIMP Commit(DWORD grfCommitFlags);
    STDMETHODIMP Revert();
    STDMETHODIMP Enum(IEnumSTATPROPSTG **ppenum);
    STDMETHODIMP Stat(STATPROPSETSTG *pstatpropstg);
    STDMETHODIMP SetTimes(FILETIME const *pctime, FILETIME const *patime, FILETIME const *pmtime);
    
    // IQueryPropertyFlags
    STDMETHODIMP GetFlags(const PROPSPEC *pspec, SHCOLSTATEF *pcsFlags);
    STDMETHODIMP SetEnumFlags(SHCOLSTATEF csFlags);

    CMediaPropStorage(CMediaPropSetStg *ppssParent, CMediaPropStorage *ppsAuthority, REFFMTID fmtid, const COLMAP **ppcmPropInfo, DWORD cNumProps, DWORD dwMode, CRITICAL_SECTION *pcs);

    HRESULT SetProperty(PROPSPEC *ppspec, PROPVARIANT *pvar);//called by the parent to set the initial data
    HRESULT QuickLookup(PROPSPEC *ppspec, PROPVARIANT **ppvar);

private:
    ~CMediaPropStorage();

    HRESULT Open(DWORD dwShareMode, DWORD dwOpenMode, IPropertyStorage **ppPropStg);

    void _ResetPropStorage(); //Resets the Propstorage to a known empty state
    HRESULT CopyPropStorageData(PROPVARIANT *pvarProps);
    void OnClose();
    HRESULT DoCommit(DWORD grfCommitFlags, FILETIME *ftFlushTime, PROPVARIANT *pVarProps, BOOL *pbDirtyFlags);//flush the data to the parent
    HRESULT LookupProp(const PROPSPEC *pspec, const COLMAP **ppcmName, PROPVARIANT **ppvarReadData, PROPVARIANT **ppvarWriteData, BOOL **ppbDirty, BOOL bPropertySet);
    BOOL IsDirectMode();
    BOOL IsSpecialProperty(const PROPSPEC *pspec);
    HRESULT _EnsureSlowPropertiesLoaded();
    virtual BOOL _IsSlowProperty(const COLMAP *pPInfo);

    LONG _cRef;
    COLMAP const **_ppcmPropInfo;
    PROPVARIANT *_pvarProps, *_pvarChangedProps;
    PROPVARIANT _varCodePage;
    BOOL *_pbDirtyFlags;
    ULONG _cNumProps;

    MUSICPROPSTG_AUTHLEVEL _authLevel;
    CMediaPropStorage *_ppsAuthority;
    CMediaPropSetStg *_ppssParent;
    FMTID _fmtid;
    FILETIME _ftLastCommit;
    PROPSTG_STATE _state;
    DWORD _dwMode;
    BOOL _bRetrievedSlowProperties;
    HRESULT _hrSlowProps;
    SHCOLSTATEF _csEnumFlags;
    CRITICAL_SECTION *_pcs; // The parent storage set's critical section.
    
    friend class CMediaPropSetStg;
};

// Base property set storage implementation.
class CMediaPropSetStg : public IPersistFile, IPropertySetStorage, protected IWMReaderCallback
{
public:
    CMediaPropSetStg();

    // IUnknown
    STDMETHODIMP QueryInterface(REFIID riid, void **ppv);
    STDMETHODIMP_(ULONG) AddRef();
    STDMETHODIMP_(ULONG) Release();

    // IPersist
    STDMETHODIMP GetClassID(CLSID *pClassID);

    // IPersistFile
    STDMETHODIMP IsDirty(void);
    STDMETHODIMP Load(LPCOLESTR pszFileName, DWORD dwMode);
    STDMETHODIMP Save(LPCOLESTR pszFileName, BOOL fRemember);
    STDMETHODIMP SaveCompleted(LPCOLESTR pszFileName);
    STDMETHODIMP GetCurFile(LPOLESTR *ppszFileName);

    // IPropertySetStorage
    STDMETHODIMP Create(REFFMTID fmtid, const CLSID * pclsid, DWORD grfFlags, DWORD grfMode, IPropertyStorage** ppPropStg);
    STDMETHODIMP Open(REFFMTID fmtid, DWORD grfMode, IPropertyStorage** ppPropStg);
    STDMETHODIMP Delete(REFFMTID fmtid);
    STDMETHODIMP Enum(IEnumSTATPROPSETSTG** ppenum);

    // IWMReaderCallBack
    STDMETHODIMP OnStatus(WMT_STATUS Staus, HRESULT hr, WMT_ATTR_DATATYPE dwType, BYTE *pValue, void *pvContext);
    STDMETHODIMP OnSample(DWORD dwOutputNum, QWORD cnsSampleTime, QWORD cnsSampleDuration, DWORD dwFlags, INSSBuffer *pSample, void* pcontext);

    virtual HRESULT FlushChanges(REFFMTID fmtid, LONG cNumProps, const COLMAP **pcmapInfo, PROPVARIANT *pVarProps, BOOL *pbDirtyFlags);
    HRESULT Init();
    virtual BOOL _IsSlowProperty(const COLMAP *pPInfo);
    
protected:
    HRESULT _ResolveFMTID(REFFMTID fmtid, CMediaPropStorage **ppps);
    HRESULT _PopulateProperty(const COLMAP *pPInfo, PROPVARIANT *pvar);
    
    BOOL _bIsWritable;
    WCHAR _wszFile[MAX_PATH];
    BOOL _bHasBeenPopulated;
    BOOL _bSlowPropertiesExtracted;
    HRESULT _hrSlowProps;

    HRESULT _hrPopulated;
    UINT _cPropertyStorages;
    CMediaPropStorage **_propStg;
    const PROPSET_INFO *_pPropStgInfo; // Indicates which propstorages to create, etc...
    HANDLE _hFileOpenEvent;
    ~CMediaPropSetStg();

private:
    HRESULT _ResetPropertySet();
    HRESULT _CreatePropertyStorages();
    virtual HRESULT _PopulatePropertySet();
    virtual HRESULT _PopulateSlowProperties();
    virtual HRESULT _PreCheck();

    LONG _cRef;
    DWORD _dwMode;

    // This property handler needes to operate in a FTA because of the content indexing service.  If
    // we're created in an STA, it turns out they can't properly impersonate a user across apartment
    // boundaries.
    // This is a critical section we use to provide very "simple" synchronized access to our internal
    // members. Basically, we just wrap every public interface member in Enter/Leave.  The WMSDK
    // doesn't throw any exceptions, so we don't need any try-finally's (and hopefully the AVI and WAV
    // code doesn't either).
    // All public interface members in the CMediaPropStorage class are also protected by this same
    // critical section.
    CRITICAL_SECTION _cs;

    friend class CMediaPropStorage;
};


// Class used to enumerate through all COLMAPs for the properties supported by a propertysetstorage //
// Used internally by a PSS when populating properties.
class CEnumAllProps
{
public:
    CEnumAllProps(const PROPSET_INFO *pPropSets, UINT cPropSets);
    const COLMAP *Next();

private:
    const PROPSET_INFO *_pPropSets;
    UINT _cPropSets;
    UINT _iPropSetPos;
    UINT _iPropPos;
};

#endif //__MEDIAPROP_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\media\convert.cpp ===
#include "pch.h"
#include "thisdll.h"

PSTR DuplicateWideStringAsMultibyte(LPCWSTR pwszSource)
{
    PSTR pszVal;
    // Get the size required.
    int cch = WideCharToMultiByte(CP_ACP, 0, pwszSource, -1, NULL, 0, NULL, NULL);
    if (cch)
    {
        pszVal = (PSTR)CoTaskMemAlloc(cch*sizeof(CHAR));
        if (pszVal)
        {
            cch = WideCharToMultiByte(CP_ACP, 0, pwszSource, -1, pszVal, cch, NULL, NULL);
            return pszVal;
        }
    }
        
    return NULL;
}

HRESULT CoerceProperty(PROPVARIANT *pvar, VARTYPE vt)
{
    BSTR bstr;
    HRESULT hr;
    switch (vt)
    {
    case VT_BSTR:
        switch (pvar->vt)
        {
        case VT_LPSTR:
            UINT cch;
            cch = MultiByteToWideChar(CP_ACP, MB_PRECOMPOSED, pvar->pszVal, -1, NULL, 0);
            // cch is required buffer size in WCHARs, including NULL terminator.
            // SysAllocStringLen takes buffer size in WCHARs, *excluding* NULL terminator, and allocates one WCHAR extra.
            bstr = SysAllocStringLen(NULL, cch - 1);
            if (bstr != NULL)
            {
                cch = MultiByteToWideChar(CP_ACP, MB_PRECOMPOSED, pvar->pszVal, -1, bstr, cch);
                PropVariantClear(pvar);
                pvar->vt=VT_BSTR;
                pvar->bstrVal = bstr;
                hr = S_OK;
            }
            else
            {
                hr = E_FAIL;
            }
            break;
            
        case VT_LPWSTR:
            bstr = SysAllocString(pvar->pwszVal);
            if (bstr!=NULL)
            {
                PropVariantClear(pvar);
                pvar->vt = VT_BSTR;
                pvar->bstrVal = bstr;
                hr = S_OK;
            }
            else
            {
                hr = E_FAIL;
            }
            break;
            
        case VT_BSTR:
            hr = S_OK;
            break;

        default:
            hr = E_FAIL;
            break;;
        }
        break;
        
    case VT_UI4:
        hr = S_OK;
        switch (pvar->vt)
        {
        case VT_UI2:
            pvar->vt = VT_UI4;
            pvar->ulVal &= 0xffff;
            break;
            
        case VT_UI4:
            break;
            
        case VT_UI8:
            //note that we lose the high order DWORD
            pvar->vt = VT_UI4;
            pvar->uhVal.HighPart = 0;
            pvar->ulVal = pvar->uhVal.LowPart;
            break;
            
        default:
            hr = E_FAIL;
            break;
        }
        break;
        
    case VT_UI8:
        hr = S_OK;
        switch (pvar->vt)
        {
        case VT_UI2:
            pvar->vt = VT_UI8;
            pvar->uhVal.LowPart = pvar->uiVal & 0xffff;
            break;
            
        case VT_UI4:
            pvar->vt = VT_UI8;
            pvar->uhVal.LowPart = pvar->ulVal;
            pvar->uhVal.HighPart = 0;
            break;
            
        case VT_UI8:
            break;
            
        default:
            hr = E_FAIL;
            break;
        }
        break;
        
    default:
        hr = E_FAIL;
        break;
    }

    return hr;
}

HRESULT WMTFromPropVariant(BYTE *buffer, WORD *cbLen, WMT_ATTR_DATATYPE *pdatatype, PROPVARIANT *pvar)
{
    HRESULT hr;
    int cch;
    switch (pvar->vt)
    {
    case VT_BSTR:
    case VT_LPWSTR:
        cch = *cbLen / sizeof(WCHAR);  // Max number of chars we can put in the BYTE buffer
        hr = StringCchCopy((LPWSTR)buffer, cch, (pvar->bstrVal == NULL) ? L"" : pvar->bstrVal);
        if (SUCCEEDED(hr))
        {
            *pdatatype = WMT_TYPE_STRING;
            *cbLen = (WORD)(lstrlen((LPWSTR)buffer)+1) * sizeof(WCHAR);
        }
        break;

    case VT_LPSTR:
        cch = MultiByteToWideChar(CP_ACP, 0, pvar->pszVal, -1, (LPWSTR)buffer, (*cbLen) / sizeof(WCHAR));
        if (cch == 0)
        {
            hr = E_FAIL;
        }
        else
        {
            *pdatatype = WMT_TYPE_STRING;
            *cbLen = (WORD)cch * sizeof(WCHAR);
            hr = S_OK;
        }
        break;

    case VT_UI4:
        *((DWORD*)buffer) = pvar->ulVal;
        *pdatatype = WMT_TYPE_DWORD;
        *cbLen = sizeof(DWORD);
        hr = S_OK;
        break;

    case VT_UI8:
        *((ULONGLONG*)buffer) = pvar->hVal.QuadPart;
        *pdatatype = WMT_TYPE_QWORD;
        *cbLen = sizeof(ULONGLONG);
        hr = S_OK;
        break;

    case VT_BOOL:
        *pdatatype = WMT_TYPE_BOOL;
        *cbLen = 4;
        *((BOOL*)buffer) = pvar->boolVal;
        hr = S_OK;
        break;

    default:
        hr = E_FAIL;
        break;
    }

    return hr;
}

HRESULT PropVariantFromWMT(UCHAR *pData, WORD cbSize, WMT_ATTR_DATATYPE attrDataType, PROPVARIANT *pvar, VARTYPE vt)
{
    PropVariantInit(pvar);

    pvar->vt = vt;

    switch (vt)
    {
    case VT_LPWSTR:
    case VT_LPSTR:
    case VT_BSTR:
        {
            WCHAR *pwszData, wszBuffer[32]; //Big enough to hold a wsprintf'ed 32 bit decimal

            switch (attrDataType)
            {
            case WMT_TYPE_WORD:
            case WMT_TYPE_DWORD:
                {
                    DWORD dwVal = *((DWORD *)pData);
                    if (attrDataType == WMT_TYPE_WORD)
                        dwVal &= 0xffff;

                    StringCchPrintf(wszBuffer, ARRAYSIZE(wszBuffer), L"%d", dwVal);
                    pwszData = wszBuffer;
                }
                break;
            
            case WMT_TYPE_STRING:
                pwszData = cbSize ? (WCHAR*)pData : L"";
                break;
            
            default:
                return E_FAIL;
            }

            if (!pwszData) // Deal with NULL strings
            {
                pvar->pwszVal = NULL;
                return S_OK;
            }

            switch (vt)
            {
            case VT_LPWSTR:
                return SHStrDupW(pwszData, &pvar->pwszVal);

            case VT_LPSTR:
                pvar->pszVal = DuplicateWideStringAsMultibyte((LPCWSTR)pData);
                return pvar->pszVal ? S_OK : E_OUTOFMEMORY;

            case VT_BSTR:
                pvar->bstrVal = SysAllocString(pwszData);
                return pvar->bstrVal ? S_OK : E_OUTOFMEMORY;
            }
        }
        break;
        
    case VT_UI4:
        {
            if (cbSize == 0)
                return E_FAIL;

            DWORD dwVal = *((DWORD *)pData);
            if (attrDataType == WMT_TYPE_WORD)
                dwVal &= 0xffff;

            switch (attrDataType)
            {
            case WMT_TYPE_BOOL:
            case WMT_TYPE_DWORD:
            case WMT_TYPE_WORD:
                pvar->ulVal = dwVal;
                break;

            case WMT_TYPE_STRING:
                StrToIntExW((WCHAR*)pData, STIF_DEFAULT, &pvar->intVal);
                break;
            
            default:
                return E_FAIL;
            }
        }
        break;

    case VT_UI8:
        if (cbSize == 0)
            return E_FAIL;

        if (attrDataType == WMT_TYPE_QWORD)
            pvar->uhVal = *((ULARGE_INTEGER *)pData);
        break;
      
    case VT_BOOL:
        if (cbSize == 0)
            return E_FAIL;

        if (attrDataType == WMT_TYPE_BOOL)
        {
            pvar->boolVal = *((VARIANT_BOOL*)pData) ? VARIANT_TRUE : VARIANT_FALSE;
            break;
        }

    default:
        return E_FAIL;
    }
    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\media\otherpss.cpp ===
#include "pch.h"
#include "thisdll.h"
#include "ids.h"
#include "MediaProp.h"


#define MAX_DESCRIPTOR  256

#include <mmsystem.h>
#include <vfw.h>
#include <msacm.h>


// Wav file stuff
typedef struct
{
    DWORD           dwSize;
    LONG            nLength;   // milliseconds
    TCHAR           szWaveFormat[ACMFORMATTAGDETAILS_FORMATTAG_CHARS];
    PWAVEFORMATEX   pwfx;
} WAVEDESC;
STDMETHODIMP  GetWaveInfo(IN LPCTSTR pszFile, OUT WAVEDESC *p);
STDMETHODIMP  GetWaveProperty(IN REFFMTID reffmtid, IN PROPID propid, IN const WAVEDESC* pWave, OUT PROPVARIANT* pVar);


const COLMAP* c_rgAVWavAudioProps[] =
{
    {&g_CM_Duration},
    {&g_CM_Bitrate},
    {&g_CM_SampleRate},
    {&g_CM_SampleSize},
    {&g_CM_ChannelCount},
    {&g_CM_Format},
};

const PROPSET_INFO g_rgAVWavPropStgs[] = 
{
    { PSGUID_AUDIO,                         c_rgAVWavAudioProps,             ARRAYSIZE(c_rgAVWavAudioProps)},
};
// Wav files




// Avi file stuff
typedef struct
{
    DWORD   dwSize;
    LONG    nLength;     // milliseconds
    LONG    nWidth;      // pixels
    LONG    nHeight;     // pixels
    LONG    nBitDepth;   
    LONG    cFrames;  
    LONG    nFrameRate;  // frames/1000 seconds
    LONG    nDataRate;   // bytes/second
    TCHAR   szCompression[MAX_DESCRIPTOR];
    TCHAR   szStreamName[MAX_DESCRIPTOR];
    TCHAR   szWaveFormat[ACMFORMATTAGDETAILS_FORMATTAG_CHARS];
    PWAVEFORMATEX  pwfx;
} AVIDESC;

STDMETHODIMP  GetAviInfo(IN LPCTSTR pszFile, OUT AVIDESC *p);
STDMETHODIMP  GetAviProperty(IN REFFMTID reffmtid, IN PROPID propid, IN const AVIDESC* pAvi, OUT PROPVARIANT* pVar);

const COLMAP* c_rgAVAviAudioProps[] =
{
    {&g_CM_Duration},
    {&g_CM_SampleSize},
    {&g_CM_Bitrate},
    {&g_CM_Format},
};

const COLMAP* c_rgAVAviImageProps[] =
{
    {&g_CM_Width},
    {&g_CM_Height},
    {&g_CM_Dimensions},
};


const COLMAP* c_rgAVAviVideoProps[] =
{
    {&g_CM_FrameCount},
    {&g_CM_FrameRate},
    {&g_CM_Compression},
    {&g_CM_BitrateV},
    {&g_CM_SampleSizeV},
};

const COLMAP* c_rgAVAviSummaryProps[] =
{
    {&g_CM_Title},
};

const PROPSET_INFO g_rgAVAviPropStgs[] = 
{
    { PSGUID_AUDIO,                         c_rgAVAviAudioProps,             ARRAYSIZE(c_rgAVAviAudioProps)},
    { PSGUID_SUMMARYINFORMATION,            c_rgAVAviSummaryProps,           ARRAYSIZE(c_rgAVAviSummaryProps)},
    { PSGUID_VIDEO,                         c_rgAVAviVideoProps,             ARRAYSIZE(c_rgAVAviVideoProps)},
    { PSGUID_IMAGESUMMARYINFORMATION,       c_rgAVAviImageProps,             ARRAYSIZE(c_rgAVAviImageProps)},
};
// avi




// Midi file stuff
// Note: Midi files are REALLLLLY slow.
typedef struct
{
    LONG    nLength;
    TCHAR   szMidiCopyright[MAX_DESCRIPTOR];
    TCHAR   szMidiSequenceName[MAX_DESCRIPTOR];
} MIDIDESC;

STDMETHODIMP  GetMidiInfo(IN LPCTSTR pszFile, OUT MIDIDESC *p);
STDMETHODIMP  GetMidiProperty(IN REFFMTID reffmtid, IN PROPID propid, IN const MIDIDESC* pMidi, OUT PROPVARIANT* pVar);

const COLMAP* c_rgAVMidiAudioProps[] =
{
    {&g_CM_Duration},
};

const COLMAP* c_rgAVMidiSummaryProps[] = 
{
    {&g_CM_Title}, // SequenceName
};

const PROPSET_INFO g_rgAVMidiPropStgs[] = 
{
    { PSGUID_AUDIO,                         c_rgAVMidiAudioProps,             ARRAYSIZE(c_rgAVMidiAudioProps)},
    { PSGUID_SUMMARYINFORMATION,            c_rgAVMidiSummaryProps,           ARRAYSIZE(c_rgAVMidiSummaryProps)},
};
// Midi




#define FOURCC_INFO mmioFOURCC('I','N','F','O')
#define FOURCC_DISP mmioFOURCC('D','I','S','P')
#define FOURCC_IARL mmioFOURCC('I','A','R','L')
#define FOURCC_IART mmioFOURCC('I','A','R','T')
#define FOURCC_ICMS mmioFOURCC('I','C','M','S')
#define FOURCC_ICMT mmioFOURCC('I','C','M','T')
#define FOURCC_ICOP mmioFOURCC('I','C','O','P')
#define FOURCC_ICRD mmioFOURCC('I','C','R','D')
#define FOURCC_ICRP mmioFOURCC('I','C','R','P')
#define FOURCC_IDIM mmioFOURCC('I','D','I','M')
#define FOURCC_IDPI mmioFOURCC('I','D','P','I')
#define FOURCC_IENG mmioFOURCC('I','E','N','G')
#define FOURCC_IGNR mmioFOURCC('I','G','N','R')
#define FOURCC_IKEY mmioFOURCC('I','K','E','Y')
#define FOURCC_ILGT mmioFOURCC('I','L','G','T')
#define FOURCC_IMED mmioFOURCC('I','M','E','D')
#define FOURCC_INAM mmioFOURCC('I','N','A','M')
#define FOURCC_IPLT mmioFOURCC('I','P','L','T')
#define FOURCC_IPRD mmioFOURCC('I','P','R','D')
#define FOURCC_ISBJ mmioFOURCC('I','S','B','J')
#define FOURCC_ISFT mmioFOURCC('I','S','F','T')
#define FOURCC_ISHP mmioFOURCC('I','S','H','P')
#define FOURCC_ISRC mmioFOURCC('I','S','R','C')
#define FOURCC_ISRF mmioFOURCC('I','S','R','F')
#define FOURCC_ITCH mmioFOURCC('I','T','C','H')
#define FOURCC_VIDC mmioFOURCC('V','I','D','C')
#define mmioWAVE    mmioFOURCC('W','A','V','E')
#define mmioFMT     mmioFOURCC('f','m','t',' ')
#define mmioDATA    mmioFOURCC('d','a','t','a')
#define MAXNUMSTREAMS   50 



//#define _MIDI_PROPERTY_SUPPORT_

STDMETHODIMP GetMidiInfo(LPCTSTR pszFile, MIDIDESC *pmidi)
{

#ifdef _MIDI_PROPERTY_SUPPORT_
    MCI_OPEN_PARMS      mciOpen;    /* Structure for MCI_OPEN command */
    DWORD               dwFlags;
    DWORD               dw;
    MCIDEVICEID         wDevID;
    MCI_STATUS_PARMS    mciStatus;
    MCI_SET_PARMS       mciSet;        /* Structure for MCI_SET command */
    MCI_INFO_PARMS      mciInfo;  
        /* Open a file with an explicitly specified device */

    mciOpen.lpstrDeviceType = TEXT("sequencer");
    mciOpen.lpstrElementName = pszFile;
    dwFlags = MCI_WAIT | MCI_OPEN_ELEMENT | MCI_OPEN_TYPE;
    dw = mciSendCommand((MCIDEVICEID)0, MCI_OPEN, dwFlags,(DWORD_PTR)(LPVOID)&mciOpen);
    if (dw)
        return E_FAIL;
    wDevID = mciOpen.wDeviceID;

    mciSet.dwTimeFormat = MCI_FORMAT_MILLISECONDS;

    dw = mciSendCommand(wDevID, MCI_SET, MCI_SET_TIME_FORMAT,
        (DWORD_PTR) (LPVOID) &mciSet);
    if (dw)
    {
        mciSendCommand(wDevID, MCI_CLOSE, 0L, (DWORD)0);
        return E_FAIL;
    }

    mciStatus.dwItem = MCI_STATUS_LENGTH;
    dw = mciSendCommand(wDevID, MCI_STATUS, MCI_STATUS_ITEM,
        (DWORD_PTR) (LPTSTR) &mciStatus);
    if (dw)
        pmidi->nLength = 0;
    else
        pmidi->nLength = (UINT)mciStatus.dwReturn;

    mciInfo.dwCallback  = 0;

    mciInfo.lpstrReturn = pmidi->szMidiCopyright;
    mciInfo.dwRetSize   = sizeof(pmidi->szMidiCopyright);
    *mciInfo.lpstrReturn = 0;
    mciSendCommand(wDevID, MCI_INFO,  MCI_INFO_COPYRIGHT, (DWORD_PTR)(LPVOID)&mciInfo);

    mciInfo.lpstrReturn = pmidi->szMidiCopyright;
    mciInfo.dwRetSize   = sizeof(pmidi->szMidiSequenceName);
    *mciInfo.lpstrReturn = 0;
    mciSendCommand(wDevID, MCI_INFO,  MCI_INFO_NAME, (DWORD_PTR)(LPVOID)&mciInfo);

    mciSendCommand(wDevID, MCI_CLOSE, 0L, (DWORD)0);

    return S_OK;

#else  _MIDI_PROPERTY_SUPPORT_

    return E_FAIL;

#endif _MIDI_PROPERTY_SUPPORT_ 
}

STDMETHODIMP  GetMidiProperty(
    IN REFFMTID reffmtid, 
    IN PROPID pid, 
    IN const MIDIDESC* pMidi, 
    OUT PROPVARIANT* pVar)
{
    HRESULT hr = S_OK;

    if (IsEqualGUID(reffmtid, FMTID_AudioSummaryInformation))
    {
        hr = S_OK;
        switch (pid)
        {
            case PIDASI_TIMELENGTH:
                if (0 >= pMidi->nLength)
                    return E_FAIL;

                // This value is in milliseconds.
                // However, we define duration to be in 100ns units, so multiply by 10000.
                pVar->uhVal.LowPart = pMidi->nLength;
                pVar->uhVal.HighPart = 0;

                pVar->uhVal.QuadPart = pVar->uhVal.QuadPart * 10000;
                pVar->vt      = VT_UI8;
                break;
        }
    }


    return hr;        
}



HRESULT ReadWaveHeader(HMMIO hmmio, WAVEDESC *pwd)
{
    BOOL        bRet = FALSE;
    MMCKINFO    mmckRIFF;
    MMCKINFO    mmck;
    DWORD       dwFormatSize;
    MMRESULT    wError;

    ZeroMemory(pwd, sizeof(*pwd));

    mmckRIFF.fccType = mmioWAVE;
    if ((wError = mmioDescend(hmmio, &mmckRIFF, NULL, MMIO_FINDRIFF))) 
    {
        return E_FAIL;
    }
    
    mmck.ckid = mmioFMT;
    if ((wError = mmioDescend(hmmio, &mmck, &mmckRIFF, MMIO_FINDCHUNK))) 
    {
        return E_FAIL;
    }
    if (mmck.cksize < sizeof(WAVEFORMAT)) 
    {
        return E_FAIL;
    }
    
    dwFormatSize = mmck.cksize;
    if (dwFormatSize <= 0x0000ffff) // (anything with a huge header is probably a corrupt file, so fail)
    {
        pwd->pwfx = (PWAVEFORMATEX)new BYTE[dwFormatSize];
        if (pwd->pwfx)
        {
            if ((DWORD)mmioRead(hmmio, (HPSTR)pwd->pwfx, mmck.cksize) != mmck.cksize) 
            {
                goto retErr;
            }
            if (pwd->pwfx->wFormatTag == WAVE_FORMAT_PCM) 
            {
                if (dwFormatSize < sizeof(PCMWAVEFORMAT)) 
                {
                    goto retErr;
                }
            } 
            else if ((dwFormatSize < sizeof(WAVEFORMATEX)) || 
                     (dwFormatSize < sizeof(WAVEFORMATEX) + pwd->pwfx->cbSize)) 
            {
                goto retErr;
            }
            if ((wError = mmioAscend(hmmio, &mmck, 0))) 
            {
                goto retErr;
            }
            mmck.ckid = mmioDATA;
            if ((wError = mmioDescend(hmmio, &mmck, &mmckRIFF, MMIO_FINDCHUNK))) 
            {
                goto retErr;
            }
            pwd->dwSize = mmck.cksize;
            return S_OK;
        }
    }

retErr:
    if (pwd->pwfx)
    {
        delete [] (LPBYTE)pwd->pwfx;
        pwd->pwfx = NULL;
    }
    return E_FAIL;
}

// Retrieves text representation of format tag
STDMETHODIMP  GetWaveFormatTag(PWAVEFORMATEX pwfx, LPTSTR pszTag, IN ULONG cchTag)
{
    ASSERT(pwfx);
    ASSERT(pszTag);
    ASSERT(cchTag);
    
    ACMFORMATTAGDETAILS aftd;
    ZeroMemory(&aftd, sizeof(aftd));
    aftd.cbStruct    = sizeof(ACMFORMATTAGDETAILSW);
    aftd.dwFormatTag = pwfx->wFormatTag;

    if (0 == acmFormatTagDetails(NULL, &aftd, ACM_FORMATTAGDETAILSF_FORMATTAG))
    {
        //  copy to output - ok if truncated.
        StringCchCopy(pszTag, cchTag, aftd.szFormatTag);
        return S_OK;
    }

    return E_FAIL;
}

STDMETHODIMP GetWaveInfo(IN LPCTSTR pszFile, OUT WAVEDESC *p)
{
    HMMIO   hmmio;
    
    if (NULL == (hmmio = mmioOpen((LPTSTR)pszFile, NULL, MMIO_ALLOCBUF | MMIO_READ)))
        return E_FAIL;

    HRESULT hr = ReadWaveHeader(hmmio, p);

    mmioClose(hmmio, 0);

    if (SUCCEEDED(hr) && p->pwfx)
    {
        // Retrieve text representation of format tag
        GetWaveFormatTag(p->pwfx, p->szWaveFormat, ARRAYSIZE(p->szWaveFormat));
    }
    return hr;
}

STDMETHODIMP FreeWaveInfo(IN OUT WAVEDESC *p)
{
    if (p->pwfx)
    {
        delete [] p->pwfx;
        p->pwfx = NULL;
    }
    return S_OK;
}

STDMETHODIMP  _getWaveAudioProperty(
    IN REFFMTID reffmtid,
    IN PROPID   pid,
    IN const PWAVEFORMATEX pwfx,
    OUT PROPVARIANT* pVar)
{
    HRESULT hr = E_UNEXPECTED;
    TCHAR   szBuf[MAX_DESCRIPTOR],
            szFmt[MAX_DESCRIPTOR];

    PropVariantInit(pVar);
    *szBuf = *szFmt = 0;

    if (pwfx && IsEqualGUID(reffmtid, FMTID_AudioSummaryInformation))
    {
        hr = S_OK;
        switch (pid)
        {
        case PIDASI_AVG_DATA_RATE:
            if (0 >= pwfx->nAvgBytesPerSec)
                return E_FAIL;

            // Convert into bits per sec.
            pVar->ulVal = pwfx->nAvgBytesPerSec * 8;
            pVar->vt    = VT_UI4;
            break;

        case PIDASI_SAMPLE_RATE:
            if (0 >= pwfx->nSamplesPerSec)
                return E_FAIL;

            // Samples per second (/1000 to get kHz)
            pVar->ulVal = pwfx->nSamplesPerSec;
            pVar->vt    = VT_UI4;
            break;

        case PIDASI_SAMPLE_SIZE:
            if (0 >= pwfx->wBitsPerSample)
                return E_FAIL;

            // Bits per sample.
            pVar->ulVal = pwfx->wBitsPerSample;
            pVar->vt    = VT_UI4;
            break;
            
        case PIDASI_CHANNEL_COUNT:
        {
            if (0 >= pwfx->nChannels)
                return E_FAIL;

            pVar->ulVal = pwfx->nChannels;
            pVar->vt    = VT_UI4;
            break;
        }
        
        default:
            return E_UNEXPECTED;
        }
    }
    return hr;
}

STDMETHODIMP  GetWaveProperty(
    IN REFFMTID reffmtid, 
    IN PROPID pid, 
    IN const WAVEDESC* pWave, 
    OUT PROPVARIANT* pVar)
{
   
    HRESULT hr = E_FAIL;
    TCHAR   szBuf[MAX_DESCRIPTOR],
            szFmt[MAX_DESCRIPTOR];

    PropVariantInit(pVar);
    *szBuf = *szFmt = 0;

    if (IsEqualGUID(reffmtid, FMTID_AudioSummaryInformation))
    {
        hr = S_OK;
        switch (pid)
        {
        case PIDASI_FORMAT:
            if (0 == *pWave->szWaveFormat)
                return E_FAIL;

            hr = SHStrDupW(pWave->szWaveFormat, &pVar->pwszVal);
            if (SUCCEEDED(hr))
                pVar->vt = VT_LPWSTR;
            else
                return hr;
            break;

            // ISSUE: nLength is never filled in in GetWaveInfo, so this will always be zero.
        case PIDASI_TIMELENGTH:
            if (0 >= pWave->nLength)
                return E_FAIL;

            // This value is in milliseconds.
            // However, we define duration to be in 100ns units, so multiply by 10000.
            pVar->uhVal.LowPart = pWave->nLength;
            pVar->uhVal.HighPart = 0;

            pVar->uhVal.QuadPart = pVar->uhVal.QuadPart * 10000;
            pVar->vt      = VT_UI8;
            break;

        default:
            hr = E_UNEXPECTED;
                
        }
    }

    if (FAILED(hr))
        hr = _getWaveAudioProperty(reffmtid, pid, pWave->pwfx, pVar);
        
    return hr;
}





STDMETHODIMP ReadAviStreams(LPCTSTR pszFile, DWORD dwFileSize, AVIDESC *pAvi)
{
    HRESULT         hr;
    PAVIFILE        pfile;
    PAVISTREAM      pavi;
    PAVISTREAM      rgpavis[MAXNUMSTREAMS];    // the current streams
    AVISTREAMINFO   avsi;
    LONG            timeStart;            // cached start, end, length
    LONG            timeEnd;
    int             cpavi;
    int             i;

    hr = AVIFileOpen(&pfile, pszFile, 0, 0L);
    if (FAILED(hr))
        return hr;

    for (i = 0; i <= MAXNUMSTREAMS; i++) 
    {
        if (AVIFileGetStream(pfile, &pavi, 0L, i) != AVIERR_OK)
            break;
        if (i == MAXNUMSTREAMS) 
        {
            AVIStreamRelease(pavi);
            //DPF("Exceeded maximum number of streams");
            break;
        }
        #pragma prefast(suppress:201, we already broke out when i == MAXNUMSTREAMS (PREfast bug 546))
        rgpavis[i] = pavi;
    }

    //
    // Couldn't get any streams out of this file
    //
    if (i == 0)
    {
        //DPF("Unable to open any streams in %s", pszFile);
        if (pfile)
            AVIFileRelease(pfile);
        return HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND);
    }

    cpavi = i;

    //
    // Start with bogus times
    //
    timeStart = 0x7FFFFFFF;
    timeEnd   = 0;

    //
    // Walk through and init all streams loaded
    //
    for (i = 0; i < cpavi; i++) 
    {

        AVIStreamInfo(rgpavis[i], &avsi, sizeof(avsi));

        switch (avsi.fccType) 
        {
            case streamtypeVIDEO:
            {
                LONG cbFormat;
                LPBYTE lpFormat;
                ICINFO icInfo;
                HIC hic;
                DWORD dwTimeLen;

                if (AVIStreamFormatSize(rgpavis[i], 0, &cbFormat) == AVIERR_OK)
                {
                    dwTimeLen           = AVIStreamEndTime(rgpavis[i]) - AVIStreamStartTime(rgpavis[i]);
                    pAvi->cFrames       = avsi.dwLength;
                    pAvi->nFrameRate    = MulDiv(avsi.dwLength, 1000000, dwTimeLen);
                    pAvi->nDataRate     = MulDiv(dwFileSize, 1000000, dwTimeLen)/1024;
                    pAvi->nWidth        = avsi.rcFrame.right - avsi.rcFrame.left;
                    pAvi->nHeight       = avsi.rcFrame.bottom - avsi.rcFrame.top;

                    // ok if truncated.
                    StringCchCopy(pAvi->szStreamName, ARRAYSIZE(pAvi->szStreamName), avsi.szName);

                    //  Retrieve raster info (compression, bit depth).
                    lpFormat = new BYTE[cbFormat];
                    if (lpFormat)
                    {
                        if (AVIStreamReadFormat(rgpavis[i], 0, lpFormat, &cbFormat) == AVIERR_OK)
                        {
                            hic = (HIC)ICLocate(FOURCC_VIDC, avsi.fccHandler, (BITMAPINFOHEADER*)lpFormat, 
                                                 NULL, (WORD)ICMODE_DECOMPRESS);
                    
                            if (hic || ((LPBITMAPINFOHEADER)lpFormat)->biCompression == 0)
                            {
                                if (((LPBITMAPINFOHEADER)lpFormat)->biCompression)
                                {
                                    ICGetInfo(hic, &icInfo, sizeof(ICINFO));
                                    ICClose(hic);
                                    // ok if truncated.
                                    StringCchCopy(pAvi->szCompression, ARRAYSIZE(pAvi->szCompression), icInfo.szName);
                                }
                                else
                                {
                                    LoadString(m_hInst, IDS_AVI_UNCOMPRESSED, pAvi->szCompression, ARRAYSIZE(pAvi->szCompression));
                                }

                                pAvi->nBitDepth = ((LPBITMAPINFOHEADER)lpFormat)->biBitCount;
                            }
                        }
                        delete [] lpFormat;
                    }
                }
                else
                    hr = E_OUTOFMEMORY;
                break;
            }
            case streamtypeAUDIO:
            {
                LONG        cbFormat;
                if (AVIStreamFormatSize(rgpavis[i], 0, &cbFormat) == AVIERR_OK)
                {
                    pAvi->pwfx = (PWAVEFORMATEX) new BYTE[cbFormat];
                    if (pAvi->pwfx)
                    {
                        ZeroMemory(pAvi->pwfx, cbFormat);
                        if (AVIStreamReadFormat(rgpavis[i], 0, pAvi->pwfx, &cbFormat) == 0)
                        {
                            GetWaveFormatTag(pAvi->pwfx, pAvi->szWaveFormat, ARRAYSIZE(pAvi->szWaveFormat));
                        }
                    }
                }
                break;
            }
            default:
                break;
        }

    //
    // We're finding the earliest and latest start and end points for
    // our scrollbar.
    //  
        timeStart = min(timeStart, AVIStreamStartTime(rgpavis[i]));
        timeEnd   = max(timeEnd, AVIStreamEndTime(rgpavis[i]));
    }

    pAvi->nLength = (UINT)(timeEnd - timeStart);

    for (i = 0; i < cpavi; i++) 
    {
        AVIStreamRelease(rgpavis[i]);
    }
    AVIFileRelease(pfile);

    return S_OK;
}


// Because some AVI programs don't export the correct headers, retrieving AVI info will take
// an extremly long time on some files, we need to verify that the headers are available
// before we call AVIFileOpen
BOOL _ValidAviHeaderInfo(LPCTSTR pszFile)
{
    BOOL  fRet = FALSE; // Assume it is bad
   
    HMMIO hmmio = mmioOpen((LPWSTR)pszFile, NULL, MMIO_READ);
    if (hmmio)
    {
        MMCKINFO  ckRIFF;
        if (mmioDescend(hmmio, &ckRIFF, NULL, 0) == 0) 
        {
            if ((ckRIFF.ckid == FOURCC_RIFF) && (ckRIFF.fccType == formtypeAVI))
            {
                MMCKINFO  ckLIST;
                ckLIST.fccType = listtypeAVIHEADER;
                if (mmioDescend(hmmio, &ckLIST, &ckRIFF, MMIO_FINDLIST) == 0) 
                {
                    ckRIFF.ckid = ckidAVIMAINHDR;
                    if (mmioDescend(hmmio, &ckRIFF, &ckLIST, MMIO_FINDCHUNK) == 0) 
                    {
                        MainAVIHeader Hdr;
                        ULONG cb = min(sizeof Hdr, ckRIFF.cksize);

                        if (mmioRead(hmmio, (HPSTR)&Hdr, cb) == cb) 
                        {
                            fRet = Hdr.dwFlags & AVIF_HASINDEX;
                        }
                    }
                }
            }
        }
        mmioClose(hmmio, 0);
    }

    return fRet;
}

STDMETHODIMP GetAviInfo(LPCTSTR pszFile, AVIDESC *pavi)
{
    HRESULT hr = E_UNEXPECTED;

    if (_ValidAviHeaderInfo(pszFile))
    {

        //  Retrieve the file size
        HANDLE hFile = CreateFile(pszFile, 
                                   GENERIC_READ, 
                                   FILE_SHARE_READ,NULL, 
                                   OPEN_EXISTING, 
                                   FILE_ATTRIBUTE_NORMAL, 
                                   NULL);

        if (INVALID_HANDLE_VALUE == hFile)
        {
            DWORD dwRet = GetLastError();
            return ERROR_SUCCESS != dwRet ? HRESULT_FROM_WIN32(dwRet) : E_UNEXPECTED;
        }

        DWORD dwFileSize = GetFileSize((HANDLE)hFile, NULL);
        CloseHandle(hFile);

        AVIFileInit();
        hr = ReadAviStreams(pszFile, dwFileSize, pavi);
        AVIFileExit();
    }

    return hr;
}

STDMETHODIMP FreeAviInfo(IN OUT AVIDESC *p)
{
    if (p->pwfx)
    {
        delete [] p->pwfx;
        p->pwfx = NULL;
    }
    return S_OK;
}



STDMETHODIMP  GetAviProperty(
    IN REFFMTID reffmtid, 
    IN PROPID pid, 
    IN const AVIDESC* pAvi, 
    OUT PROPVARIANT* pVar)
{
   
    HRESULT hr = E_UNEXPECTED;
    TCHAR   szBuf[MAX_DESCRIPTOR],
            szFmt[MAX_DESCRIPTOR];

    PropVariantInit(pVar);
    *szBuf = *szFmt = 0;

    if (IsEqualGUID(reffmtid, FMTID_SummaryInformation))
    {
        hr = S_OK;
        switch (pid)
        {
        case PIDSI_TITLE:
            if (0 == *pAvi->szStreamName)
                return E_FAIL;

            hr = SHStrDupW(pAvi->szStreamName, &pVar->pwszVal);
            if (SUCCEEDED(hr))
                pVar->vt = VT_LPWSTR;
            else
                return hr;

        default:
            hr = E_UNEXPECTED;
        }
    }
    else if (IsEqualGUID(reffmtid, FMTID_ImageSummaryInformation))
    {
        hr = S_OK;
        switch (pid)
        {
            case PIDISI_CX:
                if (0 >= pAvi->nWidth)
                    return E_FAIL;

                pVar->ulVal = pAvi->nWidth;
                pVar->vt      = VT_UI4;
                break;

            case PIDISI_CY:
                if (0 >= pAvi->nHeight)
                    return E_FAIL;

                pVar->ulVal = pAvi->nHeight;
                pVar->vt      = VT_UI4;
                break;

            case PIDISI_FRAME_COUNT:
                if (0 >= pAvi->cFrames)
                    return E_FAIL;

                pVar->ulVal = pAvi->cFrames;
                pVar->vt = VT_UI4;
                break;
            
            case PIDISI_DIMENSIONS:
                if ((0 >= pAvi->nHeight) || (0 >= pAvi->nWidth))
                    return E_FAIL;

                WCHAR szFmt[64];                
                if (LoadString(m_hInst, IDS_DIMENSIONS_FMT, szFmt, ARRAYSIZE(szFmt)))
                {
                    DWORD_PTR args[2];
                    args[0] = (DWORD_PTR)pAvi->nWidth;
                    args[1] = (DWORD_PTR)pAvi->nHeight;

                    WCHAR szBuffer[64];
                    FormatMessage(FORMAT_MESSAGE_FROM_STRING|FORMAT_MESSAGE_ARGUMENT_ARRAY, 
                                   szFmt, 0, 0, szBuffer, ARRAYSIZE(szBuffer), (va_list*)args);

                    hr = SHStrDup(szBuffer, &pVar->pwszVal);
                    if (SUCCEEDED(hr))
                        pVar->vt = VT_LPWSTR;
                    else
                        pVar->vt = VT_EMPTY;
                }
                else
                    hr = E_FAIL;
                break;



        default:
            hr = E_UNEXPECTED;

        }
    }
    else if (IsEqualGUID(reffmtid, FMTID_AudioSummaryInformation))
    {
        hr = S_OK;
        switch (pid)
        {
        case PIDASI_TIMELENGTH:
            if (0 >= pAvi->nLength)
                return E_FAIL;

            // This value is in milliseconds.
            // However, we define duration to be in 100ns units, so multiply by 10000.
            pVar->uhVal.LowPart = pAvi->nLength;
            pVar->uhVal.HighPart = 0;

            pVar->uhVal.QuadPart = pVar->uhVal.QuadPart * 10000;
            pVar->vt      = VT_UI8;
            break;

        case PIDASI_FORMAT:
            if (0 == *pAvi->szWaveFormat)
                return E_FAIL;

            hr = SHStrDupW(pAvi->szWaveFormat, &pVar->pwszVal);
            if (SUCCEEDED(hr))
                pVar->vt = VT_LPWSTR;
            else
                return hr;
            break;

        default:
            hr = E_UNEXPECTED;

        }
    }
    else if (IsEqualGUID(reffmtid, FMTID_VideoSummaryInformation))
    {
        hr = S_OK;
        switch (pid)
        {

            case PIDVSI_FRAME_RATE:
                if (0 >= pAvi->nFrameRate)
                    return E_FAIL;

                // Value is in frames/millisecond.
                pVar->ulVal = pAvi->nFrameRate;
                pVar->vt      = VT_UI4;
                break;

            case PIDVSI_DATA_RATE:
                if (0 >= pAvi->nDataRate)
                    return E_FAIL;

                // This is in bits or bytes per second.
                pVar->ulVal = pAvi->nDataRate;
                pVar->vt      = VT_UI4;
                break;


            case PIDVSI_SAMPLE_SIZE:
                if (0 >= pAvi->nBitDepth)
                    return E_FAIL;

                // bit depth
                pVar->ulVal = pAvi->nBitDepth;
                pVar->vt      = VT_UI4;
                break;

            case PIDVSI_COMPRESSION:
                if (0 == *pAvi->szCompression)
                    return E_FAIL;

                hr = SHStrDupW(pAvi->szCompression, &pVar->pwszVal);
                if (SUCCEEDED(hr))
                    pVar->vt = VT_LPWSTR;
                else
                    return hr;
                break;

            default:
                hr = E_UNEXPECTED;
        }
    }

    if (FAILED(hr))
        hr = _getWaveAudioProperty(reffmtid, pid, pAvi->pwfx, pVar);

    return hr;
}





// declares
class CWavPropSetStg : public CMediaPropSetStg
{
public:
	CWavPropSetStg();

    // IPersist
    STDMETHODIMP GetClassID(CLSID *pClassID);

private:
    HRESULT _PopulatePropertySet();
    HRESULT _PopulateSlowProperties();
    BOOL _IsSlowProperty(const COLMAP *pPInfo);
};


class CMidiPropSetStg : public CMediaPropSetStg
{
public:
	CMidiPropSetStg();

    // IPersist
    STDMETHODIMP GetClassID(CLSID *pClassID);

private:
    HRESULT _PopulatePropertySet();
};


class CAviPropSetStg : public CMediaPropSetStg
{
public:
	CAviPropSetStg();

    // IPersist
    STDMETHODIMP GetClassID(CLSID *pClassID);

private:
    HRESULT _PopulatePropertySet();
    HRESULT _PopulateSlowProperties();
    BOOL _IsSlowProperty(const COLMAP *pPInfo);
};



//impls

// Wav property set storage
CWavPropSetStg::CWavPropSetStg() : CMediaPropSetStg() 
{
    _pPropStgInfo = g_rgAVWavPropStgs;
    _cPropertyStorages = ARRAYSIZE(g_rgAVWavPropStgs);
}


STDMETHODIMP CWavPropSetStg::GetClassID(CLSID *pClassID)
{
    *pClassID = CLSID_AVWavProperties;
    return S_OK;
}

BOOL CWavPropSetStg::_IsSlowProperty(const COLMAP *pPInfo)
{
    return TRUE; // It is slow to get WAV properties.
}

HRESULT CWavPropSetStg::_PopulateSlowProperties()
{
    if (!_bSlowPropertiesExtracted)
    {
        _bSlowPropertiesExtracted = TRUE;

        WAVEDESC wd = {0};
        HRESULT hr = GetWaveInfo(_wszFile, &wd);
        if (SUCCEEDED(hr))
        {
            CEnumAllProps enumAllProps(_pPropStgInfo, _cPropertyStorages);
            const COLMAP *pPInfo = enumAllProps.Next();
            while (pPInfo)
            {
                PROPVARIANT var = {0};
                if (SUCCEEDED(GetWaveProperty(pPInfo->pscid->fmtid,
                                 pPInfo->pscid->pid,
                                 &wd,
                                 &var)))
                {
                    _PopulateProperty(pPInfo, &var);
                    PropVariantClear(&var);
                }

                pPInfo = enumAllProps.Next();
            }
        }
        FreeWaveInfo(&wd);

        _hrSlowProps = hr;
    }

    return _hrSlowProps;
}


HRESULT CWavPropSetStg::_PopulatePropertySet()
{
    if (!_bHasBeenPopulated)
    {
        if (_wszFile[0] == 0)
        {
            _hrPopulated = STG_E_INVALIDNAME;
        } 
        else
        {
            _hrPopulated = S_OK;
        }

        _bHasBeenPopulated = TRUE;
    }

    return _hrPopulated;
}




// midi property set storage
CMidiPropSetStg::CMidiPropSetStg() : CMediaPropSetStg()
{
    _pPropStgInfo = g_rgAVMidiPropStgs;
    _cPropertyStorages = ARRAYSIZE(g_rgAVMidiPropStgs);
}


STDMETHODIMP CMidiPropSetStg::GetClassID(CLSID *pClassID)
{
    *pClassID = CLSID_AVMidiProperties;
    return S_OK;
}

HRESULT CMidiPropSetStg::_PopulatePropertySet()
{
    HRESULT hr = E_FAIL;

    if (_wszFile[0] == 0)
    {
        hr =  STG_E_INVALIDNAME;
    } 
    else if (_bHasBeenPopulated)
    {
        hr = _hrPopulated;
    }
    else
    {
        MIDIDESC md;
        hr = GetMidiInfo(_wszFile, &md);
        if (SUCCEEDED(hr))
        {
            CEnumAllProps enumAllProps(_pPropStgInfo, _cPropertyStorages);
            const COLMAP *pPInfo = enumAllProps.Next();
            while (pPInfo)
            {
                PROPVARIANT var = {0};
                if (SUCCEEDED(GetMidiProperty(pPInfo->pscid->fmtid,
                                 pPInfo->pscid->pid,
                                 &md,
                                 &var)))
                {
                    _PopulateProperty(pPInfo, &var);
                }

                pPInfo = enumAllProps.Next();
            }
        }
    }
    return hr;
}



// avi property set storage
CAviPropSetStg::CAviPropSetStg() : CMediaPropSetStg()
{
    _pPropStgInfo = g_rgAVAviPropStgs;
    _cPropertyStorages = ARRAYSIZE(g_rgAVAviPropStgs);
}


STDMETHODIMP CAviPropSetStg::GetClassID(CLSID *pClassID)
{
    *pClassID = CLSID_AVAviProperties;
    return S_OK;
}

HRESULT CAviPropSetStg::_PopulateSlowProperties()
{
    if (!_bSlowPropertiesExtracted)
    {
        _bSlowPropertiesExtracted = TRUE;


        AVIDESC ad = {0};
        HRESULT hr = GetAviInfo(_wszFile, &ad);
        if (SUCCEEDED(hr))
        {
            CEnumAllProps enumAllProps(_pPropStgInfo, _cPropertyStorages);
            const COLMAP *pPInfo = enumAllProps.Next();
            while (pPInfo)
            {
                PROPVARIANT var = {0};
                if (SUCCEEDED(GetAviProperty(pPInfo->pscid->fmtid,
                                 pPInfo->pscid->pid,
                                 &ad,
                                 &var)))
                {
                    _PopulateProperty(pPInfo, &var);
                }

                pPInfo = enumAllProps.Next();
            }
        }
        FreeAviInfo(&ad);

        _hrSlowProps = hr;
    }

    return _hrSlowProps;
}


BOOL CAviPropSetStg::_IsSlowProperty(const COLMAP *pPInfo)
{
    return TRUE; // It is slow to get AVI properties.
}

HRESULT CAviPropSetStg::_PopulatePropertySet()
{
    if (!_bHasBeenPopulated)
    {
        if (_wszFile[0] == 0)
        {
            _hrPopulated = STG_E_INVALIDNAME;
        } 
        else
        {
            _hrPopulated = S_OK;
        }

        _bHasBeenPopulated = TRUE;
    }

    return _hrPopulated;
}





// Creates
STDAPI CWavPropSetStg_CreateInstance(IUnknown *punkOuter, IUnknown **ppunk, LPCOBJECTINFO poi)
{
    HRESULT hr;
    CWavPropSetStg *pPropSetStg = new CWavPropSetStg();
    if (pPropSetStg)
    {
        hr = pPropSetStg->Init();
        if (SUCCEEDED(hr))
        {
            hr = pPropSetStg->QueryInterface(IID_PPV_ARG(IUnknown, ppunk));
        }
        pPropSetStg->Release();
    }
    else
    {
        *ppunk = NULL;
        hr = E_OUTOFMEMORY;
    }
    return hr;
}


STDAPI CMidiPropSetStg_CreateInstance(IUnknown *punkOuter, IUnknown **ppunk, LPCOBJECTINFO poi)
{
    HRESULT hr;
    CMidiPropSetStg *pPropSetStg = new CMidiPropSetStg();
    if (pPropSetStg)
    {
        hr = pPropSetStg->Init();
        if (SUCCEEDED(hr))
        {
            hr = pPropSetStg->QueryInterface(IID_PPV_ARG(IUnknown, ppunk));
        }
        pPropSetStg->Release();
    }
    else
    {
        *ppunk = NULL;
        hr = E_OUTOFMEMORY;
    }
    return hr;
}




STDAPI CAviPropSetStg_CreateInstance(IUnknown *punkOuter, IUnknown **ppunk, LPCOBJECTINFO poi)
{
    HRESULT hr;
    CAviPropSetStg *pPropSetStg = new CAviPropSetStg();
    if (pPropSetStg)
    {
        hr = pPropSetStg->Init();
        if (SUCCEEDED(hr))
        {
            hr = pPropSetStg->QueryInterface(IID_PPV_ARG(IUnknown, ppunk));
        }
        pPropSetStg->Release();
    }
    else
    {
        *ppunk = NULL;
        hr = E_OUTOFMEMORY;
    }
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\media\ids.h ===
#define IDS_AVI_UNCOMPRESSED    0x2330
#define IDS_DIMENSIONS_FMT      0x2331

#define DRMSTART 0x2500

#define IDS_DRM_UNPROTECTED                   (DRMSTART + 0)
#define IDS_DRM_ISPROTECTED                   (DRMSTART + 1)           
#define IDS_DRM_ISPROTECTEDSIGNED             (DRMSTART + 2)     
#define IDS_DRM_PLAYNOPLAYHERE                (DRMSTART + 3)     
#define IDS_DRM_PLAYONLYPLAYHERE              (DRMSTART + 4)     
#define IDS_DRM_PLAYNORIGHTS                  (DRMSTART + 5)    
#define IDS_DRM_PLAYNOTUNTILDAYS              (DRMSTART + 6)       
#define IDS_DRM_PLAYNOTUNTILWEEKS             (DRMSTART + 7)        
#define IDS_DRM_PLAYNOTUNTILMONTHS            (DRMSTART + 8)   
#define IDS_DRM_PLAYBEFOREDAYS                (DRMSTART + 9)  
#define IDS_DRM_PLAYBEFOREWEEKS               (DRMSTART + 10) 
#define IDS_DRM_PLAYBEFOREMONTHS              (DRMSTART + 11)    
#define IDS_DRM_PLAYCOUNTREMAINING            (DRMSTART + 12)   
#define IDS_DRM_PLAYCOUNTNOTUNTILDAYS         (DRMSTART + 13)  
#define IDS_DRM_PLAYCOUNTNOTUNTILWEEKS        (DRMSTART + 14) 
#define IDS_DRM_PLAYCOUNTNOTUNTILMONTHS       (DRMSTART + 15) 
#define IDS_DRM_PLAYCOUNTBEFOREDAYS           (DRMSTART + 16)  
#define IDS_DRM_PLAYCOUNTBEFOREWEEKS          (DRMSTART + 17)  
#define IDS_DRM_PLAYCOUNTBEFOREMONTHS         (DRMSTART + 18)  

#define IDS_DRM_COPYCDNORIGHTS                (DRMSTART + 19)       
#define IDS_DRM_COPYCDNOTUNTILDAYS            (DRMSTART + 20)       
#define IDS_DRM_COPYCDNOTUNTILWEEKS           (DRMSTART + 21)           
#define IDS_DRM_COPYCDNOTUNTILMONTHS          (DRMSTART + 22)             
#define IDS_DRM_COPYCDBEFOREDAYS              (DRMSTART + 23)             
#define IDS_DRM_COPYCDBEFOREWEEKS             (DRMSTART + 24)             
#define IDS_DRM_COPYCDBEFOREMONTHS            (DRMSTART + 25)            
#define IDS_DRM_COPYCDCOUNTREMAINING          (DRMSTART + 26)          
#define IDS_DRM_COPYCDCOUNTNOTUNTILDAYS       (DRMSTART + 27)         
#define IDS_DRM_COPYCDCOUNTNOTUNTILWEEKS      (DRMSTART + 28)        
#define IDS_DRM_COPYCDCOUNTNOTUNTILMONTHS     (DRMSTART + 29)       
#define IDS_DRM_COPYCDCOUNTBEFOREDAYS         (DRMSTART + 30)     
#define IDS_DRM_COPYCDCOUNTBEFOREWEEKS        (DRMSTART + 31)       
#define IDS_DRM_COPYCDCOUNTBEFOREMONTHS       (DRMSTART + 32)       

#define IDS_DRM_COPYNONSDMINORIGHTS           (DRMSTART + 33)       
#define IDS_DRM_COPYNONSDMINOTUNTILDAYS       (DRMSTART + 34)       
#define IDS_DRM_COPYNONSDMINOTUNTILWEEKS      (DRMSTART + 35)       
#define IDS_DRM_COPYNONSDMINOTUNTILMONTHS     (DRMSTART + 36)       
#define IDS_DRM_COPYNONSDMIBEFOREDAYS         (DRMSTART + 37)       
#define IDS_DRM_COPYNONSDMIBEFOREWEEKS        (DRMSTART + 38)       
#define IDS_DRM_COPYNONSDMIBEFOREMONTHS       (DRMSTART + 39)      
#define IDS_DRM_COPYNONSDMICOUNTREMAINING     (DRMSTART + 40)     
#define IDS_DRM_COPYNONSDMICOUNTNOTUNTILDAYS  (DRMSTART + 41)     
#define IDS_DRM_COPYNONSDMICOUNTNOTUNTILWEEKS (DRMSTART + 42)     
#define IDS_DRM_COPYNONSDMICOUNTNOTUNTILMONTHS (DRMSTART + 43)     
#define IDS_DRM_COPYNONSDMICOUNTBEFOREDAYS    (DRMSTART + 44)     
#define IDS_DRM_COPYNONSDMICOUNTBEFOREWEEKS   (DRMSTART + 45)        
#define IDS_DRM_COPYNONSDMICOUNTBEFOREMONTHS  (DRMSTART + 46)     
#define IDS_DRM_COPYSDMINORIGHTS              (DRMSTART + 47)        
#define IDS_DRM_COPYSDMINOTUNTILDAYS          (DRMSTART + 48)        
#define IDS_DRM_COPYSDMINOTUNTILWEEKS         (DRMSTART + 49)         
#define IDS_DRM_COPYSDMINOTUNTILMONTHS        (DRMSTART + 50)     
#define IDS_DRM_COPYSDMIBEFOREDAYS            (DRMSTART + 51)        
#define IDS_DRM_COPYSDMIBEFOREWEEKS           (DRMSTART + 52)        
#define IDS_DRM_COPYSDMIBEFOREMONTHS          (DRMSTART + 53)           
#define IDS_DRM_COPYSDMICOUNTREMAINING        (DRMSTART + 54)        
#define IDS_DRM_COPYSDMICOUNTNOTUNTILDAYS     (DRMSTART + 55)           
#define IDS_DRM_COPYSDMICOUNTNOTUNTILWEEKS    (DRMSTART + 56)           
#define IDS_DRM_COPYSDMICOUNTNOTUNTILMONTHS   (DRMSTART + 57)           
#define IDS_DRM_COPYSDMICOUNTBEFOREDAYS       (DRMSTART + 58)           
#define IDS_DRM_COPYSDMICOUNTBEFOREWEEKS      (DRMSTART + 59)        
#define IDS_DRM_COPYSDMICOUNTBEFOREMONTHS     (DRMSTART + 60)           

// #define DRMSTART 0x2500
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\media\pch.h ===
#ifndef __PCH_H__
#define __PCH_H__

#include <windows.h>
#include <shpriv.h>
#include <shlguid.h>
#include <shobjidl.h>
#include <shlwapi.h>
#include <shlwapip.h>
#include <debug.h>
#include "ccstock.h"
#include "wmsdk.h"
#include "wmsdkidl.h"
#include <strsafe.h>


PSTR DuplicateWideStringAsMultibyte(LPCWSTR pwszSource);
HRESULT CoerceProperty(PROPVARIANT *pvar,VARTYPE vt);
HRESULT WMTFromPropVariant(BYTE *buffer, WORD *cbLen, WMT_ATTR_DATATYPE *pdatatype, PROPVARIANT *pvar);
HRESULT PropVariantFromWMT(UCHAR *pData, WORD cbSize, WMT_ATTR_DATATYPE attrDataType, PROPVARIANT *pvar, VARTYPE vt);

// try-except wrappers for wmvcore.dll functions
#define WMCreateEditor WMCreateEditorWrap 
#define WMCreateIndexer WMCreateIndexerWrap
#define WMCreateProfileManager WMCreateProfileManagerWrap
#define WMCreateReader WMCreateReaderWrap
#define WMCreateWriterFileSink WMCreateWriterFileSinkWrap
#define WMCreateWriterNetworkSink WMCreateWriterNetworkSinkWrap
#define WMCreateWriter WMCreateWriterWrap
#define WMCreateCertificate WMCreateCertificateWrap

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\media\thisdll.cpp ===
#include "pch.h"
#include <advpub.h>
#include "thisdll.h"
#include <cguid.h>
#define DECL_CRTFREE
#include <crtfree.h>

#define  DECLARE_DEBUG
#define  SZ_DEBUGINI        "ccshell.ini"
#define  SZ_DEBUGSECTION    "Media Handlers"
#define  SZ_MODULE          "SHMEDIA.DLL"
#include <debug.h>

HINSTANCE m_hInst = NULL;
LONG g_cRefThisDll = 0;

STDAPI_(BOOL) DllMain(HINSTANCE hDll, DWORD dwReason, void *lpRes)
{
    switch(dwReason)
    {
    case DLL_PROCESS_ATTACH:
        m_hInst = hDll;
        break;
    }
    return TRUE;
}
 
STDAPI DllCanUnloadNow(void)
{
    return g_cRefThisDll ? S_FALSE : S_OK;
}

// Call ADVPACK for the given section of our resource based INF>
//   hInstance = resource instance to get REGINST section from
//   szSection = section name to invoke
HRESULT CallRegInstall(HINSTANCE hInstance, LPCSTR szSection)
{
    HRESULT hr = E_FAIL;
    HINSTANCE hinstAdvPack = LoadLibrary(TEXT("ADVPACK.DLL"));
    if (hinstAdvPack)
    {
        REGINSTALL pfnri = (REGINSTALL)GetProcAddress(hinstAdvPack, "RegInstall");
        if (pfnri)
        {
            STRENTRY seReg[] =
            {
                { "25", "%SystemRoot%" },
                { "11", "%SystemRoot%\\system32" },
            };
            STRTABLE stReg = { ARRAYSIZE(seReg), seReg };
            hr = pfnri(hInstance, szSection, &stReg);
        }
        FreeLibrary(hinstAdvPack);
    }
    return hr;
}

STDAPI DllRegisterServer(void)
{
    CallRegInstall(m_hInst, "RegDll");
    return S_OK;
}

STDAPI DllUnregisterServer(void)
{
    CallRegInstall(m_hInst, "UnregDll");
    return S_OK;
}

CF_TABLE_BEGIN(g_ObjectInfo)

    CF_TABLE_ENTRY(&CLSID_AudioMediaProperties, CWMAPropSetStg_CreateInstance,     COCREATEONLY),
    CF_TABLE_ENTRY(&CLSID_VideoMediaProperties, CWMVPropSetStg_CreateInstance,     COCREATEONLY),
    CF_TABLE_ENTRY(&CLSID_AVAviProperties,      CAviPropSetStg_CreateInstance,     COCREATEONLY),
    CF_TABLE_ENTRY(&CLSID_AVMidiProperties,     CMidiPropSetStg_CreateInstance,    COCREATEONLY),
    CF_TABLE_ENTRY(&CLSID_AVWavProperties,      CWavPropSetStg_CreateInstance,     COCREATEONLY),
    CF_TABLE_ENTRY(&CLSID_VideoThumbnail,       CVideoThumbnail_CreateInstance,    COCREATEONLY),

CF_TABLE_END(g_ObjectInfo)


// constructor for CObjectInfo.

CObjectInfo::CObjectInfo(CLSID const* pclsidin, LPFNCREATEOBJINSTANCE pfnCreatein, IID const* piidIn,
                         IID const* piidEventsIn, long lVersionIn, DWORD dwOleMiscFlagsIn,
                         DWORD dwClassFactFlagsIn)
{
    pclsid            = pclsidin;
    pfnCreateInstance = pfnCreatein;
    piid              = piidIn;
    piidEvents        = piidEventsIn;
    lVersion          = lVersionIn;
    dwOleMiscFlags    = dwOleMiscFlagsIn;
    dwClassFactFlags  = dwClassFactFlagsIn;
}


// static class factory (no allocs!)

STDMETHODIMP CClassFactory::QueryInterface(REFIID riid, void **ppvObj)
{
    if (IsEqualIID(riid, IID_IClassFactory) || IsEqualIID(riid, IID_IUnknown))
    {
        *ppvObj = (void *)GET_ICLASSFACTORY(this);
        DllAddRef();
        return S_OK;
    }

    *ppvObj = NULL;
    return E_NOINTERFACE;
}

STDMETHODIMP_(ULONG) CClassFactory::AddRef()
{
    DllAddRef();
    return 2;
}

STDMETHODIMP_(ULONG) CClassFactory::Release()
{
    DllRelease();
    return 1;
}

STDMETHODIMP CClassFactory::CreateInstance(IUnknown *punkOuter, REFIID riid, void **ppv)
{
    *ppv = NULL;

    if (punkOuter && !IsEqualIID(riid, IID_IUnknown))
    {
        // It is technically illegal to aggregate an object and request
        // any interface other than IUnknown. Enforce this.
        //
        return CLASS_E_NOAGGREGATION;
    }
    else
    {
        LPOBJECTINFO pthisobj = (LPOBJECTINFO)this;

        if (punkOuter && !(pthisobj->dwClassFactFlags & OIF_ALLOWAGGREGATION))
            return CLASS_E_NOAGGREGATION;

        IUnknown *punk;
        HRESULT hr = pthisobj->pfnCreateInstance(punkOuter, &punk, pthisobj);
        if (SUCCEEDED(hr))
        {
            hr = punk->QueryInterface(riid, ppv);
            punk->Release();
        }
        return hr;
    }
}

STDMETHODIMP CClassFactory::LockServer(BOOL fLock)
{
    if (fLock)
        DllAddRef();
    else
        DllRelease();
    return S_OK;
}

STDAPI DllGetClassObject(REFCLSID rclsid, REFIID riid, void **ppv)
{
    if (IsEqualIID(riid, IID_IClassFactory) || IsEqualIID(riid, IID_IUnknown))
    {
        for (LPCOBJECTINFO pcls = g_ObjectInfo; pcls->pclsid; pcls++)
        {
            if (IsEqualGUID(rclsid, *(pcls->pclsid)))
            {
                *ppv = (void*)pcls;
                DllAddRef();        // class factory holds DLL ref count
                return S_OK;
            }
        }
    }

    *ppv = NULL;
    return CLASS_E_CLASSNOTAVAILABLE;
}

STDAPI_(void) DllAddRef(void)
{
    InterlockedIncrement(&g_cRefThisDll);
}

STDAPI_(void) DllRelease(void)
{
    ASSERT( 0 != g_cRefThisDll );
    InterlockedDecrement(&g_cRefThisDll);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\media\thisdll.h ===
#ifndef _THISDLL_H_
#define _THISDLL_H_

#include "pch.h"
#include <cfdefs.h>

#define OIF_ALLOWAGGREGATION  0x0001

STDAPI_(void) DllAddRef(void);
STDAPI_(void) DllRelease(void);
EXTERN_C HINSTANCE	m_hInst;

STDAPI CWMAPropSetStg_CreateInstance(IUnknown *punkOuter, IUnknown **ppunk, LPCOBJECTINFO poi);
STDAPI CWMVPropSetStg_CreateInstance(IUnknown *punkOuter, IUnknown **ppunk, LPCOBJECTINFO poi);
STDAPI CAviPropSetStg_CreateInstance(IUnknown *punkOuter, IUnknown **ppunk, LPCOBJECTINFO poi);
STDAPI CWavPropSetStg_CreateInstance(IUnknown *punkOuter, IUnknown **ppunk, LPCOBJECTINFO poi);
STDAPI CMidiPropSetStg_CreateInstance(IUnknown *punkOuter, IUnknown **ppunk, LPCOBJECTINFO poi);
STDAPI CVideoThumbnail_CreateInstance(IUnknown *punkOuter, IUnknown **ppunk, LPCOBJECTINFO poi);

#endif	// _THISDLL_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\media\wmwrap.cpp ===
#include "wmsdkidl.h"
#include "wmwrap.h"

// Some wmvcore.dll exports (eg: WMCreateReader) are not callable via LoadLibrary/GetProcAddress,
// so we can't use our regular dllload macros. Instead, we'll wrap these calls in try-except
// blocks.
// These may be removed once the window media player is part of the build, although the linker's
// delayload stubs will still throw exceptions in low memory situations.

HRESULT WMCreateEditorWrap(IWMMetadataEditor**  ppEditor)
{
    HRESULT hr;
    // WMSDK suports only x86
#ifdef _X86_
    __try
    {
        hr = WMCreateEditor(ppEditor);
    }
    __except(EXCEPTION_EXECUTE_HANDLER)
#endif
    {
        hr = E_FAIL;
        *ppEditor = NULL;
    }
    return hr;
}

HRESULT WMCreateReaderWrap(IUnknown* pUnkReserved, DWORD dwRights, IWMReader** ppReader)
{
    HRESULT hr;
    // WMSDK suports only x86
#ifdef _X86_
    __try
    {
        hr = WMCreateReader(pUnkReserved, dwRights, ppReader);
    }
    __except(EXCEPTION_EXECUTE_HANDLER)
#endif
    {
        hr = E_FAIL;
        *ppReader = NULL;
    }
    return hr;
}


HRESULT WMCreateCertificateWrap(IUnknown** ppUnkCert)
{
    HRESULT hr;
#ifdef _X86_
    __try
    {
        hr = WMCreateCertificate(ppUnkCert);
    }
    __except(EXCEPTION_EXECUTE_HANDLER)
#endif
    {
        hr = E_FAIL;
        *ppUnkCert = NULL;
    }
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\media\wmwrap.h ===
#ifndef __WMWRAP_H__
#define __WMWRAP_H__

HRESULT WMCreateEditorWrap(IWMMetadataEditor**  ppEditor);
HRESULT WMCreateReaderWrap(IUnknown* pUnkReserved, DWORD dwRights, IWMReader** ppReader);
HRESULT WMCreateCertificateWrap(IUnknown** ppUnkCert);

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\mlang\attrloc.cpp ===
// AttrLoc.cpp : Implementation of CMLStrAttrLocale
#include "private.h"

#ifdef NEWMLSTR

#include "attrloc.h"

/////////////////////////////////////////////////////////////////////////////
// CMLStrAttrLocale


CMLStrAttrLocale::CMLStrAttrLocale() :
    m_lLen(0),
    m_lcid(0)
{
}

STDMETHODIMP CMLStrAttrLocale::SetClient(IUnknown* pUnk)
{
    return E_NOTIMPL; // CMLStrAttrLocale::SetClient()
}

STDMETHODIMP CMLStrAttrLocale::GetClient(IUnknown** ppUnk)
{
    return E_NOTIMPL; // CMLStrAttrLocale::GetClient()
}

STDMETHODIMP CMLStrAttrLocale::QueryAttr(REFIID riid, LPARAM lParam, IUnknown** ppUnk, long* lConf)
{
    return E_NOTIMPL; // CMLStrAttrLocale::QueryAttr()
}

STDMETHODIMP CMLStrAttrLocale::GetAttrInterface(IID* pIID, LPARAM* plParam)
{
    return E_NOTIMPL; // CMLStrAttrLocale::GetAttrInterface()
}

STDMETHODIMP CMLStrAttrLocale::SetMLStr(long lDestPos, long lDestLen, IUnknown* pSrcMLStr, long lSrcPos, long lSrcLen)
{
    if (pSrcMLStr)
    {
        return E_NOTIMPL; // CMLStrAttrLocale::SetMLStr()
    }
    else
    {
        HRESULT hr = ::RegularizePosLen(m_lLen, &lDestPos, &lDestLen);

        m_lLen -= lDestLen;
        m_lLen += lSrcLen; // Insert default

        return S_OK;
    }
}

STDMETHODIMP CMLStrAttrLocale::SetLong(long lDestPos, long lDestLen, long lValue)
{
    ASSERT_THIS;

    HRESULT hr = ::RegularizePosLen(m_lLen, &lDestPos, &lDestLen);

    if (SUCCEEDED(hr) && lDestPos == 0)
        m_lcid = (LCID)lValue; // In this version, saves only first locale.

    return hr;
}

STDMETHODIMP CMLStrAttrLocale::GetLong(long lSrcPos, long lSrcLen, long* plValue, long* plActualPos, long* plActualLen)
{
    ASSERT_THIS;
    ASSERT_WRITE_PTR_OR_NULL(plValue);
    ASSERT_WRITE_PTR_OR_NULL(plActualPos);
    ASSERT_WRITE_PTR_OR_NULL(plActualLen);

    HRESULT hr = ::RegularizePosLen(m_lLen, &lSrcPos, &lSrcLen);

    if (SUCCEEDED(hr))
    {
        if (plValue)
            *plValue = (long)m_lcid;
        if (plActualPos)
            *plActualPos = lSrcPos;
        if (plActualLen)
            *plActualLen = lSrcLen;
    }
    else
    {
        if (plValue)
            *plValue = 0;
        if (plActualPos)
            *plActualPos = 0;
        if (plActualLen)
            *plActualLen = 0;
    }

    return hr;
}

#endif // NEWMLSTR
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\media\thumbnail.cpp ===
#include "pch.h"
#include "thisdll.h"
#include "wmwrap.h"
#include <streams.h>
#include <shlobj.h>
#include <QEdit.h>


class CVideoThumbnail : public IExtractImage,
                        public IPersistFile,
                        public IServiceProvider
{
public:
    CVideoThumbnail();
    
    STDMETHOD (QueryInterface)(REFIID riid, void **ppv);
    STDMETHOD_(ULONG, AddRef) ();
    STDMETHOD_(ULONG, Release) ();

    // IExtractImage
    STDMETHOD (GetLocation)(LPWSTR pszPathBuffer, DWORD cch,
                            DWORD * pdwPriority, const SIZE * prgSize,
                            DWORD dwRecClrDepth, DWORD *pdwFlags);
 
    STDMETHOD (Extract)(HBITMAP *phBmpThumbnail);

    // IPersistFile
    STDMETHOD (GetClassID)(CLSID *pClassID);
    STDMETHOD (IsDirty)();
    STDMETHOD (Load)(LPCOLESTR pszFileName, DWORD dwMode);
    STDMETHOD (Save)(LPCOLESTR pszFileName, BOOL fRemember);
    STDMETHOD (SaveCompleted)(LPCOLESTR pszFileName);
    STDMETHOD (GetCurFile)(LPOLESTR *ppszFileName);

    // IServiceProvider
    STDMETHOD (QueryService)(REFGUID guidService, REFIID riid, void **ppv);

private:
    ~CVideoThumbnail();
    HRESULT _InitToVideoStream();
    HRESULT _GetThumbnailBits(BITMAPINFO **ppbi);

    LONG _cRef;
    TCHAR _szPath[MAX_PATH];
    IMediaDet *_pmedia;
    SIZE _rgSize;
    DWORD _dwRecClrDepth;
};


CVideoThumbnail::CVideoThumbnail() : _cRef(1)
{
    DllAddRef();
}

CVideoThumbnail::~CVideoThumbnail()
{
    if (_pmedia)
    {
        IUnknown_SetSite(_pmedia, NULL);
        _pmedia->Release();
    }
    DllRelease();
}

HRESULT CVideoThumbnail::QueryInterface(REFIID riid, void **ppv)
{
    static const QITAB qit[] = {
        QITABENT(CVideoThumbnail, IExtractImage),
        QITABENT(CVideoThumbnail, IPersistFile),
        QITABENTMULTI(CVideoThumbnail, IPersist, IPersistFile),
        QITABENT(CVideoThumbnail, IServiceProvider),
        { 0 },
    };
    return QISearch(this, qit, riid, ppv);
}

STDMETHODIMP_(ULONG) CVideoThumbnail::AddRef()
{
    return InterlockedIncrement(&_cRef);
}

STDMETHODIMP_(ULONG) CVideoThumbnail::Release()
{
    ASSERT( 0 != _cRef );
    ULONG cRef = InterlockedDecrement(&_cRef);
    if ( 0 == cRef )
    {
        delete this;
    }
    return cRef;
}

HRESULT CVideoThumbnail::_InitToVideoStream()
{
    HRESULT hr = E_FAIL;

    if (_pmedia)
    {
        hr = S_OK;
    }
    else
    {
        if (_szPath[0])
        {
            hr = CoCreateInstance(CLSID_MediaDet, NULL, CLSCTX_INPROC_SERVER, IID_PPV_ARG(IMediaDet, &_pmedia));
            if (SUCCEEDED(hr))
            {
                // set the site provider on the MediaDet object to 
                // allowed keyed apps to use ASF decoder
                IUnknown_SetSite(_pmedia,  SAFECAST(this, IServiceProvider*));

                // really this takes a BSTR but since this is inproc this works
                hr = _pmedia->put_Filename(_szPath);
                if (SUCCEEDED(hr))
                {
                    // now seek to the first video stream so we can get it's bits
                    long nStreams;
                    if (SUCCEEDED(_pmedia->get_OutputStreams(&nStreams)))
                    {
                        for (long i = 0; i < nStreams; i++)
                        {
                            _pmedia->put_CurrentStream(i);

                            GUID guid = {0};
                            _pmedia->get_StreamType(&guid);
                            if (guid == MEDIATYPE_Video)
                                break;
                            // else if (guid == MEDIATYPE_Audio)
                            //    BOOL bHasAudio = TRUE;
                        }
                    }
                }
            }
        }
    }
    return hr;
}

HRESULT CVideoThumbnail::_GetThumbnailBits(BITMAPINFO **ppbi)
{
    *ppbi = NULL;
    HRESULT hr = _InitToVideoStream();
    if (SUCCEEDED(hr))
    {
        long iWidth = _rgSize.cx;
        long iHeight = _rgSize.cy;

        AM_MEDIA_TYPE mt;
        hr = _pmedia->get_StreamMediaType(&mt);
        if (SUCCEEDED(hr))
        {
            if (mt.formattype == FORMAT_VideoInfo)
            {
                VIDEOINFOHEADER * pvih = (VIDEOINFOHEADER *)mt.pbFormat;
                iWidth = pvih->bmiHeader.biWidth;
                iHeight = pvih->bmiHeader.biHeight;
            }
            /*
            // REVIEW: Do we have any reason to support these additional types?
            else if (mt.formattype == FORMAT_VideoInfo2 || mt.formattype == FORMAT_MPEGVideo)
            {
                // REVIEW: Does FORMAT_MPEGVideo really start with a VIDEOINFOHEADER2 structure?
                VIDEOINFOHEADER2 * pvih = (VIDEOINFOHEADER2 *)mt.pbFormat;
                iWidth = pvih->bmiHeader.biWidth;
                iHeight = pvih->bmiHeader.biHeight;
            }
            */

            if (iWidth > _rgSize.cx || iHeight > _rgSize.cy)
            {
                if ( Int32x32To64(_rgSize.cx, iHeight) > Int32x32To64(iWidth,_rgSize.cy)  )
                {
                    // constrained by height
                    iWidth = MulDiv(iWidth, _rgSize.cy, iHeight);
                    if (iWidth < 1) iWidth = 1;
                    iHeight = _rgSize.cy;
                }
                else
                {
                    // constrained by width
                    iHeight = MulDiv(iHeight, _rgSize.cx, iWidth);
                    if (iHeight < 1) iHeight = 1;
                    iWidth = _rgSize.cx;
                }
            }

            CoTaskMemFree(mt.pbFormat);
            if (mt.pUnk)
            {
                mt.pUnk->Release();
            }
        }

        LONG lByteCount = 0;
        hr = _pmedia->GetBitmapBits(0.0, &lByteCount, NULL, iWidth, iHeight);
        if (SUCCEEDED(hr))
        {
            *ppbi = (BITMAPINFO *)LocalAlloc(LPTR, lByteCount);
            if (*ppbi)
            {
                hr = _pmedia->GetBitmapBits(0.0, 0, (char *)*ppbi, iWidth, iHeight);
            }
            else
                hr = E_OUTOFMEMORY;
        }
    }
    return hr;
}

void *CalcBitsOffsetInDIB(LPBITMAPINFO pBMI)
{
    int ncolors = pBMI->bmiHeader.biClrUsed;
    if (ncolors == 0 && pBMI->bmiHeader.biBitCount <= 8)
        ncolors = 1 << pBMI->bmiHeader.biBitCount;
        
    if (pBMI->bmiHeader.biBitCount == 16 ||
        pBMI->bmiHeader.biBitCount == 32)
    {
        if (pBMI->bmiHeader.biCompression == BI_BITFIELDS)
        {
            ncolors = 3;
        }
    }

    return (void *) ((UCHAR *)&pBMI->bmiColors[0] + ncolors * sizeof(RGBQUAD));
}

STDMETHODIMP CVideoThumbnail::Extract(HBITMAP *phbmp)
{
    *phbmp = NULL;

    BITMAPINFO *pbi;
    HRESULT hr = _GetThumbnailBits(&pbi);
    if (SUCCEEDED(hr))
    {
        HDC hdc = GetDC(NULL);
        if (hdc)
        {
            *phbmp = CreateDIBitmap(hdc, &pbi->bmiHeader, CBM_INIT, CalcBitsOffsetInDIB(pbi), pbi, DIB_RGB_COLORS);
            ReleaseDC(NULL, hdc);
        }
        else
            hr = E_FAIL;

        LocalFree(pbi);
    }
    return hr;
}

STDMETHODIMP CVideoThumbnail::GetLocation(LPWSTR pszPath, DWORD cch, DWORD *pdwPrioirty, const SIZE *prgSize, DWORD dwRecClrDepth, DWORD *pdwFlags)
{
    _rgSize = *prgSize;
    _dwRecClrDepth = dwRecClrDepth;

    HRESULT hr = StringCchCopyEx(pszPath, cch, _szPath, NULL, NULL, STRSAFE_NULL_ON_FAILURE);
    if (SUCCEEDED(hr))
    {
        hr = (*pdwFlags & IEIFLAG_ASYNC) ? E_PENDING : S_OK;
        *pdwFlags = IEIFLAG_CACHE;
    }

    return hr;
}

STDMETHODIMP CVideoThumbnail::GetClassID(CLSID *pClassID)
{
    *pClassID = CLSID_VideoThumbnail;
    return S_OK;
}

STDMETHODIMP CVideoThumbnail::IsDirty(void)
{
    return S_OK;        // no
}

STDMETHODIMP CVideoThumbnail::Load(LPCOLESTR pszFileName, DWORD dwMode)
{
    return StringCchCopy(_szPath, ARRAYSIZE(_szPath), pszFileName);
}

STDMETHODIMP CVideoThumbnail::Save(LPCOLESTR pszFileName, BOOL fRemember)
{
    return S_OK;
}

STDMETHODIMP CVideoThumbnail::SaveCompleted(LPCOLESTR pszFileName)
{
    return S_OK;
}

STDMETHODIMP CVideoThumbnail::GetCurFile(LPOLESTR *ppszFileName)
{
    return E_NOTIMPL;
}

// IServiceProvider
STDMETHODIMP CVideoThumbnail::QueryService(REFGUID guidService, REFIID riid, void **ppv)
{
    // Return code for no service should be SVC_E_UNKNOWNSERVICE according to docs,
    // but that does not exist.  Return E_INVALIDARG instead.
    HRESULT hr = E_INVALIDARG;
    *ppv = NULL;

    if (guidService == _uuidof(IWMReader))
    {
        IUnknown *punkCert;
        hr = WMCreateCertificate(&punkCert);
        if (SUCCEEDED(hr))
        {
            hr = punkCert->QueryInterface(riid, ppv);
            punkCert->Release();
        }
    }

    return hr;
}

STDAPI CVideoThumbnail_CreateInstance(IUnknown *punkOuter, IUnknown **ppunk, LPCOBJECTINFO poi)
{
    HRESULT hr;
    CVideoThumbnail *pvt = new CVideoThumbnail();
    if (pvt)
    {
        *ppunk = SAFECAST(pvt, IExtractImage *);
        hr = S_OK;
    }
    else
    {
        *ppunk = NULL;
        hr = E_OUTOFMEMORY;
    }
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\media\test\proptest.cpp ===
#include "pch.h"
#include <stdio.h>

void FillPropSet(IPersistFile *pfile, char *filename)
{
    WCHAR wszbuffer[MAX_PATH];
    WIN32_FIND_DATAA findinfo;

    HANDLE hFile = FindFirstFileA(filename, &findinfo);
    if (hFile != INVALID_HANDLE_VALUE)
    {
        MultiByteToWideChar(CP_ACP, 0, findinfo.cFileName, -1, wszbuffer, MAX_PATH);
        pfile->Load(wszbuffer, STGM_READ);
        FindClose(hFile);
    }
}

void PlayWithPropertySetStorage(IPropertySetStorage *ppss)
{
    IEnumSTATPROPSETSTG *penum;
    char buffer[MAX_PATH];
    
    if (SUCCEEDED(ppss->Enum(&penum)))
    {
        STATPROPSETSTG statpss;
        IPropertyStorage *pps;
        int i=0;
        while (penum->Next(1, &statpss, NULL) == S_OK)
        {
            printf("Property Storage %i:\n", ++i);
            if (SUCCEEDED(ppss->Open(statpss.fmtid, 
                STGM_DIRECT|STGM_READWRITE|STGM_SHARE_EXCLUSIVE, &pps)))
            {
                PROPSPEC spec;
                PROPVARIANT pvar;
                STATPROPSTG statps;
                IEnumSTATPROPSTG *penumprop;
                if (SUCCEEDED(pps->Enum(&penumprop)))
                {
                    while (penumprop->Next(1, &statps, NULL)== S_OK)
                    {
                        spec.lpwstr = statps.lpwstrName;
                        spec.propid = statps.propid;
                        spec.ulKind = PRSPEC_PROPID;
                        
                        if (pps->ReadMultiple(1, &spec, &pvar) == S_OK)
                        {
                            if (spec.ulKind == PRSPEC_LPWSTR)
                                WideCharToMultiByte(CP_ACP, 0, spec.lpwstr, -1, buffer, MAX_PATH, NULL, NULL);
                            else
                                buffer[0] = 0;
                            printf("  prop %i (%s) = \"??\"\n", spec.propid, buffer);
                        }
                    }//While
                    penumprop->Release();
                }
                pps->Release();
            }//While
        }
        penum->Release();
    }
}

EXTERN_C int __cdecl main(int argc, char **argv)
{
    if (SUCCEEDED(CoInitialize(0)))
    {
        HRESULT hr;
        IPropertySetStorage *ppss;
        hr = CoCreateInstance(CLSID_MediaProperties, 0, CLSCTX_INPROC_SERVER, IID_PPV_ARG(IPropertySetStorage, &ppss));
        if (SUCCEEDED(hr))
        {
            printf(("CoCreated the Storage\n"));
            if(argc>1)
            {
                IPersistFile *pfile;
                if (SUCCEEDED(ppss->QueryInterface(IID_PPV_ARG(IPersistFile, &pfile))))
                {
                    FillPropSet(pfile, argv[1]);
                    pfile->Release();
                }
            }
            PlayWithPropertySetStorage(ppss);
            ppss->Release();
        }
        else
            printf(("Failed to CoCreate the Storage: hr = %8x\n"), hr);
        CoUninitialize();
    }
    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\media\wmpss.cpp ===
#include "pch.h"
#include "thisdll.h"
#include "wmwrap.h"
#include "MediaProp.h"
#include <streams.h> // For VIDEOINFOHEADER, etc..
#include <drmexternals.h>
#include "ids.h"

#define TRACK_ONE_BASED L"WM/TrackNumber"
#define TRACK_ZERO_BASED L"WM/Track"

// Struct used when collecting information about a file.
// This is used when populating sl	ow files, and the information within is retrieved by several
// different methods.
typedef struct
{
    // DRM info
    LPWSTR pszLicenseInformation;
    DWORD dwPlayCount;
    FILETIME ftPlayStarts;
    FILETIME ftPlayExpires;

    // Audio properties
    LPWSTR pszStreamNameAudio;
    WORD wStreamNumberAudio;
    WORD nChannels;
    DWORD dwBitrateAudio;
    LPWSTR pszCompressionAudio;
    DWORD dwSampleRate;
    ULONG lSampleSizeAudio;

    // Video properties
    LPWSTR pszStreamNameVideo;
    WORD wStreamNumberVideo;
    WORD wBitDepth;
    DWORD dwBitrateVideo;
    LONG cx;
    LONG cy;
    LPWSTR pszCompressionVideo;
    DWORD dwFrames;
    DWORD dwFrameRate;
} SHMEDIA_AUDIOVIDEOPROPS;

// Helpers for putting information in SHMEDIA_AUDIOVIDEOPROPS
void GetVideoProperties(IWMStreamConfig *pConfig, SHMEDIA_AUDIOVIDEOPROPS *pVideoProps);
void GetVideoPropertiesFromHeader(VIDEOINFOHEADER *pvih, SHMEDIA_AUDIOVIDEOPROPS *pVideoProps);
void GetVideoPropertiesFromBitmapHeader(BITMAPINFOHEADER *bmi, SHMEDIA_AUDIOVIDEOPROPS *pVideoProps);
void InitializeAudioVideoProperties(SHMEDIA_AUDIOVIDEOPROPS *pAVProps);
void FreeAudioVideoProperties(SHMEDIA_AUDIOVIDEOPROPS *pAVProps);
void GetAudioProperties(IWMStreamConfig *pConfig, SHMEDIA_AUDIOVIDEOPROPS *pAudioProps);
void AcquireLicenseInformation(IWMDRMReader *pReader, SHMEDIA_AUDIOVIDEOPROPS *pAVProps);
HRESULT GetSlowProperty(REFFMTID fmtid, PROPID pid, SHMEDIA_AUDIOVIDEOPROPS *pAVProps, PROPVARIANT *pvar);

void _AssertValidDRMStrings();


// Window media audio supported formats
// Applies to wma, mp3,...
const COLMAP* c_rgWMADocSummaryProps[] = 
{
    {&g_CM_Category},
};

const COLMAP* c_rgWMASummaryProps[] = 
{
    {&g_CM_Author},
    {&g_CM_Title},
    {&g_CM_Comment},
};

const COLMAP* c_rgWMAMusicProps[] = 
{
    {&g_CM_Artist},
    {&g_CM_Album},
    {&g_CM_Year},
    {&g_CM_Track},
    {&g_CM_Genre},
    {&g_CM_Lyrics},
};

const COLMAP* c_rgWMADRMProps[] =
{
    {&g_CM_Protected},
    {&g_CM_DRMDescription},
    {&g_CM_PlayCount},
    {&g_CM_PlayStarts},
    {&g_CM_PlayExpires},
};

const COLMAP* c_rgWMAAudioProps[] =
{
    {&g_CM_Duration},
    {&g_CM_Bitrate},
    {&g_CM_ChannelCount},
    {&g_CM_SampleSize},
    {&g_CM_SampleRate},
};

const PROPSET_INFO g_rgWMAPropStgs[] = 
{
    { PSGUID_MUSIC,                         c_rgWMAMusicProps,             ARRAYSIZE(c_rgWMAMusicProps) },
    { PSGUID_SUMMARYINFORMATION,            c_rgWMASummaryProps,      ARRAYSIZE(c_rgWMASummaryProps) },
    { PSGUID_DOCUMENTSUMMARYINFORMATION,    c_rgWMADocSummaryProps,   ARRAYSIZE(c_rgWMADocSummaryProps)},
    { PSGUID_AUDIO,                         c_rgWMAAudioProps,             ARRAYSIZE(c_rgWMAAudioProps)},
    { PSGUID_DRM,                           c_rgWMADRMProps,             ARRAYSIZE(c_rgWMADRMProps)},
};

// Windows media audio


// Window media video supported formats
// applies to wmv, asf, ...
const COLMAP* c_rgWMVSummaryProps[] = 
{
    {&g_CM_Author},
    {&g_CM_Title},
    {&g_CM_Comment},
};


const COLMAP* c_rgWMVDRMProps[] =
{
    {&g_CM_Protected},
    {&g_CM_DRMDescription},
    {&g_CM_PlayCount},
    {&g_CM_PlayStarts},
    {&g_CM_PlayExpires},
};


const COLMAP* c_rgWMVAudioProps[] =
{
    {&g_CM_Duration},
    {&g_CM_Bitrate},
    {&g_CM_ChannelCount},
    {&g_CM_SampleSize},
    {&g_CM_SampleRate},
};

const COLMAP* c_rgWMVVideoProps[] =
{
    {&g_CM_StreamName},
    {&g_CM_FrameRate},
    {&g_CM_SampleSizeV},
    {&g_CM_BitrateV},
    {&g_CM_Compression},
};

const COLMAP* c_rgWMVImageProps[] =
{
    {&g_CM_Width},
    {&g_CM_Height},
    {&g_CM_Dimensions},
    {&g_CM_FrameCount},
};

const PROPSET_INFO g_rgWMVPropStgs[] = 
{
    { PSGUID_DRM,                           c_rgWMVDRMProps,             ARRAYSIZE(c_rgWMVDRMProps) },
    { PSGUID_SUMMARYINFORMATION,            c_rgWMVSummaryProps,         ARRAYSIZE(c_rgWMVSummaryProps) },
    { PSGUID_AUDIO,                         c_rgWMVAudioProps,           ARRAYSIZE(c_rgWMVAudioProps)},
    { PSGUID_VIDEO,                         c_rgWMVVideoProps,           ARRAYSIZE(c_rgWMVVideoProps)},
    { PSGUID_IMAGESUMMARYINFORMATION,       c_rgWMVImageProps,           ARRAYSIZE(c_rgWMVImageProps)},
};

// Windows media video

// Map from scids to corresponding WMSDK attributes, for some of the "fast" properties
// retrieved via IWMHeaderInfo.  Two of these properties may also be slow (if the values aren't available
// via IWMHeaderInfo).
typedef struct
{
    const SHCOLUMNID *pscid;
    LPCWSTR pszSDKName;
} SCIDTOSDK;

const SCIDTOSDK g_rgSCIDToSDKName[] =
{
    // SCID                 sdk name            
    {&SCID_Author,          L"Author"},
    {&SCID_Title,           L"Title"},
    {&SCID_Comment,         L"Description"},
    {&SCID_Category,        L"WM/Genre"},
    {&SCID_MUSIC_Artist,    L"Author"},
    {&SCID_MUSIC_Album,     L"WM/AlbumTitle"},
    {&SCID_MUSIC_Year,      L"WM/Year"},
    {&SCID_MUSIC_Genre,     L"WM/Genre"},
    {&SCID_MUSIC_Track,     NULL},              // Track is a  special property, as evidenced by
    {&SCID_DRM_Protected,   L"Is_Protected"},   //  the fact that it doesn't have an SDK Name.
    {&SCID_AUDIO_Duration,  L"Duration"},       // Duration is slow, but may also be fast, depending on the file
    {&SCID_AUDIO_Bitrate,   L"Bitrate"},        // Bitrate is slow, but may also be fast, depending on the file
    {&SCID_MUSIC_Lyrics,    L"WM/Lyrics"},      // Lyrics
};


// impl
class CWMPropSetStg : public CMediaPropSetStg
{
public:
    HRESULT FlushChanges(REFFMTID fmtid, LONG cNumProps, const COLMAP **ppcmapInfo, PROPVARIANT *pVarProps, BOOL *pbDirtyFlags);
    BOOL _IsSlowProperty(const COLMAP *pPInfo);

private:
    HRESULT _FlushProperty(IWMHeaderInfo *phi, const COLMAP *pPInfo, PROPVARIANT *pvar);
    HRESULT _PopulateSpecialProperty(IWMHeaderInfo *phi, const COLMAP *pPInfo);
    HRESULT _SetPropertyFromWMT(const COLMAP *pPInfo, WMT_ATTR_DATATYPE attrDatatype, UCHAR *pData, WORD cbSize);
    HRESULT _PopulatePropertySet();
    HRESULT _PopulateSlowProperties();
    HRESULT _GetSlowPropertyInfo(SHMEDIA_AUDIOVIDEOPROPS *pAVProps);
    LPCWSTR _GetSDKName(const COLMAP *pPInfo);
    BOOL _IsHeaderProperty(const COLMAP *pPInfo);
    HRESULT _OpenHeaderInfo(IWMHeaderInfo **pHeaderInfo, BOOL fReadingOnly);
    HRESULT _PreCheck();
    HRESULT _QuickLookup(const COLMAP *pPInfo, PROPVARIANT **ppvar);
    void _PostProcess();

    BOOL _fProtectedContent;
    BOOL _fDurationSlow;
    BOOL _fBitrateSlow;
};

#define HI_READONLY TRUE
#define HI_READWRITE FALSE

// The only difference between CWMA and CWMV is which properties they're initialized with.
class CWMAPropSetStg : public CWMPropSetStg
{
public:
    CWMAPropSetStg() { _pPropStgInfo = g_rgWMAPropStgs; _cPropertyStorages = ARRAYSIZE(g_rgWMAPropStgs);};

    // IPersist
    STDMETHODIMP GetClassID(CLSID *pclsid) {*pclsid = CLSID_AudioMediaProperties; return S_OK;};
};


class CWMVPropSetStg : public CWMPropSetStg
{
public:
    CWMVPropSetStg() { _pPropStgInfo = g_rgWMVPropStgs; _cPropertyStorages = ARRAYSIZE(g_rgWMVPropStgs);};

    // IPersist
    STDMETHODIMP GetClassID(CLSID *pclsid) {*pclsid = CLSID_VideoMediaProperties; return S_OK;};
};


HRESULT CreateReader(REFIID riid, void **ppv)
{
    IWMReader *pReader;
    HRESULT hr = WMCreateReader(NULL, 0, &pReader);
    if (SUCCEEDED(hr))
    {
        hr = pReader->QueryInterface(riid, ppv);
        pReader->Release();
    }
    return hr;
}

HRESULT CWMPropSetStg::_PopulateSlowProperties()
{
    if (!_bSlowPropertiesExtracted)
    {
        _bSlowPropertiesExtracted = TRUE;

        SHMEDIA_AUDIOVIDEOPROPS avProps = {0};
        InitializeAudioVideoProperties(&avProps);

        HRESULT hr = _GetSlowPropertyInfo(&avProps);
        if (SUCCEEDED(hr))
        {
            // Iterate through all fmtid/pid pairs we want, and call GetSlowProperty
            CEnumAllProps enumAllProps(_pPropStgInfo, _cPropertyStorages);
            const COLMAP *pPInfo = enumAllProps.Next();
            while (pPInfo)
            {
                if (_IsSlowProperty(pPInfo))
                {
                    PROPVARIANT var = {0};
                    if (SUCCEEDED(GetSlowProperty(pPInfo->pscid->fmtid,
                                                  pPInfo->pscid->pid,
                                                  &avProps,
                                                  &var)))
                    {
                        _PopulateProperty(pPInfo, &var);
                        PropVariantClear(&var);
                    }
                }

                pPInfo = enumAllProps.Next();
            }

            // Free info in structure
            FreeAudioVideoProperties(&avProps);

            hr = S_OK;
        }

        _hrSlowProps = hr;
    }

    return _hrSlowProps;
}


BOOL CWMPropSetStg::_IsSlowProperty(const COLMAP *pPInfo)
{
    // Some properties can be slow or "fast", depending on the file.
    if (pPInfo == &g_CM_Bitrate)
        return _fBitrateSlow;

    if (pPInfo == &g_CM_Duration)
        return _fDurationSlow;

    // Other than that - if it had a name used for IWMHeaderInfo->GetAttributeXXX, then it's a fast property.
    for (int i = 0; i < ARRAYSIZE(g_rgSCIDToSDKName); i++)
    {
        if (IsEqualSCID(*pPInfo->pscid, *g_rgSCIDToSDKName[i].pscid))
        {
            // Definitely a fast property.
            return FALSE;
        }
    }
    
    // If it's not one of the IWMHeaderInfo properties, then it's definitely slow.
    return TRUE;
}


STDAPI_(BOOL) IsNullTime(const FILETIME *pft)
{
    FILETIME ftNull = {0, 0};
    return CompareFileTime(&ftNull, pft) == 0;
}

HRESULT GetSlowProperty(REFFMTID fmtid, PROPID pid, SHMEDIA_AUDIOVIDEOPROPS *pAVProps, PROPVARIANT *pvar)
{
    HRESULT hr = E_FAIL;

    if (IsEqualGUID(fmtid, FMTID_DRM))
    {
        switch (pid)
        {
        case PIDDRSI_PROTECTED:
            ASSERTMSG(FALSE, "WMPSS: Asking for PIDDRSI_PROTECTED as a slow property");
            break;

        case PIDDRSI_DESCRIPTION:
            if (pAVProps->pszLicenseInformation)
            {
                hr = SHStrDupW(pAVProps->pszLicenseInformation, &pvar->pwszVal);
                if (SUCCEEDED(hr))
                    pvar->vt = VT_LPWSTR;
            }
            break;

        case PIDDRSI_PLAYCOUNT:
            if (pAVProps->dwPlayCount != -1)
            {
                pvar->vt = VT_UI4;
                pvar->ulVal = pAVProps->dwPlayCount;
                hr = S_OK;
            }
            break;

        case PIDDRSI_PLAYSTARTS:
            if (!IsNullTime(&pAVProps->ftPlayStarts))
            {
                pvar->vt = VT_FILETIME;
                pvar->filetime = pAVProps->ftPlayStarts;
                hr = S_OK;
            }
            break;

        case PIDDRSI_PLAYEXPIRES:
            if (!IsNullTime(&pAVProps->ftPlayExpires))
            {
                pvar->vt = VT_FILETIME;
                pvar->filetime = pAVProps->ftPlayExpires;
                hr = S_OK;
            }
            break;
        }
    }
    else if (IsEqualGUID(fmtid, FMTID_AudioSummaryInformation))
    {
        switch (pid)
        {
        // case PIDASI_FORMAT: Don't know how to get this yet.
        // case PIDASI_DURATION: Don't know how to get this yet, but it's usually available through IWMHeaderInfo

        case PIDASI_STREAM_NAME:
            if (pAVProps->pszStreamNameAudio != NULL)
            {
                hr = SHStrDupW(pAVProps->pszStreamNameAudio, &pvar->pwszVal);
                if (SUCCEEDED(hr))
                    pvar->vt = VT_LPWSTR;
            }
            break;

        case PIDASI_STREAM_NUMBER:
            if (pAVProps->wStreamNumberAudio > 0)
            {
                pvar->vt = VT_UI2;
                pvar->uiVal = pAVProps->wStreamNumberAudio;
                hr = S_OK;
            }
            break;
         
        case PIDASI_AVG_DATA_RATE:
            if (pAVProps->dwBitrateAudio > 0)
            {
                pvar->vt = VT_UI4;
                pvar->ulVal = pAVProps->dwBitrateAudio;
                hr = S_OK;
            }
            break;

        case PIDASI_SAMPLE_RATE:
            if (pAVProps->dwSampleRate > 0)
            {
                pvar->vt = VT_UI4;
                pvar->ulVal = pAVProps->dwSampleRate;
                hr = S_OK;
            }
            break;

        case PIDASI_SAMPLE_SIZE:
            if (pAVProps->lSampleSizeAudio > 0)
            {
                pvar->vt = VT_UI4;
                pvar->ulVal = pAVProps->lSampleSizeAudio;
                hr = S_OK;
            }
            break;

        case PIDASI_CHANNEL_COUNT:
            if (pAVProps->nChannels > 0)
            {
                pvar->vt = VT_UI4;
                pvar->ulVal = pAVProps->nChannels;
                hr = S_OK;
            }
            break;

            // Not supported yet - don't know how to get this.
        case PIDASI_COMPRESSION:
            if (pAVProps->pszCompressionAudio != NULL)
            {
                hr = SHStrDupW(pAVProps->pszCompressionAudio, &pvar->pwszVal);
                if (SUCCEEDED(hr))
                    pvar->vt = VT_LPWSTR;
            }
            break;
        }
    }

    else if (IsEqualGUID(fmtid, FMTID_VideoSummaryInformation))
    {
        switch (pid)
        {
        case PIDVSI_STREAM_NAME:
            if (pAVProps->pszStreamNameVideo != NULL)
            {
                hr = SHStrDupW(pAVProps->pszStreamNameVideo, &pvar->pwszVal);
                if (SUCCEEDED(hr))
                    pvar->vt = VT_LPWSTR;
            }
            break;

        case PIDVSI_STREAM_NUMBER:
            if (pAVProps->wStreamNumberVideo > 0)
            {
                pvar->vt = VT_UI2;
                pvar->uiVal = pAVProps->wStreamNumberVideo;
                hr = S_OK;
            }
            break;
         
            // Not supported yet - don't know how to get this.
        case PIDVSI_FRAME_RATE:
            if (pAVProps->dwFrameRate > 0)
            {
                pvar->vt = VT_UI4;
                pvar->ulVal = pAVProps->dwFrameRate;
                hr = S_OK;
            }
            break;

        case PIDVSI_DATA_RATE:
            if (pAVProps->dwBitrateVideo > 0)
            {
                pvar->vt = VT_UI4;
                pvar->ulVal = pAVProps->dwBitrateVideo;
                hr = S_OK;
            }
            break;

        case PIDVSI_SAMPLE_SIZE:
            //This is bitdepth.
            if (pAVProps->wBitDepth > 0)
            {
                pvar->vt = VT_UI4;
                pvar->ulVal = (ULONG)pAVProps->wBitDepth;
                hr = S_OK;
            }
            break;

            // Not supported yet - don't know how to get this.
        case PIDVSI_COMPRESSION:
            if (pAVProps->pszCompressionVideo != NULL)
            {
                hr = SHStrDupW(pAVProps->pszCompressionVideo, &pvar->pwszVal);
                if (SUCCEEDED(hr))
                    pvar->vt = VT_LPWSTR;
            }
            break;

        }
    }

    else if (IsEqualGUID(fmtid, FMTID_ImageSummaryInformation))
    {
        switch(pid)
        {
        case PIDISI_CX:
            if (pAVProps->cx > 0)
            {
                pvar->vt = VT_UI4;
                pvar->ulVal = pAVProps->cx;
                hr = S_OK;
            }
            break;

        case PIDISI_CY:
            if (pAVProps->cy > 0)
            {
                pvar->vt = VT_UI4;
                pvar->ulVal = pAVProps->cy;
                hr = S_OK;
            }
            break;

        case PIDISI_FRAME_COUNT:
            if (pAVProps->dwFrames > 0)
            {
                pvar->vt = VT_UI4;
                pvar->ulVal = pAVProps->dwFrames;
                hr = S_OK;
            }
            break;

        case PIDISI_DIMENSIONS:
            if ((pAVProps->cy > 0) && (pAVProps->cx > 0))
            {
                WCHAR szFmt[64];                
                if (LoadString(m_hInst, IDS_DIMENSIONS_FMT, szFmt, ARRAYSIZE(szFmt)))
                {
                    DWORD_PTR args[2];
                    args[0] = (DWORD_PTR)pAVProps->cx;
                    args[1] = (DWORD_PTR)pAVProps->cy;

                    WCHAR szBuffer[64];
                    FormatMessage(FORMAT_MESSAGE_FROM_STRING|FORMAT_MESSAGE_ARGUMENT_ARRAY, 
                                   szFmt, 0, 0, szBuffer, ARRAYSIZE(szBuffer), (va_list*)args);

                    hr = SHStrDup(szBuffer, &pvar->pwszVal);
                    if (SUCCEEDED(hr))
                        pvar->vt = VT_LPWSTR;
                }
            }
            break;
        }
    }

    return hr;
}


typedef struct
{
    UINT ridDays;
    UINT ridWeeks;
    UINT ridMonths;
} TIMEDRMRIDS;


// These are sentinel values.
#define DRMRIDS_TYPE_NONE            -1
#define DRMRIDS_TYPE_NORIGHT         -2
// These are indices into the ridTimes array in the DRMRIDS structure.
#define DRMRIDS_TYPE_BEFORE          0
#define DRMRIDS_TYPE_NOTUNTIL        1
#define DRMRIDS_TYPE_COUNTBEFORE     2
#define DRMRIDS_TYPE_COUNTNOTUNTIL   3

typedef struct
{
    UINT ridNoRights;
    TIMEDRMRIDS ridTimes[4];
    UINT ridCountRemaining;
} DRMRIDS;




//*****************************************************************************
// NOTE: wszCount parameter is optional... can populate just a date string.
//*****************************************************************************
HRESULT ChooseAndPopulateDateCountString(
                FILETIME ftCurrent,     // current time
                FILETIME ftLicense,     // license UTC time
                WCHAR *wszCount,        // optional count string
                const TIMEDRMRIDS *pridTimes,
                WCHAR *wszOutValue,     // returned formatted string
                DWORD cchOutValue )     // num chars in 'wszOutValue'
{
    HRESULT hr = S_OK;
    
    // 'ftLicense' (the license time) is greater than the current time.
    // Determine how much greater, and use the appropriate string.
    ULARGE_INTEGER ulCurrent, ulLicense;
    WCHAR wszDiff[ 34 ];
    QWORD qwDiff;
    DWORD dwDiffDays;
    DWORD rid = 0;

    // Laborious conversion to I64 type.
    ulCurrent.LowPart = ftCurrent.dwLowDateTime;
    ulCurrent.HighPart = ftCurrent.dwHighDateTime;
    ulLicense.LowPart = ftLicense.dwLowDateTime;
    ulLicense.HighPart = ftLicense.dwHighDateTime;

    if ((QWORD)ulLicense.QuadPart > (QWORD)ulCurrent.QuadPart)
        qwDiff = (QWORD)ulLicense.QuadPart - (QWORD)ulCurrent.QuadPart;
    else
        qwDiff = (QWORD)ulCurrent.QuadPart - (QWORD)ulLicense.QuadPart;

    dwDiffDays = ( DWORD )( qwDiff / ( QWORD )864000000000);  // number of 100-ns units in a day.

    // We'll count the partial day as 1, so increment.
    // NOTE: this means we will never show a string that says
    // "expires in 0 day(s)".
    dwDiffDays++;
    if ( 31 >= dwDiffDays )
    {
        rid = pridTimes->ridDays;
    }
    else if ( 61 >= dwDiffDays )
    {
        rid = pridTimes->ridWeeks;
        dwDiffDays /= 7;    // derive # weeks
    }
    else
    {
        rid = pridTimes->ridMonths;
        dwDiffDays /= 30;   // derive # months
    }
    _ltow((long)dwDiffDays, wszDiff, 10); // wszDiff is of sufficient size

    WCHAR szDRMMsg[MAX_PATH];
    WCHAR* rgchArgList[2];
    rgchArgList[0] = wszDiff;
    rgchArgList[1] = wszCount;  // may be NULL

    // Can't get FORMAT_MESSAGE_FROM_HMODULE to work with FormatMessage....
    LoadString(m_hInst, rid, szDRMMsg, ARRAYSIZE(szDRMMsg));
    FormatMessage(FORMAT_MESSAGE_FROM_STRING | FORMAT_MESSAGE_ARGUMENT_ARRAY, szDRMMsg, 0, 0, wszOutValue, cchOutValue, reinterpret_cast<char**>(rgchArgList));

    return( hr );
}        




// Return S_FALSE indicates no information found in the state data struct.
//*****************************************************************************
HRESULT ParseDRMStateData(const WM_LICENSE_STATE_DATA *sdValue,   // data from DRM
                          const DRMRIDS *prids,                   // array of resource ID's
                          WCHAR *wszOutValue,                     // ptr to output buffer
                          DWORD cchOutValue,                      // number of chars in 'wszOutValue' buffer
                          DWORD *pdwCount,                        // Extra non-string info: counts remaining.
                          FILETIME *pftStarts,                    // Extra non string info: when it starts.
                          FILETIME *pftExpires)                   // Extra non string info: when it expires.
{
    HRESULT hr = S_OK;

    *pdwCount = -1;
    pftExpires->dwLowDateTime = 0;
    pftExpires->dwHighDateTime = 0;
    pftStarts->dwLowDateTime = 0;
    pftStarts->dwHighDateTime = 0;

    WCHAR wszCount[34];
    WCHAR wszTemp[MAX_PATH];
    
    DWORD dwNumCounts = sdValue->stateData[0].dwNumCounts;

    if (dwNumCounts != 0)
    {
        // We have a valid play count.       
        ASSERTMSG(1 == dwNumCounts, "Invalid number of playcounts in DRM_LICENSE_STATE_DATA");
        (void)_ltow((long)sdValue->stateData[0].dwCount[0], wszCount, 10); // wszCount is of sufficient size

        // ** Bonus information to store off.
        *pdwCount = sdValue->stateData[0].dwCount[0];
    }

    // Now deal with dates.
    UINT dwNumDates = sdValue->stateData[ 0 ].dwNumDates;

    // Most licenses have at most one date... an expiration.
    // There should be at most 2 dates!!
    if (dwNumDates == 0)
    {
        // No dates.. if there is also no playcount, then it's unlimited play.
        if (*pdwCount == -1)
        {
            // We're done.
            hr = S_FALSE;
        }
        else
        {
            // No dates.. just a count. Fill it into proper string.
            LoadString(m_hInst, prids->ridCountRemaining, wszTemp, ARRAYSIZE(wszTemp));
            EVAL(StringCchPrintf(wszOutValue, cchOutValue, wszTemp, wszCount)); // Ignoring return value - should always be big enough.
            // We're done.
        }
    }
    else
    {
        DWORD dwCategory = sdValue->stateData[0].dwCategory;
        // There are dates.
        if (dwNumDates == 1)
        {

            // Is it start or end?
            if ((dwCategory == WM_DRM_LICENSE_STATE_FROM) || (dwCategory == WM_DRM_LICENSE_STATE_COUNT_FROM))
            {
                // Start.
                *pftStarts = sdValue->stateData[0].datetime[0];
            }
            else if ((dwCategory == WM_DRM_LICENSE_STATE_UNTIL) || (dwCategory == WM_DRM_LICENSE_STATE_COUNT_UNTIL))
            {
                // Expires.
                *pftExpires = sdValue->stateData[0].datetime[0];
            }
            else
            {
                ASSERTMSG(FALSE, "Unexpected dwCategory for 1 date in DRM_LICENSE_STATE_DATA");
                hr = E_FAIL;
            }
        }
        else if (dwNumDates == 2)
        {
            // A start and end date.
            ASSERTMSG((dwCategory == WM_DRM_LICENSE_STATE_FROM_UNTIL) || (dwCategory == WM_DRM_LICENSE_STATE_COUNT_FROM_UNTIL), "Unexpected dwCategory for 2 dates in DRM_LICENSE_STATE_DATA");
            *pftStarts = sdValue->stateData[0].datetime[0];
            *pftExpires = sdValue->stateData[0].datetime[1];
        }
        else
        {
            ASSERTMSG(FALSE, "Too many dates in DRM_LICENSE_STATE_DATA");
            hr = E_FAIL;
        }


        if (SUCCEEDED(hr))
        {
            //   7 cases here.  * = license date.  T = current time.
            //  --------------------------
            //     BEGIN    |     END
            //  --------------------------
            // 1  T *	                      "...not allowed for xxx"
            // 2    *  T                      --- don't show anything - action is allowed ---
            // 3                T  *          "...expires in xxx"  
            // 4                   *   T      "...not allowed"
            // 5  T *              *	      "...not allowed for xxx"
            // 6    *     T        *          "...expires in xxx"
            // 7    *              *   T      "...not allowed"

            DWORD dwType; // This can be an array index into prids->ridTimes[]
            FILETIME ftLicense;
            FILETIME ftCurrent;
            GetSystemTimeAsFileTime(&ftCurrent);      // UTC time

            if (!IsNullTime(pftStarts))
            {
                // We have a start time.
                if (CompareFileTime(&ftCurrent, pftStarts) == -1)
                {
                    // CASE 1,5. We're before the start time.
                    dwType = (*pdwCount == -1) ? DRMRIDS_TYPE_NOTUNTIL : DRMRIDS_TYPE_COUNTNOTUNTIL;
                    ftLicense = *pftStarts;
                }
                else
                {
                    // We're after the start time
                    if (!IsNullTime(pftExpires))
                    {
                        // We have an expire time, and we're after the start time.
                        if (CompareFileTime(&ftCurrent, pftExpires) == -1)
                        {
                            // CASE 6. We're before the expire time.  Use "expires in" strings.
                            dwType = (*pdwCount == -1) ? DRMRIDS_TYPE_BEFORE : DRMRIDS_TYPE_COUNTBEFORE;
                            ftLicense = *pftExpires;
                        }
                        else
                        {
                            // CASE 7. After the the expire time.  Action is not allowed.
                            dwType = DRMRIDS_TYPE_NORIGHT;
                        }

                    }
                    else
                    {
                        // CASE 2. Nothing to show. Action is allowed, since we're after the start date, with no expiry.
                        dwType = DRMRIDS_TYPE_NONE;
                    }
                }
            }
            else
            {
                // No start time.
                ASSERT(!IsNullTime(pftExpires));
                // We have an expire time
                if (CompareFileTime(&ftCurrent, pftExpires) == -1)
                {
                    // CASE 3. We're before the expire time.  Use "expires in" strings.
                    dwType = (*pdwCount == -1) ? DRMRIDS_TYPE_BEFORE : DRMRIDS_TYPE_COUNTBEFORE;
                    ftLicense = *pftExpires;
                }
                else
                {
                    // CASE 4. After the the expire time.  Action is not allowed.
                    dwType = DRMRIDS_TYPE_NORIGHT;
                }
            }


            if (dwType == DRMRIDS_TYPE_NORIGHT)
            {
                // Current time is >= 'ftLicense'. Just return the "no rights" string.
                LoadString(m_hInst, prids->ridNoRights, wszOutValue, cchOutValue );
            }
            else if (dwType != DRMRIDS_TYPE_NONE)
            {
                hr = ChooseAndPopulateDateCountString(
                                    ftCurrent,
                                    ftLicense,
                                    (*pdwCount != -1) ? wszCount : NULL,
                                    &prids->ridTimes[dwType],
                                    wszOutValue,
                                    cchOutValue);
            }
            else
            {
                // Nothing to display. Action is allowed.
                ASSERT(dwType == DRMRIDS_TYPE_NONE);
            }
        }

    }
    
    return hr;
}



const WCHAR c_szNewLine[] = L"\r\n";

void AppendLicenseInfo(SHMEDIA_AUDIOVIDEOPROPS *pAVProps, WCHAR *pszLicenseInfo)
{
    WCHAR *pszLI = pAVProps->pszLicenseInformation;

    BOOL fFirstOne = (pszLI == NULL);

    int cchOrig = lstrlen(pszLI);
    // We need room for the original string, plus the new one, and any new line characters.
    int cch = (cchOrig + lstrlen(pszLicenseInfo) + (fFirstOne ? 0 : ARRAYSIZE(c_szNewLine)) + 1);
    pszLI = (WCHAR*)CoTaskMemRealloc(pszLI, cch * sizeof(WCHAR));
    
    if (pszLI)
    {
        if (fFirstOne)
        {
            // Make sure we have something to StrCat to.
            pszLI[0] = 0;
        }
        else
        {
            StrCatChainW(pszLI, cch, cchOrig, c_szNewLine);
            cchOrig += ARRAYSIZE(c_szNewLine);
        }

        StrCatChainW(pszLI, cch, cchOrig, pszLicenseInfo);
        pAVProps->pszLicenseInformation = pszLI; // in case it moved.
    }
}




const DRMRIDS g_drmridsPlay =
{
    IDS_DRM_PLAYNORIGHTS,
    {
        {IDS_DRM_PLAYBEFOREDAYS, IDS_DRM_PLAYBEFOREWEEKS, IDS_DRM_PLAYBEFOREMONTHS},
        {IDS_DRM_PLAYNOTUNTILDAYS, IDS_DRM_PLAYNOTUNTILWEEKS, IDS_DRM_PLAYNOTUNTILMONTHS},
        {IDS_DRM_PLAYCOUNTBEFOREDAYS, IDS_DRM_PLAYCOUNTBEFOREWEEKS, IDS_DRM_PLAYCOUNTBEFOREMONTHS},
        {IDS_DRM_PLAYCOUNTNOTUNTILDAYS, IDS_DRM_PLAYCOUNTNOTUNTILWEEKS, IDS_DRM_PLAYCOUNTNOTUNTILMONTHS}
    },
    IDS_DRM_PLAYCOUNTREMAINING,
};

const DRMRIDS g_drmridsCopyToCD =
{
    IDS_DRM_COPYCDNORIGHTS,
    {
        {IDS_DRM_COPYCDBEFOREDAYS, IDS_DRM_COPYCDBEFOREWEEKS, IDS_DRM_COPYCDBEFOREMONTHS},
        {IDS_DRM_COPYCDNOTUNTILDAYS, IDS_DRM_COPYCDNOTUNTILWEEKS, IDS_DRM_COPYCDNOTUNTILMONTHS},
        {IDS_DRM_COPYCDCOUNTBEFOREDAYS, IDS_DRM_COPYCDCOUNTBEFOREWEEKS, IDS_DRM_COPYCDCOUNTBEFOREMONTHS},
        {IDS_DRM_COPYCDCOUNTNOTUNTILDAYS, IDS_DRM_COPYCDCOUNTNOTUNTILWEEKS, IDS_DRM_COPYCDCOUNTNOTUNTILMONTHS}
    },
    IDS_DRM_COPYCDCOUNTREMAINING,
};

const DRMRIDS g_drmridsCopyToNonSDMIDevice =
{
    IDS_DRM_COPYNONSDMINORIGHTS,
    {
        {IDS_DRM_COPYNONSDMIBEFOREDAYS, IDS_DRM_COPYNONSDMIBEFOREWEEKS, IDS_DRM_COPYNONSDMIBEFOREMONTHS},
        {IDS_DRM_COPYNONSDMINOTUNTILDAYS, IDS_DRM_COPYNONSDMINOTUNTILWEEKS, IDS_DRM_COPYNONSDMINOTUNTILMONTHS},
        {IDS_DRM_COPYNONSDMICOUNTBEFOREDAYS, IDS_DRM_COPYNONSDMICOUNTBEFOREWEEKS, IDS_DRM_COPYNONSDMICOUNTBEFOREMONTHS},
        {IDS_DRM_COPYNONSDMICOUNTNOTUNTILDAYS, IDS_DRM_COPYNONSDMICOUNTNOTUNTILWEEKS, IDS_DRM_COPYNONSDMICOUNTNOTUNTILMONTHS}
    },
    IDS_DRM_COPYNONSDMICOUNTREMAINING,
};

const DRMRIDS g_drmridsCopyToSDMIDevice =
{
    IDS_DRM_COPYSDMINORIGHTS,
    {
        {IDS_DRM_COPYSDMIBEFOREDAYS, IDS_DRM_COPYSDMIBEFOREWEEKS, IDS_DRM_COPYSDMIBEFOREMONTHS},
        {IDS_DRM_COPYSDMINOTUNTILDAYS, IDS_DRM_COPYSDMINOTUNTILWEEKS, IDS_DRM_COPYSDMINOTUNTILMONTHS},
        {IDS_DRM_COPYSDMICOUNTBEFOREDAYS, IDS_DRM_COPYSDMICOUNTBEFOREWEEKS, IDS_DRM_COPYSDMICOUNTBEFOREMONTHS},
        {IDS_DRM_COPYSDMICOUNTNOTUNTILDAYS, IDS_DRM_COPYSDMICOUNTNOTUNTILWEEKS, IDS_DRM_COPYSDMICOUNTNOTUNTILMONTHS}
    },
    IDS_DRM_COPYSDMICOUNTREMAINING,
};

#define ACTIONALLOWED_PLAY           L"ActionAllowed.Play"
#define ACTIONALLOWED_COPYTOCD       L"ActionAllowed.Print.redbook"
#define ACTIONALLOWED_COPYTONONSMDI  L"ActionAllowed.Transfer.NONSDMI"
#define ACTIONALLOWED_COPYTOSMDI     L"ActionAllowed.Transfer.SDMI"

#define LICENSESTATE_PLAY            L"LicenseStateData.Play"
#define LICENSESTATE_COPYTOCD        L"LicenseStateData.Print.redbook"
#define LICENSESTATE_COPYTONONSMDI   L"LicenseStateData.Transfer.NONSDMI"
#define LICENSESTATE_COPYTOSMDI      L"LicenseStateData.Transfer.SDMI"

typedef struct
{
    LPCWSTR pszAction;
    LPCWSTR pszLicenseState;
    const DRMRIDS *pdrmrids;        // Resource ID's
} LICENSE_INFO;

const LICENSE_INFO g_rgLicenseInfo[] =
{
    { ACTIONALLOWED_PLAY,          LICENSESTATE_PLAY,          &g_drmridsPlay },
    { ACTIONALLOWED_COPYTOCD,      LICENSESTATE_COPYTOCD,      &g_drmridsCopyToCD },
    { ACTIONALLOWED_COPYTONONSMDI, LICENSESTATE_COPYTONONSMDI, &g_drmridsCopyToNonSDMIDevice },
    { ACTIONALLOWED_COPYTOSMDI,    LICENSESTATE_COPYTOSMDI,    &g_drmridsCopyToSDMIDevice },
};

// We can't use the drm string constants in our const array above (they aren't initialized until after
// our struct is initialized, so they're null), so we redefined the strings
// as #define's ourselves.  This function asserts that none of the strings have changed.
void _AssertValidDRMStrings()
{
    ASSERT(StrCmp(ACTIONALLOWED_PLAY,           g_wszWMDRM_ActionAllowed_Playback) == 0);
    ASSERT(StrCmp(ACTIONALLOWED_COPYTOCD,       g_wszWMDRM_ActionAllowed_CopyToCD) == 0);
    ASSERT(StrCmp(ACTIONALLOWED_COPYTONONSMDI,  g_wszWMDRM_ActionAllowed_CopyToNonSDMIDevice) == 0);
    ASSERT(StrCmp(ACTIONALLOWED_COPYTOSMDI,     g_wszWMDRM_ActionAllowed_CopyToSDMIDevice) == 0);
    ASSERT(StrCmp(LICENSESTATE_PLAY,            g_wszWMDRM_LicenseState_Playback) == 0);
    ASSERT(StrCmp(LICENSESTATE_COPYTOCD,        g_wszWMDRM_LicenseState_CopyToCD) == 0);
    ASSERT(StrCmp(LICENSESTATE_COPYTONONSMDI,   g_wszWMDRM_LicenseState_CopyToNonSDMIDevice) == 0);
    ASSERT(StrCmp(LICENSESTATE_COPYTOSMDI,      g_wszWMDRM_LicenseState_CopyToSDMIDevice) == 0);
}

BOOL _IsActionPlayback(LPCWSTR pszAction)
{
    return (StrCmp(pszAction, ACTIONALLOWED_PLAY) == 0);
}


void AcquireLicenseInformation(IWMDRMReader *pReader, SHMEDIA_AUDIOVIDEOPROPS *pAVProps)
{
    WMT_ATTR_DATATYPE dwType;
    DWORD dwValue = 0;
    WORD cbLength;
    WCHAR szValue[MAX_PATH];

    _AssertValidDRMStrings();

    // For each of the "actions":
    for (int i = 0; i < ARRAYSIZE(g_rgLicenseInfo); i++)
    {
        cbLength = sizeof(dwValue);

        // Request the license info.
        WM_LICENSE_STATE_DATA licenseState;
        cbLength = sizeof(licenseState);

        if (SUCCEEDED(pReader->GetDRMProperty(g_rgLicenseInfo[i].pszLicenseState, &dwType, (BYTE*)&licenseState, &cbLength)))
        {
            DWORD dwCount;
            FILETIME ftExpires, ftStarts;

            // We should always get at least one DRM_LICENSE_STATE_DATA.  This is what ParseDRMStateData assumes.
            ASSERTMSG(licenseState.dwNumStates >= 1, "Received WM_LICENSE_STATE_DATA with no states");

            // Parse easy special cases first.
            if (licenseState.stateData[0].dwCategory == WM_DRM_LICENSE_STATE_NORIGHT)
            {
                // Not allowed ever.  Indicate this.
                // Special case for playback action:
                if (_IsActionPlayback(g_rgLicenseInfo[i].pszAction))
                {
                    // Not allowed playback.  Determine why.  Is it because we can never play it, or can we
                    // just not play it on this computer?
                    cbLength = sizeof(dwValue);
                    if (SUCCEEDED(pReader->GetDRMProperty(g_wszWMDRM_IsDRMCached, &dwType, (BYTE*)&dwValue, &cbLength)))
                    {
                        UINT uID = (dwValue == 0) ? IDS_DRM_PLAYNORIGHTS : IDS_DRM_PLAYNOPLAYHERE;
                        LoadString(m_hInst, IDS_DRM_PLAYNOPLAYHERE, szValue, ARRAYSIZE(szValue));
                        AppendLicenseInfo(pAVProps, szValue);
                    }
                }
                else
                {
                    // Regular case:
                    LoadString(m_hInst, g_rgLicenseInfo[i].pdrmrids->ridNoRights, szValue, ARRAYSIZE(szValue));
                    AppendLicenseInfo(pAVProps, szValue);
                }
            }
            // Now parse the more complex stuff.
            else if (ParseDRMStateData(&licenseState, g_rgLicenseInfo[i].pdrmrids, szValue, ARRAYSIZE(szValue), &dwCount, &ftStarts, &ftExpires) == S_OK)
            {
                AppendLicenseInfo(pAVProps, szValue);

                // Special case for playback action - assign these values:
                if (_IsActionPlayback(g_rgLicenseInfo[i].pszAction))
                {
                    pAVProps->ftPlayExpires = ftExpires;
                    pAVProps->ftPlayStarts = ftStarts;
                    pAVProps->dwPlayCount = dwCount;
                }
            }
        }
    }
}




/**
 * Extracts all the "slow" information at once from the file, and places it in the
 * SHMEDIA_AUDIOVIDEOPROPS struct.
 */
HRESULT CWMPropSetStg::_GetSlowPropertyInfo(SHMEDIA_AUDIOVIDEOPROPS *pAVProps)
{
    IWMReader *pReader;
    HRESULT hr = CreateReader(IID_PPV_ARG(IWMReader, &pReader));

    if (SUCCEEDED(hr))
    {
        ResetEvent(_hFileOpenEvent);

        IWMReaderCallback *pReaderCB;
        hr = QueryInterface(IID_PPV_ARG(IWMReaderCallback, &pReaderCB));
        if (SUCCEEDED(hr))
        {
            hr = pReader->Open(_wszFile, pReaderCB, NULL);
            pReaderCB->Release();

            if (SUCCEEDED(hr))
            {
                // Wait until file is ready.
                WaitForSingleObject(_hFileOpenEvent, INFINITE);

                // Indicate whether the content is protected under DRM or not.
                WCHAR szValue[128];
                LoadString(m_hInst, (_fProtectedContent ? IDS_DRM_ISPROTECTED : IDS_DRM_UNPROTECTED), szValue, ARRAYSIZE(szValue));
                AppendLicenseInfo(pAVProps, szValue);

                // Try to get license information, if this is protected content
                if (_fProtectedContent)
                {
                    IWMDRMReader *pDRMReader;
                    if (SUCCEEDED(pReader->QueryInterface(IID_PPV_ARG(IWMDRMReader, &pDRMReader))))
                    {
                        AcquireLicenseInformation(pDRMReader, pAVProps);
                        pDRMReader->Release();
                    }
                }

                // Let's interate through the streams,
                IWMProfile *pProfile;

                hr = pReader->QueryInterface(IID_PPV_ARG(IWMProfile, &pProfile));
                if (SUCCEEDED(hr))
                {
                    DWORD cStreams;

                    hr = pProfile->GetStreamCount(&cStreams);

                    if (SUCCEEDED(hr))
                    {
                        BOOL bFoundVideo = FALSE;
                        BOOL bFoundAudio = FALSE;

                        for (DWORD dw = 0; dw < cStreams; dw++)
                        {
                            IWMStreamConfig *pConfig;
                            hr = pProfile->GetStream(dw, &pConfig);

                            if (FAILED(hr))
                                break;
                        
                            GUID guidStreamType;
                            if (SUCCEEDED(pConfig->GetStreamType(&guidStreamType)))
                            {
                                if (guidStreamType == MEDIATYPE_Audio)
                                {
                                    GetAudioProperties(pConfig, pAVProps);
                                    bFoundAudio = TRUE;
                                }
                                else if (guidStreamType == MEDIATYPE_Video)
                                {
                                    GetVideoProperties(pConfig, pAVProps);
                                    bFoundVideo = TRUE;
                                }
                            }

                            pConfig->Release();

                            if (bFoundVideo && bFoundAudio)
                                break;
                        }
                    }

                    pProfile->Release();
                }
                pReader->Close();
            }
        }
        pReader->Release();
    }    

    return hr;
}

void GetVideoPropertiesFromBitmapHeader(BITMAPINFOHEADER *bmi, SHMEDIA_AUDIOVIDEOPROPS *pVideoProps)
{
    // bit depth
    pVideoProps->wBitDepth = bmi->biBitCount;

    // compression.
    // Is there an easy way to get this?
    // Maybe something with the codec info?
    // pVideoProps->pszCompression = new WCHAR[cch];

}

void GetVideoPropertiesFromHeader(VIDEOINFOHEADER *pvih, SHMEDIA_AUDIOVIDEOPROPS *pVideoProps)
{
    pVideoProps->cx = pvih->rcSource.right - pvih->rcSource.left;
    pVideoProps->cy = pvih->rcSource.bottom - pvih->rcSource.top;

    // Obtain frame rate
    // AvgTimePerFrame is in 100ns units.
    // ISSUE: This value is always zero.

    GetVideoPropertiesFromBitmapHeader(&pvih->bmiHeader, pVideoProps);
}

// Can't find def'n for VIDEOINFOHEADER2
/*
void GetVideoPropertiesFromHeader2(VIDEOINFOHEADER2 *pvih, SHMEDIA_AUDIOVIDEOPROPS *pVideoProps)
{
    pVideoProps->cx = pvih->rcSource.right - pvih->rcSource.left;
    pVideoProps->cy = pvih->rcSource.bottom - pvih->rcSource.top;

    GetVideoPropertiesFromBitmapHeader(&pvih->bmiHeader, pVideoProps);
}
*/

/**
 * assumes pConfig is a video stream.  assumes pVideoProps is zero-inited.
 */
void GetVideoProperties(IWMStreamConfig *pConfig, SHMEDIA_AUDIOVIDEOPROPS *pVideoProps)
{
    // bitrate
    pConfig->GetBitrate(&pVideoProps->dwBitrateVideo); // ignore result

    // stream name
    WORD cchStreamName;
    if (SUCCEEDED(pConfig->GetStreamName(NULL, &cchStreamName)))
    {
        pVideoProps->pszStreamNameVideo = new WCHAR[cchStreamName];
        if (pVideoProps->pszStreamNameVideo)
        {
            pConfig->GetStreamName(pVideoProps->pszStreamNameVideo, &cchStreamName); // ignore result
        }
    }

    // stream number
    pConfig->GetStreamNumber(&pVideoProps->wStreamNumberVideo); // ignore result

    // Try to get an IWMMediaProps interface.
    IWMMediaProps *pMediaProps;
    if (SUCCEEDED(pConfig->QueryInterface(IID_PPV_ARG(IWMMediaProps, &pMediaProps))))
    {
        DWORD cbType;

        // Make the first call to establish the size of buffer needed.
        if (SUCCEEDED(pMediaProps->GetMediaType(NULL, &cbType)))
        {
            // Now create a buffer of the appropriate size
            BYTE *pBuf = new BYTE[cbType];

            if (pBuf)
            {
                // Create an appropriate structure pointer to the buffer.
                WM_MEDIA_TYPE *pType = (WM_MEDIA_TYPE*) pBuf;

                // Call the method again to extract the information.
                if (SUCCEEDED(pMediaProps->GetMediaType(pType, &cbType)))
                {
                    // Pick up other more obscure information.
                    if (IsEqualGUID(pType->formattype, FORMAT_MPEGVideo))
                    {
                        GetVideoPropertiesFromHeader((VIDEOINFOHEADER*)&((MPEG1VIDEOINFO*)pType->pbFormat)->hdr, pVideoProps);
                    }
                    else if (IsEqualGUID(pType->formattype, FORMAT_VideoInfo))
                    {
                        GetVideoPropertiesFromHeader((VIDEOINFOHEADER*)pType->pbFormat, pVideoProps);
                    }

// No def'n available for VIDEOINFOHEADER2
//                    else if (IsEqualGUID(pType->formattype, Format_MPEG2Video))
//                    {
//                        GetVideoPropertiesFromHeader2((VIDEOINFOHEADER2*)&((MPEG1VIDEOINFO2*)&pType->pbFormat)->hdr);
//                    }
//                    else if (IsEqualGUID(pType->formattype, Format_VideoInfo2))
//                    {
//                        GetVideoPropertiesFromHeader2((VIDEOINFOHEADER2*)&pType->pbFormat);
//                    }
                }

                delete[] pBuf;
            }
        }

        pMediaProps->Release();
    }
}

void InitializeAudioVideoProperties(SHMEDIA_AUDIOVIDEOPROPS *pAVProps)
{
    pAVProps->dwPlayCount = -1; // Indicating no playcount.

    ASSERT(pAVProps->pszLicenseInformation == NULL);
    ASSERT(IsNullTime(&pAVProps->ftPlayStarts));
    ASSERT(IsNullTime(&pAVProps->ftPlayExpires));

    // Audio properties
    ASSERT(pAVProps->pszStreamNameAudio == NULL);
    ASSERT(pAVProps->wStreamNumberAudio == 0);
    ASSERT(pAVProps->nChannels == 0);
    ASSERT(pAVProps->dwBitrateAudio == 0);
    ASSERT(pAVProps->pszCompressionAudio == NULL);
    ASSERT(pAVProps->dwSampleRate == 0);
    ASSERT(pAVProps->lSampleSizeAudio == 0);

    // Video properties
    ASSERT(pAVProps->pszStreamNameVideo == NULL);
    ASSERT(pAVProps->wStreamNumberVideo == 0);
    ASSERT(pAVProps->wBitDepth == 0);
    ASSERT(pAVProps->dwBitrateVideo == 0);
    ASSERT(pAVProps->cx == 0);
    ASSERT(pAVProps->cy == 0);
    ASSERT(pAVProps->pszCompressionVideo == NULL);
    ASSERT(pAVProps->dwFrames == 0);
    ASSERT(pAVProps->dwFrameRate == 0);
}

void FreeAudioVideoProperties(SHMEDIA_AUDIOVIDEOPROPS *pAVProps)
{
    if (pAVProps->pszStreamNameVideo)
    {
        delete[] pAVProps->pszStreamNameVideo;
    }

    if (pAVProps->pszCompressionVideo)
    {
        delete[] pAVProps->pszCompressionVideo;
    }

    if (pAVProps->pszStreamNameAudio)
    {
        delete[] pAVProps->pszStreamNameAudio;
    }

    if (pAVProps->pszCompressionAudio)
    {
        delete[] pAVProps->pszCompressionAudio;
    }

    if (pAVProps->pszLicenseInformation)
    {
        CoTaskMemFree(pAVProps->pszLicenseInformation);
    }
}



/**
 * assumes pConfig is an audio stream.  assumes pAudioProps is zero-inited.
 */
void GetAudioProperties(IWMStreamConfig *pConfig, SHMEDIA_AUDIOVIDEOPROPS *pAudioProps)
{
    // bitrate
    pConfig->GetBitrate(&pAudioProps->dwBitrateAudio); // ignore result

    // stream name
    WORD cchStreamName;
    if (SUCCEEDED(pConfig->GetStreamName(NULL, &cchStreamName)))
    {
        pAudioProps->pszStreamNameAudio = new WCHAR[cchStreamName];
        if (pAudioProps->pszStreamNameAudio)
        {
            pConfig->GetStreamName(pAudioProps->pszStreamNameAudio, &cchStreamName); // ignore result
        }
    }

    // stream number
    pConfig->GetStreamNumber(&pAudioProps->wStreamNumberAudio); // ignore result

    // Try to get an IWMMediaProps interface.
    IWMMediaProps *pMediaProps;
    if (SUCCEEDED(pConfig->QueryInterface(IID_PPV_ARG(IWMMediaProps, &pMediaProps))))
    {
        DWORD cbType;

        // Make the first call to establish the size of buffer needed.
        if (SUCCEEDED(pMediaProps->GetMediaType(NULL, &cbType)))
        {
            // Now create a buffer of the appropriate size
            BYTE *pBuf = new BYTE[cbType];

            if (pBuf)
            {
                // Create an appropriate structure pointer to the buffer.
                WM_MEDIA_TYPE *pType = (WM_MEDIA_TYPE*)pBuf;

                // Call the method again to extract the information.
                if (SUCCEEDED(pMediaProps->GetMediaType(pType, &cbType)))
                {
                    if (pType->bFixedSizeSamples)  // Assuming lSampleSize only valid if fixed sample sizes
                    {
                        pAudioProps->lSampleSizeAudio = pType->lSampleSize;
                    }

                    // Pick up other more obscure information.
                    if (IsEqualGUID(pType->formattype, FORMAT_WaveFormatEx))
                    {
                        WAVEFORMATEX *pWaveFmt = (WAVEFORMATEX*)pType->pbFormat;
                        
                        pAudioProps->nChannels = pWaveFmt->nChannels;

                        pAudioProps->dwSampleRate = pWaveFmt->nSamplesPerSec;

                        // Setting this again if we got in here.
                        // For mp3s and wmas at least, this number is accurate, while pType->lSampleSize is bogus.
                        pAudioProps->lSampleSizeAudio = pWaveFmt->wBitsPerSample;
                    }

                    // How do we get compression?
                }

                delete[] pBuf;
            }
        }

        pMediaProps->Release();
    }
}


// Returns a *pHeaderInfo and success if it opened an editor and obtained a IWMHeaderInfo.
HRESULT CWMPropSetStg::_OpenHeaderInfo(IWMHeaderInfo **ppHeaderInfo, BOOL fReadingOnly)
{
    IWMMetadataEditor *pEditor;
    *ppHeaderInfo = NULL;

    // use the "editor" object as it is much MUCH faster than the reader
    HRESULT hr = WMCreateEditor(&pEditor);
    if (SUCCEEDED(hr))
    {
        IWMMetadataEditor2 *pmde2;
        if (fReadingOnly && SUCCEEDED(pEditor->QueryInterface(IID_PPV_ARG(IWMMetadataEditor2, &pmde2))))
        {
            hr = pmde2->OpenEx(_wszFile, GENERIC_READ, FILE_SHARE_READ | FILE_SHARE_DELETE);
            pmde2->Release();
        }
        else
        {
            hr = pEditor->Open(_wszFile);
        }

        if (SUCCEEDED(hr))
        {
            hr = pEditor->QueryInterface(IID_PPV_ARG(IWMHeaderInfo, ppHeaderInfo));

            if (FAILED(hr))
            {
                pEditor->Close();
            }
        }

        // Always release this particular ref to the editor. Don't need it anymore.
        pEditor->Release();

        // If we got here with SUCCEESS, it means we have an open editor, and a ref to the metadata editor.
        ASSERT((FAILED(hr) && (*ppHeaderInfo == NULL)) || (SUCCEEDED(hr) && (*ppHeaderInfo != NULL)));
    }

    return hr;
}


// Cleans up after _OpenHeaderInfo (closes the editor, etc...)
// fFlush Flush the header?
HRESULT _CloseHeaderInfo(IWMHeaderInfo *pHeaderInfo, BOOL fFlush)
{
    HRESULT hr = S_OK;

    if (pHeaderInfo)
    {
        // Close the editor.
        IWMMetadataEditor *pEditor;
        hr = pHeaderInfo->QueryInterface(IID_PPV_ARG(IWMMetadataEditor, &pEditor));
        ASSERT(SUCCEEDED(hr)); // QI is symmetric, so this always succeeds.

        if (SUCCEEDED(hr))
        {
            if (fFlush)
            {
                hr = pEditor->Flush();
            }

            pEditor->Close();
            pEditor->Release();
        }
        pHeaderInfo->Release();
    }

    return hr;
}


HRESULT CWMPropSetStg::FlushChanges(REFFMTID fmtid, LONG cNumProps, const COLMAP **pcmapInfo, PROPVARIANT *pVarProps, BOOL *pbDirtyFlags)
{
    if (!_bIsWritable)
        return STG_E_ACCESSDENIED;

    IWMHeaderInfo *phi;
    HRESULT hr = _OpenHeaderInfo(&phi, HI_READWRITE);
    if (SUCCEEDED(hr))
    {
        BOOL bFlush = FALSE;
        for (LONG i = 0; i < cNumProps; i++)
        {
            if (pbDirtyFlags[i])
            {
                HRESULT hrFlush = E_FAIL;
                if ((pcmapInfo[i]->vt == pVarProps[i].vt) || (VT_EMPTY == pVarProps[i].vt) || (VT_NULL == pVarProps[i].vt)) // VT_EMPTY/VT_NULL means remove property
                {
                    hrFlush = _FlushProperty(phi, pcmapInfo[i], &pVarProps[i]);
                }
                else
                {
                    PROPVARIANT var;
                    // Don't need to call PropVariantInit
                    hrFlush = PropVariantCopy(&var, &pVarProps[i]);
                    
                    if (SUCCEEDED(hrFlush))
                    {
                        hrFlush = CoerceProperty(&var, pcmapInfo[i]->vt);
                    
                        if (SUCCEEDED(hrFlush))
                        {
                            hrFlush = _FlushProperty(phi, pcmapInfo[i], &var);
                        }
                        PropVariantClear(&var);
                    }
                }

                if (FAILED(hrFlush))
                {
                    // Take note of any failure case, so we have something to return.
                    hr = hrFlush;
                }
            }
        }

        // Specify the flush bit if we succeeded in writing all the properties.
        HRESULT hrClose = _CloseHeaderInfo(phi, SUCCEEDED(hr));

        // If for some reason the Flush failed (in _CloseHeaderInfo), we'll fail.
        if (FAILED(hrClose))
        {
            hr = hrClose;
        }
    }
    return hr;
}

#define MAX_PROP_LENGTH 4096 // big enough for large props like lyrics.

HRESULT CWMPropSetStg::_FlushProperty(IWMHeaderInfo *phi, const COLMAP *pPInfo, PROPVARIANT *pvar)
{
    WMT_ATTR_DATATYPE datatype;
    BYTE buffer[MAX_PROP_LENGTH];
    WORD cbLen = ARRAYSIZE(buffer);
    HRESULT hr = E_FAIL;

    // Handle special properties first:
    // The Track property can exist as both the newer 1-based WM/TrackNumber, or the old
    // 0-based WM/Track
    if (IsEqualSCID(SCID_MUSIC_Track, *pPInfo->pscid))
    {
        if ((pvar->vt != VT_EMPTY) && (pvar->vt != VT_NULL))
        {
            ASSERT(pvar->vt = VT_UI4);

            if (pvar->ulVal > 0) // Track number must be greater than zero - don't want to overflow 0-based buffer
            {
                // Decrement the track number for writing to the old zero-based property
                pvar->ulVal--;

                HRESULT hr1 = WMTFromPropVariant(buffer, &cbLen, &datatype, pvar);
                if (SUCCEEDED(hr1))
                {
                    hr1 = phi->SetAttribute(0, TRACK_ZERO_BASED, datatype, buffer, cbLen);
                }

                pvar->ulVal++; // back to 1-based

                HRESULT hr2 = WMTFromPropVariant(buffer, &cbLen, &datatype, pvar);
                if (SUCCEEDED(hr2))
                {
                    hr2 = phi->SetAttribute(0, TRACK_ONE_BASED, datatype, buffer, cbLen);
                }
                // Return success if one of them worked.
                hr = (SUCCEEDED(hr1) || SUCCEEDED(hr2)) ? S_OK : hr1;

            }
        }
        else
        {
            hr = S_OK; // Someone tried to remove the track property, but we'll just fail silently, since we can't return a good error.
        }
    }
    else if (IsEqualSCID(SCID_DRM_Protected, *pPInfo->pscid))
    {
        // We should never get here. Protected is read only.
        hr = E_INVALIDARG;
    }
    else
    {
        // Regular properties.
        if ((pvar->vt == VT_EMPTY) || (pvar->vt == VT_NULL))
        {
            // Try to remove this property.
            // Note: Doesn't matter what we pass in for datatype, since we're providing NULL as the value.
            hr = phi->SetAttribute(0, _GetSDKName(pPInfo), WMT_TYPE_STRING, NULL, 0);

            // This is weak.
            // The WMSDK has a bug where if you try to remove a property that has already been removed, it will return
            // an error (ASF_E_NOTFOUND for wma files, E_FAIL for mp3s).  So for any errors, we'll return success.
            if (FAILED(hr))
            {
                hr = S_OK;
            }
        }
        else
        {
            hr = WMTFromPropVariant(buffer, &cbLen, &datatype, pvar);
            if (SUCCEEDED(hr))
            {
                hr = phi->SetAttribute(0, _GetSDKName(pPInfo), datatype, buffer, cbLen);
            }
        }
    }

    return hr;
}




// We need to check for protected content ahead of time.
HRESULT CWMPropSetStg::_PreCheck()
{
    HRESULT hr = _PopulatePropertySet();

    if (SUCCEEDED(hr))
    {
        if (_fProtectedContent && _bIsWritable)
        {
            _bIsWritable = FALSE;
            hr = STG_E_STATUS_COPY_PROTECTION_FAILURE;
        }
    }

    return hr;
}



HRESULT CWMPropSetStg::_PopulatePropertySet()
{
    HRESULT hr = E_FAIL;

    if (_wszFile[0] == 0)
    {
        hr =  STG_E_INVALIDNAME;
    } 
    else if (!_bHasBeenPopulated)
    {
        IWMHeaderInfo *phi;
        hr = _OpenHeaderInfo(&phi, HI_READONLY);
        if (SUCCEEDED(hr))
        {
            CEnumAllProps enumAllProps(_pPropStgInfo, _cPropertyStorages);
            const COLMAP *pPInfo = enumAllProps.Next();
            while (pPInfo)
            {
                LPCWSTR pszPropName = _GetSDKName(pPInfo);

                // Skip it if this is not one of the properties available quickly through
                // IWMHeaderInfo
                if (_IsHeaderProperty(pPInfo))
                {
                    // Get length of buffer needed for property value
                    WMT_ATTR_DATATYPE proptype;
                    UCHAR buf[MAX_PROP_LENGTH];
                    WORD cbData = sizeof(buf);
                    WORD wStreamNum = 0;

                    if (_PopulateSpecialProperty(phi, pPInfo) == S_FALSE)
                    {
                        // Not a special property

                        ASSERT(_GetSDKName(pPInfo)); // If not def'd as a special prop, must have an SDK name

                        // Note: this call will fail if the buffer is not big enough.  This means that
                        // we will not get values for potentially really large properties like lyrics.
                        hr = phi->GetAttributeByName(&wStreamNum, pszPropName, &proptype, buf, &cbData);
                        if (SUCCEEDED(hr))
                        {
                            hr = _SetPropertyFromWMT(pPInfo, proptype, cbData ? buf : NULL, cbData);
                        }
                        else
                        {
                            // Is it supposed to be a string property?  If so, provide a NULL string.
                            // ISSUE: we may want to revisit this policy, because of changes in docprop
                            if ((pPInfo->vt == VT_LPSTR) || (pPInfo->vt == VT_LPWSTR))
                            {
                                hr = _SetPropertyFromWMT(pPInfo, WMT_TYPE_STRING, NULL, 0);
                            }
                        }
                    }
                }
                pPInfo = enumAllProps.Next();
            }

            _PostProcess();

            _CloseHeaderInfo(phi, FALSE);
        }

        _bHasBeenPopulated = TRUE;

        // even if we couldn't create the metadata editor, we might be able to open a reader (which we'll do later)
        // So we can return S_OK here.  However, it would be nice to know ahead of time if opening a Reader
        // will work.  Oh well.
        _hrPopulated = S_OK;
    }

    return _hrPopulated; 
}

/**
 * Takes a quick peek at what the current value of this property is (does not
 * force a slow property to be populated), returning a reference to the actual
 * value (so no PropVariantClear is necessary)
 */
HRESULT CWMPropSetStg::_QuickLookup(const COLMAP *pPInfo, PROPVARIANT **ppvar)
{
    CMediaPropStorage *pps;
    HRESULT hr = _ResolveFMTID(pPInfo->pscid->fmtid, &pps);
    if (SUCCEEDED(hr))
    {
        PROPSPEC spec;
        spec.ulKind = PRSPEC_PROPID;
        spec.propid = pPInfo->pscid->pid;
        hr = pps->QuickLookup(&spec, ppvar);
    }

    return hr;
}


/**
 * Any special actions to take after initial property population.
 */
void CWMPropSetStg::_PostProcess()
{
    PROPVARIANT *pvar;
    // 1) If this file is protected, mark this. (we don't allow writes to protected files)
    if (SUCCEEDED(_QuickLookup(&g_CM_Protected, &pvar)))
    {
        if (pvar->vt == VT_BOOL)
        {
            _fProtectedContent = pvar->boolVal;
        }
    }

    // 2) Mark if Duration or Bitrate were retrieved.  If they weren't, then we'll consider them
    //    "slow" properties for this file.
    if (SUCCEEDED(_QuickLookup(&g_CM_Duration, &pvar)))
    {
        _fDurationSlow = (pvar->vt == VT_EMPTY);
    }

    if (SUCCEEDED(_QuickLookup(&g_CM_Bitrate, &pvar)))
    {
        _fBitrateSlow = (pvar->vt == VT_EMPTY);
    }
}

/**
 * Special properties need some additional action taken.
 *
 * Track: Use 1-based track # if available, 0-based otherwise.
 */
HRESULT CWMPropSetStg::_PopulateSpecialProperty(IWMHeaderInfo *phi, const COLMAP *pPInfo)
{
    WMT_ATTR_DATATYPE proptype;
    UCHAR buf[1024];    // big enough
    WORD cbData = sizeof(buf);
    WORD wStreamNum = 0;
    HRESULT hr;

    if (IsEqualSCID(SCID_MUSIC_Track, *pPInfo->pscid))
    {
        // Try to get 1-based track.
        hr = phi->GetAttributeByName(&wStreamNum, TRACK_ONE_BASED, &proptype, buf, &cbData);

        if (FAILED(hr))
        {
            // Nope, so try to get 0-based track and increment by one.
            cbData = sizeof(buf);
            hr = phi->GetAttributeByName(&wStreamNum, TRACK_ZERO_BASED, &proptype, buf, &cbData);

            if (SUCCEEDED(hr))
            {
                // We can't just increment the value so easily, because the value could be of type
                // WMT_TYPE_STRING or WMT_TYPE_DWORD (track # is string for some mp3's)
                // So we'll go through the same conversion process as happens when we call _SetPropertyFromWMT
                PROPVARIANT varTemp = {0};
                hr = PropVariantFromWMT(buf, cbData, proptype, &varTemp, VT_UI4);
                if (SUCCEEDED(hr))
                {
                    // Got a VT_UI4, we know how to increment that.
                    varTemp.ulVal++;

                    // Now convert back to a WMT_ATTR that we can provide to _SetPropertyFromWMT
                    hr = WMTFromPropVariant(buf, &cbData, &proptype, &varTemp);
                    PropVariantClear(&varTemp);
                }
            }
        }

        if (SUCCEEDED(hr))
        {
            _SetPropertyFromWMT(pPInfo, proptype, cbData ? buf : NULL, cbData);
        }
    }
    else
    {
        hr = S_FALSE;
    }

    return hr;
}

HRESULT CWMPropSetStg::_SetPropertyFromWMT(const COLMAP *pPInfo, WMT_ATTR_DATATYPE attrDatatype, UCHAR *pData, WORD cbSize)
{
    PROPSPEC spec;

    spec.ulKind = PRSPEC_PROPID;
    spec.propid = pPInfo->pscid->pid;

    PROPVARIANT var = {0};
    if (SUCCEEDED(PropVariantFromWMT(pData, cbSize, attrDatatype, &var, pPInfo->vt)))
    {
        _PopulateProperty(pPInfo, &var);
        PropVariantClear(&var);
    }

    return S_OK;    
}

// Retrieves the name used by the WMSDK in IWMHeaderInfo->Get/SetAttribute
LPCWSTR CWMPropSetStg::_GetSDKName(const COLMAP *pPInfo)
{
    for (int i = 0; i < ARRAYSIZE(g_rgSCIDToSDKName); i++)
    {
        if (IsEqualSCID(*pPInfo->pscid, *g_rgSCIDToSDKName[i].pscid))
            return g_rgSCIDToSDKName[i].pszSDKName;
    }
    
    return NULL;
}

// Is it one of the properties that can be accessed via IWMHeaderInfo?
BOOL CWMPropSetStg::_IsHeaderProperty(const COLMAP *pPInfo)
{
    for (int i = 0; i < ARRAYSIZE(g_rgSCIDToSDKName); i++)
    {
        if (IsEqualSCID(*pPInfo->pscid, *g_rgSCIDToSDKName[i].pscid))
            return TRUE;
    }
    
    return FALSE;
}










// Creates

// For audio files (mp3, wma, ....)
STDAPI CWMAPropSetStg_CreateInstance(IUnknown *punkOuter, IUnknown **ppunk, LPCOBJECTINFO poi)
{
    HRESULT hr;
    CWMAPropSetStg *pPropSetStg = new CWMAPropSetStg();
    if (pPropSetStg)
    {
        hr = pPropSetStg->Init();
        if (SUCCEEDED(hr))
        {
            hr = pPropSetStg->QueryInterface(IID_PPV_ARG(IUnknown, ppunk));
        }
        pPropSetStg->Release();
    }
    else
    {
        *ppunk = NULL;
        hr = E_OUTOFMEMORY;
    }
    return hr;
}

// For video/audio files (wmv, wma, ... )
STDAPI CWMVPropSetStg_CreateInstance(IUnknown *punkOuter, IUnknown **ppunk, LPCOBJECTINFO poi)
{
    HRESULT hr;
    CWMVPropSetStg *pPropSetStg = new CWMVPropSetStg();
    if (pPropSetStg)
    {
        hr = pPropSetStg->Init();
        if (SUCCEEDED(hr))
        {
            hr = pPropSetStg->QueryInterface(IID_PPV_ARG(IUnknown, ppunk));
        }
        pPropSetStg->Release();
    }
    else
    {
        *ppunk = NULL;
        hr = E_OUTOFMEMORY;
    }
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\mlang\attrstr.cpp ===
// AttrStr.cpp : Implementation of CMLStrAttrStrCommonAttrStrCommon
#include "private.h"

#ifdef NEWMLSTR

#include "attrstr.h"
#include "mlsbwalk.h"

/////////////////////////////////////////////////////////////////////////////
// CMLStrAttrStrCommon

CMLStrAttrStrCommon::CMLStrAttrStrCommon(void) :
    m_pMLStrBufW(NULL),
    m_pMLStrBufA(NULL),
    m_lBufFlags(0),
    m_cchBuf(0),
    m_locale(0),
    m_LockInfo(this)
{
    m_dwThreadID = ::GetCurrentThreadId();
}

CMLStrAttrStrCommon::~CMLStrAttrStrCommon(void)
{
    if (m_pMLStrBufW)
        m_pMLStrBufW->Release();
    if (m_pMLStrBufA)
        m_pMLStrBufA->Release();
}

HRESULT CMLStrAttrStrCommon::SetStrBufCommon(void* pMLStrX, long lDestPos, long lDestLen, UINT uCodePage, IMLangStringBufW* pSrcBufW, IMLangStringBufA* pSrcBufA, long* pcchActual, long* plActualLen)
{
    ASSERT_THIS;
    ASSERT_READ_PTR_OR_NULL(pSrcBufW);
    ASSERT_READ_PTR_OR_NULL(pSrcBufA);
    ASSERT(!pSrcBufW || !pSrcBufA); // Either one or both should be NULL
    ASSERT_WRITE_PTR_OR_NULL(pcchActual);
    ASSERT_WRITE_PTR_OR_NULL(plActualLen);

    HRESULT hr = CheckThread();
    CLock Lock(TRUE, this, hr);
    long lBufFlags = 0; // '= 0' for in case of both of pSrcBufW and pSrcBufA are NULL
    long cchBuf = 0;
    long cchDestPos;
    long cchDestLen;
    long lActualLen = 0;

    if (SUCCEEDED(hr) &&
        (!pSrcBufW || SUCCEEDED(hr = pSrcBufW->GetStatus(&lBufFlags, &cchBuf))) &&
        (!pSrcBufA || SUCCEEDED(hr = pSrcBufA->GetStatus(&lBufFlags, &cchBuf))) &&
        SUCCEEDED(hr = RegularizePosLen(&lDestPos, &lDestLen)) &&
        SUCCEEDED(hr = GetCCh(0, lDestPos, &cchDestPos)) &&
        SUCCEEDED(hr = GetCCh(cchDestPos, lDestLen, &cchDestLen)))
    {
        if (!cchDestPos && cchDestLen == GetBufCCh()) // Replacing entire string
        {
            IMLangStringBufW* const pOldBufW = GetMLStrBufW();
            IMLangStringBufA* const pOldBufA = GetMLStrBufA();

            if (pOldBufW)
                pOldBufW->Release();
            else if (pOldBufA)
                pOldBufA->Release();

            if (pSrcBufW)
                pSrcBufW->AddRef();
            else if (pSrcBufA)
                pSrcBufA->AddRef();

            SetMLStrBufW(pSrcBufW);
            SetMLStrBufA(pSrcBufA);
            SetCodePage(uCodePage);
            SetBufFlags(lBufFlags);
            SetBufCCh(cchBuf);

            if (plActualLen)
                hr = GetLen(0, GetBufCCh(), &lActualLen);
        }
        else
        {
            if (pSrcBufW)
            {
                CMLStrBufWalkW BufWalk(pSrcBufW, 0, cchBuf, (pcchActual || plActualLen));

                while (BufWalk.Lock(hr))
                {
                    long cchSet;
                    long lSetLen;

                    hr = ((IMLangStringWStr*)pMLStrX)->SetWStr(lDestPos, lDestLen, BufWalk.GetStr(), BufWalk.GetCCh(), &cchSet, (plActualLen) ? &lSetLen : NULL);
                    lActualLen += lSetLen;
                    BufWalk.Unlock(hr, cchSet);
                }

                cchBuf = BufWalk.GetDoneCCh();

                pSrcBufW->Release();
            }
            else if (pSrcBufA && pMLStrX)
            {
                CMLStrBufWalkA BufWalk(pSrcBufA, 0, cchBuf, (pcchActual || plActualLen));

                while (BufWalk.Lock(hr))
                {
                    long cchSet;
                    long lSetLen;

                    hr = ((IMLangStringAStr*)pMLStrX)->SetAStr(lDestPos, lDestLen, uCodePage, BufWalk.GetStr(), BufWalk.GetCCh(), &cchSet, (plActualLen) ? &lSetLen : NULL);
                    lActualLen += lSetLen;
                    BufWalk.Unlock(hr, cchSet);
                }

                cchBuf = BufWalk.GetDoneCCh();

                pSrcBufA->Release();
            }
            else
            {
                hr = GetMLStrAttr()->SetMLStr(lDestPos, lDestLen, NULL, 0, 0);
            }
        }
    }

    if (SUCCEEDED(hr))
    {
        if (pcchActual)
            *pcchActual = cchBuf;
        if (plActualLen)
            *plActualLen = lActualLen;
    }
    else
    {
        if (pcchActual)
            *pcchActual = 0;
        if (plActualLen)
            *plActualLen = 0;
    }

    return hr;
}

HRESULT CMLStrAttrStrCommon::UnlockWStrDirect(void* pKey, const void* pszSrc, long cchSrc, long* pcchActual, long* plActualLen)
{
    HRESULT hr;
    IMLangStringBufW* const pMLStrBufW = GetMLStrBufW();
    const long cchLockLen = GetLockInfo()->GetCChLen(pKey);

    if (SUCCEEDED(hr = pMLStrBufW->UnlockBuf((WCHAR*)pszSrc, 0, cchSrc)) &&
        (GetLockInfo()->GetFlags(pKey) & MLSTR_WRITE))
    {
        if (cchSrc < cchLockLen)
        {
            if (SUCCEEDED(hr = pMLStrBufW->Delete(GetLockInfo()->GetCChPos(pKey) + cchSrc, cchLockLen - cchSrc)))
                SetBufCCh(GetBufCCh() - (cchLockLen - cchSrc));
        }

        if (SUCCEEDED(hr) && plActualLen)
            hr = CalcLenW((WCHAR*)pszSrc, cchSrc, plActualLen);

        if (pcchActual)
            *pcchActual = cchSrc;
    }

    return hr;
}

HRESULT CMLStrAttrStrCommon::UnlockWStrIndirect(void* pKey, const void* pszSrc, long cchSrc, long* pcchActual, long* plActualLen)
{
    HRESULT hr = S_OK;

    if (GetLockInfo()->GetFlags(pKey) & MLSTR_WRITE)
    {
        CComQIPtr<IMLStrAttrWStr, &IID_IMLStrAttrWStr> pAttrWStr(GetMLStrAttr());
        ASSERT(pAttrWStr);
        hr = pAttrWStr->SetWStr(GetLockInfo()->GetPos(pKey), GetLockInfo()->GetLen(pKey), (WCHAR*)pszSrc, cchSrc, pcchActual, plActualLen);
    }

    ASSIGN_IF_FAILED(hr, MemFree((void*)pszSrc));

    return hr;
}

HRESULT CMLStrAttrStrCommon::UnlockAStrDirect(void* pKey, const void* pszSrc, long cchSrc, long* pcchActual, long* plActualLen)
{
    HRESULT hr;
    IMLangStringBufA* const pMLStrBufA = GetMLStrBufA();
    const long cchLockLen = GetLockInfo()->GetCChLen(pKey);

    if (SUCCEEDED(hr = pMLStrBufA->UnlockBuf((CHAR*)pszSrc, 0, cchSrc)) &&
        (GetLockInfo()->GetFlags(pKey) & MLSTR_WRITE))
    {
        if (cchSrc < cchLockLen)
        {
            if (SUCCEEDED(hr = pMLStrBufA->Delete(GetLockInfo()->GetCChPos(pKey) + cchSrc, cchLockLen - cchSrc)))
                SetBufCCh(GetBufCCh() - (cchLockLen - cchSrc));
        }

        if (SUCCEEDED(hr) && plActualLen)
            hr = CalcLenA(GetCodePage(), (CHAR*)pszSrc, cchSrc, plActualLen);

        if (pcchActual)
            *pcchActual = cchSrc;
    }

    return hr;
}

HRESULT CMLStrAttrStrCommon::UnlockAStrIndirect(void* pKey, const void* pszSrc, long cchSrc, long* pcchActual, long* plActualLen)
{
    HRESULT hr = S_OK;

    if (GetLockInfo()->GetFlags(pKey) & MLSTR_WRITE)
    {
        CComQIPtr<IMLStrAttrAStr, &IID_IMLStrAttrAStr> pAttrAStr(GetMLStrAttr());
        ASSERT(pAttrAStr);
        hr = pAttrAStr->SetAStr(GetLockInfo()->GetPos(pKey), GetLockInfo()->GetLen(pKey), GetLockInfo()->GetCodePage(pKey), (CHAR*)pszSrc, cchSrc, pcchActual, plActualLen);
    }

    ASSIGN_IF_FAILED(hr, MemFree((void*)pszSrc));

    return hr;
}

HRESULT CMLStrAttrStrCommon::UnlockStrCommon(const void* pszSrc, long cchSrc, long* pcchActual, long* plActualLen)
{
    HRESULT hr = CheckThread();
    void* pLockKey;
    long lSrcLen;

    if (SUCCEEDED(hr))
        hr = GetLockInfo()->Find(pszSrc, cchSrc, &pLockKey);

    if (SUCCEEDED(hr))
        hr = GetLockInfo()->Unlock(pLockKey, pszSrc, cchSrc, (pcchActual) ? &cchSrc : NULL, (plActualLen) ? &lSrcLen : NULL);

    if (SUCCEEDED(hr))
    {
        if (pcchActual)
            *pcchActual = cchSrc;
        if (plActualLen)
            *plActualLen = lSrcLen;
    }
    else
    {
        if (pcchActual)
            *pcchActual = 0;
        if (plActualLen)
            *plActualLen = 0;
    }

    return hr;
}

HRESULT CMLStrAttrStrCommon::PrepareMLStrBuf(void)
{
    if (GetMLStrBufW() || GetMLStrBufA())
        return S_OK;

    IMLangStringBufW* pBuf = new CMLStrAttrStrCommon::CMLStrBufStandardW;
    if (pBuf)
    {
        SetMLStrBufW(pBuf);
        return S_OK;
    }
    else
    {
        return E_OUTOFMEMORY;
    }
}

HRESULT CMLStrAttrStrCommon::RegularizePosLen(long* plPos, long* plLen)
{
    HRESULT hr;
    long lStrLen;

    if (SUCCEEDED(hr = GetLen(0, GetBufCCh(), &lStrLen)))
        hr = ::RegularizePosLen(lStrLen, plPos, plLen);

    return hr;
}

HRESULT CMLStrAttrStrCommon::GetCCh(long cchOffset, long lLen, long* pcchLen)
{
    if (GetMLStrBufW())
    {
        if (pcchLen)
            *pcchLen = lLen; // The number of characters is equal to the length
        return S_OK;
    }
    else if (GetMLStrBufA())
    {
        HRESULT hr = S_OK;
        CMLStrBufWalkA BufWalk(GetMLStrBufA(), cchOffset, GetBufCCh() - cchOffset);

        while (lLen > 0 && BufWalk.Lock(hr))
        {
            for (LPCSTR pszTemp = BufWalk.GetStr(); lLen > 0 && *pszTemp; lLen--)
                pszTemp = ::CharNextExA((WORD)GetCodePage(), pszTemp, 0);

            if (!*pszTemp)
                lLen = 0; // String terminated

            BufWalk.Unlock(hr);
        }

        if (pcchLen)
        {
            if (SUCCEEDED(hr))
                *pcchLen = BufWalk.GetDoneCCh();
            else
                *pcchLen = 0;
        }

        return hr;
    }
    else
    {
        if (pcchLen)
            *pcchLen = 0; // No string
        return S_OK;
    }
}

HRESULT CMLStrAttrStrCommon::GetLen(long cchOffset, long cchLen, long* plLen)
{
    if (GetMLStrBufW())
    {
        if (plLen)
            *plLen = cchLen; // The length is equal to the number of characters
        return S_OK;
    }
    else if (GetMLStrBufA())
    {
        HRESULT hr = S_OK;
        long lDoneLen = 0;
        CMLStrBufWalkA BufWalk(GetMLStrBufA(), cchOffset, cchLen);

        while (BufWalk.Lock(hr))
        {
            long lTempLen;

            hr = CalcLenA(GetCodePage(), BufWalk.GetStr(), BufWalk.GetCCh(), &lTempLen);
            if (hr == S_FALSE)
                cchLen = 0; // String terminated
            lDoneLen += lTempLen;

            BufWalk.Unlock(hr);
        }

        if (plLen)
        {
            if (SUCCEEDED(hr))
                *plLen = lDoneLen;
            else
                *plLen = 0;
        }

        return hr;
    }
    else
    {
        if (plLen)
            *plLen = 0; // No string
        return S_OK;
    }
}

HRESULT CMLStrAttrStrCommon::CalcLenA(UINT uCodePage, const CHAR* psz, long cchLen, long* plLen)
{
    long lLen = 0;
    const CHAR* const pszEnd = psz + cchLen;

    for (; psz < pszEnd && *psz; lLen++)
    {
        const CHAR* const pszNew = ::CharNextExA((WORD)uCodePage, psz, 0);

        if (pszNew > pszEnd) // Overrun out of buffer
            break;

        psz = pszNew;
    }

    if (plLen)
        *plLen = lLen;

    if (*psz)
        return S_OK;
    else
        return S_FALSE;
}

HRESULT CMLStrAttrStrCommon::CalcCChA(UINT uCodePage, const CHAR* psz, long lLen, long* pcchLen)
{
    const CHAR* const pszStart = psz;

    for (; lLen > 0 && *psz; lLen--)
        psz = ::CharNextExA((WORD)uCodePage, psz, 0);

    if (pcchLen)
        *pcchLen = psz - pszStart;

    if (*psz)
        return S_OK;
    else
        return S_FALSE;
}

HRESULT CMLStrAttrStrCommon::ConvAStrToWStr(UINT uCodePage, const CHAR* pszSrc, long cchSrc, WCHAR* pszDest, long cchDest, long* pcchActualA, long* pcchActualW, long* plActualLen)
{
    HRESULT hr = S_OK;
    long lWrittenLen;
    long cchWrittenA;

    long cchWrittenW = ::MultiByteToWideChar(uCodePage, 0, pszSrc, cchSrc, pszDest, (pszDest) ? cchDest : 0);
    if (!cchWrittenW)
        hr = E_FAIL; // NLS failed

    if ((pcchActualA || plActualLen) && SUCCEEDED(hr))
        hr = CalcLenW(pszDest, cchWrittenW, &lWrittenLen); // BOGUS: pszDest may be NULL

    if (pcchActualA && SUCCEEDED(hr))
        hr = CalcCChA(uCodePage, pszSrc, lWrittenLen, &cchWrittenA);

    if (SUCCEEDED(hr))
    {
        if (pcchActualA)
            *pcchActualA = cchWrittenA;
        if (pcchActualW)
            *pcchActualW = cchWrittenW;
        if (plActualLen)
            *plActualLen = lWrittenLen;
    }
    else
    {
        if (pcchActualA)
            *pcchActualA = 0;
        if (pcchActualW)
            *pcchActualW = 0;
        if (plActualLen)
            *plActualLen = 0;
    }

    return hr;
}

HRESULT CMLStrAttrStrCommon::ConvWStrToAStr(BOOL fCanStopAtMiddle, UINT uCodePage, const WCHAR* pszSrc, long cchSrc, CHAR* pszDest, long cchDest, long* pcchActualA, long* pcchActualW, long* plActualLen)
{
    HRESULT hr = S_OK;
    long lWrittenLen;
    long cchWrittenW;

    long cchWrittenA = ::WideCharToMultiByte(uCodePage, (fCanStopAtMiddle) ? 0 : WC_DEFAULTCHAR, pszSrc, cchSrc, pszDest, (pszDest) ? cchDest : 0, NULL, NULL);
    if (!cchWrittenA)
        hr = E_FAIL; // NLS failed

    if ((pcchActualW || plActualLen) && SUCCEEDED(hr))
    {
        if (pszDest)
            hr = CalcLenA(uCodePage, pszDest, cchWrittenA, &lWrittenLen);
        else
            hr = E_NOTIMPL; // Can't retrieve pcchActualW and plActualLen
    }

    if (pcchActualW && SUCCEEDED(hr))
        hr = CalcCChW(pszSrc, lWrittenLen, &cchWrittenW);

    if (SUCCEEDED(hr))
    {
        if (pcchActualA)
            *pcchActualA = cchWrittenA;
        if (pcchActualW)
            *pcchActualW = cchWrittenW;
        if (plActualLen)
            *plActualLen = lWrittenLen;
    }
    else
    {
        if (pcchActualA)
            *pcchActualA = 0;
        if (pcchActualW)
            *pcchActualW = 0;
        if (plActualLen)
            *plActualLen = 0;
    }

    return hr;
}

/////////////////////////////////////////////////////////////////////////////
// CMLStrAttrStrCommon::CLockInfo

HRESULT CMLStrAttrStrCommon::CLockInfo::UnlockAll(void)
{
    if (m_pLockArray)
    {
        for (int n = 0; n < MAX_LOCK_COUNT; n++)
        {
            if (m_pLockArray[n].m_psz)
                Unlock(&m_pLockArray[n], m_pLockArray[n].m_psz, m_pLockArray[n].m_cchLen, NULL, NULL);
        }
    }

    return S_OK;
}

HRESULT CMLStrAttrStrCommon::CLockInfo::Lock(PFNUNLOCKPROC pfnUnlockProc, long lFlags, UINT uCodePage, void* psz, long lPos, long lLen, long cchPos, long cchLen)
{
    HRESULT hr = S_OK;
    int nIndex;

    if (!m_pLockArray)
    {
        m_pLockArray = new CLockInfoEntry[MAX_LOCK_COUNT];

        if (m_pLockArray)
        {
            for (nIndex = 0; nIndex < MAX_LOCK_COUNT; nIndex++)
                m_pLockArray[nIndex].m_psz = NULL;
        }
        else
        {
            hr = E_OUTOFMEMORY;
        }
    }

    if (SUCCEEDED(hr))
    {
        for (nIndex = 0; nIndex < MAX_LOCK_COUNT; nIndex++)
        {
            if (!m_pLockArray[nIndex].m_psz)
                break;
        }
        if (nIndex >= MAX_LOCK_COUNT)
            hr = MLSTR_E_TOOMANYNESTOFLOCK;
    }

    if (SUCCEEDED(hr))
    {
        m_pLockArray[nIndex].m_psz = psz;
        m_pLockArray[nIndex].m_pfnUnlockProc = pfnUnlockProc;
        m_pLockArray[nIndex].m_lFlags = lFlags;
        m_pLockArray[nIndex].m_uCodePage = uCodePage;
        m_pLockArray[nIndex].m_lPos = lPos;
        m_pLockArray[nIndex].m_lLen = lLen;
        m_pLockArray[nIndex].m_cchPos = cchPos;
        m_pLockArray[nIndex].m_cchLen = cchLen;
    }

    return hr;
}

HRESULT CMLStrAttrStrCommon::CLockInfo::Find(const void* psz, long, void** ppKey)
{
    HRESULT hr = S_OK;
    int nIndex;

    if (m_pLockArray)
    {
        for (nIndex = 0; nIndex < MAX_LOCK_COUNT; nIndex++)
        {
            if (psz == m_pLockArray[nIndex].m_psz)
                break;
        }
    }
    if (!m_pLockArray || nIndex >= MAX_LOCK_COUNT)
        hr = E_INVALIDARG;

    if (ppKey)
    {
        if (SUCCEEDED(hr))
            *ppKey = &m_pLockArray[nIndex];
        else
            *ppKey = NULL;
    }

    return hr;
}

HRESULT CMLStrAttrStrCommon::CLockInfo::Unlock(void* pKey, const void* psz, long cch, long* pcchActual, long* plActualLen)
{
    CLockInfoEntry* const pEntry = (CLockInfoEntry*)pKey;
    HRESULT hr;

    if (!(pEntry->m_lFlags & MLSTR_WRITE))
    {
        cch = 0;
        if (plActualLen)
            *plActualLen = 0;
    }

    hr = (m_pCommon->*(pEntry->m_pfnUnlockProc))(pKey, psz, cch, pcchActual, plActualLen);

    if (SUCCEEDED(hr))
        hr = EndLock(pEntry->m_lFlags & MLSTR_WRITE);

    pEntry->m_psz = NULL; // Remove from lock array anyway

    if (FAILED(hr))
    {
        if (pcchActual)
            *pcchActual = 0;
        if (plActualLen)
            *plActualLen = 0;
    }

    return hr;
}

/////////////////////////////////////////////////////////////////////////////
// CMLStrAttrStrCommon::CMLStrBufStandardW

long CMLStrAttrStrCommon::CMLStrBufStandardW::RoundBufSize(long cchStr)
{
    for (int n = 8; n < 12; n++)
    {
        if (cchStr < (1L << n))
            break;
    }
    const long cchTick = (1L << (n - 4));
    return (cchStr + cchTick - 1) / cchTick * cchTick;
}

#endif // NEWMLSTR
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\mlang\attrstra.h ===
// AttrStrA.h : Declaration of the CMLStrAttrAStr

#ifndef __ATTRSTRA_H_
#define __ATTRSTRA_H_

#include "mlatl.h"
#include "attrstr.h"

/////////////////////////////////////////////////////////////////////////////
// CMLStrAttrAStr
class ATL_NO_VTABLE CMLStrAttrAStr :
    public CMLStrAttrStrCommon,
    public CComObjectRoot,
    public CComCoClass<CMLStrAttrAStr, &CLSID_CMLStrAttrAStr>,
    public IMLStrAttrAStr,
    public IMLangStringNotifySink,
    public IConnectionPointContainerImpl<CMLStrAttrAStr>,
    public IConnectionPointImpl<CMLStrAttrAStr, &IID_IMLStrAttrNotifySink>
{
    typedef CMLStrAttrAStr* POWNER;

public:
    CMLStrAttrAStr(void);

    DECLARE_NO_REGISTRY()

    BEGIN_COM_MAP(CMLStrAttrAStr)
        COM_INTERFACE_ENTRY(IMLStrAttr)
        COM_INTERFACE_ENTRY(IMLStrAttrAStr)
        COM_INTERFACE_ENTRY(IMLangStringNotifySink)
        COM_INTERFACE_ENTRY_IMPL(IConnectionPointContainer)
    END_COM_MAP()

    BEGIN_CONNECTION_POINT_MAP(CMLStrAttrAStr)
        CONNECTION_POINT_ENTRY(IID_IMLStrAttrNotifySink)
    END_CONNECTION_POINT_MAP()

public:
// IMLStrAttr
    STDMETHOD(SetClient)(/*[in]*/ IUnknown* pUnk);
    STDMETHOD(GetClient)(/*[out]*/ IUnknown** ppUnk);
    STDMETHOD(QueryAttr)(/*[in]*/ REFIID riid, /*[in]*/ LPARAM lParam, /*[out]*/ IUnknown** ppUnk, /*[out]*/ long* lConf);
    STDMETHOD(GetAttrInterface)(/*[out]*/ IID* pIID, /*[out]*/ LPARAM* plParam);
    STDMETHOD(SetMLStr)(/*[in]*/ long lDestPos, /*[in]*/ long lDestLen, /*[in]*/ IUnknown* pSrcMLStr, /*[in]*/ long lSrcPos, /*[in]*/ long lSrcLen);
// IMLStrAttrAStr
    STDMETHOD(SetAStr)(/*[in]*/ long lDestPos, /*[in]*/ long lDestLen, /*[in]*/ UINT uCodePage, /*[in, size_is(cchSrc)]*/ const CHAR* pszSrc, /*[in]*/ long cchSrc, /*[out]*/ long* pcchActual, /*[out]*/ long* plActualLen);
    STDMETHOD(SetStrBufA)(/*[in]*/ long lDestPos, /*[in]*/ long lDestLen, /*[in]*/ UINT uCodePage, /*[in]*/ IMLangStringBufA* pSrcBuf, /*[out]*/ long* pcchActual, /*[out]*/ long* plActualLen);
    STDMETHOD(GetAStr)(/*[in]*/ long lSrcPos, /*[in]*/ long lSrcLen, /*[in]*/ UINT uCodePageIn, /*[out]*/ UINT* puCodePageOut, /*[out, size_is(cchDest)]*/ CHAR* pszDest, /*[in]*/ long cchDest, /*[out]*/ long* pcchActual, /*[out]*/ long* plActualLen);
    STDMETHOD(GetStrBufA)(/*[in]*/ long lSrcPos, /*[in]*/ long lSrcMaxLen, /*[out]*/ UINT* puDestCodePage, /*[out]*/ IMLangStringBufA** ppDestBuf, /*[out]*/ long* plDestLen);
    STDMETHOD(LockAStr)(/*[in]*/ long lSrcPos, /*[in]*/ long lSrcLen, /*[in]*/ long lFlags, /*[in]*/ UINT uCodePageIn, /*[in]*/ long cchRequest, /*[out]*/ UINT* puCodePageOut, /*[out, size_is(,*pcchDest)]*/ CHAR** ppszDest, /*[out]*/ long* pcchDest, /*[out]*/ long* plDestLen);
    STDMETHOD(UnlockAStr)(/*[in, size_is(cchSrc)]*/ const CHAR* pszSrc, /*[in]*/ long cchSrc, /*[out]*/ long* pcchActual, /*[out]*/ long* plActualLen);
// IMLangStringNotifySink
    STDMETHOD(OnRegisterAttr)(/*[in]*/ IUnknown* pUnk);
    STDMETHOD(OnUnregisterAttr)(/*[in]*/ IUnknown* pUnk);
    STDMETHOD(OnRequestEdit)(/*[in]*/ long lDestPos, /*[in]*/ long lDestLen, /*[in]*/ long lNewLen, /*[in]*/ REFIID riid, /*[in]*/ LPARAM lParam, /*[in]*/ IUnknown* pUnk);
    STDMETHOD(OnCanceledEdit)(/*[in]*/ long lDestPos, /*[in]*/ long lDestLen, /*[in]*/ long lNewLen, /*[in]*/ REFIID riid, /*[in]*/ LPARAM lParam, /*[in]*/ IUnknown* pUnk);
    STDMETHOD(OnChanged)(/*[in]*/ long lDestPos, /*[in]*/ long lDestLen, /*[in]*/ long lNewLen, /*[in]*/ REFIID riid, /*[in]*/ LPARAM lParam, /*[in]*/ IUnknown* pUnk);

protected:
    ~CMLStrAttrAStr(void);
    IMLStrAttr* GetMLStrAttr(void) {return this;}
    HRESULT PrepareMLangCodePages(void)
    {
        HRESULT hr = S_OK;
        if (!m_pMLCPs)
            hr = ::CoCreateInstance(CLSID_CMultiLanguage, NULL, CLSCTX_INPROC_SERVER, IID_IMLangCodePages, (void**)&m_pMLCPs);
        return hr;
    }
    IMLangCodePages* GetMLangCodePages(void) const {return m_pMLCPs;}
    HRESULT StartEndConnectionMLStr(IUnknown* const pUnk, BOOL fStart);

    IMLangCodePages* m_pMLCPs;
    IMLangString* m_pMLStr;
    DWORD m_dwMLStrCookie;
};

#endif //__ATTRSTRA_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\mlang\attrstr.h ===
// AttrStr.h : Declaration of the CMLStrAttrStrCommon

#ifndef __ATTRSTR_H_
#define __ATTRSTR_H_

#include "mlatl.h"
#include "mlstrbuf.h"

/////////////////////////////////////////////////////////////////////////////
// CMLStrAttrStrCommon
class CMLStrAttrStrCommon
{
    typedef HRESULT (CMLStrAttrStrCommon::*PFNUNLOCKPROC)(void* pKey, const void* pszSrc, long cchSrc, long* pcchActual, long* plActualLen);

public:
    CMLStrAttrStrCommon(void);

protected:
    class CLockInfo
    {
    protected:
        class CLockInfoEntry
        {
        public:
            void* m_psz;
            PFNUNLOCKPROC m_pfnUnlockProc;
            long m_lFlags;
            UINT m_uCodePage;
            long m_lPos;
            long m_lLen;
            long m_cchPos;
            long m_cchLen;
        };

    public:
        CLockInfo(CMLStrAttrStrCommon* pCommon) : m_pCommon(pCommon)
        {
            m_nLockCount = 0;
            m_pLockArray = NULL;
        }
        ~CLockInfo(void)
        {
            UnlockAll();
        }
        HRESULT UnlockAll(void);
        HRESULT StartLock(BOOL fWrite)
        {
            if (fWrite && !m_nLockCount)
                m_nLockCount = -1; // Negative means write lock
            else if (!fWrite && m_nLockCount >= 0)
                m_nLockCount++;
            else
                return MLSTR_E_ACCESSDENIED;
            return S_OK;
        }
        HRESULT EndLock(BOOL fWrite)
        {
            ASSERT(m_nLockCount);
            if (fWrite)
                m_nLockCount = 0;
            else
                m_nLockCount--;
            return S_OK;
        }
        HRESULT Lock(PFNUNLOCKPROC pfnUnlockProc, long lFlags, UINT uCodePage, void* psz, long lPos, long lLen, long cchPos, long cchLen);
        HRESULT Find(const void* psz, long cch, void** ppKey);
        HRESULT Unlock(void* pKey, const void* psz, long cch, long* pcchActual, long* plActualLen);
        long GetFlags(void* pKey) {return ((CLockInfoEntry*)pKey)->m_lFlags;}
        UINT GetCodePage(void* pKey) {return ((CLockInfoEntry*)pKey)->m_uCodePage;}
        long GetPos(void* pKey) {return ((CLockInfoEntry*)pKey)->m_lPos;}
        long GetLen(void* pKey) {return ((CLockInfoEntry*)pKey)->m_lLen;}
        long GetCChPos(void* pKey) {return ((CLockInfoEntry*)pKey)->m_cchPos;}
        long GetCChLen(void* pKey) {return ((CLockInfoEntry*)pKey)->m_cchLen;}

    protected:
        CMLStrAttrStrCommon* const m_pCommon;
        int m_nLockCount;
        CLockInfoEntry* m_pLockArray;
    };

    class CMLStrBufStandardW : public CMLStrBufW
    {
    protected:
        LPVOID MemAlloc(ULONG cb) {return ::CoTaskMemAlloc(cb);}
        LPVOID MemRealloc(LPVOID pv, ULONG cb) {return ::CoTaskMemRealloc(pv, cb);}
        void MemFree(LPVOID pv) {::CoTaskMemFree(pv);}
        long RoundBufSize(long cchStr);
    };

public:
    class CLock
    {
    public:
        CLock(BOOL fWrite, CMLStrAttrStrCommon* pCommon, HRESULT& hr) : m_fWrite(fWrite), m_pCommon(pCommon) {m_fLocked = (SUCCEEDED(hr) && SUCCEEDED(hr = m_pCommon->GetLockInfo()->StartLock(m_fWrite)));}
        ~CLock(void) {if (m_fLocked) m_pCommon->GetLockInfo()->EndLock(m_fWrite);}
        HRESULT FallThrough(void) {m_fLocked = FALSE; return S_OK;} // Don't call EndLock in destructor
    protected:
        const BOOL m_fWrite;
        CMLStrAttrStrCommon* const m_pCommon;
        BOOL m_fLocked;
    };

    HRESULT PrepareMLStrBuf(void);
    HRESULT SetStrBufCommon(void* pMLStrX, long lDestPos, long lDestLen, UINT uCodePage, IMLangStringBufW* pSrcBufW, IMLangStringBufA* pSrcBufA, long* pcchActual, long* plActualLen);
    HRESULT UnlockStrCommon(const void* pszSrc, long cchSrc, long* pcchActual, long* plActualLen);
    HRESULT CheckThread(void) {return (m_dwThreadID == ::GetCurrentThreadId()) ? S_OK : E_FAIL;}
    HRESULT RegularizePosLen(long* plPos, long* plLen);
    HRESULT GetLen(long cchOffset, long cchLen, long* plLen);
    HRESULT GetCCh(long cchOffset, long lLen, long* pcchLen);
    static HRESULT CalcLenW(const WCHAR*, long cchLen, long* plLen) {if (plLen) *plLen = cchLen; return S_OK;}
    static HRESULT CalcLenA(UINT uCodePage, const CHAR*,  long cchLen, long* plLen);
    static HRESULT CalcCChW(const WCHAR*, long lLen, long* pcchLen) {if (pcchLen) *pcchLen = lLen; return S_OK;}
    static HRESULT CalcCChA(UINT uCodePage, const CHAR*,  long lLen, long* pcchLen);
    static HRESULT CalcBufSizeW(long lLen, long* pcchSize) {if (pcchSize) *pcchSize = lLen; return S_OK;}
    static HRESULT CalcBufSizeA(long lLen, long* pcchSize) {if (pcchSize) *pcchSize = lLen * 2; return S_OK;}
    static HRESULT ConvAStrToWStr(UINT uCodePage, const CHAR* pszSrc, long cchSrc, WCHAR* pszDest, long cchDest, long* pcchActualA, long* pcchActualW, long* plActualLen);
    static HRESULT ConvWStrToAStr(BOOL fCanStopAtMiddle, UINT uCodePage, const WCHAR* pszSrc, long cchSrc, CHAR* pszDest, long cchDest, long* pcchActualA, long* pcchActualW, long* plActualLen);
    IMLangStringBufW* GetMLStrBufW(void) const {return m_pMLStrBufW;}
    void SetMLStrBufW(IMLangStringBufW* pBuf) {m_pMLStrBufW = pBuf;}
    IMLangStringBufA* GetMLStrBufA(void) const {return m_pMLStrBufA;}
    void SetMLStrBufA(IMLangStringBufA* pBuf) {m_pMLStrBufA = pBuf;}
    UINT GetCodePage(void) const {return m_uCodePage;}
    void SetCodePage(UINT uCodePage) {m_uCodePage = uCodePage;}
    long GetBufFlags(void) const {return m_lBufFlags;}
    void SetBufFlags(long lBufFlags) {m_lBufFlags = lBufFlags;}
    long GetBufCCh(void) const {return m_cchBuf;}
    void SetBufCCh(long cchBuf) {m_cchBuf = cchBuf;}
    LCID GetLocale(void) const {return m_locale;}
    void SetLocale(LCID locale) {m_locale = locale;}
    CLockInfo* GetLockInfo(void) {return &m_LockInfo;}
    HRESULT MemAlloc(ULONG cb, void** ppv) {void* pv = ::CoTaskMemAlloc(cb); if (ppv) *ppv = pv; return (pv) ? S_OK : E_OUTOFMEMORY;}
    HRESULT MemFree(void* pv) {::CoTaskMemFree(pv); return S_OK;}
    HRESULT UnlockWStrDirect(void* pKey, const void* pszSrc, long cchSrc, long* pcchActual, long* plActualLen);
    HRESULT UnlockWStrIndirect(void* pKey, const void* pszSrc, long cchSrc, long* pcchActual, long* plActualLen);
    HRESULT UnlockAStrDirect(void* pKey, const void* pszSrc, long cchSrc, long* pcchActual, long* plActualLen);
    HRESULT UnlockAStrIndirect(void* pKey, const void* pszSrc, long cchSrc, long* pcchActual, long* plActualLen);

protected:
    ~CMLStrAttrStrCommon(void);
    virtual IMLStrAttr* GetMLStrAttr(void) = 0;

    DWORD m_dwThreadID;

    IMLangStringBufW* m_pMLStrBufW;
    IMLangStringBufA* m_pMLStrBufA;
    UINT m_uCodePage;
    long m_lBufFlags;
    long m_cchBuf;

    LCID m_locale;

    CLockInfo m_LockInfo;
};

#endif //__ATTRSTR_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\mlang\attrloc.h ===
// AttrLoc.h : Declaration of the CMLStrAttrLocale

#ifndef __ATTRLOC_H_
#define __ATTRLOC_H_

#include "mlatl.h"

/////////////////////////////////////////////////////////////////////////////
// CMLStrAttrLocale
class ATL_NO_VTABLE CMLStrAttrLocale :
    public CComObjectRoot,
    public CComCoClass<CMLStrAttrLocale, &CLSID_CMLStrAttrLocale>,
    public IConnectionPointContainerImpl<CMLStrAttrLocale>,
    public IConnectionPointImpl<CMLStrAttrLocale, &IID_IMLStrAttrNotifySink>,
    public IMLStrAttrLocale
{
public:
    CMLStrAttrLocale();

    DECLARE_NO_REGISTRY()

    BEGIN_COM_MAP(CMLStrAttrLocale)
        COM_INTERFACE_ENTRY(IMLStrAttr)
        COM_INTERFACE_ENTRY(IMLStrAttrLong)
        COM_INTERFACE_ENTRY(IMLStrAttrLocale)
        COM_INTERFACE_ENTRY_IMPL(IConnectionPointContainer)
    END_COM_MAP()

    BEGIN_CONNECTION_POINT_MAP(CMLStrAttrLocale)
        CONNECTION_POINT_ENTRY(IID_IMLStrAttrNotifySink)
    END_CONNECTION_POINT_MAP()

public:
// IMLStrAttr
    STDMETHOD(SetClient)(/*[in]*/ IUnknown* pUnk);
    STDMETHOD(GetClient)(/*[out]*/ IUnknown** ppUnk);
    STDMETHOD(QueryAttr)(/*[in]*/ REFIID riid, /*[in]*/ LPARAM lParam, /*[out]*/ IUnknown** ppUnk, /*[out]*/ long* lConf);
    STDMETHOD(GetAttrInterface)(/*[out]*/ IID* pIID, /*[out]*/ LPARAM* plParam);
    STDMETHOD(SetMLStr)(/*[in]*/ long lDestPos, /*[in]*/ long lDestLen, /*[in]*/ IUnknown* pSrcMLStr, /*[in]*/ long lSrcPos, /*[in]*/ long lSrcLen);
// IMLStrAttrLong
    STDMETHOD(SetLong)(/*[in]*/ long lDestPos, /*[in]*/ long lDestLen, /*[in]*/ long lValue);
    STDMETHOD(GetLong)(/*[in]*/ long lSrcPos, /*[in]*/ long lSrcLen, /*[out]*/ long* plValue, /*[out]*/ long* plActualPos, /*[out]*/ long* plActualLen);
// IMLStrAttrLocale
    // Nothing

protected:
    long m_lLen;
    LCID m_lcid;
};

#endif //__ATTRLOC_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\mlang\attrstra.cpp ===
// AttrStrA.cpp : Implementation of CMLStrAttrAStr
#include "private.h"

#ifdef NEWMLSTR

#include "attrstra.h"
#include "mlswalk.h"
#include "mlsbwalk.h"

/////////////////////////////////////////////////////////////////////////////
// CMLStrAttrAStr

CMLStrAttrAStr::CMLStrAttrAStr(void) :
    m_pMLCPs(NULL),
    m_pMLStr(NULL)
{
}

CMLStrAttrAStr::~CMLStrAttrAStr(void)
{
    VERIFY(SetClient(NULL)); // Clean m_pMLStr
    if (m_pMLCPs)
        m_pMLCPs->Release();
}

STDMETHODIMP CMLStrAttrAStr::SetClient(IUnknown* pUnk)
{
    ASSERT_THIS;
    ASSERT_READ_PTR_OR_NULL(pUnk);

    HRESULT hr = S_OK;

    // Release old client
    IMLangString* const pMLStr = m_pMLStr;
    if (pMLStr && SUCCEEDED(hr = StartEndConnectionMLStr(pMLStr, FALSE))) // End connection to MLStr
    {
        pMLStr->Release();
        m_pMLStr = NULL;
    }

    // Set new client
    if (SUCCEEDED(hr) && pUnk) // pUnk is given
    {
        ASSERT(!m_pMLStr);
        if (SUCCEEDED(hr = pUnk->QueryInterface(IID_IMLangString, (void**)&m_pMLStr)))
        {
            ASSERT_READ_PTR(m_pMLStr);
            if (FAILED(hr = StartEndConnectionMLStr(pUnk, TRUE))) // Start connection to MLStr
            {
                m_pMLStr->Release();
                m_pMLStr = NULL;
            }
        }
    }

    return hr;
}

HRESULT CMLStrAttrAStr::StartEndConnectionMLStr(IUnknown* const pUnk, BOOL fStart)
{
    ASSERT_THIS;
    ASSERT_READ_PTR(pUnk);

    HRESULT hr;
    IConnectionPointContainer* pCPC;

    if (SUCCEEDED(hr = pUnk->QueryInterface(IID_IConnectionPointContainer, (void**)&pCPC)))
    {
        ASSERT_READ_PTR(pCPC);

        IConnectionPoint* pCP;

        if (SUCCEEDED(hr = pCPC->FindConnectionPoint(IID_IMLangStringNotifySink, &pCP)))
        {
            ASSERT_READ_PTR(pCP);

            if (fStart)
                hr = pCP->Advise((IMLStrAttr*)this, &m_dwMLStrCookie);
            else
                hr = pCP->Unadvise(m_dwMLStrCookie);

            pCP->Release();
        }

        pCPC->Release();
    }

    return hr;
}

STDMETHODIMP CMLStrAttrAStr::GetClient(IUnknown** ppUnk)
{
    ASSERT_THIS;
    ASSERT_WRITE_PTR_OR_NULL(ppUnk);

    if (ppUnk)
    {
        IUnknown* const pUnk = m_pMLStr;
        *ppUnk = pUnk;
        if (pUnk)
            pUnk->AddRef();
    }

    return S_OK;
}

STDMETHODIMP CMLStrAttrAStr::QueryAttr(REFIID riid, LPARAM lParam, IUnknown** ppUnk, long* lConf)
{
    return E_NOTIMPL; // CMLStrAttrAStr::QueryAttr()
}

STDMETHODIMP CMLStrAttrAStr::GetAttrInterface(IID* pIID, LPARAM* plParam)
{
    return E_NOTIMPL; // CMLStrAttrAStr::GetAttrInterface()
}

STDMETHODIMP CMLStrAttrAStr::SetMLStr(long lDestPos, long lDestLen, IUnknown* pSrcMLStr, long lSrcPos, long lSrcLen)
{
    return E_NOTIMPL; // CMLStrAttrAStr::SetMLStr()
}

STDMETHODIMP CMLStrAttrAStr::SetAStr(long lDestPos, long lDestLen, UINT uCodePage, const CHAR* pszSrc, long cchSrc, long* pcchActual, long* plActualLen)
{
    ASSERT_THIS;
    ASSERT_READ_BLOCK(pszSrc, cchSrc);
    ASSERT_WRITE_PTR_OR_NULL(pcchActual);
    ASSERT_WRITE_PTR_OR_NULL(plActualLen);

    HRESULT hr;

    // Fire OnRequestEdit
    IEnumConnections* pEnumConn;

    if (SUCCEEDED(hr = EnumConnections(&pEnumConn)))
    {
        ASSERT_READ_PTR(pEnumConn);

        CONNECTDATA cd;

        while ((hr = pEnumConn->Next(1, &cd, NULL)) == S_OK)
        {
            IMLStrAttrNotifySink* pSink;

            if (SUCCEEDED(hr = cd.pUnk->QueryInterface(IID_IMLStrAttrNotifySink, (void**)&pSink)))
            {
                // TODO: Regularize before fire OnRequestEdit
                // TODO: And, calculate lNewLen,
                hr = pSink->OnRequestEdit(lDestPos, lDestLen, /*lNewLen*/0, IID_IMLStrAttrAStr, 0, (IMLStrAttr*)this);
                pSink->Release();
            }
        }

        pEnumConn->Release();
    }

    hr = CheckThread();
    CLock Lock(TRUE, this, hr);
    long cchDestPos;
    long cchDestLen;
    long cchActual;
    long lActualLen;

    if (SUCCEEDED(hr) && (GetBufFlags() & MLSTR_WRITE))
        hr = E_INVALIDARG; // Not writable StrBuf; TODO: Replace StrBuf in this case if allowed

    if (SUCCEEDED(hr) &&
        SUCCEEDED(hr = PrepareMLStrBuf()) &&
        SUCCEEDED(hr = RegularizePosLen(&lDestPos, &lDestLen)) &&
        SUCCEEDED(hr = GetCCh(0, lDestPos, &cchDestPos)) &&
        SUCCEEDED(hr = GetCCh(cchDestPos, lDestLen, &cchDestLen)))
    {
        IMLangStringBufA* const pMLStrBufA = GetMLStrBufA();

        if (uCodePage == CP_ACP)
            uCodePage = g_uACP;

        if (pMLStrBufA && uCodePage == GetCodePage())
        {
            if (cchSrc > cchDestLen)
            {
                hr = pMLStrBufA->Insert(cchDestPos, cchSrc - cchDestLen, (pcchActual || plActualLen) ? &cchSrc : NULL);
                cchSrc += cchDestLen;
            }
            else if  (cchSrc < cchDestLen)
            {
                hr = pMLStrBufA->Delete(cchDestPos, cchDestLen - cchSrc);
            }

            CMLStrBufWalkA BufWalk(pMLStrBufA, cchDestPos, cchSrc, (pcchActual || plActualLen));

            lActualLen = 0;
            while (BufWalk.Lock(hr))
            {
                long lLen;

                if (plActualLen)
                    hr = CalcLenA(uCodePage, pszSrc, BufWalk.GetCCh(), &lLen);

                if (SUCCEEDED(hr))
                {
                    lActualLen += lLen;
                    ::memcpy(BufWalk.GetStr(), pszSrc, sizeof(CHAR) * BufWalk.GetCCh());
                    pszSrc += BufWalk.GetCCh();
                }

                BufWalk.Unlock(hr);
            }

            cchActual = BufWalk.GetDoneCCh();
        }
        else
        {
            IMLangStringWStr* pMLStrW;

            if (SUCCEEDED(hr = ((IMLStrAttr*)this)->QueryInterface(IID_IMLangStringWStr, (void**)&pMLStrW)))
            {
                CMLStrWalkW StrWalk(pMLStrW, lDestPos, lDestLen, MLSTR_WRITE, (pcchActual || plActualLen));

                cchActual = 0;
                lActualLen = 0;
                while (StrWalk.Lock(hr))
                {
                    long cchWrittenA;
                    long lWrittenLen;

                    if (SUCCEEDED(hr = ConvAStrToWStr(uCodePage, pszSrc, cchSrc, StrWalk.GetStr(), StrWalk.GetCCh(), &cchWrittenA, NULL, &lWrittenLen)))
                    {
                        pszSrc += cchWrittenA;
                        cchSrc -= cchWrittenA;
                        cchActual += cchWrittenA;
                        lActualLen += lWrittenLen;
                    }

                    StrWalk.Unlock(hr, lWrittenLen);
                }

                pMLStrW->Release();
            }
        }
    }

    if (SUCCEEDED(hr))
    {
        if (pcchActual)
            *pcchActual = cchActual;
        if (plActualLen)
            *plActualLen = lActualLen;
    }
    else
    {
        if (pcchActual)
            *pcchActual = 0;
        if (plActualLen)
            *plActualLen = 0;
    }
    return hr;
}

STDMETHODIMP CMLStrAttrAStr::SetStrBufA(long lDestPos, long lDestLen, UINT uCodePage, IMLangStringBufA* pSrcBuf, long* pcchActual, long* plActualLen)
{
    ASSERT_THIS;
    return SetStrBufCommon(this, lDestPos, lDestLen, uCodePage, NULL, pSrcBuf, pcchActual, plActualLen);
}

STDMETHODIMP CMLStrAttrAStr::GetAStr(long lSrcPos, long lSrcLen, UINT uCodePageIn, UINT* puCodePageOut, CHAR* pszDest, long cchDest, long* pcchActual, long* plActualLen)
{
    ASSERT_THIS;
    ASSERT_WRITE_PTR_OR_NULL(puCodePageOut);
    ASSERT_WRITE_BLOCK_OR_NULL(pszDest, cchDest);
    ASSERT_WRITE_PTR_OR_NULL(pcchActual);
    ASSERT_WRITE_PTR_OR_NULL(plActualLen);

    HRESULT hr = CheckThread();
    CLock Lock(FALSE, this, hr);
    long cchSrcPos;
    long cchSrcLen;
    long cchActual;
    long lActualLen;

    if (SUCCEEDED(hr) &&
        SUCCEEDED(hr = RegularizePosLen(&lSrcPos, &lSrcLen)) &&
        SUCCEEDED(hr = GetCCh(0, lSrcPos, &cchSrcPos)) &&
        SUCCEEDED(hr = GetCCh(cchSrcPos, lSrcLen, &cchSrcLen)))
    {
        IMLangStringBufA* const pMLStrBufA = GetMLStrBufA();

        if (pszDest)
            cchActual = min(cchSrcLen, cchDest);
        else
            cchActual = cchSrcLen;

        if (uCodePageIn == CP_ACP)
            uCodePageIn = g_uACP;

        if (pMLStrBufA && (puCodePageOut || uCodePageIn == GetCodePage()))
        {
            uCodePageIn = GetCodePage();

            CMLStrBufWalkA BufWalk(pMLStrBufA, cchSrcPos, cchActual, (pcchActual || plActualLen));

            lActualLen = 0;
            while (BufWalk.Lock(hr))
            {
                long lLen;

                if (plActualLen)
                    hr = CalcLenA(uCodePageIn, BufWalk.GetStr(), BufWalk.GetCCh(), &lLen);

                if (SUCCEEDED(hr))
                {
                    lActualLen += lLen;

                    if (pszDest)
                    {
                        ::memcpy(pszDest, BufWalk.GetStr(), sizeof(CHAR) * BufWalk.GetCCh());
                        pszDest += BufWalk.GetCCh();
                    }
                }

                BufWalk.Unlock(hr);
            }

            cchActual = BufWalk.GetDoneCCh();
        }
        else
        {
            IMLangStringWStr* pMLStrW;

            if (SUCCEEDED(hr = m_pMLStr->QueryInterface(IID_IMLangStringWStr, (void**)&pMLStrW)))
            {
                BOOL fDontHaveCodePageIn = (puCodePageOut != 0);
                CMLStrWalkW StrWalk(pMLStrW, lSrcPos, lSrcLen, (pcchActual || plActualLen));

                cchActual = 0;
                while (StrWalk.Lock(hr))
                {
                    LCID locale;
                    UINT uLocaleCodePage;
                    DWORD dwLocaleCodePages;
                    DWORD dwStrCodePages;
                    long cchWritten;
                    long lWrittenLen;

                    if (fDontHaveCodePageIn &&
                        SUCCEEDED(hr = pMLStrW->GetLocale(lSrcPos, lSrcLen, &locale, NULL, NULL)) &&
                        SUCCEEDED(hr = ::LocaleToCodePage(locale, &uLocaleCodePage)) &&
                        SUCCEEDED(hr = PrepareMLangCodePages()) &&
                        SUCCEEDED(hr = GetMLangCodePages()->CodePageToCodePages(uLocaleCodePage, &dwLocaleCodePages)) &&
                        SUCCEEDED(hr = GetMLangCodePages()->GetStrCodePages(StrWalk.GetStr(), StrWalk.GetCCh(), dwLocaleCodePages, &dwStrCodePages, NULL)))
                    {
                        fDontHaveCodePageIn = FALSE;
                        hr = GetMLangCodePages()->CodePagesToCodePage(dwStrCodePages, uLocaleCodePage, &uCodePageIn);
                    }

                    if (SUCCEEDED(hr) &&
                        SUCCEEDED(hr = ConvWStrToAStr(pcchActual || plActualLen, uCodePageIn, StrWalk.GetStr(), StrWalk.GetCCh(), pszDest, cchDest, &cchWritten, NULL, &lWrittenLen)))
                    {
                        pszDest += cchWritten;
                        cchDest -= cchWritten;
                        cchActual += cchWritten;
                    }

                    StrWalk.Unlock(hr, lWrittenLen);
                }

                lActualLen = StrWalk.GetDoneLen();

                pMLStrW->Release();
            }
        }
    }

    if (SUCCEEDED(hr))
    {
        if (puCodePageOut)
            *puCodePageOut = uCodePageIn;
        if (pcchActual)
            *pcchActual = cchActual;
        if (plActualLen)
            *plActualLen = lActualLen;
    }
    else
    {
        if (puCodePageOut)
            *puCodePageOut = 0;
        if (pcchActual)
            *pcchActual = 0;
        if (plActualLen)
            *plActualLen = 0;
    }

    return hr;
}

STDMETHODIMP CMLStrAttrAStr::GetStrBufA(long lSrcPos, long lSrcMaxLen, UINT* puDestCodePage, IMLangStringBufA** ppDestBuf, long* plDestLen)
{
    ASSERT_THIS;
    ASSERT_WRITE_PTR_OR_NULL(puDestCodePage);
    ASSERT_WRITE_PTR_OR_NULL(ppDestBuf);
    ASSERT_WRITE_PTR_OR_NULL(plDestLen);

    HRESULT hr = CheckThread();
    CLock Lock(FALSE, this, hr);
    IMLangStringBufA* pMLStrBufA;

    if (SUCCEEDED(hr) &&
        SUCCEEDED(hr = RegularizePosLen(&lSrcPos, &lSrcMaxLen)) &&
        lSrcMaxLen <= 0)
    {
        hr = E_INVALIDARG;
    }

    if (SUCCEEDED(hr))
    {
        pMLStrBufA = GetMLStrBufA();
        if (!pMLStrBufA)
            hr = MLSTR_E_STRBUFNOTAVAILABLE;
    }

    if (SUCCEEDED(hr))
    {
        if (puDestCodePage)
            *puDestCodePage = GetCodePage();
        if (ppDestBuf)
        {
            pMLStrBufA->AddRef();
            *ppDestBuf = pMLStrBufA;
        }
        if (plDestLen)
            *plDestLen = lSrcMaxLen;
    }
    else
    {
        if (puDestCodePage)
            *puDestCodePage = 0;
        if (ppDestBuf)
            *ppDestBuf = NULL;
        if (plDestLen)
            *plDestLen = 0;
    }

    return hr;
}

STDMETHODIMP CMLStrAttrAStr::LockAStr(long lSrcPos, long lSrcLen, long lFlags, UINT uCodePageIn, long cchRequest, UINT* puCodePageOut, CHAR** ppszDest, long* pcchDest, long* plDestLen)
{
    ASSERT_THIS;
    ASSERT_WRITE_PTR_OR_NULL(puCodePageOut);
    ASSERT_WRITE_PTR_OR_NULL(ppszDest);
    ASSERT_WRITE_PTR_OR_NULL(pcchDest);
    ASSERT_WRITE_PTR_OR_NULL(plDestLen);

    HRESULT hr = CheckThread();
    CLock Lock(lFlags & MLSTR_WRITE, this, hr);
    long cchSrcPos;
    long cchSrcLen;
    CHAR* pszBuf = NULL;
    long cchBuf;
    long lLockLen;
    BOOL fDirectLock;

    if (SUCCEEDED(hr) && (!lFlags || (lFlags & ~GetBufFlags() & MLSTR_WRITE)))
        hr = E_INVALIDARG; // No flags specified, or not writable StrBuf; TODO: Replace StrBuf in this case if allowed

    if (!(lFlags & MLSTR_WRITE))
        cchRequest = 0;

    if (SUCCEEDED(hr) &&
        SUCCEEDED(hr = PrepareMLStrBuf()) &&
        SUCCEEDED(hr = RegularizePosLen(&lSrcPos, &lSrcLen)) &&
        SUCCEEDED(hr = GetCCh(0, lSrcPos, &cchSrcPos)) &&
        SUCCEEDED(hr = GetCCh(cchSrcPos, lSrcLen, &cchSrcLen)))
    {
        IMLangStringBufA* const pMLStrBufA = GetMLStrBufA();
        fDirectLock = (pMLStrBufA && (puCodePageOut || uCodePageIn == GetCodePage()));

        if (fDirectLock)
        {
            long cchInserted;
            long cchLockLen = cchSrcLen;

            if (puCodePageOut)
                hr = GetAStr(lSrcPos, lSrcLen, 0, &uCodePageIn, NULL, 0, NULL, NULL);

            if (SUCCEEDED(hr) &&
                cchRequest > cchSrcLen &&
                SUCCEEDED(hr = pMLStrBufA->Insert(cchSrcPos + cchSrcLen, cchRequest - cchSrcLen, &cchInserted)))
            {
                SetBufCCh(GetBufCCh() + cchInserted);
                cchLockLen += cchInserted;

                if (!pcchDest && cchLockLen < cchRequest)
                    hr = E_OUTOFMEMORY; // Can't insert in StrBuf
            }

            if (SUCCEEDED(hr) &&
                SUCCEEDED(hr = pMLStrBufA->LockBuf(cchSrcPos, cchLockLen, &pszBuf, &cchBuf)) &&
                !pcchDest && cchBuf < max(cchSrcLen, cchRequest))
            {
                hr = E_OUTOFMEMORY; // Can't lock StrBuf
            }

            if (plDestLen && SUCCEEDED(hr))
                hr = CalcLenA(uCodePageIn, pszBuf, cchBuf, &lLockLen);
        }
        else
        {
            long cchSize;

            if (SUCCEEDED(hr = CalcBufSizeA(lSrcLen, &cchSize)))
            {
                cchBuf = max(cchSize, cchRequest);
                hr = MemAlloc(sizeof(*pszBuf) * cchBuf, (void**)&pszBuf);
            }

            if (SUCCEEDED(hr) && ((lFlags & MLSTR_READ) || puCodePageOut))
                hr = GetAStr(lSrcPos, lSrcLen,  uCodePageIn, (puCodePageOut) ? &uCodePageIn : NULL, (lFlags & MLSTR_READ) ? pszBuf : NULL, cchBuf, (pcchDest) ? &cchBuf : NULL, (plDestLen) ? &lLockLen : NULL);
        }
    }

    if (SUCCEEDED(hr) &&
        SUCCEEDED(hr = Lock.FallThrough()))
    {
        hr = GetLockInfo()->Lock((fDirectLock) ? UnlockAStrDirect : UnlockAStrIndirect, lFlags, uCodePageIn, pszBuf, lSrcPos, lSrcLen, cchSrcPos, cchBuf);
    }

    if (SUCCEEDED(hr))
    {
        if (puCodePageOut)
            *puCodePageOut = uCodePageIn;
        if (ppszDest)
            *ppszDest = pszBuf;
        if (pcchDest)
            *pcchDest = cchBuf;
        if (plDestLen)
            *plDestLen = lLockLen;
    }
    else
    {
        if (pszBuf)
        {
            if (fDirectLock)
                GetMLStrBufA()->UnlockBuf(pszBuf, 0, 0);
            else
                MemFree(pszBuf);
        }

        if (puCodePageOut)
            *puCodePageOut = 0;
        if (ppszDest)
            *ppszDest = NULL;
        if (pcchDest)
            *pcchDest = 0;
        if (plDestLen)
            *plDestLen = 0;
    }

    return hr;
}

STDMETHODIMP CMLStrAttrAStr::UnlockAStr(const CHAR* pszSrc, long cchSrc, long* pcchActual, long* plActualLen)
{
    ASSERT_THIS;
    ASSERT_READ_BLOCK(pszSrc, cchSrc);
    ASSERT_WRITE_PTR_OR_NULL(pcchActual);
    ASSERT_WRITE_PTR_OR_NULL(plActualLen);

    return UnlockStrCommon(pszSrc, cchSrc, pcchActual, plActualLen);
}

STDMETHODIMP CMLStrAttrAStr::OnRegisterAttr(IUnknown* pUnk)
{
    return E_NOTIMPL; // CMLStrAttrAStr::OnRegisterAttr()
}

STDMETHODIMP CMLStrAttrAStr::OnUnregisterAttr(IUnknown* pUnk)
{
    return E_NOTIMPL; // CMLStrAttrAStr::OnUnregisterAttr()
}

STDMETHODIMP CMLStrAttrAStr::OnRequestEdit(long lDestPos, long lDestLen, long lNewLen, REFIID riid, LPARAM lParam, IUnknown* pUnk)
{
    return E_NOTIMPL; // CMLStrAttrAStr::OnRequestEdit()
}

STDMETHODIMP CMLStrAttrAStr::OnCanceledEdit(long lDestPos, long lDestLen, long lNewLen, REFIID riid, LPARAM lParam, IUnknown* pUnk)
{
    return E_NOTIMPL; // CMLStrAttrAStr::OnCanceledEdit()
}

STDMETHODIMP CMLStrAttrAStr::OnChanged(long lDestPos, long lDestLen, long lNewLen, REFIID riid, LPARAM lParam, IUnknown* pUnk)
{
    return E_NOTIMPL; // CMLStrAttrAStr::OnChanged()
}

#endif // NEWMLSTR
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\mlang\attrstrw.h ===
// AttrStrW.h : Declaration of the CMLStrAttrWStr

#ifndef __ATTRSTRW_H_
#define __ATTRSTRW_H_

#include "mlatl.h"
#include "attrstr.h"
#include "mlstrbuf.h"

/////////////////////////////////////////////////////////////////////////////
// CMLStrAttrWStr
class ATL_NO_VTABLE CMLStrAttrWStr :
    public CMLStrAttrStrCommon,
    public CComObjectRoot,
    public CComCoClass<CMLStrAttrWStr, &CLSID_CMLStrAttrWStr>,
    public IMLStrAttrWStr,
    public IMLangStringNotifySink,
    public IConnectionPointContainerImpl<CMLStrAttrWStr>,
    public IConnectionPointImpl<CMLStrAttrWStr, &IID_IMLStrAttrNotifySink>
{
    typedef CMLStrAttrWStr* POWNER;

public:
    CMLStrAttrWStr(void);

    DECLARE_NO_REGISTRY()

    BEGIN_COM_MAP(CMLStrAttrWStr)
        COM_INTERFACE_ENTRY(IMLStrAttr)
        COM_INTERFACE_ENTRY(IMLStrAttrWStr)
        COM_INTERFACE_ENTRY(IMLangStringNotifySink)
        COM_INTERFACE_ENTRY_IMPL(IConnectionPointContainer)
    END_COM_MAP()

    BEGIN_CONNECTION_POINT_MAP(CMLStrAttrWStr)
        CONNECTION_POINT_ENTRY(IID_IMLStrAttrNotifySink)
    END_CONNECTION_POINT_MAP()

public:
// IMLStrAttr
    STDMETHOD(SetClient)(/*[in]*/ IUnknown* pUnk);
    STDMETHOD(GetClient)(/*[out]*/ IUnknown** ppUnk);
    STDMETHOD(QueryAttr)(/*[in]*/ REFIID riid, /*[in]*/ LPARAM lParam, /*[out]*/ IUnknown** ppUnk, /*[out]*/ long* lConf);
    STDMETHOD(GetAttrInterface)(/*[out]*/ IID* pIID, /*[out]*/ LPARAM* plParam);
    STDMETHOD(SetMLStr)(/*[in]*/ long lDestPos, /*[in]*/ long lDestLen, /*[in]*/ IUnknown* pSrcMLStr, /*[in]*/ long lSrcPos, /*[in]*/ long lSrcLen);
// IMLStrAttrWStr
    STDMETHOD(SetWStr)(/*[in]*/ long lDestPos, /*[in]*/ long lDestLen, /*[in, size_is(cchSrc)]*/ const WCHAR* pszSrc, /*[in]*/ long cchSrc, /*[out]*/ long* pcchActual, /*[out]*/ long* plActualLen);
    STDMETHOD(SetStrBufW)(/*[in]*/ long lDestPos, /*[in]*/ long lDestLen, /*[in]*/ IMLangStringBufW* pSrcBuf, /*[out]*/ long* pcchActual, /*[out]*/ long* plActualLen);
    STDMETHOD(GetWStr)(/*[in]*/ long lSrcPos, /*[in]*/ long lSrcLen, /*[out, size_is(cchDest)]*/ WCHAR* pszDest, /*[in]*/ long cchDest, /*[out]*/ long* pcchActual, /*[out]*/ long* plActualLen);
    STDMETHOD(GetStrBufW)(/*[in]*/ long lSrcPos, /*[in]*/ long lSrcMaxLen, /*[out]*/ IMLangStringBufW** ppDestBuf, /*[out]*/ long* plDestLen);
    STDMETHOD(LockWStr)(/*[in]*/ long lSrcPos, /*[in]*/ long lSrcLen, /*[in]*/ long lFlags, /*[in]*/ long cchRequest, /*[out, size_is(,*pcchDest)]*/ WCHAR** ppszDest, /*[out]*/ long* pcchDest, /*[out]*/ long* plDestLen);
    STDMETHOD(UnlockWStr)(/*[in, size_is(cchSrc)]*/ const WCHAR* pszSrc, /*[in]*/ long cchSrc, /*[out]*/ long* pcchActual, /*[out]*/ long* plActualLen);
// IMLangStringNotifySink
    STDMETHOD(OnRegisterAttr)(/*[in]*/ IUnknown* pUnk);
    STDMETHOD(OnUnregisterAttr)(/*[in]*/ IUnknown* pUnk);
    STDMETHOD(OnRequestEdit)(/*[in]*/ long lDestPos, /*[in]*/ long lDestLen, /*[in]*/ long lNewLen, /*[in]*/ REFIID riid, /*[in]*/ LPARAM lParam, /*[in]*/ IUnknown* pUnk);
    STDMETHOD(OnCanceledEdit)(/*[in]*/ long lDestPos, /*[in]*/ long lDestLen, /*[in]*/ long lNewLen, /*[in]*/ REFIID riid, /*[in]*/ LPARAM lParam, /*[in]*/ IUnknown* pUnk);
    STDMETHOD(OnChanged)(/*[in]*/ long lDestPos, /*[in]*/ long lDestLen, /*[in]*/ long lNewLen, /*[in]*/ REFIID riid, /*[in]*/ LPARAM lParam, /*[in]*/ IUnknown* pUnk);

protected:
    ~CMLStrAttrWStr(void);
    IMLStrAttr* GetMLStrAttr(void) {return this;}
    HRESULT StartEndConnectionMLStr(IUnknown* const pUnk, BOOL fStart);

    IMLangString* m_pMLStr;
    DWORD m_dwMLStrCookie;
};

#endif //__ATTRSTRW_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\mlang\attrstrw.cpp ===
// AttrStrW.cpp : Implementation of CMLStrAttrWStr
#include "private.h"

#ifdef NEWMLSTR

#include "attrstrw.h"
#include "mlsbwalk.h"

/////////////////////////////////////////////////////////////////////////////
// CMLStrAttrWStr

CMLStrAttrWStr::CMLStrAttrWStr(void) :
    m_pMLStr(NULL)
{
}

CMLStrAttrWStr::~CMLStrAttrWStr(void)
{
    VERIFY(SetClient(NULL)); // Clean m_pMLStr
}

STDMETHODIMP CMLStrAttrWStr::SetClient(IUnknown* pUnk)
{
    ASSERT_THIS;
    ASSERT_READ_PTR_OR_NULL(pUnk);

    HRESULT hr = S_OK;

    // Release old client
    IMLangString* const pMLStr = m_pMLStr;
    if (pMLStr && SUCCEEDED(hr = StartEndConnectionMLStr(pMLStr, FALSE))) // End connection to MLStr
    {
        pMLStr->Release();
        m_pMLStr = NULL;
    }

    // Set new client
    if (SUCCEEDED(hr) && pUnk) // pUnk is given
    {
        ASSERT(!m_pMLStr);
        if (SUCCEEDED(hr = pUnk->QueryInterface(IID_IMLangString, (void**)&m_pMLStr)))
        {
            ASSERT_READ_PTR(m_pMLStr);
            if (FAILED(hr = StartEndConnectionMLStr(pUnk, TRUE))) // Start connection to MLStr
            {
                m_pMLStr->Release();
                m_pMLStr = NULL;
            }
        }
    }

    return hr;
}

HRESULT CMLStrAttrWStr::StartEndConnectionMLStr(IUnknown* const pUnk, BOOL fStart)
{
    ASSERT_THIS;
    ASSERT_READ_PTR(pUnk);

    HRESULT hr;
    IConnectionPointContainer* pCPC;

    if (SUCCEEDED(hr = pUnk->QueryInterface(IID_IConnectionPointContainer, (void**)&pCPC)))
    {
        ASSERT_READ_PTR(pCPC);

        IConnectionPoint* pCP;

        if (SUCCEEDED(hr = pCPC->FindConnectionPoint(IID_IMLangStringNotifySink, &pCP)))
        {
            ASSERT_READ_PTR(pCP);

            if (fStart)
                hr = pCP->Advise((IMLStrAttr*)this, &m_dwMLStrCookie);
            else
                hr = pCP->Unadvise(m_dwMLStrCookie);

            pCP->Release();
        }

        pCPC->Release();
    }

    return hr;
}

STDMETHODIMP CMLStrAttrWStr::GetClient(IUnknown** ppUnk)
{
    ASSERT_THIS;
    ASSERT_WRITE_PTR_OR_NULL(ppUnk);

    if (ppUnk)
    {
        IUnknown* const pUnk = m_pMLStr;
        *ppUnk = pUnk;
        if (pUnk)
            pUnk->AddRef();
    }

    return S_OK;
}

STDMETHODIMP CMLStrAttrWStr::QueryAttr(REFIID riid, LPARAM lParam, IUnknown** ppUnk, long* lConf)
{
    return E_NOTIMPL; // CMLStrAttrWStr::QueryAttr()
}

STDMETHODIMP CMLStrAttrWStr::GetAttrInterface(IID* pIID, LPARAM* plParam)
{
    return E_NOTIMPL; // CMLStrAttrWStr::GetAttrInterface()
}

STDMETHODIMP CMLStrAttrWStr::SetMLStr(long lDestPos, long lDestLen, IUnknown* pSrcMLStr, long lSrcPos, long lSrcLen)
{
    return E_NOTIMPL; // CMLStrAttrWStr::SetMLStr()
}

STDMETHODIMP CMLStrAttrWStr::SetWStr(long lDestPos, long lDestLen, const WCHAR* pszSrc, long cchSrc, long* pcchActual, long* plActualLen)
{
    ASSERT_THIS;
    ASSERT_READ_BLOCK(pszSrc, cchSrc);
    ASSERT_WRITE_PTR_OR_NULL(pcchActual);
    ASSERT_WRITE_PTR_OR_NULL(plActualLen);

    HRESULT hr = CheckThread();
    CLock Lock(TRUE, this, hr);
    long cchDestPos;
    long cchDestLen;
    long cchActual;
    long lActualLen;

    if (SUCCEEDED(hr) && (GetBufFlags() & MLSTR_WRITE))
        hr = E_INVALIDARG; // Not writable StrBuf; TODO: Replace StrBuf in this case if allowed

    if (SUCCEEDED(hr) &&
        SUCCEEDED(hr = PrepareMLStrBuf()) &&
        SUCCEEDED(hr = RegularizePosLen(&lDestPos, &lDestLen)) &&
        SUCCEEDED(hr = GetCCh(0, lDestPos, &cchDestPos)) &&
        SUCCEEDED(hr = GetCCh(cchDestPos, lDestLen, &cchDestLen)))
    {
        IMLangStringBufW* const pMLStrBufW = GetMLStrBufW();

        if (pMLStrBufW)
        {
            if (cchSrc > cchDestLen)
            {
                hr = pMLStrBufW->Insert(cchDestPos, cchSrc - cchDestLen, (pcchActual || plActualLen) ? &cchSrc : NULL);
                cchSrc += cchDestLen;
            }
            else if  (cchSrc < cchDestLen)
            {
                hr = pMLStrBufW->Delete(cchDestPos, cchDestLen - cchSrc);
            }

            CMLStrBufWalkW BufWalk(pMLStrBufW, cchDestPos, cchSrc, (pcchActual || plActualLen));

            lActualLen = 0;
            while (BufWalk.Lock(hr))
            {
                long lLen;

                if (plActualLen)
                    hr = CalcLenW(pszSrc, BufWalk.GetCCh(), &lLen);

                if (SUCCEEDED(hr))
                {
                    lActualLen += lLen;
                    ::memcpy(BufWalk.GetStr(), pszSrc, sizeof(WCHAR) * BufWalk.GetCCh());
                    pszSrc += BufWalk.GetCCh();
                }

                BufWalk.Unlock(hr);
            }

            cchActual = BufWalk.GetDoneCCh();
        }
        else
        {
            IMLangStringBufA* const pMLStrBufA = GetMLStrBufA(); // Should succeed because PrepareMLStrBuf() above was succeeded
            const UINT uCodePage = GetCodePage();
            long cchSrcA;

            if (SUCCEEDED(hr = ConvWStrToAStr(pcchActual || plActualLen, uCodePage, pszSrc, cchSrc, NULL, 0, &cchSrcA, NULL, NULL)))
            {
                if (cchSrcA > cchDestLen)
                {
                    hr = pMLStrBufA->Insert(cchDestPos, cchSrcA - cchDestLen, (pcchActual || plActualLen) ? &cchSrcA : NULL);
                    cchSrcA += cchDestLen;
                }
                else if  (cchSrcA < cchDestLen)
                {
                    hr = pMLStrBufA->Delete(cchDestPos, cchDestLen - cchSrcA);
                }
            }

            CMLStrBufWalkA BufWalk(pMLStrBufA, cchDestPos, cchSrcA, (pcchActual || plActualLen));

            cchActual = 0;
            lActualLen = 0;
            while (BufWalk.Lock(hr))
            {
                long cchWrittenA;
                long cchWrittenW;
                long lWrittenLen;

                if (SUCCEEDED(hr = ConvWStrToAStr(pcchActual || plActualLen, uCodePage, pszSrc, cchSrc, BufWalk.GetStr(), BufWalk.GetCCh(), &cchWrittenA, &cchWrittenW, &lWrittenLen)))
                {
                    pszSrc += cchWrittenW;
                    cchSrc -= cchWrittenW;
                    cchActual += cchWrittenW;
                    lActualLen += lWrittenLen;
                }

                BufWalk.Unlock(hr, cchWrittenA);
            }
        }
    }

    if (SUCCEEDED(hr))
    {
        if (pcchActual)
            *pcchActual = cchActual;
        if (plActualLen)
            *plActualLen = lActualLen;
    }
    else
    {
        if (pcchActual)
            *pcchActual = 0;
        if (plActualLen)
            *plActualLen = 0;
    }
    return hr;
}

STDMETHODIMP CMLStrAttrWStr::SetStrBufW(long lDestPos, long lDestLen, IMLangStringBufW* pSrcBuf, long* pcchActual, long* plActualLen)
{
    ASSERT_THIS;
    return SetStrBufCommon(this, lDestPos, lDestLen, 0, pSrcBuf, NULL, pcchActual, plActualLen);
}

STDMETHODIMP CMLStrAttrWStr::GetWStr(long lSrcPos, long lSrcLen, WCHAR* pszDest, long cchDest, long* pcchActual, long* plActualLen)
{
    ASSERT_THIS;
    ASSERT_WRITE_BLOCK_OR_NULL(pszDest, cchDest);
    ASSERT_WRITE_PTR_OR_NULL(pcchActual);
    ASSERT_WRITE_PTR_OR_NULL(plActualLen);

    HRESULT hr = CheckThread();
    CLock Lock(FALSE, this, hr);
    long cchSrcPos;
    long cchSrcLen;
    long cchActual;
    long lActualLen;

    if (SUCCEEDED(hr) &&
        SUCCEEDED(hr = RegularizePosLen(&lSrcPos, &lSrcLen)) &&
        SUCCEEDED(hr = GetCCh(0, lSrcPos, &cchSrcPos)) &&
        SUCCEEDED(hr = GetCCh(cchSrcPos, lSrcLen, &cchSrcLen)))
    {
        IMLangStringBufW* const pMLStrBufW = GetMLStrBufW();
        IMLangStringBufA* const pMLStrBufA = GetMLStrBufA();

        if (pszDest)
            cchActual = min(cchSrcLen, cchDest);
        else
            cchActual = cchSrcLen;

        if (pMLStrBufW)
        {
            CMLStrBufWalkW BufWalk(pMLStrBufW, cchSrcPos, cchActual, (pcchActual || plActualLen));

            lActualLen = 0;
            while (BufWalk.Lock(hr))
            {
                long lLen;

                if (plActualLen)
                    hr = CalcLenW(BufWalk.GetStr(), BufWalk.GetCCh(), &lLen);

                if (SUCCEEDED(hr))
                {
                    lActualLen += lLen;

                    if (pszDest)
                    {
                        ::memcpy(pszDest, BufWalk.GetStr(), sizeof(WCHAR) * BufWalk.GetCCh());
                        pszDest += BufWalk.GetCCh();
                    }
                }

                BufWalk.Unlock(hr);
            }

            cchActual = BufWalk.GetDoneCCh();
        }
        else if (pMLStrBufA)
        {
            CMLStrBufWalkA BufWalk(pMLStrBufA, cchSrcPos, cchActual, (pcchActual || plActualLen));

            cchActual = 0;
            lActualLen = 0;
            while ((!pszDest || cchDest > 0) && BufWalk.Lock(hr))
            {
                CHAR* const pszBuf = BufWalk.GetStr();
                long cchWrittenA;
                long cchWrittenW;
                long lWrittenLen;

                if (SUCCEEDED(hr = ConvAStrToWStr(GetCodePage(), pszBuf, BufWalk.GetCCh(), pszDest, cchDest, &cchWrittenA, &cchWrittenW, &lWrittenLen)))
                {
                    lActualLen += lWrittenLen;
                    cchActual += cchWrittenW;

                    if (pszDest)
                    {
                        pszDest += cchWrittenW;
                        cchDest -= cchWrittenW;
                    }
                }

                BufWalk.Unlock(hr, cchWrittenA);
            }
        }
        else
        {
            ASSERT(cchActual == 0); // MLStrBuf is not available
            lActualLen = 0;
        }
    }

    if (SUCCEEDED(hr))
    {
        if (pcchActual)
            *pcchActual = cchActual;
        if (plActualLen)
            *plActualLen = lActualLen;
    }
    else
    {
        if (pcchActual)
            *pcchActual = 0;
        if (plActualLen)
            *plActualLen = 0;
    }
    return hr;
}

STDMETHODIMP CMLStrAttrWStr::GetStrBufW(long lSrcPos, long lSrcMaxLen, IMLangStringBufW** ppDestBuf, long* plDestLen)
{
    ASSERT_THIS;
    ASSERT_WRITE_PTR_OR_NULL(ppDestBuf);
    ASSERT_WRITE_PTR_OR_NULL(plDestLen);

    HRESULT hr = CheckThread();
    CLock Lock(FALSE, this, hr);
    IMLangStringBufW* pMLStrBufW;

    if (SUCCEEDED(hr) &&
        SUCCEEDED(hr = RegularizePosLen(&lSrcPos, &lSrcMaxLen)) &&
        lSrcMaxLen <= 0)
    {
        hr = E_INVALIDARG;
    }

    if (SUCCEEDED(hr))
    {
        pMLStrBufW = GetMLStrBufW();
        if (!pMLStrBufW)
            hr = MLSTR_E_STRBUFNOTAVAILABLE;
    }

    if (SUCCEEDED(hr))
    {
        if (ppDestBuf)
        {
            pMLStrBufW->AddRef();
            *ppDestBuf = pMLStrBufW;
        }
        if (plDestLen)
            *plDestLen = lSrcMaxLen;
    }
    else
    {
        if (ppDestBuf)
            *ppDestBuf = NULL;
        if (plDestLen)
            *plDestLen = 0;
    }

    return hr;
}

STDMETHODIMP CMLStrAttrWStr::LockWStr(long lSrcPos, long lSrcLen, long lFlags, long cchRequest, WCHAR** ppszDest, long* pcchDest, long* plDestLen)
{
    ASSERT_THIS;
    ASSERT_WRITE_PTR_OR_NULL(ppszDest);
    ASSERT_WRITE_PTR_OR_NULL(pcchDest);
    ASSERT_WRITE_PTR_OR_NULL(plDestLen);

    HRESULT hr = CheckThread();
    CLock Lock(lFlags & MLSTR_WRITE, this, hr);
    long cchSrcPos;
    long cchSrcLen;
    WCHAR* pszBuf = NULL;
    long cchBuf;
    long lLockLen;
    BOOL fDirectLock;

    if (SUCCEEDED(hr) && (!lFlags || (lFlags & ~GetBufFlags() & MLSTR_WRITE)))
        hr = E_INVALIDARG; // No flags specified, or not writable StrBuf; TODO: Replace StrBuf in this case if allowed

    if (!(lFlags & MLSTR_WRITE))
        cchRequest = 0;

    if (SUCCEEDED(hr) &&
        SUCCEEDED(hr = PrepareMLStrBuf()) &&
        SUCCEEDED(hr = RegularizePosLen(&lSrcPos, &lSrcLen)) &&
        SUCCEEDED(hr = GetCCh(0, lSrcPos, &cchSrcPos)) &&
        SUCCEEDED(hr = GetCCh(cchSrcPos, lSrcLen, &cchSrcLen)))
    {
        IMLangStringBufW* const pMLStrBufW = GetMLStrBufW();
        fDirectLock = (pMLStrBufW != 0);

        if (fDirectLock)
        {
            long cchInserted;
            long cchLockLen = cchSrcLen;

            if (cchRequest > cchSrcLen &&
                SUCCEEDED(hr = pMLStrBufW->Insert(cchSrcPos + cchSrcLen, cchRequest - cchSrcLen, &cchInserted)))
            {
                SetBufCCh(GetBufCCh() + cchInserted);
                cchLockLen += cchInserted;

                if (!pcchDest && cchLockLen < cchRequest)
                    hr = E_OUTOFMEMORY; // Can't insert in StrBuf
            }

            if (SUCCEEDED(hr) &&
                SUCCEEDED(hr = pMLStrBufW->LockBuf(cchSrcPos, cchLockLen, &pszBuf, &cchBuf)) &&
                !pcchDest && cchBuf < max(cchSrcLen, cchRequest))
            {
                hr = E_OUTOFMEMORY; // Can't lock StrBuf
            }

            if (plDestLen && SUCCEEDED(hr))
                hr = CalcLenW(pszBuf, cchBuf, &lLockLen);
        }
        else
        {
            long cchSize;

            if (SUCCEEDED(hr = CalcBufSizeW(lSrcLen, &cchSize)))
            {
                cchBuf = max(cchSize, cchRequest);
                hr = MemAlloc(sizeof(*pszBuf) * cchBuf, (void**)&pszBuf);
            }

            if (SUCCEEDED(hr) && (lFlags & MLSTR_READ))
                hr = GetWStr(lSrcPos, lSrcLen,  pszBuf, cchBuf, (pcchDest) ? &cchBuf : NULL, (plDestLen) ? &lLockLen : NULL);
        }
    }

    if (SUCCEEDED(hr) &&
        SUCCEEDED(hr = Lock.FallThrough()))
    {
        hr = GetLockInfo()->Lock((fDirectLock) ? UnlockWStrDirect : UnlockWStrIndirect, lFlags, 0, pszBuf, lSrcPos, lSrcLen, cchSrcPos, cchBuf);
    }

    if (SUCCEEDED(hr))
    {
        if (ppszDest)
            *ppszDest = pszBuf;
        if (pcchDest)
            *pcchDest = cchBuf;
        if (plDestLen)
            *plDestLen = lLockLen;
    }
    else
    {
        if (pszBuf)
        {
            if (fDirectLock)
                GetMLStrBufW()->UnlockBuf(pszBuf, 0, 0);
            else
                MemFree(pszBuf);
        }

        if (ppszDest)
            *ppszDest = NULL;
        if (pcchDest)
            *pcchDest = 0;
        if (plDestLen)
            *plDestLen = 0;
    }

    return hr;
}

STDMETHODIMP CMLStrAttrWStr::UnlockWStr(const WCHAR* pszSrc, long cchSrc, long* pcchActual, long* plActualLen)
{
    ASSERT_THIS;
    ASSERT_READ_BLOCK(pszSrc, cchSrc);
    ASSERT_WRITE_PTR_OR_NULL(pcchActual);
    ASSERT_WRITE_PTR_OR_NULL(plActualLen);

    return UnlockStrCommon(pszSrc, cchSrc, pcchActual, plActualLen);
}

STDMETHODIMP CMLStrAttrWStr::OnRegisterAttr(IUnknown* pUnk)
{
    return E_NOTIMPL; // CMLStrAttrWStr::OnRegisterAttr()
}

STDMETHODIMP CMLStrAttrWStr::OnUnregisterAttr(IUnknown* pUnk)
{
    return E_NOTIMPL; // CMLStrAttrWStr::OnUnregisterAttr()
}

STDMETHODIMP CMLStrAttrWStr::OnRequestEdit(long lDestPos, long lDestLen, long lNewLen, REFIID riid, LPARAM lParam, IUnknown* pUnk)
{
    return E_NOTIMPL; // CMLStrAttrWStr::OnRequestEdit()
}

STDMETHODIMP CMLStrAttrWStr::OnCanceledEdit(long lDestPos, long lDestLen, long lNewLen, REFIID riid, LPARAM lParam, IUnknown* pUnk)
{
    return E_NOTIMPL; // CMLStrAttrWStr::OnCanceledEdit()
}

STDMETHODIMP CMLStrAttrWStr::OnChanged(long lDestPos, long lDestLen, long lNewLen, REFIID riid, LPARAM lParam, IUnknown* pUnk)
{
    return E_NOTIMPL; // CMLStrAttrWStr::OnChanged()
}

#endif // NEWMLSTR
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\mlang\codepage.h ===
//+---------------------------------------------------------------------------
//
//  Copyright (C) Microsoft Corporation, 1994-1996
//
//  File:       codepage.h
//
//  Contents:   Codepage definitions
//
//----------------------------------------------------------------------------

#ifndef _CODEPAGE_H_
#define _CODEPAGE_H_

/*
 *  Code Page Default Values.
 */
enum CODEPAGE
{
    CP_UNDEFINED    = -1L,
    CP_DEFAULT      = CP_ACP, 
    CP_US_OEM       = 437L,
    CP_852          = 852L,
    CP_THAI         = 874L,
    CP_JPN_SJ       = 932L,
    CP_CHN_GB       = 936L,
    CP_KOR_5601     = 949L,
    CP_KOR_JOHAB    = 1361L,
    CP_TWN          = 950L,
    CP_UCS_2        = 1200L,
    CP_UCS_2_BE     = 1201L,
    CP_1250         = 1250L,
    CP_1251         = 1251L,
    CP_1252         = 1252L,
    CP_1253         = 1253L,
    CP_1254         = 1254L,
    CP_1255         = 1255L,
    CP_1256         = 1256L,
    CP_1257         = 1257L,
    CP_1258         = 1258L,
    CP_20127        = 20127L,
    CP_KOI8R        = 20866L,
    CP_KOI8RU       = 21866L,
    CP_ISO_8859_1   = 28591L,
    CP_ISO_8859_2   = 28592L,
    CP_ISO_8859_3   = 28593L,
    CP_ISO_8859_9   = 28599L,
    CP_ISO_8859_15  = 28605L,
    CP_USER_DEFINED = 50000L,

    CP_AUTO         = 50001L,

    CP_ISO_2022_JP   = 50220L,
    CP_ISO_2022_JP_ESC   = 50221L,
    CP_ISO_2022_JP_SIO   = 50222L,
    CP_ISO_2022_KR   = 50225L,
    CP_ISO_2022_TW   = 50226L,
    CP_ISO_2022_CH   = 50227L,

    CP_JP_AUTO      = 50932L,
    CP_CHS_AUTO     = 50936L,
    CP_KR_AUTO      = 50949L,
    CP_CHT_AUTO     = 50950L,

    CP_CYRILLIC_AUTO = 51251L,
    CP_GREEK_AUTO   = 51253L,
    CP_ARABIC_AUTO  = 51256L,

    CP_EUC_JP       = 51932L,
    CP_EUC_CH       = 51936L,
    CP_EUC_KR       = 51949L,
    CP_EUC_TW       = 51950L,

    CP_CHN_HZ       = 52936L,
    CP_18030        = 54936L,

    CP_UTF_7        = 65000L,
    CP_UTF_8        = 65001L
};

enum CP_STATE
{
    INVALID_CP      = 0,
    VALID_CP          = 1,
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\mlang\convbase.cpp ===
// ============================================================================
// Internet Character Set Conversion: Base Class
// ============================================================================

#include "private.h"
#include "convbase.h"
#include "fechrcnv.h"
#include "codepage.h"

/******************************************************************************
**************************   C O N S T R U C T O R   **************************
******************************************************************************/

CINetCodeConverter::CINetCodeConverter()
{
    m_uCodePage = 0;
    m_nCodeSet = CP_UNDEFINED;
    m_cchOverflow = 0;
}

CINetCodeConverter::CINetCodeConverter(UINT uCodePage, int nCodeSet)
{
    m_uCodePage = uCodePage;
    m_nCodeSet = nCodeSet;
    m_cchOverflow = 0;
}

/******************************************************************************
********************   G E T   S T R I N G   S I Z E   A   ********************
******************************************************************************/

HRESULT CINetCodeConverter::GetStringSizeA(LPCSTR lpSrcStr, int cchSrc, LPINT lpnSize)
{
    m_fOutput = FALSE;

    return WalkString(lpSrcStr, cchSrc, lpnSize);
}

/******************************************************************************
*********************   C O N V E R T   S T R I N G   A   *********************
******************************************************************************/

HRESULT CINetCodeConverter::ConvertStringA(LPCSTR lpSrcStr, int cchSrc, LPSTR lpDestStr, int cchDest, LPINT lpnSize)
{
    m_fOutput = TRUE;
    m_lpDestStr = lpDestStr;
    m_cchDest = cchDest;

    if ( !OutputOverflowBuffer() ) // Output those chars which could not be output at previous time.
        return FALSE;

    return WalkString(lpSrcStr, cchSrc, lpnSize);
}

/******************************************************************************
**************************   W A L K   S T R I N G   **************************
******************************************************************************/

HRESULT CINetCodeConverter::WalkString(LPCSTR lpSrcStr, int cchSrc, LPINT lpnSize)
{
        HRESULT hr = S_OK;

        m_cchOutput = 0;

        if (lpSrcStr) {
            while (cchSrc-- > 0) {
            HRESULT _hr = ConvertChar(*lpSrcStr++, cchSrc);
            if (!SUCCEEDED(_hr))
            {   
                hr = _hr;
                break;
            }
            else
                if (hr == S_OK && _hr == S_FALSE)
                    hr = S_FALSE;
            }
    } else {
        if (!CleanUp())
            hr = E_FAIL;
    }

    if (lpnSize)
        *lpnSize = m_cchOutput;

    return hr;
}

/******************************************************************************
**************************   E N D   O F   D E S T   **************************
******************************************************************************/

BOOL CINetCodeConverter::EndOfDest(UCHAR tc)
{
    if (m_cchOverflow < MAXOVERFLOWCHARS) {
        m_OverflowBuffer[m_cchOverflow++] = tc;
        return TRUE;
    } else {
        return FALSE; // Overflow on Overflow buffer, No way
    }
}

/******************************************************************************
***************   O U T P U T   O V E R F L O W   B U F F E R   ***************
******************************************************************************/

BOOL CINetCodeConverter::OutputOverflowBuffer()
{
    for (int n = 0; n < m_cchOverflow; n++) {
        if (m_cchOutput < m_cchDest) {
            *m_lpDestStr++ = m_OverflowBuffer[n];
            m_cchOutput++;
        } else {
            // Overflow again
            for (int n2 = 0; n < m_cchOverflow; n++, n2++)
                m_OverflowBuffer[n2] = m_OverflowBuffer[n];
            m_cchOverflow = n2;
            return FALSE;
        }
    }
    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\mlang\convbase.h ===
#ifndef CONVBASE_H_
#define CONVBASE_H_

#define MAXOVERFLOWCHARS 16

class CINetCodeConverter
{
private:
    UINT m_uCodePage;
    int m_nCodeSet;
    BOOL m_fOutput;
    LPSTR m_lpDestStr;
    int m_cchDest;
    int m_cchOutput;
    int m_cchOverflow;
    UCHAR m_OverflowBuffer[MAXOVERFLOWCHARS];

public:
    CINetCodeConverter();
    CINetCodeConverter(UINT uCodePage, int nCodeSet);
    virtual ~CINetCodeConverter() {}
    int GetCodeSet() {return m_nCodeSet;}
    HRESULT GetStringSizeA(LPCSTR lpSrcStr, int cchSrc, LPINT lpnSize = NULL);
    HRESULT ConvertStringA(LPCSTR lpSrcStr, int cchSrc, LPSTR lpDestStr, int cchDest, LPINT lpnSize = NULL);
    virtual int GetUnconvertBytes() = 0 ;
    virtual DWORD GetConvertMode() = 0 ;
    virtual void SetConvertMode(DWORD mode) = 0 ;

private:
    HRESULT WalkString(LPCSTR lpSrcStr, int cchSrc, LPINT lpnSize);
    BOOL EndOfDest(UCHAR tc);
    BOOL OutputOverflowBuffer();

protected:
    virtual HRESULT ConvertChar(UCHAR tc, int cchSrc=-1) = 0;
    virtual BOOL CleanUp() = 0;

protected:
    inline BOOL Output(UCHAR tc)
    {
        BOOL fDone = TRUE;

        if (m_fOutput) {
            if (m_cchOutput < m_cchDest) {
                *m_lpDestStr++ = tc;
            } else {
                (void)EndOfDest(tc);
                fDone = FALSE;
            }
        }

        m_cchOutput++;

        return fDone;
    }
};

#endif /* CONVBASE_H_ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\mlang\convobj.cpp ===
#include "private.h"
#include "convobj.h"

#include "detcbase.h"
#include "codepage.h"
#include "detcjpn.h"
#include "detckrn.h"


CMLangConvertCharset::CMLangConvertCharset(void)
{
    DllAddRef();
    lpCharConverter = NULL ;

    m_dwSrcEncoding = 0 ;
    m_dwDetectSrcEncoding = 0 ;
    m_dwDstEncoding = 0 ;
    m_dwMode = 0 ;

    return ;
}

CMLangConvertCharset::~CMLangConvertCharset(void)
{
    if (lpCharConverter)
        delete lpCharConverter ;
    DllRelease();
    return ;
}

//
//  CMLangConvertCharset implementation
//
STDAPI CMLangConvertCharset::Initialize(UINT uiSrcCodePage, UINT uiDstCodePage, DWORD dwProperty)
{
    HRESULT hr = S_OK ;

    DebugMsg(DM_TRACE, TEXT("CMLangConvertCharset::Initialize called."));

    if ( m_dwSrcEncoding != uiSrcCodePage ||
            m_dwDstEncoding != uiDstCodePage )
    {
        m_dwSrcEncoding = uiSrcCodePage ;
        m_dwDstEncoding = uiDstCodePage ;

        if (lpCharConverter)
            delete lpCharConverter ;

        lpCharConverter = new CICharConverter ;

        if (!lpCharConverter)
            return E_FAIL ;

        hr = lpCharConverter->ConvertSetup(&m_dwSrcEncoding, m_dwDstEncoding);
    }

    m_dwMode = 0 ;
    m_dwProperty = dwProperty ;

    return hr ;
}

STDAPI CMLangConvertCharset::GetSourceCodePage(UINT *puiSrcCodePage)
{
    DebugMsg(DM_TRACE, TEXT("CMLangConvertCharset::GetSourceCodePage called."));

    if (puiSrcCodePage)
    {
        *puiSrcCodePage = m_dwSrcEncoding ;
        return S_OK ;
    }
    else
        return E_INVALIDARG ;
}

STDAPI CMLangConvertCharset::GetDestinationCodePage(UINT *puiDstCodePage)
{
    DebugMsg(DM_TRACE, TEXT("CMLangConvertCharset::GetDestinationCodePage called."));

    if (puiDstCodePage)
    {
        *puiDstCodePage = m_dwDstEncoding ;
        return S_OK ;
    }
    else
        return E_INVALIDARG ;
}

STDAPI CMLangConvertCharset::GetDeterminedSrcCodePage(UINT *puiCodePage)
{
    DebugMsg(DM_TRACE, TEXT("CMLangConvertCharset::GetDeterminedSrcCodePage called."));

    if (m_dwDetectSrcEncoding)
    {
        if (puiCodePage)
        {
            *puiCodePage = m_dwDetectSrcEncoding;
            return S_OK ;
        }
        else
            return E_INVALIDARG ;
    }
    else
        return S_FALSE ;
}

STDAPI CMLangConvertCharset::GetProperty(DWORD *pdwProperty)
{
    DebugMsg(DM_TRACE, TEXT("CMLangConvertCharset::GetProperty called."));

    if (pdwProperty)
    {
        *pdwProperty = m_dwProperty;
        return S_OK ;
    }
    else
        return E_INVALIDARG ;
}

STDAPI CMLangConvertCharset::DoConversion(BYTE *pSrcStr, UINT *pcSrcSize, BYTE *pDstStr, UINT *pcDstSize)
{
    HRESULT hr ;
    DWORD dwMode = m_dwMode ;
    int nSrcSize = -1 ;
    int nDstSize = 0 ;

    DebugMsg(DM_TRACE, TEXT("CMLangConvertCharset::DoConversion called."));

    // no converter was set up 
    if (!lpCharConverter)
        return E_FAIL ;

    if (pcSrcSize)
        nSrcSize = *pcSrcSize ;

    if ( pSrcStr && nSrcSize == -1 ) // Get length of lpSrcStr if not given, assuming lpSrcStr is a zero terminate string.
    {
        if ( m_dwSrcEncoding == CP_UCS_2 )
            nSrcSize = (lstrlenW( (WCHAR*) pSrcStr) << 1 ) ;
        else
            nSrcSize = lstrlenA( (CHAR*) pSrcStr) ;
    }

    if (pcDstSize)
        nDstSize = *pcDstSize ;

    if ( m_dwSrcEncoding == CP_JP_AUTO ) // Auto Detection for Japan
    {
        CIncdJapanese DetectJapan;
        DWORD dwSrcEncoding ;

        dwSrcEncoding = DetectJapan.DetectStringA((LPSTR)pSrcStr, nSrcSize);
        // if dwSrcEncoding is zero means there is an ambiguity, we don't return
        // the detected codepage to caller, instead we defaut its codepage internally
        // to SJIS
        if (dwSrcEncoding)
        {
            m_dwDetectSrcEncoding = m_dwSrcEncoding = dwSrcEncoding ;
            m_dwProperty |= MLCONVCHARF_AUTODETECT ;
        }
        else
            dwSrcEncoding = CP_JPN_SJ;
        hr = lpCharConverter->ConvertSetup(&dwSrcEncoding, m_dwDstEncoding);
        if ( hr != S_OK )
            return hr ;
    }
    else if ( m_dwSrcEncoding == CP_KR_AUTO ) // Auto Detection for Korean
    {
        CIncdKorean DetectKorean;

        m_dwDetectSrcEncoding = m_dwSrcEncoding = DetectKorean.DetectStringA((LPSTR)pSrcStr, nSrcSize);
        hr = lpCharConverter->ConvertSetup(&m_dwSrcEncoding, m_dwDstEncoding);
        if ( hr != S_OK )
            return hr ;
        m_dwProperty |= MLCONVCHARF_AUTODETECT ;
    }
    else if ( m_dwSrcEncoding == CP_AUTO ) // General Auto Detection for all code pages
    {
        int _nSrcSize = DETECTION_MAX_LEN < nSrcSize ?  DETECTION_MAX_LEN : nSrcSize;
        INT nScores = 1;
        DWORD dwSrcEncoding ;
        DetectEncodingInfo Encoding;

        if ( S_OK == _DetectInputCodepage(MLDETECTCP_HTML, 1252, (char *)pSrcStr, &_nSrcSize, &Encoding, &nScores))
        {
            m_dwDetectSrcEncoding = m_dwSrcEncoding = dwSrcEncoding = Encoding.nCodePage;
            m_dwProperty |= MLCONVCHARF_AUTODETECT ;
        }
        else
        {
            dwSrcEncoding = 1252;
        }

        hr = lpCharConverter->ConvertSetup(&dwSrcEncoding, m_dwDstEncoding);
        if ( hr != S_OK )
        {
            return hr ;
        }
    }

    hr = lpCharConverter->DoCodeConvert(&dwMode, (LPCSTR) pSrcStr, &nSrcSize, (LPSTR) pDstStr, &nDstSize, m_dwProperty, NULL);

    // return the number of bytes processed for the source. 
    if (pcSrcSize)
        *pcSrcSize = lpCharConverter->_nSrcSize ;

    if (pcDstSize)
        *pcDstSize = nDstSize;

    if (pDstStr)
        m_dwMode = dwMode ;

    lpCharConverter->ConvertCleanUp();
    return hr ;
}

STDAPI CMLangConvertCharset::DoConversionToUnicode(CHAR *pSrcStr, UINT *pcSrcSize, WCHAR *pDstStr, UINT *pcDstSize)
{

    HRESULT hr ;
    UINT nByteCountSize = (pcDstSize ? *pcDstSize * sizeof(WCHAR) : 0 ) ;

    DebugMsg(DM_TRACE, TEXT("CMLangConvertCharset::DoConversionToUnicode called."));

    hr = DoConversion((BYTE*)pSrcStr,pcSrcSize,(BYTE*)pDstStr,&nByteCountSize);

    if (pcDstSize)
        *pcDstSize = nByteCountSize / sizeof(WCHAR);

    return hr;
}

STDAPI CMLangConvertCharset::DoConversionFromUnicode(WCHAR *pSrcStr, UINT *pcSrcSize, CHAR *pDstStr, UINT *pcDstSize)
{
    HRESULT hr ;
    UINT nByteCountSize = (pcSrcSize ? *pcSrcSize * sizeof(WCHAR) : 0 ) ;

    DebugMsg(DM_TRACE, TEXT("CMLangConvertCharset::DoConversionFromUnicode called."));

    hr = DoConversion((BYTE*)pSrcStr,&nByteCountSize,(BYTE*)pDstStr,pcDstSize);

    if (pcSrcSize)
        *pcSrcSize = nByteCountSize / sizeof(WCHAR);

    return hr ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\mlang\convinet.cpp ===
#include "private.h"
#include "jisobj.h"
#include "eucjobj.h"
#include "hzgbobj.h"
#include "kscobj.h"

#include "utf8obj.h"
#include "utf7obj.h"

#include "fechrcnv.h"

#include "codepage.h"

#include "ichrcnv.h"



HRESULT CICharConverter::KSC5601ToEUCKR(LPCSTR lpSrcStr, LPINT lpnSrcSize, LPSTR lpDestStr, int cchDest, LPINT lpnSize)
{
    int nSize=0;
    int i=0;
    HRESULT hr = S_OK;
    UCHAR szDefaultChar[3] = {0x3f}; // possible DBCS + null    


    if (_lpFallBack && (_dwFlag & MLCONVCHARF_USEDEFCHAR))
    {
        // only take SBCS, no DBCS character
        if ( 1 != WideCharToMultiByte(CP_KOR_5601, 0,
                               (LPCWSTR)_lpFallBack, 1,
                               (LPSTR)szDefaultChar, ARRAYSIZE(szDefaultChar), NULL, NULL ))
            szDefaultChar[0] = 0x3f;
    }


    while(i < *lpnSrcSize)
    {
        // Check space
        if (lpDestStr && (nSize > cchDest))
            break;

        //  DBCS
        if (((UCHAR)lpSrcStr[i] >= 0x81 && (UCHAR)lpSrcStr[i] <= 0xFE) && (i+1 < *lpnSrcSize))
        {

            // UHC 
            if (!((UCHAR)lpSrcStr[i] >= 0xA1 && (UCHAR)lpSrcStr[i] <= 0xFE &&
                  (UCHAR)lpSrcStr[i+1] >= 0xA1 && (UCHAR)lpSrcStr[i+1] <= 0xFE))

            {
                // use NCR if flag specified
                if (_dwFlag & (MLCONVCHARF_NCR_ENTITIZE|MLCONVCHARF_NAME_ENTITIZE))
                {
                    char    szDstStr[10] = {0};
                    WCHAR   szwChar[2];
                    int     cCount;
               
                    if (MultiByteToWideChar(CP_KOR_5601, 0, &lpSrcStr[i], 2, szwChar, ARRAYSIZE(szwChar)))
                    {
                        // Caculate NCR length
                        _ultoa((unsigned long)szwChar[0], (char*)szDstStr, 10);
                        cCount = lstrlenA(szDstStr)+3;
                        // Not enough space for NCR entity
                        if (lpDestStr)
                        {
                            if (nSize+cCount > cchDest)
                                break;
                            // Output NCR entity
                            else
                            {                                    
                                *lpDestStr ++= '&';
                                *lpDestStr ++= '#';
                                for (int j=0; j< cCount-3; j++)
                                    *lpDestStr++=szDstStr[j];
                                *lpDestStr ++= ';';
                            }
                        }
                        nSize += cCount;
                    }
                    else
                    {
                        if (lpDestStr)
                        {
                            if (nSize+1 > cchDest)
                                break;
                            *lpDestStr++=szDefaultChar[0];
                        }
                        nSize++;
                        hr = S_FALSE;
                    }
                }
                // use default char, question mark
                else
                {
                    if (lpDestStr)
                    {
                        if (nSize+1 > cchDest)
                            break;
                        *lpDestStr++=szDefaultChar[0];
                    }
                    nSize++;
                    hr = S_FALSE;
                }
                i += 2;
            }
            // Wansung
            else
            {
                if (lpDestStr)
                {
                    if (nSize+2 > cchDest)
                        break;
                    *lpDestStr++=lpSrcStr[i];
                    *lpDestStr++=lpSrcStr[i+1];
                }
                i+=2;
                nSize += 2;
            }
        }
        // SBCS
        else
        {
            if (lpDestStr)
            {
                if (nSize+1 > cchDest)
                    break; 
                *lpDestStr++=lpSrcStr[i];
            }
            nSize++;
            i++;
        }
    } // End of loop

    if (lpnSize)
        *lpnSize = nSize;

    return hr;
}


/******************************************************************************
******************   C O N V E R T   I N E T   S T R I N G   ******************
******************************************************************************/
HRESULT CICharConverter::CreateINetString(BOOL fInbound, UINT uCodePage, int nCodeSet)
{
    if (_hcins)
    {
        delete _hcins ;
        _hcins = NULL ;
    }

    if (fInbound) { // Inbound
        if (uCodePage == CP_JPN_SJ && ( nCodeSet == CP_ISO_2022_JP ||
            nCodeSet == CP_ISO_2022_JP_ESC || nCodeSet == CP_ISO_2022_JP_SIO ))
            // JIS
            _hcins = new CInccJisIn(uCodePage, nCodeSet);
        else if (uCodePage == CP_JPN_SJ && nCodeSet == CP_EUC_JP ) // EUC
            _hcins = new CInccEucJIn(uCodePage, nCodeSet);
        else if (uCodePage == CP_CHN_GB && nCodeSet == CP_CHN_HZ ) // HZ-GB
            _hcins = new CInccHzGbIn(uCodePage, nCodeSet);
        else if (uCodePage == CP_KOR_5601 && nCodeSet == CP_ISO_2022_KR )
            _hcins = new CInccKscIn(uCodePage, nCodeSet);
        else if (uCodePage == CP_UCS_2 && nCodeSet == CP_UTF_8 )
            _hcins = new CInccUTF8In(uCodePage, nCodeSet);
        else if (uCodePage == CP_UCS_2 && nCodeSet == CP_UTF_7 )
            _hcins = new CInccUTF7In(uCodePage, nCodeSet);

    } else { // Outbound
        if (uCodePage == CP_JPN_SJ && ( nCodeSet == CP_ISO_2022_JP ||
            nCodeSet == CP_ISO_2022_JP_ESC || nCodeSet == CP_ISO_2022_JP_SIO ))
            // JIS
            _hcins = new CInccJisOut(uCodePage, nCodeSet, _dwFlag, _lpFallBack);
        else if (uCodePage == CP_JPN_SJ && nCodeSet == CP_EUC_JP ) // EUC
            _hcins = new CInccEucJOut(uCodePage, nCodeSet, _dwFlag, _lpFallBack);
        else if (uCodePage == CP_CHN_GB && nCodeSet == CP_CHN_HZ ) // HZ-GB
            _hcins = new CInccHzGbOut(uCodePage, nCodeSet, _dwFlag, _lpFallBack);
        else if (uCodePage == CP_KOR_5601 && nCodeSet == CP_ISO_2022_KR )
            _hcins = new CInccKscOut(uCodePage, nCodeSet, _dwFlag, _lpFallBack);
        else if (uCodePage == CP_UCS_2 && nCodeSet == CP_UTF_8 )
            _hcins = new CInccUTF8Out(uCodePage, nCodeSet);
        else if (uCodePage == CP_UCS_2 && nCodeSet == CP_UTF_7 )
            _hcins = new CInccUTF7Out(uCodePage, nCodeSet);

    }

    // recode the dst codepage
    if ( _hcins )
        _hcins_dst =  nCodeSet ;

    return S_OK ;
}

HRESULT CICharConverter::DoConvertINetString(LPDWORD lpdwMode, BOOL fInbound, UINT uCodePage, int nCodeSet,
      LPCSTR lpSrcStr, LPINT lpnSrcSize, LPSTR lpDestStr, int cchDest, LPINT lpnSize)
{
    HRESULT hr = S_OK;
    HCINS hcins = NULL;
    int nSize = 0 ;
    int cchSrc = *lpnSrcSize ;

    if (!lpnSize)
        lpnSize = &nSize;

    if (!uCodePage) // Get default code page if nothing speicified
        uCodePage = g_uACP;

    if (!lpSrcStr && cchSrc < 0) // Get length of lpSrcStr if not given, assuming lpSrcStr is a zero terminate string.
        cchSrc = lstrlenA(lpSrcStr) + 1;

    if (!_hcins || ( nCodeSet != _hcins_dst ) )
        CreateINetString(fInbound,uCodePage,nCodeSet);

    if (_hcins ) { // Context created, it means DBCS
        int nTempSize = 0 ;
        
        // restore previous mode SO/SI ESC etc.
        ((CINetCodeConverter*)_hcins)->SetConvertMode(*lpdwMode);

        // if it is a JIS output set Kana mode
        if (!fInbound && uCodePage == CP_JPN_SJ && ( nCodeSet == CP_ISO_2022_JP ||
            nCodeSet == CP_ISO_2022_JP_ESC || nCodeSet == CP_ISO_2022_JP_SIO ))
            // JIS
            ((CInccJisOut*)_hcins)->SetKanaMode(nCodeSet);

        if (!lpDestStr || !cchDest) // Get the converted size
        {
            hr = ((CINetCodeConverter*)_hcins)->GetStringSizeA(lpSrcStr, cchSrc, lpnSize);
            if (0 == fInbound) 
            {
                HRESULT _hr = ((CINetCodeConverter*)_hcins)->GetStringSizeA(NULL, 0, &nTempSize);
                if (S_OK != _hr)
                    hr = _hr;
            }
        }
        else // Perform actual converting
        {
            hr = ((CINetCodeConverter*)_hcins)->ConvertStringA(lpSrcStr, cchSrc, lpDestStr, cchDest, lpnSize);
            if (0 == fInbound) 
            {
                HRESULT _hr = ((CINetCodeConverter*)_hcins)->ConvertStringA(NULL, 0, lpDestStr+*lpnSize, cchDest-*lpnSize, &nTempSize);
                if (S_OK != _hr)
                    hr = _hr;
            }
        }

        *lpnSize += nTempSize;

        // get number of unconvetable bytes 
        if ( lpnSrcSize && ((CINetCodeConverter*)_hcins)->GetUnconvertBytes() )
            *lpnSrcSize = cchSrc -((CINetCodeConverter*)_hcins)->GetUnconvertBytes();

        // only save current mode SO/SI ESC if we are perform actual converting
        // we need this if statement because for two stages plus conversion.
        // It will inquire the size first then convert from IWUU or UUWI.

        if (lpDestStr && lpdwMode )
            *lpdwMode = ((CINetCodeConverter*)_hcins)->GetConvertMode();

//        delete hcins;
    } else { 
        // Internet encodings that have same encoding scheme as their family encodings
        switch (nCodeSet)
        {
            case CP_EUC_KR:
                hr = KSC5601ToEUCKR(lpSrcStr, lpnSrcSize, lpDestStr, cchDest, lpnSize);
                break;

            default:
                if (!lpDestStr || !cchDest) // Get the converted size
                   *lpnSize = cchSrc ;
                else
                {
                   *lpnSize = min(cchSrc, cchDest);
                   if (*lpnSize)
                      MoveMemory(lpDestStr, lpSrcStr, *lpnSize);
                }
        }
    }

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\mlang\cpdetect.cpp ===
#include "private.h"
#include "detcbase.h"
#include "codepage.h"
#include "detcjpn.h"
#include "detckrn.h"

#include "fechrcnv.h"

#include "msencode.h"
#include "lcdetect.h"
#include "cpdetect.h"

CCpMRU *g_pCpMRU = NULL;



// Get data from registry and construct cache
HRESULT CCpMRU::Init(void)
{
    BOOL    bRegKeyReady = TRUE;
    HRESULT hr = S_OK;
    HKEY    hkey;

    _pCpMRU = NULL;

    // HKCR\\Software\\Microsoft\internet explorer\\international\\CpMRU
    if (ERROR_SUCCESS != RegOpenKeyEx(HKEY_CURRENT_USER, 
                         REGSTR_PATH_CPMRU,
                         0, KEY_READ|KEY_SET_VALUE, &hkey)) 
    {
        DWORD dwAction = 0;
        if (ERROR_SUCCESS != RegCreateKeyEx(HKEY_CURRENT_USER,
                                REGSTR_PATH_CPMRU,
                                0, NULL, REG_OPTION_NON_VOLATILE, KEY_ALL_ACCESS, NULL, &hkey, &dwAction))
        {
            bRegKeyReady = FALSE;
            dwCpMRUEnable = 0;
            hr = E_FAIL;
        }
    }

    if (bRegKeyReady)
    {
        DWORD dwType = REG_DWORD;
        DWORD dwSize = sizeof(DWORD);
        BOOL  bUseDefault = FALSE;

        if (ERROR_SUCCESS != RegQueryValueEx(hkey, REG_KEY_CPMRU_ENABLE, 0, &dwType, (LPBYTE)&dwCpMRUEnable, &dwSize))
        {
            dwCpMRUEnable = 1;
            RegSetValueEx(hkey, REG_KEY_CPMRU_ENABLE, 0, REG_DWORD, (LPBYTE)&dwCpMRUEnable, sizeof(dwCpMRUEnable));
        }

        // If fail to open registry data or find unreasonable cache parameters, use default settings
        if ((ERROR_SUCCESS != RegQueryValueEx(hkey, REG_KEY_CPMRU_NUM, 0, &dwType, (LPBYTE)&dwCpMRUNum, &dwSize)) ||
            (ERROR_SUCCESS != RegQueryValueEx(hkey, REG_KEY_CPMRU_INIT_HITS, 0, &dwType, (LPBYTE)&dwCpMRUInitHits, &dwSize)) ||
            (ERROR_SUCCESS != RegQueryValueEx(hkey, REG_KEY_CPMRU_PERCENTAGE_FACTOR, 0, &dwType, (LPBYTE)&dwCpMRUFactor, &dwSize)) ||
            (dwCpMRUNum > MAX_CPMRU_NUM) || !dwCpMRUFactor || !dwCpMRUInitHits)
        {
            dwCpMRUNum = DEFAULT_CPMRU_NUM;
            dwCpMRUInitHits = DEFAULT_CPMRU_INIT_HITS;
            dwCpMRUFactor = DEFAULT_CPMRU_FACTOR;
            bUseDefault = TRUE;

            // Store default value in registry
            RegSetValueEx(hkey, REG_KEY_CPMRU_NUM, 0, REG_DWORD, (LPBYTE)&dwCpMRUNum, sizeof(dwCpMRUNum));
            RegSetValueEx(hkey, REG_KEY_CPMRU_INIT_HITS, 0, REG_DWORD, (LPBYTE)&dwCpMRUInitHits, sizeof(dwCpMRUInitHits));
            RegSetValueEx(hkey, REG_KEY_CPMRU_PERCENTAGE_FACTOR, 0, REG_DWORD, (LPBYTE)&dwCpMRUFactor, sizeof(dwCpMRUFactor));
        }

        dwSize = sizeof(CODEPAGE_MRU)*dwCpMRUNum;

        if (!dwSize || NULL == (_pCpMRU = (PCODEPAGE_MRU)LocalAlloc(LPTR, dwSize)))
        {
            hr = E_FAIL;
            dwCpMRUEnable = 0;
        }

        if (_pCpMRU && !bUseDefault)
        {
            dwType = REG_BINARY;        

            if (ERROR_SUCCESS != RegQueryValueEx(hkey, REG_KEY_CPMRU, 0, &dwType, (LPBYTE)_pCpMRU, &dwSize))
            {
                ZeroMemory(_pCpMRU,sizeof(CODEPAGE_MRU)*dwCpMRUNum);
            }
        }
        RegCloseKey(hkey);      
    }

    return hr;
}

// Update registry's cache value
CCpMRU::~CCpMRU(void)
{
    HKEY hkey;

    if (bCpUpdated)
    {

        if (RegOpenKeyEx(HKEY_CURRENT_USER, 
                     REGSTR_PATH_CPMRU,
                     0, KEY_READ|KEY_SET_VALUE, &hkey) == ERROR_SUCCESS) 
        {                
            DWORD dwType = REG_BINARY;
            DWORD dwSize = sizeof(CODEPAGE_MRU)*dwCpMRUNum;
            if (_pCpMRU)
            {
                RegSetValueEx(hkey, REG_KEY_CPMRU, 0, dwType, (LPBYTE)_pCpMRU, dwSize);
                LocalFree(_pCpMRU);
                _pCpMRU = NULL;
            }

            RegCloseKey(hkey);
        }
        bCpUpdated = FALSE;
            
    }
}

HRESULT CCpMRU::GetCpMRU(PCODEPAGE_MRU pCpMRU, UINT *puiCpNum)
{
        DWORD   dwTotalHits = 0;
        UINT    i;
        HRESULT hr = E_FAIL;

        if (!(*puiCpNum))
            return E_INVALIDARG;

        if (!_pCpMRU)
            return hr;

        if (!dwCpMRUEnable || !dwCpMRUInitHits)
        {
            *puiCpNum = 0;
            return S_FALSE;
        }

        ZeroMemory(pCpMRU, sizeof(CODEPAGE_MRU)*(*puiCpNum));

        // Get total hits acount
        for (i=0; i<dwCpMRUNum; i++)
        {
            if (_pCpMRU[i].dwHistoryHits)
                dwTotalHits += _pCpMRU[i].dwHistoryHits;
            else
                break;  
        }

        // Not enough hits count to determin the result, keep collecting
        if (dwTotalHits < dwCpMRUInitHits)
        {
            *puiCpNum = 0;
            return S_FALSE;
        }

        for (i=0; i<dwCpMRUNum && i<*puiCpNum; i++)
        {
            // Percentage is 1/MIN_CPMRU_FACTOR
            if (_pCpMRU[i].dwHistoryHits*dwCpMRUFactor/dwTotalHits < 1)
                break;
        }

        if (i != 0)
        {
            CopyMemory(pCpMRU, _pCpMRU, sizeof(CODEPAGE_MRU)*(i));
            *puiCpNum = i;
            hr = S_OK;
        }

        return hr;

}

// Update code page MRU
void CCpMRU::UpdateCPMRU(DWORD dwEncoding)
{
        UINT i,j;

        if (!_pCpMRU)
            return;

        if ((dwEncoding == CP_AUTO) ||
            (dwEncoding == CP_JP_AUTO) ||
            (dwEncoding == CP_KR_AUTO))
            return;

        if (!bCpUpdated)
            bCpUpdated = TRUE;


        // Sorted         
        for (i=0; i< dwCpMRUNum; i++)
        {
            if (!_pCpMRU[i].dwEncoding || (_pCpMRU[i].dwEncoding == dwEncoding))
                break;
        }

        // If not found, replace the last encoding
        if (i == dwCpMRUNum)
        {
            _pCpMRU[dwCpMRUNum-1].dwEncoding = dwEncoding;
            _pCpMRU[dwCpMRUNum-1].dwHistoryHits = 1;
        }
        else
        {
            _pCpMRU[i].dwHistoryHits ++;

            // If it is an already exist encoding, change order as needed
            if (_pCpMRU[i].dwEncoding)
            {
                for (j=i; j>0; j--)
                {
                    if (_pCpMRU[j-1].dwHistoryHits >= _pCpMRU[i].dwHistoryHits)
                    {
                        break;
                    }
                }
                if (j < i)
                {
                    // Simple sorting
                    CODEPAGE_MRU tmpCPMRU  = _pCpMRU[i];

                    MoveMemory(&_pCpMRU[j+1], &_pCpMRU[j], (i-j)*sizeof(CODEPAGE_MRU));
                    _pCpMRU[j].dwEncoding = tmpCPMRU.dwEncoding;
                    _pCpMRU[j].dwHistoryHits = tmpCPMRU.dwHistoryHits;

                }

            }
            else
            {
                _pCpMRU[i].dwEncoding = dwEncoding;
            }

        }

        // Cached too many hits?
        if (_pCpMRU[0].dwHistoryHits > 0xFFFFFFF0)
        {
            // Find the smallest one
            // This loop will always terminate
            // because at worst, it will stop at i=0 (which we know
            // is a huge number from the "if" above).
            for (i=dwCpMRUNum-1; ; i--)
            {
                if (_pCpMRU[i].dwHistoryHits > 1)
                    break;
            }

            // Decrease Cache value
            for (j=0; j<dwCpMRUNum && _pCpMRU[j].dwHistoryHits; j++)
            {
                // We still keep those one hit encodings if any
                _pCpMRU[j].dwHistoryHits /= _pCpMRU[i].dwHistoryHits;
            }
        }
}


UINT CheckEntity(LPSTR pIn, UINT nIn)
{
    UINT uiRet = 0;
    UINT uiSearchRange;
    UINT i;
    
    uiSearchRange = (nIn > MAX_ENTITY_LENTH)? MAX_ENTITY_LENTH:nIn;

    if (*pIn == '&')
    {
        for(i=0; i<uiSearchRange; i++)
        {
            if (pIn[i] == ';')
                break;
        }
        if (i < uiSearchRange)
        {
            uiSearchRange = i+1;
            // NCR Entity
            if (pIn[1] == '#')
            {
                for (i=2; i<uiSearchRange-1; i++)
                    if (!IS_DIGITA(pIn[i]))
                    {
                        uiSearchRange = 0;
                        break;
                    }
            }
            // Name Entity
            else
            {
                for (i=1; i<uiSearchRange-1; i++)
                    if (!IS_CHARA(pIn[i]))
                    {
                        uiSearchRange = 0;
                        break;
                    }
            }
        }
        else
        {
            uiSearchRange = 0;
        }
    }
    else
    {
        uiSearchRange = 0;
    }

    return uiSearchRange;
}

void RemoveHtmlTags (LPSTR pIn, UINT *pnBytes)
//
// Remove HTML tags from pIn and compress whitespace, in-place.
// On input *pnBytes is the input length; on return *pnBytes is 
// set to the resulting length.
//
// Name Entity and NCR Entity strings also removed
{
    UINT    nIn = *pnBytes;
    UINT    nOut = 0;
    UINT    nEntity = 0;
    LPSTR   pOut = pIn;
    BOOL    fSkippedSpace = FALSE;


    while ( nIn > 0 /*&& nOut + 2 < *pnBytes */) {

        if (*pIn == '<' && nIn > 1/* && !IsNoise (pIn[1])*/) {

            // Discard text until the end of this tag.  The handling here
            // is pragmatic and imprecise; what matters is detecting mostly
            // contents text, not tags or comments.
            pIn++;
            nIn--;

            LPCSTR pSkip;
            DWORD nLenSkip;

            if ( nIn > 1 && *pIn == '%' )
            {
                pSkip = "%>";           // Skip <% to %> 
                nLenSkip = 2;
            }
            else if ( nIn > 3 && *pIn == '!' && !LowAsciiStrCmpNIA(pIn, "!--", 3) )
            {
                pSkip = "-->";          // Skip <!-- to -->
                nLenSkip = 3;
            }
            else if ( nIn > 5 && !LowAsciiStrCmpNIA(pIn, "style", 5) )
            {
                pSkip = "</style>";     // Skip <style ...> to </style>
                nLenSkip = 8;
            }
            else if ( nIn > 6 && !LowAsciiStrCmpNIA(pIn, "script", 6) )
            {
                pSkip = "</script>";    // Skip <script ...> to </script>
                nLenSkip = 9;
            }
            else if ( nIn > 3 && !LowAsciiStrCmpNIA(pIn, "xml", 3) )
            {
                pSkip = "</xml>";
                nLenSkip = 6;
            }
            else
            {
                pSkip = ">";            // match any end tag
                nLenSkip = 1;
            }

            // Skip up to a case-insensitive match of pSkip / nLenSkip

            while ( nIn > 0 )
            {
                // Spin fast up to a match of the first char.
                // NOTE: the first-char compare is NOT case insensitive
                // because this char is known to never be alphabetic.

                while ( nIn > 0 && *pIn != *pSkip )
                {
                    pIn++;
                    nIn--;
                }

                if ( nIn > nLenSkip && !LowAsciiStrCmpNIA(pIn, pSkip, nLenSkip) )
                {
                    pIn += nLenSkip;
                    nIn -= nLenSkip;
                    fSkippedSpace = TRUE;

                    break;
                }

                if ( nIn > 0)
                {
                    pIn++;
                    nIn--;
                }
            }

            // *pIn is either one past '>' or at end of input

        } 
        else 
            if (IsNoise (*pIn) || (nEntity = CheckEntity(pIn, nIn)))
            {       
            
                // Collapse whitespace -- remember it but don't copy it now
                fSkippedSpace = TRUE;       
                if (nEntity)
                {
                    pIn+=nEntity;
                    nIn-=nEntity;
                    nEntity = 0;
                }
                else
                {
                    while (nIn > 0 && IsNoise (*pIn))
                    pIn++, nIn--;
                }
            } 
            // *pIn is non-ws char
            else 
            {
                // Pass through all other characters
                // Compress all previous noise characters to a white space
                if (fSkippedSpace) 
                {
                    *pOut++ = ' ';
                    nOut++;
                    fSkippedSpace = FALSE;
                }

                *pOut++ = *pIn++;
                nIn--;
                nOut++;
            }
    }

    *pnBytes = nOut;
}

static unsigned char szKoi8ru[] = {0xA4, 0xA6, 0xA7, 0xB4, 0xB6, 0xB7, 0xAD, 0xAE, 0xBD, 0xBE};
static unsigned char sz28592[]  = {0xA1, 0xA6, /*0xAB,*/ 0xAC, 0xB1, 0xB5, 0xB6, 0xB9, /*0xBB, 0xE1*/}; // Need to fine tune this data

const CPPATCH CpData[] = 
{
    {CP_KOI8R,  CP_KOI8RU,      ARRAYSIZE(szKoi8ru),    szKoi8ru},
    {CP_1250,   CP_ISO_8859_2,  ARRAYSIZE(sz28592),     sz28592},
};


// Distinguish similar western encodings
UINT PatchCodePage(UINT uiEncoding, unsigned char *pStr, int nSize)
{
    int i, l,m, n, iPatch=0;

    while (iPatch < ARRAYSIZE(CpData))
    {
        if (uiEncoding == CpData[iPatch].srcEncoding)
        { 
            for (i=0; i<nSize; i++)
            {
                if (*pStr > HIGHEST_ASCII)
                {
                    l = 0;
                    m = CpData[iPatch].nSize-1;
                    n = m / 2;
                    while (l <= m)
                    {
                        if (*pStr == CpData[iPatch].pszUch[n])
                            return CpData[iPatch].destEncoding;
                        else
                        {
                            if (*pStr < CpData[iPatch].pszUch[n])
                            {
                                m = n-1;
                            }
                            else
                            {
                                l = n+1;
                            }
                            n = (l+m)/2;
                        }
                    }
                }
                pStr++;
            }
        }
        iPatch++;
    }

    return uiEncoding;
}



#if 0

const unsigned char szKOIRU[] = {0xA4, 0xA6, 0xA7, 0xB4, 0xB6, 0xB7, 0xAD, 0xAE, 0xBD, 0xBE};

BOOL _IsKOI8RU(unsigned char *pStr, int nSize)
{
    int     i,j;
    BOOL    bRet = FALSE;

    // Skip parameter check since this is internal
    for (i=0; i<nSize; i++)
    {
        if (*pStr >= szKOIRU[0] && *pStr <= szKOIRU[ARRAYSIZE(szKOIRU)-1])
        {
            for (j=0; j<ARRAYSIZE(szKOIRU); j++)
            {
                if (*pStr == szKOIRU[j])
                {
                    bRet = TRUE;
                    break;
                    
                }
            }
        }

        if (bRet)
            break;

        pStr++;
    }

    return bRet;
}

#endif


HRESULT WINAPI _DetectInputCodepage(DWORD dwFlag, DWORD uiPrefWinCodepage, CHAR *pSrcStr, INT *pcSrcSize, DetectEncodingInfo *lpEncoding, INT *pnScores)
{

    HRESULT hr = S_OK;
    IStream *pstmTmp = NULL;
    BOOL bGuess = FALSE;
    BOOL bLCDetectSucceed = FALSE;
    int nBufSize = *pnScores;
    CHAR *_pSrcStr = pSrcStr;
    UINT nSrcSize;
    int  i;
    BOOL bMayBeAscii = FALSE;

    // Check parameters
    if (!pSrcStr || !(*pcSrcSize) || !lpEncoding || *pnScores == 0)
        return E_INVALIDARG;

    nSrcSize = *pcSrcSize;

    // Zero out return buffer
    ZeroMemory(lpEncoding, sizeof(DetectEncodingInfo)*(*pnScores));

    // Simple Unicode detection
    if (nSrcSize >= sizeof(WCHAR))
    {
        UINT uiCp = 0;

        if (*((WCHAR *)pSrcStr) == 0xFEFF)      // Unicode
            uiCp = CP_UCS_2;
        else if (*((WCHAR *)pSrcStr) == 0xFFFE) // Uncode Big Endian
            uiCp = CP_UCS_2_BE;

        if (uiCp)
        {
            *pnScores = 1;
            lpEncoding[0].nCodePage = uiCp;
            lpEncoding[0].nConfidence = 100;
            lpEncoding[0].nDocPercent = 100;
            lpEncoding[0].nLangID = -1;
            return S_OK;
        }
    }
    
    // HTML: take off HTML 'decoration'
    if (dwFlag & MLDETECTCP_HTML)
    {
        // Dup buffer for HTML parser
        if (NULL == (_pSrcStr = (char *)LocalAlloc(LPTR, nSrcSize)))
            return E_OUTOFMEMORY;        
        CopyMemory(_pSrcStr, pSrcStr, nSrcSize);
        RemoveHtmlTags (_pSrcStr, &nSrcSize);
    }

    // if blank page/file...
    if (!nSrcSize)
        return E_FAIL;

    if (nSrcSize >= MIN_TEXT_SIZE)
    {
        // Initialize LCDetect
        if (NULL == g_pLCDetect) 
        {
            EnterCriticalSection(&g_cs);
            if (NULL == g_pLCDetect)
            {
                LCDetect *pLC = new LCDetect ((HMODULE)g_hInst);
                if (pLC)
                {
                    if (pLC->LoadState() == NO_ERROR)
                        g_pLCDetect = pLC;
                    else
                    {
                        delete pLC;                    
                    }
                }
            }
            LeaveCriticalSection(&g_cs);
        }

        if (g_pLCDetect)
        {
            LCD_Detect(_pSrcStr, nSrcSize, (PLCDScore)lpEncoding, pnScores, NULL);
            if (*pnScores)
            {
                hr = S_OK;
                bLCDetectSucceed = TRUE;
            }
        }
    }

    if (!bLCDetectSucceed)
    {
        *pnScores = 0;
        hr = E_FAIL;
    }
    
    unsigned int uiCodepage = 0;        
    LARGE_INTEGER li = {0,0};
    ULARGE_INTEGER uli = {0,0};


    if (S_OK == CreateStreamOnHGlobal(NULL, TRUE, &pstmTmp))
    {
        ULONG cb = (ULONG) nSrcSize ;
        if (S_OK == pstmTmp->Write(_pSrcStr,cb,&cb))
        {
            uli.LowPart = cb ;
            if (S_OK != pstmTmp->SetSize(uli))
            {
                hr = E_OUTOFMEMORY;
                goto DETECT_DONE;
            }
        }
        else
        {
            goto DETECT_DONE;
        }
    }
    else
    {
        hr = E_OUTOFMEMORY;
        goto DETECT_DONE;
    }
       
    pstmTmp->Seek(li,STREAM_SEEK_SET, NULL);

    switch (CceDetectInputCode(pstmTmp, grfDetectResolveAmbiguity|grfDetectUseCharMapping|grfDetectIgnoreEof, (EFam) 0, 0, &uiCodepage, &bGuess))
    {
        case cceSuccess:  
            if (*pnScores)
            {
                // LCDETECT never detects wrong on Arabic and Russian, don't consider it as DBCS in this case
                // because MSEncode might misdetect Arabic and Russian as Japanese
                // Same goes for Korean JOHAB, MSENCODE doesn't support it at all
                if (((lpEncoding[0].nLangID == LANG_ARABIC )|| (lpEncoding[0].nLangID == LANG_RUSSIAN) || (lpEncoding[0].nCodePage == CP_KOR_JOHAB)) &&
                    (lpEncoding[0].nConfidence >= MIN_ACCEPTABLE_CONFIDENCE) 
                    && (lpEncoding[0].nDocPercent >= MIN_DOCPERCENT) && !bGuess)
                    bGuess = TRUE;

                for (i=0;i<*pnScores;i++)
                {
                    if (lpEncoding[i].nCodePage == uiCodepage)
                    {
                        if ((i != 0) && !bGuess)
                        {
                            DetectEncodingInfo TmpEncoding;
                            // Re-arrange lanugage list for MSEncode result
                            MoveMemory(&TmpEncoding, &lpEncoding[0], sizeof(DetectEncodingInfo));
                            MoveMemory(&lpEncoding[0], &lpEncoding[i], sizeof(DetectEncodingInfo));
                            MoveMemory(&lpEncoding[i], &TmpEncoding, sizeof(DetectEncodingInfo));
                        }
                        // Boost confidence for double hits
                        lpEncoding[0].nDocPercent = 100;
                        if (lpEncoding[0].nConfidence < 100)
                            lpEncoding[0].nConfidence = 100;
                        break;
                    }
                }

                if (i == *pnScores)
                {
                    if (bGuess)
                    {
                        if (nBufSize > *pnScores)
                        {
                            lpEncoding[*pnScores].nCodePage = uiCodepage;
                            lpEncoding[*pnScores].nConfidence = MIN_CONFIDENCE;
                            lpEncoding[*pnScores].nDocPercent = MIN_DOCPERCENT;
                            lpEncoding[*pnScores].nLangID = -1;
                            (*pnScores)++;
                        }
                    }
                    else
                    {
                        if (nBufSize > *pnScores)
                        {
                            MoveMemory(lpEncoding+1, lpEncoding, sizeof(DetectEncodingInfo) * (*pnScores));
                            (*pnScores)++;
                        }
                        else
                        {
                            MoveMemory(lpEncoding+1, lpEncoding, sizeof(DetectEncodingInfo) * (*pnScores-1));
                        }
                        lpEncoding[0].nCodePage = uiCodepage;
                        lpEncoding[0].nConfidence = 100;
                        lpEncoding[0].nDocPercent = MIN_DOCPERCENT;
                        lpEncoding[0].nLangID = -1;
                    }
                }

            }
            else
            {
                lpEncoding[0].nCodePage = uiCodepage;
                if (bGuess) 
                    lpEncoding[0].nConfidence = MIN_CONFIDENCE;
                else
                    lpEncoding[0].nConfidence = 100;
                lpEncoding[0].nDocPercent = MIN_DOCPERCENT;
                lpEncoding[0].nLangID = -1;
                (*pnScores)++;
            }

            //hr = (g_pLCDetect || (nSrcSize < MIN_TEXT_SIZE)) ? S_OK : S_FALSE;
            hr = (!g_pLCDetect || (bGuess && !bLCDetectSucceed )) ? S_FALSE : S_OK;
            break;

        // Currently MSEncode doesn't provide any useful information in 'cceAmbiguousInput' case.
        // We may update our code here if Office team enhance MSEncode for ambiguous input later.
        case cceAmbiguousInput:
            break;

        case cceMayBeAscii:
            bMayBeAscii = TRUE;
            if (!(*pnScores))
            {
                lpEncoding[0].nCodePage = uiCodepage;
                lpEncoding[0].nConfidence = MIN_CONFIDENCE;
                lpEncoding[0].nDocPercent = -1;
                lpEncoding[0].nLangID = -1;
                (*pnScores)++;
            }
            else
            {
                for (i=0;i<*pnScores;i++)
                {
                    if (lpEncoding[i].nCodePage == uiCodepage)
                    {
                        break;
                    }
                }

                if (i == *pnScores)
                {
                    if(nBufSize > *pnScores) // Append MSEncode result to the language list
                    {
                       lpEncoding[i].nCodePage = uiCodepage;
                       lpEncoding[i].nConfidence = -1;
                       lpEncoding[i].nDocPercent = -1;
                       lpEncoding[i].nLangID = -1;
                       (*pnScores)++;
                    }
                }
            }
            hr = bLCDetectSucceed ? S_OK : S_FALSE;
            break;

        // MSEncode failed
        default:
            break;
    }




    for (i=0; i<*pnScores; i++)
    {
        switch (lpEncoding[i].nCodePage) {

            case 850:
                if ((*pnScores>1) && (lpEncoding[1].nConfidence >= MIN_CONFIDENCE))
                {
                    // Remove 850 from detection result if there is other detection results
                    (*pnScores)--;
                    if (i < *pnScores)
                        MoveMemory(&lpEncoding[i], &lpEncoding[i+1], (*pnScores-i)*sizeof(DetectEncodingInfo));
                    ZeroMemory(&lpEncoding[*pnScores], sizeof(DetectEncodingInfo));
                }
                else
                {
                    // Replace it with 1252 if it is the only result we get
                    lpEncoding[0].nCodePage = CP_1252; 
                    lpEncoding[0].nConfidence =
                    lpEncoding[0].nDocPercent = 100;
                    lpEncoding[0].nLangID = LANG_ENGLISH;
                }
                break;

            case CP_1250:
            case CP_KOI8R:
                lpEncoding[i].nCodePage = PatchCodePage(lpEncoding[i].nCodePage, (unsigned char *)_pSrcStr, nSrcSize);
                break;

            default:
                break;
        }
    }

    // If not a high confidence CP_1254 (Windows Turkish), 
    // we'll check if there're better detection results, and swap results if needed
    if ((lpEncoding[0].nCodePage == CP_1254) &&
        (*pnScores>1) && 
        ((lpEncoding[0].nDocPercent < 90) || (lpEncoding[1].nCodePage == CP_CHN_GB) || 
        (lpEncoding[1].nCodePage == CP_TWN) || (lpEncoding[1].nCodePage == CP_JPN_SJ) || (lpEncoding[1].nCodePage == CP_KOR_5601)))
    {
        MoveMemory(&lpEncoding[0], &lpEncoding[1], sizeof(DetectEncodingInfo)*(*pnScores-1));
        lpEncoding[*pnScores-1].nCodePage = CP_1254;
        lpEncoding[*pnScores-1].nLangID = LANG_TURKISH;
    }

    // 852 and 1258 text only have one sure detection result
    if (((lpEncoding[0].nCodePage == CP_852) || (lpEncoding[0].nCodePage == CP_1258)) &&
        (*pnScores>1) && 
        (lpEncoding[1].nConfidence >= MIN_CONFIDENCE))
    {
        DetectEncodingInfo tmpDetect = {0};
        MoveMemory(&tmpDetect, &lpEncoding[0], sizeof(DetectEncodingInfo));
        MoveMemory(&lpEncoding[0], &lpEncoding[1], sizeof(DetectEncodingInfo));
        MoveMemory(&lpEncoding[1], &tmpDetect, sizeof(DetectEncodingInfo));
    }

// Considering guessed value from MSENCODE is pretty accurate, we don't change S_OK to S_FALSE
#if 0
    if ((S_OK == hr) && !bLCDetectSucceed && bGuess) 
    {
        hr = S_FALSE;
    }
#endif

    if (uiPrefWinCodepage && *pnScores)
    {
        if (uiPrefWinCodepage == CP_AUTO && g_pCpMRU && !IS_ENCODED_ENCODING(lpEncoding[0].nCodePage))
        {
            UINT uiCpNum = CP_AUTO_MRU_NUM;
            CODEPAGE_MRU CpMRU[CP_AUTO_MRU_NUM];

            if (S_OK == g_pCpMRU->GetCpMRU(CpMRU, &uiCpNum))
            {
                for (i = 0; i<*pnScores; i++)
                {
                    for (UINT j = 0; j < uiCpNum; j++)
                    {
                        if (lpEncoding[i].nCodePage == CpMRU[j].dwEncoding)
                        {
                            uiPrefWinCodepage = CpMRU[j].dwEncoding;
                            break;
                        }
                    }
                    if (uiPrefWinCodepage != CP_AUTO)
                        break;
                }

                // If detection result is not in MRU
                if (uiPrefWinCodepage == CP_AUTO)
                {
                    // Don't take Unicode as perferred encoding if it is not in detection results for following reasons
                    // 1. Unicode is usually tagged with charset or Unicode BOM
                    // 2. Currently, we don't support Unicode detection in all detection engines
                    if (CpMRU[0].dwEncoding != CP_UCS_2 && CpMRU[0].dwEncoding != CP_UCS_2_BE)
                        uiPrefWinCodepage = CpMRU[0].dwEncoding;
                }
            }
        }

        // End preferred CP check if we can't get a valid one
        if (uiPrefWinCodepage == CP_AUTO)
            goto PREFERCPCHECK_DONE;

        for (i = 1; i<*pnScores; i++)
        {
            if (uiPrefWinCodepage == lpEncoding[i].nCodePage)
            {
                DetectEncodingInfo TmpEncoding;
                // Re-arrange lanugage list for prefered codepage
                TmpEncoding = lpEncoding[i];
                MoveMemory(&lpEncoding[1], &lpEncoding[0], sizeof(DetectEncodingInfo)*i);
                lpEncoding[0] = TmpEncoding;
                break;
            }
        }

        if ((uiPrefWinCodepage != lpEncoding[0].nCodePage) && 
            ((bMayBeAscii && (lpEncoding[0].nConfidence <= MIN_CONFIDENCE)) ||
            (hr != S_OK && nSrcSize >= MIN_TEXT_SIZE) ||
            (nSrcSize < MIN_TEXT_SIZE && !IS_ENCODED_ENCODING(lpEncoding[0].nCodePage))))
        {
            lpEncoding[0].nCodePage = uiPrefWinCodepage;
            lpEncoding[0].nConfidence = -1;
            lpEncoding[0].nDocPercent = -1;
            lpEncoding[0].nLangID = -1;
            *pnScores = 1;
        }
    }

PREFERCPCHECK_DONE:

    // Assume LCDETECT won't misdetect 1252 for files over MIN_TEXT_SIZE
    // and MSENCODE can handle encoded text even they're below MIN_TEXT_SIZE
    if (((nSrcSize < MIN_TEXT_SIZE) && (bMayBeAscii || E_FAIL == hr)) ||
        (lpEncoding[0].nCodePage == CP_1252) ||
        (lpEncoding[0].nCodePage == CP_UTF_8))
    {
        UINT j;
        for (j=0; j < nSrcSize; j++)
            if (*((LPBYTE)(_pSrcStr+j)) > HIGHEST_ASCII)
                break;
        if (j == nSrcSize)
        {
            if (lpEncoding[0].nCodePage == CP_1252)
            {
                lpEncoding[0].nCodePage = CP_20127;
            }
            else
            {
                *pnScores = 1;
                lpEncoding[0].nCodePage = CP_20127; 
                lpEncoding[0].nConfidence =
                lpEncoding[0].nDocPercent = 100;
                lpEncoding[0].nLangID = LANG_ENGLISH;
                hr = S_OK;
            }
        }
    }

    // UTF-8 doesn't really have distinctive signatures, 
    // if text amout is small, we won't return low confidence UTF-8 detection result.
    if (hr == S_FALSE && IS_ENCODED_ENCODING(lpEncoding[0].nCodePage) &&
        !((nSrcSize < MIN_TEXT_SIZE) && (lpEncoding[0].nCodePage == CP_UTF_8)))
        hr = S_OK;

DETECT_DONE:

    if ((dwFlag & MLDETECTCP_HTML) && _pSrcStr)
        LocalFree(_pSrcStr);

    if (pstmTmp)
    {
        pstmTmp->Release();
    }

    return hr ;
}

HRESULT WINAPI _DetectCodepageInIStream(DWORD dwFlag, DWORD uiPrefWinCodepage, IStream *pstmIn, DetectEncodingInfo *lpEncoding, INT *pnScores)
{

    HRESULT hr= S_OK, hrWarnings=S_OK;
    LARGE_INTEGER  libOrigin = { 0, 0 };
    ULARGE_INTEGER  ulPos = {0, 0};
    LPSTR lpstrIn = NULL ; 
    ULONG nlSrcSize ;
    INT nSrcUsed ;

    if (!pstmIn)
        return E_INVALIDARG ;

    // get size
    hr = pstmIn->Seek(libOrigin, STREAM_SEEK_END,&ulPos);
    if (S_OK != hr)
        hrWarnings = hr;

    if ( ulPos.LowPart == 0 && ulPos.HighPart == 0 )
        return E_INVALIDARG ;

    nlSrcSize = ulPos.LowPart ;

    // allocate a temp input buffer 
    if ( (lpstrIn = (LPSTR) LocalAlloc(LPTR, nlSrcSize )) == NULL )
    {
        hrWarnings = E_OUTOFMEMORY ;
        goto exit;
    }

    // reset the pointer
    hr = pstmIn->Seek(libOrigin, STREAM_SEEK_SET, NULL);
    if (S_OK != hr)
        hrWarnings = hr;

    hr = pstmIn->Read(lpstrIn, nlSrcSize, &nlSrcSize);
    if (S_OK != hr)
        hrWarnings = hr;

    nSrcUsed = (INT) nlSrcSize ;
    hr = _DetectInputCodepage(dwFlag, uiPrefWinCodepage, lpstrIn, &nSrcUsed, lpEncoding, pnScores);

exit :
    if (lpstrIn)
    {
        LocalFree(lpstrIn);
    }

    return (hr == S_OK) ? hrWarnings : hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\mlang\cpdetect.h ===
#ifndef _CPDETECT_H_
#define _CPDETECT_H_

#define MAX_CONFIDENCE     100  
#define MIN_CONFIDENCE     86
#define MIN_DOCPERCENT     60
#define MIN_TEXT_SIZE      200
#define HIGHEST_ASCII      127
#define MIN_ACCEPTABLE_CONFIDENCE   60

#define DEFAULT_CPMRU_INIT_HITS 100
#define DEFAULT_CPMRU_FACTOR    20
#define CP_AUTO_MRU_NUM         6
#define DEFAULT_CPMRU_NUM       10
#define MAX_CPMRU_NUM           20
#define MAX_ENTITY_LENTH        10

#define IsNoise(c) ((unsigned)(c) <= 0x20 && (c) != 0 && (c) != 0x1B)
#define IS_ENCODED_ENCODING(cp) ((cp) == CP_ISO_2022_JP || (cp) == CP_CHN_HZ || (cp) == CP_UTF_7 || (cp) == CP_UTF_8 || (cp) == CP_ISO_2022_KR)

typedef struct _CODEPAGE_MRU 
{
    DWORD   dwEncoding;
    DWORD   dwHistoryHits;
} CODEPAGE_MRU, *PCODEPAGE_MRU;

typedef struct tagCpPatch
{
    UINT            srcEncoding;
    UINT            destEncoding;
    UINT            nSize;
    unsigned char   *pszUch;
} CPPATCH;

// Dump everything under
// HKCU\\Software\\Microsoft\\Internet Explorer\\International
#define REGSTR_PATH_CPMRU TSZMICROSOFTPATH TEXT("\\Internet Explorer\\International\\CpMRU")
#define REG_KEY_CPMRU                   TEXT("Cache")
#define REG_KEY_CPMRU_ENABLE            TEXT("Enable")
#define REG_KEY_CPMRU_NUM               TEXT("Size")
#define REG_KEY_CPMRU_INIT_HITS         TEXT("InitHits")
#define REG_KEY_CPMRU_PERCENTAGE_FACTOR TEXT("Factor")


// CCpMRU
class CCpMRU
{
    PCODEPAGE_MRU   _pCpMRU;

    DWORD           dwCpMRUNum;
    DWORD           dwCpMRUInitHits;
    DWORD           dwCpMRUFactor;

public:
    DWORD           dwCpMRUEnable;
    BOOL            bCpUpdated;

    CCpMRU::CCpMRU(void)
    {
        // No update at initial time
        bCpUpdated = FALSE;
        _pCpMRU = NULL;
    }

    ~CCpMRU(void);
    HRESULT Init(void);
    HRESULT GetCpMRU(PCODEPAGE_MRU pCpMRU, UINT *puiCpNum);
    void UpdateCPMRU(DWORD dwEncoding);

};
void RemoveHtmlTags (LPSTR pIn, UINT *pnBytes);
UINT PatchCodePage(UINT uiEncoding, unsigned char *pStr, int nSize);
extern class CCpMRU * g_pCpMRU;

#endif  // _CPDETECT_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\mlang\convobj.h ===
#ifndef _CONVOBJ_H_
#define _CONVOBJ_H_

#ifdef  __cplusplus

#include "mlatl.h"
#include "fechrcnv.h"
#include "convbase.h"
#include "ichrcnv.h"

//
//  CMLangConvertCharset declaration with IMLangConvertCharset Interface
//
class ATL_NO_VTABLE CMLangConvertCharset :
    public CComObjectRoot,
    public CComCoClass<CMLangConvertCharset, &CLSID_CMLangConvertCharset>,
    public IMLangConvertCharset
{
public:
    CMLangConvertCharset(void);
    ~CMLangConvertCharset(void);

    DECLARE_NO_REGISTRY()

    BEGIN_COM_MAP(CMLangConvertCharset)
        COM_INTERFACE_ENTRY(IMLangConvertCharset)
    END_COM_MAP()

public:
    // IMLangConvertCharset
    STDMETHOD(Initialize)(UINT uiSrcCodePage, UINT uiDstCodePage, DWORD dwProperty);
    STDMETHOD(GetSourceCodePage)(UINT *puiSrcCodePage);
    STDMETHOD(GetDestinationCodePage)(UINT *puiDstCodePage);
    STDMETHOD(GetDeterminedSrcCodePage)(UINT *puiCodePage);
    STDMETHOD(GetProperty)(DWORD *pdwProperty);
    STDMETHOD(DoConversion)(BYTE *pSrcStr, UINT *pcSrcSize, BYTE *pDstStr, UINT *pcDstSize);
    STDMETHOD(DoConversionToUnicode)(CHAR *pSrcStr, UINT *pcSrcSize, WCHAR *pDstStr, UINT *pcDstSize);
    STDMETHOD(DoConversionFromUnicode)(WCHAR *pSrcStr, UINT *pcSrcSize, CHAR *pDstStr, UINT *pcDstSize);

private:

    DWORD m_dwSrcEncoding;
    DWORD m_dwDetectSrcEncoding;
    DWORD m_dwDstEncoding;
    DWORD m_dwMode;
    DWORD m_dwProperty;

    CICharConverter* lpCharConverter;

};

#endif  // __cplusplus

#endif  // _CONVOBJ_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\mlang\detcbase.cpp ===
// ============================================================================
// Internet Code Set Detection: Base Class
// ============================================================================

#include "private.h"
#include "detcbase.h"

/******************************************************************************
**********************   D E T E C T   S T R I N G   A   **********************
******************************************************************************/

int CINetCodeDetector::DetectStringA(LPCSTR lpSrcStr, int cchSrc)
{
    BOOL fDetected = FALSE;

    while (cchSrc-- > 0) {
        if (fDetected = DetectChar(*lpSrcStr++))
            break;
    }

    if (!fDetected)
        (void)CleanUp();

    return GetDetectedCodeSet();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\mlang\detcbase.h ===
class CINetCodeDetector
{
public:
    CINetCodeDetector() {}
    virtual ~CINetCodeDetector() {}
    int DetectStringA(LPCSTR lpSrcStr, int cchSrc);

protected:
    virtual BOOL DetectChar(UCHAR tc) = 0;
    virtual BOOL CleanUp() = 0;
    virtual int GetDetectedCodeSet() = 0;
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\mlang\debug.c ===
//
//

// This file cannot be compiled as a C++ file, otherwise the linker
// will bail on unresolved externals (even with extern "C" wrapping 
// this).

#include "private.h"

// Define some things for debug.h
//
#define SZ_DEBUGINI     "shellext.ini"
#define SZ_DEBUGSECTION "mlang"
#define SZ_MODULE       "MLANG"
#define DECLARE_DEBUG
#include <debug.h>
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\mlang\detcjpn.cpp ===
// =================================================================================
// Internet Character Set Detection: For Japanese
// =================================================================================

#include "private.h"
#include "detcbase.h"
#include "detcjpn.h"
#include "fechrcnv.h"
#include "codepage.h"

CIncdJapanese::CIncdJapanese(DWORD nCp)
{
    m_nScoreJis = 0;
    m_nScoreEuc = 0;
    m_nScoreSJis = 0;

    m_nISOMode = NONE ;
    m_nJISMode = REGULAR;
    m_nEucMode = REGULAR;
    m_fDoubleByteSJis = FALSE;
    // If Jpn autoselect, we'll bias to Shift-Jis like we did before
    m_nPreferredCp = (nCp == CP_JP_AUTO)? CP_JPN_SJ : nCp;
}

BOOL CIncdJapanese::CheckISOChar(UCHAR tc)
{
    switch (m_nISOMode) {
    case NONE:
        if ( tc == ESC )
            m_nISOMode = ISO_ESC ;
        break;
    case ISO_ESC:
        if ( tc == ISO2022_IN_CHAR )        // '$'
            m_nISOMode = ISO_ESC_IN ;
        else if ( tc == ISO2022_OUT_CHAR )
            m_nISOMode = ISO_ESC_OUT ;      // '('
        else
            m_nISOMode = NONE ;
        break;
    case ISO_ESC_IN:    // esc '$'
        m_nISOMode = NONE ;
        if ( tc == ISO2022_IN_JP_CHAR1 ||       // 'B'
                tc == ISO2022_IN_JP_CHAR2 )     // '@'
        {
            m_nJISMode = DOUBLEBYTE ;
            return TRUE ;
        }
        break;
    case ISO_ESC_OUT:   // esc '('
        m_nISOMode = NONE ;
        if ( tc == ISO2022_OUT_JP_CHAR1 ||      //  'B'
                tc == ISO2022_OUT_JP_CHAR2 )    //  'J'
        {
            m_nJISMode = REGULAR ;
            return TRUE ;
        }
        else if ( tc == ISO2022_OUT_JP_CHAR3 )   // 'I'
        {
            m_nJISMode = KATAKANA;
            return TRUE ;
        }
        break;
    }
    return FALSE;
}

BOOL CIncdJapanese::DetectChar(UCHAR tc)
{
    // JIS
    if ( CheckISOChar(tc) )
        return FALSE;   // JIS mode change, don't need to check other type

    switch (m_nJISMode) {
    case REGULAR:
        if (tc < 0x80)
            m_nScoreJis += SCORE_MAJOR;
        break;
    case DOUBLEBYTE:
    case KATAKANA:
        m_nScoreJis += SCORE_MAJOR;
        return FALSE;   // In JIS mode for sure, don't need to check other type
    }

    // EUC-J
    switch (m_nEucMode) {
    case REGULAR:
        if (tc >= 0xa1 && tc <= 0xfe) // Double Byte
            m_nEucMode = DOUBLEBYTE;
        else if (tc == 0x8e) // Single Byte Katakana
            m_nEucMode = KATAKANA;
        else if (tc < 0x80)
            m_nScoreEuc += SCORE_MAJOR;
        break;
    case DOUBLEBYTE:
        if (tc >= 0xa1 && tc <= 0xfe)
            m_nScoreEuc += SCORE_MAJOR * 2;
        m_nEucMode = REGULAR;
        break;
    case KATAKANA:
        if (tc >= 0xa1 && tc <= 0xdf) // Katakana range
            m_nScoreEuc += SCORE_MAJOR * 2;
        m_nEucMode = REGULAR;
        break;
    }

    // Shift-JIS
    if (!m_fDoubleByteSJis) {
        if ((tc >= 0x81 && tc <= 0x9f) || (tc >= 0xe0 && tc <= 0xfc)) // Double Byte
            m_fDoubleByteSJis = TRUE;
        else if (tc <= 0x7e || (tc >= 0xa1 && tc <= 0xdf))
            m_nScoreSJis += SCORE_MAJOR;
    } else {
        if (tc >= 0x40 && tc <= 0xfc && tc != 0x7f) // Trail Byte range
            m_nScoreSJis += SCORE_MAJOR * 2;
        m_fDoubleByteSJis = FALSE;
    }

    return FALSE;
}

int CIncdJapanese::GetDetectedCodeSet()
{
    int nMaxScore = m_nScoreSJis;
    int nCodeSet = CP_JPN_SJ;

    if (m_nScoreEuc > nMaxScore) {
        nMaxScore = m_nScoreEuc;
        nCodeSet = CP_EUC_JP ; // EUC
    } else if (m_nScoreEuc == nMaxScore) {
        if (m_nScoreEuc > MIN_JPN_DETECTLEN * SCORE_MAJOR) 
            // If the given string is not long enough, we should rather choose SJIS
            // This helps fix the bug when we are just given Window Title
            // at Shell HyperText view.
            nCodeSet = CP_EUC_JP ; // EUC
        else
            // If we can't distinguish between EUC and Shift-Jis, we use the preferred one
            nCodeSet = m_nPreferredCp;
    }

    // JIS
    if (m_nScoreJis > nMaxScore) 
        nCodeSet = CP_ISO_2022_JP ; 
    // Even score means all 7bits chars
    // in this case, it maybe just pure ANSI data, we return it is ambiguous.
    else if (m_nScoreJis == nMaxScore) 
        nCodeSet = 0 ;    

    return nCodeSet;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\mlang\detckrn.cpp ===
// =================================================================================
// Internet Character Set Detection: For Korean
// =================================================================================

#include "private.h"
#include "detcbase.h"
#include "detckrn.h"
#include "fechrcnv.h"
#include "codepage.h"

CIncdKorean::CIncdKorean()
{
    m_nEscMode = NO_ESC ;
    m_bFindDesigator = FALSE ;
    m_nCharCount = 0 ;
}

BOOL CIncdKorean::DetectChar(UCHAR tc)
{
    switch ( tc ) 
    {
        case ESC:
            if ( m_nEscMode == NO_ESC )
                m_nEscMode = sESC ;
            else
                m_nEscMode = NO_ESC ;
            break;
        case ISO2022_IN_CHAR :      //  '$'
            if ( m_nEscMode == sESC )
                m_nEscMode = sESC_1 ;
            else
                m_nEscMode = NO_ESC ;
            break;
        case ISO2022_IN_KR_CHAR_1 : //  ')'
            if ( m_nEscMode == sESC_1 )
                m_nEscMode = sESC_2 ;
            else
                m_nEscMode = NO_ESC ;
            break;
        case ISO2022_IN_KR_CHAR_2 : //  'C'
            if ( m_nEscMode == sESC_2 )
            {
                m_bFindDesigator = TRUE ;
                return TRUE ;
            }
            break;
        default:
            m_nEscMode = NO_ESC ;
            break;
    }

    // only look ahead a max 1024 char
    if ( ++m_nCharCount > 1024 )
        return TRUE;

    return FALSE;
}

int CIncdKorean::GetDetectedCodeSet()
{
    if ( m_bFindDesigator )
        return CP_ISO_2022_KR ; // ISO
    else
        return CP_KOR_5601 ; // Korean Windows 
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\mlang\detckrn.h ===
#define SCORE_NONE  0
#define SCORE_MINOR 1
#define SCORE_MAJOR 2

class CIncdKorean : public CINetCodeDetector
{
private:

    enum {NO_ESC, sESC, sESC_1, sESC_2 } m_nEscMode;
    BOOL m_bFindDesigator;
    INT  m_nCharCount;

public:
    CIncdKorean();
    ~CIncdKorean() {}

protected:
    virtual BOOL DetectChar(UCHAR tc);
    virtual BOOL CleanUp() {return FALSE;}
    virtual int GetDetectedCodeSet();
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\mlang\detcjpn.h ===
#include "codepage.h"
#define SCORE_NONE  0
#define SCORE_MINOR 1
#define SCORE_MAJOR 2

class CIncdJapanese : public CINetCodeDetector
{
private:
    long m_nScoreJis;
    long m_nScoreEuc;
    long m_nScoreSJis;
    DWORD m_nPreferredCp;

    enum {NONE, ISO_ESC, ISO_ESC_IN, ISO_ESC_OUT } m_nISOMode;
    enum {REGULAR, DOUBLEBYTE, KATAKANA} m_nEucMode, m_nJISMode ;
    BOOL m_fDoubleByteSJis;

public:
    CIncdJapanese(DWORD nCp = CP_JPN_SJ);
    ~CIncdJapanese() {}

protected:
    virtual BOOL CheckISOChar(UCHAR tc);
    virtual BOOL DetectChar(UCHAR tc);
    virtual BOOL CleanUp() {return FALSE;}
    virtual int GetDetectedCodeSet();
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\mlang\detect.h ===
/*
 * Automatic language and codepage detector
 * 
 * Bob Powell, 2/97
 * Copyright (C) 1996, 1997, Microsoft Corp.  All rights reserved.
 */

#ifdef  __cplusplus

#include <wtypes.h>
#include <limits.h>

#include "lcdetect.h"
#include "lccommon.h"

#include <qsort.h>


// Turn this on in SOURCES to enable debug output
#ifdef DEBUG_LCDETECT
#include <stdio.h>
extern int g_fDebug;
#define debug(x) { if (g_fDebug) { x; }}
#define unmapch(x) ((x) >= 2 ? (x)+'a'-2 : ' ')
#else
#define debug(x)
#endif

class LCDetect;
typedef LCDetect *PLCDetect;

class Language;
class Language7Bit;
class Language8Bit;
class LanguageUnicode;
typedef Language *PLanguage;
typedef Language7Bit *PLanguage7Bit;
typedef Language8Bit *PLanguage8Bit;
typedef LanguageUnicode *PLanguageUnicode;

class CScore;
class CScores;

/****************************************************************/

#define MAXSCORES 50            // Max possible simultaneous # of scores

#define MINRAWSCORE 100         // Score threshhold (weight * char count) 
                                // for further processing

/****************************************************************/

// Histograms

// A histogram stores an array of n-gram occurrence counts.  
// HElt stores the count, at present this is an unsigned char.

// The in-memory structure is similar to the file.
// The histogram array pointers m_panElts point into the mapped file image.

class Histogram {

public:
    Histogram (const PFileHistogramSection pHS, const PHIdx pMap);
    Histogram (const Histogram &H, const PHIdx pMap);
    virtual ~Histogram (void);

    DWORD Validate (DWORD nBytes) const;

    UCHAR Dimensionality (void) { return m_nDimensionality; }
    UCHAR EdgeSize (void) { return m_nEdgeSize; }
    USHORT CodePage (void) { return m_nCodePage; }
    USHORT GetRangeID (void) { return m_nRangeID; }
    USHORT NElts (void) { return m_nElts; }
    PHIdx GetMap (void) { return m_pMap; }

    HElt Ref (USHORT i1) const { return m_panElts[i1]; }
    HElt Ref (UCHAR i1, UCHAR i2) const {
        return m_panElts[(i1 * m_nEdgeSize) + i2]; }
    HElt Ref (UCHAR i1, UCHAR i2, UCHAR i3) const {
        return m_panElts[((i1 * m_nEdgeSize) + i2) * m_nEdgeSize + i3]; }

    HElt *Array (void) { return m_panElts; }

protected:
    UCHAR m_nDimensionality;        // 1=unigram, 2=digram etc.
    UCHAR m_nEdgeSize;              // edge size (is a function of char map)
    union {
        USHORT m_nCodePage;         // For 7 and 8-bit, is code page
        USHORT m_nRangeID;          // For Unicode, is sub-language range ID
    };
    USHORT m_nElts;                 // (edge size ^ dimensionality)
    PHIdx m_pMap;                   // char/WCHAR to histogram idx mapping

    HElt *m_panElts;                // array of elements / counts
};
typedef Histogram *PHistogram;

/****************************************************************/

// A Language object stores all the detection state for a given language,
// i.e. primary language ID.

class Language {
public:
    // nCodePages is same as nSubLangs
    Language (PLCDetect pL, int nLangID, int nCodePages, int nRangeID = 0);
    virtual ~Language (void) { }

    virtual DWORD AddHistogram (PFileHistogramSection pHS, DWORD nBytes, int nIdx) = 0;

    // Score the code pages for this language
    virtual void ScoreCodePage (LPCSTR, int nCh, CScore &S, int &idx) const;

    int LanguageID (void) const { return m_nLangID; }
    int NCodePages (void) const { return m_nCodePages; }
    int NSubLangs (void) const { return m_nSubLangs; }
    int RangeID (void) const { return m_nRangeID; }
    int GetScoreIdx (void) const { return m_nScoreIdx; }
    void SetScoreIdx (int nScoreIdx) { m_nScoreIdx = nScoreIdx; }

    virtual int GetCodePage (int n) const { return 0; }
    virtual int GetSublangRangeID (int n) const { return 0; }
    virtual int GetSublangID (int n) const { return 0; }

    virtual DetectionType Type (void) = 0;
    virtual Language7Bit const * GetLanguage7Bit (void) const { return NULL; }
    virtual Language8Bit const * GetLanguage8Bit (void) const { return NULL; }
    virtual LanguageUnicode const * GetLanguageUnicode (void) const { return NULL; }

protected:
    PLCDetect m_pLC;

    int m_nLangID;      // Win32 primary language ID
    int m_nRangeID;     // Unicode range ID, for Unicode langs
    union {
        int m_nCodePages;   // # of code pages trained for this language
        int m_nSubLangs;
    };
    int m_nScoreIdx;    // Used to create a unique index into the score arrays
                        // for each lang + cp combination, to eliminate the
                        // need to search the arrays to merge scores.  Add
                        // the code page index to this to get the array index.
};

////////////////////////////////////////////////////////////////

class Language7Bit : public Language {
public:
    Language7Bit (PLCDetect pL, int nLangID, int nCodePages);
    ~Language7Bit (void);

    DWORD AddHistogram (PFileHistogramSection pHS, DWORD nBytes, int nIdx);

    void ScoreCodePage (LPCSTR, int nCh, CScore &S, int &idx) const;

    int GetCodePage (int n) const { return m_ppCodePageHistogram[n]->CodePage();}
    virtual DetectionType Type (void) { return DETECT_7BIT; }

    PHistogram GetLangHistogram (void) const { return m_pLangHistogram; }
    PHistogram GetCodePageHistogram (int i) const { 
        return m_ppCodePageHistogram[i]; }

    virtual Language7Bit const * GetLanguage7Bit (void) const { return this; }

    const PHElt * GetPHEltArray (void) const { return m_paHElt; }

private:
    PHistogram m_pLangHistogram;
    PHistogram m_ppCodePageHistogram[MAXSUBLANG];

    PHElt m_paHElt[MAXSUBLANG];
};

////////////////////////////////////////////////////////////////

class Language8Bit : public Language {
public:
    Language8Bit (PLCDetect pL, int nLangID, int nCodePages);
    ~Language8Bit (void);

    DWORD AddHistogram (PFileHistogramSection pHS, DWORD nBytes, int nIdx);

    int GetCodePage (int n) const { return m_ppHistogram[n]->CodePage(); }

    virtual DetectionType Type (void) { return DETECT_8BIT; }

    PHistogram GetHistogram (int i) const { return m_ppHistogram[i]; }

    virtual Language8Bit const * GetLanguage8Bit (void) const { return this; }

private:
    PHistogram m_ppHistogram[MAXSUBLANG];
};

////////////////////////////////////////////////////////////////

class LanguageUnicode : public Language {
public:
    LanguageUnicode (PLCDetect pL, int nLangID, int nRecordCount, int nRangeID);
    ~LanguageUnicode (void);
    
    DWORD AddHistogram (PFileHistogramSection pHS, DWORD nBytes, int nIdx);
    
    void ScoreSublanguages (LPCWSTR wcs, int nch, CScores &S) const;

    int GetSublangRangeID (int i) const{return GetHistogram(i)->GetRangeID();}
    PLanguageUnicode GetSublanguage (int n) const;

    virtual DetectionType Type (void) { return DETECT_UNICODE; }

    PHistogram GetHistogram (int i) const { return m_ppSubLangHistogram[i]; }

    virtual LanguageUnicode const * GetLanguageUnicode (void) const { 
        return this; 
    }

    const PHElt * GetPHEltArray (void) const { return m_paHElt; }

private:
    PHistogram m_ppSubLangHistogram[MAXSUBLANG];

    PHElt m_paHElt[MAXSUBLANG];
};

/****************************************************************/

class Charmap {

public:
    Charmap (PFileMapSection pMS) : m_nID(pMS->m_dwID), m_nSize(pMS->m_dwSize),
        m_nUnique(pMS->m_dwNUnique), m_pElts( (PHIdx) (&pMS[1]) ) { }

//  int ID (void) const { return m_nID; }
    int Size (void) const { return m_nSize; }
    int NUnique (void) const { return m_nUnique; }
    PHIdx Map (void) const { return m_pElts; }
    HIdx Map (WCHAR x) const { return m_pElts[x]; }

private:
    int m_nID;          // ID by which hardwired code finds the table
    int m_nSize;        // size of table (256 or 65536)
    int m_nUnique;      // # of unique output values
    
    PHIdx m_pElts;
};
typedef Charmap *PCharmap;

/****************************************************************/

// class CScore -- score for one lang and/or code page, variously used for
// individual chunks and also for an entire document.

class CScore {
public:
    // Only these two slots need to be initialized
    CScore (void) : m_nScore(0), m_nChars(0) {}
    ~CScore (void) { }
    
    const PLanguage GetLang (void) const { return m_pLang; }
    int GetScore (void) const { return m_nScore; }
    unsigned short GetCodePage (void) const { return m_nCodePage; }
    unsigned short GetCharCount (void) const { return m_nChars; }

    void SetLang (PLanguage p) { m_pLang = p; }
    void SetScore (int x) { m_nScore = x; }
    void SetCharCount (unsigned x) { m_nChars = (unsigned short)x; }
    void SetCodePage (unsigned x) { m_nCodePage = (unsigned short)x; }

    void Add (CScore &S) { 
        SetLang(S.GetLang());
        SetCodePage(S.GetCodePage());
        SetScore(GetScore() + S.GetScore());
        SetCharCount(GetCharCount() + S.GetCharCount());
    }
    CScore & operator += (CScore &S) { Add (S); return *this; }

    int operator <= (CScore &S) {
        // Special:  always put 8-bit langs first since the code page
        // matters more for them.
        if (GetLang()->Type() != S.GetLang()->Type())
            return GetLang()->Type() == DETECT_8BIT ? -1 : 1;
        return GetScore() <= S.GetScore();
    }

#ifdef DEBUG_LCDETECT
    void Print(void) {
        printf("Lang=%d CodePage=%d Score=%d NChars=%d\n",
            GetLang() ? GetLang()->LanguageID() : -1, 
            GetCodePage(), GetScore(), GetCharCount());
    }
#endif

private:
    PLanguage m_pLang;
    int m_nScore;
    unsigned short m_nCodePage;
    unsigned short m_nChars;
};
typedef CScore *PScore;

////////////////////////////////////////////////////////////////

// class CScores
//
// For SBCS detection, the index e.g. Ref(i) is the language+codepage index,
// one of a contiguous set of values which identifies each unique supported
// language and codepage combination.
//
// For DBCS detection, the index is just the Unicode language group.

class CScores {
public:
    CScores (int nAlloc, PScore p) : m_nAlloc(nAlloc), m_nUsed(0), m_p(p) { }
    virtual ~CScores (void) { }

    void Reset (void) {
        memset ((void *)m_p, 0, sizeof(CScore) * m_nUsed);
        m_nUsed = 0;
    }

    unsigned int &NElts (void) { return m_nUsed; }
    CScore &Ref (unsigned int n) {
        if (m_nUsed <= n)
            m_nUsed = n + 1; 
        return m_p[n]; 
    }

    void SelectCodePages (void);

    void RemoveZeroScores (void) {
        for (unsigned int i = 0, j = 0; i < m_nUsed; i++)
        {
            if (m_p[i].GetScore() > MINRAWSCORE)
                m_p[j++] = m_p[i];
        }
        m_nUsed = j;
    }

    // Sort by decreasing score.
    // Instantiates template qsort using CScore::operator <=

    void SortByScore (void) {
        RemoveZeroScores ();
        if (m_nUsed)
            QSort (m_p, m_nUsed, FALSE);
    }

    CScore & FindHighScore (void) {
        int highscore = 0;
        for (unsigned int i = 0, highidx = 0; i < m_nUsed; i++) {
            if (m_p[i].GetScore() > highscore)
            {
                highscore = m_p[i].GetScore();
                highidx = i;
            }
        }
        return m_p[highidx];
    }

protected:
    unsigned int m_nAlloc;
    unsigned int m_nUsed;   // high water mark to optimize NElts(), Reset()
    PScore m_p;             // score array, typically per TScores<NNN>
};

template<ULONG Size>class TScores : public CScores {

public:
    TScores (void) : CScores (Size, m_S) { }
    virtual ~TScores (void) { }

private:
    CScore m_S[Size];
};

////////////////////////////////////////////////////////////////

class LCDetect {

public:
    LCDetect (HMODULE hM);
    ~LCDetect (void);

    unsigned int GetNCharmaps() const { return m_nCharmaps; }
    unsigned int GetN7BitLanguages() const { return m_n7BitLanguages; }
    unsigned int GetN8BitLanguages() const { return m_n8BitLanguages; }
    unsigned int GetNUnicodeLanguages() const { return m_nUnicodeLanguages; }

    PLanguage7Bit Get7BitLanguage (int i) const { return m_pp7BitLanguages[i]; }
    PLanguage8Bit Get8BitLanguage (int i) const { return m_pp8BitLanguages[i]; }
    PLanguageUnicode GetUnicodeLanguage (int i) const { return m_ppUnicodeLanguages[i]; }

    PHIdx GetMap (int i) const { return m_ppCharmaps[i]->Map(); }

    const LCDConfigure &GetConfig () const { return m_LCDConfigureDefault; }

    DWORD LoadState (void);

    DWORD DetectA (LPCSTR pStr, int nChars, PLCDScore paScores, 
                            int *pnScores, PCLCDConfigure pLCDC) const;

    DWORD DetectW (LPCWSTR wcs, int nInputChars, PLCDScore paScores, 
                            int *pnScores, PCLCDConfigure pLCDC) const;

private:
    DWORD Initialize7BitLanguage (PFileLanguageSection pLS, PLanguage *ppL);
    DWORD Initialize8BitLanguage (PFileLanguageSection pLS, Language **ppL);
    DWORD InitializeUnicodeLanguage (PFileLanguageSection pLS,Language **ppL);
    DWORD LoadLanguageSection (void *pv, int nSectionSize, PLanguage *ppL);
    DWORD LoadHistogramSection (void *pv, int nSectionSize, Language *pL);
    DWORD LoadMapSection (void *pv, int nSectionSize);
    DWORD BuildState (DWORD nFileSize);

    void Score7Bit (LPCSTR pcszText, int nChars, CScores &S) const;
    void Score8Bit (LPCSTR pcszText, int nChars, CScores &S) const;
    int ScoreCodePage (LPCSTR pStr, int nChars, CScore &S) const;
    int ChooseDetectionType (LPCSTR pcszText, int nChars) const;
    void ScoreLanguageA (LPCSTR pStr, int nChars, CScores &S) const;
    void ScoreLanguageW (LPCWSTR wcs, int nChars, CScores &S, PCLCDConfigure) const;
    void ScoreLanguageAsSBCS (LPCWSTR wcs, int nch, CScores &S) const;
    void ScoreUnicodeSublanguages (PLanguageUnicode pL, LPCWSTR wcs, 
            int nch, CScores &S) const;

private:
    // Language training info virtual-mapped in training file

    unsigned int m_nCharmaps;
    unsigned int m_n7BitLanguages;
    unsigned int m_n8BitLanguages;
    unsigned int m_nUnicodeLanguages;

    PCharmap *m_ppCharmaps;
    PLanguage7Bit *m_pp7BitLanguages;
    PLanguage8Bit *m_pp8BitLanguages;
    PLanguageUnicode *m_ppUnicodeLanguages;

    // Cached information for the optimized scoring inner-loops.

    PHElt m_paHElt7Bit[MAX7BITLANG];
    PHElt m_paHElt8Bit[MAXSCORES];
    int m_nHElt8Bit;

    // Special 7-bit lang histogram for ScoreLanguageAsSBCS()

    PHistogram m_pHU27Bit;

    // Initialization state variables

    unsigned int m_n7BitLangsRead;
    unsigned int m_n8BitLangsRead;
    unsigned int m_nUnicodeLangsRead;
    unsigned int m_nMapsRead;
    int m_nHistogramsRead;
    int m_nScoreIdx;

    // Default configuration to use when NULL parameter passed to detect

    LCDConfigure m_LCDConfigureDefault;

    // File mapping information for the training data file

    HANDLE m_hf;
    HANDLE m_hmap;
    void *m_pv;

    HMODULE m_hModule;
};

////////////////////////////////////////////////////////////////

inline PLanguageUnicode 
LanguageUnicode::GetSublanguage (int n) const 
{ 
    return m_pLC->GetUnicodeLanguage(GetSublangRangeID(n));
}

#endif  // __cplusplus
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\mlang\enumcp.cpp ===
#include "private.h"
const MIMERFC1766 MimeRfc1766[] =
{
    { 0x0436, L"af",    IDS_RFC1766_LCID0436 },
    { 0x041C, L"sq",    IDS_RFC1766_LCID041C },
    { 0x0001, L"ar",    IDS_RFC1766_LCID0001 },
    { 0x0401, L"ar-sa", IDS_RFC1766_LCID0401 },
    { 0x0801, L"ar-iq", IDS_RFC1766_LCID0801 },
    { 0x0C01, L"ar-eg", IDS_RFC1766_LCID0C01 },
    { 0x1001, L"ar-ly", IDS_RFC1766_LCID1001 },
    { 0x1401, L"ar-dz", IDS_RFC1766_LCID1401 },
    { 0x1801, L"ar-ma", IDS_RFC1766_LCID1801 },
    { 0x1C01, L"ar-tn", IDS_RFC1766_LCID1C01 },
    { 0x2001, L"ar-om", IDS_RFC1766_LCID2001 },
    { 0x2401, L"ar-ye", IDS_RFC1766_LCID2401 },
    { 0x2801, L"ar-sy", IDS_RFC1766_LCID2801 },
    { 0x2C01, L"ar-jo", IDS_RFC1766_LCID2C01 },
    { 0x3001, L"ar-lb", IDS_RFC1766_LCID3001 },
    { 0x3401, L"ar-kw", IDS_RFC1766_LCID3401 },
    { 0x3801, L"ar-ae", IDS_RFC1766_LCID3801 },
    { 0x3C01, L"ar-bh", IDS_RFC1766_LCID3C01 },
    { 0x4001, L"ar-qa", IDS_RFC1766_LCID4001 },
    { 0x042D, L"eu",    IDS_RFC1766_LCID042D },
    { 0x0402, L"bg",    IDS_RFC1766_LCID0402 },
    { 0x0423, L"be",    IDS_RFC1766_LCID0423 },
    { 0x0403, L"ca",    IDS_RFC1766_LCID0403 },
    { 0x0004, L"zh",    IDS_RFC1766_LCID0004 },
    { 0x1404, L"zh-mo", IDS_RFC1766_LCID1404 },
    { 0x0404, L"zh-tw", IDS_RFC1766_LCID0404 },
    { 0x0804, L"zh-cn", IDS_RFC1766_LCID0804 },
    { 0x0C04, L"zh-hk", IDS_RFC1766_LCID0C04 },
    { 0x1004, L"zh-sg", IDS_RFC1766_LCID1004 },
    { 0x041A, L"hr",    IDS_RFC1766_LCID041A },
    { 0x0405, L"cs",    IDS_RFC1766_LCID0405 },
    { 0x0406, L"da",    IDS_RFC1766_LCID0406 },
    { 0x0413, L"nl",    IDS_RFC1766_LCID0413 },
    { 0x0813, L"nl-be", IDS_RFC1766_LCID0813 },
    { 0x0009, L"en",    IDS_RFC1766_LCID0009 },
    { 0x2409, L"en",    IDS_RFC1766_LCID2409 },
    { 0x0409, L"en-us", IDS_RFC1766_LCID0409 },
    { 0x0809, L"en-gb", IDS_RFC1766_LCID0809 },
    { 0x0C09, L"en-au", IDS_RFC1766_LCID0C09 },
    { 0x1009, L"en-ca", IDS_RFC1766_LCID1009 },
    { 0x1409, L"en-nz", IDS_RFC1766_LCID1409 },
    { 0x1809, L"en-ie", IDS_RFC1766_LCID1809 },
    { 0x1C09, L"en-za", IDS_RFC1766_LCID1C09 },
    { 0x3009, L"en-zw", IDS_RFC1766_LCID3009 },
    { 0x2009, L"en-jm", IDS_RFC1766_LCID2009 },
    { 0x2809, L"en-bz", IDS_RFC1766_LCID2809 },
    { 0x2C09, L"en-tt", IDS_RFC1766_LCID2C09 },
    { 0x3409, L"en-ph", IDS_RFC1766_LCID3409 },
    { 0x0425, L"et",    IDS_RFC1766_LCID0425 },
    { 0x0438, L"fo",    IDS_RFC1766_LCID0438 },
    { 0x0429, L"fa",    IDS_RFC1766_LCID0429 },
    { 0x040B, L"fi",    IDS_RFC1766_LCID040B },
    { 0x040C, L"fr",    IDS_RFC1766_LCID040C },
    { 0x080C, L"fr-be", IDS_RFC1766_LCID080C },
    { 0x0C0C, L"fr-ca", IDS_RFC1766_LCID0C0C },
    { 0x100C, L"fr-ch", IDS_RFC1766_LCID100C },
    { 0x140C, L"fr-lu", IDS_RFC1766_LCID140C },
    { 0x180C, L"fr-mc", IDS_RFC1766_LCID180C },
    { 0x043C, L"gd",    IDS_RFC1766_LCID043C },
    { 0x0407, L"de",    IDS_RFC1766_LCID0407 },
    { 0x0807, L"de-ch", IDS_RFC1766_LCID0807 },
    { 0x0C07, L"de-at", IDS_RFC1766_LCID0C07 },
    { 0x1007, L"de-lu", IDS_RFC1766_LCID1007 },
    { 0x1407, L"de-li", IDS_RFC1766_LCID1407 },
    { 0x0408, L"el",    IDS_RFC1766_LCID0408 },
    { 0x040D, L"he",    IDS_RFC1766_LCID040D },
    { 0x0439, L"hi",    IDS_RFC1766_LCID0439 },
    { 0x040E, L"hu",    IDS_RFC1766_LCID040E },
    { 0x040F, L"is",    IDS_RFC1766_LCID040F },
    { 0x0421, L"id",    IDS_RFC1766_LCID0421 },
    { 0x0410, L"it",    IDS_RFC1766_LCID0410 },
    { 0x0810, L"it-ch", IDS_RFC1766_LCID0810 },
    { 0x0411, L"ja",    IDS_RFC1766_LCID0411 },
    { 0x0412, L"ko",    IDS_RFC1766_LCID0412 },
    { 0x0426, L"lv",    IDS_RFC1766_LCID0426 },
    { 0x0427, L"lt",    IDS_RFC1766_LCID0427 },
    { 0x042F, L"mk",    IDS_RFC1766_LCID042F },
    { 0x043E, L"ms",    IDS_RFC1766_LCID043E },
    { 0x043A, L"mt",    IDS_RFC1766_LCID043A },
    { 0x0415, L"pl",    IDS_RFC1766_LCID0415 },
    { 0x0416, L"pt-br", IDS_RFC1766_LCID0416 },
    { 0x0816, L"pt",    IDS_RFC1766_LCID0816 },
    { 0x0417, L"rm",    IDS_RFC1766_LCID0417 },
    { 0x0418, L"ro",    IDS_RFC1766_LCID0418 },
    { 0x0818, L"ro-md", IDS_RFC1766_LCID0818 },
    { 0x0419, L"ru",    IDS_RFC1766_LCID0419 },
    { 0x0819, L"ru-md", IDS_RFC1766_LCID0819 },
    { 0x0C1A, L"sr",    IDS_RFC1766_LCID0C1A },
    { 0x081A, L"sr",    IDS_RFC1766_LCID081A },
    { 0x041B, L"sk",    IDS_RFC1766_LCID041B },
    { 0x0424, L"sl",    IDS_RFC1766_LCID0424 },
    { 0x042E, L"sb",    IDS_RFC1766_LCID042E },
    { 0x040A, L"es",    IDS_RFC1766_LCID040A },
    { 0x080A, L"es-mx", IDS_RFC1766_LCID080A },
    { 0x0C0A, L"es",    IDS_RFC1766_LCID0C0A },
    { 0x100A, L"es-gt", IDS_RFC1766_LCID100A },
    { 0x140A, L"es-cr", IDS_RFC1766_LCID140A },
    { 0x180A, L"es-pa", IDS_RFC1766_LCID180A },
    { 0x1C0A, L"es-do", IDS_RFC1766_LCID1C0A },
    { 0x200A, L"es-ve", IDS_RFC1766_LCID200A },
    { 0x240A, L"es-co", IDS_RFC1766_LCID240A },
    { 0x280A, L"es-pe", IDS_RFC1766_LCID280A },
    { 0x2C0A, L"es-ar", IDS_RFC1766_LCID2C0A },
    { 0x300A, L"es-ec", IDS_RFC1766_LCID300A },
    { 0x340A, L"es-cl", IDS_RFC1766_LCID340A },
    { 0x380A, L"es-uy", IDS_RFC1766_LCID380A },
    { 0x3C0A, L"es-py", IDS_RFC1766_LCID3C0A },
    { 0x400A, L"es-bo", IDS_RFC1766_LCID400A },
    { 0x440A, L"es-sv", IDS_RFC1766_LCID440A },
    { 0x480A, L"es-hn", IDS_RFC1766_LCID480A },
    { 0x4C0A, L"es-ni", IDS_RFC1766_LCID4C0A },
    { 0x500A, L"es-pr", IDS_RFC1766_LCID500A },
    { 0x0430, L"sx",    IDS_RFC1766_LCID0430 },
    { 0x041D, L"sv",    IDS_RFC1766_LCID041D },
    { 0x081D, L"sv-fi", IDS_RFC1766_LCID081D },
    { 0x041E, L"th",    IDS_RFC1766_LCID041E },
    { 0x0431, L"ts",    IDS_RFC1766_LCID0431 },
    { 0x0432, L"tn",    IDS_RFC1766_LCID0432 },
    { 0x041F, L"tr",    IDS_RFC1766_LCID041F },
    { 0x0422, L"uk",    IDS_RFC1766_LCID0422 },
    { 0x0420, L"ur",    IDS_RFC1766_LCID0420 },
    { 0x0443, L"uz",    IDS_RFC1766_LCID0443 },
    { 0x0843, L"uz",    IDS_RFC1766_LCID0843 },
    { 0x042A, L"vi",    IDS_RFC1766_LCID042A },
    { 0x0434, L"xh",    IDS_RFC1766_LCID0434 },
    { 0x043D, L"yi",    IDS_RFC1766_LCID043D },
    { 0x0435, L"zu",    IDS_RFC1766_LCID0435 },
    { 0x042B, L"hy",    IDS_RFC1766_LCID042B },
    { 0x0437, L"ka",    IDS_RFC1766_LCID0437 },
    { 0x043F, L"kk",    IDS_RFC1766_LCID043F },
    { 0x0441, L"sw",    IDS_RFC1766_LCID0441 },
    { 0x0444, L"tt",    IDS_RFC1766_LCID0444 },
    { 0x0445, L"bn",    IDS_RFC1766_LCID0445 },
    { 0x0446, L"pa",    IDS_RFC1766_LCID0446 },
    { 0x0447, L"gu",    IDS_RFC1766_LCID0447 },
    { 0x0448, L"or",    IDS_RFC1766_LCID0448 },
    { 0x0449, L"ta",    IDS_RFC1766_LCID0449 },
    { 0x044A, L"te",    IDS_RFC1766_LCID044A },
    { 0x044B, L"kn",    IDS_RFC1766_LCID044B },
    { 0x044C, L"ml",    IDS_RFC1766_LCID044C },
    { 0x044D, L"as",    IDS_RFC1766_LCID044D },
    { 0x044E, L"mr",    IDS_RFC1766_LCID044E },
    { 0x083E, L"ms",    IDS_RFC1766_LCID083E },
    { 0x0861, L"ne",    IDS_RFC1766_LCID0861 },
    { 0x044F, L"sa",    IDS_RFC1766_LCID044F },
//  Sync W2K NLS, remove 0x0827 RFC1766 entry
//  { 0x0827, L"lt",    IDS_RFC1766_LCID0827 },
    { 0x0457, L"kok",   IDS_RFC1766_LCID0457 },

// Following rfc1766 names are over already published MAX_RFC1766_NAME
// We have to modify them for IE5 release, will do better later

//  { 0x082C, L"x-az-cyrillic", IDS_RFC1766_LCID082C },
//  { 0x042C, L"x-az-latin",    IDS_RFC1766_LCID042C },
    { 0x0414, L"no",   IDS_RFC1766_LCID0414 },
    { 0x0414, L"nb-no",   IDS_RFC1766_LCID0414 },
    { 0x0814, L"nn-no",   IDS_RFC1766_LCID0814 },
    { 0x082C, L"az",    IDS_RFC1766_LCID082C },
    { 0x042C, L"az",    IDS_RFC1766_LCID042C },
// More stuffs from Whistler NLS
    { 0x0440, L"kz",    IDS_RFC1766_LCID0440 },
    { 0x0450, L"mn",    IDS_RFC1766_LCID0450 },
    { 0x0456, L"gl",    IDS_RFC1766_LCID0456 },
    { 0x045A, L"syr",   IDS_RFC1766_LCID045A },
    { 0x0465, L"div",   IDS_RFC1766_LCID0465 },
// Whistler bug#350772, for Hispanic US
    { 0x540A, L"es-us", IDS_RFC1766_LCID540A },
};

UINT g_cRfc1766 = ARRAYSIZE(MimeRfc1766);
//
//  CEnumCodePage implementation
//
CEnumCodePage::CEnumCodePage(DWORD grfFlags, LANGID LangId, MIMECONTF dwSource) : _dwLevel( grfFlags ), _LangId( LangId), dwMimeSource(dwSource)
{
    DebugMsg(DM_TRACE, TEXT("constructor of CEnumCodePage 0x%08x"), this);
    DllAddRef();

    _cRef = 1;
    _iCur = 0;
}

CEnumCodePage::~CEnumCodePage()
{
    DebugMsg(DM_TRACE, TEXT("destructor of CEnumCodePage 0x%08x"), this);
    DllRelease();
}

STDAPI CEnumCodePage::QueryInterface(REFIID riid, void **ppvObj)
{
    DebugMsg(DM_TRACE, TEXT("CEnumCodePage::QueryInterface called."));
    if (IsEqualIID(riid, IID_IUnknown) || IsEqualIID(riid, IID_IEnumCodePage))
    {
        *ppvObj = SAFECAST(this, IEnumCodePage*);
        AddRef();
        return NOERROR;
    }
    *ppvObj = NULL;
    return E_NOINTERFACE;
}

STDAPI_(ULONG) CEnumCodePage::AddRef()
{
    _cRef++;
    DebugMsg(DM_TRACE, TEXT("CEnumCodePage::AddRef called. _cRef=%d"), _cRef);
    return _cRef;
}

STDAPI_(ULONG) CEnumCodePage::Release()
{
    _cRef--;
    DebugMsg(DM_TRACE, TEXT("CEnumCodePage::Release called. _cRef=%d"), _cRef);
    if (0 < _cRef)
        return _cRef;

    delete this;
    return 0;    
}

STDAPI CEnumCodePage::Clone(IEnumCodePage **ppEnumCodePage)
{
    DebugMsg(DM_TRACE, TEXT("CEnumCodePage::Clone called."));
    return E_NOTIMPL;
}

STDAPI CEnumCodePage::Next(ULONG celt, PMIMECPINFO rgcpInfo, ULONG *pceltFetched)
{    
    DebugMsg(DM_TRACE, TEXT("CEnumCodePage::Next called."));


    UINT cNum = 0;
    MIMECPINFO cpInfo;

    if (dwMimeSource &  MIMECONTF_MIME_REGISTRY)
    {
        if (NULL != g_pMimeDatabaseReg && NULL != rgcpInfo)
        {
            if (0 == _iCur)
                if (S_OK != g_pMimeDatabaseReg->EnumCodePageInfo())
                    return E_FAIL;

            while (cNum < celt)
            {
                HRESULT hr = g_pMimeDatabaseReg->GetCodePageInfoWithIndex(_iCur++, &cpInfo);
                if (SUCCEEDED(hr))
                {
                    if (_dwLevel == (cpInfo.dwFlags & _dwLevel))
                    {
                        *(rgcpInfo + cNum) = cpInfo;
                        cNum++;
                    }
                }
                else
                    break;
            }
            if (NULL != pceltFetched)
                *pceltFetched = cNum;
            return (0 < cNum)? S_OK: S_FALSE;
        }
        else
            return E_FAIL;
    } 

    while (cNum < celt)
    {
        if (SUCCEEDED(g_pMimeDatabase->GetCodePageInfoWithIndex(_iCur++, _LangId, &cpInfo)))
        {
            if (_dwLevel == (cpInfo.dwFlags & _dwLevel) &&
                (cpInfo.dwFlags & dwMimeSource))
            {
                *(rgcpInfo + cNum) = cpInfo;
                cNum++;
            }
        }
        else
            break;
    }

    if (NULL != pceltFetched)
       *pceltFetched = cNum;

    return (0 < cNum)? S_OK: S_FALSE;

}


STDAPI CEnumCodePage::Reset()
{
    DebugMsg(DM_TRACE, TEXT("CEnumCodePage::Reset called."));
    _iCur = 0;
    return NOERROR;
}

STDAPI CEnumCodePage::Skip(ULONG celt)
{
    DebugMsg(DM_TRACE, TEXT("CEnumCodePage::Skip called."));
    _iCur += celt;
    return NOERROR;
}

//
//  CEnumRfc1766 implementation
//
CEnumRfc1766::CEnumRfc1766(MIMECONTF dwSource, LANGID LangId) : _LangID(LangId)
{
    DebugMsg(DM_TRACE, TEXT("constructor of CEnumRfc1766 0x%08x"), this);
    dwMimeSource = dwSource;
    DllAddRef();
    _cRef = 1;
    _uCur = 0;
}

CEnumRfc1766::~CEnumRfc1766()
{
    DebugMsg(DM_TRACE, TEXT("destructor of CEnumRfc1766 0x%08x"), this);
    DllRelease();
}

STDAPI CEnumRfc1766::QueryInterface(REFIID riid, void **ppvObj)
{
    DebugMsg(DM_TRACE, TEXT("CEnumRfc1766::QueryInterface called."));
    if (IsEqualIID(riid, IID_IUnknown) || IsEqualIID(riid, IID_IEnumRfc1766))
    {
        *ppvObj = SAFECAST(this, IEnumRfc1766*);
        AddRef();
        return NOERROR;
    }
    *ppvObj = NULL;
    return E_NOINTERFACE;
}

STDAPI_(ULONG) CEnumRfc1766::AddRef()
{
    _cRef++;
    DebugMsg(DM_TRACE, TEXT("CEnumRfc1766::AddRef called. _cRef=%d"), _cRef);
    return _cRef;
}

STDAPI_(ULONG) CEnumRfc1766::Release()
{
    _cRef--;
    DebugMsg(DM_TRACE, TEXT("CEnumRfc1766::Release called. _cRef=%d"), _cRef);
    if (0 < _cRef)
        return _cRef;

    delete this;
    return 0;    
}

STDAPI CEnumRfc1766::Clone(IEnumRfc1766 **ppEnumRfc1766)
{
    DebugMsg(DM_TRACE, TEXT("CEnumRfc1766::Clone called."));
    return E_NOTIMPL;
}

STDAPI CEnumRfc1766::Next(ULONG celt, PRFC1766INFO rgRfc1766Info, ULONG *pceltFetched)
{
    DebugMsg(DM_TRACE, TEXT("CEnumRfc1766::Next called."));

    if (g_pMimeDatabaseReg && (dwMimeSource &  MIMECONTF_MIME_REGISTRY))
    {
        g_pMimeDatabaseReg->EnsureRfc1766Table();
        if (NULL != g_pRfc1766Reg && NULL != rgRfc1766Info)
        {
            UINT cNum = 0;

            while (cNum < celt)
            {
                if (_uCur < g_cRfc1766)
                {
                    (rgRfc1766Info + cNum)->lcid = g_pRfc1766Reg[_uCur].lcid;
                    MultiByteToWideChar(CP_ACP, 0, g_pRfc1766Reg[_uCur].szRfc1766, -1, (rgRfc1766Info + cNum)->wszRfc1766, MAX_RFC1766_NAME);
                    (rgRfc1766Info + cNum)->wszRfc1766[MAX_RFC1766_NAME-1] = 0;
                    MultiByteToWideChar(CP_ACP, 0, g_pRfc1766Reg[_uCur].szLocaleName, -1, (rgRfc1766Info + cNum)->wszLocaleName, MAX_LOCALE_NAME);
                    (rgRfc1766Info + cNum)->wszLocaleName[MAX_LOCALE_NAME-1] = 0;
                    cNum++;
                    _uCur++;
                }
                else
                    break;
            }
            if (NULL != pceltFetched)
                *pceltFetched = cNum;
            return (0 < cNum)? S_OK: S_FALSE;
        }
        else
            return E_FAIL;
    }
    if (NULL != rgRfc1766Info)
    {
        UINT cNum = 0;

        while (cNum < celt)
        {
            if (_uCur < g_cRfc1766)
            {
                (rgRfc1766Info + cNum)->lcid = MimeRfc1766[_uCur].LcId;
                MLStrCpyNW((rgRfc1766Info + cNum)->wszRfc1766, MimeRfc1766[_uCur].szRfc1766, MAX_RFC1766_NAME);

                (rgRfc1766Info + cNum)->wszRfc1766[MAX_RFC1766_NAME-1] = 0; 
                
                if (!_LoadStringExW(g_hInst, MimeRfc1766[_uCur].uidLCID, (rgRfc1766Info + cNum)->wszLocaleName, 
                                    MAX_LOCALE_NAME, _LangID))
                {
                        // Last try, switch to English, US
                        if (!_LoadStringExW(g_hInst, MimeRfc1766[_uCur].uidLCID, (rgRfc1766Info + cNum)->wszLocaleName, 
                                       MAX_LOCALE_NAME, MAKELANGID(LANG_ENGLISH, SUBLANG_ENGLISH_US)))
                             (rgRfc1766Info + cNum)->wszLocaleName[0] = 0x0000;
                }
                (rgRfc1766Info + cNum)->wszLocaleName[MAX_LOCALE_NAME-1] = 0;

                cNum++;
                _uCur++;
            }
            else
                break;
        }
        if (NULL != pceltFetched)
            *pceltFetched = cNum;
        return (0 < cNum)? S_OK: S_FALSE;
    }
    else
        return E_FAIL;
}

STDAPI CEnumRfc1766::Reset()
{
    DebugMsg(DM_TRACE, TEXT("CEnumRfc1766::Reset called."));
    _uCur = 0;
    return NOERROR;
}

STDAPI CEnumRfc1766::Skip(ULONG celt)
{
    DebugMsg(DM_TRACE, TEXT("CEnumRfc1766::Skip called."));
    _uCur += celt;
    return NOERROR;
}

//
// CEnumScript implementation
//
CEnumScript::CEnumScript(DWORD grfFlags, LANGID LangId, MIMECONTF dwSource) : _dwLevel(grfFlags), _LangId( LangId)
{
    DebugMsg(DM_TRACE, TEXT("constructor of CEnumScript 0x%08x"), this);
    DllAddRef();

    _cRef = 1;
    _uCur = 0;
}

CEnumScript::~CEnumScript()
{
    DebugMsg(DM_TRACE, TEXT("destructor of CEnumScript 0x%08x"), this);
    DllRelease();
}

STDAPI CEnumScript::QueryInterface(REFIID riid, void **ppvObj)
{
    DebugMsg(DM_TRACE, TEXT("CEnumScript::QueryInterface called."));
    if (IsEqualIID(riid, IID_IUnknown) || IsEqualIID(riid, IID_IEnumScript))
    {
        *ppvObj = SAFECAST(this, IEnumScript*);
        AddRef();
        return NOERROR;
    }
    *ppvObj = NULL;
    return E_NOINTERFACE;
}

STDAPI_(ULONG) CEnumScript::AddRef()
{
    _cRef++;
    DebugMsg(DM_TRACE, TEXT("CEnumScript::AddRef called. _cRef=%d"), _cRef);
    return _cRef;
}

STDAPI_(ULONG) CEnumScript::Release()
{
    _cRef--;
    DebugMsg(DM_TRACE, TEXT("CEnumScript::Release called. _cRef=%d"), _cRef);
    if (0 < _cRef)
        return _cRef;

    delete this;
    return 0;    
}

STDAPI CEnumScript::Clone(IEnumScript **ppEnumScript)
{
    DebugMsg(DM_TRACE, TEXT("CEnumScript::Clone called."));
    return E_NOTIMPL;
}

STDAPI CEnumScript::Next(ULONG celt, PSCRIPTINFO rgScriptInfo, ULONG *pceltFetched)
{    
    DebugMsg(DM_TRACE, TEXT("CEnumScript::Next called."));

    if (!_dwLevel)
        _dwLevel = ~0;

    if (NULL != rgScriptInfo)
    {
        UINT cNum = 0;
        LANGID LangId = _LangId;

        while (cNum < celt)
        {
            if (_uCur < g_cScript)
            {
                if (!(ScriptTable[_uCur].dwFlags & _dwLevel))
                { 
                    _uCur++;
                    continue;
                }

                (rgScriptInfo + cNum)->ScriptId = ScriptTable[_uCur].sid;

                (rgScriptInfo + cNum)->uiCodePage = ScriptTable[_uCur].uiCodePage;

                (rgScriptInfo + cNum)->wszDescription[0] = 0x0000;

                if (!_LoadStringExW(g_hInst, ScriptTable[_uCur].uidDescription, (rgScriptInfo + cNum)->wszDescription, 
                                    MAX_SCRIPT_NAME, LangId))
                {
                        // Last try, switch to English, US
                        LangId = MAKELANGID(LANG_ENGLISH, SUBLANG_ENGLISH_US);
                        _LoadStringExW(g_hInst, ScriptTable[_uCur].uidDescription, (rgScriptInfo + cNum)->wszDescription, 
                                       MAX_SCRIPT_NAME, LangId);
                }

                (rgScriptInfo + cNum)->wszFixedWidthFont[0] = 0x0000;
                if (ScriptTable[_uCur].uidFixedWidthFont)
                {
                    _LoadStringExW(g_hInst, ScriptTable[_uCur].uidFixedWidthFont, (rgScriptInfo + cNum)->wszFixedWidthFont,
                                   MAX_MIMEFACE_NAME, LangId);
                }

                (rgScriptInfo + cNum)->wszProportionalFont[0] = 0x0000;
                if (ScriptTable[_uCur].uidProportionalFont)
                {
                    _LoadStringExW(g_hInst, ScriptTable[_uCur].uidProportionalFont, (rgScriptInfo + cNum)->wszProportionalFont,
                                   MAX_MIMEFACE_NAME, LangId);
                }

                cNum++;
                _uCur++;
            }
            else
                break;
        }

        if (NULL != pceltFetched)
            *pceltFetched = cNum;
        return (0 < cNum)? S_OK: S_FALSE;
    }
    else
        return E_FAIL;
}


STDAPI CEnumScript::Reset()
{
    DebugMsg(DM_TRACE, TEXT("CEnumScript::Reset called."));
    _uCur = 0;
    return NOERROR;
}

STDAPI CEnumScript::Skip(ULONG celt)
{
    DebugMsg(DM_TRACE, TEXT("CEnumScript::Skip called."));
    _uCur += celt;
    return NOERROR;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\mlang\enumcp.h ===
#ifndef _ENUMCP_H_
#define _ENUMCP_H_

#ifdef  __cplusplus
//
//  CEnumCodePage declaration with IEnumCodePage Interface
//
class CEnumCodePage : public IEnumCodePage
{
    MIMECONTF       dwMimeSource;

public:
    // IUnknown methods
    virtual STDMETHODIMP QueryInterface(REFIID riid, void **ppvObj);
    virtual STDMETHODIMP_(ULONG) AddRef(void);
    virtual STDMETHODIMP_(ULONG) Release(void);

    // IEnumCodePage methods
    virtual STDMETHODIMP Clone(IEnumCodePage **ppEnumCodePage);
    virtual STDMETHODIMP Next(ULONG celt, PMIMECPINFO rgcpInfo, ULONG *pceltFetched);
    virtual STDMETHODIMP Reset(void);
    virtual STDMETHODIMP Skip(ULONG celt);

    // Constructor & Destructor
    CEnumCodePage(DWORD grfFlags, LANGID LangId, MIMECONTF dwSource);
    ~CEnumCodePage();

protected:
    int _cRef;
    int _iCur;
    DWORD   _dwLevel;
    LANGID  _LangId;
};

//
//  CEnumRfc1766 declaration with IEnumRfc1766 Interface
//
class CEnumRfc1766 : public IEnumRfc1766
{
    MIMECONTF   dwMimeSource;

public:
    // IUnknown methods
    virtual STDMETHODIMP QueryInterface(REFIID riid, void **ppvObj);
    virtual STDMETHODIMP_(ULONG) AddRef(void);
    virtual STDMETHODIMP_(ULONG) Release(void);

    // IEnumCodePage methods
    virtual STDMETHODIMP Clone(IEnumRfc1766 **ppEnumRfc1766);
    virtual STDMETHODIMP Next(ULONG celt, PRFC1766INFO rgRfc1766Info, ULONG *pceltFetched);
    virtual STDMETHODIMP Reset(void);
    virtual STDMETHODIMP Skip(ULONG celt);

    // Constructor & Destructor
    CEnumRfc1766(MIMECONTF dwSource, LANGID LangId);
    ~CEnumRfc1766();

protected:
    LANGID  _LangID;
    int     _cRef;
    UINT    _uCur;
};

class CEnumScript : public IEnumScript
{
public:
    // IUnknown methods
    virtual STDMETHODIMP QueryInterface(REFIID riid, void **ppvObj);
    virtual STDMETHODIMP_(ULONG) AddRef(void);
    virtual STDMETHODIMP_(ULONG) Release(void);

    // IEnumScript methods
    virtual STDMETHODIMP Clone(IEnumScript **ppEnumScript);
    virtual STDMETHODIMP Next(ULONG celt, PSCRIPTINFO rgScriptInfo, ULONG *pceltFetched);
    virtual STDMETHODIMP Reset(void);
    virtual STDMETHODIMP Skip(ULONG celt);

    // Constructor & Destructor
    CEnumScript(DWORD grfFlags, LANGID LangId, MIMECONTF dwSource);
    ~CEnumScript();

protected:
    int     _cRef;
    UINT    _uCur;
    LANGID  _LangId;
    DWORD   _dwLevel;
};


#endif  // __cplusplus

typedef struct tagRFC1766INFOA
{
    LCID    lcid;
    char    szRfc1766[MAX_RFC1766_NAME];
    char    szLocaleName[MAX_LOCALE_NAME];
} RFC1766INFOA, *PRFC1766INFOA;

#endif  // _ENUMCP_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\mlang\dllload.cpp ===
//----------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997
//
//  File:
//
//  Contents:
//
//  Classes:
//
//  Functions:
//
//  History:
//
//----------------------------------------------------------------------------
#include "private.h"
#include <winsock.h>

#pragma warning(disable:4229)  // No warnings when modifiers used on data

//----------------------------------------------------------------------------
// Delay loading mechanism.  [Stolen from shdocvw.]
//
// This allows you to write code as if you are
// calling implicitly linked APIs, and yet have these APIs really be
// explicitly linked.  You can reduce the initial number of DLLs that 
// are loaded (load on demand) using this technique.
//
// Use the following macros to indicate which APIs/DLLs are delay-linked
// and -loaded.
//
//      DELAY_LOAD
//      DELAY_LOAD_HRESULT
//      DELAY_LOAD_SAFEARRAY
//      DELAY_LOAD_UINT
//      DELAY_LOAD_INT
//      DELAY_LOAD_VOID
//
// Use these macros for APIs that are exported by ordinal only.
//
//      DELAY_LOAD_ORD
//      DELAY_LOAD_ORD_VOID     
//
// Use these macros for APIs that only exist on the integrated-shell
// installations (i.e., a new shell32 is on the system).
//
//      DELAY_LOAD_SHELL
//      DELAY_LOAD_SHELL_HRESULT
//      DELAY_LOAD_SHELL_VOID     
//
//----------------------------------------------------------------------------

#define ENSURE_LOADED(_hinst, _dll, pszfn)   (_hinst ? _hinst : (_hinst = LoadLibrary(#_dll)))

#define DELAY_LOAD_ERR(_hinst, _dll, _ret, _fn, _args, _nargs, _err) \
static _ret (* __stdcall _pfn##_fn) _args = NULL;   \
_ret __stdcall _fn _args                \
{                                       \
    if (!ENSURE_LOADED(_hinst, _dll, #_fn))   \
    {                                   \
        AssertMsg(_hinst != NULL, "LoadLibrary failed on " ## #_dll); \
        return (_ret)_err;                      \
    }                                   \
    if (_pfn##_fn == NULL)              \
    {                                   \
        *(FARPROC*)&(_pfn##_fn) = GetProcAddress(_hinst, #_fn); \
        AssertMsg(_pfn##_fn != NULL, "GetProcAddress failed on " ## #_fn); \
        if (_pfn##_fn == NULL)          \
            return (_ret)_err;          \
    }                                   \
    return _pfn##_fn _nargs;            \
 }

#define DELAY_LOAD_VOID(_hinst, _dll, _fn, _args, _nargs) \
void __stdcall _fn _args                \
{                                       \
    static void (* __stdcall _pfn##_fn) _args = NULL;   \
    if (!ENSURE_LOADED(_hinst, _dll, #_fn))   \
    {                                   \
        AssertMsg(_hinst != NULL, "LoadLibrary failed on " ## #_dll); \
        return;                         \
    }                                   \
    if (_pfn##_fn == NULL)              \
    {                                   \
        *(FARPROC*)&(_pfn##_fn) = GetProcAddress(_hinst, #_fn); \
        AssertMsg(_pfn##_fn != NULL, "GetProcAddress failed on " ## #_fn); \
        if (_pfn##_fn == NULL)          \
            return;                     \
    }                                   \
    _pfn##_fn _nargs;                   \
 }

#define DELAY_LOAD(_hinst, _dll, _ret, _fn, _args, _nargs) DELAY_LOAD_ERR(_hinst, _dll, _ret, _fn, _args, _nargs, 0)
#define DELAY_LOAD_HRESULT(_hinst, _dll, _fn, _args, _nargs) DELAY_LOAD_ERR(_hinst, _dll, HRESULT, _fn, _args, _nargs, E_FAIL)
#define DELAY_LOAD_SAFEARRAY(_hinst, _dll, _fn, _args, _nargs) DELAY_LOAD_ERR(_hinst, _dll, SAFEARRAY *, _fn, _args, _nargs, NULL)
#define DELAY_LOAD_DWORD(_hinst, _dll, _fn, _args, _nargs) DELAY_LOAD_ERR(_hinst, _dll, DWORD, _fn, _args, _nargs, 0)
#define DELAY_LOAD_UINT(_hinst, _dll, _fn, _args, _nargs) DELAY_LOAD_ERR(_hinst, _dll, UINT, _fn, _args, _nargs, 0)
#define DELAY_LOAD_INT(_hinst, _dll, _fn, _args, _nargs) DELAY_LOAD_ERR(_hinst, _dll, INT, _fn, _args, _nargs, 0)

#define DELAY_LOAD_ORD_ERR(_hinst, _dll, _ret, _fn, _ord, _args, _nargs, _err) \
_ret __stdcall _fn _args                \
{                                       \
    static _ret (* __stdcall _pfn##_fn) _args = NULL;   \
    if (!ENSURE_LOADED(_hinst, _dll, "(ordinal " ## #_ord ## ")"))   \
    {                                   \
        TraceMsg(TF_ERROR, "LoadLibrary failed on " ## #_dll); \
        return (_ret)_err;                      \
    }                                   \
    if (_pfn##_fn == NULL)              \
    {                                   \
        *(FARPROC*)&(_pfn##_fn) = GetProcAddress(_hinst, (LPSTR) _ord); \
                                        \
        /* GetProcAddress always returns non-NULL, even for bad ordinals.   \
           But do the check anyways...  */                                  \
                                        \
        if (_pfn##_fn == NULL)          \
            return (_ret)_err;          \
    }                                   \
    return _pfn##_fn _nargs;            \
 }

#define DELAY_LOAD_ORD_VOID(_hinst, _dll, _fn, _ord, _args, _nargs) \
void __stdcall _fn _args                \
{                                       \
    static void (* __stdcall _pfn##_fn) _args = NULL;   \
    if (!ENSURE_LOADED(_hinst, _dll, "(ordinal " ## #_ord ## ")"))   \
    {                                   \
        TraceMsg(TF_ERROR, "LoadLibrary failed on " ## #_dll); \
        return;                         \
    }                                   \
    if (_pfn##_fn == NULL)              \
    {                                   \
        *(FARPROC*)&(_pfn##_fn) = GetProcAddress(_hinst, (LPSTR) _ord); \
                                        \
        /* GetProcAddress always returns non-NULL, even for bad ordinals.   \
           But do the check anyways...  */                                  \
                                        \
        if (_pfn##_fn == NULL)          \
            return;                     \
    }                                   \
    _pfn##_fn _nargs;                   \
}
        
#define DELAY_LOAD_ORD(_hinst, _dll, _ret, _fn, _ord, _args, _nargs) DELAY_LOAD_ORD_ERR(_hinst, _dll, _ret, _fn, _ord, _args, _nargs, 0)

//
// And now the DLLs which are delay loaded
//

// --------- OLEAUT32.DLL ---------------

HINSTANCE g_hinstOLEAUT32 = NULL;

DELAY_LOAD_HRESULT(g_hinstOLEAUT32, OLEAUT32.DLL, RegisterTypeLib,
    (ITypeLib *ptlib, OLECHAR *szFullPath, OLECHAR *szHelpDir), (ptlib, szFullPath, szHelpDir));

DELAY_LOAD_HRESULT(g_hinstOLEAUT32, OLEAUT32.DLL, LoadTypeLib,
    (const OLECHAR *szFile, ITypeLib **pptlib), (szFile, pptlib));

DELAY_LOAD_HRESULT(g_hinstOLEAUT32, OLEAUT32.DLL, CreateErrorInfo,
    (ICreateErrorInfo **pperrinfo), (pperrinfo));

DELAY_LOAD_HRESULT(g_hinstOLEAUT32, OLEAUT32.DLL, SetErrorInfo,
   (unsigned long dwReserved, IErrorInfo*perrinfo), (dwReserved, perrinfo));

DELAY_LOAD_HRESULT(g_hinstOLEAUT32, OLEAUT32.DLL, LoadRegTypeLib,
    (REFGUID rguid, WORD wVerMajor, WORD wVerMinor, LCID lcid, ITypeLib **pptlib),
    (rguid, wVerMajor, wVerMinor, lcid, pptlib));

DELAY_LOAD(g_hinstOLEAUT32, OLEAUT32.DLL, BSTR, SysAllocString, (const OLECHAR*pch), (pch));

DELAY_LOAD(g_hinstOLEAUT32, OLEAUT32.DLL, BSTR, SysAllocStringLen, 
    (const OLECHAR*pch, unsigned int i), (pch, i));

DELAY_LOAD(g_hinstOLEAUT32, OLEAUT32.DLL, BSTR, SysAllocStringByteLen,
    (LPCSTR psz, UINT i), (psz, i));

DELAY_LOAD_UINT(g_hinstOLEAUT32, OLEAUT32.DLL, SysStringLen, (BSTR bstr), (bstr));

DELAY_LOAD_UINT(g_hinstOLEAUT32, OLEAUT32.DLL, SysStringByteLen, (BSTR bstr), (bstr));

DELAY_LOAD_VOID(g_hinstOLEAUT32, OLEAUT32.DLL, SysFreeString, (BSTR bs), (bs));

DELAY_LOAD_VOID(g_hinstOLEAUT32, OLEAUT32.DLL, VariantInit, (VARIANTARG *pvarg), (pvarg));

DELAY_LOAD_HRESULT(g_hinstOLEAUT32, OLEAUT32.DLL, VariantCopy,
    (VARIANTARG *pvargDest, VARIANTARG *pvargSrc), (pvargDest, pvargSrc));

DELAY_LOAD_HRESULT(g_hinstOLEAUT32, OLEAUT32.DLL, VariantChangeType,
    (VARIANTARG *pvargDest, VARIANTARG *pvargSrc, unsigned short wFlags, VARTYPE vt),
    (pvargDest, pvargSrc, wFlags, vt));

DELAY_LOAD_HRESULT(g_hinstOLEAUT32, OLEAUT32.DLL, VariantClear, (VARIANTARG *pvarg), (pvarg));

#pragma warning(default:4229)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\mlang\eucjobj.cpp ===
// ============================================================================
// Internet Character Set Conversion: Input from EUC-JP
// ============================================================================

#include "private.h"
#include "fechrcnv.h"
#include "eucjobj.h"
#include "codepage.h"

/******************************************************************************
**************************   C O N S T R U C T O R   **************************
******************************************************************************/

CInccEucJIn::CInccEucJIn(UINT uCodePage, int nCodeSet) : CINetCodeConverter(uCodePage, nCodeSet)
{
    Reset();    // initialization
    return ;
}

/******************************************************************************
*******************************   R E S E T   *********************************
******************************************************************************/

void CInccEucJIn::Reset()
{
    m_pfnConv = ConvMain;
    m_pfnCleanUp = CleanUpMain;
    m_tcLeadByte = 0 ;
    return ;
}

/******************************************************************************
*************************   C O N V E R T   C H A R   *************************
******************************************************************************/

HRESULT CInccEucJIn::ConvertChar(UCHAR tc, int cchSrc)
{
    BOOL fDone = (this->*m_pfnConv)(tc);
    if (fDone)
        return S_OK;
    else
        return E_FAIL;
}

/******************************************************************************
*****************************   C L E A N   U P   *****************************
******************************************************************************/

BOOL CInccEucJIn::CleanUp()
{
    return (this->*m_pfnCleanUp)();
}

/******************************************************************************
****************************   C O N V   M A I N   ****************************
******************************************************************************/

BOOL CInccEucJIn::ConvMain(UCHAR tc)
{
    BOOL fDone = TRUE;



    if (tc >= 0xa1 && tc <= 0xfe) {
        m_pfnConv = ConvDoubleByte;
        m_pfnCleanUp = CleanUpDoubleByte;
        m_tcLeadByte = tc;
    } else if (tc == 0x8e) { // Single Byte Katakana
        m_pfnConv = ConvKatakana;
        m_pfnCleanUp = CleanUpKatakana;
    } else {
        fDone = Output(tc);
    }
    return fDone;
}

/******************************************************************************
************************   C L E A N   U P   M A I N   ************************
******************************************************************************/

BOOL CInccEucJIn::CleanUpMain()
{
    return TRUE;
}

/******************************************************************************
*********************   C O N V   D O U B L E   B Y T E   *********************
******************************************************************************/

BOOL CInccEucJIn::ConvDoubleByte(UCHAR tc)
{
    BOOL fRet ;

    m_pfnConv = ConvMain;
    m_pfnCleanUp = CleanUpMain;
    if (m_tcLeadByte <= 0xde) { // && m_tcLeadByte >= 0xa1
        if (m_tcLeadByte % 2) // odd
            (void)Output((m_tcLeadByte - 0xa1) / 2 + 0x81);
        else // even
            (void)Output((m_tcLeadByte - 0xa2) / 2 + 0x81);
    } else { // m_tcLeadByte >= 0xdf && m_tcLeadByte <= 0xfe
        if (m_tcLeadByte % 2) // odd
            (void)Output((m_tcLeadByte - 0xdf) / 2 + 0xe0);
        else // even
            (void)Output((m_tcLeadByte - 0xe0) / 2 + 0xe0);
    }
    if (m_tcLeadByte % 2) { // odd
        if (tc >= 0xa1 && tc <= 0xdf)
            fRet = Output(tc - 0x61);
        else
            fRet = Output(tc - 0x60);
    } else { // even
        fRet = Output(tc - 2);
    }
    m_tcLeadByte = 0 ;
    return fRet ;
}

/******************************************************************************
*****************   C L E A N   U P   D O U B L E   B Y T E   *****************
******************************************************************************/

BOOL CInccEucJIn::CleanUpDoubleByte()
{
    m_pfnConv = ConvMain;
    m_pfnCleanUp = CleanUpMain;
    return TRUE;
}

/******************************************************************************
************************   C O N V   K A T A K A N A   ************************
******************************************************************************/

BOOL CInccEucJIn::ConvKatakana(UCHAR tc)
{
    m_pfnConv = ConvMain;
    m_pfnCleanUp = CleanUpMain;
    return Output(tc);
}

/******************************************************************************
********************   C L E A N   U P   K A T A K A N A   ********************
******************************************************************************/

BOOL CInccEucJIn::CleanUpKatakana()
{
    m_pfnConv = ConvMain;
    m_pfnCleanUp = CleanUpMain;
    return TRUE;
}

int CInccEucJIn::GetUnconvertBytes()
{
    if (m_tcLeadByte || m_pfnConv == ConvKatakana)
        return 1;
    else
        return 0;
}

DWORD CInccEucJIn::GetConvertMode()
{
    // 0xCADC -> 51932 EUC-JP (codepage)
    return 0xCADC0000 ;
}

void CInccEucJIn::SetConvertMode(DWORD mode)
{
    Reset();
    return ;
}


// ============================================================================
// Internet Character Set Conversion: Output to EUC-JP
// ============================================================================

/******************************************************************************
**************************   C O N S T R U C T O R   **************************
******************************************************************************/

CInccEucJOut::CInccEucJOut(UINT uCodePage, int nCodeSet, DWORD dwFlag, WCHAR *lpFallBack) : CINetCodeConverter(uCodePage, nCodeSet)
{
    Reset();    // initialization
    _dwFlag = dwFlag;
    _lpFallBack = lpFallBack;
    return ;
}

/******************************************************************************
*******************************   R E S E T   *********************************
******************************************************************************/
void CInccEucJOut::Reset()
{
    m_fDoubleByte = FALSE;
    m_tcLeadByte = 0 ;
    return ;
}

/******************************************************************************
*************************   C O N V E R T   C H A R   *************************
******************************************************************************/

HRESULT CInccEucJOut::ConvertChar(UCHAR tc, int cchSrc)
{
    BOOL fDone = TRUE;
    HRESULT hr = S_OK;

    if (!m_fDoubleByte) {
        if ((tc >= 0x81 && tc <= 0x9f) || (tc >= 0xe0 && tc <= 0xfc )) { // Double Byte Code
            m_fDoubleByte = TRUE;
            m_tcLeadByte = tc;
        } else if (tc >= 0xa1 && tc <= 0xdf) { // Single Byte Katakana Code
            (void) Output( (UCHAR) 0x8e);
            fDone = Output(tc);
        } else {
            fDone = Output(tc);
        }
    } else {

        // map extended char (0xfa40-0xfc4b) to a special range
        if (m_tcLeadByte >= 0xfa && m_tcLeadByte <= 0xfc && tc >= 0x40 )
        {
            WCHAR  wcDBCS ;

            wcDBCS = ((WCHAR) m_tcLeadByte ) << 8 | tc ;

            if ( wcDBCS >= 0xfa40 && wcDBCS <= 0xfa5b )
            {
                if ( wcDBCS <= 0xfa49 )
                    wcDBCS = wcDBCS - 0x0b51 ;
                else if ( wcDBCS >= 0xfa4a && wcDBCS <= 0xfa53 )
                    wcDBCS = wcDBCS - 0x072f6 ;
                else if ( wcDBCS >= 0xfa54 && wcDBCS <= 0xfa57 )
                    wcDBCS = wcDBCS - 0x0b5b ;
                else if ( wcDBCS == 0xfa58 )
                    wcDBCS = 0x878a ;
                else if ( wcDBCS == 0xfa59 )
                    wcDBCS = 0x8782 ;
                else if ( wcDBCS == 0xfa5a )
                    wcDBCS = 0x8784 ;
                else if ( wcDBCS == 0xfa5b )
                    wcDBCS = 0x879a ;
            }
            else if ( wcDBCS >= 0xfa5c && wcDBCS <= 0xfc4b )
            {
                if ( tc < 0x5c )
                    wcDBCS = wcDBCS - 0x0d5f;
                else if ( tc >= 0x80 && tc <= 0x9B )
                    wcDBCS = wcDBCS - 0x0d1d;
                else
                    wcDBCS = wcDBCS - 0x0d1c;
            }
            tc = (UCHAR) wcDBCS ;
            m_tcLeadByte = (UCHAR) ( wcDBCS >> 8 ) ;
        }

        // Do conversion
        if (m_tcLeadByte <= 0xef) {
            if (m_tcLeadByte <= 0x9f) { // && m_tcLeadByte >= 0x81
                if (tc <= 0x9e)
                    (void)Output((m_tcLeadByte - 0x81) * 2 + 0xa1);
                else
                    (void)Output((m_tcLeadByte - 0x81) * 2 + 0xa2);
            } else { // m_tcLeadByte >= 0xe0 && m_tcLeadByte <= 0xef
                if (tc <= 0x9e)
                    (void)Output((m_tcLeadByte - 0xe0) * 2 + 0xdf);
                else
                    (void)Output((m_tcLeadByte - 0xe0) * 2 + 0xe0);
            }
            if (tc >= 0x40 && tc <= 0x7e)
                fDone = Output(tc + 0x61);
            else if (tc >= 0x80 && tc <= 0x9e)
                fDone = Output(tc + 0x60);
            else
                fDone = Output(tc + 0x02);
        } else if (m_tcLeadByte >= 0xfa) { // && m_tcLeadByte <= 0xfc; IBM Extended Char
            UCHAR szDefaultChar[3] = {0x3f}; // possible DBCS + null    


            if (_lpFallBack && (_dwFlag & MLCONVCHARF_USEDEFCHAR))
            {
                // only take SBCS, no DBCS character
                if ( 1 != WideCharToMultiByte(CP_JPN_SJ, 0,
                               (LPCWSTR)_lpFallBack, 1,
                               (LPSTR)szDefaultChar, ARRAYSIZE(szDefaultChar), NULL, NULL ))
                    szDefaultChar[0] = 0x3f;
            }

            if (_dwFlag & (MLCONVCHARF_NCR_ENTITIZE|MLCONVCHARF_NAME_ENTITIZE))
            {
                char    szChar[2];
                char    szDstStr[10];
                WCHAR   szwChar[2];
                int     cCount;

                szChar[0] = m_tcLeadByte;
                szChar[1] = tc;
                
                if (MultiByteToWideChar(CP_JPN_SJ, 0, szChar, 2, szwChar, ARRAYSIZE(szwChar)))
                {

                    // Output NCR entity
                    Output('&');
                    Output('#');
                    _ultoa((unsigned long)szwChar[0], (char*)szDstStr, 10);
                    cCount = lstrlenA(szDstStr);
                    for (int i=0; i< cCount; i++)
                    {
                        Output(szDstStr[i]);
                    }
                    fDone = Output(';');
                }
                else
                {
                    fDone = Output(szDefaultChar[0]);
                    hr = S_FALSE;
                }
            }
            else
            {
                    fDone = Output(szDefaultChar[0]);
                    hr = S_FALSE;
            }
        } else {
            (void)Output(m_tcLeadByte);
            fDone = Output(tc);
        }
        m_fDoubleByte = FALSE;
        m_tcLeadByte = 0 ;
    }

    if (!fDone)
        hr = E_FAIL;

    return hr;
}

/******************************************************************************
*****************************   C L E A N   U P   *****************************
******************************************************************************/

BOOL CInccEucJOut::CleanUp()
{
    m_fDoubleByte = FALSE;
    return TRUE;
}

int CInccEucJOut::GetUnconvertBytes()
{
    if (m_tcLeadByte)
        return 1;
    else
        return 0;
}

DWORD CInccEucJOut::GetConvertMode()
{
    return 0 ;
}

void CInccEucJOut::SetConvertMode(DWORD mode)
{
    Reset();
    return ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\mlang\fechmap.cpp ===
/*----------------------------------------------------------------------------
    %%File: fechmap.c
    %%Unit: fechmap
    %%Contact: jpick

    DLL entry points for FarEast conversion module.
----------------------------------------------------------------------------*/

#include "private.h"
#include "fechmap_.h"

#include "codepage.h"

static CODEPAGE _mpicetce[icetCount] =
{
    CP_EUC_CH,              // icetEucCn
    CP_EUC_JP,              // icetEucJp
    CP_EUC_KR,              // icetEucKr
    CP_UNDEFINED,           // icetEucTw        (Not externally supported)
    CP_UNDEFINED,           // icetIso2022Cn    (Not externally supported)
    CP_ISO_2022_JP,         // icetIso2022Jp
    CP_ISO_2022_KR,         // icetIso2022Kr
    CP_UNDEFINED,           // icetIso2022Tw    (Not externally supported)
    CP_TWN,                 // icetBig5
    CP_CHN_GB,              // icetGbk
    CP_CHN_HZ,              // icetHz
    CP_JPN_SJ,              // icetShiftJis
    CP_KOR_5601,            // icetWansung
    CP_UTF_7,               // icetUtf7
    CP_UTF_8,               // icetUtf8
};

/* C C E  D E T E C T  I N P U T  C O D E */
/*----------------------------------------------------------------------------
    %%Function: CceDetectInputCode
    %%Contact: jpick

    Routine that will analyze contents of file to make a best guess
    as to what encoding method was used on it.  Caller-supplied get
    and unget routines used for data access.
----------------------------------------------------------------------------*/
EXPIMPL(CCE)
CceDetectInputCode(
    IStream   *pstmIn,           // input stream
    DWORD     dwFlags,          // configuration flags
    EFam      efPref,           // optional: preferred encoding family
    int       nPrefCp,          // optional: preferred code page
    UINT      *lpCe,                // set to detected encoding
    BOOL      *lpfGuess         // set to fTrue if function "guessed"
)
{
    CCE cceRet;
    ICET icet;
    
    if (!pstmIn || !lpCe || !lpfGuess)
        return cceInvalidParameter;
        
    // DEBUG, only.  Prepare the assert handler.  This macro will
    // return cceInternal to the calling app if an assert is hit
    // before the handler is cleared, below.
    //
    //  InitAndCatchAsserts();
        
    cceRet = CceDetermineInputType(pstmIn, dwFlags, efPref, 
                    nPrefCp, &icet, lpfGuess);
    
    if ((cceRet == cceSuccess) || (cceRet == cceMayBeAscii))
        {
        if (_mpicetce[icet] != CP_UNDEFINED )
            *lpCe = (UINT) _mpicetce[icet];
        else
            cceRet = cceUnknownInput;
        }
        
    // Done with the assert handler.
    //
    //  ClearAsserts();

    return cceRet;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\mlang\eucjobj.h ===
#include "convbase.h"

class CInccEucJIn : public CINetCodeConverter
{
private:
    BOOL (CInccEucJIn::*m_pfnConv)(UCHAR tc);
    BOOL (CInccEucJIn::*m_pfnCleanUp)();
    UCHAR m_tcLeadByte;                             /* perserve the last lead byte */

public:
    CInccEucJIn(UINT uCodePage, int nCodeSet);
    ~CInccEucJIn() {}
    virtual HRESULT ConvertChar(UCHAR tc, int cchSrc=-1);
    virtual BOOL CleanUp();
    virtual int GetUnconvertBytes();
    virtual DWORD GetConvertMode();
    virtual void SetConvertMode(DWORD mode);

private:
    void Reset();
    BOOL ConvMain(UCHAR tc);
    BOOL CleanUpMain();
    BOOL ConvDoubleByte(UCHAR tc);
    BOOL CleanUpDoubleByte();
    BOOL ConvKatakana(UCHAR tc);
    BOOL CleanUpKatakana();
};

class CInccEucJOut : public CINetCodeConverter
{
private:
    BOOL m_fDoubleByte;
    BYTE m_tcLeadByte;
    DWORD   _dwFlag;
    WCHAR   *_lpFallBack;

public:
    CInccEucJOut(UINT uCodePage, int nCodeSet,  DWORD dwFlag, WCHAR *lpFallBack);
    ~CInccEucJOut() {}
    virtual HRESULT ConvertChar(UCHAR tc, int cchSrc=-1);
    virtual BOOL CleanUp();
    virtual int GetUnconvertBytes();
    virtual DWORD GetConvertMode();
    virtual void SetConvertMode(DWORD mode);
private:
    void Reset();
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\mlang\fechmap_.h ===
/*----------------------------------------------------------------------------
    %%File: fechmap_.h
    %%Unit: fechmap
    %%Contact: jpick

    Internal header file for FarEast character conversion module.
----------------------------------------------------------------------------*/

#ifndef FECHMAP__H
#define FECHMAP__H

#include <windows.h>
#include <stdio.h>
#include <stddef.h>

#include "msencode.h"
//#include "assert.h"


// Character encoding types supported by this module.
// Internal version -- broader than the set exposed publicly.
// (Doing this since much of the groundwork is already in
// for future support don't want to remove or ifdef out that
// code).
//
// Main DLL entry points manage the correspondence between
// external and internal encoding types.
//
typedef enum _icet      // Internal Character Encoding Type
    {
    icetNil = -1,
    icetEucCn = 0,
    icetEucJp,
    icetEucKr,
    icetEucTw,
    icetIso2022Cn,
    icetIso2022Jp,
    icetIso2022Kr,
    icetIso2022Tw,
    icetBig5,
    icetGbk,
    icetHz,
    icetShiftJis,
    icetWansung,
    icetUtf7,
    icetUtf8,
    icetCount,
    } ICET;


// Miscellaneous useful definitions
//
#define fTrue   (BOOL) 1
#define fFalse  (BOOL) 0


// MS Code Page Definitions
//
#define nCpJapan        932
#define nCpChina        936
#define nCpKorea        949
#define nCpTaiwan       950

#define FIsFeCp(cp) \
    (((cp) == nCpJapan) || ((cp) == nCpChina) || ((cp) == nCpKorea) || ((cp) == nCpTaiwan))

#define WchFromUchUch(uchLead, uchTrail) \
    (WCHAR) ((((UCHAR)(uchLead)) << 8) | ((UCHAR)(uchTrail)))

// Prototype for internal auto-detection code
//
CCE CceDetermineInputType(
    IStream   *pstmIn,           // input stream
    DWORD     dwFlags,
    EFam      efPref,
    int       nPrefCp,
    ICET     *lpicet,
    BOOL     *lpfGuess
);

// Prototype for ISO-2022 escape sequence interpreter.
//
CCE CceReadEscSeq(IStream *pstmIn, ICET *lpicet);

#endif                  // #ifndef FECHMAP__H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\mlang\fechauto.cpp ===
/*----------------------------------------------------------------------------
    %%File: fechauto.c
    %%Unit: fechmap
    %%Contact: jpick

    Module that attempts to auto-detect encoding for a given stream.
----------------------------------------------------------------------------*/

#include <stdio.h>
#include <stddef.h>

#include "private.h"
#include "fechmap_.h"
#include "lexint_.h"

// Code marked by these #defines will be deleted eventually ...
// (It prints out useful information and statistics about how
// auto-detect is doing and what it's finding in the input).
//
#define JPDEBUG         0
#define JPDEBUG2        0
#define JPDEBUG3        0

#define NEED_NAMES      0

#if JPDEBUG || JPDEBUG2 || JPDEBUG3
#undef NEED_NAMES
#define NEED_NAMES      1
#endif

#if NEED_NAMES
static char *rgszIcetNames[icetCount] =
{
    "icetEucCn",
    "icetEucJp",
    "icetEucKr",
    "icetEucTw",
    "icetIso2022Cn",
    "icetIso2022Jp",
    "icetIso2022Kr",
    "icetIso2022Tw",
    "icetBig5",
    "icetGbk",
    "icetHz",
    "icetShiftJis",
    "icetWansung",
    "icetUtf7",
    "icetUtf8",
};
#endif

// Characters we care about
//
#define chSo        (UCHAR) 0x0e
#define chSi        (UCHAR) 0x0f
#define chEsc       (UCHAR) 0x1b

// Minimum Sample Size
//
#define cchMinSample        64

// High-ASCII character threshold.  If this routine is unable
// to absolutely determine the encoding of this file, it will
// need to guess.  Files that are ASCII, but contain high-ASCII
// characters (e.g., a file with some Cyrillic characters) may
// confuse us.  If the number of high-ASCII characters falls
// below this threshold, return the encoding we guessed but 
// also return a special rc that says the file "might be ASCII."
//
// 5%, for now.
//
// 40%, for now, of the high-ascii characters must be in high-
// ascii pairs.  (Pulled down because of Big5 and the other
// DBCS encodings that can have trail bytes in the low range).
//
#define nHighCharThreshold       5      // %
#define nHighPairThreshold      40      // %

// Used by CceDetermineInputTypeReturnAll() to determine whether any icet has
// high enough count to rule out all other icets.
//
#define CchCountThreshold(icet) (((icet) == icetHz || (icet) == icetUtf7) ? 5 : 10)



// Tokens
//
// Stop tokens (negative) imply special handling and will cause
// the processing loop to stop (eof, err, si, so and esc are
// stop tokens).
//
#define xmn           0
#define esc         (-1)
#define  so         (-2)
#define  si         (-3)
#define eof         (-4)
#define err         (-5)

#define _FStopToken(tk)     ((tk) < 0)


// Masks used in _CBitsOnFromUlong()
//
#define lMaskBitCount1  (LONG) 0x55555555
#define lMaskBitCount2  (LONG) 0x33333333
#define lMaskBitCount3  (LONG) 0x0F0F0F0F
#define lMaskBitCount4  (LONG) 0x00FF00FF
#define lMaskBitCount5  (LONG) 0x0000FFFF

/* _  C  B I T S  O N  F R O M  U L O N G */
/*----------------------------------------------------------------------------
    %%Function: _CBitsOnFromUlong
    %%Contact: jpick

    (adapted from code in convio.c)
----------------------------------------------------------------------------*/
int __inline _CBitsOnFromUlong(ULONG ulBits)
{
    ulBits = (ulBits & lMaskBitCount1) + ((ulBits & ~lMaskBitCount1) >> 1);
    ulBits = (ulBits & lMaskBitCount2) + ((ulBits & ~lMaskBitCount2) >> 2);
    ulBits = (ulBits & lMaskBitCount3) + ((ulBits & ~lMaskBitCount3) >> 4);
    ulBits = (ulBits & lMaskBitCount4) + ((ulBits & ~lMaskBitCount4) >> 8);
    ulBits = (ulBits & lMaskBitCount5) + ((ulBits & ~lMaskBitCount5) >> 16);
    
    return (int)ulBits;
}
    
// Masks for the encodings
//
#define grfEucCn        (ULONG) 0x0001
#define grfEucJp        (ULONG) 0x0002
#define grfEucKr        (ULONG) 0x0004
#define grfEucTw        (ULONG) 0x0008
#define grfIso2022Cn    (ULONG) 0x0010
#define grfIso2022Jp    (ULONG) 0x0020
#define grfIso2022Kr    (ULONG) 0x0040
#define grfIso2022Tw    (ULONG) 0x0080
#define grfBig5         (ULONG) 0x0100
#define grfGbk          (ULONG) 0x0200
#define grfHz           (ULONG) 0x0400 
#define grfShiftJis     (ULONG) 0x0800
#define grfWansung      (ULONG) 0x1000
#define grfUtf7         (ULONG) 0x2000  
#define grfUtf8         (ULONG) 0x4000

// grfAll assumes that the tests for Euc-Kr fall within those
// for Wansung (as far as I can tell from reading, Euc-Kr is a
// strict subset of Wansung).  The same for Euc-Cn and Gbk.  No
// need to test for both the subset and the whole.
//
#define grfAll              (ULONG) 0x7FFA
#define grfAllButIso2022    (ULONG) 0x7F0A
#define cAll                13              // == number bits set in grfAll
#define cAllButIso2022      9               // == number bits set in grfAllButIso2022

// Array that maps an encoding to its mask
//
static ULONG _mpicetgrf[icetCount] =
{
    grfEucCn,
    grfEucJp,
    grfEucKr,
    grfEucTw,
    grfIso2022Cn,
    grfIso2022Jp,
    grfIso2022Kr,
    grfIso2022Tw,
    grfBig5,
    grfGbk,
    grfHz,
    grfShiftJis,
    grfWansung,
    grfUtf7,
    grfUtf8,
};

// Prototypes
//
static int  _NGetNextUch(IStream *pstmIn, unsigned char *c, BOOL *lpfIsHigh);
static ICET _IcetFromIcetMask(ULONG ulMask);
static ICET _IcetDefaultFromIcetMask(ULONG ulMask);
static CCE  _CceResolveAmbiguity(ULONG grfIcet, ICET *lpicet, int nPrefCp, EFam efPref);
static CCE  _CceReadEscSeq(IStream *pstmIn, int nPrefCp, ICET *lpicet, BOOL *lpfGuess);


/* C C E  D E T E R M I N E  I N P U T  T Y P E */
/*----------------------------------------------------------------------------
    %%Function: CceDetermineInputType
    %%Contact: jpick

    Attempt to determine the appropriate ICET type for the given 
    stream.  Caller-supplied get/unget routines used for data access.
----------------------------------------------------------------------------*/
CCE CceDetermineInputType(
    IStream   *pstmIn,           // input stream
    DWORD     dwFlags,          // configuration flags
    EFam      efPref,           // optional: preferred encoding family
    int       nPrefCp,          // optional: preferred code page
    ICET     *lpicet,           // set to detected encoding
    BOOL     *lpfGuess          // set to fTrue if function "guessed"
)
{
    unsigned char uch;
    int nToken;
    CCE cceRet;
    BOOL fGuess;
    ICET icet;
    int cIcetActive;
    ULONG grfIcetActive;    // Bitarray tracks which encodings are still active candidates.
    ICET icetSeq;
    int i, nCount, nCountCurr;
    DWORD dwValFlags;
    BOOL fIsHigh;
    int cchHigh = 0;
    int cchHighPairs = 0;
    int cchTotal = 0;
    BOOL fLastHigh = fFalse;
    
#if JPDEBUG3
    ULONG grfIcetNoCommonChars;
#endif

#if JPDEBUG
    printf("flags: %d\n", dwFlags);
#endif
    
    // Initialize parsers
    //
    dwValFlags = grfCountCommonChars;
    if (dwFlags & grfDetectUseCharMapping)
        dwValFlags |= grfValidateCharMapping;
    ValidateInitAll(dwValFlags);
    
    // Initialize locals -- be optimistic
    //
    cceRet = cceSuccess;
    fGuess = fFalse;
    grfIcetActive = grfAllButIso2022;
    cIcetActive = cAllButIso2022;
    
#if JPDEBUG3
    grfIcetNoCommonChars = grfAllButIso2022;
#endif
    
    while (fTrue)
        {
        nToken = _NGetNextUch(pstmIn, &uch, &fIsHigh);
        if (_FStopToken(nToken))
            break;
            
        // Update (admittedly dumb) statistics -- really counts high
        // ascii characters in runs (not really pairs).  But threshold
        // constants (defined, above) were determined by calculating
        // exactly these numbers for ~25 files, so it should be ok (?).
        //
        ++cchTotal;
        if (fIsHigh)
            {
            ++cchHigh;
            if (fLastHigh)
                ++cchHighPairs;
            }
        fLastHigh = fIsHigh;
            
        for (i = 0; i < icetCount; i++)
            {
            if (!(grfIcetActive & _mpicetgrf[i]) || (NValidateUch((ICET)i, uch, fFalse) != 0))
                continue;
                
            grfIcetActive &= ~_mpicetgrf[i];
            --cIcetActive;
#if JPDEBUG
            printf("Log:  Lost %s at offset 0x%.4x (%d), char 0x%.2x\n", rgszIcetNames[i], (cchTotal-1), (cchTotal-1), uch);
#endif
            }
            
#if JPDEBUG3
        for (i = 0; i < icetCount; i++)
            {
            if (!(grfIcetActive & _mpicetgrf[i]) || !(grfIcetNoCommonChars & _mpicetgrf[i]))
                continue;
                
            if (!FValidateCharCount(i, &nCount) || (nCount == 0))
                continue;
                
            grfIcetNoCommonChars &= ~_mpicetgrf[i];
            printf("Log:  Found first common seq for %s at offset 0x%.4x (%d)\n", rgszIcetNames[i], (cchTotal-1), (cchTotal-1));
            }
#endif
            
        if ((cIcetActive == 0) || ((cIcetActive == 1) && (cchTotal > cchMinSample)))
            break;
        }
        
    // Figure out why we exited the loop.
    //
    if (nToken == err)
        {
        cceRet = cceRead;
        goto _LRet;
        }
        
    // Process escapes separately.  Interpret the escape sequence
    // to determine for real which ISO7 flavor we have found.
    //
    if ((nToken == esc) || (nToken == so) || (nToken == si))
        {
        LARGE_INTEGER   li;
        HRESULT hr;

        LISet32(li, -1 );
        hr = pstmIn->Seek(li,STREAM_SEEK_CUR, NULL);

//      if (!pfnUnget(uch, lpvPrivate))
//          {
//          cceRet = cceUnget;
//          goto _LRet;
//          }
        cceRet = _CceReadEscSeq(pstmIn, nPrefCp, &icet, &fGuess);
#if JPDEBUG
        if (cceRet == cceSuccess)
            printf("Log:  Found encoding %s at offset 0x%.4x (%d)\n", rgszIcetNames[icet], cchTotal, cchTotal);
#endif
        // ISO is a special case -- no need to check statistics.
        //
        goto _LRet;
        }
        
#if JPDEBUG2
    printf("Counts:  %d total chars, %d high chars, %d high pairs\n", cchTotal, cchHigh, cchHighPairs); 
#endif
            
    // If the token was eof, and we're not ignoring eof, transition
    // the remaining active sets on eof.
    //
    if ((nToken == eof) && !(dwFlags & grfDetectIgnoreEof))
        {
        for (i = 0; i < icetCount; i++)
            {
            if (!(grfIcetActive & _mpicetgrf[i]) || (NValidateUch((ICET)i, 0, fTrue) != 0))
                continue;
#if JPDEBUG
            printf("Log:  Lost %s at EOF\n", rgszIcetNames[i]);
#endif
            grfIcetActive &= ~_mpicetgrf[i];
            --cIcetActive;
            }
        }
        
    Assert(cIcetActive >= 0);   // better *not* be less than 0

    // See how we've narrowed our field of choices and set the 
    // return status accordingly.
    //
    if (cIcetActive <= 0)
        {
#if JPDEBUG
        printf("Log:  Bailed out entirely at offset 0x%.4x (%d)\n", cchTotal, cchTotal);
#endif
        cceRet = cceUnknownInput;
        goto _LRet;
        }
    else if (cIcetActive == 1)
        {
        icet = _IcetFromIcetMask(grfIcetActive);
#if JPDEBUG
        printf("Log:  Found encoding %s at offset 0x%.4x (%d)\n", rgszIcetNames[icet], cchTotal, cchTotal);
#endif
        // If we matched an encoding type and also found matching 
        // common character runs, skip statistics (see comment,
        // below).
        //
        if (FValidateCharCount(icet, &nCount) && (nCount > 0))
            {
#if JPDEBUG3
            printf("Log:  %d common sequences for %s\n", nCount, rgszIcetNames[icet]);
#endif
            goto _LRet;
            }
        else
            {
            goto _LStats;
            }
        }
        
    // Did we learn anything from counting characters?
    //
    icetSeq = (ICET)-1;
    nCountCurr = 0;
    for (i = 0; i < icetCount; i++)
        {
        if (!(grfIcetActive & _mpicetgrf[i]) || !FValidateCharCount((ICET)i, &nCount))
            continue;
            
        if (nCount > nCountCurr)
            {
            icetSeq = (ICET)i;
            nCountCurr = nCount;
            }
            
#if JPDEBUG3
        printf("Log:  %d common sequences for %s\n", nCount, rgszIcetNames[i]);
#endif
        }
            
    // Any luck?  If so, return.  Don't bother checking statistics.
    // We just proved that we found at least one common run of 
    // characters in this input.  The odds against this for just a
    // plain ASCII file with some high characters seem pretty high.
    // Ignore the statistics and just return the encoding type we
    // found.
    //
    if (icetSeq != -1)
        {
        icet = icetSeq;
        goto _LRet;
        }
        
#if JPDEBUG
    printf("Log:  Active Icet Mask 0x%.8x, %d left\n", grfIcetActive, cIcetActive);
    printf("Log:  Icet's left -- ");
    for (i = 0; i < icetCount; i++)
        {
        if (grfIcetActive & _mpicetgrf[i])
            printf("%s, ", rgszIcetNames[i]);
        }
    printf("\n");
#endif

    // If caller did not want us to try to guess at the encoding
    // in the absence of definitive data, bail out.
    //
    if (!(dwFlags & grfDetectResolveAmbiguity))
        {
        cceRet = cceAmbiguousInput;
        goto _LRet;
        }
        
    // We're guessing -- note it.
    //
    fGuess = fTrue;
        
    // More than one active encoding.  Attempt to resolve ambiguity.
    //
    cceRet = _CceResolveAmbiguity(grfIcetActive, &icet, nPrefCp, efPref);
    if (cceRet != cceSuccess)
        return cceRet;
        
_LStats:
        
    // Adjust the return code based on the "statistics" we gathered,
    // above.
    //
    if (cchHigh > 0)
        {
        if ((cchTotal < cchMinSample) ||
            (((cchHigh * 100) / cchTotal) < nHighCharThreshold) ||
            (((cchHighPairs * 100) / cchHigh) < nHighPairThreshold))
            {
            cceRet = cceMayBeAscii;
            }
        }
    else
        {
        cceRet = cceMayBeAscii;     // no high-ascii characters?  definitely maybe!
        }

#if JPDEBUG2
    if (cchHigh > 0)
        {
        int nPercent1 = ((cchHigh * 100) / cchTotal);
        int nPercent2 = ((cchHighPairs * 100) / cchHigh);
        printf("Ratios -- high/total: %d%%, runs/high: %d%%\n", nPercent1, nPercent2);
        }
#endif
        
_LRet:

    // Set the return variables, if successful.
    //
    if ((cceRet == cceSuccess) || (cceRet == cceMayBeAscii))
        {
        *lpicet = icet;
        *lpfGuess = fGuess;
        }
        
#if JPDEBUG
        if (cceRet == cceSuccess)
            {
            printf("Log:  Returning %s, fGuess = %s\n", rgszIcetNames[icet], (fGuess ? "fTrue" : "fFalse"));
            }
        else if (cceRet == cceMayBeAscii)
            {
            printf("Log:  Returning %s, fGuess = %s, may-be-ASCII\n", rgszIcetNames[icet], (fGuess ? "fTrue" : "fFalse"));
            }
#endif
        
    return cceRet;
}


/* _ N  G E T  N E X T  U C H */
/*----------------------------------------------------------------------------
    %%Function: _NGetNextUch
    %%Contact: jpick

    Get the next character from the input stream.  Classify the character.
----------------------------------------------------------------------------*/
static int _NGetNextUch(IStream *pstmIn, unsigned char *c, BOOL *lpfIsHigh)
{
    ULONG rc;
    unsigned char uch;
    HRESULT hr;
          
    hr = pstmIn->Read(&uch, 1, &rc);
    
    if (rc == 0)
        return eof;
    else if (hr != S_OK )
        return err;
        
    *lpfIsHigh = (uch >= 0x80);
    *c = uch;
        
    switch (uch)
        {
        case chEsc:
            return esc;
        case chSo:
            return so;
        case chSi:
            return si;
        default:
            return xmn;
        }
}


// Masks for _CceResolveAmbiguity() -- only externally supported character
// sets are used in ambiguity resolution.  Don't include Euc-Tw here.
//
#define grfJapan            (ULONG) (grfShiftJis | grfEucJp)
#define grfChina            (ULONG) (grfEucCn | grfGbk)
#define grfKorea            (ULONG) (grfEucKr | grfWansung)
#define grfTaiwan           (ULONG) (grfBig5)
#define grfDbcs             (ULONG) (grfShiftJis | grfGbk | grfWansung | grfBig5)
#define grfEuc              (ULONG) (grfEucJp | grfEucKr | grfEucCn)


/* _ C E  F R O M  C E  M A S K */
/*----------------------------------------------------------------------------
    %%Function: _IcetFromIcetMask
    %%Contact: jpick
----------------------------------------------------------------------------*/
static ICET _IcetFromIcetMask(ULONG ulMask)
{
    switch (ulMask)
    {
    case grfEucCn:
        return icetEucCn;
    case grfEucJp:
        return icetEucJp;
    case grfEucKr:
        return icetEucKr;
    case grfEucTw:
        return icetEucTw;
    case grfIso2022Cn:
        return icetIso2022Cn;
    case grfIso2022Jp:
        return icetIso2022Jp;
    case grfIso2022Kr:
        return icetIso2022Kr;
    case grfIso2022Tw:
        return icetIso2022Tw;
    case grfBig5:
        return icetBig5;
    case grfGbk:
        return icetGbk;
    case grfHz:
        return icetHz;
    case grfShiftJis:
        return icetShiftJis;
    case grfWansung:
        return icetWansung;
    case grfUtf7:
        return icetUtf7;
    case grfUtf8:
        return icetUtf8;
    default:
        break;
    }
    
    // Should never get here ...
    //
//  NotReached();
    
    // Can't return a bogus value, here.
    //
    return icetShiftJis;
}

/* _ C E  D E F A U L T  F R O M  C E  M A S K */
/*----------------------------------------------------------------------------
    %%Function: _IcetDefaultFromIcetMask
    %%Contact: jpick
----------------------------------------------------------------------------*/
static ICET _IcetDefaultFromIcetMask(ULONG ulMask)
{
    // Priorities -- DBCS, EUC, Japan, Taiwan, China and Korea (???).
    //
    if (ulMask & grfDbcs)
        {
        if (ulMask & grfJapan)
            return icetShiftJis;
        if (ulMask & grfChina)
            return icetGbk;
        if (ulMask & grfTaiwan)
            return icetBig5;
        if (ulMask & grfKorea)
            return icetWansung;
        }
    else // EUC
        {
        if (ulMask & grfJapan)
            return icetEucJp;
        if (ulMask & grfChina)
            return icetEucCn;
        if (ulMask & grfKorea)
            return icetEucKr;           // may be able to return icetWansung, here
        }
        
    // (Assert);
    return icetShiftJis;  // ???
}

/* _ U L  C E  M A S K  F R O M  C P  E T P */
/*----------------------------------------------------------------------------
    %%Function: _UlIcetMaskFromCpEf
    %%Contact: jpick
----------------------------------------------------------------------------*/
static ULONG _UlIcetMaskFromCpEf(int nCp, EFam ef)
{
    ULONG grf = grfAll;
    
    switch (nCp)
    {
    case nCpJapan:
        grf &= grfJapan;
        break;
    case nCpChina:
        grf &= grfChina;
        break;
    case nCpKorea:
        grf &= grfKorea;
        break;
    case nCpTaiwan:
        grf &= grfTaiwan;
        break;
    default:
        break;
    }
    
    switch (ef)
    {
    case efDbcs:
        grf &= grfDbcs;
        break;
    case efEuc:
        grf &= grfEuc;
        break;
    default:
        break;
    }
    return grf;
}


/* _ C C E  R E S O L V E  A M B I G U I T Y */
/*----------------------------------------------------------------------------
    %%Function: _CceResolveAmbiguity
    %%Contact: jpick

    Attempt to resolve ambiguous input encoding based on user
    preferences, if set, and system code page.  grfIcet contains a
    bitmask representing the encodings that are still possible after
    examining the input sample.
----------------------------------------------------------------------------*/
static CCE _CceResolveAmbiguity(ULONG grfIcet, ICET *lpicet, int nPrefCp, EFam efPref)
{
    ULONG grfIcetOrig = grfIcet;
    ULONG grfPref;
    ULONG grfSys;
    ULONG grfResult;
    int cIcet;
    
    // Build "list" of encodings based on user-prefs.
    //
    grfPref = _UlIcetMaskFromCpEf(nPrefCp, efPref);
    
    // See if the user's preferences make any difference.
    //
    grfResult = grfIcet & grfPref;
    
    if (grfResult)
        {
        cIcet = _CBitsOnFromUlong(grfResult);
        if (cIcet == 1)
            {
            *lpicet = _IcetFromIcetMask(grfResult);
            return cceSuccess;
            }
        else
            grfIcet = grfResult;            // see comment, below
        }
        
    // Now look to the system code page for help.  Look at
    // the set of encodings as modified by the user
    // preferences (??? do we want to do this ???).
    //
    if (!FIsFeCp(g_uACP) || (grfIcetOrig & grfUtf8))
        goto _LDefault;
        
    // Build "list" of encodings based on system cp.
    //
    grfSys = _UlIcetMaskFromCpEf(g_uACP, (EFam) 0);
    
    // See if the system cp makes any difference.
    //
    grfResult = grfIcet & grfSys;
    
    if (grfResult)
        {
        cIcet = _CBitsOnFromUlong(grfResult);
        if (cIcet == 1)
            {
            *lpicet = _IcetFromIcetMask(grfResult);
            return cceSuccess;
            }
        }
            
_LDefault:

    // Special case -- pick UTF-8 if it's legal and the prefs
    // don't help us.
    //
    *lpicet =
        (grfIcetOrig & grfUtf8) ? icetUtf8 : _IcetDefaultFromIcetMask(grfIcet);
    return cceSuccess;
}


/* _ C C E  R E A D  E S C  S E Q */
/*----------------------------------------------------------------------------
    %%Function: _CceReadEscSeq
    %%Contact: jpick

    We've read (and put back) an escape character.  Call the ISO-2022
    escape sequence converter to have it map the escape sequence to the
    appropriate character set.  We may be looking at the escape sequence
    for ASCII, so be prepared to read ahead to the next one.
----------------------------------------------------------------------------*/
static CCE _CceReadEscSeq(
    IStream   *pstmIn,           // input stream
    int       nPrefCp,
    ICET     *lpicet,
    BOOL     *lpfGuess
)
{
    unsigned char uch;
    CCE cceRet;
    int nToken;
    BOOL fDummy;
    
    do
        {
        cceRet = CceReadEscSeq(pstmIn, lpicet); 
        
        if ((cceRet == cceSuccess) || (cceRet != cceMayBeAscii))
            break;
        
        while (fTrue)
            {
            nToken = _NGetNextUch(pstmIn, &uch, &fDummy);
            if (_FStopToken(nToken))
                break;
            }
            
        // Why did we stop?
        //
        if (nToken == err)
            {
            cceRet = cceRead;
            break;
            }
        else if (nToken == eof)
            {
            // Means this is legal ISO-2022 input, but we've seen nothing
            // but non-flavor-specific escape sequences (e.g., only ASCII
            // or shift sequences).  Choose the encoding type based on
            // preferences (only pick from those currently supported
            // externally).
            //
            switch (nPrefCp)
                {
                case nCpKorea:
                    *lpicet = icetIso2022Kr;
                    break;
                case nCpJapan:
                default:                        // Right ??? (gotta pick something ...)
                    *lpicet = icetIso2022Jp;
                    break;
                }
            *lpfGuess = fTrue;                  // not *really* guessing, but ... (???)
            cceRet = cceSuccess;
            break;
            }
            
        Assert((nToken == esc) || (nToken == so) || (nToken == si));
        {
        LARGE_INTEGER   li;
        HRESULT hr;

        LISet32(li, -1 );

        hr = pstmIn->Seek(li,STREAM_SEEK_CUR, NULL);
        }
        // Put it back for CceReadEscSeq() to process.
        //
//      if (!pfnUnget(uch, lpvPrivate))
//          {
//          cceRet = cceUnget;
//          break;
//          }
            
        } while (fTrue);
    
    return cceRet;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\mlang\hzgbobj.h ===
#include "convbase.h"

class CInccHzGbIn : public CINetCodeConverter
{
private:
    BOOL (CInccHzGbIn::*m_pfnConv)(UCHAR tc);
    BOOL (CInccHzGbIn::*m_pfnCleanUp)();
    BOOL m_fGBMode;
    UCHAR m_tcLeadByte;
    UINT  m_nESCBytes;                     /* # bytes of ESC sequence */

public:
    CInccHzGbIn();
    CInccHzGbIn(UINT uCodePage, int nCodeSet);
    ~CInccHzGbIn() {}
    virtual HRESULT ConvertChar(UCHAR tc, int cchSrc=-1);
    virtual BOOL CleanUp();
    virtual int GetUnconvertBytes();
    virtual DWORD GetConvertMode();
    virtual void SetConvertMode(DWORD mode);

private:
    void Reset();
    BOOL ConvMain(UCHAR tc);
    BOOL CleanUpMain();
    BOOL ConvTilde(UCHAR tc);
    BOOL CleanUpTilde();
    BOOL ConvDoubleByte(UCHAR tc);
    BOOL CleanUpDoubleByte();
};

class CInccHzGbOut : public CINetCodeConverter
{
private:
    BOOL    m_fDoubleByte;
    UCHAR   m_tcLeadByte;
    BOOL    m_fGBMode;
    DWORD   _dwFlag;
    WCHAR   *_lpFallBack;

public:
    CInccHzGbOut(UINT uCodePage, int nCodeSet, DWORD dwFlag, WCHAR *lpFallBack);
    ~CInccHzGbOut() {}
    virtual HRESULT ConvertChar(UCHAR tc, int cchSrc=-1);
    virtual BOOL CleanUp();
    virtual int GetUnconvertBytes();
    virtual DWORD GetConvertMode();
    virtual void SetConvertMode(DWORD mode);
private:
    void Reset();
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\mlang\font.h ===
/********************************************************************
 *
 *  Header Name : font.h 
 *  Font structures defines for MLang fontlink2
 *
 ********************************************************************/

#ifndef __FONT_H__
#define __FONT_H__

#define  TWO_BYTE_NUM(p)   (((p[0])<<8)|(p[1]))
#define  FOUR_BYTE_NUM(p)  (((p[0])<<24)|((p[1])<<16)|((p[2])<<8)|(p[3]))
#define  OFFSET_OS2CPRANGE sizeof(SHORT) * 24 + sizeof(PANOSE) + sizeof(ULONG) * 4 + sizeof(CHAR) * 4 
#define  MAX_FONT_FILE_NAME     48
#define  FONT_TABLE_INIT_SIZE   100
#define  FONT_DATA_FILE_NAME    TEXT("mlfcache.dat")
#define  FONT_DATA_SIGNATURE    "mlang font data"
#define  REGFONTKEYNT           TEXT("Software\\Microsoft\\Windows NT\\CurrentVersion\\Fonts")
#define  REGFONTKEY95           TEXT("Software\\Microsoft\\Windows\\CurrentVersion\\Fonts")
#define  FONT_FOLDER            TEXT("fonts")
#define  MAX_FONT_INDEX         30
#define  FONTDATATABLENUM       2

// Font database file format:
// Table header
// Table Entry [Table Entry]
// Table data [Table data]
typedef struct tagFontDataHeader{
    char    FileSig[16];
    DWORD   dwVersion;
    DWORD   dwCheckSum;
    WORD    nTable;
} FONTDATAHEADER;

typedef struct tagFontTable{
    char    szName[4];
    DWORD   dwOffset;
    DWORD   dwSize;
} FONTDATATABLE;

typedef struct {
  char  TTCTag    [4];
  BYTE  Version   [4];
  BYTE  DirCount  [4];
  BYTE  OffsetTTF1[4];
} TTC_HEAD;

typedef struct {
  BYTE  Version      [4];
  BYTE  NumTables    [2];
  BYTE  SearchRange  [2];
  BYTE  EntrySelector[2];
  BYTE  RangeShift   [2];
} TTF_HEAD;

typedef struct {
  char  Tag     [4];
  BYTE  CheckSum[4];
  BYTE  Offset  [4];
  BYTE  Length  [4];
} TABLE_DIR;

typedef struct {
  BYTE  Format[2];
  BYTE  NumRec[2];
  BYTE  Offset[2];
} NAME_TABLE;

#define FONT_SUBFAMILY_NAME 2
#define FONT_NAME           4
#define MICROSOFT_PLATFORM  3
#define UNICODE_INDEXING    1
#define CMAP_FORMAT_FOUR    4
#define APPLE_UNICODE_PLATFORM  0
#define APPLE_UNICODE_INDEXING  3
#define UNICODE_SYMBOL_INDEXING 0


typedef struct {
  BYTE  Platform[2];
  BYTE  Encoding[2];  // = 1 if string is in Unicode
  BYTE  LangID  [2];
  BYTE  NameID  [2];  // = 2 for font subfamily name
  BYTE  Length  [2];
  BYTE  Offset  [2];
} NAME_RECORD;

typedef struct {
  BYTE  Version  [2];
  BYTE  NumTables[2];
} CMAP_HEAD;

typedef struct {
  BYTE  Platform[2];  // = 3 if Microsoft
  BYTE  Encoding[2];  // = 1 if string is in Unicode
  BYTE  Offset  [4];
} CMAP_TABLE;

typedef struct {
  BYTE  Platform[2];  // = 3 if Microsoft
  BYTE  Encoding[2];  // = 1 if string is in Unicode
  BYTE  Offset  [4];
} OS2_TABLE;

typedef struct {
  BYTE  Format       [2];  // must be 4
  BYTE  Length       [2];
  BYTE  Version      [2];
  BYTE  SegCountX2   [2];
  BYTE  SeachgRange  [2];
  BYTE  EntrySelector[2];
  BYTE  RangeShift   [2];
} CMAP_FORMAT;

// font table
typedef struct tagFontInfo{
    TCHAR   szFaceName[LF_FACESIZE];
    TCHAR   szFileName[MAX_FONT_FILE_NAME];
    DWORD   dwCodePages[2];
    LOGFONT lf;
    DWORD   dwUniSubRanges[4];
    SCRIPT_IDS scripts;
} FONTINFO;

typedef struct tagSCRIPT
{
    SCRIPT_ID   sid;
    UINT        uidDescription;     // script name (localization needed)
    UINT        uiCodePage;         // can be NULL to indicate no Windows code pages 
    WCHAR       wcCandidate;        // primary candiate for the script
    UINT        uidFixedWidthFont;  // default fixed width font (localization needed)
    UINT        uidProportionalFont;// default proportional font (localization needed)
    DWORD       dwFlags;            // script level flag
} SCRIPT;

//Unicode range table
typedef struct tagURangeFont{
    WCHAR wcFrom;
    WCHAR wcTo;
    int   nFonts;
    int   *pFontIndex;
} URANGEFONT;

extern UINT     g_cScript;

extern const    SCRIPT ScriptTable[];

//Script 


#endif  // __FONT_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\mlang\hzgbobj.cpp ===
// ============================================================================
// Internet Character Set Conversion: Input from HZ-GB-2312
// ============================================================================

#include "private.h"
#include "fechrcnv.h"
#include "hzgbobj.h"
#include "codepage.h"

/******************************************************************************
**************************   C O N S T R U C T O R   **************************
******************************************************************************/

CInccHzGbIn::CInccHzGbIn(UINT uCodePage, int nCodeSet) : CINetCodeConverter(uCodePage, nCodeSet)
{
    Reset();    // initialization
    return ;
}

/******************************************************************************
*******************************   R E S E T   *********************************
******************************************************************************/

void CInccHzGbIn::Reset()
{
    m_pfnConv = ConvMain;
    m_pfnCleanUp = CleanUpMain;
    m_fGBMode = FALSE;
    m_tcLeadByte = 0 ;
    m_nESCBytes = 0 ;  
    return ;
}

/******************************************************************************
*************************   C O N V E R T   C H A R   *************************
******************************************************************************/

HRESULT CInccHzGbIn::ConvertChar(UCHAR tc, int cchSrc)
{
    BOOL fDone = (this->*m_pfnConv)(tc);
    if (fDone)
        return S_OK;
    else
        return E_FAIL;
}

/******************************************************************************
*****************************   C L E A N   U P   *****************************
******************************************************************************/

BOOL CInccHzGbIn::CleanUp()
{
    return (this->*m_pfnCleanUp)();
}

/******************************************************************************
****************************   C O N V   M A I N   ****************************
******************************************************************************/

BOOL CInccHzGbIn::ConvMain(UCHAR tc)
{
    BOOL fDone = TRUE;

    if (!m_fGBMode) {
        if (tc == '~') {
            m_pfnConv = ConvTilde;
            m_pfnCleanUp = CleanUpTilde;
            m_nESCBytes = 1 ;  
        } else {
            fDone = Output(tc);
        }
    } else {
        if (tc >= 0x20 && tc <= 0x7e) {
            m_pfnConv = ConvDoubleByte;
            m_pfnCleanUp = CleanUpDoubleByte;
            m_tcLeadByte = tc;
        } else {
            fDone = Output(tc);
        }
    }
    return fDone;
}

/******************************************************************************
************************   C L E A N   U P   M A I N   ************************
******************************************************************************/

BOOL CInccHzGbIn::CleanUpMain()
{
    return TRUE;
}

/******************************************************************************
***************************   C O N V   T I L D E   ***************************
******************************************************************************/

BOOL CInccHzGbIn::ConvTilde(UCHAR tc)
{
    m_pfnConv = ConvMain;
    m_pfnCleanUp = CleanUpMain;

    m_nESCBytes = 0 ;  

    switch (tc) {
    case '~':
        return Output('~');

    case '{':
        m_fGBMode = TRUE;
        return TRUE;

    case '\n':
        return TRUE; // Just eat it

    default:
        (void)Output('~');
        if (SUCCEEDED(ConvertChar(tc)))
            return TRUE;
        else
            return FALSE;
    }
}

/******************************************************************************
***********************   C L E A N   U P   T I L D E   ***********************
******************************************************************************/

BOOL CInccHzGbIn::CleanUpTilde()
{
    m_pfnConv = ConvMain;
    m_pfnCleanUp = CleanUpMain;

    return Output('~');
}

/******************************************************************************
*********************   C O N V   D O U B L E   B Y T E   *********************
******************************************************************************/

BOOL CInccHzGbIn::ConvDoubleByte(UCHAR tc)
{
    BOOL fRet ;
    m_pfnConv = ConvMain;
    m_pfnCleanUp = CleanUpMain;

    if (m_tcLeadByte >= 0x21 && m_tcLeadByte <= 0x77 && tc >= 0x21 && tc <= 0x7e) { // Check if GB char
        (void)Output(m_tcLeadByte | 0x80);
        fRet = Output(tc | 0x80);
    } else if (m_tcLeadByte == '~' && tc == '}') { // 0x7e7d
        m_fGBMode = FALSE;
        fRet = TRUE;
    } else if (m_tcLeadByte >= 0x78 && m_tcLeadByte <= 0x7d && tc >= 0x21 && tc <= 0x7e) { // Check if non standard extended code
        (void)Output((UCHAR)0xa1); // Output blank box symbol
        fRet = Output((UCHAR)0xf5);
    } else if (m_tcLeadByte == '~') {
        (void)Output('~'); // Output blank box symbol
        fRet = Output(tc);
    } else if (m_tcLeadByte == ' ') {
        fRet = Output(tc);
    } else if (tc == ' ') {
        (void)Output((UCHAR)0xa1); // Output space symbol
        fRet = Output((UCHAR)0xa1);
    } else {
        (void)Output(m_tcLeadByte);
        fRet = Output(tc);
    }
    m_tcLeadByte = 0 ;
    return fRet ;
}

/******************************************************************************
*****************   C L E A N   U P   D O U B L E   B Y T E   *****************
******************************************************************************/

BOOL CInccHzGbIn::CleanUpDoubleByte()
{
    m_pfnConv = ConvMain;
    m_pfnCleanUp = CleanUpMain;

    return Output(m_tcLeadByte);
}

int CInccHzGbIn::GetUnconvertBytes()
{
    if (m_tcLeadByte)
        return 1;
    else if ( m_nESCBytes )
        return 1;
    else
        return 0;
}

DWORD CInccHzGbIn::GetConvertMode()
{
    return ( m_fGBMode ? 1 : 0 ) ;
}

void CInccHzGbIn::SetConvertMode(DWORD mode)
{
    Reset();    // initialization
    if ( mode & 0x01 )
        m_fGBMode = TRUE ;
    else
        m_fGBMode = FALSE ;

    return ;
}

// ============================================================================
// Internet Character Set Conversion: Output to HZ-GB-2312
// ============================================================================

/******************************************************************************
**************************   C O N S T R U C T O R   **************************
******************************************************************************/

CInccHzGbOut::CInccHzGbOut(UINT uCodePage, int nCodeSet, DWORD dwFlag, WCHAR * lpFallBack) : CINetCodeConverter(uCodePage, nCodeSet)
{
    Reset();    // initialization
    _dwFlag = dwFlag;
    _lpFallBack = lpFallBack;
    return ;
}

/******************************************************************************
*******************************   R E S E T   *********************************
******************************************************************************/
void CInccHzGbOut::Reset()
{
    m_fDoubleByte = FALSE;
    m_fGBMode = FALSE;
    m_tcLeadByte = 0 ;
    return ;
}

/******************************************************************************
*************************   C O N V E R T   C H A R   *************************
******************************************************************************/

HRESULT CInccHzGbOut::ConvertChar(UCHAR tc, int cchSrc)
{
    BOOL fDone = TRUE;
    HRESULT hr = S_OK;


    if (!m_fDoubleByte) 
    {
        //
        // We're not using IsDBCSLeadByteEx() due to perf. concern
        // We should assert that our hard code table match IsDBCSLeadByteEx(), 
        // But, MLang ships with down level platforms and assert won't be valid if there is a range change
        //
        if (IS_CHS_LEADBYTE(tc)) 
        {
            m_fDoubleByte = TRUE;
            m_tcLeadByte = tc;
        }
        else 
        {
            if (m_fGBMode) 
            {
                Output('~');
                fDone = Output('}');
                m_fGBMode = FALSE;
            }
            // tilde should be encoded as two tildes
            if (tc == '~') 
                Output('~');
            fDone = Output(tc);
        }
    } 
    else 
    {
        m_fDoubleByte = FALSE;
// a-ehuang: Bug# 31726, send all out of range code to convert to NCR
//           RFC 1843 => valid HZ code range: leading byte 0x21 - 0x77, 2nd byte 0x21 - 0x7e
        if ( (m_tcLeadByte < 0xa1 || m_tcLeadByte > 0xf7) || (tc < 0xa1 || tc > 0xfe) )
// end-31726
        {
            UCHAR szDefaultChar[3] = {0x3f}; // possible DBCS + null    

            if (_lpFallBack && (_dwFlag & MLCONVCHARF_USEDEFCHAR))
            {
                // only take SBCS, no DBCS character
                if ( 1 != WideCharToMultiByte(CP_CHN_GB, 0,
                               (LPCWSTR)_lpFallBack, 1,
                               (LPSTR)szDefaultChar, ARRAYSIZE(szDefaultChar), NULL, NULL ))
                    szDefaultChar[0] = 0x3f;
            }

            // End Escape sequence for NCR entity output
            if (m_fGBMode)
            {
                Output('~');
                Output('}');
                m_fGBMode = FALSE;
            }

            if (_dwFlag & (MLCONVCHARF_NCR_ENTITIZE|MLCONVCHARF_NAME_ENTITIZE))
            {
                char    szChar[2];
                char    szDstStr[10];
                WCHAR   szwChar[2];
                int     cCount;

                szChar[0] = m_tcLeadByte;
                szChar[1] = tc;
                
                if (MultiByteToWideChar(CP_CHN_GB, 0, szChar, 2, szwChar, ARRAYSIZE(szwChar)))
                {

                    // Output NCR entity
                    Output('&');
                    Output('#');
                    _ultoa((unsigned long)szwChar[0], (char*)szDstStr, 10);
                    cCount = lstrlenA(szDstStr);
                    for (int i=0; i< cCount; i++)
                    {
                        Output(szDstStr[i]);
                    }
                    fDone = Output(';');
                }
                else
                {
                    fDone = Output(szDefaultChar[0]);
                    hr = S_FALSE;
                }
            }
            else
            {
                fDone = Output(szDefaultChar[0]);
                hr = S_FALSE;
            }
        }
        else
        {
            if (!m_fGBMode) 
            {
                Output('~');
                Output('{');
                m_fGBMode = TRUE;
            }

            Output(m_tcLeadByte & 0x7f);
            fDone = Output(tc & 0x7f);
        }
        m_tcLeadByte = 0 ;
    }

    if (!fDone)
        hr = E_FAIL;

    return hr;
}

/******************************************************************************
*****************************   C L E A N   U P   *****************************
******************************************************************************/

BOOL CInccHzGbOut::CleanUp()
{
    if (!m_fGBMode) {
        return TRUE;
    } else {
        m_fGBMode = FALSE ;
        (void)Output('~');
        return Output('}');
    }
}

int CInccHzGbOut::GetUnconvertBytes()
{
    if (m_tcLeadByte)
        return 1;
    else
        return 0;
}

DWORD CInccHzGbOut::GetConvertMode()
{
    return 0 ;
}

void CInccHzGbOut::SetConvertMode(DWORD mode)
{
    Reset();    // initialization
    return ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\mlang\fechrcnv.h ===
#ifndef _FECHRCNV_H_
#define _FECHRCNV_H_

#ifdef __cplusplus
extern "C" {
#endif 

// Code Page
#define CP_JAPAN                932
#define CP_PRC                  936
#define CP_KOREA                949
#define CP_TAIWAN               950

// Code Definition
#define ESC                     0x1b
#define SO                      0x0e
#define SI                      0x0f
#define ISO2022_IN_CHAR         '$'
#define ISO2022_IN_JP_CHAR1     'B'
#define ISO2022_IN_JP_CHAR2     '@'
#define ISO2022_IN_JP_CHAR3_1   '('
#define ISO2022_IN_JP_CHAR3_2   'D'
#define ISO2022_IN_KR_CHAR_1    ')'
#define ISO2022_IN_KR_CHAR_2    'C'
#define ISO2022_OUT_CHAR        '('
#define ISO2022_OUT_JP_CHAR1    'B'
#define ISO2022_OUT_JP_CHAR2    'J'
#define ISO2022_OUT_JP_CHAR3    'I' /* esc ( I - Kana mode */
#define ISO2022_OUT_JP_CHAR4    'H' /* treated as ESC ( J */

// Minimum length to determine if the string is EUC
#define MIN_JPN_DETECTLEN      48

typedef LPVOID HCINS;
typedef HCINS FAR* LPHCINS;

#ifdef __cplusplus
}
#endif 

#endif  // _FECHRCNV_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\mlang\ichrcnv.h ===
#ifndef ICHRCNV_H_
#define ICHRCNV_H_

#define MAXOVERFLOWCHARS 16


class CICharConverter
{
private:

    DWORD _dwWinCodePage;
    DWORD _dwInternetEncoding;
    DWORD _dwUTFEncoding;
    DWORD _dwUTFEncoding2;
    DWORD _dwUnicodeEncoding;
    DWORD _dwFlag;  
    WCHAR * _lpFallBack;

    BOOL  _bConvertDirt;

    LPSTR _lpUnicodeStr;
    LPSTR _lpInterm1Str;
    LPSTR _lpInterm2Str;

    HCINS _hcins;
    int   _hcins_dst;
    int   _cvt_count;


public:
    DWORD _dwConvertType;
    LPSTR _lpDstStr;
    LPSTR _lpSrcStr;
    int _nSrcSize;

    CICharConverter();
    CICharConverter(DWORD dwFlag, WCHAR *lpFallBack);
    CICharConverter(DWORD dwSrcEncoding, DWORD dwDstEncoding);
    ~CICharConverter();
    HRESULT ConvertSetup(DWORD * pdwSrcEncoding, DWORD dwDstEncoding);
    HRESULT DoCodeConvert(LPDWORD lpdwMode, LPCSTR lpSrcStr, LPINT lpnSrcSize,
         LPSTR lpDstStr, LPINT lpnDstSize, DWORD dwFlag, WCHAR *lpFallBack);
    BOOL ConvertCleanUp();

private:
    HRESULT ConvertUUWI(LPDWORD lpdwMode, LPCSTR lpSrcStr, LPINT lpnSrcSize,
        LPSTR lpDstStr, LPINT lpnDstSize, DWORD dwFlag, WCHAR *lpFallBack);
    HRESULT ConvertIWUU(LPDWORD lpdwMode, LPCSTR lpSrcStr, LPINT lpnSrcSize,
        LPSTR lpDstStr, LPINT lpnDstSize, DWORD dwFlag, WCHAR *lpFallBack);
    HRESULT UnicodeToMultiByteEncoding(DWORD dwDstEncoding, LPCSTR lpSrcStr, LPINT lpnSrcSize,
        LPSTR lpDstStr, LPINT lpnDstSize, DWORD dwFlag, WCHAR *lpFallBack);
    HRESULT UTF78ToUnicode(LPDWORD lpdwMode, LPCSTR lpSrcStr, LPINT lpnSrcSize,
        LPSTR lpDstStr, LPINT lpnDstSize);
    HRESULT UnicodeToUTF78(LPDWORD lpdwMode, LPCSTR lpSrcStr, LPINT lpnSrcSize,
        LPSTR lpDstStr, LPINT lpnDstSize);
    HRESULT UnicodeToWindowsCodePage(LPCSTR lpSrcStr, LPINT lpnSrcSize,
        LPSTR lpDstStr, LPINT lpnDstSize, DWORD dwFlag, WCHAR *lpFallBack);
    HRESULT UnicodeToInternetEncoding(LPCSTR lpSrcStr, LPINT lpnSrcSize,
        LPSTR lpDstStr, LPINT lpnDstSize, DWORD dwFlag, WCHAR *lpFallBack);
    HRESULT WindowsCodePageToUnicode(LPCSTR lpSrcStr, LPINT lpnSrcSize,
        LPSTR lpDstStr, LPINT lpnDstSize);
    HRESULT InternetEncodingToUnicode(LPCSTR lpSrcStr, LPINT lpnSrcSize,
        LPSTR lpDstStr, LPINT lpnDstSize);
    HRESULT WindowsCodePageToInternetEncoding(LPDWORD lpdwMode, LPCSTR lpSrcStr, LPINT lpnSrcSize,
        LPSTR lpDstStr, LPINT lpnDstSize, DWORD dwFlag, WCHAR *lpFallBack);
    HRESULT InternetEncodingToWindowsCodePage(LPDWORD lpdwMode, LPCSTR lpSrcStr, LPINT lpnSrcSize,
        LPSTR lpDstStr, LPINT lpnDstSize, DWORD dwFlag, WCHAR *lpFallBack);
    HRESULT WindowsCodePageToInternetEncodingWrap(LPCSTR lpSrcStr, LPINT lpnSrcSize,
        LPSTR lpDstStr, LPINT lpnDstSize, DWORD dwFlag, WCHAR *lpFallBack);
    HRESULT InternetEncodingToWindowsCodePageWrap(LPCSTR lpSrcStr, LPINT lpnSrcSize,
        LPSTR lpDstStr, LPINT lpnDstSize, DWORD dwFlag, WCHAR *lpFallBack);

    HRESULT CreateINetString(BOOL fInbound, UINT uCodePage, int nCodeSet);
    HRESULT DoConvertINetString(LPDWORD lpdwMode, BOOL fInbound, UINT uCodePage, int nCodeSet,
      LPCSTR lpSrcStr, LPINT lpnSrcSize, LPSTR lpDestStr, int cchDest, LPINT lpnSize);

    HRESULT KSC5601ToEUCKR(LPCSTR lpSrcStr, LPINT lpnSrcSize, LPSTR lpDestStr, int cchDest, LPINT lpnSize);
protected:

};

HRESULT WINAPI _IStreamConvertINetString(CICharConverter * INetConvert, LPDWORD lpdwMode, DWORD dwSrcEncoding, DWORD dwDstEncoding, IStream *pstmIn, IStream *pstmOut, DWORD *pdwProperty);

#endif /* ICHRCNV_H_ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\mlang\init.cpp ===
#include "private.h"
#include "mlmain.h"
#include "mlstr.h"
#include "convobj.h"
#include "cpdetect.h"
#ifdef NEWMLSTR
#include "attrstrw.h"
#include "attrstra.h"
#include "attrloc.h"
#include "util.h"
#endif
#define DECL_CRTFREE
#include <crtfree.h>

#define _WINDLL
#include <atlimpl.cpp>

#include <shlwapi.h>    // for IsOS() flags

BEGIN_OBJECT_MAP(ObjectMap)
    OBJECT_ENTRY(CLSID_CMultiLanguage, CMultiLanguage)
    OBJECT_ENTRY(CLSID_CMLangString, CMLStr)
    OBJECT_ENTRY(CLSID_CMLangConvertCharset, CMLangConvertCharset)
#ifdef NEWMLSTR
    OBJECT_ENTRY(CLSID_CMLStrAttrWStr, CMLStrAttrWStr)
    OBJECT_ENTRY(CLSID_CMLStrAttrAStr, CMLStrAttrAStr)
    OBJECT_ENTRY(CLSID_CMLStrAttrLocale, CMLStrAttrLocale)
#endif
END_OBJECT_MAP()

//
//  Globals
//
HINSTANCE   g_hInst = NULL;
HINSTANCE   g_hUrlMon = NULL;
CRITICAL_SECTION g_cs;
CComModule _Module;
#ifdef NEWMLSTR
CMLAlloc* g_pMalloc;
#endif
BOOL g_bIsNT5;
BOOL g_bIsNT;
BOOL g_bIsWin98;
UINT g_uACP;
BOOL g_bUseSysUTF8;
//
//  Build Global Objects
//
void BuildGlobalObjects(void)
{
    DebugMsg(DM_TRACE, TEXT("BuildGlobalObjects called."));
    EnterCriticalSection(&g_cs);
    // Build CMimeDatabase Object
    if (NULL == g_pMimeDatabase)
        g_pMimeDatabase = new CMimeDatabase;
#ifdef NEWMLSTR
    if (NULL == g_pMalloc)
        g_pMalloc = new CMLAlloc;
#endif
    LeaveCriticalSection(&g_cs);
}

void FreeGlobalObjects(void)
{
    DebugMsg(DM_TRACE, TEXT("FreeGlobalObjects called."));
    // Free CMimeDatabase Object
    if (NULL != g_pMimeDatabase)
    {
        delete g_pMimeDatabase;
        g_pMimeDatabase = NULL;
    }
#ifdef NEWMLSTR
    if (NULL != g_pMalloc)
    {
        delete g_pMalloc;
        g_pMalloc = NULL;
    }
#endif

    // LCDETECT
    if ( NULL != g_pLCDetect )
    {
        delete (LCDetect *)g_pLCDetect;
        g_pLCDetect = NULL;
    }

    if (NULL != g_pCpMRU)
    {
        delete g_pCpMRU;
        g_pCpMRU = NULL;
    }

    if (g_pMimeDatabaseReg)
    {
        delete g_pMimeDatabaseReg;
        g_pMimeDatabaseReg = NULL;
    }

    CMLangFontLink_FreeGlobalObjects();
}

//
//  DLL part of the Object
//
extern "C" BOOL WINAPI DllMain(HMODULE hInstance, DWORD dwReason, LPVOID)
{
    BOOL fRet = TRUE;

    DebugMsg(DM_TRACE, TEXT("DllMain called. dwReason=0x%08x"), dwReason);
    switch (dwReason)
    {
        LPVOID lpv;

        case DLL_PROCESS_ATTACH:

            SHFusionInitializeFromModule(hInstance);    
            InitializeCriticalSection(&g_cs);
            g_hInst = (HINSTANCE)hInstance;
            DisableThreadLibraryCalls(g_hInst);
            
            _Module.Init(ObjectMap, g_hInst);
            // HACKHACK (reinerf) - because ATL2.1 bites the big one, we have to malloc some memory
            // here so that it will cause _Module.m_hHeap to be initialized. They do not init this
            // member variable in a thread safe manner, so we will alloc and free a small chunk of
            // memory right now to ensure that the heap is created only once.
            lpv = malloc(2 * sizeof(CHAR));
            if (lpv)
            {
                free(lpv);
            }

            g_bIsNT5 = staticIsOS(OS_WIN2000ORGREATER);
            if (g_bIsNT5)
            {
                char szTest[] = {'a'};
                if (MultiByteToWideChar(CP_UTF8,
                                        MB_ERR_INVALID_CHARS,
                                        szTest, sizeof(szTest),
                                        NULL, 0 ))
                {
                    g_bUseSysUTF8 = TRUE;
                }
            }
            g_bIsNT = staticIsOS(OS_NT);
            g_bIsWin98 = staticIsOS(OS_WIN98ORGREATER);
            g_uACP = GetACP();
            break;

        case DLL_PROCESS_DETACH:
            FreeGlobalObjects();
            _Module.Term();
            DeleteCriticalSection(&g_cs);
            if (g_hUrlMon)
            {
               FreeLibrary(g_hUrlMon);
            }
            SHFusionUninitialize();
            break;
    }
    return TRUE;
}

void DllAddRef(void)
{
    _Module.Lock();
}

void DllRelease(void)
{
    _Module.Unlock();
}

STDAPI DllGetClassObject(REFCLSID rclsid, REFIID riid, void **ppvObj)
{
    DebugMsg(DM_TRACE, TEXT("DllGetClassObject called."));
    if (NULL == g_pMimeDatabase)
        BuildGlobalObjects();

    //
    // See comments in util.cpp NeedToLoadMLangForOutlook()
    //
    if (NeedToLoadMLangForOutlook())
        LoadLibrary(TEXT("mlang.dll"));

    return _Module.GetClassObject(rclsid, riid, ppvObj);
}

STDAPI DllCanUnloadNow(void)
{
    return (_Module.GetLockCount() == 0) ? S_OK : S_FALSE;
}

//
//  Self Registration part
//
#if 0
HRESULT CallRegInstall(LPCSTR szSection)
{
    HRESULT hr = E_FAIL;
    HINSTANCE hinstAdvPack = LoadLibrary(TEXT("ADVPACK.DLL"));

    DebugMsg(DM_TRACE, TEXT("CallRegInstall called for %s."), szSection);
    if (NULL != hinstAdvPack)
    {
        REGINSTALL pfnri = (REGINSTALL)GetProcAddress(hinstAdvPack, achREGINSTALL);

        if (NULL != pfnri)
            hr = pfnri(g_hInst, szSection, NULL);
        FreeLibrary(hinstAdvPack);
    }
    return hr;
}
#endif

STDAPI DllRegisterServer(void)
{
    HRESULT hr;

    DebugMsg(DM_TRACE, TEXT("DllRegisterServer called."));

#if 0
    HINSTANCE hinstAdvPack = LoadLibrary(TEXT("ADVPACK.DLL"));
    OSVERSIONINFO osvi;
    BOOL fRunningOnNT;


    // Determine which version of NT or Windows we're running on
    osvi.dwOSVersionInfoSize = sizeof(osvi);
    GetVersionEx(&osvi);
    fRunningOnNT = (VER_PLATFORM_WIN32_NT == osvi.dwPlatformId);
    
    // Delete any old registration entries, then add the new ones.
    // Keep ADVPACK.DLL loaded across multiple calls to RegInstall.
    CallRegInstall("UnReg");
    hr = CallRegInstall(fRunningOnNT? "Reg.NT": "Reg");
    if (NULL != hinstAdvPack)
        FreeLibrary(hinstAdvPack);

    // Need to register TypeLib here ...
    // Get the full path of this module
    GetModuleFileName(g_hInst, szModule, ARRAYSIZE(szModule));

    // Register our TypeLib
    MultiByteToWideChar(CP_ACP, 0, szModule, -1, wszTemp, ARRAYSIZE(wszTemp));
    hr = LoadTypeLib(wszTemp, &pTypeLib);
    if (SUCCEEDED(hr))
    {
        hr = RegisterTypeLib(pTypeLib, wszTemp, NULL);
        pTypeLib->Release();
    }
#else
    hr = RegisterServerInfo();
// Legacy registry MIME DB code, keep it for backward compatiblility
    MimeDatabaseInfo();
#endif
    return hr;
}

STDAPI DllUnregisterServer(void)
{
    HRESULT hr;

    DebugMsg(DM_TRACE, TEXT("DllUnregisterServer called."));
#if 0
    hr = CallRegInstall("UnReg");
#else
    hr = UnregisterServerInfo();
#endif
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\mlang\ichrcnv.cpp ===
#include "private.h"
#include "detcbase.h"
#include "codepage.h"
#include "detcjpn.h"
#include "detckrn.h"
#include "fechrcnv.h"
#include "ichrcnv.h"
#include "cpdetect.h"
#include <tchar.h>


#define CONV_UU     12
#define CONV_UUW    10
#define CONV_UUWI   9
#define CONV_UW     6
#define CONV_UWI    5
#define CONV_WI     3

#define MAX_CHAR_SIZE   4

#define MAPUSERDEF(x) (((x) == 50000) ? 1252 : (x))
#define CONVERT_IS_VALIDCODEPAGE(x) (((x) == CP_USER_DEFINED) ? TRUE: IsValidCodePage(x))
#define CONV_CHK_NLS 0x00000001

struct ENCODINGINFO
{
    DWORD       dwEncoding;
    DWORD       dwCodePage;
    BYTE        bTypeUUIW;
    CP_STATE    nCP_State ;                 // whether this is a valid windows codepage  ?
    DWORD       dwFlags;                    // give us more flexibilities to handle different encodings differently
};

static WCHAR UniocdeSignature = { 0xFFFE } ;

/*
    Bit 4 (16) - Unicode <-> Internet Encoding
    Bit 3 (8) - UTF8, UTF7
    Bit 2 (4) - Unicode
    Bit 1 (2) - Windows CodePage
    Bit 0 (1) - Internet Encoding

     P.S. if bit 4 is set, it means it should convert between Unicode and Internet
     Encoding directly, no intermediate step - Windows CodePage
*/

// these codepages including Unicode need special convertor
static struct ENCODINGINFO aEncodingInfo[] =
{

    {  CP_JPN_SJ,            932,       0x02,   INVALID_CP,     0 }, // W-Japanese Shift JIS
    {  CP_CHN_GB,            936,       0x02,   INVALID_CP,     0 }, // W-Simplified Chinese
    {  CP_KOR_5601,          949,       0x02,   INVALID_CP,     0 }, // W-Krean Unified Hangul
    {  CP_TWN,               950,       0x02,   INVALID_CP,     0 }, // W-Traditional Chinese
    {  CP_UCS_2,               0,       0x04,   INVALID_CP,     0 }, // U-Unicode 
    {  CP_UCS_2_BE,            0,       0x04,   INVALID_CP,     0 }, // U-Unicode Big Endian
    {  CP_1252,             1252,       0x02,   INVALID_CP,     0 }, // W-Latin 1
    {  CP_20127,            1252,       0x11,   INVALID_CP,     CONV_CHK_NLS }, // US ASCII
    {  CP_ISO_8859_1,       1252,       0x11,   INVALID_CP,     CONV_CHK_NLS }, // I-ISO 8859-1 Latin 1 
    {  CP_ISO_8859_15,      1252,       0x11,   INVALID_CP,     CONV_CHK_NLS }, // I-ISO 8859-1 Latin 1 
    {  CP_AUTO,             1252,       0x01,   INVALID_CP,     0 }, // General auto detect 
    {  CP_ISO_2022_JP,       932,       0x01,   INVALID_CP,     0 }, // I-ISO 2022-JP No Halfwidth Katakana 
    {  CP_ISO_2022_JP_ESC,   932,       0x01,   INVALID_CP,     0 }, // I-ISO 2022-JP w/esc Halfwidth Katakana 
    {  CP_ISO_2022_JP_SIO,   932,       0x01,   INVALID_CP,     0 }, // I-ISO 2022-JP w/sio Halfwidth Katakana 
    {  CP_ISO_2022_KR,       949,       0x01,   INVALID_CP,     0 }, // I-ISO 2022-KR
    {  CP_ISO_2022_TW,       950,       0x01,   INVALID_CP,     0 }, // I-ISO 2022-TW
    {  CP_ISO_2022_CH,       936,       0x01,   INVALID_CP,     0 }, // I-ISO 2022-CH
    {  CP_JP_AUTO,           932,       0x01,   INVALID_CP,     0 }, // JP auto detect 
    {  CP_CHS_AUTO,          936,       0x01,   INVALID_CP,     0 }, // Simplified Chinese auto detect 
    {  CP_KR_AUTO,           949,       0x01,   INVALID_CP,     0 }, // KR auto detect 
    {  CP_CHT_AUTO,          950,       0x01,   INVALID_CP,     0 }, // Traditional Chinese auto detect 
    {  CP_CYRILLIC_AUTO,    1251,       0x01,   INVALID_CP,     0 }, // Cyrillic auto detect 
    {  CP_GREEK_AUTO,       1253,       0x01,   INVALID_CP,     0 }, // Greek auto detect 
    {  CP_ARABIC_AUTO,      1256,       0x01,   INVALID_CP,     0 }, // Arabic auto detect 
    {  CP_EUC_JP,            932,       0x01,   INVALID_CP,     0 }, // EUC Japanese 
    {  CP_EUC_CH,            936,       0x01,   INVALID_CP,     0 }, // EUC Chinese 
    {  CP_EUC_KR,            949,       0x01,   INVALID_CP,     0 }, // EUC Korean
    {  CP_EUC_TW,            950,       0x01,   INVALID_CP,     0 }, // EUC Taiwanese 
    {  CP_CHN_HZ,            936,       0x01,   INVALID_CP,     0 }, // Simplify Chinese HZ-GB 
    {  CP_UTF_7,               0,       0x08,   INVALID_CP,     0 }, // U-UTF7 
    {  CP_UTF_8,               0,       0x08,   INVALID_CP,     0 }, // U-UTF8 
};


// HTML name entity table for Latin-1 Supplement - from 0x00A0-0x00FF

#define NAME_ENTITY_OFFSET  0x00A0
#define NAME_ENTITY_MAX     0x00FF
#define NAME_ENTITY_ENTRY   96

static CHAR *g_lpstrNameEntity[NAME_ENTITY_ENTRY] =
{
    "&nbsp;",   // "&#160;" -- no-break space = non-breaking space,
    "&iexcl;",  // "&#161;" -- inverted exclamation mark, U+00A1 ISOnum -->
    "&cent;",   // "&#162;" -- cent sign, U+00A2 ISOnum -->
    "&pound;",  // "&#163;" -- pound sign, U+00A3 ISOnum -->
    "&curren;", // "&#164;" -- currency sign, U+00A4 ISOnum -->
    "&yen;",    // "&#165;" -- yen sign = yuan sign, U+00A5 ISOnum -->
    "&brvbar;", // "&#166;" -- broken bar = broken vertical bar,
    "&sect;",   // "&#167;" -- section sign, U+00A7 ISOnum -->
    "&uml;",    // "&#168;" -- diaeresis = spacing diaeresis,
    "&copy;",   // "&#169;" -- copyright sign, U+00A9 ISOnum -->
    "&ordf;",   // "&#170;" -- feminine ordinal indicator, U+00AA ISOnum -->
    "&laquo;",  // "&#171;" -- left-pointing double angle quotation mark
    "&not;",    // "&#172;" -- not sign = discretionary hyphen,
    "&shy;",    // "&#173;" -- soft hyphen = discretionary hyphen,
    "&reg;",    // "&#174;" -- registered sign = registered trade mark sign,
    "&macr;",   // "&#175;" -- macron = spacing macron = overline
    "&deg;",    // "&#176;" -- degree sign, U+00B0 ISOnum -->
    "&plusmn;", // "&#177;" -- plus-minus sign = plus-or-minus sign,
    "&sup2;",   // "&#178;" -- superscript two = superscript digit two
    "&sup3;",   // "&#179;" -- superscript three = superscript digit three
    "&acute;",  // "&#180;" -- acute accent = spacing acute,
    "&micro;",  // "&#181;" -- micro sign, U+00B5 ISOnum -->
    "&para;",   // "&#182;" -- pilcrow sign = paragraph sign,
    "&middot;", // "&#183;" -- middle dot = Georgian comma
    "&cedil;",  // "&#184;" -- cedilla = spacing cedilla, U+00B8 ISOdia -->
    "&sup1;",   // "&#185;" -- superscript one = superscript digit one,
    "&ordm;",   // "&#186;" -- masculine ordinal indicator,
    "&raquo;",  // "&#187;" -- right-pointing double angle quotation mark
    "&frac14;", // "&#188;" -- vulgar fraction one quarter
    "&frac12;", // "&#189;" -- vulgar fraction one half
    "&frac34;", // "&#190;" -- vulgar fraction three quarters
    "&iquest;", // "&#191;" -- inverted question mark
    "&Agrave;", // "&#192;" -- latin capital letter A with grave
    "&Aacute;", // "&#193;" -- latin capital letter A with acute,
    "&Acirc;",  // "&#194;" -- latin capital letter A with circumflex,
    "&Atilde;", // "&#195;" -- latin capital letter A with tilde,
    "&Auml;",   // "&#196;" -- latin capital letter A with diaeresis,
    "&Aring;",  // "&#197;" -- latin capital letter A with ring above
    "&AElig;",  // "&#198;" -- latin capital letter AE
    "&Ccedil;", // "&#199;" -- latin capital letter C with cedilla,
    "&Egrave;", // "&#200;" -- latin capital letter E with grave,
    "&Eacute;", // "&#201;" -- latin capital letter E with acute,
    "&Ecirc;",  // "&#202;" -- latin capital letter E with circumflex,
    "&Euml;",   // "&#203;" -- latin capital letter E with diaeresis,
    "&Igrave;", // "&#204;" -- latin capital letter I with grave,
    "&Iacute;", // "&#205;" -- latin capital letter I with acute,
    "&Icirc;",  // "&#206;" -- latin capital letter I with circumflex,
    "&Iuml;",   // "&#207;" -- latin capital letter I with diaeresis,
    "&ETH;",    // "&#208;" -- latin capital letter ETH, U+00D0 ISOlat1 -->
    "&Ntilde;", // "&#209;" -- latin capital letter N with tilde,
    "&Ograve;", // "&#210;" -- latin capital letter O with grave,
    "&Oacute;", // "&#211;" -- latin capital letter O with acute,
    "&Ocirc;",  // "&#212;" -- latin capital letter O with circumflex,
    "&Otilde;", // "&#213;" -- latin capital letter O with tilde,
    "&Ouml;",   // "&#214;" -- latin capital letter O with diaeresis,
    "&times;",  // "&#215;" -- multiplication sign, U+00D7 ISOnum -->
    "&Oslash;", // "&#216;" -- latin capital letter O with stroke
    "&Ugrave;", // "&#217;" -- latin capital letter U with grave,
    "&Uacute;", // "&#218;" -- latin capital letter U with acute,
    "&Ucirc;",  // "&#219;" -- latin capital letter U with circumflex,
    "&Uuml;",   // "&#220;" -- latin capital letter U with diaeresis,
    "&Yacute;", // "&#221;" -- latin capital letter Y with acute,
    "&THORN;",  // "&#222;" -- latin capital letter THORN,
    "&szlig;",  // "&#223;" -- latin small letter sharp s = ess-zed,
    "&agrave;", // "&#224;" -- latin small letter a with grave
    "&aacute;", // "&#225;" -- latin small letter a with acute,
    "&acirc;",  // "&#226;" -- latin small letter a with circumflex,
    "&atilde;", // "&#227;" -- latin small letter a with tilde,
    "&auml;",   // "&#228;" -- latin small letter a with diaeresis,
    "&aring;",  // "&#229;" -- latin small letter a with ring above
    "&aelig;",  // "&#230;" -- latin small letter ae
    "&ccedil;", // "&#231;" -- latin small letter c with cedilla,
    "&egrave;", // "&#232;" -- latin small letter e with grave,
    "&eacute;", // "&#233;" -- latin small letter e with acute,
    "&ecirc;",  // "&#234;" -- latin small letter e with circumflex,
    "&euml;",   // "&#235;" -- latin small letter e with diaeresis,
    "&igrave;", // "&#236;" -- latin small letter i with grave,
    "&iacute;", // "&#237;" -- latin small letter i with acute,
    "&icirc;",  // "&#238;" -- latin small letter i with circumflex,
    "&iuml;",   // "&#239;" -- latin small letter i with diaeresis,
    "&eth;",    // "&#240;" -- latin small letter eth, U+00F0 ISOlat1 -->
    "&ntilde;", // "&#241;" -- latin small letter n with tilde,
    "&ograve;", // "&#242;" -- latin small letter o with grave,
    "&oacute;", // "&#243;" -- latin small letter o with acute,
    "&ocirc;",  // "&#244;" -- latin small letter o with circumflex,
    "&otilde;", // "&#245;" -- latin small letter o with tilde,
    "&ouml;",   // "&#246;" -- latin small letter o with diaeresis,
    "&divide;", // "&#247;" -- division sign, U+00F7 ISOnum -->
    "&oslash;", // "&#248;" -- latin small letter o with stroke,
    "&ugrave;", // "&#249;" -- latin small letter u with grave,
    "&uacute;", // "&#250;" -- latin small letter u with acute,
    "&ucirc;",  // "&#251;" -- latin small letter u with circumflex,
    "&uuml;",   // "&#252;" -- latin small letter u with diaeresis,
    "&yacute;", // "&#253;" -- latin small letter y with acute,
    "&thorn;",  // "&#254;" -- latin small letter thorn with,
    "&yuml;",   // "&#255;" -- latin small letter y with diaeresis,
};


#ifdef MORE_NAME_ENTITY   // in case we decide to do more name entity latter
// Additional HTML 4.0 name entity table for CP 1252 extension character set
#define CP1252EXT_BASE  (UINT)0x0080
#define CP1252EXT_MAX   (UINT)0x009F
#define NONUNI          0xFFFF
#define UNDEFCHAR       "???????"
#define CP1252EXT_NCR_SIZE  7

struct NAME_ENTITY_EXT
{
    UWORD     uwUniCode;
    LPCTSTR   lpszNameEntity;
};

static struct NAME_ENTITY_EXT aNameEntityExt[] =
{
//      UniCode  NCR_Enty          Name_Enty        CP1252Ext  Comment
    {   0x20AC,  "&#8364;"  },  // "&euro;"    },  // &#128;  #EURO SIGN
//  {   NONUNI,  UNDEFCHAR  },  // "&;"        },  // &#129;  #UNDEFINED
    {   0x201A,  "&#8218;"  },  // "&sbquo;"   },  // &#130;  #SINGLE LOW-9 QUOTATION MARK
    {   0x0192,  "&#0402;"  },  // "&fnof;"    },  // &#131;  #LATIN SMALL LETTER F WITH HOOK
    {   0x201E,  "&#8222;"  },  // "&bdquo;"   },  // &#132;  #DOUBLE LOW-9 QUOTATION MARK
    {   0x2026,  "&#8230;"  },  // "&hellip;"  },  // &#133;  #HORIZONTAL ELLIPSIS
    {   0x2020,  "&#8224;"  },  // "&dagger;"  },  // &#134;  #DAGGER
    {   0x2021,  "&#8225;"  },  // "&Dagger;"  },  // &#135;  #DOUBLE DAGGER
    {   0x02C6,  "&#0710;"  },  // "&circ;"    },  // &#136;  #MODIFIER LETTER CIRCUMFLEX ACCENT
    {   0x2030,  "&#8240;"  },  // "&permil;"  },  // &#137;  #PER MILLE SIGN
    {   0x0160,  "&#0352;"  },  // "&Scaron;"  },  // &#138;  #LATIN CAPITAL LETTER S WITH CARON
    {   0x2039,  "&#8249;"  },  // "&lsaquo;"  },  // &#139;  #SINGLE LEFT-POINTING ANGLE QUOTATION MARK
    {   0x0152,  "&#0338;"  },  // "&OElig;"   },  // &#140;  #LATIN CAPITAL LIGATURE OE
//  {   NONUNI,  UNDEFCHAR  },  // "&;"        },  // &#141;  #UNDEFINED
    {   0x017D,  "&#0381;"  },  // "&;"        },  // &#142;  #LATIN CAPITAL LETTER Z WITH CARON, ***no name entity defined in HTML 4.0***
//  {   NONUNI,  UNDEFCHAR  },  // "&;"        },  // &#143;  #UNDEFINED
//  {   NONUNI,  UNDEFCHAR  },  // "&;"        },  // &#144;  #UNDEFINED
    {   0x2018,  "&#8216;"  },  // "&lsquo;"   },  // &#145;  #LEFT SINGLE QUOTATION MARK
    {   0x2019,  "&#8217;"  },  // "&rsquo;"   },  // &#146;  #RIGHT SINGLE QUOTATION MARK
    {   0x201C,  "&#8220;"  },  // "&ldquo;"   },  // &#147;  #LEFT DOUBLE QUOTATION MARK
    {   0x201D,  "&#8221;"  },  // "&rdquo;"   },  // &#148;  #RIGHT DOUBLE QUOTATION MARK
    {   0x2022,  "&#8226;"  },  // "&bull;"    },  // &#149;  #BULLET
    {   0x2013,  "&#8211;"  },  // "&ndash;"   },  // &#150;  #EN DASH
    {   0x2014,  "&#8212;"  },  // "&mdash;"   },  // &#151;  #EM DASH
    {   0x20DC,  "&#0732;"  },  // "&tilde;"   },  // &#152;  #SMALL TILDE
    {   0x2122,  "&#8482;"  },  // "&trade;"   },  // &#153;  #TRADE MARK SIGN
    {   0x0161,  "&#0353;"  },  // "&scaron;"  },  // &#154;  #LATIN SMALL LETTER S WITH CARON
    {   0x203A,  "&#8250;"  },  // "&rsaquo;"  },  // &#155;  #SINGLE RIGHT-POINTING ANGLE QUOTATION MARK
    {   0x0153,  "&#0339;"  },  // "&oelig;"   },  // &#156;  #LATIN SMALL LIGATURE OE
//  {   NONUNI,  UNDEFCHAR  },  // "&;"        },  // &#157;  #UNDEFINED
    {   0x017E,  "&#0382;"  },  // "&;"        },  // &#158;  #LATIN SMALL LETTER Z WITH CARON, ***no name entity defined in HTML 4.0***
    {   0x0178,  "&#0376;"  },  // "&Yuml;"    },  // &#159;  #LATIN CAPITAL LETTER Y WITH DIAERESIS
};
#endif


/******************************************************************************
*****************************   U T I L I T I E S   ***************************
******************************************************************************/
void DataByteSwap(LPSTR DataBuf, int len )
{
    int i ;
    UCHAR tmpData ;

    if ( len )
        for ( i = 0 ; i < len-1 ; i+=2 )
        {
            tmpData = DataBuf[i] ;
            DataBuf[i] = DataBuf[i+1] ;
            DataBuf[i+1] = tmpData ;
        }

    return ;
}

void CheckUnicodeDataType(DWORD dwDstEncoding, LPSTR DataBuf, int len )
{
    
    if ( DataBuf && len )
    {
        if ( dwDstEncoding == CP_UCS_2_BE )
            DataByteSwap(DataBuf,len);
    }
    return ;
}

void CheckASCIIEncoding(DWORD dwSrcEncoding, LPSTR DataBuf, int len )
{
    if (DataBuf && len)
    {
        if (dwSrcEncoding == CP_20127)
        {
            for (int i = 0; i<len; i++)
            {
                if (*DataBuf & 0x80)
                {
                    *DataBuf &= 0x7f;
                }
                DataBuf++;
            }
        }
    }
}

/******************************************************************************
******************   C O N V E R T   I N E T   S T R I N G   ******************
******************************************************************************/
HRESULT CICharConverter::UnicodeToMultiByteEncoding(DWORD dwDstEncoding, LPCSTR lpSrcStr, LPINT lpnSrcSize,
    LPSTR lpDstStr, LPINT lpnDstSize, DWORD dwFlag, WCHAR *lpFallBack)
{

    int nBuffSize, i ;
    BOOL UseDefChar = FALSE ;
    LPSTR lpDefFallBack = NULL ;
    UCHAR DefaultCharBuff[3]; // possible DBCS + null    
    HRESULT hr = E_FAIL;
    int _nDstSize = *lpnDstSize;    

    if ( _dwUnicodeEncoding == CP_UCS_2_BE && _cvt_count == 0 )
    {
       if ( _lpUnicodeStr = (LPSTR)LocalAlloc(LPTR, *lpnSrcSize ) )
       {
          MoveMemory(_lpUnicodeStr, lpSrcStr, *lpnSrcSize ) ;
          lpSrcStr = _lpUnicodeStr ;
       }
       else
       {
          hr = E_OUTOFMEMORY;
          goto EXIT;
       }
    }

    CheckUnicodeDataType(_dwUnicodeEncoding, (LPSTR) lpSrcStr, *lpnSrcSize);
    
    nBuffSize = *lpnSrcSize / sizeof(WCHAR);

    // We force to use MLang NO_BEST_FIT_CHAR check on ISCII encoding since system don't accept default chars
    if (IS_NLS_DLL_CP(dwDstEncoding) && (dwFlag & MLCONVCHARF_USEDEFCHAR))
        dwFlag |= MLCONVCHARF_NOBESTFITCHARS;

    if ( lpFallBack && ( dwFlag & MLCONVCHARF_USEDEFCHAR ))
    {
        // only take SBCS, no DBCS character
        if ( 1 == WideCharToMultiByte(MAPUSERDEF(dwDstEncoding), 0,
                               (LPCWSTR)lpFallBack, 1,
                               (LPSTR)DefaultCharBuff, sizeof(DefaultCharBuff), NULL, NULL ))
            lpDefFallBack = (LPSTR) DefaultCharBuff;        
    }

    if(!(*lpnDstSize = WideCharToMultiByte(MAPUSERDEF(dwDstEncoding), 0,
                                           (LPCWSTR)lpSrcStr, nBuffSize,
                                           lpDstStr, *lpnDstSize, IS_NLS_DLL_CP(dwDstEncoding)? NULL:(LPCSTR)lpDefFallBack, IS_NLS_DLL_CP(dwDstEncoding)? NULL:&UseDefChar)))
    {
        hr = E_FAIL;
        goto EXIT;
    }

    if ( !_cvt_count ) // save SrcSize if it is the first time conversion
        _nSrcSize = nBuffSize * sizeof(WCHAR);

    if (*lpnDstSize)
    {
        if (dwFlag & ( MLCONVCHARF_NCR_ENTITIZE | MLCONVCHARF_NAME_ENTITIZE | MLCONVCHARF_NOBESTFITCHARS ))
        {
            char    *lpDstStrTmp = lpDstStr;
            WCHAR   *lpwStrTmp = NULL;
            WCHAR   *lpwStrTmpSave = NULL;
            char    *lpDstStrTmp2 = NULL;
            char    *lpDstStrTmp2Save = NULL;
            int     cCount, ConvCount = 0, nCount = 0;
            WCHAR   *lpwSrcStrTmp = (WCHAR *)lpSrcStr;
            int     *lpBCharOffset = NULL;
            int     *lpBCharOffsetSave = NULL;

            if (!(lpwStrTmpSave = lpwStrTmp = (WCHAR *)LocalAlloc(LPTR, *lpnSrcSize)))
            {
                hr = E_OUTOFMEMORY;
                goto ENTITIZE_DONE;
            }

            // Make sure we have real converted buffer to check BEST_FIT_CHAR and DEFAULT_CHAR
            if (!_nDstSize)
            {
                lpDstStrTmp2Save = lpDstStrTmp2 = (char *)LocalAlloc(LPTR, *lpnDstSize);
                if (lpDstStrTmp2)
                {
                    WideCharToMultiByte(MAPUSERDEF(dwDstEncoding), 0,
                               (LPCWSTR)lpSrcStr, nBuffSize,
                               lpDstStrTmp2, *lpnDstSize, NULL, NULL );
                }
                else
                {
                    hr = E_OUTOFMEMORY;
                    goto ENTITIZE_DONE;
                }
            }

            if (nBuffSize == 
                MultiByteToWideChar(MAPUSERDEF(dwDstEncoding), 0, _nDstSize? lpDstStr : lpDstStrTmp2, *lpnDstSize, lpwStrTmp, _nSrcSize))
            {
                // Pre scan to get number of best fit chars.
                for (i=0; i<nBuffSize; i++)
                {
                    // make special case for ?(yen sign) in Shift-JIS
                    if (*lpwStrTmp++ != *lpwSrcStrTmp++)
                    {
                        if ((dwDstEncoding == CP_JPN_SJ) && (*(lpwSrcStrTmp - 1) == 0x00A5))
                            *(lpwStrTmp - 1) = 0x00A5;
                        else
                            nCount ++;
                    }
                }

                lpwSrcStrTmp -= nBuffSize;
                lpwStrTmp -= nBuffSize;

                if (nCount)
                {
                    int j = 0;

                    if (!(dwFlag & ( MLCONVCHARF_NCR_ENTITIZE | MLCONVCHARF_NAME_ENTITIZE | MLCONVCHARF_USEDEFCHAR)))
                    {
                        hr = E_FAIL;
                        goto ENTITIZE_DONE;
                    }

                    if (!(lpBCharOffsetSave = lpBCharOffset = (int *) LocalAlloc(LPTR, nCount*sizeof(int))))
                    {
                        hr = E_OUTOFMEMORY;
                        goto ENTITIZE_DONE;
                    }

                    // Record the offset position of each best fit char.
                    for (i=0; i<nBuffSize; i++)
                    {
                        if (*lpwStrTmp++ != *lpwSrcStrTmp++)
                        {
                            *lpBCharOffset = i-j;
                            lpBCharOffset++;
                            j = i+1;
                        }
                    }

                    lpBCharOffset -= nCount;
                    lpwSrcStrTmp -= nBuffSize;
                    lpwStrTmp -= nBuffSize;

                    for (i=0; i<nCount; i++)
                    {
                        BOOL bIsSurrogatePair = FALSE;

                        if (*lpBCharOffset)
                        {
                            cCount = WideCharToMultiByte(MAPUSERDEF(dwDstEncoding), 0,
                                   (LPCWSTR)lpwSrcStrTmp, *lpBCharOffset,
                                   lpDstStrTmp,  _nDstSize? _nDstSize-ConvCount : 0, NULL, NULL );

                            ConvCount += cCount;
                            if (_nDstSize)
                            {
                                lpDstStrTmp += cCount;
                            }
                            lpwSrcStrTmp += *lpBCharOffset;
                        }

                        BOOL fConverted = FALSE;

                        // check if unconvertable character falls in NAME ENTITY area
                        if (dwFlag & MLCONVCHARF_NAME_ENTITIZE)
                        {
                            // for beta2, make assmption that name entity implys NCR.
                            dwFlag |= MLCONVCHARF_NCR_ENTITIZE;

#ifdef MORE_NAME_ENTITY   // in case we decide do more name entity latter
                            BOOL      fDoNEnty = FALSE;
                            LPCTSTR   lpszNEnty = NULL;

                            // check if character is in the Latin-1 Supplement range
                            if ((*lpwSrcStrTmp >= NAME_ENTITY_OFFSET) && (*lpwSrcStrTmp <= NAME_ENTITY_MAX ))
                            {
                                fDoNEnty = TRUE;
                                lpszNEnty = g_lpstrNameEntity[(*lpwSrcStrTmp) - NAME_ENTITY_OFFSET];
                            }

                            // check if character is in the additional name entity table for CP 1252 extension
                            if (!fDoNEnty)
                            {
                                for (int idx = 0; idx < ARRAYSIZE(aNameEntityExt); idx++)
                                    if (*lpwSrcStrTmp == aNameEntityExt[idx].uwUniCode)
                                    {
                                        fDoNEnty = TRUE;
                                        lpszNEnty = aNameEntityExt[idx].lpszNameEntity;
                                        break;
                                    }
                            }

                            if (fDoNEnty)
                            {
                                cCount = lstrlenA(lpszNEnty);
                                if (_nDstSize)
                                {
                                    CopyMemory(lpDstStrTmp, lpszNEnty, cCount);
                                    lpDstStrTmp += cCount ;
                                }

                                ConvCount += cCount;
                                fConverted = TRUE;
                            }
#else
                            // check if character is in the Latin-1 Supplement range
                            if ((*lpwSrcStrTmp >= NAME_ENTITY_OFFSET)
                                && (*lpwSrcStrTmp < ARRAYSIZE(g_lpstrNameEntity)+NAME_ENTITY_OFFSET))
                                
                            {
                                LPCTSTR   lpszNEnty = NULL;

                                if (!(lpszNEnty = g_lpstrNameEntity[(*lpwSrcStrTmp) - NAME_ENTITY_OFFSET]))
                                {
#ifdef DEBUG
                                    AssertMsg((BOOL)FALSE, "Name entity table broken"); 
#endif
                                    hr = E_FAIL;
                                    goto ENTITIZE_DONE;
                                }

                                    cCount = lstrlenA(lpszNEnty);
                                    if (_nDstSize)
                                    {
                                        CopyMemory(lpDstStrTmp, lpszNEnty, cCount);
                                        lpDstStrTmp += cCount ;
                                    }
                                
                                ConvCount += cCount;
                                fConverted = TRUE;
                            }
#endif
                        }

                        // check if NCR requested
                        if ((!fConverted) && (dwFlag & MLCONVCHARF_NCR_ENTITIZE))
                        {
                            if ((nCount-i >= 2) &&
                                (*lpwSrcStrTmp >= 0xD800 && *lpwSrcStrTmp <= 0xDBFF) &&
                                (*(lpwSrcStrTmp+1) >= 0xDC00 && *(lpwSrcStrTmp+1) <= 0xDFFF))
                                bIsSurrogatePair = TRUE;
                            else
                                bIsSurrogatePair = FALSE;
                          
                            if (_nDstSize)
                            {
                                lpDstStrTmp[0] = '&' ;
                                lpDstStrTmp[1] = '#' ;
                                lpDstStrTmp += 2 ;
                                // If it is a Unicode surrogates pair, we convert it to real Unicode value
                                if (bIsSurrogatePair)
                                {
                                    DWORD dwUnicode = ((*lpwSrcStrTmp - 0xD800) << 10) + *(lpwSrcStrTmp+1) - 0xDC00 + 0x10000;
                                    _ultoa( dwUnicode, (char*)lpDstStrTmp, 10);
                                }
                                else
                                    _ultoa( *lpwSrcStrTmp, (char*)lpDstStrTmp, 10);
                                cCount = lstrlenA(lpDstStrTmp);
                                lpDstStrTmp += cCount;
                                ConvCount += cCount;
                                *(lpDstStrTmp++) = ';' ;
                            }
                            else
                            {
                                char szTmpString[10];
                                if (bIsSurrogatePair)
                                {
                                    DWORD dwUnicode = ((*lpwSrcStrTmp - 0xD800) << 10) + *(lpwSrcStrTmp+1) - 0xDC00 + 0x10000;
                                    _ultoa( dwUnicode, szTmpString, 10);
                                }
                                else
                                    _ultoa( *lpwSrcStrTmp, szTmpString, 10);
                                ConvCount += lstrlenA(szTmpString);
                            }
                        
                            fConverted = TRUE;
                            ConvCount += 3;                    
                        }

                        // handle MLCONVCHARF_USEDEFCHAR here - less priority and default method
                        if (!fConverted)
                        {
                            if (_nDstSize)
                            {
                                *lpDstStrTmp = lpDefFallBack ? *lpDefFallBack : '?';
                                lpDstStrTmp++;
                            }

                            ConvCount++;
                            if (!UseDefChar)
                                UseDefChar = TRUE;
                        }

                        lpBCharOffset++;
                        lpwSrcStrTmp++;
                        // Skip next character if it is a Unicode surrogates pair
                        if (bIsSurrogatePair)
                        {
                            lpBCharOffset++;
                            lpwSrcStrTmp++;
                            i++;
                        }
                    }
                    lpBCharOffset -= nCount ;
                }

                int nRemain = (*lpnSrcSize - (int)((char*)lpwSrcStrTmp - (char *)lpSrcStr))/sizeof(WCHAR);

                ConvCount += WideCharToMultiByte(MAPUSERDEF(dwDstEncoding), 0,
                                   (LPCWSTR)lpwSrcStrTmp, nRemain,
                                   lpDstStrTmp, _nDstSize? _nDstSize-ConvCount : 0, NULL, NULL );

                *lpnDstSize = ConvCount ;

                hr = S_OK;
            } 
            else
            {
                hr = E_FAIL;
            }

ENTITIZE_DONE:
            if (lpwStrTmpSave)
                LocalFree(lpwStrTmpSave);
            if (lpDstStrTmp2Save)
                LocalFree(lpDstStrTmp2Save);
            if (lpBCharOffsetSave)
                LocalFree(lpBCharOffsetSave);
        }
        else
        {
            hr = S_OK;
        }       

        if (S_OK == hr && UseDefChar)
            hr = S_FALSE;
    }
    else
    {
        hr = E_FAIL;
    }

EXIT:
    return hr;
}

HRESULT CICharConverter::UTF78ToUnicode(LPDWORD lpdwMode, LPCSTR lpSrcStr, LPINT lpnSrcSize,
    LPSTR lpDstStr, LPINT lpnDstSize)
{
    HRESULT hr ;

    hr = DoConvertINetString(lpdwMode, TRUE, CP_UCS_2, _dwUTFEncoding, lpSrcStr, lpnSrcSize, lpDstStr, *lpnDstSize, lpnDstSize);

    if ( !_cvt_count ) // save SrcSize if it is the first time conversion
        _nSrcSize = *lpnSrcSize ;

    CheckUnicodeDataType(_dwUnicodeEncoding, lpDstStr, *lpnDstSize);

    return hr ;
}

HRESULT CICharConverter::UnicodeToUTF78(LPDWORD lpdwMode, LPCSTR lpSrcStr, LPINT lpnSrcSize,
    LPSTR lpDstStr, LPINT lpnDstSize)
{
    HRESULT hr ;

    if ( _dwUnicodeEncoding == CP_UCS_2_BE && _cvt_count == 0 )
    {
       if ( _lpUnicodeStr = (LPSTR)LocalAlloc(LPTR, *lpnSrcSize ) )
       {
          MoveMemory(_lpUnicodeStr, lpSrcStr, *lpnSrcSize ) ;
          lpSrcStr = _lpUnicodeStr ;
       }
       else
        return E_OUTOFMEMORY ;
    }

    CheckUnicodeDataType(_dwUnicodeEncoding, (LPSTR) lpSrcStr, *lpnSrcSize);

    hr = DoConvertINetString(lpdwMode, FALSE, CP_UCS_2, _dwUTFEncoding, lpSrcStr, lpnSrcSize, lpDstStr, *lpnDstSize, lpnDstSize);
    if ( !_cvt_count ) // save SrcSize if it is the first time conversion
        _nSrcSize = *lpnSrcSize ;


    return hr ;
}

HRESULT CICharConverter::UnicodeToWindowsCodePage(LPCSTR lpSrcStr, LPINT lpnSrcSize,
    LPSTR lpDstStr, LPINT lpnDstSize, DWORD dwFlag, WCHAR *lpFallBack)
{
    HRESULT hr ;

    hr = UnicodeToMultiByteEncoding(_dwWinCodePage,lpSrcStr,lpnSrcSize,lpDstStr,lpnDstSize,dwFlag,lpFallBack);

    return hr ;
}

HRESULT CICharConverter::UnicodeToInternetEncoding(LPCSTR lpSrcStr, LPINT lpnSrcSize,
    LPSTR lpDstStr, LPINT lpnDstSize, DWORD dwFlag, WCHAR *lpFallBack)
{
    HRESULT hr ;

    hr = UnicodeToMultiByteEncoding(_dwInternetEncoding,lpSrcStr,lpnSrcSize,lpDstStr,lpnDstSize,dwFlag,lpFallBack);

    return hr ;
}

HRESULT CICharConverter::InternetEncodingToUnicode(LPCSTR lpSrcStr, LPINT lpnSrcSize,
    LPSTR lpDstStr, LPINT lpnDstSize)
{
    int cch;
    int cb = *lpnSrcSize;

    if ( !_cvt_count)
    {
        // If we have a multibyte character encoding, we are at risk of splitting
        // some characters at the read boundary.  We must Make sure we have a
        // discrete number of characters first.

        UINT uMax = MAX_CHAR_SIZE ;
        cb++; // pre-increment
        do
        {
            cch = MultiByteToWideChar( MAPUSERDEF(_dwInternetEncoding),
                                        MB_ERR_INVALID_CHARS,
                                        lpSrcStr, --cb,
                                        NULL, 0 );
            --uMax;
        } while (!cch && uMax && cb);
    }

    if ( !cb || cb == (*lpnSrcSize - MAX_CHAR_SIZE +1 ))  // if conversion problem isn't at the end of the string
        cb = *lpnSrcSize ; // restore orginal value            


    *lpnDstSize = MultiByteToWideChar( MAPUSERDEF(_dwInternetEncoding), 0,
                               lpSrcStr, cb,
                               (LPWSTR)lpDstStr, *lpnDstSize/sizeof(WCHAR) );
    *lpnDstSize = *lpnDstSize * sizeof(WCHAR);
    if ( !_cvt_count ) // save SrcSize if it is the first time conversion
        _nSrcSize = cb ;

    CheckUnicodeDataType(_dwUnicodeEncoding, lpDstStr, *lpnDstSize);            

    if (*lpnDstSize==0 && (cb || cb != *lpnSrcSize))
    {
            // GetLastError() for MultiByteToWideChar()
            // Skip invalid characters for UTF8 conversion            
            if (CP_UTF_8 == MAPUSERDEF(_dwInternetEncoding)&&
                ERROR_NO_UNICODE_TRANSLATION == GetLastError())
                return S_OK;
            else
                return E_FAIL ;
    }
    else
        return S_OK ;
}

HRESULT CICharConverter::WindowsCodePageToUnicode(LPCSTR lpSrcStr, LPINT lpnSrcSize,
    LPSTR lpDstStr, LPINT lpnDstSize)
{

    int cch1, cch2;
    int cb = *lpnSrcSize;

    if ( !_cvt_count && cb > 1 )
    {
        if (IS_DBCSCODEPAGE(MAPUSERDEF(_dwWinCodePage)))
        {
            // Detect DBCS dangling character
            if (!MultiByteToWideChar( MAPUSERDEF(_dwWinCodePage),
                                        MB_ERR_INVALID_CHARS,
                                        lpSrcStr, cb,
                                        NULL, 0 ))
            {
                if (IsDBCSLeadByteEx(MAPUSERDEF(_dwWinCodePage), lpSrcStr[cb-1]))
                {
                    cch1 = MultiByteToWideChar( MAPUSERDEF(_dwWinCodePage),
                                            0,
                                            lpSrcStr, cb,
                                            NULL, 0 );

                    cch2 = MultiByteToWideChar( MAPUSERDEF(_dwWinCodePage),
                                            0,
                                            lpSrcStr, --cb,
                                            NULL, 0 );
                    
                    if (cch1 != cch2+1)
                    {
                        //Dangling DBCS character not found, restore cb.
                        cb++;
                    }
                }
            }
        }
        else 
        {
            // If we have a multibyte character encoding, we are at risk of splitting
            // some characters at the read boundary.  We must Make sure we have a
            // discrete number of characters first.

            UINT uMax = MAX_CHAR_SIZE ;
            cb++; // pre-increment
            do
            {
                cch1 = MultiByteToWideChar( MAPUSERDEF(_dwWinCodePage),
                                            MB_ERR_INVALID_CHARS,
                                            lpSrcStr, --cb,
                                            NULL, 0 );
                --uMax;
            } while (!cch1 && uMax && cb);
    
            if ( !cb || cb == (*lpnSrcSize - MAX_CHAR_SIZE +1 ))  // if conversion problem isn't at the end of the string
                cb = *lpnSrcSize ; // restore orginal value            
        }        
    }

    *lpnDstSize = MultiByteToWideChar( MAPUSERDEF(_dwWinCodePage), 0,
                               lpSrcStr, cb,
                               (LPWSTR)lpDstStr, *lpnDstSize/sizeof(WCHAR) );
    *lpnDstSize = *lpnDstSize * sizeof(WCHAR);
    if ( !_cvt_count ) // save SrcSize if it is the first time conversion
        _nSrcSize = cb ;

    CheckUnicodeDataType(_dwUnicodeEncoding, lpDstStr, *lpnDstSize);
    
    // Whistler Bug#360429, 
    // Web page could have a splitting DBCS character at the very end of the page,
    // To work around it, we allow one byte of dangling DBCS character.
    if (*lpnDstSize==0 && (cb || (cb != *lpnSrcSize && ++cb != *lpnSrcSize)))
        return E_FAIL ;
    else
        return S_OK ;
}

HRESULT CICharConverter::WindowsCodePageToInternetEncoding(LPDWORD lpdwMode, LPCSTR lpSrcStr, LPINT lpnSrcSize,
    LPSTR lpDstStr, LPINT lpnDstSize, DWORD dwFlag, WCHAR *lpFallBack)
{
    HRESULT hr ;

    // check if the conversion should go through Unicode indirectly
    if ( _dwConvertType & 0x10 )
        hr = WindowsCodePageToInternetEncodingWrap(lpSrcStr, lpnSrcSize, lpDstStr, lpnDstSize, dwFlag, lpFallBack);
    else
    {

        hr = DoConvertINetString(lpdwMode, FALSE, _dwWinCodePage, _dwInternetEncoding, lpSrcStr, lpnSrcSize, lpDstStr, *lpnDstSize, lpnDstSize);

        if ( !_cvt_count ) // save SrcSize if it is the first time conversion
            _nSrcSize = *lpnSrcSize ;
    }
    return hr ;
}

HRESULT CICharConverter::InternetEncodingToWindowsCodePage(LPDWORD lpdwMode, LPCSTR lpSrcStr, LPINT lpnSrcSize,
    LPSTR lpDstStr, LPINT lpnDstSize, DWORD dwFlag, WCHAR *lpFallBack)
{
    HRESULT hr ;

    // check if the conversion should go through Unicode indirectly
    if ( _dwConvertType & 0x10 )
        hr = InternetEncodingToWindowsCodePageWrap(lpSrcStr, lpnSrcSize, lpDstStr, lpnDstSize, dwFlag, lpFallBack);
    else
    {
        hr = DoConvertINetString(lpdwMode, TRUE, _dwWinCodePage, _dwInternetEncoding, lpSrcStr, lpnSrcSize, lpDstStr, *lpnDstSize, lpnDstSize);

        if ( !_cvt_count ) // save SrcSize if it is the first time conversion
            _nSrcSize = *lpnSrcSize ;
    }
    return hr ;
}

HRESULT CICharConverter::WindowsCodePageToInternetEncodingWrap(LPCSTR lpSrcStr, LPINT lpnSrcSize,
    LPSTR lpDstStr, LPINT lpnDstSize, DWORD dwFlag, WCHAR *lpFallBack)
{
    int nBuffSize = 0 ;
    int cb = *lpnSrcSize;
    UINT uMax = MAX_CHAR_SIZE ;
    BOOL UseDefChar = FALSE ;
    HRESULT hr = S_OK;

    if ( !_cvt_count )
    {
        cb++; // pre-increment
        do
        {
            nBuffSize = MultiByteToWideChar( MAPUSERDEF(_dwWinCodePage),
                                        MB_ERR_INVALID_CHARS,
                                        lpSrcStr, --cb,
                                        NULL, 0 );
            --uMax;
        } while (!nBuffSize && uMax && cb);
    }

    if ( cb == (*lpnSrcSize - MAX_CHAR_SIZE +1 ))  // if conversion problem isn't at the end of the string
        cb = *lpnSrcSize ; // restore orginal value

    if (!nBuffSize)  // in case there are illeage characters
        nBuffSize = cb ;

    if ( _lpInterm1Str = (LPSTR) LocalAlloc(LPTR, (nBuffSize * sizeof(WCHAR))))
    {
        nBuffSize = MultiByteToWideChar(MAPUSERDEF(_dwWinCodePage), 0,
                        lpSrcStr, cb, (LPWSTR)_lpInterm1Str, nBuffSize );

        int iSrcSizeTmp = nBuffSize * sizeof(WCHAR);
        hr = UnicodeToMultiByteEncoding(MAPUSERDEF(_dwInternetEncoding), (LPCSTR)_lpInterm1Str, &iSrcSizeTmp,
                                        lpDstStr, lpnDstSize, dwFlag, lpFallBack);
//        *lpnDstSize = WideCharToMultiByte( MAPUSERDEF(_dwInternetEncoding), 0,
//                        (LPCWSTR)_lpInterm1Str, nBuffSize, lpDstStr, *lpnDstSize, NULL, &UseDefChar );

        if ( !_cvt_count ) // save SrcSize if it is the first time conversion
            _nSrcSize = cb ;
    }
    else        
        hr = E_FAIL;

    if (hr == S_OK)
    {
        if (*lpnDstSize==0 && cb)
            hr = E_FAIL ;
        else 
        {
            if ( UseDefChar )
                return S_FALSE ;
            else
                return S_OK ;
        }
    }

    return hr;
}

HRESULT CICharConverter::InternetEncodingToWindowsCodePageWrap(LPCSTR lpSrcStr, LPINT lpnSrcSize,
    LPSTR lpDstStr, LPINT lpnDstSize, DWORD dwFlag, WCHAR *lpFallBack)
{

    int nBuffSize = 0 ;
    int cb = *lpnSrcSize;
    UINT uMax = MAX_CHAR_SIZE ;
    BOOL UseDefChar = FALSE ;
    HRESULT hr = S_OK;

    if ( !_cvt_count )
    {
        cb++; // pre-increment
        do
        {
            nBuffSize = MultiByteToWideChar( MAPUSERDEF(_dwInternetEncoding),
                                        MB_ERR_INVALID_CHARS,
                                        lpSrcStr, --cb,
                                        NULL, 0 );
            --uMax;
        } while (!nBuffSize && uMax && cb);
    }

    if ( cb == (*lpnSrcSize - MAX_CHAR_SIZE +1 ))  // if conversion problem isn't at the end of the string
        cb = *lpnSrcSize ; // restore orginal value

    if (!nBuffSize)  // in case there are illeage characters
        nBuffSize = cb ;

    if ( _lpInterm1Str = (LPSTR) LocalAlloc(LPTR,nBuffSize * sizeof (WCHAR) ))
    {
        nBuffSize = MultiByteToWideChar( MAPUSERDEF(_dwInternetEncoding), 0,
                        lpSrcStr, cb, (LPWSTR)_lpInterm1Str, nBuffSize );

        int iSrcSizeTmp = nBuffSize * sizeof(WCHAR);
        hr = UnicodeToMultiByteEncoding(MAPUSERDEF(_dwWinCodePage), (LPCSTR)_lpInterm1Str, &iSrcSizeTmp,
                                        lpDstStr, lpnDstSize, dwFlag, lpFallBack);
//        *lpnDstSize = WideCharToMultiByte( MAPUSERDEF(_dwWinCodePage), 0,
//                        (LPCWSTR)_lpInterm1Str, nBuffSize, lpDstStr, *lpnDstSize, NULL, &UseDefChar );

        if ( !_cvt_count ) // save SrcSize if it is the first time conversion
            _nSrcSize = cb ;
    }
    else
        hr = E_FAIL;

    if (hr == S_OK)
    {
        if (*lpnDstSize==0 && cb)
            hr = E_FAIL ;
        else 
        {
            if ( UseDefChar )
                return S_FALSE ;
            else
                return S_OK ;
        }
    }

    return hr;
}

HRESULT CICharConverter::ConvertIWUU(LPDWORD lpdwMode, LPCSTR lpSrcStr, LPINT lpnSrcSize,
    LPSTR lpDstStr, LPINT lpnDstSize, DWORD dwFlag, WCHAR *lpFallBack)
{
    int nBuffSize = 0 ;
    HRESULT hr = S_OK ;
    HRESULT hrWarnings = S_OK ;

    // InternetEncodingToWindowsCodePage
    if ( _dwConvertType % 2 && _dwConvertType < 21 ) /* start from Internet Encoding */
    {
        if ( _dwConvertType == 5 || _dwConvertType == 9 ) /* use interm buffer */
        {
            hr = InternetEncodingToWindowsCodePage(lpdwMode, lpSrcStr, lpnSrcSize, NULL, &nBuffSize, dwFlag, lpFallBack);
            if ( _lpInterm1Str = (LPSTR) LocalAlloc(LPTR,nBuffSize) )
            {
                hr = InternetEncodingToWindowsCodePage(lpdwMode, lpSrcStr, lpnSrcSize, _lpInterm1Str, &nBuffSize, dwFlag, lpFallBack);
                lpSrcStr = _lpInterm1Str ;
                *lpnSrcSize = nBuffSize ;
            }
            else
                goto fail ;
        }
        else
            hr = InternetEncodingToWindowsCodePage(lpdwMode, lpSrcStr, lpnSrcSize, lpDstStr, lpnDstSize, dwFlag, lpFallBack);
        _cvt_count ++ ;
    }

    if ( hr != S_OK )
        hrWarnings = hr ;
        
    // WindowsCodePageToUnicode or InternetEncodingToUnicode
    if ( _dwConvertType == 21 || _dwConvertType == 25 )
    {
        if ( _dwConvertType == 21 )
            hr = InternetEncodingToUnicode(lpSrcStr, lpnSrcSize, lpDstStr, lpnDstSize);
        else // _dwConvertType == 25 
        {
            hr = InternetEncodingToUnicode(lpSrcStr, lpnSrcSize, NULL, &nBuffSize);
            if ( _lpInterm1Str= (LPSTR)LocalAlloc(LPTR, nBuffSize) )
            {
                hr = InternetEncodingToUnicode(lpSrcStr, lpnSrcSize, _lpInterm1Str, &nBuffSize);
                lpSrcStr = _lpInterm1Str ;
                *lpnSrcSize = nBuffSize ;
            }
            else
                goto fail ;
        }
        _cvt_count ++ ;
    }
    else if ( _dwConvertType >= 4 && _dwConvertType <= 10 )
    {
        if ( _dwConvertType > 8 )
        {
            nBuffSize = 0 ;
            hr = WindowsCodePageToUnicode(lpSrcStr, lpnSrcSize, NULL, &nBuffSize);
            if ( _cvt_count )
            {
                if ( _lpInterm2Str= (LPSTR)LocalAlloc(LPTR, nBuffSize) )
                {
                    hr = WindowsCodePageToUnicode(lpSrcStr, lpnSrcSize, _lpInterm2Str, &nBuffSize);
                    lpSrcStr = _lpInterm2Str ;
                    *lpnSrcSize = nBuffSize ;
                }
                else
                    goto fail ;

            }
            else
            {
                if ( _lpInterm1Str= (LPSTR)LocalAlloc(LPTR, nBuffSize) )
                {
                    hr = WindowsCodePageToUnicode(lpSrcStr, lpnSrcSize, _lpInterm1Str, &nBuffSize);
                    lpSrcStr = _lpInterm1Str ;
                    *lpnSrcSize = nBuffSize ;
                }
                else
                    goto fail ;
            }
        }
        else
            hr = WindowsCodePageToUnicode(lpSrcStr, lpnSrcSize, lpDstStr, lpnDstSize);
        _cvt_count ++ ;
    }

    if ( hr != S_OK )
        hrWarnings = hr ;

    // UnicodeToUTF78
    if ( _dwConvertType & 0x08 )
#ifndef UNIX
        hr = UnicodeToUTF78(lpdwMode, lpSrcStr, lpnSrcSize, lpDstStr, lpnDstSize);
#else
        {
        /* we now hack the lpSrcStr to be the same as 2 byte Unicode so mlang
         * lowlevel code can work right.
         */
        LPWSTR lpwSrcStr = (LPWSTR)lpSrcStr;
        INT tmpSize = *lpnSrcSize/sizeof(WCHAR);
        UCHAR *pTmp = new UCHAR[(tmpSize+1)*2];
        if(pTmp) {
            for(int i = 0; i < tmpSize; i++) {
                pTmp[i*2] = *lpwSrcStr++;
                pTmp[i*2+1] = 0x00;
            }
            pTmp[i*2] = pTmp[i*2+1] = 0x00;
            tmpSize *= 2;
            hr = UnicodeToUTF78(lpdwMode, (LPCSTR)pTmp, &tmpSize, lpDstStr, lpnDstSize);
        }
        else
            hr = E_FAIL;
        delete [] pTmp;
        }
#endif /* UNIX */

    return ( hr == S_OK ? hrWarnings : hr ) ;

fail :
    return E_FAIL ;
}

HRESULT CICharConverter::ConvertUUWI(LPDWORD lpdwMode, LPCSTR lpSrcStr, LPINT lpnSrcSize,
    LPSTR lpDstStr, LPINT lpnDstSize, DWORD dwFlag, WCHAR *lpFallBack)
{
    int nBuffSize = 0 ;
    HRESULT hr = S_OK ;
    HRESULT hrWarnings = S_OK ;

    // UTF78ToUnicode
    if ( _dwConvertType & 0x08 )
    {
        if ( _dwConvertType == 12 ) /* convert UTF78 -> Unicode only */
            hr = UTF78ToUnicode(lpdwMode, lpSrcStr, lpnSrcSize, lpDstStr, lpnDstSize);
        else /* use interm buffer, type = 10 or 9 */
        {
            hr = UTF78ToUnicode(lpdwMode, lpSrcStr, lpnSrcSize, NULL, &nBuffSize);
            if ( _lpInterm1Str= (LPSTR)LocalAlloc(LPTR, nBuffSize) )
            {
                hr = UTF78ToUnicode(lpdwMode, lpSrcStr, lpnSrcSize, _lpInterm1Str, &nBuffSize);
                lpSrcStr = _lpInterm1Str ;
                *lpnSrcSize = nBuffSize ;
            }
            else
                goto fail ;
        }
        _cvt_count ++ ;
    }

    if ( hr != S_OK )
        hrWarnings = hr ;

    // UnicodeToWindowsCodePage or UnicodeToInternetEncoding
    if ( _dwConvertType == 21 || _dwConvertType == 25 )
    {
        hr = UnicodeToInternetEncoding(lpSrcStr, lpnSrcSize, lpDstStr, lpnDstSize, dwFlag, lpFallBack);
        _cvt_count ++ ;
    }
    else if ( _dwConvertType >= 4 && _dwConvertType <= 10 )
    {
        if ( _dwConvertType % 2 ) /* use interm buffer */
        {
            nBuffSize = 0 ;
            hr = UnicodeToWindowsCodePage(lpSrcStr, lpnSrcSize, NULL, &nBuffSize, dwFlag, lpFallBack);
            if ( _cvt_count )
            {
                if ( _lpInterm2Str= (LPSTR)LocalAlloc(LPTR, nBuffSize) )
                {
                    hr = UnicodeToWindowsCodePage(lpSrcStr, lpnSrcSize, _lpInterm2Str, &nBuffSize, dwFlag, lpFallBack);
                    lpSrcStr = _lpInterm2Str ;
                    *lpnSrcSize = nBuffSize ;
                }
                else
                    goto fail ;
            }
            else
            {
                if ( _lpInterm1Str= (LPSTR)LocalAlloc(LPTR, nBuffSize) )
                {
                    hr = UnicodeToWindowsCodePage(lpSrcStr, lpnSrcSize, _lpInterm1Str, &nBuffSize, dwFlag, lpFallBack);
                    lpSrcStr = _lpInterm1Str ;
                    *lpnSrcSize = nBuffSize ;
                }
                else
                    goto fail ;
            }
        }
        else
            hr = UnicodeToWindowsCodePage(lpSrcStr, lpnSrcSize, lpDstStr, lpnDstSize, dwFlag, lpFallBack);
        _cvt_count ++ ;
    }

    if ( hr != S_OK )
        hrWarnings = hr ;

    // WindowsCodePageToInternetEncoding
    if ( _dwConvertType % 2 && _dwConvertType < 21 )
        hr = WindowsCodePageToInternetEncoding(lpdwMode, lpSrcStr, lpnSrcSize, lpDstStr, lpnDstSize, dwFlag, lpFallBack);

    return ( hr == S_OK ? hrWarnings : hr ) ;

fail :
    return E_FAIL ;
}

#if 0
struct CODEPAGEINFO
{
    UINT        uCodePage ;
    CP_STATE    nCP_State ;    // whether this is a valid windows codepage  ?
};

// ValidCodepageInfo is used to cache whether a codepage is a vaild code
// It uses circular-FIFO cache algorithm
#define MAX_CP_CACHE    32
static int cp_cache_count = 0 ;
static int cp_cache_ptr = 0 ;
static struct CODEPAGEINFO ValidCodepageInfo[MAX_CP_CACHE];

// ValidCodepageInfo is used to cache whether a codepage is a vaild codepage
// It uses circular-FIFO cache algorithm

BOOL CheckIsValidCodePage (UINT uCodePage)
{
    if ( uCodePage == 50000 ) // User defined
        return TRUE ;

    int i ;
    BOOL bRet ;

    for ( i = 0 ; i < cp_cache_count ; i++ )
    {
        if ( uCodePage == ValidCodepageInfo[i].uCodePage )
        {
            if ( ValidCodepageInfo[i].nCP_State == VALID_CP )
                return TRUE ;
            else
                return FALSE ;
        }
    }

    // not found, call IsValidCodePage and cache the return value
    bRet = IsValidCodePage(uCodePage);

    EnterCriticalSection(&g_cs);
    ValidCodepageInfo[cp_cache_ptr].uCodePage = uCodePage ;
    if (bRet)
        ValidCodepageInfo[cp_cache_ptr].nCP_State = VALID_CP ;
    else
        ValidCodepageInfo[cp_cache_ptr].nCP_State = INVALID_CP ;
    if ( cp_cache_count < MAX_CP_CACHE )
        cp_cache_count++ ;
    cp_cache_ptr = ( ++cp_cache_ptr ) % MAX_CP_CACHE ;
    LeaveCriticalSection(&g_cs);

    return bRet ;
}
#endif

/*
    Conversion Flag:

    Bit 7 - Convert Direction.

    Bit 4 (16) - Unicode <-> Internet Encoding
    Bit 3 (8) - UTF8, UTF7
    Bit 2 (4) - Unicode
    Bit 1 (2) - Windows CodePage
    Bit 0 (1) - Internet Encoding

    12, 6, 3 (19) - one step convert
    10, 5 (21)  - two steps convert
    9 (25) - three steps convert

*/

int GetWindowsEncodingIndex(DWORD dwEncoding)
{
    int nr = sizeof (aEncodingInfo) / sizeof(ENCODINGINFO) ;
    int i, half = nr / 2, index = -1 ;

    if (aEncodingInfo[half].dwEncoding > dwEncoding )
    {
        for ( i = 0 ; i < half ; i++ )
            if (aEncodingInfo[i].dwEncoding == dwEncoding )
                index = i ;

    }
    else if (aEncodingInfo[half].dwEncoding < dwEncoding )
    {
        for ( i = half + 1 ; i < nr ; i++ )
            if (aEncodingInfo[i].dwEncoding == dwEncoding )
                index = i ;
    }
    else
        index = half ;

    if (index>=0) // found
    {
        if ( aEncodingInfo[index].nCP_State != VALID_CP &&
                aEncodingInfo[index].dwCodePage )
        {

            if ( aEncodingInfo[index].dwCodePage == 50000 || IsValidCodePage(aEncodingInfo[index].dwCodePage ) ) // 50000 means user defined
                aEncodingInfo[index].nCP_State = VALID_CP ;
            else
                aEncodingInfo[index].nCP_State = INVALID_CP ;

            if ((aEncodingInfo[index].nCP_State == VALID_CP) &&
                (aEncodingInfo[index].dwFlags & CONV_CHK_NLS) &&
                !IsValidCodePage(aEncodingInfo[index].dwEncoding))
                aEncodingInfo[index].nCP_State = INVALID_CP ;
        }
        // Use system UTF8 conversion to work around security issues on Win2k and greater platforms.
        if (g_bUseSysUTF8 && dwEncoding == CP_UTF_8)
        {
            aEncodingInfo[index].bTypeUUIW = 0x11;
        }
    }

    return index ;
}

HRESULT CICharConverter::ConvertSetup(DWORD * pdwSrcEncoding, DWORD dwDstEncoding)
{
    DWORD SrcFlag = 0, DstFlag = 0 ;
    int index, unknown = 0 ;

    // IE bug 109708 - WEIWU 5/11/00
    // Always consider US-ASCII as a valid source encoding for conversion
/*
    if (*pdwSrcEncoding == CP_20127 && !IsValidCodePage(CP_20127))
        *pdwSrcEncoding = CP_1252;
*/
    /* check source & destination encoding type */
    index = GetWindowsEncodingIndex(*pdwSrcEncoding);
    if ( index >=0 )
    {
        SrcFlag = (DWORD) aEncodingInfo[index].bTypeUUIW ;
        if ( aEncodingInfo[index].dwCodePage )
        {
            _dwWinCodePage = (DWORD) aEncodingInfo[index].dwCodePage ;
            if (aEncodingInfo[index].nCP_State == INVALID_CP )
                goto fail ;
        }
        if ( SrcFlag & 0x08 )
            _dwUTFEncoding = *pdwSrcEncoding ;
        if ( SrcFlag & 0x01 )
            _dwInternetEncoding = *pdwSrcEncoding ;
        if ( SrcFlag & 0x04 )
            _dwUnicodeEncoding = *pdwSrcEncoding ;
    }
    // assume it is a unknown Window Codepage
    else
    {
        if ( !CONVERT_IS_VALIDCODEPAGE(*pdwSrcEncoding))
            goto fail ;

        SrcFlag = 0x02 ;
        _dwWinCodePage = *pdwSrcEncoding ;

        unknown ++ ;
    }

    index = GetWindowsEncodingIndex(dwDstEncoding);
    if ( index >=0 )
    {
        // check if two codepages are compatiable
        if ( _dwWinCodePage && aEncodingInfo[index].dwCodePage )
        {
            if (_dwWinCodePage != (DWORD) aEncodingInfo[index].dwCodePage )
                goto fail ;
        }

        DstFlag = (DWORD) aEncodingInfo[index].bTypeUUIW ;
        if ( aEncodingInfo[index].dwCodePage )
        {
            _dwWinCodePage = (DWORD) aEncodingInfo[index].dwCodePage ;
            if (aEncodingInfo[index].nCP_State == INVALID_CP )
                goto fail ;
        }
        if ( DstFlag & 0x08 )
        {
            if (_dwUTFEncoding)
                _dwUTFEncoding2 = dwDstEncoding ;
            else
                _dwUTFEncoding = dwDstEncoding ;
        }
        if ( DstFlag & 0x01 )
            _dwInternetEncoding = dwDstEncoding ;
        if ( DstFlag & 0x04 )
            _dwUnicodeEncoding = dwDstEncoding ;
    }
    // 1) First time unknown, assume it is a unknown Window Codepage
    //    the conversion become UTF78 <-> Unicode <-> Window Codepage
    // 2) Second time unknown, assume it is a unknown Internet Encoding
    //    the conversion become Windows Codepage <-> Unicode <-> Internet Encoding
    else
    {
        if ( !CONVERT_IS_VALIDCODEPAGE(dwDstEncoding))
            goto fail ;

        if ( unknown == 0 )
        {
            if ( _dwWinCodePage )
            {
                if (_dwWinCodePage != dwDstEncoding )
                    goto fail ;
            }

            DstFlag = 0x02 ;
            _dwWinCodePage = dwDstEncoding ;
        }
        else
        {
            DstFlag = 0x11 ;
            _dwInternetEncoding = dwDstEncoding ;
        }
    }

    if ( !SrcFlag | !DstFlag )
        goto fail ;

    if ( SrcFlag == DstFlag && *pdwSrcEncoding != dwDstEncoding && ( 4 != SrcFlag ) && ( 8 != SrcFlag ))
        goto fail ;

    _dwConvertType = SrcFlag | DstFlag ;

    _bConvertDirt = ( SrcFlag & 0x0f ) > ( DstFlag & 0x0f )  ;

    // if code convertor has been allocated, deallocate it
    if (_hcins)
    {
        delete _hcins ;
        _hcins = NULL ;
    }

    return S_OK ;

fail :
    return S_FALSE ;
}


HRESULT CICharConverter::DoCodeConvert(LPDWORD lpdwMode, LPCSTR lpSrcStr, LPINT lpnSrcSize,
    LPSTR lpDstStr, LPINT lpnDstSize, DWORD dwFlag, WCHAR *lpFallBack)
{
    HRESULT hr = S_OK ;

    if ( 4 == _dwConvertType ) // CP_UCS_2 <-> CP_UCS_2_BE 
    {
        if (!lpDstStr)
        {   
            _nSrcSize = *lpnDstSize = *lpnSrcSize ;
        }
        else
        {
            int nSize = min(*lpnDstSize,*lpnSrcSize);

            _nSrcSize = *lpnSrcSize ;
            if ( lpDstStr && nSize > 0 )
            {
                MoveMemory(lpDstStr, lpSrcStr, nSize );
                DataByteSwap(lpDstStr, nSize );
                _nSrcSize = nSize ;
                *lpnDstSize = nSize ;
            }
        }
    }
    else if ( 8 == _dwConvertType) // UTF7 <-> UTF8
    {
        if (_dwUTFEncoding == _dwUTFEncoding2)
        {
            _nSrcSize = *lpnDstSize = min(*lpnDstSize,*lpnSrcSize);
            if (*lpnDstSize > 0)
                MoveMemory(lpDstStr, lpSrcStr, *lpnDstSize);
        }
        else
        {
            int nBuffSize = 0;
            // Always succeeds
            hr = UTF78ToUnicode(lpdwMode, lpSrcStr, lpnSrcSize, NULL, &nBuffSize);
            if (_lpInterm1Str)
                LocalFree(_lpInterm1Str);
            if ( _lpInterm1Str= (LPSTR)LocalAlloc(LPTR, nBuffSize) )
            {            
                DWORD dwTmpEncoding = _dwUTFEncoding;
                int nTmpSrcSize;

                hr = UTF78ToUnicode(lpdwMode, lpSrcStr, lpnSrcSize, _lpInterm1Str, &nBuffSize);                
                _dwUTFEncoding = _dwUTFEncoding2 ;
                nTmpSrcSize = _nSrcSize;
                // We don't need to create another dwMode since only UTF7 conversion needs it
                hr = UnicodeToUTF78(lpdwMode, _lpInterm1Str, &nBuffSize, lpDstStr, lpnDstSize);
                _nSrcSize = nTmpSrcSize;
                _dwUTFEncoding = dwTmpEncoding ;
            }
            else
                hr = E_OUTOFMEMORY;
        }
    }
    else if ( _bConvertDirt )
        hr = ConvertUUWI(lpdwMode, lpSrcStr,lpnSrcSize,lpDstStr,lpnDstSize, dwFlag, lpFallBack);
    else
        hr = ConvertIWUU(lpdwMode, lpSrcStr,lpnSrcSize,lpDstStr,lpnDstSize, dwFlag, lpFallBack);

    return hr ;
}

BOOL CICharConverter::ConvertCleanUp()
{
    if (_lpInterm1Str)
    {
         LocalFree(_lpInterm1Str);
         _lpInterm1Str = NULL ;
    }
    if (_lpInterm2Str)
    {
         LocalFree(_lpInterm2Str);
         _lpInterm2Str = NULL ;
    }
    if (_lpUnicodeStr)
    {
         LocalFree(_lpUnicodeStr);
         _lpUnicodeStr = NULL ;
    }
    _cvt_count = 0 ;
    _nSrcSize = 0 ;

    return TRUE ;
}

CICharConverter::CICharConverter()
{
    _lpInterm1Str = NULL ;
    _lpInterm2Str = NULL ;
    _lpUnicodeStr = NULL ;
    _hcins = NULL ;
    _cvt_count = 0 ;
    _dwWinCodePage = 0;
    _dwInternetEncoding = 0;
    _dwUTFEncoding = 0;
    _dwUTFEncoding2 = 0;
    _dwUnicodeEncoding = 0;
    _dwConvertType = 0;
    _nSrcSize = 0 ;
    _hcins_dst = 0 ;

    return ;
}

CICharConverter::CICharConverter(DWORD dwFlag, WCHAR *lpFallBack)
{
    _lpInterm1Str = NULL ;
    _lpInterm2Str = NULL ;
    _lpUnicodeStr = NULL ;
    _hcins = NULL ;
    _cvt_count = 0 ;
    _dwWinCodePage = 0;
    _dwInternetEncoding = 0;
    _dwUTFEncoding = 0;
    _dwUTFEncoding2 = 0;
    _dwUnicodeEncoding = 0;
    _dwConvertType = 0;
    _nSrcSize = 0 ;
    _hcins_dst = 0 ;
    _dwFlag = dwFlag;
    _lpFallBack = lpFallBack;

    return ;
}


CICharConverter::~CICharConverter()
{
    if (_lpInterm1Str)
    {
         LocalFree(_lpInterm1Str);
         _lpInterm1Str = NULL ;
    }
    if (_lpInterm2Str)
    {
         LocalFree(_lpInterm2Str);
         _lpInterm2Str = NULL ;
    }
    if (_lpUnicodeStr)
    {
         LocalFree(_lpUnicodeStr);
         _lpUnicodeStr = NULL ;
    }
    if (_hcins)
    {
        delete _hcins ;
        _hcins = NULL ;
    }
}

CICharConverter::CICharConverter(DWORD dwSrcEncoding, DWORD dwDstEncoding)
{
    _lpInterm1Str = NULL ;
    _lpInterm2Str = NULL ;
    _lpUnicodeStr = NULL ;
    _hcins = NULL ;
    _cvt_count = 0 ;
    _dwWinCodePage = 0;
    _dwInternetEncoding = 0;
    _dwUTFEncoding = 0;
    _dwUTFEncoding2 = 0;
    _dwUnicodeEncoding = 0;
    _dwConvertType = 0;
    _nSrcSize = 0 ;
    _hcins_dst = 0 ;
    
    ConvertSetup(&dwSrcEncoding,dwDstEncoding);
    return ;
}

HRESULT WINAPI IsConvertINetStringAvailable(DWORD dwSrcEncoding, DWORD dwDstEncoding)
{
    HRESULT hr;
    CICharConverter * INetConvert = new CICharConverter ;

    if (!INetConvert)
        return E_OUTOFMEMORY;

    hr = INetConvert->ConvertSetup(&dwSrcEncoding, dwDstEncoding);
    delete INetConvert;

    return hr ;
}

#define DETECTION_BUFFER_NUM    3


// In CP_AUTO and detection result is UTF7 case, private converter might use high word of *lpdwMode to store internal data, but we need 
// to use it to notify Trident the detection result, currently, we bias to returning correct detection result.
// This is currently by design. If we get a change to re-prototype conversion object, we can resovle this issue
HRESULT WINAPI ConvertINetStringEx(LPDWORD lpdwMode, DWORD dwSrcEncoding, DWORD dwDstEncoding, LPCSTR lpSrcStr, LPINT lpnSrcSize, LPSTR lpDstStr, LPINT lpnDstSize, DWORD dwFlag, WCHAR *lpFallBack)
{
    CICharConverter * INetConvert;
    int nSrcSize;
    int nDstSize;
    DWORD   dwMode = 0 ;
    // dwDetectResult 
    // CP_UNDEFINED :Fail to detect
    //      0       :Not a auto-detect scenario
    // Others       :Detected encoding
    DWORD   dwDetectResult = CP_UNDEFINED;
    HRESULT hr ;

    if(lpnSrcSize)
    {
        nSrcSize = *lpnSrcSize;
    }
    else
        nSrcSize = -1;

    if ( lpSrcStr && nSrcSize == -1 ) // Get length of lpSrcStr if not given, assuming lpSrcStr is a zero terminate string.
    {
        if ( dwSrcEncoding == CP_UCS_2 )
            nSrcSize = (lstrlenW((WCHAR*)lpSrcStr) << 1) ;
        else
            nSrcSize = lstrlenA(lpSrcStr) ;
    }

    // If there is nothing need to be converted, we return S_OK;
    if (!nSrcSize || !lpSrcStr)
    {
        if (lpnDstSize)
           *lpnDstSize = 0;
        return S_OK;
    }

    INetConvert = new CICharConverter(dwFlag, lpFallBack) ;    

    if (!INetConvert)
        return E_OUTOFMEMORY;

    // ASSERT(CP_AUTO != dwDstEncoding);

    // if null specified at dst buffer we'll get the size of required buffer.
    if(!lpDstStr)
        nDstSize = 0;
    else if (lpnDstSize)
        nDstSize = *lpnDstSize;
    else 
        nDstSize = 0;

    if (lpdwMode)
        dwMode = *lpdwMode ;

    // In real world, clients uses 28591 as 1252, 28599 as 1254, 
    // To correctly convert those extended characters to Unicode,
    // We internally replace it with 1252 
    if (dwDstEncoding == CP_UCS_2 || dwDstEncoding == CP_UCS_2_BE)
    {
        if ((dwSrcEncoding == CP_ISO_8859_1) && _IsValidCodePage(CP_1252))
            dwSrcEncoding = CP_1252;

        if ((dwSrcEncoding == CP_ISO_8859_9) && _IsValidCodePage(CP_1254))
            dwSrcEncoding = CP_1254;
    }

    if ((dwDstEncoding == CP_1252) && (dwSrcEncoding == CP_ISO_8859_1))
    {
        dwSrcEncoding = CP_1252;
    }

    if ((dwDstEncoding == CP_1254) && (dwSrcEncoding == CP_ISO_8859_9))
    {
        dwSrcEncoding = CP_1254;
    }

    //
    // Auto Detection for Japan
    // Japanese user often tag their data incorrectly, so, if MLCONVCHARF_DETECTJPN specified, 
    // we'll do extra detection for Shift-Jis and EUC
    //
    if ( dwSrcEncoding == CP_JP_AUTO ||                                 
        ((dwFlag & MLCONVCHARF_DETECTJPN) && 
        (dwSrcEncoding == CP_JPN_SJ || dwSrcEncoding == CP_EUC_JP))) // Auto Detection for Japan
    {        
        CIncdJapanese DetectJapan(dwSrcEncoding);
        UINT uiCodePage ;

        uiCodePage = ( dwMode >> 16 ) & 0xffff ;
        if ( uiCodePage )
        {
            dwSrcEncoding = uiCodePage ;
            dwDetectResult = 0;
        }
        else
        {
            dwSrcEncoding = DetectJapan.DetectStringA(lpSrcStr, nSrcSize);
            // if dwSrcEncoding is zero means there is an ambiguity, we don't return
            // the detected codepage to caller, instead we defaut its codepage internally
            // to SJIS
            if (dwSrcEncoding)
            {
                dwDetectResult = dwSrcEncoding << 16 ;
            }
            else
                dwSrcEncoding = CP_JPN_SJ;
        }
    }
    // bug #43190, we auto-detect again for euc-kr page because IMN ver 1.0
    // mislabel an ISO-KR page as a ks_c_5601-1987 page. This is the only way 
    // we can fix that mistake. 
    else if ( dwSrcEncoding == CP_KR_AUTO || dwSrcEncoding == CP_KOR_5601 ||
        dwSrcEncoding == CP_EUC_KR )
    {
        CIncdKorean DetectKorean;
        UINT uiCodePage ;

        uiCodePage = ( dwMode >> 16 ) & 0xffff ;
        if ( uiCodePage )
        {
            dwSrcEncoding = uiCodePage ;
            dwDetectResult = 0;
        }
        else
        {
            dwSrcEncoding = DetectKorean.DetectStringA(lpSrcStr, nSrcSize);
            if (dwSrcEncoding)
            {
                dwDetectResult = dwSrcEncoding << 16 ;
            }
            else
                dwSrcEncoding = CP_KOR_5601;
        }

    }
    else if ( dwSrcEncoding == CP_AUTO ) // General Auto Detection for all code pages
    {
        int _nSrcSize = DETECTION_MAX_LEN < nSrcSize ?  DETECTION_MAX_LEN : nSrcSize;
        int nScores = DETECTION_BUFFER_NUM;
        DetectEncodingInfo Encoding[DETECTION_BUFFER_NUM];
        UINT uiCodePage ;


        uiCodePage = ( dwMode >> 16 ) & 0xffff ;
        if ( uiCodePage )
        {
            dwSrcEncoding = uiCodePage ;
            dwDetectResult = 0;
        }
        else
        {
            dwSrcEncoding = g_uACP;
            if ( S_OK == _DetectInputCodepage(MLDETECTCP_HTML, CP_AUTO, (char *)lpSrcStr, &_nSrcSize, &Encoding[0], &nScores))
            {
                MIMECPINFO cpInfo;

                if (Encoding[0].nCodePage == CP_20127)
                    Encoding[0].nCodePage = dwSrcEncoding;

                if (NULL != g_pMimeDatabase)
                {
                    if (SUCCEEDED(g_pMimeDatabase->GetCodePageInfo(Encoding[0].nCodePage, 0x409, &cpInfo)) && 
                        (cpInfo.dwFlags & MIMECONTF_VALID))
                    {
                        dwSrcEncoding = Encoding[0].nCodePage;     
                        dwDetectResult = dwSrcEncoding << 16 ;  
                    }
                }
            }

            // If we failed in general detection and system locale is Jpn, we try harder 
            // with our Japanese detection engine
            if (dwSrcEncoding == CP_JPN_SJ && dwDetectResult == CP_UNDEFINED)
            {
                CIncdJapanese DetectJapan;
                DWORD dwSrcEncodingJpn = DetectJapan.DetectStringA(lpSrcStr, nSrcSize);
                if (dwSrcEncodingJpn)
                {
                    // We only change conversion encoding without returnning this result to browser 
                    // if it is in the middle of detection, this is to prevent other encodings been mis-detected as Jpn encodings.
                    dwSrcEncoding = dwSrcEncodingJpn;   
                    
                    // Set search range for end tag as 10 bytes
                    if (nSrcSize >= 10)
                    {
                        char szTmpStr[11] = {0};
                        char *lpTmpStr = szTmpStr;
                        _tcsncpy(szTmpStr, (char *)&lpSrcStr[nSrcSize-10], 10);                        

                        //ToLower
                        while(*lpTmpStr)
                        {
                            if (*lpTmpStr >= 'A' && *lpTmpStr <= 'W')
                                *lpTmpStr += 0x20;
                            lpTmpStr++;
                        }

                        // If end of page, return this result
                        if (MLStrStr(szTmpStr, "</html>"))
                            dwDetectResult = dwSrcEncoding << 16 ;  
                    }

                }
            }
            //aEncodingInfo[GetWindowsEncodingIndex(CP_AUTO)].dwCodePage = dwSrcEncoding;         
        }     
    }
    else
    {
        // Not a auto-detect scenario
        dwDetectResult = 0;
    }

    if ( S_OK == ( hr = INetConvert->ConvertSetup(&dwSrcEncoding,dwDstEncoding )))
    {
       if ( dwSrcEncoding != dwDstEncoding )
       {
            // if high word of dwMode is CP_UTF_7, it must be detection result, don't pass it to UTF7 converter
            if ( dwSrcEncoding == CP_UTF_7 && (dwMode >> 16) == CP_UTF_7)
                dwMode &= 0xFFFF;
            // ASSERT(!((IS_ENCODED_ENCODING(dwSrcEncoding) || IS_ENCODED_ENCODING(dwDstEncoding)) && (NULL == lpdwMode)));
            hr = INetConvert->DoCodeConvert(&dwMode, lpSrcStr, &nSrcSize, lpDstStr, &nDstSize, dwFlag, lpFallBack);

            // return the number of bytes processed for the source. 
            if (lpnSrcSize)
                *lpnSrcSize = INetConvert->_nSrcSize ;
            INetConvert->ConvertCleanUp();
       }
       else
       {
            int nSize, i ;
            hr = S_OK ;
            BOOL bLeadByte = FALSE ;

            // only check for windows codepage
            if ( INetConvert->_dwConvertType == 02 && lpSrcStr )
            { 
                for ( i=0; i<nSrcSize; i++)
                {
                   if (bLeadByte)
                       bLeadByte = FALSE ;
                   else if (IsDBCSLeadByteEx(dwSrcEncoding,lpSrcStr[i]))
                       bLeadByte = TRUE ;
                }
                if (bLeadByte)
                    nSrcSize-- ;
            }
            // set input size
            if (lpnSrcSize)
                *lpnSrcSize = nSrcSize ;
            // set output size and copy if we need to
            if (lpDstStr && *lpnDstSize)
            {
                nSize = min(*lpnDstSize,nSrcSize);
                MoveMemory(lpDstStr, lpSrcStr, nSize);
                nDstSize = nSize ;
            }
            else
                nDstSize = nSrcSize ;
       }
    }
    else
            nDstSize = 0 ;

    delete INetConvert;

    // return the number of bytes copied for the destination,
    if (lpnDstSize)
        *lpnDstSize = nDstSize;

    if (lpdwMode && lpDstStr)
    {        
        if (dwDetectResult)                     // CP_AUTO conversion
        {
            dwMode &= 0xFFFF;                   // Clear HIGHWORD in case private converter set it
            // If we have detection result, return it in HIGHWORD
            // in the case of UTF7 conversion, private converter might use high word to store internal data,
            // this will conflict with our logic of returning detection result in high word, it is a design flaw, 
            // currently, we ignore conversion setting and give detection result more priority
            if (dwDetectResult != CP_UNDEFINED) 
                dwMode |= dwDetectResult;
        }
        *lpdwMode = dwMode ;
    }

    return hr ;
}

// We already published this API, keep it for backward compatibility
HRESULT WINAPI ConvertINetReset(void)
{
    // Always suceed
    return S_OK ;
}

HRESULT WINAPI ConvertINetMultiByteToUnicodeEx(LPDWORD lpdwMode, DWORD dwEncoding, LPCSTR lpSrcStr, LPINT lpnMultiCharCount, LPWSTR lpDstStr, LPINT lpnWideCharCount, DWORD dwFlag, WCHAR *lpFallBack)
{
    HRESULT hr ;
    int nByteCountSize = 0;

    if (lpnWideCharCount)
    {
        nByteCountSize = *lpnWideCharCount * sizeof(WCHAR);
    }

#ifdef UNIX
   int saved_nByteCountSize = nByteCountSize;
#endif /* UNIX */

    hr = ConvertINetStringEx(lpdwMode,dwEncoding, CP_UCS_2, lpSrcStr, lpnMultiCharCount, (LPSTR)lpDstStr, &nByteCountSize, dwFlag, lpFallBack) ;

#ifdef UNIX
    if(dwEncoding == 1200 || dwEncoding == 65000 || dwEncoding == 65001 ||
       (dwEncoding == 50001 && !_IsValidCodePage(dwEncoding)) )
    {
        /*
         * On unix we need to convert the little endian mode 2 byte unicode
         * format to unix mode 4 byte wChars.
         */
        if(lpDstStr && (saved_nByteCountSize < (nByteCountSize/2)*sizeof(WCHAR)))
            hr = E_FAIL;
        else
        {
            /*
             * Use a temporary array to do the 2byte -> 4byte conversion
             */
            LPSTR pTmp = (LPSTR) lpDstStr;
            LPWSTR pw4 = NULL;

            if(pTmp) /* allocate only if we have a lpDstStr */
                pw4 = new WCHAR[nByteCountSize/2];
            if(pw4)
            {
                int i = 0;
                LPWSTR pw4Tmp = pw4;
                for(; i < nByteCountSize/2; i++)
                    *pw4Tmp++ = (UCHAR)pTmp[i*2];
                pw4Tmp = pw4;
                for(i = 0; i < nByteCountSize/2; i++)
                    *lpDstStr++ = *pw4Tmp++;
            }
            if(!pw4 && pTmp) /* if lpDstStr and allocate fails bail out */
                hr = E_FAIL;
            delete [] pw4;
        }
        nByteCountSize *= 2; // Expand twice as we have 4 byte wchars.
    }
#endif
    *lpnWideCharCount = nByteCountSize / sizeof(WCHAR);

    return hr ;
}


HRESULT WINAPI ConvertINetUnicodeToMultiByteEx(LPDWORD lpdwMode, DWORD dwEncoding, LPCWSTR lpSrcStr, LPINT lpnWideCharCount, LPSTR lpDstStr, LPINT lpnMultiCharCount, DWORD dwFlag, WCHAR *lpFallBack)
{
    HRESULT hr ;
    int nByteCountSize=-1;

    if(lpnWideCharCount && *lpnWideCharCount != -1) 
        nByteCountSize = *lpnWideCharCount * sizeof(WCHAR);

    hr = ConvertINetStringEx(lpdwMode,CP_UCS_2, dwEncoding, (LPCSTR) lpSrcStr, &nByteCountSize, lpDstStr, lpnMultiCharCount, dwFlag, lpFallBack);

#ifdef UNIX
    if(dwEncoding == 1200 || dwEncoding == 65000 || dwEncoding == 65001) {
        nByteCountSize *= 2; // Expand twice as we have 4 byte wchars.
    }
#endif /* UNIX */

    if (lpnWideCharCount)
        *lpnWideCharCount = nByteCountSize / sizeof(WCHAR);

    return hr ;
}

HRESULT WINAPI ConvertINetString(LPDWORD lpdwMode, DWORD dwSrcEncoding, DWORD dwDstEncoding, LPCSTR lpSrcStr, LPINT lpnSrcSize, LPSTR lpDstStr, LPINT lpnDstSize)
{
    HRESULT hr ;

    hr = ConvertINetStringEx(lpdwMode,dwSrcEncoding,dwDstEncoding,lpSrcStr,lpnSrcSize,lpDstStr,lpnDstSize, 0, NULL);

    return hr ;
}

HRESULT WINAPI ConvertINetUnicodeToMultiByte(LPDWORD lpdwMode, DWORD dwEncoding, LPCWSTR lpSrcStr, LPINT lpnWideCharCount, LPSTR lpDstStr, LPINT lpnMultiCharCount)
{
    HRESULT hr ;
    DWORD dwFlag = 0 ;

    if ( lpdwMode )
        dwFlag |= ( *lpdwMode & 0x00008000 ) ? MLCONVCHARF_ENTITIZE : 0 ;

    hr = ConvertINetUnicodeToMultiByteEx(lpdwMode,dwEncoding,lpSrcStr,lpnWideCharCount,lpDstStr,lpnMultiCharCount,dwFlag,NULL);

    return hr ;
}

HRESULT WINAPI ConvertINetMultiByteToUnicode(LPDWORD lpdwMode, DWORD dwEncoding, LPCSTR lpSrcStr, LPINT lpnMultiCharCount, LPWSTR lpDstStr, LPINT lpnWideCharCount)
{
    HRESULT hr ;

    hr = ConvertINetMultiByteToUnicodeEx(lpdwMode,dwEncoding,lpSrcStr,lpnMultiCharCount,lpDstStr,lpnWideCharCount, 0, NULL);

    return hr ;
}

#define STR_BUFFER_SIZE 2048

HRESULT _ConvertINetStringInIStream(CICharConverter * INetConvert, LPDWORD lpdwMode, DWORD dwSrcEncoding, DWORD dwDstEncoding, IStream *pstmIn, IStream *pstmOut, DWORD dwFlag, WCHAR *lpFallBack)
{
    DWORD   dwMode, dwModeTemp ;
    HRESULT hr= S_OK, hrWarnings=S_OK;
    LPSTR lpstrIn = NULL, lpstrOut = NULL; 
    ULONG nSrcSize, nSrcUsed, nSrcLeft, nDstSize, _nDstSize, nOutBuffSize ;

    if (lpdwMode)
        dwMode = *lpdwMode ;

    // allocate a temp input buffer - 2K in size
    if ( (lpstrIn = (LPSTR) LocalAlloc(LPTR, STR_BUFFER_SIZE )) == NULL )
    {
        hrWarnings = E_OUTOFMEMORY ;
        goto exit;
    }

    if ( (lpstrOut = (LPSTR) LocalAlloc(LPTR, STR_BUFFER_SIZE * 2 )) == NULL )
    {
        hrWarnings = E_OUTOFMEMORY ;
        goto exit;
    }

    nOutBuffSize = STR_BUFFER_SIZE * 2 ;
    nSrcLeft = 0 ;

    // In real world, clients uses 28591 as 1252, 28599 as 1254, 
    // To correctly convert those extended characters to Unicode,
    // We internally replace it with 1252 
    if (dwDstEncoding == CP_UCS_2 || dwDstEncoding == CP_UCS_2_BE)
    {
        if ((dwSrcEncoding == CP_ISO_8859_1) && _IsValidCodePage(CP_1252))
            dwSrcEncoding = CP_1252;

        if ((dwSrcEncoding == CP_ISO_8859_9) && _IsValidCodePage(CP_1254))
            dwSrcEncoding = CP_1254;
    }

    if ((dwDstEncoding == CP_1252) && (dwSrcEncoding == CP_ISO_8859_1))
    {
        dwSrcEncoding = CP_1252;
    }

    if ((dwDstEncoding == CP_1254) && (dwSrcEncoding == CP_ISO_8859_9))
    {
        dwSrcEncoding = CP_1254;
    }


    if ( dwSrcEncoding == CP_JP_AUTO ) // Auto Detection for Japan
    {
        CIncdJapanese DetectJapan;
        UINT uiCodePage ;
        LARGE_INTEGER   li;

        uiCodePage = ( dwMode >> 16 ) & 0xffff ;
        if ( uiCodePage )
            dwSrcEncoding = uiCodePage ;
        else
        {
            LISet32(li, 0);

            hr = pstmIn->Read(lpstrIn, STR_BUFFER_SIZE , &nSrcSize);
            if (S_OK != hr)
                hrWarnings = hr;
            hr = pstmIn->Seek(li,STREAM_SEEK_SET, NULL);
            if (S_OK != hr)
                hrWarnings = hr;

            dwSrcEncoding = DetectJapan.DetectStringA(lpstrIn, nSrcSize);
            // if dwSrcEncoding is zero means there is an ambiguity, we don't return
            // the detected codepage to caller, instead we defaut its codepage internally
            // to SJIS
            if (dwSrcEncoding)
            {
                dwMode &= 0x0000ffff ;
                dwMode |= dwSrcEncoding << 16 ; 
            }
            else
                dwSrcEncoding = CP_JPN_SJ;
        }
    }
    // bug #43190, we auto-detect again for euc-kr page because IMN ver 1.0
    // mislabel an ISO-KR page as a ks_c_5601-1987 page. This is the only way 
    // we can fix that mistake. 
    else if ( dwSrcEncoding == CP_KR_AUTO || dwSrcEncoding == CP_KOR_5601 ||
        dwSrcEncoding == CP_EUC_KR )
    {
        CIncdKorean DetectKorean;
        UINT uiCodePage ;
        LARGE_INTEGER   li;

        uiCodePage = ( dwMode >> 16 ) & 0xffff ;
        if ( uiCodePage )
            dwSrcEncoding = uiCodePage ;
        else
        {
            LISet32(li, 0);
            
            hr = pstmIn->Read(lpstrIn, STR_BUFFER_SIZE, &nSrcSize);
            if (S_OK != hr)
                hrWarnings = hr;
            hr = pstmIn->Seek(li,STREAM_SEEK_SET, NULL);
            if (S_OK != hr)
                hrWarnings = hr;
            dwSrcEncoding = DetectKorean.DetectStringA(lpstrIn, nSrcSize);
            if (dwSrcEncoding)
            {
                dwMode &= 0x0000ffff ;
                dwMode |= dwSrcEncoding << 16 ; 
            }
            else
                dwSrcEncoding = CP_KOR_5601;
        }
    }
    else if ( dwSrcEncoding == CP_AUTO ) // General Auto Detection for all code pages
    {
        INT nScores = 1;
        DWORD dwSrcEncoding ;
        DetectEncodingInfo Encoding;
        UINT uiCodePage ;
        LARGE_INTEGER   li;

        uiCodePage = ( dwMode >> 16 ) & 0xffff ;
        if ( uiCodePage )
            dwSrcEncoding = uiCodePage ;
        else
        {
            LISet32(li, 0);

            hr = pstmIn->Read(lpstrIn, STR_BUFFER_SIZE , &nSrcSize);
            if (S_OK != hr)
                hrWarnings = hr;
            hr = pstmIn->Seek(li,STREAM_SEEK_SET, NULL);
            if (S_OK != hr)
                hrWarnings = hr;

            if (DETECTION_MAX_LEN < nSrcSize)
                nSrcSize =  DETECTION_MAX_LEN;

            if ( S_OK == _DetectInputCodepage(MLDETECTCP_HTML, 1252, lpstrIn, (int *)&nSrcSize, &Encoding, &nScores))
            {
                dwSrcEncoding = Encoding.nCodePage;
                dwMode &= 0x0000ffff ;
                dwMode |= dwSrcEncoding << 16 ; 
            }
            else
            {
                dwSrcEncoding = CP_ACP;
            }
            aEncodingInfo[GetWindowsEncodingIndex(CP_AUTO)].dwCodePage = dwSrcEncoding;
        }
    }

    if ( S_OK == ( hr = INetConvert->ConvertSetup(&dwSrcEncoding,dwDstEncoding )))
    {
        // Loop for ever
        while(1)
        {
            // Read a buffer
            hr = pstmIn->Read(&lpstrIn[nSrcLeft], STR_BUFFER_SIZE-nSrcLeft, &nSrcSize);
            if (S_OK != hr)
                hrWarnings = hr;

            // Done
            if (0 == nSrcSize)
                break;

            nSrcSize += nSrcLeft ;
            nSrcUsed = nSrcSize ;
            dwModeTemp = dwMode ;
            nDstSize = 0 ;

            // get the size of output buffer
            hr = INetConvert->DoCodeConvert(&dwModeTemp, (LPCSTR)lpstrIn, (LPINT)&nSrcUsed, NULL, (LPINT)&nDstSize, dwFlag, lpFallBack);
            if (S_OK != hr)
                hrWarnings = hr;

            // Reallocate output buffer if so
            if ( nDstSize > nOutBuffSize )
            {
                LPSTR psz = (LPSTR) LocalReAlloc(lpstrOut, nDstSize, LMEM_ZEROINIT|LMEM_MOVEABLE);
                if (psz == NULL)
                {
                    hrWarnings = E_OUTOFMEMORY ;
                    goto exit;
                }
                lpstrOut = psz;
                nOutBuffSize = nDstSize ;
            }
            _nDstSize = nDstSize;

            // Due to multi_stage conversion, this is the actual size is used
            nSrcUsed = INetConvert->_nSrcSize ;
            nSrcLeft = nSrcSize - nSrcUsed ;

#if 0
            // restore Src size
            nSrcUsed = nSrcSize ;
#endif
            // do conversion
            hr = INetConvert->DoCodeConvert(&dwMode, (LPCSTR)lpstrIn, (LPINT)&nSrcUsed, lpstrOut, (LPINT)&_nDstSize, dwFlag, lpFallBack);
            if (S_OK != hr)
                hrWarnings = hr;

            // Write It
            hr = pstmOut->Write(lpstrOut, nDstSize, &nDstSize);
            if (S_OK != hr)
                hrWarnings = hr;

            if (nSrcLeft )
                MoveMemory(lpstrIn, &lpstrIn[nSrcSize-nSrcLeft],nSrcLeft);

            INetConvert->ConvertCleanUp();
        }
    }

    if (nSrcLeft )
    {
        LARGE_INTEGER   li;

        LISet32(li, -(LONG)nSrcLeft );
        hr = pstmIn->Seek(li,STREAM_SEEK_CUR, NULL);
    }

    if (lpdwMode)
        *lpdwMode = dwMode ;

exit :
    if (lpstrIn)
        LocalFree(lpstrIn);
    if (lpstrOut)
        LocalFree(lpstrOut);

    // Done
    return (hr == S_OK) ? hrWarnings : hr;
}


HRESULT WINAPI ConvertINetStringInIStream(LPDWORD lpdwMode, DWORD dwSrcEncoding, DWORD dwDstEncoding, IStream *pstmIn, IStream *pstmOut, DWORD dwFlag, WCHAR *lpFallBack)
{
    HRESULT hr;
    CICharConverter * INetConvert = new CICharConverter(dwFlag, lpFallBack) ;

    if (!INetConvert)
        return E_OUTOFMEMORY;

    hr = _ConvertINetStringInIStream(INetConvert,lpdwMode,dwSrcEncoding,dwDstEncoding,pstmIn,pstmOut,dwFlag,lpFallBack);

    delete INetConvert;

    return hr ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\mlang\jisobj.cpp ===
// ============================================================================
// Internet Character Set Conversion: Input from ISO-2022-JP
// ============================================================================

#include "private.h"
#include "fechrcnv.h"
#include "jisobj.h"

#include "codepage.h"

/******************************************************************************
**************************   C O N S T R U C T O R   **************************
******************************************************************************/

CInccJisIn::CInccJisIn(UINT uCodePage, int nCodeSet) : CINetCodeConverter(uCodePage, nCodeSet)
{
    Reset();    // initialization
    return ;
}

/******************************************************************************
*******************************   R E S E T   *********************************
******************************************************************************/

void CInccJisIn::Reset()
{
    m_pfnConv = ConvMain;   
    m_pfnCleanUp = CleanUpMain;
    m_fShift = FALSE;
    m_fJapan = FALSE;
    m_fLeadByte = FALSE ; 
    m_tcLeadByte = 0 ;
    m_nESCBytes = 0 ;
    m_eEscState = JIS_ASCII ; 
    return ;
}

/******************************************************************************
*************************   C O N V E R T   C H A R   *************************
******************************************************************************/

HRESULT CInccJisIn::ConvertChar(UCHAR tc, int cchSrc)
{
    BOOL fDone = (this->*m_pfnConv)(tc);
    if (fDone)
        return S_OK;
    else
        return E_FAIL;
}

/******************************************************************************
*****************************   C L E A N   U P   *****************************
******************************************************************************/

BOOL CInccJisIn::CleanUp()
{
    return (this->*m_pfnCleanUp)();
}

/******************************************************************************
****************************   C O N V   M A I N   ****************************
******************************************************************************/

BOOL CInccJisIn::ConvMain(UCHAR tc)
{
    BOOL fDone = TRUE;

    switch (tc) {
    case SO:
        m_fShift = TRUE;
        break;

    case SI:
        m_fShift = FALSE;
        m_fLeadByte = FALSE;
        break;

    default:
        if (m_fShift) {
            fDone = Output(tc | 0x80);
            // it may continue to convert to Unicode, so we need to know
            // whether current byte is a lead byte or not
            m_fLeadByte = ~m_fLeadByte ;
        } else {
            if (tc == ESC) {
                m_pfnConv = ConvEsc;
                m_pfnCleanUp = CleanUpEsc;
                m_nESCBytes++;
            } else {
                if (m_fJapan) {
                    if (tc == '*') {
                        m_pfnConv = ConvStar;
                        m_pfnCleanUp = CleanUpStar;
                    } else {
                        m_pfnConv = ConvDoubleByte;
                        m_pfnCleanUp = CleanUpDoubleByte;
                        m_tcLeadByte = tc;
                    }
                } else {
                    switch ( m_eEscState )
                    {
                        case JIS_ASCII:
                            fDone = Output(tc);
                            break ;
                        case JIS_Roman:
#if 0
                            if ( tc == 0x7e ) /* tilde in ACSII -> overline */
                            {
                                Output(0x81);
                                fDone = Output(0x50);
                            }
                            else
                                fDone = Output(tc);
#else
                            fDone = Output(tc);
#endif
                            break ;
                        case JIS_Kana:
                            fDone = Output(tc | 0x80 );
                            break ;
                        default:
                            fDone = Output(tc);
                            break ;
                    }
                }
            }
        }
        break;
    }
    return fDone;
}

/******************************************************************************
************************   C L E A N   U P   M A I N   ************************
******************************************************************************/

BOOL CInccJisIn::CleanUpMain()
{
    return TRUE;
}

/******************************************************************************
*****************************   C O N V   E S C   *****************************
******************************************************************************/

BOOL CInccJisIn::ConvEsc(UCHAR tc)
{
    switch (tc) {
    case ISO2022_IN_CHAR:
        m_pfnConv = ConvIsoIn;
        m_pfnCleanUp = CleanUpIsoIn;
        m_nESCBytes++;
        return TRUE;

    case ISO2022_OUT_CHAR:
        m_pfnConv = ConvIsoOut;
        m_pfnCleanUp = CleanUpIsoOut;
        m_nESCBytes++;
        return TRUE;

    default:
        m_pfnConv = ConvMain;
        m_pfnCleanUp = CleanUpMain;
        m_nESCBytes = 0 ;
        (void)Output(ESC);
        if (SUCCEEDED(ConvertChar(tc)))
            return TRUE;
        else
            return FALSE;
    }
}

/******************************************************************************
*************************   C L E A N   U P   E S C   *************************
******************************************************************************/

BOOL CInccJisIn::CleanUpEsc()
{
    m_pfnConv = ConvMain;
    m_pfnCleanUp = CleanUpMain;
    return Output(ESC);
}

/******************************************************************************
**************************   C O N V   I S O   I N   **************************
******************************************************************************/

BOOL CInccJisIn::ConvIsoIn(UCHAR tc)
{
    switch (tc) {
    case ISO2022_IN_JP_CHAR1:       /* 'B' */
    case ISO2022_IN_JP_CHAR2:       /* '@' */
        m_pfnConv = ConvMain;
        m_pfnCleanUp = CleanUpMain;
        m_fJapan = TRUE;
        m_nESCBytes = 0 ;
        return TRUE;

    case ISO2022_IN_JP_CHAR3_1:     /* '(' */
        m_pfnConv = ConvIsoInJp;
        m_pfnCleanUp = CleanUpIsoInJp;
        m_nESCBytes++ ;
        return TRUE;

    default:
        m_pfnConv = ConvMain;
        m_pfnCleanUp = CleanUpMain;
        m_nESCBytes = 0 ;
        (void)Output(ESC);
        (void)ConvertChar(ISO2022_IN_CHAR);
        if (SUCCEEDED(ConvertChar(tc)))
            return TRUE;
        else
            return FALSE;
    }
}

/******************************************************************************
**********************   C L E A N   U P   I S O   I N   **********************
******************************************************************************/

BOOL CInccJisIn::CleanUpIsoIn()
{
    m_pfnConv = ConvMain;
    m_pfnCleanUp = CleanUpMain;

    (void)Output(ESC);
    (void)ConvertChar(ISO2022_IN_CHAR);
    return CleanUp();
}

/******************************************************************************
***********************   C O N V   I S O   I N   J P   ***********************
******************************************************************************/

BOOL CInccJisIn::ConvIsoInJp(UCHAR tc)
{
    m_pfnConv = ConvMain;
    m_pfnCleanUp = CleanUpMain;
    m_nESCBytes = 0 ;

    if (tc == ISO2022_IN_JP_CHAR3_2) {
        m_fJapan = TRUE;
        return TRUE;
    } else {
        (void)Output(ESC);
        (void)ConvertChar(ISO2022_IN_CHAR);
        (void)ConvertChar(ISO2022_IN_JP_CHAR3_1);
        if (SUCCEEDED(ConvertChar(tc)))
            return TRUE;
        else
            return FALSE;
    }
}

/******************************************************************************
*******************   C L E A N   U P   I S O   I N   J P   *******************
******************************************************************************/

BOOL CInccJisIn::CleanUpIsoInJp()
{
    m_pfnConv = ConvMain;
    m_pfnCleanUp = CleanUpMain;
    m_nESCBytes = 0 ;

    (void)Output(ESC);
    (void)ConvertChar(ISO2022_IN_CHAR);
    (void)ConvertChar(ISO2022_IN_JP_CHAR3_1);
    return CleanUp();
}

/******************************************************************************
*************************   C O N V   I S O   O U T   *************************
******************************************************************************/

BOOL CInccJisIn::ConvIsoOut(UCHAR tc)
{
    m_pfnConv = ConvMain;
    m_pfnCleanUp = CleanUpMain;
    m_nESCBytes = 0 ;

    switch (tc) {
    case ISO2022_OUT_JP_CHAR1:  /* B */
        m_fJapan = FALSE;
        m_eEscState = JIS_ASCII ;
        return TRUE;

    case ISO2022_OUT_JP_CHAR2:  /* J */
    case ISO2022_OUT_JP_CHAR4:  /* H */
        m_fJapan = FALSE;
        m_eEscState = JIS_Roman ;
        return TRUE;       

    case ISO2022_OUT_JP_CHAR3: /* I */
        m_fJapan = FALSE;
        m_eEscState = JIS_Kana ; 
        return TRUE;       

    default:
        (void)Output(ESC);
        (void)ConvertChar(ISO2022_OUT_CHAR);
        if (SUCCEEDED(ConvertChar(tc)))
            return TRUE;
        else
            return FALSE;
    }
}

/******************************************************************************
*********************   C L E A N   U P   I S O   O U T   *********************
******************************************************************************/

BOOL CInccJisIn::CleanUpIsoOut()
{
    m_pfnConv = ConvMain;
    m_pfnCleanUp = CleanUpMain;
    m_nESCBytes = 0 ;

    (void)Output(ESC);
    (void)ConvertChar(ISO2022_OUT_CHAR);
    return CleanUp();
}

/******************************************************************************
****************************   C O N V   S T A R   ****************************
******************************************************************************/

BOOL CInccJisIn::ConvStar(UCHAR tc)
{
    m_pfnConv = ConvMain;
    m_pfnCleanUp = CleanUpMain;

    return Output(tc | 0x80);
}

/******************************************************************************
************************   C L E A N   U P   S T A R   ************************
******************************************************************************/

BOOL CInccJisIn::CleanUpStar()
{
    m_pfnConv = ConvMain;
    m_pfnCleanUp = CleanUpMain;

    return Output('*');
}

/******************************************************************************
*********************   C O N V   D O U B L E   B Y T E   *********************
******************************************************************************/

BOOL CInccJisIn::ConvDoubleByte(UCHAR tc)
{
    BOOL bRet ;
    UCHAR tcSJisLB;
    UCHAR tcSJisTB;

    m_pfnConv = ConvMain;
    m_pfnCleanUp = CleanUpMain;

    tcSJisLB = ((m_tcLeadByte - 0x21) >> 1) + 0x81;
    if (tcSJisLB > 0x9f)
        tcSJisLB += 0x40;

    tcSJisTB = tc + (m_tcLeadByte & 1 ? 0x1f : 0x7d);
    if (tcSJisTB >= 0x7f)
        tcSJisTB++;

    (void)Output(tcSJisLB);
    bRet = Output(tcSJisTB);

    m_tcLeadByte = 0 ;
    return bRet ;
}

/******************************************************************************
*****************   C L E A N   U P   D O U B L E   B Y T E   *****************
******************************************************************************/

BOOL CInccJisIn::CleanUpDoubleByte()
{
    BOOL bRet ;
    m_pfnConv = ConvMain;
    m_pfnCleanUp = CleanUpMain;

    bRet = Output(m_tcLeadByte);
    m_tcLeadByte = 0 ;
    return bRet ;
}

int CInccJisIn::GetUnconvertBytes()
{
    if ( m_tcLeadByte || m_fLeadByte )
        return 1 ;
    else if ( m_nESCBytes )
        return m_nESCBytes < 4 ? m_nESCBytes : 3 ;
    else
        return 0 ;
}

DWORD CInccJisIn::GetConvertMode()
{
    // 0xC42C -> 50220 ISO-2022-JP
    return ( m_fJapan ? 1 : 0 ) + ( m_fShift ? 2 : 0 ) | 0xC42C0000 ;
}

void CInccJisIn::SetConvertMode(DWORD mode)
{
    Reset();
    if ( mode & 0x00000001 )
        m_fJapan = TRUE ;
    if ( mode & 0x00000002 ) 
        m_fShift = TRUE ;

    return ;
}

// ============================================================================
// Internet Character Set Conversion: Output to ISO-2022-JP
// ============================================================================

#define VOICE_MARK_OFFSET       0xA0
#define VOICE_MARK_DEDF_OFFSET  0xC8

#if 0   // Shift JIS Table - not used
// this is the table used to determine whether the kana char is voiced sound markable
// if it is, what is the combined full width kana.
static WCHAR g_wVoiceMarkKana[48] =
{
  /*               0,      1,      2,      3,      4,      5,      6,      7,      8,      9,      A,      B,      C,      D,      E,      F, */

  /* a0-af */    0x0,    0x0,    0x0,    0x0,    0x0,    0x0,    0x0,    0x0,    0x0, 0x8394,    0x0,    0x0,    0x0,    0x0,    0x0,    0x0,
  /* b0-bf */    0x0,    0x0,    0x0,    0x0,    0x0,    0x0, 0x834B, 0x834D, 0x834f, 0x8351, 0x8353, 0x8355, 0x8357, 0x8359, 0x835B, 0x835D,
  /* c0-cf */ 0x835F, 0x8361, 0x8364, 0x8366, 0x8368,    0x0,    0x0,    0x0,    0x0,    0x0, 0x836F, 0x8372, 0x8375, 0x8378, 0x837B,    0x0,

};

// special voiced sound mark '0xde' conversion
static WCHAR g_wMarkDEKana[16] =
{
  /* c8-cf */  0x0, 0x0, 0x836F, 0x8372, 0x8375, 0x8378, 0x837B, 0x0,
};


// special voiced sound mark '0xdf' conversion
static WCHAR g_wMarkDFKana[16] =
{
  /* c8-cf */ 0x0, 0x0, 0x8370, 0x8373, 0x8376, 0x8379, 0x837C, 0x0,
};

// this is the table used to convert half width kana to full width kana
static WCHAR g_wFullWKana[64] =
{
  /*               0,      1,      2,      3,      4,      5,      6,      7,      8,      9,      A,      B,      C,      D,      E,      F, */

  /* a0-af */    0x0, 0x8142, 0x8175, 0x8176, 0x8141, 0x8145, 0x8392, 0x8340, 0x8342, 0x8344, 0x8346, 0x8348, 0x8383, 0x8385, 0x8387, 0x8362,
  /* b0-bf */ 0x815B, 0x8341, 0x8343, 0x8345, 0x8347, 0x8349, 0x834A, 0x834C, 0x834E, 0x8350, 0x8352, 0x8354, 0x8356, 0x8358, 0x835A, 0x835C,
  /* c0-cf */ 0x835E, 0x8360, 0x8363, 0x8365, 0x8367, 0x8369, 0x836A, 0x836B, 0x836C, 0x836D, 0x836E, 0x8371, 0x8374, 0x8377, 0x837A, 0x837D,
  /* d0-df */ 0x837E, 0x8380, 0x8381, 0x8382, 0x8384, 0x8386, 0x8388, 0x8389, 0x838A, 0x838B, 0x838C, 0x838D, 0x838F, 0x8393, 0x814A, 0x814B,
};
#endif

// JIS Table

// this is the table used to determine whether the kana char is voiced sound markable
// if it is, what is the combined full width kana.
static WCHAR g_wVoiceMarkKana[48] =
{
  /*               0,      1,      2,      3,      4,      5,      6,      7,      8,      9,      A,      B,      C,      D,      E,      F, */

  /* a0-af */    0x0,    0x0,    0x0,    0x0,    0x0,    0x0,    0x0,    0x0,    0x0, 0x2574,    0x0,    0x0,    0x0,    0x0,    0x0,    0x0,
  /* b0-bf */    0x0,    0x0,    0x0,    0x0,    0x0,    0x0, 0x252c, 0x252e, 0x2530, 0x2532, 0x2534, 0x2536, 0x2538, 0x253A, 0x253C, 0x253E,
  /* c0-cf */ 0x2540, 0x2542, 0x2545, 0x2547, 0x2549,    0x0,    0x0,    0x0,    0x0,    0x0, 0x2550, 0x2553, 0x2556, 0x2559, 0x255C,    0x0,

};

// special voiced sound mark '0xde' conversion
static WCHAR g_wMarkDEKana[16] =
{
  /* c8-cf */  0x0, 0x0, 0x2550, 0x2553, 0x2556, 0x2559, 0x255C, 0x0,
};

// special voiced sound mark '0xdf' conversion
static WCHAR g_wMarkDFKana[16] =
{
  /* c8-cf */ 0x0, 0x0, 0x2551, 0x2554, 0x2557, 0x255A, 0x255D, 0x0,
};

// this is the table used to convert half width kana to full width kana
static WCHAR g_wFullWKana[64] =
{
  /*               0,      1,      2,      3,      4,      5,      6,      7,      8,      9,      A,      B,      C,      D,      E,      F, */

  /* a0-af */    0x0, 0x2123, 0x2156, 0x2157, 0x2122, 0x2126, 0x2572, 0x2521, 0x2523, 0x2525, 0x2527, 0x2529, 0x2563, 0x2565, 0x2567, 0x2543,
  /* b0-bf */ 0x213C, 0x2522, 0x2524, 0x2526, 0x2528, 0x252A, 0x252B, 0x252D, 0x252f, 0x2531, 0x2533, 0x2535, 0x2537, 0x2539, 0x253B, 0x253D,
  /* c0-cf */ 0x253F, 0x2541, 0x2544, 0x2546, 0x2548, 0x254A, 0x254B, 0x254C, 0x254D, 0x254E, 0x254F, 0x2552, 0x2555, 0x2558, 0x255B, 0x255E,
  /* d0-df */ 0x255F, 0x2560, 0x2561, 0x2562, 0x2564, 0x2566, 0x2568, 0x2569, 0x256A, 0x256B, 0x256C, 0x256D, 0x256F, 0x2573, 0x212B, 0x212C,
};

/******************************************************************************
**************************   C O N S T R U C T O R   **************************
******************************************************************************/

CInccJisOut::CInccJisOut(UINT uCodePage, int nCodeSet, DWORD dwFlag, WCHAR *lpFallBack) : CINetCodeConverter(uCodePage, nCodeSet)
{
    m_dwFlag = dwFlag;
    // Per Office team's request, we should disable BESTFITCHARS feature for now.
    m_dwFlag &= ~MLCONVCHARF_NOBESTFITCHARS;
    m_lpFallBack = lpFallBack;
    Reset();    // initialization
    return ;
}

/******************************************************************************
*******************************   R E S E T   *********************************
******************************************************************************/

void CInccJisOut::Reset()
{
    m_fDoubleByte = FALSE;
    m_fKana = FALSE;
    m_fJapan = FALSE;
    m_fSaveByte = FALSE;
    m_tcLeadByte = 0 ;
    m_tcPrevByte = 0 ;
    m_eKanaMode = SIO_MODE ; 
    return ;
}

/******************************************************************************
*************************   C O N V E R T   C H A R   *************************
******************************************************************************/

HRESULT CInccJisOut::ConvertChar(UCHAR tc, int cchSrc)
{
    BOOL fDone = TRUE;
    HRESULT hr = S_OK;

    if (!m_fDoubleByte) {
        if ((tc >= 0x81 && tc <= 0x9f) || (tc >= 0xe0 && tc <= 0xfc )) { 
            // Switch to Double Byte Code
            if (m_fKana) {
                if ( SIO_MODE == m_eKanaMode )
                    fDone = Output(SI);
                else if ( (FULL_MODE == m_eKanaMode) && !(m_dwFlag & MLCONVCHARF_NOBESTFITCHARS))
                {
                    fDone = KanaCleanUp();
                    m_fJapan = TRUE; // in FULL mode, Kana are bouble byte code too.
                }
                m_fKana = FALSE;
            }
            if (!m_fJapan) {
                (void)Output(ESC);  // ESC $ B - JIS-83
                (void)Output(ISO2022_IN_CHAR);
                fDone = Output(ISO2022_IN_JP_CHAR1);
                m_fJapan = TRUE;
            }
            m_fDoubleByte = TRUE;
            m_tcLeadByte = tc;
        } else if (tc >= 0xa1 && tc <= 0xdf) { 
            // Single Byte Katakana Code
            if (m_fJapan) {
                if ( (FULL_MODE == m_eKanaMode) && !(m_dwFlag & MLCONVCHARF_NOBESTFITCHARS))
                    m_fKana = TRUE; // no mode changing
                else if ( (SIO_MODE == m_eKanaMode) || (FULL_MODE == m_eKanaMode))
                {
                    (void)Output(ESC);  // ESC ( B - ACSII
                    (void)Output(ISO2022_OUT_CHAR);
                    fDone = Output(ISO2022_OUT_JP_CHAR1);
                }
                m_fJapan = FALSE;
            }
            if (!m_fKana) {
                switch ( m_eKanaMode )
                {
                    case SIO_MODE :
                        fDone = Output(SO);
                        break ;
                    case ESC_MODE :
                        (void)Output(ESC);  // ESC ( I - Kana mode
                        (void)Output(ISO2022_OUT_CHAR);
                        fDone = Output(ISO2022_OUT_JP_CHAR3);
                        break ;
                    case FULL_MODE :
                        // Don't switch if NO_BEST_FIT_CHAR
                        if (!(m_dwFlag & MLCONVCHARF_NOBESTFITCHARS))
                        {
                            (void)Output(ESC);  // ESC $ B - JIS 83
                            (void)Output(ISO2022_IN_CHAR);
                            fDone = Output(ISO2022_IN_JP_CHAR1);                        
                        }
                        break;

                }
                m_fKana = TRUE;
            }
            if ( FULL_MODE ==  m_eKanaMode )
            {
                hr = ConvFullWidthKana(tc);
                if (SUCCEEDED(hr))
                    fDone = TRUE;
                else
                    fDone = FALSE;
            }
            else
                fDone = Output(tc & 0x7f);
        } else {
            // Single Byte Code
            if (m_fKana) {
                if ( SIO_MODE == m_eKanaMode )
                    fDone = Output(SI);
                else {
                    if ( FULL_MODE == m_eKanaMode )
                        fDone = KanaCleanUp();
                    (void)Output(ESC);  // ESC ( B - ACSII
                    (void)Output(ISO2022_OUT_CHAR);
                    fDone = Output(ISO2022_OUT_JP_CHAR1);
                }
                m_fKana = FALSE;
            }
            if (m_fJapan) {
                (void)Output(ESC);  // ESC ( B - ACSII
                (void)Output(ISO2022_OUT_CHAR);
                fDone = Output(ISO2022_OUT_JP_CHAR1);
                m_fJapan = FALSE;
            }
            fDone = Output(tc);
        }
    } else {

        // map extended char (0xfa40-0xfc4b) to a special range
        if (m_tcLeadByte >= 0xfa && m_tcLeadByte <= 0xfc && tc >= 0x40 )
        {
            WCHAR  wcDBCS ;

            wcDBCS = ((WCHAR) m_tcLeadByte ) << 8 | tc ;

            if ( wcDBCS >= 0xfa40 && wcDBCS <= 0xfa5b )
            {
                if ( wcDBCS <= 0xfa49 )
                    wcDBCS = wcDBCS - 0x0b51 ;
                else if ( wcDBCS >= 0xfa4a && wcDBCS <= 0xfa53 )
                    wcDBCS = wcDBCS - 0x072f6 ;
                else if ( wcDBCS >= 0xfa54 && wcDBCS <= 0xfa57 )
                    wcDBCS = wcDBCS - 0x0b5b ;
                else if ( wcDBCS == 0xfa58 )
                    wcDBCS = 0x878a ;
                else if ( wcDBCS == 0xfa59 )
                    wcDBCS = 0x8782 ;
                else if ( wcDBCS == 0xfa5a )
                    wcDBCS = 0x8784 ;
                else if ( wcDBCS == 0xfa5b )
                    wcDBCS = 0x879a ;
            }
            else if ( wcDBCS >= 0xfa5c && wcDBCS <= 0xfc4b )
            {
                if ( tc < 0x5c )
                    wcDBCS = wcDBCS - 0x0d5f;
                else if ( tc >= 0x80 && tc <= 0x9B )
                    wcDBCS = wcDBCS - 0x0d1d;
                else
                    wcDBCS = wcDBCS - 0x0d1c;
            }
            tc = (UCHAR) wcDBCS ;
            m_tcLeadByte = (UCHAR) ( wcDBCS >> 8 ) ;
        }

        // Convert Double Byte Code
        m_tcLeadByte -= ((m_tcLeadByte > 0x9f) ? 0xb1 : 0x71);
        m_tcLeadByte = m_tcLeadByte * 2 + 1;
        if (tc > 0x9e) {
            tc -= 0x7e;
            m_tcLeadByte++;
        } else {
            if (tc > 0x7e)
                tc--;
            tc -= 0x1f;
        }
        (void)Output(m_tcLeadByte);
        fDone = Output(tc);
        m_fDoubleByte = FALSE;
        m_tcLeadByte = 0 ;
    }

    if (fDone)
        return hr;
    else
        return E_FAIL;
}

/******************************************************************************
*****************************   C L E A N   U P   *****************************
******************************************************************************/

BOOL CInccJisOut::CleanUp()
{
    BOOL fDone = TRUE;

    // Discard m_byLeadByte: if (m_fDoubleByte) Output(m_byLeadByte);

    fDone = KanaCleanUp();

    if (m_fKana)
    {
        if ( SIO_MODE == m_eKanaMode )
            fDone = Output(SI);
        else if (!(m_dwFlag & MLCONVCHARF_NOBESTFITCHARS))   // FULL mode and ESC mode
        {
            (void)Output(ESC); // ESC ( B - ASCII
            (void)Output(ISO2022_OUT_CHAR);
            fDone = Output(ISO2022_OUT_JP_CHAR1);
        }
        m_fKana = FALSE ;
    }

    if (m_fJapan) {
        (void)Output(ESC); // ESC ( B - ASCII
        (void)Output(ISO2022_OUT_CHAR);
        fDone = Output(ISO2022_OUT_JP_CHAR1);
        m_fJapan = FALSE ;
    }

    return fDone;
}


/******************************************************************************
*************************   C O N V E R T   C H A R   *************************
******************************************************************************/

HRESULT CInccJisOut::ConvFullWidthKana(UCHAR tc)
{
    BOOL fDone = TRUE ;
    int index ;
    WCHAR DoubleBytes ;
    HRESULT hr = S_OK;

    if (m_dwFlag & MLCONVCHARF_NOBESTFITCHARS)
    {
        UCHAR szDefaultChar[3] = {0x3f}; // possible DBCS + null

        if (m_lpFallBack && (m_dwFlag & MLCONVCHARF_USEDEFCHAR))
        {
            // only take SBCS, no DBCS character
            if ( 1 != WideCharToMultiByte(CP_JPN_SJ, 0,
                         (LPCWSTR)m_lpFallBack, 1,
                         (LPSTR)szDefaultChar, ARRAYSIZE(szDefaultChar), NULL, NULL ))
                szDefaultChar[0] = 0x3f;
        }

        if (m_dwFlag & (MLCONVCHARF_NCR_ENTITIZE|MLCONVCHARF_NAME_ENTITIZE))
        {
            char    szChar[2] = {0};
            char    szDstStr[10] = {0};
            WCHAR   szwChar[2];
            int     cCount;

            szChar[0] = tc;
                
            if (MultiByteToWideChar(CP_JPN_SJ, 0, szChar, -1, szwChar, ARRAYSIZE(szwChar)))
            {
                // Output NCR entity
                Output('&');
                Output('#');
                _ultoa((unsigned long)szwChar[0], (char*)szDstStr, 10);
                cCount = lstrlenA(szDstStr);
                for (int i=0; i< cCount; i++)
                {
                    Output(szDstStr[i]);
                }
                fDone = Output(';');
            }
            else
            {
                fDone = Output(szDefaultChar[0]); // use default char
                hr = S_FALSE;
            }
        }
        else
        {
            fDone = Output(szDefaultChar[0]); // use default char
            hr = S_FALSE;
        }
    }
    else
    {
        // voiced sound mark or semi-voiced sound mark 
        if ( m_fSaveByte && ( tc == 0xde || tc == 0xdf ) )
        {
            if ( m_tcPrevByte >= 0x0CA && m_tcPrevByte <= 0x0CE ) 
            {
                index = m_tcPrevByte - VOICE_MARK_DEDF_OFFSET ;
                
                if ( tc == 0xde )
                    DoubleBytes = g_wMarkDEKana[index] ;
                else
                    DoubleBytes = g_wMarkDFKana[index] ;
                
                Output( (UCHAR) (DoubleBytes >> 8 ));
                fDone = Output( (UCHAR) DoubleBytes );
                m_fSaveByte = FALSE ;
                m_tcPrevByte = '\0' ;                
            }
            else
            {
                index = m_tcPrevByte - VOICE_MARK_OFFSET ;
                
                // Invalid trail byte could cause buffer overrun, skip it
                if (index < ARRAYSIZE(g_wVoiceMarkKana))
                {
                    DoubleBytes = g_wVoiceMarkKana[index] ;
                    Output( (UCHAR) (DoubleBytes >> 8 ));
                    fDone = Output( (UCHAR) DoubleBytes );
                    m_fSaveByte = FALSE ;
                    m_tcPrevByte = '\0' ;
                }
            }
        }
        else 
        {

            // output previous saved voice sound markable char
            if ( m_fSaveByte )
            {
                index = m_tcPrevByte - VOICE_MARK_OFFSET ;
                DoubleBytes = g_wFullWKana[index] ;
                Output( (UCHAR) (DoubleBytes >> 8 ) );
                fDone = Output( (UCHAR) DoubleBytes );
                m_fSaveByte = FALSE ;
                m_tcPrevByte = '\0' ;
            }

            // half width kana
            if ( tc >= 0xa1 && tc <= 0xdf )
            {
                index = tc - VOICE_MARK_OFFSET ;
                // check if this char can be combined with voice sound mark
                if ( index < ARRAYSIZE(g_wVoiceMarkKana) && g_wVoiceMarkKana[index] )
                {
                    m_fSaveByte = TRUE ;
                    m_tcPrevByte = tc ;
                }
                // convert half width kana to full width kana
                else
                {
                    DoubleBytes = g_wFullWKana[index] ;
                    Output( (UCHAR) ( DoubleBytes >> 8 ));
                    fDone = Output( (UCHAR) DoubleBytes );
                }
            }
            else
                fDone = Output(tc);
        }
    }

    if (fDone)
        return hr;
    else
        return E_FAIL;

}

/******************************************************************************
*************************** K A N A  C L E A N   U P   ************************
******************************************************************************/

BOOL CInccJisOut::KanaCleanUp()
{
    BOOL fDone = TRUE;
    WCHAR DoubleBytes ;
    int index ;

    // output previous saved voice sound markable char
    if ( m_fSaveByte )
    {
        index = m_tcPrevByte - VOICE_MARK_OFFSET ;
        DoubleBytes = g_wFullWKana[index] ;
        Output( (UCHAR) ( DoubleBytes >> 8 ));
        fDone = Output( (UCHAR) DoubleBytes );
        m_fSaveByte = FALSE ;
        m_tcPrevByte = '\0' ;
    }

    return fDone;
}

int CInccJisOut::GetUnconvertBytes()
{
    if ( m_tcLeadByte )
        return 1 ;
    else
        return 0 ;
}

DWORD CInccJisOut::GetConvertMode()
{
    return ( m_fJapan ? 1 : 0 ) +  ( m_fKana ? 2 : 0 ) ;
}

void CInccJisOut::SetConvertMode(DWORD mode)
{
    Reset();
    if ( mode & 0x00000001 ) 
        m_fJapan = TRUE ;
    if ( mode & 0x00000002 ) 
        m_fKana = TRUE ;
    return ;
}

void CInccJisOut::SetKanaMode(UINT uCodePage)
{
    switch ( uCodePage )
    {
        case    CP_ISO_2022_JP_ESC:
            m_eKanaMode = ESC_MODE ; 
            break ;
        case    CP_ISO_2022_JP_SIO:
            m_eKanaMode = SIO_MODE ; 
            break ;
        default :
            m_eKanaMode = FULL_MODE ; 
            break ;
    }
    return ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\mlang\kscobj.cpp ===
// ============================================================================
// Internet Character Set Conversion: Input from ISO-2022-KR
// ============================================================================

#include "private.h"
#include "fechrcnv.h"
#include "kscobj.h"
#include "codepage.h"

/******************************************************************************
**************************   C O N S T R U C T O R   **************************
******************************************************************************/

CInccKscIn::CInccKscIn(UINT uCodePage, int nCodeSet) : CINetCodeConverter(uCodePage, nCodeSet)
{
    Reset();    // initialization
    return ;
}

/******************************************************************************
*******************************   R E S E T   *********************************
******************************************************************************/

void CInccKscIn::Reset()
{
    m_pfnConv = ConvMain;
    m_pfnCleanUp = CleanUpMain;
    m_fShift = FALSE;
    // bug #57570, Korean ISP DACOM only labels one designator in the 
    // conversion of a MIME mail. To decode the other part of MIME correctly, 
    // we need to decode the ISO document or MIME message even there is no
    // designator "esc ) C".
    m_fKorea = TRUE;
    m_nESCBytes = 0 ;
    m_fLeadByte = FALSE ;
    return ;
}

/******************************************************************************
*************************   C O N V E R T   C H A R   *************************
******************************************************************************/

HRESULT CInccKscIn::ConvertChar(UCHAR tc, int cchSrc)
{
    BOOL fDone = (this->*m_pfnConv)(tc);
    if (fDone)
        return S_OK;
    else
        return E_FAIL;
}

/******************************************************************************
*****************************   C L E A N   U P   *****************************
******************************************************************************/

BOOL CInccKscIn::CleanUp()
{
    return (this->*m_pfnCleanUp)();
}

/******************************************************************************
****************************   C O N V   M A I N   ****************************
******************************************************************************/

BOOL CInccKscIn::ConvMain(UCHAR tc)
{
    BOOL fDone = TRUE;

    if (tc == ESC) {
        m_pfnConv = ConvEsc;
        m_pfnCleanUp = CleanUpEsc;
        m_nESCBytes++ ;
    } else {
        if (m_fKorea) {
            switch (tc) {
            case SO:
                m_fShift = TRUE;
                break;

            case SI:
                m_fShift = FALSE;
                m_fLeadByte = FALSE ;
                break;

            default:
                if (m_fShift) {
                    switch (tc) {
                    case ' ':
                    case '\t':
                    case '\n':
                        fDone = Output(tc);
                        break;

                    default:
                        fDone = Output(tc | 0x80);
                        m_fLeadByte = ~m_fLeadByte ;
                        break;
                    }
                } else {
                    fDone = Output(tc);
                }
                break;
            }
        } else {
            fDone = Output(tc);
        }
    }
    return fDone;
}

/******************************************************************************
************************   C L E A N   U P   M A I N   ************************
******************************************************************************/

BOOL CInccKscIn::CleanUpMain()
{
    return TRUE;
}

/******************************************************************************
*****************************   C O N V   E S C   *****************************
******************************************************************************/

BOOL CInccKscIn::ConvEsc(UCHAR tc)
{
    if (tc == ISO2022_IN_CHAR) {
        m_pfnConv = ConvIsoIn;
        m_pfnCleanUp = CleanUpIsoIn;
        m_nESCBytes++ ;
        return TRUE;
    } else {
        m_pfnConv = ConvMain;
        m_pfnCleanUp = CleanUpMain;
        m_nESCBytes = 0 ;
        (void)Output(ESC);
        if (SUCCEEDED(ConvertChar(tc)))
            return TRUE;
        else
            return FALSE;
    }
}

/******************************************************************************
*************************   C L E A N   U P   E S C   *************************
******************************************************************************/

BOOL CInccKscIn::CleanUpEsc()
{
    m_pfnConv = ConvMain;
    m_pfnCleanUp = CleanUpMain;
    m_nESCBytes = 0 ;
    return Output(ESC);
}

/******************************************************************************
**************************   C O N V   I S O   I N   **************************
******************************************************************************/

BOOL CInccKscIn::ConvIsoIn(UCHAR tc)
{
    if (tc == ISO2022_IN_KR_CHAR_1) {
        m_pfnConv = ConvIsoInKr;
        m_pfnCleanUp = CleanUpIsoInKr;
        m_nESCBytes++ ;
        return TRUE;
    } else {
        m_pfnConv = ConvMain;
        m_pfnCleanUp = CleanUpMain;
        m_nESCBytes = 0 ;
        (void)Output(ESC);
        (void)ConvertChar(ISO2022_IN_CHAR);
        if (SUCCEEDED(ConvertChar(tc)))
            return TRUE;
        else
            return FALSE;
    }
}

/******************************************************************************
**********************   C L E A N   U P   I S O   I N   **********************
******************************************************************************/

BOOL CInccKscIn::CleanUpIsoIn()
{
    m_pfnConv = ConvMain;
    m_pfnCleanUp = CleanUpMain;
    m_nESCBytes = 0 ;

    (void)Output(ESC);
    (void)ConvertChar(ISO2022_IN_CHAR);
    return CleanUp();
}

/******************************************************************************
***********************   C O N V   I S O   I N   K R   ***********************
******************************************************************************/

BOOL CInccKscIn::ConvIsoInKr(UCHAR tc)
{
    m_pfnConv = ConvMain;
    m_pfnCleanUp = CleanUpMain;
    m_nESCBytes = 0 ;

    if (tc == ISO2022_IN_KR_CHAR_2) {
        m_fKorea = TRUE;
        return TRUE;
    } else {
        (void)Output(ESC);
        (void)ConvertChar(ISO2022_IN_CHAR);
        (void)ConvertChar(ISO2022_IN_KR_CHAR_1);
        if (SUCCEEDED(ConvertChar(tc)))
            return TRUE;
        else
            return FALSE;
    }
}

/******************************************************************************
*******************   C L E A N   U P   I S O   I N   K R   *******************
******************************************************************************/

BOOL CInccKscIn::CleanUpIsoInKr()
{
    m_pfnConv = ConvMain;
    m_pfnCleanUp = CleanUpMain;
    m_nESCBytes = 0 ;

    (void)Output(ESC);
    (void)ConvertChar(ISO2022_IN_CHAR);
    (void)ConvertChar(ISO2022_IN_KR_CHAR_1);
    return CleanUp();
}

int CInccKscIn::GetUnconvertBytes()
{
    if ( m_fLeadByte )
        return 1 ;
    else if ( m_nESCBytes )
        return m_nESCBytes < 4 ? m_nESCBytes : 3 ;
    else
        return 0 ;
}

DWORD CInccKscIn::GetConvertMode()
{
    // 0xC431 -> 50225 ISO-2022-KR
    return ( m_fKorea ? 1 : 0 ) + ( m_fShift ? 2 : 0 ) | 0xC4310000 ;
}

void CInccKscIn::SetConvertMode(DWORD mode)
{
    Reset();    // initialization

    if ( mode & 0x00000001 )
        m_fKorea = TRUE ;
    if ( mode & 0x00000002 ) 
        m_fShift = TRUE ;
    return ;
}

// ============================================================================
// Internet Character Set Conversion: Output to ISO-2022-KSC
// ============================================================================

/******************************************************************************
**************************   C O N S T R U C T O R   **************************
******************************************************************************/

CInccKscOut::CInccKscOut(UINT uCodePage, int nCodeSet, DWORD dwFlag, WCHAR *lpFallBack) : CINetCodeConverter(uCodePage, nCodeSet)
{
    Reset();    // initialization
    _dwFlag = dwFlag;
    _lpFallBack = lpFallBack;
    return ;
}

/******************************************************************************
*******************************   R E S E T   *********************************
******************************************************************************/

void CInccKscOut::Reset()
{
    m_fDoubleByte = FALSE;
    m_fShift = FALSE;
    m_fKorea = FALSE;
    m_tcLeadByte = 0 ;
    return ;
}

/******************************************************************************
*************************   C O N V E R T   C H A R   *************************
******************************************************************************/

HRESULT CInccKscOut::ConvertChar(UCHAR tc, int cchSrc)
{
    BOOL fDone = TRUE;
    HRESULT hr = S_OK;

//
//IE RAID #103403 weiwu 03/16/00
//
//Per Korean PM (sykim), we don't have to prepend iso-2022-kr designator to conversion result string
//Also considering that URLMON can't handle encoded ASCII iso-2022-kr string
//We now remove following code, if it triggers any compatibility issues, we should re-enable it
//
#if 0
    // put designator to the top of the document
    if (!m_fKorea) {
        (void)Output(ESC);
        (void)Output(ISO2022_IN_CHAR);
        (void)Output(ISO2022_IN_KR_CHAR_1);
        (void)Output(ISO2022_IN_KR_CHAR_2);
        m_fKorea = TRUE;
    }
#endif

    if (!m_fDoubleByte) {
        //
        // We're not using IsDBCSLeadByteEx() due to perf. concern
        // We should assert that our hard code table match IsDBCSLeadByteEx(), 
        // But, MLang ships with down level platforms and assert won't be valid if there is a range change
        //
        if (IS_KOR_LEADBYTE(tc)) {
            m_fDoubleByte = TRUE;
            m_tcLeadByte = tc;
        } else {
            if (m_fKorea && m_fShift) {
                (void)Output(SI);
                m_fShift = FALSE;
            }
            fDone = Output(tc);
        }
    } else {
        m_fDoubleByte = FALSE;
        if (tc > 0x40) { // Check if trail byte indicates Hangeul
            if (m_tcLeadByte > 0xa0 && tc > 0xa0) { // Check if it's a Wansung
                if (!m_fShift) {
                    if (!m_fKorea) {
                        (void)Output(ESC);
                        (void)Output(ISO2022_IN_CHAR);
                        (void)Output(ISO2022_IN_KR_CHAR_1);
                        (void)Output(ISO2022_IN_KR_CHAR_2);
                        m_fKorea = TRUE;
                    }
                    (void)Output(SO);
                    m_fShift = TRUE;
                }                
                (void)Output(m_tcLeadByte & 0x7f);
                fDone = Output(tc & 0x7f);
            } else {
                UCHAR szDefaultChar[3] = {0x3f}; // possible DBCS + null    


                if (_lpFallBack && (_dwFlag & MLCONVCHARF_USEDEFCHAR))
                {
                    // only take SBCS, no DBCS character
                    if ( 1 != WideCharToMultiByte(CP_KOR_5601, 0,
                               (LPCWSTR)_lpFallBack, 1,
                               (LPSTR)szDefaultChar, ARRAYSIZE(szDefaultChar), NULL, NULL ))
                        szDefaultChar[0] = 0x3f;
                }

                // shift out if we're in DBCS mode
                if (m_fKorea && m_fShift) {
                    (void)Output(SI);
                    m_fShift = FALSE;
                }

                if (_dwFlag & (MLCONVCHARF_NCR_ENTITIZE|MLCONVCHARF_NAME_ENTITIZE))
                {
                    char    szChar[2];
                    char    szDstStr[10];
                    WCHAR   szwChar[2];
                    int     cCount;

                    szChar[0] = m_tcLeadByte;
                    szChar[1] = tc;
                
                    if (MultiByteToWideChar(CP_KOR_5601, 0, szChar, 2, szwChar, ARRAYSIZE(szwChar)))
                    {
                        // Output NCR entity
                        Output('&');
                        Output('#');
                        _ultoa((unsigned long)szwChar[0], (char*)szDstStr, 10);
                        cCount = lstrlenA(szDstStr);
                        for (int i=0; i< cCount; i++)
                        {
                            Output(szDstStr[i]);
                        }
                        fDone = Output(';');
                    }
                    else
                    {
                        fDone = Output(szDefaultChar[0]); // use default char
                        hr = S_FALSE;
                    }
                }
                else
                {
                    fDone = Output(szDefaultChar[0]); // use default char
                    hr = S_FALSE;
                }
            }
        } else {
            if (m_fKorea && m_fShift) {
                (void)Output(SI);
                m_fShift = FALSE;
            }
            (void)Output(m_tcLeadByte);
            fDone = Output(tc);
        }
        m_tcLeadByte = 0 ;
    }

    if (!fDone)
        hr = E_FAIL;

    return hr;
}

/******************************************************************************
*****************************   C L E A N   U P   *****************************
******************************************************************************/

BOOL CInccKscOut::CleanUp()
{
    BOOL fDone = TRUE;

    if ( m_fShift) 
    {
        fDone = Output(SI);
        m_fShift = FALSE;
    }
    return fDone ;
}

int CInccKscOut::GetUnconvertBytes()
{
    if (m_tcLeadByte)
        return 1 ;
    else
        return 0 ;
}

DWORD CInccKscOut::GetConvertMode()
{
    // for output, we don't need write back code page. 0xC431 -> 50225 ISO-2022-KR
    return ( m_fKorea ? 1 : 0 ) +  ( m_fShift ? 2 : 0 ) ;
}

void CInccKscOut::SetConvertMode(DWORD mode)
{
    Reset();    // initialization

    if ( mode & 0x00000001 ) 
        m_fKorea = TRUE ;
    if ( mode & 0x00000002 ) 
        m_fShift = TRUE ;
    return ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\mlang\jislex.cpp ===
/*----------------------------------------------------------------------------
    %%File: jislex.c
    %%Unit: fechmap
    %%Contact: jpick

    Simple converter for decoding a subset of possible ISO-2022-7 encoded
    files (ISO-2022).  Data is translated to and from Unicode.  Converter
    operates according to user options.
    
    Module currently handles ISO-2022-JP (and JIS) and ISO-2022-KR.  
    
    Converter is set up to handle ISO-2022-TW and ISO-2022-CN, but there
    are as yet no conversion tables for these.
----------------------------------------------------------------------------*/

#include <stdio.h>
#include <stddef.h>

#include "private.h"
#include "fechmap_.h"
#include "lexint_.h"


// State table for reading ISO-2022-7 encoded text
//
// Lexer recognizes the following designator sequences, used 
// to select a one or two byte character set:
//
//    <esc> $ @             -- JIS C 6626-1978  (synonym of <esc> $ ( @)
//    <esc> $ A             -- GB 2312-80       (synonym of <esc> $ ( A)
//    <esc> $ B             -- JIS X 0208-1983  (synonym of <esc> $ ( B)
//
//    <esc> $ ( @           -- JIS C 6626-1978
//    <esc> $ ( A           -- GB 2312-80
//    <esc> $ ( B           -- JIS X 0208-1983
//    <esc> $ ( C           -- KS C 5601-1992
//    <esc> $ ( D           -- JIS X 0212-1990
//    <esc> $ ( E           -- ??? (ISO-IR-165:1992) ???
//    <esc> $ ( G           -- CNS 11643-1992 Plane 1
//    <esc> $ ( H           -- CNS 11643-1992 Plane 2
//    <esc> $ ( I           -- CNS 11643-1992 Plane 3
//    <esc> $ ( J           -- CNS 11643-1992 Plane 4
//    <esc> $ ( K           -- CNS 11643-1992 Plane 5
//    <esc> $ ( L           -- CNS 11643-1992 Plane 6
//    <esc> $ ( M           -- CNS 11643-1992 Plane 7
//
//    <esc> $ ) C           -- KSC 5601-1987 (Implies ISO-2022-KR ??)
//
//    <esc> & @ <esc> $ B   -- JIS X 0208-1990
//
//    <esc> ( B             -- Ascii
//    <esc> ( H             -- Deprecated variant of JIS-Roman
//    <esc> ( I             -- Half-Width Katakana
//    <esc> ( J             -- JIS-Roman
//    <esc> ( T             -- GB 1988-89 Roman
//
// Lexer recognizes the following shift sequences, used to allow
// interpretation of a given byte or bytes:
//
//    <si>                  -- locking shift, interpret bytes as G0
//    <so>                  -- locking shift, interpret bytes as G1
//    <esc> n               -- locking shift, interpret bytes as G2
//    <esc> o               -- locking shift, interpret bytes as G3
//    <esc> N               -- single shift, interpret bytes as G2
//    <esc> O               -- single shift, interpret bytes as G3
//
// REVIEW (jpick): don't currently need the final four shift
//   sequences.  If we support ISO-2022-CN, we'll need to use
//   G2 and G3 and potentially, then, the last four shifts.
//

/*----------------------------------------------------------------------------
    Character Classification Table
----------------------------------------------------------------------------*/

// Tokens
//
#define txt         (JTK) 0
#define ext         (JTK) 1     // extended characters that are legal under certain circumstances
#define esc         (JTK) 2
#define si          (JTK) 3
#define so          (JTK) 4
#define dlr         (JTK) 5
#define at          (JTK) 6
#define amp         (JTK) 7
#define opr         (JTK) 8
#define cpr         (JTK) 9
#define tkA         (JTK) 10
#define tkB         (JTK) 11
#define tkC         (JTK) 12
#define tkD         (JTK) 13
#define tkE         (JTK) 14
#define tkG         (JTK) 15
#define tkH         (JTK) 16
#define tkI         (JTK) 17
#define tkJ         (JTK) 18
#define tkK         (JTK) 19
#define tkL         (JTK) 20
#define tkM         (JTK) 21
#define tkT         (JTK) 22
#define unk         (JTK) 23    // Unexpected character
#define eof         (JTK) 24    // end-of-file
#define err         (JTK) 25    // read error

#define nTokens     26

// Lookup table for ISO-2022-7 encoded files
//
static JTK _rgjtkCharClass[256] =
//  0    1    2    3    4    5    6    7    8    9    a    b    c    d    e    f
    {
//  nul  soh  stx  etx  eot  enq  ack  bel  bs   tab  lf   vt   np   cr   so   si       0
    txt, txt, txt, txt, txt, txt, txt, txt, txt, txt, txt, txt, txt, txt, so,  si, 

//  dle  dc1  dc2  dc3  dc4  nak  syn  etb  can  em   eof  esc  fs   gs   rs   us       1
    txt, txt, txt, txt, txt, txt, txt, txt, txt, txt, txt, esc, txt, txt, txt, txt, 

//  sp   !    "    #    $    %    &    '    (    )    *    +    ,    -    .    /        2
    txt, txt, txt, txt, dlr, txt, amp, txt, opr, cpr, txt, txt, txt, txt, txt, txt, 

//  0    1    2    3    4    5    6    7    8    9    :    ;    <    =    >    ?        3
    txt, txt, txt, txt, txt, txt, txt, txt, txt, txt, txt, txt, txt, txt, txt, txt, 

//  @    A    B    C    D    E    F    G    H    I    J    K    L    M    N    O        4
    at,  tkA, tkB, tkC, tkD, tkE, txt, tkG, tkH, tkI, tkJ, tkK, tkL, tkM, txt, txt, 

//  P    Q    R    S    T    U    V    W    X    Y    Z    [    \    ]    ^    _        5
    txt, txt, txt, txt, tkT, txt, txt, txt, txt, txt, txt, txt, txt, txt, txt, txt, 

//  `    a    b    c    d    e    f    g    h    i    j    k    l    m    n    o        6
    txt, txt, txt, txt, txt, txt, txt, txt, txt, txt, txt, txt, txt, txt, txt, txt, 

//  p    q    r    s    t    u    v    w    x    y    z    {    |    }    ~    del      7
    txt, txt, txt, txt, txt, txt, txt, txt, txt, txt, txt, txt, txt, txt, txt, txt, 

//                                                                                      8
    unk, unk, unk, unk, unk, unk, unk, unk, unk, unk, unk, unk, unk, unk, unk, unk, 

//                                                                                      9
    unk, unk, unk, unk, unk, unk, unk, unk, unk, unk, unk, unk, unk, unk, unk, unk, 

//                                                                                      a
    unk, ext, ext, ext, ext, ext, ext, ext, ext, ext, ext, ext, ext, ext, ext, ext, 

//                                                                                      b
    ext, ext, ext, ext, ext, ext, ext, ext, ext, ext, ext, ext, ext, ext, ext, ext, 

//                                                                                      c
    ext, ext, ext, ext, ext, ext, ext, ext, ext, ext, ext, ext, ext, ext, ext, ext, 

//                                                                                      d
    ext, ext, ext, ext, ext, ext, ext, ext, ext, ext, ext, ext, ext, ext, ext, ext, 

//                                                                                      e
    unk, unk, unk, unk, unk, unk, unk, unk, unk, unk, unk, unk, unk, unk, unk, unk, 

//                                                                                      f
    unk, unk, unk, unk, unk, unk, unk, unk, unk, unk, unk, unk, unk, unk, unk, unk, 

//  0    1    2    3    4    5    6    7    8    9    a    b    c    d    e    f
};


/*----------------------------------------------------------------------------
    State Table
----------------------------------------------------------------------------*/

// Final states have the high-bit set.  States that represent the reading
// of a valid character escape sequence also encode the character set
// "name" (moniker??) -- the state with the high bit masked off.
//
// Table State
//
typedef unsigned char TST;

// Final State Mask, Related
//
#define grfFinal                            (TST) 0x80
#define _NEscTypeFromState(nState)          (int) ((nState) & 0x7f)

// ASCII Escape Sequence (Final State)
#define ASC     (TST) (grfFinal | 0x00)     // Ascii

// Japanese Escape Sequences (Final States)
#define JS0     (TST) (grfFinal | 0x01)     // JIS-Roman
#define JS1     (TST) (grfFinal | 0x02)     // Half-Width Katakana
#define JS2     (TST) (grfFinal | 0x03)     // JIS C 6226-1978
#define JS3     (TST) (grfFinal | 0x04)     // JIS X 0208-1983
#define JS4     (TST) (grfFinal | 0x05)     // JIS X 0208-1990
#define JS5     (TST) (grfFinal | 0x06)     // JIS X 0212-1990

// Chinese (PRC) Escape Sequences (Final States)
#define CS0     (TST) (grfFinal | 0x07)     // GB 1988-89 Roman
#define CS1     (TST) (grfFinal | 0x08)     // GB 2312-80

// Chinese (Taiwan) Escape Sequences (Final States)
#define TS0     (TST) (grfFinal | 0x09)     // CNS 11643-1992 Plane 1
#define TS1     (TST) (grfFinal | 0x0a)     // CNS 11643-1992 Plane 2
#define TS2     (TST) (grfFinal | 0x0b)     // CNS 11643-1992 Plane 3
#define TS3     (TST) (grfFinal | 0x0c)     // CNS 11643-1992 Plane 4
#define TS4     (TST) (grfFinal | 0x0d)     // CNS 11643-1992 Plane 5
#define TS5     (TST) (grfFinal | 0x0e)     // CNS 11643-1992 Plane 6
#define TS6     (TST) (grfFinal | 0x0f)     // CNS 11643-1992 Plane 7

// Korean Escape Sequences (Final State)
#define KS0     (TST) (grfFinal | 0x10)     // KS C 5601-1992

// Document "Signal" for ISO-2022-KR (Doc needs special processing)
#define KSD     (TST) (grfFinal | 0x11)     // ISO-2022-KR Document Signal

// Number of unique *character set* escape sequences
//
#define cCsEsc  18

// Special States (not escape sequence) (Final States)
//
#define TXT     (TST) (grfFinal | (cCsEsc + 1))     // Process Text
#define EXT     (TST) (grfFinal | (cCsEsc + 2))     // Process (Possibly Illegal) Extended Chars
#define FIN     (TST) (grfFinal | (cCsEsc + 3))     // Finish
#define EOI     (TST) (grfFinal | (cCsEsc + 4))     // Unexpected End-Of-Input
#define UNK     (TST) (grfFinal | (cCsEsc + 5))     // Unknown State (Unexpected Character)
#define ERR     (TST) (grfFinal | (cCsEsc + 6))     // Read Error

// Shift Sequences (do not specify character set) (Final States)
//
#define LSO     (TST) (grfFinal | (cCsEsc + 7))     // Locking shift out (g1 into GL)
#define LSI     (TST) (grfFinal | (cCsEsc + 8))     // Locking shift in (g0 into GL)

// For convenience, also define constants for the sets
// that the states represent.
//
#define csNIL       (-1)                            // Invalid Designator
#define csASC       (_NEscTypeFromState(ASC))       // Ascii
#define csJS0       (_NEscTypeFromState(JS0))       // JIS-Roman
#define csJS1       (_NEscTypeFromState(JS1))       // Half-Width Katakana
#define csJS2       (_NEscTypeFromState(JS2))       // JIS C 6226-1978
#define csJS3       (_NEscTypeFromState(JS3))       // JIS X 0208-1983
#define csJS4       (_NEscTypeFromState(JS4))       // JIS X 0208-1990
#define csJS5       (_NEscTypeFromState(JS5))       // JIS X 0212-1990
#define csCS0       (_NEscTypeFromState(CS0))       // GB 1988-89 Roman
#define csCS1       (_NEscTypeFromState(CS1))       // GB 2312-80
#define csTS0       (_NEscTypeFromState(TS0))       // CNS 11643-1992 Plane 1
#define csTS1       (_NEscTypeFromState(TS1))       // CNS 11643-1992 Plane 2
#define csTS2       (_NEscTypeFromState(TS2))       // CNS 11643-1992 Plane 3
#define csTS3       (_NEscTypeFromState(TS3))       // CNS 11643-1992 Plane 4
#define csTS4       (_NEscTypeFromState(TS4))       // CNS 11643-1992 Plane 5
#define csTS5       (_NEscTypeFromState(TS5))       // CNS 11643-1992 Plane 6
#define csTS6       (_NEscTypeFromState(TS6))       // CNS 11643-1992 Plane 7
#define csKS0       (_NEscTypeFromState(KS0))       // KS C 5601-1992 (into G0)
#define csKSD       (_NEscTypeFromState(KSD))       // KS C 5601-1992 (into G1)

// Table States (Intermediate States)
#define ST0     (TST)  0
#define ST1     (TST)  1
#define ST2     (TST)  2
#define ST3     (TST)  3
#define ST4     (TST)  4
#define ST5     (TST)  5
#define ST6     (TST)  6
#define ST7     (TST)  7
#define ST8     (TST)  8
#define ST9     (TST)  9

// Number of "real" (table) states
//
#define nStates     10

#define IsFinal(state)  ((state) & grfFinal)


// State    Have Seen               Looking For
// ----------------------------------------------------------
// ST0      -- Start State --       <ESC> Text
// ST1      <ESC>                   $ & (
// ST2      <ESC> $                 ( ) @ A B   (**)
// ST3      <ESC> $ (               @ A B C D E G H I J K L M
// ST4      <ESC> $ )               C
// ST5      <ESC> &                 @
// ST6      <ESC> & @               <ESC>
// ST7      <ESC> & @ <ESC>         $
// ST8      <ESC> & @ <ESC> $       B
// ST9      <ESC> (                 B H I J T
//
// (**)  "<ESC> $ ID" is a synonym of "<ESC> $ ( ID" for ID=(@, A, B)
//
// Because of the large number of tokens, this table is
// inverted (tokens x states).
//
static signed char _rgchNextState[nTokens][nStates] =
{
//
//           S     S     S     S     S     S     S     S     S     S 
//           T     T     T     T     T     T     T     T     T     T  
//           0     1     2     3     4     5     6     7     8     9   
//--------------------------------------------------------------------
//
/* txt */  TXT,  UNK,  UNK,  UNK,  UNK,  UNK,  UNK,  UNK,  UNK,  UNK,
/* ext */  EXT,  UNK,  UNK,  UNK,  UNK,  UNK,  UNK,  UNK,  UNK,  UNK,
/* esc */  ST1,  UNK,  UNK,  UNK,  UNK,  UNK,  ST7,  UNK,  UNK,  UNK,
/* si  */  LSI,  UNK,  UNK,  UNK,  UNK,  UNK,  UNK,  UNK,  UNK,  UNK,
/* so  */  LSO,  UNK,  UNK,  UNK,  UNK,  UNK,  UNK,  UNK,  UNK,  UNK,
/* $   */  TXT,  ST2,  UNK,  UNK,  UNK,  UNK,  UNK,  ST8,  UNK,  UNK,
/* @   */  TXT,  UNK,  JS2,  JS2,  UNK,  ST6,  UNK,  UNK,  UNK,  UNK,
/* &   */  TXT,  ST5,  UNK,  UNK,  UNK,  UNK,  UNK,  UNK,  UNK,  UNK,
/* (   */  TXT,  ST9,  ST3,  UNK,  UNK,  UNK,  UNK,  UNK,  UNK,  UNK,
/* )   */  TXT,  UNK,  ST4,  UNK,  UNK,  UNK,  UNK,  UNK,  UNK,  UNK,
/* A   */  TXT,  UNK,  CS1,  CS1,  UNK,  UNK,  UNK,  UNK,  UNK,  UNK,
/* B   */  TXT,  UNK,  JS3,  JS3,  UNK,  UNK,  UNK,  UNK,  JS4,  ASC,
/* C   */  TXT,  UNK,  UNK,  KS0,  KSD,  UNK,  UNK,  UNK,  UNK,  UNK,
/* D   */  TXT,  UNK,  UNK,  JS5,  UNK,  UNK,  UNK,  UNK,  UNK,  UNK,
/* E   */  TXT,  UNK,  UNK,  UNK,  UNK,  UNK,  UNK,  UNK,  UNK,  UNK,
/* G   */  TXT,  UNK,  UNK,  TS0,  UNK,  UNK,  UNK,  UNK,  UNK,  UNK,
/* H   */  TXT,  UNK,  UNK,  TS1,  UNK,  UNK,  UNK,  UNK,  UNK,  JS0,
/* I   */  TXT,  UNK,  UNK,  TS2,  UNK,  UNK,  UNK,  UNK,  UNK,  JS1,
/* J   */  TXT,  UNK,  UNK,  TS3,  UNK,  UNK,  UNK,  UNK,  UNK,  JS0,
/* K   */  TXT,  UNK,  UNK,  TS4,  UNK,  UNK,  UNK,  UNK,  UNK,  UNK,
/* L   */  TXT,  UNK,  UNK,  TS5,  UNK,  UNK,  UNK,  UNK,  UNK,  UNK,
/* M   */  TXT,  UNK,  UNK,  TS6,  UNK,  UNK,  UNK,  UNK,  UNK,  UNK,
/* T   */  TXT,  UNK,  UNK,  UNK,  UNK,  UNK,  UNK,  UNK,  UNK,  CS0,
/* unk */  UNK,  UNK,  UNK,  UNK,  UNK,  UNK,  UNK,  UNK,  UNK,  UNK,
/* eof */  FIN,  EOI,  EOI,  EOI,  EOI,  EOI,  EOI,  EOI,  EOI,  EOI,
/* err */  ERR,  ERR,  ERR,  ERR,  ERR,  ERR,  ERR,  ERR,  ERR,  ERR,
};


// Also for ISO-2022 out.  Build arrays of possible character
// sets for each type of input character set.  Character sets
// should appear in order of hit probability (e.g., in 2022-Jp
// JS3 is the most common set).  Mark the end of array with -1.
// (Only store these for non-ascii sets).
//
//
// China (icetIso2022Cn)
static int _rgceCn[] = { -1, };

// Japan (icetIso2022Jp)
static int _rgceJp[] = { csJS3, csJS1, csJS5, -1, };

// Korea (icetIso2022Kr)
static int _rgceKr[] = { -1, };

// Taiwan (icetIso2022Tw)
static int _rgceTw[] = { -1, };

static int *_mpicetrgce[icetCount] =
    {
    0,              // icetEucCn
    0,              // icetEucJp
    0,              // icetEucKr
    0,              // icetEucTw
    _rgceCn,        // icetIso2022Cn
    _rgceJp,        // icetIso2022Jp
    _rgceKr,        // icetIso2022Kr
    _rgceTw,        // icetIso2022Tw
    0,              // icetBig5
    0,              // icetGbk
    0,              // icetShiftJis
    0,              // icetWansung
    0,              // icetUtf8
    };

/* _ J T K  G E T  N E X T */
/*----------------------------------------------------------------------------
    %%Function: _JtkGetNext
    %%Contact: jpick

    Get the next character and classify it.  Return the token.
----------------------------------------------------------------------------*/
static JTK __inline _JtkGetNext(IStream *pstmIn, PUCHAR puch)
{
    ULONG rc;
    HRESULT hr;
          
    hr = pstmIn->Read(puch, 1, &rc);
    
    if (hr != S_OK )
        return err;
    else if (rc == 0)
        return eof;
    else
        return _rgjtkCharClass[*puch];
}

/* C C E  R E A D  E S C  S E Q */
/*----------------------------------------------------------------------------
    %%Function: CceReadEscSeq
    %%Contact: jpick

    Read pointer is positioned at an escape sequence, figure out
    which escape sequence it is.
----------------------------------------------------------------------------*/
CCE CceReadEscSeq(IStream *pstmIn, ICET *lpicet)
{
    UCHAR uch;
    TST tstCurr;
    JTK jtk;
    CCE cceRet;
#ifdef DEBUG
    TST tstPrev;
#endif

    // Sanity checks ...
    //
#ifdef DEBUG
    if (!pstmIn || !lpicet)
        return cceInvalidParameter;
#endif
        
    tstCurr = ST0;

    while (1)
        {
        // Find the next stopping state.
        //
        do
            {
            // Get the next character and clasify it.
            //
            jtk = _JtkGetNext(pstmIn, &uch);
                
#ifdef DEBUG
            // Save the previous state for debugging purposes, only.
            //
            tstPrev = tstCurr;
#endif
            // Transition -- note that order is different than
            // "normal" transition tables.
            //
            tstCurr = _rgchNextState[jtk][tstCurr];
        
            } while (!IsFinal(tstCurr));
        
        switch (tstCurr)
            {
            case JS0:           // JIS-Roman
            case JS1:           // Half-Width Katakana
            case JS2:           // JIS C 6226-1978
            case JS3:           // JIS X 0208-1983
            case JS4:           // JIS X 0208-1990
            case JS5:           // JIS X 0212-1990
                *lpicet = icetIso2022Jp;
                cceRet = cceSuccess;
                goto _LRet;
            case CS0:           // GB 1988-89 Roman
            case CS1:           // GB 2312-80
                *lpicet = icetIso2022Cn;
                cceRet = cceSuccess;
                goto _LRet;
            case TS0:           // CNS 11643-1992 Plane 1
            case TS1:           // CNS 11643-1992 Plane 2
            case TS2:           // CNS 11643-1992 Plane 3
            case TS3:           // CNS 11643-1992 Plane 4
            case TS4:           // CNS 11643-1992 Plane 5
            case TS5:           // CNS 11643-1992 Plane 6
            case TS6:           // CNS 11643-1992 Plane 7
                *lpicet = icetIso2022Tw;
                cceRet = cceSuccess;
                goto _LRet;
            case KS0:           // KS C 5601-1992
            case KSD:           // ISO-2022-KR Document Signal
                *lpicet = icetIso2022Kr;
                cceRet = cceSuccess;
                goto _LRet;
            case ASC:           // Ascii
            case LSO:
            case LSI:
            case TXT:
            case EXT:
            case FIN:
                // Insufficient information to choose a flavor ...
                cceRet = cceMayBeAscii;
                goto _LRet;
            case ERR:
                cceRet = cceRead;
                goto _LRet;
            default:            // UNK, EOI
                cceRet = cceUnknownInput;
                goto _LRet;
            }
        }
        
_LRet:

    return cceRet;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\mlang\kscobj.h ===
#include "convbase.h"

class CInccKscIn : public CINetCodeConverter
{
private:
    BOOL (CInccKscIn::*m_pfnConv)(UCHAR tc);
    BOOL (CInccKscIn::*m_pfnCleanUp)();
    BOOL m_fShift;
    BOOL m_fKorea;
    BOOL m_fLeadByte;
    UINT m_nESCBytes;                               /* # bytes of ESC sequence */

public:
    CInccKscIn(UINT uCodePage, int nCodeSet);
    ~CInccKscIn() {}
    virtual HRESULT ConvertChar(UCHAR tc, int cchSrc=-1);
    virtual BOOL CleanUp();
    virtual int GetUnconvertBytes();
    virtual DWORD GetConvertMode();
    virtual void SetConvertMode(DWORD mode);

private:
    void Reset();
    BOOL ConvMain(UCHAR tc);
    BOOL CleanUpMain();
    BOOL ConvEsc(UCHAR tc);
    BOOL CleanUpEsc();
    BOOL ConvIsoIn(UCHAR tc);
    BOOL CleanUpIsoIn();
    BOOL ConvIsoInKr(UCHAR tc);
    BOOL CleanUpIsoInKr();
};

class CInccKscOut : public CINetCodeConverter
{
private:
    BOOL    m_fDoubleByte;
    BYTE    m_tcLeadByte;
    DWORD   _dwFlag;
    BOOL    m_fShift;
    BOOL    m_fKorea;
    WCHAR  *_lpFallBack;

public:
    CInccKscOut(UINT uCodePage, int nCodeSet, DWORD dwFlag, WCHAR *lpFallBack);
    ~CInccKscOut() {}
    virtual HRESULT ConvertChar(UCHAR tc, int cchSrc=-1);
    virtual BOOL CleanUp();
    virtual int GetUnconvertBytes();
    virtual DWORD GetConvertMode();
    virtual void SetConvertMode(DWORD mode);
private:
    void Reset();
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\mlang\jisobj.h ===
#include "convbase.h"

enum KANA_MODE
{
    FULL_MODE    = 0,
    ESC_MODE     = 1,
    SIO_MODE     = 2,
};

enum JIS_ESC_STATE
{
    JIS_ASCII    = 0,
    JIS_Roman    = 1,
    JIS_Kana     = 2,
    JIS_DoubleByte = 3,
};

class CInccJisIn : public CINetCodeConverter
{
private:
    BOOL (CInccJisIn::*m_pfnConv)(UCHAR tc);        
    BOOL (CInccJisIn::*m_pfnCleanUp)();
    BOOL m_fShift;                                  /* Shift in/out control */
    BOOL m_fJapan;                                  /* IN_JP OUT_JP control */
    BOOL m_fLeadByte;                               /* Shift in and lead byte flag */
    UCHAR m_tcLeadByte;                             /* perserve the last lead byte */
    UINT m_nESCBytes;                               /* # bytes of ESC sequence */
    JIS_ESC_STATE m_eEscState;                      /* State of ESC sequence */

public:
    CInccJisIn(UINT uCodePage, int nCodeSet);
    ~CInccJisIn() {}
    virtual HRESULT ConvertChar(UCHAR tc, int cchSrc=-1);
    virtual BOOL CleanUp();
    virtual int GetUnconvertBytes();
    virtual DWORD GetConvertMode();
    virtual void SetConvertMode(DWORD mode);

private:
    void Reset();
    BOOL ConvMain(UCHAR tc);
    BOOL CleanUpMain();
    BOOL ConvEsc(UCHAR tc);
    BOOL CleanUpEsc();
    BOOL ConvIsoIn(UCHAR tc);
    BOOL CleanUpIsoIn();
    BOOL ConvIsoInJp(UCHAR tc);
    BOOL CleanUpIsoInJp();
    BOOL ConvIsoOut(UCHAR tc);
    BOOL CleanUpIsoOut();
    BOOL ConvStar(UCHAR tc);
    BOOL CleanUpStar();
    BOOL ConvDoubleByte(UCHAR tc);
    BOOL CleanUpDoubleByte();
};

class CInccJisOut : public CINetCodeConverter
{
private:
    BOOL m_fDoubleByte;
    UCHAR m_tcLeadByte;     // use for DBCS lead byte
    UCHAR m_tcPrevByte;     // use for half width kana as a saved previous byte

    BOOL m_fKana;
    BOOL m_fJapan;
    BOOL m_fSaveByte;
    DWORD  m_dwFlag;
    WCHAR  *m_lpFallBack;

    KANA_MODE m_eKanaMode ;  // half width kana convert method

public:
    CInccJisOut(UINT uCodePage, int nCodeSet, DWORD dwFlag, WCHAR *lpFallBack);
    ~CInccJisOut() {}
    virtual HRESULT ConvertChar(UCHAR tc, int cchSrc=-1);
    virtual BOOL CleanUp();
    virtual int GetUnconvertBytes();
    virtual DWORD GetConvertMode();
    virtual void SetConvertMode(DWORD mode);
    void SetKanaMode(UINT uCodePage);
private:
    void Reset();
    HRESULT ConvFullWidthKana(UCHAR tc);
    BOOL KanaCleanUp();
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\mlang\lexint_.h ===
/*----------------------------------------------------------------------------
    %%File: lexint_.h
    %%Unit: fechmap
    %%Contact: jpick

    Header file for internal FarEast lexer modules.
----------------------------------------------------------------------------*/

#ifndef LEXINT__H
#define LEXINT__H

#include <windows.h>
#include <stdio.h>
#include <stddef.h>


// REVIEW:  other common internal lexer defs go here.
//

// Token type
//
typedef unsigned char JTK;

// Two-Byte Character Mode Mask
//
#define grfTwoByte      (JTK) 0x80

// Longest *character* sequence (not escape sequence -- this
// is the length of the longest multi-byte character).
//
#define cchSeqMax       4

// Prototypes/Defines for the format validation module
//
#define grfValidateCharMapping      0x0001
#define grfCountCommonChars         0x0002

void ValidateInit(ICET icetIn, DWORD dwFlags);
void ValidateInitAll(DWORD dwFlags);
void ValidateReset(ICET icetIn);
void ValidateResetAll(void);
int  NValidateUch(ICET icetIn, UCHAR uch, BOOL fEoi);
BOOL FValidateCharCount(ICET icetIn, int *lpcMatch);

#endif     // #ifndef LEXINT__H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\mlang\lcdetect.h ===
/*
 * Automatic language and codepage detection
 * 
 * Bob Powell, 2/97
 * Copyright (C) 1996, 1997, Microsoft Corp.  All rights reserved.
 */

#if !defined( __LCDETECT_H__ )
#define __LCDETECT_H__

typedef struct LCDScore {
    UINT nLangID;           // Win32 primary language ID
    UINT nCodePage;         // Win32 code page (valid for SBCS input only!)
    int nDocPercent;        // % of doc in this language, 0-100
    int nConfidence;        // Relative confidence measure, approx 0-100
} LCDScore;
typedef struct LCDScore * PLCDScore;

typedef struct LCDConfigure {
    int nMin7BitScore;      // per-char score threshhold for 7-bit detection
    int nMin8BitScore;      // " " for 8-bit
    int nMinUnicodeScore;   // " " for Unicode
    int nRelativeThreshhold;// relative "" as % of the top scoring doc, 0-100
    int nDocPctThreshhold;  // min % of doc in a language to score it, 0-100
    int nChunkSize;         // # of chars to process at a time
} LCDConfigure;
typedef struct LCDConfigure *PLCDConfigure;
typedef struct LCDConfigure const *PCLCDConfigure;

// Pass in rough body text in pStr, length nChars
// Pass in preallocated LCDScore array in paScores, array size in *pnScores.
// On return, *pnScores is set to number of elements containing result data.
//
// If pLCDC is NULL, the default configuration is used.
// To detect with a custom configuration, call LCD_GetConfig() to fill in
// a copy of an LCDConfigure, and then pas it to LCD_Detect().

extern "C" DWORD WINAPI LCD_Detect (LPCSTR pStr, int nChars, 
                            PLCDScore paScores, int *pnScores,
                            PCLCDConfigure pLCDC);

extern "C" DWORD WINAPI LCD_DetectW (LPCWSTR pwStr, int nChars,
                            PLCDScore paScores, int *pnScores,
                            PCLCDConfigure pLCDC);

extern "C" void WINAPI LCD_GetConfig (PLCDConfigure pLCDC);

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\mlang\mimedb.cpp ===
#include "private.h"

// Table pre-sorted by charset for binary search !!!
const MIMECHARSET MimeCharSet[] =
{
//  { Charset, CodePage, InternetEncoding, Flags }
    { L"_autodetect", 50932, 50932, MIMECONTF_MIME_LATEST | MIMECONTF_MIME_IE4 },
    { L"_autodetect_all", 50001, 50001, MIMECONTF_MIME_LATEST},
    { L"_autodetect_kr", 50949, 50949, MIMECONTF_MIME_LATEST| MIMECONTF_MIME_IE4 },
    { L"_iso-2022-jp$ESC", 932, 50221, MIMECONTF_MIME_IE4 },
    { L"_iso-2022-jp$SIO", 932, 50222, MIMECONTF_MIME_IE4 },
    { L"437", 1252, 437, MIMECONTF_MIME_LATEST},
    { L"ANSI_X3.4-1968", 1252, 20127, MIMECONTF_MIME_LATEST},
    { L"ANSI_X3.4-1968", 1252, 1252, MIMECONTF_MIME_IE4},
    { L"ANSI_X3.4-1986", 1252, 20127, MIMECONTF_MIME_LATEST},
    { L"ANSI_X3.4-1986", 1252, 1252, MIMECONTF_MIME_IE4},
    { L"arabic", 1256, 28596, MIMECONTF_MIME_LATEST},
    { L"arabic", 1256, 1256, MIMECONTF_MIME_IE4},
    { L"ascii", 1252, 20127, MIMECONTF_MIME_LATEST},
    { L"ascii", 1252, 1252, MIMECONTF_MIME_IE4},
    { L"ASMO-708", 1256, 708, MIMECONTF_MIME_LATEST| MIMECONTF_MIME_IE4},
    { L"Big5", 950, 950, MIMECONTF_MIME_LATEST | MIMECONTF_MIME_IE4 },
    { L"Big5-HKSCS", 950, 950, MIMECONTF_MIME_LATEST},
    { L"CCSID00858", 1252, 858, MIMECONTF_MIME_LATEST },
    { L"CCSID00924", 1252, 20924, MIMECONTF_MIME_LATEST },
    { L"CCSID01140", 1252, 1140, MIMECONTF_MIME_LATEST },
    { L"CCSID01141", 1252, 1141, MIMECONTF_MIME_LATEST },
    { L"CCSID01142", 1252, 1142, MIMECONTF_MIME_LATEST },
 